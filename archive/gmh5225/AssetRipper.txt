Project Path: arc_gmh5225_AssetRipper_j6rjlzlz

Source Tree:

```txt
arc_gmh5225_AssetRipper_j6rjlzlz
├── AssetRipper.FileAnalyzer
│   ├── Analyzer.cs
│   ├── AssetRipper.FileAnalyzer.csproj
│   ├── BuildType.cs
│   ├── BundleFile.cs
│   ├── CommonString.cs
│   ├── FileIdentifier.cs
│   ├── IO
│   │   ├── FileReader.cs
│   │   └── FileType.cs
│   ├── LocalSerializedObjectIdentifier.cs
│   ├── ObjectInfo.cs
│   ├── Program.cs
│   ├── README.md
│   ├── SerializedFile.cs
│   ├── SerializedFileFormatVersion.cs
│   ├── SerializedFileHeader.cs
│   ├── SerializedType.cs
│   ├── StreamFile.cs
│   └── WebFile.cs
├── AssetRipper.Fundamentals
│   ├── AssetRipper.Fundamentals.csproj
│   ├── BuildInfo.cs
│   ├── ClassIDType.cs
│   ├── Classes
│   │   ├── Font
│   │   │   ├── FontRenderingMode.cs
│   │   │   └── FontStyle.cs
│   │   ├── GUIText
│   │   │   ├── TextAlignment.cs
│   │   │   └── TextAnchor.cs
│   │   ├── Meta
│   │   │   ├── Meta.cs
│   │   │   └── MetaPtr.cs
│   │   ├── Misc
│   │   │   ├── BoneWeights4.cs
│   │   │   ├── Bones
│   │   │   │   ├── ArmType.cs
│   │   │   │   ├── BoneType.cs
│   │   │   │   ├── FingerDoFType.cs
│   │   │   │   ├── FingerType.cs
│   │   │   │   ├── HumanBodyBones.cs
│   │   │   │   ├── LimbType.cs
│   │   │   │   ├── MuscleType.cs
│   │   │   │   ├── PhalangeType.cs
│   │   │   │   └── TDoFBoneType.cs
│   │   │   ├── BuildTargetGroup.cs
│   │   │   ├── Float.cs
│   │   │   ├── Hash128.cs
│   │   │   ├── KeyframeTpl
│   │   │   │   ├── KeyframeTpl.cs
│   │   │   │   ├── TangentMode
│   │   │   │   │   ├── TangentMode.cs
│   │   │   │   │   ├── TangentMode2.cs
│   │   │   │   │   └── TangentMode5.cs
│   │   │   │   └── WeightedMode.cs
│   │   │   ├── OffsetPtr.cs
│   │   │   ├── PPtr.cs
│   │   │   ├── Serializable
│   │   │   │   ├── AnimationCurveTpl
│   │   │   │   │   ├── AnimationCurveTpl.cs
│   │   │   │   │   ├── CurveLoopTypes.cs
│   │   │   │   │   └── RotationOrder.cs
│   │   │   │   ├── Boundaries
│   │   │   │   │   ├── AABB.cs
│   │   │   │   │   ├── AABBi.cs
│   │   │   │   │   ├── IAABB.cs
│   │   │   │   │   ├── IAABBi.cs
│   │   │   │   │   ├── IMinMaxAABB.cs
│   │   │   │   │   └── MinMaxAABB.cs
│   │   │   │   ├── GUIStyle
│   │   │   │   │   ├── GUIStyle.cs
│   │   │   │   │   ├── GUIStyleState.cs
│   │   │   │   │   ├── ImagePosition.cs
│   │   │   │   │   └── TextClipping.cs
│   │   │   │   ├── Gradient
│   │   │   │   │   ├── Gradient.cs
│   │   │   │   │   └── GradientMode.cs
│   │   │   │   ├── LayerMask.cs
│   │   │   │   ├── PropertyName.cs
│   │   │   │   └── RectOffset.cs
│   │   │   └── UnityGUID.cs
│   │   ├── Object
│   │   │   └── HideFlags.cs
│   │   ├── UnknownObject.cs
│   │   ├── UnreadableObject.cs
│   │   └── Utf8StringBase.cs
│   ├── Configuration
│   │   ├── BundledAssetsExportMode.cs
│   │   ├── CoreConfiguration.cs
│   │   ├── ScriptContentLevel.cs
│   │   └── StreamingAssetsMode.cs
│   ├── Converters
│   │   └── Files
│   │       ├── SerializedFileMetadataConverter.cs
│   │       └── SerializedTypeConverter.cs
│   ├── Equality
│   │   ├── ArrayEquality.cs
│   │   ├── IAlmostEquatable.cs
│   │   └── NearEquality.cs
│   ├── Extensions
│   │   ├── ArrayExtensions.cs
│   │   ├── BitArrayExtensions.cs
│   │   ├── ByteArrayExtensions.cs
│   │   ├── IDictionaryExtensions.cs
│   │   ├── IEnumerableExtensions.cs
│   │   ├── IReadOnlyListExtensions.cs
│   │   ├── StreamExtensions.cs
│   │   └── TextWriterExtensions.cs
│   ├── GlobalUsings.cs
│   ├── IO
│   │   ├── AccessDictionary.cs
│   │   ├── AccessDictionaryBase.cs
│   │   ├── AccessList.cs
│   │   ├── AccessListBase.cs
│   │   ├── AdjustableStream.cs
│   │   ├── Asset
│   │   │   ├── AssetReader.cs
│   │   │   ├── AssetWriter.cs
│   │   │   ├── IAsset.cs
│   │   │   ├── IAssetReadable.cs
│   │   │   ├── IAssetWritable.cs
│   │   │   ├── IYamlExportable.cs
│   │   │   └── TransferInstructionFlags.cs
│   │   ├── AssetDictionary.cs
│   │   ├── AssetDictionaryExtensions.cs
│   │   ├── AssetList.cs
│   │   ├── Extensions
│   │   │   ├── ArrayWriteAssetExtensions.cs
│   │   │   ├── ArrayWriteEndianExtensions.cs
│   │   │   ├── AssetReaderExtensions.cs
│   │   │   ├── AssetWriterExtensions.cs
│   │   │   ├── BinaryReaderExtensions.cs
│   │   │   ├── BinaryWriterExtensions.cs
│   │   │   ├── EndianReaderExtensions.cs
│   │   │   ├── EndianWriterExtensions.cs
│   │   │   ├── IDictionaryReadAssetExtensions.cs
│   │   │   ├── IDictionaryReadEndianExtensions.cs
│   │   │   ├── IDictionaryWriteAssetExtensions.cs
│   │   │   ├── IDictionaryWriteEndianExtensions.cs
│   │   │   ├── StreamExtensions.cs
│   │   │   ├── YamlArrayExtensions.cs
│   │   │   ├── YamlDictionaryExtensions.cs
│   │   │   ├── YamlEnumerableExtensions.cs
│   │   │   └── YamlSerializedVersionExtensions.cs
│   │   ├── InvariantStreamWriter.cs
│   │   ├── MultiFile
│   │   │   ├── MultiFileStream.cs
│   │   │   └── SplitNameComparer.cs
│   │   ├── NullableKeyValuePair.cs
│   │   ├── PartialStream.cs
│   │   ├── ReverseStream.cs
│   │   └── Smart
│   │       ├── SmartStream.cs
│   │       └── SmartStreamType.cs
│   ├── Interfaces
│   │   ├── IHasRawData.cs
│   │   ├── IHasStringName.cs
│   │   ├── IMonoBehaviourBase.cs
│   │   ├── ITypeTreeSerializable.cs
│   │   ├── IUnityAssetBase.cs
│   │   └── IUnityObjectBase.cs
│   ├── Layout
│   │   ├── ClassNameHandler.cs
│   │   └── LayoutInfo.cs
│   ├── Logging
│   │   ├── ConsoleLogger.cs
│   │   ├── FileLogger.cs
│   │   ├── ILogger.cs
│   │   ├── LogCategory.cs
│   │   ├── LogType.cs
│   │   └── Logger.cs
│   ├── Math
│   │   ├── Colors
│   │   │   ├── ColorRGBA32.cs
│   │   │   ├── ColorRGBAf.cs
│   │   │   ├── IColorRGBA32.cs
│   │   │   └── IColorRGBAf.cs
│   │   ├── IMatrix4x4f.cs
│   │   ├── IRectf.cs
│   │   ├── Matrix4x4f.cs
│   │   ├── PackedBitVectors
│   │   │   ├── IPackedFloatVector.cs
│   │   │   ├── IPackedIntVector.cs
│   │   │   ├── IPackedQuatVector.cs
│   │   │   ├── PackedFloatVector.cs
│   │   │   ├── PackedIntVector.cs
│   │   │   └── PackedQuatVector.cs
│   │   ├── Rectf.cs
│   │   └── Vectors
│   │       ├── GeometricMath.cs
│   │       ├── IQuaternionf.cs
│   │       ├── IVector2f.cs
│   │       ├── IVector2i.cs
│   │       ├── IVector3f.cs
│   │       ├── IVector3i.cs
│   │       ├── IVector4f.cs
│   │       ├── Quaternionf.cs
│   │       ├── Vector2f.cs
│   │       ├── Vector2i.cs
│   │       ├── Vector3f.cs
│   │       ├── Vector3i.cs
│   │       └── Vector4f.cs
│   ├── Parser
│   │   ├── Asset
│   │   │   ├── AssetFactoryBase.cs
│   │   │   ├── AssetInfo.DummySerializedFile.cs
│   │   │   ├── AssetInfo.cs
│   │   │   ├── AssetType.cs
│   │   │   ├── DependencyContext.cs
│   │   │   ├── IAssetContainer.cs
│   │   │   ├── IAssetContainerExtensions.cs
│   │   │   └── IDependent.cs
│   │   ├── Files
│   │   │   ├── ArchiveFiles
│   │   │   │   ├── ArchiveFile.cs
│   │   │   │   ├── ArchiveFileEntry.cs
│   │   │   │   ├── ArchiveFileScheme.cs
│   │   │   │   ├── ArchiveHeader.cs
│   │   │   │   └── ArchiveType.cs
│   │   │   ├── BuildTarget.cs
│   │   │   ├── BundleFile
│   │   │   │   ├── BundleFile.cs
│   │   │   │   ├── BundleFileScheme.cs
│   │   │   │   ├── BundleType.cs
│   │   │   │   ├── BundleVersion.cs
│   │   │   │   ├── CompressionType.cs
│   │   │   │   ├── Header
│   │   │   │   │   ├── BundleFileStreamHeader.cs
│   │   │   │   │   ├── BundleHeader.cs
│   │   │   │   │   └── BundleRawWebHeader.cs
│   │   │   │   ├── IO
│   │   │   │   │   ├── BundleFileBlockReader.cs
│   │   │   │   │   ├── BundleReader.cs
│   │   │   │   │   └── IBundleReadable.cs
│   │   │   │   ├── Parser
│   │   │   │   │   ├── BlocksInfo.cs
│   │   │   │   │   ├── BundleFlags.cs
│   │   │   │   │   ├── BundleMetadata.cs
│   │   │   │   │   ├── BundleScene.cs
│   │   │   │   │   ├── DirectoryInfo.cs
│   │   │   │   │   ├── Node.cs
│   │   │   │   │   ├── StorageBlock.cs
│   │   │   │   │   └── StorageBlockFlags.cs
│   │   │   │   └── SevenZipHelper.cs
│   │   │   ├── Entries
│   │   │   │   ├── FileEntry.cs
│   │   │   │   ├── FileEntryType.cs
│   │   │   │   └── FileList.cs
│   │   │   ├── ResourceFiles
│   │   │   │   ├── IResourceFile.cs
│   │   │   │   ├── ResourceFile.cs
│   │   │   │   └── ResourceFileScheme.cs
│   │   │   ├── Schemes
│   │   │   │   ├── FileScheme.cs
│   │   │   │   └── FileSchemeList.cs
│   │   │   ├── SerializedFiles
│   │   │   │   ├── FormatVersion.cs
│   │   │   │   ├── IO
│   │   │   │   │   ├── ISerializedReadable.cs
│   │   │   │   │   ├── ISerializedWritable.cs
│   │   │   │   │   ├── SerializedReader.cs
│   │   │   │   │   └── SerializedWriter.cs
│   │   │   │   ├── ISerializedFile.cs
│   │   │   │   ├── Parser
│   │   │   │   │   ├── FileIdentifier.cs
│   │   │   │   │   ├── LocalSerializedObjectIdentifier.cs
│   │   │   │   │   ├── ObjectInfo.cs
│   │   │   │   │   ├── SerializedFileHeader.cs
│   │   │   │   │   ├── SerializedFileMetadata.cs
│   │   │   │   │   ├── SerializedType.cs
│   │   │   │   │   ├── SerializedTypeBase.cs
│   │   │   │   │   ├── SerializedTypeReference.cs
│   │   │   │   │   ├── TransferMetaFlags.cs
│   │   │   │   │   └── TypeTree
│   │   │   │   │       ├── CommonString.cs
│   │   │   │   │       ├── TypeTree.cs
│   │   │   │   │       └── TypeTreeNode.cs
│   │   │   │   ├── SerializedFile.cs
│   │   │   │   ├── SerializedFileException.cs
│   │   │   │   ├── SerializedFileScheme.cs
│   │   │   │   └── VirtualSerializedFile.cs
│   │   │   └── WebFiles
│   │   │       ├── WebFile.cs
│   │   │       ├── WebFileEntry.cs
│   │   │       ├── WebFileScheme.cs
│   │   │       ├── WebHeader.cs
│   │   │       └── WebMetadata.cs
│   │   └── Utils
│   │       └── FilenameUtils.cs
│   ├── Project
│   │   ├── Collections
│   │   │   └── IExportCollection.cs
│   │   ├── ExportIdHandler.cs
│   │   ├── IExportContainer.cs
│   │   └── IProjectAssetContainer.cs
│   ├── Structure
│   │   ├── Assembly
│   │   │   ├── Managers
│   │   │   │   ├── BaseManager.cs
│   │   │   │   ├── IAssemblyManager.cs
│   │   │   │   ├── IL2CppManager.cs
│   │   │   │   └── MonoManager.cs
│   │   │   ├── Mono
│   │   │   │   ├── ElementType.cs
│   │   │   │   ├── Extensions
│   │   │   │   │   ├── MetadataResolverExtensions.cs
│   │   │   │   │   ├── MethodDefinitionExtensions.cs
│   │   │   │   │   └── TypeReferenceExtensions.cs
│   │   │   │   ├── MonoFieldContext.cs
│   │   │   │   ├── MonoType.cs
│   │   │   │   ├── MonoTypeContext.cs
│   │   │   │   └── MonoUtils.cs
│   │   │   ├── PrimitiveType.cs
│   │   │   ├── ScriptIdentifier.cs
│   │   │   ├── ScriptingBackend.cs
│   │   │   └── Serializable
│   │   │       ├── SerializableField.cs
│   │   │       ├── SerializablePointer.cs
│   │   │       ├── SerializableStructure.cs
│   │   │       └── SerializableType.cs
│   │   ├── GameCollection.cs
│   │   ├── GameStructure
│   │   │   ├── GameProcessorContext.cs
│   │   │   ├── GameStructureProcessor.cs
│   │   │   ├── Platforms
│   │   │   │   ├── AndroidGameStructure.cs
│   │   │   │   ├── LinuxGameStructure.cs
│   │   │   │   ├── MacGameStructure.cs
│   │   │   │   ├── MixedGameStructure.cs
│   │   │   │   ├── PCGameStructure.cs
│   │   │   │   ├── PS4GameStructure.cs
│   │   │   │   ├── PlatformChecker.cs
│   │   │   │   ├── PlatformGameStructure.cs
│   │   │   │   ├── SwitchGameStructure.cs
│   │   │   │   ├── WebGLGameStructure.cs
│   │   │   │   ├── WebPlayerGameStructure.cs
│   │   │   │   ├── WiiUGameStructure.cs
│   │   │   │   └── iOSGameStructure.cs
│   │   │   └── Preprocessor.cs
│   │   ├── IFileCollection.cs
│   │   └── SchemeReader.cs
│   ├── TaskManager.cs
│   ├── UnityAssetBase.cs
│   ├── UnityObjectBase.cs
│   ├── Utils
│   │   ├── ArrayUtils.cs
│   │   ├── CrcUtils.cs
│   │   ├── DirectoryUtils.cs
│   │   ├── ExecutingDirectory.cs
│   │   ├── FileUtils.cs
│   │   ├── HashUtils.cs
│   │   ├── MD4.cs
│   │   ├── ObjectUtils.cs
│   │   ├── TempFolderManager.cs
│   │   └── ThreadSafeRandom.cs
│   └── VersionHandling
│       └── VersionManager.cs
├── AssetRipper.IO.Endian
│   ├── AssetRipper.IO.Endian.csproj
│   ├── EndianReader.cs
│   ├── EndianType.cs
│   ├── EndianWriter.cs
│   ├── IEndianReadable.cs
│   └── IEndianWritable.cs
├── AssetRipper.IO.Files
│   ├── ArchiveFiles
│   │   ├── ArchiveFile.cs
│   │   ├── ArchiveFileEntry.cs
│   │   ├── ArchiveFileScheme.cs
│   │   ├── ArchiveHeader.cs
│   │   └── ArchiveType.cs
│   ├── AssetRipper.IO.Files.csproj
│   ├── AssetType.cs
│   ├── BuildTarget.cs
│   ├── BundleFiles
│   │   ├── BundleFile.cs
│   │   ├── BundleFileScheme.cs
│   │   ├── BundleType.cs
│   │   ├── BundleVersion.cs
│   │   ├── CompressionType.cs
│   │   ├── Header
│   │   │   ├── BundleFileStreamHeader.cs
│   │   │   ├── BundleHeader.cs
│   │   │   └── BundleRawWebHeader.cs
│   │   ├── IO
│   │   │   ├── BundleFileBlockReader.cs
│   │   │   ├── BundleReader.cs
│   │   │   └── IBundleReadable.cs
│   │   ├── Parser
│   │   │   ├── BlocksInfo.cs
│   │   │   ├── BundleFlags.cs
│   │   │   ├── BundleMetadata.cs
│   │   │   ├── BundleScene.cs
│   │   │   ├── DirectoryInfo.cs
│   │   │   ├── Node.cs
│   │   │   ├── StorageBlock.cs
│   │   │   └── StorageBlockFlags.cs
│   │   └── SevenZipHelper.cs
│   ├── Converters
│   │   ├── SerializedFileMetadataConverter.cs
│   │   └── SerializedTypeConverter.cs
│   ├── Entries
│   │   ├── FileEntry.cs
│   │   ├── FileEntryType.cs
│   │   └── FileList.cs
│   ├── Extensions
│   │   └── StreamExtensions.cs
│   ├── GlobalUsings.cs
│   ├── ResourceFiles
│   │   ├── IResourceFile.cs
│   │   ├── ResourceFile.cs
│   │   └── ResourceFileScheme.cs
│   ├── SchemeReader.cs
│   ├── Schemes
│   │   ├── FileScheme.cs
│   │   └── FileSchemeList.cs
│   ├── SerializedFiles
│   │   ├── FormatVersion.cs
│   │   ├── IO
│   │   │   ├── ISerializedReadable.cs
│   │   │   ├── ISerializedWritable.cs
│   │   │   ├── SerializedReader.cs
│   │   │   └── SerializedWriter.cs
│   │   ├── Parser
│   │   │   ├── FileIdentifier.cs
│   │   │   ├── LocalSerializedObjectIdentifier.cs
│   │   │   ├── ObjectInfo.cs
│   │   │   ├── SerializedFileHeader.cs
│   │   │   ├── SerializedFileMetadata.cs
│   │   │   ├── SerializedType.cs
│   │   │   ├── SerializedTypeBase.cs
│   │   │   ├── SerializedTypeReference.cs
│   │   │   ├── TransferMetaFlags.cs
│   │   │   └── TypeTrees
│   │   │       ├── CommonString.cs
│   │   │       ├── TypeTree.cs
│   │   │       └── TypeTreeNode.cs
│   │   ├── SerializedFile.cs
│   │   ├── SerializedFileException.cs
│   │   └── SerializedFileScheme.cs
│   ├── Streams
│   │   ├── MultiFile
│   │   │   ├── MultiFileStream.cs
│   │   │   └── SplitNameComparer.cs
│   │   └── Smart
│   │       ├── SmartStream.cs
│   │       └── SmartStreamType.cs
│   ├── Utils
│   │   └── FilenameUtils.cs
│   └── WebFiles
│       ├── WebFile.cs
│       ├── WebFileEntry.cs
│       ├── WebFileScheme.cs
│       ├── WebHeader.cs
│       └── WebMetadata.cs
├── AssetRipper.SerializationLogic
│   ├── AsmUtils.cs
│   ├── AssetRipper.SerializationLogic.csproj
│   ├── EngineTypePredicates.cs
│   ├── Extensions
│   │   ├── MethodDefinitionExtensions.cs
│   │   ├── ResolutionExtensions.cs
│   │   ├── TypeDefinitionExtensions.cs
│   │   └── TypeDescriptorExtensions.cs
│   ├── FieldSerializationLogic.cs
│   ├── ResolutionException.cs
│   └── TypeDefinitionConverter.cs
├── AssetRipper.SystemTester
│   ├── AssetRipper.SystemTester.csproj
│   ├── Program.cs
│   └── README.md
├── AssetRipper.Tests
│   ├── AssetRipper.Tests.csproj
│   ├── GuidTests.cs
│   ├── NearEqualityTests.cs
│   ├── PackedBitVectorTests
│   │   ├── FloatVectorTests.cs
│   │   ├── IntVectorTests.cs
│   │   └── QuatVectorTests.cs
│   └── QuaternionTests.cs
├── AssetRipper.Yaml
│   ├── AssetRipper.Yaml.csproj
│   ├── Emitter.cs
│   ├── Extensions
│   │   ├── EmitterExtensions.cs
│   │   ├── PrimitiveExtensions.cs
│   │   ├── StringBuilderExtensions.cs
│   │   ├── YamlArrayExtensions.cs
│   │   ├── YamlDictionaryExtensions.cs
│   │   ├── YamlEnumerableExtensions.cs
│   │   └── YamlListExtensions.cs
│   ├── MappingStyle.cs
│   ├── MetaType.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── ScalarStyle.cs
│   ├── ScalarType.cs
│   ├── SequenceStyle.cs
│   ├── YAMLDocument.cs
│   ├── YAMLMappingNode.cs
│   ├── YAMLNode.cs
│   ├── YAMLNodeType.cs
│   ├── YAMLScalarNode.cs
│   ├── YAMLSequenceNode.cs
│   ├── YAMLTag.cs
│   └── YAMLWriter.cs
├── AssetRipper.Yaml.Tests
│   ├── AssetRipper.Yaml.Tests.csproj
│   ├── FlowMappingTests.cs
│   └── MemoryTextWriter.cs
├── AssetRipper.sln
├── AssetRipper.sln.DotSettings
├── AssetRipperCommon
│   ├── AssetRipperCommon.csproj
│   ├── Classes
│   │   ├── Animation
│   │   │   └── AnimationCullingType.cs
│   │   ├── AnimationClip
│   │   │   ├── AnimationType.cs
│   │   │   ├── GenericBinding
│   │   │   │   ├── BindingCustomType.cs
│   │   │   │   └── TransformType.cs
│   │   │   ├── HumanoidMuscleType.cs
│   │   │   └── WrapMode.cs
│   │   ├── Animator
│   │   │   ├── AnimatorCullingMode.cs
│   │   │   └── AnimatorUpdateMode.cs
│   │   ├── AnimatorController
│   │   │   ├── Constants
│   │   │   │   ├── IBlend1dDataConstant.cs
│   │   │   │   └── TransitionInterruptionSource.cs
│   │   │   └── Editor
│   │   │       ├── AnimatorControllerLayer
│   │   │       │   └── AnimatorLayerBlendingMode.cs
│   │   │       └── AnimatorControllerParameter
│   │   │           └── AnimatorControllerParameterType.cs
│   │   ├── AnimatorTransition
│   │   │   └── AnimatorConditionMode.cs
│   │   ├── AudioClip
│   │   │   ├── AudioClipLoadType.cs
│   │   │   ├── AudioCompressionFormat.cs
│   │   │   ├── AudioType.cs
│   │   │   ├── FMODSoundFormat.cs
│   │   │   └── FMODSoundType.cs
│   │   ├── AudioManager
│   │   │   └── AudioSpeakerMode.cs
│   │   ├── AudioReverbFilter
│   │   │   └── AudioReverbPreset.cs
│   │   ├── AudioSource
│   │   │   └── AudioRolloffMode.cs
│   │   ├── Avatar
│   │   │   └── BodyDoF.cs
│   │   ├── BlendTree
│   │   │   └── BlendTreeType.cs
│   │   ├── Camera
│   │   │   ├── FieldOfViewAxis.cs
│   │   │   ├── GateFitMode.cs
│   │   │   ├── ProjectionMatrixMode.cs
│   │   │   ├── RenderingPath.cs
│   │   │   └── StereoTargetEyeMask.cs
│   │   ├── CapsuleCollider2D
│   │   │   └── CapsuleDirection2D.cs
│   │   ├── ClusterInputManager
│   │   │   └── ClusterInputType.cs
│   │   ├── CompositeCollider2D
│   │   │   ├── GenerationType.cs
│   │   │   └── GeometryType.cs
│   │   ├── EditorSettings
│   │   │   ├── AssetPipelineMode.cs
│   │   │   ├── CacheServerMode.cs
│   │   │   ├── EditorBehaviorMode.cs
│   │   │   ├── EnterPlayModeOptions.cs
│   │   │   ├── ExternalVersionControl.cs
│   │   │   ├── LineEndingsMode.cs
│   │   │   ├── SerializationMode.cs
│   │   │   └── SpritePackerMode.cs
│   │   ├── Flare
│   │   │   └── TextureLayout.cs
│   │   ├── GameObject
│   │   │   └── IGameObject.cs
│   │   ├── GraphicsSettings
│   │   │   ├── BuiltinShaderMode.cs
│   │   │   ├── CameraHDRMode.cs
│   │   │   ├── GraphicsTier.cs
│   │   │   ├── InstancingStrippingVariant.cs
│   │   │   ├── LightmapStrippingMode.cs
│   │   │   ├── RealtimeGICPUUsage.cs
│   │   │   ├── ShaderQuality.cs
│   │   │   └── TransparencySortMode.cs
│   │   ├── IComponent.cs
│   │   ├── IEditorExtension.cs
│   │   ├── INamedObject.cs
│   │   ├── ITransform.cs
│   │   ├── InputManager
│   │   │   ├── InputAxesDirection.cs
│   │   │   ├── InputAxisType.cs
│   │   │   └── JoystickType.cs
│   │   ├── LODGroup
│   │   │   └── LODFadeMode.cs
│   │   ├── Light
│   │   │   ├── LightRenderMode.cs
│   │   │   ├── LightShadowCasterMode.cs
│   │   │   ├── LightShadows.cs
│   │   │   ├── LightShape.cs
│   │   │   ├── LightType.cs
│   │   │   ├── LightmapBakeType.cs
│   │   │   ├── LightmappingMode.cs
│   │   │   └── MixedLightingMode.cs
│   │   ├── LightmapSettings
│   │   │   ├── DenoiserType.cs
│   │   │   ├── FilterMode.cs
│   │   │   ├── FilterType.cs
│   │   │   ├── GISettings
│   │   │   │   └── EnvironmentAmbientMode.cs
│   │   │   ├── GIWorkflowMode.cs
│   │   │   ├── Lightmapper.cs
│   │   │   ├── LightmapsMode.cs
│   │   │   ├── ReflectionCubemapCompression.cs
│   │   │   └── Sampling.cs
│   │   ├── Mesh
│   │   │   ├── IChannelInfoLegacy.cs
│   │   │   ├── ICompressedMeshLegacy.cs
│   │   │   ├── IMeshBlendShapeChannelLegacy.cs
│   │   │   ├── IMeshBlendShapeLegacy.cs
│   │   │   ├── IStreamInfoLegacy.cs
│   │   │   ├── ISubMeshLegacy.cs
│   │   │   ├── IVertexDataLegacy.cs
│   │   │   ├── IndexFormat.cs
│   │   │   ├── MeshCompression.cs
│   │   │   ├── MeshHelper.cs
│   │   │   ├── MeshOptimizationFlags.cs
│   │   │   └── MeshTopology.cs
│   │   ├── MeshCollider
│   │   │   └── MeshColliderCookingOptions.cs
│   │   ├── Meta
│   │   │   └── Importers
│   │   │       └── Texture
│   │   │           ├── AndroidETC2FallbackOverride.cs
│   │   │           ├── SpriteAlignment.cs
│   │   │           ├── SpriteImportMode.cs
│   │   │           ├── TextureImporterAlphaSource.cs
│   │   │           ├── TextureImporterCompression.cs
│   │   │           ├── TextureImporterGenerateCubemap.cs
│   │   │           ├── TextureImporterMipFilter.cs
│   │   │           ├── TextureImporterNPOTScale.cs
│   │   │           ├── TextureImporterNormalFilter.cs
│   │   │           ├── TextureImporterShape.cs
│   │   │           ├── TextureImporterType.cs
│   │   │           └── TextureResizeAlgorithm.cs
│   │   ├── Misc
│   │   │   └── IStreamingInfo.cs
│   │   ├── NavMeshAgent
│   │   │   └── ObstacleAvoidanceType.cs
│   │   ├── NavMeshObstacle
│   │   │   └── NavMeshObstacleShape.cs
│   │   ├── ParticleSystem
│   │   │   ├── CollisionModule
│   │   │   │   ├── ParticleSystemCollisionMode.cs
│   │   │   │   ├── ParticleSystemCollisionQuality.cs
│   │   │   │   └── ParticleSystemCollisionType.cs
│   │   │   ├── Curve
│   │   │   │   └── ParticleSystemCurveMode.cs
│   │   │   ├── CustomDataModule
│   │   │   │   └── ParticleSystemCustomDataMode.cs
│   │   │   ├── Emission
│   │   │   │   └── EmissionType.cs
│   │   │   ├── InheritVelocity
│   │   │   │   └── InheritVelocityMode.cs
│   │   │   ├── MinMaxGradient
│   │   │   │   └── MinMaxGradientState.cs
│   │   │   ├── NoiseModule
│   │   │   │   └── ParticleSystemNoiseQuality.cs
│   │   │   ├── ParticleSystemCullingMode.cs
│   │   │   ├── ParticleSystemRingBufferMode.cs
│   │   │   ├── ParticleSystemScalingMode.cs
│   │   │   ├── ParticleSystemSimulationSpace.cs
│   │   │   ├── ParticleSystemStopAction.cs
│   │   │   ├── Shape
│   │   │   │   ├── ParticleSystemShapeMultiModeValue.cs
│   │   │   │   ├── ParticleSystemShapeType.cs
│   │   │   │   └── PlacementMode.cs
│   │   │   ├── SubEmitter
│   │   │   │   ├── ParticleSystemSubEmitterProperties.cs
│   │   │   │   └── ParticleSystemSubEmitterType.cs
│   │   │   ├── TrailModule
│   │   │   │   ├── ParticleSystemTrailMode.cs
│   │   │   │   └── ParticleSystemTrailTextureMode.cs
│   │   │   ├── Trigger
│   │   │   │   └── TriggerAction.cs
│   │   │   └── UV
│   │   │       ├── ParticleSystemAnimationMode.cs
│   │   │       ├── ParticleSystemAnimationRowMode.cs
│   │   │       ├── ParticleSystemAnimationTimeMode.cs
│   │   │       └── ParticleSystemAnimationType.cs
│   │   ├── ParticleSystemForceField
│   │   │   └── ParticleSystemForceFieldShape.cs
│   │   ├── ParticleSystemRenderer
│   │   │   ├── ParticleSystemRenderMode.cs
│   │   │   ├── ParticleSystemRenderSpace.cs
│   │   │   └── ParticleSystemSortMode.cs
│   │   ├── PhysicsManager
│   │   │   ├── BroadphaseType.cs
│   │   │   ├── ContactPairsMode.cs
│   │   │   ├── ContactsGeneration.cs
│   │   │   ├── FrictionType.cs
│   │   │   └── SolverType.cs
│   │   ├── PrefabInstance
│   │   │   └── IPrefabInstance.cs
│   │   ├── QualitySettings
│   │   │   ├── AnisotropicFiltering.cs
│   │   │   ├── AntiAliasing.cs
│   │   │   ├── QualityLevel.cs
│   │   │   ├── ShadowCascades.cs
│   │   │   ├── ShadowProjection.cs
│   │   │   ├── ShadowQuality.cs
│   │   │   ├── ShadowResolution.cs
│   │   │   ├── ShadowmaskMode.cs
│   │   │   ├── SkinWeights.cs
│   │   │   ├── TextureQuality.cs
│   │   │   └── VSyncCount.cs
│   │   ├── ReflectionProbe
│   │   │   ├── ReflectionProbeClearFlags.cs
│   │   │   ├── ReflectionProbeMode.cs
│   │   │   ├── ReflectionProbeRefreshMode.cs
│   │   │   ├── ReflectionProbeTimeSlicingMode.cs
│   │   │   └── ReflectionProbeType.cs
│   │   ├── RenderSettings
│   │   │   ├── AmbientMode.cs
│   │   │   └── FogMode.cs
│   │   ├── RenderTexture
│   │   │   └── RenderTextureFormat.cs
│   │   ├── Renderer
│   │   │   ├── EditorSelectedRenderState.cs
│   │   │   ├── LightProbeUsage.cs
│   │   │   ├── MotionVectorGenerationMode.cs
│   │   │   ├── RayTracingMode.cs
│   │   │   ├── ReceiveGI.cs
│   │   │   ├── ReflectionProbeUsage.cs
│   │   │   └── ShadowCastingMode.cs
│   │   ├── Rigidbody
│   │   │   ├── CollisionDetectionMode.cs
│   │   │   ├── RigidbodyConstraints.cs
│   │   │   └── RigidbodyInterpolation.cs
│   │   ├── Rigidbody2D
│   │   │   ├── CollisionDetectionMode2D.cs
│   │   │   ├── RigidbodyConstraints2D.cs
│   │   │   ├── RigidbodyInterpolation2D.cs
│   │   │   ├── RigidbodySleepMode2D.cs
│   │   │   └── RigidbodyType2D.cs
│   │   ├── Shader
│   │   │   ├── Enums
│   │   │   │   ├── GPUPlatform.cs
│   │   │   │   ├── GpuProgramType
│   │   │   │   │   ├── ShaderGpuProgramType.cs
│   │   │   │   │   ├── ShaderGpuProgramType53.cs
│   │   │   │   │   └── ShaderGpuProgramType55.cs
│   │   │   │   ├── ShaderChannel
│   │   │   │   │   ├── ShaderChannel.cs
│   │   │   │   │   ├── ShaderChannel2018.cs
│   │   │   │   │   ├── ShaderChannel4.cs
│   │   │   │   │   └── ShaderChannel5.cs
│   │   │   │   ├── ShaderParamType.cs
│   │   │   │   ├── ShaderType.cs
│   │   │   │   ├── VertexComponent.cs
│   │   │   │   └── VertexFormat
│   │   │   │       ├── VertexChannelFormat.cs
│   │   │   │       ├── VertexFormat.cs
│   │   │   │       ├── VertexFormat2017.cs
│   │   │   │       └── VertexFormat2019.cs
│   │   │   └── SerializedShader
│   │   │       └── Enum
│   │   │           ├── BlendMode.cs
│   │   │           ├── BlendOp.cs
│   │   │           ├── ColorWriteMask.cs
│   │   │           ├── CullMode.cs
│   │   │           ├── FogMode.cs
│   │   │           ├── SerializedPassType.cs
│   │   │           ├── SerializedPropertyFlag.cs
│   │   │           ├── SerializedPropertyType.cs
│   │   │           ├── StencilComp.cs
│   │   │           ├── StencilOp.cs
│   │   │           ├── StencilType.cs
│   │   │           ├── ZClip.cs
│   │   │           ├── ZTest.cs
│   │   │           └── ZWrite.cs
│   │   ├── ShaderVariantCollection
│   │   │   └── PassType.cs
│   │   ├── Sprite
│   │   │   ├── SpriteMeshType.cs
│   │   │   ├── SpritePackingMode.cs
│   │   │   └── SpritePackingRotation.cs
│   │   ├── SpriteRenderer
│   │   │   ├── SpriteDrawMode.cs
│   │   │   ├── SpriteMaskInteraction.cs
│   │   │   ├── SpriteSortPoint.cs
│   │   │   └── SpriteTileMode.cs
│   │   ├── TagManager
│   │   │   └── TagManagerConstants.cs
│   │   ├── Terrain
│   │   │   └── MaterialType.cs
│   │   ├── TerrainData
│   │   │   └── DetailRenderMode.cs
│   │   ├── Texture2D
│   │   │   ├── ColorSpace.cs
│   │   │   ├── FilterMode.cs
│   │   │   ├── TextureDimension.cs
│   │   │   ├── TextureFormat.cs
│   │   │   ├── TextureUsageMode.cs
│   │   │   └── TextureWrapMode.cs
│   │   ├── Texture2DArray
│   │   │   └── GraphicsFormat.cs
│   │   ├── TrailRenderer
│   │   │   ├── LineAlignment.cs
│   │   │   └── LineTextureMode.cs
│   │   └── UI
│   │       └── Canvas
│   │           └── RenderMode.cs
│   ├── Exceptions
│   │   └── UnbackedPropertyException.cs
│   ├── GlobalUsings.cs
│   ├── Parser
│   │   └── Asset
│   │       └── AssetFactory.cs
│   ├── Project
│   │   ├── Collections
│   │   │   ├── AssetExportCollection.cs
│   │   │   ├── AssetsExportCollection.cs
│   │   │   ├── BuildSettingsExportCollection.cs
│   │   │   ├── EmptyExportCollection.cs
│   │   │   ├── EngineExportCollection.cs
│   │   │   ├── ExportCollection.cs
│   │   │   ├── FailExportCollection.cs
│   │   │   ├── ManagerExportCollection.cs
│   │   │   ├── PrefabExportCollection.cs
│   │   │   ├── RawExportCollection.cs
│   │   │   ├── SceneExportCollection.cs
│   │   │   ├── SkipExportCollection.cs
│   │   │   ├── UnknownExportCollection.cs
│   │   │   └── UnreadableExportCollection.cs
│   │   ├── Exporters
│   │   │   ├── BinaryAssetExporter.cs
│   │   │   ├── BuildSettingsExporter.cs
│   │   │   ├── DefaultYamlExporter.cs
│   │   │   ├── DummyAssetExporter.cs
│   │   │   ├── Engine
│   │   │   │   ├── EngineAssetExporter.cs
│   │   │   │   ├── EngineBuiltInAsset.cs
│   │   │   │   ├── EngineBuiltInAssetInfo.cs
│   │   │   │   └── EngineBuiltInAssets.cs
│   │   │   ├── IAssetExporter.cs
│   │   │   ├── ManagerAssetExporter.cs
│   │   │   ├── RawAssetExporter.cs
│   │   │   ├── SceneYamlExporter.cs
│   │   │   ├── ScriptableObjectExporter.cs
│   │   │   ├── UnknownObjectExporter.cs
│   │   │   ├── UnreadableObjectExporter.cs
│   │   │   └── YamlExporterBase.cs
│   │   ├── ProjectAssetContainer.cs
│   │   ├── ProjectAssetPath.cs
│   │   └── ProjectExporter.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── SourceGenExtensions
│   │   ├── AnimationClipBindingConstantExtensions.cs
│   │   ├── AnimationClipExtensions.cs
│   │   ├── AnimationCurveExtensions.cs
│   │   ├── AnimationExtensions.cs
│   │   ├── AnimatorConditionExtensions.cs
│   │   ├── AnimatorControllerExtensions.cs
│   │   ├── AnimatorControllerLayerExtensions.cs
│   │   ├── AnimatorControllerParameterExtensions.cs
│   │   ├── AnimatorExtensions.cs
│   │   ├── AnimatorOverrideControllerExtensions.cs
│   │   ├── AssetBundleExtensions.cs
│   │   ├── AudioClipExtensions.cs
│   │   ├── AudioManagerExtensions.cs
│   │   ├── AudioReverbFilterExtensions.cs
│   │   ├── AudioSourceExtensions.cs
│   │   ├── AvatarConstantExtensions.cs
│   │   ├── AvatarExtensions.cs
│   │   ├── BlendShapeDataExtensions.cs
│   │   ├── BlendTreeExtensions.cs
│   │   ├── BlendTreeNodeConstantExtensions.cs
│   │   ├── BufferBindingExtensions.cs
│   │   ├── BuiltinShaderSettingsExtensions.cs
│   │   ├── CameraExtensions.cs
│   │   ├── CanvasExtensions.cs
│   │   ├── CapsuleCollider2DExtensions.cs
│   │   ├── ChannelInfoExtensions.cs
│   │   ├── ChildMotionExtensions.cs
│   │   ├── ClipExtensions.cs
│   │   ├── CollisionModuleExtensions.cs
│   │   ├── ColorRGBA32Extensions.cs
│   │   ├── ColorRGBAfExtensions.cs
│   │   ├── ComponentExtensions.cs
│   │   ├── CompositeCollider2DExtensions.cs
│   │   ├── CompressedAnimationCurveExtensions.cs
│   │   ├── CompressedMeshExtensions.cs
│   │   ├── ConditionConstantExtensions.cs
│   │   ├── ConstantClipExtensions.cs
│   │   ├── ControllerConstantExtensions.cs
│   │   ├── CrashReportingSettingsExtensions.cs
│   │   ├── CustomDataModuleExtensions.cs
│   │   ├── DenseClipExtensions.cs
│   │   ├── DetailPrototypeExtensions.cs
│   │   ├── EditorSettingsExtensions.cs
│   │   ├── EmissionModuleExtensions.cs
│   │   ├── ExternalForcesModuleExtensions.cs
│   │   ├── FlareExtensions.cs
│   │   ├── FloatCurveExtensions.cs
│   │   ├── FontExtensions.cs
│   │   ├── GISettingsExtensions.cs
│   │   ├── GLTextureSettingsExtensions.cs
│   │   ├── GUITextExtensions.cs
│   │   ├── GameObjectExtensions.cs
│   │   ├── GenericBindingExtensions.cs
│   │   ├── GraphicsSettingsExtensions.cs
│   │   ├── GuidExtensions.cs
│   │   ├── HeightmapExtensions.cs
│   │   ├── HumanExtensions.cs
│   │   ├── IHVImageFormatImporterExtensions.cs
│   │   ├── InheritVelocityModuleExtensions.cs
│   │   ├── InputAxisExtensions.cs
│   │   ├── KeyframeExtensions.Float.cs
│   │   ├── KeyframeExtensions.Quaternionf.cs
│   │   ├── KeyframeExtensions.Vector3f.cs
│   │   ├── LODExtensions.cs
│   │   ├── LODGroupExtensions.cs
│   │   ├── LayerConstantExtensions.cs
│   │   ├── LightExtensions.cs
│   │   ├── LightmapBakeModeExtensions.cs
│   │   ├── LightmapEditorSettingsExtensions.cs
│   │   ├── LightmapSettingsExtensions.cs
│   │   ├── LightsModuleExtensions.cs
│   │   ├── LineParametersExtensions.cs
│   │   ├── MaterialExtensions.cs
│   │   ├── MatrixParameterExtensions.cs
│   │   ├── MeshBlendShapeChannelExtensions.cs
│   │   ├── MeshBlendShapeExtensions.cs
│   │   ├── MeshColliderExtensions.cs
│   │   ├── MeshExtensions.cs
│   │   ├── MeshFilterExtensions.cs
│   │   ├── MeshOutlineGenerator.cs
│   │   ├── MinMaxCurveExtensions.cs
│   │   ├── MinMaxGradientExtensions.cs
│   │   ├── MonoBehaviourExtensions.cs
│   │   ├── MonoScriptExtensions.cs
│   │   ├── MultiModeParameterExtensions.cs
│   │   ├── MuscleClipInfoExtensions.cs
│   │   ├── NavMeshAgentExtensions.cs
│   │   ├── NavMeshBuildSettingsExtensions.cs
│   │   ├── NavMeshObstacleExtensions.cs
│   │   ├── NavMeshSettingsExtensions.cs
│   │   ├── NoiseModuleExtensions.cs
│   │   ├── OcclusionCullingDataExtensions.cs
│   │   ├── PPtrCurveExtensions.cs
│   │   ├── PackedFloatVectorExtensions.cs
│   │   ├── PackedIntVectorExtensions.cs
│   │   ├── PackedQuatVectorExtensions.cs
│   │   ├── PackingSettingsExtensions.cs
│   │   ├── ParticleSystemEmissionBurstExtensions.cs
│   │   ├── ParticleSystemExtensions.cs
│   │   ├── ParticleSystemForceFieldParametersExtensions.cs
│   │   ├── ParticleSystemRendererExtensions.cs
│   │   ├── Physics2DSettings.cs
│   │   ├── PhysicsJobOptions2DExtensions.cs
│   │   ├── PhysicsManagerExtensions.cs
│   │   ├── PlatformShaderDefinesExtensions.cs
│   │   ├── PrefabInstanceExtensions.cs
│   │   ├── QualitySettingExtensions.cs
│   │   ├── QualitySettingsExtensions.cs
│   │   ├── QuaternionCurveExtensions.cs
│   │   ├── RectfExtensions.cs
│   │   ├── ReflectionProbeExtensions.cs
│   │   ├── RenderSettingsExtensions.cs
│   │   ├── RenderTextureExtensions.cs
│   │   ├── RendererExtensions.cs
│   │   ├── Rigidbody2DExtensions.cs
│   │   ├── RigidbodyExtensions.cs
│   │   ├── RuntimeAnimatorControllerExtensions.cs
│   │   ├── SerializedPassExtensions.cs
│   │   ├── SerializedProgramExtensions.cs
│   │   ├── SerializedPropertyExtensions.cs
│   │   ├── SerializedShaderFloatValueExtensions.cs
│   │   ├── SerializedShaderRTBlendStateExtensions.cs
│   │   ├── SerializedShaderStateExtensions.cs
│   │   ├── SerializedShaderVectorValueExtensions.cs
│   │   ├── SerializedStencilOpExtensions.cs
│   │   ├── SerializedSubProgramExtensions.cs
│   │   ├── ShaderBindChannelExtensions.cs
│   │   ├── ShaderErrorExtensions.cs
│   │   ├── ShaderExtensions.cs
│   │   ├── ShadowSettingsExtensions.cs
│   │   ├── ShapeModuleExtensions.cs
│   │   ├── SpriteAtlasDataExtensions.cs
│   │   ├── SpriteAtlasEditorDataExtensions.cs
│   │   ├── SpriteAtlasExtensions.cs
│   │   ├── SpriteBoneExtensions.cs
│   │   ├── SpriteExtensions.cs
│   │   ├── SpriteMaskExtensions.cs
│   │   ├── SpriteMetaDataExtensions.cs
│   │   ├── SpriteRenderDataExtensions.cs
│   │   ├── SpriteRendererExtensions.cs
│   │   ├── SpriteSheetMetaDataExtensions.cs
│   │   ├── StateBehavioursPairExtensions.cs
│   │   ├── StateConstantExtensions.cs
│   │   ├── StateMotionPairExtensions.cs
│   │   ├── StaticBatchInfoExtensions.cs
│   │   ├── StreamInfoExtensions.cs
│   │   ├── StreamedClipExtensions.cs
│   │   ├── StreamedResourceExtensions.cs
│   │   ├── StreamingInfoExtensions.cs
│   │   ├── SubEmitterDataExtensions.cs
│   │   ├── SubMeshExtensions.cs
│   │   ├── TagManagerExtensions.cs
│   │   ├── TerrainExtensions.cs
│   │   ├── TextMeshExtensions.cs
│   │   ├── Texture2DArrayExtensions.cs
│   │   ├── Texture2DExtensions.cs
│   │   ├── Texture3DExtensions.cs
│   │   ├── TextureImporterExtensions.cs
│   │   ├── TextureImporterPlatformSettings.cs
│   │   ├── TextureParameterExtensions.cs
│   │   ├── TextureSettingsExtensions.cs
│   │   ├── TierGraphicsSettingsEditorExtensions.cs
│   │   ├── TierGraphicsSettingsExtensions.cs
│   │   ├── TierSettingsExtensions.cs
│   │   ├── TrailModuleExtensions.cs
│   │   ├── TransformExtensions.cs
│   │   ├── TransitionConstantExtensions.cs
│   │   ├── TriggerModuleExtensions.cs
│   │   ├── UAVParameterExtensions.cs
│   │   ├── UVModuleExtensions.cs
│   │   ├── UnityConnectSettingsExtensions.cs
│   │   ├── UnityPropertySheetExtensions.cs
│   │   ├── ValueConstantExtensions.cs
│   │   ├── VariantInfoExtensions.cs
│   │   ├── Vector2fExtensions.cs
│   │   ├── Vector3CurveExtensions.cs
│   │   ├── Vector3fExtensions.cs
│   │   ├── Vector4fExtensions.cs
│   │   ├── VectorParameterExtensions.cs
│   │   ├── VertexDataExtensions.cs
│   │   └── VirtualAnimationFactory.cs
│   ├── Structure
│   │   └── GameStructure
│   │       └── GameStructure.cs
│   └── Utils
│       └── TypeTreeHelper.cs
├── AssetRipperConsole
│   ├── App.config
│   ├── App.manifest
│   ├── AssetRipperConsole.csproj
│   ├── Directory.Build.props
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   └── PublishProfiles
│   │       ├── linux_console.pubxml
│   │       ├── mac_console.pubxml
│   │       └── windows_console.pubxml
│   └── README.md
├── AssetRipperCore
│   ├── AssetRipperCore.csproj
│   ├── Classes
│   │   ├── Component.cs
│   │   ├── EditorExtension.cs
│   │   ├── GameObject
│   │   │   ├── ComponentPair.cs
│   │   │   └── GameObject.cs
│   │   ├── Mesh
│   │   │   ├── BlendShapeData.cs
│   │   │   ├── BlendShapeVertex.cs
│   │   │   ├── ChannelInfo.cs
│   │   │   ├── CompressedMesh.cs
│   │   │   ├── Mesh.cs
│   │   │   ├── MeshBlendShape.cs
│   │   │   ├── MeshBlendShapeChannel.cs
│   │   │   ├── StreamInfo.cs
│   │   │   ├── SubMesh.cs
│   │   │   ├── VariableBoneCountWeights.cs
│   │   │   └── VertexData.cs
│   │   ├── Misc
│   │   │   └── StreamingInfo.cs
│   │   ├── NamedObject.cs
│   │   ├── Object
│   │   │   └── Object.cs
│   │   ├── Prefab.cs
│   │   ├── PrefabInstance
│   │   │   ├── PrefabInstance.cs
│   │   │   ├── PrefabModification.cs
│   │   │   └── PropertyModification.cs
│   │   ├── Transform.cs
│   │   └── Utf8StringLegacy.cs
│   ├── Converters
│   │   ├── DoesNothing
│   │   │   ├── ComponentConverter.cs
│   │   │   ├── EditorExtensionConverter.cs
│   │   │   ├── GameObject
│   │   │   │   └── ComponentPairConverter.cs
│   │   │   ├── NamedObjectConverter.cs
│   │   │   └── TransformConverter.cs
│   │   ├── GameObject
│   │   │   └── GameObjectConverter.cs
│   │   └── Mesh
│   │       ├── BlendShapeConverter.cs
│   │       ├── ChannelInfoConverter.cs
│   │       ├── MeshConverter.cs
│   │       ├── StreamInfoConverter.cs
│   │       ├── SubMeshConverter.cs
│   │       └── VertexDataConverter.cs
│   ├── Directory.Build.props
│   ├── GlobalUsings.cs
│   ├── Project
│   │   ├── Collections
│   │   │   └── AnimatorControllerExportCollection.cs
│   │   └── Exporters
│   │       └── AnimatorControllerExporter.cs
│   └── Properties
│       └── AssemblyInfo.cs
├── AssetRipperGUI
│   ├── App.axaml
│   ├── App.axaml.cs
│   ├── AssetInfo
│   │   ├── AssetYamlNode.cs
│   │   ├── AvaloniaBitmapFromDirectBitmap.cs
│   │   └── SelectedAsset.cs
│   ├── AssetRipperGUI.csproj
│   ├── BaseViewModel.cs
│   ├── Components
│   │   ├── AudioExportConfigDropdown.cs
│   │   ├── BaseConfigurationDropdown.axaml
│   │   ├── BaseConfigurationDropdown.axaml.cs
│   │   ├── BundledAssetsExportModeConfigDropdown.cs
│   │   ├── ImageExportConfigDropdown.cs
│   │   ├── MeshExportConfigDropdown.cs
│   │   ├── ScriptContentLevelConfigDropdown.cs
│   │   ├── ScriptExportModeConfigDropdown.cs
│   │   ├── ScriptLanguageVersionConfigDropdown.cs
│   │   ├── ShaderExportConfigDropdown.cs
│   │   ├── SpriteExportConfigDropdown.cs
│   │   ├── TerrainExportConfigDropdown.cs
│   │   ├── TextExportConfigDropdown.cs
│   │   └── UserControlWithPropChange.cs
│   ├── DummyAssetForLooseResourceFile.cs
│   ├── Exceptions
│   │   └── GameNotFoundException.cs
│   ├── Extensions
│   │   └── UIExtentions.cs
│   ├── GlobalUsings.cs
│   ├── LocalizationManager.cs
│   ├── LocalizeExtension.cs
│   ├── Logging
│   │   └── RipperAvaloniaSink.cs
│   ├── MainWindow.ViewModel.Configuration.cs
│   ├── MainWindow.ViewModel.cs
│   ├── MainWindow.axaml
│   ├── MainWindow.axaml.cs
│   ├── Managers
│   │   ├── UIExportManager.cs
│   │   └── UIImportManager.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   └── PublishProfiles
│   │       ├── linux_gui.pubxml
│   │       ├── mac_gui.pubxml
│   │       └── windows_gui.pubxml
│   ├── Resources
│   │   └── GUI_Icon.ico
│   ├── UIAssetContainer.cs
│   ├── UIFileListing.cs
│   └── Utils
│       └── PermissionValidator.cs
├── AssetRipperLibrary
│   ├── AssetRipperLibrary.csproj
│   ├── Attributes
│   │   └── RegisterPluginAttribute.cs
│   ├── Configuration
│   │   ├── AudioExportFormat.cs
│   │   ├── ImageExportFormat.cs
│   │   ├── LibraryConfiguration.cs
│   │   ├── MeshCoordinateSpace.cs
│   │   ├── MeshExportFormat.cs
│   │   ├── ScriptExportMode.cs
│   │   ├── ScriptLanguageVersion.cs
│   │   ├── ShaderExportMode.cs
│   │   ├── SpriteExportMode.cs
│   │   ├── TerrainExportMode.cs
│   │   └── TextExportMode.cs
│   ├── Exporters
│   │   ├── AnimationClips
│   │   │   ├── AnimationClipConverter.cs
│   │   │   ├── AnimationClipExportCollection.cs
│   │   │   ├── AnimationClipExporter.cs
│   │   │   └── CustomCurveResolver.cs
│   │   ├── AnimatorControllers
│   │   │   ├── AnimatorControllerExportCollection.cs
│   │   │   ├── AnimatorControllerExporter.cs
│   │   │   └── Editor
│   │   │       ├── StreamedCurveKey.cs
│   │   │       └── StreamedFrame.cs
│   │   ├── Audio
│   │   │   ├── AudioClipDecoder.cs
│   │   │   ├── AudioClipExportCollection.cs
│   │   │   ├── AudioClipExporter.cs
│   │   │   ├── AudioConverter.cs
│   │   │   ├── NativeAudioExportCollection.cs
│   │   │   ├── NativeAudioExporter.cs
│   │   │   ├── YamlAudioExportCollection.cs
│   │   │   └── YamlAudioExporter.cs
│   │   ├── IPostExporter.cs
│   │   ├── Meshes
│   │   │   ├── GlbMeshExportCollection.cs
│   │   │   ├── GlbMeshExporter.cs
│   │   │   ├── UnifiedMeshExportCollection.cs
│   │   │   └── UnifiedMeshExporter.cs
│   │   ├── Miscellaneous
│   │   │   ├── FontAssetExportCollection.cs
│   │   │   ├── FontAssetExporter.cs
│   │   │   ├── MovieTextureAssetExportCollection.cs
│   │   │   ├── MovieTextureAssetExporter.cs
│   │   │   ├── TextAssetExportCollection.cs
│   │   │   ├── TextAssetExporter.cs
│   │   │   ├── VideoClipExportCollection.cs
│   │   │   └── VideoClipExporter.cs
│   │   ├── ProjectVersionPostExporter.cs
│   │   ├── Scripts
│   │   │   ├── AssemblyDefinitions
│   │   │   │   ├── AssemblyDefinitionAsset.cs
│   │   │   │   ├── AssemblyDefinitionDetails.cs
│   │   │   │   ├── AssemblyDefinitionExporter.cs
│   │   │   │   └── AssemblyDefinitionSerializerContext.cs
│   │   │   ├── AssemblyDllExporter.cs
│   │   │   ├── AssemblyExportCollection.cs
│   │   │   ├── CecilAssemblyResolver.cs
│   │   │   ├── DllPostExporter.cs
│   │   │   ├── FilePathCleanup.cs
│   │   │   ├── ReferenceAssemblies.cs
│   │   │   ├── ScriptDecompiler.cs
│   │   │   ├── ScriptExportCollection.MonoScriptInfo.cs
│   │   │   ├── ScriptExportCollection.cs
│   │   │   ├── ScriptExporter.cs
│   │   │   ├── ScriptUtilities.cs
│   │   │   ├── Transforms
│   │   │   │   ├── EnsureOutParamsSetTransform.cs
│   │   │   │   ├── EnsureStructFieldsSetTransform.cs
│   │   │   │   ├── EnsureValidBaseConstructorTransform.cs
│   │   │   │   ├── FixCompilerGeneratedAccessorsTransform.cs
│   │   │   │   ├── FixEventDeclarationsTransform.cs
│   │   │   │   ├── FixExplicitInterfaceImplementationTransform.cs
│   │   │   │   ├── FixGenericStructConstraintTransform.cs
│   │   │   │   ├── FixOptionalParametersTransform.cs
│   │   │   │   ├── FixStructLayoutAmbiguityTransform.cs
│   │   │   │   ├── MemberStubTransform.cs
│   │   │   │   ├── RemoveCompilerAttributeTransform.cs
│   │   │   │   ├── RemoveInvalidMemberTransform.cs
│   │   │   │   └── ValidateNullCastsTransform.cs
│   │   │   └── WholeAssemblyDecompiler.cs
│   │   ├── Shaders
│   │   │   ├── DummyShaderTextExporter.cs
│   │   │   ├── PropertyType.cs
│   │   │   ├── RequiredProperty.cs
│   │   │   ├── ShaderDisassemblyExporter.cs
│   │   │   ├── SimpleShaderExporter.cs
│   │   │   ├── TemplateJson.cs
│   │   │   ├── TemplateList.cs
│   │   │   ├── TemplateShader.cs
│   │   │   ├── Templates
│   │   │   │   ├── Billboard.txt
│   │   │   │   ├── Default.txt
│   │   │   │   ├── ParticlesLit.txt
│   │   │   │   ├── SingleColor.txt
│   │   │   │   ├── SingleTexture.txt
│   │   │   │   ├── Templates.json
│   │   │   │   ├── TransparentDiffuse.txt
│   │   │   │   └── Unlit.txt
│   │   │   ├── YamlShaderExportCollection.cs
│   │   │   └── YamlShaderExporter.cs
│   │   ├── Terrains
│   │   │   ├── TerrainHeatmapExportCollection.cs
│   │   │   ├── TerrainHeatmapExporter.cs
│   │   │   ├── TerrainObjExportCollection.cs
│   │   │   └── TerrainObjExporter.cs
│   │   ├── Textures
│   │   │   ├── CrunchHandler.cs
│   │   │   ├── Enums
│   │   │   │   ├── KTXBaseInternalFormat.cs
│   │   │   │   └── TexgenpackTexturetype.cs
│   │   │   ├── Extensions
│   │   │   │   └── Texture2DExtensions.cs
│   │   │   ├── ImporterFactory.cs
│   │   │   ├── RawTextureExportCollection.cs
│   │   │   ├── RawTextureExporter.cs
│   │   │   ├── TexGenPackHandler.cs
│   │   │   ├── TextureAssetExporter.cs
│   │   │   ├── TextureConverter.cs
│   │   │   └── TextureExportCollection.cs
│   │   ├── TypeTrees
│   │   │   └── TypeTreeExporter.cs
│   │   ├── YamlStreamedAssetExportCollection.cs
│   │   └── YamlStreamedAssetExporter.cs
│   ├── GlobalUsings.cs
│   ├── Libraries
│   │   ├── MeshSharp.FBX.dll
│   │   ├── MeshSharp.OBJ.dll
│   │   ├── MeshSharp.PLY.dll
│   │   ├── MeshSharp.STL.dll
│   │   ├── MeshSharp.dll
│   │   ├── x64
│   │   │   ├── crunch_x64.dll
│   │   │   ├── crunchunity_x64.dll
│   │   │   └── texgenpack_x64.dll
│   │   └── x86
│   │       ├── crunch_x86.dll
│   │       ├── crunchunity_x86.dll
│   │       └── texgenpack_x86.dll
│   ├── PluginBase.cs
│   ├── Properties
│   │   └── AssemblyInfo.cs
│   ├── Reference
│   │   ├── ModelConverter.cs
│   │   └── ModelExporter.cs
│   ├── Ripper.cs
│   └── Utils
│       ├── BmpWriter.cs
│       ├── DirectBitmap.InternalSaveMethods.cs
│       ├── DirectBitmap.cs
│       ├── DumpInfo.cs
│       └── Util.cs
├── CONTRIBUTING.md
├── LICENSE.md
├── Libraries
│   ├── AssetRipper.SourceGenerated.dll
│   ├── System.Collections.dll
│   └── System.Runtime.dll
├── Licenses
│   ├── AsmResolver.md
│   ├── AssetStudio.md
│   ├── Avalonia.md
│   ├── Brotli.md
│   ├── CommandLineParser.md
│   ├── Cpp2IL.md
│   ├── Crunch.md
│   ├── Fmod5Sharp.md
│   ├── ILSpy.md
│   ├── ImageSharp.md
│   ├── LibVLCSharp.md
│   ├── Lz4.md
│   ├── MeshSharp.md
│   ├── MessageBoxAvalonia.md
│   ├── MonoCecil.md
│   ├── NAudio.md
│   ├── NAudioLame.md
│   ├── NAudioVorbis.md
│   ├── NVorbis.md
│   ├── SharpCompress.md
│   ├── SharpGLTF.md
│   ├── SharpZipLib.md
│   ├── Smolv.md
│   ├── SpirV.md
│   ├── Xiph.md
│   ├── YamlDotNet.md
│   ├── darkfx.md
│   ├── texgenpack.md
│   ├── uTinyRipper.md
│   └── uTinyRipperExporter.md
├── Localizations
│   ├── ar.json
│   ├── de.json
│   ├── en_GB.json
│   ├── en_US.json
│   ├── es.json
│   ├── fr.json
│   ├── id.json
│   ├── it.json
│   ├── ja.json
│   ├── ko.json
│   ├── nl.json
│   ├── pl.json
│   ├── pt_BR.json
│   ├── ru.json
│   ├── tr.json
│   ├── uk.json
│   ├── zh_Hans.json
│   └── zh_Hant.json
├── Media
│   └── Images
│       ├── 2D_Logo
│       │   ├── AssetRipperLogo.kra
│       │   ├── AssetRipperLogo.png
│       │   ├── AssetRipperLogoBackground.png
│       │   └── AssetRipperLogoTransparent.png
│       └── LogoReimagined
│           ├── LogoReimagined.blend
│           ├── LogoReimagined.png
│           ├── LogoReimaginedBackground.png
│           ├── LogoReimaginedBackgroundTransparent.png
│           └── LogoReimaginedTransparent.png
├── README.md
├── ShaderTextRestorer
│   ├── ConstantBuffers
│   │   ├── ConstantBufferChunk.cs
│   │   ├── ConstantBufferFlags.cs
│   │   ├── ConstantBufferType.cs
│   │   ├── ShaderVariableFlags.cs
│   │   ├── Variable.cs
│   │   ├── VariableChunk.cs
│   │   └── VariableHeader.cs
│   ├── D3DCompiler
│   │   ├── D3DCompiler.cs
│   │   └── IDxcBlob.cs
│   ├── DXShaderProgramRestorer.cs
│   ├── Exporters
│   │   ├── DirectX
│   │   │   ├── DXDataHeader.cs
│   │   │   ├── DXInputPrimitive.cs
│   │   │   ├── DXShaderTextExtractor.cs
│   │   │   └── ShaderDXExporter.cs
│   │   ├── ShaderGLESExporter.cs
│   │   ├── ShaderMetalExporter.cs
│   │   ├── ShaderTextExporter.cs
│   │   ├── ShaderUnknownExporter.cs
│   │   └── ShaderVulkanExporter.cs
│   ├── Extensions
│   │   ├── ShaderExtensions.cs
│   │   └── ShaderGpuProgramTypeExtensions.cs
│   ├── Handlers
│   │   ├── D3DHandler.cs
│   │   └── DXDecompilerlyHandler.cs
│   ├── IO
│   │   ├── SerializedExtensions.cs
│   │   └── ShaderWriter.cs
│   ├── README.md
│   ├── Resources
│   │   ├── DXProgramType.cs
│   │   ├── ResourceBindingChunk.cs
│   │   ├── ResourceChunk.cs
│   │   ├── ResourceReturnType.cs
│   │   ├── Sampler.cs
│   │   ├── SamplerFilterMode.cs
│   │   ├── SamplerWrapMode.cs
│   │   ├── ShaderFlags.cs
│   │   ├── ShaderInputFlags.cs
│   │   ├── ShaderInputType.cs
│   │   └── ShaderResourceViewDimension.cs
│   ├── ShaderBlob
│   │   ├── Parameters
│   │   │   ├── BufferBinding.cs
│   │   │   ├── ConstantBuffer.cs
│   │   │   ├── MatrixParameter.cs
│   │   │   ├── SamplerParameter.cs
│   │   │   ├── StructParameter.cs
│   │   │   ├── TextureParameter.cs
│   │   │   ├── UAVParameter.cs
│   │   │   └── VectorParameter.cs
│   │   ├── ParserBindChannels.cs
│   │   ├── ShaderBindChannel.cs
│   │   ├── ShaderSubProgram.cs
│   │   ├── ShaderSubProgramBlob.cs
│   │   └── ShaderSubProgramEntry.cs
│   ├── ShaderTextRestorer.csproj
│   └── Types
│       ├── ShaderType.cs
│       ├── ShaderTypeMember.cs
│       ├── ShaderVariableClass.cs
│       └── ShaderVariableType.cs
├── Smolv
│   ├── OpData.cs
│   ├── Original-Cpp-Notes.md
│   ├── README.md
│   ├── Smolv.csproj
│   ├── SmolvDecoder.cs
│   └── SpvOp.cs
├── SpirV
│   ├── Disassembler.cs
│   ├── EnumValuesExtensions.cs
│   ├── Instruction.cs
│   ├── Module.cs
│   ├── OperandType.cs
│   ├── ParsedInstruction.cs
│   ├── README.md
│   ├── Reader.cs
│   ├── SpirV.Core.Grammar.cs
│   ├── SpirV.Meta.cs
│   ├── SpirV.csproj
│   └── Types.cs
├── docs
│   ├── api
│   │   └── index.md
│   ├── articles
│   │   ├── CommonIssues.md
│   │   ├── Credits.md
│   │   ├── Downloads.md
│   │   ├── Requirements.md
│   │   ├── RoadMap.md
│   │   ├── RunningOnMac.md
│   │   ├── images
│   │   │   └── RunningOnMac
│   │   │       ├── 001.png
│   │   │       ├── 002.png
│   │   │       ├── 003.png
│   │   │       ├── 004.png
│   │   │       ├── 005.png
│   │   │       ├── 006.png
│   │   │       ├── 007.png
│   │   │       ├── 008.png
│   │   │       ├── 009.png
│   │   │       ├── 010.png
│   │   │       ├── 011.png
│   │   │       ├── 012.png
│   │   │       ├── 013.png
│   │   │       ├── 014.png
│   │   │       ├── 015.png
│   │   │       ├── 016.png
│   │   │       ├── 017.png
│   │   │       ├── 018.png
│   │   │       └── 019.png
│   │   ├── intro.md
│   │   └── toc.yml
│   ├── docfx.json
│   ├── index.md
│   ├── templates
│   │   └── darkfx
│   │       ├── partials
│   │       │   ├── affix.tmpl.partial
│   │       │   ├── footer.tmpl.partial
│   │       │   └── head.tmpl.partial
│   │       └── styles
│   │           ├── main.css
│   │           └── toggle-theme.js
│   └── toc.yml
├── generate_all.sh
└── get_names.sh

```

`AssetRipper.FileAnalyzer/Analyzer.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.FileAnalyzer.IO;
using System;
using System.IO;

namespace AssetRipper.FileAnalyzer
{
	public static class Analyzer
	{
		public static void LoadFiles(string[] files)
		{
			foreach (string file in files)
			{
				LoadFile(file);
			}
		}
		public static void LoadFile(string fullName)
		{
			Logger.Info(fullName);
			try
			{
				var reader = new FileReader(fullName);
				switch (reader.FileType)
				{
					case FileType.AssetsFile:
						Logger.Info("AssetsFile");
						LoadAssetsFile(reader);
						break;
					case FileType.BundleFile:
						Logger.Info("BundleFile");
						LoadBundleFile(reader);
						break;
					case FileType.WebFile:
						Logger.Info("WebFile");
						LoadWebFile(reader);
						break;
					default:
						Logger.Info("Not a rippable file");
						reader.Dispose();
						break;
				}
			}
			catch (Exception ex)
			{
				Logger.Error(ex);
			}
		}
		private static void LoadAssetsFile(FileReader reader)
		{
			Logger.Info($"Loading {reader.FileName}");
			try
			{
				var assetsFile = new SerializedFile(reader);
				if (assetsFile.IsVersionStripped)
				{
					Logger.Info("\tUnity version: stripped");
				}
				else
				{
					Logger.Info($"\tUnity version: {assetsFile.unityVersion}");
				}

				Logger.Info($"\tSerialied version: {(int)assetsFile.header.m_Version}");
				Logger.Info($"\tEndianess: {(assetsFile.header.m_Endianess == 0 ? "Little Endian" : "Big Endian")}");

				if (assetsFile.m_Externals.Count > 0)
				{
					Logger.Info("\tShared files:");
				}

				foreach (var sharedFile in assetsFile.m_Externals)
				{
					Logger.Info($"\t\t{sharedFile.fileName}");
					Logger.Info($"\t\t\tGUID: {sharedFile.guid}");
					Logger.Info($"\t\t\tType: {sharedFile.type}");
				}
			}
			catch (Exception e)
			{
				Logger.Error($"Error while reading assets file {reader.FileName}", e);
			}
			finally
			{
				reader.Dispose();
			}
		}
		private static void LoadBundleFile(FileReader reader)
		{
			Logger.Info("Loading " + reader.FileName);
			try
			{
				var bundleFile = new BundleFile(reader);
				Logger.Info($"\tSignature: {bundleFile.m_Header.signature}");
				Logger.Info($"\tBundle version: {bundleFile.m_Header.version}");
				Logger.Info($"\tUnity version: {bundleFile.m_Header.unityRevision}");//real unity version
				Logger.Info(string.Format("\tFlags: 0x{0:X4}", bundleFile.m_Header.flags));
				Logger.Info($"\tSub Files:");
				foreach (var file in bundleFile.fileList)
				{
					Logger.Info($"\t\t{file.fileName}");
				}
			}
			catch (Exception e)
			{
				Logger.Error($"Error while reading bundle file {reader.FileName}:", e);
			}
			finally
			{
				reader.Dispose();
			}
		}
		private static void LoadWebFile(FileReader reader)
		{
			Logger.Info("Loading " + reader.FileName);
			try
			{
				var webFile = new WebFile(reader);
				foreach (var file in webFile.fileList)
				{
					var dummyPath = Path.Combine(Path.GetDirectoryName(reader.FullPath), file.fileName);
					var subReader = new FileReader(dummyPath, file.stream);
					switch (subReader.FileType)
					{
						case FileType.AssetsFile:
							LoadAssetsFile(subReader);
							break;
						case FileType.BundleFile:
							LoadBundleFile(subReader);
							break;
						case FileType.WebFile:
							LoadWebFile(subReader);
							break;
						case FileType.ResourceFile:
							Logger.Info("Resource File");
							break;
					}
				}
			}
			catch (Exception e)
			{
				Logger.Error($"Error while reading web file {reader.FileName}", e);
			}
			finally
			{
				reader.Dispose();
			}
		}
	}
}

```

`AssetRipper.FileAnalyzer/AssetRipper.FileAnalyzer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>AssetRipper.FileAnalyzer</AssemblyName>
		<RootNamespace>AssetRipper.FileAnalyzer</RootNamespace>
		<OutputPath>..\Bins\AssetRipper.FileAnalyzer\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipper.FileAnalyzer\$(Configuration)\</IntermediateOutputPath>
		<Configurations>DebugWindows;ReleaseWindows;DebugMac;ReleaseMac;DebugLinux;ReleaseLinux</Configurations>
		<Platforms>x64</Platforms>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='DebugMac' or '$(Configuration)'=='DebugLinux'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
	  <ProjectReference Include="..\AssetRipper.Fundamentals\AssetRipper.Fundamentals.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipper.FileAnalyzer/BuildType.cs`:

```cs
namespace AssetRipper.FileAnalyzer
{
	public class BuildType
	{
		private string buildType;

		public BuildType(string type)
		{
			buildType = type;
		}

		public bool IsAlpha => buildType == "a";
		public bool IsPatch => buildType == "p";
	}
}

```

`AssetRipper.FileAnalyzer/BundleFile.cs`:

```cs
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.FileAnalyzer.IO;
using AssetRipper.IO.Endian;
using K4os.Compression.LZ4;
using System.IO;
using System.Linq;

namespace AssetRipper.FileAnalyzer
{
	public class BundleFile
	{
		public sealed class Header
		{
			public string signature;
			public uint version;
			public string unityVersion;
			public string unityRevision;
			public long size;
			public uint compressedBlocksInfoSize;
			public uint uncompressedBlocksInfoSize;
			public uint flags;
		}

		public sealed class StorageBlock
		{
			public uint compressedSize;
			public uint uncompressedSize;
			public ushort flags;
		}

		public sealed class Node
		{
			public long offset;
			public long size;
			public uint flags;
			public string path;
		}

		public Header m_Header;
		private StorageBlock[] m_BlocksInfo;
		private Node[] m_DirectoryInfo;

		public StreamFile[] fileList;

		public BundleFile(FileReader reader)
		{
			m_Header = new Header();
			m_Header.signature = reader.ReadStringToNull();
			m_Header.version = reader.ReadUInt32();
			m_Header.unityVersion = reader.ReadStringToNull();
			m_Header.unityRevision = reader.ReadStringToNull();
			switch (m_Header.signature)
			{
				case "UnityArchive":
					break; //TODO
				case "UnityWeb":
				case "UnityRaw":
					if (m_Header.version == 6)
					{
						goto case "UnityFS";
					}
					ReadHeaderAndBlocksInfo(reader);
					using (Stream blocksStream = CreateBlocksStream(reader.FullPath))
					{
						ReadBlocksAndDirectory(reader, blocksStream);
						ReadFiles(blocksStream, reader.FullPath);
					}
					break;
				case "UnityFS":
					ReadHeader(reader);
					ReadBlocksInfoAndDirectory(reader);
					using (Stream blocksStream = CreateBlocksStream(reader.FullPath))
					{
						ReadBlocks(reader, blocksStream);
						ReadFiles(blocksStream, reader.FullPath);
					}
					break;
			}
		}

		private void ReadHeaderAndBlocksInfo(EndianReader reader)
		{
			bool isCompressed = m_Header.signature == "UnityWeb";
			if (m_Header.version >= 4)
			{
				byte[] hash = reader.ReadBytes(16);
				uint crc = reader.ReadUInt32();
			}
			uint minimumStreamedBytes = reader.ReadUInt32();
			m_Header.size = reader.ReadUInt32();
			uint numberOfLevelsToDownloadBeforeStreaming = reader.ReadUInt32();
			int levelCount = reader.ReadInt32();
			m_BlocksInfo = new StorageBlock[1];
			for (int i = 0; i < levelCount; i++)
			{
				StorageBlock storageBlock = new StorageBlock()
				{
					compressedSize = reader.ReadUInt32(),
					uncompressedSize = reader.ReadUInt32(),
					flags = (ushort)(isCompressed ? 1 : 0)
				};
				if (i == levelCount - 1)
				{
					m_BlocksInfo[0] = storageBlock;
				}
			}
			if (m_Header.version >= 2)
			{
				uint completeFileSize = reader.ReadUInt32();
			}
			if (m_Header.version >= 3)
			{
				uint fileInfoHeaderSize = reader.ReadUInt32();
			}
			reader.BaseStream.Position = m_Header.size;
		}

		private Stream CreateBlocksStream(string path)
		{
			Stream blocksStream;
			long uncompressedSizeSum = m_BlocksInfo.Sum(x => x.uncompressedSize);
			if (uncompressedSizeSum >= int.MaxValue)
			{
				/*var memoryMappedFile = MemoryMappedFile.CreateNew(null, uncompressedSizeSum);
				assetsDataStream = memoryMappedFile.CreateViewStream();*/
				blocksStream = new FileStream(path + ".temp", FileMode.Create, FileAccess.ReadWrite, FileShare.None, 4096, FileOptions.DeleteOnClose);
			}
			else
			{
				blocksStream = new MemoryStream((int)uncompressedSizeSum);
			}
			return blocksStream;
		}

		private void ReadBlocksAndDirectory(EndianReader reader, Stream blocksStream)
		{
			foreach (StorageBlock blockInfo in m_BlocksInfo)
			{
				byte[] compressedBytes = reader.ReadBytes((int)blockInfo.compressedSize);
				if (blockInfo.flags == 1)//LZMA
				{
					using MemoryStream memoryStream = new MemoryStream(compressedBytes);
					SevenZipHelper.DecompressLZMASizeStream(memoryStream, compressedBytes.Length, blocksStream);
				}
				else
				{
					blocksStream.Write(compressedBytes, 0, compressedBytes.Length);
				}
			}
			blocksStream.Position = 0;
			EndianReader blocksReader = new EndianReader(blocksStream, EndianType.BigEndian);
			int nodesCount = blocksReader.ReadInt32();
			m_DirectoryInfo = new Node[nodesCount];
			for (int i = 0; i < nodesCount; i++)
			{
				m_DirectoryInfo[i] = new Node
				{
					path = blocksReader.ReadStringToNull(),
					offset = blocksReader.ReadUInt32(),
					size = blocksReader.ReadUInt32()
				};
			}
		}

		public void ReadFiles(Stream blocksStream, string path)
		{
			fileList = new StreamFile[m_DirectoryInfo.Length];
			for (int i = 0; i < m_DirectoryInfo.Length; i++)
			{
				Node node = m_DirectoryInfo[i];
				StreamFile file = new StreamFile();
				fileList[i] = file;
				file.path = node.path;
				file.fileName = Path.GetFileName(node.path);
				if (node.size >= int.MaxValue)
				{
					/*var memoryMappedFile = MemoryMappedFile.CreateNew(null, entryinfo_size);
					file.stream = memoryMappedFile.CreateViewStream();*/
					string extractPath = path + "_unpacked" + Path.DirectorySeparatorChar;
					Directory.CreateDirectory(extractPath);
					file.stream = new FileStream(extractPath + file.fileName, FileMode.Create, FileAccess.ReadWrite, FileShare.ReadWrite);
				}
				else
				{
					file.stream = new MemoryStream((int)node.size);
				}
				blocksStream.Position = node.offset;
				blocksStream.CopyTo(file.stream, node.size);
				file.stream.Position = 0;
			}
		}

		private void ReadHeader(EndianReader reader)
		{
			m_Header.size = reader.ReadInt64();
			m_Header.compressedBlocksInfoSize = reader.ReadUInt32();
			m_Header.uncompressedBlocksInfoSize = reader.ReadUInt32();
			m_Header.flags = reader.ReadUInt32();
			if (m_Header.signature != "UnityFS")
			{
				reader.ReadByte();
			}
		}

		private void ReadBlocksInfoAndDirectory(EndianReader reader)
		{
			byte[] blocksInfoBytes;
			if (m_Header.version >= 7)
			{
				reader.AlignStream(16);
			}
			if ((m_Header.flags & 0x80) != 0) //kArchiveBlocksInfoAtTheEnd
			{
				long position = reader.BaseStream.Position;
				reader.BaseStream.Position = reader.BaseStream.Length - m_Header.compressedBlocksInfoSize;
				blocksInfoBytes = reader.ReadBytes((int)m_Header.compressedBlocksInfoSize);
				reader.BaseStream.Position = position;
			}
			else //0x40 kArchiveBlocksAndDirectoryInfoCombined
			{
				blocksInfoBytes = reader.ReadBytes((int)m_Header.compressedBlocksInfoSize);
			}
			MemoryStream blocksInfoUncompresseddStream;
			switch (m_Header.flags & 0x3F) //kArchiveCompressionTypeMask
			{
				default: //None
					{
						blocksInfoUncompresseddStream = new MemoryStream(blocksInfoBytes);
						break;
					}
				case 1: //LZMA
					{
						MemoryStream blocksInfoCompressedStream = new MemoryStream(blocksInfoBytes);
						blocksInfoUncompresseddStream = new MemoryStream((int)m_Header.uncompressedBlocksInfoSize);
						SevenZipHelper.DecompressLZMAStream(blocksInfoCompressedStream, m_Header.compressedBlocksInfoSize, blocksInfoUncompresseddStream, m_Header.uncompressedBlocksInfoSize);
						blocksInfoUncompresseddStream.Position = 0;
						blocksInfoCompressedStream.Close();
						break;
					}
				case 2: //LZ4
				case 3: //LZ4HC
					{
						uint uncompressedSize = m_Header.uncompressedBlocksInfoSize;
						byte[] uncompressedBytes = new byte[uncompressedSize];
						int bytesWritten = LZ4Codec.Decode(blocksInfoBytes, uncompressedBytes);
						if (bytesWritten != uncompressedSize)
						{
							throw new System.Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize}");
						}
						blocksInfoUncompresseddStream = new MemoryStream(uncompressedBytes);
						break;
					}
			}
			using EndianReader blocksInfoReader = new EndianReader(blocksInfoUncompresseddStream, EndianType.BigEndian);
			byte[] uncompressedDataHash = blocksInfoReader.ReadBytes(16);
			int blocksInfoCount = blocksInfoReader.ReadInt32();
			m_BlocksInfo = new StorageBlock[blocksInfoCount];
			for (int i = 0; i < blocksInfoCount; i++)
			{
				m_BlocksInfo[i] = new StorageBlock
				{
					uncompressedSize = blocksInfoReader.ReadUInt32(),
					compressedSize = blocksInfoReader.ReadUInt32(),
					flags = blocksInfoReader.ReadUInt16()
				};
			}

			int nodesCount = blocksInfoReader.ReadInt32();
			m_DirectoryInfo = new Node[nodesCount];
			for (int i = 0; i < nodesCount; i++)
			{
				m_DirectoryInfo[i] = new Node
				{
					offset = blocksInfoReader.ReadInt64(),
					size = blocksInfoReader.ReadInt64(),
					flags = blocksInfoReader.ReadUInt32(),
					path = blocksInfoReader.ReadStringToNull(),
				};
			}
		}

		private void ReadBlocks(EndianReader reader, Stream blocksStream)
		{
			foreach (StorageBlock blockInfo in m_BlocksInfo)
			{
				switch (blockInfo.flags & 0x3F) //kStorageBlockCompressionTypeMask
				{
					default: //None
						{
							reader.BaseStream.CopyTo(blocksStream, blockInfo.compressedSize);
							break;
						}
					case 1: //LZMA
						{
							SevenZipHelper.DecompressLZMAStream(reader.BaseStream, blockInfo.compressedSize, blocksStream, blockInfo.uncompressedSize);
							break;
						}
					case 2: //LZ4
					case 3: //LZ4HC
						{
							byte[] compressedBytes = reader.ReadBytes((int)blockInfo.compressedSize);
							uint uncompressedSize = blockInfo.uncompressedSize;
							byte[] uncompressedBytes = new byte[uncompressedSize];
							int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
							compressedBytes = null;
							if (bytesWritten != uncompressedSize)
							{
								throw new System.Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize}");
							}
							blocksStream.Write(uncompressedBytes);
							break;
						}
				}
			}
			blocksStream.Position = 0;
		}
	}
}

```

`AssetRipper.FileAnalyzer/CommonString.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.FileAnalyzer
{
	public static class CommonString
	{
		public static readonly Dictionary<uint, string> StringBuffer = new Dictionary<uint, string>
		{
			{0, "AABB"},
			{5, "AnimationClip"},
			{19, "AnimationCurve"},
			{34, "AnimationState"},
			{49, "Array"},
			{55, "Base"},
			{60, "BitField"},
			{69, "bitset"},
			{76, "bool"},
			{81, "char"},
			{86, "ColorRGBA"},
			{96, "Component"},
			{106, "data"},
			{111, "deque"},
			{117, "double"},
			{124, "dynamic_array"},
			{138, "FastPropertyName"},
			{155, "first"},
			{161, "float"},
			{167, "Font"},
			{172, "GameObject"},
			{183, "Generic Mono"},
			{196, "GradientNEW"},
			{208, "GUID"},
			{213, "GUIStyle"},
			{222, "int"},
			{226, "list"},
			{231, "long long"},
			{241, "map"},
			{245, "Matrix4x4f"},
			{256, "MdFour"},
			{263, "MonoBehaviour"},
			{277, "MonoScript"},
			{288, "m_ByteSize"},
			{299, "m_Curve"},
			{307, "m_EditorClassIdentifier"},
			{331, "m_EditorHideFlags"},
			{349, "m_Enabled"},
			{359, "m_ExtensionPtr"},
			{374, "m_GameObject"},
			{387, "m_Index"},
			{395, "m_IsArray"},
			{405, "m_IsStatic"},
			{416, "m_MetaFlag"},
			{427, "m_Name"},
			{434, "m_ObjectHideFlags"},
			{452, "m_PrefabInternal"},
			{469, "m_PrefabParentObject"},
			{490, "m_Script"},
			{499, "m_StaticEditorFlags"},
			{519, "m_Type"},
			{526, "m_Version"},
			{536, "Object"},
			{543, "pair"},
			{548, "PPtr<Component>"},
			{564, "PPtr<GameObject>"},
			{581, "PPtr<Material>"},
			{596, "PPtr<MonoBehaviour>"},
			{616, "PPtr<MonoScript>"},
			{633, "PPtr<Object>"},
			{646, "PPtr<Prefab>"},
			{659, "PPtr<Sprite>"},
			{672, "PPtr<TextAsset>"},
			{688, "PPtr<Texture>"},
			{702, "PPtr<Texture2D>"},
			{718, "PPtr<Transform>"},
			{734, "Prefab"},
			{741, "Quaternionf"},
			{753, "Rectf"},
			{759, "RectInt"},
			{767, "RectOffset"},
			{778, "second"},
			{785, "set"},
			{789, "short"},
			{795, "size"},
			{800, "SInt16"},
			{807, "SInt32"},
			{814, "SInt64"},
			{821, "SInt8"},
			{827, "staticvector"},
			{840, "string"},
			{847, "TextAsset"},
			{857, "TextMesh"},
			{866, "Texture"},
			{874, "Texture2D"},
			{884, "Transform"},
			{894, "TypelessData"},
			{907, "UInt16"},
			{914, "UInt32"},
			{921, "UInt64"},
			{928, "UInt8"},
			{934, "unsigned int"},
			{947, "unsigned long long"},
			{966, "unsigned short"},
			{981, "vector"},
			{988, "Vector2f"},
			{997, "Vector3f"},
			{1006, "Vector4f"},
			{1015, "m_ScriptingClassIdentifier"},
			{1042, "Gradient"},
			{1051, "Type*"},
			{1057, "int2_storage"},
			{1070, "int3_storage"},
			{1083, "BoundsInt"},
			{1093, "m_CorrespondingSourceObject"},
			{1121, "m_PrefabInstance"},
			{1138, "m_PrefabAsset"},
			{1152, "FileSize"},
			{1161, "Hash128"}
		};
	}
}

```

`AssetRipper.FileAnalyzer/FileIdentifier.cs`:

```cs
using System;

namespace AssetRipper.FileAnalyzer
{
	public class FileIdentifier
	{
		public Guid guid;
		public int type; //enum { kNonAssetType = 0, kDeprecatedCachedAssetType = 1, kSerializedAssetType = 2, kMetaAssetType = 3 };
		public string pathName;

		//custom
		public string fileName;
	}
}

```

`AssetRipper.FileAnalyzer/IO/FileReader.cs`:

```cs
using AssetRipper.Core.IO.Extensions;
using AssetRipper.IO.Endian;
using System;
using System.IO;
using System.Linq;

namespace AssetRipper.FileAnalyzer.IO
{
	public class FileReader : EndianReader
	{
		public string FullPath { get; }
		public string FileName { get; }
		public FileType FileType { get; }

		private static byte[] gzipMagic = { 0x1f, 0x8b };
		private static byte[] brotliMagic = { 0x62, 0x72, 0x6F, 0x74, 0x6C, 0x69 };

		public FileReader(string path) : this(path, File.Open(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)) { }

		public FileReader(string path, Stream stream) : base(stream, EndianType.BigEndian)
		{
			FullPath = Path.GetFullPath(path);
			FileName = Path.GetFileName(path);
			FileType = CheckFileType();
		}

		private FileType CheckFileType()
		{
			var signature = this.ReadStringToNull(20);
			BaseStream.Position = 0;
			switch (signature)
			{
				case "UnityWeb":
				case "UnityRaw":
				case "UnityArchive":
				case "UnityFS":
					return FileType.BundleFile;
				case "UnityWebData1.0":
					return FileType.WebFile;
				default:
					{
						var magic = ReadBytes(2);
						BaseStream.Position = 0;
						if (gzipMagic.SequenceEqual(magic))
						{
							return FileType.WebFile;
						}
						BaseStream.Position = 0x20;
						magic = ReadBytes(6);
						BaseStream.Position = 0;
						if (brotliMagic.SequenceEqual(magic))
						{
							return FileType.WebFile;
						}
						if (IsSerializedFile())
						{
							return FileType.AssetsFile;
						}
						else
						{
							return FileType.ResourceFile;
						}
					}
			}
		}

		private bool IsSerializedFile()
		{
			var fileSize = BaseStream.Length;
			if (fileSize < 20)
			{
				return false;
			}
			var m_MetadataSize = ReadUInt32();
			long m_FileSize = ReadUInt32();
			var m_Version = ReadUInt32();
			long m_DataOffset = ReadUInt32();
			var m_Endianess = ReadByte();
			var m_Reserved = ReadBytes(3);
			if (m_Version >= 22)
			{
				if (fileSize < 48)
				{
					BaseStream.Position = 0;
					return false;
				}
				m_MetadataSize = ReadUInt32();
				m_FileSize = ReadInt64();
				m_DataOffset = ReadInt64();
			}
			BaseStream.Position = 0;
			if (m_FileSize != fileSize)
			{
				return false;
			}
			if (m_DataOffset > fileSize)
			{
				return false;
			}
			return true;
		}
	}
}

```

`AssetRipper.FileAnalyzer/IO/FileType.cs`:

```cs
namespace AssetRipper.FileAnalyzer.IO
{
	public enum FileType
	{
		AssetsFile,
		BundleFile,
		WebFile,
		ResourceFile
	}
}

```

`AssetRipper.FileAnalyzer/LocalSerializedObjectIdentifier.cs`:

```cs
namespace AssetRipper.FileAnalyzer
{
	public class LocalSerializedObjectIdentifier
	{
		public int localSerializedFileIndex;
		public long localIdentifierInFile;
	}
}

```

`AssetRipper.FileAnalyzer/ObjectInfo.cs`:

```cs
namespace AssetRipper.FileAnalyzer
{
	public class ObjectInfo
	{
		public long byteStart;
		public uint byteSize;
		public int typeID;
		public int classID;
		public ushort isDestroyed;
		public byte stripped;

		public long m_PathID;
		public SerializedType serializedType;
	}
}

```

`AssetRipper.FileAnalyzer/Program.cs`:

```cs
using AssetRipper.Core.Logging;
using System;

namespace AssetRipper.FileAnalyzer
{
	class Program
	{
		static void Main(string[] args)
		{
			if (args.Length == 0)
			{
				Console.WriteLine("No arguments");
			}
			else
			{
				Logger.Add(new ConsoleLogger(true));
				Analyzer.LoadFiles(args);
			}
			Console.ReadKey();
			return;
		}
	}
}

```

`AssetRipper.FileAnalyzer/README.md`:

```md
# AssetRipper.FileAnalyzer

This is a simple program to investigate header information on asset bundles and serialized files. Just drag and drop the file onto the exe.
```

`AssetRipper.FileAnalyzer/SerializedFile.cs`:

```cs
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;
using AssetRipper.FileAnalyzer.IO;
using AssetRipper.IO.Endian;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AssetRipper.FileAnalyzer
{
	public class SerializedFile
	{
		public FileReader reader;
		public string fullName;
		public string originalPath;
		public string fileName;
		public int[] version = { 0, 0, 0, 0 };
		public BuildType buildType;

		public SerializedFileHeader header;
		private byte m_FileEndianess;
		public string unityVersion = "2.5.0f5";
		public BuildTarget m_TargetPlatform = BuildTarget.AnyPlayer;
		private bool m_EnableTypeTree = true;
		public List<SerializedType> m_Types;
		public int bigIDEnabled = 0;
		public List<ObjectInfo> m_Objects;
		private List<LocalSerializedObjectIdentifier> m_ScriptTypes;
		public List<FileIdentifier> m_Externals;
		public List<SerializedType> m_RefTypes;
		public string userInformation;

		public SerializedFile(FileReader reader)
		{
			this.reader = reader;
			fullName = reader.FullPath;
			fileName = reader.FileName;

			// ReadHeader
			header = new SerializedFileHeader();
			header.m_MetadataSize = reader.ReadUInt32();
			header.m_FileSize = reader.ReadUInt32();
			header.m_Version = (SerializedFileFormatVersion)reader.ReadUInt32();
			header.m_DataOffset = reader.ReadUInt32();

			if (header.m_Version >= SerializedFileFormatVersion.kUnknown_9)
			{
				header.m_Endianess = reader.ReadByte();
				header.m_Reserved = reader.ReadBytes(3);
				m_FileEndianess = header.m_Endianess;
			}
			else
			{
				reader.BaseStream.Position = header.m_FileSize - header.m_MetadataSize;
				m_FileEndianess = reader.ReadByte();
			}

			if (header.m_Version >= SerializedFileFormatVersion.kLargeFilesSupport)
			{
				header.m_MetadataSize = reader.ReadUInt32();
				header.m_FileSize = reader.ReadInt64();
				header.m_DataOffset = reader.ReadInt64();
				reader.ReadInt64(); // unknown
			}

			// ReadMetadata
			if (m_FileEndianess == 0)
			{
				reader.EndianType = EndianType.LittleEndian;
			}
			if (header.m_Version >= SerializedFileFormatVersion.kUnknown_7)
			{
				unityVersion = reader.ReadStringToNull();
				SetVersion(unityVersion);
			}
			if (header.m_Version >= SerializedFileFormatVersion.kUnknown_8)
			{
				m_TargetPlatform = (BuildTarget)reader.ReadInt32();
			}
			if (header.m_Version >= SerializedFileFormatVersion.kHasTypeTreeHashes)
			{
				m_EnableTypeTree = reader.ReadBoolean();
			}

			// Read Types
			int typeCount = reader.ReadInt32();
			m_Types = new List<SerializedType>(typeCount);
			for (int i = 0; i < typeCount; i++)
			{
				m_Types.Add(ReadSerializedType(false));
			}

			if (header.m_Version >= SerializedFileFormatVersion.kUnknown_7 && header.m_Version < SerializedFileFormatVersion.kUnknown_14)
			{
				bigIDEnabled = reader.ReadInt32();
			}

			// Read Objects
			int objectCount = reader.ReadInt32();
			m_Objects = new List<ObjectInfo>(objectCount);
			for (int i = 0; i < objectCount; i++)
			{
				var objectInfo = new ObjectInfo();
				if (bigIDEnabled != 0)
				{
					objectInfo.m_PathID = reader.ReadInt64();
				}
				else if (header.m_Version < SerializedFileFormatVersion.kUnknown_14)
				{
					objectInfo.m_PathID = reader.ReadInt32();
				}
				else
				{
					reader.AlignStream();
					objectInfo.m_PathID = reader.ReadInt64();
				}

				if (header.m_Version >= SerializedFileFormatVersion.kLargeFilesSupport)
				{
					objectInfo.byteStart = reader.ReadInt64();
				}
				else
				{
					objectInfo.byteStart = reader.ReadUInt32();
				}

				objectInfo.byteStart += header.m_DataOffset;
				objectInfo.byteSize = reader.ReadUInt32();
				objectInfo.typeID = reader.ReadInt32();
				if (header.m_Version < SerializedFileFormatVersion.kRefactoredClassId)
				{
					objectInfo.classID = reader.ReadUInt16();
					objectInfo.serializedType = m_Types.Find(x => x.classID == objectInfo.typeID);
				}
				else
				{
					var type = m_Types[objectInfo.typeID];
					objectInfo.serializedType = type;
					objectInfo.classID = type.classID;
				}
				if (header.m_Version < SerializedFileFormatVersion.kHasScriptTypeIndex)
				{
					objectInfo.isDestroyed = reader.ReadUInt16();
				}
				if (header.m_Version >= SerializedFileFormatVersion.kHasScriptTypeIndex && header.m_Version < SerializedFileFormatVersion.kRefactorTypeData)
				{
					var m_ScriptTypeIndex = reader.ReadInt16();
					if (objectInfo.serializedType != null)
					{
						objectInfo.serializedType.m_ScriptTypeIndex = m_ScriptTypeIndex;
					}
				}
				if (header.m_Version == SerializedFileFormatVersion.kSupportsStrippedObject || header.m_Version == SerializedFileFormatVersion.kRefactoredClassId)
				{
					objectInfo.stripped = reader.ReadByte();
				}
				m_Objects.Add(objectInfo);
			}

			if (header.m_Version >= SerializedFileFormatVersion.kHasScriptTypeIndex)
			{
				int scriptCount = reader.ReadInt32();
				m_ScriptTypes = new List<LocalSerializedObjectIdentifier>(scriptCount);
				for (int i = 0; i < scriptCount; i++)
				{
					var m_ScriptType = new LocalSerializedObjectIdentifier();
					m_ScriptType.localSerializedFileIndex = reader.ReadInt32();
					if (header.m_Version < SerializedFileFormatVersion.kUnknown_14)
					{
						m_ScriptType.localIdentifierInFile = reader.ReadInt32();
					}
					else
					{
						reader.AlignStream();
						m_ScriptType.localIdentifierInFile = reader.ReadInt64();
					}
					m_ScriptTypes.Add(m_ScriptType);
				}
			}

			int externalsCount = reader.ReadInt32();
			m_Externals = new List<FileIdentifier>(externalsCount);
			for (int i = 0; i < externalsCount; i++)
			{
				var m_External = new FileIdentifier();
				if (header.m_Version >= SerializedFileFormatVersion.kUnknown_6)
				{
					var tempEmpty = reader.ReadStringToNull();
				}
				if (header.m_Version >= SerializedFileFormatVersion.kUnknown_5)
				{
					m_External.guid = new Guid(reader.ReadBytes(16));
					m_External.type = reader.ReadInt32();
				}
				m_External.pathName = reader.ReadStringToNull();
				m_External.fileName = Path.GetFileName(m_External.pathName);
				m_Externals.Add(m_External);
			}

			if (header.m_Version >= SerializedFileFormatVersion.kSupportsRefObject)
			{
				int refTypesCount = reader.ReadInt32();
				m_RefTypes = new List<SerializedType>(refTypesCount);
				for (int i = 0; i < refTypesCount; i++)
				{
					m_RefTypes.Add(ReadSerializedType(true));
				}
			}

			if (header.m_Version >= SerializedFileFormatVersion.kUnknown_5)
			{
				userInformation = reader.ReadStringToNull();
			}

			//reader.AlignStream(16);
		}

		public void SetVersion(string stringVersion)
		{
			if (stringVersion != strippedVersion)
			{
				unityVersion = stringVersion;
				var buildSplit = Regex.Replace(stringVersion, @"\d", "").Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
				buildType = new BuildType(buildSplit[0]);
				var versionSplit = Regex.Replace(stringVersion, @"\D", ".").Split(new[] { "." }, StringSplitOptions.RemoveEmptyEntries);
				version = versionSplit.Select(int.Parse).ToArray();
			}
		}

		private SerializedType ReadSerializedType(bool isRefType)
		{
			var type = new SerializedType();

			type.classID = reader.ReadInt32();

			if (header.m_Version >= SerializedFileFormatVersion.kRefactoredClassId)
			{
				type.m_IsStrippedType = reader.ReadBoolean();
			}

			if (header.m_Version >= SerializedFileFormatVersion.kRefactorTypeData)
			{
				type.m_ScriptTypeIndex = reader.ReadInt16();
			}

			if (header.m_Version >= SerializedFileFormatVersion.kHasTypeTreeHashes)
			{
				if (isRefType && type.m_ScriptTypeIndex >= 0)
				{
					type.m_ScriptID = reader.ReadBytes(16);
				}
				else if ((header.m_Version < SerializedFileFormatVersion.kRefactoredClassId && type.classID < 0) || (header.m_Version >= SerializedFileFormatVersion.kRefactoredClassId && type.classID == 114))
				{
					type.m_ScriptID = reader.ReadBytes(16);
				}
				type.m_OldTypeHash = reader.ReadBytes(16);
			}

			if (m_EnableTypeTree)
			{
				type.m_Type = new TypeTree();
				type.m_Type.Nodes.Clear();
				if (header.m_Version >= SerializedFileFormatVersion.kUnknown_12 || header.m_Version == SerializedFileFormatVersion.kUnknown_10)
				{
					TypeTreeBlobRead(type.m_Type);
				}
				else
				{
					ReadTypeTree(type.m_Type);
				}
				if (header.m_Version >= SerializedFileFormatVersion.kStoresTypeDependencies)
				{
					if (isRefType)
					{
						type.m_KlassName = reader.ReadStringToNull();
						type.m_NameSpace = reader.ReadStringToNull();
						type.m_AsmName = reader.ReadStringToNull();
					}
					else
					{
						type.m_TypeDependencies = reader.ReadInt32Array();
					}
				}
			}

			return type;
		}

		private void ReadTypeTree(TypeTree m_Type, int level = 0)
		{
			var typeTreeNode = new TypeTreeNode();
			m_Type.Nodes.Add(typeTreeNode);
			typeTreeNode.Level = (byte)level;
			typeTreeNode.Type = reader.ReadStringToNull();
			typeTreeNode.Name = reader.ReadStringToNull();
			typeTreeNode.ByteSize = reader.ReadInt32();
			if (header.m_Version == SerializedFileFormatVersion.kUnknown_2)
			{
				var variableCount = reader.ReadInt32();
			}
			if (header.m_Version != SerializedFileFormatVersion.kUnknown_3)
			{
				typeTreeNode.Index = reader.ReadInt32();
			}
			typeTreeNode.TypeFlags = reader.ReadInt32();
			typeTreeNode.Version = reader.ReadInt32();
			if (header.m_Version != SerializedFileFormatVersion.kUnknown_3)
			{
				typeTreeNode.MetaFlag = (AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TransferMetaFlags)reader.ReadUInt32();
			}

			int childrenCount = reader.ReadInt32();
			for (int i = 0; i < childrenCount; i++)
			{
				ReadTypeTree(m_Type, level + 1);
			}
		}

		private void TypeTreeBlobRead(TypeTree m_Type)
		{
			int numberOfNodes = reader.ReadInt32();
			int stringBufferSize = reader.ReadInt32();
			for (int i = 0; i < numberOfNodes; i++)
			{
				var typeTreeNode = new TypeTreeNode();
				m_Type.Nodes.Add(typeTreeNode);
				typeTreeNode.Version = reader.ReadUInt16();
				typeTreeNode.Level = reader.ReadByte();
				typeTreeNode.TypeFlags = reader.ReadByte();
				typeTreeNode.TypeStrOffset = reader.ReadUInt32();
				typeTreeNode.NameStrOffset = reader.ReadUInt32();
				typeTreeNode.ByteSize = reader.ReadInt32();
				typeTreeNode.Index = reader.ReadInt32();
				typeTreeNode.MetaFlag = (AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TransferMetaFlags)reader.ReadUInt32();
				if (header.m_Version >= SerializedFileFormatVersion.kTypeTreeNodeWithTypeFlags)
				{
					typeTreeNode.RefTypeHash = reader.ReadUInt64();
				}
			}
			m_Type.StringBuffer = reader.ReadBytes(stringBufferSize);

			using (var stringBufferReader = new BinaryReader(new MemoryStream(m_Type.StringBuffer)))
			{
				for (int i = 0; i < numberOfNodes; i++)
				{
					var m_Node = m_Type.Nodes[i];
					m_Node.Type = ReadString(stringBufferReader, m_Node.TypeStrOffset);
					m_Node.Name = ReadString(stringBufferReader, m_Node.NameStrOffset);
				}
			}

			string ReadString(BinaryReader stringBufferReader, uint value)
			{
				var isOffset = (value & 0x80000000) == 0;
				if (isOffset)
				{
					stringBufferReader.BaseStream.Position = value;
					return stringBufferReader.ReadStringToNull();
				}
				var offset = value & 0x7FFFFFFF;
				if (CommonString.StringBuffer.TryGetValue(offset, out var str))
				{
					return str;
				}
				return offset.ToString();
			}
		}

		public bool IsVersionStripped => unityVersion == strippedVersion;

		private const string strippedVersion = "0.0.0";
	}
}

```

`AssetRipper.FileAnalyzer/SerializedFileFormatVersion.cs`:

```cs
namespace AssetRipper.FileAnalyzer
{
	public enum SerializedFileFormatVersion
	{
		kUnsupported = 1,
		kUnknown_2 = 2,
		kUnknown_3 = 3,
		/// <summary>
		/// 1.2.0 to 2.0.0
		/// </summary>
		kUnknown_5 = 5,
		/// <summary>
		/// 2.1.0 to 2.6.1
		/// </summary>
		kUnknown_6 = 6,
		/// <summary>
		/// 3.0.0b
		/// </summary>
		kUnknown_7 = 7,
		/// <summary>
		/// 3.0.0 to 3.4.2
		/// </summary>
		kUnknown_8 = 8,
		/// <summary>
		/// 3.5.0 to 4.7.2
		/// </summary>
		kUnknown_9 = 9,
		/// <summary>
		/// 5.0.0aunk1
		/// </summary>
		kUnknown_10 = 10,
		/// <summary>
		/// 5.0.0aunk2
		/// </summary>
		kHasScriptTypeIndex = 11,
		/// <summary>
		/// 5.0.0aunk3
		/// </summary>
		kUnknown_12 = 12,
		/// <summary>
		/// 5.0.0aunk4
		/// </summary>
		kHasTypeTreeHashes = 13,
		/// <summary>
		/// 5.0.0unk
		/// </summary>
		kUnknown_14 = 14,
		/// <summary>
		/// 5.0.1 to 5.4.0
		/// </summary>
		kSupportsStrippedObject = 15,
		/// <summary>
		/// 5.5.0a
		/// </summary>
		kRefactoredClassId = 16,
		/// <summary>
		/// 5.5.0unk to 2018.4
		/// </summary>
		kRefactorTypeData = 17,
		/// <summary>
		/// 2019.1a
		/// </summary>
		kRefactorShareableTypeTreeData = 18,
		/// <summary>
		/// 2019.1unk
		/// </summary>
		kTypeTreeNodeWithTypeFlags = 19,
		/// <summary>
		/// 2019.2
		/// </summary>
		kSupportsRefObject = 20,
		/// <summary>
		/// 2019.3 to 2019.4
		/// </summary>
		kStoresTypeDependencies = 21,
		/// <summary>
		/// 2020.1 to x
		/// </summary>
		kLargeFilesSupport = 22
	}
}

```

`AssetRipper.FileAnalyzer/SerializedFileHeader.cs`:

```cs
namespace AssetRipper.FileAnalyzer
{
	public class SerializedFileHeader
	{
		public uint m_MetadataSize;
		public long m_FileSize;
		public SerializedFileFormatVersion m_Version;
		public long m_DataOffset;
		public byte m_Endianess;
		public byte[] m_Reserved;
	}
}

```

`AssetRipper.FileAnalyzer/SerializedType.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;

namespace AssetRipper.FileAnalyzer
{
	public class SerializedType
	{
		public int classID;
		public bool m_IsStrippedType;
		public short m_ScriptTypeIndex = -1;
		public TypeTree m_Type;
		public byte[] m_ScriptID; //Hash128
		public byte[] m_OldTypeHash; //Hash128
		public int[] m_TypeDependencies;
		public string m_KlassName;
		public string m_NameSpace;
		public string m_AsmName;
	}
}

```

`AssetRipper.FileAnalyzer/StreamFile.cs`:

```cs
using System.IO;

namespace AssetRipper.FileAnalyzer
{
	public class StreamFile
	{
		public string path;
		public string fileName;
		public Stream stream;
	}
}

```

`AssetRipper.FileAnalyzer/WebFile.cs`:

```cs
using AssetRipper.Core.IO.Extensions;
using AssetRipper.IO.Endian;
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Text;

namespace AssetRipper.FileAnalyzer
{
	public class WebFile
	{
		public static byte[] gzipMagic = { 0x1f, 0x8b };
		public static byte[] brotliMagic = { 0x62, 0x72, 0x6F, 0x74, 0x6C, 0x69 };
		public StreamFile[] fileList;

		private class WebData
		{
			public int dataOffset;
			public int dataLength;
			public string path;
		}

		public WebFile(EndianReader reader)
		{
			var magic = reader.ReadBytes(2);
			reader.BaseStream.Position = 0;
			if (gzipMagic.SequenceEqual(magic))
			{
				using GZipStream gzipStream = new GZipStream(reader.BaseStream, CompressionMode.Decompress);
				using MemoryStream stream = new MemoryStream();
				gzipStream.CopyTo(stream);
				stream.Position = 0;
				using BinaryReader binaryReader = new BinaryReader(stream);
				ReadWebData(binaryReader);
			}
			else
			{
				reader.BaseStream.Position = 0x20;
				magic = reader.ReadBytes(6);
				reader.BaseStream.Position = 0;
				if (brotliMagic.SequenceEqual(magic))
				{
					using BrotliStream brotliStream = new BrotliStream(reader.BaseStream, CompressionMode.Decompress);
					using MemoryStream stream = new MemoryStream();
					brotliStream.CopyTo(stream);
					stream.Position = 0;
					using BinaryReader binaryReader = new BinaryReader(stream);
					ReadWebData(binaryReader);
				}
				else
				{
					reader.EndianType = EndianType.LittleEndian;
					ReadWebData(reader);
				}
			}
		}

		private void ReadWebData(BinaryReader reader)
		{
			var signature = reader.ReadStringToNull();
			if (signature != "UnityWebData1.0")
			{
				return;
			}

			var headLength = reader.ReadInt32();
			var dataList = new List<WebData>();
			while (reader.BaseStream.Position < headLength)
			{
				var data = new WebData();
				data.dataOffset = reader.ReadInt32();
				data.dataLength = reader.ReadInt32();
				var pathLength = reader.ReadInt32();
				data.path = Encoding.UTF8.GetString(reader.ReadBytes(pathLength));
				dataList.Add(data);
			}
			fileList = new StreamFile[dataList.Count];
			for (int i = 0; i < dataList.Count; i++)
			{
				var data = dataList[i];
				var file = new StreamFile();
				file.path = data.path;
				file.fileName = Path.GetFileName(data.path);
				reader.BaseStream.Position = data.dataOffset;
				file.stream = new MemoryStream(reader.ReadBytes(data.dataLength));
				fileList[i] = file;
			}
		}
	}
}

```

`AssetRipper.Fundamentals/AssetRipper.Fundamentals.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<OutputPath>..\Bins\AssetRipper.Fundamentals\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipper.Fundamentals\$(Configuration)\</IntermediateOutputPath>
		<AssemblyName>AssetRipper.Fundamentals</AssemblyName>
		<RootNamespace>AssetRipper.Core</RootNamespace>
		<Copyright>Copyright ©  2022</Copyright>
		<Authors>ds5678</Authors>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.PE.File" Version="4.11.1" />
		<PackageReference Include="AssetRipper.VersionUtilities" Version="1.2.1" />
		<PackageReference Include="K4os.Compression.LZ4" Version="1.2.16" />
		<PackageReference Include="Mono.Cecil" Version="0.11.4" />
		<PackageReference Include="Samboy063.Cpp2IL.Core" Version="2022.0.5" />
		<PackageReference Include="SharpCompress" Version="0.32.1" />
		<PackageReference Include="SharpZipLib" Version="1.3.3" />
	</ItemGroup>

	<ItemGroup>
	  <ProjectReference Include="..\AssetRipper.IO.Endian\AssetRipper.IO.Endian.csproj" />
	  <ProjectReference Include="..\AssetRipper.Yaml\AssetRipper.Yaml.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipper.Fundamentals/BuildInfo.cs`:

```cs
namespace AssetRipper.Core
{
	public static class BuildInfo
	{
		public const string Name = "AssetRipper";
		public const string CommonName = Name + "Common";
		public const string ConsoleName = Name + "Console";
		public const string CoreName = Name + "Core";
		public const string GUIName = Name + "GUI";
		public const string LibraryName = Name + "Library";

		public const string Author = "ds5678";
		public const string CopyRight = "Copyright © 2022";

		public const string Version = "0.2.0.5";
	}
}

```

`AssetRipper.Fundamentals/ClassIDType.cs`:

```cs
// official Class ID Reference: https://docs.unity3d.com/Manual/ClassIDReference.html
namespace AssetRipper.Core
{
	// Since some output is based on string representation renamed values has negative index
	public enum ClassIDType
	{
		UnknownType = -1,
		Object = 0,
		GameObject = 1,
		Component = 2,
		LevelGameManager = 3,
		Transform = 4,
		TimeManager = 5,
		GlobalGameManager = 6,
		Behaviour = 8,
		GameManager = 9,
		AudioManager = 11,
		ParticleAnimator = 12,
		InputManager = 13,
		EllipsoidParticleEmitter = 15,
		Pipeline = 17,
		EditorExtension = 18,
		Physics2DSettings = 19,
		Camera = 20,
		Material = 21,
		MeshRenderer = 23,
		Renderer = 25,
		ParticleRenderer = 26,
		Texture = 27,
		Texture2D = 28,
		OcclusionCullingSettings = 29,
		GraphicsSettings = 30,
		MeshFilter = 33,
		OcclusionPortal = 41,
		Mesh = 43,
		Skybox = 45,
		QualitySettings = 47,
		Shader = 48,
		TextAsset = 49,
		Rigidbody2D = 50,
		NotificationManager = 52,
		Collider2D = 53,
		Rigidbody = 54,
		PhysicsManager = 55,
		Collider = 56,
		Joint = 57,
		CircleCollider2D = 58,
		HingeJoint = 59,
		PolygonCollider2D = 60,
		BoxCollider2D = 61,
		PhysicsMaterial2D = 62,
		MeshCollider = 64,
		BoxCollider = 65,
		CompositeCollider2D = 66,
		EdgeCollider2D = 68,
		PolygonColliderBase2D = 69,
		CapsuleCollider2D = 70,
		AnimationManager = 71,
		ComputeShader = 72,
		AnimationClip = 74,
		ConstantForce = 75,
		WorldParticleCollider = 76,
		TagManager = 78,
		AudioListener = 81,
		AudioSource = 82,
		AudioClip = 83,
		RenderTexture = 84,
		CustomRenderTexture = 86,
		MeshParticleEmitter = 87,
		ParticleEmitter = 88,
		Cubemap = 89,
		Avatar = 90,
		AnimatorController = 91,
		GUILayer = 92,
		RuntimeAnimatorController = 93,
		ShaderNameRegistry = 94,
		Animator = 95,
		TrailRenderer = 96,
		DelayedCallManager = 98,
		TextMesh = 102,
		RenderSettings = 104,
		Light = 108,
		ShaderInclude = 109,
		BaseAnimationTrack = 110,
		Animation = 111,
		MonoBehaviour = 114,
		MonoScript = 115,
		MonoManager = 116,
		Texture3D = 117,
		NewAnimationTrack = 118,
		Projector = 119,
		LineRenderer = 120,
		Flare = 121,
		Halo = 122,
		LensFlare = 123,
		FlareLayer = 124,
		HaloLayer = 125,
		NavMeshProjectSettings = 126,
		HaloManager = 127,
		Font = 128,
		PlayerSettings = 129,
		NamedObject = 130,
		GUITexture = 131,
		GUIText = 132,
		GUIElement = 133,
		PhysicMaterial = 134,
		SphereCollider = 135,
		CapsuleCollider = 136,
		SkinnedMeshRenderer = 137,
		FixedJoint = 138,
		RaycastCollider = 140,
		BuildSettings = 141,
		AssetBundle = 142,
		CharacterController = 143,
		CharacterJoint = 144,
		SpringJoint = 145,
		WheelCollider = 146,
		ResourceManager = 147,
		NetworkView = 148,
		NetworkManager = 149,
		PreloadData = 150,
		MovieTexture = 152,
		ConfigurableJoint = 153,
		TerrainCollider = 154,
		MasterServerInterface = 155,
		TerrainData = 156,
		LightmapSettings = 157,
		WebCamTexture = 158,
		EditorSettings = 159,
		InteractiveCloth = 160,
		ClothRenderer = 161,
		EditorUserSettings = 162,
		SkinnedCloth = 163,
		AudioReverbFilter = 164,
		AudioHighPassFilter = 165,
		AudioChorusFilter = 166,
		AudioReverbZone = 167,
		AudioEchoFilter = 168,
		AudioLowPassFilter = 169,
		AudioDistortionFilter = 170,
		SparseTexture = 171,
		AudioBehaviour = 180,
		AudioFilter = 181,
		WindZone = 182,
		Cloth = 183,
		SubstanceArchive = 184,
		ProceduralMaterial = 185,
		ProceduralTexture = 186,
		Texture2DArray = 187,
		CubemapArray = 188,
		OffMeshLink = 191,
		OcclusionArea = 192,
		Tree = 193,
		NavMeshObsolete = 194,
		NavMeshAgent = 195,
		NavMeshSettings = 196,
		LightProbes_197 = 197,
		ParticleSystem = 198,
		ParticleSystemRenderer = 199,
		ShaderVariantCollection = 200,
		LODGroup = 205,
		BlendTree = 206,
		Motion = 207,
		NavMeshObstacle = 208,
		SortingGroup = 210,
		SpriteRenderer = 212,
		Sprite = 213,
		CachedSpriteAtlas = 214,
		ReflectionProbe = 215,
		Terrain = 218,
		LightProbeGroup = 220,
		AnimatorOverrideController = 221,
		CanvasRenderer = 222,
		Canvas = 223,
		RectTransform = 224,
		CanvasGroup = 225,
		BillboardAsset = 226,
		BillboardRenderer = 227,
		SpeedTreeWindAsset = 228,
		AnchoredJoint2D = 229,
		Joint2D = 230,
		SpringJoint2D = 231,
		DistanceJoint2D = 232,
		HingeJoint2D = 233,
		SliderJoint2D = 234,
		WheelJoint2D = 235,
		ClusterInputManager = 236,
		BaseVideoTexture = 237,
		NavMeshData = 238,
		AudioMixer = 240,
		AudioMixerController = 241,
		AudioMixerGroupController = 243,
		AudioMixerEffectController = 244,
		AudioMixerSnapshotController = 245,
		PhysicsUpdateBehaviour2D = 246,
		ConstantForce2D = 247,
		Effector2D = 248,
		AreaEffector2D = 249,
		PointEffector2D = 250,
		PlatformEffector2D = 251,
		SurfaceEffector2D = 252,
		BuoyancyEffector2D = 253,
		RelativeJoint2D = 254,
		FixedJoint2D = 255,
		FrictionJoint2D = 256,
		TargetJoint2D = 257,
		LightProbes_258 = 258,
		LightProbeProxyVolume = 259,
		SampleClip = 271,
		AudioMixerSnapshot = 272,
		AudioMixerGroup = 273,
		NScreenBridge = 280,
		AssetBundleManifest = 290,
		UnityAdsManager = 292,
		RuntimeInitializeOnLoadManager = 300,
		CloudWebServicesManager = 301,
		UnityAnalyticsManager = 303,
		CrashReportManager = 304,
		PerformanceReportingManager = 305,
		UnityConnectSettings = 310,
		AvatarMask_319 = 319,
		PlayableDirector = 320,
		VideoClip_327 = 327,
		VideoPlayer = 328,
		VideoClip_329 = 329,
		ParticleSystemForceField = 330,
		SpriteMask = 331,
		WorldAnchor = 362,
		OcclusionCullingData = 363,
		PrefabInstance = 1001,
		EditorExtensionImpl = 1002,
		AssetImporter = 1003,
		AssetDatabaseV1 = 1004,
		Mesh3DSImporter = 1005,
		TextureImporter = 1006,
		ShaderImporter = 1007,
		ComputeShaderImporter = 1008,
		AvatarMask_1011 = 1011,
		AvatarSkeletonMask = 1012,
		AudioImporter = 1020,
		HierarchyState = 1026,
		GUIDSerializer = 1027,
		AssetMetaData = 1028,
		DefaultAsset = 1029,
		DefaultImporter = 1030,
		TextScriptImporter = 1031,
		SceneAsset = 1032,
		NativeFormatImporter = 1034,
		MonoImporter = 1035,
		AssetServerCache = 1037,
		LibraryAssetImporter = 1038,
		ModelImporter = 1040,
		FBXImporter = 1041,
		TrueTypeFontImporter = 1042,
		MovieImporter = 1044,
		EditorBuildSettings = 1045,
		DDSImporter = 1046,
		InspectorExpandedState = 1048,
		AnnotationManager = 1049,
		PluginImporter = 1050,
		EditorUserBuildSettings = 1051,
		PVRImporter = 1052,
		ASTCImporter = 1053,
		KTXImporter = 1054,
		IHVImageFormatImporter = 1055,
		AnimatorStateTransition = 1101,
		AnimatorState = 1102,
		HumanTemplate = 1105,
		AnimatorStateMachine = 1107,
		PreviewAnimationClip = 1108,
		AnimatorTransition = 1109,
		SpeedTreeImporter = 1110,
		AnimatorTransitionBase = 1111,
		SubstanceImporter = 1112,
		LightmapParameters = 1113,
		LightingDataAsset = 1120,
		SketchUpImporter = 1124,
		BuildReport = 1125,
		PackedAssets = 1126,
		VideoClipImporter = 1127,
		StyleSheetImporter = 1128,
		TilemapCollider2D = 19719996,
		AssetImporterLog = 41386430,
		VFXRenderer = 73398921,
		SerializableManagedRefTestClass = 76251197,
		Grid = 156049354,
		ScenesUsingAssets = 156483287,
		ArticulationBody = 171741748,
		Preset = 181963792,
		EmptyObject = 277625683,
		IConstraint = 285090594,
		TestObjectWithSpecialLayoutOne = 293259124,
		AssemblyDefinitionReferenceImporter = 294290339,
		SiblingDerived = 334799969,
		TestObjectWithSerializedMapStringNonAlignedStruct = 342846651,
		SubDerived = 367388927,
		AssetImportInProgressProxy = 369655926,
		PluginBuildInfo = 382020655,
		MemorySettings = 387306366,
		EditorProjectAccess = 426301858,
		PrefabImporter = 468431735,
		TestObjectWithSerializedArray = 478637458,
		TestObjectWithSerializedAnimationCurve = 478637459,
		TilemapRenderer = 483693784,
		ScriptableCamera = 488575907,
		SpriteAtlasAsset = 612988286,
		SpriteAtlasDatabase = 638013454,
		AudioBuildInfo = 641289076,
		CachedSpriteAtlasRuntimeData = 644342135,
		RendererFake = 646504946,
		AssemblyDefinitionReferenceAsset = 662584278,
		BuiltAssetBundleInfoSet = 668709126,
		SpriteAtlas = 687078895,
		RayTracingShaderImporter = 747330370,
		PreviewImporter = 815301076,
		RayTracingShader = 825902497,
		LightingSettings = 850595691,
		PlatformModuleSetup = 877146078,
		VersionControlSettings = 890905787,
		CustomCollider2D = 893571522,
		AimConstraint = 895512359,
		VFXManager = 937362698,
		RuleSetFileAsset = 954905827,
		VisualEffectSubgraph = 994735392,
		VisualEffectSubgraphOperator = 994735403,
		VisualEffectSubgraphBlock = 994735404,
		Prefab = 1001480554,
		LocalizationImporter = 1027052791,
		Derived = 1091556383,
		PropertyModificationsTargetTestObject = 1111377672,
		ReferencesArtifactGenerator = 1114811875,
		AssemblyDefinitionAsset = 1152215463,
		SceneVisibilityState = 1154873562,
		LookAtConstraint = 1183024399,
		SpriteAtlasImporter = 1210832254,
		MultiArtifactTestImporter = 1223240404,
		GameObjectRecorder = 1268269756,
		LightingDataAssetParent = 1325145578,
		PresetManager = 1386491679,
		TestObjectWithSpecialLayoutTwo = 1392443030,
		StreamingManager = 1403656975,
		LowerResBlitTexture = 1480428607,
		VideoBuildInfo = 1521398425,
		StreamingController = 1542919678,
		RenderPassAttachment = 1571458007,
		TestObjectVectorPairStringBool = 1628831178,
		AndroidAssetPackImporter = 1736697216,
		GridLayout = 1742807556,
		AssemblyDefinitionImporter = 1766753193,
		ParentConstraint = 1773428102,
		RuleSetFileImporter = 1777034230,
		FakeComponent = 1803986026,
		PositionConstraint = 1818360608,
		RotationConstraint = 1818360609,
		ScaleConstraint = 1818360610,
		Tilemap = 1839735485,
		PackageManifest = 1896753125,
		PackageManifestImporter = 1896753126,
		TerrainLayer = 1953259897,
		SpriteShapeRenderer = 1971053207,
		NativeObjectType = 1977754360,
		TestObjectWithSerializedMapStringBool = 1981279845,
		SerializableManagedHost = 1995898324,
		VisualEffectAsset = 2058629509,
		VisualEffectImporter = 2058629510,
		VisualEffectResource = 2058629511,
		VisualEffectObject = 2059678085,
		VisualEffect = 2083052967,
		LocalizationAsset = 2083778819,
		ScriptedImporter = 2089858483,
		ShaderIncludeImporter = 2103361453,
		TilemapEditorUserSettings = 2126867596
	}

	public static class ClassIDTypeExtention
	{
		public static int ToInt(this ClassIDType _this)
		{
			return (int)_this;
		}

		/// <summary>
		/// Transform and RectTransform
		/// </summary>
		public static bool IsTransform(this ClassIDType _this)
		{
			return _this == ClassIDType.Transform || _this == ClassIDType.RectTransform;
		}

		/// <summary>
		/// Classes that inherit from LevelGameManager
		/// </summary>
		public static bool IsSceneSettings(this ClassIDType _this)
		{
			switch (_this)
			{
				case ClassIDType.OcclusionCullingSettings:
				case ClassIDType.RenderSettings:
				case ClassIDType.LightmapSettings:
				case ClassIDType.NavMeshSettings:
					return true;
			}
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Font/FontRenderingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Font
{
	public enum FontRenderingMode
	{
		/// <summary>
		/// Use Anti-Aliased Font rendering. When using dynamic fonts, this is the mode which is fastest in rendering font textures.
		/// </summary>
		Smooth = 0,
		/// <summary>
		/// Use Anti-Aliased Font rendering with hinting. This forces character lines to run along pixel boundaries, and generally produces.
		/// </summary>
		HintedSmooth,
		/// <summary>
		/// Use hinted font rendering without anti-aliasing. This is the crispest font rendering option, and may be most readable for small.
		/// </summary>
		HintedRaster,
		/// <summary>
		/// Use the OS default font rendering mode. This selects either FontRenderingMode.HintedSmooth or.
		/// </summary>
		OSDefault,
	}
}

```

`AssetRipper.Fundamentals/Classes/Font/FontStyle.cs`:

```cs
namespace AssetRipper.Core.Classes.Font
{
	public enum FontStyle
	{
		/// <summary>
		/// No special style is applied.
		/// </summary>
		Normal = 0,
		/// <summary>
		/// Bold style applied to your texts.
		/// </summary>
		Bold,
		/// <summary>
		/// Italic style applied to your texts.
		/// </summary>
		Italic,
		/// <summary>
		/// Bold and Italic styles applied to your texts.
		/// </summary>
		BoldAndItalic,
	}
}

```

`AssetRipper.Fundamentals/Classes/GUIText/TextAlignment.cs`:

```cs
namespace AssetRipper.Core.Classes.GUIText
{
	/// <summary>
	/// How multiline text should be aligned.
	/// </summary>
	public enum TextAlignment
	{
		/// <summary>
		/// Text lines are aligned on the left side.
		/// </summary>
		Left = 0,
		/// <summary>
		/// Text lines are centered.
		/// </summary>
		Center = 1,
		/// <summary>
		/// Text lines are aligned on the right side.
		/// </summary>
		Right = 2,
	}
}

```

`AssetRipper.Fundamentals/Classes/GUIText/TextAnchor.cs`:

```cs
namespace AssetRipper.Core.Classes.GUIText
{
	/// <summary>
	/// Where the anchor of the text is placed.
	/// </summary>
	public enum TextAnchor
	{
		/// <summary>
		/// Text is anchored in upper left corner.
		/// </summary>
		UpperLeft = 0,
		/// <summary>
		/// Text is anchored in upper side, centered horizontally.
		/// </summary>
		UpperCenter = 1,
		/// <summary>
		/// Text is anchored in upper right corner.
		/// </summary>
		UpperRight = 2,
		/// <summary>
		/// Text is anchored in left side, centered vertically.
		/// </summary>
		MiddleLeft = 3,
		/// <summary>
		/// Text is centered both horizontally and vertically.
		/// </summary>
		MiddleCenter = 4,
		/// <summary>
		/// Text is anchored in right side, centered vertically.
		/// </summary>
		MiddleRight = 5,
		/// <summary>
		/// Text is anchored in lower left corner.
		/// </summary>
		LowerLeft = 6,
		/// <summary>
		/// Text is anchored in lower side, centered horizontally.
		/// </summary>
		LowerCenter = 7,
		/// <summary>
		/// Text is anchored in lower right corner.
		/// </summary>
		LowerRight = 8,
	}
}

```

`AssetRipper.Fundamentals/Classes/Meta/Meta.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using DateTime = System.DateTime;


namespace AssetRipper.Core.Classes.Meta
{
	public class Meta
	{
		public Meta(UnityGUID guid, IUnityObjectBase importer) : this(guid, true, importer) { }

		public Meta(UnityGUID guid, bool hasLicense, IUnityObjectBase importer) : this(guid, hasLicense, false, importer) { }

		public Meta(UnityGUID guid, bool hasLicense, bool isFolder, IUnityObjectBase importer)
		{
			if (guid.IsZero)
			{
				throw new ArgumentNullException(nameof(guid));
			}

			GUID = guid;
			IsFolderAsset = isFolder;
			HasLicenseData = hasLicense;
			Importer = importer ?? throw new ArgumentNullException(nameof(importer));
		}

		public static int ToFileFormatVersion(UnityVersion version)
		{
#warning TODO:
			return 2;
		}

		public YamlDocument ExportYamlDocument(IExportContainer container)
		{
			YamlDocument document = new YamlDocument();
			YamlMappingNode root = document.CreateMappingRoot();
			root.Add(FileFormatVersionName, ToFileFormatVersion(container.ExportVersion));
			root.Add(GuidName, GUID.ExportYaml(container));
			if (IsFolderAsset)
			{
				root.Add(FolderAssetName, true);
			}
			if (HasLicenseData)
			{
				root.Add(TimeCreatedName, CurrentTick);
				root.Add(LicenseTypeName, "Free");
			}
			//if (Importer.IncludesImporter(container.ExportVersion)) //For now, assume true
			{
				root.Add(Importer.ClassID.ToString(), Importer.ExportYaml(container));
			}
			return document;
		}

		public UnityGUID GUID { get; }
		public bool IsFolderAsset { get; }
		public bool HasLicenseData { get; }
		public IUnityObjectBase Importer { get; }

		private long CurrentTick => (DateTime.Now.Ticks - 0x089f7ff5f7b58000) / 10000000;

		public const string FileFormatVersionName = "fileFormatVersion";
		public const string GuidName = "guid";
		public const string FolderAssetName = "folderAsset";
		public const string TimeCreatedName = "timeCreated";
		public const string LicenseTypeName = "licenseType";
	}
}

```

`AssetRipper.Fundamentals/Classes/Meta/MetaPtr.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Meta
{
	public sealed class MetaPtr : IYamlExportable
	{
		public MetaPtr(long fileID)
		{
			FileID = fileID;
			GUID = new();
			AssetType = new();
		}

		public MetaPtr(long fileID, UnityGUID guid, AssetType assetType)
		{
			FileID = fileID;
			GUID = guid;
			AssetType = assetType;
		}

		public MetaPtr(ClassIDType classID, AssetType assetType) : this(ExportIdHandler.GetMainExportID((uint)classID), UnityGUID.MissingReference, assetType) { }

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(FileIDName, FileID);
			if (!GUID.IsZero)
			{
				node.Add(GuidName, GUID.ExportYaml(container));
				node.Add(TypeName, (int)AssetType);
			}
			return node;
		}

		public static MetaPtr NullPtr { get; } = new MetaPtr(0);

		public long FileID { get; }
		public UnityGUID GUID { get; }
		public AssetType AssetType { get; }

		public const string FileIDName = "fileID";
		public const string GuidName = "guid";
		public const string TypeName = "type";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/BoneWeights4.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc
{
	/// <summary>
	/// BoneInfluence previously
	/// </summary>
	public sealed class BoneWeights4 : IAsset
	{
		public BoneWeights4() { }

		public BoneWeights4(float w0, float w1, float w2, float w3, int i0, int i1, int i2, int i3)
		{
			m_Weights = new float[4];
			m_BoneIndices = new int[4];
			Weight_0_ = w0;
			Weight_1_ = w1;
			Weight_2_ = w2;
			Weight_3_ = w3;
			BoneIndex_0_ = i0;
			BoneIndex_1_ = i1;
			BoneIndex_2_ = i2;
			BoneIndex_3_ = i3;
		}

		public void Read(AssetReader reader)
		{
			Weight_0_ = reader.ReadSingle();
			Weight_1_ = reader.ReadSingle();
			Weight_2_ = reader.ReadSingle();
			Weight_3_ = reader.ReadSingle();
			BoneIndex_0_ = reader.ReadInt32();
			BoneIndex_1_ = reader.ReadInt32();
			BoneIndex_2_ = reader.ReadInt32();
			BoneIndex_3_ = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Weight_0_);
			writer.Write(Weight_1_);
			writer.Write(Weight_2_);
			writer.Write(Weight_3_);
			writer.Write(BoneIndex_0_);
			writer.Write(BoneIndex_1_);
			writer.Write(BoneIndex_2_);
			writer.Write(BoneIndex_3_);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(Weight0Name, Weight_0_);
			node.Add(Weight1Name, Weight_1_);
			node.Add(Weight2Name, Weight_2_);
			node.Add(Weight3Name, Weight_3_);
			node.Add(BoneIndex0Name, BoneIndex_0_);
			node.Add(BoneIndex1Name, BoneIndex_1_);
			node.Add(BoneIndex2Name, BoneIndex_2_);
			node.Add(BoneIndex3Name, BoneIndex_3_);
			return node;
		}

		public float Weight_0_ { get => Weights[0]; set => Weights[0] = value; }
		public float Weight_1_ { get => Weights[1]; set => Weights[1] = value; }
		public float Weight_2_ { get => Weights[2]; set => Weights[2] = value; }
		public float Weight_3_ { get => Weights[3]; set => Weights[3] = value; }
		public int BoneIndex_0_ { get => BoneIndices[0]; set => BoneIndices[0] = value; }
		public int BoneIndex_1_ { get => BoneIndices[1]; set => BoneIndices[1] = value; }
		public int BoneIndex_2_ { get => BoneIndices[2]; set => BoneIndices[2] = value; }
		public int BoneIndex_3_ { get => BoneIndices[3]; set => BoneIndices[3] = value; }
		public float[] Weights
		{
			get
			{
				if (m_Weights == null)
				{
					m_Weights = new float[4];
				}

				return m_Weights;
			}
		}
		public int[] BoneIndices
		{
			get
			{
				if (m_BoneIndices == null)
				{
					m_BoneIndices = new int[4];
				}

				return m_BoneIndices;
			}
		}
		private float[]? m_Weights;
		private int[]? m_BoneIndices;


		public const string Weight0Name = "weight[0]";
		public const string Weight1Name = "weight[1]";
		public const string Weight2Name = "weight[2]";
		public const string Weight3Name = "weight[3]";
		public const string BoneIndex0Name = "boneIndex[0]";
		public const string BoneIndex1Name = "boneIndex[1]";
		public const string BoneIndex2Name = "boneIndex[2]";
		public const string BoneIndex3Name = "boneIndex[3]";

		public const int Dimention = 4;
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/ArmType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum ArmType
	{
		LeftHand = 0,
		RightHand = 1,

		Last,
	}

	public static class ArmTypeExtensions
	{
		public static BoneType ToBoneType(this ArmType _this)
		{
			return _this switch
			{
				ArmType.LeftHand => BoneType.LeftHand,
				ArmType.RightHand => BoneType.RightHand,
				_ => throw new ArgumentException(_this.ToString()),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/BoneType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum BoneType
	{
		Hips = 0,
		LeftUpperLeg = 1,
		RightUpperLeg = 2,
		LeftLowerLeg = 3,
		RightLowerLeg = 4,
		LeftFoot = 5,
		RightFoot = 6,
		Spine = 7,
		Chest = 8,
		UpperChest = 9,
		Neck = 10,
		Head = 11,
		LeftShoulder = 12,
		RightShoulder = 13,
		LeftUpperArm = 14,
		RightUpperArm = 15,
		LeftLowerArm = 16,
		RightLowerArm = 17,
		LeftHand = 18,
		RightHand = 19,
		LeftToes = 20,
		RightToes = 21,
		LeftEye = 22,
		RightEye = 23,
		Jaw = 24,

		Last,
	}

	public static class BoneTypeExtensions
	{
		/// <summary>
		/// 5.6.0 and greater
		/// </summary>
		public static bool IsIncludeUpperChest(UnityVersion version) => version.IsGreaterEqual(5, 6);

		public static BoneType Update(this BoneType _this, UnityVersion version)
		{
			if (!IsIncludeUpperChest(version))
			{
				if (_this >= BoneType.UpperChest)
				{
					_this++;
				}
			}
			return _this;
		}

		public static string ToAttributeString(this BoneType _this)
		{
			if (_this < BoneType.Last)
			{
				return _this.ToString();
			}
			throw new ArgumentException(_this.ToString());
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/FingerDoFType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum FingerDoFType
	{
		_1Stretched = 0,
		Spread = 1,
		_2Stretched = 2,
		_3Stretched = 3,

		Last,
	}

	public static class FingerDoFTypeExtensions
	{
		public static string ToAttributeString(this FingerDoFType _this)
		{
			return _this switch
			{
				FingerDoFType._1Stretched => "1 Stretched",
				FingerDoFType.Spread => "Spread",
				FingerDoFType._2Stretched => "2 Stretched",
				FingerDoFType._3Stretched => "3 Stretched",
				_ => throw new ArgumentException(_this.ToString()),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/FingerType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum FingerType
	{
		Thumb = 0,
		Index = 1,
		Middle = 2,
		Ring = 3,
		Little = 4,

		Last,
	}

	public static class FingerTypeExtensions
	{
		public static string ToAttributeString(this FingerType _this)
		{
			if (_this < FingerType.Last)
			{
				return _this.ToString();
			}
			throw new ArgumentException(_this.ToString());
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/HumanBodyBones.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Animation/ScriptBindings/Avatar.bindings.cs"/>
	/// </summary>
	public enum HumanBodyBones
	{
		Hips = 0,
		LeftUpperLeg = 1,
		RightUpperLeg = 2,
		LeftLowerLeg = 3,
		RightLowerLeg = 4,
		LeftFoot = 5,
		RightFoot = 6,
		Spine = 7,
		Chest = 8,
		Neck = 9,
		Head = 10,
		LeftShoulder = 11,
		RightShoulder = 12,
		LeftUpperArm = 13,
		RightUpperArm = 14,
		LeftLowerArm = 15,
		RightLowerArm = 16,
		LeftHand = 17,
		RightHand = 18,
		LeftToes = 19,
		RightToes = 20,
		LeftEye = 21,
		RightEye = 22,
		Jaw = 23,
		LeftThumbProximal = 24,
		LeftThumbIntermediate = 25,
		LeftThumbDistal = 26,
		LeftIndexProximal = 27,
		LeftIndexIntermediate = 28,
		LeftIndexDistal = 29,
		LeftMiddleProximal = 30,
		LeftMiddleIntermediate = 31,
		LeftMiddleDistal = 32,
		LeftRingProximal = 33,
		LeftRingIntermediate = 34,
		LeftRingDistal = 35,
		LeftLittleProximal = 36,
		LeftLittleIntermediate = 37,
		LeftLittleDistal = 38,
		RightThumbProximal = 39,
		RightThumbIntermediate = 40,
		RightThumbDistal = 41,
		RightIndexProximal = 42,
		RightIndexIntermediate = 43,
		RightIndexDistal = 44,
		RightMiddleProximal = 45,
		RightMiddleIntermediate = 46,
		RightMiddleDistal = 47,
		RightRingProximal = 48,
		RightRingIntermediate = 49,
		RightRingDistal = 50,
		RightLittleProximal = 51,
		RightLittleIntermediate = 52,
		RightLittleDistal = 53,
		UpperChest = 54,

		LastBone = 55,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/LimbType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum LimbType
	{
		LeftFoot = 0,
		RightFoot = 1,
		LeftHand = 2,
		RightHand = 3,

		Last,
	}

	public static class LimbTypeExtensions
	{
		public static BoneType ToBoneType(this LimbType _this)
		{
			return _this switch
			{
				LimbType.LeftFoot => BoneType.LeftFoot,
				LimbType.RightFoot => BoneType.RightFoot,
				LimbType.LeftHand => BoneType.LeftHand,
				LimbType.RightHand => BoneType.RightHand,
				_ => throw new ArgumentException(_this.ToString()),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/MuscleType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum MuscleType
	{
		SpineFrontBack = 0,
		SpineLeftRight = 1,
		SpineTwistLeftRight = 2,
		ChestFrontBack = 3,
		ChestLeftRight = 4,
		ChestTwistLeftRight = 5,
		UpperchestFrontBack = 6,
		UpperchestLeftRight = 7,
		UpperchestTwisLeftRight = 8,
		NeckNodDownUp = 9,
		NeckTiltLeftRight = 10,
		NeckTurnLeftRight = 11,
		HeadNodDownUp = 12,
		HeadTiltLeftRight = 13,
		HeadTurnLeftRight = 14,
		LeftEyeDownUp = 15,
		LeftEyeInOut = 16,
		RightEyeDownUp = 17,
		RightEyeInOut = 18,
		JawClose = 19,
		JawLeftRight = 20,
		LeftUpperLegFrontBack = 21,
		LeftUpperLegInOut = 22,
		LeftUpperLegTwistInOut = 23,
		LeftLowerLegStretch = 24,
		LeftLowerLegTwistInOut = 25,
		LeftFootUpDown = 26,
		LeftFootTwistInOut = 27,
		LeftToesUpDown = 28,
		RightUpperLegFrontBack = 29,
		RightUpperLegInOut = 30,
		RightUpperLegTwistInOut = 31,
		RightLowerLegStretch = 32,
		RightLowerLegTwistInOut = 33,
		RightFootUpDown = 34,
		RightFootTwistInOut = 35,
		RightToesUpDown = 36,
		LeftShoulderDownUp = 37,
		LeftShoulderFrontBack = 38,
		LeftArmDownUp = 39,
		LeftArmFrontBack = 40,
		LeftArmTwistInOut = 41,
		LeftForearmStretch = 42,
		LeftForearmTwistInOut = 43,
		LeftHandDownUp = 44,
		LeftHandInOut = 45,
		RightShoulderDownUp = 46,
		RightShoulderFrontBack = 47,
		RightArmDownUp = 48,
		RightArmFrontBack = 49,
		RightArmTwistInOut = 50,
		RightForearmStretch = 51,
		RightForearmTwistInOut = 52,
		RightHandDownUp = 53,
		RightHandInOut = 54,

		Last,
	}

	public static class MuscleTypeExtensions
	{
		/// <summary>
		/// 5.6.0 and greater
		/// </summary>
		public static bool IsIncludeUpperChest(UnityVersion version) => BoneTypeExtensions.IsIncludeUpperChest(version);

		public static MuscleType Update(this MuscleType _this, UnityVersion version)
		{
			if (!IsIncludeUpperChest(version))
			{
				if (_this >= MuscleType.UpperchestFrontBack)
				{
					_this += 3;
				}
			}
			return _this;
		}

		public static string ToAttributeString(this MuscleType _this)
		{
			return _this switch
			{
				MuscleType.SpineFrontBack => "Spine Front-Back",
				MuscleType.SpineLeftRight => "Spine Left-Right",
				MuscleType.SpineTwistLeftRight => "Spine Twist Left-Right",
				MuscleType.ChestFrontBack => "Chest Front-Back",
				MuscleType.ChestLeftRight => "Chest Left-Right",
				MuscleType.ChestTwistLeftRight => "Chest Twist Left-Right",
				MuscleType.UpperchestFrontBack => "UpperChest Front-Back",
				MuscleType.UpperchestLeftRight => "UpperChest Left-Right",
				MuscleType.UpperchestTwisLeftRight => "UpperChest Twist Left-Right",
				MuscleType.NeckNodDownUp => "Neck Nod Down-Up",
				MuscleType.NeckTiltLeftRight => "Neck Tilt Left-Right",
				MuscleType.NeckTurnLeftRight => "Neck Turn Left-Right",
				MuscleType.HeadNodDownUp => "Head Nod Down-Up",
				MuscleType.HeadTiltLeftRight => "Head Tilt Left-Right",
				MuscleType.HeadTurnLeftRight => "Head Turn Left-Right",
				MuscleType.LeftEyeDownUp => "Left Eye Down-Up",
				MuscleType.LeftEyeInOut => "Left Eye In-Out",
				MuscleType.RightEyeDownUp => "Right Eye Down-Up",
				MuscleType.RightEyeInOut => "Right Eye In-Out",
				MuscleType.JawClose => "Jaw Close",
				MuscleType.JawLeftRight => "Jaw Left-Right",
				MuscleType.LeftUpperLegFrontBack => "Left Upper Leg Front-Back",
				MuscleType.LeftUpperLegInOut => "Left Upper Leg In-Out",
				MuscleType.LeftUpperLegTwistInOut => "Left Upper Leg Twist In-Out",
				MuscleType.LeftLowerLegStretch => "Left Lower Leg Stretch",
				MuscleType.LeftLowerLegTwistInOut => "Left Lower Leg Twist In-Out",
				MuscleType.LeftFootUpDown => "Left Foot Up-Down",
				MuscleType.LeftFootTwistInOut => "Left Foot Twist In-Out",
				MuscleType.LeftToesUpDown => "Left Toes Up-Down",
				MuscleType.RightUpperLegFrontBack => "Right Upper Leg Front-Back",
				MuscleType.RightUpperLegInOut => "Right Upper Leg In-Out",
				MuscleType.RightUpperLegTwistInOut => "Right Upper Leg Twist In-Out",
				MuscleType.RightLowerLegStretch => "Right Lower Leg Stretch",
				MuscleType.RightLowerLegTwistInOut => "Right Lower Leg Twist In-Out",
				MuscleType.RightFootUpDown => "Right Foot Up-Down",
				MuscleType.RightFootTwistInOut => "Right Foot Twist In-Out",
				MuscleType.RightToesUpDown => "Right Toes Up-Down",
				MuscleType.LeftShoulderDownUp => "Left Shoulder Down-Up",
				MuscleType.LeftShoulderFrontBack => "Left Shoulder Front-Back",
				MuscleType.LeftArmDownUp => "Left Arm Down-Up",
				MuscleType.LeftArmFrontBack => "Left Arm Front-Back",
				MuscleType.LeftArmTwistInOut => "Left Arm Twist In-Out",
				MuscleType.LeftForearmStretch => "Left Forearm Stretch",
				MuscleType.LeftForearmTwistInOut => "Left Forearm Twist In-Out",
				MuscleType.LeftHandDownUp => "Left Hand Down-Up",
				MuscleType.LeftHandInOut => "Left Hand In-Out",
				MuscleType.RightShoulderDownUp => "Right Shoulder Down-Up",
				MuscleType.RightShoulderFrontBack => "Right Shoulder Front-Back",
				MuscleType.RightArmDownUp => "Right Arm Down-Up",
				MuscleType.RightArmFrontBack => "Right Arm Front-Back",
				MuscleType.RightArmTwistInOut => "Right Arm Twist In-Out",
				MuscleType.RightForearmStretch => "Right Forearm Stretch",
				MuscleType.RightForearmTwistInOut => "Right Forearm Twist In-Out",
				MuscleType.RightHandDownUp => "Right Hand Down-Up",
				MuscleType.RightHandInOut => "Right Hand In-Out",
				_ => throw new ArgumentException(_this.ToString()),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/PhalangeType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum PhalangeType
	{
		Proximal = 0,
		Intermediate = 1,
		Distal = 2,

		Last,
	}

	public static class PhalangeTypeExtensions
	{
		public static string ToAttributeString(this PhalangeType _this)
		{
			if (_this < PhalangeType.Last)
			{
				return _this.ToString();
			}
			throw new ArgumentException(_this.ToString());
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Bones/TDoFBoneType.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Bones
{
	public enum TDoFBoneType
	{
		Spine = 0,
		Chest = 1,
		UpperChest = 2,
		Neck = 3,
		Head = 4,
		LeftUpperLeg = 5,
		LeftLowerLeg = 6,
		LeftFoot = 7,
		LeftToes = 8,
		RightUpperLeg = 9,
		RightLowerLeg = 10,
		RightFoot = 11,
		RightToes = 12,
		LeftShoulder = 13,
		LeftUpperArm = 14,
		LeftLowerArm = 15,
		LeftHand = 16,
		RightShoulder = 17,
		RightUpperArm = 18,
		RightLowerArm = 19,
		RightHand = 20,

		Last,
	}

	public static class TDoFBoneTypeExtensions
	{
		/// <summary>
		/// 5.6.0 and greater
		/// </summary>
		public static bool IsIncludeUpperChest(UnityVersion version) => BoneTypeExtensions.IsIncludeUpperChest(version);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool IsIncludeHead(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool IsIncludeLeftLowerLeg(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool IsIncludeRightLowerLeg(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool IsIncludeLeftUpperArm(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool IsIncludeRightUpperArm(UnityVersion version) => version.IsGreaterEqual(2017, 3);

		public static TDoFBoneType Update(this TDoFBoneType _this, UnityVersion version)
		{
			if (!IsIncludeUpperChest(version))
			{
				if (_this >= TDoFBoneType.UpperChest)
				{
					_this++;
				}
			}
			if (!IsIncludeHead(version))
			{
				if (_this >= TDoFBoneType.Head)
				{
					_this++;
				}
			}
			if (!IsIncludeLeftLowerLeg(version))
			{
				if (_this >= TDoFBoneType.LeftLowerLeg)
				{
					_this += 3;
				}
			}
			if (!IsIncludeRightLowerLeg(version))
			{
				if (_this >= TDoFBoneType.RightLowerLeg)
				{
					_this += 3;
				}
			}
			if (!IsIncludeLeftUpperArm(version))
			{
				if (_this >= TDoFBoneType.LeftUpperArm)
				{
					_this += 3;
				}
			}
			if (!IsIncludeRightUpperArm(version))
			{
				if (_this >= TDoFBoneType.RightUpperArm)
				{
					_this += 3;
				}
			}
			return _this;
		}

		public static BoneType ToBoneType(this TDoFBoneType _this)
		{
			return _this switch
			{
				TDoFBoneType.Spine => BoneType.Spine,
				TDoFBoneType.Chest => BoneType.Chest,
				TDoFBoneType.UpperChest => BoneType.UpperChest,
				TDoFBoneType.Neck => BoneType.Neck,
				TDoFBoneType.Head => BoneType.Head,
				TDoFBoneType.LeftUpperLeg => BoneType.LeftUpperLeg,
				TDoFBoneType.LeftLowerLeg => BoneType.LeftLowerLeg,
				TDoFBoneType.LeftFoot => BoneType.LeftFoot,
				TDoFBoneType.LeftToes => BoneType.LeftToes,
				TDoFBoneType.RightUpperLeg => BoneType.RightUpperLeg,
				TDoFBoneType.RightLowerLeg => BoneType.RightLowerLeg,
				TDoFBoneType.RightFoot => BoneType.RightFoot,
				TDoFBoneType.RightToes => BoneType.RightToes,
				TDoFBoneType.LeftShoulder => BoneType.LeftShoulder,
				TDoFBoneType.LeftUpperArm => BoneType.LeftUpperArm,
				TDoFBoneType.LeftLowerArm => BoneType.LeftLowerArm,
				TDoFBoneType.LeftHand => BoneType.LeftHand,
				TDoFBoneType.RightShoulder => BoneType.RightShoulder,
				TDoFBoneType.RightUpperArm => BoneType.RightUpperArm,
				TDoFBoneType.RightLowerArm => BoneType.RightLowerArm,
				TDoFBoneType.RightHand => BoneType.RightHand,
				_ => throw new ArgumentException(_this.ToString()),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/BuildTargetGroup.cs`:

```cs
using AssetRipper.Core.Parser.Files;

namespace AssetRipper.Core.Classes.Misc
{
	public enum BuildTargetGroup
	{
		/// <summary>
		/// Unknown target.
		/// </summary>
		Unknown = 0,
		/// <summary>
		/// Mac/PC standalone target.
		/// </summary>
		Standalone = 1,
		/// <summary>
		/// Mac/PC webplayer target.
		/// </summary>
		WebPlayer = 2,
		Wii = 3,
		/// <summary>
		/// Apple iOS target.
		/// </summary>
		iPhone = 4,
		/// <summary>
		/// Apple iOS target.
		/// </summary>
		iOS = 4,
		PS3 = 5,
		XBOX360 = 6,
		/// <summary>
		/// Android target.
		/// </summary>
		Android = 7,
		GLESEmu = 9,
		/// <summary>
		/// Google Native Client
		/// </summary>
		NaCl = 11,
		FlashPlayer = 12,
		/// <summary>
		/// WebGL.
		/// </summary>
		WebGL = 13,
		/// <summary>
		/// Windows Store Apps target.
		/// </summary>
		WSA = 14,
		Metro = 14,
		WP8 = 15,
		BlackBerry = 16,
		/// <summary>
		/// Samsung Tizen target.
		/// </summary>
		Tizen = 17,
		/// <summary>
		/// Sony PS Vita target.
		/// </summary>
		PSP2 = 18,
		/// <summary>
		/// Sony Playstation 4 target.
		/// </summary>
		PS4 = 19,
		PSM = 20,
		/// <summary>
		/// Microsoft Xbox One target.
		/// </summary>
		XboxOne = 21,
		SamsungTV = 22,
		/// <summary>
		/// Nintendo 3DS target.
		/// </summary>
		N3DS = 23,
		/// <summary>
		/// Nintendo Wii U target.
		/// </summary>
		WiiU = 24,
		/// <summary>
		/// Apple's tvOS target.
		/// </summary>
		tvOS = 25,
		/// <summary>
		/// Facebook target.
		/// </summary>
		Facebook = 26,
		/// <summary>
		/// Nintendo Switch target.
		/// </summary>
		Switch = 27,
	}

	public static class BuildTargetGroupExtensions
	{
		public static BuildTargetGroup PlatformToBuildGroup(this BuildTarget _this)
		{
			switch (_this)
			{
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXPPC:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXIntel64:
					return BuildTargetGroup.Standalone;

				case BuildTarget.WebPlayerLZMA:
				case BuildTarget.WebPlayerLZMAStreamed:
					return BuildTargetGroup.WebPlayer;

				case BuildTarget.Wii:
					return BuildTargetGroup.Wii;

				case BuildTarget.iOS:
					return BuildTargetGroup.iOS;

				case BuildTarget.PS3:
					return BuildTargetGroup.PS3;

				case BuildTarget.XBox360:
					return BuildTargetGroup.XBOX360;

				case BuildTarget.Android:
					return BuildTargetGroup.Android;

				case BuildTarget.WinGLESEmu:
				case BuildTarget.WinGLES20Emu:
					return BuildTargetGroup.GLESEmu;

				case BuildTarget.GoogleNaCl:
					return BuildTargetGroup.NaCl;

				case BuildTarget.Flash:
					return BuildTargetGroup.FlashPlayer;

				case BuildTarget.WebGL:
					return BuildTargetGroup.WebGL;

				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerARM:
					return BuildTargetGroup.WSA;

				case BuildTarget.WP8Player:
					return BuildTargetGroup.WP8;

				case BuildTarget.BB10:
					return BuildTargetGroup.BlackBerry;

				case BuildTarget.Tizen:
					return BuildTargetGroup.Tizen;

				case BuildTarget.PSP2:
					return BuildTargetGroup.PSP2;

				case BuildTarget.PS4:
					return BuildTargetGroup.PS4;

				case BuildTarget.PSM:
					return BuildTargetGroup.PSM;

				case BuildTarget.XboxOne:
					return BuildTargetGroup.XboxOne;

				case BuildTarget.SamsungTV:
					return BuildTargetGroup.SamsungTV;

				case BuildTarget.N3DS:
					return BuildTargetGroup.N3DS;

				case BuildTarget.WiiU:
					return BuildTargetGroup.WiiU;

				case BuildTarget.tvOS:
					return BuildTargetGroup.tvOS;

				case BuildTarget.Switch:
					return BuildTargetGroup.Switch;

				default:
					throw new NotSupportedException($"Platform {_this} is not supported.");
			}
		}

		public static string ToExportString(this BuildTargetGroup _this)
		{
			return _this switch
			{
				BuildTargetGroup.Unknown => "Unknown",
				BuildTargetGroup.Standalone => "Standalone",
				BuildTargetGroup.WebPlayer => "WebPlayer",
				BuildTargetGroup.Wii => "Wii",
				BuildTargetGroup.iOS => "iPhone",
				BuildTargetGroup.PS3 => "PS3",
				BuildTargetGroup.XBOX360 => "XBOX360",
				BuildTargetGroup.Android => "Android",
				BuildTargetGroup.GLESEmu => "GLESEmu",
				BuildTargetGroup.NaCl => "NaCl",
				BuildTargetGroup.FlashPlayer => "FlashPlayer",
				BuildTargetGroup.WebGL => "WebGL",
				BuildTargetGroup.Metro => "Windows Store Apps",
				BuildTargetGroup.WP8 => "WP8",
				BuildTargetGroup.BlackBerry => "BlackBerry",
				BuildTargetGroup.Tizen => "Tizen",
				BuildTargetGroup.PSP2 => "PSP2",
				BuildTargetGroup.PS4 => "PS4",
				BuildTargetGroup.PSM => "PSM",
				BuildTargetGroup.XboxOne => "XboxOne",
				BuildTargetGroup.SamsungTV => "SamsungTV",
				BuildTargetGroup.N3DS => "Nintendo 3DS",
				BuildTargetGroup.WiiU => "WiiU",
				BuildTargetGroup.tvOS => "tvOS",
				BuildTargetGroup.Facebook => "Facebook",
				BuildTargetGroup.Switch => "Nintendo Switch",
				_ => throw new NotSupportedException($"Value: {_this}"),
			};
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Float.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;

using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc
{
	public sealed class Float : IAsset, IYamlExportable
	{
		public Float() { }

		public Float(float value)
		{
			Value = value;
		}

		public static implicit operator Float(float value)
		{
			return new Float(value);
		}

		public static implicit operator float(Float value)
		{
			return value.Value;
		}

		public void Read(AssetReader reader)
		{
			Value = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Value);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			return new YamlScalarNode(Value);
		}

		public override bool Equals(object? obj)
		{
			if (obj is Float f)
			{
				return Value == f.Value;
			}

			return false;
		}

		public override int GetHashCode()
		{
			return Value.GetHashCode();
		}

		public float Value { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Hash128.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Parser.Files.BundleFile.IO;
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using AssetRipper.Core.Project;
using AssetRipper.IO.Endian;
using AssetRipper.Yaml;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.Classes.Misc
{
	public sealed class Hash128 : IAsset, ISerializedReadable, ISerializedWritable, IBundleReadable, IEquatable<Hash128>
	{
		public Hash128() { }

		public Hash128(uint v) : this(v, 0, 0, 0) { }

		public Hash128(uint v0, uint v1, uint v2, uint v3)
		{
			Data0 = v0;
			Data1 = v1;
			Data2 = v2;
			Data3 = v3;
		}

		public Hash128(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			if (data.Length != 16)
			{
				throw new ArgumentException("Length must be exactly 16", nameof(data));
			}

			Data0 = BitConverter.ToUInt32(data, 0);
			Data1 = BitConverter.ToUInt32(data, 4);
			Data2 = BitConverter.ToUInt32(data, 8);
			Data3 = BitConverter.ToUInt32(data, 12);
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(5))
			{
				return 2;
			}
			return 1;
		}

		public void Read(BundleReader reader)
		{
			Read((EndianReader)reader);
		}

		public void Read(SerializedReader reader)
		{
			Read((EndianReader)reader);
		}

		public void Read(AssetReader reader)
		{
			Read((EndianReader)reader);
		}

		public void Read(EndianReader reader)
		{
			Data0 = reader.ReadUInt32();
			Data1 = reader.ReadUInt32();
			Data2 = reader.ReadUInt32();
			Data3 = reader.ReadUInt32();
		}

		public void Write(SerializedWriter writer)
		{
			Write((EndianWriter)writer);
		}

		public void Write(AssetWriter writer)
		{
			Write((EndianWriter)writer);
		}

		public void Write(EndianWriter writer)
		{
			writer.Write(Data0);
			writer.Write(Data1);
			writer.Write(Data2);
			writer.Write(Data3);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			if (ToSerializedVersion(container.Version) > 1)
			{
				node.Add(HashName, $"{Data0:x8}{Data1:x8}{Data2:x8}{Data3:x8}");
			}
			else
			{
				node.Add(Bytes0Name, (byte)((Data0 & 0x000000FF) >> 0));
				node.Add(Bytes1Name, (byte)((Data0 & 0x0000FF00) >> 8));
				node.Add(Bytes2Name, (byte)((Data0 & 0x00FF0000) >> 16));
				node.Add(Bytes3Name, (byte)((Data0 & 0xFF000000) >> 24));
				node.Add(Bytes4Name, (byte)((Data1 & 0x000000FF) >> 0));
				node.Add(Bytes5Name, (byte)((Data1 & 0x0000FF00) >> 8));
				node.Add(Bytes6Name, (byte)((Data1 & 0x00FF0000) >> 16));
				node.Add(Bytes7Name, (byte)((Data1 & 0xFF000000) >> 24));
				node.Add(Bytes8Name, (byte)((Data2 & 0x000000FF) >> 0));
				node.Add(Bytes9Name, (byte)((Data2 & 0x0000FF00) >> 8));
				node.Add(Bytes10Name, (byte)((Data2 & 0x00FF0000) >> 16));
				node.Add(Bytes11Name, (byte)((Data2 & 0xFF000000) >> 24));
				node.Add(Bytes12Name, (byte)((Data3 & 0x000000FF) >> 0));
				node.Add(Bytes13Name, (byte)((Data3 & 0x0000FF00) >> 8));
				node.Add(Bytes14Name, (byte)((Data3 & 0x00FF0000) >> 16));
				node.Add(Bytes15Name, (byte)((Data3 & 0xFF000000) >> 24));
			}
			return node;
		}

		public override bool Equals([NotNullWhen(true)] object? obj)
		{
			if (obj is Hash128 hash)
			{
				return Equals(hash);
			}
			else
			{
				return false;
			}
		}

		public bool Equals(Hash128? other)
		{
			return other is not null && this.Data0 == other.Data0 && this.Data1 == other.Data1 && this.Data2 == other.Data2 && this.Data3 == other.Data3;
		}

		public static bool operator ==(Hash128 left, Hash128 right) => left.Equals(right);

		public static bool operator !=(Hash128 left, Hash128 right) => !left.Equals(right);

		public override int GetHashCode()
		{
			int hash = 311;
			unchecked
			{
				hash = hash + (709 * Data0.GetHashCode());
				hash = (hash * 443) + Data1.GetHashCode();
				hash = (hash * 269) + Data2.GetHashCode();
				hash = (hash * 653) + Data3.GetHashCode();
			}
			return hash;
		}

		public override string ToString()
		{
			UnityGUID guid = new UnityGUID(Data0, Data1, Data2, Data3);
			return guid.ToString();
		}

		public uint Data0 { get; set; }
		public uint Data1 { get; set; }
		public uint Data2 { get; set; }
		public uint Data3 { get; set; }

		public const string Bytes0Name = "bytes[0]";
		public const string Bytes1Name = "bytes[1]";
		public const string Bytes2Name = "bytes[2]";
		public const string Bytes3Name = "bytes[3]";
		public const string Bytes4Name = "bytes[4]";
		public const string Bytes5Name = "bytes[5]";
		public const string Bytes6Name = "bytes[6]";
		public const string Bytes7Name = "bytes[7]";
		public const string Bytes8Name = "bytes[8]";
		public const string Bytes9Name = "bytes[9]";
		public const string Bytes10Name = "bytes[10]";
		public const string Bytes11Name = "bytes[11]";
		public const string Bytes12Name = "bytes[12]";
		public const string Bytes13Name = "bytes[13]";
		public const string Bytes14Name = "bytes[14]";
		public const string Bytes15Name = "bytes[15]";
		public const string HashName = "Hash";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/KeyframeTpl/KeyframeTpl.cs`:

```cs
using AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.KeyframeTpl
{
	public sealed class KeyframeTpl<T> : IAsset, IEquatable<KeyframeTpl<T>> where T : IAsset, new()
	{
		public KeyframeTpl() { }

		public KeyframeTpl(float time, T value, T weight) : this(time, value, new(), new(), weight)
		{
			// this enum member is version agnostic
			TangentMode = KeyframeTpl.TangentMode.TangentMode.FreeSmooth.ToTangent(UnityVersion.MinVersion);
		}

		public KeyframeTpl(float time, T value, T inSlope, T outSlope, T weight)
		{
			Time = time;
			Value = value;
			InSlope = inSlope;
			OutSlope = outSlope;
			// this enum member is version agnostic
			TangentMode = KeyframeTpl.TangentMode.TangentMode.FreeFree.ToTangent(UnityVersion.MinVersion);
			WeightedMode = WeightedMode.None;
			InWeight = weight;
			OutWeight = weight;
		}

		/// <summary>
		/// Makes a shallow clone
		/// </summary>
		/// <returns></returns>
		public KeyframeTpl<T> Clone()
		{
			KeyframeTpl<T> instance = new();
			instance.Time = Time;
			instance.Value = Value;
			instance.WeightedMode = WeightedMode;
			instance.InWeight = InWeight;
			instance.OutWeight = OutWeight;
			instance.InSlope = InSlope;
			instance.OutSlope = OutSlope;
			instance.TangentMode = TangentMode;
			return instance;
		}

		public void Read(AssetReader reader)
		{
			Time = reader.ReadSingle();
			Value = reader.ReadAsset<T>();
			InSlope = reader.ReadAsset<T>();
			OutSlope = reader.ReadAsset<T>();
			if (HasTangentMode(reader.Version, reader.Flags))
			{
				TangentMode = reader.ReadInt32();
			}
			if (HasWeightedMode(reader.Version))
			{
				WeightedMode = (WeightedMode)reader.ReadInt32();
				InWeight = reader.ReadAsset<T>();
				OutWeight = reader.ReadAsset<T>();
			}
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Time);
			Value.Write(writer);
			InSlope.Write(writer);
			OutSlope.Write(writer);
			if (HasTangentMode(writer.Version, writer.Flags))
			{
				writer.Write(TangentMode);
			}
			if (HasWeightedMode(writer.Version))
			{
				writer.Write((int)WeightedMode);
				InWeight.Write(writer);
				OutWeight.Write(writer);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			node.Add(TimeName, Time);
			node.Add(ValueName, Value.ExportYaml(container));
			node.Add(InSlopeName, InSlope.ExportYaml(container));
			node.Add(OutSlopeName, OutSlope.ExportYaml(container));
			if (HasTangentMode(container.ExportVersion, container.ExportFlags))
			{
				node.Add(TangentModeName, TangentMode);
			}
			if (HasWeightedMode(container.ExportVersion))
			{
				node.Add(WeightedModeName, (int)WeightedMode);
				node.Add(InWeightName, InWeight.ExportYaml(container));
				node.Add(OutWeightName, OutWeight.ExportYaml(container));
			}
			return node;
		}

		public TangentMode.TangentMode GetTangentMode(UnityVersion version)
		{
			if (TangentModeExtensions.TangentMode5Relevant(version))
			{
				return ((TangentMode5)TangentMode).ToTangentMode();
			}
			else
			{
				return ((TangentMode2)TangentMode).ToTangentMode();
			}
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(2018))
			{
				// unknown conversion
				return 3;
			}
			else if (TangentModeExtensions.TangentMode5Relevant(version))
			{
				// TangentMode enum has been changed
				return 2;
			}
			else
			{
				return 1;
			}
		}

		/// <summary>
		/// 2.1.0 and greater and Not Release
		/// </summary>
		public static bool HasTangentMode(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2, 1) && !flags.IsRelease();
		/// <summary>
		/// 2018.1 and greater
		/// </summary>
		public static bool HasWeightedMode(UnityVersion version) => version.IsGreaterEqual(2018);
		/// <summary>
		/// 2018.1 and greater
		/// </summary>
		public static bool HasInWeight(UnityVersion version) => version.IsGreaterEqual(2018);
		/// <summary>
		/// 2018.1 and greater
		/// </summary>
		public static bool HasOutWeight(UnityVersion version) => version.IsGreaterEqual(2018);

		public override bool Equals(object? obj)
		{
			if (obj is KeyframeTpl<T> keyframe)
			{
				return Equals(keyframe);
			}
			else
			{
				return false;
			}
		}

		public override int GetHashCode()
		{
			return 0;
		}

		public bool Equals(KeyframeTpl<T>? other)
		{
			return
				other is not null &&
				Time.Equals(other.Time) &&
				TangentMode.Equals(other.TangentMode) &&
				WeightedMode.Equals(other.WeightedMode) &&
				Value.Equals(other.Value) &&
				InSlope.Equals(other.InSlope) &&
				OutSlope.Equals(other.OutSlope) &&
				InWeight.Equals(other.InWeight) &&
				OutWeight.Equals(other.OutWeight);
		}

		public float Time { get; set; }
		public int TangentMode { get; set; }
		public WeightedMode WeightedMode { get; set; }
		public T Value { get; set; } = new();
		public T InSlope { get; set; } = new();
		public T OutSlope { get; set; } = new();
		public T InWeight { get; set; } = new();
		public T OutWeight { get; set; } = new();

		public static Float DefaultFloatWeight => 1.0f / 3.0f;
		public static Vector3f DefaultVector3Weight => new Vector3f(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f);
		public static Quaternionf DefaultQuaternionWeight => new Quaternionf(1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f, 1.0f / 3.0f);

		public const string TimeName = "time";
		public const string ValueName = "value";
		public const string InSlopeName = "inSlope";
		public const string OutSlopeName = "outSlope";
		public const string TangentModeName = "tangentMode";
		public const string WeightedModeName = "weightedMode";
		public const string InWeightName = "inWeight";
		public const string OutWeightName = "outWeight";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/KeyframeTpl/TangentMode/TangentMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode
{
	public enum TangentMode
	{
		Free = 0,
		Broken = 1,
		Auto = 2,
		Linear = 4,
		Constant = 6,
		ClampedAuto = 8,

		LFree = Free,
		HFree = Free,
		LAuto = Auto,
		HAuto = Auto << 4,
		LLinear = Linear,
		HLinear = Linear << 4,
		LConstant = Constant,
		HConstant = Constant << 4,
		LClampedAuto = ClampedAuto,
		HClampedAuto = ClampedAuto << 4,

		ClampedAutoBoth = LClampedAuto | HClampedAuto,
		AutoBoth = LAuto | HAuto,
		FreeSmooth = LFree | HFree,
		FreeFree = Broken | LFree | HFree,
		FreeLinear = Broken | LFree | HLinear,
		FreeConstant = Broken | LFree | HConstant,
		LinearFree = Broken | LLinear | HFree,
		LinearLinear = Broken | LLinear | HLinear,
		LinearConstant = Broken | LLinear | HConstant,
		ConstantFree = Broken | LConstant | HFree,
		ConstantLinear = Broken | LConstant | HLinear,
		ConstantConstant = Broken | LConstant | HConstant,
	}

	public static class TangentModeExtensions
	{
		/// <summary>
		/// 5.5.0 and greater
		/// </summary>
		public static bool TangentMode5Relevant(UnityVersion version) => version.IsGreaterEqual(5, 5);

		public static int ToTangent(this TangentMode _this, UnityVersion version)
		{
			if (TangentMode5Relevant(version))
			{
				return (int)_this.ToTangentMode5();
			}
			else
			{
				return (int)_this.ToTangentMode2();
			}
		}

		public static TangentMode2 ToTangentMode2(this TangentMode _this)
		{
			int value = (int)_this;
			int mask = (int)TangentMode.HConstant;
			int mask2 = (int)TangentMode2.HConstant;
			value = (value & ~mask2) | ((value & mask) >> 2);
			return (TangentMode2)value;
		}

		public static TangentMode5 ToTangentMode5(this TangentMode _this)
		{
			return (TangentMode5)_this;
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/KeyframeTpl/TangentMode/TangentMode2.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode
{
	/// <summary>
	/// Less than 5.5.0
	/// </summary>
	public enum TangentMode2
	{
		Free = 0,
		Broken = 1,
		Auto = 2,
		Linear = 4,
		Constant = 6,

		LFree = Free,
		HFree = Free,
		LAuto = Auto,
		HAuto = Auto << 2,
		LLinear = Linear,
		HLinear = Linear << 2,
		LConstant = Constant,
		HConstant = Constant << 2,
	}

	public static class TangentMode2Extensions
	{
		public static TangentMode ToTangentMode(this TangentMode2 _this)
		{
			int value = (int)_this;
			int mask = (int)TangentMode2.HConstant;
			value = (value & ~mask) | ((value & mask) << 2);
			return (TangentMode)value;
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/KeyframeTpl/TangentMode/TangentMode5.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode
{
	/// <summary>
	/// 5.5.0 and greater
	/// </summary>
	public enum TangentMode5
	{
		Free = 0,
		Broken = 1,
		Auto = 2,
		Linear = 4,
		Constant = 6,
		ClampedAuto = 8,

		LFree = Free,
		HFree = Free,
		LAuto = Auto,
		HAuto = Auto << 4,
		LLinear = Linear,
		HLinear = Linear << 4,
		LConstant = Constant,
		HConstant = Constant << 4,
		LClampedAuto = ClampedAuto,
		HClampedAuto = ClampedAuto << 4,
	}

	public static class TangentMode5Extensions
	{
		public static TangentMode ToTangentMode(this TangentMode5 _this)
		{
			return (TangentMode)_this;
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/KeyframeTpl/WeightedMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.KeyframeTpl
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Animation/AnimationCurve.bindings.cs"/>
	/// </summary>
	public enum WeightedMode
	{
		/// <summary>
		/// Exclude both inWeight or outWeight when calculating curve segments.
		/// </summary>
		None = 0,
		/// <summary>
		/// Include inWeight when calculating the previous curve segment.
		/// </summary>
		In = 1,
		/// <summary>
		/// Include outWeight when calculating the next curve segment.
		/// </summary>
		Out = 2,
		/// <summary>
		/// Include inWeight and outWeight when calculating curve segments.
		/// </summary>
		Both = 3,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/OffsetPtr.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc
{
	public sealed class OffsetPtr<T> : IAsset where T : IAssetReadable, IYamlExportable, new()
	{
		public OffsetPtr() : this(new()) { }

		public OffsetPtr(T instance)
		{
			Instance = instance;
		}

		public void Read(AssetReader reader)
		{
			Instance = reader.ReadAsset<T>();
		}

		public void Write(AssetWriter writer)
		{
			if (Instance is IAssetWritable writable)
			{
				writable.Write(writer);
			}
			else
			{
				string typeName = Instance?.GetType().ToString() ?? typeof(T).ToString();
				throw new System.NotSupportedException($"Writing not supported for {typeName}");
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(DataName, Instance.ExportYaml(container));
			return node;
		}

		public const string DataName = "data";

		public T Instance;
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/PPtr.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc
{
	public static class PPtr
	{
		/// <summary>
		/// At least version 5.0.0
		/// </summary>
		public static bool IsLongID(UnityVersion version)
		{
			// NOTE: unknown version SerializedFiles.FormatVersion.Unknown_14
			return version.IsGreaterEqual(5);
		}

		public static YamlNode ExportYaml<T>(IExportContainer container, int fileIndex, long pathID) where T : IUnityObjectBase
		{
			return new PPtr<T>(fileIndex, pathID).ExportYaml(container);
		}

		public static YamlNode ExportYaml<T>(this IPPtr<T> pptr, IExportContainer container) where T : IUnityObjectBase
		{
			if (pptr.IsNull())
			{
				return MetaPtr.NullPtr.ExportYaml(container);
			}

			T? asset = pptr.FindAsset(container);
			if (asset is null)
			{
				AssetType assetType = container.ToExportType(typeof(T));
				MetaPtr pointer = new MetaPtr(VersionHandling.VersionManager.AssetFactory.GetClassIdForType(typeof(T)), assetType);
				return pointer.ExportYaml(container);
			}
			else
			{
				MetaPtr exPointer = container.CreateExportPointer(asset);
				return exPointer.ExportYaml(container);
			}
		}

		public static void CopyValues(this IPPtr destination, IPPtr source)
		{
			destination.FileIndex = source.FileIndex;
			destination.PathIndex = source.PathIndex;
		}

		public static PPtr<T>[] CastArray<T>(IPPtr[] array) where T : IUnityObjectBase
		{
			PPtr<T>[] result = new PPtr<T>[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				result[i] = new PPtr<T>(array[i]);
			}
			return result;
		}

		public static T? FindAsset<T>(this IPPtr<T> pptr, IAssetContainer file) where T : IUnityObjectBase
		{
			if (pptr.IsNull())
			{
				return default;
			}
			IUnityObjectBase? asset = file.FindAsset(pptr.FileIndex, pptr.PathIndex);
			return asset switch
			{
				null => default,
				UnknownObject or UnreadableObject => default,
				T t => t,
				_ => throw new Exception($"Object's type {asset.GetType().Name} isn't assignable from {typeof(T).Name}"),
			};
		}

		public static T? TryGetAsset<T>(this IPPtr<T> pptr, IAssetContainer file) where T : IUnityObjectBase
		{
			if (pptr.IsNull())
			{
				return default;
			}
			return pptr.GetAsset(file);
		}

		public static T GetAsset<T>(this IPPtr<T> pptr, IAssetContainer file) where T : IUnityObjectBase
		{
			if (pptr.IsNull())
			{
				throw new Exception("Can't get null PPtr");
			}
			IUnityObjectBase asset = file.GetAsset(pptr.FileIndex, pptr.PathIndex);
			if (asset is T t)
			{
				return t;
			}
			throw new Exception($"Object's type {asset.GetType().Name} isn't assignable from {typeof(T).Name}");
		}

		public static bool IsAsset<T>(this IPPtr<T> pptr, IUnityObjectBase asset) where T : IUnityObjectBase
		{
			if (pptr.FileIndex == 0)
			{
				return asset.PathID == pptr.PathIndex;
			}
			else
			{
				throw new NotSupportedException("Need to specify file where to find");
			}
		}

		public static bool IsAsset<T>(this IPPtr<T> pptr, IAssetContainer file, IUnityObjectBase asset) where T : IUnityObjectBase
		{
			if (pptr.FileIndex == 0)
			{
				if (file == asset.SerializedFile)
				{
					return asset.PathID == pptr.PathIndex;
				}
				else
				{
					return false;
				}
			}
			else
			{
				return asset.PathID == pptr.PathIndex && file.Dependencies[pptr.FileIndex - 1].IsFile(asset.SerializedFile);
			}
		}

		public static bool IsValid<T>(this IPPtr<T> pptr, IExportContainer container) where T : IUnityObjectBase
		{
			return pptr.FindAsset(container) != null;
		}

		public static string ToLogString<T>(this IPPtr<T> pptr, IAssetContainer container) where T : IUnityObjectBase
		{
			string depName = pptr.FileIndex == 0 ? container.Name : container.Dependencies[pptr.FileIndex - 1].PathNameOrigin;
			return $"[{depName}]{typeof(T).Name}_{pptr.PathIndex}";
		}

		public static PPtr<T1> CastTo<T1>(this IPPtr pptr) where T1 : IUnityObjectBase
		{
			return new PPtr<T1>(pptr.FileIndex, pptr.PathIndex);
		}

		public static bool IsVirtual(this IPPtr pptr) => pptr.FileIndex == VirtualSerializedFile.VirtualFileIndex;
		/// <summary>
		/// PathID == 0
		/// </summary>
		public static bool IsNull(this IPPtr pptr) => pptr.PathIndex == 0;
	}

	public interface IPPtr : IAsset
	{
		/// <summary>
		/// 0 means current file
		/// </summary>
		int FileIndex { get; set; }
		/// <summary>
		/// It is acts more like a hash in some cases
		/// </summary>
		long PathIndex { get; set; }
	}

	public interface IPPtr<T> : IPPtr where T : IUnityObjectBase
	{
	}

	public sealed class PPtr<T> : IPPtr<T>, IEquatable<PPtr<T>> where T : IUnityObjectBase
	{
		public PPtr() { }

		public PPtr(int fileIndex, long pathID)
		{
			FileIndex = fileIndex;
			PathIndex = pathID;
		}

		public PPtr(IPPtr other) : this(other.FileIndex, other.PathIndex) { }

		public static bool operator ==(PPtr<T> left, PPtr<T> right)
		{
			return left.FileIndex == right.FileIndex && left.PathIndex == right.PathIndex;
		}

		public static bool operator !=(PPtr<T> left, PPtr<T> right)
		{
			return left.FileIndex != right.FileIndex || left.PathIndex != right.PathIndex;
		}

		public void Read(AssetReader reader)
		{
			FileIndex = reader.ReadInt32();
			PathIndex = PPtr.IsLongID(reader.Version) ? reader.ReadInt64() : reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(FileIndex);
			if (PPtr.IsLongID(writer.Version))
			{
				writer.Write(PathIndex);
			}
			else
			{
				writer.Write((int)PathIndex);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			return PPtr.ExportYaml(this, container);
		}

		public override string ToString()
		{
			return $"[{FileIndex}, {PathIndex}]";
		}

		public override bool Equals(object? obj)
		{
			return Equals(obj as PPtr<T>);
		}

		public override int GetHashCode()
		{
			int hash = 149;
			unchecked
			{
				hash = hash + (181 * FileIndex.GetHashCode());
				hash = (hash * 173) + PathIndex.GetHashCode();
			}
			return hash;
		}

		public bool Equals(PPtr<T>? other)
		{
			return other is not null && this == other;
		}

		public bool IsVirtual => this.IsVirtual();
		/// <summary>
		/// PathID == 0
		/// </summary>
		public bool IsNull => this.IsNull();
		/// <inheritdoc/>
		public int FileIndex { get; set; }
		/// <inheritdoc/>
		public long PathIndex { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/AnimationCurveTpl/AnimationCurveTpl.cs`:

```cs
using AssetRipper.Core.Classes.Misc.KeyframeTpl;
using AssetRipper.Core.Equality;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.Misc.Serializable.AnimationCurveTpl
{
	public sealed class AnimationCurveTpl<T> : IAsset, IEquatable<AnimationCurveTpl<T>> where T : IAsset, IYamlExportable, new()
	{
		public AnimationCurveTpl() { }

		public AnimationCurveTpl(bool _)
		{
			PreInfinity = CurveLoopTypes.CycleWithOffset;
			PostInfinity = CurveLoopTypes.CycleWithOffset;
			RotationOrder = RotationOrder.OrderZXY;
		}

		public AnimationCurveTpl(T defaultValue, T defaultWeight) : this(false)
		{
			Curve = new KeyframeTpl<T>[2];
			Curve[0] = new KeyframeTpl<T>(0.0f, defaultValue, defaultWeight);
			Curve[1] = new KeyframeTpl<T>(1.0f, defaultValue, defaultWeight);
		}

		public AnimationCurveTpl(T value1, T value2, T defaultWeight) : this(false)
		{
			Curve = new KeyframeTpl<T>[2];
			Curve[0] = new KeyframeTpl<T>(0.0f, value1, defaultWeight);
			Curve[1] = new KeyframeTpl<T>(1.0f, value2, defaultWeight);
		}

		public AnimationCurveTpl(T value1, T inSlope1, T outSlope1, T value2, T inSlope2, T outSlope2, T defaultWeight) : this(false)
		{
			Curve = new KeyframeTpl<T>[2];
			Curve[0] = new KeyframeTpl<T>(0.0f, value1, inSlope1, outSlope1, defaultWeight);
			Curve[1] = new KeyframeTpl<T>(1.0f, value2, inSlope2, outSlope2, defaultWeight);
		}

		public AnimationCurveTpl(KeyframeTpl<T> keyframe) : this(false)
		{
			Curve = new KeyframeTpl<T>[1];
			Curve[0] = keyframe;
		}

		public AnimationCurveTpl(KeyframeTpl<T> keyframe1, KeyframeTpl<T> keyframe2) : this(false)
		{
			Curve = new KeyframeTpl<T>[2];
			Curve[0] = keyframe1;
			Curve[1] = keyframe2;
		}

		public AnimationCurveTpl(IReadOnlyList<KeyframeTpl<T>> keyframes) : this(false)
		{
			Curve = new KeyframeTpl<T>[keyframes.Count];
			for (int i = 0; i < keyframes.Count; i++)
			{
				Curve[i] = keyframes[i];
			}
		}

		public AnimationCurveTpl(IReadOnlyList<KeyframeTpl<T>> keyframes, CurveLoopTypes preInfinity, CurveLoopTypes postInfinity)
		{
			PreInfinity = preInfinity;
			PostInfinity = postInfinity;
			RotationOrder = RotationOrder.OrderZXY;
			Curve = new KeyframeTpl<T>[keyframes.Count];
			for (int i = 0; i < keyframes.Count; i++)
			{
				Curve[i] = keyframes[i];
			}
		}

		public void Read(AssetReader reader)
		{
			Curve = reader.ReadAssetArray<KeyframeTpl<T>>();
			reader.AlignStream();

			PreInfinity = (CurveLoopTypes)reader.ReadInt32();
			PostInfinity = (CurveLoopTypes)reader.ReadInt32();
			if (HasRotationOrder(reader.Version))
			{
				RotationOrder = (RotationOrder)reader.ReadInt32();
			}
		}

		public void Write(AssetWriter writer)
		{
			Curve.Write(writer);
			writer.AlignStream();

			writer.Write((int)PreInfinity);
			writer.Write((int)PostInfinity);
			if (HasRotationOrder(writer.Version))
			{
				writer.Write((int)RotationOrder);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			node.Add(CurveName, Curve.ExportYaml(container));
			node.Add(PreInfinityName, (int)PreInfinity);
			node.Add(PostInfinityName, (int)PostInfinity);
			if (HasRotationOrder(container.ExportVersion))
			{
				node.Add(RotationOrderName, (int)GetExportRotationOrder(container.Version));
			}
			return node;
		}

		private RotationOrder GetExportRotationOrder(UnityVersion version)
		{
			return HasRotationOrder(version) ? RotationOrder : RotationOrder.OrderZXY;
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(2, 1))
			{
				// unknown conversion
				return 2;
			}
			else
			{
				return 1;
			}
		}

		/// <summary>
		/// 5.3.0 and greater
		/// </summary>
		public static bool HasRotationOrder(UnityVersion version) => version.IsGreaterEqual(5, 3);

		public override bool Equals(object? obj)
		{
			if (obj is AnimationCurveTpl<T> curve)
			{
				return Equals(curve);
			}
			else
			{
				return false;
			}
		}

		public override int GetHashCode()
		{
			return 0;
		}

		public bool Equals(AnimationCurveTpl<T>? other)
		{
			return
				other is not null &&
				PreInfinity == other.PreInfinity &&
				PostInfinity == other.PostInfinity &&
				RotationOrder == other.RotationOrder &&
				ArrayEquality.AreEqualArrays(Curve, other.Curve);
		}

		public KeyframeTpl<T>[] Curve { get; set; } = Array.Empty<KeyframeTpl<T>>();
		public CurveLoopTypes PreInfinity { get; set; }
		public CurveLoopTypes PostInfinity { get; set; }
		public RotationOrder RotationOrder { get; set; }

		public const string CurveName = "m_Curve";
		public const string PreInfinityName = "m_PreInfinity";
		public const string PostInfinityName = "m_PostInfinity";
		public const string RotationOrderName = "m_RotationOrder";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/AnimationCurveTpl/CurveLoopTypes.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Serializable.AnimationCurveTpl
{
	public enum CurveLoopTypes
	{
		Constant = 0,
		Cycle = 1,
		CycleWithOffset = 2,
		Oscillate = 3,
		Linear = 4,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/AnimationCurveTpl/RotationOrder.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Serializable.AnimationCurveTpl
{
	public enum RotationOrder
	{
		OrderXYZ = 0,
		OrderXZY = 1,
		OrderYZX = 2,
		OrderYXZ = 3,
		OrderZXY = 4,
		OrderZYX = 5,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/AABB.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public sealed class AABB : IAsset, IAABB
	{
		public AABB() : this(new Vector3f(), new Vector3f()) { }
		public AABB(IVector3f center, IVector3f extent)
		{
			Center = center;
			Extent = extent;
		}

		public void Read(AssetReader reader)
		{
			Center.Read(reader);
			Extent.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			Center.Write(writer);
			Extent.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(CenterName, Center.ExportYaml(container));
			node.Add(ExtentName, Extent.ExportYaml(container));
			return node;
		}

		public override string ToString()
		{
			return $"C:{Center} E:{Extent}";
		}

		public IVector3f Center { get; }
		public IVector3f Extent { get; }

		public const string CenterName = "m_Center";
		public const string ExtentName = "m_Extent";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/AABBi.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public sealed class AABBi : IAsset, IAABBi
	{
		public AABBi() : this(new Vector3i(), new Vector3i()) { }
		public AABBi(Vector3i center, Vector3i extent)
		{
			m_Center = center;
			m_Extent = extent;
		}

		public void Read(AssetReader reader)
		{
			m_Center.Read(reader);
			m_Extent.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			m_Center.Write(writer);
			m_Extent.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(CenterName, m_Center.ExportYaml(container));
			node.Add(ExtentName, m_Extent.ExportYaml(container));
			return node;
		}

		private Vector3i m_Center;
		private Vector3i m_Extent;
		public IVector3i Center => m_Center;
		public IVector3i Extent => m_Extent;

		public const string CenterName = "m_Center";
		public const string ExtentName = "m_Extent";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/IAABB.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public interface IAABB : IAsset
	{
		IVector3f Center { get; }
		IVector3f Extent { get; }
	}

	public static class AABBExtensions
	{
		public static void CopyValuesFrom(this IAABB instance, IAABB source)
		{
			instance.Center.CopyValuesFrom(source.Center);
			instance.Extent.CopyValuesFrom(source.Extent);
		}

		public static void CopyValuesFrom(this IAABB instance, IVector3f center, IVector3f extent)
		{
			instance.Center.CopyValuesFrom(center);
			instance.Extent.CopyValuesFrom(extent);
		}

		public static void Reset(this IAABB instance)
		{
			instance.Center.Reset();
			instance.Extent.Reset();
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/IAABBi.cs`:

```cs
using AssetRipper.Core.Math.Vectors;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public interface IAABBi
	{
		IVector3i Center { get; }
		IVector3i Extent { get; }
	}
}
```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/IMinMaxAABB.cs`:

```cs
using AssetRipper.Core.Math.Vectors;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public interface IMinMaxAABB
	{
		IVector3f Min { get; }
		IVector3f Max { get; }
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Boundaries/MinMaxAABB.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.Boundaries
{
	public sealed class MinMaxAABB : IAsset, IMinMaxAABB
	{
		public const string MinName = "m_Min";
		public const string MaxName = "m_Max";
		private Vector3f m_Min = new();
		private Vector3f m_Max = new();
		public IVector3f Min => m_Min;
		public IVector3f Max => m_Max;

		public void Read(AssetReader reader)
		{
			m_Min.Read(reader);
			m_Max.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			m_Min.Write(writer);
			m_Max.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(MinName, m_Min.ExportYaml(container));
			node.Add(MaxName, m_Max.ExportYaml(container));
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/GUIStyle/GUIStyle.cs`:

```cs
using AssetRipper.Core.Classes.Font;
using AssetRipper.Core.Classes.GUIText;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.GUIStyle
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/IMGUI/GUIStyle.cs"/>
	/// </summary>
	public sealed class GUIStyle : IAsset
	{
		public GUIStyle()
		{
			Name = string.Empty;
			FontSize = 33;
			RichText = true;
			StretchWidth = true;
		}

		public GUIStyle(LayoutInfo layout) : this()
		{
			TextClipping = layout.Version.IsGreaterEqual(4) ? TextClipping.Overflow : TextClipping.Clip;
		}

		public void Read(AssetReader reader)
		{
			Name = reader.ReadString();
			Normal.Read(reader);
			Hover.Read(reader);
			Active.Read(reader);
			Focused.Read(reader);
			OnNormal.Read(reader);
			OnHover.Read(reader);
			OnActive.Read(reader);
			OnFocused.Read(reader);
			Border.Read(reader);
			if (IsBuiltinFormat(reader.Version))
			{
				Margin.Read(reader);
				Padding.Read(reader);
			}
			else
			{
				Padding.Read(reader);
				Margin.Read(reader);
			}

			Overflow.Read(reader);
			Font.Read(reader);
			if (IsBuiltinFormat(reader.Version))
			{
				FontSize = reader.ReadInt32();
				FontStyle = (FontStyle)reader.ReadInt32();
				Alignment = (TextAnchor)reader.ReadInt32();
				WordWrap = reader.ReadBoolean();
				RichText = reader.ReadBoolean();
				reader.AlignStream();

				TextClipping = (TextClipping)reader.ReadInt32();
				ImagePosition = (ImagePosition)reader.ReadInt32();
				ContentOffset.Read(reader);
				FixedWidth = reader.ReadSingle();
				FixedHeight = reader.ReadSingle();
				StretchWidth = reader.ReadBoolean();
				StretchHeight = reader.ReadBoolean();
				reader.AlignStream();
			}
			else
			{
				ImagePosition = (ImagePosition)reader.ReadInt32();
				Alignment = (TextAnchor)reader.ReadInt32();
				WordWrap = reader.ReadBoolean();
				reader.AlignStream();

				TextClipping = (TextClipping)reader.ReadInt32();
				ContentOffset.Read(reader);
				ClipOffset.Read(reader);
				FixedWidth = reader.ReadSingle();
				FixedHeight = reader.ReadSingle();
				if (HasFontSize(reader.Version))
				{
					FontSize = reader.ReadInt32();
					FontStyle = (FontStyle)reader.ReadInt32();
				}
				StretchWidth = reader.ReadBoolean();
				reader.AlignStream();
				StretchHeight = reader.ReadBoolean();
				reader.AlignStream();
			}
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Name);
			Normal.Write(writer);
			Hover.Write(writer);
			Active.Write(writer);
			Focused.Write(writer);
			OnNormal.Write(writer);
			OnHover.Write(writer);
			OnActive.Write(writer);
			OnFocused.Write(writer);
			Border.Write(writer);
			if (IsBuiltinFormat(writer.Version))
			{
				Margin.Write(writer);
				Padding.Write(writer);
			}
			else
			{
				Padding.Write(writer);
				Margin.Write(writer);
			}

			Overflow.Write(writer);
			Font.Write(writer);
			if (IsBuiltinFormat(writer.Version))
			{
				writer.Write(FontSize);
				writer.Write((int)FontStyle);
				writer.Write((int)Alignment);
				writer.Write(WordWrap);
				writer.Write(RichText);
				writer.AlignStream();

				writer.Write((int)TextClipping);
				writer.Write((int)ImagePosition);
				ContentOffset.Write(writer);
				writer.Write(FixedWidth);
				writer.Write(FixedHeight);
				writer.Write(StretchWidth);
				writer.Write(StretchHeight);
				writer.AlignStream();
			}
			else
			{
				writer.Write((int)ImagePosition);
				writer.Write((int)Alignment);
				writer.Write(WordWrap);
				writer.AlignStream();

				writer.Write((int)TextClipping);
				ContentOffset.Write(writer);
				ClipOffset.Write(writer);
				writer.Write(FixedWidth);
				writer.Write(FixedHeight);
				if (HasFontSize(writer.Version))
				{
					writer.Write(FontSize);
					writer.Write((int)FontStyle);
				}
				writer.Write(StretchWidth);
				writer.AlignStream();
				writer.Write(StretchHeight);
				writer.AlignStream();
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(NameName, Name);
			node.Add(NormalName, Normal.ExportYaml(container));
			node.Add(HoverName, Hover.ExportYaml(container));
			node.Add(ActiveName, Active.ExportYaml(container));
			node.Add(FocusedName, Focused.ExportYaml(container));
			node.Add(OnNormalName, OnNormal.ExportYaml(container));
			node.Add(OnHoverName, OnHover.ExportYaml(container));
			node.Add(OnActiveName, OnActive.ExportYaml(container));
			node.Add(OnFocusedName, OnFocused.ExportYaml(container));
			node.Add(BorderName, Border.ExportYaml(container));
			if (IsBuiltinFormat(container.ExportVersion))
			{
				node.Add(MarginName, Margin.ExportYaml(container));
				node.Add(PaddingName, Padding.ExportYaml(container));
			}
			else
			{
				node.Add(PaddingName, Padding.ExportYaml(container));
				node.Add(MarginName, Margin.ExportYaml(container));
			}

			node.Add(OverflowName, Overflow.ExportYaml(container));
			node.Add(FontName, Font.ExportYaml(container));
			if (IsBuiltinFormat(container.ExportVersion))
			{
				node.Add(FontSizeName, FontSize);
				node.Add(FontStyleName, (int)FontStyle);
				node.Add(AlignmentName, (int)Alignment);
				node.Add(WordWrapName, WordWrap);
				node.Add(RichTextName, RichText);
				node.Add(TextClippingName, (int)TextClipping);
				node.Add(ImagePositionName, (int)ImagePosition);
				node.Add(ContentOffsetName, ContentOffset.ExportYaml(container));
				node.Add(FixedWidthName, FixedWidth);
				node.Add(FixedHeightName, FixedHeight);
				node.Add(StretchWidthName, StretchWidth);
				node.Add(StretchHeightName, StretchHeight);
			}
			else
			{
				node.Add(ImagePositionName, (int)ImagePosition);
				node.Add(AlignmentName, (int)Alignment);
				node.Add(WordWrapName, WordWrap);
				node.Add(TextClippingName, (int)TextClipping);
				node.Add(ContentOffsetName, ContentOffset.ExportYaml(container));
				node.Add(ClipOffsetName, ClipOffset.ExportYaml(container));
				node.Add(FixedWidthName, FixedWidth);
				node.Add(FixedHeightName, FixedHeight);
				if (HasFontSize(container.ExportVersion))
				{
					node.Add(FontSizeName, FontSize);
					node.Add(FontStyleName, (int)FontStyle);
				}
				node.Add(StretchWidthName, StretchWidth);
				node.Add(StretchHeightName, StretchHeight);
			}
			return node;
		}

		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasFontSize(UnityVersion version) => version.IsGreaterEqual(3);
		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasFontStyle(UnityVersion version) => version.IsGreaterEqual(3);
		/// <summary>
		/// 4.0.0 and greater
		/// </summary>
		public static bool HasRichText(UnityVersion version) => version.IsGreaterEqual(4);
		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool HasClipOffset(UnityVersion version) => version.IsLess(4);

		/// <summary>
		/// 4.0.0 and greater
		/// GUIStyle became builtin serializable only in v4.0.0
		/// </summary>
		public static bool IsBuiltinFormat(UnityVersion version) => version.IsGreaterEqual(4);

		public string Name { get; set; }
		public int FontSize { get; set; }
		public FontStyle FontStyle { get; set; }
		public TextAnchor Alignment { get; set; }
		public bool WordWrap { get; set; }
		public bool RichText { get; set; }
		public TextClipping TextClipping { get; set; }
		public ImagePosition ImagePosition { get; set; }
		public float FixedWidth { get; set; }
		public float FixedHeight { get; set; }
		public bool StretchWidth { get; set; }
		public bool StretchHeight { get; set; }

		public GUIStyleState Normal = new();
		public GUIStyleState Hover = new();
		public GUIStyleState Active = new();
		public GUIStyleState Focused = new();
		public GUIStyleState OnNormal = new();
		public GUIStyleState OnHover = new();
		public GUIStyleState OnActive = new();
		public GUIStyleState OnFocused = new();
		public RectOffset Border = new();
		public RectOffset Margin = new();
		public RectOffset Padding = new();
		public RectOffset Overflow = new();
		/// <summary>
		/// IFont
		/// </summary>
		public PPtr<IUnityObjectBase> Font = new();
		public Vector2f ContentOffset = new();
		public Vector2f ClipOffset = new();

		public const string NameName = "m_Name";
		public const string NormalName = "m_Normal";
		public const string HoverName = "m_Hover";
		public const string ActiveName = "m_Active";
		public const string FocusedName = "m_Focused";
		public const string OnNormalName = "m_OnNormal";
		public const string OnHoverName = "m_OnHover";
		public const string OnActiveName = "m_OnActive";
		public const string OnFocusedName = "m_OnFocused";
		public const string BorderName = "m_Border";
		public const string MarginName = "m_Margin";
		public const string PaddingName = "m_Padding";
		public const string OverflowName = "m_Overflow";
		public const string FontName = "m_Font";
		public const string FontSizeName = "m_FontSize";
		public const string FontStyleName = "m_FontStyle";
		public const string AlignmentName = "m_Alignment";
		public const string WordWrapName = "m_WordWrap";
		public const string RichTextName = "m_RichText";
		public const string TextClippingName = "m_TextClipping";
		public const string ImagePositionName = "m_ImagePosition";
		public const string ContentOffsetName = "m_ContentOffset";
		public const string ClipOffsetName = "m_ClipOffset";
		public const string FixedWidthName = "m_FixedWidth";
		public const string FixedHeightName = "m_FixedHeight";
		public const string StretchWidthName = "m_StretchWidth";
		public const string StretchHeightName = "m_StretchHeight";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/GUIStyle/GUIStyleState.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.GUIStyle
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/IMGUI/GUIStyle.cs"/>
	/// </summary>
	public sealed class GUIStyleState : IAsset
	{
		public GUIStyleState()
		{
			Background = new();
			ScaledBackgrounds = Array.Empty<PPtr<IUnityObjectBase>>();
			TextColor = ColorRGBAf.Black;
		}

		public GUIStyleState(GUIStyleState copy)
		{
			Background = copy.Background;
			TextColor = copy.TextColor.Clone();
			ScaledBackgrounds = new PPtr<IUnityObjectBase>[copy.ScaledBackgrounds.Length];
			for (int i = 0; i < copy.ScaledBackgrounds.Length; i++)
			{
				ScaledBackgrounds[i] = copy.ScaledBackgrounds[i];
			}
		}

		public void Read(AssetReader reader)
		{
			Background.Read(reader);
			if (HasScaledBackgrounds(reader.Version, reader.Flags))
			{
				ScaledBackgrounds = reader.ReadAssetArray<PPtr<IUnityObjectBase>>();
			}
			else
			{
				ScaledBackgrounds = Array.Empty<PPtr<IUnityObjectBase>>();
			}
			TextColor.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			Background.Write(writer);
			if (HasScaledBackgrounds(writer.Version, writer.Flags))
			{
				writer.WriteAssetArray(ScaledBackgrounds);
			}
			TextColor.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(BackgroundName, Background.ExportYaml(container));
			if (HasScaledBackgrounds(container.ExportVersion, container.ExportFlags))
			{
				node.Add(ScaledBackgroundsName, ScaledBackgrounds.ExportYaml(container));
			}
			node.Add(TextColorName, TextColor.ExportYaml(container));
			return node;
		}

		/// <summary>
		/// 5.4.0 and greater and Not Release
		/// </summary>
		public static bool HasScaledBackgrounds(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(5, 4) && !flags.IsRelease();

		/// <summary>
		/// Texture2D
		/// </summary>
		public PPtr<IUnityObjectBase>[] ScaledBackgrounds { get; set; }

		/// <summary>
		/// Texture2D
		/// </summary>
		public PPtr<IUnityObjectBase> Background = new();
		public ColorRGBAf TextColor = new();

		public const string BackgroundName = "m_Background";
		public const string ScaledBackgroundsName = "m_ScaledBackgrounds";
		public const string TextColorName = "m_TextColor";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/GUIStyle/ImagePosition.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Serializable.GUIStyle
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/IMGUI/GUIStyle.cs"/>
	/// </summary>
	public enum ImagePosition
	{
		/// <summary>
		/// Image is to the left of the text.
		/// </summary>
		ImageLeft = 0,
		/// <summary>
		/// Image is above the text.
		/// </summary>
		ImageAbove = 1,
		/// <summary>
		/// Only the image is displayed.
		/// </summary>
		ImageOnly = 2,
		/// <summary>
		/// Only the text is displayed.
		/// </summary>
		TextOnly = 3,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/GUIStyle/TextClipping.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Serializable.GUIStyle
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/IMGUI/GUIStyle.cs"/>
	/// </summary>
	public enum TextClipping
	{
		/// <summary>
		/// Text flows freely outside the element.
		/// </summary>
		Overflow = 0,
		/// <summary>
		/// Text gets clipped to be inside the element.
		/// </summary>
		Clip = 1,
		/// <summary>
		/// Text gets truncated with dots to show it is too long.
		/// </summary>
		Truncate = 2,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Gradient/Gradient.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable.Gradient
{
	/// <summary>
	/// GradientNEW previously
	/// </summary>
	public sealed class Gradient : IAsset
	{
		public Gradient() { }

		public Gradient(ColorRGBAf color1, ColorRGBAf color2) : this()
		{
			Ctime0 = 0;
			Atime0 = 0;
			Ctime1 = ushort.MaxValue;
			Atime1 = ushort.MaxValue;
			Key0 = color1;
			Key1 = color2;
			NumColorKeys = 2;
			NumAlphaKeys = 2;
		}

		public void Read(AssetReader reader)
		{
			if (!UsesColorRBGAf(reader.Version))
			{
				Key0_32 = reader.ReadAsset<ColorRGBA32>();
				Key1_32 = reader.ReadAsset<ColorRGBA32>();
				Key2_32 = reader.ReadAsset<ColorRGBA32>();
				Key3_32 = reader.ReadAsset<ColorRGBA32>();
				Key4_32 = reader.ReadAsset<ColorRGBA32>();
				Key5_32 = reader.ReadAsset<ColorRGBA32>();
				Key6_32 = reader.ReadAsset<ColorRGBA32>();
				Key7_32 = reader.ReadAsset<ColorRGBA32>();
			}
			else
			{
				Key0.Read(reader);
				Key1.Read(reader);
				Key2.Read(reader);
				Key3.Read(reader);
				Key4.Read(reader);
				Key5.Read(reader);
				Key6.Read(reader);
				Key7.Read(reader);
			}

			Ctime0 = reader.ReadUInt16();
			Ctime1 = reader.ReadUInt16();
			Ctime2 = reader.ReadUInt16();
			Ctime3 = reader.ReadUInt16();
			Ctime4 = reader.ReadUInt16();
			Ctime5 = reader.ReadUInt16();
			Ctime6 = reader.ReadUInt16();
			Ctime7 = reader.ReadUInt16();
			Atime0 = reader.ReadUInt16();
			Atime1 = reader.ReadUInt16();
			Atime2 = reader.ReadUInt16();
			Atime3 = reader.ReadUInt16();
			Atime4 = reader.ReadUInt16();
			Atime5 = reader.ReadUInt16();
			Atime6 = reader.ReadUInt16();
			Atime7 = reader.ReadUInt16();
			if (HasMode(reader.Version))
			{
				Mode = (GradientMode)reader.ReadInt32();
			}

			NumColorKeys = reader.ReadByte();
			NumAlphaKeys = reader.ReadByte();
			reader.AlignStream();
		}

		public void Write(AssetWriter writer)
		{
			if (!UsesColorRBGAf(writer.Version))
			{
				Key0_32.Write(writer);
				Key1_32.Write(writer);
				Key2_32.Write(writer);
				Key3_32.Write(writer);
				Key4_32.Write(writer);
				Key5_32.Write(writer);
				Key6_32.Write(writer);
				Key7_32.Write(writer);
			}
			else
			{
				Key0.Write(writer);
				Key1.Write(writer);
				Key2.Write(writer);
				Key3.Write(writer);
				Key4.Write(writer);
				Key5.Write(writer);
				Key6.Write(writer);
				Key7.Write(writer);
			}

			writer.Write(Ctime0);
			writer.Write(Ctime1);
			writer.Write(Ctime2);
			writer.Write(Ctime3);
			writer.Write(Ctime4);
			writer.Write(Ctime5);
			writer.Write(Ctime6);
			writer.Write(Ctime7);
			writer.Write(Atime0);
			writer.Write(Atime1);
			writer.Write(Atime2);
			writer.Write(Atime3);
			writer.Write(Atime4);
			writer.Write(Atime5);
			writer.Write(Atime6);
			writer.Write(Atime7);
			if (HasMode(writer.Version))
			{
				writer.Write((int)Mode);
			}

			writer.Write(NumColorKeys);
			writer.Write(NumAlphaKeys);
			writer.AlignStream();
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			if (!UsesColorRBGAf(container.ExportVersion))
			{
				node.Add(Key0Name, Key0_32.ExportYaml(container));
				node.Add(Key1Name, Key1_32.ExportYaml(container));
				node.Add(Key2Name, Key2_32.ExportYaml(container));
				node.Add(Key3Name, Key3_32.ExportYaml(container));
				node.Add(Key4Name, Key4_32.ExportYaml(container));
				node.Add(Key5Name, Key5_32.ExportYaml(container));
				node.Add(Key6Name, Key6_32.ExportYaml(container));
				node.Add(Key7Name, Key7_32.ExportYaml(container));
			}
			else
			{
				node.Add(Key0Name, Key0.ExportYaml(container));
				node.Add(Key1Name, Key1.ExportYaml(container));
				node.Add(Key2Name, Key2.ExportYaml(container));
				node.Add(Key3Name, Key3.ExportYaml(container));
				node.Add(Key4Name, Key4.ExportYaml(container));
				node.Add(Key5Name, Key5.ExportYaml(container));
				node.Add(Key6Name, Key6.ExportYaml(container));
				node.Add(Key7Name, Key7.ExportYaml(container));
			}

			node.Add(Ctime0Name, Ctime0);
			node.Add(Ctime1Name, Ctime1);
			node.Add(Ctime2Name, Ctime2);
			node.Add(Ctime3Name, Ctime3);
			node.Add(Ctime4Name, Ctime4);
			node.Add(Ctime5Name, Ctime5);
			node.Add(Ctime6Name, Ctime6);
			node.Add(Ctime7Name, Ctime7);
			node.Add(Atime0Name, Atime0);
			node.Add(Atime1Name, Atime1);
			node.Add(Atime2Name, Atime2);
			node.Add(Atime3Name, Atime3);
			node.Add(Atime4Name, Atime4);
			node.Add(Atime5Name, Atime5);
			node.Add(Atime6Name, Atime6);
			node.Add(Atime7Name, Atime7);
			if (HasMode(container.ExportVersion))
			{
				node.Add(ModeName, (int)Mode);
			}

			node.Add(NumColorKeysName, NumColorKeys);
			node.Add(NumAlphaKeysName, NumAlphaKeys);
			return node;
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (UsesColorRBGAf(version))
			{
				// ColorRBGA32 has been replaced by ColorRBGAf
				return 2;
			}
			else
			{
				return 1;
			}
		}

		/// <summary>
		/// 5.6 and greater
		/// </summary>
		public static bool UsesColorRBGAf(UnityVersion version) => version.IsGreaterEqual(5, 6);

		/// <summary>
		/// 5.5 and greater
		/// </summary>
		public static bool HasMode(UnityVersion version) => version.IsGreaterEqual(5, 5);

		public void Add(ushort time, ColorRGBA32 color)
		{
			Add(time, (ColorRGBAf)color);
		}

		public void Add(ushort time, ColorRGBAf color)
		{
			AddColorRGBAf(time, color.R, color.G, color.B);
			AddAlpha(time, color.A);
		}

		public void AddColorRGBAf(ushort time, float r, float g, float b)
		{
			switch (NumColorKeys)
			{
				case 0:
					Key0 = new ColorRGBAf(r, g, b, Key0.A);
					Ctime0 = time;
					break;
				case 1:
					Key1 = new ColorRGBAf(r, g, b, Key1.A);
					Ctime1 = time;
					break;
				case 2:
					Key2 = new ColorRGBAf(r, g, b, Key2.A);
					Ctime2 = time;
					break;
				case 3:
					Key3 = new ColorRGBAf(r, g, b, Key3.A);
					Ctime3 = time;
					break;
				case 4:
					Key4 = new ColorRGBAf(r, g, b, Key4.A);
					Ctime4 = time;
					break;
				case 5:
					Key5 = new ColorRGBAf(r, g, b, Key5.A);
					Ctime5 = time;
					break;
				case 6:
					Key6 = new ColorRGBAf(r, g, b, Key6.A);
					Ctime6 = time;
					break;
				case 7:
					Key7 = new ColorRGBAf(r, g, b, Key7.A);
					Ctime7 = time;
					break;
				default:
					throw new NotSupportedException();
			}
			NumColorKeys++;
		}

		public void AddAlpha(ushort time, float a)
		{
			switch (NumAlphaKeys)
			{
				case 0:
					Key0 = new ColorRGBAf(Key0.R, Key0.G, Key0.B, a);
					Atime0 = time;
					break;
				case 1:
					Key1 = new ColorRGBAf(Key1.R, Key1.G, Key1.B, a);
					Atime1 = time;
					break;
				case 2:
					Key2 = new ColorRGBAf(Key2.R, Key2.G, Key2.B, a);
					Atime2 = time;
					break;
				case 3:
					Key3 = new ColorRGBAf(Key3.R, Key3.G, Key3.B, a);
					Atime3 = time;
					break;
				case 4:
					Key4 = new ColorRGBAf(Key4.R, Key4.G, Key4.B, a);
					Atime4 = time;
					break;
				case 5:
					Key5 = new ColorRGBAf(Key5.R, Key5.G, Key5.B, a);
					Atime5 = time;
					break;
				case 6:
					Key6 = new ColorRGBAf(Key6.R, Key6.G, Key6.B, a);
					Atime6 = time;
					break;
				case 7:
					Key7 = new ColorRGBAf(Key7.R, Key7.G, Key7.B, a);
					Atime7 = time;
					break;
				default:
					throw new NotSupportedException();
			}
			NumAlphaKeys++;
		}

		public ColorRGBA32 Key0_32
		{
			get => (ColorRGBA32)Key0;
			set => Key0 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key1_32
		{
			get => (ColorRGBA32)Key1;
			set => Key1 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key2_32
		{
			get => (ColorRGBA32)Key2;
			set => Key2 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key3_32
		{
			get => (ColorRGBA32)Key3;
			set => Key3 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key4_32
		{
			get => (ColorRGBA32)Key4;
			set => Key4 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key5_32
		{
			get => (ColorRGBA32)Key5;
			set => Key5 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key6_32
		{
			get => (ColorRGBA32)Key6;
			set => Key6 = (ColorRGBAf)value;
		}
		public ColorRGBA32 Key7_32
		{
			get => (ColorRGBA32)Key7;
			set => Key7 = (ColorRGBAf)value;
		}
		public ushort Ctime0 { get; set; }
		public ushort Ctime1 { get; set; }
		public ushort Ctime2 { get; set; }
		public ushort Ctime3 { get; set; }
		public ushort Ctime4 { get; set; }
		public ushort Ctime5 { get; set; }
		public ushort Ctime6 { get; set; }
		public ushort Ctime7 { get; set; }
		public ushort Atime0 { get; set; }
		public ushort Atime1 { get; set; }
		public ushort Atime2 { get; set; }
		public ushort Atime3 { get; set; }
		public ushort Atime4 { get; set; }
		public ushort Atime5 { get; set; }
		public ushort Atime6 { get; set; }
		public ushort Atime7 { get; set; }
		public GradientMode Mode { get; set; }
		public byte NumColorKeys { get; set; }
		public byte NumAlphaKeys { get; set; }

		public ColorRGBAf Key0 = new();
		public ColorRGBAf Key1 = new();
		public ColorRGBAf Key2 = new();
		public ColorRGBAf Key3 = new();
		public ColorRGBAf Key4 = new();
		public ColorRGBAf Key5 = new();
		public ColorRGBAf Key6 = new();
		public ColorRGBAf Key7 = new();

		public const string Key0Name = "key0";
		public const string Key1Name = "key1";
		public const string Key2Name = "key2";
		public const string Key3Name = "key3";
		public const string Key4Name = "key4";
		public const string Key5Name = "key5";
		public const string Key6Name = "key6";
		public const string Key7Name = "key7";
		public const string Ctime0Name = "ctime0";
		public const string Ctime1Name = "ctime1";
		public const string Ctime2Name = "ctime2";
		public const string Ctime3Name = "ctime3";
		public const string Ctime4Name = "ctime4";
		public const string Ctime5Name = "ctime5";
		public const string Ctime6Name = "ctime6";
		public const string Ctime7Name = "ctime7";
		public const string Atime0Name = "atime0";
		public const string Atime1Name = "atime1";
		public const string Atime2Name = "atime2";
		public const string Atime3Name = "atime3";
		public const string Atime4Name = "atime4";
		public const string Atime5Name = "atime5";
		public const string Atime6Name = "atime6";
		public const string Atime7Name = "atime7";
		public const string ModeName = "m_Mode";
		public const string NumColorKeysName = "m_NumColorKeys";
		public const string NumAlphaKeysName = "m_NumAlphaKeys";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/Gradient/GradientMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Misc.Serializable.Gradient
{
	/// <summary>
	/// Select how gradients will be evaluated.
	/// </summary>
	public enum GradientMode
	{
		/// <summary>
		/// Find the 2 keys adjacent to the requested evaluation time, and linearly interpolate between them to obtain a blended color.
		/// </summary>
		Blend = 0,
		/// <summary>
		/// Return a fixed color, by finding the first key whose time value is greater than the requested evaluation time.
		/// </summary>
		Fixed = 1,
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/LayerMask.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable
{
	public sealed class LayerMask : IAsset
	{
		public void Read(AssetReader reader)
		{
			Bits = Is32Bits(reader.Version) ? reader.ReadUInt32() : reader.ReadUInt16();
		}

		public void Write(AssetWriter writer)
		{
			if (Is32Bits(writer.Version))
			{
				writer.Write(Bits);
			}
			else
			{
				writer.Write((ushort)Bits);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			node.Add(BitsName, Bits);
			return node;
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(2))
			{
				// Bits size has been changed to 32
				return 2;
			}
			else
			{
				return 1;
			}
		}

		/// <summary>
		/// 2.0.0 and greater
		/// </summary>
		public bool Is32Bits(UnityVersion version) => version.IsGreaterEqual(2);

		public uint Bits { get; set; }

		public const string BitsName = "m_Bits";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/PropertyName.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;

using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable
{
	public sealed class PropertyName : IAsset
	{
		public static bool operator ==(PropertyName lhs, PropertyName rhs)
		{
			return lhs.ID == rhs.ID;
		}

		public static bool operator !=(PropertyName lhs, PropertyName rhs)
		{
			return lhs.ID != rhs.ID;
		}

		public void Read(AssetReader reader)
		{
			ID = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(ID);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			return new YamlScalarNode(ID == 0 ? string.Empty : $"Unknown_{unchecked((uint)ID)}");
		}

		public override int GetHashCode()
		{
			return ID;
		}

		public override bool Equals(object? other)
		{
			if (other is PropertyName propertyName)
			{
				return propertyName == this;
			}
			return false;
		}

		public int ID { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/Serializable/RectOffset.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc.Serializable
{
	public sealed class RectOffset : IAsset
	{
		public void Read(AssetReader reader)
		{
			Left = reader.ReadInt32();
			Right = reader.ReadInt32();
			Top = reader.ReadInt32();
			Bottom = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Left);
			writer.Write(Right);
			writer.Write(Top);
			writer.Write(Bottom);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(LeftName, Left);
			node.Add(RightName, Right);
			node.Add(TopName, Top);
			node.Add(BottomName, Bottom);
			return node;
		}

		public int Left { get; set; }
		public int Right { get; set; }
		public int Top { get; set; }
		public int Bottom { get; set; }

		public const string LeftName = "m_Left";
		public const string RightName = "m_Right";
		public const string TopName = "m_Top";
		public const string BottomName = "m_Bottom";
	}
}

```

`AssetRipper.Fundamentals/Classes/Misc/UnityGUID.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using AssetRipper.Core.Project;
using AssetRipper.IO.Endian;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Buffers.Binary;
using System.Security.Cryptography;
using System.Text;

namespace AssetRipper.Core.Classes.Misc
{
	public struct UnityGUID : IAsset, ISerializedReadable, ISerializedWritable, IEquatable<UnityGUID>
	{
		public UnityGUID(Guid guid) : this(ConvertSystemOrUnityBytes(guid.ToByteArray())) { }

		public UnityGUID(byte[] guidData)
		{
			Data0 = BinaryPrimitives.ReadUInt32LittleEndian(guidData.AsSpan(0, 4));
			Data1 = BinaryPrimitives.ReadUInt32LittleEndian(guidData.AsSpan(4, 4));
			Data2 = BinaryPrimitives.ReadUInt32LittleEndian(guidData.AsSpan(8, 4));
			Data3 = BinaryPrimitives.ReadUInt32LittleEndian(guidData.AsSpan(12, 4));
		}

		public UnityGUID(uint dword0, uint dword1, uint dword2, uint dword3)
		{
			Data0 = dword0;
			Data1 = dword1;
			Data2 = dword2;
			Data3 = dword3;
		}

		public static UnityGUID NewGuid() => new UnityGUID(Guid.NewGuid().ToByteArray());

		public static explicit operator UnityGUID(Guid systemGuid) => new UnityGUID(systemGuid);

		public static explicit operator Guid(UnityGUID unityGuid) => new Guid(ConvertSystemOrUnityBytes(unityGuid.ToByteArray()));

		public static bool operator ==(UnityGUID left, UnityGUID right)
		{
			return left.Data0 == right.Data0 && left.Data1 == right.Data1 && left.Data2 == right.Data2 && left.Data3 == right.Data3;
		}

		public static bool operator !=(UnityGUID left, UnityGUID right)
		{
			return left.Data0 != right.Data0 || left.Data1 != right.Data1 || left.Data2 != right.Data2 || left.Data3 != right.Data3;
		}

		public void Read(SerializedReader reader) => Read((EndianReader)reader);
		public void Read(AssetReader reader) => Read((EndianReader)reader);
		public void Read(EndianReader reader)
		{
			Data0 = reader.ReadUInt32();
			Data1 = reader.ReadUInt32();
			Data2 = reader.ReadUInt32();
			Data3 = reader.ReadUInt32();
		}

		public void Write(SerializedWriter writer) => Write((EndianWriter)writer);
		public void Write(AssetWriter writer) => Write((EndianWriter)writer);
		public void Write(EndianWriter writer)
		{
			writer.Write(Data0);
			writer.Write(Data1);
			writer.Write(Data2);
			writer.Write(Data3);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			return new YamlScalarNode(ToString());
		}

		public byte[] ToByteArray()
		{
			byte[] result = new byte[16];
			BinaryPrimitives.WriteUInt32LittleEndian(result.AsSpan(0, 4), Data0);
			BinaryPrimitives.WriteUInt32LittleEndian(result.AsSpan(4, 4), Data1);
			BinaryPrimitives.WriteUInt32LittleEndian(result.AsSpan(8, 4), Data2);
			BinaryPrimitives.WriteUInt32LittleEndian(result.AsSpan(12, 4), Data3);
			return result;
		}

		public override bool Equals(object? obj)
		{
			if (obj is UnityGUID guid)
			{
				return this == guid;
			}
			return false;
		}

		public bool Equals(UnityGUID other) => this == other;

		public override int GetHashCode()
		{
			int hash = 19;
			unchecked
			{
				hash = hash + (31 * Data0.GetHashCode());
				hash = (hash * 479) + Data1.GetHashCode();
				hash = (hash * 593) + Data2.GetHashCode();
				hash = (hash * 347) + Data3.GetHashCode();
			}
			return hash;
		}

		public override string ToString()
		{
			StringBuilder sb = GetStringBuilder();
			try
			{
				Append(sb, Data0);
				Append(sb, Data1);
				Append(sb, Data2);
				Append(sb, Data3);
				return sb.ToString();
			}
			finally
			{
				sb.Clear();
			}
		}

		private static StringBuilder GetStringBuilder()
		{
			if (s_sb == null)
			{
				s_sb = new StringBuilder(32, 32);
			}
			return s_sb;
		}

		private void Append(StringBuilder sb, uint value)
		{
			sb.Append(StringBuilderExtensions.ByteHexRepresentations[unchecked((int)(value << 4) & 0xF0) | unchecked((int)(value >> 4) & 0xF)]);
			sb.Append(StringBuilderExtensions.ByteHexRepresentations[unchecked((int)(value >> 4) & 0xF0) | unchecked((int)(value >> 12) & 0xF)]);
			sb.Append(StringBuilderExtensions.ByteHexRepresentations[unchecked((int)(value >> 12) & 0xF0) | unchecked((int)(value >> 20) & 0xF)]);
			sb.Append(StringBuilderExtensions.ByteHexRepresentations[unchecked((int)(value >> 20) & 0xF0) | unchecked((int)(value >> 28) & 0xF)]);
		}

		/// <summary>
		/// Converts system bytes to unity bytes, or the reverse
		/// </summary>
		/// <param name="originalBytes">A 16 byte input array</param>
		/// <returns></returns>
		/// <exception cref="ArgumentNullException">Array is null</exception>
		/// <exception cref="ArgumentException">Array doesn't have 16 elements</exception>
		private static byte[] ConvertSystemOrUnityBytes(byte[] originalBytes)
		{
			if (originalBytes is null)
			{
				throw new ArgumentNullException(nameof(originalBytes));
			}

			if (originalBytes.Length != 16)
			{
				throw new ArgumentException($"Invalid length: {originalBytes.Length}", nameof(originalBytes));
			}

			byte[] newBytes = new byte[16];
			for (int i = 0; i < 4; i++)
			{
				newBytes[i] = originalBytes[3 - i];
			}
			newBytes[4] = originalBytes[5];
			newBytes[5] = originalBytes[4];
			newBytes[6] = originalBytes[7];
			newBytes[7] = originalBytes[6];
			for (int i = 8; i < 16; i++)
			{
				newBytes[i] = originalBytes[i];
			}
			for (int i = 0; i < 16; i++)
			{
				//AB becomes BA
				byte value = newBytes[i];
				newBytes[i] = (byte)(unchecked((int)(value << 4) & 0xF0) | unchecked((int)(value >> 4) & 0xF));
			}

			return newBytes;
		}

		public static UnityGUID Parse(string guidString)
		{
			return new UnityGUID(Guid.Parse(guidString));
		}

		/// <summary>
		/// Make a guid by MD5 hashing a string
		/// </summary>
		/// <remarks>
		/// The returned guid is most likely not "valid" by official standards. However, Unity doesn't seem to care.
		/// </remarks>
		/// <param name="str">Input string. Can be any length</param>
		/// <returns>A stable guid corresponding to the input string</returns>
		public static UnityGUID Md5Hash(string str) => Md5Hash(Encoding.UTF8.GetBytes(str));

		/// <summary>
		/// Make a guid by MD5 hashing some input data
		/// </summary>
		/// <remarks>
		/// The returned guid is most likely not "valid" by official standards. However, Unity doesn't seem to care.
		/// </remarks>
		/// <param name="inputBytes">Input byte array. Can be any length</param>
		/// <returns>A stable guid corresponding to the input bytes</returns>
		public static UnityGUID Md5Hash(byte[] inputBytes)
		{
			byte[] hashBytes = MD5.HashData(inputBytes);
			return new UnityGUID(ConvertSystemOrUnityBytes(hashBytes));
		}

		public bool IsZero => Data0 == 0 && Data1 == 0 && Data2 == 0 && Data3 == 0;

		public uint Data0 { get; set; }
		public uint Data1 { get; set; }
		public uint Data2 { get; set; }
		public uint Data3 { get; set; }

		/// <summary>
		/// 0x0000000DEADBEEF15DEADF00D0000000
		/// </summary>
		public static readonly UnityGUID MissingReference = new UnityGUID(0xD0000000, 0x1FEEBDAE, 0x00FDAED5, 0x0000000D);

		[ThreadStatic]
		private static StringBuilder? s_sb = null;
	}
}

```

`AssetRipper.Fundamentals/Classes/Object/HideFlags.cs`:

```cs
namespace AssetRipper.Core.Classes.Object
{
	/// <summary>
	/// Bit mask that controls object destruction, saving and visibility in inspectors.
	/// </summary>
	[Flags]
	public enum HideFlags
	{
		/// <summary>
		/// A normal, visible object. This is the default.
		/// </summary>
		None = 0,
		/// <summary>
		/// The object will not appear in the hierarchy.
		/// </summary>
		HideInHierarchy = 1,
		/// <summary>
		/// It is not possible to view it in the inspector.
		/// </summary>
		HideInInspector = 2,
		/// <summary>
		/// The object will not be saved to the Scene in the editor.
		/// </summary>
		DontSaveInEditor = 4,
		/// <summary>
		/// The object is not be editable in the inspector.
		/// </summary>
		NotEditable = 8,
		/// <summary>
		/// The object will not be saved when building a player.
		/// </summary>
		DontSaveInBuild = 16,
		/// <summary>
		/// The object will not be unloaded by Resources.UnloadUnusedAssets.
		/// </summary>
		DontUnloadUnusedAsset = 32,
		/// <summary>
		/// The object will not be saved to the Scene. It will not be destroyed when a new Scene is loaded.
		/// It is a shortcut for HideFlags.DontSaveInBuild | HideFlags.DontSaveInEditor | HideFlags.DontUnloadUnusedAsset.
		/// </summary>
		DontSave = DontSaveInEditor | DontSaveInBuild | DontUnloadUnusedAsset, //52
		/// <summary>
		/// The GameObject is not shown in the Hierarchy, not saved to to Scenes, and not unloaded by Resources.UnloadUnusedAssets.
		/// </summary>
		HideAndDontSave = HideInHierarchy | DontSaveInEditor | NotEditable | DontSaveInBuild | DontUnloadUnusedAsset, //61
	}
}

```

`AssetRipper.Fundamentals/Classes/UnknownObject.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using System.IO;

namespace AssetRipper.Core.Classes
{
	public class UnknownObject : UnityObjectBase
	{
		public byte[] RawData { get; private set; } = Array.Empty<byte>();

		public UnknownObject(AssetInfo assetInfo) : base(assetInfo) { }

		public override void Read(AssetReader reader)
		{
			throw new NotSupportedException();
		}

		public void Read(AssetReader reader, int byteSize)
		{
			if (byteSize > 0)
			{
				RawData = reader.ReadBytes(byteSize);
			}
		}

		public override void Write(AssetWriter writer)
		{
			writer.Write(RawData);
		}

		public override string ExportExtension => "unknown";

		public override string ExportPath => Path.Combine("AssetRipper", "UnknownAssets", ClassID.ToString());
	}
}

```

`AssetRipper.Fundamentals/Classes/UnreadableObject.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using System.IO;

namespace AssetRipper.Core.Classes
{
	public class UnreadableObject : UnityObjectBase, IHasNameString, IHasRawData
	{
		public byte[] RawData { get; private set; } = Array.Empty<byte>();
		public string NameString { get; set; } = "";

		public UnreadableObject(AssetInfo assetInfo) : base(assetInfo) { }

		public override void Read(AssetReader reader)
		{
			throw new NotSupportedException();
		}

		public void Read(AssetReader reader, int byteSize)
		{
			if (byteSize > 0)
			{
				RawData = reader.ReadBytes(byteSize);
			}
		}

		public override void Write(AssetWriter writer)
		{
			writer.Write(RawData);
		}

		public override string ExportExtension => "unreadable";

		public override string ExportPath => Path.Combine("AssetRipper", "UnreadableAssets", ClassID.ToString());
	}
}

```

`AssetRipper.Fundamentals/Classes/Utf8StringBase.cs`:

```cs
using AssetRipper.Core.Layout;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Text;

namespace AssetRipper.Core.Classes
{
	public abstract class Utf8StringBase : UnityAssetBase, IEquatable<Utf8StringBase>, IEquatable<string>
	{
		public Utf8StringBase() : base() { }
		public Utf8StringBase(LayoutInfo layout) : base(layout) { }

		public abstract byte[] Data { get; set; }

		public string String
		{
			get => Encoding.UTF8.GetString(Data);
			set => Data = Encoding.UTF8.GetBytes(value);
		}

		public static bool operator ==(Utf8StringBase? utf8String, string? str) => utf8String?.String == str;
		public static bool operator !=(Utf8StringBase? utf8String, string? str) => utf8String?.String != str;
		public static bool operator ==(string? str, Utf8StringBase? utf8String) => utf8String?.String == str;
		public static bool operator !=(string? str, Utf8StringBase? utf8String) => utf8String?.String != str;
		public static bool operator ==(Utf8StringBase? str1, Utf8StringBase? str2)
		{
			if (str1 is null || str2 is null)
			{
				return str1 is null && str2 is null;
			}

			if (str1.Data.Length != str2.Data.Length)
			{
				return false;
			}

			for (int i = 0; i < str1.Data.Length; i++)
			{
				if (str1.Data[i] != str2.Data[i])
				{
					return false;
				}
			}

			return true;
		}
		public static bool operator !=(Utf8StringBase? str1, Utf8StringBase? str2) => !(str1 == str2);

		public bool Equals(Utf8StringBase? other) => this == other;

		public bool Equals(string? other) => String.Equals(other);

		public override YamlNode ExportYamlEditor(IExportContainer container)
		{
			return new YamlScalarNode(String);
		}

		public override YamlNode ExportYamlRelease(IExportContainer container)
		{
			return new YamlScalarNode(String);
		}

		public bool CopyIfNullOrEmpty(Utf8StringBase? other)
		{
			if (Data is null || Data.Length == 0)
			{
				Data = CopyData(other?.Data);
				return true;
			}
			return false;
		}

		private static byte[] CopyData(byte[]? source)
		{
			if (source is null || source.Length == 0)
			{
				return Array.Empty<byte>();
			}
			else
			{
				byte[] destination = new byte[source.Length];
				Array.Copy(source!, destination, source.Length);
				return destination;
			}
		}

		public override bool Equals(object? obj)
		{
			if (obj is null)
			{
				return false;
			}
			else if (obj is Utf8StringBase utf8String)
			{
				return Equals(utf8String);
			}
			else if (obj is string str)
			{
				return Equals(str);
			}
			else
			{
				return false;
			}
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(Data);
		}

		public override string ToString()
		{
			return String;
		}
	}

	public static class Utf8StringBaseExtensions
	{
		public static string[] ToStringArray(this Utf8StringBase[] utf8Strings)
		{
			string[] result = new string[utf8Strings.Length];
			for (int i = 0; i < utf8Strings.Length; i++)
			{
				result[i] = utf8Strings[i].String;
			}
			return result;
		}
	}
}

```

`AssetRipper.Fundamentals/Configuration/BundledAssetsExportMode.cs`:

```cs
namespace AssetRipper.Core.Configuration
{
	public enum BundledAssetsExportMode
	{
		/// <summary>
		/// Bundled assets are treated the same as assets from other files.
		/// </summary>
		GroupByAssetType,
		/// <summary>
		/// Bundled assets are grouped by their asset bundle name.<br/>
		/// For example: Assets/Asset_Bundles/NameOfAssetBundle/InternalPath1/.../InternalPathN/assetName.extension
		/// </summary>
		GroupByBundleName,
		/// <summary>
		/// Bundled assets are exported without grouping.<br/>
		/// For example: Assets/InternalPath1/.../InternalPathN/bundledAssetName.extension
		/// </summary>
		DirectExport,
	}
}

```

`AssetRipper.Fundamentals/Configuration/CoreConfiguration.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Utils;
using System.IO;

namespace AssetRipper.Core.Configuration
{
	public class CoreConfiguration
	{
		#region Import Settings
		/// <summary>
		/// Disabling scripts can allow some games to export when they previously did not.
		/// </summary>
		public bool DisableScriptImport => ScriptContentLevel == ScriptContentLevel.Level0;
		/// <summary>
		/// The level of scripts to export
		/// </summary>
		public ScriptContentLevel ScriptContentLevel { get; set; }
		/// <summary>
		/// Including the streaming assets directory can cause some games to fail while exporting.
		/// </summary>
		public bool IgnoreStreamingAssets
		{
			get => StreamingAssetsMode == StreamingAssetsMode.Ignore;
			set
			{
				StreamingAssetsMode = value ? StreamingAssetsMode.Ignore : StreamingAssetsMode.Extract;
			}
		}
		/// <summary>
		/// How the StreamingAssets folder is handled
		/// </summary>
		public StreamingAssetsMode StreamingAssetsMode { get; set; }
		#endregion

		#region Export Settings
		/// <summary>
		/// The root path to export to
		/// </summary>
		public string ExportRootPath { get; set; } = "";
		/// <summary>
		/// The path to create a new unity project in
		/// </summary>
		public string ProjectRootPath => Path.Combine(ExportRootPath, "ExportedProject");
		public string AssetsPath => Path.Combine(ProjectRootPath, "Assets");
		public string ProjectSettingsPath => Path.Combine(ProjectRootPath, "ProjectSettings");
		public string AuxiliaryFilesPath => Path.Combine(ExportRootPath, "AuxiliaryFiles");
		/// <summary>
		/// Should objects get exported with dependencies or without?
		/// </summary>
		public bool ExportDependencies { get; set; }
		public BundledAssetsExportMode BundledAssetsExportMode { get; set; }
		/// <summary>
		/// A function to determine if an object is allowed to be exported.<br/>
		/// Set by default to allow everything.
		/// </summary>
		public Func<IUnityObjectBase, bool> Filter { get; set; } = DefaultFilterMethod;
		#endregion

		#region Project Settings
		public UnityVersion Version { get; private set; }
		public BuildTarget Platform { get; private set; }
		public TransferInstructionFlags Flags { get; private set; }
		#endregion

		#region Default Filter
		/// <summary>
		/// The default filter that allows everything
		/// </summary>
		public static Func<IUnityObjectBase, bool> DefaultFilter { get; } = DefaultFilterMethod;
		private static bool DefaultFilterMethod(IUnityObjectBase asset) => true;
		#endregion

		public CoreConfiguration() => ResetToDefaultValues();

		public void SetProjectSettings(Layout.LayoutInfo info) => SetProjectSettings(info.Version, info.Platform, info.Flags);
		public void SetProjectSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			Version = version;
			Platform = platform;
			Flags = flags;
		}

		public virtual void ResetToDefaultValues()
		{
			ScriptContentLevel = ScriptContentLevel.Level2;
			StreamingAssetsMode = StreamingAssetsMode.Extract;
			ExportRootPath = ExecutingDirectory.Combine("Ripped");
			ExportDependencies = false;
			BundledAssetsExportMode = BundledAssetsExportMode.GroupByBundleName;
			Filter = DefaultFilter;
		}

		public virtual void LogConfigurationValues()
		{
			Logger.Info(LogCategory.General, $"Configuration Settings:");
			Logger.Info(LogCategory.General, $"{nameof(ScriptContentLevel)}: {ScriptContentLevel}");
			Logger.Info(LogCategory.General, $"{nameof(StreamingAssetsMode)}: {StreamingAssetsMode}");
			Logger.Info(LogCategory.General, $"{nameof(ExportRootPath)}: {ExportRootPath}");
			Logger.Info(LogCategory.General, $"{nameof(ExportDependencies)}: {ExportDependencies}");
			Logger.Info(LogCategory.General, $"{nameof(BundledAssetsExportMode)}: {BundledAssetsExportMode}");
		}
	}
}

```

`AssetRipper.Fundamentals/Configuration/ScriptContentLevel.cs`:

```cs
namespace AssetRipper.Core.Configuration
{
	public enum ScriptContentLevel
	{
		/// <summary>
		/// Scripts are not exported.
		/// </summary>
		Level0,
		/// <summary>
		/// Methods are stripped from decompiled export.
		/// </summary>
		Level1,
		/// <summary>
		/// This level is the default. It exports full methods for Mono games and dummy methods for IL2Cpp games.
		/// </summary>
		Level2,
		/// <summary>
		/// IL2Cpp methods are safely recovered where possible.
		/// </summary>
		Level3,
		/// <summary>
		/// IL2Cpp methods are recovered without regard to safety.
		/// </summary>
		Level4,
	}
}

```

`AssetRipper.Fundamentals/Configuration/StreamingAssetsMode.cs`:

```cs
namespace AssetRipper.Core.Configuration
{
	public enum StreamingAssetsMode
	{
		Ignore,
		Extract,
		//Copy,
	}
}

```

`AssetRipper.Fundamentals/Converters/Files/SerializedFileMetadataConverter.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;

namespace AssetRipper.Core.Converters.Files
{
	public static class SerializedFileMetadataConverter
	{
		public static void CombineFormats(FormatVersion generation, SerializedFileMetadata origin)
		{
			if (!SerializedFileMetadata.HasEnableTypeTree(generation))
			{
				origin.EnableTypeTree = true;
			}
			for (int i = 0; i < origin.Types.Length; i++)
			{
				SerializedTypeConverter.CombineFormats(generation, origin.Types[i]);
			}
			if (generation >= FormatVersion.RefactorTypeData)
			{
				for (int i = 0; i < origin.Object.Length; i++)
				{
					ObjectInfo entry = origin.Object[i];
					SerializedType type = origin.Types[entry.TypeID];
					entry.ClassID = type.TypeID;
					entry.ScriptTypeIndex = type.ScriptTypeIndex;
					entry.Stripped = type.IsStrippedType;
				}
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Converters/Files/SerializedTypeConverter.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;

namespace AssetRipper.Core.Converters.Files
{
	public static class SerializedTypeConverter
	{
		public static void CombineFormats(FormatVersion generation, SerializedType origin)
		{
			origin.OldType.MaybeSetNamesFromBuffer();
		}
	}
}

```

`AssetRipper.Fundamentals/Equality/ArrayEquality.cs`:

```cs
namespace AssetRipper.Core.Equality
{
	public static class ArrayEquality
	{
		public static bool AreEqual<T>(T first, T second) where T : IEquatable<T>
		{
			if (first is null || second is null)
			{
				return first is null && second is null;
			}
			return first.Equals(second);
		}

		public static bool AreEqualArrays<T>(T[] first, T[] second) where T : IEquatable<T>
		{
			if (first is null || second is null)
			{
				return first is null && second is null;
			}
			if (first.Length != second.Length)
			{
				return false;
			}
			for (int i = 0; i < first.Length; i++)
			{
				if (!AreEqual(first[i], second[i]))
				{
					return false;
				}
			}
			return true;
		}

		public static bool AreEqualArrayArrays<T>(T[][] first, T[][] second) where T : IEquatable<T>
		{
			if (first is null || second is null)
			{
				return first is null && second is null;
			}
			if (first.Length != second.Length)
			{
				return false;
			}
			for (int i = 0; i < first.Length; i++)
			{
				if (!AreEqualArrays(first[i], second[i]))
				{
					return false;
				}
			}
			return true;
		}
	}
}

```

`AssetRipper.Fundamentals/Equality/IAlmostEquatable.cs`:

```cs
namespace AssetRipper.Core.Equality
{
	public interface IAlmostEquatable
	{
		/// <summary>
		/// Check if two objects are almost equal to each other by proportion
		/// </summary>
		/// <param name="value">The value to compare with</param>
		/// <param name="maximumProportion"></param>
		/// <remarks>
		/// Float comparisons are done by <see cref="NearEquality.AlmostEqualByProportion(float, float, float)"/><br/>
		/// Double comparisons are done by <see cref="NearEquality.AlmostEqualByProportion(double, double, float)"/>
		/// </remarks>
		/// <returns>True if the objects are equal or almost equal by proportion</returns>
		bool AlmostEqualByProportion(object value, float maximumProportion);

		/// <summary>
		/// Check if two objects are almost equal to each other by deviation
		/// </summary>
		/// <param name="value">The value to compare with</param>
		/// <param name="maximumDeviation">The positive maximum value deviation between two near equal decimal values</param>
		/// <remarks>
		/// Float comparisons are done by <see cref="NearEquality.AlmostEqualByDeviation(float, float, float)"/><br/>
		/// Double comparisons are done by <see cref="NearEquality.AlmostEqualByDeviation(double, double, float)"/>
		/// </remarks>
		/// <returns>True if the objects are equal or almost equal by deviation</returns>
		bool AlmostEqualByDeviation(object value, float maximumDeviation);
	}
}

```

`AssetRipper.Fundamentals/Equality/NearEquality.cs`:

```cs
namespace AssetRipper.Core.Equality
{
	public static class NearEquality
	{
		public static bool AlmostEqualByProportion(float value1, float value2, float maximumProportion)
		{
			if (float.IsNaN(value1) || float.IsNaN(value2))
			{
				return float.IsNaN(value1) && float.IsNaN(value2);
			}

			if (float.IsPositiveInfinity(value1) || float.IsPositiveInfinity(value2))
			{
				return float.IsPositiveInfinity(value1) && float.IsPositiveInfinity(value2);
			}

			if (float.IsNegativeInfinity(value1) || float.IsNegativeInfinity(value2))
			{
				return float.IsNegativeInfinity(value1) && float.IsNegativeInfinity(value2);
			}

			if (value1 == 0f || value2 == 0f)
			{
				return value1 == value2;
			}

			float proportion = (value1 > value2 ? value1 / value2 : value2 / value1) - 1f;

			return 0 <= proportion && proportion <= maximumProportion;
		}

		public static bool AlmostEqualByDeviation(float value1, float value2, float maximumDeviation)
		{
			if (float.IsNaN(value1) || float.IsNaN(value2))
			{
				return float.IsNaN(value1) && float.IsNaN(value2);
			}

			if (float.IsPositiveInfinity(value1) || float.IsPositiveInfinity(value2))
			{
				return float.IsPositiveInfinity(value1) && float.IsPositiveInfinity(value2);
			}

			if (float.IsNegativeInfinity(value1) || float.IsNegativeInfinity(value2))
			{
				return float.IsNegativeInfinity(value1) && float.IsNegativeInfinity(value2);
			}

			float deviation = System.Math.Abs(value1 - value2);

			return deviation <= maximumDeviation;
		}

		public static bool AlmostEqualByProportion(double value1, double value2, float maximumProportion)
		{
			if (double.IsNaN(value1) || double.IsNaN(value2))
			{
				return double.IsNaN(value1) && double.IsNaN(value2);
			}

			if (double.IsPositiveInfinity(value1) || double.IsPositiveInfinity(value2))
			{
				return double.IsPositiveInfinity(value1) && double.IsPositiveInfinity(value2);
			}

			if (double.IsNegativeInfinity(value1) || double.IsNegativeInfinity(value2))
			{
				return double.IsNegativeInfinity(value1) && double.IsNegativeInfinity(value2);
			}

			if (value1 == 0d || value2 == 0d)
			{
				return value1 == value2;
			}

			double proportion = (value1 > value2 ? value1 / value2 : value2 / value1) - 1d;

			return 0 <= proportion && proportion <= maximumProportion;
		}

		public static bool AlmostEqualByDeviation(double value1, double value2, float maximumDeviation)
		{
			if (double.IsNaN(value1) || double.IsNaN(value2))
			{
				return double.IsNaN(value1) && double.IsNaN(value2);
			}

			if (double.IsPositiveInfinity(value1) || double.IsPositiveInfinity(value2))
			{
				return double.IsPositiveInfinity(value1) && double.IsPositiveInfinity(value2);
			}

			if (double.IsNegativeInfinity(value1) || double.IsNegativeInfinity(value2))
			{
				return double.IsNegativeInfinity(value1) && double.IsNegativeInfinity(value2);
			}

			double deviation = System.Math.Abs(value1 - value2);

			return deviation <= maximumDeviation;
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/ArrayExtensions.cs`:

```cs
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.Extensions
{
	public static class ArrayExtensions
	{
		public static bool IsNullOrEmpty<T>([NotNullWhen(false)] this T[]? array) => array is null || array.Length == 0;
	}
}

```

`AssetRipper.Fundamentals/Extensions/BitArrayExtensions.cs`:

```cs
using System.Collections;

namespace AssetRipper.Core.Extensions
{
	public static class BitArrayExtensions
	{
		public static uint ToUInt32(this BitArray _this)
		{
			int value = 0;
			for (int i = 0; i < 8 * sizeof(uint); i++)
			{
				if (_this[i])
				{
					value |= 1 << i;
				}
			}
			return unchecked((uint)value);
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/ByteArrayExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Extensions
{
	public static class ByteArrayExtensions
	{
		public static byte[] SwapBytes(this byte[] _this, int size)
		{
			byte[] buffer = new byte[_this.Length];
			using (MemoryStream dst = new MemoryStream(buffer))
			{
				using BinaryWriter writer = new BinaryWriter(dst);
				using MemoryStream src = new MemoryStream(_this);
				using EndianReader reader = new EndianReader(src, EndianType.BigEndian);
				if (size == 2)
				{
					for (int i = 0; i < _this.Length; i += 2)
					{
						writer.Write(reader.ReadUInt16());
					}
				}
				else if (size == 4)
				{
					for (int i = 0; i < _this.Length; i += 4)
					{
						writer.Write(reader.ReadUInt32());
					}
				}
				else
				{
					throw new ArgumentException(size.ToString(), nameof(size));
				}
			}
			return buffer;
		}

		public static string ToFormattedHex(this byte[] _this)
		{
			StringBuilder sb = new StringBuilder();
			int count = 0;
			foreach (byte b in _this)
			{
				sb.Append(b.ToString("X2"));
				count++;
				if (count >= 16)
				{
					sb.AppendLine();
					count = 0;
				}
				else if (count % 4 == 0)
				{
					sb.Append('\t');
				}
				else
				{
					sb.Append(' ');
				}
			}
			return sb.ToString();
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/IDictionaryExtensions.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Extensions
{
	public static class IDictionaryExtensions
	{
		public static void AddRange<T1, T2>(this IDictionary<T1, T2> _this, IReadOnlyDictionary<T1, T2> source)
		{
			foreach (KeyValuePair<T1, T2> argument in source)
			{
				_this.Add(argument.Key, argument.Value);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/IEnumerableExtensions.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Extensions
{
	public static class IEnumerableExtensions
	{
		public static int IndexOf<T>(this IEnumerable<T> _this, Func<T, bool> predicate)
		{
			int index = 0;
			foreach (T t in _this)
			{
				if (predicate(t))
				{
					return index;
				}
				index++;
			}
			return -1;
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/IReadOnlyListExtensions.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Extensions
{
	public static class IReadOnlyListExtensions
	{
		public static int IndexOf<T>(this IReadOnlyList<T> _this, T value)
		{
			for (int i = 0; i < _this.Count; i++)
			{
				T t = _this[i];
				if (EqualityComparer<T>.Default.Equals(t, value))
				{
					return i;
				}
			}
			return -1;
		}

		public static bool Contains<T>(this IReadOnlyList<T> _this, T value)
		{
			return _this.IndexOf(value) > -1;
		}
	}
}

```

`AssetRipper.Fundamentals/Extensions/StreamExtensions.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Extensions
{
	public static class StreamExtensions
	{
		public static void ReadBuffer(this Stream _this, byte[] buffer, int offset, int count)
		{
			do
			{
				int read = _this.Read(buffer, offset, count);
				if (read == 0)
				{
					throw new Exception($"No data left");
				}
				offset += read;
				count -= read;
			}
			while (count > 0);
		}

		public static void CopyStream(this Stream _this, Stream dstStream)
		{
			byte[] buffer = new byte[BufferSize];
			while (true)
			{
				int offset = 0;
				int count = BufferSize;
				int toWrite = 0;

				int read;
				do
				{
					read = _this.Read(buffer, offset, count);
					offset += read;
					count -= read;
					toWrite += read;
				} while (read != 0);

				dstStream.Write(buffer, 0, toWrite);
				if (toWrite != BufferSize)
				{
					return;
				}
			}
		}

		public static void CopyStream(this Stream _this, Stream dstStream, long size)
		{
			byte[] buffer = new byte[BufferSize];
			for (long left = size; left > 0; left -= BufferSize)
			{
				int toRead = BufferSize < left ? BufferSize : (int)left;
				int offset = 0;
				int count = toRead;
				while (count > 0)
				{
					int read = _this.Read(buffer, offset, count);
					if (read == 0)
					{
						throw new Exception($"No data left");
					}
					offset += read;
					count -= read;
				}
				dstStream.Write(buffer, 0, toRead);
			}
		}

		private const int BufferSize = 81920;
	}
}

```

`AssetRipper.Fundamentals/Extensions/TextWriterExtensions.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Extensions
{
	public static class TextWriterExtensions
	{
		public static void WriteString(this TextWriter writer, string @string, int offset, int length)
		{
			for (int i = offset; i < offset + length; i++)
			{
				writer.Write(@string[i]);
			}
		}

		public static void WriteIndent(this TextWriter writer, int count)
		{
			for (int i = 0; i < count; i++)
			{
				writer.Write('\t');
			}
		}
	}
}

```

`AssetRipper.Fundamentals/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipper.Fundamentals/IO/AccessDictionary.cs`:

```cs
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.IO
{
	/// <summary>
	/// A wrapper for accessing the elements of an <see cref="AccessDictionaryBase{TKey, TValue}"/>
	/// </summary>
	/// <typeparam name="TKeyBase">The exposed key type, such as an interface</typeparam>
	/// <typeparam name="TValueBase">The exposed value type, such as an interface</typeparam>
	/// <typeparam name="TKey">The key type of the reference dictionary</typeparam>
	/// <typeparam name="TValue">The value type of the reference dictionary</typeparam>
	public sealed class AccessDictionary<TKey, TValue, TKeyBase, TValueBase> : AccessDictionaryBase<TKeyBase, TValueBase>
		where TKeyBase : notnull
		where TValueBase : notnull
		where TKey : notnull, TKeyBase, new()
		where TValue : notnull, TValueBase, new()
	{
		private readonly AssetDictionary<TKey, TValue> referenceDictionary;

		public AccessDictionary(AssetDictionary<TKey, TValue> referenceDictionary)
		{
			this.referenceDictionary = referenceDictionary;
		}

		/// <inheritdoc/>
		public override int Count => referenceDictionary.Count;

		/// <inheritdoc/>
		public override int Capacity
		{
			get => referenceDictionary.Capacity;
			set => referenceDictionary.Capacity = value;
		}

		/// <inheritdoc/>
		public override void Add(TKeyBase key, TValueBase value) => referenceDictionary.Add((TKey)key, (TValue)value);

		/// <inheritdoc/>
		public override void Add(NullableKeyValuePair<TKeyBase, TValueBase> pair) => Add(pair.Key, pair.Value);

		/// <inheritdoc/>
		public override void AddNew() => referenceDictionary.AddNew();

		/// <inheritdoc/>
		public override TKeyBase GetKey(int index) => referenceDictionary.GetKey(index);

		/// <inheritdoc/>
		public override void SetKey(int index, TKeyBase newKey) => referenceDictionary.SetKey(index, (TKey)newKey);

		/// <inheritdoc/>
		public override TValueBase GetValue(int index) => referenceDictionary.GetValue(index);

		/// <inheritdoc/>
		public override void SetValue(int index, TValueBase newValue) => referenceDictionary.SetValue(index, (TValue)newValue);

		public override NullableKeyValuePair<TKeyBase, TValueBase> GetPair(int index) => CastPair(referenceDictionary.GetPair(index));

		/// <inheritdoc/>
		public override int IndexOf(NullableKeyValuePair<TKeyBase, TValueBase> item) => referenceDictionary.IndexOf(CastPair(item));

		/// <inheritdoc/>
		public override void Insert(int index, NullableKeyValuePair<TKeyBase, TValueBase> item) => referenceDictionary.Insert(index, CastPair(item));

		/// <inheritdoc/>
		public override void RemoveAt(int index) => referenceDictionary.RemoveAt(index);

		/// <inheritdoc/>
		public override void Clear() => referenceDictionary.Clear();

		/// <inheritdoc/>
		public override bool Contains(NullableKeyValuePair<TKeyBase, TValueBase> item) => referenceDictionary.Contains(CastPair(item));

		/// <inheritdoc/>
		public override void CopyTo(NullableKeyValuePair<TKeyBase, TValueBase>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException(nameof(array));
			}

			if (arrayIndex < 0 || arrayIndex >= array.Length - Count)
			{
				throw new ArgumentOutOfRangeException(nameof(arrayIndex));
			}

			for (int i = 0; i < Count; i++)
			{
				array[i + arrayIndex] = GetPair(i);
			}
		}

		/// <inheritdoc/>
		public override bool Remove(NullableKeyValuePair<TKeyBase, TValueBase> item) => referenceDictionary.Remove(CastPair(item));

		protected override bool TryGetSinglePairForKey(TKeyBase key, [NotNullWhen(true)] out NullableKeyValuePair<TKeyBase, TValueBase>? pair)
		{
			if (key is null)
			{
				throw new ArgumentNullException(nameof(key));
			}

			int hash = key.GetHashCode();
			bool found = false;
			pair = null;
			for (int i = Count - 1; i > -1; i--)
			{
				NullableKeyValuePair<TKey, TValue> p = referenceDictionary.GetPair(i);
				if (p.Key is not null && p.Key.GetHashCode() == hash && key.Equals(p.Key))
				{
					if (found)
					{
						throw new Exception("Found more than one matching key");
					}
					else
					{
						found = true;
						pair = CastPair(p);
					}
				}
			}
			return found;
		}

		private static NullableKeyValuePair<TKey, TValue> CastPair(NullableKeyValuePair<TKeyBase, TValueBase> pair)
		{
			return new NullableKeyValuePair<TKey, TValue>((TKey)pair.Key, (TValue)pair.Value);
		}

		private static NullableKeyValuePair<TKeyBase, TValueBase> CastPair(NullableKeyValuePair<TKey, TValue> pair)
		{
			return new NullableKeyValuePair<TKeyBase, TValueBase>(pair.Key, pair.Value);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AccessDictionaryBase.cs`:

```cs
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace AssetRipper.Core.IO
{
	/// <summary>
	/// Access the contents of a dictionary
	/// </summary>
	/// <typeparam name="TKey">The exposed key type, such as an interface, base type, or primitive type</typeparam>
	/// <typeparam name="TValue">The exposed value type, such as an interface, base type, or primitive type</typeparam>
	public abstract class AccessDictionaryBase<TKey, TValue> : IEnumerable<NullableKeyValuePair<TKey, TValue>>
		where TKey : notnull
		where TValue : notnull
	{
		/// <summary>
		/// The capacity of the dictionary 
		/// </summary>
		public abstract int Capacity { get; set; }

		/// <summary>
		/// The number of pairs in the dictionary
		/// </summary>
		public abstract int Count { get; }

		/// <summary>
		/// The keys in the dictionary
		/// </summary>
		public IEnumerable<TKey> Keys => keyEnumerable ??= new KeyEnumerable(this);
		private KeyEnumerable? keyEnumerable;

		/// <summary>
		/// The values in the dictionary
		/// </summary>
		public IEnumerable<TValue> Values => valueEnumerable ??= new ValueEnumerable(this);
		private ValueEnumerable? valueEnumerable;

		/// <summary>
		/// Add a pair to the dictionary
		/// </summary>
		/// <remarks>
		/// This method is not necessarily type safe. 
		/// It could throw exceptions if used improperly.
		/// </remarks>
		/// <param name="key">The key to be added</param>
		/// <param name="value">The value to be added</param>
		public abstract void Add(TKey key, TValue value);

		/// <summary>
		/// Add a pair to the dictionary
		/// </summary>
		/// <remarks>
		/// This method is not necessarily type safe. 
		/// It could throw exceptions if used improperly.
		/// </remarks>
		/// <param name="pair">The pair to be added</param>
		public abstract void Add(NullableKeyValuePair<TKey, TValue> pair);

		/// <summary>
		/// Add a new pair to the dictionary
		/// </summary>
		public abstract void AddNew();

		public bool ContainsKey(TKey key) => Keys.Contains(key);

		/// <summary>
		/// Get a key in the dictionary
		/// </summary>
		/// <param name="index">The index to access</param>
		/// <returns>The key at the specified index</returns>
		public abstract TKey GetKey(int index);

		/// <summary>
		/// Get a value in the dictionary
		/// </summary>
		/// <param name="index">The index to access</param>
		/// <returns>The value at the specified index</returns>
		public abstract TValue GetValue(int index);

		/// <summary>
		/// Get a pair in the dictionary
		/// </summary>
		/// <param name="index">The index to access</param>
		/// <returns>The pair at the specified index</returns>
		public abstract NullableKeyValuePair<TKey, TValue> GetPair(int index);

		/// <summary>
		/// Set a key in the dictionary
		/// </summary>
		/// <remarks>
		/// This method is not necessarily type safe. 
		/// It could throw exceptions if used improperly.
		/// </remarks>
		/// <param name="index">The index to access</param>
		/// <param name="newKey">The new key to be assigned</param>
		public abstract void SetKey(int index, TKey newKey);

		/// <summary>
		/// Set a value in the dictionary
		/// </summary>
		/// <remarks>
		/// This method is not necessarily type safe. 
		/// It could throw exceptions if used improperly.
		/// </remarks>
		/// <param name="index">The index to access</param>
		/// <param name="newValue">The new value to be assigned</param>
		public abstract void SetValue(int index, TValue newValue);

		/// <inheritdoc/>
		public bool IsReadOnly => false;

		/// <inheritdoc/>
		public abstract int IndexOf(NullableKeyValuePair<TKey, TValue> item);

		/// <inheritdoc/>
		public abstract void Insert(int index, NullableKeyValuePair<TKey, TValue> item);

		/// <inheritdoc/>
		public abstract void RemoveAt(int index);

		/// <inheritdoc/>
		public abstract void Clear();

		/// <inheritdoc/>
		public abstract bool Contains(NullableKeyValuePair<TKey, TValue> item);

		/// <inheritdoc/>
		public abstract void CopyTo(NullableKeyValuePair<TKey, TValue>[] array, int arrayIndex);

		/// <inheritdoc/>
		public abstract bool Remove(NullableKeyValuePair<TKey, TValue> item);

		protected NullableKeyValuePair<TKey, TValue> GetSinglePairForKey(TKey key)
		{
			if (TryGetSinglePairForKey(key, out NullableKeyValuePair<TKey, TValue>? pair))
			{
				return pair;
			}
			else
			{
				throw new KeyNotFoundException($"Key not found: {key?.ToString()}");
			}
		}

		protected abstract bool TryGetSinglePairForKey(TKey key, [NotNullWhen(true)] out NullableKeyValuePair<TKey, TValue>? pair);

		/// <summary>
		/// Access a value in the dictionary
		/// </summary>
		/// <remarks>
		/// The get method is type safe.
		/// The set method is not necessarily type safe
		/// and could throw exceptions if used improperly.
		/// Both will throw if the key isn't unique.
		/// </remarks>
		public TValue this[TKey key]
		{
			get => GetSinglePairForKey(key).Value;
			set
			{
				if (TryGetSinglePairForKey(key, out NullableKeyValuePair<TKey, TValue>? pair))
				{
					pair.Value = value;
				}
				else
				{
					Add(key, value);
				}
			}
		}

		public bool TryGetValue(TKey key, [NotNullWhen(true)] out TValue? value)
		{
			if (TryGetSinglePairForKey(key, out NullableKeyValuePair<TKey, TValue>? pair))
			{
				value = pair.Value;
				return value is not null;
			}
			else
			{
				value = default;
				return false;
			}
		}

		/// <inheritdoc/>
		public IEnumerator<NullableKeyValuePair<TKey, TValue>> GetEnumerator()
		{
			for (int i = 0; i < Count; i++)
			{
				yield return GetPair(i);
			}
		}

		/// <inheritdoc/>
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();

		private class KeyEnumerable : IEnumerable<TKey>
		{
			private readonly AccessDictionaryBase<TKey, TValue> dictionary;

			public KeyEnumerable(AccessDictionaryBase<TKey, TValue> dictionary)
			{
				this.dictionary = dictionary;
			}

			public IEnumerator<TKey> GetEnumerator()
			{
				for (int i = 0; i < dictionary.Count; i++)
				{
					yield return dictionary.GetKey(i);
				}
			}

			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		private class ValueEnumerable : IEnumerable<TValue>
		{
			private readonly AccessDictionaryBase<TKey, TValue> dictionary;

			public ValueEnumerable(AccessDictionaryBase<TKey, TValue> dictionary)
			{
				this.dictionary = dictionary;
			}

			public IEnumerator<TValue> GetEnumerator()
			{
				for (int i = 0; i < dictionary.Count; i++)
				{
					yield return dictionary.GetValue(i);
				}
			}

			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AccessList.cs`:

```cs
namespace AssetRipper.Core.IO
{
	public sealed class AccessList<T, TBase> : AccessListBase<TBase>
		where TBase : notnull
		where T : notnull, TBase, new()
	{
		private readonly AssetList<T> referenceList;

		public AccessList(AssetList<T> referenceList)
		{
			this.referenceList = referenceList;
		}

		/// <inheritdoc/>
		public override int Count => referenceList.Count;

		/// <inheritdoc/>
		public override int Capacity
		{
			get => referenceList.Capacity;
			set => referenceList.Capacity = value;
		}

		/// <inheritdoc/>
		public override void Add(TBase item) => referenceList.Add((T)item);

		/// <inheritdoc/>
		public override TBase AddNew() => referenceList.AddNew();

		/// <inheritdoc/>
		public override int IndexOf(TBase item) => referenceList.IndexOf((T)item);

		/// <inheritdoc/>
		public override void Insert(int index, TBase item) => referenceList.Insert(index, (T)item);

		/// <inheritdoc/>
		public override void RemoveAt(int index) => referenceList.RemoveAt(index);

		/// <inheritdoc/>
		public override void Clear() => referenceList.Clear();

		/// <inheritdoc/>
		public override bool Contains(TBase item) => referenceList.Contains((T)item);

		/// <inheritdoc/>
		public override void CopyTo(TBase[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException(nameof(array));
			}

			if (arrayIndex < 0 || arrayIndex >= array.Length - Count)
			{
				throw new ArgumentOutOfRangeException(nameof(arrayIndex));
			}

			for (int i = 0; i < Count; i++)
			{
				array[i + arrayIndex] = this[i];
			}
		}

		public override int EnsureCapacity(int capacity) => referenceList.EnsureCapacity(capacity);

		/// <inheritdoc/>
		public override bool Remove(TBase item) => referenceList.Remove((T)item);

		/// <inheritdoc/>
		public override TBase this[int index]
		{
			get => referenceList[index];
			set => referenceList[index] = (T)value;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AccessListBase.cs`:

```cs
using System.Collections;
using System.Collections.Generic;

namespace AssetRipper.Core.IO
{
	public abstract class AccessListBase<T> : IList<T>, IReadOnlyList<T>
		where T : notnull
	{
		/// <inheritdoc/>
		public abstract T this[int index] { get; set; }

		/// <inheritdoc/>
		public abstract int Count { get; }

		/// <summary>
		/// The capacity of the list 
		/// </summary>
		public abstract int Capacity { get; set; }

		/// <inheritdoc/>
		public bool IsReadOnly => false;

		/// <inheritdoc/>
		public abstract void Add(T item);

		public void AddRange(IEnumerable<T> range)
		{
			foreach (T item in range)
			{
				Add(item);
			}
		}

		public void AddRange(T[] array)
		{
			EnsureCapacity(Count + array.Length);
			for (int i = 0; i < array.Length; i++)
			{
				Add(array[i]);
			}
		}

		/// <summary>
		/// Add a new element to the list
		/// </summary>
		public abstract T AddNew();

		/// <inheritdoc/>
		public abstract void Clear();

		/// <inheritdoc/>
		public abstract bool Contains(T item);

		/// <inheritdoc/>
		public abstract void CopyTo(T[] array, int arrayIndex);

		public abstract int EnsureCapacity(int capacity);

		/// <inheritdoc/>
		public abstract int IndexOf(T item);

		/// <inheritdoc/>
		public abstract void Insert(int index, T item);

		/// <inheritdoc/>
		public abstract bool Remove(T item);

		/// <inheritdoc/>
		public abstract void RemoveAt(int index);

		/// <inheritdoc/>
		public IEnumerator<T> GetEnumerator()
		{
			for (int i = 0; i < Count; i++)
			{
				yield return this[i];
			}
		}

		/// <inheritdoc/>
		IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
	}
}

```

`AssetRipper.Fundamentals/IO/AdjustableStream.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.IO
{
	/// <summary>
	/// A wrapper stream with moveable boundaries
	/// </summary>
	public class AdjustableStream : Stream
	{
		private readonly Stream m_stream;
		private readonly bool m_leaveOpen;
		private long m_minPosition = 0;
		private long m_maxPosition = long.MaxValue;
		private bool m_isDisposed;

		public AdjustableStream(Stream baseStream) : this(baseStream, true) { }

		public AdjustableStream(Stream baseStream, bool leaveOpen)
		{
			m_stream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));
			m_leaveOpen = leaveOpen;
		}

		/// <inheritdoc/>
		public override bool CanRead => m_stream.CanRead;
		/// <inheritdoc/>
		public override bool CanWrite => m_stream.CanWrite;
		/// <inheritdoc/>
		public override bool CanSeek => false;


		/// <inheritdoc/>
		public override long Position
		{
			get => m_stream.Position;
			set
			{
				if (value < m_minPosition || m_maxPosition < value)
				{
					throw new ArgumentOutOfRangeException(nameof(value), "New position must be between the minimum and maximum positions, inclusive");
				}

				m_stream.Position = value;
			}
		}
		/// <inheritdoc/>
		public override long Length => System.Math.Min(m_maxPosition, m_stream.Length) - m_minPosition;
		public long MinPosition => m_minPosition;
		public long MaxPosition => m_maxPosition;

		public void ResetPositionBoundaries()
		{
			m_minPosition = 0;
			m_maxPosition = long.MaxValue;
		}

		public void SetPositionBoundaries(long minimumPosition, long maximumPosition, long newPosition)
		{
			if (minimumPosition < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(minimumPosition), "Cannot be negative");
			}

			if (maximumPosition < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(maximumPosition), "Cannot be negative");
			}

			if (newPosition < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(newPosition), "Cannot be negative");
			}

			if (maximumPosition < minimumPosition)
			{
				throw new ArgumentOutOfRangeException(nameof(maximumPosition), "Maximum cannot be less than the minimum");
			}

			if (newPosition < minimumPosition || maximumPosition < newPosition)
			{
				throw new ArgumentOutOfRangeException(nameof(newPosition), "New position must be between the minimum and maximum positions, inclusive");
			}

			m_minPosition = minimumPosition;
			m_maxPosition = maximumPosition;
			if (Position != newPosition)
			{
				Position = newPosition;
			}
		}

		/// <inheritdoc/>
		public override void Flush() => m_stream.Flush();

		/// <inheritdoc/>
		public override int Read(byte[] buffer, int offset, int count)
		{
			count = (int)System.Math.Max(System.Math.Min(count, m_maxPosition - Position), 0);
			return m_stream.Read(buffer, offset, count);
		}

		/// <inheritdoc/>
		public override long Seek(long offset, SeekOrigin origin)
		{
			throw new NotSupportedException();
		}

		/// <inheritdoc/>
		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		/// <inheritdoc/>
		public override void Write(byte[] buffer, int offset, int count)
		{
			if (Position + count > m_maxPosition)
			{
				throw new ArgumentOutOfRangeException(nameof(count), "Cannot write past the max position");
			}
			m_stream.Write(buffer, offset, count);
		}

		~AdjustableStream()
		{
			Dispose(false);
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing)
		{
			if (!m_isDisposed)
			{
				if (!m_leaveOpen)
				{
					m_stream?.Dispose();
				}
				m_isDisposed = true;
			}
			base.Dispose(disposing);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/AssetReader.cs`:

```cs
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files;
using AssetRipper.IO.Endian;
using System.IO;
using System.Text;


namespace AssetRipper.Core.IO.Asset
{
	public sealed class AssetReader : EndianReader
	{
		public AssetReader(Stream stream, EndianType endian, LayoutInfo info) : this(new AdjustableStream(stream), endian, info) { }
		private AssetReader(AdjustableStream stream, EndianType endian, LayoutInfo info) : base(stream, endian, info.IsAlignArrays)
		{
			Info = info;
			IsAlignString = info.IsAlign;
			AdjustableStream = stream;
		}

		public override string ReadString()
		{
			int length = ReadInt32();
			if (length == 0)
			{
				return string.Empty;
			}

			byte[] buffer = ReadStringBuffer(length);
			string result = Encoding.UTF8.GetString(buffer, 0, length);
			if (IsAlignString)
			{
				AlignStream();
			}
			return result;
		}

		public T ReadAsset<T>() where T : IAssetReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadAssetArray<T>() where T : IAssetReadable, new() => ReadAssetArray<T>(true);
		public T[] ReadAssetArray<T>(bool allowAlignment) where T : IAssetReadable, new()
		{
			int count = ReadInt32();
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(count), $"Cannot be negative: {count}");
			}

			T[] array = count == 0 ? Array.Empty<T>() : new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				array[i] = instance;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public T[][] ReadAssetArrayArray<T>() where T : IAssetReadable, new() => ReadAssetArrayArray<T>(true);
		public T[][] ReadAssetArrayArray<T>(bool allowAlignment) where T : IAssetReadable, new()
		{
			int count = ReadInt32();
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(count), $"Cannot be negative: {count}");
			}

			T[][] array = count == 0 ? Array.Empty<T[]>() : new T[count][];
			for (int i = 0; i < count; i++)
			{
				T[] innerArray = ReadAssetArray<T>();
				array[i] = innerArray;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public AssetList<T> ReadAssetList<T>() where T : IAssetReadable, new() => ReadAssetList<T>(true);
		public AssetList<T> ReadAssetList<T>(bool allowAlignment) where T : IAssetReadable, new()
		{
			int count = ReadInt32();
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(count), $"Cannot be negative: {count}");
			}

			AssetList<T> list = new AssetList<T>();
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				list.Add(instance);
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
			return list;
		}

		public AssetList<AssetList<T>> ReadAssetListList<T>() where T : IAssetReadable, new() => ReadAssetListList<T>(true);
		public AssetList<AssetList<T>> ReadAssetListList<T>(bool allowAlignment) where T : IAssetReadable, new()
		{
			int count = ReadInt32();
			if (count < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(count), $"Cannot be negative: {count}");
			}

			AssetList<AssetList<T>> list = new AssetList<AssetList<T>>();
			for (int i = 0; i < count; i++)
			{
				AssetList<T> innerList = ReadAssetList<T>();
				list.Add(innerList);
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return list;
		}

		public override string ToString()
		{
			return $"{nameof(AssetReader)} ({Platform} {Version})";
		}

		public LayoutInfo Info { get; }
		public UnityVersion Version => Info.Version;
		public BuildTarget Platform => Info.Platform;
		public TransferInstructionFlags Flags => Info.Flags;
		public AdjustableStream AdjustableStream { get; }

		private bool IsAlignString { get; }
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/AssetWriter.cs`:

```cs
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files;
using AssetRipper.IO.Endian;
using System.IO;
using System.Text;

namespace AssetRipper.Core.IO.Asset
{
	public sealed class AssetWriter : EndianWriter
	{
		public AssetWriter(Stream stream, EndianType endian, LayoutInfo info) : base(stream, endian, info.IsAlignArrays)
		{
			Info = info;
			IsAlignString = info.IsAlign;
		}

		public override void Write(char value)
		{
			FillInnerBuffer(value);
			Write(m_buffer, 0, sizeof(char));
		}

		public override void Write(string value)
		{
			char[] valueArray = value.ToCharArray();
			int count = Encoding.UTF8.GetByteCount(valueArray, 0, valueArray.Length);
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			byte[] buffer = count <= m_buffer.Length ? m_buffer : new byte[count];
			int written = Encoding.UTF8.GetBytes(valueArray, 0, valueArray.Length, buffer, 0);
			if (written != count)
			{
				throw new Exception($"Written {written} but expected {count}");
			}

			Write(buffer, 0, written);
			if (IsAlignString)
			{
				AlignStream();
			}
		}

		public override void Write(char[] buffer, int index, int count)
		{
			int byteIndex = 0;
			int byteCount = buffer.Length * sizeof(char);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(char), index++)
				{
					FillInnerBuffer(buffer[index], i);
				}

				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
		}

		public void WriteAsset<T>(T value) where T : IAssetWritable
		{
			value.Write(this);
		}

		public void WriteAssetArray<T>(T[] buffer) where T : IAssetWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i].Write(this);
			}

			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteAssetArray<T>(T[][] buffer) where T : IAssetWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.GetLength(0); i++)
			{
				WriteAssetArray(buffer[i]);
			}

			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public LayoutInfo Info { get; }
		public UnityVersion Version => Info.Version;
		public BuildTarget Platform => Info.Platform;
		public TransferInstructionFlags Flags => Info.Flags;
		private bool IsAlignString { get; }
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/IAsset.cs`:

```cs
namespace AssetRipper.Core.IO.Asset
{
	public interface IAsset : IAssetReadable, IAssetWritable, IYamlExportable
	{
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/IAssetReadable.cs`:

```cs
namespace AssetRipper.Core.IO.Asset
{
	public interface IAssetReadable
	{
		void Read(AssetReader reader);
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/IAssetWritable.cs`:

```cs
namespace AssetRipper.Core.IO.Asset
{
	public interface IAssetWritable
	{
		void Write(AssetWriter writer);
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/IYamlExportable.cs`:

```cs
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.IO.Asset
{
	public interface IYamlExportable
	{
		YamlNode ExportYaml(IExportContainer container);
	}
}

```

`AssetRipper.Fundamentals/IO/Asset/TransferInstructionFlags.cs`:

```cs
namespace AssetRipper.Core.IO.Asset
{
	[Flags]
	public enum TransferInstructionFlags : uint
	{
		NoTransferInstructionFlags = 0x0,
		NeedsInstanceIDRemapping = 0x1,
		/// <summary>
		/// Only serialize data needed for .meta files
		/// </summary>
		AssetMetaDataOnly = 0x2,
		YamlGlobalPPtrReference = 0x4,
		LoadAndUnloadAssetsDuringBuild = 0x8,
		SerializeDebugProperties = 0x10,
		IgnoreDebugPropertiesForIndex = 0x20,
		BuildPlayerOnlySerializeBuildProperties = 0x40,
		Workaround35MeshSerializationFuckup = 0x80,
		/// <summary>
		/// Is this a game or a project file 
		/// </summary>
		SerializeGameRelease = 0x100,
		SwapEndianess = 0x200,
		SaveGlobalManagers = 0x400,
		DontReadObjectsFromDiskBeforeWriting = 0x800,
		SerializeMonoReload = 0x1000,
		DontRequireAllMetaFlags = 0x2000,
		SerializeForPrefabSystem = 0x4000,
		WarnAboutLeakedObjects = 0x8000,
		EditorPlayMode = 0x40000,
		BuildResourceImage = 0x80000,
		SerializeEditorMinimalScene = 0x200000,
		GenerateBakedPhysixMeshes = 0x400000,
		ThreadedSerialization = 0x800000,
		IsBuiltinResourcesFile = 0x1000000,
		PerformUnloadDependencyTracking = 0x2000000,
		DisableWriteTypeTree = 0x4000000,
		AutoreplaceEditorWindow = 0x8000000,
		DontCreateMonoBehaviourScriptWrapper = 0x10000000,
		SerializeForInspector = 0x20000000,
		SerializedAssetBundleVersion = 0x40000000,
		AllowTextSerialization = 0x80000000,
	}

	public static class TransferInstructionFlagsExtensions
	{
		public static bool IsRelease(this TransferInstructionFlags _this)
		{
			return (_this & TransferInstructionFlags.SerializeGameRelease) != 0;
		}
		public static bool IsForPrefab(this TransferInstructionFlags _this)
		{
			return (_this & TransferInstructionFlags.SerializeForPrefabSystem) != 0;
		}
		public static bool IsEditorScene(this TransferInstructionFlags _this)
		{
			return (_this & TransferInstructionFlags.SerializeEditorMinimalScene) != 0;
		}
		public static bool IsBuiltinResources(this TransferInstructionFlags _this)
		{
			return (_this & TransferInstructionFlags.IsBuiltinResourcesFile) != 0;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AssetDictionary.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.IO
{
	/// <summary>
	/// A dictionary class supporting non-unique keys
	/// </summary>
	/// <typeparam name="TKey">The type of the keys in the dictionary.</typeparam>
	/// <typeparam name="TValue">The type of the values in the dictionary.</typeparam>
	public sealed class AssetDictionary<TKey, TValue> : AccessDictionaryBase<TKey, TValue>, IDependent
		where TKey : notnull, new()
		where TValue : notnull, new()
	{
		private static readonly bool isDependentType = NullableKeyValuePair<TKey, TValue>.IsDependentType;
		private const int DefaultCapacity = 4;
		private NullableKeyValuePair<TKey, TValue>[] pairs;
		private int count = 0;

		public AssetDictionary() : this(DefaultCapacity) { }

		public AssetDictionary(int capacity)
		{
			pairs = capacity == 0 ? Array.Empty<NullableKeyValuePair<TKey, TValue>>() : new NullableKeyValuePair<TKey, TValue>[capacity];
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			if (isDependentType)
			{
				foreach (NullableKeyValuePair<TKey, TValue> keyValuePair in this)
				{
					if (keyValuePair != null)
					{
						foreach (PPtr<IUnityObjectBase> dependency in keyValuePair.FetchDependencies(context))
						{
							yield return dependency;
						}
					}
				}
			}
		}

		/// <inheritdoc/>
		public override int Count => count;

		/// <inheritdoc/>
		public override int Capacity
		{
			get => pairs.Length;
			set
			{
				if (value < count)
				{
					throw new ArgumentOutOfRangeException(nameof(value));
				}

				if (value != pairs.Length)
				{
					if (value > 0)
					{
						NullableKeyValuePair<TKey, TValue>[] newPairs = new NullableKeyValuePair<TKey, TValue>[value];
						if (count > 0)
						{
							Array.Copy(pairs, newPairs, count);
						}
						pairs = newPairs;
					}
					else
					{
						pairs = Array.Empty<NullableKeyValuePair<TKey, TValue>>();
					}
				}
			}
		}

		/// <inheritdoc/>
		public override void Add(TKey key, TValue value)
		{
			Add(new NullableKeyValuePair<TKey, TValue>(key, value));
		}

		/// <inheritdoc/>
		public override void Add(NullableKeyValuePair<TKey, TValue> pair)
		{
			if (count == Capacity)
			{
				Grow(count + 1);
			}

			pairs[count] = pair;
			count++;
		}

		/// <inheritdoc/>
		public override void AddNew() => Add(new TKey(), new TValue());

		public void AddRange(IEnumerable<NullableKeyValuePair<TKey, TValue>> range)
		{
			foreach (NullableKeyValuePair<TKey, TValue> pair in range)
			{
				Add(pair);
			}
		}

		/// <inheritdoc/>
		public override TKey GetKey(int index)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			return pairs[index].Key;
		}

		/// <inheritdoc/>
		public override void SetKey(int index, TKey newKey)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			pairs[index] = new NullableKeyValuePair<TKey, TValue>(newKey, pairs[index].Value);
		}

		/// <inheritdoc/>
		public override TValue GetValue(int index)
		{
			if (index < 0 || index >= count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			return pairs[index].Value;
		}

		/// <inheritdoc/>
		public override void SetValue(int index, TValue newValue)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			pairs[index] = new KeyValuePair<TKey, TValue>(pairs[index].Key, newValue);
		}

		public override NullableKeyValuePair<TKey, TValue> GetPair(int index)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			return pairs[index];
		}

		/// <inheritdoc/>
		public override int IndexOf(NullableKeyValuePair<TKey, TValue> item) => Array.IndexOf(pairs, item, 0, count);

		/// <inheritdoc/>
		public override void Insert(int index, NullableKeyValuePair<TKey, TValue> item)
		{
			// Note that insertions at the end are legal.
			if ((uint)index > (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			if (count == pairs.Length)
			{
				Grow(count + 1);
			}

			if (index < count)
			{
				Array.Copy(pairs, index, pairs, index + 1, count - index);
			}

			pairs[index] = item;
			count++;
		}

		/// <inheritdoc/>
		public override void RemoveAt(int index)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			count--;
			if (index < count)
			{
				Array.Copy(pairs, index + 1, pairs, index, count - index);
			}
#pragma warning disable CS8625 // Cannot convert null literal to non-nullable reference type.
			pairs[count] = default;
#pragma warning restore CS8625 // Cannot convert null literal to non-nullable reference type.
		}

		/// <inheritdoc/>
		public override void Clear()
		{
			if (count > 0)
			{
				Array.Clear(pairs, 0, count); // Clear the elements so that the gc can reclaim the references.
			}
			count = 0;
		}

		/// <inheritdoc/>
		public override bool Contains(NullableKeyValuePair<TKey, TValue> item)
		{
			return IndexOf(item) >= 0;
		}

		/// <inheritdoc/>
		public override void CopyTo(NullableKeyValuePair<TKey, TValue>[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException(nameof(array));
			}

			if (arrayIndex < 0 || arrayIndex >= array.Length - count)
			{
				throw new ArgumentOutOfRangeException(nameof(arrayIndex));
			}

			Array.Copy(pairs, 0, array, arrayIndex, count);
		}

		/// <inheritdoc/>
		public override bool Remove(NullableKeyValuePair<TKey, TValue> item)
		{
			int index = IndexOf(item);
			if (index >= 0)
			{
				RemoveAt(index);
				return true;
			}
			return false;
		}

		protected override bool TryGetSinglePairForKey(TKey key, [NotNullWhen(true)] out NullableKeyValuePair<TKey, TValue>? pair)
		{
			if (key is null)
			{
				throw new ArgumentNullException(nameof(key));
			}

			int hash = key.GetHashCode();
			bool found = false;
			pair = null;
			for (int i = Count - 1; i > -1; i--)
			{
				NullableKeyValuePair<TKey, TValue> p = pairs[i];
				if (p.Key is not null && p.Key.GetHashCode() == hash && key.Equals(p.Key))
				{
					if (found)
					{
						throw new Exception("Found more than one matching key");
					}
					else
					{
						found = true;
						pair = p;
					}
				}
			}
			return found;
		}

		/// <summary>
		/// Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
		/// If the current capacity of the list is less than specified <paramref name="capacity"/>,
		/// the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
		/// </summary>
		/// <param name="capacity">The minimum capacity to ensure.</param>
		/// <returns>The new capacity of this list.</returns>
		public int EnsureCapacity(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(capacity));
			}
			if (pairs.Length < capacity)
			{
				Grow(capacity);
			}

			return pairs.Length;
		}

		private void Grow(int capacity)
		{
			long newcapacity = pairs.Length == 0 ? DefaultCapacity : 2L * pairs.Length;

			// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
			// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
			if (newcapacity > Array.MaxLength)
			{
				newcapacity = Array.MaxLength;
			}

			// If the computed capacity is still less than specified, set to the original argument.
			// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.
			if (newcapacity < capacity)
			{
				newcapacity = capacity;
			}

			Capacity = (int)newcapacity;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AssetDictionaryExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.IO
{
	public static class AssetDictionaryExtensions
	{
		public static NullableKeyValuePair<TKeyBase, TValueBase>[] ToCastedArray<TKey, TValue, TKeyBase, TValueBase>(this AssetDictionary<TKey, TValue> dictionary)
			where TKeyBase : notnull
			where TValueBase : notnull
			where TKey : notnull, TKeyBase, new()
			where TValue : notnull, TValueBase, new()
		{
			NullableKeyValuePair<TKeyBase, TValueBase>[] result = new NullableKeyValuePair<TKeyBase, TValueBase>[dictionary.Count];
			for (int i = 0; i < result.Length; i++)
			{
				NullableKeyValuePair<TKey, TValue> dictEntry = dictionary.GetPair(i);
				result[i] = new NullableKeyValuePair<TKeyBase, TValueBase>(dictEntry.Key, dictEntry.Value);
			}
			return result;
		}

		public static NullableKeyValuePair<TKeyBase, PPtr<TValueElement>>[] ToPPtrArray<TKey, TValue, TKeyBase, TValueElement>(this AssetDictionary<TKey, TValue> dictionary)
			where TKeyBase : notnull
			where TKey : notnull, TKeyBase, new()
			where TValue : notnull, IPPtr, new()
			where TValueElement : notnull, IUnityObjectBase
		{
			NullableKeyValuePair<TKeyBase, PPtr<TValueElement>>[] result = new NullableKeyValuePair<TKeyBase, PPtr<TValueElement>>[dictionary.Count];
			for (int i = 0; i < result.Length; i++)
			{
				NullableKeyValuePair<TKey, TValue> dictEntry = dictionary.GetPair(i);
				result[i] = new NullableKeyValuePair<TKeyBase, PPtr<TValueElement>>(dictEntry.Key, new PPtr<TValueElement>(dictEntry.Value));
			}
			return result;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/AssetList.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.IO
{
	public sealed class AssetList<T> : AccessListBase<T>, IDependent
		where T : notnull, new()
	{
		private static readonly bool isDependentType = typeof(IDependent).IsAssignableFrom(typeof(T));
		private const int DefaultCapacity = 4;
		private int count = 0;
		private T[] items;

		public AssetList() : this(DefaultCapacity) { }

		public AssetList(int capacity)
		{
			items = capacity == 0 ? Array.Empty<T>() : new T[capacity];
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			if (isDependentType)
			{
				foreach (IDependent? dependent in this)
				{
					if (dependent != null)
					{
						foreach (PPtr<IUnityObjectBase> dependency in dependent.FetchDependencies(context))
						{
							yield return dependency;
						}
					}
				}
			}
		}

		/// <inheritdoc/>
		public override int Count => count;

		/// <inheritdoc/>
		public override int Capacity
		{
			get => items.Length;
			set
			{
				if (value < count)
				{
					throw new ArgumentOutOfRangeException(nameof(value));
				}

				if (value != items.Length)
				{
					if (value > 0)
					{
						T[] newElements = new T[value];
						if (count > 0)
						{
							Array.Copy(items, newElements, count);
						}
						items = newElements;
					}
					else
					{
						items = Array.Empty<T>();
					}
				}
			}
		}

		/// <inheritdoc/>
		public override T this[int index]
		{
			get
			{
				if ((uint)index >= (uint)count)
				{
					throw new ArgumentOutOfRangeException(nameof(index));
				}

				return items[index];
			}
			set
			{
				if ((uint)index >= (uint)count)
				{
					throw new ArgumentOutOfRangeException(nameof(index));
				}

				items[index] = value;
			}
		}

		/// <inheritdoc/>
		public override void Add(T item)
		{
			if (count == Capacity)
			{
				Grow(count + 1);
			}

			items[count] = item;
			count++;
		}

		/// <inheritdoc/>
		public override T AddNew()
		{
			T newItem = new();
			Add(newItem);
			return newItem;
		}

		/// <inheritdoc/>
		public override void Clear()
		{
			if (count > 0)
			{
				Array.Clear(items, 0, count); // Clear the elements so that the gc can reclaim the references.
			}
			count = 0;
		}

		/// <inheritdoc/>
		public override bool Contains(T item) => IndexOf(item) >= 0;

		/// <inheritdoc/>
		public override void CopyTo(T[] array, int arrayIndex)
		{
			if (array == null)
			{
				throw new ArgumentNullException(nameof(array));
			}

			if (arrayIndex < 0 || arrayIndex >= array.Length - count)
			{
				throw new ArgumentOutOfRangeException(nameof(arrayIndex));
			}

			Array.Copy(items, 0, array, arrayIndex, count);
		}

		/// <inheritdoc/>
		public override int IndexOf(T item) => Array.IndexOf(items, item, 0, count);

		/// <inheritdoc/>
		public override void Insert(int index, T item)
		{
			// Note that insertions at the end are legal.
			if ((uint)index > (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			if (count == items.Length)
			{
				Grow(count + 1);
			}

			if (index < count)
			{
				Array.Copy(items, index, items, index + 1, count - index);
			}

			items[index] = item;
			count++;
		}

		/// <inheritdoc/>
		public override bool Remove(T item)
		{
			int index = IndexOf(item);
			if (index >= 0)
			{
				RemoveAt(index);
				return true;
			}
			return false;
		}

		/// <inheritdoc/>
		public override void RemoveAt(int index)
		{
			if ((uint)index >= (uint)count)
			{
				throw new ArgumentOutOfRangeException(nameof(index));
			}

			count--;
			if (index < count)
			{
				Array.Copy(items, index + 1, items, index, count - index);
			}
			items[count] = default!;
		}

		public Span<T> AsSpan() => items.AsSpan(0, count);

		/// <summary>
		/// Ensures that the capacity of this list is at least the specified <paramref name="capacity"/>.
		/// If the current capacity of the list is less than specified <paramref name="capacity"/>,
		/// the capacity is increased by continuously twice current capacity until it is at least the specified <paramref name="capacity"/>.
		/// </summary>
		/// <param name="capacity">The minimum capacity to ensure.</param>
		/// <returns>The new capacity of this list.</returns>
		public override int EnsureCapacity(int capacity)
		{
			if (capacity < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(capacity));
			}
			if (items.Length < capacity)
			{
				Grow(capacity);
			}

			return items.Length;
		}

		private void Grow(int capacity)
		{
			long newcapacity = items.Length == 0 ? DefaultCapacity : 2L * items.Length;

			// Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.
			// Note that this check works even when _items.Length overflowed thanks to the (uint) cast
			if (newcapacity > Array.MaxLength)
			{
				newcapacity = Array.MaxLength;
			}

			// If the computed capacity is still less than specified, set to the original argument.
			// Capacities exceeding Array.MaxLength will be surfaced as OutOfMemoryException by Array.Resize.
			if (newcapacity < capacity)
			{
				newcapacity = capacity;
			}

			Capacity = (int)newcapacity;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/ArrayWriteAssetExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.IO.Extensions
{
	public static class ArrayWriteAssetExtensions
	{
		public static void Write(this bool[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this char[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this byte[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this short[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this ushort[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this int[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this uint[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this long[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this ulong[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this float[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this double[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this string[] _this, AssetWriter writer)
		{
			ArrayWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write<T>(this Tuple<string, T>[] _this, AssetWriter writer) where T : IAssetWritable
		{
			writer.Write(_this.Length);
			for (int i = 0; i < _this.Length; i++)
			{
				writer.Write(_this[i]);
			}
		}

		public static void Write<T1, T2>(this Tuple<T1, T2>[] _this, AssetWriter writer, Func<T1, int> converter) where T2 : IAssetWritable
		{
			writer.Write(_this.Length);
			for (int i = 0; i < _this.Length; i++)
			{
				writer.Write(_this[i], converter);
			}
		}

		public static void Write<T>(this T[] _this, AssetWriter writer)
			   where T : IAssetWritable
		{
			writer.WriteAssetArray(_this);
		}

		public static void Write<T>(this T[][] _this, AssetWriter writer)
			   where T : IAssetWritable
		{
			writer.WriteAssetArray(_this);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/ArrayWriteEndianExtensions.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.IO.Extensions
{
	public static class ArrayWriteEndianExtensions
	{
		public static void Write(this bool[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this char[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this byte[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this short[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this ushort[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this int[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this uint[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this long[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this ulong[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this float[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this double[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}

		public static void Write(this string[] _this, EndianWriter writer)
		{
			writer.WriteArray(_this);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/AssetReaderExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class AssetReaderExtensions
	{
		public static Tuple<string, T> ReadTupleStringT<T>(this AssetReader reader) where T : IAssetReadable, new()
		{
			string item1 = reader.ReadString();
			T item2 = new T();
			item2.Read(reader);
			return new Tuple<string, T>(item1, item2);
		}

		public static Tuple<string, T>[] ReadTupleStringTArray<T>(this AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			Tuple<string, T>[] array = new Tuple<string, T>[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = ReadTupleStringT<T>(reader);
			}
			return array;
		}

		public static Tuple<T1, T2> ReadTupleEnum32T<T1, T2>(this AssetReader reader, Func<int, T1> converter) where T2 : IAssetReadable, new()
		{
			T1 item1 = converter(reader.ReadInt32());
			T2 item2 = new T2();
			item2.Read(reader);
			return new Tuple<T1, T2>(item1, item2);
		}

		public static Tuple<T1, T2>[] ReadTupleEnum32TArray<T1, T2>(this AssetReader reader, Func<int, T1> converter) where T2 : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			Tuple<T1, T2>[] array = new Tuple<T1, T2>[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = ReadTupleEnum32T<T1, T2>(reader, converter);
			}
			return array;
		}

		public static Tuple<T, long> ReadTupleTLong<T>(this AssetReader reader) where T : IAssetReadable, new()
		{
			T t = new T();
			t.Read(reader);
			long value = reader.ReadInt64();
			return new Tuple<T, long>(t, value);
		}

		public static KeyValuePair<string, T>[] ReadKVPStringTArray<T>(this AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			KeyValuePair<string, T>[] array = new KeyValuePair<string, T>[count];
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				T value = new T();
				value.Read(reader);
				KeyValuePair<string, T> kvp = new KeyValuePair<string, T>(key, value);
				array[i] = kvp;
			}
			return array;
		}

		public static KeyValuePair<T1, T2>[] ReadKVPTTArray<T1, T2>(this AssetReader reader) where T1 : IAssetReadable, new() where T2 : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			KeyValuePair<T1, T2>[] array = new KeyValuePair<T1, T2>[count];
			for (int i = 0; i < count; i++)
			{
				T1 key = new T1();
				key.Read(reader);
				T2 value = new T2();
				value.Read(reader);
				KeyValuePair<T1, T2> kvp = new KeyValuePair<T1, T2>(key, value);
				array[i] = kvp;
			}
			return array;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/AssetWriterExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.IO.Extensions
{
	public static class AssetWriterExtensions
	{
		public static void Write(this AssetWriter _this, Tuple<int, long> value)
		{
			EndianWriterExtensions.Write(_this, value);
		}

		public static void Write<T>(this AssetWriter _this, Tuple<T, long> value, Func<T, int> converter)
		{
			EndianWriterExtensions.Write(_this, value, converter);
		}

		public static void Write<T>(this AssetWriter _this, Tuple<string, T> value) where T : IAssetWritable
		{
			_this.Write(value.Item1);
			value.Item2.Write(_this);
		}

		public static void Write<T1, T2>(this AssetWriter _this, Tuple<T1, T2> value, Func<T1, int> converter) where T2 : IAssetWritable
		{
			_this.Write(converter(value.Item1));
			value.Item2.Write(_this);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/BinaryReaderExtensions.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.Core.IO.Extensions
{
	public static class BinaryReaderExtensions
	{
		/// <summary>
		/// Reads the specified number of bytes from the stream, starting from a specified point in the byte array.
		/// </summary>
		/// <param name="_this">The binary reader to read from.</param>
		/// <param name="buffer">The buffer to read data into.</param>
		/// <param name="offset">The starting point in the buffer at which to begin reading into the buffer.</param>
		/// <param name="count">The number of bytes to read.</param>
		/// <exception cref="System.ArgumentException"></exception> 
		/// <exception cref="System.ArgumentNullException">buffer is null</exception> 
		/// <exception cref="System.ArgumentOutOfRangeException">index or count is negative</exception> 
		/// <exception cref="System.ObjectDisposedException">The stream is closed</exception> 
		/// <exception cref="System.IO.IOException">An I/O error occurred</exception> 
		public static void ReadBuffer(this BinaryReader _this, byte[] buffer, int offset, int count)
		{
			do
			{
				int read = _this.Read(buffer, offset, count);
				if (read == 0)
				{
					throw new IOException($"No data left");
				}
				offset += read;
				count -= read;
			}
			while (count > 0);
		}

		public static void AlignStream(this BinaryReader reader) => reader.BaseStream.Align();
		public static void AlignStream(this BinaryReader reader, int alignment) => reader.BaseStream.Align(alignment);

		public static string ReadAlignedString(this BinaryReader reader)
		{
			int length = reader.ReadInt32();
			if (length > 0 && length <= reader.BaseStream.Length - reader.BaseStream.Position)
			{
				byte[] stringData = reader.ReadBytes(length);
				string result = Encoding.UTF8.GetString(stringData);
				reader.AlignStream(4);
				return result;
			}
			return "";
		}

		public static string ReadStringToNull(this BinaryReader reader, int maxLength = 32767)
		{
			List<byte> bytes = new List<byte>();
			int count = 0;
			while (reader.BaseStream.Position != reader.BaseStream.Length && count < maxLength)
			{
				byte b = reader.ReadByte();
				if (b == 0)
				{
					break;
				}
				bytes.Add(b);
				count++;
			}
			return Encoding.UTF8.GetString(bytes.ToArray());
		}

		private static T[] ReadArray<T>(Func<T> del, int length)
		{
			T[] array = new T[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = del();
			}
			return array;
		}

		public static bool[] ReadBooleanArray(this BinaryReader reader)
		{
			return ReadArray(reader.ReadBoolean, reader.ReadInt32());
		}

		public static byte[] ReadUInt8Array(this BinaryReader reader)
		{
			return reader.ReadBytes(reader.ReadInt32());
		}

		public static ushort[] ReadUInt16Array(this BinaryReader reader)
		{
			return ReadArray(reader.ReadUInt16, reader.ReadInt32());
		}

		public static int[] ReadInt32Array(this BinaryReader reader)
		{
			return ReadArray(reader.ReadInt32, reader.ReadInt32());
		}

		public static int[] ReadInt32Array(this BinaryReader reader, int length)
		{
			return ReadArray(reader.ReadInt32, length);
		}

		public static uint[] ReadUInt32Array(this BinaryReader reader)
		{
			return ReadArray(reader.ReadUInt32, reader.ReadInt32());
		}

		public static uint[][] ReadUInt32ArrayArray(this BinaryReader reader)
		{
			return ReadArray(reader.ReadUInt32Array, reader.ReadInt32());
		}

		public static uint[] ReadUInt32Array(this BinaryReader reader, int length)
		{
			return ReadArray(reader.ReadUInt32, length);
		}

		public static float[] ReadSingleArray(this BinaryReader reader)
		{
			return ReadArray(reader.ReadSingle, reader.ReadInt32());
		}

		public static float[] ReadSingleArray(this BinaryReader reader, int length)
		{
			return ReadArray(reader.ReadSingle, length);
		}

		public static string[] ReadStringArray(this BinaryReader reader)
		{
			return ReadArray(reader.ReadAlignedString, reader.ReadInt32());
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/BinaryWriterExtensions.cs`:

```cs
using System.IO;
using System.Text;

namespace AssetRipper.Core.IO.Extensions
{
	public static class BinaryWriterExtensions
	{
		public static void AlignStream(this BinaryWriter writer, int alignment)
		{
			long pos = writer.BaseStream.Position;
			long mod = pos % alignment;
			if (mod != 0)
			{
				writer.Write(new byte[alignment - mod]);
			}
		}

		public static void WriteAlignedString(this BinaryWriter writer, string str)
		{
			byte[] bytes = Encoding.UTF8.GetBytes(str);
			writer.Write(bytes.Length);
			writer.Write(bytes);
			writer.AlignStream(4);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/EndianReaderExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class EndianReaderExtensions
	{
		public static uint[][] ReadUInt32ArrayArray(this EndianReader _this)
		{
			int count = _this.ReadInt32();
			uint[][] array = new uint[count][];
			for (int i = 0; i < count; i++)
			{
				array[i] = _this.ReadUInt32Array();
			}
			return array;
		}

		public static string[][] ReadStringArrayArray(this EndianReader _this)
		{
			int count = _this.ReadInt32();
			string[][] array = new string[count][];
			for (int i = 0; i < count; i++)
			{
				array[i] = _this.ReadStringArray();
			}
			return array;
		}

		public static Tuple<bool, string> ReadTupleBoolString(this EndianReader reader)
		{
			bool value1 = reader.ReadBoolean();
			string value2 = reader.ReadString();
			return new Tuple<bool, string>(value1, value2);
		}

		public static Tuple<bool, string>[] ReadTupleBoolStringArray(this EndianReader reader)
		{
			int count = reader.ReadInt32();
			Tuple<bool, string>[] array = new Tuple<bool, string>[count];
			for (int i = 0; i < count; i++)
			{
				Tuple<bool, string> tuple = ReadTupleBoolString(reader);
				array[i] = tuple;
			}
			return array;
		}

		public static Tuple<char, char> ReadTupleCharChar(this EndianReader reader)
		{
			char value1 = Convert.ToChar(reader.ReadByte());
			char value2 = Convert.ToChar(reader.ReadByte());
			return new Tuple<char, char>(value1, value2);
		}

		public static Tuple<char, float> ReadTupleCharSingle(this EndianReader reader)
		{
			char value1 = Convert.ToChar(reader.ReadByte());
			float value2 = reader.ReadSingle();
			return new Tuple<char, float>(value1, value2);
		}

		public static Tuple<char, float>[] ReadTupleCharSingleArray(this EndianReader reader)
		{
			int count = reader.ReadInt32();
			Tuple<char, float>[] array = new Tuple<char, float>[count];
			for (int i = 0; i < count; i++)
			{
				Tuple<char, float> tuple = ReadTupleCharSingle(reader);
				array[i] = tuple;
			}
			return array;
		}

		public static Tuple<byte, byte> ReadTupleByteByte(this EndianReader reader)
		{
			byte value1 = reader.ReadByte();
			byte value2 = reader.ReadByte();
			return new Tuple<byte, byte>(value1, value2);
		}

		public static Tuple<byte, float> ReadTupleByteSingle(this EndianReader reader)
		{
			byte value1 = reader.ReadByte();
			float value2 = reader.ReadSingle();
			return new Tuple<byte, float>(value1, value2);
		}

		public static Tuple<byte, float>[] ReadTupleByteSingleArray(this EndianReader reader)
		{
			int count = reader.ReadInt32();
			Tuple<byte, float>[] array = new Tuple<byte, float>[count];
			for (int i = 0; i < count; i++)
			{
				Tuple<byte, float> tuple = ReadTupleByteSingle(reader);
				array[i] = tuple;
			}
			return array;
		}

		public static Tuple<ushort, ushort> ReadTupleUInt16UInt16(this EndianReader reader)
		{
			ushort value1 = reader.ReadUInt16();
			ushort value2 = reader.ReadUInt16();
			return new Tuple<ushort, ushort>(value1, value2);
		}

		public static Tuple<int, long> ReadTupleInt32Int64(this EndianReader reader)
		{
			int value1 = reader.ReadInt32();
			long value2 = reader.ReadInt64();
			return new Tuple<int, long>(value1, value2);
		}

		public static Tuple<int, float> ReadTupleInt32Single(this EndianReader reader)
		{
			int value1 = reader.ReadInt32();
			float value2 = reader.ReadSingle();
			return new Tuple<int, float>(value1, value2);
		}

		public static Tuple<int, float>[] ReadTupleIntSingleArray(this EndianReader reader)
		{
			int count = reader.ReadInt32();
			Tuple<int, float>[] array = new Tuple<int, float>[count];
			for (int i = 0; i < count; i++)
			{
				Tuple<int, float> tuple = ReadTupleInt32Single(reader);
				array[i] = tuple;
			}
			return array;
		}

		public static Tuple<T, long> ReadTupleTLong<T>(this EndianReader reader, Func<int, T> converter)
		{
			T value1 = converter(reader.ReadInt32());
			long value2 = reader.ReadInt64();
			return new Tuple<T, long>(value1, value2);
		}

		public static KeyValuePair<int, uint>[] ReadKVPInt32UInt32Array(this EndianReader reader)
		{
			int count = reader.ReadInt32();
			KeyValuePair<int, uint>[] array = new KeyValuePair<int, uint>[count];
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				uint value = reader.ReadUInt32();
				KeyValuePair<int, uint> kvp = new KeyValuePair<int, uint>(key, value);
				array[i] = kvp;
			}
			return array;
		}

		public static T[] ReadArray<T>(this EndianReader reader, Func<int, T> converter)
		{
			int count = reader.ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				int value = reader.ReadInt32();
				array[i] = converter(value);
			}
			return array;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/EndianWriterExtensions.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.IO.Extensions
{
	public static class EndianWriterExtensions
	{
		public static void Write(this EndianWriter writer, Tuple<int, long> value)
		{
			writer.Write(value.Item1);
			writer.Write(value.Item2);
		}

		public static void Write<T>(this EndianWriter writer, Tuple<T, long> value, Func<T, int> converter)
		{
			writer.Write(converter(value.Item1));
			writer.Write(value.Item2);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/IDictionaryReadAssetExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class IDictionaryReadAssetExtensions
	{
		public static void Read(this IDictionary<int, int> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<int, uint> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<int, string> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<uint, string> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<long, string> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, byte> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, short> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, ushort> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, int> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, uint> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, long> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, ulong> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<string, string> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<Tuple<char, char>, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read(this IDictionary<Tuple<byte, byte>, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void ReadSafe(this IDictionary<Tuple<byte, byte>, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.ReadSafe(_this, reader);
		}

		public static void Read(this IDictionary<Tuple<ushort, ushort>, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void ReadSafe(this IDictionary<Tuple<ushort, ushort>, float> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.ReadSafe(_this, reader);
		}

		public static void Read(this IDictionary<Tuple<int, long>, string> _this, AssetReader reader)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader);
		}

		public static void Read<T>(this IDictionary<Tuple<T, long>, string> _this, AssetReader reader, Func<int, T> converter)
		{
			IDictionaryReadEndianExtensions.Read(_this, reader, converter);
		}

		public static void Read<T>(this IDictionary<int, T> _this, AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				T value = new T();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<int, T> _this, AssetReader reader, Func<T> instantiator) where T : IAssetReadable
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				T value = instantiator();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<uint, T> _this, AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				uint key = reader.ReadUInt32();
				T value = new T();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<string, T> _this, AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				T value = new T();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<string, T> _this, AssetReader reader, Func<T> instantiator) where T : IAssetReadable
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				T value = instantiator();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T1, T2>(this IDictionary<Tuple<T1, long>, T2> _this, AssetReader reader) where T1 : IAssetReadable, new() where T2 : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<T1, long> key = reader.ReadTupleTLong<T1>();
				T2 value = new T2();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<T, int> _this, AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T key = new T();
				key.Read(reader);
				int value = reader.ReadInt32();
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<T, float> _this, AssetReader reader) where T : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T key = new T();
				key.Read(reader);
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<T, float> _this, AssetReader reader, Func<T> instantiator) where T : IAssetReadable
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T key = instantiator();
				key.Read(reader);
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void Read<T1, T2>(this IDictionary<T1, T2> _this, AssetReader reader) where T1 : IAssetReadable, new() where T2 : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T1 key = new T1();
				key.Read(reader);
				T2 value = new T2();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T1, T2>(this IDictionary<T1, T2> _this, AssetReader reader, Func<T1> keyInstantiator) where T1 : IAssetReadable
			where T2 : IAssetReadable, new()
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T1 key = keyInstantiator();
				key.Read(reader);
				T2 value = new T2();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T1, T2>(this IDictionary<T1, T2> _this, AssetReader reader, Func<T2> valueInstantiator) where T1 : IAssetReadable, new() where T2 : IAssetReadable
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T1 key = new T1();
				key.Read(reader);
				T2 value = valueInstantiator();
				value.Read(reader);
				_this.Add(key, value);
			}
		}

		public static void Read<T1, T2>(this IDictionary<T1, T2> _this, AssetReader reader, Func<T1> keyInstantiator, Func<T2> valueInstantiator) where T1 : IAssetReadable
			where T2 : IAssetReadable
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				T1 key = keyInstantiator();
				key.Read(reader);
				T2 value = valueInstantiator();
				value.Read(reader);
				_this.Add(key, value);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/IDictionaryReadEndianExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class IDictionaryReadEndianExtensions
	{
		public static void Read(this IDictionary<int, int> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				int value = reader.ReadInt32();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<int, uint> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				uint value = reader.ReadUInt32();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<int, string> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				int key = reader.ReadInt32();
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<uint, string> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				uint key = reader.ReadUInt32();
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<long, string> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				long key = reader.ReadInt64();
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, byte> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				byte value = reader.ReadByte();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, short> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				short value = reader.ReadInt16();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, ushort> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				ushort value = reader.ReadUInt16();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, int> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				int value = reader.ReadInt32();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, uint> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				uint value = reader.ReadUInt32();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, long> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				long value = reader.ReadInt64();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, ulong> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				ulong value = reader.ReadUInt64();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<string, string> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				string key = reader.ReadString();
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<Tuple<char, char>, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<char, char> key = reader.ReadTupleCharChar();
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void Read(this IDictionary<Tuple<byte, byte>, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<byte, byte> key = reader.ReadTupleByteByte();
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void ReadSafe(this IDictionary<Tuple<byte, byte>, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<byte, byte> key = reader.ReadTupleByteByte();
				float value = reader.ReadSingle();
				_this[key] = value;
			}
		}

		public static void Read(this IDictionary<Tuple<ushort, ushort>, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<ushort, ushort> key = reader.ReadTupleUInt16UInt16();
				float value = reader.ReadSingle();
				_this.Add(key, value);
			}
		}

		public static void ReadSafe(this IDictionary<Tuple<ushort, ushort>, float> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<ushort, ushort> key = reader.ReadTupleUInt16UInt16();
				float value = reader.ReadSingle();
				_this[key] = value;
			}
		}

		public static void Read(this IDictionary<Tuple<int, long>, string> _this, EndianReader reader)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<int, long> key = reader.ReadTupleInt32Int64();
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}

		public static void Read<T>(this IDictionary<Tuple<T, long>, string> _this, EndianReader reader, Func<int, T> converter)
		{
			int count = reader.ReadInt32();
			for (int i = 0; i < count; i++)
			{
				Tuple<T, long> key = reader.ReadTupleTLong(converter);
				string value = reader.ReadString();
				_this.Add(key, value);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/IDictionaryWriteAssetExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class IDictionaryWriteAssetExtensions
	{
		public static void Write(this IReadOnlyDictionary<int, int> _this, AssetWriter writer)
		{
			IDictionaryWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this IReadOnlyDictionary<int, string> _this, AssetWriter writer)
		{
			IDictionaryWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this IReadOnlyDictionary<long, string> _this, AssetWriter writer)
		{
			IDictionaryWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write(this IReadOnlyDictionary<Tuple<int, long>, string> _this, AssetWriter writer)
		{
			IDictionaryWriteEndianExtensions.Write(_this, writer);
		}

		public static void Write<T>(this IReadOnlyDictionary<Tuple<T, long>, string> _this, AssetWriter writer, Func<T, int> converter)
		{
			IDictionaryWriteEndianExtensions.Write(_this, writer, converter);
		}

		public static void Write<T>(this IReadOnlyDictionary<string, T> _this, AssetWriter writer) where T : IAssetWritable
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<string, T> kvp in _this)
			{
				writer.Write(kvp.Key);
				kvp.Value.Write(writer);
			}
		}

		public static void Write<T1, T2>(this IReadOnlyDictionary<T1, T2> _this, AssetWriter writer) where T1 : IAssetWritable
			where T2 : IAssetWritable
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<T1, T2> kvp in _this)
			{
				kvp.Key.Write(writer);
				kvp.Value.Write(writer);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/IDictionaryWriteEndianExtensions.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class IDictionaryWriteEndianExtensions
	{
		public static void Write(this IReadOnlyDictionary<int, int> _this, EndianWriter writer)
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<int, int> kvp in _this)
			{
				writer.Write(kvp.Key);
				writer.Write(kvp.Value);
			}
		}

		public static void Write(this IReadOnlyDictionary<int, string> _this, EndianWriter writer)
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<int, string> kvp in _this)
			{
				writer.Write(kvp.Key);
				writer.Write(kvp.Value);
			}
		}

		public static void Write(this IReadOnlyDictionary<long, string> _this, EndianWriter writer)
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<long, string> kvp in _this)
			{
				writer.Write(kvp.Key);
				writer.Write(kvp.Value);
			}
		}

		public static void Write(this IReadOnlyDictionary<Tuple<int, long>, string> _this, EndianWriter writer)
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<Tuple<int, long>, string> kvp in _this)
			{
				writer.Write(kvp.Key);
				writer.Write(kvp.Value);
			}
		}

		public static void Write<T>(this IReadOnlyDictionary<Tuple<T, long>, string> _this, EndianWriter writer, Func<T, int> converter)
		{
			writer.Write(_this.Count);
			foreach (KeyValuePair<Tuple<T, long>, string> kvp in _this)
			{
				writer.Write(kvp.Key, converter);
				writer.Write(kvp.Value);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/StreamExtensions.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.IO.Extensions
{
	public static class StreamExtensions
	{
		private const int BufferSize = 81920;

		public static void Align(this Stream _this) => Align(_this, 4);
		public static void Align(this Stream _this, int alignment)
		{
			long pos = _this.Position;
			long mod = pos % alignment;
			if (mod != 0)
			{
				_this.Position += alignment - mod;
			}
		}

		public static void CopyTo(this Stream source, Stream destination, long size)
		{
			byte[] buffer = new byte[BufferSize];
			for (long left = size; left > 0; left -= BufferSize)
			{
				int toRead = BufferSize < left ? BufferSize : (int)left;
				int read = source.Read(buffer, 0, toRead);
				destination.Write(buffer, 0, read);
				if (read != toRead)
				{
					return;
				}
			}
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/YamlArrayExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class YamlArrayExtensions
	{
		public static YamlNode ExportYaml<T>(this T[][] _this, IExportContainer container) where T : IYamlExportable
		{
			return ((IEnumerable<IEnumerable<T>>)_this).ExportYaml(container);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/YamlDictionaryExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class YamlDictionaryExtensions
	{
		public static YamlNode ExportYaml<T>(this IReadOnlyDictionary<int, T> _this, IExportContainer container) where T : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<int, T> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				map.Add(kvp.Key, kvp.Value.ExportYaml(container));
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IReadOnlyDictionary<string, T> _this, IExportContainer container) where T : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<string, T> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				map.Add(kvp.Key, kvp.Value.ExportYaml(container));
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T1, T2>(this IReadOnlyDictionary<Tuple<T1, long>, T2> _this, IExportContainer container) where T1 : IYamlExportable
			where T2 : IYamlExportable
		{
#warning TODO: test
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<Tuple<T1, long>, T2> kvp in _this)
			{
				YamlMappingNode kvpMap = new YamlMappingNode();
				YamlMappingNode keyMap = new YamlMappingNode();
				keyMap.Add("first", kvp.Key.Item1.ExportYaml(container));
				keyMap.Add("second", kvp.Key.Item2);
				kvpMap.Add("first", keyMap);
				kvpMap.Add("second", kvp.Value.ExportYaml(container));
				node.Add(kvpMap);
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IReadOnlyDictionary<T, int> _this, IExportContainer container) where T : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<T, int> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				YamlNode key = kvp.Key.ExportYaml(container);
				if (key.NodeType == YamlNodeType.Scalar)
				{
					map.Add(key, kvp.Value);
				}
				else
				{
					map.Add("first", key);
					map.Add("second", kvp.Value);
				}
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IReadOnlyDictionary<T, float> _this, IExportContainer container) where T : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<T, float> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				YamlNode key = kvp.Key.ExportYaml(container);
				if (key.NodeType == YamlNodeType.Scalar)
				{
					map.Add(key, kvp.Value);
				}
				else
				{
					map.Add("first", key);
					map.Add("second", kvp.Value);
				}
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T1, T2>(this IReadOnlyDictionary<T1, T2> _this, IExportContainer container) where T1 : IYamlExportable
			where T2 : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<T1, T2> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				YamlNode key = kvp.Key.ExportYaml(container);
				if (key.NodeType == YamlNodeType.Scalar)
				{
					map.Add(key, kvp.Value.ExportYaml(container));
				}
				else
				{
					map.Add("first", key);
					map.Add("second", kvp.Value.ExportYaml(container));
				}
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T1, T2>(this IReadOnlyDictionary<T1, T2[]> _this, IExportContainer container) where T1 : IYamlExportable
			where T2 : IYamlExportable
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (KeyValuePair<T1, T2[]> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				YamlNode key = kvp.Key.ExportYaml(container);
				if (key.NodeType == YamlNodeType.Scalar)
				{
					map.Add(key, kvp.Value.ExportYaml(container));
				}
				else
				{
					map.Add("first", key);
					map.Add("second", kvp.Value.ExportYaml(container));
				}
				node.Add(map);
			}
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/YamlEnumerableExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.IO.Extensions
{
	public static class YamlEnumerableExtensions
	{
		public static YamlNode ExportYaml<T>(this IEnumerable<T> _this, IExportContainer container) where T : IYamlExportable
		{
			if (_this == null)
			{
				throw new ArgumentNullException(nameof(_this));
			}

			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (T export in _this)
			{
				node.Add(export.ExportYaml(container));
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IEnumerable<IEnumerable<T>> _this, IExportContainer container) where T : IYamlExportable
		{
			if (_this == null)
			{
				throw new ArgumentNullException(nameof(_this));
			}

			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (IEnumerable<T> export in _this)
			{
				node.Add(export.ExportYaml(container));
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IEnumerable<Tuple<string, T>> _this, IExportContainer container) where T : IYamlExportable
		{
			if (_this == null)
			{
				throw new ArgumentNullException(nameof(_this));
			}

			YamlSequenceNode node = new YamlSequenceNode();
			foreach (Tuple<string, T> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				map.Add(kvp.Item1, kvp.Item2.ExportYaml(container));
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T1, T2>(this IEnumerable<Tuple<T1, T2>> _this, IExportContainer container, Func<T1, int> converter) where T2 : IYamlExportable
		{
			if (_this == null)
			{
				throw new ArgumentNullException(nameof(_this));
			}

			YamlSequenceNode node = new YamlSequenceNode();
			foreach (Tuple<T1, T2> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				map.Add(converter(kvp.Item1), kvp.Item2.ExportYaml(container));
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IEnumerable<KeyValuePair<string, T>> _this, IExportContainer container) where T : IYamlExportable
		{
			if (_this == null)
			{
				throw new ArgumentNullException(nameof(_this));
			}

			YamlSequenceNode node = new YamlSequenceNode();
			foreach (KeyValuePair<string, T> kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode();
				map.Add(kvp.Key, kvp.Value.ExportYaml(container));
				node.Add(map);
			}
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/IO/Extensions/YamlSerializedVersionExtensions.cs`:

```cs
using AssetRipper.Yaml;

namespace AssetRipper.Core.IO.Extensions
{
	public static class YamlSerializedVersionExtensions
	{
		public static void AddSerializedVersion(this YamlMappingNode _this, int version)
		{
			if (version > 1)
			{
				_this.Add(SerializedVersionName, version);
			}
		}

		public static void ForceAddSerializedVersion(this YamlMappingNode _this, int version)
		{
			if (version > 0)
			{
				_this.Add(SerializedVersionName, version);
			}
		}

		public static void InsertSerializedVersion(this YamlMappingNode _this, int version)
		{
			if (version > 1)
			{
				_this.InsertBegin(SerializedVersionName, version);
			}
		}

		public const string SerializedVersionName = "serializedVersion";
	}
}

```

`AssetRipper.Fundamentals/IO/InvariantStreamWriter.cs`:

```cs
using System.Globalization;
using System.IO;
using System.Text;

namespace AssetRipper.Core.IO
{
	public class InvariantStreamWriter : StreamWriter
	{
		public InvariantStreamWriter(Stream stream) : base(stream) { }

		public InvariantStreamWriter(string path) : base(path) { }

		public InvariantStreamWriter(Stream stream, Encoding encoding) : base(stream, encoding) { }

		public InvariantStreamWriter(string path, bool append) : base(path, append) { }

		public InvariantStreamWriter(Stream stream, Encoding encoding, int bufferSize) : base(stream, encoding, bufferSize) { }

		public InvariantStreamWriter(string path, bool append, Encoding encoding) : base(path, append, encoding) { }

		public InvariantStreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen) : base(stream, encoding, bufferSize, leaveOpen) { }

		public InvariantStreamWriter(string path, bool append, Encoding encoding, int bufferSize) : base(path, append, encoding, bufferSize) { }

		public override IFormatProvider FormatProvider => CultureInfo.InvariantCulture;
	}
}

```

`AssetRipper.Fundamentals/IO/MultiFile/MultiFileStream.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AssetRipper.Core.IO.MultiFile
{
	public sealed class MultiFileStream : Stream
	{
		public MultiFileStream(IEnumerable<Stream> streams)
		{
			if (streams == null)
			{
				throw new ArgumentNullException(nameof(streams));
			}
			foreach (Stream stream in streams)
			{
				if (stream == null)
				{
					throw new ArgumentNullException();
				}
				if (!stream.CanSeek)
				{
					throw new Exception($"Stream {stream} isn't seekable");
				}
			}

			m_streams = streams.ToArray();
			if (m_streams.Count == 0)
			{
				throw new ArgumentException(nameof(streams));
			}

			Length = streams.Sum(t => t.Length);
			CanRead = m_streams.All(t => t.CanRead);
			CanWrite = m_streams.All(t => t.CanWrite);
			UpdateCurrentStream();
		}

		~MultiFileStream()
		{
			Dispose(false);
		}

		/// <summary>
		/// Determines if the path could be part of a multi file
		/// </summary>
		/// <param name="path">The path to check</param>
		/// <returns>True if the path matches the multi file regex</returns>
		public static bool IsMultiFile(string path)
		{
			return s_splitCheck.IsMatch(path);
		}

		public static bool Exists(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return Exists(directory, file);
			}
			if (File.Exists(path))
			{
				return true;
			}

			{
				SplitPath(path, out string directory, out string file, true);
				if (string.IsNullOrEmpty(file))
				{
					return false;
				}
				else
				{
					return Exists(directory, file);
				}
			}
		}

		public static Stream OpenRead(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return OpenRead(directory, file);
			}
			if (File.Exists(path))
			{
				return File.OpenRead(path);
			}

			{
				SplitPath(path, out string directory, out string file);
				return OpenRead(directory, file);
			}
		}

		public static string GetFilePath(string path)
		{
			if (IsMultiFile(path))
			{
				int index = path.LastIndexOf('.');
				return path.Substring(0, index);
			}
			return path;
		}

		public static string GetFileName(string path)
		{
			if (IsMultiFile(path))
			{
				return Path.GetFileNameWithoutExtension(path);
			}
			return Path.GetFileName(path);
		}

		public static string[] GetFiles(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return GetFiles(directory, file);
			}

			if (File.Exists(path))
			{
				return new[] { path };
			}
			return Array.Empty<string>();
		}

		public static bool IsNameEquals(string fileName, string compare)
		{
			fileName = GetFileName(fileName);
			return fileName == compare;
		}

		/// <summary>
		/// Determines if a multi file exists
		/// </summary>
		/// <param name="dirPath">The directory containing the multi file</param>
		/// <param name="fileName">The name of the multi file without the split extension</param>
		/// <returns>True if a valid multi file exists in that directory with that name</returns>
		private static bool Exists(string dirPath, string fileName)
		{
			string filePath = Path.Combine(dirPath, fileName);
			string splitFilePath = filePath + ".split";

			string[] splitFiles = GetFiles(dirPath, fileName);
			if (splitFiles.Length == 0)
			{
				return false;
			}

			for (int i = 0; i < splitFiles.Length; i++)
			{
				string indexFileName = splitFilePath + i;
				if (!splitFiles.Contains(indexFileName))
				{
					return false;
				}
			}
			return true;
		}

		private static string[] GetFiles(string dirPath, string fileName)
		{
			if (!Directory.Exists(dirPath))
			{
				return Array.Empty<string>();
			}

			string filePatern = fileName + ".split*";
			return Directory.GetFiles(dirPath, filePatern);
		}

		private static Stream OpenRead(string dirPath, string fileName)
		{
			string filePath = Path.Combine(dirPath, fileName);
			string splitFilePath = filePath + ".split";

			string[] splitFiles = GetFiles(dirPath, fileName);
			for (int i = 0; i < splitFiles.Length; i++)
			{
				string indexFileName = splitFilePath + i;
				if (!splitFiles.Contains(indexFileName))
				{
					throw new Exception($"Try to open splited file part '{filePath}' but file part '{indexFileName}' wasn't found");
				}
			}

			splitFiles = splitFiles.OrderBy(t => t, s_splitNameComparer).ToArray();
			Stream[] streams = new Stream[splitFiles.Length];
			try
			{
				for (int i = 0; i < splitFiles.Length; i++)
				{
					Stream stream = File.OpenRead(splitFiles[i]);
					streams[i] = stream;
				}

				return new MultiFileStream(streams);
			}
			catch
			{
				foreach (Stream stream in streams)
				{
					if (stream == null)
					{
						break;
					}
					stream.Dispose();
				}
				throw;
			}
		}

		private static void SplitPath(string path, out string directory, out string file) => SplitPath(path, out directory, out file, false);
		private static void SplitPath(string path, out string directory, out string file, bool allowNullReturn)
		{
			directory = Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
			directory = string.IsNullOrEmpty(directory) ? "." : directory;
			file = Path.GetFileName(path);
			if (string.IsNullOrEmpty(file) && !allowNullReturn)
			{
				throw new Exception($"Can't determine file name for {path}");
			}
		}

		private static void SplitPathWithoutExtension(string path, out string directory, out string file)
		{
			directory = Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
			directory = string.IsNullOrEmpty(directory) ? "." : directory;
			file = Path.GetFileNameWithoutExtension(path);
			if (string.IsNullOrEmpty(file))
			{
				throw new Exception($"Can't determine file name for {path}");
			}
		}

		public override void Flush()
		{
			m_currentStream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
				case SeekOrigin.Begin:
					Position = offset;
					break;
				case SeekOrigin.Current:
					Position += offset;
					break;
				case SeekOrigin.End:
					Position = Length - offset;
					break;
			}
			return Position;
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override int ReadByte()
		{
			int value = m_currentStream.ReadByte();
			if (value >= 0)
			{
				m_position++;
				if (m_position == m_currentEnd)
				{
					NextStream();
				}
			}
			return value;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			int read = m_currentStream.Read(buffer, offset, count);
			m_position += read;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}

			return read;
		}

		public override void WriteByte(byte value)
		{
			m_currentStream.WriteByte(value);
			m_position++;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			while (count > 0)
			{
				long available = m_currentEnd - m_position;
				int toWrite = count < available ? count : (int)available;
				m_currentStream.Write(buffer, offset, toWrite);
				m_position += toWrite;
				if (m_position == m_currentEnd)
				{
					NextStream();
				}

				offset += toWrite;
				count -= toWrite;
			}
		}

		protected override void Dispose(bool disposing)
		{
			foreach (Stream stream in m_streams)
			{
				stream.Dispose();
			}
			base.Dispose(disposing);
		}

		private void NextStream()
		{
			int nextStreamIndex = m_streamIndex + 1;
			if (nextStreamIndex < m_streams.Count)
			{
				m_currentBegin += m_currentStream.Length;
				m_streamIndex = nextStreamIndex;
				m_currentStream = m_streams[m_streamIndex];
				m_currentStream.Position = 0;
				m_currentEnd += m_currentStream.Length;
			}
		}

		private void UpdateCurrentStream()
		{
			m_currentBegin = 0;
			m_currentEnd = 0;
			for (int i = 0; i < m_streams.Count; i++)
			{
				m_streamIndex = i;
				m_currentStream = m_streams[m_streamIndex];
				m_currentEnd = m_currentBegin + m_currentStream.Length;
				if (m_currentEnd > m_position)
				{
					m_currentStream.Position = m_position - m_currentBegin;
					return;
				}

				m_currentBegin += m_currentStream.Length;
			}
			m_currentBegin -= m_currentStream.Length;
			m_currentStream.Position = m_position - m_currentBegin;
		}

		public override long Position
		{
			get => m_position;
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException(nameof(value), value, null);
				}

				m_position = value;
				if (value < m_currentBegin || value >= m_currentEnd)
				{
					UpdateCurrentStream();
				}
				else
				{
					m_currentStream.Position = value - m_currentBegin;
				}
			}
		}

		public override long Length { get; }

		public override bool CanRead { get; }
		public override bool CanWrite { get; }
		public override bool CanSeek => true;

		private static readonly Regex s_splitCheck = new Regex($@".+{MultifileRegPostfix}[0-9]+$", RegexOptions.Compiled);
		private static readonly SplitNameComparer s_splitNameComparer = new SplitNameComparer();

		public const string MultifileRegPostfix = @"\.split";

		private readonly IReadOnlyList<Stream> m_streams;

		private Stream m_currentStream;
		private int m_streamIndex;
		private long m_position;
		private long m_currentBegin;
		private long m_currentEnd;
	}
}

```

`AssetRipper.Fundamentals/IO/MultiFile/SplitNameComparer.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.IO.MultiFile
{
	public class SplitNameComparer : IComparer<string>
	{
		public int Compare(string? x, string? y)
		{
			int xNumber = GetSplitIndex(x);
			int yNumber = GetSplitIndex(y);
			return xNumber.CompareTo(yNumber);
		}

		private static int GetSplitIndex(string? value)
		{
			if (string.IsNullOrEmpty(value))
			{
				return -1;
			}

			int i;
			for (i = value.Length - 1; i >= 0; i--)
			{
				if (!char.IsDigit(value[i]))
				{
					i++;
					break;
				}
			}
			string number = value.Substring(i);
			return int.Parse(number);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/NullableKeyValuePair.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.IO
{
	public class NullableKeyValuePair<TKey, TValue> : IDependent, IEquatable<NullableKeyValuePair<TKey, TValue>>
		where TKey : notnull
		where TValue : notnull
	{
		static NullableKeyValuePair()
		{
			hasDependentKeys = typeof(IDependent).IsAssignableFrom(typeof(TKey));
			hasDependentValues = typeof(IDependent).IsAssignableFrom(typeof(TValue));
			IsDependentType = hasDependentKeys || hasDependentValues;
		}

		private static readonly bool hasDependentKeys;
		private static readonly bool hasDependentValues;
		public static bool IsDependentType { get; }
		public TKey? Key { get; set; }
		public TValue? Value { get; set; }

		public NullableKeyValuePair() { }

		public NullableKeyValuePair(TKey key, TValue value)
		{
			Key = key;
			Value = value;
		}

		public NullableKeyValuePair(KeyValuePair<TKey, TValue> pair)
		{
			Key = pair.Key;
			Value = pair.Value;
		}

		public static implicit operator KeyValuePair<TKey?, TValue?>(NullableKeyValuePair<TKey, TValue> nullable)
		{
			return nullable is null ? default : new KeyValuePair<TKey?, TValue?>(nullable.Key, nullable.Value);
		}

		public static implicit operator NullableKeyValuePair<TKey, TValue>(KeyValuePair<TKey, TValue> nonnullable)
		{
			return new NullableKeyValuePair<TKey, TValue>(nonnullable);
		}

		public static bool operator ==(NullableKeyValuePair<TKey, TValue>? left, NullableKeyValuePair<TKey, TValue>? right)
		{
			return EqualityComparer<NullableKeyValuePair<TKey, TValue>>.Default.Equals(left, right);
		}

		public static bool operator !=(NullableKeyValuePair<TKey, TValue>? left, NullableKeyValuePair<TKey, TValue>? right)
		{
			return !(left == right);
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			if (hasDependentKeys && Key != null && Key is IDependent keyDependent)
			{
				foreach (PPtr<IUnityObjectBase> dependency in keyDependent.FetchDependencies(context))
				{
					yield return dependency;
				}
			}
			if (hasDependentValues && Value != null && Value is IDependent valueDependent)
			{
				foreach (PPtr<IUnityObjectBase> dependency in valueDependent.FetchDependencies(context))
				{
					yield return dependency;
				}
			}
		}

		public override bool Equals(object? obj)
		{
			return Equals(obj as NullableKeyValuePair<TKey, TValue>);
		}

		public bool Equals(NullableKeyValuePair<TKey, TValue>? other)
		{
			return other is not null &&
				   EqualityComparer<TKey>.Default.Equals(Key, other.Key) &&
				   EqualityComparer<TValue>.Default.Equals(Value, other.Value);
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(Key, Value);
		}
	}
}

```

`AssetRipper.Fundamentals/IO/PartialStream.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.IO
{
	/// <summary>
	/// A stream implementation for accessing a subset of another stream
	/// </summary>
	public class PartialStream : Stream
	{
		public PartialStream(Stream baseStream, long offset, long length) : this(baseStream, offset, length, true) { }

		public PartialStream(Stream baseStream, long offset, long length, bool leaveOpen)
		{
			m_stream = baseStream ?? throw new ArgumentNullException(nameof(baseStream));
			m_baseOffset = offset;
			Length = length;
			m_leaveOpen = leaveOpen;

			m_initialPosition = baseStream.Position;
			Position = 0;
		}

		~PartialStream()
		{
			Dispose(false);
		}

		/// <inheritdoc/>
		public override void Flush()
		{
			m_stream.Flush();
		}

		/// <inheritdoc/>
		public override int Read(byte[] buffer, int offset, int count)
		{
			count = (int)System.Math.Max(System.Math.Min(count, Length - Position), 0);
			int read = m_stream.Read(buffer, offset, count);
			return read;
		}

		/// <inheritdoc/>
		public override long Seek(long offset, SeekOrigin origin)
		{
			if (origin == SeekOrigin.Begin)
			{
				return m_stream.Seek(m_baseOffset + offset, SeekOrigin.Begin) - m_baseOffset;
			}
			else if (origin == SeekOrigin.End)
			{
				return m_stream.Seek(m_baseOffset + Length + offset, SeekOrigin.Begin) - m_baseOffset;
			}
			else
			{
				return m_stream.Seek(offset, origin) - m_baseOffset;
			}
		}

		/// <inheritdoc/>
		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		/// <inheritdoc/>
		public override void Write(byte[] buffer, int offset, int count)
		{
			if (Position + count > Length)
			{
				throw new Exception("Partial stream's position is out of range");
			}
			m_stream.Write(buffer, offset, count);
		}

		/// <inheritdoc/>
		protected override void Dispose(bool disposing)
		{
			if (m_leaveOpen)
			{
				if (!m_isDisposed)
				{
					m_stream.Position = m_initialPosition;
					m_isDisposed = true;
				}
			}
			else
			{
				m_stream.Dispose();
			}
			base.Dispose(disposing);
		}

		/// <inheritdoc/>
		public override bool CanRead => m_stream.CanRead;
		/// <inheritdoc/>
		public override bool CanSeek => m_stream.CanSeek;
		/// <inheritdoc/>
		public override bool CanWrite => m_stream.CanWrite;
		/// <inheritdoc/>
		public override long Length { get; }

		/// <inheritdoc/>
		public override long Position
		{
			get => m_stream.Position - m_baseOffset;
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException(nameof(value), "Non-negative number required");
				}
				m_stream.Position = m_baseOffset + value;
			}
		}

		private readonly Stream m_stream;
		private readonly long m_baseOffset;
		private readonly bool m_leaveOpen;
		private readonly long m_initialPosition;

		private bool m_isDisposed;
	}
}

```

`AssetRipper.Fundamentals/IO/ReverseStream.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.IO
{
	public class ReverseStream : Stream
	{
		public ReverseStream(Stream stream) : this(stream, true) { }

		public ReverseStream(Stream stream, bool leaveOpen) : this(stream, 0, stream.Length, leaveOpen) { }

		public ReverseStream(Stream stream, long offset, long size) : this(stream, offset, size, true) { }

		public ReverseStream(Stream stream, long offset, long size, bool leaveOpen)
		{
			if (stream == null)
			{
				throw new ArgumentNullException(nameof(stream));
			}
			if (offset > stream.Length)
			{
				throw new ArgumentException($"Start position {offset} grater than stream lengh {stream.Length}", nameof(offset));
			}
			if (size > stream.Length)
			{
				throw new ArgumentException($"Length {size} grater than stream lengh {stream.Length}", nameof(stream));
			}
			if (!stream.CanSeek)
			{
				throw new ArgumentException("Stream can't seek", nameof(stream));
			}

			m_stream = stream;
			m_begin = offset;
			m_end = offset + size;
			Position = m_stream.Position - m_begin;
			Length = size;
			m_leaveOpen = leaveOpen;
		}

		~ReverseStream()
		{
			Dispose(false);
		}

		public override void Flush()
		{
			m_stream.Flush();
		}

		public override void WriteByte(byte value)
		{
			if (Position < 0)
			{
				throw new Exception($"Position {Position} is out of range");
			}
			if (Position >= Length)
			{
				throw new Exception($"Position {Position} is out of range {Length}");
			}

			m_stream.Position = m_end - Position - 1;
			Position++;
			m_stream.WriteByte(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (Position < 0)
			{
				throw new Exception($"Position {Position} is out of range");
			}
			if (Position >= Length)
			{
				throw new Exception($"Position {Position} is out of range {Length}");
			}

			while (count > 0)
			{
				int toWrite = System.Math.Min(DefaultBufferSize, count);
				Buffer.BlockCopy(buffer, offset, m_buffer, 0, toWrite);
				Array.Reverse(m_buffer, 0, toWrite);

				m_stream.Position = m_end - Position - toWrite;
				m_stream.Write(m_buffer, 0, toWrite);

				offset += toWrite;
				Position += toWrite;
				count -= toWrite;
			}
		}

		public override int ReadByte()
		{
			if (Position < 0)
			{
				throw new Exception($"Position {Position} is out of range");
			}
			if (Position >= Length)
			{
				throw new Exception($"Position {Position} is out of range {Length}");
			}

			m_stream.Position = m_end - Position - 1;
			Position++;
			return m_stream.ReadByte();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (Position < 0)
			{
				throw new Exception($"Position {Position} is out of range");
			}
			if (Position >= Length)
			{
				throw new Exception($"Position {Position} is out of range {Length}");
			}

			int totalRead = 0;
			while (count > 0)
			{
				int toRead = System.Math.Min(DefaultBufferSize, count);
				m_stream.Position = m_end - Position - toRead;
				int read = m_stream.Read(m_buffer, 0, toRead);

				Array.Reverse(m_buffer, 0, read);
				Buffer.BlockCopy(m_buffer, 0, buffer, offset, read);

				offset += read;
				Position += read;
				count -= read;
				totalRead += read;

				if (read != toRead)
				{
					break;
				}
			}
			return totalRead;
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
				case SeekOrigin.Begin:
					Position = offset;
					break;

				case SeekOrigin.Current:
					Position += offset;
					break;

				case SeekOrigin.End:
					Position = m_end - offset - 1;
					break;
			}
			return Position;
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (!m_leaveOpen)
			{
				m_stream.Dispose();
			}
		}

		public override long Position
		{
			get => m_position;
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException(nameof(value), value, null);
				}
				m_position = value;
			}
		}
		public override long Length { get; }
		public override bool CanWrite => m_stream.CanWrite;
		public override bool CanTimeout => m_stream.CanTimeout;
		public override bool CanSeek => true;
		public override bool CanRead => m_stream.CanRead;
		public override int ReadTimeout
		{
			get => m_stream.ReadTimeout;
			set => m_stream.ReadTimeout = value;
		}
		public override int WriteTimeout
		{
			get => m_stream.WriteTimeout;
			set => m_stream.WriteTimeout = value;
		}

		private const int DefaultBufferSize = 4096;

		private readonly byte[] m_buffer = new byte[DefaultBufferSize];

		private readonly Stream m_stream;
		private readonly long m_begin;
		private readonly long m_end;
		private readonly bool m_leaveOpen;

		private long m_position;
	}
}

```

`AssetRipper.Fundamentals/IO/Smart/SmartStream.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using System.IO;

namespace AssetRipper.Core.IO.Smart
{
	public class SmartStream : Stream
	{
		private class SmartRefCount
		{
			public static SmartRefCount operator ++(SmartRefCount _this)
			{
				_this.RefCount++;
				return _this;
			}
			public static SmartRefCount operator --(SmartRefCount _this)
			{
				_this.RefCount--;
				return _this;
			}

			public void Increase()
			{
				RefCount++;
			}

			public void Decrease()
			{
				RefCount--;
			}

			public override string ToString()
			{
				return m_refCount.ToString();
			}

			public bool IsZero => RefCount == 0;

			private int RefCount
			{
				get => m_refCount;
				set
				{
					if (value < 0)
					{
						throw new ArgumentOutOfRangeException();
					}
					m_refCount = value;
				}
			}

			private int m_refCount = 0;
		}

		private SmartStream()
		{
			m_isDisposed = true;
		}

		private SmartStream(Stream baseStream, SmartStreamType type)
		{
			if (baseStream == null)
			{
				throw new ArgumentNullException(nameof(baseStream));
			}
			m_stream = baseStream;
			m_streamType = type;
			m_refCount = new SmartRefCount();
			m_refCount++;
		}

		private SmartStream(SmartStream copy)
		{
			Assign(copy);
		}

		~SmartStream()
		{
			Dispose(false);
		}

		public static SmartStream CreateNull()
		{
			return new SmartStream();
		}

		public static SmartStream OpenRead(string path)
		{
			return new SmartStream(MultiFileStream.OpenRead(path), SmartStreamType.File);
		}

		public static SmartStream CreateTemp()
		{
			string tempFile = Path.GetTempFileName();
			return new SmartStream(new FileStream(tempFile, FileMode.Open, FileAccess.ReadWrite, FileShare.None, 4096, FileOptions.DeleteOnClose), SmartStreamType.File);
		}

		public static SmartStream CreateMemory()
		{
			return new SmartStream(new MemoryStream(), SmartStreamType.Memory);
		}

		public static SmartStream CreateMemory(byte[] buffer)
		{
			return new SmartStream(new MemoryStream(buffer), SmartStreamType.Memory);
		}

		public static SmartStream CreateMemory(byte[] buffer, int offset, int size)
		{
			return new SmartStream(new MemoryStream(buffer, offset, size), SmartStreamType.Memory);
		}

		public void Assign(SmartStream source)
		{
			Dispose();

			m_stream = source.m_stream;
			m_streamType = source.m_streamType;
			m_refCount = source.m_refCount;
			m_isDisposed = source.m_isDisposed;
			if (m_isDisposed)
			{
				if (!IsNull)
				{
					throw new ObjectDisposedException(nameof(source));
				}
			}
			else
			{
				m_refCount++;
			}
		}

		public void Move(SmartStream source)
		{
			Assign(source);
			source.Dispose();
		}

		public SmartStream CreateReference()
		{
			return new SmartStream(this);
		}

		public override void Flush()
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			return m_stream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			return m_stream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.Write(buffer, offset, count);
		}

		protected override void Dispose(bool disposing)
		{
			if (!IsNull && !m_isDisposed)
			{
				m_refCount--;
				if (m_refCount.IsZero)
				{
					m_stream.Dispose();
				}
				m_isDisposed = true;
			}
			base.Dispose(disposing);
		}

		public override bool CanRead
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanRead;
			}
		}
		public override bool CanSeek
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanSeek;
			}
		}
		public override bool CanWrite
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanWrite;
			}
		}

		public override long Position
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.Position;
			}
			set
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				m_stream.Position = value;
			}
		}

		public override long Length
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.Length;
			}
		}

		public SmartStreamType StreamType
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_streamType;
			}
		}

		public bool IsNull => m_stream == null;

		private SmartRefCount m_refCount;
		private Stream m_stream;
		private SmartStreamType m_streamType;
		private bool m_isDisposed;
	}
}

```

`AssetRipper.Fundamentals/IO/Smart/SmartStreamType.cs`:

```cs
namespace AssetRipper.Core.IO.Smart
{
	public enum SmartStreamType
	{
		File,
		Memory,
	}
}

```

`AssetRipper.Fundamentals/Interfaces/IHasRawData.cs`:

```cs
namespace AssetRipper.Core.Interfaces
{
	public interface IHasRawData
	{
		byte[] RawData { get; }
	}
}

```

`AssetRipper.Fundamentals/Interfaces/IHasStringName.cs`:

```cs
namespace AssetRipper.Core.Interfaces
{
	public interface IHasNameString
	{
		string NameString { get; set; }
	}

	public static class HasNameExtensions
	{
		/// <summary>
		/// Get a non-empty name for the object
		/// </summary>
		/// <param name="named">The object implementing the HasName interface</param>
		/// <returns>The object's name if it's not empty, otherwise the name of the object's type</returns>
		public static string GetNameNotEmpty(this IHasNameString named)
		{
			string result = named.NameString;
			if (string.IsNullOrEmpty(result))
			{
				result = named is IUnityObjectBase @object ? @object.AssetClassName : named.GetType().Name;
			}
			return result;
		}
	}
}

```

`AssetRipper.Fundamentals/Interfaces/IMonoBehaviourBase.cs`:

```cs
using AssetRipper.Core.Structure.Assembly.Serializable;

namespace AssetRipper.Core.Interfaces
{
	public interface IMonoBehaviourBase
	{
		SerializableStructure Structure { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Interfaces/ITypeTreeSerializable.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;
using System.Collections.Generic;

namespace AssetRipper.Core.Interfaces
{
	public interface ITypeTreeSerializable
	{
		List<TypeTreeNode> MakeReleaseTypeTreeNodes(int depth, int startingIndex);
		List<TypeTreeNode> MakeEditorTypeTreeNodes(int depth, int startingIndex);
	}
}

```

`AssetRipper.Fundamentals/Interfaces/IUnityAssetBase.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;

namespace AssetRipper.Core.Interfaces
{
	public interface IUnityAssetBase : IAsset, IDependent, ITypeTreeSerializable
	{
	}
}

```

`AssetRipper.Fundamentals/Interfaces/IUnityObjectBase.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Object;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Interfaces
{
	public interface IUnityObjectBase : IUnityAssetBase
	{
		AssetInfo AssetInfo { get; set; }
		string AssetClassName { get; }
		ClassIDType ClassID { get; }
		string ExportExtension { get; }
		string ExportPath { get; }
		ISerializedFile SerializedFile { get; }
		UnityGUID GUID { get; set; }
		long PathID { get; }
		YamlDocument ExportYamlDocument(IExportContainer container);
	}

	public static class UnityObjectBaseExtensions
	{
		public static string GetOriginalName(this IUnityObjectBase _this)
		{
			if (_this is IHasNameString named)
			{
				return named.NameString;
			}
			else
			{
				throw new Exception($"Unable to get name for {_this.ClassID}");
			}
		}

		public static string? TryGetName(this IUnityObjectBase _this)
		{
			if (_this is IHasNameString named)
			{
				return named.NameString;
			}
			else
			{
				return null;
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Layout/ClassNameHandler.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Layout
{
	public static class ClassNameHandler
	{
		private static IReadOnlyDictionary<ClassIDType, string> ClassNames { get; } = InitializeClassNames();

		public const string TypelessdataName = "_typelessdata";

		private static Dictionary<ClassIDType, string> InitializeClassNames()
		{
			Dictionary<ClassIDType, string> names = new Dictionary<ClassIDType, string>();
			ClassIDType[] classTypes = (ClassIDType[])System.Enum.GetValues(typeof(ClassIDType));
			foreach (ClassIDType classType in classTypes)
			{
				names[classType] = classType.ToString();
			}
			return names;
		}

		public static string? GetClassName(this LayoutInfo layout, ClassIDType classID)
		{
			if (classID == ClassIDType.PrefabInstance)
			{
				return GetPrefabClassName(layout.Version);
			}
			else if (ClassNames.TryGetValue(classID, out string? name))
			{
				return name;
			}
			else
			{
				return null;
			}
		}

		private static string GetPrefabClassName(UnityVersion version)
		{
			if (version.IsGreaterEqual(2018, 3))
			{
				return "PrefabInstance";
			}
			else if (version.IsGreaterEqual(3, 5))
			{
				return "Prefab";
			}
			else
			{
				return "DataTemplate";
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Layout/LayoutInfo.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files;
using System.Collections.Generic;

namespace AssetRipper.Core.Layout
{
	/// <summary>
	/// A class for holding the Version, Platform, and Transfer Instruction Flags
	/// </summary>
	public sealed class LayoutInfo : IEquatable<LayoutInfo>
	{
		/// <summary>
		/// 2.1.0 and greater
		/// The alignment concept was first introduced only in v2.1.0
		/// </summary>
		public bool IsAlign { get; }
		/// <summary>
		/// 2017.1 and greater
		/// </summary>
		public bool IsAlignArrays { get; }
		/// <summary>
		/// 4.5.0 and greater
		/// </summary>
		public bool IsStructSerializable { get; }

		public UnityVersion Version { get; }
		public BuildTarget Platform { get; }
		public TransferInstructionFlags Flags { get; }

		public LayoutInfo(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			Version = version;
			Platform = platform;
			Flags = flags;
			IsAlign = Version.IsGreaterEqual(2, 1);
			IsAlignArrays = Version.IsGreaterEqual(2017);
			IsStructSerializable = Version.IsGreaterEqual(4, 5);
		}

		public override string ToString()
		{
			return $"v{Version} {Platform} [{Flags}]";
		}

		public override bool Equals(object? obj)
		{
			return Equals(obj as LayoutInfo);
		}

		public bool Equals(LayoutInfo? other)
		{
			return other is not null &&
				   Version.Equals(other.Version) &&
				   Platform == other.Platform &&
				   Flags == other.Flags;
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(Version, Platform, Flags);
		}

		public static bool operator ==(LayoutInfo left, LayoutInfo right)
		{
			return EqualityComparer<LayoutInfo>.Default.Equals(left, right);
		}

		public static bool operator !=(LayoutInfo left, LayoutInfo right)
		{
			return !(left == right);
		}
	}
}

```

`AssetRipper.Fundamentals/Logging/ConsoleLogger.cs`:

```cs
namespace AssetRipper.Core.Logging
{
	public class ConsoleLogger : ILogger
	{
		public ConsoleLogger() : this(false) { }
		/// <param name="resizeConsole">If true, on Windows it will resize the console to 80% of the maximum size.</param>
		public ConsoleLogger(bool resizeConsole)
		{
			if (resizeConsole && OperatingSystem.IsWindows())
			{
				try
				{
					Console.WindowWidth = (int)(Console.LargestWindowWidth * 0.8f);
					Console.WindowHeight = (int)(Console.LargestWindowHeight * 0.8f);
					Console.BufferHeight = 2000;
				}
				catch
				{
					// pull/563 : happens when running in any context where the console is not actually attached to a TTY
				}
			}
		}

		public void BlankLine(int numLines)
		{
			for (int i = 0; i < numLines; i++)
			{
				Console.WriteLine();
			}
		}

		public void Log(LogType type, LogCategory category, string message)
		{
			if (type == LogType.Info)
			{
				if (category == LogCategory.None)
				{
					Console.WriteLine(message);
				}
				else
				{
					Console.WriteLine($"{category} : {message}");
				}

				return;
			}

			ConsoleColor foreColor = Console.ForegroundColor;

			switch (type)
			{
				case LogType.Debug:
					Console.ForegroundColor = ConsoleColor.DarkBlue;
					break;

				case LogType.Verbose:
					Console.ForegroundColor = ConsoleColor.DarkGray;
					break;

				case LogType.Warning:
					Console.ForegroundColor = ConsoleColor.DarkYellow;
					break;

				case LogType.Error:
					Console.ForegroundColor = ConsoleColor.DarkRed;
					break;
			}

			if (category == LogCategory.None)
			{
				Console.WriteLine(message);
			}
			else
			{
				Console.WriteLine($"{category} : {message}");
			}

			Console.ForegroundColor = foreColor;
		}
	}
}

```

`AssetRipper.Fundamentals/Logging/FileLogger.cs`:

```cs
using AssetRipper.Core.Utils;
using System.IO;
using System.Linq;
using System.Text;

namespace AssetRipper.Core.Logging
{
	public class FileLogger : ILogger
	{
		private readonly string filePath;

		public FileLogger() : this(ExecutingDirectory.Combine("AssetRipper.log")) { }

		/// <param name="filePath">The absolute path to the log file</param>
		public FileLogger(string filePath)
		{
			if (string.IsNullOrWhiteSpace(filePath))
			{
				throw new ArgumentException("Invalid path", nameof(filePath));
			}

			this.filePath = filePath;

			File.Create(this.filePath).Close();
		}

		public void Log(LogType type, LogCategory category, string message)
		{
			StringBuilder stringBuilder = new StringBuilder();

			if (category != LogCategory.None)
			{
				stringBuilder.Append($"{category.ToString()} ");
			}

			switch (type)
			{
				case LogType.Warning:
				case LogType.Error:
					stringBuilder.Append($"[{type.ToString()}] ");
					break;
			}
			stringBuilder.Append(": ");
			stringBuilder.Append(message);
			stringBuilder.Append(Environment.NewLine);
			try
			{
				File.AppendAllText(filePath, stringBuilder.ToString());
			}
			catch (System.IO.IOException)
			{
				//Could not log to file
			}
		}

		public void BlankLine(int numLines)
		{
			try
			{
				File.AppendAllLines(filePath, Enumerable.Repeat("", 5).ToArray());
			}
			catch (System.IO.IOException)
			{
				//Could not log to file
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Logging/ILogger.cs`:

```cs
namespace AssetRipper.Core.Logging
{
	public interface ILogger
	{
		void Log(LogType type, LogCategory category, string message);

		void BlankLine(int numLines);
	}
}

```

`AssetRipper.Fundamentals/Logging/LogCategory.cs`:

```cs
namespace AssetRipper.Core.Logging
{
	public enum LogCategory
	{
		General,
		Import,
		Export,
		ExportedFile,
		Cpp2IL,
		System,
		LibVlc,
		Avalonia,
		Plugin,
		VersionManager,

		None,
		Debug,
	}
}

```

`AssetRipper.Fundamentals/Logging/LogType.cs`:

```cs
namespace AssetRipper.Core.Logging
{
	public enum LogType
	{
		Info,
		Warning,
		Error,
		Verbose,
		Debug,
	}
}

```

`AssetRipper.Fundamentals/Logging/Logger.cs`:

```cs
using AssetRipper.Core.Utils;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Logging
{
	public static class Logger
	{
		private static readonly List<ILogger> loggers = new List<ILogger>();
		public static bool AllowVerbose { get; set; }

		public static event Action<string, object?> OnStatusChanged = (_, _) => { };

		static Logger()
		{
			Cpp2IL.Core.Logger.InfoLog += (string message, string source) => LogCpp2IL(LogType.Info, message);
			Cpp2IL.Core.Logger.WarningLog += (string message, string source) => LogCpp2IL(LogType.Verbose, message);
			Cpp2IL.Core.Logger.ErrorLog += (string message, string source) => LogCpp2IL(LogType.Error, message);
			Cpp2IL.Core.Logger.VerboseLog += (string message, string source) => LogCpp2IL(LogType.Verbose, message);
		}

		private static void LogCpp2IL(LogType logType, string message)
		{
			Log(logType, LogCategory.Cpp2IL, message.Trim());
		}

		public static void Log(LogType type, LogCategory category, string message)
		{
#if !DEBUG
			if (type == LogType.Debug)
			{
				return;
			}
#endif
			if (type == LogType.Verbose && !AllowVerbose)
			{
				return;
			}

			if (message == null)
			{
				throw new ArgumentNullException(nameof(message));
			}

			foreach (ILogger instance in loggers)
			{
				instance?.Log(type, category, message);
			}
		}

		public static void Log(LogType type, LogCategory category, string[] messages)
		{
			if (messages == null)
			{
				throw new ArgumentNullException(nameof(messages));
			}

			foreach (string message in messages)
			{
				Log(type, category, message);
			}
		}

		public static void BlankLine() => BlankLine(1);
		public static void BlankLine(int numLines)
		{
			foreach (ILogger instance in loggers)
			{
				instance?.BlankLine(numLines);
			}
		}

		public static void Info(string message) => Log(LogType.Info, LogCategory.None, message);
		public static void Info(LogCategory category, string message) => Log(LogType.Info, category, message);
		public static void Warning(string message) => Log(LogType.Warning, LogCategory.None, message);
		public static void Warning(LogCategory category, string message) => Log(LogType.Warning, category, message);
		public static void Error(string message) => Log(LogType.Error, LogCategory.None, message);
		public static void Error(LogCategory category, string message) => Log(LogType.Error, category, message);
		public static void Error(Exception e) => Error(LogCategory.None, null, e);
		public static void Error(string message, Exception e) => Error(LogCategory.None, message, e);
		public static void Error(LogCategory category, string? message, Exception e)
		{
			StringBuilder sb = new StringBuilder();
			if (message != null)
			{
				sb.AppendLine(message);
			}

			sb.AppendLine(e.ToString());
			Log(LogType.Error, category, sb.ToString());
		}
		public static void Verbose(string message) => Log(LogType.Verbose, LogCategory.None, message);
		public static void Verbose(LogCategory category, string message) => Log(LogType.Verbose, category, message);
		public static void Debug(string message) => Log(LogType.Debug, LogCategory.None, message);
		public static void Debug(LogCategory category, string message) => Log(LogType.Debug, category, message);

		private static void LogReleaseInformation()
		{
#if DEBUG
			Log(LogType.Info, LogCategory.System, $"AssetRipper Build Type: Debug {GetBuildArchitecture()} {GetBuildType()}");
#else
			Log(LogType.Info, LogCategory.System, $"AssetRipper Build Type: Release {GetBuildArchitecture()} {GetBuildType()}");
#endif
		}

		private static string GetBuildArchitecture()
		{
			return Environment.Is64BitProcess ? "x64" : "x86";
		}

		private static string GetBuildType()
		{
			return File.Exists(ExecutingDirectory.Combine("AssetRipperCore.dll")) ? "Compiled" : "Published";
		}

		private static void LogOperatingSystemInformation()
		{
			Log(LogType.Info, LogCategory.System, $"System Version: {Environment.OSVersion.VersionString}");
			string architecture = Environment.Is64BitOperatingSystem ? "x64" : "x86";
			Log(LogType.Info, LogCategory.System, $"Operating System: {GetOsName()} {architecture}");
		}

		public static void LogSystemInformation(string programName)
		{
			Log(LogType.Info, LogCategory.System, programName);
			LogOperatingSystemInformation();
			Log(LogType.Info, LogCategory.System, $"AssetRipper Version: {BuildInfo.Version}");
			LogReleaseInformation();
			Log(LogType.Info, LogCategory.System, $"UTC Current Time: {System.DateTime.UtcNow.ToString()}");
			Log(LogType.Info, LogCategory.System, $"UTC Compile Time: {GetCompileTime()}");
		}

		private static string GetCompileTime()
		{
			string path = ExecutingDirectory.Combine("compile_time.txt");
			if (File.Exists(path))
			{
				return File.ReadAllText(path).Trim();
			}
			else
			{
				return "Unknown";
			}
		}

		private static string GetOsName()
		{
			if (OperatingSystem.IsWindows())
			{
				return "Windows";
			}
			else if (OperatingSystem.IsLinux())
			{
				return "Linux";
			}
			else if (OperatingSystem.IsMacOS())
			{
				return "MacOS";
			}
			else if (OperatingSystem.IsBrowser())
			{
				return "Browser";
			}
			else if (OperatingSystem.IsAndroid())
			{
				return "Android";
			}
			else if (OperatingSystem.IsIOS())
			{
				return "iOS";
			}
			else if (OperatingSystem.IsFreeBSD())
			{
				return "FreeBSD";
			}
			else
			{
				return "Other";
			}
		}

		public static void Add(ILogger logger) => loggers.Add(logger);

		public static void Remove(ILogger logger) => loggers.Remove(logger);

		public static void Clear() => loggers.Clear();

		public static void SendStatusChange(string newStatus, object? context = null) => OnStatusChanged(newStatus, context);
	}
}

```

`AssetRipper.Fundamentals/Math/Colors/ColorRGBA32.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Math.Colors
{
	public sealed class ColorRGBA32 : IAsset, IColorRGBA32
	{
		public ColorRGBA32() { }

		public ColorRGBA32(byte r, byte g, byte b, byte a)
		{
			Rgba = unchecked((uint)(r | (g << 8) | (b << 16) | (a << 24)));
		}

		public static explicit operator ColorRGBA32(ColorRGBAf color)
		{
			byte r = ConvertFloatToByte(color.R);
			byte g = ConvertFloatToByte(color.G);
			byte b = ConvertFloatToByte(color.B);
			byte a = ConvertFloatToByte(color.A);
			return new ColorRGBA32(r, g, b, a);
		}

		private static byte ConvertFloatToByte(float value)
		{
			if (float.IsNaN(value))
			{
				return byte.MinValue;
			}

			float scaledValue = value * 255.0f;
			if (scaledValue <= 0f)
			{
				return byte.MinValue;
			}

			if (scaledValue >= 255f)
			{
				return byte.MaxValue;
			}

			return (byte)scaledValue;
		}

		public void Read(AssetReader reader)
		{
			Rgba = reader.ReadUInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Rgba);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion());
			node.Add(RgbaName, Rgba);
			return node;
		}

		/// <summary>
		/// NOTE: min version is 2
		/// </summary>
		public static int ToSerializedVersion() => 2;

		public static ColorRGBA32 Black => new ColorRGBA32(byte.MinValue, byte.MinValue, byte.MinValue, byte.MaxValue);
		public static ColorRGBA32 White => new ColorRGBA32(byte.MaxValue, byte.MaxValue, byte.MaxValue, byte.MaxValue);

		public uint Rgba { get; set; }

		public const string RgbaName = "rgba";
	}
}

```

`AssetRipper.Fundamentals/Math/Colors/ColorRGBAf.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Core.Math.Colors
{
	public sealed class ColorRGBAf : IAsset, IEquatable<ColorRGBAf>, IColorRGBAf
	{
		public float R { get; set; }
		public float G { get; set; }
		public float B { get; set; }
		public float A { get; set; }

		public const string RName = "r";
		public const string GName = "g";
		public const string BName = "b";
		public const string AName = "a";

		public ColorRGBAf() { }

		public ColorRGBAf(float r, float g, float b, float a)
		{
			R = r;
			G = g;
			B = b;
			A = a;
		}

		public static explicit operator ColorRGBAf(ColorRGBA32 color32)
		{
			ColorRGBAf color = new();
			color.CopyValuesFrom(color32);
			return color;
		}

		public static explicit operator Vector4f(ColorRGBAf c) => new(c.R, c.G, c.B, c.A);

		public ColorRGBAf Clone() => new ColorRGBAf(R, G, B, A);

		public void CopyValuesFrom(ColorRGBA32 color32)
		{
			R = color32.R() / 255.0f;
			G = color32.G() / 255.0f;
			B = color32.B() / 255.0f;
			A = color32.A() / 255.0f;
		}

		public void CopyValuesFrom(ColorRGBAf colorf)
		{
			R = colorf.R;
			G = colorf.G;
			B = colorf.B;
			A = colorf.A;
		}

		public void Read(AssetReader reader)
		{
			R = reader.ReadSingle();
			G = reader.ReadSingle();
			B = reader.ReadSingle();
			A = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(R);
			writer.Write(G);
			writer.Write(B);
			writer.Write(A);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new();
			node.Style = MappingStyle.Flow;
			node.Add(RName, R);
			node.Add(GName, G);
			node.Add(BName, B);
			node.Add(AName, A);
			return node;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "[R:{0:0.00} G:{1:0.00} B:{2:0.00} A:{3:0.00}]", R, G, B, A);
		}

		public override int GetHashCode()
		{
			return ((Vector4f)this).GetHashCode();
		}

		public override bool Equals(object? other)
		{
			if (other is ColorRGBAf color)
			{
				return Equals(color);
			}
			else
			{
				return false;
			}
		}

		public bool Equals(ColorRGBAf? other)
		{
			return other is not null && R.Equals(other.R) && G.Equals(other.G) && B.Equals(other.B) && A.Equals(other.A);
		}

		public static ColorRGBAf operator +(ColorRGBAf a, ColorRGBAf b)
		{
			return new ColorRGBAf(a.R + b.R, a.G + b.G, a.B + b.B, a.A + b.A);
		}

		public static ColorRGBAf operator -(ColorRGBAf a, ColorRGBAf b)
		{
			return new ColorRGBAf(a.R - b.R, a.G - b.G, a.B - b.B, a.A - b.A);
		}

		public static ColorRGBAf operator *(ColorRGBAf a, ColorRGBAf b)
		{
			return new ColorRGBAf(a.R * b.R, a.G * b.G, a.B * b.B, a.A * b.A);
		}

		public static ColorRGBAf operator *(ColorRGBAf a, float b)
		{
			return new ColorRGBAf(a.R * b, a.G * b, a.B * b, a.A * b);
		}

		public static ColorRGBAf operator *(float b, ColorRGBAf a)
		{
			return new ColorRGBAf(a.R * b, a.G * b, a.B * b, a.A * b);
		}

		public static ColorRGBAf operator /(ColorRGBAf a, float b)
		{
			return new ColorRGBAf(a.R / b, a.G / b, a.B / b, a.A / b);
		}

		public static bool operator ==(ColorRGBAf lhs, ColorRGBAf rhs)
		{
			return (Vector4f)lhs == (Vector4f)rhs;
		}

		public static bool operator !=(ColorRGBAf lhs, ColorRGBAf rhs)
		{
			return !(lhs == rhs);
		}

		public static ColorRGBAf Black => new(0.0f, 0.0f, 0.0f, 1.0f);
		public static ColorRGBAf White => new(1.0f, 1.0f, 1.0f, 1.0f);
	}
}

```

`AssetRipper.Fundamentals/Math/Colors/IColorRGBA32.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Colors
{
	public interface IColorRGBA32 : IAsset
	{
		uint Rgba { get; set; }
	}

	public static class ColorRGBA32Extensions
	{
		public static byte R(this IColorRGBA32 color) => (byte)((color.Rgba >> 0) & 0xFF);
		public static byte G(this IColorRGBA32 color) => (byte)((color.Rgba >> 8) & 0xFF);
		public static byte B(this IColorRGBA32 color) => (byte)((color.Rgba >> 16) & 0xFF);
		public static byte A(this IColorRGBA32 color) => (byte)((color.Rgba >> 24) & 0xFF);
	}
}

```

`AssetRipper.Fundamentals/Math/Colors/IColorRGBAf.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Colors
{
	public interface IColorRGBAf : IAsset
	{
		float R { get; set; }
		float G { get; set; }
		float B { get; set; }
		float A { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/IMatrix4x4f.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math
{
	public interface IMatrix4x4f : IAsset
	{
		float E00 { get; set; }
		float E01 { get; set; }
		float E02 { get; set; }
		float E03 { get; set; }
		float E10 { get; set; }
		float E11 { get; set; }
		float E12 { get; set; }
		float E13 { get; set; }
		float E20 { get; set; }
		float E21 { get; set; }
		float E22 { get; set; }
		float E23 { get; set; }
		float E30 { get; set; }
		float E31 { get; set; }
		float E32 { get; set; }
		float E33 { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/IRectf.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math
{
	public interface IRectf : IAsset
	{
		float X { get; set; }
		float Y { get; set; }
		float Width { get; set; }
		float Height { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/Matrix4x4f.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Math
{
	public sealed class Matrix4x4f : IAsset, IEquatable<Matrix4x4f>, IMatrix4x4f
	{
		public float E00 { get; set; }
		public float E01 { get; set; }
		public float E02 { get; set; }
		public float E03 { get; set; }

		public float E10 { get; set; }
		public float E11 { get; set; }
		public float E12 { get; set; }
		public float E13 { get; set; }

		public float E20 { get; set; }
		public float E21 { get; set; }
		public float E22 { get; set; }
		public float E23 { get; set; }

		public float E30 { get; set; }
		public float E31 { get; set; }
		public float E32 { get; set; }
		public float E33 { get; set; }

		public const string E00Name = "e00";
		public const string E01Name = "e01";
		public const string E02Name = "e02";
		public const string E03Name = "e03";
		public const string E10Name = "e10";
		public const string E11Name = "e11";
		public const string E12Name = "e12";
		public const string E13Name = "e13";
		public const string E20Name = "e20";
		public const string E21Name = "e21";
		public const string E22Name = "e22";
		public const string E23Name = "e23";
		public const string E30Name = "e30";
		public const string E31Name = "e31";
		public const string E32Name = "e32";
		public const string E33Name = "e33";

		public Matrix4x4f() { }

		public Matrix4x4f(float[] values)
		{
			if (values == null)
			{
				throw new ArgumentNullException(nameof(values));
			}

			if (values.Length != 16)
			{
				throw new ArgumentOutOfRangeException(nameof(values), "There must be exactly sixteen input values for Matrix.");
			}

			E00 = values[0];
			E01 = values[1];
			E02 = values[2];
			E03 = values[3];

			E10 = values[4];
			E11 = values[5];
			E12 = values[6];
			E13 = values[7];

			E20 = values[8];
			E21 = values[9];
			E22 = values[10];
			E23 = values[11];

			E30 = values[12];
			E31 = values[13];
			E32 = values[14];
			E33 = values[15];
		}

		public void Read(AssetReader reader)
		{
			E00 = reader.ReadSingle();
			E01 = reader.ReadSingle();
			E02 = reader.ReadSingle();
			E03 = reader.ReadSingle();
			E10 = reader.ReadSingle();
			E11 = reader.ReadSingle();
			E12 = reader.ReadSingle();
			E13 = reader.ReadSingle();
			E20 = reader.ReadSingle();
			E21 = reader.ReadSingle();
			E22 = reader.ReadSingle();
			E23 = reader.ReadSingle();
			E30 = reader.ReadSingle();
			E31 = reader.ReadSingle();
			E32 = reader.ReadSingle();
			E33 = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(E00);
			writer.Write(E01);
			writer.Write(E02);
			writer.Write(E03);
			writer.Write(E10);
			writer.Write(E11);
			writer.Write(E12);
			writer.Write(E13);
			writer.Write(E20);
			writer.Write(E21);
			writer.Write(E22);
			writer.Write(E23);
			writer.Write(E30);
			writer.Write(E31);
			writer.Write(E32);
			writer.Write(E33);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(E00Name, E00);
			node.Add(E01Name, E01);
			node.Add(E02Name, E02);
			node.Add(E03Name, E03);
			node.Add(E10Name, E10);
			node.Add(E11Name, E11);
			node.Add(E12Name, E12);
			node.Add(E13Name, E13);
			node.Add(E20Name, E20);
			node.Add(E21Name, E21);
			node.Add(E22Name, E22);
			node.Add(E23Name, E23);
			node.Add(E30Name, E30);
			node.Add(E31Name, E31);
			node.Add(E32Name, E32);
			node.Add(E33Name, E33);
			return node;
		}

		public float this[int row, int column]
		{
			get => this[row + (column * 4)];

			set => this[row + (column * 4)] = value;
		}

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => E00,
					1 => E01,
					2 => E02,
					3 => E03,
					4 => E10,
					5 => E11,
					6 => E12,
					7 => E13,
					8 => E20,
					9 => E21,
					10 => E22,
					11 => E23,
					12 => E30,
					13 => E31,
					14 => E32,
					15 => E33,
					_ => throw new ArgumentOutOfRangeException(nameof(index), "Invalid Matrix4x4 index!"),
				};
			}

			set
			{
				switch (index)
				{
					case 0: E00 = value; break;
					case 1: E01 = value; break;
					case 2: E02 = value; break;
					case 3: E03 = value; break;
					case 4: E10 = value; break;
					case 5: E11 = value; break;
					case 6: E12 = value; break;
					case 7: E13 = value; break;
					case 8: E20 = value; break;
					case 9: E21 = value; break;
					case 10: E22 = value; break;
					case 11: E23 = value; break;
					case 12: E30 = value; break;
					case 13: E31 = value; break;
					case 14: E32 = value; break;
					case 15: E33 = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Matrix4x4 index!");
				}
			}
		}

		public static Matrix4x4f Identity => new Matrix4x4f { E00 = 1.0f, E11 = 1.0f, E22 = 1.0f, E33 = 1.0f };

		public override int GetHashCode()
		{
			return GetColumn(0).GetHashCode() ^ (GetColumn(1).GetHashCode() << 2) ^ (GetColumn(2).GetHashCode() >> 2) ^ (GetColumn(3).GetHashCode() >> 1);
		}

		public override bool Equals(object? other)
		{
			if (other is Matrix4x4f matrix)
			{
				return Equals(matrix);
			}
			else
			{
				return false;
			}
		}

		public bool Equals(Matrix4x4f? other)
		{
			return other is not null && GetColumn(0).Equals(other.GetColumn(0))
				   && GetColumn(1).Equals(other.GetColumn(1))
				   && GetColumn(2).Equals(other.GetColumn(2))
				   && GetColumn(3).Equals(other.GetColumn(3));
		}

		public Vector4f GetColumn(int index)
		{
			return index switch
			{
				0 => new Vector4f(E00, E01, E02, E03),
				1 => new Vector4f(E10, E11, E12, E13),
				2 => new Vector4f(E20, E21, E22, E23),
				3 => new Vector4f(E30, E31, E32, E33),
				_ => throw new IndexOutOfRangeException("Invalid column index!"),
			};
		}

		public Vector4f GetRow(int index)
		{
			return index switch
			{
				0 => new Vector4f(E00, E10, E20, E30),
				1 => new Vector4f(E01, E11, E21, E31),
				2 => new Vector4f(E02, E12, E22, E32),
				3 => new Vector4f(E03, E13, E23, E33),
				_ => throw new IndexOutOfRangeException("Invalid row index!"),
			};
		}

		public static Matrix4x4f operator *(Matrix4x4f lhs, Matrix4x4f rhs)
		{
			Matrix4x4f res = new();
			res.E00 = (lhs.E00 * rhs.E00) + (lhs.E10 * rhs.E01) + (lhs.E20 * rhs.E02) + (lhs.E30 * rhs.E03);
			res.E10 = (lhs.E00 * rhs.E10) + (lhs.E10 * rhs.E11) + (lhs.E20 * rhs.E12) + (lhs.E30 * rhs.E13);
			res.E20 = (lhs.E00 * rhs.E20) + (lhs.E10 * rhs.E21) + (lhs.E20 * rhs.E22) + (lhs.E30 * rhs.E23);
			res.E30 = (lhs.E00 * rhs.E30) + (lhs.E10 * rhs.E31) + (lhs.E20 * rhs.E32) + (lhs.E30 * rhs.E33);

			res.E01 = (lhs.E01 * rhs.E00) + (lhs.E11 * rhs.E01) + (lhs.E21 * rhs.E02) + (lhs.E31 * rhs.E03);
			res.E11 = (lhs.E01 * rhs.E10) + (lhs.E11 * rhs.E11) + (lhs.E21 * rhs.E12) + (lhs.E31 * rhs.E13);
			res.E21 = (lhs.E01 * rhs.E20) + (lhs.E11 * rhs.E21) + (lhs.E21 * rhs.E22) + (lhs.E31 * rhs.E23);
			res.E31 = (lhs.E01 * rhs.E30) + (lhs.E11 * rhs.E31) + (lhs.E21 * rhs.E32) + (lhs.E31 * rhs.E33);

			res.E02 = (lhs.E02 * rhs.E00) + (lhs.E12 * rhs.E01) + (lhs.E22 * rhs.E02) + (lhs.E32 * rhs.E03);
			res.E12 = (lhs.E02 * rhs.E10) + (lhs.E12 * rhs.E11) + (lhs.E22 * rhs.E12) + (lhs.E32 * rhs.E13);
			res.E22 = (lhs.E02 * rhs.E20) + (lhs.E12 * rhs.E21) + (lhs.E22 * rhs.E22) + (lhs.E32 * rhs.E23);
			res.E32 = (lhs.E02 * rhs.E30) + (lhs.E12 * rhs.E31) + (lhs.E22 * rhs.E32) + (lhs.E32 * rhs.E33);

			res.E03 = (lhs.E03 * rhs.E00) + (lhs.E13 * rhs.E01) + (lhs.E23 * rhs.E02) + (lhs.E33 * rhs.E03);
			res.E13 = (lhs.E03 * rhs.E10) + (lhs.E13 * rhs.E11) + (lhs.E23 * rhs.E12) + (lhs.E33 * rhs.E13);
			res.E23 = (lhs.E03 * rhs.E20) + (lhs.E13 * rhs.E21) + (lhs.E23 * rhs.E22) + (lhs.E33 * rhs.E23);
			res.E33 = (lhs.E03 * rhs.E30) + (lhs.E13 * rhs.E31) + (lhs.E23 * rhs.E32) + (lhs.E33 * rhs.E33);

			return res;
		}

		public static bool operator ==(Matrix4x4f lhs, Matrix4x4f rhs)
		{
			return lhs.GetColumn(0) == rhs.GetColumn(0)
				&& lhs.GetColumn(1) == rhs.GetColumn(1)
				&& lhs.GetColumn(2) == rhs.GetColumn(2)
				&& lhs.GetColumn(3) == rhs.GetColumn(3);
		}

		public static bool operator !=(Matrix4x4f lhs, Matrix4x4f rhs)
		{
			return !(lhs == rhs);
		}

		public static Matrix4x4f Scale(Vector3f vector)
		{
			Matrix4x4f m = new();
			m.E00 = vector.X; m.E10 = 0F; m.E20 = 0F; m.E30 = 0F;
			m.E01 = 0F; m.E11 = vector.Y; m.E21 = 0F; m.E31 = 0F;
			m.E02 = 0F; m.E12 = 0F; m.E22 = vector.Z; m.E32 = 0F;
			m.E03 = 0F; m.E13 = 0F; m.E23 = 0F; m.E33 = 1F;
			return m;
		}

		public static Matrix4x4f Translate(Vector3f vector)
		{
			Matrix4x4f m = new();
			m.E00 = 1F; m.E10 = 0F; m.E20 = 0F; m.E30 = vector.X;
			m.E01 = 0F; m.E11 = 1F; m.E21 = 0F; m.E31 = vector.Y;
			m.E02 = 0F; m.E12 = 0F; m.E22 = 1F; m.E32 = vector.Z;
			m.E03 = 0F; m.E13 = 0F; m.E23 = 0F; m.E33 = 1F;
			return m;
		}

		public static Matrix4x4f Rotate(Quaternionf q)
		{
			float x = q.X * 2.0F;
			float y = q.Y * 2.0F;
			float z = q.Z * 2.0F;
			float xx = q.X * x;
			float yy = q.Y * y;
			float zz = q.Z * z;
			float xy = q.X * y;
			float xz = q.X * z;
			float yz = q.Y * z;
			float wx = q.W * x;
			float wy = q.W * y;
			float wz = q.W * z;

			Matrix4x4f m = new();
			m.E00 = 1.0f - (yy + zz); m.E01 = xy + wz; m.E02 = xz - wy; m.E03 = 0.0F;
			m.E10 = xy - wz; m.E11 = 1.0f - (xx + zz); m.E12 = yz + wx; m.E13 = 0.0F;
			m.E20 = xz + wy; m.E21 = yz - wx; m.E22 = 1.0f - (xx + yy); m.E23 = 0.0F;
			m.E30 = 0.0F; m.E31 = 0.0F; m.E32 = 0.0F; m.E33 = 1.0F;
			return m;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/IPackedFloatVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public interface IPackedFloatVector : IAsset
	{
		/// <summary>
		/// The number of values stored within
		/// </summary>
		uint NumItems { get; set; }
		/// <summary>
		/// A positive value representing the difference between the maximum and minimum values stored in the data
		/// </summary>
		float Range { get; set; }
		/// <summary>
		/// The minimum value compressed in the data
		/// </summary>
		float Start { get; set; }
		/// <summary>
		/// The compressed data containing all the values
		/// </summary>
		byte[] Data { get; set; }
		/// <summary>
		/// Allegedly a maximum of 32, but it seems to be really 24 due to the <see cref="float"/> binary structure
		/// </summary>
		byte BitSize { get; set; }
	}

	public static class PackedFloatVectorExtensions
	{
		public static bool IsSet(this IPackedFloatVector packedVector) => packedVector.NumItems > 0;

		public static void CopyValuesFrom(this IPackedFloatVector instance, IPackedFloatVector source)
		{
			instance.NumItems = source.NumItems;
			instance.Range = source.Range;
			instance.Start = source.Start;
			instance.Data = source.Data.ToArray();
			instance.BitSize = source.BitSize;
		}

		public static float[] Unpack(this IPackedFloatVector packedVector)
		{
			return packedVector.Unpack(packedVector.NumItems, 0);
		}

		public static float[] Unpack(this IPackedFloatVector packedVector, uint chunkCount, int offset)
		{
			int bitIndex = packedVector.BitSize * offset % 8;
			int byteIndex = packedVector.BitSize * offset / 8;

			float scale = 1.0f / packedVector.Range;
			float halfMaxValue = scale * ((1 << packedVector.BitSize) - 1);
			float[] buffer = new float[chunkCount];

			for (int i = 0; i < chunkCount; i++)
			{
				int value = 0;
				int bits = 0;
				while (bits < packedVector.BitSize)
				{
					value |= packedVector.Data[byteIndex] >> bitIndex << bits;
					int num = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
					bitIndex += num;
					bits += num;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				value &= (1 << packedVector.BitSize) - 1;
				buffer[i] = packedVector.Start + (value / halfMaxValue);
			}
			return buffer;
		}

		public static float[] Unpack(this IPackedFloatVector packedVector, uint chunkSize, uint chunkCount, int offset)
		{
			return packedVector.Unpack(chunkSize * chunkCount, offset);
		}

		public static float[] UnpackFloats(this IPackedFloatVector packedVector, int itemCountInChunk, int chunkStride, int start = 0, int numChunks = -1)
		{
			if (chunkStride % 4 != 0)
			{
				throw new ArgumentException(nameof(chunkStride));
			}

			int bitIndex = packedVector.BitSize * start;
			int byteIndex = bitIndex / 8;
			bitIndex %= 8;

			float scale = 1.0f / packedVector.Range;
			if (numChunks == -1)
			{
				numChunks = (int)packedVector.NumItems / itemCountInChunk;
			}

			int end = chunkStride * numChunks / 4;
			List<float> data = new List<float>();
			for (int index = 0; index != end; index += chunkStride / 4)
			{
				for (int i = 0; i < itemCountInChunk; ++i)
				{
					uint x = 0;

					int bits = 0;
					while (bits < packedVector.BitSize)
					{
						x |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bits));
						int read = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
						bitIndex += read;
						bits += read;
						if (bitIndex == 8)
						{
							byteIndex++;
							bitIndex = 0;
						}
					}
					x &= unchecked((uint)(1 << packedVector.BitSize) - 1u);
					data.Add((x / (scale * ((1 << packedVector.BitSize) - 1))) + packedVector.Start);
				}
			}
			return data.ToArray();
		}

		public static void PackFloats(this IPackedFloatVector packedVector, float[] data, int itemCountInChunk, int chunkStride, int numChunks, int bitSize, bool adjustBitSize)
		{
			if (data.Length != itemCountInChunk * numChunks)
			{
				throw new ArgumentException(nameof(data));
			}

			if (chunkStride != itemCountInChunk * 4)
			{
				throw new ArgumentException(nameof(chunkStride));
			}

			packedVector.PackFloats(data, bitSize, adjustBitSize);
		}

		public static void PackFloats(this IPackedFloatVector packedVector, float[] data, int bitSize, bool adjustBitSize)
		{
			float maxf = float.NegativeInfinity;
			float minf = float.PositiveInfinity;
			for (int i = 0; i < data.Length; ++i)
			{
				if (maxf < data[i])
				{
					maxf = data[i];
				}

				if (minf > data[i])
				{
					minf = data[i];
				}
			}

			packedVector.Range = maxf - minf;

			if (adjustBitSize)
			{
				bitSize += GetBitCount(packedVector.Range);
			}

			if (bitSize > 32)
			{
				bitSize = 32;
			}

			packedVector.Start = minf;
			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = (byte)bitSize;
			packedVector.Data = new byte[((packedVector.NumItems * bitSize) + 7) / 8];


			double scale = 1.0d / packedVector.Range;

			int bitIndex = 0;
			int byteIndex = 0;

			for (int i = 0; i < data.Length; ++i)
			{
				double scaled = (data[i] - packedVector.Start) * scale;
				if (scaled < 0)
				{
					scaled = 0d;
				}
				else if (scaled > 1)
				{
					scaled = 1d;
				}

				float f = BitConverter.Int32BitsToSingle((1 << (packedVector.BitSize)) - 1);
				double d = scaled * f;
				uint x = BitConverter.SingleToUInt32Bits((float)d);

				int bits = 0;
				while (bits < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((x >> bits) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
					bitIndex += read;
					bits += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		private static int GetBitCount(double value)
		{
			double log = System.Math.Log2(value);
			return (int)System.Math.Ceiling(log);
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/IPackedIntVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using System.Linq;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public interface IPackedIntVector : IAsset
	{
		uint NumItems { get; set; }
		byte[] Data { get; set; }
		/// <summary>
		/// Maximum of 32
		/// </summary>
		byte BitSize { get; set; }
	}

	public static class PackedIntVectorExtensions
	{
		public static bool IsSet(this IPackedIntVector packedVector) => packedVector.NumItems > 0;

		public static void CopyValuesFrom(this IPackedIntVector instance, IPackedIntVector source)
		{
			instance.NumItems = source.NumItems;
			instance.Data = source.Data.ToArray();
			instance.BitSize = source.BitSize;
		}

		public static void PackUInts(this IPackedIntVector packedVector, uint[] data)
		{
			uint maxDataValue = 0;
			for (int i = 0; i < data.Length; i++)
			{
				if (maxDataValue < data[i])
				{
					maxDataValue = data[i];
				}
			}

			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
			packedVector.Data = new byte[((data.Length * packedVector.BitSize) + 7) / 8];

			int bitIndex = 0;
			int byteIndex = 0;
			for (int i = 0; i < data.Length; i++)
			{
				int bitOffset = 0;
				while (bitOffset < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((data[i] >> bitOffset) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		public static void PackUShorts(this IPackedIntVector packedVector, ushort[] data)
		{
			uint maxDataValue = 0;
			for (int i = 0; i < data.Length; i++)
			{
				if (maxDataValue < data[i])
				{
					maxDataValue = data[i];
				}
			}

			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
			packedVector.Data = new byte[((data.Length * packedVector.BitSize) + 7) / 8];

			int bitIndex = 0;
			int byteIndex = 0;
			for (int i = 0; i < data.Length; i++)
			{
				int bitOffset = 0;
				while (bitOffset < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((data[i] >> bitOffset) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		public static int[] UnpackInts(this IPackedIntVector packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			int[] buffer = new int[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= packedVector.Data[byteIndex] >> bitIndex << bitOffset;
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= unchecked((1 << packedVector.BitSize) - 1);
			}
			return buffer;
		}

		public static uint[] UnpackUInts(this IPackedIntVector packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			uint[] buffer = new uint[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= unchecked((uint)((packedVector.Data[byteIndex] >> bitIndex) << bitOffset));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= (1U << packedVector.BitSize) - 1;
			}
			return buffer;
		}

		public static ushort[] UnpackUShorts(this IPackedIntVector packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			ushort[] buffer = new ushort[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= unchecked((ushort)((packedVector.Data[byteIndex] >> bitIndex) << bitOffset));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= unchecked((ushort)((1U << packedVector.BitSize) - 1));
			}
			return buffer;
		}

		private static byte GetBitCount(uint value)
		{
			double log = System.Math.Log2(value);
			return (byte)System.Math.Ceiling(log);
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/IPackedQuatVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using System.Linq;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public interface IPackedQuatVector : IAsset
	{
		uint NumItems { get; set; }
		byte[] Data { get; set; }
	}

	public static class PackedQuatVectorExtensions
	{
		public static void CopyValuesFrom(this IPackedQuatVector instance, IPackedQuatVector source)
		{
			instance.NumItems = source.NumItems;
			instance.Data = source.Data.ToArray();
		}

		public static void Pack(this IPackedQuatVector packedVector, IQuaternionf[] inputData)
		{
			packedVector.NumItems = (uint)inputData.Length;
			packedVector.Data = new byte[inputData.Length * 4];

			int bitIndex = 0;
			int byteIndex = 0;

			for (int i = 0; i < inputData.Length; i++)
			{
				IQuaternionf q = inputData[i];
				byte flags = unchecked((byte)(q.X < 0 ? 4 : 0));

				float max = System.Math.Abs(q.X);
				if (System.Math.Abs(q.Y) > max)
				{
					max = System.Math.Abs(q.Y);
					flags = 1;
					if (q.Y < 0)
					{
						flags |= 4;
					}
				}
				if (System.Math.Abs(q.Z) > max)
				{
					max = System.Math.Abs(q.Z);
					flags = 2;
					if (q.Z < 0)
					{
						flags |= 4;
					}
				}
				if (System.Math.Abs(q.W) > max)
				{
					max = System.Math.Abs(q.W);
					flags = 3;
					if (q.W < 0)
					{
						flags |= 4;
					}
				}
				int bitOffset = 0;
				while (bitOffset < 3)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((flags >> bitOffset) << bitIndex));
					int num = System.Math.Min(3 - bitOffset, 8 - bitIndex);
					bitIndex += num;
					bitOffset += num;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				for (int j = 0; j < 4; j++)
				{
					if ((flags & 3) != j)
					{
						int bitSize = (((flags & 3) + 1) % 4 == j) ? 9 : 10;
						double scaled = (q.GetAt(j) + 1d) * 0.5d;
						if (scaled < 0)
						{
							scaled = 0d;
						}
						else if (scaled > 1)
						{
							scaled = 1d;
						}

						float f = BitConverter.Int32BitsToSingle((1 << bitSize) - 1);
						uint x = BitConverter.SingleToUInt32Bits((float)(scaled * f));

						bitOffset = 0;
						while (bitOffset < bitSize)
						{
							packedVector.Data[byteIndex] |= unchecked((byte)((x >> bitOffset) << bitIndex));
							int read = System.Math.Min(bitSize - bitOffset, 8 - bitIndex);
							bitIndex += read;
							bitOffset += read;
							if (bitIndex == 8)
							{
								byteIndex++;
								bitIndex = 0;
							}
						}
					}
				}
			}
		}

		public static Quaternionf[] Unpack(this IPackedQuatVector packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			Quaternionf[] buffer = new Quaternionf[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				uint flags = 0;
				int bitOffset = 0;
				while (bitOffset < 3)
				{
					flags |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
					int read = System.Math.Min(3 - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				flags &= 7;

				double sum = 0;
				Quaternionf quaternion = new Quaternionf();
				for (int j = 0; j < 4; j++)
				{
					if ((flags & 3) != j)
					{
						int bitSize = (((flags & 3) + 1) % 4 == j) ? 9 : 10;

						uint value = 0;
						bitOffset = 0;
						while (bitOffset < bitSize)
						{
							value |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
							int num = System.Math.Min(bitSize - bitOffset, 8 - bitIndex);
							bitIndex += num;
							bitOffset += num;
							if (bitIndex == 8)
							{
								byteIndex++;
								bitIndex = 0;
							}
						}
						value &= unchecked((uint)((1 << bitSize) - 1));

						// final value's range is [-1.0f : 1.0f]
						double halfMaxValue = 0.5d * ((1 << bitSize) - 1);
						double quaternion_j = (value / halfMaxValue) - 1.0d;
						quaternion.SetAt(j, (float)quaternion_j);
						sum += quaternion_j * quaternion_j;
					}
				}

				int lastComponent = unchecked((int)(flags & 3));
				quaternion.SetAt(lastComponent, (float)System.Math.Sqrt(1.0d - sum));
				if ((flags & 4) != 0)
				{
					quaternion.FlipSignAt(lastComponent);
				}

				buffer[i] = quaternion;
			}
			return buffer;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/PackedFloatVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public sealed class PackedFloatVector : IPackedFloatVector
	{
		public const string NumItemsName = "m_NumItems";
		public const string RangeName = "m_Range";
		public const string StartName = "m_Start";
		public const string DataName = "m_Data";
		public const string BitSizeName = "m_BitSize";

		public uint NumItems { get; set; }
		public float Range { get; set; }
		public float Start { get; set; }
		public byte[] Data { get; set; } = Array.Empty<byte>();
		public byte BitSize { get; set; }

		public void Read(AssetReader reader)
		{
			NumItems = reader.ReadUInt32();
			Range = reader.ReadSingle();
			Start = reader.ReadSingle();
			Data = reader.ReadByteArray();
			reader.AlignStream();
			BitSize = reader.ReadByte();
			reader.AlignStream();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(NumItems);
			writer.Write(Range);
			writer.Write(Start);
			writer.Write(Data);
			writer.AlignStream();
			writer.Write(BitSize);
			writer.AlignStream();
		}

		public YamlNode ExportYaml(IExportContainer _)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(NumItemsName, NumItems);
			node.Add(RangeName, Range);
			node.Add(StartName, Start);
			node.Add(DataName, Data.ExportYaml());
			node.Add(BitSizeName, BitSize);
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/PackedIntVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public sealed class PackedIntVector : IPackedIntVector
	{
		public const string NumItemsName = "m_NumItems";
		public const string DataName = "m_Data";
		public const string BitSizeName = "m_BitSize";

		public uint NumItems { get; set; }
		public byte[] Data { get; set; } = Array.Empty<byte>();
		public byte BitSize { get; set; }

		public void Read(AssetReader reader)
		{
			NumItems = reader.ReadUInt32();
			Data = reader.ReadByteArray();
			reader.AlignStream();
			BitSize = reader.ReadByte();
			reader.AlignStream();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(NumItems);
			writer.Write(Data);
			writer.AlignStream();
			writer.Write(BitSize);
			writer.AlignStream();
		}

		public YamlNode ExportYaml(IExportContainer _)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(NumItemsName, NumItems);
			node.Add(DataName, Data == null ? YamlSequenceNode.Empty : Data.ExportYaml());
			node.Add(BitSizeName, BitSize);
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/PackedBitVectors/PackedQuatVector.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Core.Math.PackedBitVectors
{
	public sealed class PackedQuatVector : IPackedQuatVector
	{
		public const string NumItemsName = "m_NumItems";
		public const string DataName = "m_Data";

		public uint NumItems { get; set; }
		public byte[] Data { get; set; } = Array.Empty<byte>();

		public void Read(AssetReader reader)
		{
			NumItems = reader.ReadUInt32();
			Data = reader.ReadByteArray();
			reader.AlignStream();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(NumItems);
			writer.Write(Data);
			writer.AlignStream();
		}

		public YamlNode ExportYaml(IExportContainer _)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(NumItemsName, NumItems);
			node.Add(DataName, Data == null ? YamlSequenceNode.Empty : Data.ExportYaml());
			return node;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/Rectf.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Core.Math
{
	public sealed class Rectf : IAsset, IRectf
	{
		public float X { get; set; }
		public float Y { get; set; }
		public float Width { get; set; }
		public float Height { get; set; }

		public const string XName = "x";
		public const string YName = "y";
		public const string WidthName = "width";
		public const string HeightName = "height";

		public Rectf() { }

		public Rectf(float x, float y, float width, float height)
		{
			X = x;
			Y = y;
			Width = width;
			Height = height;
		}

		public Rectf(Vector2f positon, Vector2f size) : this(positon.X, positon.Y, size.X, size.Y) { }

		public static int ToSerializedVersion(UnityVersion version)
		{
			return 2; //2.0.0 and higher
		}

		public static bool operator ==(Rectf left, Rectf right)
		{
			if (left.X != right.X)
			{
				return false;
			}
			if (left.Y != right.Y)
			{
				return false;
			}
			if (left.Height != right.Height)
			{
				return false;
			}
			if (left.Width != right.Width)
			{
				return false;
			}
			return true;
		}

		public static bool operator !=(Rectf left, Rectf right)
		{
			if (left.X != right.X)
			{
				return true;
			}
			if (left.Y != right.Y)
			{
				return true;
			}
			if (left.Height != right.Height)
			{
				return true;
			}
			if (left.Width != right.Width)
			{
				return true;
			}
			return false;
		}

		public static Rectf operator +(Rectf left, Rectf right)
		{
			Rectf result = new();
			result.X = left.X + right.X;
			result.Y = left.Y + right.Y;
			result.Width = left.Width + right.Width;
			result.Height = left.Height + right.Height;
			return result;
		}

		public static Rectf operator -(Rectf left, Rectf right)
		{
			Rectf result = new();
			result.X = left.X - right.X;
			result.Y = left.Y - right.Y;
			result.Width = left.Width - right.Width;
			result.Height = left.Height - right.Height;
			return result;
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadSingle();
			Y = reader.ReadSingle();
			Width = reader.ReadSingle();
			Height = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
			writer.Write(Width);
			writer.Write(Height);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			node.Add(XName, X);
			node.Add(YName, Y);
			node.Add(WidthName, Width);
			node.Add(HeightName, Height);
			return node;
		}

		public override bool Equals(object? obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj.GetType() != typeof(Rectf))
			{
				return false;
			}
			return this == (Rectf)obj;
		}

		public override int GetHashCode()
		{
			int hash = 97;
			unchecked
			{
				hash = hash + (347 * X.GetHashCode());
				hash = (hash * 53) + Y.GetHashCode();
				hash = (hash * 641) + Width.GetHashCode();
				hash = (hash * 557) + Height.GetHashCode();
			}
			return hash;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "[X:{0:0.00}, Y:{1:0.00}, W:{2:0.00}, H:{3:0.00}", X, Y, Width, Height);
		}

		public bool ContainsCorner(Vector2f position)
		{
			if (X != position.X && X + Width != position.X)
			{
				return false;
			}
			if (Y != position.Y && Y + Height != position.Y)
			{
				return false;
			}
			return true;
		}

		public Vector2f Center => new Vector2f(X + (Width / 2.0f), Y + (Height / 2.0f));

		public Vector2f Position => new Vector2f(X, Y);
		public Vector2f Size => new Vector2f(Width, Height);
		public Vector2f Min
		{
			get => new Vector2f(XMin, YMin);
			set
			{
				XMin = value.X;
				YMin = value.Y;
			}
		}
		public Vector2f Max
		{
			get => new Vector2f(XMax, YMax);
			set
			{
				XMax = value.X;
				YMax = value.Y;
			}
		}

		public float XMin
		{
			get => X;
			set
			{
				float delta = X - value;
				X = value;
				Width += delta;
			}
		}
		public float YMin
		{
			get => Y;
			set
			{
				float delta = Y - value;
				Y = value;
				Height += delta;
			}
		}
		public float XMax
		{
			get => X + Width;
			set => Width = value - XMin;
		}
		public float YMax
		{
			get => Y + Height;
			set => Height = value - YMin;
		}
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/GeometricMath.cs`:

```cs
namespace AssetRipper.Core.Math.Vectors
{
	public static class GeometricMath
	{
		private const float kEpsilon = 0.00001F;

		/// <summary>
		/// Angle increase when 2nd line is moving in clockwise direction
		/// </summary>
		/// <returns>Angle in degrees</returns>
		public static float AngleFrom3Points(IVector2f point1, IVector2f point2, IVector2f point3)
		{
			float transformedP1X = point1.X - point2.X;
			float transformedP1Y = point1.Y - point2.Y;
			float transformedP2X = point3.X - point2.X;
			float transformedP2Y = point3.Y - point2.Y;

			double angleToP1 = System.Math.Atan2(transformedP1Y, transformedP1X);
			double angleToP2 = System.Math.Atan2(transformedP2Y, transformedP2X);

			double angle = angleToP1 - angleToP2;
			if (angle < 0)
			{
				angle += 2 * System.Math.PI;
			}

			return (float)(360.0 * angle / (2.0 * System.Math.PI));
		}
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IQuaternionf.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IQuaternionf : IAsset
	{
		float X { get; set; }
		float Y { get; set; }
		float Z { get; set; }
		float W { get; set; }
	}

	public static class QuaternionfExtensions
	{
		public static void CopyValuesFrom(this IQuaternionf instance, IQuaternionf source)
		{
			instance.X = source.X;
			instance.Y = source.Y;
			instance.Z = source.Z;
			instance.W = source.W;
		}

		public static float GetAt(this IQuaternionf quaternion, int index)
		{
			return index switch
			{
				0 => quaternion.X,
				1 => quaternion.Y,
				2 => quaternion.Z,
				3 => quaternion.W,
				_ => throw new IndexOutOfRangeException($"Index {index} is out of bound"),
			};
		}

		public static void SetAt(this IQuaternionf quaternion, int index, float value)
		{
			switch (index)
			{
				case 0:
					quaternion.X = value;
					return;
				case 1:
					quaternion.Y = value;
					return;
				case 2:
					quaternion.Z = value;
					return;
				case 3:
					quaternion.W = value;
					return;
				default:
					throw new IndexOutOfRangeException($"Index {index} is out of bound");
			}
		}

		public static void FlipSignAt(this IQuaternionf quaternion, int index)
		{
			switch (index)
			{
				case 0:
					quaternion.X = -quaternion.X;
					return;
				case 1:
					quaternion.Y = -quaternion.Y;
					return;
				case 2:
					quaternion.Z = -quaternion.Z;
					return;
				case 3:
					quaternion.W = -quaternion.W;
					return;
				default:
					throw new IndexOutOfRangeException($"Index {index} is out of bound");
			}
		}

		public static Vector3f ToEulerAngle(this IQuaternionf quaternion, bool asDegrees = true)
		{
			Vector3f euler = new Vector3f();
			quaternion.ToEulerAngle(euler, asDegrees);
			return euler;
		}

		/// <summary>
		/// Converts 
		/// </summary>
		/// <param name="quaternion">The source quaternion</param>
		/// <param name="destination">The destination vector for the Euler values to</param>
		/// <param name="asDegrees">Convert the result to degrees? If false, radians are used.</param>
		public static void ToEulerAngle(this IQuaternionf quaternion, IVector3f destination, bool asDegrees)
		{
			double eax;
			double eay;
			double eaz;

			float qx = quaternion.X;
			float qy = -quaternion.Y;
			float qz = -quaternion.Z;
			float qw = quaternion.W;

			double[,] M = new double[4, 4];

			double Nq = (qx * qx) + (qy * qy) + (qz * qz) + (qw * qw);
			double s = Nq > 0.0 ? 2.0 / Nq : 0.0;
			double xs = qx * s, ys = qy * s, zs = qz * s;
			double wx = qw * xs, wy = qw * ys, wz = qw * zs;
			double xx = qx * xs, xy = qx * ys, xz = qx * zs;
			double yy = qy * ys, yz = qy * zs, zz = qz * zs;

			M[0, 0] = 1.0 - (yy + zz); M[0, 1] = xy - wz; M[0, 2] = xz + wy;
			M[1, 0] = xy + wz; M[1, 1] = 1.0 - (xx + zz); M[1, 2] = yz - wx;
			M[2, 0] = xz - wy; M[2, 1] = yz + wx; M[2, 2] = 1.0 - (xx + yy);
			M[3, 0] = M[3, 1] = M[3, 2] = M[0, 3] = M[1, 3] = M[2, 3] = 0.0; M[3, 3] = 1.0;

			double test = System.Math.Sqrt((M[0, 0] * M[0, 0]) + (M[1, 0] * M[1, 0]));
			if (test > 16 * 1.19209290E-07F)//FLT_EPSILON
			{
				eax = System.Math.Atan2(M[2, 1], M[2, 2]);
				eay = System.Math.Atan2(-M[2, 0], test);
				eaz = System.Math.Atan2(M[1, 0], M[0, 0]);
			}
			else
			{
				eax = System.Math.Atan2(-M[1, 2], M[1, 1]);
				eay = System.Math.Atan2(-M[2, 0], test);
				eaz = 0;
			}

			destination.X = GetAngle(eax, asDegrees);
			destination.Y = GetAngle(eay, asDegrees);
			destination.Z = GetAngle(eaz, asDegrees);
		}

		private static float GetAngle(double radians, bool convertToDegrees)
		{
			return (float)(convertToDegrees ? (radians * 180.0 / System.Math.PI) : radians);
		}

		public static double Dot(this IQuaternionf a, IQuaternionf b)
		{
			return ((double)a.X * b.X) + ((double)a.Y * b.Y) + ((double)a.Z * b.Z) + ((double)a.W * b.W);
		}

		public static bool IsUnitQuaternion(this IQuaternionf a)
		{
			return ((a.X * a.X) + (a.Y * a.Y) + (a.Z * a.Z) + (a.W * a.W)) > 1d - kEpsilon;
		}

		public static bool IsEqualUsingDot(this IQuaternionf a, IQuaternionf b)
		{
			return a.Dot(b) > 1.0f - kEpsilon;
		}

		private const float kEpsilon = 0.00001F;
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IVector2f.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IVector2f : IAsset
	{
		float X { get; set; }
		float Y { get; set; }
	}

	public static class Vector2fExtensions
	{
		public static void CopyValues(this IVector2f destination, IVector2f source)
		{
			destination.X = source.X;
			destination.Y = source.Y;
		}

		public static void Normalize(this IVector2f vector)
		{
			double length = vector.Length();
			if (length > kEpsilon)
			{
				vector.X = (float)(vector.X / length);
				vector.Y = (float)(vector.Y / length);
			}
			else
			{
				vector.X = 0;
				vector.Y = 0;
			}
		}

		public static double Length(this IVector2f vector)
		{
			return System.Math.Sqrt(vector.LengthSquared());
		}

		public static double LengthSquared(this IVector2f vector)
		{
			return ((double)vector.X * vector.X) + ((double)vector.Y * vector.Y);
		}

		private const float kEpsilon = 0.00001F;
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IVector2i.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IVector2i : IAsset
	{
		int X { get; set; }
		int Y { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IVector3f.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IVector3f : IAsset
	{
		float X { get; set; }
		float Y { get; set; }
		float Z { get; set; }
	}

	public static class Vector3fExtensions
	{
		public static void CopyValuesFrom(this IVector3f instance, IVector3f source)
		{
			instance.X = source.X;
			instance.Y = source.Y;
			instance.Z = source.Z;
		}

		public static void Reset(this IVector3f instance)
		{
			instance.X = 0;
			instance.Y = 0;
			instance.Z = 0;
		}

		public static Quaternionf ToQuaternion(this IVector3f source, bool isDegrees = true)
		{
			Quaternionf result = new Quaternionf();
			source.ToQuaternion(result, isDegrees);
			return result;
		}

		public static void ToQuaternion(this IVector3f source, IQuaternionf destination, bool isDegrees)
		{
			// Abbreviations for the various angular functions
			double cy = System.Math.Cos(GetRadians(source.Z, isDegrees) * 0.5);
			double sy = System.Math.Sin(GetRadians(source.Z, isDegrees) * 0.5);
			double cp = System.Math.Cos(GetRadians(source.Y, isDegrees) * 0.5);
			double sp = System.Math.Sin(GetRadians(source.Y, isDegrees) * 0.5);
			double cr = System.Math.Cos(GetRadians(source.X, isDegrees) * 0.5);
			double sr = System.Math.Sin(GetRadians(source.X, isDegrees) * 0.5);

			destination.W = -(float)((cr * cp * cy) + (sr * sp * sy));
			destination.X = -(float)((sr * cp * cy) - (cr * sp * sy));
			destination.Y = (float)((cr * sp * cy) + (sr * cp * sy));
			destination.Z = (float)((cr * cp * sy) - (sr * sp * cy));
		}

		private static double GetRadians(double angle, bool isDegrees)
		{
			return isDegrees ? (angle * System.Math.PI / 180.0) : angle;
		}

		public static void Normalize(this IVector3f instance)
		{
			float length = instance.Length();
			if (length > kEpsilon)
			{
				instance.X /= length;
				instance.Y /= length;
				instance.Z /= length;
			}
			else
			{
				instance.X = 0;
				instance.Y = 0;
				instance.Z = 0;
			}
		}

		public static float Length(this IVector3f instance)
		{
			return (float)System.Math.Sqrt(instance.LengthSquared());
		}

		public static float LengthSquared(this IVector3f instance)
		{
			return (instance.X * instance.X) + (instance.Y * instance.Y) + (instance.Z * instance.Z);
		}

		public static float Dot(this IVector3f instance, IVector3f other)
		{
			return (instance.X * other.X) + (instance.Y * other.Y) + (instance.Z * other.Z);
		}

		public static bool IsEqualByDot(this IVector3f instance, IVector3f other)
		{
			float instanceLength = instance.Length();
			float otherLength = other.Length();

			if (instanceLength < kEpsilon)
			{
				return otherLength < kEpsilon;
			}

			if (otherLength < kEpsilon)
			{
				return false;
			}

			float dot = instance.Dot(other);
			float deviation = 1f - (dot / instanceLength / otherLength);
			return deviation < kEpsilon;
		}

		private const float kEpsilon = 0.00001F;
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IVector3i.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IVector3i : IAsset
	{
		int X { get; set; }
		int Y { get; set; }
		int Z { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/IVector4f.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Math.Vectors
{
	public interface IVector4f : IAsset
	{
		float X { get; set; }
		float Y { get; set; }
		float Z { get; set; }
		float W { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Quaternionf.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Quaternionf : IAsset, IEquatable<Quaternionf>, IQuaternionf
	{
		public float X { get; set; }
		public float Y { get; set; }
		public float Z { get; set; }
		public float W { get; set; }
		public const string XName = "x";
		public const string YName = "y";
		public const string ZName = "z";
		public const string WName = "w";

		public Quaternionf() { }

		public Quaternionf(float x, float y, float z, float w)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadSingle();
			Y = reader.ReadSingle();
			Z = reader.ReadSingle();
			W = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
			writer.Write(Z);
			writer.Write(W);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(XName, X);
			node.Add(YName, Y);
			node.Add(ZName, Z);
			node.Add(WName, W);
			return node;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "[{0:0.00}, {1:0.00}, {2:0.00}, {3:0.00}]", X, Y, Z, W);
		}

		public static Quaternionf Zero => new Quaternionf(0.0f, 0.0f, 0.0f, 1.0f);

		public static implicit operator Quaternionf(Vector4f v) => new Vector4f(v.X, v.Y, v.Z, v.W);

		public static implicit operator System.Numerics.Quaternion(Quaternionf q) => new System.Numerics.Quaternion(q.X, q.Y, q.Z, q.W);
		public static implicit operator Quaternionf(System.Numerics.Quaternion q) => new Quaternionf(q.X, q.Y, q.Z, q.W);

		public override int GetHashCode()
		{
			return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2) ^ (W.GetHashCode() >> 1);
		}

		public override bool Equals(object? other)
		{
			if (other is Quaternionf quat)
			{
				return Equals(quat);
			}
			else
			{
				return false;
			}
		}

		public bool Equals(Quaternionf? other)
		{
			return other is not null && X == other.X && Y == other.Y && Z == other.Z && W == other.W;
		}

		public static bool operator ==(Quaternionf lhs, Quaternionf rhs)
		{
			return lhs.Equals(rhs);
		}

		public static bool operator !=(Quaternionf lhs, Quaternionf rhs)
		{
			return !(lhs == rhs);
		}
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Vector2f.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Vector2f : IAsset, IEquatable<Vector2f>, IVector2f
	{
		public float X { get; set; }
		public float Y { get; set; }

		public Vector2f() { }

		public Vector2f(float value) : this(value, value) { }

		public Vector2f(float x, float y)
		{
			X = x;
			Y = y;
		}

		public static implicit operator Vector2f(Vector2i v2) => v2 is null ? new() : new Vector2f(v2.X, v2.Y);
		public static explicit operator Vector2f(Vector3f v3) => new Vector2f(v3.X, v3.Y);
		public static explicit operator Vector2f(Vector3i v3) => v3 is null ? new() : new Vector2f(v3.X, v3.Y);

		public static implicit operator System.Numerics.Vector2(Vector2f v2) => new System.Numerics.Vector2(v2.X, v2.Y);
		public static implicit operator Vector2f(System.Numerics.Vector2 v2) => new Vector2f(v2.X, v2.Y);

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => X,
					1 => Y,
					_ => throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector2f index!"),
				};
			}

			set
			{
				switch (index)
				{
					case 0: X = value; break;
					case 1: Y = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector2f index!");
				}
			}
		}

		public static Vector2f operator -(Vector2f left)
		{
			return new Vector2f(-left.X, -left.Y);
		}

		public static Vector2f operator -(Vector2f left, Vector2f right)
		{
			return new Vector2f(left.X - right.X, left.Y - right.Y);
		}

		public static Vector2f operator +(Vector2f left, Vector2f right)
		{
			return new Vector2f(left.X + right.X, left.Y + right.Y);
		}

		public static Vector2f operator *(Vector2f left, float right)
		{
			return new Vector2f(left.X * right, left.Y * right);
		}

		public static Vector2f operator /(Vector2f left, float right)
		{
			return new Vector2f(left.X / right, left.Y / right);
		}

		public static bool operator ==(Vector2f left, Vector2f right)
		{
			return left.X == right.X && left.Y == right.Y;
		}

		public static bool operator !=(Vector2f left, Vector2f right)
		{
			return left.X != right.X || left.Y != right.Y;
		}

		public static Vector2f Scale(Vector2f left, Vector2f right)
		{
			return new Vector2f(left.X * right.X, left.Y * right.Y);
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadSingle();
			Y = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(XName, X);
			node.Add(YName, Y);
			return node;
		}

		public override int GetHashCode()
		{
			return X.GetHashCode() ^ (Y.GetHashCode() << 2);
		}

		public override bool Equals(object? other)
		{
			if (other is Vector2f asset)
			{
				return Equals(asset);
			}
			else
			{
				return false;
			}
		}

		public bool Equals(Vector2f? other)
		{
			return other is not null && X == other.X && Y == other.Y;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "[{0:0.00}, {1:0.00}]", X, Y);
		}

		public static Vector2f One { get; } = new Vector2f(1.0f, 1.0f);

		public static Vector2f Zero { get; } = new Vector2f();

		public const string XName = "x";
		public const string YName = "y";
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Vector2i.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Vector2i : IAsset, IVector2i
	{
		public Vector2i() { }
		public Vector2i(int x, int y)
		{
			X = x;
			Y = y;
		}

		public static bool operator ==(Vector2i left, Vector2i right)
		{
			if (left is null)
			{
				return right is null;
			}
			else if (right is null)
			{
				return false;
			}
			else
			{
				return left.X == right.X && left.Y == right.Y;
			}
		}

		public static bool operator !=(Vector2i left, Vector2i right)
		{
			return !(left == right);
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadInt32();
			Y = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(XName, X);
			node.Add(YName, Y);
			return node;
		}

		public override bool Equals(object? obj)
		{
			if (obj == null)
			{
				return false;
			}

			if (obj.GetType() != typeof(Vector2i))
			{
				return false;
			}

			return this == (Vector2i)obj;
		}

		public override int GetHashCode()
		{
			int hash = 941;
			unchecked
			{
				hash = hash + (61 * X.GetHashCode());
				hash = (hash * 677) + Y.GetHashCode();
			}
			return hash;
		}

		public override string ToString()
		{
			return $"[{X}, {Y}]";
		}

		public int X { get; set; }
		public int Y { get; set; }

		public const string XName = "x";
		public const string YName = "y";
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Vector3f.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Globalization;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Vector3f : IAsset, IEquatable<Vector3f>, IVector3f
	{
		public float X { get; set; }
		public float Y { get; set; }
		public float Z { get; set; }

		public Vector3f() { }

		public Vector3f(float x, float y, float z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		public Vector3f DeepClone() => new Vector3f(X, Y, Z);

		public static implicit operator Vector3f(Vector2f v2) => new Vector3f(v2.X, v2.Y, 0f);
		public static implicit operator Vector3f(Vector2i v2) => v2 is null ? new() : new Vector3f(v2.X, v2.Y, 0f);
		public static implicit operator Vector3f(Vector3i v3) => v3 is null ? new() : new Vector3f(v3.X, v3.Y, v3.Z);
		public static explicit operator Vector3f(Vector4f v4) => new Vector3f(v4.X, v4.Y, v4.Z);

		public static implicit operator System.Numerics.Vector3(Vector3f v3) => new System.Numerics.Vector3(v3.X, v3.Y, v3.Z);
		public static implicit operator Vector3f(System.Numerics.Vector3 v3) => new Vector3f(v3.X, v3.Y, v3.Z);

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => X,
					1 => Y,
					2 => Z,
					_ => throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector3 index!"),
				};
			}

			set
			{
				switch (index)
				{
					case 0: X = value; break;
					case 1: Y = value; break;
					case 2: Z = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector3 index!");
				}
			}
		}

		public override int GetHashCode()
		{
			return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2);
		}

		public override bool Equals(object? other)
		{
			if (other is Vector3f v)
			{
				return Equals(v);
			}
			return false;
		}

		public bool Equals(Vector3f? other)
		{
			return other is not null && X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z);
		}

		public static Vector3f operator -(Vector3f left)
		{
			return new Vector3f(-left.X, -left.Y, -left.Z);
		}

		public static Vector3f operator -(Vector3f left, Vector3f right)
		{
			return new Vector3f(left.X - right.X, left.Y - right.Y, left.Z - right.Z);
		}

		public static Vector3f operator +(Vector3f left, Vector3f right)
		{
			return new Vector3f(left.X + right.X, left.Y + right.Y, left.Z + right.Z);
		}

		public static Vector3f operator *(Vector3f left, float right)
		{
			return new Vector3f(left.X * right, left.Y * right, left.Z * right);
		}

		public static Vector3f operator *(float d, Vector3f a)
		{
			return new Vector3f(a.X * d, a.Y * d, a.Z * d);
		}

		public static Vector3f operator /(Vector3f left, float right)
		{
			return new Vector3f(left.X / right, left.Y / right, left.Z / right);
		}

		public static bool operator ==(Vector3f left, Vector3f right)
		{
			return left.X == right.X && left.Y == right.Y && left.Z == right.Z;
		}

		public static bool operator !=(Vector3f left, Vector3f right)
		{
			return left.X != right.X || left.Y != right.Y || left.Z != right.Z;
		}

		public static Vector3f Scale(Vector3f left, Vector3f right)
		{
			return new Vector3f(left.X * right.X, left.Y * right.Y, left.Z * right.Z);
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadSingle();
			Y = reader.ReadSingle();
			Z = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
			writer.Write(Z);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(XName, X);
			node.Add(YName, Y);
			node.Add(ZName, Z);
			return node;
		}

		public override string ToString()
		{
			return string.Format(CultureInfo.InvariantCulture, "[{0:0.00}, {1:0.00}, {2:0.00}]", X, Y, Z);
		}

		public static Vector3f One => new Vector3f(1.0f, 1.0f, 1.0f);

		public static Vector3f Zero => new Vector3f();

		public const string XName = "x";
		public const string YName = "y";
		public const string ZName = "z";
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Vector3i.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Vector3i : IAsset, IVector3i
	{
		public Vector3i() { }
		public Vector3i(int x, int y, int z)
		{
			X = x;
			Y = y;
			Z = z;
		}

		public static bool operator ==(Vector3i left, Vector3i right)
		{
			if (left is null)
			{
				return right is null;
			}
			else if (right is null)
			{
				return false;
			}
			else
			{
				return left.X == right.X && left.Y == right.Y && left.Z == right.Z;
			}
		}

		public static bool operator !=(Vector3i left, Vector3i right)
		{
			return !(left == right);
		}

		public int GetValueByMember(int member)
		{
			member %= 3;
			if (member == 0)
			{
				return X;
			}

			if (member == 1)
			{
				return Y;
			}

			return Z;
		}

		public int GetMemberByValue(int value)
		{
			if (X == value)
			{
				return 0;
			}

			if (Y == value)
			{
				return 1;
			}

			if (Z == value)
			{
				return 2;
			}

			throw new ArgumentException($"Member with value {value} wasn't found");
		}

		public bool ContainsValue(int value)
		{
			if (X == value || Y == value || Z == value)
			{
				return true;
			}

			return false;
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadInt32();
			Y = reader.ReadInt32();
			Z = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
			writer.Write(Z);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Style = MappingStyle.Flow;
			node.Add(XName, X);
			node.Add(YName, Y);
			node.Add(ZName, Z);
			return node;
		}

		public override bool Equals(object? obj)
		{
			if (obj == null)
			{
				return false;
			}

			if (obj.GetType() != typeof(Vector3i))
			{
				return false;
			}

			return this == (Vector3i)obj;
		}

		public override int GetHashCode()
		{
			int hash = 193;
			unchecked
			{
				hash = hash + (787 * X.GetHashCode());
				hash = (hash * 823) + Y.GetHashCode();
				hash = (hash * 431) + Z.GetHashCode();
			}
			return hash;
		}

		public override string ToString()
		{
			return $"[{X}, {Y}, {Z}]";
		}

		public int X { get; set; }
		public int Y { get; set; }
		public int Z { get; set; }

		public const string XName = "x";
		public const string YName = "y";
		public const string ZName = "z";
	}
}

```

`AssetRipper.Fundamentals/Math/Vectors/Vector4f.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Math.Vectors
{
	public sealed class Vector4f : IAsset, IEquatable<Vector4f>, IVector4f
	{
		public float X { get; set; }
		public float Y { get; set; }
		public float Z { get; set; }
		public float W { get; set; }
		public const string XName = "x";
		public const string YName = "y";
		public const string ZName = "z";
		public const string WName = "w";

		public Vector4f() { }

		public Vector4f(float value) : this(value, value, value, value) { }

		public Vector4f(float x, float y, float z, float w)
		{
			X = x;
			Y = y;
			Z = z;
			W = w;
		}

		public Vector4f(Vector3f value, float w)
		{
			X = value.X;
			Y = value.Y;
			Z = value.Z;
			W = w;
		}

		public float this[int index]
		{
			get
			{
				return index switch
				{
					0 => X,
					1 => Y,
					2 => Z,
					3 => W,
					_ => throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector4 index!"),
				};
			}

			set
			{
				switch (index)
				{
					case 0: X = value; break;
					case 1: Y = value; break;
					case 2: Z = value; break;
					case 3: W = value; break;
					default: throw new ArgumentOutOfRangeException(nameof(index), "Invalid Vector4 index!");
				}
			}
		}

		public static implicit operator Vector4f(Vector2f v2) => new(v2.X, v2.Y, 0.0f, 0.0f);
		public static implicit operator Vector4f(Vector2i v2) => v2 is null ? new() : new(v2.X, v2.Y, 0.0f, 0.0f);
		public static implicit operator Vector4f(Vector3f v3) => new(v3.X, v3.Y, v3.Z, 0.0f);
		public static implicit operator Vector4f(Vector3i v3) => v3 is null ? new() : new(v3.X, v3.Y, v3.Z, 0.0f);

		public static explicit operator Vector4f(Quaternionf q) => new(q.X, q.Y, q.Z, q.W);
		public static explicit operator ColorRGBAf(Vector4f v) => new(v.X, v.Y, v.Z, v.W);

		public static implicit operator System.Numerics.Vector4(Vector4f v4) => new(v4.X, v4.Y, v4.Z, v4.W);
		public static implicit operator Vector4f(System.Numerics.Vector4 v4) => new(v4.X, v4.Y, v4.Z, v4.W);

		public static Vector4f operator -(Vector4f left)
		{
			return new Vector4f(-left.X, -left.Y, -left.Z, -left.W);
		}

		public static Vector4f operator -(Vector4f left, Vector4f right)
		{
			return new Vector4f(left.X - right.X, left.Y - right.Y, left.Z - right.Z, left.W - right.W);
		}

		public static Vector4f operator +(Vector4f left, Vector4f right)
		{
			return new Vector4f(left.X + right.X, left.Y + right.Y, left.Z + right.Z, left.W + right.W);
		}

		public static Vector4f operator *(Vector4f left, float right)
		{
			return new Vector4f(left.X * right, left.Y * right, left.Z * right, left.W * right);
		}

		public static Vector4f operator *(float left, Vector4f right)
		{
			return new Vector4f(right.X * left, right.Y * left, right.Z * left, right.W * left);
		}

		public static Vector4f operator /(Vector4f left, float right)
		{
			return new Vector4f(left.X / right, left.Y / right, left.Z / right, left.W / right);
		}

		public static bool operator ==(Vector4f left, Vector4f right)
		{
			return left.X == right.X && left.Y == right.Y && left.Z == right.Z && left.W == right.W;
		}

		public static bool operator !=(Vector4f left, Vector4f right)
		{
			return left.X != right.X || left.Y != right.Y || left.Z != right.Z || left.W != right.W;
		}

		public void Read(AssetReader reader)
		{
			X = reader.ReadSingle();
			Y = reader.ReadSingle();
			Z = reader.ReadSingle();
			W = reader.ReadSingle();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(X);
			writer.Write(Y);
			writer.Write(Z);
			writer.Write(W);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new(MappingStyle.Flow);
			node.Add(XName, X);
			node.Add(YName, Y);
			node.Add(ZName, Z);
			node.Add(WName, W);
			return node;
		}

		public override bool Equals(object? other)
		{
			if (other is Vector4f vector)
			{
				return Equals(vector);
			}
			return false;
		}

		public bool Equals(Vector4f? other)
		{
			return other is not null && X.Equals(other.X) && Y.Equals(other.Y) && Z.Equals(other.Z) && W.Equals(other.W);
		}

		public override int GetHashCode()
		{
			return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2) ^ (W.GetHashCode() >> 1);
		}

		public override string ToString()
		{
			return $"[{X:0.00}, {Y:0.00}, {Z:0.00}, {W:0.00}]";
		}

		public void Normalize()
		{
			float length = Length();
			if (length > kEpsilon)
			{
				float invNorm = 1.0f / length;
				X *= invNorm;
				Y *= invNorm;
				Z *= invNorm;
				W *= invNorm;
			}
			else
			{
				X = 0;
				Y = 0;
				Z = 0;
				W = 0;
			}
		}

		public float Length()
		{
			return (float)System.Math.Sqrt(LengthSquared());
		}

		public float LengthSquared()
		{
			return (X * X) + (Y * Y) + (Z * Z) + (W * W);
		}

		public static Vector4f Zero => new();

		private const float kEpsilon = 0.00001F;
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/AssetFactoryBase.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Misc.Serializable;
using AssetRipper.Core.Classes.Misc.Serializable.AnimationCurveTpl;
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.Classes.Misc.Serializable.Gradient;
using AssetRipper.Core.Classes.Misc.Serializable.GUIStyle;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Structure.Assembly.Mono;

namespace AssetRipper.Core.Parser.Asset
{
	public abstract class AssetFactoryBase
	{
		public abstract IUnityObjectBase? CreateAsset(AssetInfo assetInfo, UnityVersion version);

		public virtual IAsset CreateEngineAsset(string name)
		{
			return name switch
			{
				MonoUtils.Vector2Name => new Vector2f(),
				MonoUtils.Vector2IntName => new Vector2i(),
				MonoUtils.Vector3Name => new Vector3f(),
				MonoUtils.Vector3IntName => new Vector3i(),
				MonoUtils.Vector4Name => new Vector4f(),
				MonoUtils.RectName => new Rectf(),
				MonoUtils.BoundsName => new AABB(),
				MonoUtils.BoundsIntName => new AABBi(),
				MonoUtils.QuaternionName => new Quaternionf(),
				MonoUtils.Matrix4x4Name => new Matrix4x4f(),
				MonoUtils.ColorName => new ColorRGBAf(),
				MonoUtils.Color32Name => new ColorRGBA32(),
				MonoUtils.LayerMaskName => new LayerMask(),
				MonoUtils.AnimationCurveName => new AnimationCurveTpl<Float>(),
				MonoUtils.GradientName => new Gradient(),
				MonoUtils.RectOffsetName => new RectOffset(),
				MonoUtils.GUIStyleName => new GUIStyle(),
				MonoUtils.PropertyNameName => new PropertyName(),
				_ => throw new NotImplementedException(name),
			};
		}

		public abstract ClassIDType GetClassIdForType(Type type);
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/AssetInfo.DummySerializedFile.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Structure;
using AssetRipper.IO.Endian;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Parser.Asset
{
	public sealed partial class AssetInfo
	{
		private sealed class DummySerializedFile : ISerializedFile
		{
			public IFileCollection Collection => throw new NotSupportedException();

			public EndianType EndianType => EndianType.LittleEndian;

			public string Name => throw new NotSupportedException();

			public LayoutInfo Layout => throw new NotSupportedException();

			public UnityVersion Version => throw new NotSupportedException();

			public BuildTarget Platform => BuildTarget.NoTarget;

			public TransferInstructionFlags Flags => TransferInstructionFlags.NoTransferInstructionFlags;

			public IReadOnlyList<FileIdentifier> Dependencies => throw new NotSupportedException();

			public PPtr<T> CreatePPtr<T>(T asset) where T : IUnityObjectBase
			{
				throw new NotSupportedException();
			}

			public IEnumerable<IUnityObjectBase> FetchAssets()
			{
				return Enumerable.Empty<IUnityObjectBase>();
			}

			public IUnityObjectBase? FindAsset(long pathID)
			{
				return null;
			}

			public IUnityObjectBase? FindAsset(int fileIndex, long pathID)
			{
				return null;
			}

			public IUnityObjectBase? FindAsset(ClassIDType classID)
			{
				return null;
			}

			public IUnityObjectBase? FindAsset(ClassIDType classID, string name)
			{
				return null;
			}

			public IUnityObjectBase GetAsset(long pathID)
			{
				throw new NotSupportedException();
			}

			public IUnityObjectBase GetAsset(int fileIndex, long pathID)
			{
				throw new NotSupportedException();
			}

			public ObjectInfo GetAssetEntry(long pathID)
			{
				throw new NotSupportedException();
			}

			public ClassIDType GetAssetType(long pathID)
			{
				throw new NotSupportedException();
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/AssetInfo.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Files.SerializedFiles;

namespace AssetRipper.Core.Parser.Asset
{
	public sealed partial class AssetInfo
	{
		public AssetInfo(ISerializedFile serializedFile, long pathID, ClassIDType classID) 
			: this(serializedFile, pathID, classID, UnityGUID.NewGuid()) { }
		public AssetInfo(ISerializedFile serializedFile, long pathID, ClassIDType classID, UnityGUID guid)
		{
			File = serializedFile ?? throw new ArgumentNullException(nameof(serializedFile));
			PathID = pathID;
			ClassID = classID;
			GUID = guid;
		}

		public ISerializedFile File { get; }
		public long PathID { get; }
		public ClassIDType ClassID { get; }
		public int ClassNumber => (int)ClassID;
		public UnityGUID GUID { get; set; }

		public static AssetInfo MakeDummyAssetInfo()
		{
			return new AssetInfo(dummySerializedFile, -1, default, default);
		}

		private static readonly DummySerializedFile dummySerializedFile = new();
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/AssetType.cs`:

```cs
namespace AssetRipper.Core.Parser.Asset
{
	public enum AssetType
	{
		/// <summary>
		/// Used by released game
		/// </summary>
		Internal = 0,
		/// <summary>
		/// Library asset file. It is editor created file, it doesn't exist in Assets directory
		/// It has the format "library/cache/[first Hash byte as hex]/[Hash as hex]"
		/// </summary>
		Cached = 1,
		/// <summary>
		/// Serialized asset file. It contains all parameters inside itself
		/// </summary>
		Serialized = 2,
		/// <summary>
		/// Binary asset file. It contains all parameters inside meta file
		/// </summary>
		Meta = 3,
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/DependencyContext.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Asset
{
	public sealed class DependencyContext
	{
		public DependencyContext(LayoutInfo layout, bool log)
		{
			Info = layout;
			m_hierarchy = log ? new Stack<string>() : null;
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependenciesFromDependent<T>(T dependent, string name) where T : IDependent
		{
			if (m_hierarchy is not null)
			{
				m_hierarchy.Push(name);
			}
			foreach (PPtr<IUnityObjectBase> pointer in dependent.FetchDependencies(this))
			{
				if (!pointer.IsNull)
				{
					yield return pointer;
				}
			}
			if (m_hierarchy is not null)
			{
				m_hierarchy.Pop();
			}
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependenciesFromArray<T>(IEnumerable<T> dependents, string name) where T : IDependent
		{
			if (m_hierarchy is not null)
			{
				m_hierarchy.Push(name);
			}
			foreach (T dependent in dependents)
			{
				foreach (PPtr<IUnityObjectBase> pointer in dependent.FetchDependencies(this))
				{
					if (!pointer.IsNull)
					{
						yield return pointer;
					}
				}
			}
			if (m_hierarchy is not null)
			{
				m_hierarchy.Pop();
			}
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependenciesFromArrayArray<T>(IEnumerable<T> dependents, string name) where T : IEnumerable<IDependent>
		{
			//Logging not required here because FetchDependenciesFromArray handles it
			foreach (T subArray in dependents)
			{
				foreach (PPtr<IUnityObjectBase> pointer in this.FetchDependenciesFromArray(subArray, name))
				{
					yield return pointer; //this pointer is not null because FetchDependenciesFromArray already checks for that 
				}
			}
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies<T>(IEnumerable<PPtr<T>> pointers, string name) where T : IUnityObjectBase
		{
			foreach (PPtr<T> pointer in pointers)
			{
				if (!pointer.IsNull)
				{
					yield return FetchDependency(pointer, name);
				}
			}
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies<T1, T2>(IDictionary<T1, PPtr<T2>> pointers, string name) where T2 : IUnityObjectBase
		{
			foreach (KeyValuePair<T1, PPtr<T2>> pointerPair in pointers)
			{
				if (!pointerPair.Value.IsNull)
				{
					yield return FetchDependency(pointerPair.Value, name);
				}
			}
		}

		public PPtr<IUnityObjectBase> FetchDependency<T>(PPtr<T> pointer, string name) where T : IUnityObjectBase
		{
			if (m_hierarchy is not null)
			{
				PointerName = name;
			}
			return pointer.CastTo<IUnityObjectBase>();
		}

		public string GetPointerPath()
		{
			if (m_hierarchy is null || m_hierarchy.Count == 0)
			{
				return string.Empty;
			}

			string hierarchy = string.Empty;
			int i = 0;
			foreach (string sub in m_hierarchy)
			{
				if (i == 0)
				{
					hierarchy = sub;
				}
				else
				{
					hierarchy = sub + "." + hierarchy;
				}
				i++;
			}
			return hierarchy;
		}

		public LayoutInfo Info { get; }
		public UnityVersion Version => Info.Version;
		public BuildTarget Platform => Info.Platform;
		public TransferInstructionFlags Flags => Info.Flags;
		public string PointerName { get; private set; } = "";

		private readonly Stack<string>? m_hierarchy;
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/IAssetContainer.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Asset
{
	public interface IAssetContainer
	{
		/// <summary>
		/// Get asset from current asset container
		/// </summary>
		/// <param name="fileIndex">Path ID of the asset</param>
		/// <returns>Found asset</returns>
		IUnityObjectBase GetAsset(long pathID);
		/// <summary>
		/// Try to get asset in the dependency file with specified file index
		/// </summary>
		/// <param name="fileIndex">Dependent file index</param>
		/// <param name="pathID">Path ID of the asset</param>
		/// <returns>Found asset or null</returns>
		IUnityObjectBase? FindAsset(int fileIndex, long pathID);
		/// <summary>
		/// Get asset in the dependency with specified file index
		/// </summary>
		/// <param name="fileIndex">Dependent file index</param>
		/// <param name="pathID">Path ID of the asset</param>
		/// <returns>Found asset</returns>
		IUnityObjectBase GetAsset(int fileIndex, long pathID);
		IUnityObjectBase? FindAsset(ClassIDType classID);
		IUnityObjectBase? FindAsset(ClassIDType classID, string name);

		ClassIDType GetAssetType(long pathID);

		string Name { get; }
		LayoutInfo Layout { get; }
		UnityVersion Version { get; }
		BuildTarget Platform { get; }
		TransferInstructionFlags Flags { get; }

		IReadOnlyList<FileIdentifier> Dependencies { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/IAssetContainerExtensions.cs`:

```cs
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.Parser.Asset
{
	public static class IAssetContainerExtensions
	{
		public static string GetAssetLogString(this IAssetContainer _this, long pathID)
		{
			IUnityObjectBase asset = _this.GetAsset(pathID);
			string? name = asset.TryGetName();
			if (name == null)
			{
				return $"{asset.ClassID}_{pathID}";
			}
			else
			{
				return $"{asset.ClassID}_{pathID}({name})";
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Asset/IDependent.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Asset
{
	public interface IDependent
	{
		IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context);
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ArchiveFiles/ArchiveFile.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.ArchiveFiles
{
	public sealed class ArchiveFile : FileList
	{
		internal ArchiveFile(ArchiveFileScheme scheme) : base(scheme.NameOrigin)
		{
			Header = scheme.Header;
		}

		public static bool IsArchiveFile(string filePath)
		{
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return IsArchiveFile(stream);
		}

		public static bool IsArchiveFile(byte[] buffer, int offset, int size)
		{
			using MemoryStream stream = new MemoryStream(buffer, offset, size, false);
			return IsArchiveFile(stream);
		}

		public static bool IsArchiveFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return ArchiveHeader.IsArchiveHeader(reader);
		}

		public static ArchiveFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static ArchiveFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return ArchiveFileScheme.ReadScheme(buffer, filePath, fileName);
		}

		public static ArchiveFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			return ArchiveFileScheme.ReadScheme(stream, filePath, fileName);
		}

		public ArchiveHeader Header { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ArchiveFiles/ArchiveFileEntry.cs`:

```cs
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Utils;

namespace AssetRipper.Core.Parser.Files.ArchiveFiles
{
	public sealed class ArchiveFileEntry : FileEntry
	{
		public ArchiveFileEntry(long offset, long size, string name)
		{
			Offset = offset;
			Size = size;
			NameOrigin = name;
			Name = FilenameUtils.FixFileIdentifier(name);
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ArchiveFiles/ArchiveFileScheme.cs`:

```cs
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Files.WebFiles;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.IO.Endian;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;

namespace AssetRipper.Core.Parser.Files.ArchiveFiles
{
	public sealed class ArchiveFileScheme : FileScheme
	{
		private ArchiveFileScheme(string filePath, string fileName) : base(filePath, fileName) { }

		internal static ArchiveFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			ArchiveFileScheme scheme = new ArchiveFileScheme(filePath, fileName);
			using (MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false))
			{
				scheme.ReadScheme(stream);
			}
			return scheme;
		}

		internal static ArchiveFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			ArchiveFileScheme scheme = new ArchiveFileScheme(filePath, fileName);
			scheme.ReadScheme(stream);
			return scheme;
		}

		internal ArchiveFile ReadFile(GameProcessorContext context)
		{
			ArchiveFile archive = new ArchiveFile(this);
			archive.AddFile(context, WebScheme);
			return archive;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		private void ReadScheme(Stream stream)
		{
			byte[] buffer;
			using (EndianReader reader = new EndianReader(stream, EndianType.BigEndian))
			{
				Header.Read(reader);
				buffer = Header.Type switch
				{
					ArchiveType.GZip => ReadGZip(reader),
					ArchiveType.Brotli => ReadBrotli(reader),
					_ => throw new NotSupportedException(Header.Type.ToString()),
				};
			}

			WebScheme = WebFile.ReadScheme(buffer, FilePath);
		}

		private static byte[] ReadGZip(EndianReader reader)
		{
			using MemoryStream stream = new MemoryStream();
			using GZipStream gzipStream = new GZipStream(reader.BaseStream, CompressionMode.Decompress);
			gzipStream.CopyTo(stream);
			return stream.ToArray();
		}

		private static byte[] ReadBrotli(EndianReader reader)
		{
			using MemoryStream stream = new MemoryStream();
			using BrotliStream brotliStream = new BrotliStream(reader.BaseStream, CompressionMode.Decompress);
			brotliStream.CopyTo(stream);
			return stream.ToArray();
		}

		public override FileEntryType SchemeType => FileEntryType.Archive;
		public override IEnumerable<FileIdentifier> Dependencies => WebScheme.Dependencies;

		public ArchiveHeader Header { get; } = new ArchiveHeader();
		public WebFileScheme WebScheme { get; private set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ArchiveFiles/ArchiveHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.ArchiveFiles
{
	public sealed class ArchiveHeader
	{
		internal static bool IsArchiveHeader(EndianReader reader)
		{
			long position = reader.BaseStream.Position;

			ushort gzipMagic = ReadGZipMagic(reader);
			reader.BaseStream.Position = position;
			if (gzipMagic == GZipMagic)
			{
				return true;
			}

			string? brotliSignature = ReadBrotliMetadata(reader);
			reader.BaseStream.Position = position;
			if (brotliSignature == BrotliSignature)
			{
				return true;
			}

			return brotliSignature == BrotliSignature;
		}

		private static ushort ReadGZipMagic(EndianReader reader)
		{
			if (reader.BaseStream.Length >= sizeof(ushort))
			{
				return reader.ReadUInt16();
			}
			return 0;
		}

		private static string? ReadBrotliMetadata(EndianReader reader)
		{
			if (reader.BaseStream.Length < 4)
			{
				return null;
			}

			reader.BaseStream.Position += 1;
			byte bt = reader.ReadByte(); // read 3 bits
			int sizeBytes = bt & 0x3;

			if (reader.BaseStream.Position + sizeBytes > reader.BaseStream.Length)
			{
				return null;
			}

			int length = 0;
			for (int i = 0; i < sizeBytes; i++)
			{
				byte nbt = reader.ReadByte();  // read next 8 bits
				int bits = (bt >> 2) | ((nbt & 0x3) << 6);
				bt = nbt;
				length += bits << (8 * i);
			}

			if (length <= 0)
			{
				return null;
			}
			if (reader.BaseStream.Position + length > reader.BaseStream.Length)
			{
				return null;
			}

			return reader.ReadString(length + 1);
		}

		public void Read(EndianReader reader)
		{
			ushort gzipMagic = reader.ReadUInt16();
			reader.BaseStream.Position -= sizeof(ushort);
			if (gzipMagic == GZipMagic)
			{
				Type = ArchiveType.GZip;
				return;
			}

			long position = reader.BaseStream.Position;
			string? signature = ReadBrotliMetadata(reader);
			reader.BaseStream.Position = position;
			if (signature == BrotliSignature)
			{
				Type = ArchiveType.Brotli;
				return;
			}

			throw new Exception("Unsupported archive type");
		}

		public ArchiveType Type { get; private set; }

		private const ushort GZipMagic = 0x1F8B;
		private const string BrotliSignature = "UnityWeb Compressed Content (brotli)";
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ArchiveFiles/ArchiveType.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.ArchiveFiles
{
	public enum ArchiveType
	{
		GZip,
		Brotli,
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BuildTarget.cs`:

```cs
namespace AssetRipper.Core.Parser.Files
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/BuildTarget.cs"/>
	/// </summary>
	public enum BuildTarget : uint
	{
		ValidPlayer = 1,
		/// <summary>
		/// Build a universal macOS standalone
		/// </summary>
		StandaloneOSXUniversal = 2,
		/// <summary>
		/// Build a macOS standalone (PowerPC only)
		/// </summary>
		StandaloneOSXPPC = 3,
		/// <summary>
		/// Build a macOS standalone (Intel only)
		/// </summary>
		StandaloneOSXIntel = 4,
		/// <summary>
		/// Build a Windows standalone
		/// </summary>
		StandaloneWinPlayer = 5,
		/// <summary>
		/// Build a web player.
		/// </summary>
		WebPlayerLZMA = 6,
		/// <summary>
		/// Build a streamed web player
		/// </summary>
		WebPlayerLZMAStreamed = 7,
		Wii = 8,
		/// <summary>
		/// Build an iOS player
		/// </summary>
		iOS = 9,
		PS3 = 10,
		XBox360 = 11,
		Broadcom = 12,
		/// <summary>
		/// Build an Android .apk standalone app
		/// </summary>
		Android = 13,
		WinGLESEmu = 14,
		WinGLES20Emu = 15,
		/// <summary>
		/// Google Native Client
		/// </summary>
		GoogleNaCl = 16,
		/// <summary>
		/// Build a Linux standalone
		/// </summary>
		StandaloneLinux = 17,
		Flash = 18,
		/// <summary>
		/// Build a Windows 64-bit standalone
		/// </summary>
		StandaloneWin64Player = 19,
		/// <summary>
		/// WebGL
		/// </summary>
		WebGL = 20,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerX86 = 21,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerX64 = 22,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerARM = 23,
		/// <summary>
		/// Build a Linux 64-bit standalone
		/// </summary>
		StandaloneLinux64 = 24,
		/// <summary>
		/// Build a Linux universal standalone
		/// </summary>
		StandaloneLinuxUniversal = 25,
		WP8Player = 26,
		/// <summary>
		/// Build a macOS Intel 64-bit standalone
		/// </summary>
		StandaloneOSXIntel64 = 27,
		/// <summary>
		/// BlackBerry
		/// </summary>
		BB10 = 28,
		/// <summary>
		/// Build a Tizen player
		/// </summary>
		Tizen = 29,
		/// <summary>
		/// Build a PS Vita Standalone
		/// </summary>
		PSP2 = 30,
		/// <summary>
		/// Build a PS4 Standalone
		/// </summary>
		PS4 = 31,
		PSM = 32,
		/// <summary>
		/// Build a Xbox One Standalone
		/// </summary>
		XboxOne = 33,
		/// <summary>
		/// Build to Samsung Smart TV platform
		/// </summary>
		SamsungTV = 34,
		/// <summary>
		/// Build to Nintendo 3DS platform
		/// </summary>
		N3DS = 35,
		/// <summary>
		/// Build a Wii U standalone
		/// </summary>
		WiiU = 36,
		/// <summary>
		/// Build to Apple's tvOS platform
		/// </summary>
		tvOS = 37,
		/// <summary>
		/// Build a Nintendo Switch player
		/// </summary>
		Switch = 38,
		Lumin = 39,
		Stadia = 40,
		CloudRendering = 41,
		GameCoreXboxSeries = 42,
		GameCoreXboxOne = 43,
		/// <summary>
		/// Build a PS5 Standalone
		/// </summary>
		PS5 = 44,
		EmbeddedLinux = 45,
		QNX = 46,

		/// <summary>
		/// Editor
		/// </summary>
		NoTarget = 0xFFFFFFFE,
		AnyPlayer = 0xFFFFFFFF,
	}

	public static class PlatformExtensions
	{
		public static bool IsCompatible(this BuildTarget _this, BuildTarget comp)
		{
			if (_this == comp)
			{
				return true;
			}

			if (_this.IsStandalone())
			{
				if (comp.IsStandalone())
				{
					return true;
				}
			}

			return false;
		}

		public static bool IsStandalone(this BuildTarget _this)
		{
			switch (_this)
			{
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.StandaloneOSXPPC:
				case BuildTarget.StandaloneOSXUniversal:
					return true;
			}
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/BundleFile.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.Parser.Files.BundleFile.Header;
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public sealed class BundleFile : FileList
	{
		public BundleHeader Header { get; }
		public BundleMetadata Metadata { get; }

		internal BundleFile(BundleFileScheme scheme) : base(scheme.NameOrigin)
		{
			if (scheme == null)
			{
				throw new ArgumentNullException(nameof(scheme));
			}

			Header = scheme.Header;
			Metadata = scheme.Metadata;
		}

		public static bool IsBundleFile(string filePath) => IsBundleFile(MultiFileStream.OpenRead(filePath));
		public static bool IsBundleFile(byte[] buffer, int offset, int size) => IsBundleFile(new MemoryStream(buffer, offset, size, false));
		public static bool IsBundleFile(Stream stream) => BundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));

		public static BundleFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static BundleFileScheme ReadScheme(byte[] buffer, string filePath, string fileName) => BundleFileScheme.ReadScheme(buffer, filePath, fileName);
		public static BundleFileScheme ReadScheme(Stream stream, string filePath, string fileName) => BundleFileScheme.ReadScheme(stream, filePath, fileName);

	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/BundleFileScheme.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.BundleFile.Header;
using AssetRipper.Core.Parser.Files.BundleFile.IO;
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Structure;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.IO.Endian;
using K4os.Compression.LZ4;
using System.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public sealed class BundleFileScheme : FileSchemeList
	{
		public BundleHeader Header { get; } = new BundleHeader();
		public BundleMetadata Metadata { get; } = new BundleMetadata();
		public override FileEntryType SchemeType => FileEntryType.Bundle;

		private BundleFileScheme(string filePath, string fileName) : base(filePath, fileName) { }

		internal BundleFile ReadFile(GameProcessorContext context)
		{
			BundleFile bundle = new BundleFile(this);
			foreach (FileScheme scheme in Schemes)
			{
				bundle.AddFile(context, scheme);
			}
			return bundle;
		}

		internal static BundleFileScheme ReadScheme(byte[] buffer, string filePath, string fileName) => ReadScheme(new MemoryStream(buffer, 0, buffer.Length, false), filePath, fileName);
		internal static BundleFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			BundleFileScheme scheme = new BundleFileScheme(filePath, fileName);
			scheme.ReadScheme(stream);
			return scheme;
		}

		private void ReadScheme(Stream stream)
		{
			long basePosition = stream.Position;
			ReadHeader(stream);

			switch (Header.Signature)
			{
				case BundleType.UnityRaw:
				case BundleType.UnityWeb:
					ReadRawWebMetadata(stream, out Stream dataStream, out long metadataOffset);//ReadBlocksAndDirectory
					ReadRawWebData(dataStream, metadataOffset);//also ReadBlocksAndDirectory
					break;

				case BundleType.UnityFS:
					long headerSize = stream.Position - basePosition;
					ReadFileStreamMetadata(stream, basePosition);//ReadBlocksInfoAndDirectory
					ReadFileStreamData(stream, basePosition, headerSize);//ReadBlocks and ReadFiles
					break;

				default:
					throw new Exception($"Unknown bundle signature '{Header.Signature}'");
			}
		}

		private void ReadHeader(Stream stream)
		{
			long headerPosition = stream.Position;
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			Header.Read(reader);
			if (Header.Signature.IsRawWeb())
			{
				if (stream.Position - headerPosition != Header.RawWeb!.HeaderSize)
				{
					throw new Exception($"Read {stream.Position - headerPosition} but expected {Header.RawWeb.HeaderSize} bytes while reading the raw/web bundle header.");
				}
			}
		}

		private void ReadRawWebMetadata(Stream stream, out Stream dataStream, out long metadataOffset)
		{
			BundleRawWebHeader header = Header.RawWeb!;
			int metadataSize = BundleRawWebHeader.HasUncompressedBlocksInfoSize(Header.Version) ? header.UncompressedBlocksInfoSize : 0;
			switch (Header.Signature)
			{
				case BundleType.UnityRaw:
					{
						dataStream = stream;
						metadataOffset = stream.Position;

						ReadMetadata(dataStream, metadataSize);
					}
					break;

				case BundleType.UnityWeb:
					{
						// read only last chunk
						BundleScene chunkInfo = header.Scenes[header.Scenes.Length - 1];
						dataStream = new MemoryStream(new byte[chunkInfo.DecompressedSize]);
						SevenZipHelper.DecompressLZMASizeStream(stream, chunkInfo.CompressedSize, dataStream);
						metadataOffset = 0;

						dataStream.Position = 0;
						ReadMetadata(dataStream, metadataSize);
					}
					break;

				default:
					throw new Exception($"Unsupported bundle signature '{Header.Signature}'");
			}
		}

		private void ReadFileStreamMetadata(Stream stream, long basePosition)
		{
			BundleFileStreamHeader header = Header.FileStream!;
			if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
			{
				stream.Align(16);
			}
			if (header.Flags.GetBlocksInfoAtTheEnd())
			{
				stream.Position = basePosition + (header.Size - header.CompressedBlocksInfoSize);
			}

			CompressionType metaCompression = header.Flags.GetCompression();
			switch (metaCompression)
			{
				case CompressionType.None:
					{
						ReadMetadata(stream, header.UncompressedBlocksInfoSize);
					}
					break;

				case CompressionType.Lzma:
					{
						using MemoryStream uncompressedStream = new MemoryStream(new byte[header.UncompressedBlocksInfoSize]);
						SevenZipHelper.DecompressLZMAStream(stream, header.CompressedBlocksInfoSize, uncompressedStream, header.UncompressedBlocksInfoSize);

						uncompressedStream.Position = 0;
						ReadMetadata(uncompressedStream, header.UncompressedBlocksInfoSize);
					}
					break;

				case CompressionType.Lz4:
				case CompressionType.Lz4HC:
					{
						int uncompressedSize = header.UncompressedBlocksInfoSize;
						byte[] uncompressedBytes = new byte[uncompressedSize];
						byte[] compressedBytes = new BinaryReader(stream).ReadBytes(header.CompressedBlocksInfoSize);
						int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
						if (bytesWritten != uncompressedSize)
						{
							throw new System.Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize} for {compressedBytes.Length} compressed bytes");
						}
						ReadMetadata(new MemoryStream(uncompressedBytes), uncompressedSize);
					}
					break;

				default:
					throw new NotSupportedException($"Bundle compression '{metaCompression}' isn't supported");
			}
		}

		private void ReadMetadata(Stream stream, int metadataSize)
		{
			long metadataPosition = stream.Position;
			using (BundleReader reader = new BundleReader(stream, EndianType.BigEndian, Header.Signature, Header.Version, Header.Flags))
			{
				Metadata.Read(reader);
			}
			if (metadataSize > 0)
			{
				if (stream.Position - metadataPosition != metadataSize)
				{
					throw new Exception($"Read {stream.Position - metadataPosition} but expected {metadataSize} while reading bundle metadata");
				}
			}
		}

		private void ReadRawWebData(Stream stream, long metadataOffset)
		{
			foreach (Node entry in Metadata.DirectoryInfo.Nodes)
			{
				byte[] buffer = new byte[entry.Size];
				stream.Position = metadataOffset + entry.Offset;
				stream.ReadBuffer(buffer, 0, buffer.Length);
				FileScheme scheme = SchemeReader.ReadScheme(buffer, FilePath, entry.PathOrigin);
				AddScheme(scheme);
			}
		}

		private void ReadFileStreamData(Stream stream, long basePosition, long headerSize)
		{
			if (Header.Flags.GetBlocksInfoAtTheEnd())
			{
				stream.Position = basePosition + headerSize;
				if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
				{
					stream.Align(16);
				}
			}
			if (Header.Flags.GetAlignAfterBlocksInfo())
			{
				stream.Align(16);
			}

			using BundleFileBlockReader blockReader = new BundleFileBlockReader(stream, Metadata.BlocksInfo);
			foreach (Node entry in Metadata.DirectoryInfo.Nodes)
			{
				SmartStream entryStream = blockReader.ReadEntry(entry);
				FileScheme scheme = SchemeReader.ReadScheme(entryStream, FilePath, entry.PathOrigin);
				AddScheme(scheme);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/BundleType.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public enum BundleType
	{
		UnityArchive,//not supported
		UnityRaw,
		UnityWeb,
		UnityFS,
	}

	public static class BundleTypeExtensions
	{
		/// <summary>
		/// True if UnityRaw or UnityWeb
		/// </summary>
		public static bool IsRawWeb(this BundleType _this)
		{
			return _this == BundleType.UnityRaw || _this == BundleType.UnityWeb;
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/BundleVersion.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public enum BundleVersion
	{
		Unknown = 0,

		BF_100_250 = 1,
		BF_260_340 = 2,
		BF_350_4x = 3,
		BF_520a1 = 4,
		BF_520aunk = 5,
		BF_520_x = 6,
		BF_LargeFilesSupport = 7,//not real name
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/CompressionType.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public enum CompressionType
	{
		None = 0,
		Lzma = 1,
		Lz4 = 2,
		Lz4HC = 3,
		Lzham = 4,
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Header/BundleFileStreamHeader.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.BundleFile.Header
{
	public sealed class BundleFileStreamHeader
	{
		public BundleFileStreamHeader(EndianReader reader)
		{
			Size = reader.ReadInt64();
			CompressedBlocksInfoSize = reader.ReadInt32();
			UncompressedBlocksInfoSize = reader.ReadInt32();
			Flags = (BundleFlags)reader.ReadInt32();
		}

		/// <summary>
		/// Equal to file size, sometimes equal to uncompressed data size without the header
		/// </summary>
		public long Size { get; set; }
		/// <summary>
		/// UnityFS length of the possibly-compressed (LZMA, LZ4) bundle data header
		/// </summary>
		public int CompressedBlocksInfoSize { get; set; }
		public int UncompressedBlocksInfoSize { get; set; }
		public BundleFlags Flags { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Header/BundleHeader.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.BundleFile.Header
{
	public sealed class BundleHeader
	{
		public BundleType Signature { get; set; }
		public BundleVersion Version { get; set; }
		/// <summary>
		/// Generation version
		/// </summary>
		public string? UnityWebBundleVersion { get; set; }
		/// <summary>
		/// Actual engine version
		/// </summary>
		public UnityVersion UnityWebMinimumRevision { get; set; }
		public BundleFlags Flags
		{
			get
			{
				if (Signature == BundleType.UnityFS)
				{
					return FileStream!.Flags;
				}
				return 0;
			}
		}

		public BundleRawWebHeader? RawWeb { get; set; }
		public BundleFileStreamHeader? FileStream { get; set; }

		public void Read(EndianReader reader)
		{
			string signature = reader.ReadStringZeroTerm();
			Signature = ParseSignature(signature);
			Version = (BundleVersion)reader.ReadInt32();
			UnityWebBundleVersion = reader.ReadStringZeroTerm();
			string engineVersion = reader.ReadStringZeroTerm();
			UnityWebMinimumRevision = UnityVersion.Parse(engineVersion);

			switch (Signature)
			{
				case BundleType.UnityRaw:
				case BundleType.UnityWeb:
					RawWeb = new BundleRawWebHeader(reader, Version);//ReadHeaderAndBlocksInfo
					break;
				case BundleType.UnityFS:
					FileStream = new BundleFileStreamHeader(reader);//ReadHeader
					break;
				case BundleType.UnityArchive:
					throw new NotSupportedException("UnityArchives are not currently supported");
				default:
					throw new Exception($"Unknown bundle signature '{Signature}'");
			}
		}

		public static BundleType ParseSignature(string signature)
		{
			return TryParseSignature(signature, out BundleType bundleType)
				? bundleType
				: throw new ArgumentException($"Unsupported signature '{signature}'");
		}

		public static bool TryParseSignature(string signatureString, out BundleType type)
		{
			switch (signatureString)
			{
				case nameof(BundleType.UnityWeb):
					type = BundleType.UnityWeb;
					return true;
				case nameof(BundleType.UnityRaw):
					type = BundleType.UnityRaw;
					return true;
				case nameof(BundleType.UnityFS):
					type = BundleType.UnityFS;
					return true;
				case nameof(BundleType.UnityArchive):
					type = BundleType.UnityArchive;
					return true;
				default:
					type = default;
					return false;
			}
		}

		internal static bool IsBundleHeader(EndianReader reader)
		{
			const int MaxLength = 0x20;
			if (reader.BaseStream.Length >= MaxLength)
			{
				long position = reader.BaseStream.Position;
				bool isRead = reader.ReadStringZeroTerm(MaxLength, out string? signature);
				reader.BaseStream.Position = position;
				if (isRead)
				{
					return TryParseSignature(signature!, out BundleType _);
				}
			}
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Header/BundleRawWebHeader.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.BundleFile.Header
{
	public sealed class BundleRawWebHeader
	{
		/// <summary>
		/// 5.2.0 and greater / Bundle Version 4 +
		/// </summary>
		public static bool HasHash(BundleVersion generation) => generation >= BundleVersion.BF_520a1;
		/// <summary>
		/// 2.6.0 and greater / Bundle Version 2 +
		/// </summary>
		public static bool HasCompleteFileSize(BundleVersion generation) => generation >= BundleVersion.BF_260_340;
		/// <summary>
		/// 3.5.0 and greater / Bundle Version 3 +
		/// </summary>
		public static bool HasUncompressedBlocksInfoSize(BundleVersion generation) => generation >= BundleVersion.BF_350_4x;

		public BundleRawWebHeader(EndianReader reader, BundleVersion generation)
		{
			if (HasHash(generation))
			{
				Hash.Read(reader);
				Crc = reader.ReadUInt32();
			}
			MinimumStreamedBytes = reader.ReadUInt32();
			HeaderSize = reader.ReadInt32();
			NumberOfScenesToDownloadBeforeStreaming = reader.ReadInt32();
			Scenes = reader.ReadEndianArray<BundleScene>();
			if (HasCompleteFileSize(generation))
			{
				CompleteFileSize = reader.ReadUInt32();
			}
			if (HasUncompressedBlocksInfoSize(generation))
			{
				UncompressedBlocksInfoSize = (int)reader.ReadUInt32();
			}
			reader.AlignStream();
		}

		public uint Crc { get; set; }
		/// <summary>
		/// Minimum number of bytes to read for streamed bundles, equal to BundleSize for normal bundles
		/// </summary>
		public uint MinimumStreamedBytes { get; set; }
		public int HeaderSize { get; set; }
		/// <summary>
		/// Equal to 1 if it's a streamed bundle, number of LZMAChunkInfos + mainData assets otherwise
		/// </summary>
		public int NumberOfScenesToDownloadBeforeStreaming { get; set; }
		/// <summary>
		/// LZMA chunks info
		/// </summary>
		public BundleScene[] Scenes { get; set; }
		public uint CompleteFileSize { get; set; }
		public int UncompressedBlocksInfoSize { get; set; }

		public Hash128 Hash = new();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/IO/BundleFileBlockReader.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using K4os.Compression.LZ4;
using System.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.IO
{
	internal sealed class BundleFileBlockReader : IDisposable
	{
		public BundleFileBlockReader(Stream stream, BlocksInfo blocksInfo)
		{
			m_stream = stream;
			m_blocksInfo = blocksInfo;
			m_dataOffset = stream.Position;
		}

		~BundleFileBlockReader()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public SmartStream ReadEntry(Node entry)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(nameof(BundleFileBlockReader));
			}

			// find block offsets
			int blockIndex;
			long blockCompressedOffset = 0;
			long blockDecompressedOffset = 0;
			for (blockIndex = 0; blockDecompressedOffset + m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize <= entry.Offset; blockIndex++)
			{
				blockCompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].CompressedSize;
				blockDecompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize;
			}
			long entryOffsetInsideBlock = entry.Offset - blockDecompressedOffset;

			using SmartStream entryStream = CreateStream(entry.Size);
			long left = entry.Size;
			m_stream.Position = m_dataOffset + blockCompressedOffset;

			// copy data of all blocks used by current entry to new stream
			while (left > 0)
			{
				long blockStreamOffset;
				Stream blockStream;
				StorageBlock block = m_blocksInfo.StorageBlocks[blockIndex];
				if (m_cachedBlockIndex == blockIndex)
				{
					// data of the previous entry is in the same block as this one
					// so we don't need to unpack it once again. Instead we can use cached stream
					blockStreamOffset = 0;
					blockStream = m_cachedBlockStream;
					m_stream.Position += block.CompressedSize;
				}
				else
				{
					CompressionType compressType = block.Flags.GetCompression();
					if (compressType == CompressionType.None)
					{
						blockStreamOffset = m_dataOffset + blockCompressedOffset;
						blockStream = m_stream;
					}
					else
					{
						blockStreamOffset = 0;
						m_cachedBlockIndex = blockIndex;
						m_cachedBlockStream.Move(CreateStream(block.UncompressedSize));
						switch (compressType)
						{
							case CompressionType.Lzma:
								SevenZipHelper.DecompressLZMAStream(m_stream, block.CompressedSize, m_cachedBlockStream, block.UncompressedSize);
								break;

							case CompressionType.Lz4:
							case CompressionType.Lz4HC:
								uint uncompressedSize = block.UncompressedSize;
								byte[] uncompressedBytes = new byte[uncompressedSize];
								byte[] compressedBytes = new BinaryReader(m_stream).ReadBytes((int)block.CompressedSize);
								int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
								if (bytesWritten != uncompressedSize)
								{
									throw new System.Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize}");
								}
								new MemoryStream(uncompressedBytes).CopyTo(m_cachedBlockStream);
								break;

							default:
								throw new NotImplementedException($"Bundle compression '{compressType}' isn't supported");
						}
						blockStream = m_cachedBlockStream;
					}
				}

				// consider next offsets:
				// 1) block - if it is new stream then offset is 0, otherwise offset of this block in the bundle file
				// 2) entry - if this is first block for current entry then it is offset of this entry related to this block
				//			  otherwise 0
				long blockSize = block.UncompressedSize - entryOffsetInsideBlock;
				blockStream.Position = blockStreamOffset + entryOffsetInsideBlock;
				entryOffsetInsideBlock = 0;

				long size = System.Math.Min(blockSize, left);
				blockStream.CopyStream(entryStream, size);
				blockIndex++;

				blockCompressedOffset += block.CompressedSize;
				left -= size;
			}
			if (left < 0)
			{
				throw new Exception($"Read more than expected");
			}
			entryStream.Position = 0;
			return entryStream.CreateReference();
		}

		private void Dispose(bool disposing)
		{
			m_isDisposed = true;
			m_cachedBlockStream.Dispose();
		}

		private SmartStream CreateStream(long decompressedSize)
		{
			return decompressedSize > int.MaxValue ? SmartStream.CreateTemp() : SmartStream.CreateMemory(new byte[decompressedSize]);
		}

		private readonly Stream m_stream;
		private readonly BlocksInfo m_blocksInfo = new();
		private readonly long m_dataOffset;

		private readonly SmartStream m_cachedBlockStream = SmartStream.CreateNull();
		private int m_cachedBlockIndex = -1;

		private bool m_isDisposed = false;
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/IO/BundleReader.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.Parser;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.IO
{
	public sealed class BundleReader : EndianReader
	{
		public BundleReader(Stream stream, EndianType endianess, BundleType signature, BundleVersion generation, BundleFlags flags) : base(stream, endianess)
		{
			Signature = signature;
			Generation = generation;
			Flags = flags;
		}

		public T ReadBundle<T>() where T : IBundleReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadBundleArray<T>() where T : IBundleReadable, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public T[] ReadBundleArray<T>(Func<T> instantiator) where T : IBundleReadable
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = instantiator();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public BundleType Signature { get; }
		public BundleVersion Generation { get; }
		public BundleFlags Flags { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/IO/IBundleReadable.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile.IO
{
	public interface IBundleReadable
	{
		void Read(BundleReader reader);
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/BlocksInfo.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Files.BundleFile.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	public sealed class BlocksInfo : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			Hash.Read(reader);
			StorageBlocks = reader.ReadBundleArray<StorageBlock>();
		}

		public StorageBlock[] StorageBlocks { get; set; } = Array.Empty<StorageBlock>();

		public Hash128 Hash { get; } = new();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/BundleFlags.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	[Flags]
	public enum BundleFlags
	{
		None = 0,

		CompressionBit1 = 0x1,
		CompressionBit2 = 0x2,
		CompressionBit3 = 0x4,
		CompressionBit4 = 0x8,
		CompressionBit5 = 0x10,
		CompressionBit6 = 0x20,
		CompressionTypeMask = 0x3F,

		BlocksAndDirectoryInfoCombined = 0x40,
		BlocksInfoAtTheEnd = 0x80,
		OldWebPluginCompatibility = 0x100,
		/// <summary>
		/// Padding is added after blocks info, so files within asset bundles start on aligned boundaries.
		/// </summary>
		/// <remarks>
		/// Introduced in 2019.4.41f1?, 2020.3.34f1, 2021.3.2f1, 2022.1.1f1 so that Switch patching works appropriately.<br/>
		/// <see href="https://unity3d.com/unity/whats-new/2021.3.2"/><br/>
		/// <see href="https://issuetracker.unity3d.com/issues/files-within-assetbundles-do-not-start-on-aligned-boundaries-breaking-patching-on-nintendo-switch"/><br/>
		/// This fix implies that loading newly generated AssetBundles will require using this new Unity editor/runtime combination. It is not backwards compatible.
		/// </remarks>
		AlignAfterBlocksInfo = 0x200,
	}

	public static class BundleFlagsExtensions
	{
		/// <summary>
		/// The lowest 6 bits
		/// </summary>
		public static CompressionType GetCompression(this BundleFlags _this)
		{
			return (CompressionType)(_this & BundleFlags.CompressionTypeMask);
		}

		/// <summary>
		/// The 0x40 bit: <see cref="BundleFlags.BlocksAndDirectoryInfoCombined"/>
		/// </summary>
		public static bool GetBlocksAndDirectoryInfoCombined(this BundleFlags _this)
		{
			return (_this & BundleFlags.BlocksAndDirectoryInfoCombined) != 0;
		}

		/// <summary>
		/// The 0x80 bit: <see cref="BundleFlags.BlocksInfoAtTheEnd"/>
		/// </summary>
		public static bool GetBlocksInfoAtTheEnd(this BundleFlags _this)
		{
			return (_this & BundleFlags.BlocksInfoAtTheEnd) != 0;
		}

		/// <summary>
		/// The 0x100 bit: <see cref="BundleFlags.OldWebPluginCompatibility"/>
		/// </summary>
		public static bool GetOldWebPluginCompatibility(this BundleFlags _this)
		{
			return (_this & BundleFlags.OldWebPluginCompatibility) != 0;
		}

		/// <summary>
		/// The 0x200 bit: <see cref="BundleFlags.AlignAfterBlocksInfo"/>
		/// </summary>
		public static bool GetAlignAfterBlocksInfo(this BundleFlags _this)
		{
			return (_this & BundleFlags.AlignAfterBlocksInfo) != 0;
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/BundleMetadata.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	/// <summary>
	/// Metadata about bundle's block or chunk
	/// </summary>
	public sealed class BundleMetadata : IBundleReadable
	{
		/// <summary>
		/// 5.2.0 and greater
		/// </summary>
		private static bool HasBlocksInfo(BundleType signature) => signature == BundleType.UnityFS;

		public void Read(BundleReader reader)
		{
			if (HasBlocksInfo(reader.Signature))
			{
				BlocksInfo.Read(reader);
				if (reader.Flags.GetBlocksAndDirectoryInfoCombined())
				{
					DirectoryInfo.Read(reader);
				}
			}
			else
			{
				DirectoryInfo.Read(reader);
				reader.AlignStream();
			}
		}

		public BlocksInfo BlocksInfo = new();
		public DirectoryInfo DirectoryInfo = new();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/BundleScene.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	/// <summary>
	/// Contains compression information about chunk
	/// Chunk is a structure (optionaly LZMA compressed) that contains file entries and data blob
	/// </summary>
	public struct BundleScene : IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			CompressedSize = reader.ReadUInt32();
			DecompressedSize = reader.ReadUInt32();
		}

		public override string ToString()
		{
			return $"C:{CompressedSize} D:{DecompressedSize}";
		}

		public uint CompressedSize { get; private set; }
		public uint DecompressedSize { get; private set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/DirectoryInfo.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	public sealed class DirectoryInfo : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			Nodes = reader.ReadBundleArray<Node>();
		}

		public Node[] Nodes { get; set; } = Array.Empty<Node>();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/Node.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.IO;
using AssetRipper.Core.Parser.Utils;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	public sealed class Node : IBundleReadable
	{
		/// <summary>
		/// 5.2.0 and greater
		/// </summary>
		public static bool HasBlobIndex(BundleType signature) => signature == BundleType.UnityFS;

		public void Read(BundleReader reader)
		{
			if (HasBlobIndex(reader.Signature))
			{
				Offset = reader.ReadInt64();
				Size = reader.ReadInt64();
				BlobIndex = reader.ReadInt32();
				PathOrigin = reader.ReadStringZeroTerm();
			}
			else
			{
				PathOrigin = reader.ReadStringZeroTerm();
				Offset = reader.ReadInt32();
				Size = reader.ReadInt32();
			}
			Path = FilenameUtils.FixFileIdentifier(PathOrigin);
		}

		public override string ToString()
		{
			return Path;
		}

		public string Path { get; set; } = "";
		public string PathOrigin { get; set; } = "";
		public long Offset { get; set; }
		public long Size { get; set; }
		public int BlobIndex { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/StorageBlock.cs`:

```cs
using AssetRipper.Core.Parser.Files.BundleFile.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	/// <summary>
	/// Contains compression information about a block<br/>
	/// Blocks are similar to chunk structure in that it contains a data blob but without file entries
	/// </summary>
	public struct StorageBlock : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			UncompressedSize = reader.ReadUInt32();
			CompressedSize = reader.ReadUInt32();
			Flags = (StorageBlockFlags)reader.ReadUInt16();
		}

		public override string ToString()
		{
			return $"C:{CompressedSize} D:{UncompressedSize} F:{Flags}";
		}

		public uint UncompressedSize { get; private set; }
		public uint CompressedSize { get; private set; }
		public StorageBlockFlags Flags { get; private set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/Parser/StorageBlockFlags.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.BundleFile.Parser
{
	[Flags]
	public enum StorageBlockFlags
	{
		CompressionTypeMask = 0x3F,

		Streamed = 0x40,
	}

	public static class StorageBlockFlagsExtensions
	{
		public static CompressionType GetCompression(this StorageBlockFlags _this)
		{
			return (CompressionType)(_this & StorageBlockFlags.CompressionTypeMask);
		}

		public static bool IsStreamed(this StorageBlockFlags _this)
		{
			return (_this & StorageBlockFlags.Streamed) != 0;
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/BundleFile/SevenZipHelper.cs`:

```cs
using AssetRipper.Core.Extensions;
using SharpCompress.Compressors.LZMA;
using System.IO;

namespace AssetRipper.Core.Parser.Files.BundleFile
{
	public static class SevenZipHelper
	{
		/// <summary>
		/// Read LZMA properties and decompress LZMA data
		/// </summary>
		/// <param name="compressedStream">LZMA compressed stream</param>
		/// <param name="compressedSize">Compressed data length</param>
		/// <param name="decompressedStream">Stream for decompressed output</param>
		/// <param name="decompressedSize">Decompressed data length</param>
		public static void DecompressLZMAStream(Stream compressedStream, long compressedSize, Stream decompressedStream, long decompressedSize)
		{
			byte[] properties = new byte[PropertiesSize];
			long basePosition = compressedStream.Position;

			compressedStream.ReadBuffer(properties, 0, PropertiesSize);

			long headSize = compressedStream.Position - basePosition;
			long headlessSize = compressedSize - headSize;

			DecompressLZMAStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

			if (compressedStream.Position > basePosition + compressedSize)
			{
				throw new Exception($"Read {compressedStream.Position - basePosition} more than expected {compressedSize}");
			}
			compressedStream.Position = basePosition + compressedSize;
		}

		/// <summary>
		/// Read LZMA properties and decompressed size and decompress LZMA data
		/// </summary>
		/// <param name="compressedStream">LZMA compressed stream</param>
		/// <param name="compressedSize">Compressed data length</param>
		/// <param name="decompressedStream">Stream for decompressed output</param>
		public static void DecompressLZMASizeStream(Stream compressedStream, long compressedSize, Stream decompressedStream)
		{
			byte[] properties = new byte[PropertiesSize]; //GetBuffer();
			byte[] sizeBytes = new byte[UncompressedSize]; //GetBuffer();
			long basePosition = compressedStream.Position;

			compressedStream.ReadBuffer(properties, 0, PropertiesSize);
			compressedStream.ReadBuffer(sizeBytes, 0, UncompressedSize);
			long decompressedSize = BitConverter.ToInt64(sizeBytes, 0);

			long headSize = compressedStream.Position - basePosition;
			long headlessSize = compressedSize - headSize;

			DecompressLZMAStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

			if (compressedStream.Position > basePosition + compressedSize)
			{
				throw new Exception($"Read {compressedStream.Position - basePosition} more than expected {compressedSize}");
			}
			compressedStream.Position = basePosition + compressedSize;
		}

		private static void DecompressLZMAStream(byte[] properties, Stream compressedStream, long headlessSize, Stream decompressedStream, long decompressedSize)
		{
			LzmaStream lzmaStream = new LzmaStream(properties, compressedStream, headlessSize, -1, null, false);

			byte[] buffer = GetBuffer();
			int read;
			long totalRead = 0;
			while (totalRead < decompressedSize)
			{
				int toRead = (int)System.Math.Min(buffer.Length, decompressedSize - totalRead);
				read = lzmaStream.Read(buffer, 0, toRead);
				if (read > 0)
				{
					decompressedStream.Write(buffer, 0, read);
					totalRead += read;
				}
				else
				{
					break;
				}
			}
		}

		private static byte[] GetBuffer()
		{
			if (s_buffer == null)
			{
				s_buffer = new byte[1024];
			}
			return s_buffer;
		}

		private const int PropertiesSize = 5;
		private const int UncompressedSize = 8;

		[ThreadStatic]
		private static byte[]? s_buffer;
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/Entries/FileEntry.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.Entries
{
	public abstract class FileEntry
	{
		public override string? ToString()
		{
			return Name;
		}

		public string Name { get; protected set; } = "";
		public string NameOrigin { get; protected set; } = "";
		public long Offset { get; protected set; }
		public long Size { get; protected set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/Entries/FileEntryType.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.Entries
{
	public enum FileEntryType
	{
		Serialized,
		Bundle,
		Archive,
		Web,
		Resource,
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/Entries/FileList.cs`:

```cs
using AssetRipper.Core.Parser.Files.ArchiveFiles;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.WebFiles;
using AssetRipper.Core.Structure.GameStructure;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.Entries
{
	public abstract class FileList
	{
		public FileList(string name)
		{
			Name = name;
		}

		public IEnumerable<SerializedFiles.SerializedFile> FetchSerializedFiles()
		{
			foreach (SerializedFiles.SerializedFile file in SerializedFiles)
			{
				yield return file;
			}
			foreach (FileList list in FileLists)
			{
				foreach (SerializedFiles.SerializedFile file in list.FetchSerializedFiles())
				{
					yield return file;
				}
			}
		}

		public void AddSerializedFile(SerializedFiles.SerializedFile file)
		{
			m_serializedFiles.Add(file);
			OnSerializedFileAdded(file);
		}

		public void AddFileList(FileList list)
		{
			m_fileLists.Add(list);
			OnFileListAdded(list);
		}

		public void AddResourceFile(ResourceFiles.ResourceFile resource)
		{
			m_resourceFiles.Add(resource);
			OnResourceFileAdded(resource);
		}

		internal void AddFile(GameProcessorContext context, FileScheme scheme)
		{
			switch (scheme.SchemeType)
			{
				case FileEntryType.Serialized:
					{
						SerializedFileScheme serializedScheme = (SerializedFileScheme)scheme;
						SerializedFiles.SerializedFile file = serializedScheme.ReadFile(context);
						AddSerializedFile(file);
					}
					break;

				case FileEntryType.Bundle:
					{
						BundleFileScheme bundleScheme = (BundleFileScheme)scheme;
						BundleFile.BundleFile bundle = bundleScheme.ReadFile(context);
						AddFileList(bundle);
					}
					break;

				case FileEntryType.Archive:
					{
						ArchiveFileScheme archiveScheme = (ArchiveFileScheme)scheme;
						ArchiveFiles.ArchiveFile archive = archiveScheme.ReadFile(context);
						AddFileList(archive);
					}
					break;

				case FileEntryType.Web:
					{
						WebFileScheme webScheme = (WebFileScheme)scheme;
						WebFiles.WebFile webFile = webScheme.ReadFile(context);
						AddFileList(webFile);
					}
					break;

				case FileEntryType.Resource:
					{
						ResourceFileScheme resourceScheme = (ResourceFileScheme)scheme;
						ResourceFiles.ResourceFile resource = resourceScheme.ReadFile();
						AddResourceFile(resource);
					}
					break;

				default:
					throw new NotSupportedException(scheme.SchemeType.ToString());
			}
		}

		protected virtual void OnSerializedFileAdded(SerializedFiles.SerializedFile file) { }

		protected virtual void OnFileListAdded(FileList list) { }

		protected virtual void OnResourceFileAdded(ResourceFiles.ResourceFile resource) { }

		public string Name { get; }

		public IReadOnlyList<SerializedFiles.SerializedFile> SerializedFiles => m_serializedFiles;
		public IReadOnlyList<FileList> FileLists => m_fileLists;
		public IReadOnlyList<ResourceFiles.ResourceFile> ResourceFiles => m_resourceFiles;

		private readonly List<SerializedFiles.SerializedFile> m_serializedFiles = new List<SerializedFiles.SerializedFile>(0);
		private readonly List<FileList> m_fileLists = new List<FileList>(0);
		private readonly List<ResourceFiles.ResourceFile> m_resourceFiles = new List<ResourceFiles.ResourceFile>(0);
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ResourceFiles/IResourceFile.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Parser.Files.ResourceFiles
{
	public interface IResourceFile
	{
		Stream Stream { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ResourceFiles/ResourceFile.cs`:

```cs
using AssetRipper.Core.IO.Smart;
using System.IO;

namespace AssetRipper.Core.Parser.Files.ResourceFiles
{
	public sealed class ResourceFile : IResourceFile, IDisposable
	{
		internal ResourceFile(ResourceFileScheme scheme)
		{
			Name = scheme.NameOrigin;
			Stream = scheme.Stream.CreateReference();
		}

		~ResourceFile()
		{
			Dispose(false);
		}

		public static bool IsDefaultResourceFile(string fileName)
		{
			string extension = Path.GetExtension(fileName).ToLower();
			return extension switch
			{
				ResourceFileExtension or StreamingFileExtension => true,
				_ => false,
			};
		}

		public static ResourceFileScheme LoadScheme(string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static ResourceFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return ResourceFileScheme.ReadScheme(buffer, filePath, fileName);
		}

		public static ResourceFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return ResourceFileScheme.ReadScheme(stream, filePath, fileName);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public override string ToString()
		{
			return Name;
		}

		private void Dispose(bool _)
		{
			Stream.Dispose();
		}

		public string Name { get; }
		public Stream Stream { get; }

		public const string ResourceFileExtension = ".resource";
		public const string StreamingFileExtension = ".ress";
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/ResourceFiles/ResourceFileScheme.cs`:

```cs
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.ResourceFiles
{
	public sealed class ResourceFileScheme : FileScheme
	{
		private ResourceFileScheme(SmartStream stream, string filePath, string fileName) : base(filePath, fileName)
		{
			Stream = stream.CreateReference();
		}

		internal static ResourceFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.CreateMemory(buffer);
			return new ResourceFileScheme(stream, filePath, fileName);
		}

		internal static ResourceFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return new ResourceFileScheme(stream, filePath, fileName);
		}

		public ResourceFile ReadFile()
		{
			return new ResourceFile(this);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			Stream.Dispose();
		}

		public override FileEntryType SchemeType => FileEntryType.Resource;
		public override IEnumerable<FileIdentifier> Dependencies { get { yield break; } }

		public SmartStream Stream { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/Schemes/FileScheme.cs`:

```cs
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Utils;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.Schemes
{
	public abstract class FileScheme : IDisposable
	{
		protected FileScheme(string filePath, string fileName)
		{
			FilePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
			NameOrigin = fileName;
			Name = FilenameUtils.FixFileIdentifier(fileName);
		}

		public override string? ToString()
		{
			return Name == null ? base.ToString() : $"T:{SchemeType} N:'{Name}'";
		}

		public string FilePath { get; }
		public string NameOrigin { get; }
		public string Name { get; }

		public abstract FileEntryType SchemeType { get; }
		public abstract IEnumerable<FileIdentifier> Dependencies { get; }

		~FileScheme()
		{
			Dispose(false);
		}

		protected virtual void Dispose(bool disposing) { }

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

	}
}

```

`AssetRipper.Fundamentals/Parser/Files/Schemes/FileSchemeList.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.Schemes
{
	public abstract class FileSchemeList : FileScheme
	{
		protected FileSchemeList(string filePath, string fileName) : base(filePath, fileName) { }

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			foreach (FileScheme scheme in Schemes)
			{
				scheme.Dispose();
			}
		}

		protected void AddScheme(FileScheme scheme)
		{
			m_schemes.Add(scheme);
		}

		public sealed override IEnumerable<FileIdentifier> Dependencies
		{
			get
			{
				foreach (FileScheme scheme in m_schemes)
				{
					foreach (FileIdentifier dependency in scheme.Dependencies)
					{
						yield return dependency;
					}
				}
			}
		}

		public IReadOnlyList<FileScheme> Schemes => m_schemes;

		private readonly List<FileScheme> m_schemes = new List<FileScheme>();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/FormatVersion.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	/// <summary>
	/// SerializedFileFormatVersion in the pdb
	/// </summary>
	public enum FormatVersion
	{
		Unsupported = 1,
		Unknown_2 = 2,
		Unknown_3 = 3,
		/// <summary>
		/// 1.2.0 to 2.0.0
		/// </summary>
		Unknown_5 = 5,
		/// <summary>
		/// 2.1.0 to 2.6.1
		/// </summary>
		Unknown_6 = 6,
		/// <summary>
		/// 3.0.0b
		/// </summary>
		Unknown_7 = 7,
		/// <summary>
		/// 3.0.0 to 3.4.2
		/// </summary>
		Unknown_8 = 8,
		/// <summary>
		/// 3.5.0 to 4.7.2
		/// </summary>
		Unknown_9 = 9,
		/// <summary>
		/// 5.0.0aunk1
		/// </summary>
		Unknown_10 = 10,
		/// <summary>
		/// 5.0.0aunk2
		/// </summary>
		HasScriptTypeIndex = 11,
		/// <summary>
		/// 5.0.0aunk3
		/// </summary>
		Unknown_12 = 12,
		/// <summary>
		/// 5.0.0aunk4
		/// </summary>
		HasTypeTreeHashes = 13,
		/// <summary>
		/// 5.0.0unk
		/// </summary>
		Unknown_14 = 14,
		/// <summary>
		/// 5.0.1 to 5.4.0
		/// </summary>
		SupportsStrippedObject = 15,
		/// <summary>
		/// 5.5.0a
		/// </summary>
		RefactoredClassId = 16,
		/// <summary>
		/// 5.5.0unk to 2018.4
		/// </summary>
		RefactorTypeData = 17,
		/// <summary>
		/// 2019.1a
		/// </summary>
		RefactorShareableTypeTreeData = 18,
		/// <summary>
		/// 2019.1unk
		/// </summary>
		TypeTreeNodeWithTypeFlags = 19,
		/// <summary>
		/// 2019.2
		/// </summary>
		SupportsRefObject = 20,
		/// <summary>
		/// 2019.3 to 2019.4
		/// </summary>
		StoresTypeDependencies = 21,
		/// <summary>
		/// 2020.1 to x
		/// </summary>
		LargeFilesSupport = 22,
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/IO/ISerializedReadable.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.SerializedFiles.IO
{
	public interface ISerializedReadable
	{
		void Read(SerializedReader reader);
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/IO/ISerializedWritable.cs`:

```cs
namespace AssetRipper.Core.Parser.Files.SerializedFiles.IO
{
	public interface ISerializedWritable
	{
		void Write(SerializedWriter writer);
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/IO/SerializedReader.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.IO
{
	public sealed class SerializedReader : EndianReader
	{
		public SerializedReader(Stream stream, EndianType endianess, FormatVersion generation) : base(stream, endianess)
		{
			Generation = generation;
		}

		public T ReadSerialized<T>() where T : ISerializedReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadSerializedArray<T>() where T : ISerializedReadable, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public T[] ReadSerializedTypeArray<T>(bool hasTypeTree) where T : SerializedTypeBase, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new();
				instance.Read(this, hasTypeTree);
				array[i] = instance;
			}
			return array;
		}

		public FormatVersion Generation { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/IO/SerializedWriter.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.IO
{
	public sealed class SerializedWriter : EndianWriter
	{
		public SerializedWriter(Stream stream, EndianType endianess, FormatVersion generation) : base(stream, endianess)
		{
			Generation = generation;
		}

		public void WriteSerialized<T>(T value) where T : ISerializedWritable
		{
			value.Write(this);
		}

		public void WriteSerializedArray<T>(T[] buffer) where T : ISerializedWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i].Write(this);
			}
		}

		public void WriteSerializedTypeArray<T>(T[] buffer, bool hasTypeTree) where T : SerializedTypeBase
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i].Write(this, hasTypeTree);
			}
		}

		public FormatVersion Generation { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/ISerializedFile.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Structure;
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	public interface ISerializedFile : IAssetContainer
	{
		/// <summary>
		/// Try to find an asset in the current serialized file
		/// </summary>
		/// <param name="pathID">Path ID of the asset</param>
		/// <returns>Found asset or null</returns>
		IUnityObjectBase? FindAsset(long pathID);

		ObjectInfo GetAssetEntry(long pathID);

		PPtr<T> CreatePPtr<T>(T asset) where T : IUnityObjectBase;

		IEnumerable<IUnityObjectBase> FetchAssets();

		IFileCollection Collection { get; }
		EndianType EndianType { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/FileIdentifier.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using AssetRipper.Core.Parser.Utils;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	/// <summary>
	/// A serialized file may be linked with other serialized files to create shared dependencies.
	/// </summary>
	public struct FileIdentifier : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 2.1.0 and greater
		/// </summary>
		public static bool HasAssetPath(FormatVersion generation) => generation >= FormatVersion.Unknown_6;
		/// <summary>
		/// 1.2.0 and greater
		/// </summary>
		public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.Unknown_5;

		public bool IsFile(ISerializedFile? file)
		{
			return file is not null && file.Name == PathName;
		}

		public void Read(SerializedReader reader)
		{
			if (HasAssetPath(reader.Generation))
			{
				AssetPath = reader.ReadStringZeroTerm();
			}
			if (HasHash(reader.Generation))
			{
				Guid.Read(reader);
				Type = (AssetType)reader.ReadInt32();
			}
			PathNameOrigin = reader.ReadStringZeroTerm();
			PathName = FilenameUtils.FixFileIdentifier(PathNameOrigin);
		}

		public void Write(SerializedWriter writer)
		{
			if (HasAssetPath(writer.Generation))
			{
				writer.WriteStringZeroTerm(AssetPath);
			}
			if (HasHash(writer.Generation))
			{
				Guid.Write(writer);
				writer.Write((int)Type);
			}
			writer.WriteStringZeroTerm(PathNameOrigin);
		}

		public string GetFilePath()
		{
			if (Type == AssetType.Meta)
			{
				return Guid.ToString();
			}
			return PathName;
		}

		public override string? ToString()
		{
			if (Type == AssetType.Meta)
			{
				return Guid.ToString();
			}
			return PathNameOrigin ?? base.ToString();
		}

		/// <summary>
		/// File path without such prefixes as archive:/directory/fileName
		/// </summary>
		public string PathName { get; set; }

		/// <summary>
		/// Virtual asset path. Used for cached files, otherwise it's empty.
		/// The file with that path usually doesn't exist, so it's probably an alias.
		/// </summary>
		public string AssetPath { get; set; }
		/// <summary>
		/// The type of the file
		/// </summary>
		public AssetType Type { get; set; }
		/// <summary>
		/// Actual file path. This path is relative to the path of the current file.
		/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
		/// </summary>
		public string PathNameOrigin { get; set; }

		public UnityGUID Guid;
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/LocalSerializedObjectIdentifier.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	public struct LocalSerializedObjectIdentifier : ISerializedReadable, ISerializedWritable
	{
		public void Read(SerializedReader reader)
		{
			LocalSerializedFileIndex = reader.ReadInt32();
			if (ObjectInfo.IsLongID(reader.Generation))
			{
				reader.AlignStream();
				LocalIdentifierInFile = reader.ReadInt64();
			}
			else
			{
				LocalIdentifierInFile = reader.ReadInt32();
			}
		}

		public void Write(SerializedWriter writer)
		{
			writer.Write(LocalSerializedFileIndex);
			if (ObjectInfo.IsLongID(writer.Generation))
			{
				writer.AlignStream();
				writer.Write(LocalIdentifierInFile);
			}
			else
			{
				writer.Write((int)LocalIdentifierInFile);
			}
		}

		public override string ToString()
		{
			return $"[{LocalSerializedFileIndex}, {LocalIdentifierInFile}]";
		}

		public int LocalSerializedFileIndex { get; set; }
		public long LocalIdentifierInFile { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/ObjectInfo.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	/// <summary>
	/// Contains information for a block of raw serialized object data.
	/// </summary>
	public sealed class ObjectInfo : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 5.0.0unk and greater
		/// </summary>
		public static bool IsLongID(FormatVersion generation) => generation >= FormatVersion.Unknown_14;
		/// <summary>
		/// Less than 5.5.0
		/// </summary>
		public static bool HasClassID(FormatVersion generation) => generation < FormatVersion.RefactoredClassId;
		/// <summary>
		/// Less than 5.0.0unk
		/// </summary>
		public static bool HasIsDestroyed(FormatVersion generation) => generation < FormatVersion.HasScriptTypeIndex;
		/// <summary>
		/// 5.0.0unk to 5.5.0unk exclusive
		/// </summary>
		public static bool HasScriptID(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex && generation < FormatVersion.RefactorTypeData;
		/// <summary>
		/// 5.0.1 to 5.5.0unk exclusive
		/// </summary>
		public static bool HasStripped(FormatVersion generation) => generation >= FormatVersion.SupportsStrippedObject && generation < FormatVersion.RefactorTypeData;
		/// <summary>
		/// 2020.1.0 and greater / Format Version 22 +
		/// </summary>
		public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

		public void Read(SerializedReader reader)
		{
			if (IsLongID(reader.Generation))
			{
				reader.AlignStream();
				FileID = reader.ReadInt64();
			}
			else
			{
				FileID = reader.ReadInt32();
			}

			if (HasLargeFilesSupport(reader.Generation))
			{
				ByteStart = reader.ReadInt64();
			}
			else
			{
				ByteStart = reader.ReadUInt32();
			}

			ByteSize = reader.ReadInt32();
			TypeID = reader.ReadInt32();
			if (HasClassID(reader.Generation))
			{
				ClassID = (ClassIDType)reader.ReadInt16();
			}
			if (HasScriptID(reader.Generation))
			{
				ScriptTypeIndex = reader.ReadInt16();
			}
			else if (HasIsDestroyed(reader.Generation))
			{
				IsDestroyed = reader.ReadUInt16();
			}
			if (HasStripped(reader.Generation))
			{
				Stripped = reader.ReadBoolean();
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (IsLongID(writer.Generation))
			{
				writer.AlignStream();
				writer.Write(FileID);
			}
			else
			{
				writer.Write((int)FileID);
			}

			if (HasLargeFilesSupport(writer.Generation))
			{
				writer.Write(ByteStart);
			}
			else
			{
				writer.Write((uint)ByteStart);
			}

			writer.Write(ByteSize);
			writer.Write(TypeID);
			if (HasClassID(writer.Generation))
			{
				writer.Write((short)ClassID);
			}
			if (HasScriptID(writer.Generation))
			{
				writer.Write(ScriptTypeIndex);
			}
			else if (HasIsDestroyed(writer.Generation))
			{
				writer.Write(IsDestroyed);
			}
			if (HasStripped(writer.Generation))
			{
				writer.Write(Stripped);
			}
		}

		public override string ToString()
		{
			return $"{ClassID}[{FileID}]";
		}

		/// <summary>
		/// ObjectID<br/>
		/// Unique ID that identifies the object. Can be used as a key for a map.
		/// </summary>
		public long FileID { get; set; }
		/// <summary>
		/// Offset to the object data.<br/>
		/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
		/// </summary>
		public long ByteStart { get; set; }
		/// <summary>
		/// Size of the object data.
		/// </summary>
		public int ByteSize { get; set; }
		/// <summary>
		/// New versions:<br/>
		///		Type index in <see cref="SerializedFileMetadata.Types"/> array<br/>
		/// Old versions:<br/>
		///		Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/><br/>
		///		Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
		/// </summary>
		public int TypeID { get; set; }
		/// <summary>
		/// Class ID of the object.
		/// </summary>
		public ClassIDType ClassID { get; set; }
		public ushort IsDestroyed { get; set; }
		public short ScriptTypeIndex { get; set; }
		public bool Stripped { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/SerializedFileHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	/// <summary>
	/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
	/// </summary>
	public sealed class SerializedFileHeader
	{
		/// <summary>
		/// Size of the metadata parts of the file
		/// </summary>
		public long MetadataSize { get; set; }
		/// <summary>
		/// Size of the whole file
		/// </summary>
		public long FileSize { get; set; }
		/// <summary>
		/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update
		/// </summary>
		public FormatVersion Version { get; set; }
		/// <summary>
		/// Offset to the serialized object data. It starts at the data for the first object
		/// </summary>
		public long DataOffset { get; set; }
		/// <summary>
		/// Presumably controls the byte order of the data structure. This field is normally set to 0, which may indicate a little endian byte order.
		/// </summary>
		public bool Endianess { get; set; }

		public const int HeaderMinSize = 16;

		public const int MetadataMinSize = 16;


		/// <summary>
		/// 3.5.0 and greater / Format Version 9 +
		/// </summary>
		public static bool HasEndianess(FormatVersion generation) => generation >= FormatVersion.Unknown_9;

		/// <summary>
		/// 2020.1.0 and greater / Format Version 22 +
		/// </summary>
		public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

		public static bool IsSerializedFileHeader(EndianReader reader, long fileSize)
		{
			long initialPosition = reader.BaseStream.Position;

			//Sanity check that there is enough room here first.
			if (reader.BaseStream.Position + HeaderMinSize > reader.BaseStream.Length)
			{
				return false;
			}

			//Pre-22 format: 
			// - Metadata Size
			// - File Size
			// - Generation
			int metadataSize = reader.ReadInt32();
			ulong headerDefinedFileSize = reader.ReadUInt32();

			// Read generation first, the format changed hugely in gen 22 (unity 2020)
			// Generation is always at [base + 0x8]
			int generation = reader.ReadInt32();
			if (!Enum.IsDefined(typeof(FormatVersion), generation))
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			reader.BaseStream.Position = initialPosition;
			if (generation >= 22)
			{
				//22 Format:
				//First known value is at 0x14, and is metadata size as a 32-bit integer.
				//Then the file size as a 64-bit integer.
				reader.BaseStream.Position = initialPosition + 0x14;
				metadataSize = reader.ReadInt32();
				headerDefinedFileSize = reader.ReadUInt64();
			}

			if (metadataSize < MetadataMinSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			if (headerDefinedFileSize < HeaderMinSize + MetadataMinSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			if (fileSize < 0 || headerDefinedFileSize != (ulong)fileSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			reader.BaseStream.Position = initialPosition;
			return true;
		}

		public void Read(EndianReader reader)
		{
			//For gen 22+ these will be zero
			MetadataSize = reader.ReadInt32();
			FileSize = reader.ReadUInt32();

			//Read generation
			Version = (FormatVersion)reader.ReadInt32();

			//For gen 22+ these will be zero
			DataOffset = reader.ReadUInt32();

			if (HasEndianess(Version))
			{
				Endianess = reader.ReadBoolean();
				reader.AlignStream();
			}
			if (HasLargeFilesSupport(Version))
			{
				MetadataSize = reader.ReadUInt32();
				FileSize = reader.ReadInt64();
				DataOffset = reader.ReadInt64();
				reader.ReadInt64(); // unknown
			}

			if (MetadataSize <= 0)
			{
				throw new Exception($"Invalid metadata size {MetadataSize}");
			}

			if (!Enum.IsDefined(typeof(FormatVersion), Version))
			{
				throw new Exception($"Unsupported file generation {Version}'");
			}
		}

		public void Write(EndianWriter writer)
		{
			//0x00
			if (HasLargeFilesSupport(Version))
			{
				writer.Write(0);
				writer.Write(0);
			}
			else
			{
				writer.Write((int)MetadataSize);
				writer.Write((uint)FileSize);
			}

			//0x08
			writer.Write((int)Version);

			//0x0c
			if (HasLargeFilesSupport(Version))
			{
				writer.Write(0);
			}
			else
			{
				writer.Write((uint)DataOffset);
			}

			//0x10
			if (HasEndianess(Version))
			{
				writer.Write(Endianess);
				writer.AlignStream();
			}

			//0x14
			if (HasLargeFilesSupport(Version))
			{
				writer.Write((uint)MetadataSize);
				writer.Write((long)FileSize);
				writer.Write((long)DataOffset);
				writer.Write((long)0);
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/SerializedFileMetadata.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	public sealed class SerializedFileMetadata
	{
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasEndian(FormatVersion generation) => generation < FormatVersion.Unknown_9;
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool IsMetadataAtTheEnd(FormatVersion generation) => generation < FormatVersion.Unknown_9;

		/// <summary>
		/// 3.0.0b and greater
		/// </summary>
		public static bool HasSignature(FormatVersion generation) => generation >= FormatVersion.Unknown_7;
		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasPlatform(FormatVersion generation) => generation >= FormatVersion.Unknown_8;
		/// <summary>
		/// 5.0.0Unk2 and greater
		/// </summary>
		public static bool HasEnableTypeTree(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
		/// <summary>
		/// 3.0.0b to 4.x.x
		/// </summary>
		public static bool HasLongFileID(FormatVersion generation) => generation >= FormatVersion.Unknown_7 && generation < FormatVersion.Unknown_14;
		/// <summary>
		/// 5.0.0Unk0 and greater
		/// </summary>
		public static bool HasScriptTypes(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex;
		/// <summary>
		/// 1.2.0 and greater
		/// </summary>
		public static bool HasUserInformation(FormatVersion generation) => generation >= FormatVersion.Unknown_5;
		/// <summary>
		/// 2019.2 and greater
		/// </summary>
		public static bool HasRefTypes(FormatVersion generation) => generation >= FormatVersion.SupportsRefObject;

		public void Read(Stream stream, SerializedFileHeader header)
		{
			bool swapEndianess = header.Endianess;
			if (HasEndian(header.Version))
			{
				SwapEndianess = stream.ReadByte() != 0;
				swapEndianess = SwapEndianess;
			}
			EndianType endianess = swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
			using SerializedReader reader = new SerializedReader(stream, endianess, header.Version);
			Read(reader);
		}

		public void Write(Stream stream, SerializedFileHeader header)
		{
			bool swapEndianess = header.Endianess;
			if (HasEndian(header.Version))
			{
				stream.WriteByte((byte)(SwapEndianess ? 1 : 0));
				swapEndianess = SwapEndianess;
			}
			EndianType endianess = swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
			using SerializedWriter writer = new SerializedWriter(stream, endianess, header.Version);
			Write(writer);
		}

		private void Read(SerializedReader reader)
		{
			if (HasSignature(reader.Generation))
			{
				string signature = reader.ReadStringZeroTerm();
				UnityVersion = UnityVersion.Parse(signature);
			}
			if (HasPlatform(reader.Generation))
			{
				TargetPlatform = (BuildTarget)reader.ReadUInt32();
			}

			if (HasEnableTypeTree(reader.Generation))
			{
				EnableTypeTree = reader.ReadBoolean();
			}
			else
			{
				EnableTypeTree = true;
			}

			Types = reader.ReadSerializedTypeArray<SerializedType>(EnableTypeTree);

			if (HasLongFileID(reader.Generation))
			{
				LongFileID = reader.ReadUInt32();
			}

#warning TODO: pass LongFileID to ObjectInfo
			Object = reader.ReadSerializedArray<ObjectInfo>();

			if (HasScriptTypes(reader.Generation))
			{
				ScriptTypes = reader.ReadSerializedArray<LocalSerializedObjectIdentifier>();
			}

			Externals = reader.ReadSerializedArray<FileIdentifier>();

			if (HasRefTypes(reader.Generation))
			{
				RefTypes = reader.ReadSerializedTypeArray<SerializedTypeReference>(EnableTypeTree);
			}
			if (HasUserInformation(reader.Generation))
			{
				UserInformation = reader.ReadStringZeroTerm();
			}
		}

		private void Write(SerializedWriter writer)
		{
			if (HasSignature(writer.Generation))
			{
				writer.WriteStringZeroTerm(UnityVersion.ToString());
			}
			if (HasPlatform(writer.Generation))
			{
				writer.Write((uint)TargetPlatform);
			}
			if (HasEnableTypeTree(writer.Generation))
			{
				writer.Write(EnableTypeTree);
			}

			writer.WriteSerializedTypeArray(Types, EnableTypeTree);
			if (HasLongFileID(writer.Generation))
			{
				writer.Write(LongFileID);
			}

			writer.WriteSerializedArray(Object);
			if (HasScriptTypes(writer.Generation))
			{
				writer.WriteSerializedArray(ScriptTypes);
			}
			writer.WriteSerializedArray(Externals);
			if (HasRefTypes(writer.Generation))
			{
				writer.WriteSerializedTypeArray(RefTypes, EnableTypeTree);
			}
			if (HasUserInformation(writer.Generation))
			{
				writer.WriteStringZeroTerm(UserInformation);
			}
		}

		public UnityVersion UnityVersion { get; set; }
		public BuildTarget TargetPlatform { get; set; }
		public bool EnableTypeTree { get; set; }
		public SerializedType[] Types { get; set; } = Array.Empty<SerializedType>();
		/// <summary>
		/// Indicate that <see cref="ObjectInfo.FileID"/> is 8 bytes size<br/>
		/// Serialized files with this enabled field doesn't exist
		/// </summary>
		public uint LongFileID { get; set; }
		public bool SwapEndianess { get; set; }
		public ObjectInfo[] Object { get; set; } = Array.Empty<ObjectInfo>();
		public LocalSerializedObjectIdentifier[] ScriptTypes { get; set; } = Array.Empty<LocalSerializedObjectIdentifier>();
		public FileIdentifier[] Externals { get; set; } = Array.Empty<FileIdentifier>();
		public string UserInformation { get; set; } = "";
		public SerializedTypeReference[] RefTypes { get; set; } = Array.Empty<SerializedTypeReference>();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/SerializedType.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	public sealed class SerializedType : SerializedTypeBase
	{
		public int[] TypeDependencies { get; set; } = Array.Empty<int>();

		private static bool HasScriptID(FormatVersion generation, ClassIDType typeID)
		{
			//Temporary solution to #296
			return typeID == ClassIDType.MonoBehaviour;
			//Previous code:
			//(generation < FormatVersion.RefactoredClassId && typeID < 0)
			//|| (generation >= FormatVersion.RefactoredClassId && typeID == ClassIDType.MonoBehaviour);
		}

		public override void Read(SerializedReader reader, bool hasTypeTree)
		{
			base.Read(reader, hasTypeTree);

			if (HasHash(reader.Generation))
			{
				if (HasScriptID(reader.Generation, TypeID))
				{
					ScriptID.Read(reader);
				}
				OldTypeHash.Read(reader);
			}

			if (hasTypeTree)
			{
				OldType.Read(reader);
				if (HasTypeDependencies(reader.Generation))
				{
					TypeDependencies = reader.ReadInt32Array();
				}
			}
		}

		public override void Write(SerializedWriter writer, bool hasTypeTree)
		{
			base.Write(writer, hasTypeTree);

			if (HasHash(writer.Generation))
			{
				if (HasScriptID(writer.Generation, TypeID))
				{
					ScriptID.Write(writer);
				}
				OldTypeHash.Write(writer);
			}

			if (hasTypeTree)
			{
				OldType.Write(writer);
				if (HasTypeDependencies(writer.Generation))
				{
					writer.WriteArray(TypeDependencies);
				}
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/SerializedTypeBase.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	public abstract class SerializedTypeBase
	{
		public ClassIDType TypeID { get; set; }
		public bool IsStrippedType { get; set; }
		/// <summary>
		/// For <see cref="ClassIDType.MonoBehaviour"/> specifies script type
		/// </summary>
		public short ScriptTypeIndex { get; set; }
		/// <summary>
		/// The type of the class.
		/// </summary>
		public TypeTree.TypeTree OldType { get; } = new();
		public Hash128 ScriptID { get; } = new();
		public Hash128 OldTypeHash { get; } = new();

		public virtual void Read(SerializedReader reader, bool hasTypeTree)
		{
			if (HasScriptTypeIndex(reader.Generation))
			{
				TypeID = (ClassIDType)reader.ReadInt32();
			}
			else
			{
				OriginalTypeID = reader.ReadInt32();
			}
			if (HasIsStrippedType(reader.Generation))
			{
				IsStrippedType = reader.ReadBoolean();
			}
			if (HasScriptTypeIndex(reader.Generation))
			{
				ScriptTypeIndex = reader.ReadInt16();
			}
		}

		public virtual void Write(SerializedWriter writer, bool hasTypeTree)
		{
			if (HasScriptTypeIndex(writer.Generation))
			{
				writer.Write((int)TypeID);
			}
			else
			{
				writer.Write(OriginalTypeID);
			}
			if (HasIsStrippedType(writer.Generation))
			{
				writer.Write(IsStrippedType);
			}
			if (HasScriptTypeIndex(writer.Generation))
			{
				writer.Write(ScriptTypeIndex);
			}
		}

		public override string ToString()
		{
			return TypeID.ToString();
		}

		/// <summary>
		/// For versions less than 17, it specifies <see cref="TypeID"/> or -<see cref="ScriptTypeIndex"/> -1 for MonoBehaviour
		/// </summary>
		public int OriginalTypeID
		{
			get
			{
				return TypeID == ClassIDType.MonoBehaviour ? -(ScriptTypeIndex + 1) : (int)TypeID;
			}
			set
			{
				if (value >= 0)
				{
					TypeID = (ClassIDType)value;
					ScriptTypeIndex = -1;
				}
				else
				{
					TypeID = ClassIDType.MonoBehaviour;
					ScriptTypeIndex = (short)(-value - 1);
				}
			}
		}

		/// <summary>
		/// 5.5.0a and greater, ie format version 16+
		/// </summary>
		public static bool HasIsStrippedType(FormatVersion generation) => generation >= FormatVersion.RefactoredClassId;
		/// <summary>
		/// 5.5.0 and greater, ie format version 17+
		/// </summary>
		public static bool HasScriptTypeIndex(FormatVersion generation) => generation >= FormatVersion.RefactorTypeData;
		/// <summary>
		/// 5.0.0unk2 and greater, ie format version 13+
		/// </summary>
		public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
		/// <summary>
		/// 2019.3 and greater, ie format version 21+
		/// </summary>
		public static bool HasTypeDependencies(FormatVersion generation) => generation >= FormatVersion.StoresTypeDependencies;
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/SerializedTypeReference.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	public sealed class SerializedTypeReference : SerializedTypeBase
	{
		public string ClassName { get; set; } = "";
		public string NameSpace { get; set; } = "";
		public string AsmName { get; set; } = "";

		public override void Read(SerializedReader reader, bool hasTypeTree)
		{
			base.Read(reader, hasTypeTree);

			if (HasHash(reader.Generation))
			{
				if (HasScriptID(ScriptTypeIndex, reader.Generation, TypeID))
				{
					ScriptID.Read(reader);
				}
				OldTypeHash.Read(reader);
			}

			if (hasTypeTree)
			{
				OldType.Read(reader);
				if (HasTypeDependencies(reader.Generation))
				{
					ClassName = reader.ReadStringZeroTerm();
					NameSpace = reader.ReadStringZeroTerm();
					AsmName = reader.ReadStringZeroTerm();
				}
			}
		}

		public override void Write(SerializedWriter writer, bool hasTypeTree)
		{
			base.Write(writer, hasTypeTree);

			if (HasHash(writer.Generation))
			{
				if (HasScriptID(ScriptTypeIndex, writer.Generation, TypeID))
				{
					ScriptID.Write(writer);
				}
				OldTypeHash.Write(writer);
			}

			if (hasTypeTree)
			{
				OldType.Write(writer);
				if (HasTypeDependencies(writer.Generation))
				{
					writer.WriteStringZeroTerm(ClassName);
					writer.WriteStringZeroTerm(NameSpace);
					writer.WriteStringZeroTerm(AsmName);
				}
			}
		}

		private static bool HasScriptID(short scriptTypeIndex, FormatVersion generation, ClassIDType typeID)
		{
			//Temporary solution to #296
			return (scriptTypeIndex >= 0) || typeID == ClassIDType.MonoBehaviour;
			//Previous code:
			//(scriptTypeIndex >= 0)
			//|| (generation < FormatVersion.RefactoredClassId && typeID < 0)
			//|| (generation >= FormatVersion.RefactoredClassId && typeID == ClassIDType.MonoBehaviour);
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/TransferMetaFlags.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser
{
	[Flags]
	public enum TransferMetaFlags : uint
	{
		NoTransferFlags = 0x0,
		HideInEditor = 0x1,
		Unknown1 = 0x2,
		Unknown2 = 0x4,
		Unknown3 = 0x8,
		NotEditable = 0x10,
		Unknown5 = 0x20,
		StrongPPtr = 0x40,
		Unknown7 = 0x80,
		TreatIntegerValueAsBoolean = 0x100,
		Unknown9 = 0x200,
		Unknown10 = 0x400,
		SimpleEditor = 0x800,
		DebugProperty = 0x1000,
		Unknown13 = 0x2000,
		AlignBytes = 0x4000,
		AnyChildUsesAlignBytes = 0x8000,
		IgnoreWithInspectorUndo = 0x10000,
		Unknown17 = 0x20000,
		EditorDisplaysCharacterMap = 0x40000,
		IgnoreInMetaFiles = 0x80000,
		TransferAsArrayEntryNameInMetaFiles = 0x100000,
		TransferUsingFlowMappingStyle = 0x200000,
		GenerateBitwiseDifferences = 0x400000,
		DontAnimate = 0x800000,
		TransferHex64 = 0x1000000,
		CharPropertyMask = 0x2000000,
		DontValidateUTF8 = 0x4000000,
		FixedBuffer = 0x8000000,
		DisallowSerializedPropertyModification = 0x10000000,
		Unknown29 = 0x20000000,
		Unknown30 = 0x40000000,
		Unknown31 = 0x80000000,
	}

	public static class TransferMetaFlagsExtensions
	{
		public static bool IsHideInEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.HideInEditor) != 0;
		public static bool IsNotEditable(this TransferMetaFlags _this) => (_this & TransferMetaFlags.NotEditable) != 0;
		public static bool IsStrongPPtr(this TransferMetaFlags _this) => (_this & TransferMetaFlags.StrongPPtr) != 0;
		public static bool IsTreatIntegerValueAsBoolean(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TreatIntegerValueAsBoolean) != 0;
		public static bool IsSimpleEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.SimpleEditor) != 0;
		public static bool IsDebugProperty(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DebugProperty) != 0;
		public static bool IsAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AlignBytes) != 0;
		public static bool IsAnyChildUsesAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AnyChildUsesAlignBytes) != 0;
		public static bool IsIgnoreWithInspectorUndo(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreWithInspectorUndo) != 0;
		public static bool IsEditorDisplaysCharacterMap(this TransferMetaFlags _this) => (_this & TransferMetaFlags.EditorDisplaysCharacterMap) != 0;
		public static bool IsIgnoreInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreInMetaFiles) != 0;
		public static bool IsTransferAsArrayEntryNameInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles) != 0;
		public static bool IsTransferUsingFlowMappingStyle(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferUsingFlowMappingStyle) != 0;
		public static bool IsGenerateBitwiseDifferences(this TransferMetaFlags _this) => (_this & TransferMetaFlags.GenerateBitwiseDifferences) != 0;
		public static bool IsDontAnimate(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontAnimate) != 0;
		public static bool IsTransferHex64(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferHex64) != 0;
		public static bool IsCharPropertyMask(this TransferMetaFlags _this) => (_this & TransferMetaFlags.CharPropertyMask) != 0;
		public static bool IsDontValidateUTF8(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontValidateUTF8) != 0;
		public static bool IsFixedBuffer(this TransferMetaFlags _this) => (_this & TransferMetaFlags.FixedBuffer) != 0;
		public static bool IsDisallowSerializedPropertyModification(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DisallowSerializedPropertyModification) != 0;
		public static IEnumerable<string> Split(this TransferMetaFlags flags)
		{
			if (flags == TransferMetaFlags.NoTransferFlags)
			{
				yield return nameof(TransferMetaFlags.NoTransferFlags);
			}
			else
			{
				if (flags.HasFlag(TransferMetaFlags.HideInEditor))
				{
					yield return nameof(TransferMetaFlags.HideInEditor);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown1))
				{
					yield return nameof(TransferMetaFlags.Unknown1);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown2))
				{
					yield return nameof(TransferMetaFlags.Unknown2);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown3))
				{
					yield return nameof(TransferMetaFlags.Unknown3);
				}

				if (flags.HasFlag(TransferMetaFlags.NotEditable))
				{
					yield return nameof(TransferMetaFlags.NotEditable);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown5))
				{
					yield return nameof(TransferMetaFlags.Unknown5);
				}

				if (flags.HasFlag(TransferMetaFlags.StrongPPtr))
				{
					yield return nameof(TransferMetaFlags.StrongPPtr);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown7))
				{
					yield return nameof(TransferMetaFlags.Unknown7);
				}

				if (flags.HasFlag(TransferMetaFlags.TreatIntegerValueAsBoolean))
				{
					yield return nameof(TransferMetaFlags.TreatIntegerValueAsBoolean);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown9))
				{
					yield return nameof(TransferMetaFlags.Unknown9);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown10))
				{
					yield return nameof(TransferMetaFlags.Unknown10);
				}

				if (flags.HasFlag(TransferMetaFlags.SimpleEditor))
				{
					yield return nameof(TransferMetaFlags.SimpleEditor);
				}

				if (flags.HasFlag(TransferMetaFlags.DebugProperty))
				{
					yield return nameof(TransferMetaFlags.DebugProperty);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown13))
				{
					yield return nameof(TransferMetaFlags.Unknown13);
				}

				if (flags.HasFlag(TransferMetaFlags.AlignBytes))
				{
					yield return nameof(TransferMetaFlags.AlignBytes);
				}

				if (flags.HasFlag(TransferMetaFlags.AnyChildUsesAlignBytes))
				{
					yield return nameof(TransferMetaFlags.AnyChildUsesAlignBytes);
				}

				if (flags.HasFlag(TransferMetaFlags.IgnoreWithInspectorUndo))
				{
					yield return nameof(TransferMetaFlags.IgnoreWithInspectorUndo);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown17))
				{
					yield return nameof(TransferMetaFlags.Unknown17);
				}

				if (flags.HasFlag(TransferMetaFlags.EditorDisplaysCharacterMap))
				{
					yield return nameof(TransferMetaFlags.EditorDisplaysCharacterMap);
				}

				if (flags.HasFlag(TransferMetaFlags.IgnoreInMetaFiles))
				{
					yield return nameof(TransferMetaFlags.IgnoreInMetaFiles);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles))
				{
					yield return nameof(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferUsingFlowMappingStyle))
				{
					yield return nameof(TransferMetaFlags.TransferUsingFlowMappingStyle);
				}

				if (flags.HasFlag(TransferMetaFlags.GenerateBitwiseDifferences))
				{
					yield return nameof(TransferMetaFlags.GenerateBitwiseDifferences);
				}

				if (flags.HasFlag(TransferMetaFlags.DontAnimate))
				{
					yield return nameof(TransferMetaFlags.DontAnimate);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferHex64))
				{
					yield return nameof(TransferMetaFlags.TransferHex64);
				}

				if (flags.HasFlag(TransferMetaFlags.CharPropertyMask))
				{
					yield return nameof(TransferMetaFlags.CharPropertyMask);
				}

				if (flags.HasFlag(TransferMetaFlags.DontValidateUTF8))
				{
					yield return nameof(TransferMetaFlags.DontValidateUTF8);
				}

				if (flags.HasFlag(TransferMetaFlags.FixedBuffer))
				{
					yield return nameof(TransferMetaFlags.FixedBuffer);
				}

				if (flags.HasFlag(TransferMetaFlags.DisallowSerializedPropertyModification))
				{
					yield return nameof(TransferMetaFlags.DisallowSerializedPropertyModification);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown29))
				{
					yield return nameof(TransferMetaFlags.Unknown29);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown30))
				{
					yield return nameof(TransferMetaFlags.Unknown30);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown31))
				{
					yield return nameof(TransferMetaFlags.Unknown31);
				}
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/TypeTree/CommonString.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree
{
	public static class CommonString
	{
		public static readonly Dictionary<uint, string> StringBuffer = new Dictionary<uint, string>
		{
			{0, "AABB"},
			{5, "AnimationClip"},
			{19, "AnimationCurve"},
			{34, "AnimationState"},
			{49, "Array"},
			{55, "Base"},
			{60, "BitField"},
			{69, "bitset"},
			{76, "bool"},
			{81, "char"},
			{86, "ColorRGBA"},
			{96, "Component"},
			{106, "data"},
			{111, "deque"},
			{117, "double"},
			{124, "dynamic_array"},
			{138, "FastPropertyName"},
			{155, "first"},
			{161, "float"},
			{167, "Font"},
			{172, "GameObject"},
			{183, "Generic Mono"},
			{196, "GradientNEW"},
			{208, "GUID"},
			{213, "GUIStyle"},
			{222, "int"},
			{226, "list"},
			{231, "long long"},
			{241, "map"},
			{245, "Matrix4x4f"},
			{256, "MdFour"},
			{263, "MonoBehaviour"},
			{277, "MonoScript"},
			{288, "m_ByteSize"},
			{299, "m_Curve"},
			{307, "m_EditorClassIdentifier"},
			{331, "m_EditorHideFlags"},
			{349, "m_Enabled"},
			{359, "m_ExtensionPtr"},
			{374, "m_GameObject"},
			{387, "m_Index"},
			{395, "m_IsArray"},
			{405, "m_IsStatic"},
			{416, "m_MetaFlag"},
			{427, "m_Name"},
			{434, "m_ObjectHideFlags"},
			{452, "m_PrefabInternal"},
			{469, "m_PrefabParentObject"},
			{490, "m_Script"},
			{499, "m_StaticEditorFlags"},
			{519, "m_Type"},
			{526, "m_Version"},
			{536, "Object"},
			{543, "pair"},
			{548, "PPtr<Component>"},
			{564, "PPtr<GameObject>"},
			{581, "PPtr<Material>"},
			{596, "PPtr<MonoBehaviour>"},
			{616, "PPtr<MonoScript>"},
			{633, "PPtr<Object>"},
			{646, "PPtr<Prefab>"},
			{659, "PPtr<Sprite>"},
			{672, "PPtr<TextAsset>"},
			{688, "PPtr<Texture>"},
			{702, "PPtr<Texture2D>"},
			{718, "PPtr<Transform>"},
			{734, "Prefab"},
			{741, "Quaternionf"},
			{753, "Rectf"},
			{759, "RectInt"},
			{767, "RectOffset"},
			{778, "second"},
			{785, "set"},
			{789, "short"},
			{795, "size"},
			{800, "SInt16"},
			{807, "SInt32"},
			{814, "SInt64"},
			{821, "SInt8"},
			{827, "staticvector"},
			{840, "string"},
			{847, "TextAsset"},
			{857, "TextMesh"},
			{866, "Texture"},
			{874, "Texture2D"},
			{884, "Transform"},
			{894, "TypelessData"},
			{907, "UInt16"},
			{914, "UInt32"},
			{921, "UInt64"},
			{928, "UInt8"},
			{934, "unsigned int"},
			{947, "unsigned long long"},
			{966, "unsigned short"},
			{981, "vector"},
			{988, "Vector2f"},
			{997, "Vector3f"},
			{1006, "Vector4f"},
			{1015, "m_ScriptingClassIdentifier"},
			{1042, "Gradient"},
			{1051, "Type*"},
			{1057, "int2_storage"},
			{1070, "int3_storage"},
			{1083, "BoundsInt"},
			{1093, "m_CorrespondingSourceObject"},
			{1121, "m_PrefabInstance"},
			{1138, "m_PrefabAsset"},
			{1152, "FileSize"},
			{1161, "Hash128"}
		};
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/TypeTree/TypeTree.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using AssetRipper.IO.Endian;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree
{
	public sealed class TypeTree : ISerializedReadable, ISerializedWritable
	{
		public void Read(SerializedReader reader)
		{
			if (TypeTreeNode.IsFormat5(reader.Generation))
			{
				IsFormat5 = true;

				int nodesCount = reader.ReadInt32();
				if (nodesCount < 0)
				{
					throw new InvalidDataException($"Node count cannot be negative: {nodesCount}");
				}

				int stringBufferSize = reader.ReadInt32();
				if (stringBufferSize < 0)
				{
					throw new InvalidDataException($"String buffer size cannot be negative: {stringBufferSize}");
				}

				Nodes.Clear();
				Nodes.Capacity = nodesCount;
				for (int i = 0; i < nodesCount; i++)
				{
					TypeTreeNode node = new TypeTreeNode();
					node.Read(reader);
					Nodes.Add(node);
				}
				if (stringBufferSize == 0)
				{
					StringBuffer = Array.Empty<byte>();
				}
				else
				{
					StringBuffer = new byte[stringBufferSize];
					reader.Read(StringBuffer, 0, StringBuffer.Length);
				}
			}
			else
			{
				IsFormat5 = false;
				Nodes.Clear();
				ReadTreeNode(reader, Nodes, 0);
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (TypeTreeNode.IsFormat5(writer.Generation))
			{
				writer.Write(Nodes.Count);
				writer.Write(StringBuffer.Length);
				foreach (TypeTreeNode node in Nodes)
				{
					node.Write(writer);
				}
				writer.Write(StringBuffer, 0, StringBuffer.Length);
			}
			else
			{
				int index = 0;
				WriteTreeNode(writer, ref index);
			}
		}

		private static void ReadTreeNode(SerializedReader reader, ICollection<TypeTreeNode> nodes, byte depth)
		{
			TypeTreeNode node = new TypeTreeNode();
			node.Read(reader);
			node.Level = depth;
			nodes.Add(node);

			int childCount = reader.ReadInt32();
			for (int i = 0; i < childCount; i++)
			{
				ReadTreeNode(reader, nodes, (byte)(depth + 1));
			}
		}

		private void WriteTreeNode(SerializedWriter writer, ref int index)
		{
			Nodes[index].Write(writer);
			int childCount = GetChildCount(index);
			writer.Write(childCount);
			index++;
			for (int i = 0; i < childCount; i++)
			{
				WriteTreeNode(writer, ref index);
			}
		}

		public override string? ToString()
		{
			if (Nodes == null)
			{
				return base.ToString();
			}

			return Nodes[0].ToString();
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			if (Nodes != null)
			{
				foreach (TypeTreeNode node in Nodes)
				{
					node.ToString(sb).AppendLine();
				}
			}
			return sb;
		}

		private int GetChildCount(int index)
		{
			int count = 0;
			int depth = Nodes[index].Level + 1;
			for (int i = index + 1; i < Nodes.Count; i++)
			{
				int nodeDepth = Nodes[i].Level;
				if (nodeDepth < depth)
				{
					break;
				}
				if (nodeDepth == depth)
				{
					count++;
				}
			}
			return count;
		}

		public string Dump
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				ToString(sb);
				return sb.ToString();
			}
		}

		public void MaybeSetNamesFromBuffer()
		{
			if (IsFormat5)
			{
				Dictionary<uint, string> customTypes = new Dictionary<uint, string>();
				using (MemoryStream stream = new MemoryStream(StringBuffer))
				{
					using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
					while (stream.Position < stream.Length)
					{
						uint position = (uint)stream.Position;
						string name = reader.ReadStringZeroTerm();
						customTypes.Add(position, name);
					}
				}

				foreach (TypeTreeNode node in Nodes)
				{
					node.Type = GetTypeName(customTypes, node.TypeStrOffset);
					node.Name = GetTypeName(customTypes, node.NameStrOffset);
				}
			}
		}

		private static string GetTypeName(Dictionary<uint, string> customTypes, uint value)
		{
			bool isCustomType = (value & 0x80000000) == 0;
			if (isCustomType)
			{
				return customTypes[value];
			}
			else
			{
				uint offset = value & ~0x80000000;
				if (CommonString.StringBuffer.TryGetValue(offset, out string? nodeTypeName))
				{
					return nodeTypeName;
				}
				else
				{
					throw new Exception($"Unsupported asset class type name '{offset}''");
				}
			}
		}

		public List<TypeTreeNode> Nodes { get; } = new();
		public byte[] StringBuffer { get; set; } = Array.Empty<byte>();
		/// <summary>
		/// 5.0.0a1 and greater<br/>
		/// Generation 10
		/// </summary>
		private bool IsFormat5 { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/Parser/TypeTree/TypeTreeNode.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles.IO;
using System.Text;

namespace AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree
{
	public class TypeTreeNode : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 5.0.0a1 and greater<br/>
		/// Generation 10
		/// </summary>
		public static bool IsFormat5(FormatVersion generation) => generation >= FormatVersion.Unknown_10;
		/// <summary>
		/// 2019.1 and greater<br/>
		/// Generation 19
		/// </summary>
		public static bool HasRefTypeHash(FormatVersion generation) => generation >= FormatVersion.TypeTreeNodeWithTypeFlags;

		public TypeTreeNode() { }

		public TypeTreeNode(string type, string name, int level, bool align)
		{
			Type = type;
			Name = name;
			Level = (byte)level;
			MetaFlag = align ? TransferMetaFlags.AlignBytes : TransferMetaFlags.NoTransferFlags;
		}

		public TypeTreeNode(string type, string name, int level, int byteSize, int index, int version, int typeFlags, TransferMetaFlags metaFlag)
		{
			Type = type;
			Name = name;
			Level = (byte)level;
			ByteSize = byteSize;
			Index = index;
			Version = version;
			TypeFlags = typeFlags;
			MetaFlag = metaFlag;
		}

		public void Read(SerializedReader reader)
		{
			if (IsFormat5(reader.Generation))
			{
				Version = reader.ReadUInt16();
				Level = reader.ReadByte();
				TypeFlags = reader.ReadByte();
				TypeStrOffset = reader.ReadUInt32();
				NameStrOffset = reader.ReadUInt32();
				ByteSize = reader.ReadInt32();
				Index = reader.ReadInt32();
				MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
				if (HasRefTypeHash(reader.Generation))
				{
					RefTypeHash = reader.ReadUInt64();
				}
			}
			else
			{
				Type = reader.ReadStringZeroTerm();
				Name = reader.ReadStringZeroTerm();
				ByteSize = reader.ReadInt32();
				Index = reader.ReadInt32();
				TypeFlags = reader.ReadInt32();
				Version = reader.ReadInt32();
				MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (IsFormat5(writer.Generation))
			{
				writer.Write((ushort)Version);
				writer.Write((byte)Level);
				writer.Write((byte)TypeFlags);
				writer.Write(TypeStrOffset);
				writer.Write(NameStrOffset);
				writer.Write(ByteSize);
				writer.Write(Index);
				writer.Write((uint)MetaFlag);
				if (HasRefTypeHash(writer.Generation))
				{
					writer.Write(RefTypeHash);
				}
			}
			else
			{
				writer.WriteStringZeroTerm(Type);
				writer.WriteStringZeroTerm(Name);
				writer.Write(ByteSize);
				writer.Write(Index);
				writer.Write(TypeFlags);
				writer.Write(Version);
				writer.Write((uint)MetaFlag);
			}
		}

		public override string? ToString()
		{
			if (Type == null)
			{
				return base.ToString();
			}
			else
			{
				return $"{Type} {Name}";
			}
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			sb.Append('\t', Level).Append(Type).Append(' ').Append(Name);
			sb.AppendFormat(" // ByteSize{0}{1:x}{2}, Index{3}{4:x}{5}, Version{6}{7:x}{8}, IsArray{{{9}}}, MetaFlag{10}{11:x}{12}",
					"{", ByteSize, "}",
					"{", Index, "}",
					"{", Version, "}",
					TypeFlags,
					"{", (uint)MetaFlag, "}");
			return sb;
		}

		/// <summary>
		/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.<br/>
		/// Equal to serializedVersion in Yaml format files
		/// </summary>
		public int Version { get; set; }
		/// <summary>
		/// Depth of current type relative to root
		/// </summary>
		public byte Level { get; set; }
		/// <summary>
		/// Array flag, set to 1 if type is "Array" or "TypelessData".
		/// </summary>
		public int TypeFlags { get; set; }
		/// <summary>
		/// Type offset in <see cref="TypeTree.StringBuffer"/>
		/// </summary>
		public uint TypeStrOffset { get; set; }
		/// <summary>
		/// Name offset in <see cref="TypeTree.StringBuffer"/>
		/// </summary>
		public uint NameStrOffset { get; set; }
		/// <summary>
		/// Name of the data type. This can be the name of any substructure or a static predefined type.
		/// </summary>
		public string Type { get; set; } = "";
		/// <summary>
		/// Name of the field.
		/// </summary>
		public string Name { get; set; } = "";
		/// <summary>
		/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside its hierarchy<br/>
		/// Note: The padding for the alignment is not included in the size.
		/// </summary>
		public int ByteSize { get; set; }
		/// <summary>
		/// Index of the field that is unique within a tree.<br/>
		/// Normally starts with 0 and is incremented with each additional field.
		/// </summary>
		public int Index { get; set; }
		/// <summary>
		/// Metaflags of the field
		/// </summary>
		public TransferMetaFlags MetaFlag { get; set; }
		public ulong RefTypeHash { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/SerializedFile.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure;
using AssetRipper.Core.VersionHandling;
using AssetRipper.IO.Endian;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	/// <summary>
	/// Serialized files contain binary serialized objects and optional run-time type information.
	/// They have file name extensions like .asset, .assets, .sharedAssets but may also have no extension at all
	/// </summary>
	public sealed class SerializedFile : ISerializedFile
	{
		public string Name { get; }
		public string NameOrigin { get; }
		public string FilePath { get; }
		public SerializedFileHeader Header { get; }
		public SerializedFileMetadata Metadata { get; }
		public LayoutInfo Layout { get; }
		public UnityVersion Version => Layout.Version;
		public BuildTarget Platform => Layout.Platform;
		public TransferInstructionFlags Flags => Layout.Flags;
		public EndianType EndianType
		{
			get
			{
				bool swapEndianess = SerializedFileHeader.HasEndianess(Header.Version) ? Header.Endianess : Metadata.SwapEndianess;
				return swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
			}
		}

		public IFileCollection Collection { get; }
		public IReadOnlyList<FileIdentifier> Dependencies => Metadata.Externals;

		private readonly Dictionary<long, IUnityObjectBase> m_assets = new();
		private readonly Dictionary<long, int> m_assetEntryLookup = new();
		internal SerializedFile(IFileCollection collection, SerializedFileScheme scheme)
		{
			Collection = collection ?? throw new ArgumentNullException(nameof(collection));
			FilePath = scheme.FilePath;
			NameOrigin = scheme.Name;
			Name = FilenameUtils.FixFileIdentifier(scheme.Name);
			Layout = GetLayout(collection, scheme, Name);

			Header = scheme.Header;
			Metadata = scheme.Metadata;

			for (int i = 0; i < Metadata.Object.Length; i++)
			{
				m_assetEntryLookup.Add(Metadata.Object[i].FileID, i);
			}
		}

		public static bool IsSerializedFile(string filePath) => IsSerializedFile(MultiFileStream.OpenRead(filePath));
		public static bool IsSerializedFile(byte[] buffer, int offset, int size) => IsSerializedFile(new MemoryStream(buffer, offset, size, false));
		public static bool IsSerializedFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return SerializedFileHeader.IsSerializedFileHeader(reader, stream.Length);
		}

		public static SerializedFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using SmartStream fileStream = SmartStream.OpenRead(filePath);
			return ReadScheme(fileStream, filePath, fileName);
		}

		public static SerializedFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return SerializedFileScheme.ReadSceme(buffer, filePath, fileName);
		}

		public static SerializedFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return SerializedFileScheme.ReadSceme(stream, filePath, fileName);
		}

		private static LayoutInfo GetLayout(IFileCollection collection, SerializedFileScheme scheme, string name)
		{
			if (!SerializedFileMetadata.HasPlatform(scheme.Header.Version))
			{
				return collection.Layout;
			}
			if (FilenameUtils.IsDefaultResource(name))
			{
				return collection.Layout;
			}

			return new LayoutInfo(scheme.Metadata.UnityVersion, scheme.Metadata.TargetPlatform, scheme.Flags);
		}

		public IUnityObjectBase GetAsset(long pathID)
		{
			return FindAsset(pathID) ?? throw new Exception($"Object with path ID {pathID} wasn't found");
		}

		public IUnityObjectBase GetAsset(int fileIndex, long pathID)
		{
			return FindAsset(fileIndex, pathID, false) ?? throw new Exception($"Object with file ID {fileIndex} path ID {pathID} wasn't found");
		}

		public IUnityObjectBase? FindAsset(long pathID)
		{
			m_assets.TryGetValue(pathID, out IUnityObjectBase? asset);
			return asset;
		}

		public IUnityObjectBase? FindAsset(int fileIndex, long pathID)
		{
			return FindAsset(fileIndex, pathID, true);
		}

		public IUnityObjectBase? FindAsset(ClassIDType classID)
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset.ClassID == classID)
				{
					return asset;
				}
			}

			foreach (FileIdentifier identifier in Metadata.Externals)
			{
				ISerializedFile? file = Collection.FindSerializedFile(identifier.GetFilePath());
				if (file == null)
				{
					continue;
				}
				foreach (IUnityObjectBase asset in file.FetchAssets())
				{
					if (asset.ClassID == classID)
					{
						return asset;
					}
				}
			}
			return null;
		}

		public IUnityObjectBase? FindAsset(ClassIDType classID, string name)
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset.ClassID == classID)
				{
					IHasNameString namedAsset = (IHasNameString)asset;
					if (namedAsset.NameString == name)
					{
						return asset;
					}
				}
			}

			foreach (FileIdentifier identifier in Metadata.Externals)
			{
				ISerializedFile? file = Collection.FindSerializedFile(identifier.GetFilePath());
				if (file == null)
				{
					continue;
				}
				foreach (IUnityObjectBase asset in file.FetchAssets())
				{
					if (asset.ClassID == classID)
					{
						IHasNameString namedAsset = (IHasNameString)asset;
						if (namedAsset.NameString == name)
						{
							return asset;
						}
					}
				}
			}
			return null;
		}

		public ObjectInfo GetAssetEntry(long pathID)
		{
			return Metadata.Object[m_assetEntryLookup[pathID]];
		}

		public ClassIDType GetAssetType(long pathID)
		{
			return Metadata.Object[m_assetEntryLookup[pathID]].ClassID;
		}

		public PPtr<T> CreatePPtr<T>(T asset) where T : IUnityObjectBase
		{
			if (asset.SerializedFile == this)
			{
				return new PPtr<T>(0, asset.PathID);
			}

			for (int i = 0; i < Metadata.Externals.Length; i++)
			{
				FileIdentifier identifier = Metadata.Externals[i];
				ISerializedFile? file = Collection.FindSerializedFile(identifier.GetFilePath());
				if (asset.SerializedFile == file)
				{
					return new PPtr<T>(i + 1, asset.PathID);
				}
			}

			throw new Exception("Asset doesn't belong to this serialized file or its dependencies");
		}

		public IEnumerable<IUnityObjectBase> FetchAssets()
		{
			return m_assets.Values;
		}

		public override string ToString()
		{
			return Name;
		}

		internal void ReadData(Stream stream)
		{
			using AssetReader assetReader = new AssetReader(stream, EndianType, Layout);
			if (SerializedFileMetadata.HasScriptTypes(Header.Version))
			{
				foreach (LocalSerializedObjectIdentifier ptr in Metadata.ScriptTypes)
				{
					if (ptr.LocalSerializedFileIndex == 0)
					{
						int index = m_assetEntryLookup[ptr.LocalIdentifierInFile];
						ReadAsset(assetReader, Metadata.Object[index]);
					}
				}
			}

			for (int i = 0; i < Metadata.Object.Length; i++)
			{
				if (Metadata.Object[i].ClassID == ClassIDType.MonoScript)
				{
					if (!m_assets.ContainsKey(Metadata.Object[i].FileID))
					{
						ReadAsset(assetReader, Metadata.Object[i]);
					}
				}
			}

			for (int i = 0; i < Metadata.Object.Length; i++)
			{
				if (!m_assets.ContainsKey(Metadata.Object[i].FileID))
				{
					ReadAsset(assetReader, Metadata.Object[i]);
				}
			}
		}

		private IUnityObjectBase? FindAsset(int fileIndex, long pathID, bool isSafe)
		{
			ISerializedFile? file;
			if (fileIndex == 0)
			{
				file = this;
			}
			else if (fileIndex < 0)
			{
				if (isSafe)
				{
					Logger.Error($"File index cannot be negative: {fileIndex}");
					return null;
				}
				else
				{
					throw new ArgumentOutOfRangeException(nameof(fileIndex), $"File index cannot be negative: {fileIndex}");
				}
			}
			else
			{
				fileIndex--;
				if (fileIndex >= Metadata.Externals.Length)
				{
					if (isSafe)
					{
						Logger.Error($"{nameof(SerializedFile)} with index {fileIndex} was not found in dependencies");
						return null;
					}
					else
					{
						throw new ArgumentException($"{nameof(SerializedFile)} with index {fileIndex} was not found in dependencies", nameof(fileIndex));
					}
				}

				FileIdentifier identifier = Metadata.Externals[fileIndex];
				file = Collection.FindSerializedFile(identifier.GetFilePath());
			}

			if (file == null)
			{
				if (isSafe)
				{
					return null;
				}
				throw new Exception($"{nameof(SerializedFile)} with index {fileIndex} was not found in collection");
			}

			IUnityObjectBase? asset = file.FindAsset(pathID);
			if (asset == null)
			{
				if (isSafe)
				{
					return null;
				}
				throw new Exception($"Object with path ID {pathID} was not found");
			}
			return asset;
		}

		private void ReadAsset(AssetReader reader, ObjectInfo info)
		{
			AssetInfo assetInfo = new AssetInfo(this, info.FileID, info.ClassID);
			IUnityObjectBase asset = ReadAsset(reader, assetInfo, Header.DataOffset + info.ByteStart, info.ByteSize);
			AddAsset(info.FileID, asset);
		}

		private IUnityObjectBase ReadAsset(AssetReader reader, AssetInfo assetInfo, long offset, int size)
		{
			IUnityObjectBase? asset;
			try
			{
				asset = VersionManager.AssetFactory.CreateAsset(assetInfo, Version);
			}
			catch (TypeLoadException typeLoadException)
			{
#if DEBUG
				throw new SerializedFileException($"Could not load {typeLoadException.TypeName}", typeLoadException, Version, Platform, assetInfo.ClassID, Name, FilePath);
#else
				Logger.Error($"Could not load {typeLoadException.TypeName} : {typeLoadException.Message}");
				asset = null;
#endif
			}

			bool replaceWithUnreadableObject = false;
			reader.AdjustableStream.SetPositionBoundaries(offset, offset + size, offset);
			if (asset is null)
			{
				UnknownObject unknownObject = new UnknownObject(assetInfo);
				unknownObject.Read(reader, size);
				asset = unknownObject;
			}
			else
			{
				try
				{
					asset.Read(reader);
				}
				catch (Exception ex)
				{
#if DEBUG
					throw new SerializedFileException($"Error during reading of asset type {assetInfo.ClassID}", ex, Version, Platform, assetInfo.ClassID, Name, FilePath);
#else
					replaceWithUnreadableObject = true;
					Logger.Error($"Error during reading of asset type {assetInfo.ClassID}. V: {Version} P: {Platform} N: {Name} Path: {FilePath}", ex);
#endif
				}
			}
			
			long read = reader.BaseStream.Position - offset;
			if (!replaceWithUnreadableObject && read != size)
			{
				if (asset is IMonoBehaviourBase monoBehaviour && monoBehaviour.Structure == null)
				{
					reader.BaseStream.Position = offset + size;
				}
				else
				{
#if DEBUG
					throw new SerializedFileException($"Read {read} but expected {size} for asset type {assetInfo.ClassID}", Version, Platform, assetInfo.ClassID, Name, FilePath);
#else
					replaceWithUnreadableObject = true;
					Logger.Error($"Read {read} but expected {size} for asset type {assetInfo.ClassID}. V: {Version} P: {Platform} N: {Name} Path: {FilePath}");
#endif
				}
			}

			if (replaceWithUnreadableObject)
			{
				reader.AdjustableStream.Position = offset;
				UnreadableObject unreadable = new UnreadableObject(assetInfo);
				unreadable.Read(reader, size);
				unreadable.NameString = asset is IHasNameString hasName ? hasName.NameString : asset.GetType().Name;
				asset = unreadable;
			}

			reader.AdjustableStream.ResetPositionBoundaries();
			return asset;
		}
		/*
		private void UpdateFileVersion()
		{
			if (!SerializedFileMetadata.HasSignature(Header.Version))
			{
				foreach (IUnityObjectBase asset in FetchAssets())
				{
					if (asset is IBuildSettings settings && settings.Version != null)
					{
						Metadata.UnityVersion = UnityVersion.Parse(settings.Version);
						return;
					}
				}
			}
		}*/

		private void AddAsset(long pathID, IUnityObjectBase asset)
		{
			m_assets.Add(pathID, asset);
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/SerializedFileException.cs`:

```cs
using System.Text;

namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	public sealed class SerializedFileException : Exception
	{
		public SerializedFileException(string message, UnityVersion version, BuildTarget platform, ClassIDType assetType, string fileName, string filePath) : base(message)
		{
			if (string.IsNullOrEmpty(fileName))
			{
				throw new ArgumentNullException(nameof(fileName));
			}
			if (string.IsNullOrEmpty(filePath))
			{
				throw new ArgumentNullException(nameof(filePath));
			}

			Version = version;
			Platform = platform;
			AssetType = assetType;
			FileName = fileName;
			FilePath = filePath;
		}

		public SerializedFileException(string message, Exception innerException, UnityVersion version, BuildTarget platform, ClassIDType assetType, string fileName, string filePath) : base(message, innerException)
		{
			if (string.IsNullOrEmpty(fileName))
			{
				throw new ArgumentNullException(nameof(fileName));
			}
			if (string.IsNullOrEmpty(filePath))
			{
				throw new ArgumentNullException(nameof(filePath));
			}

			Version = version;
			Platform = platform;
			AssetType = assetType;
			FileName = fileName;
			FilePath = filePath;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			sb.Append("SerializedFileException:");
			sb.Append(" v:").Append(Version.ToString());
			sb.Append(" p:").Append(Platform.ToString());
			sb.Append(" t:").Append(AssetType.ToString());
			sb.Append(" n:").Append(FileName).AppendLine();
			sb.Append("Path:").Append(FilePath).AppendLine();
			sb.Append("Message: ").Append(Message).AppendLine();
			if (InnerException != null)
			{
				sb.Append("Inner: ").Append(InnerException.ToString()).AppendLine();
			}
			sb.Append("StackTrace: ").Append(StackTrace);
			return sb.ToString();
		}

		public UnityVersion Version { get; }
		public BuildTarget Platform { get; }
		public ClassIDType AssetType { get; }
		public string FileName { get; }
		public string FilePath { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/SerializedFileScheme.cs`:

```cs
using AssetRipper.Core.Converters.Files;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.IO.Endian;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	public sealed class SerializedFileScheme : FileScheme
	{
		private SerializedFileScheme(byte[] buffer, string filePath, string fileName) : base(filePath, fileName)
		{
			Stream = new MemoryStream(buffer, 0, buffer.Length, false);
		}

		private SerializedFileScheme(SmartStream stream, string filePath, string fileName) : base(filePath, fileName)
		{
			if (stream.Length <= int.MaxValue)
			{
				byte[] buffer = new byte[stream.Length];
				stream.ReadBuffer(buffer, 0, buffer.Length);
				Stream = new MemoryStream(buffer, 0, buffer.Length, false);
			}
			else
			{
				Stream = stream.CreateReference();
			}
		}

		internal static SerializedFileScheme ReadSceme(byte[] buffer, string filePath, string fileName)
		{
			SerializedFileScheme scheme = new SerializedFileScheme(buffer, filePath, fileName);
			scheme.ReadScheme();
			return scheme;
		}

		internal static SerializedFileScheme ReadSceme(SmartStream stream, string filePath, string fileName)
		{
			SerializedFileScheme scheme = new SerializedFileScheme(stream, filePath, fileName);
			scheme.ReadScheme();
			return scheme;
		}

		internal SerializedFile ReadFile(GameProcessorContext context)
		{
			SerializedFile file = new SerializedFile(context.Collection, this);
			context.AddSerializedFile(file, this);
			return file;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (Stream != null)
			{
				Stream.Dispose();
				Stream = null!;
			}
		}

		private void ReadScheme()
		{
			using (EndianReader reader = new EndianReader(Stream, EndianType.BigEndian))
			{
				Header.Read(reader);
			}
			if (SerializedFileMetadata.IsMetadataAtTheEnd(Header.Version))
			{
				Stream.Position = Header.FileSize - Header.MetadataSize;
			}
			Metadata.Read(Stream, Header);

			SerializedFileMetadataConverter.CombineFormats(Header.Version, Metadata);
			UpdateFlags();
		}

		private void UpdateFlags()
		{
			Flags = TransferInstructionFlags.SerializeGameRelease;
			if (SerializedFileMetadata.HasPlatform(Header.Version))
			{
				if (Metadata.TargetPlatform == BuildTarget.NoTarget)
				{
					Flags = TransferInstructionFlags.NoTransferInstructionFlags;
					if (FilePath.EndsWith(".unity", StringComparison.Ordinal))
					{
						Flags |= TransferInstructionFlags.SerializeEditorMinimalScene;
					}
				}
			}

			if (FilenameUtils.IsEngineResource(Name) || (Header.Version < FormatVersion.Unknown_10 && FilenameUtils.IsBuiltinExtra(Name)))
			{
				Flags |= TransferInstructionFlags.IsBuiltinResourcesFile;
			}
			if (Header.Endianess || Metadata.SwapEndianess)
			{
				Flags |= TransferInstructionFlags.SwapEndianess;
			}
		}

		public override FileEntryType SchemeType => FileEntryType.Serialized;
		public override IEnumerable<FileIdentifier> Dependencies => Metadata.Externals;

		public SerializedFileHeader Header { get; } = new SerializedFileHeader();
		public SerializedFileMetadata Metadata { get; } = new SerializedFileMetadata();
		public TransferInstructionFlags Flags { get; set; }

		public Stream Stream { get; private set; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/SerializedFiles/VirtualSerializedFile.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Structure;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.VersionHandling;
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.SerializedFiles
{
	/// <summary>
	/// A serialized file without any actual file backing it
	/// </summary>
	public class VirtualSerializedFile : ISerializedFile
	{
		public VirtualSerializedFile(LayoutInfo layout)
		{
			Layout = layout;
		}

		public IUnityObjectBase GetAsset(long pathID)
		{
			IUnityObjectBase? asset = FindAsset(pathID);
			if (asset is null)
			{
				throw new Exception($"Object with path ID {pathID} wasn't found");
			}
			return asset;
		}

		public IUnityObjectBase GetAsset(int fileIndex, long pathID)
		{
			if (fileIndex == VirtualFileIndex)
			{
				return GetAsset(pathID);
			}
			throw new NotSupportedException();
		}

		public IUnityObjectBase? FindAsset(long pathID)
		{
			m_assets.TryGetValue(pathID, out IUnityObjectBase? asset);
			return asset;
		}

		public IUnityObjectBase? FindAsset(int fileIndex, long pathID)
		{
			if (fileIndex == VirtualFileIndex)
			{
				return FindAsset(pathID);
			}
			throw new NotSupportedException();
		}

		public IUnityObjectBase? FindAsset(ClassIDType classID)
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset.ClassID == classID)
				{
					return asset;
				}
			}
			return null;
		}

		public IUnityObjectBase? FindAsset(ClassIDType classID, string name)
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset.ClassID == classID && asset is IHasNameString namedAsset)
				{
					if (namedAsset.NameString == name)
					{
						return asset;
					}
				}
			}
			return null;
		}

		public ObjectInfo GetAssetEntry(long pathID)
		{
			throw new NotSupportedException();
		}

		public ClassIDType GetAssetType(long pathID)
		{
			return m_assets[pathID].ClassID;
		}

		public PPtr<T> CreatePPtr<T>(T asset) where T : IUnityObjectBase
		{
			if (asset.SerializedFile == this)
			{
				return new PPtr<T>(VirtualFileIndex, asset.PathID);
			}
			throw new Exception($"Asset '{asset}' doesn't belong to {nameof(VirtualSerializedFile)}");
		}

		public IEnumerable<IUnityObjectBase> FetchAssets()
		{
			return m_assets.Values;
		}

		[Obsolete]
		public T CreateAsset<T>(Func<AssetInfo, T> instantiator) where T : IUnityObjectBase
		{
			//ClassIDType classID = typeof(T).ToClassIDType();
			//AssetInfo assetInfo = CreateAssetInfo(classID);
			//T instance = instantiator(assetInfo);
			//m_assets.Add(instance.PathID, instance);
			//return instance;
			throw new NotSupportedException();
		}

		public T CreateAsset<T>(ClassIDType classID) where T : IUnityObjectBase
		{
			AssetInfo assetInfo = CreateAssetInfo(classID);
			IUnityObjectBase? asset = VersionManager.AssetFactory.CreateAsset(assetInfo, Version);
			if (asset is null)
			{
				throw new ArgumentException($"Could not create asset with id: {classID}", nameof(classID));
			}
			if (asset is T instance)
			{
				m_assets.Add(instance.PathID, instance);
				return instance;
			}
			else
			{
				throw new ArgumentException($"Asset type {asset.GetType()} is not assignable to {typeof(T)}", nameof(classID));
			}
		}

		public void AddAsset(IUnityObjectBase asset, ClassIDType classID)
		{
			asset.AssetInfo = CreateAssetInfo(classID);
			m_assets.Add(asset.PathID, asset);
		}

		private AssetInfo CreateAssetInfo(ClassIDType classID)
		{
			return new AssetInfo(this, ++m_nextId, classID);
		}

		public string Name => nameof(VirtualSerializedFile);
		public BuildTarget Platform => Layout.Platform;
		public UnityVersion Version => Layout.Version;
		public TransferInstructionFlags Flags => Layout.Flags;
		public EndianType EndianType => EndianType.LittleEndian;

		public bool IsScene => throw new NotSupportedException();

		public LayoutInfo Layout { get; }
		public IFileCollection Collection => throw new NotSupportedException();
		public IAssemblyManager AssemblyManager => throw new NotSupportedException();
		public IReadOnlyList<FileIdentifier> Dependencies => throw new NotSupportedException();

		public const int VirtualFileIndex = -1;

		private readonly Dictionary<long, IUnityObjectBase> m_assets = new Dictionary<long, IUnityObjectBase>();

		private long m_nextId;
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/WebFiles/WebFile.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.WebFiles
{
	public sealed class WebFile : FileList
	{
		internal WebFile(WebFileScheme scheme) : base(scheme.NameOrigin)
		{
			Header = scheme.Header;
			Metadata = scheme.Metadata;
		}

		public static bool IsWebFile(string webPath)
		{
			using Stream stream = MultiFileStream.OpenRead(webPath);
			return IsWebFile(stream);
		}

		public static bool IsWebFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return WebHeader.IsWebHeader(reader);
		}

		public static bool IsWebFile(byte[] buffer, int offset, int size)
		{
			using MemoryStream stream = new MemoryStream(buffer, offset, size, false);
			return IsWebFile(stream);
		}

		public static WebFileScheme ReadScheme(byte[] buffer, string filePath)
		{
			return WebFileScheme.ReadScheme(buffer, filePath);
		}

		public static WebFileScheme ReadScheme(SmartStream stream, string filePath)
		{
			return WebFileScheme.ReadScheme(stream, filePath);
		}

		public WebHeader Header { get; }
		public WebMetadata Metadata { get; }
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/WebFiles/WebFileEntry.cs`:

```cs
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.WebFiles
{
	public class WebFileEntry : FileEntry, IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			Offset = reader.ReadInt32();
			Size = reader.ReadInt32();
			NameOrigin = reader.ReadString();
			Name = FilenameUtils.FixFileIdentifier(NameOrigin);
		}
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/WebFiles/WebFileScheme.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Structure;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.IO.Endian;
using System.IO;

namespace AssetRipper.Core.Parser.Files.WebFiles
{
	public sealed class WebFileScheme : FileSchemeList
	{
		private WebFileScheme(string filePath) : base(filePath, string.Empty) { }

		internal static WebFileScheme ReadScheme(byte[] buffer, string filePath)
		{
			WebFileScheme scheme = new WebFileScheme(filePath);
			using (MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false))
			{
				scheme.ReadScheme(stream);
			}
			return scheme;
		}

		internal static WebFileScheme ReadScheme(Stream stream, string filePath)
		{
			WebFileScheme scheme = new WebFileScheme(filePath);
			scheme.ReadScheme(stream);
			return scheme;
		}

		internal WebFile ReadFile(GameProcessorContext context)
		{
			WebFile web = new WebFile(this);
			foreach (FileScheme scheme in Schemes)
			{
				web.AddFile(context, scheme);
			}
			return web;
		}

		private void ReadScheme(Stream stream)
		{
			using (EndianReader reader = new EndianReader(stream, EndianType.LittleEndian))
			{
				Header.Read(reader);
				Metadata.Read(reader);
			}

			foreach (WebFileEntry entry in Metadata.Entries)
			{
				byte[] buffer = new byte[entry.Size];
				stream.Position = entry.Offset;
				stream.ReadBuffer(buffer, 0, buffer.Length);
				FileScheme scheme = SchemeReader.ReadScheme(buffer, FilePath, entry.NameOrigin);
				AddScheme(scheme);
			}
		}

		public override FileEntryType SchemeType => FileEntryType.Web;

		public WebHeader Header { get; } = new WebHeader();
		public WebMetadata Metadata { get; } = new WebMetadata();
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/WebFiles/WebHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.Core.Parser.Files.WebFiles
{
	public sealed class WebHeader : IEndianReadable
	{
		internal static bool IsWebHeader(EndianReader reader)
		{
			if (reader.BaseStream.Length - reader.BaseStream.Position > Signature.Length)
			{
				long position = reader.BaseStream.Position;
				bool isRead = reader.ReadStringZeroTerm(Signature.Length + 1, out string? signature);
				reader.BaseStream.Position = position;
				if (isRead)
				{
					return signature == Signature;
				}
			}
			return false;
		}

		public void Read(EndianReader reader)
		{
			string signature = reader.ReadStringZeroTerm();
			if (signature != Signature)
			{
				throw new Exception($"Signature '{signature}' doesn't match to '{Signature}'");
			}
		}

		private const string Signature = "UnityWebData1.0";
	}
}

```

`AssetRipper.Fundamentals/Parser/Files/WebFiles/WebMetadata.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.Core.Parser.Files.WebFiles
{
	public class WebMetadata : IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			List<WebFileEntry> entries = new List<WebFileEntry>();
			long metadataLength = reader.ReadInt32();
			while (reader.BaseStream.Position < metadataLength)
			{
				WebFileEntry entry = new WebFileEntry();
				entry.Read(reader);
				entries.Add(entry);
			}
			Entries = entries.ToArray();
		}

		public WebFileEntry[] Entries { get; set; } = Array.Empty<WebFileEntry>();
	}
}

```

`AssetRipper.Fundamentals/Parser/Utils/FilenameUtils.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Parser.Utils
{
	public static class FilenameUtils
	{
		public static bool IsEngineResource(string fileName)
		{
			return IsDefaultResource(fileName) || IsEditorResource(fileName);
		}

		public static bool IsDefaultResource(string fileName)
		{
			return fileName == DefaultResourceName1 || fileName == DefaultResourceName2;
		}

		public static bool IsEditorResource(string fileName)
		{
			return fileName == EditorResourceName;
		}

		public static bool IsBuiltinExtra(string fileName)
		{
			return fileName == BuiltinExtraName1 || fileName == BuiltinExtraName2;
		}

		public static bool IsEngineGeneratedF(string fileName)
		{
			return fileName == EngineGeneratedF;
		}

		public static string FixFileIdentifier(string name)
		{
			name = name.ToLower();
			name = FixDependencyName(name);
			name = FixResourcePath(name);
			if (IsDefaultResource(name))
			{
				name = DefaultResourceName1;
			}
			else if (IsBuiltinExtra(name))
			{
				name = BuiltinExtraName1;
			}
			return name;
		}

		public static string FixDependencyName(string dependency)
		{
			if (dependency.StartsWith(LibraryFolder, StringComparison.Ordinal))
			{
				return dependency.Substring(LibraryFolder.Length);
			}
			else if (dependency.StartsWith(ResourcesFolder, StringComparison.Ordinal))
			{
				return dependency.Substring(ResourcesFolder.Length);
			}
			return dependency;
		}

		public static string FixResourcePath(string resourcePath)
		{
			const string archivePrefix = "archive:/";
			if (resourcePath.StartsWith(archivePrefix, StringComparison.Ordinal))
			{
				resourcePath = Path.GetFileName(resourcePath);
			}
			return resourcePath;
		}

		public static string FixAssemblyName(string assembly)
		{
			if (IsAssemblyIdentifier(assembly))
			{
				assembly = $"Assembly - {assembly}";
			}
			assembly = FixAssemblyEndian(assembly);
			return assembly;
		}

		public static string FixAssemblyEndian(string assembly)
		{
			if (assembly.EndsWith(AssemblyExtension, StringComparison.Ordinal))
			{
				return assembly.Substring(0, assembly.Length - AssemblyExtension.Length);
			}
			return assembly;
		}

		public static bool IsProjectAssembly(string assembly)
		{
			const string PrefixName = "Assembly";
			return assembly.StartsWith($"{PrefixName} - ", StringComparison.Ordinal) || assembly.StartsWith($"{PrefixName}-", StringComparison.Ordinal);
		}

		private static bool IsAssemblyIdentifier(string assembly)
		{
			switch (assembly)
			{
				case "Boo":
				case "Boo - first pass":
				case "CSharp":
				case "CSharp - first pass":
				case "UnityScript":
				case "UnityScript - first pass":
					return true;

				default:
					return false;
			}
		}

		public const string LibraryFolder = "library/";
		public const string ResourcesFolder = "resources/";
		public const string DefaultResourceName1 = "unity default resources";
		public const string DefaultResourceName2 = "unity_default_resources";
		public const string EditorResourceName = "unity editor resources";
		public const string BuiltinExtraName1 = "unity builtin extra";
		public const string BuiltinExtraName2 = "unity_builtin_extra";
		public const string EngineGeneratedF = "0000000000000000f000000000000000";
		public const string AssemblyExtension = ".dll";
	}
}

```

`AssetRipper.Fundamentals/Project/Collections/IExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Collections
{
	public interface IExportCollection
	{
		bool Export(IProjectAssetContainer container, string dirPath);
		bool IsContains(IUnityObjectBase asset);
		long GetExportID(IUnityObjectBase asset);
		MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal);

		ISerializedFile File { get; }
		TransferInstructionFlags Flags { get; }
		IEnumerable<IUnityObjectBase> Assets { get; }
		string Name { get; }
	}
}

```

`AssetRipper.Fundamentals/Project/ExportIdHandler.cs`:

```cs
using AssetRipper.Core.Interfaces;
#if DEBUG
using AssetRipper.Core.Extensions;
#endif

namespace AssetRipper.Core.Project
{
	public static class ExportIdHandler
	{
		public static long GetMainExportID(IUnityObjectBase asset)
		{
			return GetMainExportID((uint)asset.ClassID, 0);
		}

		public static long GetMainExportID(uint classID)
		{
			return GetMainExportID(classID, 0);
		}

		public static long GetMainExportID(IUnityObjectBase asset, uint value)
		{
			return GetMainExportID((uint)asset.ClassID, value);
		}

		public static long GetMainExportID(uint classID, uint value)
		{
			if (classID > 100100)
			{
				if (value != 0)
				{
					throw new ArgumentException("Unique asset type with non unique modifier", nameof(value));
				}
				return classID;
			}

#if DEBUG
			if (value >= 100000)
			{
				throw new ArgumentException($"Value {value} for main export ID must have no more than 5 digits");
			}
#endif
			return (classID * 100000) + value;
		}
	}
}

```

`AssetRipper.Fundamentals/Project/IExportContainer.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Core.Project
{
	public interface IExportContainer : IAssetContainer
	{
		long GetExportID(IUnityObjectBase asset);
		AssetType ToExportType(Type type);
		MetaPtr CreateExportPointer(IUnityObjectBase asset);

		string SceneIndexToName(int sceneID);
		bool IsSceneDuplicate(int sceneID);
		string TagIDToName(int tagID);
		ushort TagNameToID(string tagName);

		IExportCollection CurrentCollection { get; }
		LayoutInfo ExportLayout { get; }
		UnityVersion ExportVersion { get; }
		BuildTarget ExportPlatform { get; }
		TransferInstructionFlags ExportFlags { get; }
	}
}

```

`AssetRipper.Fundamentals/Project/IProjectAssetContainer.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.Project
{
	public interface IProjectAssetContainer : IExportContainer
	{
		ISerializedFile File { get; }
		VirtualSerializedFile VirtualFile { get; }
		UnityGUID SceneNameToGUID(string name);
		bool TryGetAssetPathFromAssets(IEnumerable<IUnityObjectBase> assets, [NotNullWhen(true)] out IUnityObjectBase? selectedAsset, out string assetPath);
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Managers/BaseManager.cs`:

```cs
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure.Assembly.Mono;
using AssetRipper.Core.Structure.Assembly.Serializable;
using AssetRipper.Core.Structure.GameStructure.Platforms;
using Mono.Cecil;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;

namespace AssetRipper.Core.Structure.Assembly.Managers
{
	public class BaseManager : IAssemblyManager, IAssemblyResolver
	{
		public bool IsSet => ScriptingBackend != ScriptingBackend.Unknown;
		public virtual ScriptingBackend ScriptingBackend => ScriptingBackend.Unknown;

		protected readonly Dictionary<string, AssemblyDefinition?> m_assemblies = new();
		protected readonly Dictionary<string, bool> m_validTypes = new();

		public LayoutInfo Layout { get; }

		private event Action<string> m_requestAssemblyCallback;
		private readonly Dictionary<string, SerializableType> m_serializableTypes = new();

		public BaseManager(LayoutInfo layout, Action<string> requestAssemblyCallback)
		{
			Layout = layout;
			m_requestAssemblyCallback = requestAssemblyCallback ?? throw new ArgumentNullException(nameof(requestAssemblyCallback));
		}

		public virtual void Initialize(PlatformGameStructure gameStructure) { }

		public static string ToAssemblyName(string scopeName)
		{
			if (scopeName.EndsWith(MonoManager.AssemblyExtension, StringComparison.Ordinal))
			{
				return scopeName.Substring(0, scopeName.Length - MonoManager.AssemblyExtension.Length);
			}
			return scopeName;
		}

		protected static string GetUniqueName(TypeReference type)
		{
			string assembly = FilenameUtils.FixAssemblyEndian(type.Scope.Name);
			return ScriptIdentifier.ToUniqueName(assembly, type.FullName);
		}

		public virtual void Load(string filePath)
		{
			ReaderParameters parameters = new ReaderParameters(ReadingMode.Deferred)
			{
				InMemory = false,
				ReadWrite = false,
				AssemblyResolver = this,
			};
			AssemblyDefinition assembly;
			try
			{
				assembly = AssemblyDefinition.ReadAssembly(filePath, parameters);
			}
			catch (BadImageFormatException badImageFormatException)
			{
				throw new BadImageFormatException($"Could not read {filePath}", badImageFormatException);
			}
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			string assemblyName = ToAssemblyName(assembly.Name.Name);
			m_assemblies.Add(fileName, assembly);
			m_assemblies[assemblyName] = assembly;
		}

		public virtual void Read(Stream stream, string fileName)
		{
			ReaderParameters parameters = new ReaderParameters(ReadingMode.Immediate)
			{
				InMemory = true,
				ReadWrite = false,
				AssemblyResolver = this,
			};
			AssemblyDefinition assembly = AssemblyDefinition.ReadAssembly(stream, parameters);
			fileName = Path.GetFileNameWithoutExtension(fileName);
			string assemblyName = ToAssemblyName(assembly.Name.Name);
			m_assemblies.Add(fileName, assembly);
			m_assemblies[assemblyName] = assembly;
		}

		public virtual void Unload(string fileName)
		{
			if (m_assemblies.TryGetValue(fileName, out AssemblyDefinition? assembly))
			{
				assembly?.Dispose();
				m_assemblies.Remove(fileName);
			}
		}

		public virtual bool IsAssemblyLoaded(string assembly)
		{
			return m_assemblies.ContainsKey(assembly);
		}

		public virtual bool IsPresent(ScriptIdentifier scriptID)
		{
			if (!IsSet)
			{
				return false;
			}

			if (scriptID.IsDefault)
			{
				return false;
			}
			else
			{
				return FindType(scriptID.Assembly, scriptID.Namespace, scriptID.Name) != null;
			}
		}

		public virtual bool IsValid(ScriptIdentifier scriptID)
		{
			if (!IsSet)
			{
				return false;
			}

			if (scriptID.IsDefault)
			{
				return false;
			}

			TypeDefinition? type = FindType(scriptID);
			if (type == null)
			{
				return false;
			}

			if (type.IsAbstract)
			{
				return false;
			}

			MonoTypeContext context = new MonoTypeContext(type);
			if (!IsTypeValid(context))
			{
				return false;
			}

			if (!IsInheritanceValid(type))
			{
				return false;
			}

			return true;
		}

		public virtual TypeDefinition GetTypeDefinition(ScriptIdentifier scriptID)
		{
			TypeDefinition? type = FindType(scriptID);
			if (type == null)
			{
				throw new ArgumentException($"Can't find type {scriptID.UniqueName}");
			}
			return type;
		}

		public virtual ScriptIdentifier GetScriptID(string assembly, string name)
		{
			if (!IsSet)
			{
				return default;
			}

			TypeDefinition? type = FindType(assembly, name);
			if (type == null)
			{
				return default;
			}
			return new ScriptIdentifier(type.Scope.Name, type.Namespace, type.Name);
		}

		public virtual ScriptIdentifier GetScriptID(string assembly, string @namespace, string name)
		{
			if (!IsSet)
			{
				return default;
			}

			TypeDefinition? type = FindType(assembly, @namespace, name);
			if (type == null)
			{
				return default;
			}
			return new ScriptIdentifier(assembly, type.Namespace, type.Name);
		}

		public virtual AssemblyDefinition? Resolve(AssemblyNameReference assemblyReference)
		{
			string assemblyName = ToAssemblyName(assemblyReference.Name);
			return FindAssembly(assemblyName);
		}

		public virtual AssemblyDefinition? Resolve(AssemblyNameReference name, ReaderParameters parameters)
		{
			return Resolve(name);
		}

		public virtual SerializableType GetSerializableType(ScriptIdentifier scriptID)
		{
			string uniqueName = scriptID.UniqueName;
			if (m_serializableTypes.TryGetValue(uniqueName, out SerializableType? sType))
			{
				return sType;
			}
			TypeDefinition? type = FindType(scriptID);
			if (type == null)
			{
				throw new ArgumentException($"Can't find type {scriptID.UniqueName}");
			}
			return new MonoType(this, type);
		}

		public SerializableType GetSerializableType(MonoTypeContext context)
		{
			if (context.Type.ContainsGenericParameter)
			{
				throw new ArgumentException($"{context.Type.FullName} contains a geneneric parameter", nameof(context));
			}
			if (MonoUtils.IsSerializableArray(context.Type))
			{
				throw new ArgumentException($"{context.Type.FullName} is a serializable array", nameof(context));
			}

			string uniqueName = GetUniqueName(context.Type);
			if (TryGetSerializableType(uniqueName, out SerializableType? serializableType))
			{
				return serializableType;
			}
			else
			{
				return new MonoType(this, context);
			}
		}

		internal void AddSerializableType(TypeReference type, SerializableType scriptType)
		{
			string uniqueName = GetUniqueName(type);
			AddSerializableType(uniqueName, scriptType);
		}

		internal void InvokeRequestAssemblyCallback(string assemblyName) => m_requestAssemblyCallback.Invoke(assemblyName);

		internal void AddSerializableType(string uniqueName, SerializableType scriptType) => m_serializableTypes.Add(uniqueName, scriptType);

		internal bool TryGetSerializableType(string uniqueName, [NotNullWhen(true)] out SerializableType? scriptType)
		{
			return m_serializableTypes.TryGetValue(uniqueName, out scriptType);
		}

		protected AssemblyDefinition? FindAssembly(string name)
		{
			if (m_assemblies.TryGetValue(name, out AssemblyDefinition? assembly))
			{
				return assembly;
			}

			InvokeRequestAssemblyCallback(name);
			if (m_assemblies.TryGetValue(name, out assembly))
			{
				return assembly;
			}
			m_assemblies.Add(name, null);
			return null;
		}

		protected TypeDefinition? FindType(string assembly, string name)
		{
			AssemblyDefinition? definition = FindAssembly(assembly);
			if (definition == null)
			{
				return null;
			}

			foreach (ModuleDefinition module in definition.Modules)
			{
				foreach (TypeDefinition type in module.Types)
				{
					if (type.Name == name)
					{
						return type;
					}
				}
			}
			return null;
		}

		protected TypeDefinition? FindType(string assembly, string @namespace, string name)
		{
			AssemblyDefinition? definition = FindAssembly(assembly);
			if (definition == null)
			{
				return null;
			}

			foreach (ModuleDefinition module in definition.Modules)
			{
				TypeDefinition type = module.GetType(@namespace, name);
				if (type != null)
				{
					return type;
				}
			}
			return null;
		}

		protected TypeDefinition? FindType(ScriptIdentifier scriptID)
		{
			return FindType(scriptID.Assembly, scriptID.Namespace, scriptID.Name);
		}

		/// <summary>
		/// Is it possible to properly restore serializable layout for specified type
		/// </summary>
		/// <param name="type">Type to check</param>
		/// <param name="arguments">Generic arguments for checking type</param>
		/// <returns>Is type valid for serialization</returns>
		protected bool IsTypeValid(MonoTypeContext context)
		{
			if (context.Type.IsGenericParameter)
			{
				MonoTypeContext parameterContext = context.Resolve();
				return IsTypeValid(parameterContext);
			}
			if (context.Type.IsArray)
			{
				ArrayType array = (ArrayType)context.Type;
				MonoTypeContext arrayContext = new MonoTypeContext(array.ElementType, context);
				return IsTypeValid(arrayContext);
			}
			if (MonoUtils.IsBuiltinGeneric(context.Type))
			{
				GenericInstanceType generic = (GenericInstanceType)context.Type;
				TypeReference element = generic.GenericArguments[0];
				MonoTypeContext genericContext = new MonoTypeContext(element, context);
				return IsTypeValid(genericContext);
			}

			if (MonoUtils.IsPrime(context.Type))
			{
				return true;
			}
			if (context.Type.Module == null)
			{
				return false;
			}

			if (m_validTypes.TryGetValue(context.Type.FullName, out bool isValid))
			{
				return isValid;
			}

			// set value right here to prevent recursion
			m_validTypes[context.Type.FullName] = true;

			// Resolve method for generic instance returns template definition, so we need to check module for template first
			if (context.Type.IsGenericInstance)
			{
				GenericInstanceType instance = (GenericInstanceType)context.Type;
				if (instance.ElementType.Module == null)
				{
					m_validTypes[context.Type.FullName] = false;
					return false;
				}
			}

			TypeDefinition definition = context.Type.Resolve();
			if (definition == null)
			{
				m_validTypes[context.Type.FullName] = false;
				return false;
			}
			if (definition.IsInterface)
			{
				return true;
			}

			MonoTypeContext baseContext = context.GetBase();
			if (!IsTypeValid(baseContext))
			{
				m_validTypes[context.Type.FullName] = false;
				return false;
			}

			IReadOnlyDictionary<GenericParameter, TypeReference> arguments = context.GetContextArguments();
			foreach (FieldDefinition field in definition.Fields)
			{
				if (!MonoUtils.IsSerializableModifier(field))
				{
					continue;
				}

				MonoTypeContext fieldContext = new MonoTypeContext(field.FieldType, arguments);
				if (!IsTypeValid(fieldContext))
				{
					m_validTypes[context.Type.FullName] = false;
					return false;
				}
			}
			return true;
		}

		protected bool IsInheritanceValid(TypeReference type)
		{
			while (type != null)
			{
				if (type.Module == null)
				{
					return false;
				}
				TypeDefinition definition = type.Resolve();
				if (definition == null)
				{
					return false;
				}

				if (MonoUtils.IsMonoBehaviour(definition) || MonoUtils.IsScriptableObject(definition))
				{
					return true;
				}
				type = definition.BaseType;
			}
			return false;
		}

		public virtual AssemblyDefinition[] GetAssemblies()
		{
			return m_assemblies.Values.Where(x => x is not null).Distinct().ToArray()!;
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected void Dispose(bool disposing)
		{
			foreach (AssemblyDefinition? assembly in m_assemblies.Values)
			{
				if (assembly != null)
				{
					assembly.Dispose();
				}
			}
		}

		~BaseManager()
		{
			Dispose(false);
		}

	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Managers/IAssemblyManager.cs`:

```cs
using AssetRipper.Core.Structure.Assembly.Serializable;
using AssetRipper.Core.Structure.GameStructure.Platforms;
using Mono.Cecil;
using System.IO;

namespace AssetRipper.Core.Structure.Assembly.Managers
{
	public interface IAssemblyManager : IDisposable
	{
		void Initialize(PlatformGameStructure gameStructure);
		void Load(string filePath);
		void Read(Stream stream, string fileName);
		void Unload(string fileName);

		bool IsAssemblyLoaded(string assembly);
		bool IsPresent(ScriptIdentifier scriptID);
		bool IsValid(ScriptIdentifier scriptID);
		SerializableType GetSerializableType(ScriptIdentifier scriptID);
		TypeDefinition GetTypeDefinition(ScriptIdentifier scriptID);
		AssemblyDefinition[] GetAssemblies();
		ScriptIdentifier GetScriptID(string assembly, string name);
		ScriptIdentifier GetScriptID(string assembly, string @namespace, string name);

		bool IsSet { get; }
		ScriptingBackend ScriptingBackend { get; }
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Managers/IL2CppManager.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Structure.GameStructure.Platforms;
using Mono.Cecil;
using System.IO;
using System.Text;
using Cpp2IlApi = Cpp2IL.Core.Cpp2IlApi;

namespace AssetRipper.Core.Structure.Assembly.Managers
{
	public sealed class IL2CppManager : BaseManager
	{
		public string? GameAssemblyPath { get; private set; }
		public string? UnityPlayerPath { get; private set; }
		public string? GameDataPath { get; private set; }
		public string? MetaDataPath { get; private set; }
		public int[]? UnityVersion { get; private set; }
		private readonly ScriptContentLevel contentLevel;

		public IL2CppManager(LayoutInfo layout, Action<string> requestAssemblyCallback, ScriptContentLevel level) : base(layout, requestAssemblyCallback)
		{
			contentLevel = level;
		}

		public override ScriptingBackend ScriptingBackend => ScriptingBackend.IL2Cpp;

		public override void Initialize(PlatformGameStructure gameStructure)
		{
			string? gameDataPath = gameStructure.GameDataPath;
			if (string.IsNullOrWhiteSpace(gameDataPath))
			{
				throw new ArgumentNullException(nameof(gameDataPath));
			}

			GameDataPath = gameDataPath;
			GameAssemblyPath = gameStructure.Il2CppGameAssemblyPath;
			UnityPlayerPath = gameStructure.UnityPlayerPath;
			MetaDataPath = gameStructure.Il2CppMetaDataPath;

			if (gameStructure.UnityVersion != null)
			{
				UnityVersion = gameStructure.UnityVersion;
			}
			else
			{
				UnityVersion = Cpp2IlApi.DetermineUnityVersion(UnityPlayerPath!, GameDataPath);
			}

			if (UnityVersion == null)
			{
				throw new NullReferenceException("Could not determine the unity version");
			}
			else
			{
				Logger.Info(LogCategory.Import, $"During Il2Cpp initialization, found Unity version: {MakeVersionString(UnityVersion)}");
			}

			Logger.SendStatusChange("loading_step_parse_il2cpp_metadata");

			Cpp2IlApi.InitializeLibCpp2Il(GameAssemblyPath!, MetaDataPath!, UnityVersion, false);

			Logger.SendStatusChange("loading_step_generate_dummy_dll");

			Cpp2IlApi.MakeDummyDLLs(true);

			LibCpp2IL.InstructionSet instructionSet = LibCpp2IL.LibCpp2IlMain.Binary?.InstructionSet ?? throw new Exception("Null binary");
			Logger.Info(LogCategory.Import, $"During Il2Cpp initialization, found {instructionSet} instruction set.");

			Cpp2IL.Core.BaseKeyFunctionAddresses? keyFunctionAddresses = null;
			if (IsAddressScanSupported(instructionSet))
			{
				Logger.SendStatusChange("loading_step_locate_key_functions");
				keyFunctionAddresses = Cpp2IlApi.ScanForKeyFunctionAddresses();
			}

			if (IsAttributeRestorationSupported(instructionSet))
			{
				Logger.SendStatusChange("loading_step_restore_attributes");
				Cpp2IlApi.RunAttributeRestorationForAllAssemblies(keyFunctionAddresses);
			}

			if (contentLevel >= ScriptContentLevel.Level3)
			{
				bool unsafeAnalysis = contentLevel == ScriptContentLevel.Level4;
				foreach (AssemblyDefinition assembly in Cpp2IlApi.GeneratedAssemblies)
				{
					Cpp2IlApi.AnalyseAssembly(Cpp2IL.Core.AnalysisLevel.IL_ONLY, assembly, keyFunctionAddresses!, null, true, unsafeAnalysis);
				}
			}

			foreach (AssemblyDefinition assembly in Cpp2IlApi.GeneratedAssemblies)
			{
				m_assemblies.Add(assembly.Name.Name, assembly);
			}
		}

		public override void Load(string filePath)
		{
			throw new NotSupportedException();
		}

		public override void Read(Stream stream, string fileName)
		{
			throw new NotSupportedException();
		}

		private static string MakeVersionString(int[] version)
		{
			if (version == null || version.Length == 0)
			{
				return "";
			}

			StringBuilder builder = new StringBuilder();
			builder.Append(version[0]);
			for (int i = 1; i < version.Length; i++)
			{
				builder.Append('.');
				builder.Append(version[i]);
			}
			return builder.ToString();
		}

		private static bool IsAddressScanSupported(LibCpp2IL.InstructionSet set) => set switch
		{
			LibCpp2IL.InstructionSet.X86_32 => true,
			LibCpp2IL.InstructionSet.X86_64 => true,
			LibCpp2IL.InstructionSet.ARM64 => true,
			_ => false,
		};

		private static bool IsAttributeRestorationSupported(LibCpp2IL.InstructionSet set) => set switch
		{
			LibCpp2IL.InstructionSet.X86_32 => true,
			LibCpp2IL.InstructionSet.X86_64 => true,
			LibCpp2IL.InstructionSet.WASM => true,

			//Arm32 and Arm64 were excluded before for performance reasons.
			//However, the community requested that they be enabled anyway.
			LibCpp2IL.InstructionSet.ARM32 => true,
			LibCpp2IL.InstructionSet.ARM64 => true,

			_ => false, 
		};

		~IL2CppManager()
		{
			Dispose(false);
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Managers/MonoManager.cs`:

```cs
using AsmResolver.PE.File;
using AsmResolver.PE.File.Headers;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Structure.GameStructure.Platforms;

namespace AssetRipper.Core.Structure.Assembly.Managers
{
	public sealed class MonoManager : BaseManager
	{
		public const string AssemblyExtension = ".dll";

		public override ScriptingBackend ScriptingBackend => ScriptingBackend.Mono;

		public MonoManager(LayoutInfo layout, Action<string> requestAssemblyCallback) : base(layout, requestAssemblyCallback) { }

		public override void Initialize(PlatformGameStructure gameStructure)
		{
			Logger.Info(LogCategory.Import, $"During Mono initialization, found {gameStructure.Assemblies.Count} assemblies");
			foreach ((string assemblyName, string assemblyPath) in gameStructure.Assemblies)
			{
				try
				{
					if (!PEFile.FromFile(assemblyPath).OptionalHeader.GetDataDirectory(DataDirectoryIndex.ClrDirectory).IsPresentInPE)
					{
						Logger.Info(LogCategory.Import, $"Skipping native assembly: {assemblyName}");
					}
					else
					{
						Load(assemblyPath);
					}
				}
				catch (BadImageFormatException)
				{
					Logger.Info(LogCategory.Import, $"Skipping non-PE file: {assemblyName}");
				}
			}
		}

		public static bool IsMonoAssembly(string fileName)
		{
			if (fileName.EndsWith(AssemblyExtension, StringComparison.Ordinal))
			{
				return true;
			}
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/ElementType.cs`:

```cs
namespace AssetRipper.Core.Structure.Assembly.Mono
{
	public enum ElementType : byte
	{
		None = 0x00,
		Void = 0x01,
		Boolean = 0x02,
		Char = 0x03,
		I1 = 0x04,
		U1 = 0x05,
		I2 = 0x06,
		U2 = 0x07,
		I4 = 0x08,
		U4 = 0x09,
		I8 = 0x0a,
		U8 = 0x0b,
		R4 = 0x0c,
		R8 = 0x0d,
		String = 0x0e,
		Ptr = 0x0f,   // Followed by <type> token
		ByRef = 0x10,   // Followed by <type> token
		ValueType = 0x11,   // Followed by <type> token
		Class = 0x12,   // Followed by <type> token
		Var = 0x13,   // Followed by generic parameter number
		Array = 0x14,   // <type> <rank> <boundsCount> <bound1>  <loCount> <lo1>
		GenericInst = 0x15,   // <type> <type-arg-count> <type-1> ... <type-n> */
		TypedByRef = 0x16,
		I = 0x18,   // System.IntPtr
		U = 0x19,   // System.UIntPtr
		FnPtr = 0x1b,   // Followed by full method signature
		Object = 0x1c,   // System.Object
		SzArray = 0x1d,   // Single-dim array with 0 lower bound
		MVar = 0x1e,   // Followed by generic parameter number
		CModReqD = 0x1f,   // Required modifier : followed by a TypeDef or TypeRef token
		CModOpt = 0x20,   // Optional modifier : followed by a TypeDef or TypeRef token
		Internal = 0x21,   // Implemented within the CLI
		Modifier = 0x40,   // Or'd with following element types
		Sentinel = 0x41,   // Sentinel for varargs method signature
		Pinned = 0x45,   // Denotes a local variable that points at a pinned object

		// special undocumented constants
		Type = 0x50,
		Boxed = 0x51,
		Enum = 0x55
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/Extensions/MetadataResolverExtensions.cs`:

```cs
using Mono.Cecil;
using System.Reflection;

namespace AssetRipper.Core.Structure.Assembly.Mono.Extensions
{
	public static class MetadataResolverExtensions
	{
		/*
		 * MetadataResolver.AreSame(TypeReference, TypeReference)
		 */

		static MethodInfo areSameMethodInfo = typeof(MetadataResolver).GetMethod(
				"AreSame",
				BindingFlags.NonPublic | BindingFlags.Static,
				null,
				new Type[] { typeof(TypeReference), typeof(TypeReference) },
				null)
			?? throw new Exception();

		public static bool AreSame(TypeReference a, TypeReference b)
		{
			return (bool)(areSameMethodInfo.Invoke(null, new object[] { a, b }) ?? throw new Exception());
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/Extensions/MethodDefinitionExtensions.cs`:

```cs
using Mono.Cecil;

namespace AssetRipper.Core.Structure.Assembly.Mono.Extensions
{
	public static class MethodDefinitionExtensions
	{
		/*
		 * IsVarArg
		 * GetSentinelPosition
		 */

		public static bool IsVarArg(this IMethodSignature self)
		{
			return (self.CallingConvention & MethodCallingConvention.VarArg) != 0;
		}

		public static int GetSentinelPosition(this IMethodSignature self)
		{
			if (!self.HasParameters)
			{
				return -1;
			}

			global::Mono.Collections.Generic.Collection<ParameterDefinition> parameters = self.Parameters;
			for (int i = 0; i < parameters.Count; i++)
			{
				if (parameters[i].ParameterType.IsSentinel)
				{
					return i;
				}
			}

			return -1;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/Extensions/TypeReferenceExtensions.cs`:

```cs
using Mono.Cecil;
using System.Reflection;

namespace AssetRipper.Core.Structure.Assembly.Mono.Extensions
{
	public static class TypeReferenceExtensions
	{
		/*
		 * ResolveOrDefault
		 * 
		 * Other changes:
		 * etype
		 * public ElementType
		 */

		public static TypeReference ResolveOrDefault(this TypeReference typeReference)
		{
			ModuleDefinition module = typeReference.Module;
			if (module == null)
			{
				return typeReference;
			}

			TypeDefinition definition = module.MetadataResolver.Resolve(typeReference);
			if (definition == null)
			{
				return typeReference;
			}

			return definition;
		}

		static FieldInfo etypeFieldInfo = typeof(TypeReference).GetField("etype", BindingFlags.NonPublic | BindingFlags.Instance)
			?? throw new Exception();

		public static ElementType GetEType(this TypeReference _this)
		{
			return (ElementType)(etypeFieldInfo.GetValue(_this) ?? throw new Exception());
		}

		public static void SetEType(this TypeReference _this, ElementType value)
		{
			etypeFieldInfo.SetValue(_this, value);
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/MonoFieldContext.cs`:

```cs
using AssetRipper.Core.Layout;
using Mono.Cecil;
using System.Collections.Generic;

namespace AssetRipper.Core.Structure.Assembly.Mono
{
	public readonly struct MonoFieldContext
	{
		public MonoFieldContext(FieldDefinition field, LayoutInfo layout) : this(field, null, layout) { }

		public MonoFieldContext(FieldDefinition field, IReadOnlyDictionary<GenericParameter, TypeReference>? arguments, LayoutInfo layout)
		{
			Layout = layout;
			Definition = field;
			ElementType = field.FieldType;
			IsArray = false;
			Arguments = arguments;
		}

		public MonoFieldContext(in MonoFieldContext copy, TypeReference fieldType, bool isArrayElement)
		{
			Layout = copy.Layout;
			Definition = copy.Definition;
			ElementType = fieldType;
			IsArray = isArrayElement;
			Arguments = copy.Arguments;
		}

		public LayoutInfo Layout { get; }
		public FieldDefinition Definition { get; }
		public TypeReference DeclaringType => Definition.DeclaringType;
		public TypeReference ElementType { get; }
		public bool IsArray { get; }
		public IReadOnlyDictionary<GenericParameter, TypeReference>? Arguments { get; }
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/MonoType.cs`:

```cs
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.Structure.Assembly.Serializable;
using Mono.Cecil;
using System.Collections.Generic;
using static AssetRipper.Core.Structure.Assembly.Mono.MonoUtils;

namespace AssetRipper.Core.Structure.Assembly.Mono
{
	public sealed class MonoType : SerializableType
	{
		internal MonoType(BaseManager manager, TypeReference type) : this(manager, new MonoTypeContext(type)) { }

		internal MonoType(BaseManager manager, MonoTypeContext context) : base(context.Type.Namespace, ToPrimitiveType(context.Type), MonoUtils.GetName(context.Type))
		{
			if (context.Type.ContainsGenericParameter)
			{
				throw new ArgumentException("Context type contains a generic parameter", nameof(context));
			}
			if (IsSerializableArray(context.Type))
			{
				throw new ArgumentException("Arrays are not valid Mono Types", nameof(context));
			}

			manager.AddSerializableType(context.Type, this);
			Base = GetBaseType(manager, context);
			Fields = CreateFields(manager, context);
		}

		private static SerializableType? GetBaseType(BaseManager manager, MonoTypeContext context)
		{
			MonoTypeContext baseContext = context.GetBase();
			MonoTypeContext resolvedContext = baseContext.Resolve();
			if (IsObject(resolvedContext.Type))
			{
				return null;
			}
			return manager.GetSerializableType(resolvedContext);
		}

		private static Field[] CreateFields(BaseManager manager, MonoTypeContext context)
		{
			List<Field> fields = new List<Field>();
			TypeDefinition definition = context.Type.Resolve();
			IReadOnlyDictionary<GenericParameter, TypeReference> arguments = context.GetContextArguments();
			foreach (FieldDefinition field in definition.Fields)
			{
				MonoFieldContext fieldContext = new MonoFieldContext(field, arguments, manager.Layout);
				if (IsSerializable(fieldContext))
				{
					MonoTypeContext typeContext = new MonoTypeContext(field.FieldType, arguments);
					MonoTypeContext resolvedContext = typeContext.Resolve();
					int depth = 0;
					MonoTypeContext serFieldContext = GetSerializedElementContext(resolvedContext, ref depth);
					if (depth > 1)
					{
						continue;
					}
					SerializableType scriptType = manager.GetSerializableType(serFieldContext);
					Field fieldStruc = new Field(scriptType, depth, field.Name);
					fields.Add(fieldStruc);
				}
			}
			return fields.ToArray();
		}

		private static MonoTypeContext GetSerializedElementContext(MonoTypeContext context, ref int depth)
		{
			if (context.Type.IsArray)
			{
				ArrayType array = (ArrayType)context.Type;
				depth++;
				return GetSerializedElementContext(new MonoTypeContext(array.ElementType), ref depth);
			}
			if (IsList(context.Type))
			{
				GenericInstanceType generic = (GenericInstanceType)context.Type;
				depth++;
				return GetSerializedElementContext(new MonoTypeContext(generic.GenericArguments[0]), ref depth);
			}
			return context;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/MonoTypeContext.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Structure.Assembly.Mono.Extensions;
using Mono.Cecil;
using System.Collections.Generic;
using System.Text;

namespace AssetRipper.Core.Structure.Assembly.Mono
{
	public readonly struct MonoTypeContext
	{
		public TypeReference Type { get; }
		/// <summary>
		/// Arguments of the declaring type, where current Type is located
		/// </summary>
		private IReadOnlyDictionary<GenericParameter, TypeReference> Arguments { get; }

		private static readonly Dictionary<GenericParameter, TypeReference> s_emptyArguments = new Dictionary<GenericParameter, TypeReference>(0);

		public MonoTypeContext(TypeReference type) : this(type, GetDeclaringArguments(type)) { }

		public MonoTypeContext(TypeReference type, MonoTypeContext context) : this(type, context.Arguments) { }

		public MonoTypeContext(TypeReference type, IReadOnlyDictionary<GenericParameter, TypeReference> arguments)
		{
			Type = type;
			Arguments = arguments;
		}

		private static IReadOnlyDictionary<GenericParameter, TypeReference> GetDeclaringArguments(TypeReference type)
		{
			if (type.HasGenericParameters)
			{
				// if context get created for a template class, set arguments equals to itself
				Dictionary<GenericParameter, TypeReference> templateArguments = new Dictionary<GenericParameter, TypeReference>(type.GenericParameters.Count);
				foreach (GenericParameter parameter in type.GenericParameters)
				{
					templateArguments.Add(parameter, parameter);
				}
				return templateArguments;
			}
			return s_emptyArguments;
		}

		public MonoTypeContext GetBase()
		{
			// Resolve method returns template definition for GenericInstance
			TypeDefinition definition = Type.Resolve();
			TypeReference parent = definition.BaseType;
			IReadOnlyDictionary<GenericParameter, TypeReference> parentArguments = Arguments;
			if (parent.IsGenericInstance && parent.ContainsGenericParameter)
			{
				parentArguments = GetContextArguments();
			}
			return new MonoTypeContext(parent, parentArguments);
		}

		/// <summary>
		/// Replace all generic parameters with actual arguments
		/// </summary>
		/// <returns>Return new generic type if change was happened. Otherwise return a self copy</returns>
		public MonoTypeContext Resolve()
		{
			if (Type.ContainsGenericParameter)
			{
				return ResolveGenericParameter();
			}
			return this;
		}

		/// <summary>
		/// Appends method generic arguments to current ones
		/// </summary>
		/// <returns>Return context with merged arguments if change was happened. Otherwise return a self copy</returns>
		public MonoTypeContext Merge(MethodDefinition method)
		{
			if (method.HasGenericParameters)
			{
				int argsCount = method.GenericParameters.Count + Arguments.Count;
				Dictionary<GenericParameter, TypeReference> arguments = new Dictionary<GenericParameter, TypeReference>(argsCount);
				arguments.AddRange(Arguments);
				foreach (GenericParameter parameter in method.GenericParameters)
				{
					arguments.Add(parameter, parameter);
				}
				return new MonoTypeContext(Type, arguments);
			}
			return this;
		}

		/// <summary>
		/// Get generic arguments of current Type
		/// </summary>
		public IReadOnlyDictionary<GenericParameter, TypeReference> GetContextArguments()
		{
			if (Type.IsGenericInstance)
			{
				GenericInstanceType instance = (GenericInstanceType)Type;
				// we need to get definition to get real generic parameters (T1, T2) instead of references ({!0}, {!1})
				TypeDefinition template = instance.ElementType.Resolve();
				Dictionary<GenericParameter, TypeReference> arguments = new Dictionary<GenericParameter, TypeReference>(template.GenericParameters.Count);
				for (int i = 0; i < template.GenericParameters.Count; i++)
				{
					GenericParameter parameter = template.GenericParameters[i];
					TypeReference argument = instance.GenericArguments[i];
					MonoTypeContext argumentContext = new MonoTypeContext(argument, Arguments);
					MonoTypeContext resolvedContext = argumentContext.Resolve();
					arguments.Add(parameter, resolvedContext.Type);
				}
				return arguments;
			}
			return Arguments;
		}

		public override string? ToString()
		{
			if (Type == null)
			{
				return base.ToString();
			}
			if (Arguments.Count == 0)
			{
				return Type.FullName;
			}
			else
			{
				StringBuilder sb = new StringBuilder();
				sb.Append(Type.FullName).Append('<');
				int i = 0;
				foreach (TypeReference argument in Arguments.Values)
				{
					sb.Append(argument.FullName);
					i++;
					if (i < Arguments.Count)
					{
						sb.Append(", ");
					}
				}
				sb.Append('>');
				return sb.ToString();
			}
		}

		/// <summary>
		/// Replace generic parameters with actual arguments
		/// </summary>
		private MonoTypeContext ResolveGenericParameter()
		{
			switch (Type.GetEType())
			{
				case ElementType.Var:
				case ElementType.MVar:
					{
						GenericParameter parameter = (GenericParameter)Type;
						TypeReference resolvedType = Arguments[parameter];
						return new MonoTypeContext(resolvedType);
					}

				case ElementType.Array:
					{
						ArrayType array = (ArrayType)Type;
						MonoTypeContext arrayContext = new MonoTypeContext(array.ElementType, Arguments);
						MonoTypeContext resolvedContext = arrayContext.ResolveGenericParameter();
						ArrayType newArray = new ArrayType(resolvedContext.Type, array.Rank);
						if (array.Rank > 1)
						{
							for (int i = 0; i < array.Rank; i++)
							{
								newArray.Dimensions[i] = array.Dimensions[i];
							}
						}
						return new MonoTypeContext(newArray, Arguments);
					}

				case ElementType.GenericInst:
					{
						GenericInstanceType genericInstance = (GenericInstanceType)Type;
						GenericInstanceType newInstance = new GenericInstanceType(genericInstance.ElementType);
						foreach (TypeReference argument in genericInstance.GenericArguments)
						{
							MonoTypeContext argumentContext = new MonoTypeContext(argument, Arguments);
							MonoTypeContext resolvedArgument = argumentContext.Resolve();
							newInstance.GenericArguments.Add(resolvedArgument.Type);
						}
						return new MonoTypeContext(newInstance, Arguments);
					}

				case ElementType.ByRef:
					{
						ByReferenceType reference = (ByReferenceType)Type;
						MonoTypeContext refContext = new MonoTypeContext(reference.ElementType, Arguments);
						MonoTypeContext resolvedContext = refContext.ResolveGenericParameter();
						ByReferenceType newReference = new ByReferenceType(resolvedContext.Type);
						return new MonoTypeContext(newReference, Arguments);
					}

				case ElementType.Ptr:
					{
						PointerType pointer = (PointerType)Type;
						MonoTypeContext ptrContext = new MonoTypeContext(pointer.ElementType, Arguments);
						MonoTypeContext resolvedContext = ptrContext.ResolveGenericParameter();
						PointerType newPointer = new PointerType(resolvedContext.Type);
						return new MonoTypeContext(newPointer, Arguments);
					}

				case ElementType.Pinned:
					{
						PinnedType pinned = (PinnedType)Type;
						MonoTypeContext pinContext = new MonoTypeContext(pinned.ElementType, Arguments);
						MonoTypeContext resolvedContext = pinContext.ResolveGenericParameter();
						PinnedType newPinned = new PinnedType(resolvedContext.Type);
						return new MonoTypeContext(newPinned, Arguments);
					}

				case ElementType.FnPtr:
					{
						FunctionPointerType funcPtr = (FunctionPointerType)Type;
						FunctionPointerType newFuncPtr = new FunctionPointerType();
						newFuncPtr.HasThis = funcPtr.HasThis;
						newFuncPtr.ExplicitThis = funcPtr.ExplicitThis;
						newFuncPtr.CallingConvention = funcPtr.CallingConvention;
						MonoTypeContext returnContext = new MonoTypeContext(funcPtr.ReturnType, Arguments);
						MonoTypeContext resolvedReturn = returnContext.Resolve();
						newFuncPtr.ReturnType = resolvedReturn.Type;
						foreach (ParameterDefinition param in funcPtr.Parameters)
						{
							MonoTypeContext paramContext = new MonoTypeContext(param.ParameterType, Arguments);
							MonoTypeContext resolvedParam = paramContext.Resolve();
							ParameterDefinition newParameter = new ParameterDefinition(param.Name, param.Attributes, resolvedParam.Type);
							newFuncPtr.Parameters.Add(newParameter);
						}
						return new MonoTypeContext(newFuncPtr, Arguments);
					}

				default:
					throw new Exception($"Unknown generic parameter container {Type}");
			}
		}

	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Mono/MonoUtils.cs`:

```cs
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.Structure.Assembly.Mono.Extensions;
using Mono.Cecil;
using Mono.Collections.Generic;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetRipper.Core.Structure.Assembly.Mono
{
	public static class MonoUtils
	{
		#region Constants
		public const string ObjectName = "Object";
		public const string CObjectName = "object";
		public const string ValueType = "ValueType";
		public const string VoidName = "Void";
		public const string CVoidName = "void";
		public const string BooleanName = "Boolean";
		public const string BoolName = "bool";
		public const string IntPtrName = "IntPtr";
		public const string UIntPtrName = "UIntPtr";
		public const string CharName = "Char";
		public const string CCharName = "char";
		public const string SByteName = "SByte";
		public const string CSByteName = "sbyte";
		public const string ByteName = "Byte";
		public const string CByteName = "byte";
		public const string Int16Name = "Int16";
		public const string ShortName = "short";
		public const string UInt16Name = "UInt16";
		public const string UShortName = "ushort";
		public const string Int32Name = "Int32";
		public const string IntName = "int";
		public const string UInt32Name = "UInt32";
		public const string UIntName = "uint";
		public const string Int64Name = "Int64";
		public const string LongName = "long";
		public const string UInt64Name = "UInt64";
		public const string ULongName = "ulong";
		public const string HalfName = "Half";
		public const string SingleName = "Single";
		public const string FloatName = "float";
		public const string DoubleName = "Double";
		public const string CDoubleName = "double";
		public const string StringName = "String";
		public const string CStringName = "string";

		public const string SystemNamespace = "System";
		public const string SystemCollectionGenericNamespace = "System.Collections.Generic";
		public const string UnityEngineNamespace = "UnityEngine";
		public const string CompilerServicesNamespace = "System.Runtime.CompilerServices";

		public const string CompilerGeneratedName = "CompilerGeneratedAttribute";
		private const string SerializeFieldName = "SerializeField";
		private const string EnumValueFieldName = "value__";


		public const string Vector2Name = "Vector2";
		public const string Vector2IntName = "Vector2Int";
		public const string Vector3Name = "Vector3";
		public const string Vector3IntName = "Vector3Int";
		public const string Vector4Name = "Vector4";
		public const string RectName = "Rect";
		public const string BoundsName = "Bounds";
		public const string BoundsIntName = "BoundsInt";
		public const string QuaternionName = "Quaternion";
		public const string Matrix4x4Name = "Matrix4x4";
		public const string ColorName = "Color";
		public const string Color32Name = "Color32";
		public const string LayerMaskName = "LayerMask";
		public const string FloatCurveName = "FloatCurve";
		public const string Vector3CurveName = "Vector3Curve";
		public const string QuaternionCurveName = "QuaternionCurve";
		public const string PPtrCurveName = "PPtrCurve";
		public const string AnimationCurveName = "AnimationCurve";
		public const string GradientName = "Gradient";
		public const string RectOffsetName = "RectOffset";
		public const string GUIStyleName = "GUIStyle";
		public const string PropertyNameName = "PropertyName";

		private const string MulticastDelegateName = "MulticastDelegate";
		private const string ListName = "List`1";
		private const string ExposedReferenceName = "ExposedReference`1";

		private const string ScriptableObjectName = "ScriptableObject";
		private const string ComponentName = "Component";
		private const string BehaviourName = "Behaviour";
		private const string MonoBehaviourName = "MonoBehaviour";

		private const string MSCoreLibName = "mscorlib";
		private const string NetStandardName = "netstandard";
		private const string SystemName = "System";
		private const string CLRName = "CommonLanguageRuntimeLibrary";
		private const string UnityEngineName = "UnityEngine";
		private const string BooName = "Boo";
		private const string BooLangName = "Boo.Lang";
		private const string UnityScriptName = "UnityScript";
		private const string UnityScriptLangName = "UnityScript.Lang";
		private const string MonoName = "Mono";

		#endregion

		#region Assemblies

		public static string ToFullName(string module, string fullname)
		{
			return $"[{module}]{fullname}";
		}

		public static bool IsBuiltinLibrary(string module)
		{
			if (IsFrameworkLibrary(module))
			{
				return true;
			}
			if (IsUnityLibrary(module))
			{
				return true;
			}

			return false;
		}

		public static bool IsFrameworkLibrary(string module)
		{
			return module switch
			{
				MSCoreLibName or NetStandardName or SystemName or CLRName => true,
				_ => module.StartsWith($"{SystemName}.", StringComparison.Ordinal),
			};
		}

		public static bool IsUnityLibrary(string module)
		{
			switch (module)
			{
				case UnityEngineName:
				case BooName:
				case BooLangName:
				case UnityScriptName:
				case UnityScriptLangName:
					return true;

				default:
					{
						if (module.StartsWith($"{UnityEngineName}.", StringComparison.Ordinal))
						{
							return true;
						}
						if (module.StartsWith($"{MonoName}.", StringComparison.Ordinal))
						{
							return true;
						}
						return false;
					}
			}
		}

		#endregion

		#region Attributes
		public static bool IsCompilerGeneratedAttrribute(string @namespace, string name)
		{
			if (@namespace == CompilerServicesNamespace)
			{
				return name == CompilerGeneratedName;
			}
			else
			{
				return false;
			}
		}

		public static bool IsSerializeFieldAttrribute(string @namespace, string name)
		{
			if (@namespace == UnityEngineNamespace)
			{
				return name == SerializeFieldName;
			}
			else
			{
				return false;
			}
		}
		#endregion

		#region Naming
		public static string GetNestedName(TypeReference type)
		{
			string typeName = GetTypeName(type);
			return GetNestedName(type, typeName);
		}

		public static string GetNestedName(TypeReference type, string typeName)
		{
			if (type.IsGenericParameter)
			{
				return typeName;
			}
			if (type.IsArray)
			{
				return GetNestedName(type.GetElementType(), typeName);
			}
			if (type.IsNested)
			{
				string declaringName;
				if (type.IsGenericInstance)
				{
					GenericInstanceType generic = (GenericInstanceType)type;
					int argumentCount = MonoUtils.GetGenericArgumentCount(generic);
					List<TypeReference> genericArguments = new List<TypeReference>(generic.GenericArguments.Count - argumentCount);
					for (int i = 0; i < generic.GenericArguments.Count - argumentCount; i++)
					{
						genericArguments.Add(generic.GenericArguments[i]);
					}
					declaringName = GetNestedGenericName(type.DeclaringType, genericArguments);
				}
				else if (type.HasGenericParameters)
				{
					List<TypeReference> genericArguments = new List<TypeReference>(type.GenericParameters);
					declaringName = GetNestedGenericName(type.DeclaringType, genericArguments);
				}
				else
				{
					declaringName = GetNestedName(type.DeclaringType);
				}
				return $"{declaringName}.{typeName}";
			}
			return typeName;
		}

		public static string ToCleanName(string name)
		{
			int openIndex = name.IndexOf('<');
			if (openIndex == -1)
			{
				return name;
			}
			string firstPart = name.Substring(0, openIndex);
			int closeIndex = name.IndexOf('>');
			string secondPart = name.Substring(closeIndex + 1, name.Length - (closeIndex + 1));
			return firstPart + ToCleanName(secondPart);
		}

		public static string GetSimpleName(TypeReference type)
		{
			string name = type.Name;
			int index = name.IndexOf('`');
			if (index == -1)
			{
				return name;
			}

			bool strip = false;
			StringBuilder sb = new StringBuilder(name.Length);
			foreach (char c in name)
			{
				if (c == '`')
				{
					strip = true;
				}
				else if (!char.IsDigit(c))
				{
					strip = false;
				}

				if (!strip)
				{
					sb.Append(c);
				}
			}

			return sb.ToString();
		}

		public static string GetTypeName(TypeReference type)
		{
			if (IsCPrimitive(type))
			{
				return ToCPrimitiveString(type.Name);
			}

			if (type.IsGenericInstance)
			{
				GenericInstanceType generic = (GenericInstanceType)type;
				return GetGenericInstanceName(generic);
			}
			else if (type.HasGenericParameters)
			{
				return GetGenericTypeName(type);
			}
			else if (type.IsArray)
			{
				ArrayType array = (ArrayType)type;
				return GetTypeName(array.ElementType) + $"[{new string(',', array.Dimensions.Count - 1)}]";
			}
			return type.Name;
		}

		public static string GetFullName(TypeReference type)
		{
			string module = GetModuleName(type);
			return GetFullName(type, module);
		}

		public static string GetFullName(TypeReference type, string module)
		{
			string name = GetNestedName(type);
			string fullName = $"{type.Namespace}.{name}";
			return ToFullName(module, fullName);
		}

		public static string GetModuleName(TypeReference type)
		{
			// reference and definition may has differrent module, so to avoid duplicates we need try to get defition
			TypeReference definition = type.ResolveOrDefault();
			definition = definition == null ? type : definition;
			return BaseManager.ToAssemblyName(definition.Scope.Name);
		}

		private static string GetNestedGenericName(TypeReference type, List<TypeReference> genericArguments)
		{
			string name = type.Name;
			if (type.HasGenericParameters)
			{
				name = GetGenericTypeName(type, genericArguments);
				int argumentCount = MonoUtils.GetGenericParameterCount(type);
				genericArguments.RemoveRange(genericArguments.Count - argumentCount, argumentCount);
			}
			if (type.IsNested)
			{
				string declaringName = GetNestedGenericName(type.DeclaringType, genericArguments);
				return $"{declaringName}.{name}";
			}
			else
			{
				return name;
			}
		}

		public static bool HasMember(TypeReference type, string name)
		{
			if (type == null)
			{
				return false;
			}
			if (type.Module == null)
			{
				return false;
			}
			TypeDefinition definition = type.Resolve();
			if (definition == null)
			{
				return false;
			}

			foreach (FieldDefinition field in definition.Fields)
			{
				if (field.Name == name)
				{
					return true;
				}
			}
			foreach (PropertyDefinition property in definition.Properties)
			{
				if (property.Name == name)
				{
					return true;
				}
			}
			return HasMember(definition.BaseType, name);
		}

		public static string ToCPrimitiveString(string name)
		{
			return name switch
			{
				StringName or CStringName => CStringName,
				ObjectName or CObjectName => CObjectName,
				_ => ToPrimitiveString(name),
			};
		}

		public static string ToPrimitiveString(string name)
		{
			return name switch
			{
				VoidName or CVoidName => CVoidName,
				BooleanName or BoolName => BoolName,
				IntPtrName => IntPtrName,
				UIntPtrName => UIntPtrName,
				CharName or CCharName => CCharName,
				SByteName or CSByteName => CSByteName,
				ByteName or CByteName => CByteName,
				Int16Name or ShortName => ShortName,
				UInt16Name or UShortName => UShortName,
				Int32Name or IntName => IntName,
				UInt32Name or UIntName => UIntName,
				Int64Name or LongName => LongName,
				UInt64Name or ULongName => ULongName,
				HalfName => HalfName,
				SingleName or FloatName => FloatName,
				DoubleName or CDoubleName => CDoubleName,
				_ => throw new Exception(name),
			};
		}

		public static string GetName(TypeReference type)
		{
			if (IsCPrimitive(type))
			{
				return ToCPrimitiveString(type.Name);
			}
			else if (type.IsGenericInstance)
			{
				GenericInstanceType generic = (GenericInstanceType)type;
				return GetGenericInstanceName(generic);
			}
			else if (type.HasGenericParameters)
			{
				return GetGenericTypeName(type);
			}
			else if (type.IsArray)
			{
				ArrayType array = (ArrayType)type;
				return GetName(array.ElementType) + $"[{new string(',', array.Dimensions.Count - 1)}]";
			}
			return type.Name;
		}

		internal static string GetGenericTypeName(TypeReference genericType)
		{
			// TypeReference contain parameters with "<!0,!1> (!index)" name but TypeDefinition's name is "<T1,T2> (RealParameterName)"
			genericType = genericType.ResolveOrDefault();
			return GetGenericName(genericType, genericType.GenericParameters);
		}

		internal static string GetGenericTypeName(TypeReference genericType, IReadOnlyList<TypeReference> genericArguments)
		{
			genericType = genericType.ResolveOrDefault();
			return GetGenericName(genericType, genericArguments);
		}

		internal static string GetGenericInstanceName(GenericInstanceType genericInstance)
		{
			return GetGenericName(genericInstance.ElementType, genericInstance.GenericArguments);
		}

		internal static string GetGenericName(TypeReference genericType, IReadOnlyList<TypeReference> genericArguments)
		{
			string name = genericType.Name;
			int argumentCount = GetGenericParameterCount(genericType);
			int index = name.IndexOf('`');
			if (argumentCount == 0 || index < 0)
			{
				// nested class/enum (of generic class) is generic instance but it doesn't have '`' symbol in its name
				return name;
			}

			StringBuilder sb = new StringBuilder(genericType.Name, 0, index, 50 + index);
			sb.Append('<');
			for (int i = genericArguments.Count - argumentCount; i < genericArguments.Count; i++)
			{
				TypeReference arg = genericArguments[i];
				string argumentName = GetName(arg);
				sb.Append(argumentName);
				if (i < genericArguments.Count - 1)
				{
					sb.Append(", ");
				}
			}
			sb.Append('>');
			return sb.ToString();
		}

		internal static string GetGenericName<T>(TypeReference genericType, Collection<T> genericArguments) where T : TypeReference
		{
			string name = genericType.Name;
			int argumentCount = GetGenericParameterCount(genericType);
			int index = name.IndexOf('`');
			if (argumentCount == 0 || index < 0)
			{
				// nested class/enum (of generic class) is generic instance but it doesn't have '`' symbol in its name
				return name;
			}

			StringBuilder sb = new StringBuilder(genericType.Name, 0, index, 50 + index);
			sb.Append('<');
			for (int i = genericArguments.Count - argumentCount; i < genericArguments.Count; i++)
			{
				TypeReference arg = genericArguments[i];
				string argumentName = GetName(arg);
				sb.Append(argumentName);
				if (i < genericArguments.Count - 1)
				{
					sb.Append(", ");
				}
			}
			sb.Append('>');
			return sb.ToString();
		}
		#endregion

		#region Generics
		public static GenericInstanceType CreateGenericInstance(TypeReference genericTemplate, IEnumerable<TypeReference> arguments)
		{
			GenericInstanceType genericInstance = new GenericInstanceType(genericTemplate);
			foreach (TypeReference argument in arguments)
			{
				genericInstance.GenericArguments.Add(argument);
			}
			return genericInstance;
		}

		public static int GetGenericArgumentCount(GenericInstanceType genericInstance)
		{
			int count = genericInstance.GenericArguments.Count;
			if (genericInstance.IsNested)
			{
				TypeReference declaring = genericInstance.DeclaringType;
				if (declaring.HasGenericParameters)
				{
					count -= declaring.GenericParameters.Count;
				}
			}
			return count;
		}

		public static int GetGenericParameterCount(TypeReference genericType)
		{
			int count = genericType.GenericParameters.Count;
			if (genericType.IsNested)
			{
				TypeReference declaring = genericType.DeclaringType;
				if (declaring.HasGenericParameters)
				{
					count -= declaring.GenericParameters.Count;
				}
			}
			return count;
		}
		#endregion

		#region AreSame
		public static bool AreSame(TypeReference type, MonoTypeContext checkContext, TypeReference checkType)
		{
			if (ReferenceEquals(type, checkType))
			{
				return true;
			}
			else if (type == null || checkType == null)
			{
				return false;
			}

			MonoTypeContext context = new MonoTypeContext(checkType, checkContext);
			MonoTypeContext resolvedContext = context.Resolve();
			return MetadataResolverExtensions.AreSame(type, resolvedContext.Type);
		}

		public static bool AreSame(MethodDefinition method, MonoTypeContext checkContext, MethodDefinition checkMethod)
		{
			if (method.Name != checkMethod.Name)
			{
				return false;
			}
			if (method.HasGenericParameters)
			{
				if (!checkMethod.HasGenericParameters)
				{
					return false;
				}

				if (method.GenericParameters.Count != checkMethod.GenericParameters.Count)
				{
					return false;
				}

				checkContext = checkContext.Merge(checkMethod);
			}
			if (!AreSame(method.ReturnType, checkContext, checkMethod.ReturnType))
			{
				return false;
			}

			if (method.IsVarArg())
			{
				if (!checkMethod.IsVarArg())
				{
					return false;
				}

				if (method.Parameters.Count >= checkMethod.Parameters.Count)
				{
					return false;
				}

				if (checkMethod.GetSentinelPosition() != method.Parameters.Count)
				{
					return false;
				}
			}

			if (method.HasParameters)
			{
				if (!checkMethod.HasParameters)
				{
					return false;
				}

				if (method.Parameters.Count != checkMethod.Parameters.Count)
				{
					return false;
				}

				for (int i = 0; i < method.Parameters.Count; i++)
				{
					if (!AreSame(method.Parameters[i].ParameterType, checkContext, checkMethod.Parameters[i].ParameterType))
					{
						return false;
					}
				}
			}

			return true;
		}
		#endregion

		#region Boolean TypeReference Methods
		public static bool IsPrimitive(TypeReference type) => IsPrimitive(type.Namespace, type.Name);
		public static bool IsPrimitive(string @namespace, string name)
		{
			if (@namespace == SystemNamespace)
			{
				switch (name)
				{
					case VoidName:
					case CVoidName:
					case BooleanName:
					case BoolName:
					case SByteName:
					case CSByteName:
					case ByteName:
					case CByteName:
					case CharName:
					case CCharName:
					case Int16Name:
					case ShortName:
					case UInt16Name:
					case UShortName:
					case Int32Name:
					case IntName:
					case UInt32Name:
					case UIntName:
					case Int64Name:
					case LongName:
					case UInt64Name:
					case ULongName:
					case SingleName:
					case FloatName:
					case DoubleName:
					case CDoubleName:
						return true;
				}
			}
			return false;
		}

		public static bool IsCPrimitive(TypeReference type) => IsCPrimitive(type.Namespace, type.Name);
		public static bool IsCPrimitive(string @namespace, string name)
		{
			if (IsPrimitive(@namespace, name))
			{
				return true;
			}

			if (IsString(@namespace, name))
			{
				return true;
			}

			if (IsObject(@namespace, name))
			{
				return true;
			}

			return false;
		}

		public static bool IsBasic(TypeReference type) => IsBasic(type.Namespace, type.Name);
		public static bool IsBasic(string @namespace, string name)
		{
			if (IsObject(@namespace, name))
			{
				return true;
			}

			if (@namespace == SystemNamespace && name == ValueType)
			{
				return true;
			}

			return false;
		}

		public static bool IsDelegate(TypeReference type) => IsDelegate(type.Namespace, type.Name);
		public static bool IsDelegate(string @namespace, string name)
		{
			return @namespace == SystemNamespace && name == MulticastDelegateName;
		}

		public static bool IsObject(TypeReference type) => IsObject(type.Namespace, type.Name);
		public static bool IsObject(string @namespace, string name)
		{
			return @namespace == SystemNamespace && (name == ObjectName || name == CObjectName);
		}

		public static bool IsString(TypeReference type) => IsString(type.Namespace, type.Name);
		public static bool IsString(string @namespace, string name)
		{
			return @namespace == SystemNamespace && (name == StringName || name == CStringName);
		}

		public static bool IsList(TypeReference type) => IsList(type.Namespace, type.Name);
		public static bool IsList(string @namespace, string name)
		{
			return @namespace == SystemCollectionGenericNamespace && name == ListName;
		}

		public static bool IsEngineObject(TypeReference type) => IsEngineObject(type.Namespace, type.Name);
		public static bool IsEngineObject(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == ObjectName;
		}

		public static bool IsScriptableObject(TypeReference type) => IsScriptableObject(type.Namespace, type.Name);
		public static bool IsScriptableObject(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == ScriptableObjectName;
		}

		public static bool IsComponent(TypeReference type) => IsComponent(type.Namespace, type.Name);
		public static bool IsComponent(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == ComponentName;
		}

		public static bool IsBehaviour(TypeReference type) => IsBehaviour(type.Namespace, type.Name);
		public static bool IsBehaviour(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == BehaviourName;
		}

		public static bool IsMonoBehaviour(TypeReference type) => IsMonoBehaviour(type.Namespace, type.Name);
		public static bool IsMonoBehaviour(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == MonoBehaviourName;
		}

		public static bool IsEngineStruct(TypeReference type) => IsEngineStruct(type.Namespace, type.Name);
		public static bool IsEngineStruct(string @namespace, string name)
		{
			if (@namespace == UnityEngineNamespace)
			{
				switch (name)
				{
					case Vector2Name:
					case Vector2IntName:
					case Vector3Name:
					case Vector3IntName:
					case Vector4Name:
					case RectName:
					case BoundsName:
					case BoundsIntName:
					case QuaternionName:
					case Matrix4x4Name:
					case ColorName:
					case Color32Name:
					case LayerMaskName:
					case AnimationCurveName:
					case GradientName:
					case RectOffsetName:
					case GUIStyleName:
						return true;

					case PropertyNameName:
						return true;
				}
			}
			return false;
		}

		public static bool IsExposedReference(TypeReference type) => IsExposedReference(type.Namespace, type.Name);
		public static bool IsExposedReference(string @namespace, string name)
		{
			return @namespace == UnityEngineNamespace && name == ExposedReferenceName;
		}

		public static bool IsPrime(TypeReference type) => IsPrime(type.Namespace, type.Name);
		public static bool IsPrime(string @namespace, string name)
		{
			if (IsObject(@namespace, name))
			{
				return true;
			}

			if (IsMonoPrime(@namespace, name))
			{
				return true;
			}

			return false;
		}

		public static bool IsMonoPrime(TypeReference type) => IsMonoPrime(type.Namespace, type.Name);
		public static bool IsMonoPrime(string @namespace, string name)
		{
			if (IsMonoBehaviour(@namespace, name))
			{
				return true;
			}

			if (IsBehaviour(@namespace, name))
			{
				return true;
			}

			if (IsComponent(@namespace, name))
			{
				return true;
			}

			if (IsEngineObject(@namespace, name))
			{
				return true;
			}

			return false;
		}

		public static bool IsBuiltinGeneric(TypeReference type) => IsBuiltinGeneric(type.Namespace, type.Name);
		public static bool IsBuiltinGeneric(string @namespace, string name)
		{
			return IsList(@namespace, name) || IsExposedReference(@namespace, name);
		}
		#endregion

		#region Helpers
		public static bool IsSerializablePrimitive_EType(TypeReference type)
		{
			switch (type.GetEType())
			{
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
					return true;
				default:
					return false;
			}
		}

		public static bool IsCPrimitive_EType(TypeReference type)
		{
			switch (type.GetEType())
			{
				case ElementType.Boolean:
				case ElementType.Char:
				case ElementType.I:
				case ElementType.U:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
				case ElementType.Object:
					return true;

				default:
					return false;
			}
		}

		public static bool IsSerializableArray(TypeReference type)
		{
			return type.IsArray || IsList(type);
		}

		public static bool IsSerializableGeneric(TypeReference type, IReadOnlyDictionary<GenericParameter, TypeReference> arguments)
		{
			if (type.IsGenericInstance)
			{
				if (IsBuiltinGeneric(type))
				{
					return true;
				}

				TypeDefinition definition = type.Resolve();
				if (definition.IsEnum)
				{
					return true;
				}

				if (definition.IsSerializable && type is GenericInstanceType git)
				{
					bool allSerializableArgs = git.GenericArguments.All(t =>
					{
						if (t is GenericParameter p && arguments.TryGetValue(p, out TypeReference? resolved))
						{
							t = resolved;
						}

						if (t.IsGenericInstance)
						{
							return IsSerializableGeneric(t, arguments);
						}

						TypeDefinition resolvedType = t.Resolve();

						if (resolvedType == null)
						{
							return false;
						}

						if (resolvedType.IsSerializable)
						{
							return true;
						}

						if (resolvedType.BaseType?.Resolve()?.IsSerializable == true)
						{
							return true;
						}

						return false;
					});

					return allSerializableArgs;
				}
			}
			return false;
		}

		public static bool IsMonoDerived(TypeReference type)
		{
			while (type != null)
			{
				if (IsMonoPrime(type))
				{
					return true;
				}

				TypeDefinition definition = type.Resolve();
				type = definition.BaseType;
			}
			return false;
		}

		public static bool HasSerializeFieldAttribute(FieldDefinition field)
		{
			foreach (CustomAttribute attribute in field.CustomAttributes)
			{
				TypeReference type = attribute.AttributeType;
				if (IsSerializeFieldAttrribute(type.Namespace, type.Name))
				{
					return true;
				}
			}
			return false;
		}

		public static PrimitiveType ToPrimitiveType(TypeReference type)
		{
			TypeDefinition definition = type.Resolve();
			if (definition.IsEnum)
			{
				foreach (FieldDefinition field in definition.Fields)
				{
					if (field.Name == EnumValueFieldName)
					{
						type = field.FieldType;
						break;
					}
				}
			}

			return ToPrimitiveType(type.Namespace, type.Name);
		}

		public static PrimitiveType ToPrimitiveType(string @namespace, string name)
		{
			if (@namespace == SystemNamespace)
			{
				return name switch
				{
					VoidName => PrimitiveType.Void,
					BooleanName => PrimitiveType.Bool,
					CharName => PrimitiveType.Char,
					SByteName => PrimitiveType.SByte,
					ByteName => PrimitiveType.Byte,
					Int16Name => PrimitiveType.Short,
					UInt16Name => PrimitiveType.UShort,
					Int32Name => PrimitiveType.Int,
					UInt32Name => PrimitiveType.UInt,
					Int64Name => PrimitiveType.Long,
					UInt64Name => PrimitiveType.ULong,
					HalfName => PrimitiveType.Half,
					SingleName => PrimitiveType.Single,
					DoubleName => PrimitiveType.Double,
					StringName => PrimitiveType.String,
					_ => PrimitiveType.Complex,
				};
			}
			return PrimitiveType.Complex;
		}

		public static bool IsCompilerGenerated(TypeDefinition type)
		{
			foreach (CustomAttribute attr in type.CustomAttributes)
			{
				if (IsCompilerGeneratedAttrribute(attr.AttributeType.Namespace, attr.AttributeType.Name))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsCompilerGenerated(FieldDefinition field)
		{
			foreach (CustomAttribute attr in field.CustomAttributes)
			{
				if (IsCompilerGeneratedAttrribute(attr.AttributeType.Namespace, attr.AttributeType.Name))
				{
					return true;
				}
			}
			return false;
		}
		#endregion

		#region Serialization
		public static bool IsSerializable(in MonoFieldContext context)
		{
			if (IsSerializableModifier(context.Definition))
			{
				return IsFieldTypeSerializable(context);
			}
			return false;
		}

		public static bool IsSerializableModifier(FieldDefinition field)
		{
			if (field.HasConstant)
			{
				return false;
			}
			else if (field.IsStatic)
			{
				return false;
			}
			else if (field.IsInitOnly)
			{
				return false;
			}
			else if (IsCompilerGenerated(field))
			{
				return false;
			}
			else if (field.IsPublic)
			{
				if (field.IsNotSerialized)
				{
					return false;
				}
				return true;
			}
			else
			{
				return HasSerializeFieldAttribute(field);
			}
		}

		public static bool IsFieldTypeSerializable(in MonoFieldContext context)
		{
			TypeReference fieldType = context.ElementType;

			// if it's generic parameter then get its real type
			if (fieldType.IsGenericParameter)
			{
				GenericParameter parameter = (GenericParameter)fieldType;
				fieldType = context.Arguments?[parameter] ?? throw new Exception();
			}

			if (fieldType.IsArray)
			{
				ArrayType array = (ArrayType)fieldType;
				// one dimention array only
				if (!array.IsVector)
				{
					return false;
				}

				// if it's generic parameter then get its real type
				TypeReference elementType = array.ElementType;
				if (elementType.IsGenericParameter)
				{
					GenericParameter parameter = (GenericParameter)elementType;
					elementType = context.Arguments?[parameter] ?? throw new Exception();
				}

				// array of arrays isn't serializable
				if (elementType.IsArray)
				{
					return false;
				}
				// array of serializable generics is serializable
				if (IsSerializableGeneric(elementType, context.Arguments ?? throw new Exception()))
				{
					return true;
				}
				// check if array element is serializable
				MonoFieldContext elementScope = new MonoFieldContext(context, elementType, true);
				return IsFieldTypeSerializable(elementScope);
			}

			if (IsList(fieldType))
			{
				// list is serialized same way as array, so check its argument
				GenericInstanceType list = (GenericInstanceType)fieldType;
				TypeReference listElement = list.GenericArguments[0];

				// if it's generic parameter then get its real type
				if (listElement.IsGenericParameter)
				{
					GenericParameter parameter = (GenericParameter)listElement;
					listElement = context.Arguments?[parameter] ?? throw new Exception();
				}

				// list of arrays isn't serializable
				if (listElement.IsArray)
				{
					return false;
				}
				// list of buildin generics isn't serializable
				if (IsBuiltinGeneric(listElement))
				{
					return false;
				}
				// check if list element is serializable
				MonoFieldContext elementScope = new MonoFieldContext(context, listElement, true);
				return IsFieldTypeSerializable(elementScope);
			}

			if (IsSerializablePrimitive_EType(fieldType))
			{
				return true;
			}
			if (IsObject(fieldType))
			{
				return false;
			}

			if (IsEngineStruct(fieldType))
			{
				return true;
			}
			if (fieldType.IsGenericInstance)
			{
				// even monobehaviour derived generic instances aren't serialiable
				return IsSerializableGeneric(fieldType, context.Arguments ?? throw new Exception());
			}
			if (IsMonoDerived(fieldType))
			{
				if (fieldType.ContainsGenericParameter)
				{
					return false;
				}
				return true;
			}

			if (IsRecursive(context.DeclaringType, fieldType))
			{
				return context.IsArray;
			}

			TypeDefinition definition = fieldType.Resolve();
			if (definition.IsInterface)
			{
				return false;
			}
			if (definition.IsAbstract)
			{
				return false;
			}
			if (IsCompilerGenerated(definition))
			{
				return false;
			}
			if (definition.IsEnum)
			{
				return true;
			}
			if (definition.IsSerializable)
			{
				if (IsFrameworkLibrary(GetModuleName(definition)))
				{
					return false;
				}
				if (definition.IsValueType && !context.Layout.IsStructSerializable)
				{
					return false;
				}
				return true;
			}

			return false;
		}

		private static bool IsRecursive(TypeReference declaringType, TypeReference fieldType)
		{
			// "built in" primitive .NET types are placed into itself... it is so stupid
			// field.FieldType.IsPrimitive || MonoType.IsString(field.FieldType) || MonoType.IsEnginePointer(field.FieldType) => return false
			if (IsDelegate(fieldType))
			{
				return false;
			}
			if (declaringType == fieldType)
			{
				return true;
			}
			return false;
		}
		#endregion
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/PrimitiveType.cs`:

```cs
namespace AssetRipper.Core.Structure.Assembly
{
	public enum PrimitiveType
	{
		Void,
		Bool,
		Char,
		SByte,
		Byte,
		Short,
		UShort,
		Int,
		UInt,
		Long,
		ULong,
		Half,
		Single,
		Double,
		String,
		Complex,
	}

	public static class PrimitiveTypeExtensions
	{
		public static int GetSize(this PrimitiveType _this)
		{
			switch (_this)
			{
				case PrimitiveType.Bool:
				case PrimitiveType.Char:
				case PrimitiveType.Byte:
				case PrimitiveType.SByte:
					return 1;

				case PrimitiveType.Short:
				case PrimitiveType.UShort:
				case PrimitiveType.Half:
					return 2;

				case PrimitiveType.Int:
				case PrimitiveType.UInt:
				case PrimitiveType.Single:
					return 4;

				case PrimitiveType.Long:
				case PrimitiveType.ULong:
				case PrimitiveType.Double:
					return 8;

				case PrimitiveType.String:
				case PrimitiveType.Complex:
					return -1;

				default:
					throw new NotImplementedException();
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/ScriptIdentifier.cs`:

```cs
namespace AssetRipper.Core.Structure.Assembly
{
	public struct ScriptIdentifier
	{
		public ScriptIdentifier(string assembly, string @namespace, string name)
		{
			if (string.IsNullOrEmpty(assembly))
			{
				throw new ArgumentNullException(nameof(assembly));
			}
			if (@namespace == null)
			{
				throw new ArgumentNullException(nameof(@namespace));
			}
			if (string.IsNullOrEmpty(name))
			{
				throw new ArgumentNullException(nameof(name));
			}
			Assembly = assembly;
			Namespace = @namespace;
			Name = name;
		}

		public static string ToUniqueName(string assembly, string @namespace, string name)
		{
			return @namespace == string.Empty ? $"[{assembly}]{name}" : $"[{assembly}]{@namespace}.{name}";
		}

		public static string ToUniqueName(string assembly, string fullName)
		{
			return $"[{assembly}]{fullName}";
		}

		public static bool operator ==(ScriptIdentifier left, ScriptIdentifier right)
		{
			if (left.Assembly != right.Assembly)
			{
				return false;
			}
			if (left.Namespace != right.Namespace)
			{
				return false;
			}
			if (left.Name != right.Name)
			{
				return false;
			}
			return true;
		}

		public static bool operator !=(ScriptIdentifier left, ScriptIdentifier right)
		{
			if (left.Assembly != right.Assembly)
			{
				return true;
			}
			if (left.Namespace != right.Namespace)
			{
				return true;
			}
			if (left.Name != right.Name)
			{
				return true;
			}
			return false;
		}

		public override bool Equals(object? obj)
		{
			if (obj == null)
			{
				return false;
			}
			if (obj.GetType() != typeof(ScriptIdentifier))
			{
				return false;
			}
			return this == (ScriptIdentifier)obj;
		}

		public override int GetHashCode()
		{
			int hash = 317;
			unchecked
			{
				hash = hash + (89 * Assembly.GetHashCode());
				hash = (hash * 79) + Namespace.GetHashCode();
				hash = (hash * 37) + Name.GetHashCode();
			}
			return hash;
		}

		public override string? ToString()
		{
			return IsDefault ? base.ToString() : Namespace == string.Empty ? $"{Name}" : $"{Namespace}.{Name}";
		}

		public bool IsDefault => Name == null;
		public string UniqueName => ToUniqueName(Assembly, Namespace, Name);

		public string Assembly { get; }
		public string Namespace { get; }
		public string Name { get; }
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/ScriptingBackend.cs`:

```cs
namespace AssetRipper.Core.Structure.Assembly
{
	public enum ScriptingBackend
	{
		Unknown,

		Mono,
		IL2Cpp
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Serializable/SerializableField.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;

using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Structure.Assembly.Serializable
{
	public struct SerializableField
	{
		public void Read(AssetReader reader, int depth, in SerializableType.Field etalon)
		{
			switch (etalon.Type.Type)
			{
				case PrimitiveType.Bool:
					if (etalon.IsArray)
					{
						CValue = reader.ReadBooleanArray();
					}
					else
					{
						PValue = reader.ReadBoolean() ? 1U : 0U;
					}
					reader.AlignStream();
					break;

				case PrimitiveType.Char:
					if (etalon.IsArray)
					{
						CValue = reader.ReadCharArray();
					}
					else
					{
						PValue = reader.ReadChar();
					}
					reader.AlignStream();
					break;

				case PrimitiveType.SByte:
					if (etalon.IsArray)
					{
						CValue = reader.ReadByteArray();
					}
					else
					{
						PValue = unchecked((byte)reader.ReadSByte());
					}
					reader.AlignStream();
					break;

				case PrimitiveType.Byte:
					if (etalon.IsArray)
					{
						CValue = reader.ReadByteArray();
					}
					else
					{
						PValue = reader.ReadByte();
					}
					reader.AlignStream();
					break;

				case PrimitiveType.Short:
					if (etalon.IsArray)
					{
						CValue = reader.ReadInt16Array();
					}
					else
					{
						PValue = unchecked((ushort)reader.ReadInt16());
					}
					reader.AlignStream();
					break;

				case PrimitiveType.UShort:
					if (etalon.IsArray)
					{
						CValue = reader.ReadUInt16Array();
					}
					else
					{
						PValue = reader.ReadUInt16();
					}
					reader.AlignStream();
					break;

				case PrimitiveType.Int:
					if (etalon.IsArray)
					{
						CValue = reader.ReadInt32Array();
					}
					else
					{
						PValue = unchecked((uint)reader.ReadInt32());
					}
					break;

				case PrimitiveType.UInt:
					if (etalon.IsArray)
					{
						CValue = reader.ReadUInt32Array();
					}
					else
					{
						PValue = reader.ReadUInt32();
					}
					break;

				case PrimitiveType.Long:
					if (etalon.IsArray)
					{
						CValue = reader.ReadInt64Array();
					}
					else
					{
						PValue = unchecked((ulong)reader.ReadInt64());
					}
					break;

				case PrimitiveType.ULong:
					if (etalon.IsArray)
					{
						CValue = reader.ReadUInt64Array();
					}
					else
					{
						PValue = reader.ReadUInt64();
					}
					break;

				case PrimitiveType.Single:
					if (etalon.IsArray)
					{
						CValue = reader.ReadSingleArray();
					}
					else
					{
						PValue = BitConverter.SingleToUInt32Bits(reader.ReadSingle());
					}
					break;

				case PrimitiveType.Double:
					if (etalon.IsArray)
					{
						CValue = reader.ReadDoubleArray();
					}
					else
					{
						PValue = BitConverter.DoubleToUInt64Bits(reader.ReadDouble());
					}
					break;

				case PrimitiveType.String:
					if (etalon.IsArray)
					{
						CValue = reader.ReadStringArray();
					}
					else
					{
						CValue = reader.ReadString();
					}
					break;

				case PrimitiveType.Complex:
					if (etalon.IsArray)
					{
						int count = reader.ReadInt32();

						if (count > 1_000_000)
						{
							Logger.Warning($"Unreasonable count for complex array: {count} for field {etalon.Name} of type {etalon.Type}. Probably means there's a bug in serializable detection. Expecting to deadlock here.");
						}

						IAsset[] structures = new IAsset[count];
						for (int i = 0; i < count; i++)
						{
							IAsset structure = etalon.Type.CreateInstance(depth + 1, reader.Version);
							structure.Read(reader);
							structures[i] = structure;
						}
						CValue = structures;
					}
					else
					{
						IAsset structure = etalon.Type.CreateInstance(depth + 1, reader.Version);
						structure.Read(reader);
						CValue = structure;
					}
					break;

				default:
					throw new NotSupportedException(etalon.Type.Type.ToString());
			}
		}

		public void Write(AssetWriter writer, in SerializableType.Field etalon)
		{
			switch (etalon.Type.Type)
			{
				case PrimitiveType.Bool:
					if (etalon.IsArray)
					{
						((bool[])CValue).Write(writer);
					}
					else
					{
						writer.Write(PValue != 0);
					}
					writer.AlignStream();
					break;

				case PrimitiveType.Char:
					if (etalon.IsArray)
					{
						((char[])CValue).Write(writer);
					}
					else
					{
						writer.Write((char)PValue);
					}
					writer.AlignStream();
					break;

				case PrimitiveType.SByte:
					if (etalon.IsArray)
					{
						((byte[])CValue).Write(writer);
					}
					else
					{
						writer.Write(unchecked((sbyte)PValue));
					}
					writer.AlignStream();
					break;

				case PrimitiveType.Byte:
					if (etalon.IsArray)
					{
						((byte[])CValue).Write(writer);
					}
					else
					{
						writer.Write((byte)PValue);
					}
					writer.AlignStream();
					break;

				case PrimitiveType.Short:
					if (etalon.IsArray)
					{
						((short[])CValue).Write(writer);
					}
					else
					{
						writer.Write(unchecked((short)PValue));
					}
					writer.AlignStream();
					break;

				case PrimitiveType.UShort:
					if (etalon.IsArray)
					{
						((ushort[])CValue).Write(writer);
					}
					else
					{
						writer.Write((ushort)PValue);
					}
					writer.AlignStream();
					break;

				case PrimitiveType.Int:
					if (etalon.IsArray)
					{
						((int[])CValue).Write(writer);
					}
					else
					{
						writer.Write(unchecked((int)PValue));
					}
					break;

				case PrimitiveType.UInt:
					if (etalon.IsArray)
					{
						((uint[])CValue).Write(writer);
					}
					else
					{
						writer.Write((uint)PValue);
					}
					break;

				case PrimitiveType.Long:
					if (etalon.IsArray)
					{
						((long[])CValue).Write(writer);
					}
					else
					{
						writer.Write(unchecked((long)PValue));
					}
					break;

				case PrimitiveType.ULong:
					if (etalon.IsArray)
					{
						((ulong[])CValue).Write(writer);
					}
					else
					{
						writer.Write(PValue);
					}
					break;

				case PrimitiveType.Single:
					if (etalon.IsArray)
					{
						((float[])CValue).Write(writer);
					}
					else
					{
						writer.Write(BitConverter.UInt32BitsToSingle((uint)PValue));
					}
					break;

				case PrimitiveType.Double:
					if (etalon.IsArray)
					{
						((double[])CValue).Write(writer);
					}
					else
					{
						writer.Write(BitConverter.UInt64BitsToDouble(PValue));
					}
					break;

				case PrimitiveType.String:
					if (etalon.IsArray)
					{
						((string[])CValue).Write(writer);
					}
					else
					{
						writer.Write((string)CValue);
					}
					break;

				case PrimitiveType.Complex:
					if (etalon.IsArray)
					{
						((IAsset[])CValue).Write(writer);
					}
					else
					{
						((IAsset)CValue).Write(writer);
					}
					break;

				default:
					throw new NotSupportedException(etalon.Type.Type.ToString());
			}
		}

		public YamlNode ExportYaml(IExportContainer container, in SerializableType.Field etalon)
		{
			if (etalon.IsArray)
			{
				if (etalon.Type.Type == PrimitiveType.Complex)
				{
					IAsset[] structures = (IAsset[])CValue;
					return structures.ExportYaml(container);
				}
				else
				{
					switch (etalon.Type.Type)
					{
						case PrimitiveType.Bool:
							{
								bool[] array = (bool[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.Char:
							{
								char[] array = (char[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.SByte:
							{
								byte[] array = (byte[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.Byte:
							{
								byte[] array = (byte[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.Short:
							{
								short[] array = (short[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.UShort:
							{
								ushort[] array = (ushort[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.Int:
							{
								int[] array = (int[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.UInt:
							{
								uint[] array = (uint[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.Long:
							{
								long[] array = (long[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.ULong:
							{
								ulong[] array = (ulong[])CValue;
								return array.ExportYaml(true);
							}
						case PrimitiveType.Single:
							{
								float[] array = (float[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.Double:
							{
								double[] array = (double[])CValue;
								return array.ExportYaml();
							}
						case PrimitiveType.String:
							{
								string[] array = (string[])CValue;
								return array.ExportYaml();
							}
						default:
							throw new NotSupportedException(etalon.Type.Type.ToString());
					}
				}
			}
			else
			{
				if (etalon.Type.Type == PrimitiveType.Complex)
				{
					IAsset structure = (IAsset)CValue;
					return structure.ExportYaml(container);
				}
				else
				{
					return etalon.Type.Type switch
					{
						PrimitiveType.Bool => new YamlScalarNode(PValue != 0),
						PrimitiveType.Char => new YamlScalarNode((int)(char)PValue),
						PrimitiveType.SByte => new YamlScalarNode(unchecked((sbyte)PValue)),
						PrimitiveType.Byte => new YamlScalarNode((byte)PValue),
						PrimitiveType.Short => new YamlScalarNode(unchecked((short)PValue)),
						PrimitiveType.UShort => new YamlScalarNode((ushort)PValue),
						PrimitiveType.Int => new YamlScalarNode(unchecked((int)PValue)),
						PrimitiveType.UInt => new YamlScalarNode((uint)PValue),
						PrimitiveType.Long => new YamlScalarNode(unchecked((long)PValue)),
						PrimitiveType.ULong => new YamlScalarNode(PValue),
						PrimitiveType.Single => new YamlScalarNode(BitConverter.UInt32BitsToSingle((uint)PValue)),
						PrimitiveType.Double => new YamlScalarNode(BitConverter.UInt64BitsToDouble(PValue)),
						PrimitiveType.String => new YamlScalarNode((string)CValue),
						_ => throw new NotSupportedException(etalon.Type.Type.ToString()),
					};
				}
			}
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context, SerializableType.Field etalon)
		{
			if (etalon.Type.Type == PrimitiveType.Complex)
			{
				if (etalon.IsArray)
				{
					IAsset[] structures = (IAsset[])CValue;
					if (structures.Length > 0 && structures[0] is IDependent)
					{
						foreach (PPtr<IUnityObjectBase> asset in context.FetchDependenciesFromArray(structures.Cast<IDependent>(), etalon.Name))
						{
							yield return asset;
						}
					}
				}
				else
				{
					IAsset structure = (IAsset)CValue;
					if (structure is IDependent dependent)
					{
						foreach (PPtr<IUnityObjectBase> asset in context.FetchDependenciesFromDependent(dependent, etalon.Name))
						{
							yield return asset;
						}
					}
				}
			}
		}

		public ulong PValue { get; set; }
		public object CValue { get; set; }
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Serializable/SerializablePointer.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Structure.Assembly.Serializable
{
	public sealed class SerializablePointer : IAsset, IDependent
	{
		public void Read(AssetReader reader)
		{
			Pointer.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			Pointer.Write(writer);
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			yield return context.FetchDependency(Pointer, string.Empty);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			return Pointer.ExportYaml(container);
		}

		public PPtr<IUnityObjectBase> Pointer = new();
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Serializable/SerializableStructure.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Core.Structure.Assembly.Mono;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Structure.Assembly.Serializable
{
	public sealed class SerializableStructure : IAsset, IDependent
	{
		internal SerializableStructure(SerializableType type, int depth)
		{
			Depth = depth;
			Type = type ?? throw new ArgumentNullException(nameof(type));
			Fields = new SerializableField[type.FieldCount];
		}

		public void Read(AssetReader reader)
		{
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableType.Field etalon = Type.GetField(i);
				if (IsAvailable(etalon))
				{
					Fields[i].Read(reader, Depth, etalon);
				}
			}
		}

		public void Write(AssetWriter writer)
		{
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableType.Field etalon = Type.GetField(i);
				if (IsAvailable(etalon))
				{
					Fields[i].Write(writer, etalon);
				}
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableType.Field etalon = Type.GetField(i);
				if (IsAvailable(etalon))
				{
					node.Add(etalon.Name, Fields[i].ExportYaml(container, etalon));
				}
			}
			return node;
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			for (int i = 0; i < Fields.Length; i++)
			{
				SerializableType.Field etalon = Type.GetField(i);
				if (IsAvailable(etalon))
				{
					foreach (PPtr<IUnityObjectBase> asset in Fields[i].FetchDependencies(context, etalon))
					{
						yield return asset;
					}
				}
			}
		}

		public override string ToString()
		{
			if (Type.Namespace.Length == 0)
			{
				return $"{Type.Name}";
			}
			else
			{
				return $"{Type.Namespace}.{Type.Name}";
			}
		}

		private bool IsAvailable(in SerializableType.Field field)
		{
			if (Depth < MaxDepthLevel)
			{
				return true;
			}
			if (field.IsArray)
			{
				return false;
			}
			if (field.Type.Type == PrimitiveType.Complex)
			{
				if (MonoUtils.IsEngineStruct(field.Type.Namespace, field.Type.Name))
				{
					return true;
				}
				return false;
			}
			return true;
		}

		public int Depth { get; }
		public SerializableType Type { get; }
		public SerializableField[] Fields { get; }

		public const int MaxDepthLevel = 8;
	}
}

```

`AssetRipper.Fundamentals/Structure/Assembly/Serializable/SerializableType.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Structure.Assembly.Mono;
using AssetRipper.Core.VersionHandling;
using System.Collections.Generic;
using System.Linq;
using static AssetRipper.Core.Structure.Assembly.Mono.MonoUtils;

namespace AssetRipper.Core.Structure.Assembly.Serializable
{
	public abstract class SerializableType
	{
		public readonly struct Field
		{
			public Field(SerializableType type, int arrayDepth, string name)
			{
				Type = type;
				ArrayDepth = arrayDepth;
				Name = name;
			}

			public override string? ToString()
			{
				if (Type == null)
				{
					return base.ToString();
				}

				return $"{Type}{string.Concat(Enumerable.Repeat("[]", ArrayDepth))} {Name}";
			}

			public SerializableType Type { get; }
			public int ArrayDepth { get; }
			public bool IsArray => ArrayDepth > 0;
			public string Name { get; }
		}

		protected SerializableType(string @namespace, PrimitiveType type, string name)
		{
			Namespace = @namespace ?? throw new ArgumentNullException(nameof(@namespace));
			Type = type;
			Name = name ?? throw new ArgumentNullException(nameof(name));
			// is a placeholder - Is assigned by inheriting types.
			Fields = new List<Field>();
		}

		public SerializableStructure CreateSerializableStructure()
		{
			return new SerializableStructure(this, 0);
		}

		public IAsset CreateInstance(int depth, UnityVersion version)
		{
			if (MonoUtils.IsEngineStruct(Namespace, Name))
			{
				return VersionManager.AssetFactory.CreateEngineAsset(Name);
			}
			if (IsEnginePointer())
			{
				return new SerializablePointer();
			}
			return new SerializableStructure(this, depth);
		}

		public Field GetField(int index)
		{
			if (index < BaseFieldCount && Base != null)
			{
				return Base.GetField(index);
			}
			return Fields[index - BaseFieldCount];
		}

		public bool IsPrimitive()
		{
			return MonoUtils.IsPrimitive(Namespace, Name);
		}

		public bool IsString()
		{
			return MonoUtils.IsString(Namespace, Name);
		}

		public bool IsEngineStruct()
		{
			return MonoUtils.IsEngineStruct(Namespace, Name);
		}

		public bool IsEnginePointer()
		{
			if (IsObject(Namespace, Name))
			{
				return false;
			}
			if (IsMonoPrime(Namespace, Name))
			{
				return true;
			}
			if (Base == null)
			{
				return false;
			}
			return Base.IsEnginePointer();
		}

		public override string ToString()
		{
			return Namespace.Length == 0 ? Name : $"{Namespace}.{Name}";
		}

		public string Namespace { get; }
		public PrimitiveType Type { get; }
		public string Name { get; }
		public SerializableType? Base { get; protected set; }
		public IReadOnlyList<Field> Fields { get; protected set; }
		public int FieldCount => BaseFieldCount + Fields.Count;

		internal int BaseFieldCount
		{
			get
			{
				if (m_baseFieldCount < 0)
				{
					m_baseFieldCount = Base == null ? 0 : Base.FieldCount;
				}
				return m_baseFieldCount;
			}
		}

		private int m_baseFieldCount = -1;
	}
}

```

`AssetRipper.Fundamentals/Structure/GameCollection.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.Utils;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace AssetRipper.Core.Structure
{
	public sealed class GameCollection : FileList, IFileCollection, IDisposable
	{
		public LayoutInfo Layout { get; }

		public IReadOnlyDictionary<string, SerializedFile> GameFiles => m_files;
		public IAssemblyManager AssemblyManager { get; set; }

		public List<ResourceFile?> GameResourceFiles => m_resources.Values.ToList();
		public List<SerializedFile> GameSerializedFiles => m_files.Values.ToList();

		private readonly Dictionary<string, SerializedFile> m_files = new();
		private readonly Dictionary<string, ResourceFile?> m_resources = new();

		private readonly HashSet<SerializedFile> m_scenes = new HashSet<SerializedFile>();

		public Func<string, string?>? ResourceCallback;

		private readonly Dictionary<Type, List<IUnityObjectBase>> _cachedAssetsByType = new();

		public GameCollection(LayoutInfo layout) : base(nameof(GameCollection))
		{
			Layout = layout;
		}

		public ISerializedFile? FindSerializedFile(string fileName)
		{
			m_files.TryGetValue(fileName, out SerializedFile? file);
			return file;
		}

		public bool TryGetResourceFile(string resourceName, [NotNullWhen(true)] out ResourceFile? file)
		{
			return m_resources.TryGetValue(resourceName, out file);
		}

		public IResourceFile? FindResourceFile(string resName)
		{
			string fixedName = FilenameUtils.FixResourcePath(resName);
			if (m_resources.TryGetValue(fixedName, out ResourceFile? file))
			{
				return file;
			}

			string? resPath = ResourceCallback?.Invoke(fixedName);
			if (resPath == null)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, $"Resource file '{resName}' hasn't been found");
				m_resources.Add(fixedName, null);
				return null;
			}

			using (ResourceFileScheme scheme = ResourceFile.LoadScheme(resPath, fixedName))
			{
				ResourceFile resourceFile = scheme.ReadFile();
				AddResourceFile(resourceFile);
			}
			Logger.Info(LogCategory.Import, $"Resource file '{resName}' has been loaded");
			return m_resources[fixedName];
		}

		public T? FindAsset<T>() where T : IUnityObjectBase
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset is T castedAsset)
				{
					return castedAsset;
				}
			}
			return default;
		}

		public T? FindAsset<T>(string name) where T : IUnityObjectBase, IHasNameString
		{
			foreach (IUnityObjectBase asset in FetchAssets())
			{
				if (asset is T namedAsset)
				{
					if (namedAsset.NameString == name)
					{
						return namedAsset;
					}
				}
			}
			return default;
		}

		public IEnumerable<IUnityObjectBase> FetchAssets()
		{
			foreach (SerializedFile file in m_files.Values)
			{
				foreach (IUnityObjectBase asset in file.FetchAssets())
				{
					yield return asset;
				}
			}
		}

		public IEnumerable<IUnityObjectBase> FetchAssetsOfType<T>() where T : IUnityObjectBase
		{
			if (_cachedAssetsByType.TryGetValue(typeof(T), out List<IUnityObjectBase>? list))
			{
				return list;
			}

			List<IUnityObjectBase> objects = FetchAssets().Where(o => o is T).ToList();
			_cachedAssetsByType.TryAdd(typeof(T), objects);

			return objects;
		}

		public bool IsScene(ISerializedFile file) => m_scenes.Contains(file);

		protected override void OnSerializedFileAdded(SerializedFile file)
		{
			if (m_files.ContainsKey(file.Name))
			{
				SerializedFile existingFile = m_files[file.Name];
				if (existingFile.FilePath == file.FilePath)
				{
					Logger.Error(LogCategory.Import, $"{nameof(SerializedFile)} with name '{file.Name}' and path '{file.FilePath}' was already added to this collection");
					return;
				}
				else if (FileUtils.GetFileSize(file.FilePath) == FileUtils.GetFileSize(existingFile.FilePath))
				{
					return; //assume identical
				}
				else
				{
#if DEBUG
					throw new ArgumentException($"{nameof(SerializedFile)} with name '{file.Name}' and path '{file.FilePath}' conflicts with file at '{existingFile.FilePath}'", nameof(file));
#else
					Logger.Warning(LogCategory.Import, $"{nameof(SerializedFile)} with name '{file.Name}' and path '{file.FilePath}' conflicts with file at '{existingFile.FilePath}'");
					return;
#endif
				}
			}
			if (file.Platform != Layout.Platform)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, $"'{file.Name}' is incompatible with platform of the game collection");
			}
			if (file.Version != Layout.Version)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, $"'{file.Name}' is incompatible with version of the game collection");
			}

			m_files[file.Name] = file;
			if (IsSceneSerializedFile(file))
			{
				m_scenes.Add(file);
			}
		}

		protected override void OnFileListAdded(FileList list)
		{
			foreach (SerializedFile file in list.SerializedFiles)
			{
				OnSerializedFileAdded(file);
			}
			foreach (FileList nestedList in list.FileLists)
			{
				OnFileListAdded(nestedList);
			}
			foreach (ResourceFile file in list.ResourceFiles)
			{
				OnResourceFileAdded(file);
			}
		}

		protected override void OnResourceFileAdded(ResourceFile file)
		{
			if (m_resources.ContainsKey(file.Name))
			{
#if DEBUG
				throw new ArgumentException($"{nameof(ResourceFile)} with name '{file.Name}' already presents in the collection", nameof(file));
#else
				Logger.Warning(LogCategory.Import, $"{nameof(ResourceFile)} with name '{file.Name}' already presents in the collection");
#endif
			}
			else
			{
				m_resources.Add(file.Name, file);
			}
		}

		private static bool IsSceneSerializedFile(SerializedFile file)
		{
			return file.Metadata.Object.Any(entry => entry.ClassID.IsSceneSettings());
		}

		private void Dispose(bool disposing)
		{
			AssemblyManager?.Dispose();
			foreach (ResourceFile? res in m_resources.Values)
			{
				res?.Dispose();
			}
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		~GameCollection() => Dispose(false);
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/GameProcessorContext.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Structure.GameStructure
{
	internal sealed class GameProcessorContext
	{
		public GameProcessorContext(GameCollection collection)
		{
			Collection = collection;
		}

		public void AddSerializedFile(SerializedFile file, SerializedFileScheme scheme)
		{
			m_files.Add(file, scheme);
		}

		public void ReadSerializedFiles()
		{
			while (m_files.Count > 0)
			{
				(SerializedFile file, SerializedFileScheme scheme) = m_files.First();
				if (scheme.Stream.Length > 100 * 1024)
				{
					//Don't update status for files less than 100kb because they'll be read so quickly that they're just clutter. 
					Logger.SendStatusChange("loading_step_load_assets_from_file", file.Name);
				}

				ReadFile(file);
			}
		}

		private void ReadFile(SerializedFile file)
		{
#warning TODO: fix cross dependencies
			m_knownFiles.Add(file.Name);
			foreach (FileIdentifier dependency in file.Metadata.Externals)
			{
				if (!m_knownFiles.Contains(dependency.PathName))
				{
					if (Collection.GameFiles.TryGetValue(dependency.PathName, out SerializedFile? dependencyFile))
					{
						ReadFile(dependencyFile);
					}
					else
					{
						m_knownFiles.Add(dependency.PathName);
					}
				}
			}

			SerializedFileScheme scheme = m_files[file];
			file.ReadData(scheme.Stream);
			scheme.Dispose();
			m_files.Remove(file);
		}

		public GameCollection Collection { get; }

		private Dictionary<SerializedFile, SerializedFileScheme> m_files = new Dictionary<SerializedFile, SerializedFileScheme>();
		private readonly HashSet<string> m_knownFiles = new HashSet<string>();
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/GameStructureProcessor.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.ArchiveFiles;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Structure.GameStructure.Platforms;
using System.Collections.Generic;
using System.Linq;


namespace AssetRipper.Core.Structure.GameStructure
{
	public sealed class GameStructureProcessor : IDisposable
	{
		private readonly List<FileScheme> m_schemes = new List<FileScheme>();
		private readonly HashSet<string> m_knownFiles = new HashSet<string>();

		public bool IsValid => m_schemes.Any(t => t.SchemeType != FileEntryType.Resource);

		/// <summary>Adds a file and its type to the list of files</summary>
		public void AddScheme(string filePath, string fileName)
		{
			FileScheme scheme = SchemeReader.LoadScheme(filePath, fileName);
			OnSchemeLoaded(scheme);
			m_schemes.Add(scheme);
		}

		/// <summary>Recursively adds Serialized files to the m_knownFiles hashset</summary>
		private void OnSchemeLoaded(FileScheme scheme)
		{
			if (scheme.SchemeType == FileEntryType.Serialized)
			{
				m_knownFiles.Add(scheme.Name);
			}

			if (scheme is FileSchemeList list)
			{
				foreach (FileScheme nestedScheme in list.Schemes)
				{
					OnSchemeLoaded(nestedScheme);
				}
			}
		}

		/// <summary>Attempts to add any missing dependencies to the file list</summary>
		/// <param name="dependencyCallback">A method that takes a dependency name and tries to output a path</param>
		public void AddDependencySchemes(Func<string, string?> dependencyCallback)
		{
			for (int i = 0; i < m_schemes.Count; i++)
			{
				FileScheme scheme = m_schemes[i];
				foreach (FileIdentifier dependency in scheme.Dependencies)
				{
					if (m_knownFiles.Contains(dependency.PathName))
					{
						continue;
					}

					string? systemFilePath = dependencyCallback.Invoke(dependency.PathName);
					if (systemFilePath == null)
					{
						m_knownFiles.Add(dependency.PathName);
						Logger.Log(LogType.Warning, LogCategory.Import, $"Dependency '{dependency}' wasn't found");
						continue;
					}

					AddScheme(systemFilePath, dependency.PathName);
				}
			}
		}

		public void ProcessSchemes(GameCollection fileCollection)
		{
			//Initializes it with a reference to the file collection
			GameProcessorContext context = new GameProcessorContext(fileCollection);

			Logger.SendStatusChange("loading_step_pre_processing");

			foreach (FileScheme scheme in m_schemes)
			{
				//Not just a simple add
				//Grouped by scheme type
				//And new objects are added to lists
				fileCollection.AddFile(context, scheme);
			}
			context.ReadSerializedFiles();
		}

		public LayoutInfo GetLayoutInfo()
		{
			SerializedFileScheme? prime = GetPrimaryFile();
			if (prime != null)
			{
				return GetLayoutInfo(prime);
			}

			SerializedFileScheme? serialized = GetEngineFile() ?? throw new Exception("Could not get serialized file scheme");
			return GetLayoutInfo(serialized);
		}

		private static IEnumerable<FileScheme> EnumerateSchemes(IReadOnlyList<FileScheme> schemes)
		{
			foreach (FileScheme scheme in schemes)
			{
				yield return scheme;
				if (scheme is FileSchemeList fileList)
				{
					foreach (FileScheme nestedScheme in EnumerateSchemes(fileList.Schemes))
					{
						yield return nestedScheme;
					}
				}
				else if (scheme.SchemeType == FileEntryType.Archive)
				{
					ArchiveFileScheme archive = (ArchiveFileScheme)scheme;
					yield return archive.WebScheme;
					foreach (FileScheme nestedScheme in EnumerateSchemes(archive.WebScheme.Schemes))
					{
						yield return nestedScheme;
					}
				}
			}
		}

		private static UnityVersion GetDefaultGenerationVersions(FormatVersion generation)
		{
			if (generation < FormatVersion.Unknown_5)
			{
				return new UnityVersion(1, 2, 2);
			}

			return generation switch
			{
				FormatVersion.Unknown_5 => new UnityVersion(1, 6),
				FormatVersion.Unknown_6 => new UnityVersion(2, 5),
				FormatVersion.Unknown_7 => new UnityVersion(3, 0, 0, UnityVersionType.Beta, 1),
				_ => throw new NotSupportedException(),
			};
		}

		private LayoutInfo GetLayoutInfo(SerializedFileScheme serialized)
		{
			if (SerializedFileMetadata.HasPlatform(serialized.Header.Version))
			{
				SerializedFileMetadata metadata = serialized.Metadata;
				return new LayoutInfo(metadata.UnityVersion, metadata.TargetPlatform, serialized.Flags);
			}
			else
			{
				const BuildTarget DefaultPlatform = BuildTarget.StandaloneWinPlayer;
				const TransferInstructionFlags DefaultFlags = TransferInstructionFlags.SerializeGameRelease;
				BundleFileScheme? bundle = GetBundleFile();
				if (bundle == null)
				{
					Logger.Log(LogType.Warning, LogCategory.Import, "Unable to determine layout for provided files. Tring default one");
					UnityVersion version = GetDefaultGenerationVersions(serialized.Header.Version);
					return new LayoutInfo(version, DefaultPlatform, DefaultFlags);

				}
				else
				{
					Logger.Log(LogType.Warning, LogCategory.Import, "Unable to precisly determine layout for provided files. Tring default one");
					return new LayoutInfo(bundle.Header.UnityWebMinimumRevision, DefaultPlatform, DefaultFlags);
				}
			}
		}

		private SerializedFileScheme? GetPrimaryFile()
		{
			foreach (FileScheme scheme in EnumerateSchemes(m_schemes))
			{
				if (scheme.SchemeType == FileEntryType.Serialized)
				{
					if (PlatformGameStructure.IsPrimaryEngineFile(scheme.NameOrigin))
					{
						return (SerializedFileScheme)scheme;
					}
				}
			}
			return null;
		}

		private SerializedFileScheme? GetEngineFile()
		{
			foreach (FileScheme scheme in EnumerateSchemes(m_schemes))
			{
				if (scheme.SchemeType == FileEntryType.Serialized)
				{
					return (SerializedFileScheme)scheme;
				}
			}
			return null;
		}

		private BundleFileScheme? GetBundleFile()
		{
			foreach (FileScheme scheme in EnumerateSchemes(m_schemes))
			{
				if (scheme.SchemeType == FileEntryType.Bundle)
				{
					return (BundleFileScheme)scheme;
				}
			}
			return null;
		}

		~GameStructureProcessor()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			GC.SuppressFinalize(this);
			Dispose(true);
		}

		private void Dispose(bool disposing)
		{
			foreach (FileScheme scheme in m_schemes)
			{
				scheme.Dispose();
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/AndroidGameStructure.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class AndroidGameStructure : PlatformGameStructure
	{
		public AndroidGameStructure(string rootPath) : this(rootPath, string.Empty) { }

		public AndroidGameStructure(string rootPath, string? obbPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Root directory '{rootPath}' doesn't exist");
			}

			string apkDataPath = Path.Combine(rootPath, AssetName, BinName, DataFolderName);
			DirectoryInfo apkDataDirectory = new DirectoryInfo(apkDataPath);
			if (!apkDataDirectory.Exists)
			{
				throw new Exception($"Data directory hasn't been found");
			}
			List<string> dataPaths = new List<string>() { apkDataPath };

			RootPath = rootPath;
			GameDataPath = apkDataPath;
			StreamingAssetsPath = null;
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			LibPath = Path.Combine(RootPath, LibName);
			Il2CppGameAssemblyPath = GetIl2CppGameAssemblyPath(LibPath);
			Il2CppMetaDataPath = Path.Combine(ManagedPath, MetadataName, DefaultGlobalMetadataName);
			UnityPlayerPath = null;
			UnityVersion = GetUnityVersionFromDataDirectory(GameDataPath);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (IsMono(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			if (obbPath != null)
			{
				m_obbRoot = new DirectoryInfo(obbPath);
				if (!m_obbRoot.Exists)
				{
					throw new Exception($"Obb directory '{obbPath}' doesn't exist");
				}

				string obbDataPath = Path.Combine(obbPath, AssetName, BinName, DataFolderName);
				if (!Directory.Exists(obbDataPath))
				{
					throw new Exception($"Obb data directory '{obbDataPath}' wasn't found");
				}
				dataPaths.Add(obbDataPath);
			}
			DataPaths = dataPaths.ToArray();
		}

		public override void CollectFiles(bool skipStreamingAssets)
		{
			base.CollectFiles(skipStreamingAssets);
			CollectApkAssetBundles(Files);
		}

		public static bool IsAndroidStructure(string path)
		{
			DirectoryInfo directory = new DirectoryInfo(path);
			if (!directory.Exists)
			{
				return false;
			}

			int match = GetRootAndroidDirectoryMatch(directory);
			if (match <= 8)
			{
				return false;
			}

			string dataPath = Path.Combine(path, AssetName, BinName, DataFolderName);

			return Directory.Exists(dataPath);
		}

		public static bool IsAndroidObbStructure(string path)
		{
			DirectoryInfo directory = new DirectoryInfo(path);
			if (!directory.Exists)
			{
				return false;
			}

			int match = GetRootAndroidDirectoryMatch(directory);
			if (match != 8)
			{
				return false;
			}

			string dataPath = Path.Combine(path, AssetName, BinName, DataFolderName);

			return Directory.Exists(dataPath);
		}

		private static int GetRootAndroidDirectoryMatch(DirectoryInfo directory)
		{
			int matches = 0;
			foreach (DirectoryInfo subDirectory in directory.EnumerateDirectories())
			{
				switch (subDirectory.Name)
				{
					case AssetName:
						matches |= 8;
						break;

					case MetaName:
						matches |= 4;
						break;

					case LibName:
						matches |= 2;
						break;
				}
			}
			return matches;
		}

		private void CollectApkAssetBundles(IDictionary<string, string> files)
		{
			string assetPath = Path.Combine(m_root.FullName, AssetName);
			DirectoryInfo root = new DirectoryInfo(assetPath);

			CollectAssetBundles(root, files);
			foreach (DirectoryInfo subDirectory in root.EnumerateDirectories())
			{
				if (subDirectory.Name == BinName)
				{
					continue;
				}
				CollectAssetBundlesRecursively(subDirectory, files);
			}
		}

		private static string? GetIl2CppGameAssemblyPath(string libDirectory)
		{
			if (string.IsNullOrEmpty(libDirectory) || !Directory.Exists(libDirectory))
			{
				return null;
			}

			return Directory.GetFiles(libDirectory, Il2CppGameAssemblyName, SearchOption.AllDirectories).FirstOrDefault();
		}

		private static string? GetAndroidUnityAssemblyPath(string libDirectory)
		{
			if (string.IsNullOrEmpty(libDirectory) || !Directory.Exists(libDirectory))
			{
				return null;
			}

			return Directory.GetFiles(libDirectory, AndroidUnityAssemblyName, SearchOption.AllDirectories).FirstOrDefault();
		}

		private static bool IsMono(string managedDirectory)
		{
			if (string.IsNullOrEmpty(managedDirectory) || !Directory.Exists(managedDirectory))
			{
				return false;
			}

			return Directory.GetFiles(managedDirectory, "*.dll").Length > 0;
		}

		public string LibPath { get; private set; }

		private const string AssetName = "assets";
		private const string MetaName = "META-INF";
		private const string BinName = "bin";
		private const string Il2CppGameAssemblyName = "libil2cpp.so";
		private const string AndroidUnityAssemblyName = "libunity.so";

		private readonly DirectoryInfo? m_obbRoot;
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/LinuxGameStructure.cs`:

```cs
using AssetRipper.Core.Logging;
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class LinuxGameStructure : PlatformGameStructure
	{
		public LinuxGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			if (IsExecutableFile(rootPath))
			{
				Logger.Info(LogCategory.Import, "Linux executable found. Setting root to parent directory");
				m_root = new FileInfo(rootPath).Directory ?? throw new Exception("Could not get file directory");
			}
			else if (IsUnityDataDirectory(rootPath))
			{
				Logger.Info(LogCategory.Import, "Linux data directory found. Setting root to parent directory");
				m_root = new DirectoryInfo(rootPath).Parent ?? throw new Exception("Could not get parent directory");
			}
			else
			{
				m_root = new DirectoryInfo(rootPath);
				if (!m_root.Exists)
				{
					throw new Exception($"Directory '{rootPath}' doesn't exist");
				}
			}

			if (!GetDataLinuxDirectory(m_root, out string? dataPath, out string? name))
			{
				throw new Exception($"Data directory wasn't found");
			}

			Name = name;
			RootPath = m_root.FullName;
			GameDataPath = dataPath;
			StreamingAssetsPath = Path.Combine(GameDataPath, StreamingName);
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			UnityPlayerPath = Path.Combine(RootPath, DefaultUnityPlayerName);
			UnityVersion = null;
			Il2CppGameAssemblyPath = Path.Combine(RootPath, DefaultGameAssemblyName);
			Il2CppMetaDataPath = Path.Combine(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			DataPaths = new string[] { dataPath };
		}

		public static bool IsLinuxStructure(string path)
		{
			DirectoryInfo dinfo;
			if (IsExecutableFile(path))
			{
				dinfo = new FileInfo(path).Directory ?? throw new Exception("Could not get file directory");
			}
			else if (IsUnityDataDirectory(path))
			{
				return true;
			}
			else
			{
				dinfo = new DirectoryInfo(path);
			}

			if (!dinfo.Exists)
			{
				return false;
			}
			else
			{
				return IsRootLinuxDirectory(dinfo);
			}
		}

		private static bool IsUnityDataDirectory(string folderPath)
		{
			if (string.IsNullOrEmpty(folderPath) || !folderPath.EndsWith($"_{DataFolderName}"))
			{
				return false;
			}

			DirectoryInfo directoryInfo = new DirectoryInfo(folderPath);
			if (!directoryInfo.Exists || directoryInfo.Parent == null)
			{
				return false;
			}

			string folderName = directoryInfo.Name;
			string gameName = folderName.Substring(0, folderName.IndexOf($"_{DataFolderName}"));
			string rootPath = directoryInfo.Parent.FullName;
			string x86Path = Path.Combine(rootPath, gameName + x86Extension);
			string x64Path = Path.Combine(rootPath, gameName + x64Extension);
			string x86_64Path = Path.Combine(rootPath, gameName + x86_64Extension);
			if (File.Exists(x86Path) || File.Exists(x64Path) || File.Exists(x86_64Path))
			{
				return true;
			}
			else
			{
				return false;
			}
		}

		private static bool IsExecutableFile(string filePath)
		{
			return !string.IsNullOrEmpty(filePath)
				&& (filePath.EndsWith(x86Extension) || filePath.EndsWith(x64Extension) || filePath.EndsWith(x86_64Extension))
				&& File.Exists(filePath);
		}

		private static bool IsRootLinuxDirectory(DirectoryInfo rootDiectory)
		{
			return GetDataLinuxDirectory(rootDiectory, out string _, out string _);
		}

		private static bool GetDataLinuxDirectory(DirectoryInfo rootDiectory, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? name)
		{
			foreach (FileInfo finfo in rootDiectory.EnumerateFiles())
			{
				if (finfo.Extension == x86Extension || finfo.Extension == x64Extension || finfo.Extension == x86_64Extension)
				{
					name = Path.GetFileNameWithoutExtension(finfo.Name);
					string dataFolder = $"{name}_{DataFolderName}";
					dataPath = Path.Combine(rootDiectory.FullName, dataFolder);
					if (Directory.Exists(dataPath))
					{
						return true;
					}
				}
			}

			name = null;
			dataPath = null;
			return false;
		}


		private const string x86Extension = ".x86";
		private const string x64Extension = ".x64";
		private const string x86_64Extension = ".x86_64";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/MacGameStructure.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class MacGameStructure : PlatformGameStructure
	{
		public MacGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Directory '{rootPath}' doesn't exist");
			}

			string resourcePath = Path.Combine(m_root.FullName, ContentsName, ResourcesName);
			if (!Directory.Exists(resourcePath))
			{
				throw new Exception("Resources directory wasn't found");
			}
			string dataPath = Path.Combine(resourcePath, DataFolderName);
			if (!Directory.Exists(dataPath))
			{
				throw new Exception("Data directory wasn't found");
			}
			DataPaths = new string[] { dataPath, resourcePath };


			Name = m_root.Name.Substring(0, m_root.Name.Length - AppExtension.Length);
			RootPath = rootPath;
			GameDataPath = dataPath;
			StreamingAssetsPath = Path.Combine(GameDataPath, StreamingName);
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			UnityPlayerPath = Path.Combine(RootPath, ContentsName, FrameworksName, MacUnityPlayerName);
			UnityVersion = null;

			Il2CppGameAssemblyPath = Path.Combine(RootPath, ContentsName, FrameworksName, "GameAssembly.dylib");
			Il2CppMetaDataPath = Path.Combine(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}
		}

		public static bool IsMacStructure(string path)
		{
			DirectoryInfo dinfo = new DirectoryInfo(path);
			if (!dinfo.Exists)
			{
				return false;
			}
			if (!dinfo.Name.EndsWith(AppExtension, StringComparison.Ordinal))
			{
				return false;
			}

			string dataPath = Path.Combine(dinfo.FullName, ContentsName, ResourcesName, DataFolderName);
			if (!Directory.Exists(dataPath))
			{
				return false;
			}
			string resourcePath = Path.Combine(dinfo.FullName, ContentsName, ResourcesName);
			if (!Directory.Exists(resourcePath))
			{
				return false;
			}
			return true;
		}


		private const string ContentsName = "Contents";
		private const string FrameworksName = "Frameworks";
		private const string MacUnityPlayerName = "UnityPlayer.dylib";
		private const string AppExtension = ".app";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/MixedGameStructure.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Structure.Assembly.Managers;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	public sealed class MixedGameStructure : PlatformGameStructure
	{
		public MixedGameStructure(IEnumerable<string> paths)
		{
			HashSet<string> dataPaths = new HashSet<string>();
			foreach (string path in SelectUniquePaths(paths))
			{
				if (MultiFileStream.Exists(path))
				{
					string name = MultiFileStream.GetFileName(path);
					AddFile(Files, name, path);
					string directory = Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
					dataPaths.Add(directory);
				}
				else if (Directory.Exists(path))
				{
					DirectoryInfo directory = new DirectoryInfo(path);
					CollectFromDirectory(directory, Files, Assemblies, dataPaths);
				}
				else
				{
					throw new Exception($"Neither file nor directory at '{path}' exists");
				}
			}

			DataPaths = dataPaths.ToArray();
			Name = Files.Count == 0 ? string.Empty : Files.First().Key;
			RootPath = null;
			GameDataPath = null;
			ManagedPath = null;
			UnityPlayerPath = null;
			UnityVersion = null;
			Il2CppGameAssemblyPath = null;
			Il2CppMetaDataPath = null;
			Backend = Assemblies.Count > 0 ? Assembly.ScriptingBackend.Mono : Assembly.ScriptingBackend.Unknown;
		}

		private IEnumerable<string> SelectUniquePaths(IEnumerable<string> paths)
		{
			return paths.Select(t => MultiFileStream.GetFilePath(t)).Distinct();
		}

		private void CollectFromDirectory(DirectoryInfo root, IDictionary<string, string> files, IDictionary<string, string> assemblies, ISet<string> dataPaths)
		{
			int count = files.Count;
			CollectSerializedGameFiles(root, files);
			CollectWebFiles(root, files);
			CollectAssetBundles(root, files);
			CollectAssembliesSafe(root, assemblies);
			if (files.Count != count)
			{
				dataPaths.Add(root.FullName);
			}

			foreach (DirectoryInfo subDirectory in root.EnumerateDirectories())
			{
				CollectFromDirectory(subDirectory, files, assemblies, dataPaths);
			}
		}

		private void CollectWebFiles(DirectoryInfo root, IDictionary<string, string> files)
		{
			foreach (FileInfo levelFile in root.EnumerateFiles())
			{
				string extension = Path.GetExtension(levelFile.Name);
				switch (extension)
				{
					case WebGLGameStructure.DataExtension:
					case WebGLGameStructure.DataGzExtension:
						{
							string name = Path.GetFileNameWithoutExtension(levelFile.Name);
							AddFile(files, name, levelFile.FullName);
						}
						break;

					case WebGLGameStructure.UnityWebExtension:
						{
							if (levelFile.Name.EndsWith(WebGLGameStructure.DataWebExtension, StringComparison.Ordinal))
							{
								string name = levelFile.Name.Substring(0, levelFile.Name.Length - WebGLGameStructure.DataWebExtension.Length);
								AddFile(files, name, levelFile.FullName);
							}
						}
						break;
				}
			}
		}

		private void CollectAssembliesSafe(DirectoryInfo root, IDictionary<string, string> assemblies)
		{
			foreach (FileInfo file in root.EnumerateFiles())
			{
				if (MonoManager.IsMonoAssembly(file.Name))
				{
					if (assemblies.ContainsKey(file.Name))
					{
						Logger.Log(LogType.Warning, LogCategory.Import, $"Duplicate assemblies found: '{assemblies[file.Name]}' & '{file.FullName}'");
					}
					else
					{
						assemblies.Add(file.Name, file.FullName);
					}
				}
			}
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/PCGameStructure.cs`:

```cs
using AssetRipper.Core.Logging;
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class PCGameStructure : PlatformGameStructure
	{
		public PCGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			if (IsExecutableFile(rootPath))
			{
				Logger.Info(LogCategory.Import, "PC executable found. Setting root to parent directory");
				m_root = new FileInfo(rootPath).Directory ?? throw new Exception("File has no directory");
			}
			else if (IsUnityDataDirectory(rootPath))
			{
				Logger.Info(LogCategory.Import, "PC data directory found. Setting root to parent directory");
				m_root = new DirectoryInfo(rootPath).Parent ?? throw new Exception("Directory has no parent");
			}
			else
			{
				m_root = new DirectoryInfo(rootPath);
				if (!m_root.Exists)
				{
					throw new Exception($"Directory '{rootPath}' doesn't exist");
				}
			}

			if (!GetDataPCDirectory(m_root, out string? dataPath, out string? name))
			{
				throw new Exception($"Data directory wasn't found");
			}

			Name = name;
			RootPath = m_root.FullName;
			GameDataPath = dataPath;
			StreamingAssetsPath = Path.Combine(GameDataPath, StreamingName);
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			UnityPlayerPath = Path.Combine(RootPath, DefaultUnityPlayerName);
			UnityVersion = null;
			Il2CppGameAssemblyPath = Path.Combine(RootPath, DefaultGameAssemblyName);
			Il2CppMetaDataPath = Path.Combine(GameDataPath, "il2cpp_data", MetadataName, DefaultGlobalMetadataName);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			DataPaths = new string[] { dataPath };
		}

		public static bool IsPCStructure(string path)
		{
			DirectoryInfo dinfo;
			if (IsExecutableFile(path))
			{
				dinfo = new FileInfo(path).Directory ?? throw new Exception("File has no directory");
			}
			else if (IsUnityDataDirectory(path))
			{
				return true;
			}
			else
			{
				dinfo = new DirectoryInfo(path);
			}

			if (!dinfo.Exists)
			{
				return false;
			}
			else
			{
				return IsRootPCDirectory(dinfo);
			}
		}

		private static bool IsUnityDataDirectory(string folderPath)
		{
			if (string.IsNullOrEmpty(folderPath) || !folderPath.EndsWith($"_{DataFolderName}"))
			{
				return false;
			}

			DirectoryInfo directoryInfo = new DirectoryInfo(folderPath);
			if (!directoryInfo.Exists || directoryInfo.Parent == null)
			{
				return false;
			}

			string folderName = directoryInfo.Name;
			string gameName = folderName.Substring(0, folderName.IndexOf($"_{DataFolderName}"));
			string rootPath = directoryInfo.Parent.FullName;
			if (File.Exists(Path.Combine(rootPath, gameName + ExeExtension)))
			{
				return true;
			}
			else
			{
				return false;
			}
		}

		private static bool IsExecutableFile(string filePath)
		{
			return !string.IsNullOrEmpty(filePath) && filePath.EndsWith(ExeExtension) && File.Exists(filePath);
		}

		private static bool IsRootPCDirectory(DirectoryInfo rootDirectory)
		{
			return GetDataPCDirectory(rootDirectory, out string? _, out string? _);
		}

		private static bool GetDataPCDirectory(DirectoryInfo rootDirectory, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? name)
		{
			name = "";
			int exeCount = 0;
			foreach (FileInfo fileInfo in rootDirectory.EnumerateFiles())
			{
				if (fileInfo.Extension == ExeExtension)
				{
					exeCount++;
					name = Path.GetFileNameWithoutExtension(fileInfo.Name);
					string dataFolder = $"{name}_{DataFolderName}";
					dataPath = Path.Combine(rootDirectory.FullName, dataFolder);
					if (Directory.Exists(dataPath))
					{
						return true;
					}
				}
			}

			if (exeCount > 0)
			{
				name = exeCount == 1 ? name : rootDirectory.Name;
				dataPath = Path.Combine(rootDirectory.FullName, DataFolderName);
				if (Directory.Exists(dataPath))
				{
					return true;
				}
			}

			name = null;
			dataPath = null;
			return false;
		}


		private const string ExeExtension = ".exe";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/PS4GameStructure.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class PS4GameStructure : PlatformGameStructure
	{
		private const string PS4ExecutableName = "eboot.bin";
		private const string PS4DataFolderName = "Media";
		private const string ModulesName = "Modules";
		private const string PS4IL2CppGameAssemblyName = "Il2CppUserAssemblies.prx";

		private string ModulesPath { get; set; }

		public PS4GameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Directory '{rootPath}' doesn't exist");
			}

			if (!GetDataDirectory(m_root, out string? dataPath))
			{
				throw new Exception($"Data directory wasn't found");
			}

			Name = m_root.Name;
			RootPath = rootPath;
			GameDataPath = dataPath;
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			ModulesPath = Path.Combine(GameDataPath, ModulesName);
			UnityPlayerPath = null;
			string globalGameManagersPath = Path.Combine(GameDataPath, GlobalGameManagersName);
			UnityVersion = GetUnityVersionFromDataDirectory(globalGameManagersPath);
			Il2CppGameAssemblyPath = Path.Combine(ModulesPath, PS4IL2CppGameAssemblyName);
			Il2CppMetaDataPath = Path.Combine(GameDataPath, MetadataName, DefaultGlobalMetadataName);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			DataPaths = new string[] { dataPath };
		}

		public static bool IsPS4Structure(string path)
		{
			DirectoryInfo dinfo = new DirectoryInfo(path);
			if (!dinfo.Exists)
			{
				return false;
			}
			return IsRootPS4Directory(dinfo);
		}

		private static bool IsRootPS4Directory(DirectoryInfo rootDiectory)
		{
			return GetDataDirectory(rootDiectory, out string _);
		}

		private static bool GetDataDirectory(DirectoryInfo rootDiectory, [NotNullWhen(true)] out string? dataPath)
		{
			foreach (FileInfo finfo in rootDiectory.EnumerateFiles())
			{
				if (finfo.Name == PS4ExecutableName)
				{
					dataPath = Path.Combine(rootDiectory.FullName, PS4DataFolderName);
					if (Directory.Exists(dataPath))
					{
						return true;
					}
				}
			}

			dataPath = null;
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/PlatformChecker.cs`:

```cs
using AssetRipper.Core.Logging;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	public static class PlatformChecker
	{
		public static bool CheckPlatform(List<string> paths, [NotNullWhen(true)] out PlatformGameStructure? platformStructure, [NotNullWhen(true)] out MixedGameStructure? mixedStructure)
		{
			platformStructure = null;
			mixedStructure = null;

			if (CheckPC(paths, out PCGameStructure? pcGameStructure))
			{
				platformStructure = pcGameStructure;
			}
			else if (CheckLinux(paths, out LinuxGameStructure? linuxGameStructure))
			{
				platformStructure = linuxGameStructure;
			}
			else if (CheckMac(paths, out MacGameStructure? macGameStructure))
			{
				platformStructure = macGameStructure;
			}
			else if (CheckAndroid(paths, out AndroidGameStructure? androidGameStructure))
			{
				platformStructure = androidGameStructure;
			}
			else if (CheckiOS(paths, out iOSGameStructure? iosGameStructure))
			{
				platformStructure = iosGameStructure;
			}
			else if (CheckSwitch(paths, out SwitchGameStructure? switchGameStructure))
			{
				platformStructure = switchGameStructure;
			}
			else if (CheckPS4(paths, out PS4GameStructure? ps4GameStructure))
			{
				platformStructure = ps4GameStructure;
			}
			else if (CheckWebGL(paths, out WebGLGameStructure? webglGameStructure))
			{
				platformStructure = webglGameStructure;
			}
			else if (CheckWebPlayer(paths, out WebPlayerGameStructure? webplayerGameStructure))
			{
				platformStructure = webplayerGameStructure;
			}
			else if (CheckWiiU(paths, out WiiUGameStructure? wiiUGameStructure))
			{
				platformStructure = wiiUGameStructure;
			}

			if (CheckMixed(paths, out MixedGameStructure? mixedGameStructure))
			{
				mixedStructure = mixedGameStructure;
			}

			return platformStructure != null || mixedStructure != null;
		}


		private static bool CheckPC(List<string> paths, [NotNullWhen(true)] out PCGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (PCGameStructure.IsPCStructure(path))
				{
					gameStructure = new PCGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"PC game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckLinux(List<string> paths, [NotNullWhen(true)] out LinuxGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (LinuxGameStructure.IsLinuxStructure(path))
				{
					gameStructure = new LinuxGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"Linux game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckMac(List<string> paths, [NotNullWhen(true)] out MacGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (MacGameStructure.IsMacStructure(path))
				{
					gameStructure = new MacGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"Mac game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckAndroid(List<string> paths, [NotNullWhen(true)] out AndroidGameStructure? gameStructure)
		{
			string? androidStructure = null;
			string? obbStructure = null;
			foreach (string path in paths)
			{
				if (AndroidGameStructure.IsAndroidStructure(path))
				{
					if (androidStructure == null)
					{
						androidStructure = path;
					}
					else
					{
						throw new Exception("2 Android game stuctures has been found");
					}
				}
				else if (AndroidGameStructure.IsAndroidObbStructure(path))
				{
					if (obbStructure == null)
					{
						obbStructure = path;
					}
					else
					{
						throw new Exception("2 Android obb game stuctures has been found");
					}
				}
			}

			if (androidStructure != null)
			{
				gameStructure = new AndroidGameStructure(androidStructure, obbStructure);
				paths.Remove(androidStructure);
				Logger.Info(LogCategory.Import, $"Android game structure has been found at '{androidStructure}'");
				if (obbStructure != null)
				{
					paths.Remove(obbStructure);
					Logger.Info(LogCategory.Import, $"Android obb game structure has been found at '{obbStructure}'");
				}
				return true;
			}

			gameStructure = null;
			return false;
		}

		private static bool CheckiOS(List<string> paths, [NotNullWhen(true)] out iOSGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (iOSGameStructure.IsiOSStructure(path))
				{
					gameStructure = new iOSGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"iOS game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckPS4(List<string> paths, [NotNullWhen(true)] out PS4GameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (PS4GameStructure.IsPS4Structure(path))
				{
					gameStructure = new PS4GameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"PS4 game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckSwitch(List<string> paths, [NotNullWhen(true)] out SwitchGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (SwitchGameStructure.IsSwitchStructure(path))
				{
					gameStructure = new SwitchGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"Switch game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckWebGL(List<string> paths, [NotNullWhen(true)] out WebGLGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (WebGLGameStructure.IsWebGLStructure(path))
				{
					gameStructure = new WebGLGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"WebPlayer game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckWebPlayer(List<string> paths, [NotNullWhen(true)] out WebPlayerGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (WebPlayerGameStructure.IsWebPlayerStructure(path))
				{
					gameStructure = new WebPlayerGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"WebPlayer game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckWiiU(List<string> paths, [NotNullWhen(true)] out WiiUGameStructure? gameStructure)
		{
			foreach (string path in paths)
			{
				if (WiiUGameStructure.IsWiiUStructure(path))
				{
					gameStructure = new WiiUGameStructure(path);
					paths.Remove(path);
					Logger.Info(LogCategory.Import, $"WiiU game structure has been found at '{path}'");
					return true;
				}
			}
			gameStructure = null;
			return false;
		}

		private static bool CheckMixed(List<string> paths, [NotNullWhen(true)] out MixedGameStructure? gameStructure)
		{
			if (paths.Count > 0)
			{
				gameStructure = new MixedGameStructure(paths);
				if (paths.Count == 1)
				{
					Logger.Info(LogCategory.Import, $"Mixed game structure has been found at {paths[0]}");
				}
				else
				{
					Logger.Info(LogCategory.Import, $"Mixed game structure has been found for {paths.Count} paths");
				}

				paths.Clear();
				return true;
			}
			gameStructure = null;
			return false;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/PlatformGameStructure.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Structure.Assembly.Managers;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	public abstract class PlatformGameStructure
	{
		public string? Name { get; protected set; }
		public string? RootPath { get; protected set; }
		public string? GameDataPath { get; protected set; }
		public string? StreamingAssetsPath { get; protected set; }
		public string? ResourcesPath { get; protected set; }
		public ScriptingBackend Backend { get; protected set; } = ScriptingBackend.Unknown;
		public string? ManagedPath { get; protected set; }
		public string? Il2CppGameAssemblyPath { get; protected set; }
		public string? Il2CppMetaDataPath { get; protected set; }
		public string? UnityPlayerPath { get; protected set; }
		public int[]? UnityVersion { get; protected set; }

		public IReadOnlyList<string> DataPaths { get; protected set; } = Array.Empty<string>();

		/// <summary>Name : FullName</summary>
		public Dictionary<string, string> Files { get; } = new Dictionary<string, string>();
		/// <summary>AssemblyName : AssemblyPath</summary>
		public Dictionary<string, string> Assemblies { get; } = new Dictionary<string, string>();

		protected DirectoryInfo m_root { get; set; }

		protected static readonly Regex s_levelTemplate = new Regex($@"^level(0|[1-9][0-9]*)({MultiFileStream.MultifileRegPostfix}0)?$", RegexOptions.Compiled);
		protected static readonly Regex s_sharedAssetTemplate = new Regex(@"^sharedassets[0-9]+\.assets", RegexOptions.Compiled);

		protected const string DataFolderName = "Data";
		protected const string ManagedName = "Managed";
		protected const string LibName = "lib";
		protected const string ResourcesName = "Resources";
		protected const string UnityName = "unity";
		protected const string StreamingName = "StreamingAssets";
		protected const string MetadataName = "Metadata";
		protected const string DefaultUnityPlayerName = "UnityPlayer.dll";
		protected const string DefaultGameAssemblyName = "GameAssembly.dll";
		protected const string DefaultGlobalMetadataName = "global-metadata.dat";

		protected const string DataName = "data";
		protected const string DataBundleName = DataName + AssetBundleExtension;
		protected const string MainDataName = "mainData";
		protected const string GlobalGameManagersName = "globalgamemanagers";
		protected const string GlobalGameManagerAssetsName = "globalgamemanagers.assets";
		protected const string ResourcesAssetsName = "resources.assets";
		protected const string LevelPrefix = "level";

		protected const string AssetBundleExtension = ".unity3d";
		protected const string AlternateBundleExtension = ".bundle";
		protected const string Lz4BundleName = DataName + AssetBundleExtension;

		public static bool IsPrimaryEngineFile(string fileName)
		{
			if (fileName == MainDataName ||
				fileName == GlobalGameManagersName ||
				fileName == GlobalGameManagerAssetsName ||
				fileName == ResourcesAssetsName ||
				s_levelTemplate.IsMatch(fileName) ||
				s_sharedAssetTemplate.IsMatch(fileName))
			{
				return true;
			}
			return false;
		}

		/// <summary>Attempts to find the path for the dependency with that name.</summary>
		public string? RequestDependency(string dependency)
		{
			if (Files.TryGetValue(dependency, out string? dependencyPath))
			{
				return dependencyPath;
			}

			foreach (string dataPath in DataPaths)
			{
				string filePath = Path.Combine(dataPath, dependency);
				if (MultiFileStream.Exists(filePath))
				{
					return filePath;
				}

				if (FilenameUtils.IsDefaultResource(dependency))
				{
					return FindEngineDependency(dataPath, FilenameUtils.DefaultResourceName1) ??
						FindEngineDependency(dataPath, FilenameUtils.DefaultResourceName2);
				}
				else if (FilenameUtils.IsBuiltinExtra(dependency))
				{
					return FindEngineDependency(dataPath, FilenameUtils.BuiltinExtraName1) ??
						FindEngineDependency(dataPath, FilenameUtils.BuiltinExtraName2);
				}
			}
			return null;
		}

		public string? RequestAssembly(string assembly)
		{
			string assemblyName = $"{assembly}{MonoManager.AssemblyExtension}";
			if (Assemblies.TryGetValue(assemblyName, out string? assemblyPath))
			{
				return assemblyPath;
			}
			return null;
		}

		public string? RequestResource(string resource)
		{
			foreach (string dataPath in DataPaths)
			{
				string path = Path.Combine(dataPath, resource);
				if (MultiFileStream.Exists(path))
				{
					return path;
				}
			}
			return null;
		}

		public virtual void CollectFiles(bool skipStreamingAssets)
		{
			if (this is MixedGameStructure)
			{
				return;
			}

			foreach (string dataPath in DataPaths)
			{
				DirectoryInfo dataDirectory = new DirectoryInfo(dataPath);
				CollectGameFiles(dataDirectory, Files);
			}
			CollectMainAssemblies();
			if (!skipStreamingAssets)
			{
				CollectStreamingAssets(Files);
			}
		}

		protected void CollectGameFiles(DirectoryInfo root, IDictionary<string, string> files)
		{
			Logger.Info(LogCategory.Import, "Collecting game files...");
			CollectCompressedGameFiles(root, files);
			CollectSerializedGameFiles(root, files);
		}

		/// <summary>
		/// Finds data.unity3d when Lz4 compressed
		/// </summary>
		protected void CollectCompressedGameFiles(DirectoryInfo root, IDictionary<string, string> files)
		{
			string dataBundlePath = Path.Combine(root.FullName, DataBundleName);
			if (MultiFileStream.Exists(dataBundlePath))
			{
				AddAssetBundle(files, DataBundleName, dataBundlePath);
			}
		}

		/// <summary>
		/// Collects global game managers and all the level files
		/// </summary>
		protected void CollectSerializedGameFiles(DirectoryInfo root, IDictionary<string, string> files)
		{
			string filePath = Path.Combine(root.FullName, GlobalGameManagersName);
			if (MultiFileStream.Exists(filePath))
			{
				AddFile(files, GlobalGameManagersName, filePath);
			}
			else
			{
				filePath = Path.Combine(root.FullName, MainDataName);
				if (MultiFileStream.Exists(filePath))
				{
					AddFile(files, MainDataName, filePath);
				}
			}

			foreach (FileInfo levelFile in root.EnumerateFiles())
			{
				if (s_levelTemplate.IsMatch(levelFile.Name))
				{
					string levelName = MultiFileStream.GetFileName(levelFile.Name);
					AddFile(files, levelName, levelFile.FullName);
				}
			}
		}

		/// <summary>
		/// Collect bundles from the Streaming Assets folder
		/// </summary>
		protected void CollectStreamingAssets(IDictionary<string, string> files)
		{
			if (string.IsNullOrWhiteSpace(StreamingAssetsPath))
			{
				return;
			}

			Logger.Info(LogCategory.Import, "Collecting Streaming Assets...");
			DirectoryInfo streamingDirectory = new DirectoryInfo(StreamingAssetsPath);
			if (streamingDirectory.Exists)
			{
				CollectAssetBundlesRecursively(streamingDirectory, files);
			}
		}

		/// <summary>
		/// Collect asset bundles only from this directory
		/// </summary>
		protected void CollectAssetBundles(DirectoryInfo root, IDictionary<string, string> files)
		{
			foreach (FileInfo file in root.EnumerateFiles())
			{
				//if (file.Extension == AssetBundleExtension || file.Extension == AlternateBundleExtension)
				if (BundleFile.IsBundleFile(file.FullName))
				{
					string name = Path.GetFileNameWithoutExtension(file.Name).ToLowerInvariant();
					AddAssetBundle(files, name, file.FullName);
				}
			}
		}

		/// <summary>
		/// Collect asset bundles from this directory and all subdirectories
		/// </summary>
		protected void CollectAssetBundlesRecursively(DirectoryInfo root, IDictionary<string, string> files)
		{
			CollectAssetBundles(root, files);
			foreach (DirectoryInfo directory in root.EnumerateDirectories())
			{
				CollectAssetBundlesRecursively(directory, files);
			}
		}

		protected static void CollectAssemblies(DirectoryInfo root, IDictionary<string, string> assemblies)
		{
			foreach (FileInfo file in root.EnumerateFiles())
			{
				if (MonoManager.IsMonoAssembly(file.Name))
				{
					assemblies.Add(file.Name, file.FullName);
				}
			}
		}

		protected void CollectMainAssemblies()
		{
			if (Backend != ScriptingBackend.Mono)
			{
				return;//Only needed for Mono
			}
			else if (!string.IsNullOrWhiteSpace(ManagedPath) && Directory.Exists(ManagedPath))
			{
				DirectoryInfo managedDirectory = new DirectoryInfo(ManagedPath);
				CollectAssemblies(managedDirectory, Assemblies);
			}
			else if (!string.IsNullOrEmpty(GameDataPath))
			{
				string libPath = Path.Combine(Path.GetFullPath(GameDataPath), LibName);
				if (Directory.Exists(libPath))
				{
					CollectAssemblies(new DirectoryInfo(GameDataPath), Assemblies);
					DirectoryInfo libDirectory = new DirectoryInfo(libPath);
					CollectAssemblies(libDirectory, Assemblies);
				}
			}
		}

		private string? FindEngineDependency(string path, string dependency)
		{
			string filePath = Path.Combine(path, dependency);
			if (File.Exists(filePath))
			{
				return filePath;
			}

			string resourcePath = Path.Combine(path, ResourcesName);
			filePath = Path.Combine(resourcePath, dependency);
			if (File.Exists(filePath))
			{
				return filePath;
			}

			// really old versions contains file in this directory
			string unityPath = Path.Combine(path, UnityName);
			filePath = Path.Combine(unityPath, dependency);
			if (File.Exists(filePath))
			{
				return filePath;
			}
			return null;
		}

		/// <summary>
		/// Add game file
		/// </summary>
		protected void AddFile(IDictionary<string, string> files, string name, string path)
		{
			files.Add(name, path);
			Logger.Info(LogCategory.Import, $"Game file '{name}' has been found");
		}

		protected void AddAssetBundle(IDictionary<string, string> files, string name, string path)
		{
#warning TEMP HACK:
			int i = 0;
			string uniqueName = name;
			while (files.ContainsKey(uniqueName))
			{
				uniqueName = name + i++;
			}
			files.Add(uniqueName, path);
			Logger.Info(LogCategory.Import, $"Asset bundle '{name}' has been found");
		}

		protected static int[] GetUnityVersionFromSerializedFile(string filePath)
		{
			return ToArray(SerializedFile.LoadScheme(filePath).Metadata.UnityVersion);
		}

		protected static int[] GetUnityVersionFromBundleFile(string filePath)
		{
			return ToArray(BundleFile.LoadScheme(filePath).Header.UnityWebMinimumRevision);
		}

		private static int[] ToArray(UnityVersion version)
		{
			return new int[] { version.Major, version.Minor, version.Build };
		}

		protected static int[]? GetUnityVersionFromDataDirectory(string dataDirectoryPath)
		{
			string globalGameManagersPath = Path.Combine(dataDirectoryPath, GlobalGameManagersName);
			if (File.Exists(globalGameManagersPath))
			{
				return GetUnityVersionFromSerializedFile(globalGameManagersPath);
			}
			string dataBundlePath = Path.Combine(dataDirectoryPath, DataBundleName);
			if (File.Exists(dataBundlePath))
			{
				return GetUnityVersionFromBundleFile(dataBundlePath);
			}
			return null;
		}

		protected static bool HasMonoAssemblies(string managedDirectory)
		{
			if (string.IsNullOrEmpty(managedDirectory) || !Directory.Exists(managedDirectory))
			{
				return false;
			}

			return Directory.GetFiles(managedDirectory, "*.dll").Length > 0;
		}

		protected bool HasIl2CppFiles()
		{
			return Il2CppGameAssemblyPath != null &&
				Il2CppMetaDataPath != null &&
				File.Exists(Il2CppGameAssemblyPath) &&
				File.Exists(Il2CppMetaDataPath);
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/SwitchGameStructure.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class SwitchGameStructure : PlatformGameStructure
	{
		private const string ExefsName = "exefs";
		private const string RomName = "romfs";
		private const string MainName = "main";

		public SwitchGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Root directory '{rootPath}' doesn't exist");
			}

			if (!GetDataSwitchDirectory(m_root, out string? dataPath))
			{
				throw new Exception($"Data directory wasn't found");
			}

			Name = m_root.Name;
			RootPath = rootPath;
			GameDataPath = dataPath;
			StreamingAssetsPath = Path.Combine(dataPath, StreamingName);
			ResourcesPath = Path.Combine(dataPath, ResourcesName);
			ManagedPath = Path.Combine(dataPath, ManagedName);
			UnityPlayerPath = null;
			UnityVersion = GetUnityVersionFromDataDirectory(dataPath);
			Il2CppGameAssemblyPath = Path.Combine(rootPath, ExefsName, MainName);
			Il2CppMetaDataPath = Path.Combine(ManagedPath, MetadataName, DefaultGlobalMetadataName);
			Backend = HasIl2CppFiles() ? Assembly.ScriptingBackend.IL2Cpp : Assembly.ScriptingBackend.Unknown;

			DataPaths = new string[] { dataPath };
		}

		public static bool IsSwitchStructure(string path)
		{
			DirectoryInfo rootInfo = new DirectoryInfo(path);
			if (!rootInfo.Exists)
			{
				return false;
			}
			if (!Directory.Exists(Path.Combine(rootInfo.FullName, ExefsName)))
			{
				return false;
			}

			return GetDataSwitchDirectory(rootInfo, out string _);
		}

		private static bool GetDataSwitchDirectory(DirectoryInfo rootDirectory, [NotNullWhen(true)] out string? dataPath)
		{
			dataPath = null;
			string romPath = Path.Combine(rootDirectory.FullName, RomName);
			if (!Directory.Exists(romPath))
			{
				return false;
			}

			string ldataPath = Path.Combine(romPath, DataFolderName);
			if (!Directory.Exists(ldataPath))
			{
				return false;
			}

			dataPath = ldataPath;
			return true;
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/WebGLGameStructure.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class WebGLGameStructure : PlatformGameStructure
	{
		public WebGLGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Directory '{rootPath}' doesn't exist");
			}

			string buildPath = Path.Combine(m_root.FullName, BuildName);
			if (Directory.Exists(buildPath))
			{
				DirectoryInfo buildDirectory = new DirectoryInfo(buildPath);
				foreach (FileInfo file in buildDirectory.EnumerateFiles())
				{
					if (file.Name.EndsWith(DataWebExtension, StringComparison.Ordinal))
					{
						Name = file.Name.Substring(0, file.Name.Length - DataWebExtension.Length);
						Files.Add(Name, file.FullName);
						break;
					}
				}
				DataPaths = new string[] { rootPath, buildPath };
			}
			else
			{
				string developmentPath = Path.Combine(m_root.FullName, DevelopmentName);
				if (Directory.Exists(developmentPath))
				{
					DirectoryInfo buildDirectory = new DirectoryInfo(developmentPath);
					foreach (FileInfo file in buildDirectory.EnumerateFiles())
					{
						if (file.Extension == DataExtension)
						{
							Name = file.Name.Substring(0, file.Name.Length - DataExtension.Length);
							Files.Add(Name, file.FullName);
							break;
						}
					}
					DataPaths = new string[] { rootPath, developmentPath };
				}
				else
				{
					string releasePath = Path.Combine(m_root.FullName, ReleaseName);
					if (Directory.Exists(releasePath))
					{
						DirectoryInfo buildDirectory = new DirectoryInfo(releasePath);
						foreach (FileInfo file in buildDirectory.EnumerateFiles())
						{
							if (file.Extension == DataGzExtension)
							{
								Name = file.Name.Substring(0, file.Name.Length - DataGzExtension.Length);
								Files.Add(Name, file.FullName);
								break;
							}
						}
						DataPaths = new string[] { rootPath, releasePath };
					}
					else
					{
						throw new Exception("Build directory wasn't found");
					}
				}
			}

			Name = m_root.Name;
			RootPath = rootPath;
			GameDataPath = rootPath;
			StreamingAssetsPath = rootPath;
			ResourcesPath = null;
			ManagedPath = null;
			UnityPlayerPath = null;
			UnityVersion = null;
			Il2CppGameAssemblyPath = null;
			Il2CppMetaDataPath = null;
			Backend = Assembly.ScriptingBackend.Unknown;

			if (Files.Count == 0)
			{
				throw new Exception("No files were found");
			}
		}

		public static bool IsWebGLStructure(string path)
		{
			DirectoryInfo root = new DirectoryInfo(path);
			if (!root.Exists)
			{
				return false;
			}

			foreach (FileInfo fi in root.EnumerateFiles())
			{
				if (fi.Extension == HtmlExtension)
				{
					foreach (DirectoryInfo di in root.EnumerateDirectories())
					{
						switch (di.Name)
						{
							case DevelopmentName:
								{
									foreach (FileInfo file in di.EnumerateFiles())
									{
										if (file.Extension == DataExtension)
										{
											return true;
										}
									}
								}
								break;

							case ReleaseName:
								{
									foreach (FileInfo file in di.EnumerateFiles())
									{
										if (file.Extension == DataGzExtension)
										{
											return true;
										}
									}
								}
								break;

							case BuildName:
								{
									foreach (FileInfo file in di.EnumerateFiles())
									{
										if (file.Name.EndsWith(DataWebExtension, StringComparison.Ordinal))
										{
											return true;
										}
									}
								}
								break;
						}
					}

					return false;
				}
			}
			return false;
		}

		private const string DevelopmentName = "Development";
		private const string ReleaseName = "Release";
		private const string BuildName = "Build";

		private const string HtmlExtension = ".html";
		public const string DataExtension = ".data";
		public const string DataGzExtension = ".datagz";
		public const string UnityWebExtension = ".unityweb";
		public const string DataWebExtension = DataExtension + UnityWebExtension;
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/WebPlayerGameStructure.cs`:

```cs
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class WebPlayerGameStructure : PlatformGameStructure
	{
		public WebPlayerGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Directory '{rootPath}' doesn't exist");
			}

			if (!GetWebPlayerName(m_root, out string? name))
			{
				throw new Exception($"Web player asset bundle data wasn't found");
			}

			Name = name;
			RootPath = rootPath;
			GameDataPath = null;
			StreamingAssetsPath = null;
			ResourcesPath = null;
			ManagedPath = null;
			UnityPlayerPath = null;
			Il2CppGameAssemblyPath = null;
			Il2CppMetaDataPath = null;
			UnityVersion = null;
			Backend = Assembly.ScriptingBackend.Unknown;

			DataPaths = new string[] { rootPath };

			string abPath = Path.Combine(m_root.FullName, Name + AssetBundleExtension);
			Files.Add(Name, abPath);
		}

		public static bool IsWebPlayerStructure(string path)
		{
			DirectoryInfo dinfo = new DirectoryInfo(path);
			if (!dinfo.Exists)
			{
				return false;
			}

			return GetWebPlayerName(dinfo, out string _);
		}

		public static bool GetWebPlayerName(DirectoryInfo root, [NotNullWhen(true)] out string? name)
		{
			foreach (FileInfo fi in root.EnumerateFiles())
			{
				if (fi.Extension == HtmlExtension)
				{
					name = fi.Name.Substring(0, fi.Name.Length - HtmlExtension.Length);
					string abPath = Path.Combine(root.FullName, name + AssetBundleExtension);
					if (File.Exists(abPath))
					{
						return true;
					}
				}
			}
			name = null;
			return false;
		}

		private const string HtmlExtension = ".html";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/WiiUGameStructure.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class WiiUGameStructure : PlatformGameStructure
	{
		public WiiUGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Directory '{rootPath}' doesn't exist");
			}

			Name = m_root.Name;
			RootPath = m_root.FullName;
			GameDataPath = Path.Combine(RootPath, ContentName, DataFolderName);
			if (!Directory.Exists(GameDataPath))
			{
				throw new Exception($"Data directory wasn't found");
			}
			StreamingAssetsPath = Path.Combine(GameDataPath, StreamingName);
			ResourcesPath = Path.Combine(GameDataPath, ResourcesName);
			ManagedPath = Path.Combine(GameDataPath, ManagedName);
			UnityPlayerPath = null;
			UnityVersion = null;
			Il2CppGameAssemblyPath = null;
			Il2CppMetaDataPath = null;
			//WiiU doesn't support IL2Cpp
			//See https://docs.unity3d.com/2017.4/Documentation/Manual/ScriptingRestrictions.html

			if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			DataPaths = new string[] { GameDataPath };
		}

		public static bool IsWiiUStructure(string rootPath)
		{
			string gameDataPath = Path.Combine(rootPath, ContentName, DataFolderName);
			return Directory.Exists(gameDataPath);
		}

		private const string ContentName = "content";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Platforms/iOSGameStructure.cs`:

```cs
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure.Platforms
{
	internal sealed class iOSGameStructure : PlatformGameStructure
	{
		public iOSGameStructure(string rootPath)
		{
			if (string.IsNullOrEmpty(rootPath))
			{
				throw new ArgumentNullException(nameof(rootPath));
			}
			m_root = new DirectoryInfo(rootPath);
			if (!m_root.Exists)
			{
				throw new Exception($"Root directory '{rootPath}' doesn't exist");
			}

			if (!GetDataiOSDirectory(m_root, out string? dataPath, out string? appPath, out string? name))
			{
				throw new Exception($"Data directory wasn't found");
			}

			Name = name;
			RootPath = rootPath;
			GameDataPath = dataPath;
			StreamingAssetsPath = Path.Combine(m_root.FullName, iOSStreamingName);
			ResourcesPath = Path.Combine(dataPath, ResourcesName);
			ManagedPath = Path.Combine(dataPath, ManagedName);
			UnityPlayerPath = null;
			UnityVersion = GetUnityVersionFromDataDirectory(GameDataPath);
			Il2CppGameAssemblyPath = Path.Combine(appPath, name);
			Il2CppMetaDataPath = Path.Combine(ManagedPath, MetadataName, DefaultGlobalMetadataName);

			if (HasIl2CppFiles())
			{
				Backend = Assembly.ScriptingBackend.IL2Cpp;
			}
			else if (HasMonoAssemblies(ManagedPath))
			{
				Backend = Assembly.ScriptingBackend.Mono;
			}
			else
			{
				Backend = Assembly.ScriptingBackend.Unknown;
			}

			DataPaths = new string[] { dataPath };
		}

		public static bool IsiOSStructure(string path)
		{
			DirectoryInfo root = new DirectoryInfo(path);
			if (!root.Exists)
			{
				return false;
			}

			return GetDataiOSDirectory(root, out string _, out string _, out string _);
		}

		private static bool GetDataiOSDirectory(DirectoryInfo rootDirectory, [NotNullWhen(true)] out string? dataPath, [NotNullWhen(true)] out string? appPath, [NotNullWhen(true)] out string? appName)
		{
			dataPath = null;
			appPath = null;
			appName = null;

			string payloadPath = Path.Combine(rootDirectory.FullName, PayloadName);
			DirectoryInfo payloadDirectory = new DirectoryInfo(payloadPath);
			if (!payloadDirectory.Exists)
			{
				return false;
			}

			foreach (DirectoryInfo dinfo in payloadDirectory.EnumerateDirectories())
			{
				if (dinfo.Name.EndsWith(AppExtension, StringComparison.Ordinal))
				{
					appPath = dinfo.FullName;
					appName = dinfo.Name.Substring(0, dinfo.Name.Length - AppExtension.Length);
					dataPath = Path.Combine(dinfo.FullName, DataFolderName);
					if (Directory.Exists(dataPath))
					{
						return true;
					}
				}
			}

			dataPath = null;
			appPath = null;
			appName = null;
			return false;
		}

		private void CollectiOSStreamingAssets(DirectoryInfo root, IDictionary<string, string> files)
		{
			string streamingPath = Path.Combine(root.FullName, iOSStreamingName);
			DirectoryInfo streamingDirectory = new DirectoryInfo(streamingPath);
			if (streamingDirectory.Exists)
			{
				CollectAssetBundlesRecursively(root, files);
			}
		}


		private const string iOSStreamingName = "Raw";

		private const string PayloadName = "Payload";
		private const string AppExtension = ".app";
	}
}

```

`AssetRipper.Fundamentals/Structure/GameStructure/Preprocessor.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.Core.Utils;
using ICSharpCode.SharpZipLib.Zip;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Structure.GameStructure
{
	public static class Preprocessor
	{
		private const string ZipExtension = ".zip";
		private const string ApkExtension = ".apk";
		private const string ObbExtension = ".obb";
		private const string XapkExtension = ".xapk";
		private const string VpkExtension = ".vpk"; //PS Vita
		private const string IpaExtension = ".ipa"; //iOS App Store Package
		private const uint ZipNormalMagic = 0x04034B50;
		private const uint ZipEmptyMagic = 0x06054B50;
		private const uint ZipSpannedMagic = 0x08074B50;

		public static List<string> Process(IEnumerable<string> paths)
		{
			List<string> result = new List<string>();
			foreach (string path in paths)
			{
				switch (GetFileExtension(path))
				{
					case ZipExtension:
					case ApkExtension:
					case ObbExtension:
					case VpkExtension:
					case IpaExtension:
						result.Add(ExtractZip(path));
						break;
					case XapkExtension:
						result.Add(ExtractXapk(path));
						break;
					default:
						result.Add(path);
						break;
				}
			}
			return result;
		}

		private static string ExtractZip(string zipFilePath)
		{
			if (!HasCompatibleMagic(zipFilePath))
			{
				return zipFilePath;
			}

			string outputDirectory = TempFolderManager.CreateNewRandomTempFolder();
			DecompressZipArchive(zipFilePath, outputDirectory);
			return outputDirectory;
		}

		private static string ExtractXapk(string xapkFilePath)
		{
			if (!HasCompatibleMagic(xapkFilePath))
			{
				return xapkFilePath;
			}

			string intermediateDirectory = TempFolderManager.CreateNewRandomTempFolder();
			string outputDirectory = TempFolderManager.CreateNewRandomTempFolder();
			DecompressZipArchive(xapkFilePath, intermediateDirectory);
			foreach (string filePath in Directory.GetFiles(intermediateDirectory))
			{
				if (GetFileExtension(filePath) == ApkExtension)
				{
					DecompressZipArchive(filePath, outputDirectory);
				}
			}
			return outputDirectory;
		}

		private static void DecompressZipArchive(string zipFilePath, string outputDirectory)
		{
			Logger.Info(LogCategory.Import, $"Decompressing files...{Environment.NewLine}\tFrom: {zipFilePath}{Environment.NewLine}\tTo: {outputDirectory}");
			FastZip zipper = new FastZip();
			zipper.ExtractZip(zipFilePath, outputDirectory, null);
		}

		private static string? GetFileExtension(string path)
		{
			if (File.Exists(path))
			{
				return Path.GetExtension(path);
			}
			else
			{
				return null;
			}
		}

		private static bool HasCompatibleMagic(string path)
		{
			uint magic = GetMagicNumber(path);
			return magic == ZipNormalMagic || magic == ZipEmptyMagic || magic == ZipSpannedMagic;
		}

		private static uint GetMagicNumber(string path)
		{
			return new BinaryReader(File.OpenRead(path)).ReadUInt32();
		}
	}
}

```

`AssetRipper.Fundamentals/Structure/IFileCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Structure.Assembly.Managers;
using System.Collections.Generic;

namespace AssetRipper.Core.Structure
{
	public interface IFileCollection
	{
		LayoutInfo Layout { get; }
		ISerializedFile? FindSerializedFile(string fileName);
		IResourceFile? FindResourceFile(string fileName);

		T? FindAsset<T>() where T : IUnityObjectBase;
		T? FindAsset<T>(string name) where T : IUnityObjectBase, IHasNameString;
		IEnumerable<IUnityObjectBase> FetchAssets();

		IEnumerable<IUnityObjectBase> FetchAssetsOfType<T>() where T : IUnityObjectBase;

		bool IsScene(ISerializedFile file);

		IAssemblyManager AssemblyManager { get; }
	}
}

```

`AssetRipper.Fundamentals/Structure/SchemeReader.cs`:

```cs
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.ArchiveFiles;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.WebFiles;
using System.IO;

namespace AssetRipper.Core.Structure
{
	public static class SchemeReader
	{
		/// <summary>Returns some information about the file including its type</summary>
		public static FileScheme LoadScheme(string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static FileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			using MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false);
			if (BundleFile.IsBundleFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_bundle", fileName);
				return BundleFileScheme.ReadScheme(buffer, filePath, fileName);
			}
			if (ArchiveFile.IsArchiveFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_archive", fileName);
				return ArchiveFile.ReadScheme(buffer, filePath, fileName);
			}
			if (WebFile.IsWebFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_web", fileName);
				return WebFile.ReadScheme(buffer, filePath);
			}
			if (SerializedFile.IsSerializedFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_serialized", fileName);
				return SerializedFile.ReadScheme(buffer, filePath, fileName);
			}
			Logger.SendStatusChange($"loading_step_parse_resource", fileName);
			return ResourceFile.ReadScheme(buffer, filePath, fileName);
		}

		public static FileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			if (BundleFile.IsBundleFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_bundle", fileName);
				return BundleFileScheme.ReadScheme(stream, filePath, fileName);
			}
			if (ArchiveFile.IsArchiveFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_archive", fileName);
				return ArchiveFile.ReadScheme(stream, filePath, fileName);
			}
			if (WebFile.IsWebFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_web", fileName);
				return WebFile.ReadScheme(stream, filePath);
			}
			if (SerializedFile.IsSerializedFile(stream))
			{
				Logger.SendStatusChange($"loading_step_parse_serialized", fileName);
				return SerializedFile.ReadScheme(stream, filePath, fileName);
			}

			Logger.SendStatusChange($"loading_step_parse_resource", fileName);
			return ResourceFile.ReadScheme(stream, filePath, fileName);
		}
	}
}

```

`AssetRipper.Fundamentals/TaskManager.cs`:

```cs
using System.Collections.Generic;
using System.Threading.Tasks;

namespace AssetRipper.Core
{
	public static class TaskManager
	{
		private static readonly List<Task> tasks = new List<Task>();

		public static void AddTask(Task task) => tasks.Add(task);

		public static void WaitUntilAllCompleted()
		{
			foreach (Task task in tasks)
			{
				task.Wait();
			}
			tasks.Clear();
		}
	}
}

```

`AssetRipper.Fundamentals/UnityAssetBase.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Equality;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core
{
	/// <summary>
	/// The artificial base class for all generated Unity classes
	/// </summary>
	public class UnityAssetBase : IUnityAssetBase, IAlmostEquatable
	{
		public UnityAssetBase() { }
		public UnityAssetBase(LayoutInfo layout)
		{
		}

		public virtual void ReadEditor(AssetReader reader) => throw new NotSupportedException();

		public virtual void ReadRelease(AssetReader reader) => throw new NotSupportedException();

		public virtual void Read(AssetReader reader)
		{
			if (reader.Flags.IsRelease())
			{
				ReadRelease(reader);
			}
			else
			{
				ReadEditor(reader);
			}
		}

		public virtual void WriteEditor(AssetWriter writer) => throw new NotSupportedException();

		public virtual void WriteRelease(AssetWriter writer) => throw new NotSupportedException();

		public virtual void Write(AssetWriter writer)
		{
			if (writer.Flags.IsRelease())
			{
				WriteRelease(writer);
			}
			else
			{
				WriteEditor(writer);
			}
		}

		public virtual YamlNode ExportYamlEditor(IExportContainer container) => throw new NotSupportedException($"Editor yaml export is not supported for {GetType().FullName}");

		public virtual YamlNode ExportYamlRelease(IExportContainer container) => throw new NotSupportedException($"Release yaml export is not supported for {GetType().FullName}");

		public virtual YamlNode ExportYaml(IExportContainer container)
		{
			if (container.ExportFlags.IsRelease())
			{
				return ExportYamlRelease(container);
			}
			else
			{
				return ExportYamlEditor(container);
			}
		}

		public virtual IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			return Array.Empty<PPtr<IUnityObjectBase>>();
		}

		public virtual List<TypeTreeNode> MakeReleaseTypeTreeNodes(int depth, int startingIndex) => throw new NotSupportedException();

		public virtual List<TypeTreeNode> MakeEditorTypeTreeNodes(int depth, int startingIndex) => throw new NotSupportedException();

		private bool HasEqualMetadata([NotNullWhen(true)] object? obj)
		{
			if (obj is null)
			{
				return false;
			}

			if (this.GetType() != obj.GetType())
			{
				return false;
			}

			if (obj is UnityObjectBase unityObjectBase)
			{
				UnityObjectBase thisObject = (UnityObjectBase)this;
				return thisObject.SerializedFile == unityObjectBase.SerializedFile &&
					thisObject.ClassID == unityObjectBase.ClassID &&
					thisObject.PathID == unityObjectBase.PathID &&
					thisObject.GUID == unityObjectBase.GUID;
			}
			else
			{
				return true;
			}
		}

		/// <inheritdoc/>
		public bool AlmostEqualByProportion(object value, float maximumProportion)
		{
			if (HasEqualMetadata(value))
			{
				return AlmostEqualByProportion((UnityAssetBase)value, maximumProportion);
			}
			else
			{
				return false;
			}
		}

		/// <inheritdoc/>
		public bool AlmostEqualByDeviation(object value, float maximumDeviation)
		{
			if (HasEqualMetadata(value))
			{
				return AlmostEqualByDeviation((UnityAssetBase)value, maximumDeviation);
			}
			else
			{
				return false;
			}
		}

		/// <summary>
		/// Check if two objects are almost equal to each other by proportion
		/// </summary>
		/// <remarks>
		/// This method assumes that the other asset is not null
		/// and has the same metadata as this.
		/// </remarks>
		/// <param name="value">Another asset with the same type as this</param>
		/// <param name="maximumProportion"></param>
		/// <returns>True if the objects are equal or almost equal by proportion</returns>
		protected virtual bool AlmostEqualByProportion(UnityAssetBase value, float maximumProportion)
		{
			return ReferenceEquals(this, value);
		}

		/// <summary>
		/// Check if two objects are almost equal to each other by deviation
		/// </summary>
		/// <remarks>
		/// This method assumes that the other asset is not null
		/// and has the same metadata as this.
		/// </remarks>
		/// <param name="value">Another asset with the same type as this</param>
		/// <param name="maximumDeviation">The positive maximum value deviation between two near equal decimal values</param>
		/// <returns>True if the objects are equal or almost equal by deviation</returns>
		protected virtual bool AlmostEqualByDeviation(UnityAssetBase value, float maximumDeviation)
		{
			return ReferenceEquals(this, value);
		}
	}
}

```

`AssetRipper.Fundamentals/UnityObjectBase.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Object;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.IO;

namespace AssetRipper.Core
{
	/// <summary>
	/// The artificial base class for all generated Unity classes with Type ID numbers<br/>
	/// In other words, the classes that inherit from Object
	/// </summary>
	public class UnityObjectBase : UnityAssetBase, IUnityObjectBase
	{
		public AssetInfo AssetInfo { get; set; }
		public ISerializedFile SerializedFile => AssetInfo.File;
		public virtual ClassIDType ClassID => AssetInfo.ClassID;
		public virtual string AssetClassName => "Unknown";
		public long PathID => AssetInfo.PathID;
		public UnityGUID GUID
		{
			get => AssetInfo.GUID;
			set
			{
				AssetInfo.GUID = value;
			}
		}
		public virtual string ExportPath => Path.Combine(AssetsKeyword, AssetClassName);
		public virtual string ExportExtension => AssetExtension;

		public const string AssetsKeyword = "Assets";
		protected const string AssetExtension = "asset";

		public UnityObjectBase() : base()
		{
			AssetInfo = AssetInfo.MakeDummyAssetInfo();
		}

		public UnityObjectBase(LayoutInfo layout) : base(layout) 
		{
			AssetInfo = AssetInfo.MakeDummyAssetInfo();
		}

		public UnityObjectBase(AssetInfo assetInfo) : base()
		{
			AssetInfo = assetInfo;
		}

		public YamlDocument ExportYamlDocument(IExportContainer container)
		{
			YamlDocument document = new YamlDocument();
			YamlMappingNode root = document.CreateMappingRoot();
			root.Tag = ClassID.ToInt().ToString();
			root.Anchor = container.GetExportID(this).ToString();
			YamlNode node = ExportYaml(container);
			root.Add(AssetClassName, node);
			return document;
		}
	}
}

```

`AssetRipper.Fundamentals/Utils/ArrayUtils.cs`:

```cs
namespace AssetRipper.Core.Utils
{
	public static class ArrayUtils
	{
		public static T[] Combine<T>(T[] array1, T[] array2)
		{
			if (array1 == null)
			{
				throw new ArgumentNullException(nameof(array1));
			}

			if (array2 == null)
			{
				throw new ArgumentNullException(nameof(array2));
			}

			T[] result = new T[array1.Length + array2.Length];
			for (int i = 0; i < array1.Length; i++)
			{
				result[i] = array1[i];
			}
			for (int j = 0; j < array2.Length; j++)
			{
				result[j + array1.Length] = array2[j];
			}
			return result;
		}

		/// <summary>
		/// Creates an array with non-null elements
		/// </summary>
		/// <typeparam name="T">The type of the array elements</typeparam>
		/// <param name="length">The length of the array</param>
		/// <returns>A new array of the specified length and type</returns>
		/// <exception cref="ArgumentOutOfRangeException">Length less than zero</exception>
		public static T[] CreateAndInitializeArray<T>(int length) where T : new()
		{
			if (length < 0)
			{
				throw new ArgumentOutOfRangeException(nameof(length));
			}

			if (length == 0)
			{
				return Array.Empty<T>();
			}

			T[] array = new T[length];
			for (int i = 0; i < length; i++)
			{
				array[i] = new();
			}
			return array;
		}
	}
}

```

`AssetRipper.Fundamentals/Utils/CrcUtils.cs`:

```cs
using AssetRipper.Core.Classes;
using ICSharpCode.SharpZipLib.Checksum;
using System.Text;

namespace AssetRipper.Core.Utils
{
	public static class CrcUtils
	{
		public static uint CalculateDigest(byte[] data)
		{
			Crc32 crc = new Crc32();
			crc.Update(data);
			return (uint)crc.Value;
		}

		public static uint CalculateDigestAscii(string data)
		{
			Crc32 crc = new Crc32();
			for (int i = 0; i < data.Length; i++)
			{
				byte b = (byte)data[i];
				crc.Update(b);
			}

			return (uint)crc.Value;
		}

		public static uint CalculateDigestUTF8(string data)
		{
			return CalculateDigest(Encoding.UTF8.GetBytes(data));
		}

		public static uint CalculateDigestUTF8(Utf8StringBase data)
		{
			return CalculateDigest(data.Data);
		}

		public static uint CalculateDigest(byte[] data, int offset, int size)
		{
			Crc32 crc = new Crc32();
			ArraySegment<byte> segment = new ArraySegment<byte>(data, offset, size);
			crc.Update(segment);
			return (uint)crc.Value;
		}

		public static bool VerifyDigestUTF8(string data, uint digest)
		{
			return CalculateDigestUTF8(data) == digest;
		}

		public static bool VerifyDigestUTF8(Utf8StringBase data, uint digest)
		{
			return CalculateDigestUTF8(data) == digest;
		}

		public static bool Verify28DigestUTF8(string data, uint digest)
		{
			return (CalculateDigestUTF8(data) & 0xFFFFFFF) == digest;
		}

		public static bool Verify28DigestUTF8(Utf8StringBase data, uint digest)
		{
			return (CalculateDigestUTF8(data) & 0xFFFFFFF) == digest;
		}

		public static bool VerifyDigest(byte[] data, int offset, int size, uint digest)
		{
			return CalculateDigest(data, offset, size) == digest;
		}
	}
}

```

`AssetRipper.Fundamentals/Utils/DirectoryUtils.cs`:

```cs
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AssetRipper.Core.Utils
{
	public static class DirectoryUtils
	{
		public static string FixInvalidPathCharacters(string path)
		{
			return PathRegex.Replace(path, "_");
		}

		private static Regex GeneratePathRegex()
		{
			string invalidChars = new string(Path.GetInvalidFileNameChars().Except(new char[] { '\\', '/' }).ToArray());
			string escapedChars = Regex.Escape(invalidChars);
			return new Regex($"[{escapedChars}]");
		}

		public static string GetRelativePath(string filePath, string folder)
		{
			Uri pathUri = new Uri(filePath);
			if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				folder += Path.DirectorySeparatorChar;
			}
			Uri folderUri = new Uri(folder);
			return Uri.UnescapeDataString(folderUri.MakeRelativeUri(pathUri).ToString().Replace('/', Path.DirectorySeparatorChar));
		}

		private static readonly Regex PathRegex = GeneratePathRegex();
	}
}

```

`AssetRipper.Fundamentals/Utils/ExecutingDirectory.cs`:

```cs
namespace AssetRipper.Core.Utils
{
	public static class ExecutingDirectory
	{
		static ExecutingDirectory()
		{
			Info = new System.IO.DirectoryInfo(System.AppContext.BaseDirectory);
		}

		public static System.IO.DirectoryInfo Info { get; }
		public static string Name => Info.Name;
		public static string Path => Info.FullName;

		public static string Combine(string relativePath) => System.IO.Path.Combine(Path, relativePath);
		public static string Combine(string path1, string path2) => System.IO.Path.Combine(Path, path1, path2);
		public static string Combine(string path1, string path2, string path3) => System.IO.Path.Combine(Path, path1, path2, path3);
		public static string Combine(params string[] parameters) => System.IO.Path.Combine(Path, System.IO.Path.Combine(parameters));
	}
}

```

`AssetRipper.Fundamentals/Utils/FileUtils.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;

namespace AssetRipper.Core.Utils
{
	public static class FileUtils
	{
		private static readonly Dictionary<string, int> UniqueNamesByInitialPath = new();

		/// <summary>
		/// Reads a file to determine its length
		/// </summary>
		/// <param name="path">The path to the file being investigated</param>
		/// <returns>The number of bytes in the file</returns>
		public static long GetFileSize(string path)
		{
			using FileStream stream = File.OpenRead(path);
			return stream.Length;
		}

		public static string FixInvalidNameCharacters(string path)
		{
			return FileNameRegex.Replace(path, string.Empty);
		}

		public static string RemoveCloneSuffixes(string path)
		{
			return path.Replace("(Clone)", string.Empty);
		}

		public static string GetUniqueName(string dirPath, string fileName, int maxNameLength)
		{
			string? ext = null;
			string? name = null;
			int maxLength = maxNameLength - 4;
			string validFileName = fileName;
			if (validFileName.Length > maxLength)
			{
				ext = Path.GetExtension(validFileName);
				name = validFileName.Substring(0, maxLength - ext.Length);
				validFileName = name + ext;
			}

			if (!Directory.Exists(dirPath))
			{
				return validFileName;
			}

			name = name ?? Path.GetFileNameWithoutExtension(validFileName);
			if (!IsReservedName(name))
			{
				if (!File.Exists(Path.Combine(dirPath, validFileName)))
				{
					return validFileName;
				}
			}

			ext = ext ?? Path.GetExtension(validFileName);

			string key = Path.Combine(dirPath, $"{name}{ext}");
			UniqueNamesByInitialPath.TryGetValue(key, out int initial);

			for (int counter = initial; counter < int.MaxValue; counter++)
			{
				string proposedName = $"{name}_{counter}{ext}";
				if (!File.Exists(Path.Combine(dirPath, proposedName)))
				{
					UniqueNamesByInitialPath[key] = counter;
					return proposedName;
				}
			}
			throw new Exception($"Can't generate unique name for file {fileName} in directory {dirPath}");
		}

		public static bool IsReservedName(string name)
		{
			if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
			{
				return ReservedNames.Contains(name.ToLower());
			}
			return false;
		}

		private static Regex GenerateFileNameRegex()
		{
			string invalidChars = GetInvalidFileNameChars();
			string escapedChars = Regex.Escape(invalidChars);
			return new Regex($"[{escapedChars}]");
		}

		/// <summary>
		/// Gets all the invalid characters including the colon on Linux
		/// </summary>
		/// <returns></returns>
		private static string GetInvalidFileNameChars()
		{
			char[] defaultBadCharacters = Path.GetInvalidFileNameChars();
			string result = new string(defaultBadCharacters);
			if (defaultBadCharacters.Contains(':'))
			{
				return result;
			}
			else
			{
				return result + ':';
			}
		}

		public const int MaxFileNameLength = 256;
		public const int MaxFilePathLength = 260;

		private static readonly HashSet<string> ReservedNames = new HashSet<string>()
		{
			"aux", "con", "nul", "prn",
			"com1", "com2", "com3", "com4", "com5", "com6", "com7", "com8", "com9",
			"lpt1", "lpt2", "lpt3", "lpt4", "lpt5", "lpt6", "lpt7", "lpt8", "lpt9",
		};
		private static readonly Regex FileNameRegex = GenerateFileNameRegex();
	}
}

```

`AssetRipper.Fundamentals/Utils/HashUtils.cs`:

```cs
using System.Security.Cryptography;
using System.Text;

namespace AssetRipper.Core.Utils
{
	public static class HashUtils
	{
		public static string HashBytes(byte[] inputBytes)
		{
			using MD5 md5 = MD5.Create();
			byte[] hashBytes = md5.ComputeHash(inputBytes);
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < hashBytes.Length; i++)
			{
				sb.Append(hashBytes[i].ToString("X2"));
			}
			return sb.ToString();
		}
	}
}

```

`AssetRipper.Fundamentals/Utils/MD4.cs`:

```cs
using System.Collections.Generic;
using System.Linq;
using System.Security.Cryptography;

namespace AssetRipper.Core.Utils
{
	public class MD4 : HashAlgorithm
	{
		public MD4()
		{
			_x = new uint[16];

			Initialize();
		}

		public override void Initialize()
		{
			_a = 0x67452301;
			_b = 0xefcdab89;
			_c = 0x98badcfe;
			_d = 0x10325476;

			_bytesProcessed = 0;
		}

		protected override void HashCore(byte[] array, int offset, int length)
		{
			ProcessMessage(Bytes(array, offset, length));
		}

		protected override byte[] HashFinal()
		{
			try
			{
				ProcessMessage(Padding());

				return new[] { _a, _b, _c, _d }.SelectMany(word => Bytes(word)).ToArray();
			}
			finally
			{
				Initialize();
			}
		}

		private void ProcessMessage(IEnumerable<byte> bytes)
		{
			foreach (byte b in bytes)
			{
				int c = _bytesProcessed & 63;
				int i = c >> 2;
				int s = (c & 3) << 3;

				_x[i] = (_x[i] & ~((uint)255 << s)) | ((uint)b << s);

				if (c == 63)
				{
					Process16WordBlock();
				}

				_bytesProcessed++;
			}
		}

		private static IEnumerable<byte> Bytes(byte[] bytes, int offset, int length)
		{
			for (int i = offset; i < length; i++)
			{
				yield return bytes[i];
			}
		}

		private IEnumerable<byte> Bytes(uint word)
		{
			yield return (byte)(word & 255);
			yield return (byte)((word >> 8) & 255);
			yield return (byte)((word >> 16) & 255);
			yield return (byte)((word >> 24) & 255);
		}

		private IEnumerable<byte> Repeat(byte value, int count)
		{
			for (int i = 0; i < count; i++)
			{
				yield return value;
			}
		}

		private IEnumerable<byte> Padding()
		{
			return Repeat(128, 1)
			   .Concat(Repeat(0, ((_bytesProcessed + 8) & 0x7fffffc0) + 55 - _bytesProcessed))
			   .Concat(Bytes((uint)_bytesProcessed << 3))
			   .Concat(Repeat(0, 4));
		}

		private void Process16WordBlock()
		{
			uint aa = _a;
			uint bb = _b;
			uint cc = _c;
			uint dd = _d;

			foreach (int k in new[] { 0, 4, 8, 12 })
			{
				aa = Round1Operation(aa, bb, cc, dd, _x[k], 3);
				dd = Round1Operation(dd, aa, bb, cc, _x[k + 1], 7);
				cc = Round1Operation(cc, dd, aa, bb, _x[k + 2], 11);
				bb = Round1Operation(bb, cc, dd, aa, _x[k + 3], 19);
			}

			foreach (int k in new[] { 0, 1, 2, 3 })
			{
				aa = Round2Operation(aa, bb, cc, dd, _x[k], 3);
				dd = Round2Operation(dd, aa, bb, cc, _x[k + 4], 5);
				cc = Round2Operation(cc, dd, aa, bb, _x[k + 8], 9);
				bb = Round2Operation(bb, cc, dd, aa, _x[k + 12], 13);
			}

			foreach (int k in new[] { 0, 2, 1, 3 })
			{
				aa = Round3Operation(aa, bb, cc, dd, _x[k], 3);
				dd = Round3Operation(dd, aa, bb, cc, _x[k + 8], 9);
				cc = Round3Operation(cc, dd, aa, bb, _x[k + 4], 11);
				bb = Round3Operation(bb, cc, dd, aa, _x[k + 12], 15);
			}

			unchecked
			{
				_a += aa;
				_b += bb;
				_c += cc;
				_d += dd;
			}
		}

		private static uint ROL(uint value, int numberOfBits)
		{
			return (value << numberOfBits) | (value >> (32 - numberOfBits));
		}

		private static uint Round1Operation(uint a, uint b, uint c, uint d, uint xk, int s)
		{
			unchecked
			{
				return ROL(a + ((b & c) | (~b & d)) + xk, s);
			}
		}

		private static uint Round2Operation(uint a, uint b, uint c, uint d, uint xk, int s)
		{
			unchecked
			{
				return ROL(a + ((b & c) | (b & d) | (c & d)) + xk + 0x5a827999, s);
			}
		}

		private static uint Round3Operation(uint a, uint b, uint c, uint d, uint xk, int s)
		{
			unchecked
			{
				return ROL(a + (b ^ c ^ d) + xk + 0x6ed9eba1, s);
			}
		}

		private uint _a;
		private uint _b;
		private uint _c;
		private uint _d;
		private uint[] _x;
		private int _bytesProcessed;
	}
}

```

`AssetRipper.Fundamentals/Utils/ObjectUtils.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Threading;

namespace AssetRipper.Core.Utils
{
	public static class ObjectUtils
	{
		private const long TenToTheFifthteenth = 1_000_000_000_000_000L;
		/// <summary>
		/// 9223
		/// </summary>
		private const uint MaxPrefixedClassId = (uint)(long.MaxValue / TenToTheFifthteenth);

		public static long GenerateExportID(IUnityObjectBase asset, Func<long, bool> duplicateChecker)
		{
			if (asset == null)
			{
				throw new ArgumentNullException(nameof(asset));
			}

#warning TODO: depending on the export version exportID should has random or ordered value

			long exportID;
			uint classID = (uint)asset.ClassID;
			if (classID > MaxPrefixedClassId)
			{
				do
				{
					//Checked for StreamingController on 2018.2.5f1
					//Small class id's use the below format
					//Whereas this uses random id's
					exportID = GenerateInternalID();
				}
				while (duplicateChecker(exportID));
			}
			else
			{
				long prefix = classID * TenToTheFifthteenth;
				ulong persistentValue = 0;
				do
				{
					ulong value = unchecked((ulong)GenerateInternalID());
					persistentValue = unchecked(persistentValue + value);
					exportID = prefix + (long)(persistentValue % TenToTheFifthteenth);
				}
				while (duplicateChecker(exportID));
			}

			return exportID;
		}

		public static long GenerateInternalID()
		{
			s_random.NextBytes(s_idBuffer.Value!);
			return BitConverter.ToInt64(s_idBuffer.Value!, 0);
		}

		public static UnityGUID CalculateAssetsGUID(IEnumerable<IUnityObjectBase> assets)
		{
			List<uint> hashList = new List<uint>();
			foreach (IUnityObjectBase asset in assets)
			{
				hashList.Add(asset.GUID.Data0);
				hashList.Add(asset.GUID.Data1);
				hashList.Add(asset.GUID.Data2);
				hashList.Add(asset.GUID.Data3);
			}

			return CalculateGUID(hashList);
		}

		public static UnityGUID CalculateGUID(List<uint> hashList)
		{
			uint[] hashArray = hashList.ToArray();
			byte[] buffer = new byte[hashArray.Length * sizeof(uint)];
			Buffer.BlockCopy(hashArray, 0, buffer, 0, buffer.Length);
			using MD5 md5 = MD5.Create();
			byte[] hash = md5.ComputeHash(buffer);
			return new UnityGUID(hash);
		}

		public const char DirectorySeparatorChar = '/';
		public const string DirectorySeparator = "/";

		private static readonly ThreadSafeRandom s_random = new ThreadSafeRandom();
		private static readonly ThreadLocal<byte[]> s_idBuffer = new ThreadLocal<byte[]>(() => new byte[8]);
	}
}

```

`AssetRipper.Fundamentals/Utils/TempFolderManager.cs`:

```cs
using System.IO;

namespace AssetRipper.Core.Utils
{
	public static class TempFolderManager
	{
		private const int NumberOfRandomCharacters = 10;
		public static string TempFolderPath { get; }

		static TempFolderManager()
		{
			TempFolderPath = ExecutingDirectory.Combine("temp");
			DeleteTempFolder();
			Directory.CreateDirectory(TempFolderPath);
		}

		private static void DeleteTempFolder()
		{
			if (Directory.Exists(TempFolderPath))
			{
				Directory.Delete(TempFolderPath, true);
			}
		}

		private static string GetNewRandomTempFolder() => Path.Combine(TempFolderPath, GetRandomString());

		private static string GetRandomString() => GetRandomString(NumberOfRandomCharacters);

		/// <summary> Get the first characters of a new random guid </summary>
		/// <param name="numCharacters">The number of characters to return up to 32</param>
		/// <returns>A new string of pseudorandom hexadecimal characters</returns>
		private static string GetRandomString(int numCharacters)
		{
			string guid = Guid.NewGuid().ToString().Replace("-", "");
			if (numCharacters < 1 || numCharacters > 31)
			{
				return guid;
			}
			else
			{
				return guid.Substring(0, numCharacters);
			}
		}

		public static string CreateNewRandomTempFolder()
		{
			string path = GetNewRandomTempFolder();
			Directory.CreateDirectory(path);
			return path;
		}

		/// <summary>
		/// Make a temporary file
		/// </summary>
		/// <param name="data"></param>
		/// <param name="fileExtension">The file extension with the dot</param>
		/// <returns>The path to the file</returns>
		public static string WriteToTempFile(byte[] data, string fileExtension)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			string fileName = GetRandomString() + (fileExtension ?? "");
			string filePath = Path.Combine(TempFolderPath, fileName);
			File.WriteAllBytes(filePath, data);
			return filePath;
		}
	}
}

```

`AssetRipper.Fundamentals/Utils/ThreadSafeRandom.cs`:

```cs
namespace AssetRipper.Core.Utils
{
	public class ThreadSafeRandom
	{
		public int Next()
		{
			return GetLocal().Next();
		}

		public int Next(int maxValue)
		{
			return GetLocal().Next(maxValue);
		}

		public int Next(int minValue, int maxValue)
		{
			return GetLocal().Next(minValue, maxValue);
		}

		public void NextBytes(byte[] buffer)
		{
			GetLocal().NextBytes(buffer);
		}

		private static Random GetLocal()
		{
			if (s_local == null)
			{
				int seed;
				lock (s_global)
				{
					seed = s_global.Next();
				}
				s_local = new Random(seed);
			}
			return s_local;
		}

		private static readonly Random s_global = new Random();
		[ThreadStatic]
		private static Random? s_local;
	}
}

```

`AssetRipper.Fundamentals/VersionHandling/VersionManager.cs`:

```cs
using AssetRipper.Core.Parser.Asset;

namespace AssetRipper.Core.VersionHandling
{
	public static class VersionManager
	{
		private static AssetFactoryBase? _assetFactory;
		public static AssetFactoryBase AssetFactory
		{
			get
			{
				return _assetFactory ?? throw new Exception("AssetFactory not set");
			}
			set
			{
				_assetFactory = value;
			}
		}
	}
}

```

`AssetRipper.IO.Endian/AssetRipper.IO.Endian.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

</Project>

```

`AssetRipper.IO.Endian/EndianReader.cs`:

```cs
using System;
using System.Buffers.Binary;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;

namespace AssetRipper.IO.Endian
{
	public class EndianReader : BinaryReader
	{
		private bool isBigEndian = false;
		public EndianType EndianType
		{
			get => isBigEndian ? EndianType.BigEndian : EndianType.LittleEndian;
			set => isBigEndian = value == EndianType.BigEndian;
		}

		protected bool IsAlignArray { get; }

		protected const int BufferSize = 4096;

		private readonly byte[] m_buffer = new byte[BufferSize];

		public EndianReader(Stream stream, EndianType endianess) : this(stream, endianess, false) { }

		protected EndianReader(Stream stream, EndianType endianess, bool alignArray) : base(stream, Encoding.UTF8, true)
		{
			EndianType = endianess;
			IsAlignArray = alignArray;
		}

		~EndianReader()
		{
			Dispose(false);
		}

		public override char ReadChar()
		{
			return (char)ReadUInt16();
		}

		public override short ReadInt16()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadInt16BigEndian(base.ReadBytes(2));
			}
			else
			{
				return base.ReadInt16();
			}
		}

		public override ushort ReadUInt16()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadUInt16BigEndian(base.ReadBytes(2));
			}
			else
			{
				return base.ReadUInt16();
			}
		}

		public override int ReadInt32()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadInt32BigEndian(base.ReadBytes(4));
			}
			else
			{
				return base.ReadInt32();
			}
		}

		public override uint ReadUInt32()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadUInt32BigEndian(base.ReadBytes(4));
			}
			else
			{
				return base.ReadUInt32();
			}
		}

		public override long ReadInt64()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadInt64BigEndian(base.ReadBytes(8));
			}
			else
			{
				return base.ReadInt64();
			}
		}

		public override ulong ReadUInt64()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadUInt64BigEndian(base.ReadBytes(8));
			}
			else
			{
				return base.ReadUInt64();
			}
		}

		public override Half ReadHalf()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadHalfBigEndian(base.ReadBytes(2));
			}
			else
			{
				return base.ReadHalf();
			}
		}

		public override float ReadSingle()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadSingleBigEndian(base.ReadBytes(4));
			}
			else
			{
				return base.ReadSingle();
			}
		}

		public override double ReadDouble()
		{
			if (isBigEndian)
			{
				return BinaryPrimitives.ReadDoubleBigEndian(base.ReadBytes(8));
			}
			else
			{
				return base.ReadDouble();
			}
		}

		public override decimal ReadDecimal()
		{
			if (isBigEndian)
			{
				throw new NotSupportedException();
			}
			else
			{
				return base.ReadDecimal();
			}
		}

		public override string ReadString()
		{
			int length = ReadInt32();
			byte[] buffer = ReadStringBuffer(length);
			return Encoding.UTF8.GetString(buffer, 0, length);
		}

		public string ReadString(int length)
		{
			byte[] buffer = ReadStringBuffer(length);
			return Encoding.UTF8.GetString(buffer, 0, length);
		}

		/// <summary>
		/// Read C like UTF8 format zero terminated string
		/// </summary>
		/// <returns>Read string</returns>
		public string ReadStringZeroTerm()
		{
			if (ReadStringZeroTerm(m_buffer.Length, out string? result))
			{
				return result;
			}
			throw new Exception("Can't find end of string");
		}

		/// <summary>
		/// Read C like UTF8 format zero terminated string
		/// </summary>
		/// <param name="maxLength">Max allowed character count to read</param>
		/// <param name="result">Read string if found</param>
		/// <returns>Whether zero term has been found</returns>
		public bool ReadStringZeroTerm(int maxLength, [NotNullWhen(true)] out string? result)
		{
			maxLength = Math.Min(maxLength, m_buffer.Length);
			for (int i = 0; i < maxLength; i++)
			{
				byte bt = ReadByte();
				if (bt == 0)
				{
					result = Encoding.UTF8.GetString(m_buffer, 0, i);
					return true;
				}
				m_buffer[i] = bt;
			}

			result = null;
			return false;
		}

		public bool[] ReadBooleanArray() => ReadBooleanArray(true);
		public bool[] ReadBooleanArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			bool[] array = count == 0 ? Array.Empty<bool>() : new bool[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadBoolean();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public char[] ReadCharArray() => ReadCharArray(true);
		public char[] ReadCharArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			char[] array = count == 0 ? Array.Empty<char>() : new char[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadChar();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public byte[] ReadByteArray() => ReadByteArray(true);
		public byte[] ReadByteArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			byte[] array = count == 0 ? Array.Empty<byte>() : new byte[count];
			while (index < count)
			{
				int read = Read(array, index, count - index);
				if (read == 0)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements");
				}
				index += read;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public sbyte[] ReadSByteArray() => ReadSByteArray(true);
		public sbyte[] ReadSByteArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			sbyte[] array = count == 0 ? Array.Empty<sbyte>() : new sbyte[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadSByte();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public short[] ReadInt16Array() => ReadInt16Array(true);
		public short[] ReadInt16Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			short[] array = count == 0 ? Array.Empty<short>() : new short[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadInt16();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public ushort[] ReadUInt16Array() => ReadUInt16Array(true);
		public ushort[] ReadUInt16Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			ushort[] array = count == 0 ? Array.Empty<ushort>() : new ushort[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadUInt16();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public int[] ReadInt32Array() => ReadInt32Array(true);
		public int[] ReadInt32Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			int[] array = count == 0 ? Array.Empty<int>() : new int[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadInt32();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public uint[] ReadUInt32Array() => ReadUInt32Array(true);
		public uint[] ReadUInt32Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			uint[] array = count == 0 ? Array.Empty<uint>() : new uint[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadUInt32();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public long[] ReadInt64Array() => ReadInt64Array(true);
		public long[] ReadInt64Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			long[] array = count == 0 ? Array.Empty<long>() : new long[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadInt64();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public ulong[] ReadUInt64Array() => ReadUInt64Array(true);
		public ulong[] ReadUInt64Array(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			ulong[] array = count == 0 ? Array.Empty<ulong>() : new ulong[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadUInt64();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public float[] ReadSingleArray() => ReadSingleArray(true);
		public float[] ReadSingleArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			float[] array = count == 0 ? Array.Empty<float>() : new float[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadSingle();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public double[] ReadDoubleArray() => ReadDoubleArray(true);
		public double[] ReadDoubleArray(bool allowAlignment)
		{
			int count = ReadInt32();
			int index = 0;
			double[] array = count == 0 ? Array.Empty<double>() : new double[count];
			while (index < count)
			{
				try
				{
					array[index] = ReadDouble();
				}
				catch (Exception ex)
				{
					throw new Exception($"End of stream. Read {index}, expected {count} elements", ex);
				}
				index++;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public string[] ReadStringArray() => ReadStringArray(true);
		public string[] ReadStringArray(bool allowAlignment)
		{
			int count = ReadInt32();
			string[] array = count == 0 ? Array.Empty<string>() : new string[count];
			for (int i = 0; i < count; i++)
			{
				string value = ReadString();
				array[i] = value;
			}
			if (allowAlignment && IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public T ReadEndian<T>() where T : IEndianReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadEndianArray<T>() where T : IEndianReadable, new()
		{
			int count = ReadInt32();
			T[] array = count == 0 ? Array.Empty<T>() : new T[count];
			for (int i = 0; i < count; i++)
			{
				T t = new T();
				t.Read(this);
				array[i] = t;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public T[][] ReadEndianArrayArray<T>() where T : IEndianReadable, new()
		{
			int count = ReadInt32();
			T[][] array = count == 0 ? Array.Empty<T[]>() : new T[count][];
			for (int i = 0; i < count; i++)
			{
				T[] innerArray = ReadEndianArray<T>();
				array[i] = innerArray;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
			return array;
		}

		public void AlignStream()
		{
			BaseStream.Position = (BaseStream.Position + 3) & ~3;
		}

		protected byte[] ReadStringBuffer(int size)
		{
			if (m_buffer.Length >= size)
			{
				FillInnerBuffer(size);
				return m_buffer;
			}
			else
			{
				byte[] buffer = new byte[size];
				int offset = 0;
				int count = size;
				while (count > 0)
				{
					int read = Read(buffer, offset, count);
					if (read == 0)
					{
						throw new Exception($"End of stream. Read {offset}, expected {size} bytes");
					}
					offset += read;
					count -= read;
				}
				return buffer;
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected void FillInnerBuffer(int size)
		{
			int offset = 0;
			int count = size;
			while (count > 0)
			{
				int read = Read(m_buffer, offset, count);
				if (read == 0)
				{
					throw new Exception($"End of stream. Read {offset}, expected {size} bytes");
				}
				offset += read;
				count -= read;
			}
		}
	}
}

```

`AssetRipper.IO.Endian/EndianType.cs`:

```cs
namespace AssetRipper.IO.Endian
{
	public enum EndianType
	{
		/// <summary>
		/// Ordinal endian, less significant part first. 0x04030201 = [0x01, 0x02, 0x03, 0x4]
		/// </summary>
		LittleEndian,
		/// <summary>
		/// Inversed endian, most significant part first. 0x04030201 = [0x04, 0x03, 0x02, 0x01]
		/// </summary>
		BigEndian,
	}
}

```

`AssetRipper.IO.Endian/EndianWriter.cs`:

```cs
using System;
using System.IO;
using System.Runtime.CompilerServices;
using System.Text;

namespace AssetRipper.IO.Endian
{
	public class EndianWriter : BinaryWriter
	{
		public EndianWriter(Stream stream, EndianType endianess) : this(stream, endianess, false) { }

		protected EndianWriter(Stream stream, EndianType endianess, bool alignArray) : base(stream, Encoding.UTF8, true)
		{
			EndianType = endianess;
			IsAlignArray = alignArray;
		}

		~EndianWriter()
		{
			Dispose(false);
		}

		public override void Write(short value)
		{
			FillInnerBuffer(unchecked((ushort)value));
			Write(m_buffer, 0, sizeof(short));
		}

		public override void Write(ushort value)
		{
			FillInnerBuffer(value);
			Write(m_buffer, 0, sizeof(ushort));
		}

		public override void Write(int value)
		{
			FillInnerBuffer(unchecked((uint)value));
			Write(m_buffer, 0, sizeof(int));
		}

		public override void Write(uint value)
		{
			FillInnerBuffer(value);
			Write(m_buffer, 0, sizeof(uint));
		}

		public override void Write(long value)
		{
			FillInnerBuffer(unchecked((ulong)value));
			Write(m_buffer, 0, sizeof(long));
		}

		public override void Write(ulong value)
		{
			FillInnerBuffer(value);
			Write(m_buffer, 0, sizeof(ulong));
		}

		public override void Write(float value)
		{
			uint value32 = BitConverter.SingleToUInt32Bits(value);
			FillInnerBuffer(value32);
			Write(m_buffer, 0, sizeof(float));
		}

		public override void Write(double value)
		{
			ulong value64 = BitConverter.DoubleToUInt64Bits(value);
			FillInnerBuffer(value64);
			Write(m_buffer, 0, sizeof(double));
		}

		public override void Write(string value)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(value);
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));
			Write(buffer, 0, buffer.Length);
		}

		public void WriteStringZeroTerm(string value)
		{
			byte[] buffer = Encoding.UTF8.GetBytes(value);
			m_buffer[0] = 0;
			Write(buffer, 0, buffer.Length);
			Write(m_buffer, 0, sizeof(byte));
		}

		public void WriteArray(bool[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(bool[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int last = index + count;
			while (index < last)
			{
				int left = last - index;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i++, index++)
				{
					m_buffer[i] = buffer[index] ? (byte)1 : (byte)0;
				}
				Write(m_buffer, 0, toWrite);
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(char[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(char[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			Write(buffer, index, count);
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(byte[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(byte[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));
			Write(buffer, index, count);
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(short[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(short[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(short);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(short), index++)
				{
					FillInnerBuffer(unchecked((ushort)buffer[index]), i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(ushort[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(ushort[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(ushort);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(ushort), index++)
				{
					FillInnerBuffer(buffer[index], i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(int[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(int[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(int);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(int), index++)
				{
					FillInnerBuffer(buffer[index], i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(uint[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(uint[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(uint);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(uint), index++)
				{
					FillInnerBuffer(buffer[index], i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(long[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(long[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(long);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(long), index++)
				{
					FillInnerBuffer(unchecked((ulong)buffer[index]), i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(ulong[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(ulong[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(ulong);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(ulong), index++)
				{
					FillInnerBuffer(buffer[index], i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(float[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(float[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(float);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(float), index++)
				{
					FillInnerBuffer(BitConverter.SingleToUInt32Bits(buffer[index]), i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(double[] buffer)
		{
			WriteArray(buffer, 0, buffer.Length);
		}

		public void WriteArray(double[] buffer, int index, int count)
		{
			FillInnerBuffer(count);
			Write(m_buffer, 0, sizeof(int));

			int byteIndex = 0;
			int byteCount = count * sizeof(double);
			int last = index + count;
			while (index < last)
			{
				int left = byteCount - byteIndex;
				int toWrite = left < BufferSize ? left : BufferSize;
				for (int i = 0; i < toWrite; i += sizeof(double), index++)
				{
					FillInnerBuffer(BitConverter.DoubleToUInt64Bits(buffer[index]), i);
				}
				Write(m_buffer, 0, toWrite);
				byteIndex += toWrite;
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteArray(string[] buffer)
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				string str = buffer[i];
				Write(str);
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteEndian<T>(T value) where T : IEndianWritable
		{
			value.Write(this);
		}

		public void WriteEndianArray<T>(T[] buffer) where T : IEndianWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				T t = buffer[i];
				t.Write(this);
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void WriteEndianArray<T>(T[][] buffer) where T : IEndianWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.GetLength(0); i++)
			{
				WriteEndianArray(buffer[i]);
			}
			if (IsAlignArray)
			{
				AlignStream();
			}
		}

		public void AlignStream()
		{
			BaseStream.Position = (BaseStream.Position + 3) & ~3;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected void FillInnerBuffer(ushort value, int offset = 0)
		{
			if (EndianType == EndianType.LittleEndian)
			{
				m_buffer[offset + 0] = unchecked((byte)(value >> 0));
				m_buffer[offset + 1] = unchecked((byte)(value >> 8));
			}
			else
			{
				m_buffer[offset + 1] = unchecked((byte)(value >> 0));
				m_buffer[offset + 0] = unchecked((byte)(value >> 8));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected void FillInnerBuffer(int value, int offset = 0)
		{
			if (EndianType == EndianType.LittleEndian)
			{
				m_buffer[offset + 0] = unchecked((byte)(value >> 0));
				m_buffer[offset + 1] = unchecked((byte)(value >> 8));
				m_buffer[offset + 2] = unchecked((byte)(value >> 16));
				m_buffer[offset + 3] = unchecked((byte)(value >> 24));
			}
			else
			{
				m_buffer[offset + 3] = unchecked((byte)(value >> 0));
				m_buffer[offset + 2] = unchecked((byte)(value >> 8));
				m_buffer[offset + 1] = unchecked((byte)(value >> 16));
				m_buffer[offset + 0] = unchecked((byte)(value >> 24));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected void FillInnerBuffer(uint value, int offset = 0)
		{
			if (EndianType == EndianType.LittleEndian)
			{
				m_buffer[offset + 0] = unchecked((byte)(value >> 0));
				m_buffer[offset + 1] = unchecked((byte)(value >> 8));
				m_buffer[offset + 2] = unchecked((byte)(value >> 16));
				m_buffer[offset + 3] = unchecked((byte)(value >> 24));
			}
			else
			{
				m_buffer[offset + 3] = unchecked((byte)(value >> 0));
				m_buffer[offset + 2] = unchecked((byte)(value >> 8));
				m_buffer[offset + 1] = unchecked((byte)(value >> 16));
				m_buffer[offset + 0] = unchecked((byte)(value >> 24));
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		protected void FillInnerBuffer(ulong value, int offset = 0)
		{
			if (EndianType == EndianType.LittleEndian)
			{
				m_buffer[offset + 0] = unchecked((byte)(value >> 0));
				m_buffer[offset + 1] = unchecked((byte)(value >> 8));
				m_buffer[offset + 2] = unchecked((byte)(value >> 16));
				m_buffer[offset + 3] = unchecked((byte)(value >> 24));
				m_buffer[offset + 4] = unchecked((byte)(value >> 32));
				m_buffer[offset + 5] = unchecked((byte)(value >> 40));
				m_buffer[offset + 6] = unchecked((byte)(value >> 48));
				m_buffer[offset + 7] = unchecked((byte)(value >> 56));
			}
			else
			{
				m_buffer[offset + 7] = unchecked((byte)(value >> 0));
				m_buffer[offset + 6] = unchecked((byte)(value >> 8));
				m_buffer[offset + 5] = unchecked((byte)(value >> 16));
				m_buffer[offset + 4] = unchecked((byte)(value >> 24));
				m_buffer[offset + 3] = unchecked((byte)(value >> 32));
				m_buffer[offset + 2] = unchecked((byte)(value >> 40));
				m_buffer[offset + 1] = unchecked((byte)(value >> 48));
				m_buffer[offset + 0] = unchecked((byte)(value >> 56));
			}
		}

		public EndianType EndianType { get; }

		protected bool IsAlignArray { get; }

		protected const int BufferSize = 4096;

		protected readonly byte[] m_buffer = new byte[BufferSize];
	}
}

```

`AssetRipper.IO.Endian/IEndianReadable.cs`:

```cs
namespace AssetRipper.IO.Endian
{
	public interface IEndianReadable
	{
		void Read(EndianReader reader);
	}
}

```

`AssetRipper.IO.Endian/IEndianWritable.cs`:

```cs
namespace AssetRipper.IO.Endian
{
	public interface IEndianWritable
	{
		void Write(EndianWriter writer);
	}
}

```

`AssetRipper.IO.Files/ArchiveFiles/ArchiveFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Streams.MultiFile;
using System.IO;

namespace AssetRipper.IO.Files.ArchiveFiles
{
	public sealed class ArchiveFile : FileList
	{
		internal ArchiveFile(ArchiveFileScheme scheme) : base(scheme.NameOrigin)
		{
			Header = scheme.Header;
		}

		public static bool IsArchiveFile(string filePath)
		{
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return IsArchiveFile(stream);
		}

		public static bool IsArchiveFile(byte[] buffer, int offset, int size)
		{
			using MemoryStream stream = new MemoryStream(buffer, offset, size, false);
			return IsArchiveFile(stream);
		}

		public static bool IsArchiveFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return ArchiveHeader.IsArchiveHeader(reader);
		}

		public static ArchiveFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static ArchiveFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return ArchiveFileScheme.ReadScheme(buffer, filePath, fileName);
		}

		public static ArchiveFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			return ArchiveFileScheme.ReadScheme(stream, filePath, fileName);
		}

		public ArchiveHeader Header { get; }
	}
}

```

`AssetRipper.IO.Files/ArchiveFiles/ArchiveFileEntry.cs`:

```cs
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Utils;

namespace AssetRipper.IO.Files.ArchiveFiles
{
	public sealed class ArchiveFileEntry : FileEntry
	{
		public ArchiveFileEntry(long offset, long size, string name)
		{
			Offset = offset;
			Size = size;
			NameOrigin = name;
			Name = FilenameUtils.FixFileIdentifier(name);
		}
	}
}

```

`AssetRipper.IO.Files/ArchiveFiles/ArchiveFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Schemes;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.WebFiles;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;

namespace AssetRipper.IO.Files.ArchiveFiles
{
	public sealed class ArchiveFileScheme : FileScheme
	{
		private ArchiveFileScheme(string filePath, string fileName) : base(filePath, fileName) { }

		internal static ArchiveFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			ArchiveFileScheme scheme = new ArchiveFileScheme(filePath, fileName);
			using (MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false))
			{
				scheme.ReadScheme(stream);
			}
			return scheme;
		}

		internal static ArchiveFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			ArchiveFileScheme scheme = new ArchiveFileScheme(filePath, fileName);
			scheme.ReadScheme(stream);
			return scheme;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
		}

		private void ReadScheme(Stream stream)
		{
			byte[] buffer;
			using (EndianReader reader = new EndianReader(stream, EndianType.BigEndian))
			{
				Header.Read(reader);
				buffer = Header.Type switch
				{
					ArchiveType.GZip => ReadGZip(reader),
					ArchiveType.Brotli => ReadBrotli(reader),
					_ => throw new NotSupportedException(Header.Type.ToString()),
				};
			}

			WebScheme = WebFile.ReadScheme(buffer, FilePath);
		}

		private static byte[] ReadGZip(EndianReader reader)
		{
			using MemoryStream stream = new MemoryStream();
			using GZipStream gzipStream = new GZipStream(reader.BaseStream, CompressionMode.Decompress);
			gzipStream.CopyTo(stream);
			return stream.ToArray();
		}

		private static byte[] ReadBrotli(EndianReader reader)
		{
			using MemoryStream stream = new MemoryStream();
			using BrotliStream brotliStream = new BrotliStream(reader.BaseStream, CompressionMode.Decompress);
			brotliStream.CopyTo(stream);
			return stream.ToArray();
		}

		public override FileEntryType SchemeType => FileEntryType.Archive;
		public override IEnumerable<FileIdentifier> Dependencies => WebScheme.Dependencies;

		public ArchiveHeader Header { get; } = new ArchiveHeader();
		public WebFileScheme WebScheme { get; private set; }
	}
}

```

`AssetRipper.IO.Files/ArchiveFiles/ArchiveHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.ArchiveFiles
{
	public sealed class ArchiveHeader
	{
		internal static bool IsArchiveHeader(EndianReader reader)
		{
			long position = reader.BaseStream.Position;

			ushort gzipMagic = ReadGZipMagic(reader);
			reader.BaseStream.Position = position;
			if (gzipMagic == GZipMagic)
			{
				return true;
			}

			string? brotliSignature = ReadBrotliMetadata(reader);
			reader.BaseStream.Position = position;
			if (brotliSignature == BrotliSignature)
			{
				return true;
			}

			return brotliSignature == BrotliSignature;
		}

		private static ushort ReadGZipMagic(EndianReader reader)
		{
			if (reader.BaseStream.Length >= sizeof(ushort))
			{
				return reader.ReadUInt16();
			}
			return 0;
		}

		private static string? ReadBrotliMetadata(EndianReader reader)
		{
			if (reader.BaseStream.Length < 4)
			{
				return null;
			}

			reader.BaseStream.Position += 1;
			byte bt = reader.ReadByte(); // read 3 bits
			int sizeBytes = bt & 0x3;

			if (reader.BaseStream.Position + sizeBytes > reader.BaseStream.Length)
			{
				return null;
			}

			int length = 0;
			for (int i = 0; i < sizeBytes; i++)
			{
				byte nbt = reader.ReadByte();  // read next 8 bits
				int bits = (bt >> 2) | ((nbt & 0x3) << 6);
				bt = nbt;
				length += bits << (8 * i);
			}

			if (length <= 0)
			{
				return null;
			}
			if (reader.BaseStream.Position + length > reader.BaseStream.Length)
			{
				return null;
			}

			return reader.ReadString(length + 1);
		}

		public void Read(EndianReader reader)
		{
			ushort gzipMagic = reader.ReadUInt16();
			reader.BaseStream.Position -= sizeof(ushort);
			if (gzipMagic == GZipMagic)
			{
				Type = ArchiveType.GZip;
				return;
			}

			long position = reader.BaseStream.Position;
			string? signature = ReadBrotliMetadata(reader);
			reader.BaseStream.Position = position;
			if (signature == BrotliSignature)
			{
				Type = ArchiveType.Brotli;
				return;
			}

			throw new Exception("Unsupported archive type");
		}

		public ArchiveType Type { get; private set; }

		private const ushort GZipMagic = 0x1F8B;
		private const string BrotliSignature = "UnityWeb Compressed Content (brotli)";
	}
}

```

`AssetRipper.IO.Files/ArchiveFiles/ArchiveType.cs`:

```cs
namespace AssetRipper.IO.Files.ArchiveFiles
{
	public enum ArchiveType
	{
		GZip,
		Brotli,
	}
}

```

`AssetRipper.IO.Files/AssetRipper.IO.Files.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<ItemGroup>
	  <PackageReference Include="AssetRipper.VersionUtilities" Version="1.2.1" />
	  <PackageReference Include="K4os.Compression.LZ4" Version="1.2.16" />
	  <PackageReference Include="SharpCompress" Version="0.32.1" />
	</ItemGroup>

	<ItemGroup>
	  <ProjectReference Include="..\AssetRipper.IO.Endian\AssetRipper.IO.Endian.csproj" />
	</ItemGroup>

</Project>

```

`AssetRipper.IO.Files/AssetType.cs`:

```cs
namespace AssetRipper.IO.Files
{
	public enum AssetType
	{
		/// <summary>
		/// Used by released game
		/// </summary>
		Internal = 0,
		/// <summary>
		/// Library asset file. It is editor created file, it doesn't exist in Assets directory
		/// It has the format "library/cache/[first Hash byte as hex]/[Hash as hex]"
		/// </summary>
		Cached = 1,
		/// <summary>
		/// Serialized asset file. It contains all parameters inside itself
		/// </summary>
		Serialized = 2,
		/// <summary>
		/// Binary asset file. It contains all parameters inside meta file
		/// </summary>
		Meta = 3,
	}
}

```

`AssetRipper.IO.Files/BuildTarget.cs`:

```cs
namespace AssetRipper.IO.Files
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/BuildTarget.cs"/>
	/// </summary>
	public enum BuildTarget : uint
	{
		ValidPlayer = 1,
		/// <summary>
		/// Build a universal macOS standalone
		/// </summary>
		StandaloneOSXUniversal = 2,
		/// <summary>
		/// Build a macOS standalone (PowerPC only)
		/// </summary>
		StandaloneOSXPPC = 3,
		/// <summary>
		/// Build a macOS standalone (Intel only)
		/// </summary>
		StandaloneOSXIntel = 4,
		/// <summary>
		/// Build a Windows standalone
		/// </summary>
		StandaloneWinPlayer = 5,
		/// <summary>
		/// Build a web player.
		/// </summary>
		WebPlayerLZMA = 6,
		/// <summary>
		/// Build a streamed web player
		/// </summary>
		WebPlayerLZMAStreamed = 7,
		Wii = 8,
		/// <summary>
		/// Build an iOS player
		/// </summary>
		iOS = 9,
		PS3 = 10,
		XBox360 = 11,
		Broadcom = 12,
		/// <summary>
		/// Build an Android .apk standalone app
		/// </summary>
		Android = 13,
		WinGLESEmu = 14,
		WinGLES20Emu = 15,
		/// <summary>
		/// Google Native Client
		/// </summary>
		GoogleNaCl = 16,
		/// <summary>
		/// Build a Linux standalone
		/// </summary>
		StandaloneLinux = 17,
		Flash = 18,
		/// <summary>
		/// Build a Windows 64-bit standalone
		/// </summary>
		StandaloneWin64Player = 19,
		/// <summary>
		/// WebGL
		/// </summary>
		WebGL = 20,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerX86 = 21,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerX64 = 22,
		/// <summary>
		/// Build an Windows Store Apps player
		/// </summary>
		MetroPlayerARM = 23,
		/// <summary>
		/// Build a Linux 64-bit standalone
		/// </summary>
		StandaloneLinux64 = 24,
		/// <summary>
		/// Build a Linux universal standalone
		/// </summary>
		StandaloneLinuxUniversal = 25,
		WP8Player = 26,
		/// <summary>
		/// Build a macOS Intel 64-bit standalone
		/// </summary>
		StandaloneOSXIntel64 = 27,
		/// <summary>
		/// BlackBerry
		/// </summary>
		BB10 = 28,
		/// <summary>
		/// Build a Tizen player
		/// </summary>
		Tizen = 29,
		/// <summary>
		/// Build a PS Vita Standalone
		/// </summary>
		PSP2 = 30,
		/// <summary>
		/// Build a PS4 Standalone
		/// </summary>
		PS4 = 31,
		PSM = 32,
		/// <summary>
		/// Build a Xbox One Standalone
		/// </summary>
		XboxOne = 33,
		/// <summary>
		/// Build to Samsung Smart TV platform
		/// </summary>
		SamsungTV = 34,
		/// <summary>
		/// Build to Nintendo 3DS platform
		/// </summary>
		N3DS = 35,
		/// <summary>
		/// Build a Wii U standalone
		/// </summary>
		WiiU = 36,
		/// <summary>
		/// Build to Apple's tvOS platform
		/// </summary>
		tvOS = 37,
		/// <summary>
		/// Build a Nintendo Switch player
		/// </summary>
		Switch = 38,
		Lumin = 39,
		Stadia = 40,
		CloudRendering = 41,
		GameCoreXboxSeries = 42,
		GameCoreXboxOne = 43,
		/// <summary>
		/// Build a PS5 Standalone
		/// </summary>
		PS5 = 44,
		EmbeddedLinux = 45,
		QNX = 46,

		/// <summary>
		/// Editor
		/// </summary>
		NoTarget = 0xFFFFFFFE,
		AnyPlayer = 0xFFFFFFFF,
	}

	public static class PlatformExtensions
	{
		public static bool IsCompatible(this BuildTarget _this, BuildTarget comp)
		{
			if (_this == comp)
			{
				return true;
			}

			if (_this.IsStandalone())
			{
				if (comp.IsStandalone())
				{
					return true;
				}
			}

			return false;
		}

		public static bool IsStandalone(this BuildTarget _this)
		{
			switch (_this)
			{
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.StandaloneOSXPPC:
				case BuildTarget.StandaloneOSXUniversal:
					return true;
			}
			return false;
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/BundleFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Header;
using AssetRipper.IO.Files.BundleFiles.Parser;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Streams.MultiFile;
using System.IO;

namespace AssetRipper.IO.Files.BundleFiles
{
	public sealed class BundleFile : FileList
	{
		public BundleHeader Header { get; }
		public BundleMetadata Metadata { get; }

		internal BundleFile(BundleFileScheme scheme) : base(scheme.NameOrigin)
		{
			if (scheme == null)
			{
				throw new ArgumentNullException(nameof(scheme));
			}

			Header = scheme.Header;
			Metadata = scheme.Metadata;
		}

		public static bool IsBundleFile(string filePath) => IsBundleFile(MultiFileStream.OpenRead(filePath));
		public static bool IsBundleFile(byte[] buffer, int offset, int size) => IsBundleFile(new MemoryStream(buffer, offset, size, false));
		public static bool IsBundleFile(Stream stream) => BundleHeader.IsBundleHeader(new EndianReader(stream, EndianType.BigEndian));

		public static BundleFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using Stream stream = MultiFileStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static BundleFileScheme ReadScheme(byte[] buffer, string filePath, string fileName) => BundleFileScheme.ReadScheme(buffer, filePath, fileName);
		public static BundleFileScheme ReadScheme(Stream stream, string filePath, string fileName) => BundleFileScheme.ReadScheme(stream, filePath, fileName);

	}
}

```

`AssetRipper.IO.Files/BundleFiles/BundleFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Header;
using AssetRipper.IO.Files.BundleFiles.IO;
using AssetRipper.IO.Files.BundleFiles.Parser;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Extensions;
using AssetRipper.IO.Files.Schemes;
using AssetRipper.IO.Files.Streams.Smart;
using K4os.Compression.LZ4;
using System.IO;

namespace AssetRipper.IO.Files.BundleFiles
{
	public sealed class BundleFileScheme : FileSchemeList
	{
		public BundleHeader Header { get; } = new BundleHeader();
		public BundleMetadata Metadata { get; } = new BundleMetadata();
		public override FileEntryType SchemeType => FileEntryType.Bundle;

		private BundleFileScheme(string filePath, string fileName) : base(filePath, fileName) { }
		internal static BundleFileScheme ReadScheme(byte[] buffer, string filePath, string fileName) => ReadScheme(new MemoryStream(buffer, 0, buffer.Length, false), filePath, fileName);
		internal static BundleFileScheme ReadScheme(Stream stream, string filePath, string fileName)
		{
			BundleFileScheme scheme = new BundleFileScheme(filePath, fileName);
			scheme.ReadScheme(stream);
			return scheme;
		}

		private void ReadScheme(Stream stream)
		{
			long basePosition = stream.Position;
			ReadHeader(stream);

			switch (Header.Signature)
			{
				case BundleType.UnityRaw:
				case BundleType.UnityWeb:
					ReadRawWebMetadata(stream, out Stream dataStream, out long metadataOffset);//ReadBlocksAndDirectory
					ReadRawWebData(dataStream, metadataOffset);//also ReadBlocksAndDirectory
					break;

				case BundleType.UnityFS:
					long headerSize = stream.Position - basePosition;
					ReadFileStreamMetadata(stream, basePosition);//ReadBlocksInfoAndDirectory
					ReadFileStreamData(stream, basePosition, headerSize);//ReadBlocks and ReadFiles
					break;

				default:
					throw new Exception($"Unknown bundle signature '{Header.Signature}'");
			}
		}

		private void ReadHeader(Stream stream)
		{
			long headerPosition = stream.Position;
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			Header.Read(reader);
			if (Header.Signature.IsRawWeb())
			{
				if (stream.Position - headerPosition != Header.RawWeb!.HeaderSize)
				{
					throw new Exception($"Read {stream.Position - headerPosition} but expected {Header.RawWeb.HeaderSize} bytes while reading the raw/web bundle header.");
				}
			}
		}

		private void ReadRawWebMetadata(Stream stream, out Stream dataStream, out long metadataOffset)
		{
			BundleRawWebHeader header = Header.RawWeb!;
			int metadataSize = BundleRawWebHeader.HasUncompressedBlocksInfoSize(Header.Version) ? header.UncompressedBlocksInfoSize : 0;
			switch (Header.Signature)
			{
				case BundleType.UnityRaw:
					{
						dataStream = stream;
						metadataOffset = stream.Position;

						ReadMetadata(dataStream, metadataSize);
					}
					break;

				case BundleType.UnityWeb:
					{
						// read only last chunk
						BundleScene chunkInfo = header.Scenes[header.Scenes.Length - 1];
						dataStream = new MemoryStream(new byte[chunkInfo.DecompressedSize]);
						SevenZipHelper.DecompressLZMASizeStream(stream, chunkInfo.CompressedSize, dataStream);
						metadataOffset = 0;

						dataStream.Position = 0;
						ReadMetadata(dataStream, metadataSize);
					}
					break;

				default:
					throw new Exception($"Unsupported bundle signature '{Header.Signature}'");
			}
		}

		private void ReadFileStreamMetadata(Stream stream, long basePosition)
		{
			BundleFileStreamHeader header = Header.FileStream!;
			if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
			{
				stream.Align(16);
			}
			if (header.Flags.GetBlocksInfoAtTheEnd())
			{
				stream.Position = basePosition + (header.Size - header.CompressedBlocksInfoSize);
			}

			CompressionType metaCompression = header.Flags.GetCompression();
			switch (metaCompression)
			{
				case CompressionType.None:
					{
						ReadMetadata(stream, header.UncompressedBlocksInfoSize);
					}
					break;

				case CompressionType.Lzma:
					{
						using MemoryStream uncompressedStream = new MemoryStream(new byte[header.UncompressedBlocksInfoSize]);
						SevenZipHelper.DecompressLZMAStream(stream, header.CompressedBlocksInfoSize, uncompressedStream, header.UncompressedBlocksInfoSize);

						uncompressedStream.Position = 0;
						ReadMetadata(uncompressedStream, header.UncompressedBlocksInfoSize);
					}
					break;

				case CompressionType.Lz4:
				case CompressionType.Lz4HC:
					{
						int uncompressedSize = header.UncompressedBlocksInfoSize;
						byte[] uncompressedBytes = new byte[uncompressedSize];
						byte[] compressedBytes = new BinaryReader(stream).ReadBytes(header.CompressedBlocksInfoSize);
						int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
						if (bytesWritten != uncompressedSize)
						{
							throw new Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize} for {compressedBytes.Length} compressed bytes");
						}
						ReadMetadata(new MemoryStream(uncompressedBytes), uncompressedSize);
					}
					break;

				default:
					throw new NotSupportedException($"Bundle compression '{metaCompression}' isn't supported");
			}
		}

		private void ReadMetadata(Stream stream, int metadataSize)
		{
			long metadataPosition = stream.Position;
			using (BundleReader reader = new BundleReader(stream, EndianType.BigEndian, Header.Signature, Header.Version, Header.Flags))
			{
				Metadata.Read(reader);
			}
			if (metadataSize > 0)
			{
				if (stream.Position - metadataPosition != metadataSize)
				{
					throw new Exception($"Read {stream.Position - metadataPosition} but expected {metadataSize} while reading bundle metadata");
				}
			}
		}

		private void ReadRawWebData(Stream stream, long metadataOffset)
		{
			foreach (Node entry in Metadata.DirectoryInfo.Nodes)
			{
				byte[] buffer = new byte[entry.Size];
				stream.Position = metadataOffset + entry.Offset;
				stream.ReadBuffer(buffer, 0, buffer.Length);
				FileScheme scheme = SchemeReader.ReadScheme(buffer, FilePath, entry.PathOrigin);
				AddScheme(scheme);
			}
		}

		private void ReadFileStreamData(Stream stream, long basePosition, long headerSize)
		{
			if (Header.Flags.GetBlocksInfoAtTheEnd())
			{
				stream.Position = basePosition + headerSize;
				if (Header.Version >= BundleVersion.BF_LargeFilesSupport)
				{
					stream.Align(16);
				}
			}
			if (Header.Flags.GetAlignAfterBlocksInfo())
			{
				stream.Align(16);
			}

			using BundleFileBlockReader blockReader = new BundleFileBlockReader(stream, Metadata.BlocksInfo);
			foreach (Node entry in Metadata.DirectoryInfo.Nodes)
			{
				SmartStream entryStream = blockReader.ReadEntry(entry);
				FileScheme scheme = SchemeReader.ReadScheme(entryStream, FilePath, entry.PathOrigin);
				AddScheme(scheme);
			}
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/BundleType.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles
{
	public enum BundleType
	{
		UnityArchive,//not supported
		UnityRaw,
		UnityWeb,
		UnityFS,
	}

	public static class BundleTypeExtensions
	{
		/// <summary>
		/// True if UnityRaw or UnityWeb
		/// </summary>
		public static bool IsRawWeb(this BundleType _this)
		{
			return _this == BundleType.UnityRaw || _this == BundleType.UnityWeb;
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/BundleVersion.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles
{
	public enum BundleVersion
	{
		Unknown = 0,

		BF_100_250 = 1,
		BF_260_340 = 2,
		BF_350_4x = 3,
		BF_520a1 = 4,
		BF_520aunk = 5,
		BF_520_x = 6,
		BF_LargeFilesSupport = 7,//not real name
	}
}

```

`AssetRipper.IO.Files/BundleFiles/CompressionType.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles
{
	public enum CompressionType
	{
		None = 0,
		Lzma = 1,
		Lz4 = 2,
		Lz4HC = 3,
		Lzham = 4,
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Header/BundleFileStreamHeader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Parser;

namespace AssetRipper.IO.Files.BundleFiles.Header
{
	public sealed class BundleFileStreamHeader
	{
		public BundleFileStreamHeader(EndianReader reader)
		{
			Size = reader.ReadInt64();
			CompressedBlocksInfoSize = reader.ReadInt32();
			UncompressedBlocksInfoSize = reader.ReadInt32();
			Flags = (BundleFlags)reader.ReadInt32();
		}

		/// <summary>
		/// Equal to file size, sometimes equal to uncompressed data size without the header
		/// </summary>
		public long Size { get; set; }
		/// <summary>
		/// UnityFS length of the possibly-compressed (LZMA, LZ4) bundle data header
		/// </summary>
		public int CompressedBlocksInfoSize { get; set; }
		public int UncompressedBlocksInfoSize { get; set; }
		public BundleFlags Flags { get; set; }
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Header/BundleHeader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Parser;

namespace AssetRipper.IO.Files.BundleFiles.Header
{
	public sealed class BundleHeader
	{
		public BundleType Signature { get; set; }
		public BundleVersion Version { get; set; }
		/// <summary>
		/// Generation version
		/// </summary>
		public string? UnityWebBundleVersion { get; set; }
		/// <summary>
		/// Actual engine version
		/// </summary>
		public UnityVersion UnityWebMinimumRevision { get; set; }
		public BundleFlags Flags
		{
			get
			{
				if (Signature == BundleType.UnityFS)
				{
					return FileStream!.Flags;
				}
				return 0;
			}
		}

		public BundleRawWebHeader? RawWeb { get; set; }
		public BundleFileStreamHeader? FileStream { get; set; }

		public void Read(EndianReader reader)
		{
			string signature = reader.ReadStringZeroTerm();
			Signature = ParseSignature(signature);
			Version = (BundleVersion)reader.ReadInt32();
			UnityWebBundleVersion = reader.ReadStringZeroTerm();
			string engineVersion = reader.ReadStringZeroTerm();
			UnityWebMinimumRevision = UnityVersion.Parse(engineVersion);

			switch (Signature)
			{
				case BundleType.UnityRaw:
				case BundleType.UnityWeb:
					RawWeb = new BundleRawWebHeader(reader, Version);//ReadHeaderAndBlocksInfo
					break;
				case BundleType.UnityFS:
					FileStream = new BundleFileStreamHeader(reader);//ReadHeader
					break;
				case BundleType.UnityArchive:
					throw new NotSupportedException("UnityArchives are not currently supported");
				default:
					throw new Exception($"Unknown bundle signature '{Signature}'");
			}
		}

		public static BundleType ParseSignature(string signature)
		{
			return TryParseSignature(signature, out BundleType bundleType)
				? bundleType
				: throw new ArgumentException($"Unsupported signature '{signature}'");
		}

		public static bool TryParseSignature(string signatureString, out BundleType type)
		{
			switch (signatureString)
			{
				case nameof(BundleType.UnityWeb):
					type = BundleType.UnityWeb;
					return true;
				case nameof(BundleType.UnityRaw):
					type = BundleType.UnityRaw;
					return true;
				case nameof(BundleType.UnityFS):
					type = BundleType.UnityFS;
					return true;
				case nameof(BundleType.UnityArchive):
					type = BundleType.UnityArchive;
					return true;
				default:
					type = default;
					return false;
			}
		}

		internal static bool IsBundleHeader(EndianReader reader)
		{
			const int MaxLength = 0x20;
			if (reader.BaseStream.Length >= MaxLength)
			{
				long position = reader.BaseStream.Position;
				bool isRead = reader.ReadStringZeroTerm(MaxLength, out string? signature);
				reader.BaseStream.Position = position;
				if (isRead)
				{
					return TryParseSignature(signature!, out BundleType _);
				}
			}
			return false;
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Header/BundleRawWebHeader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Parser;

namespace AssetRipper.IO.Files.BundleFiles.Header
{
	public sealed class BundleRawWebHeader
	{
		/// <summary>
		/// 5.2.0 and greater / Bundle Version 4 +
		/// </summary>
		public static bool HasHash(BundleVersion generation) => generation >= BundleVersion.BF_520a1;
		/// <summary>
		/// 2.6.0 and greater / Bundle Version 2 +
		/// </summary>
		public static bool HasCompleteFileSize(BundleVersion generation) => generation >= BundleVersion.BF_260_340;
		/// <summary>
		/// 3.5.0 and greater / Bundle Version 3 +
		/// </summary>
		public static bool HasUncompressedBlocksInfoSize(BundleVersion generation) => generation >= BundleVersion.BF_350_4x;

		public BundleRawWebHeader(EndianReader reader, BundleVersion generation)
		{
			if (HasHash(generation))
			{
				Hash = reader.ReadBytes(16);
				Crc = reader.ReadUInt32();
			}
			MinimumStreamedBytes = reader.ReadUInt32();
			HeaderSize = reader.ReadInt32();
			NumberOfScenesToDownloadBeforeStreaming = reader.ReadInt32();
			Scenes = reader.ReadEndianArray<BundleScene>();
			if (HasCompleteFileSize(generation))
			{
				CompleteFileSize = reader.ReadUInt32();
			}
			if (HasUncompressedBlocksInfoSize(generation))
			{
				UncompressedBlocksInfoSize = (int)reader.ReadUInt32();
			}
			reader.AlignStream();
		}

		public uint Crc { get; set; }
		/// <summary>
		/// Minimum number of bytes to read for streamed bundles, equal to BundleSize for normal bundles
		/// </summary>
		public uint MinimumStreamedBytes { get; set; }
		public int HeaderSize { get; set; }
		/// <summary>
		/// Equal to 1 if it's a streamed bundle, number of LZMAChunkInfos + mainData assets otherwise
		/// </summary>
		public int NumberOfScenesToDownloadBeforeStreaming { get; set; }
		/// <summary>
		/// LZMA chunks info
		/// </summary>
		public BundleScene[] Scenes { get; set; }
		public uint CompleteFileSize { get; set; }
		public int UncompressedBlocksInfoSize { get; set; }
		/// <summary>
		/// Hash128
		/// </summary>
		public byte[] Hash { get; set; } = Array.Empty<byte>();
	}
}

```

`AssetRipper.IO.Files/BundleFiles/IO/BundleFileBlockReader.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.Parser;
using AssetRipper.IO.Files.Extensions;
using AssetRipper.IO.Files.Streams.Smart;
using K4os.Compression.LZ4;
using System.IO;

namespace AssetRipper.IO.Files.BundleFiles.IO
{
	internal sealed class BundleFileBlockReader : IDisposable
	{
		public BundleFileBlockReader(Stream stream, BlocksInfo blocksInfo)
		{
			m_stream = stream;
			m_blocksInfo = blocksInfo;
			m_dataOffset = stream.Position;
		}

		~BundleFileBlockReader()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public SmartStream ReadEntry(Node entry)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(nameof(BundleFileBlockReader));
			}

			// find block offsets
			int blockIndex;
			long blockCompressedOffset = 0;
			long blockDecompressedOffset = 0;
			for (blockIndex = 0; blockDecompressedOffset + m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize <= entry.Offset; blockIndex++)
			{
				blockCompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].CompressedSize;
				blockDecompressedOffset += m_blocksInfo.StorageBlocks[blockIndex].UncompressedSize;
			}
			long entryOffsetInsideBlock = entry.Offset - blockDecompressedOffset;

			using SmartStream entryStream = CreateStream(entry.Size);
			long left = entry.Size;
			m_stream.Position = m_dataOffset + blockCompressedOffset;

			// copy data of all blocks used by current entry to new stream
			while (left > 0)
			{
				long blockStreamOffset;
				Stream blockStream;
				StorageBlock block = m_blocksInfo.StorageBlocks[blockIndex];
				if (m_cachedBlockIndex == blockIndex)
				{
					// data of the previous entry is in the same block as this one
					// so we don't need to unpack it once again. Instead we can use cached stream
					blockStreamOffset = 0;
					blockStream = m_cachedBlockStream;
					m_stream.Position += block.CompressedSize;
				}
				else
				{
					CompressionType compressType = block.Flags.GetCompression();
					if (compressType == CompressionType.None)
					{
						blockStreamOffset = m_dataOffset + blockCompressedOffset;
						blockStream = m_stream;
					}
					else
					{
						blockStreamOffset = 0;
						m_cachedBlockIndex = blockIndex;
						m_cachedBlockStream.Move(CreateStream(block.UncompressedSize));
						switch (compressType)
						{
							case CompressionType.Lzma:
								SevenZipHelper.DecompressLZMAStream(m_stream, block.CompressedSize, m_cachedBlockStream, block.UncompressedSize);
								break;

							case CompressionType.Lz4:
							case CompressionType.Lz4HC:
								uint uncompressedSize = block.UncompressedSize;
								byte[] uncompressedBytes = new byte[uncompressedSize];
								byte[] compressedBytes = new BinaryReader(m_stream).ReadBytes((int)block.CompressedSize);
								int bytesWritten = LZ4Codec.Decode(compressedBytes, uncompressedBytes);
								if (bytesWritten != uncompressedSize)
								{
									throw new Exception($"Incorrect number of bytes written. {bytesWritten} instead of {uncompressedSize}");
								}
								new MemoryStream(uncompressedBytes).CopyTo(m_cachedBlockStream);
								break;

							default:
								throw new NotImplementedException($"Bundle compression '{compressType}' isn't supported");
						}
						blockStream = m_cachedBlockStream;
					}
				}

				// consider next offsets:
				// 1) block - if it is new stream then offset is 0, otherwise offset of this block in the bundle file
				// 2) entry - if this is first block for current entry then it is offset of this entry related to this block
				//			  otherwise 0
				long blockSize = block.UncompressedSize - entryOffsetInsideBlock;
				blockStream.Position = blockStreamOffset + entryOffsetInsideBlock;
				entryOffsetInsideBlock = 0;

				long size = Math.Min(blockSize, left);
				blockStream.CopyStream(entryStream, size);
				blockIndex++;

				blockCompressedOffset += block.CompressedSize;
				left -= size;
			}
			if (left < 0)
			{
				throw new Exception($"Read more than expected");
			}
			entryStream.Position = 0;
			return entryStream.CreateReference();
		}

		private void Dispose(bool disposing)
		{
			m_isDisposed = true;
			m_cachedBlockStream.Dispose();
		}

		private SmartStream CreateStream(long decompressedSize)
		{
			return decompressedSize > int.MaxValue ? SmartStream.CreateTemp() : SmartStream.CreateMemory(new byte[decompressedSize]);
		}

		private readonly Stream m_stream;
		private readonly BlocksInfo m_blocksInfo = new();
		private readonly long m_dataOffset;

		private readonly SmartStream m_cachedBlockStream = SmartStream.CreateNull();
		private int m_cachedBlockIndex = -1;

		private bool m_isDisposed = false;
	}
}

```

`AssetRipper.IO.Files/BundleFiles/IO/BundleReader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.BundleFiles.Parser;
using System.IO;

namespace AssetRipper.IO.Files.BundleFiles.IO
{
	public sealed class BundleReader : EndianReader
	{
		public BundleReader(Stream stream, EndianType endianess, BundleType signature, BundleVersion generation, BundleFlags flags) : base(stream, endianess)
		{
			Signature = signature;
			Generation = generation;
			Flags = flags;
		}

		public T ReadBundle<T>() where T : IBundleReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadBundleArray<T>() where T : IBundleReadable, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public T[] ReadBundleArray<T>(Func<T> instantiator) where T : IBundleReadable
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = instantiator();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public BundleType Signature { get; }
		public BundleVersion Generation { get; }
		public BundleFlags Flags { get; }
	}
}

```

`AssetRipper.IO.Files/BundleFiles/IO/IBundleReadable.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.IO
{
	public interface IBundleReadable
	{
		void Read(BundleReader reader);
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/BlocksInfo.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.IO;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	public sealed class BlocksInfo : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			Hash = reader.ReadBytes(16);
			StorageBlocks = reader.ReadBundleArray<StorageBlock>();
		}

		public StorageBlock[] StorageBlocks { get; set; } = Array.Empty<StorageBlock>();
		/// <summary>
		/// Hash128
		/// </summary>
		public byte[] Hash { get; set; } = Array.Empty<byte>();
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/BundleFlags.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	[Flags]
	public enum BundleFlags
	{
		None = 0,

		CompressionBit1 = 0x1,
		CompressionBit2 = 0x2,
		CompressionBit3 = 0x4,
		CompressionBit4 = 0x8,
		CompressionBit5 = 0x10,
		CompressionBit6 = 0x20,
		CompressionTypeMask = 0x3F,

		BlocksAndDirectoryInfoCombined = 0x40,
		BlocksInfoAtTheEnd = 0x80,
		OldWebPluginCompatibility = 0x100,
		/// <summary>
		/// Padding is added after blocks info, so files within asset bundles start on aligned boundaries.
		/// </summary>
		/// <remarks>
		/// Introduced in 2019.4.41f1?, 2020.3.34f1, 2021.3.2f1, 2022.1.1f1 so that Switch patching works appropriately.<br/>
		/// <see href="https://unity3d.com/unity/whats-new/2021.3.2"/><br/>
		/// <see href="https://issuetracker.unity3d.com/issues/files-within-assetbundles-do-not-start-on-aligned-boundaries-breaking-patching-on-nintendo-switch"/><br/>
		/// This fix implies that loading newly generated AssetBundles will require using this new Unity editor/runtime combination. It is not backwards compatible.
		/// </remarks>
		AlignAfterBlocksInfo = 0x200,
	}

	public static class BundleFlagsExtensions
	{
		/// <summary>
		/// The lowest 6 bits
		/// </summary>
		public static CompressionType GetCompression(this BundleFlags _this)
		{
			return (CompressionType)(_this & BundleFlags.CompressionTypeMask);
		}

		/// <summary>
		/// The 0x40 bit: <see cref="BundleFlags.BlocksAndDirectoryInfoCombined"/>
		/// </summary>
		public static bool GetBlocksAndDirectoryInfoCombined(this BundleFlags _this)
		{
			return (_this & BundleFlags.BlocksAndDirectoryInfoCombined) != 0;
		}

		/// <summary>
		/// The 0x80 bit: <see cref="BundleFlags.BlocksInfoAtTheEnd"/>
		/// </summary>
		public static bool GetBlocksInfoAtTheEnd(this BundleFlags _this)
		{
			return (_this & BundleFlags.BlocksInfoAtTheEnd) != 0;
		}

		/// <summary>
		/// The 0x100 bit: <see cref="BundleFlags.OldWebPluginCompatibility"/>
		/// </summary>
		public static bool GetOldWebPluginCompatibility(this BundleFlags _this)
		{
			return (_this & BundleFlags.OldWebPluginCompatibility) != 0;
		}

		/// <summary>
		/// The 0x200 bit: <see cref="BundleFlags.AlignAfterBlocksInfo"/>
		/// </summary>
		public static bool GetAlignAfterBlocksInfo(this BundleFlags _this)
		{
			return (_this & BundleFlags.AlignAfterBlocksInfo) != 0;
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/BundleMetadata.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.IO;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	/// <summary>
	/// Metadata about bundle's block or chunk
	/// </summary>
	public sealed class BundleMetadata : IBundleReadable
	{
		/// <summary>
		/// 5.2.0 and greater
		/// </summary>
		private static bool HasBlocksInfo(BundleType signature) => signature == BundleType.UnityFS;

		public void Read(BundleReader reader)
		{
			if (HasBlocksInfo(reader.Signature))
			{
				BlocksInfo.Read(reader);
				if (reader.Flags.GetBlocksAndDirectoryInfoCombined())
				{
					DirectoryInfo.Read(reader);
				}
			}
			else
			{
				DirectoryInfo.Read(reader);
				reader.AlignStream();
			}
		}

		public BlocksInfo BlocksInfo = new();
		public DirectoryInfo DirectoryInfo = new();
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/BundleScene.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	/// <summary>
	/// Contains compression information about chunk
	/// Chunk is a structure (optionaly LZMA compressed) that contains file entries and data blob
	/// </summary>
	public struct BundleScene : IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			CompressedSize = reader.ReadUInt32();
			DecompressedSize = reader.ReadUInt32();
		}

		public override string ToString()
		{
			return $"C:{CompressedSize} D:{DecompressedSize}";
		}

		public uint CompressedSize { get; private set; }
		public uint DecompressedSize { get; private set; }
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/DirectoryInfo.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.IO;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	public sealed class DirectoryInfo : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			Nodes = reader.ReadBundleArray<Node>();
		}

		public Node[] Nodes { get; set; } = Array.Empty<Node>();
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/Node.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.IO;
using AssetRipper.IO.Files.Utils;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	public sealed class Node : IBundleReadable
	{
		/// <summary>
		/// 5.2.0 and greater
		/// </summary>
		public static bool HasBlobIndex(BundleType signature) => signature == BundleType.UnityFS;

		public void Read(BundleReader reader)
		{
			if (HasBlobIndex(reader.Signature))
			{
				Offset = reader.ReadInt64();
				Size = reader.ReadInt64();
				BlobIndex = reader.ReadInt32();
				PathOrigin = reader.ReadStringZeroTerm();
			}
			else
			{
				PathOrigin = reader.ReadStringZeroTerm();
				Offset = reader.ReadInt32();
				Size = reader.ReadInt32();
			}
			Path = FilenameUtils.FixFileIdentifier(PathOrigin);
		}

		public override string ToString()
		{
			return Path;
		}

		public string Path { get; set; } = "";
		public string PathOrigin { get; set; } = "";
		public long Offset { get; set; }
		public long Size { get; set; }
		public int BlobIndex { get; set; }
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/StorageBlock.cs`:

```cs
using AssetRipper.IO.Files.BundleFiles.IO;

namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	/// <summary>
	/// Contains compression information about a block<br/>
	/// Blocks are similar to chunk structure in that it contains a data blob but without file entries
	/// </summary>
	public struct StorageBlock : IBundleReadable
	{
		public void Read(BundleReader reader)
		{
			UncompressedSize = reader.ReadUInt32();
			CompressedSize = reader.ReadUInt32();
			Flags = (StorageBlockFlags)reader.ReadUInt16();
		}

		public override string ToString()
		{
			return $"C:{CompressedSize} D:{UncompressedSize} F:{Flags}";
		}

		public uint UncompressedSize { get; private set; }
		public uint CompressedSize { get; private set; }
		public StorageBlockFlags Flags { get; private set; }
	}
}

```

`AssetRipper.IO.Files/BundleFiles/Parser/StorageBlockFlags.cs`:

```cs
namespace AssetRipper.IO.Files.BundleFiles.Parser
{
	[Flags]
	public enum StorageBlockFlags
	{
		CompressionTypeMask = 0x3F,

		Streamed = 0x40,
	}

	public static class StorageBlockFlagsExtensions
	{
		public static CompressionType GetCompression(this StorageBlockFlags _this)
		{
			return (CompressionType)(_this & StorageBlockFlags.CompressionTypeMask);
		}

		public static bool IsStreamed(this StorageBlockFlags _this)
		{
			return (_this & StorageBlockFlags.Streamed) != 0;
		}
	}
}

```

`AssetRipper.IO.Files/BundleFiles/SevenZipHelper.cs`:

```cs
using AssetRipper.IO.Files.Extensions;
using SharpCompress.Compressors.LZMA;
using System.IO;

namespace AssetRipper.IO.Files.BundleFiles
{
	public static class SevenZipHelper
	{
		/// <summary>
		/// Read LZMA properties and decompress LZMA data
		/// </summary>
		/// <param name="compressedStream">LZMA compressed stream</param>
		/// <param name="compressedSize">Compressed data length</param>
		/// <param name="decompressedStream">Stream for decompressed output</param>
		/// <param name="decompressedSize">Decompressed data length</param>
		public static void DecompressLZMAStream(Stream compressedStream, long compressedSize, Stream decompressedStream, long decompressedSize)
		{
			byte[] properties = new byte[PropertiesSize];
			long basePosition = compressedStream.Position;

			compressedStream.ReadBuffer(properties, 0, PropertiesSize);

			long headSize = compressedStream.Position - basePosition;
			long headlessSize = compressedSize - headSize;

			DecompressLZMAStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

			if (compressedStream.Position > basePosition + compressedSize)
			{
				throw new Exception($"Read {compressedStream.Position - basePosition} more than expected {compressedSize}");
			}
			compressedStream.Position = basePosition + compressedSize;
		}

		/// <summary>
		/// Read LZMA properties and decompressed size and decompress LZMA data
		/// </summary>
		/// <param name="compressedStream">LZMA compressed stream</param>
		/// <param name="compressedSize">Compressed data length</param>
		/// <param name="decompressedStream">Stream for decompressed output</param>
		public static void DecompressLZMASizeStream(Stream compressedStream, long compressedSize, Stream decompressedStream)
		{
			byte[] properties = new byte[PropertiesSize]; //GetBuffer();
			byte[] sizeBytes = new byte[UncompressedSize]; //GetBuffer();
			long basePosition = compressedStream.Position;

			compressedStream.ReadBuffer(properties, 0, PropertiesSize);
			compressedStream.ReadBuffer(sizeBytes, 0, UncompressedSize);
			long decompressedSize = BitConverter.ToInt64(sizeBytes, 0);

			long headSize = compressedStream.Position - basePosition;
			long headlessSize = compressedSize - headSize;

			DecompressLZMAStream(properties, compressedStream, headlessSize, decompressedStream, decompressedSize);

			if (compressedStream.Position > basePosition + compressedSize)
			{
				throw new Exception($"Read {compressedStream.Position - basePosition} more than expected {compressedSize}");
			}
			compressedStream.Position = basePosition + compressedSize;
		}

		private static void DecompressLZMAStream(byte[] properties, Stream compressedStream, long headlessSize, Stream decompressedStream, long decompressedSize)
		{
			LzmaStream lzmaStream = new LzmaStream(properties, compressedStream, headlessSize, -1, null, false);

			byte[] buffer = GetBuffer();
			int read;
			long totalRead = 0;
			while (totalRead < decompressedSize)
			{
				int toRead = (int)Math.Min(buffer.Length, decompressedSize - totalRead);
				read = lzmaStream.Read(buffer, 0, toRead);
				if (read > 0)
				{
					decompressedStream.Write(buffer, 0, read);
					totalRead += read;
				}
				else
				{
					break;
				}
			}
		}

		private static byte[] GetBuffer()
		{
			if (s_buffer == null)
			{
				s_buffer = new byte[1024];
			}
			return s_buffer;
		}

		private const int PropertiesSize = 5;
		private const int UncompressedSize = 8;

		[ThreadStatic]
		private static byte[]? s_buffer;
	}
}

```

`AssetRipper.IO.Files/Converters/SerializedFileMetadataConverter.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.Converters
{
	public static class SerializedFileMetadataConverter
	{
		public static void CombineFormats(FormatVersion generation, SerializedFileMetadata origin)
		{
			if (!SerializedFileMetadata.HasEnableTypeTree(generation))
			{
				origin.EnableTypeTree = true;
			}
			for (int i = 0; i < origin.Types.Length; i++)
			{
				SerializedTypeConverter.CombineFormats(generation, origin.Types[i]);
			}
			if (generation >= FormatVersion.RefactorTypeData)
			{
				for (int i = 0; i < origin.Object.Length; i++)
				{
					ObjectInfo entry = origin.Object[i];
					SerializedType type = origin.Types[entry.TypeID];
					entry.ClassID = (short)type.TypeID;
					entry.ScriptTypeIndex = type.ScriptTypeIndex;
					entry.Stripped = type.IsStrippedType;
				}
			}
		}
	}
}

```

`AssetRipper.IO.Files/Converters/SerializedTypeConverter.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.SerializedFiles.Parser;

namespace AssetRipper.IO.Files.Converters
{
	public static class SerializedTypeConverter
	{
		public static void CombineFormats(FormatVersion generation, SerializedType origin)
		{
			origin.OldType.MaybeSetNamesFromBuffer();
		}
	}
}

```

`AssetRipper.IO.Files/Entries/FileEntry.cs`:

```cs
namespace AssetRipper.IO.Files.Entries
{
	public abstract class FileEntry
	{
		public override string? ToString()
		{
			return Name;
		}

		public string Name { get; protected set; } = "";
		public string NameOrigin { get; protected set; } = "";
		public long Offset { get; protected set; }
		public long Size { get; protected set; }
	}
}

```

`AssetRipper.IO.Files/Entries/FileEntryType.cs`:

```cs
namespace AssetRipper.IO.Files.Entries
{
	public enum FileEntryType
	{
		Serialized,
		Bundle,
		Archive,
		Web,
		Resource,
	}
}

```

`AssetRipper.IO.Files/Entries/FileList.cs`:

```cs
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.SerializedFiles;
using System.Collections.Generic;

namespace AssetRipper.IO.Files.Entries
{
	public abstract class FileList
	{
		public FileList(string name)
		{
			Name = name;
		}

		public IEnumerable<SerializedFile> FetchSerializedFiles()
		{
			foreach (SerializedFile file in SerializedFiles)
			{
				yield return file;
			}
			foreach (FileList list in FileLists)
			{
				foreach (SerializedFile file in list.FetchSerializedFiles())
				{
					yield return file;
				}
			}
		}

		public void AddSerializedFile(SerializedFile file)
		{
			m_serializedFiles.Add(file);
			OnSerializedFileAdded(file);
		}

		public void AddFileList(FileList list)
		{
			m_fileLists.Add(list);
			OnFileListAdded(list);
		}

		public void AddResourceFile(ResourceFile resource)
		{
			m_resourceFiles.Add(resource);
			OnResourceFileAdded(resource);
		}

		protected virtual void OnSerializedFileAdded(SerializedFile file) { }

		protected virtual void OnFileListAdded(FileList list) { }

		protected virtual void OnResourceFileAdded(ResourceFile resource) { }

		public string Name { get; }

		public IReadOnlyList<SerializedFile> SerializedFiles => m_serializedFiles;
		public IReadOnlyList<FileList> FileLists => m_fileLists;
		public IReadOnlyList<ResourceFile> ResourceFiles => m_resourceFiles;

		private readonly List<SerializedFile> m_serializedFiles = new List<SerializedFile>(0);
		private readonly List<FileList> m_fileLists = new List<FileList>(0);
		private readonly List<ResourceFile> m_resourceFiles = new List<ResourceFile>(0);
	}
}

```

`AssetRipper.IO.Files/Extensions/StreamExtensions.cs`:

```cs
using System.IO;

namespace AssetRipper.IO.Files.Extensions
{
	public static class StreamExtensions
	{
		public static void Align(this Stream _this) => _this.Align(4);
		public static void Align(this Stream _this, int alignment)
		{
			long pos = _this.Position;
			long mod = pos % alignment;
			if (mod != 0)
			{
				_this.Position += alignment - mod;
			}
		}

		public static void ReadBuffer(this Stream _this, byte[] buffer, int offset, int count)
		{
			do
			{
				int read = _this.Read(buffer, offset, count);
				if (read == 0)
				{
					throw new Exception($"No data left");
				}
				offset += read;
				count -= read;
			}
			while (count > 0);
		}

		public static void CopyStream(this Stream _this, Stream dstStream)
		{
			byte[] buffer = new byte[BufferSize];
			while (true)
			{
				int offset = 0;
				int count = BufferSize;
				int toWrite = 0;

				int read;
				do
				{
					read = _this.Read(buffer, offset, count);
					offset += read;
					count -= read;
					toWrite += read;
				} while (read != 0);

				dstStream.Write(buffer, 0, toWrite);
				if (toWrite != BufferSize)
				{
					return;
				}
			}
		}

		public static void CopyStream(this Stream _this, Stream dstStream, long size)
		{
			byte[] buffer = new byte[BufferSize];
			for (long left = size; left > 0; left -= BufferSize)
			{
				int toRead = BufferSize < left ? BufferSize : (int)left;
				int offset = 0;
				int count = toRead;
				while (count > 0)
				{
					int read = _this.Read(buffer, offset, count);
					if (read == 0)
					{
						throw new Exception($"No data left");
					}
					offset += read;
					count -= read;
				}
				dstStream.Write(buffer, 0, toRead);
			}
		}

		private const int BufferSize = 81920;
	}
}

```

`AssetRipper.IO.Files/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipper.IO.Files/ResourceFiles/IResourceFile.cs`:

```cs
using System.IO;

namespace AssetRipper.IO.Files.ResourceFiles
{
	public interface IResourceFile
	{
		Stream Stream { get; }
	}
}

```

`AssetRipper.IO.Files/ResourceFiles/ResourceFile.cs`:

```cs
using AssetRipper.IO.Files.Streams.Smart;
using System.IO;

namespace AssetRipper.IO.Files.ResourceFiles
{
	public sealed class ResourceFile : IResourceFile, IDisposable
	{
		internal ResourceFile(ResourceFileScheme scheme)
		{
			Name = scheme.NameOrigin;
			Stream = scheme.Stream.CreateReference();
		}

		~ResourceFile()
		{
			Dispose(false);
		}

		public static bool IsDefaultResourceFile(string fileName)
		{
			string extension = Path.GetExtension(fileName).ToLower();
			return extension switch
			{
				ResourceFileExtension or StreamingFileExtension => true,
				_ => false,
			};
		}

		public static ResourceFileScheme LoadScheme(string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static ResourceFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return ResourceFileScheme.ReadScheme(buffer, filePath, fileName);
		}

		public static ResourceFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return ResourceFileScheme.ReadScheme(stream, filePath, fileName);
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		public override string ToString()
		{
			return Name;
		}

		private void Dispose(bool _)
		{
			Stream.Dispose();
		}

		public string Name { get; }
		public Stream Stream { get; }

		public const string ResourceFileExtension = ".resource";
		public const string StreamingFileExtension = ".ress";
	}
}

```

`AssetRipper.IO.Files/ResourceFiles/ResourceFileScheme.cs`:

```cs
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Schemes;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Streams.Smart;
using System.Collections.Generic;

namespace AssetRipper.IO.Files.ResourceFiles
{
	public sealed class ResourceFileScheme : FileScheme
	{
		private ResourceFileScheme(SmartStream stream, string filePath, string fileName) : base(filePath, fileName)
		{
			Stream = stream.CreateReference();
		}

		internal static ResourceFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.CreateMemory(buffer);
			return new ResourceFileScheme(stream, filePath, fileName);
		}

		internal static ResourceFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return new ResourceFileScheme(stream, filePath, fileName);
		}

		public ResourceFile ReadFile()
		{
			return new ResourceFile(this);
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			Stream.Dispose();
		}

		public override FileEntryType SchemeType => FileEntryType.Resource;
		public override IEnumerable<FileIdentifier> Dependencies { get { yield break; } }

		public SmartStream Stream { get; }
	}
}

```

`AssetRipper.IO.Files/SchemeReader.cs`:

```cs
using AssetRipper.IO.Files.ArchiveFiles;
using AssetRipper.IO.Files.BundleFiles;
using AssetRipper.IO.Files.ResourceFiles;
using AssetRipper.IO.Files.Schemes;
using AssetRipper.IO.Files.SerializedFiles;
using AssetRipper.IO.Files.Streams.Smart;
using AssetRipper.IO.Files.WebFiles;
using System.IO;

namespace AssetRipper.IO.Files
{
	public static class SchemeReader
	{
		/// <summary>Returns some information about the file including its type</summary>
		public static FileScheme LoadScheme(string filePath, string fileName)
		{
			using SmartStream stream = SmartStream.OpenRead(filePath);
			return ReadScheme(stream, filePath, fileName);
		}

		public static FileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			using MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false);
			if (BundleFile.IsBundleFile(stream))
			{
				return BundleFileScheme.ReadScheme(buffer, filePath, fileName);
			}
			if (ArchiveFile.IsArchiveFile(stream))
			{
				return ArchiveFile.ReadScheme(buffer, filePath, fileName);
			}
			if (WebFile.IsWebFile(stream))
			{
				return WebFile.ReadScheme(buffer, filePath);
			}
			if (SerializedFile.IsSerializedFile(stream))
			{
				return SerializedFile.ReadScheme(buffer, filePath, fileName);
			}
			return ResourceFile.ReadScheme(buffer, filePath, fileName);
		}

		public static FileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			if (BundleFile.IsBundleFile(stream))
			{
				return BundleFileScheme.ReadScheme(stream, filePath, fileName);
			}
			if (ArchiveFile.IsArchiveFile(stream))
			{
				return ArchiveFile.ReadScheme(stream, filePath, fileName);
			}
			if (WebFile.IsWebFile(stream))
			{
				return WebFile.ReadScheme(stream, filePath);
			}
			if (SerializedFile.IsSerializedFile(stream))
			{
				return SerializedFile.ReadScheme(stream, filePath, fileName);
			}

			return ResourceFile.ReadScheme(stream, filePath, fileName);
		}
	}
}

```

`AssetRipper.IO.Files/Schemes/FileScheme.cs`:

```cs
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Utils;
using System.Collections.Generic;

namespace AssetRipper.IO.Files.Schemes
{
	public abstract class FileScheme : IDisposable
	{
		protected FileScheme(string filePath, string fileName)
		{
			FilePath = filePath ?? throw new ArgumentNullException(nameof(filePath));
			NameOrigin = fileName;
			Name = FilenameUtils.FixFileIdentifier(fileName);
		}

		public override string? ToString()
		{
			return Name == null ? base.ToString() : $"T:{SchemeType} N:'{Name}'";
		}

		public string FilePath { get; }
		public string NameOrigin { get; }
		public string Name { get; }

		public abstract FileEntryType SchemeType { get; }
		public abstract IEnumerable<FileIdentifier> Dependencies { get; }

		~FileScheme()
		{
			Dispose(false);
		}

		protected virtual void Dispose(bool disposing) { }

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

	}
}

```

`AssetRipper.IO.Files/Schemes/FileSchemeList.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.Parser;
using System.Collections.Generic;

namespace AssetRipper.IO.Files.Schemes
{
	public abstract class FileSchemeList : FileScheme
	{
		protected FileSchemeList(string filePath, string fileName) : base(filePath, fileName) { }

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			foreach (FileScheme scheme in Schemes)
			{
				scheme.Dispose();
			}
		}

		protected void AddScheme(FileScheme scheme)
		{
			m_schemes.Add(scheme);
		}

		public sealed override IEnumerable<FileIdentifier> Dependencies
		{
			get
			{
				foreach (FileScheme scheme in m_schemes)
				{
					foreach (FileIdentifier dependency in scheme.Dependencies)
					{
						yield return dependency;
					}
				}
			}
		}

		public IReadOnlyList<FileScheme> Schemes => m_schemes;

		private readonly List<FileScheme> m_schemes = new List<FileScheme>();
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/FormatVersion.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles
{
	/// <summary>
	/// SerializedFileFormatVersion in the pdb
	/// </summary>
	public enum FormatVersion
	{
		Unsupported = 1,
		Unknown_2 = 2,
		Unknown_3 = 3,
		/// <summary>
		/// 1.2.0 to 2.0.0
		/// </summary>
		Unknown_5 = 5,
		/// <summary>
		/// 2.1.0 to 2.6.1
		/// </summary>
		Unknown_6 = 6,
		/// <summary>
		/// 3.0.0b
		/// </summary>
		Unknown_7 = 7,
		/// <summary>
		/// 3.0.0 to 3.4.2
		/// </summary>
		Unknown_8 = 8,
		/// <summary>
		/// 3.5.0 to 4.7.2
		/// </summary>
		Unknown_9 = 9,
		/// <summary>
		/// 5.0.0aunk1
		/// </summary>
		Unknown_10 = 10,
		/// <summary>
		/// 5.0.0aunk2
		/// </summary>
		HasScriptTypeIndex = 11,
		/// <summary>
		/// 5.0.0aunk3
		/// </summary>
		Unknown_12 = 12,
		/// <summary>
		/// 5.0.0aunk4
		/// </summary>
		HasTypeTreeHashes = 13,
		/// <summary>
		/// 5.0.0unk
		/// </summary>
		Unknown_14 = 14,
		/// <summary>
		/// 5.0.1 to 5.4.0
		/// </summary>
		SupportsStrippedObject = 15,
		/// <summary>
		/// 5.5.0a
		/// </summary>
		RefactoredClassId = 16,
		/// <summary>
		/// 5.5.0unk to 2018.4
		/// </summary>
		RefactorTypeData = 17,
		/// <summary>
		/// 2019.1a
		/// </summary>
		RefactorShareableTypeTreeData = 18,
		/// <summary>
		/// 2019.1unk
		/// </summary>
		TypeTreeNodeWithTypeFlags = 19,
		/// <summary>
		/// 2019.2
		/// </summary>
		SupportsRefObject = 20,
		/// <summary>
		/// 2019.3 to 2019.4
		/// </summary>
		StoresTypeDependencies = 21,
		/// <summary>
		/// 2020.1 to x
		/// </summary>
		LargeFilesSupport = 22,
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/IO/ISerializedReadable.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.IO
{
	public interface ISerializedReadable
	{
		void Read(SerializedReader reader);
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/IO/ISerializedWritable.cs`:

```cs
namespace AssetRipper.IO.Files.SerializedFiles.IO
{
	public interface ISerializedWritable
	{
		void Write(SerializedWriter writer);
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/IO/SerializedReader.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using System.IO;

namespace AssetRipper.IO.Files.SerializedFiles.IO
{
	public sealed class SerializedReader : EndianReader
	{
		public SerializedReader(Stream stream, EndianType endianess, FormatVersion generation) : base(stream, endianess)
		{
			Generation = generation;
		}

		public T ReadSerialized<T>() where T : ISerializedReadable, new()
		{
			T t = new T();
			t.Read(this);
			return t;
		}

		public T[] ReadSerializedArray<T>() where T : ISerializedReadable, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new T();
				instance.Read(this);
				array[i] = instance;
			}
			return array;
		}

		public T[] ReadSerializedTypeArray<T>(bool hasTypeTree) where T : SerializedTypeBase, new()
		{
			int count = ReadInt32();
			T[] array = new T[count];
			for (int i = 0; i < count; i++)
			{
				T instance = new();
				instance.Read(this, hasTypeTree);
				array[i] = instance;
			}
			return array;
		}

		public FormatVersion Generation { get; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/IO/SerializedWriter.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using System.IO;

namespace AssetRipper.IO.Files.SerializedFiles.IO
{
	public sealed class SerializedWriter : EndianWriter
	{
		public SerializedWriter(Stream stream, EndianType endianess, FormatVersion generation) : base(stream, endianess)
		{
			Generation = generation;
		}

		public void WriteSerialized<T>(T value) where T : ISerializedWritable
		{
			value.Write(this);
		}

		public void WriteSerializedArray<T>(T[] buffer) where T : ISerializedWritable
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i].Write(this);
			}
		}

		public void WriteSerializedTypeArray<T>(T[] buffer, bool hasTypeTree) where T : SerializedTypeBase
		{
			FillInnerBuffer(buffer.Length);
			Write(m_buffer, 0, sizeof(int));

			for (int i = 0; i < buffer.Length; i++)
			{
				buffer[i].Write(this, hasTypeTree);
			}
		}

		public FormatVersion Generation { get; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/FileIdentifier.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;
using AssetRipper.IO.Files.Utils;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	/// <summary>
	/// A serialized file may be linked with other serialized files to create shared dependencies.
	/// </summary>
	public struct FileIdentifier : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 2.1.0 and greater
		/// </summary>
		public static bool HasAssetPath(FormatVersion generation) => generation >= FormatVersion.Unknown_6;
		/// <summary>
		/// 1.2.0 and greater
		/// </summary>
		public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.Unknown_5;

		public bool IsFile(SerializedFile? file)
		{
			return file is not null && file.Name == PathName;
		}

		public void Read(SerializedReader reader)
		{
			if (HasAssetPath(reader.Generation))
			{
				AssetPath = reader.ReadStringZeroTerm();
			}
			if (HasHash(reader.Generation))
			{
				//Commented out during creation of AssetRipper.IO.Files
				//Guid.Read(reader);
				Guid = reader.ReadBytes(16);
				Type = (AssetType)reader.ReadInt32();
			}
			PathNameOrigin = reader.ReadStringZeroTerm();
			PathName = FilenameUtils.FixFileIdentifier(PathNameOrigin);
		}

		public void Write(SerializedWriter writer)
		{
			if (HasAssetPath(writer.Generation))
			{
				writer.WriteStringZeroTerm(AssetPath);
			}
			if (HasHash(writer.Generation))
			{
				//Commented out during creation of AssetRipper.IO.Files
				//Guid.Write(writer);
				writer.Write(Guid ?? new byte[16]);
				writer.Write((int)Type);
			}
			writer.WriteStringZeroTerm(PathNameOrigin);
		}

		public string GetFilePath()
		{
			//Commented out during creation of AssetRipper.IO.Files
			//if (Type == AssetType.Meta)
			//{
			//	return Guid.ToString();
			//}
			return PathName;
		}

		public override string? ToString()
		{
			//Commented out during creation of AssetRipper.IO.Files
			//if (Type == AssetType.Meta)
			//{
			//	return Guid.ToString();
			//}
			return PathNameOrigin ?? base.ToString();
		}

		/// <summary>
		/// File path without such prefixes as archive:/directory/fileName
		/// </summary>
		public string PathName { get; set; }

		/// <summary>
		/// Virtual asset path. Used for cached files, otherwise it's empty.
		/// The file with that path usually doesn't exist, so it's probably an alias.
		/// </summary>
		public string AssetPath { get; set; }
		/// <summary>
		/// The type of the file
		/// </summary>
		public AssetType Type { get; set; }
		/// <summary>
		/// Actual file path. This path is relative to the path of the current file.
		/// The folder "library" often needs to be translated to "resources" in order to find the file on the file system.
		/// </summary>
		public string PathNameOrigin { get; set; }

		//Commented out during creation of AssetRipper.IO.Files
		//public UnityGUID Guid;
		public byte[]? Guid { get; set; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/LocalSerializedObjectIdentifier.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	public struct LocalSerializedObjectIdentifier : ISerializedReadable, ISerializedWritable
	{
		public void Read(SerializedReader reader)
		{
			LocalSerializedFileIndex = reader.ReadInt32();
			if (ObjectInfo.IsLongID(reader.Generation))
			{
				reader.AlignStream();
				LocalIdentifierInFile = reader.ReadInt64();
			}
			else
			{
				LocalIdentifierInFile = reader.ReadInt32();
			}
		}

		public void Write(SerializedWriter writer)
		{
			writer.Write(LocalSerializedFileIndex);
			if (ObjectInfo.IsLongID(writer.Generation))
			{
				writer.AlignStream();
				writer.Write(LocalIdentifierInFile);
			}
			else
			{
				writer.Write((int)LocalIdentifierInFile);
			}
		}

		public override string ToString()
		{
			return $"[{LocalSerializedFileIndex}, {LocalIdentifierInFile}]";
		}

		public int LocalSerializedFileIndex { get; set; }
		public long LocalIdentifierInFile { get; set; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/ObjectInfo.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	/// <summary>
	/// Contains information for a block of raw serialized object data.
	/// </summary>
	public sealed class ObjectInfo : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 5.0.0unk and greater
		/// </summary>
		public static bool IsLongID(FormatVersion generation) => generation >= FormatVersion.Unknown_14;
		/// <summary>
		/// Less than 5.5.0
		/// </summary>
		public static bool HasClassID(FormatVersion generation) => generation < FormatVersion.RefactoredClassId;
		/// <summary>
		/// Less than 5.0.0unk
		/// </summary>
		public static bool HasIsDestroyed(FormatVersion generation) => generation < FormatVersion.HasScriptTypeIndex;
		/// <summary>
		/// 5.0.0unk to 5.5.0unk exclusive
		/// </summary>
		public static bool HasScriptID(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex && generation < FormatVersion.RefactorTypeData;
		/// <summary>
		/// 5.0.1 to 5.5.0unk exclusive
		/// </summary>
		public static bool HasStripped(FormatVersion generation) => generation >= FormatVersion.SupportsStrippedObject && generation < FormatVersion.RefactorTypeData;
		/// <summary>
		/// 2020.1.0 and greater / Format Version 22 +
		/// </summary>
		public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

		public void Read(SerializedReader reader)
		{
			if (IsLongID(reader.Generation))
			{
				reader.AlignStream();
				FileID = reader.ReadInt64();
			}
			else
			{
				FileID = reader.ReadInt32();
			}

			if (HasLargeFilesSupport(reader.Generation))
			{
				ByteStart = reader.ReadInt64();
			}
			else
			{
				ByteStart = reader.ReadUInt32();
			}

			ByteSize = reader.ReadInt32();
			TypeID = reader.ReadInt32();
			if (HasClassID(reader.Generation))
			{
				ClassID = reader.ReadInt16();
			}
			if (HasScriptID(reader.Generation))
			{
				ScriptTypeIndex = reader.ReadInt16();
			}
			else if (HasIsDestroyed(reader.Generation))
			{
				IsDestroyed = reader.ReadUInt16();
			}
			if (HasStripped(reader.Generation))
			{
				Stripped = reader.ReadBoolean();
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (IsLongID(writer.Generation))
			{
				writer.AlignStream();
				writer.Write(FileID);
			}
			else
			{
				writer.Write((int)FileID);
			}

			if (HasLargeFilesSupport(writer.Generation))
			{
				writer.Write(ByteStart);
			}
			else
			{
				writer.Write((uint)ByteStart);
			}

			writer.Write(ByteSize);
			writer.Write(TypeID);
			if (HasClassID(writer.Generation))
			{
				writer.Write(ClassID);
			}
			if (HasScriptID(writer.Generation))
			{
				writer.Write(ScriptTypeIndex);
			}
			else if (HasIsDestroyed(writer.Generation))
			{
				writer.Write(IsDestroyed);
			}
			if (HasStripped(writer.Generation))
			{
				writer.Write(Stripped);
			}
		}

		public override string ToString()
		{
			return $"{ClassID}[{FileID}]";
		}

		/// <summary>
		/// ObjectID<br/>
		/// Unique ID that identifies the object. Can be used as a key for a map.
		/// </summary>
		public long FileID { get; set; }
		/// <summary>
		/// Offset to the object data.<br/>
		/// Add to <see cref="SerializedFileHeader.DataOffset"/> to get the absolute offset within the serialized file.
		/// </summary>
		public long ByteStart { get; set; }
		/// <summary>
		/// Size of the object data.
		/// </summary>
		public int ByteSize { get; set; }
		/// <summary>
		/// New versions:<br/>
		///		Type index in <see cref="SerializedFileMetadata.Types"/> array<br/>
		/// Old versions:<br/>
		///		Type ID of the object, which is mapped to <see cref="SerializedType.TypeID"/><br/>
		///		Equals to classID if the object is not <see cref="ClassIDType.MonoBehaviour"/>
		/// </summary>
		public int TypeID { get; set; }
		/// <summary>
		/// Class ID of the object.
		/// </summary>
		public short ClassID { get; set; }
		public ushort IsDestroyed { get; set; }
		public short ScriptTypeIndex { get; set; }
		public bool Stripped { get; set; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/SerializedFileHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	/// <summary>
	/// The file header is found at the beginning of an asset file. The header is always using big endian byte order.
	/// </summary>
	public sealed class SerializedFileHeader
	{
		/// <summary>
		/// Size of the metadata parts of the file
		/// </summary>
		public long MetadataSize { get; set; }
		/// <summary>
		/// Size of the whole file
		/// </summary>
		public long FileSize { get; set; }
		/// <summary>
		/// File format version. The number is required for backward compatibility and is normally incremented after the file format has been changed in a major update
		/// </summary>
		public FormatVersion Version { get; set; }
		/// <summary>
		/// Offset to the serialized object data. It starts at the data for the first object
		/// </summary>
		public long DataOffset { get; set; }
		/// <summary>
		/// Presumably controls the byte order of the data structure. This field is normally set to 0, which may indicate a little endian byte order.
		/// </summary>
		public bool Endianess { get; set; }

		public const int HeaderMinSize = 16;

		public const int MetadataMinSize = 16;


		/// <summary>
		/// 3.5.0 and greater / Format Version 9 +
		/// </summary>
		public static bool HasEndianess(FormatVersion generation) => generation >= FormatVersion.Unknown_9;

		/// <summary>
		/// 2020.1.0 and greater / Format Version 22 +
		/// </summary>
		public static bool HasLargeFilesSupport(FormatVersion generation) => generation >= FormatVersion.LargeFilesSupport;

		public static bool IsSerializedFileHeader(EndianReader reader, long fileSize)
		{
			long initialPosition = reader.BaseStream.Position;

			//Sanity check that there is enough room here first.
			if (reader.BaseStream.Position + HeaderMinSize > reader.BaseStream.Length)
			{
				return false;
			}

			//Pre-22 format: 
			// - Metadata Size
			// - File Size
			// - Generation
			int metadataSize = reader.ReadInt32();
			ulong headerDefinedFileSize = reader.ReadUInt32();

			// Read generation first, the format changed hugely in gen 22 (unity 2020)
			// Generation is always at [base + 0x8]
			int generation = reader.ReadInt32();
			if (!Enum.IsDefined(typeof(FormatVersion), generation))
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			reader.BaseStream.Position = initialPosition;
			if (generation >= 22)
			{
				//22 Format:
				//First known value is at 0x14, and is metadata size as a 32-bit integer.
				//Then the file size as a 64-bit integer.
				reader.BaseStream.Position = initialPosition + 0x14;
				metadataSize = reader.ReadInt32();
				headerDefinedFileSize = reader.ReadUInt64();
			}

			if (metadataSize < MetadataMinSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			if (headerDefinedFileSize < HeaderMinSize + MetadataMinSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			if (fileSize < 0 || headerDefinedFileSize != (ulong)fileSize)
			{
				reader.BaseStream.Position = initialPosition;
				return false;
			}

			reader.BaseStream.Position = initialPosition;
			return true;
		}

		public void Read(EndianReader reader)
		{
			//For gen 22+ these will be zero
			MetadataSize = reader.ReadInt32();
			FileSize = reader.ReadUInt32();

			//Read generation
			Version = (FormatVersion)reader.ReadInt32();

			//For gen 22+ these will be zero
			DataOffset = reader.ReadUInt32();

			if (HasEndianess(Version))
			{
				Endianess = reader.ReadBoolean();
				reader.AlignStream();
			}
			if (HasLargeFilesSupport(Version))
			{
				MetadataSize = reader.ReadUInt32();
				FileSize = reader.ReadInt64();
				DataOffset = reader.ReadInt64();
				reader.ReadInt64(); // unknown
			}

			if (MetadataSize <= 0)
			{
				throw new Exception($"Invalid metadata size {MetadataSize}");
			}

			if (!Enum.IsDefined(typeof(FormatVersion), Version))
			{
				throw new Exception($"Unsupported file generation {Version}'");
			}
		}

		public void Write(EndianWriter writer)
		{
			//0x00
			if (HasLargeFilesSupport(Version))
			{
				writer.Write(0);
				writer.Write(0);
			}
			else
			{
				writer.Write((int)MetadataSize);
				writer.Write((uint)FileSize);
			}

			//0x08
			writer.Write((int)Version);

			//0x0c
			if (HasLargeFilesSupport(Version))
			{
				writer.Write(0);
			}
			else
			{
				writer.Write((uint)DataOffset);
			}

			//0x10
			if (HasEndianess(Version))
			{
				writer.Write(Endianess);
				writer.AlignStream();
			}

			//0x14
			if (HasLargeFilesSupport(Version))
			{
				writer.Write((uint)MetadataSize);
				writer.Write(FileSize);
				writer.Write(DataOffset);
				writer.Write((long)0);
			}
		}
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/SerializedFileMetadata.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.IO;
using System.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	public sealed class SerializedFileMetadata
	{
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasEndian(FormatVersion generation) => generation < FormatVersion.Unknown_9;
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool IsMetadataAtTheEnd(FormatVersion generation) => generation < FormatVersion.Unknown_9;

		/// <summary>
		/// 3.0.0b and greater
		/// </summary>
		public static bool HasSignature(FormatVersion generation) => generation >= FormatVersion.Unknown_7;
		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasPlatform(FormatVersion generation) => generation >= FormatVersion.Unknown_8;
		/// <summary>
		/// 5.0.0Unk2 and greater
		/// </summary>
		public static bool HasEnableTypeTree(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
		/// <summary>
		/// 3.0.0b to 4.x.x
		/// </summary>
		public static bool HasLongFileID(FormatVersion generation) => generation >= FormatVersion.Unknown_7 && generation < FormatVersion.Unknown_14;
		/// <summary>
		/// 5.0.0Unk0 and greater
		/// </summary>
		public static bool HasScriptTypes(FormatVersion generation) => generation >= FormatVersion.HasScriptTypeIndex;
		/// <summary>
		/// 1.2.0 and greater
		/// </summary>
		public static bool HasUserInformation(FormatVersion generation) => generation >= FormatVersion.Unknown_5;
		/// <summary>
		/// 2019.2 and greater
		/// </summary>
		public static bool HasRefTypes(FormatVersion generation) => generation >= FormatVersion.SupportsRefObject;

		public void Read(Stream stream, SerializedFileHeader header)
		{
			bool swapEndianess = header.Endianess;
			if (HasEndian(header.Version))
			{
				SwapEndianess = stream.ReadByte() != 0;
				swapEndianess = SwapEndianess;
			}
			EndianType endianess = swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
			using SerializedReader reader = new SerializedReader(stream, endianess, header.Version);
			Read(reader);
		}

		public void Write(Stream stream, SerializedFileHeader header)
		{
			bool swapEndianess = header.Endianess;
			if (HasEndian(header.Version))
			{
				stream.WriteByte((byte)(SwapEndianess ? 1 : 0));
				swapEndianess = SwapEndianess;
			}
			EndianType endianess = swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
			using SerializedWriter writer = new SerializedWriter(stream, endianess, header.Version);
			Write(writer);
		}

		private void Read(SerializedReader reader)
		{
			if (HasSignature(reader.Generation))
			{
				string signature = reader.ReadStringZeroTerm();
				UnityVersion = UnityVersion.Parse(signature);
			}
			if (HasPlatform(reader.Generation))
			{
				TargetPlatform = (BuildTarget)reader.ReadUInt32();
			}

			if (HasEnableTypeTree(reader.Generation))
			{
				EnableTypeTree = reader.ReadBoolean();
			}
			else
			{
				EnableTypeTree = true;
			}

			Types = reader.ReadSerializedTypeArray<SerializedType>(EnableTypeTree);

			if (HasLongFileID(reader.Generation))
			{
				LongFileID = reader.ReadUInt32();
			}

#warning TODO: pass LongFileID to ObjectInfo
			Object = reader.ReadSerializedArray<ObjectInfo>();

			if (HasScriptTypes(reader.Generation))
			{
				ScriptTypes = reader.ReadSerializedArray<LocalSerializedObjectIdentifier>();
			}

			Externals = reader.ReadSerializedArray<FileIdentifier>();

			if (HasRefTypes(reader.Generation))
			{
				RefTypes = reader.ReadSerializedTypeArray<SerializedTypeReference>(EnableTypeTree);
			}
			if (HasUserInformation(reader.Generation))
			{
				UserInformation = reader.ReadStringZeroTerm();
			}
		}

		private void Write(SerializedWriter writer)
		{
			if (HasSignature(writer.Generation))
			{
				writer.WriteStringZeroTerm(UnityVersion.ToString());
			}
			if (HasPlatform(writer.Generation))
			{
				writer.Write((uint)TargetPlatform);
			}
			if (HasEnableTypeTree(writer.Generation))
			{
				writer.Write(EnableTypeTree);
			}

			writer.WriteSerializedTypeArray(Types, EnableTypeTree);
			if (HasLongFileID(writer.Generation))
			{
				writer.Write(LongFileID);
			}

			writer.WriteSerializedArray(Object);
			if (HasScriptTypes(writer.Generation))
			{
				writer.WriteSerializedArray(ScriptTypes);
			}
			writer.WriteSerializedArray(Externals);
			if (HasRefTypes(writer.Generation))
			{
				writer.WriteSerializedTypeArray(RefTypes, EnableTypeTree);
			}
			if (HasUserInformation(writer.Generation))
			{
				writer.WriteStringZeroTerm(UserInformation);
			}
		}

		public UnityVersion UnityVersion { get; set; }
		public BuildTarget TargetPlatform { get; set; }
		public bool EnableTypeTree { get; set; }
		public SerializedType[] Types { get; set; } = Array.Empty<SerializedType>();
		/// <summary>
		/// Indicate that <see cref="ObjectInfo.FileID"/> is 8 bytes size<br/>
		/// Serialized files with this enabled field doesn't exist
		/// </summary>
		public uint LongFileID { get; set; }
		public bool SwapEndianess { get; set; }
		public ObjectInfo[] Object { get; set; } = Array.Empty<ObjectInfo>();
		public LocalSerializedObjectIdentifier[] ScriptTypes { get; set; } = Array.Empty<LocalSerializedObjectIdentifier>();
		public FileIdentifier[] Externals { get; set; } = Array.Empty<FileIdentifier>();
		public string UserInformation { get; set; } = "";
		public SerializedTypeReference[] RefTypes { get; set; } = Array.Empty<SerializedTypeReference>();
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/SerializedType.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	public sealed class SerializedType : SerializedTypeBase
	{
		public int[] TypeDependencies { get; set; } = Array.Empty<int>();

		private static bool HasScriptID(FormatVersion generation, int typeID)
		{
			//Temporary solution to #296
			return typeID == 114;//MonoBehaviour
								 //Previous code:
								 //(generation < FormatVersion.RefactoredClassId && typeID < 0)
								 //|| (generation >= FormatVersion.RefactoredClassId && typeID == ClassIDType.MonoBehaviour);
		}

		public override void Read(SerializedReader reader, bool hasTypeTree)
		{
			base.Read(reader, hasTypeTree);

			if (HasHash(reader.Generation))
			{
				if (HasScriptID(reader.Generation, TypeID))
				{
					ScriptID = reader.ReadBytes(16);
				}
				OldTypeHash = reader.ReadBytes(16);
			}

			if (hasTypeTree)
			{
				OldType.Read(reader);
				if (HasTypeDependencies(reader.Generation))
				{
					TypeDependencies = reader.ReadInt32Array();
				}
			}
		}

		public override void Write(SerializedWriter writer, bool hasTypeTree)
		{
			base.Write(writer, hasTypeTree);

			if (HasHash(writer.Generation))
			{
				if (HasScriptID(writer.Generation, TypeID))
				{
					writer.Write(ScriptID);
				}
				writer.Write(OldTypeHash);
			}

			if (hasTypeTree)
			{
				OldType.Write(writer);
				if (HasTypeDependencies(writer.Generation))
				{
					writer.WriteArray(TypeDependencies);
				}
			}
		}
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/SerializedTypeBase.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	public abstract class SerializedTypeBase
	{
		public int TypeID { get; set; }
		public bool IsStrippedType { get; set; }
		/// <summary>
		/// For <see cref="ClassIDType.MonoBehaviour"/> specifies script type
		/// </summary>
		public short ScriptTypeIndex { get; set; }
		/// <summary>
		/// The type of the class.
		/// </summary>
		public TypeTrees.TypeTree OldType { get; } = new();
		/// <summary>
		/// Hash128
		/// </summary>
		public byte[] ScriptID { get; set; } = Array.Empty<byte>();
		public byte[] OldTypeHash { get; set; } = Array.Empty<byte>();

		public virtual void Read(SerializedReader reader, bool hasTypeTree)
		{
			if (HasScriptTypeIndex(reader.Generation))
			{
				TypeID = reader.ReadInt32();
			}
			else
			{
				OriginalTypeID = reader.ReadInt32();
			}
			if (HasIsStrippedType(reader.Generation))
			{
				IsStrippedType = reader.ReadBoolean();
			}
			if (HasScriptTypeIndex(reader.Generation))
			{
				ScriptTypeIndex = reader.ReadInt16();
			}
		}

		public virtual void Write(SerializedWriter writer, bool hasTypeTree)
		{
			if (HasScriptTypeIndex(writer.Generation))
			{
				writer.Write(TypeID);
			}
			else
			{
				writer.Write(OriginalTypeID);
			}
			if (HasIsStrippedType(writer.Generation))
			{
				writer.Write(IsStrippedType);
			}
			if (HasScriptTypeIndex(writer.Generation))
			{
				writer.Write(ScriptTypeIndex);
			}
		}

		public override string ToString()
		{
			return TypeID.ToString();
		}

		/// <summary>
		/// For versions less than 17, it specifies <see cref="TypeID"/> or -<see cref="ScriptTypeIndex"/> -1 for MonoBehaviour
		/// </summary>
		public int OriginalTypeID
		{
			get
			{
				return TypeID == 114 ? -(ScriptTypeIndex + 1) : TypeID;
			}
			set
			{
				if (value >= 0)
				{
					TypeID = value;
					ScriptTypeIndex = -1;
				}
				else
				{
					TypeID = 114; //MonoBehaviour
					ScriptTypeIndex = (short)(-value - 1);
				}
			}
		}

		/// <summary>
		/// 5.5.0a and greater, ie format version 16+
		/// </summary>
		public static bool HasIsStrippedType(FormatVersion generation) => generation >= FormatVersion.RefactoredClassId;
		/// <summary>
		/// 5.5.0 and greater, ie format version 17+
		/// </summary>
		public static bool HasScriptTypeIndex(FormatVersion generation) => generation >= FormatVersion.RefactorTypeData;
		/// <summary>
		/// 5.0.0unk2 and greater, ie format version 13+
		/// </summary>
		public static bool HasHash(FormatVersion generation) => generation >= FormatVersion.HasTypeTreeHashes;
		/// <summary>
		/// 2019.3 and greater, ie format version 21+
		/// </summary>
		public static bool HasTypeDependencies(FormatVersion generation) => generation >= FormatVersion.StoresTypeDependencies;
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/SerializedTypeReference.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	public sealed class SerializedTypeReference : SerializedTypeBase
	{
		public string ClassName { get; set; } = "";
		public string NameSpace { get; set; } = "";
		public string AsmName { get; set; } = "";

		public override void Read(SerializedReader reader, bool hasTypeTree)
		{
			base.Read(reader, hasTypeTree);

			if (HasHash(reader.Generation))
			{
				if (HasScriptID(ScriptTypeIndex, reader.Generation, TypeID))
				{
					ScriptID = reader.ReadBytes(16);
				}
				OldTypeHash = reader.ReadBytes(16);
			}

			if (hasTypeTree)
			{
				OldType.Read(reader);
				if (HasTypeDependencies(reader.Generation))
				{
					ClassName = reader.ReadStringZeroTerm();
					NameSpace = reader.ReadStringZeroTerm();
					AsmName = reader.ReadStringZeroTerm();
				}
			}
		}

		public override void Write(SerializedWriter writer, bool hasTypeTree)
		{
			base.Write(writer, hasTypeTree);

			if (HasHash(writer.Generation))
			{
				if (HasScriptID(ScriptTypeIndex, writer.Generation, TypeID))
				{
					writer.Write(ScriptID);
				}
				writer.Write(OldTypeHash);
			}

			if (hasTypeTree)
			{
				OldType.Write(writer);
				if (HasTypeDependencies(writer.Generation))
				{
					writer.WriteStringZeroTerm(ClassName);
					writer.WriteStringZeroTerm(NameSpace);
					writer.WriteStringZeroTerm(AsmName);
				}
			}
		}

		private static bool HasScriptID(short scriptTypeIndex, FormatVersion generation, int typeID)
		{
			//Temporary solution to #296
			return scriptTypeIndex >= 0 || typeID == 114;//MonoBehaviour
														 //Previous code:
														 //(scriptTypeIndex >= 0)
														 //|| (generation < FormatVersion.RefactoredClassId && typeID < 0)
														 //|| (generation >= FormatVersion.RefactoredClassId && typeID == ClassIDType.MonoBehaviour);
		}
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/TransferMetaFlags.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.IO.Files.SerializedFiles.Parser
{
	[Flags]
	public enum TransferMetaFlags : uint
	{
		NoTransferFlags = 0x0,
		HideInEditor = 0x1,
		Unknown1 = 0x2,
		Unknown2 = 0x4,
		Unknown3 = 0x8,
		NotEditable = 0x10,
		Unknown5 = 0x20,
		StrongPPtr = 0x40,
		Unknown7 = 0x80,
		TreatIntegerValueAsBoolean = 0x100,
		Unknown9 = 0x200,
		Unknown10 = 0x400,
		SimpleEditor = 0x800,
		DebugProperty = 0x1000,
		Unknown13 = 0x2000,
		AlignBytes = 0x4000,
		AnyChildUsesAlignBytes = 0x8000,
		IgnoreWithInspectorUndo = 0x10000,
		Unknown17 = 0x20000,
		EditorDisplaysCharacterMap = 0x40000,
		IgnoreInMetaFiles = 0x80000,
		TransferAsArrayEntryNameInMetaFiles = 0x100000,
		TransferUsingFlowMappingStyle = 0x200000,
		GenerateBitwiseDifferences = 0x400000,
		DontAnimate = 0x800000,
		TransferHex64 = 0x1000000,
		CharPropertyMask = 0x2000000,
		DontValidateUTF8 = 0x4000000,
		FixedBuffer = 0x8000000,
		DisallowSerializedPropertyModification = 0x10000000,
		Unknown29 = 0x20000000,
		Unknown30 = 0x40000000,
		Unknown31 = 0x80000000,
	}

	public static class TransferMetaFlagsExtensions
	{
		public static bool IsHideInEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.HideInEditor) != 0;
		public static bool IsNotEditable(this TransferMetaFlags _this) => (_this & TransferMetaFlags.NotEditable) != 0;
		public static bool IsStrongPPtr(this TransferMetaFlags _this) => (_this & TransferMetaFlags.StrongPPtr) != 0;
		public static bool IsTreatIntegerValueAsBoolean(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TreatIntegerValueAsBoolean) != 0;
		public static bool IsSimpleEditor(this TransferMetaFlags _this) => (_this & TransferMetaFlags.SimpleEditor) != 0;
		public static bool IsDebugProperty(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DebugProperty) != 0;
		public static bool IsAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AlignBytes) != 0;
		public static bool IsAnyChildUsesAlignBytes(this TransferMetaFlags _this) => (_this & TransferMetaFlags.AnyChildUsesAlignBytes) != 0;
		public static bool IsIgnoreWithInspectorUndo(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreWithInspectorUndo) != 0;
		public static bool IsEditorDisplaysCharacterMap(this TransferMetaFlags _this) => (_this & TransferMetaFlags.EditorDisplaysCharacterMap) != 0;
		public static bool IsIgnoreInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.IgnoreInMetaFiles) != 0;
		public static bool IsTransferAsArrayEntryNameInMetaFiles(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles) != 0;
		public static bool IsTransferUsingFlowMappingStyle(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferUsingFlowMappingStyle) != 0;
		public static bool IsGenerateBitwiseDifferences(this TransferMetaFlags _this) => (_this & TransferMetaFlags.GenerateBitwiseDifferences) != 0;
		public static bool IsDontAnimate(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontAnimate) != 0;
		public static bool IsTransferHex64(this TransferMetaFlags _this) => (_this & TransferMetaFlags.TransferHex64) != 0;
		public static bool IsCharPropertyMask(this TransferMetaFlags _this) => (_this & TransferMetaFlags.CharPropertyMask) != 0;
		public static bool IsDontValidateUTF8(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DontValidateUTF8) != 0;
		public static bool IsFixedBuffer(this TransferMetaFlags _this) => (_this & TransferMetaFlags.FixedBuffer) != 0;
		public static bool IsDisallowSerializedPropertyModification(this TransferMetaFlags _this) => (_this & TransferMetaFlags.DisallowSerializedPropertyModification) != 0;
		public static IEnumerable<string> Split(this TransferMetaFlags flags)
		{
			if (flags == TransferMetaFlags.NoTransferFlags)
			{
				yield return nameof(TransferMetaFlags.NoTransferFlags);
			}
			else
			{
				if (flags.HasFlag(TransferMetaFlags.HideInEditor))
				{
					yield return nameof(TransferMetaFlags.HideInEditor);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown1))
				{
					yield return nameof(TransferMetaFlags.Unknown1);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown2))
				{
					yield return nameof(TransferMetaFlags.Unknown2);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown3))
				{
					yield return nameof(TransferMetaFlags.Unknown3);
				}

				if (flags.HasFlag(TransferMetaFlags.NotEditable))
				{
					yield return nameof(TransferMetaFlags.NotEditable);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown5))
				{
					yield return nameof(TransferMetaFlags.Unknown5);
				}

				if (flags.HasFlag(TransferMetaFlags.StrongPPtr))
				{
					yield return nameof(TransferMetaFlags.StrongPPtr);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown7))
				{
					yield return nameof(TransferMetaFlags.Unknown7);
				}

				if (flags.HasFlag(TransferMetaFlags.TreatIntegerValueAsBoolean))
				{
					yield return nameof(TransferMetaFlags.TreatIntegerValueAsBoolean);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown9))
				{
					yield return nameof(TransferMetaFlags.Unknown9);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown10))
				{
					yield return nameof(TransferMetaFlags.Unknown10);
				}

				if (flags.HasFlag(TransferMetaFlags.SimpleEditor))
				{
					yield return nameof(TransferMetaFlags.SimpleEditor);
				}

				if (flags.HasFlag(TransferMetaFlags.DebugProperty))
				{
					yield return nameof(TransferMetaFlags.DebugProperty);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown13))
				{
					yield return nameof(TransferMetaFlags.Unknown13);
				}

				if (flags.HasFlag(TransferMetaFlags.AlignBytes))
				{
					yield return nameof(TransferMetaFlags.AlignBytes);
				}

				if (flags.HasFlag(TransferMetaFlags.AnyChildUsesAlignBytes))
				{
					yield return nameof(TransferMetaFlags.AnyChildUsesAlignBytes);
				}

				if (flags.HasFlag(TransferMetaFlags.IgnoreWithInspectorUndo))
				{
					yield return nameof(TransferMetaFlags.IgnoreWithInspectorUndo);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown17))
				{
					yield return nameof(TransferMetaFlags.Unknown17);
				}

				if (flags.HasFlag(TransferMetaFlags.EditorDisplaysCharacterMap))
				{
					yield return nameof(TransferMetaFlags.EditorDisplaysCharacterMap);
				}

				if (flags.HasFlag(TransferMetaFlags.IgnoreInMetaFiles))
				{
					yield return nameof(TransferMetaFlags.IgnoreInMetaFiles);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles))
				{
					yield return nameof(TransferMetaFlags.TransferAsArrayEntryNameInMetaFiles);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferUsingFlowMappingStyle))
				{
					yield return nameof(TransferMetaFlags.TransferUsingFlowMappingStyle);
				}

				if (flags.HasFlag(TransferMetaFlags.GenerateBitwiseDifferences))
				{
					yield return nameof(TransferMetaFlags.GenerateBitwiseDifferences);
				}

				if (flags.HasFlag(TransferMetaFlags.DontAnimate))
				{
					yield return nameof(TransferMetaFlags.DontAnimate);
				}

				if (flags.HasFlag(TransferMetaFlags.TransferHex64))
				{
					yield return nameof(TransferMetaFlags.TransferHex64);
				}

				if (flags.HasFlag(TransferMetaFlags.CharPropertyMask))
				{
					yield return nameof(TransferMetaFlags.CharPropertyMask);
				}

				if (flags.HasFlag(TransferMetaFlags.DontValidateUTF8))
				{
					yield return nameof(TransferMetaFlags.DontValidateUTF8);
				}

				if (flags.HasFlag(TransferMetaFlags.FixedBuffer))
				{
					yield return nameof(TransferMetaFlags.FixedBuffer);
				}

				if (flags.HasFlag(TransferMetaFlags.DisallowSerializedPropertyModification))
				{
					yield return nameof(TransferMetaFlags.DisallowSerializedPropertyModification);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown29))
				{
					yield return nameof(TransferMetaFlags.Unknown29);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown30))
				{
					yield return nameof(TransferMetaFlags.Unknown30);
				}

				if (flags.HasFlag(TransferMetaFlags.Unknown31))
				{
					yield return nameof(TransferMetaFlags.Unknown31);
				}
			}
		}
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/CommonString.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees
{
	public static class CommonString
	{
		public static readonly Dictionary<uint, string> StringBuffer = new Dictionary<uint, string>
		{
			{0, "AABB"},
			{5, "AnimationClip"},
			{19, "AnimationCurve"},
			{34, "AnimationState"},
			{49, "Array"},
			{55, "Base"},
			{60, "BitField"},
			{69, "bitset"},
			{76, "bool"},
			{81, "char"},
			{86, "ColorRGBA"},
			{96, "Component"},
			{106, "data"},
			{111, "deque"},
			{117, "double"},
			{124, "dynamic_array"},
			{138, "FastPropertyName"},
			{155, "first"},
			{161, "float"},
			{167, "Font"},
			{172, "GameObject"},
			{183, "Generic Mono"},
			{196, "GradientNEW"},
			{208, "GUID"},
			{213, "GUIStyle"},
			{222, "int"},
			{226, "list"},
			{231, "long long"},
			{241, "map"},
			{245, "Matrix4x4f"},
			{256, "MdFour"},
			{263, "MonoBehaviour"},
			{277, "MonoScript"},
			{288, "m_ByteSize"},
			{299, "m_Curve"},
			{307, "m_EditorClassIdentifier"},
			{331, "m_EditorHideFlags"},
			{349, "m_Enabled"},
			{359, "m_ExtensionPtr"},
			{374, "m_GameObject"},
			{387, "m_Index"},
			{395, "m_IsArray"},
			{405, "m_IsStatic"},
			{416, "m_MetaFlag"},
			{427, "m_Name"},
			{434, "m_ObjectHideFlags"},
			{452, "m_PrefabInternal"},
			{469, "m_PrefabParentObject"},
			{490, "m_Script"},
			{499, "m_StaticEditorFlags"},
			{519, "m_Type"},
			{526, "m_Version"},
			{536, "Object"},
			{543, "pair"},
			{548, "PPtr<Component>"},
			{564, "PPtr<GameObject>"},
			{581, "PPtr<Material>"},
			{596, "PPtr<MonoBehaviour>"},
			{616, "PPtr<MonoScript>"},
			{633, "PPtr<Object>"},
			{646, "PPtr<Prefab>"},
			{659, "PPtr<Sprite>"},
			{672, "PPtr<TextAsset>"},
			{688, "PPtr<Texture>"},
			{702, "PPtr<Texture2D>"},
			{718, "PPtr<Transform>"},
			{734, "Prefab"},
			{741, "Quaternionf"},
			{753, "Rectf"},
			{759, "RectInt"},
			{767, "RectOffset"},
			{778, "second"},
			{785, "set"},
			{789, "short"},
			{795, "size"},
			{800, "SInt16"},
			{807, "SInt32"},
			{814, "SInt64"},
			{821, "SInt8"},
			{827, "staticvector"},
			{840, "string"},
			{847, "TextAsset"},
			{857, "TextMesh"},
			{866, "Texture"},
			{874, "Texture2D"},
			{884, "Transform"},
			{894, "TypelessData"},
			{907, "UInt16"},
			{914, "UInt32"},
			{921, "UInt64"},
			{928, "UInt8"},
			{934, "unsigned int"},
			{947, "unsigned long long"},
			{966, "unsigned short"},
			{981, "vector"},
			{988, "Vector2f"},
			{997, "Vector3f"},
			{1006, "Vector4f"},
			{1015, "m_ScriptingClassIdentifier"},
			{1042, "Gradient"},
			{1051, "Type*"},
			{1057, "int2_storage"},
			{1070, "int3_storage"},
			{1083, "BoundsInt"},
			{1093, "m_CorrespondingSourceObject"},
			{1121, "m_PrefabInstance"},
			{1138, "m_PrefabAsset"},
			{1152, "FileSize"},
			{1161, "Hash128"}
		};
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/TypeTree.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.IO;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees
{
	public sealed class TypeTree : ISerializedReadable, ISerializedWritable
	{
		public void Read(SerializedReader reader)
		{
			if (TypeTreeNode.IsFormat5(reader.Generation))
			{
				IsFormat5 = true;

				int nodesCount = reader.ReadInt32();
				if (nodesCount < 0)
				{
					throw new InvalidDataException($"Node count cannot be negative: {nodesCount}");
				}

				int stringBufferSize = reader.ReadInt32();
				if (stringBufferSize < 0)
				{
					throw new InvalidDataException($"String buffer size cannot be negative: {stringBufferSize}");
				}

				Nodes.Clear();
				Nodes.Capacity = nodesCount;
				for (int i = 0; i < nodesCount; i++)
				{
					TypeTreeNode node = new TypeTreeNode();
					node.Read(reader);
					Nodes.Add(node);
				}
				if (stringBufferSize == 0)
				{
					StringBuffer = Array.Empty<byte>();
				}
				else
				{
					StringBuffer = new byte[stringBufferSize];
					reader.Read(StringBuffer, 0, StringBuffer.Length);
				}
			}
			else
			{
				IsFormat5 = false;
				Nodes.Clear();
				ReadTreeNode(reader, Nodes, 0);
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (TypeTreeNode.IsFormat5(writer.Generation))
			{
				writer.Write(Nodes.Count);
				writer.Write(StringBuffer.Length);
				foreach (TypeTreeNode node in Nodes)
				{
					node.Write(writer);
				}
				writer.Write(StringBuffer, 0, StringBuffer.Length);
			}
			else
			{
				int index = 0;
				WriteTreeNode(writer, ref index);
			}
		}

		private static void ReadTreeNode(SerializedReader reader, ICollection<TypeTreeNode> nodes, byte depth)
		{
			TypeTreeNode node = new TypeTreeNode();
			node.Read(reader);
			node.Level = depth;
			nodes.Add(node);

			int childCount = reader.ReadInt32();
			for (int i = 0; i < childCount; i++)
			{
				ReadTreeNode(reader, nodes, (byte)(depth + 1));
			}
		}

		private void WriteTreeNode(SerializedWriter writer, ref int index)
		{
			Nodes[index].Write(writer);
			int childCount = GetChildCount(index);
			writer.Write(childCount);
			index++;
			for (int i = 0; i < childCount; i++)
			{
				WriteTreeNode(writer, ref index);
			}
		}

		public override string? ToString()
		{
			if (Nodes == null)
			{
				return base.ToString();
			}

			return Nodes[0].ToString();
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			if (Nodes != null)
			{
				foreach (TypeTreeNode node in Nodes)
				{
					node.ToString(sb).AppendLine();
				}
			}
			return sb;
		}

		private int GetChildCount(int index)
		{
			int count = 0;
			int depth = Nodes[index].Level + 1;
			for (int i = index + 1; i < Nodes.Count; i++)
			{
				int nodeDepth = Nodes[i].Level;
				if (nodeDepth < depth)
				{
					break;
				}
				if (nodeDepth == depth)
				{
					count++;
				}
			}
			return count;
		}

		public string Dump
		{
			get
			{
				StringBuilder sb = new StringBuilder();
				ToString(sb);
				return sb.ToString();
			}
		}

		public void MaybeSetNamesFromBuffer()
		{
			if (IsFormat5)
			{
				Dictionary<uint, string> customTypes = new Dictionary<uint, string>();
				using (MemoryStream stream = new MemoryStream(StringBuffer))
				{
					using EndianReader reader = new EndianReader(stream, EndianType.LittleEndian);
					while (stream.Position < stream.Length)
					{
						uint position = (uint)stream.Position;
						string name = reader.ReadStringZeroTerm();
						customTypes.Add(position, name);
					}
				}

				foreach (TypeTreeNode node in Nodes)
				{
					node.Type = GetTypeName(customTypes, node.TypeStrOffset);
					node.Name = GetTypeName(customTypes, node.NameStrOffset);
				}
			}
		}

		private static string GetTypeName(Dictionary<uint, string> customTypes, uint value)
		{
			bool isCustomType = (value & 0x80000000) == 0;
			if (isCustomType)
			{
				return customTypes[value];
			}
			else
			{
				uint offset = value & ~0x80000000;
				if (CommonString.StringBuffer.TryGetValue(offset, out string? nodeTypeName))
				{
					return nodeTypeName;
				}
				else
				{
					throw new Exception($"Unsupported asset class type name '{offset}''");
				}
			}
		}

		public List<TypeTreeNode> Nodes { get; } = new();
		public byte[] StringBuffer { get; set; } = Array.Empty<byte>();
		/// <summary>
		/// 5.0.0a1 and greater<br/>
		/// Generation 10
		/// </summary>
		private bool IsFormat5 { get; set; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/Parser/TypeTrees/TypeTreeNode.cs`:

```cs
using AssetRipper.IO.Files.SerializedFiles.IO;
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles.Parser.TypeTrees
{
	public class TypeTreeNode : ISerializedReadable, ISerializedWritable
	{
		/// <summary>
		/// 5.0.0a1 and greater<br/>
		/// Generation 10
		/// </summary>
		public static bool IsFormat5(FormatVersion generation) => generation >= FormatVersion.Unknown_10;
		/// <summary>
		/// 2019.1 and greater<br/>
		/// Generation 19
		/// </summary>
		public static bool HasRefTypeHash(FormatVersion generation) => generation >= FormatVersion.TypeTreeNodeWithTypeFlags;

		public TypeTreeNode() { }

		public TypeTreeNode(string type, string name, int level, bool align)
		{
			Type = type;
			Name = name;
			Level = (byte)level;
			MetaFlag = align ? TransferMetaFlags.AlignBytes : TransferMetaFlags.NoTransferFlags;
		}

		public TypeTreeNode(string type, string name, int level, int byteSize, int index, int version, int typeFlags, TransferMetaFlags metaFlag)
		{
			Type = type;
			Name = name;
			Level = (byte)level;
			ByteSize = byteSize;
			Index = index;
			Version = version;
			TypeFlags = typeFlags;
			MetaFlag = metaFlag;
		}

		public void Read(SerializedReader reader)
		{
			if (IsFormat5(reader.Generation))
			{
				Version = reader.ReadUInt16();
				Level = reader.ReadByte();
				TypeFlags = reader.ReadByte();
				TypeStrOffset = reader.ReadUInt32();
				NameStrOffset = reader.ReadUInt32();
				ByteSize = reader.ReadInt32();
				Index = reader.ReadInt32();
				MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
				if (HasRefTypeHash(reader.Generation))
				{
					RefTypeHash = reader.ReadUInt64();
				}
			}
			else
			{
				Type = reader.ReadStringZeroTerm();
				Name = reader.ReadStringZeroTerm();
				ByteSize = reader.ReadInt32();
				Index = reader.ReadInt32();
				TypeFlags = reader.ReadInt32();
				Version = reader.ReadInt32();
				MetaFlag = (TransferMetaFlags)reader.ReadUInt32();
			}
		}

		public void Write(SerializedWriter writer)
		{
			if (IsFormat5(writer.Generation))
			{
				writer.Write((ushort)Version);
				writer.Write(Level);
				writer.Write((byte)TypeFlags);
				writer.Write(TypeStrOffset);
				writer.Write(NameStrOffset);
				writer.Write(ByteSize);
				writer.Write(Index);
				writer.Write((uint)MetaFlag);
				if (HasRefTypeHash(writer.Generation))
				{
					writer.Write(RefTypeHash);
				}
			}
			else
			{
				writer.WriteStringZeroTerm(Type);
				writer.WriteStringZeroTerm(Name);
				writer.Write(ByteSize);
				writer.Write(Index);
				writer.Write(TypeFlags);
				writer.Write(Version);
				writer.Write((uint)MetaFlag);
			}
		}

		public override string? ToString()
		{
			if (Type == null)
			{
				return base.ToString();
			}
			else
			{
				return $"{Type} {Name}";
			}
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			sb.Append('\t', Level).Append(Type).Append(' ').Append(Name);
			sb.AppendFormat(" // ByteSize{0}{1:x}{2}, Index{3}{4:x}{5}, Version{6}{7:x}{8}, IsArray{{{9}}}, MetaFlag{10}{11:x}{12}",
					"{", ByteSize, "}",
					"{", Index, "}",
					"{", Version, "}",
					TypeFlags,
					"{", (uint)MetaFlag, "}");
			return sb;
		}

		/// <summary>
		/// Field type version, starts with 1 and is incremented after the type information has been significantly updated in a new release.<br/>
		/// Equal to serializedVersion in Yaml format files
		/// </summary>
		public int Version { get; set; }
		/// <summary>
		/// Depth of current type relative to root
		/// </summary>
		public byte Level { get; set; }
		/// <summary>
		/// Array flag, set to 1 if type is "Array" or "TypelessData".
		/// </summary>
		public int TypeFlags { get; set; }
		/// <summary>
		/// Type offset in <see cref="TypeTree.StringBuffer"/>
		/// </summary>
		public uint TypeStrOffset { get; set; }
		/// <summary>
		/// Name offset in <see cref="TypeTree.StringBuffer"/>
		/// </summary>
		public uint NameStrOffset { get; set; }
		/// <summary>
		/// Name of the data type. This can be the name of any substructure or a static predefined type.
		/// </summary>
		public string Type { get; set; } = "";
		/// <summary>
		/// Name of the field.
		/// </summary>
		public string Name { get; set; } = "";
		/// <summary>
		/// Size of the data value in bytes, e.g. 4 for int. -1 means that there is an array somewhere inside its hierarchy<br/>
		/// Note: The padding for the alignment is not included in the size.
		/// </summary>
		public int ByteSize { get; set; }
		/// <summary>
		/// Index of the field that is unique within a tree.<br/>
		/// Normally starts with 0 and is incremented with each additional field.
		/// </summary>
		public int Index { get; set; }
		/// <summary>
		/// Metaflags of the field
		/// </summary>
		public TransferMetaFlags MetaFlag { get; set; }
		public ulong RefTypeHash { get; set; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/SerializedFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Streams.MultiFile;
using AssetRipper.IO.Files.Streams.Smart;
using AssetRipper.IO.Files.Utils;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.IO.Files.SerializedFiles
{
	/// <summary>
	/// Serialized files contain binary serialized objects and optional run-time type information.
	/// They have file name extensions like .asset, .assets, .sharedAssets but may also have no extension at all
	/// </summary>
	public sealed class SerializedFile
	{
		public string Name { get; }
		public string NameOrigin { get; }
		public string FilePath { get; }
		public SerializedFileHeader Header { get; }
		public SerializedFileMetadata Metadata { get; }
		public UnityVersion Version { get; set; }
		public BuildTarget Platform { get; set; }

		public IReadOnlyList<FileIdentifier> Dependencies => Metadata.Externals;
		private readonly Dictionary<long, int> m_assetEntryLookup = new();
		internal SerializedFile(SerializedFileScheme scheme)
		{
			FilePath = scheme.FilePath;
			NameOrigin = scheme.Name;
			Name = FilenameUtils.FixFileIdentifier(scheme.Name);

			Header = scheme.Header;
			Metadata = scheme.Metadata;

			for (int i = 0; i < Metadata.Object.Length; i++)
			{
				m_assetEntryLookup.Add(Metadata.Object[i].FileID, i);
			}
		}

		public static bool IsSerializedFile(string filePath) => IsSerializedFile(MultiFileStream.OpenRead(filePath));
		public static bool IsSerializedFile(byte[] buffer, int offset, int size) => IsSerializedFile(new MemoryStream(buffer, offset, size, false));
		public static bool IsSerializedFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return SerializedFileHeader.IsSerializedFileHeader(reader, stream.Length);
		}

		public static SerializedFileScheme LoadScheme(string filePath)
		{
			string fileName = Path.GetFileNameWithoutExtension(filePath);
			using SmartStream fileStream = SmartStream.OpenRead(filePath);
			return ReadScheme(fileStream, filePath, fileName);
		}

		public static SerializedFileScheme ReadScheme(byte[] buffer, string filePath, string fileName)
		{
			return SerializedFileScheme.ReadSceme(buffer, filePath, fileName);
		}

		public static SerializedFileScheme ReadScheme(SmartStream stream, string filePath, string fileName)
		{
			return SerializedFileScheme.ReadSceme(stream, filePath, fileName);
		}

		public ObjectInfo GetAssetEntry(long pathID)
		{
			return Metadata.Object[m_assetEntryLookup[pathID]];
		}

		public override string ToString()
		{
			return Name;
		}

		public EndianType GetEndianType()
		{
			bool swapEndianess = SerializedFileHeader.HasEndianess(Header.Version) ? Header.Endianess : Metadata.SwapEndianess;
			return swapEndianess ? EndianType.BigEndian : EndianType.LittleEndian;
		}
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/SerializedFileException.cs`:

```cs
using System.Text;

namespace AssetRipper.IO.Files.SerializedFiles
{
	public sealed class SerializedFileException : Exception
	{
		public SerializedFileException(string message, UnityVersion version, BuildTarget platform, int classIdType, string fileName, string filePath) : base(message)
		{
			if (string.IsNullOrEmpty(fileName))
			{
				throw new ArgumentNullException(nameof(fileName));
			}
			if (string.IsNullOrEmpty(filePath))
			{
				throw new ArgumentNullException(nameof(filePath));
			}

			Version = version;
			Platform = platform;
			ClassIdType = classIdType;
			FileName = fileName;
			FilePath = filePath;
		}

		public SerializedFileException(string message, Exception innerException, UnityVersion version, BuildTarget platform, int classIdType, string fileName, string filePath) : base(message, innerException)
		{
			if (string.IsNullOrEmpty(fileName))
			{
				throw new ArgumentNullException(nameof(fileName));
			}
			if (string.IsNullOrEmpty(filePath))
			{
				throw new ArgumentNullException(nameof(filePath));
			}

			Version = version;
			Platform = platform;
			ClassIdType = classIdType;
			FileName = fileName;
			FilePath = filePath;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			sb.Append("SerializedFileException:");
			sb.Append(" v:").Append(Version.ToString());
			sb.Append(" p:").Append(Platform.ToString());
			sb.Append(" t:").Append(ClassIdType.ToString());
			sb.Append(" n:").Append(FileName).AppendLine();
			sb.Append("Path:").Append(FilePath).AppendLine();
			sb.Append("Message: ").Append(Message).AppendLine();
			if (InnerException != null)
			{
				sb.Append("Inner: ").Append(InnerException.ToString()).AppendLine();
			}
			sb.Append("StackTrace: ").Append(StackTrace);
			return sb.ToString();
		}

		public UnityVersion Version { get; }
		public BuildTarget Platform { get; }
		public int ClassIdType { get; }
		public string FileName { get; }
		public string FilePath { get; }
	}
}

```

`AssetRipper.IO.Files/SerializedFiles/SerializedFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Converters;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Extensions;
using AssetRipper.IO.Files.Schemes;
using AssetRipper.IO.Files.SerializedFiles.Parser;
using AssetRipper.IO.Files.Streams.Smart;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.IO.Files.SerializedFiles
{
	public sealed class SerializedFileScheme : FileScheme
	{
		private SerializedFileScheme(byte[] buffer, string filePath, string fileName) : base(filePath, fileName)
		{
			Stream = new MemoryStream(buffer, 0, buffer.Length, false);
		}

		private SerializedFileScheme(SmartStream stream, string filePath, string fileName) : base(filePath, fileName)
		{
			if (stream.Length <= int.MaxValue)
			{
				byte[] buffer = new byte[stream.Length];
				stream.ReadBuffer(buffer, 0, buffer.Length);
				Stream = new MemoryStream(buffer, 0, buffer.Length, false);
			}
			else
			{
				Stream = stream.CreateReference();
			}
		}

		internal static SerializedFileScheme ReadSceme(byte[] buffer, string filePath, string fileName)
		{
			SerializedFileScheme scheme = new SerializedFileScheme(buffer, filePath, fileName);
			scheme.ReadScheme();
			return scheme;
		}

		internal static SerializedFileScheme ReadSceme(SmartStream stream, string filePath, string fileName)
		{
			SerializedFileScheme scheme = new SerializedFileScheme(stream, filePath, fileName);
			scheme.ReadScheme();
			return scheme;
		}

		protected override void Dispose(bool disposing)
		{
			base.Dispose(disposing);
			if (Stream != null)
			{
				Stream.Dispose();
				Stream = null!;
			}
		}

		private void ReadScheme()
		{
			using (EndianReader reader = new EndianReader(Stream, EndianType.BigEndian))
			{
				Header.Read(reader);
			}
			if (SerializedFileMetadata.IsMetadataAtTheEnd(Header.Version))
			{
				Stream.Position = Header.FileSize - Header.MetadataSize;
			}
			Metadata.Read(Stream, Header);

			SerializedFileMetadataConverter.CombineFormats(Header.Version, Metadata);
		}

		public override FileEntryType SchemeType => FileEntryType.Serialized;
		public override IEnumerable<FileIdentifier> Dependencies => Metadata.Externals;

		public SerializedFileHeader Header { get; } = new SerializedFileHeader();
		public SerializedFileMetadata Metadata { get; } = new SerializedFileMetadata();
		public Stream Stream { get; private set; }
	}
}

```

`AssetRipper.IO.Files/Streams/MultiFile/MultiFileStream.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AssetRipper.IO.Files.Streams.MultiFile
{
	public sealed class MultiFileStream : Stream
	{
		public MultiFileStream(IEnumerable<Stream> streams)
		{
			if (streams == null)
			{
				throw new ArgumentNullException(nameof(streams));
			}
			foreach (Stream stream in streams)
			{
				if (stream == null)
				{
					throw new ArgumentNullException();
				}
				if (!stream.CanSeek)
				{
					throw new Exception($"Stream {stream} isn't seekable");
				}
			}

			m_streams = streams.ToArray();
			if (m_streams.Count == 0)
			{
				throw new ArgumentException(nameof(streams));
			}

			Length = streams.Sum(t => t.Length);
			CanRead = m_streams.All(t => t.CanRead);
			CanWrite = m_streams.All(t => t.CanWrite);
			UpdateCurrentStream();
		}

		~MultiFileStream()
		{
			Dispose(false);
		}

		/// <summary>
		/// Determines if the path could be part of a multi file
		/// </summary>
		/// <param name="path">The path to check</param>
		/// <returns>True if the path matches the multi file regex</returns>
		public static bool IsMultiFile(string path)
		{
			return s_splitCheck.IsMatch(path);
		}

		public static bool Exists(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return Exists(directory, file);
			}
			if (File.Exists(path))
			{
				return true;
			}

			{
				SplitPath(path, out string directory, out string file, true);
				if (string.IsNullOrEmpty(file))
				{
					return false;
				}
				else
				{
					return Exists(directory, file);
				}
			}
		}

		public static Stream OpenRead(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return OpenRead(directory, file);
			}
			if (File.Exists(path))
			{
				return File.OpenRead(path);
			}

			{
				SplitPath(path, out string directory, out string file);
				return OpenRead(directory, file);
			}
		}

		public static string GetFilePath(string path)
		{
			if (IsMultiFile(path))
			{
				int index = path.LastIndexOf('.');
				return path.Substring(0, index);
			}
			return path;
		}

		public static string GetFileName(string path)
		{
			if (IsMultiFile(path))
			{
				return Path.GetFileNameWithoutExtension(path);
			}
			return Path.GetFileName(path);
		}

		public static string[] GetFiles(string path)
		{
			if (IsMultiFile(path))
			{
				SplitPathWithoutExtension(path, out string directory, out string file);
				return GetFiles(directory, file);
			}

			if (File.Exists(path))
			{
				return new[] { path };
			}
			return Array.Empty<string>();
		}

		public static bool IsNameEquals(string fileName, string compare)
		{
			fileName = GetFileName(fileName);
			return fileName == compare;
		}

		/// <summary>
		/// Determines if a multi file exists
		/// </summary>
		/// <param name="dirPath">The directory containing the multi file</param>
		/// <param name="fileName">The name of the multi file without the split extension</param>
		/// <returns>True if a valid multi file exists in that directory with that name</returns>
		private static bool Exists(string dirPath, string fileName)
		{
			string filePath = Path.Combine(dirPath, fileName);
			string splitFilePath = filePath + ".split";

			string[] splitFiles = GetFiles(dirPath, fileName);
			if (splitFiles.Length == 0)
			{
				return false;
			}

			for (int i = 0; i < splitFiles.Length; i++)
			{
				string indexFileName = splitFilePath + i;
				if (!splitFiles.Contains(indexFileName))
				{
					return false;
				}
			}
			return true;
		}

		private static string[] GetFiles(string dirPath, string fileName)
		{
			if (!Directory.Exists(dirPath))
			{
				return Array.Empty<string>();
			}

			string filePatern = fileName + ".split*";
			return Directory.GetFiles(dirPath, filePatern);
		}

		private static Stream OpenRead(string dirPath, string fileName)
		{
			string filePath = Path.Combine(dirPath, fileName);
			string splitFilePath = filePath + ".split";

			string[] splitFiles = GetFiles(dirPath, fileName);
			for (int i = 0; i < splitFiles.Length; i++)
			{
				string indexFileName = splitFilePath + i;
				if (!splitFiles.Contains(indexFileName))
				{
					throw new Exception($"Try to open splited file part '{filePath}' but file part '{indexFileName}' wasn't found");
				}
			}

			splitFiles = splitFiles.OrderBy(t => t, s_splitNameComparer).ToArray();
			Stream[] streams = new Stream[splitFiles.Length];
			try
			{
				for (int i = 0; i < splitFiles.Length; i++)
				{
					Stream stream = File.OpenRead(splitFiles[i]);
					streams[i] = stream;
				}

				return new MultiFileStream(streams);
			}
			catch
			{
				foreach (Stream stream in streams)
				{
					if (stream == null)
					{
						break;
					}
					stream.Dispose();
				}
				throw;
			}
		}

		private static void SplitPath(string path, out string directory, out string file) => SplitPath(path, out directory, out file, false);
		private static void SplitPath(string path, out string directory, out string file, bool allowNullReturn)
		{
			directory = Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
			directory = string.IsNullOrEmpty(directory) ? "." : directory;
			file = Path.GetFileName(path);
			if (string.IsNullOrEmpty(file) && !allowNullReturn)
			{
				throw new Exception($"Can't determine file name for {path}");
			}
		}

		private static void SplitPathWithoutExtension(string path, out string directory, out string file)
		{
			directory = Path.GetDirectoryName(path) ?? throw new Exception("Could not get directory name");
			directory = string.IsNullOrEmpty(directory) ? "." : directory;
			file = Path.GetFileNameWithoutExtension(path);
			if (string.IsNullOrEmpty(file))
			{
				throw new Exception($"Can't determine file name for {path}");
			}
		}

		public override void Flush()
		{
			m_currentStream.Flush();
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			switch (origin)
			{
				case SeekOrigin.Begin:
					Position = offset;
					break;
				case SeekOrigin.Current:
					Position += offset;
					break;
				case SeekOrigin.End:
					Position = Length - offset;
					break;
			}
			return Position;
		}

		public override void SetLength(long value)
		{
			throw new NotSupportedException();
		}

		public override int ReadByte()
		{
			int value = m_currentStream.ReadByte();
			if (value >= 0)
			{
				m_position++;
				if (m_position == m_currentEnd)
				{
					NextStream();
				}
			}
			return value;
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			int read = m_currentStream.Read(buffer, offset, count);
			m_position += read;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}

			return read;
		}

		public override void WriteByte(byte value)
		{
			m_currentStream.WriteByte(value);
			m_position++;
			if (m_position == m_currentEnd)
			{
				NextStream();
			}
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			while (count > 0)
			{
				long available = m_currentEnd - m_position;
				int toWrite = count < available ? count : (int)available;
				m_currentStream.Write(buffer, offset, toWrite);
				m_position += toWrite;
				if (m_position == m_currentEnd)
				{
					NextStream();
				}

				offset += toWrite;
				count -= toWrite;
			}
		}

		protected override void Dispose(bool disposing)
		{
			foreach (Stream stream in m_streams)
			{
				stream.Dispose();
			}
			base.Dispose(disposing);
		}

		private void NextStream()
		{
			int nextStreamIndex = m_streamIndex + 1;
			if (nextStreamIndex < m_streams.Count)
			{
				m_currentBegin += m_currentStream.Length;
				m_streamIndex = nextStreamIndex;
				m_currentStream = m_streams[m_streamIndex];
				m_currentStream.Position = 0;
				m_currentEnd += m_currentStream.Length;
			}
		}

		private void UpdateCurrentStream()
		{
			m_currentBegin = 0;
			m_currentEnd = 0;
			for (int i = 0; i < m_streams.Count; i++)
			{
				m_streamIndex = i;
				m_currentStream = m_streams[m_streamIndex];
				m_currentEnd = m_currentBegin + m_currentStream.Length;
				if (m_currentEnd > m_position)
				{
					m_currentStream.Position = m_position - m_currentBegin;
					return;
				}

				m_currentBegin += m_currentStream.Length;
			}
			m_currentBegin -= m_currentStream.Length;
			m_currentStream.Position = m_position - m_currentBegin;
		}

		public override long Position
		{
			get => m_position;
			set
			{
				if (value < 0)
				{
					throw new ArgumentOutOfRangeException(nameof(value), value, null);
				}

				m_position = value;
				if (value < m_currentBegin || value >= m_currentEnd)
				{
					UpdateCurrentStream();
				}
				else
				{
					m_currentStream.Position = value - m_currentBegin;
				}
			}
		}

		public override long Length { get; }

		public override bool CanRead { get; }
		public override bool CanWrite { get; }
		public override bool CanSeek => true;

		private static readonly Regex s_splitCheck = new Regex($@".+{MultifileRegPostfix}[0-9]+$", RegexOptions.Compiled);
		private static readonly SplitNameComparer s_splitNameComparer = new SplitNameComparer();

		public const string MultifileRegPostfix = @"\.split";

		private readonly IReadOnlyList<Stream> m_streams;

		private Stream m_currentStream;
		private int m_streamIndex;
		private long m_position;
		private long m_currentBegin;
		private long m_currentEnd;
	}
}

```

`AssetRipper.IO.Files/Streams/MultiFile/SplitNameComparer.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.IO.Files.Streams.MultiFile
{
	public class SplitNameComparer : IComparer<string>
	{
		public int Compare(string? x, string? y)
		{
			int xNumber = GetSplitIndex(x);
			int yNumber = GetSplitIndex(y);
			return xNumber.CompareTo(yNumber);
		}

		private static int GetSplitIndex(string? value)
		{
			if (string.IsNullOrEmpty(value))
			{
				return -1;
			}

			int i;
			for (i = value.Length - 1; i >= 0; i--)
			{
				if (!char.IsDigit(value[i]))
				{
					i++;
					break;
				}
			}
			string number = value.Substring(i);
			return int.Parse(number);
		}
	}
}

```

`AssetRipper.IO.Files/Streams/Smart/SmartStream.cs`:

```cs
using AssetRipper.IO.Files.Streams.MultiFile;
using System.IO;

namespace AssetRipper.IO.Files.Streams.Smart
{
	public class SmartStream : Stream
	{
		private class SmartRefCount
		{
			public static SmartRefCount operator ++(SmartRefCount _this)
			{
				_this.RefCount++;
				return _this;
			}
			public static SmartRefCount operator --(SmartRefCount _this)
			{
				_this.RefCount--;
				return _this;
			}

			public void Increase()
			{
				RefCount++;
			}

			public void Decrease()
			{
				RefCount--;
			}

			public override string ToString()
			{
				return m_refCount.ToString();
			}

			public bool IsZero => RefCount == 0;

			private int RefCount
			{
				get => m_refCount;
				set
				{
					if (value < 0)
					{
						throw new ArgumentOutOfRangeException();
					}
					m_refCount = value;
				}
			}

			private int m_refCount = 0;
		}

		private SmartStream()
		{
			m_isDisposed = true;
		}

		private SmartStream(Stream baseStream, SmartStreamType type)
		{
			if (baseStream == null)
			{
				throw new ArgumentNullException(nameof(baseStream));
			}
			m_stream = baseStream;
			m_streamType = type;
			m_refCount = new SmartRefCount();
			m_refCount++;
		}

		private SmartStream(SmartStream copy)
		{
			Assign(copy);
		}

		~SmartStream()
		{
			Dispose(false);
		}

		public static SmartStream CreateNull()
		{
			return new SmartStream();
		}

		public static SmartStream OpenRead(string path)
		{
			return new SmartStream(MultiFileStream.OpenRead(path), SmartStreamType.File);
		}

		public static SmartStream CreateTemp()
		{
			string tempFile = Path.GetTempFileName();
			return new SmartStream(new FileStream(tempFile, FileMode.Open, FileAccess.ReadWrite, FileShare.None, 4096, FileOptions.DeleteOnClose), SmartStreamType.File);
		}

		public static SmartStream CreateMemory()
		{
			return new SmartStream(new MemoryStream(), SmartStreamType.Memory);
		}

		public static SmartStream CreateMemory(byte[] buffer)
		{
			return new SmartStream(new MemoryStream(buffer), SmartStreamType.Memory);
		}

		public static SmartStream CreateMemory(byte[] buffer, int offset, int size)
		{
			return new SmartStream(new MemoryStream(buffer, offset, size), SmartStreamType.Memory);
		}

		public void Assign(SmartStream source)
		{
			Dispose();

			m_stream = source.m_stream;
			m_streamType = source.m_streamType;
			m_refCount = source.m_refCount;
			m_isDisposed = source.m_isDisposed;
			if (m_isDisposed)
			{
				if (!IsNull)
				{
					throw new ObjectDisposedException(nameof(source));
				}
			}
			else
			{
				m_refCount++;
			}
		}

		public void Move(SmartStream source)
		{
			Assign(source);
			source.Dispose();
		}

		public SmartStream CreateReference()
		{
			return new SmartStream(this);
		}

		public override void Flush()
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.Flush();
		}

		public override int Read(byte[] buffer, int offset, int count)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			return m_stream.Read(buffer, offset, count);
		}

		public override long Seek(long offset, SeekOrigin origin)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			return m_stream.Seek(offset, origin);
		}

		public override void SetLength(long value)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.SetLength(value);
		}

		public override void Write(byte[] buffer, int offset, int count)
		{
			if (m_isDisposed)
			{
				throw new ObjectDisposedException(null);
			}
			m_stream.Write(buffer, offset, count);
		}

		protected override void Dispose(bool disposing)
		{
			if (!IsNull && !m_isDisposed)
			{
				m_refCount--;
				if (m_refCount.IsZero)
				{
					m_stream.Dispose();
				}
				m_isDisposed = true;
			}
			base.Dispose(disposing);
		}

		public override bool CanRead
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanRead;
			}
		}
		public override bool CanSeek
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanSeek;
			}
		}
		public override bool CanWrite
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.CanWrite;
			}
		}

		public override long Position
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.Position;
			}
			set
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				m_stream.Position = value;
			}
		}

		public override long Length
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_stream.Length;
			}
		}

		public SmartStreamType StreamType
		{
			get
			{
				if (m_isDisposed)
				{
					throw new ObjectDisposedException(null);
				}
				return m_streamType;
			}
		}

		public bool IsNull => m_stream == null;

		private SmartRefCount m_refCount;
		private Stream m_stream;
		private SmartStreamType m_streamType;
		private bool m_isDisposed;
	}
}

```

`AssetRipper.IO.Files/Streams/Smart/SmartStreamType.cs`:

```cs
namespace AssetRipper.IO.Files.Streams.Smart
{
	public enum SmartStreamType
	{
		File,
		Memory,
	}
}

```

`AssetRipper.IO.Files/Utils/FilenameUtils.cs`:

```cs
using System.IO;

namespace AssetRipper.IO.Files.Utils
{
	public static class FilenameUtils
	{
		public static bool IsEngineResource(string fileName)
		{
			return IsDefaultResource(fileName) || IsEditorResource(fileName);
		}

		public static bool IsDefaultResource(string fileName)
		{
			return fileName == DefaultResourceName1 || fileName == DefaultResourceName2;
		}

		public static bool IsEditorResource(string fileName)
		{
			return fileName == EditorResourceName;
		}

		public static bool IsBuiltinExtra(string fileName)
		{
			return fileName == BuiltinExtraName1 || fileName == BuiltinExtraName2;
		}

		public static bool IsEngineGeneratedF(string fileName)
		{
			return fileName == EngineGeneratedF;
		}

		public static string FixFileIdentifier(string name)
		{
			name = name.ToLower();
			name = FixDependencyName(name);
			name = FixResourcePath(name);
			if (IsDefaultResource(name))
			{
				name = DefaultResourceName1;
			}
			else if (IsBuiltinExtra(name))
			{
				name = BuiltinExtraName1;
			}
			return name;
		}

		public static string FixDependencyName(string dependency)
		{
			if (dependency.StartsWith(LibraryFolder, StringComparison.Ordinal))
			{
				return dependency.Substring(LibraryFolder.Length);
			}
			else if (dependency.StartsWith(ResourcesFolder, StringComparison.Ordinal))
			{
				return dependency.Substring(ResourcesFolder.Length);
			}
			return dependency;
		}

		public static string FixResourcePath(string resourcePath)
		{
			const string archivePrefix = "archive:/";
			if (resourcePath.StartsWith(archivePrefix, StringComparison.Ordinal))
			{
				resourcePath = Path.GetFileName(resourcePath);
			}
			return resourcePath;
		}

		public static string FixAssemblyName(string assembly)
		{
			if (IsAssemblyIdentifier(assembly))
			{
				assembly = $"Assembly - {assembly}";
			}
			assembly = FixAssemblyEndian(assembly);
			return assembly;
		}

		public static string FixAssemblyEndian(string assembly)
		{
			if (assembly.EndsWith(AssemblyExtension, StringComparison.Ordinal))
			{
				return assembly.Substring(0, assembly.Length - AssemblyExtension.Length);
			}
			return assembly;
		}

		public static bool IsProjectAssembly(string assembly)
		{
			const string PrefixName = "Assembly";
			return assembly.StartsWith($"{PrefixName} - ", StringComparison.Ordinal) || assembly.StartsWith($"{PrefixName}-", StringComparison.Ordinal);
		}

		private static bool IsAssemblyIdentifier(string assembly)
		{
			switch (assembly)
			{
				case "Boo":
				case "Boo - first pass":
				case "CSharp":
				case "CSharp - first pass":
				case "UnityScript":
				case "UnityScript - first pass":
					return true;

				default:
					return false;
			}
		}

		public const string LibraryFolder = "library/";
		public const string ResourcesFolder = "resources/";
		public const string DefaultResourceName1 = "unity default resources";
		public const string DefaultResourceName2 = "unity_default_resources";
		public const string EditorResourceName = "unity editor resources";
		public const string BuiltinExtraName1 = "unity builtin extra";
		public const string BuiltinExtraName2 = "unity_builtin_extra";
		public const string EngineGeneratedF = "0000000000000000f000000000000000";
		public const string AssemblyExtension = ".dll";
	}
}

```

`AssetRipper.IO.Files/WebFiles/WebFile.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Streams.MultiFile;
using AssetRipper.IO.Files.Streams.Smart;
using System.IO;

namespace AssetRipper.IO.Files.WebFiles
{
	public sealed class WebFile : FileList
	{
		internal WebFile(WebFileScheme scheme) : base(scheme.NameOrigin)
		{
			Header = scheme.Header;
			Metadata = scheme.Metadata;
		}

		public static bool IsWebFile(string webPath)
		{
			using Stream stream = MultiFileStream.OpenRead(webPath);
			return IsWebFile(stream);
		}

		public static bool IsWebFile(Stream stream)
		{
			using EndianReader reader = new EndianReader(stream, EndianType.BigEndian);
			return WebHeader.IsWebHeader(reader);
		}

		public static bool IsWebFile(byte[] buffer, int offset, int size)
		{
			using MemoryStream stream = new MemoryStream(buffer, offset, size, false);
			return IsWebFile(stream);
		}

		public static WebFileScheme ReadScheme(byte[] buffer, string filePath)
		{
			return WebFileScheme.ReadScheme(buffer, filePath);
		}

		public static WebFileScheme ReadScheme(SmartStream stream, string filePath)
		{
			return WebFileScheme.ReadScheme(stream, filePath);
		}

		public WebHeader Header { get; }
		public WebMetadata Metadata { get; }
	}
}

```

`AssetRipper.IO.Files/WebFiles/WebFileEntry.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Utils;

namespace AssetRipper.IO.Files.WebFiles
{
	public class WebFileEntry : FileEntry, IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			Offset = reader.ReadInt32();
			Size = reader.ReadInt32();
			NameOrigin = reader.ReadString();
			Name = FilenameUtils.FixFileIdentifier(NameOrigin);
		}
	}
}

```

`AssetRipper.IO.Files/WebFiles/WebFileScheme.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.IO.Files.Entries;
using AssetRipper.IO.Files.Extensions;
using AssetRipper.IO.Files.Schemes;
using System.IO;

namespace AssetRipper.IO.Files.WebFiles
{
	public sealed class WebFileScheme : FileSchemeList
	{
		private WebFileScheme(string filePath) : base(filePath, string.Empty) { }

		internal static WebFileScheme ReadScheme(byte[] buffer, string filePath)
		{
			WebFileScheme scheme = new WebFileScheme(filePath);
			using (MemoryStream stream = new MemoryStream(buffer, 0, buffer.Length, false))
			{
				scheme.ReadScheme(stream);
			}
			return scheme;
		}

		internal static WebFileScheme ReadScheme(Stream stream, string filePath)
		{
			WebFileScheme scheme = new WebFileScheme(filePath);
			scheme.ReadScheme(stream);
			return scheme;
		}

		private void ReadScheme(Stream stream)
		{
			using (EndianReader reader = new EndianReader(stream, EndianType.LittleEndian))
			{
				Header.Read(reader);
				Metadata.Read(reader);
			}

			foreach (WebFileEntry entry in Metadata.Entries)
			{
				byte[] buffer = new byte[entry.Size];
				stream.Position = entry.Offset;
				stream.ReadBuffer(buffer, 0, buffer.Length);
				FileScheme scheme = SchemeReader.ReadScheme(buffer, FilePath, entry.NameOrigin);
				AddScheme(scheme);
			}
		}

		public override FileEntryType SchemeType => FileEntryType.Web;

		public WebHeader Header { get; } = new WebHeader();
		public WebMetadata Metadata { get; } = new WebMetadata();
	}
}

```

`AssetRipper.IO.Files/WebFiles/WebHeader.cs`:

```cs
using AssetRipper.IO.Endian;

namespace AssetRipper.IO.Files.WebFiles
{
	public sealed class WebHeader : IEndianReadable
	{
		internal static bool IsWebHeader(EndianReader reader)
		{
			if (reader.BaseStream.Length - reader.BaseStream.Position > Signature.Length)
			{
				long position = reader.BaseStream.Position;
				bool isRead = reader.ReadStringZeroTerm(Signature.Length + 1, out string? signature);
				reader.BaseStream.Position = position;
				if (isRead)
				{
					return signature == Signature;
				}
			}
			return false;
		}

		public void Read(EndianReader reader)
		{
			string signature = reader.ReadStringZeroTerm();
			if (signature != Signature)
			{
				throw new Exception($"Signature '{signature}' doesn't match to '{Signature}'");
			}
		}

		private const string Signature = "UnityWebData1.0";
	}
}

```

`AssetRipper.IO.Files/WebFiles/WebMetadata.cs`:

```cs
using AssetRipper.IO.Endian;
using System.Collections.Generic;

namespace AssetRipper.IO.Files.WebFiles
{
	public class WebMetadata : IEndianReadable
	{
		public void Read(EndianReader reader)
		{
			List<WebFileEntry> entries = new List<WebFileEntry>();
			long metadataLength = reader.ReadInt32();
			while (reader.BaseStream.Position < metadataLength)
			{
				WebFileEntry entry = new WebFileEntry();
				entry.Read(reader);
				entries.Add(entry);
			}
			Entries = entries.ToArray();
		}

		public WebFileEntry[] Entries { get; set; } = Array.Empty<WebFileEntry>();
	}
}

```

`AssetRipper.SerializationLogic/AsmUtils.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;
using AssetRipper.SerializationLogic.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.SerializationLogic
{
	public static class AsmUtils
	{
		public static IEnumerable<TypeDefinition> AllInterfacesImplementedBy(TypeDefinition typeDefinition)
		{
			return TypeAndBaseTypesOf(typeDefinition).SelectMany(t => t.Interfaces).Select(i => i.Interface.CheckedResolve()).Distinct();
		}

		public static IEnumerable<TypeDefinition> TypeAndBaseTypesOf(ITypeDescriptor? typeReference)
		{
			while (typeReference != null)
			{
				TypeDefinition typeDefinition = typeReference.CheckedResolve();
				yield return typeDefinition;
				typeReference = typeDefinition.BaseType;
			}
		}

		public static IEnumerable<TypeDefinition> BaseTypesOf(ITypeDescriptor typeReference)
		{
			return TypeAndBaseTypesOf(typeReference).Skip(1);
		}

		public static bool IsGenericList(ITypeDescriptor type)
		{
			return type.Name == "List`1" && type.SafeNamespace() == "System.Collections.Generic";
		}

		public static bool IsGenericDictionary(ITypeDescriptor type)
		{
			if (type.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
			{
				type = genericInstanceTypeSignature.GenericType;
			}

			return type.Name == "Dictionary`2" && type.SafeNamespace() == "System.Collections.Generic";
		}

		public static TypeSignature ElementTypeOfCollection(TypeSignature type)
		{
			if (type is SzArrayTypeSignature szArrayTypeSignature)
			{
				return szArrayTypeSignature.BaseType;
			}

			if (type is ArrayTypeSignature arrayTypeSignature)
			{
				return arrayTypeSignature.BaseType;
			}

			if (IsGenericList(type))
			{
				return ((GenericInstanceTypeSignature)type).TypeArguments.Single();
			}

			throw new ArgumentException("", nameof(type));
		}
	}
}

```

`AssetRipper.SerializationLogic/AssetRipper.SerializationLogic.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<OutputPath>..\Bins\AssetRipper.SerializationLogic\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipper.SerializationLogic\$(Configuration)\</IntermediateOutputPath>
		<AssemblyName>AssetRipper.SerializationLogic</AssemblyName>
		<RootNamespace>AssetRipper.SerializationLogic</RootNamespace>
		<Copyright>Copyright ©  2022</Copyright>
		<Authors>ds5678</Authors>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AsmResolver.DotNet" Version="4.11.1" />
		<PackageReference Include="Mono.Cecil" Version="0.11.4" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipper.SerializationLogic/EngineTypePredicates.cs`:

```cs
using AsmResolver.DotNet;
using AssetRipper.SerializationLogic.Extensions;
using System.Collections.Generic;

namespace AssetRipper.SerializationLogic
{
	public class EngineTypePredicates
	{
		private static readonly HashSet<string> TypesThatShouldHaveHadSerializableAttribute = new HashSet<string>
		{
			"Vector3",
			"Vector2",
			"Vector4",
			"Rect",
			"RectInt",
			"Quaternion",
			"Matrix4x4",
			"Color",
			"Color32",
			"LayerMask",
			"Bounds",
			"BoundsInt",
			"Vector3Int",
			"Vector2Int",
		};

		private const string Gradient = "UnityEngine.Gradient";
		private const string GUIStyle = "UnityEngine.GUIStyle";
		private const string RectOffset = "UnityEngine.RectOffset";
		protected const string UnityEngineObject = "UnityEngine.Object";
		public const string MonoBehaviour = "UnityEngine.MonoBehaviour";
		public const string ScriptableObject = "UnityEngine.ScriptableObject";
		protected const string Matrix4x4 = "UnityEngine.Matrix4x4";
		protected const string Color32 = "UnityEngine.Color32";
		private const string SerializeFieldAttribute = "UnityEngine.SerializeField";
		private const string SerializeReferenceAttribute = "UnityEngine.SerializeReference";

		private static readonly string[] serializableClasses = new[]
		{
			"UnityEngine.AnimationCurve",
			"UnityEngine.Gradient",
			"UnityEngine.GUIStyle",
			"UnityEngine.RectOffset"
		};

		private static readonly string[] serializableStructs = new[]
		{
			// NOTE: assumes all types here are NOT interfaces
			"UnityEngine.Color32",
			"UnityEngine.Matrix4x4",
			"UnityEngine.Rendering.SphericalHarmonicsL2",
			"UnityEngine.PropertyName",
		};

		public static bool IsMonoBehaviour(ITypeDescriptor type)
		{
			return IsMonoBehaviour(type.CheckedResolve());
		}

		private static bool IsMonoBehaviour(TypeDefinition typeDefinition)
		{
			return typeDefinition.IsSubclassOf(MonoBehaviour);
		}

		public static bool IsScriptableObject(ITypeDescriptor type)
		{
			return IsScriptableObject(type.CheckedResolve());
		}

		private static bool IsScriptableObject(TypeDefinition temp)
		{
			return temp.IsSubclassOf(ScriptableObject);
		}

		public static bool IsColor32(ITypeDescriptor type)
		{
			return type.IsAssignableTo(Color32);
		}

		//Do NOT remove these, cil2as still depends on these in 4.x
		public static bool IsMatrix4x4(ITypeDescriptor type)
		{
			return type.IsAssignableTo(Matrix4x4);
		}

		public static bool IsGradient(ITypeDescriptor type)
		{
			return type.IsAssignableTo(Gradient);
		}

		public static bool IsGUIStyle(ITypeDescriptor type)
		{
			return type.IsAssignableTo(GUIStyle);
		}

		public static bool IsRectOffset(ITypeDescriptor type)
		{
			return type.IsAssignableTo(RectOffset);
		}

		public static bool IsSerializableUnityClass(ITypeDescriptor type)
		{
			foreach (string unityClasses in serializableClasses)
			{
				if (type.IsAssignableTo(unityClasses))
				{
					return true;
				}
			}
			return false;
		}

		public static bool IsSerializableUnityStruct(ITypeDescriptor type)
		{
			foreach (string unityStruct in serializableStructs)
			{
				// NOTE: structs cannot inherit from structs, and can only inherit from interfaces
				//	   since we know all types in serializableStructs are not interfaces,
				//	   we can just do a direct comparison.
				if (type.FullName == unityStruct)
				{
					return true;
				}
			}

			if (type.FullName.IndexOf("UnityEngine.LazyLoadReference`1") == 0)
			{
				return true;
			}

			return false;
		}

		public static bool IsUnityEngineObject(ITypeDescriptor type)
		{
#warning todo: somehow solve this elegantly. CheckedResolve() drops the [] of a type.
			if (type.IsArray())
			{
				return false;
			}

			if (type.FullName == UnityEngineObject)
			{
				return true;
			}

			TypeDefinition? typeDefinition = type.Resolve();
			if (typeDefinition == null)
			{
				return false;
			}

			return typeDefinition.IsSubclassOf(UnityEngineObject);
		}

		public static bool ShouldHaveHadSerializableAttribute(ITypeDescriptor type)
		{
			return IsUnityEngineValueType(type);
		}

		public static bool IsUnityEngineValueType(ITypeDescriptor type)
		{
			return type.SafeNamespace() == "UnityEngine" && TypesThatShouldHaveHadSerializableAttribute.Contains(type.Name ?? "");
		}

		public static bool IsSerializeFieldAttribute(ITypeDescriptor attributeType)
		{
			return attributeType.FullName == SerializeFieldAttribute;
		}

		public static bool IsSerializeReferenceAttribute(ITypeDescriptor attributeType)
		{
			return attributeType.FullName == SerializeReferenceAttribute;
		}
	}
}

```

`AssetRipper.SerializationLogic/Extensions/MethodDefinitionExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.SerializationLogic.Extensions
{
	static class MethodDefinitionExtensions
	{
		public static bool SameAs(this MethodDefinition self, MethodDefinition other)
		{
			// FIXME: should be able to compare MethodDefinition references directly
			return self.FullName == other.FullName;
		}

		public static string PropertyName(this MethodDefinition self)
		{
			return self.Name.Value.Substring(4);
		}

		public static bool IsConversionOperator(this MethodDefinition method)
		{
			if (!method.IsSpecialName)
			{
				return false;
			}

			return method.Name == "op_Implicit" || method.Name == "op_Explicit";
		}

		public static bool IsSimpleSetter(this MethodDefinition original)
		{
			return original.IsSetMethod && original.Parameters.Count == 1;
		}

		public static bool IsSimpleGetter(this MethodDefinition original)
		{
			return original.IsGetMethod && original.Parameters.Count == 0;
		}

		public static bool IsSimplePropertyAccessor(this MethodDefinition method)
		{
			return method.IsSimpleGetter() || method.IsSimpleSetter();
		}

		public static bool IsDefaultConstructor(MethodDefinition m)
		{
			return m.IsConstructor && !m.IsStatic && m.Parameters.Count == 0;
		}
	}
}

```

`AssetRipper.SerializationLogic/Extensions/ResolutionExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.SerializationLogic.Extensions
{
	public static class ResolutionExtensions
	{
		public static TypeDefinition CheckedResolve(this ITypeDescriptor reference)
		{
			if (reference.Module == null)
			{
				throw new ResolutionException(reference);
			}

			if (reference is not TypeDefinition definition)
			{
				definition = reference.Resolve() ?? throw new ResolutionException(reference);
			}

			return definition;
		}

		public static MethodDefinition CheckedResolve(this IMethodDefOrRef reference)
		{
			if (reference.Module == null)
			{
				throw new ResolutionException(reference);
			}

			if (reference is not MethodDefinition definition)
			{
				definition = reference.Resolve() ?? throw new ResolutionException(reference);
			}

			return definition;
		}
	}
}

```

`AssetRipper.SerializationLogic/Extensions/TypeDefinitionExtensions.cs`:

```cs
using AsmResolver.DotNet;

namespace AssetRipper.SerializationLogic.Extensions
{
	public static class TypeDefinitionExtensions
	{
		public static bool IsSubclassOf(this TypeDefinition type, string baseTypeName)
		{
			ITypeDefOrRef? baseType = type.BaseType;
			if (baseType == null)
			{
				return false;
			}

			if (baseType.FullName == baseTypeName)
			{
				return true;
			}

			TypeDefinition? baseTypeDef = baseType.Resolve();
			if (baseTypeDef == null)
			{
				return false;
			}

			return baseTypeDef.IsSubclassOf(baseTypeName);
		}

		public static bool IsSubclassOf(this TypeDefinition type, params string[] baseTypeNames)
		{
			ITypeDefOrRef? baseType = type.BaseType;
			if (baseType == null)
			{
				return false;
			}

			for (int i = 0; i < baseTypeNames.Length; i++)
			{
				if (baseType.FullName == baseTypeNames[i])
				{
					return true;
				}
			}

			TypeDefinition? baseTypeDef = baseType.Resolve();
			if (baseTypeDef == null)
			{
				return false;
			}

			return baseTypeDef.IsSubclassOf(baseTypeNames);
		}
	}
}

```

`AssetRipper.SerializationLogic/Extensions/TypeDescriptorExtensions.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;

namespace AssetRipper.SerializationLogic.Extensions
{
	public static class TypeDescriptorExtensions
	{
		public static string? SafeNamespace(this ITypeDescriptor type)
		{
			if (type.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
			{
				return genericInstanceTypeSignature.GenericType.SafeNamespace();
			}

			if (type.DeclaringType is not null)
			{
				return type.DeclaringType.SafeNamespace();
			}

			return type.Namespace;
		}

		public static bool IsAssignableTo(this ITypeDescriptor typeRef, string typeName)
		{
			if (typeRef.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature)
			{
				return genericInstanceTypeSignature.GenericType.IsAssignableTo(typeName);
			}

			if (typeRef.FullName == typeName)
			{
				return true;
			}

			return typeRef.Resolve()?.IsSubclassOf(typeName) ?? false;
			// If we can't resolve our typeref or one of its base types,
			// let's assume it is not assignable to our target type
		}

		public static bool IsEnum(this ITypeDescriptor type)
		{
			return type.IsValueType && !type.IsPrimitive() && type.CheckedResolve().IsEnum;
		}

		public static bool IsStruct(this ITypeDescriptor type)
		{
			return type.IsValueType && !type.IsPrimitive() && !type.IsEnum() && !IsSystemDecimal(type);
		}

		public static bool IsPrimitive(this ITypeDescriptor type)
		{
			return type.ToTypeSignature() is CorLibTypeSignature;
		}

		public static bool IsArray(this ITypeDescriptor type)
		{
			return type.ToTypeSignature() is SzArrayTypeSignature or ArrayTypeSignature;
		}

		private static bool IsSystemDecimal(ITypeDescriptor type)
		{
			return type.FullName == "System.Decimal";
		}
	}
}

```

`AssetRipper.SerializationLogic/FieldSerializationLogic.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using AssetRipper.SerializationLogic.Extensions;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.SerializationLogic
{
	public static class FieldSerializationLogic
	{
		private static readonly SignatureComparer signatureComparer = new();

		public static bool WillUnitySerialize(FieldDefinition fieldDefinition)
		{
			if (fieldDefinition == null)
			{
				return false;
			}

			//skip static, const and NotSerialized fields before even checking the type
			if (fieldDefinition.IsStatic || IsConst(fieldDefinition) || fieldDefinition.IsNotSerialized || fieldDefinition.IsInitOnly)
			{
				return false;
			}

			// The field must have correct visibility/decoration to be serialized.
			if (!fieldDefinition.IsPublic &&
				!ShouldHaveHadAllFieldsPublic(fieldDefinition) &&
				!HasSerializeFieldAttribute(fieldDefinition) &&
				!HasSerializeReferenceAttribute(fieldDefinition))
			{
				return false;
			}

			// Don't try to resolve types that come from Windows assembly,
			// as serialization weaver will fail to resolve that (due to it being in platform specific SDKs)
			if (ShouldNotTryToResolve(fieldDefinition.Signature!.FieldType))
			{
				return false;
			}

			if (IsFixedBuffer(fieldDefinition))
			{
				return true;
			}

			// Resolving types is more complex and slower than checking their names or attributes,
			// thus keep those checks below
			TypeSignature? typeReference = fieldDefinition.Signature!.FieldType;

			//the type of the field must be serializable in the first place.

			if (typeReference is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.String)
			{
				return true;
			}

			if (typeReference.IsValueType)
			{
				return IsValueTypeSerializable(typeReference);
			}

			if (typeReference is SzArrayTypeSignature || AsmUtils.IsGenericList(typeReference))
			{
				if (!HasSerializeReferenceAttribute(fieldDefinition))
				{
					return IsSupportedCollection(typeReference);
				}
			}


			if (!IsReferenceTypeSerializable(typeReference) && !HasSerializeReferenceAttribute(fieldDefinition))
			{
				return false;
			}

			if (IsDelegate(typeReference))
			{
				return false;
			}

			return true;
		}

		private static bool IsDelegate(ITypeDescriptor typeReference)
		{
			return typeReference.IsAssignableTo("System.Delegate");
		}

		public static bool ShouldFieldBePPtrRemapped(FieldDefinition fieldDefinition)
		{
			if (!WillUnitySerialize(fieldDefinition))
			{
				return false;
			}

			return CanTypeContainUnityEngineObjectReference(fieldDefinition.Signature!.FieldType);
		}

		private static bool CanTypeContainUnityEngineObjectReference(ITypeDescriptor typeReference)
		{
			if (IsUnityEngineObject(typeReference))
			{
				return true;
			}

			if (typeReference.IsEnum())
			{
				return false;
			}

			if (typeReference.ToTypeSignature() is CorLibTypeSignature corLibTypeSignature && IsSerializablePrimitive(corLibTypeSignature))
			{
				return false;
			}

			if (IsSupportedCollection(typeReference.ToTypeSignature()))
			{
				return CanTypeContainUnityEngineObjectReference(AsmUtils.ElementTypeOfCollection(typeReference.ToTypeSignature()));
			}

			TypeDefinition? definition = typeReference.Resolve();
			return definition switch
			{
				null => false,
				_ => HasFieldsThatCanContainUnityEngineObjectReferences(definition)
			};
		}

		private static bool HasFieldsThatCanContainUnityEngineObjectReferences(TypeDefinition definition)
		{
			return AllFieldsFor(definition).Where(kv => !signatureComparer.Equals(kv.Signature?.FieldType.Resolve(), definition)).Any(kv => CanFieldContainUnityEngineObjectReference(definition, kv));
		}

		private static IEnumerable<FieldDefinition> AllFieldsFor(TypeDefinition definition)
		{
			TypeDefinition? baseType = definition.BaseType?.Resolve();

			if (baseType != null)
			{
				foreach (FieldDefinition baseField in AllFieldsFor(baseType))
				{
					yield return baseField;
				}
			}

			foreach (FieldDefinition field in definition.Fields)
			{
				yield return field;
			}
		}

		private static bool CanFieldContainUnityEngineObjectReference(ITypeDescriptor typeReference, FieldDefinition t)
		{
			if (signatureComparer.Equals(t.Signature!.FieldType, typeReference.ToTypeSignature()))
			{
				return false;
			}

			if (!WillUnitySerialize(t))
			{
				return false;
			}

			if (EngineTypePredicates.IsUnityEngineValueType(typeReference))
			{
				return false;
			}

			return true;
		}

		private static bool IsConst(FieldDefinition fieldDefinition)
		{
			return fieldDefinition.IsLiteral && !fieldDefinition.IsInitOnly;
		}

		public static bool HasSerializeFieldAttribute(FieldDefinition field)
		{
			return FieldAttributes(field).Any(EngineTypePredicates.IsSerializeFieldAttribute);
		}

		public static bool HasSerializeReferenceAttribute(FieldDefinition field)
		{
			foreach (ITypeDefOrRef attribute in FieldAttributes(field))
			{
				if (EngineTypePredicates.IsSerializeReferenceAttribute(attribute))
				{
					return true;
				}
			}

			return false;
		}

		private static IEnumerable<ITypeDefOrRef> FieldAttributes(FieldDefinition field)
		{
			return field.CustomAttributes.Select(c => c.Constructor!.DeclaringType!);
		}

		public static bool ShouldNotTryToResolve(ITypeDescriptor typeReference)
		{
			string? typeReferenceScopeName = typeReference.Scope?.Name;
			if (typeReferenceScopeName == "Windows")
			{
				return true;
			}

			if (typeReferenceScopeName == "mscorlib")
			{
				TypeDefinition? resolved = typeReference.Resolve();
				return resolved == null;
			}

			try
			{   // This will throw an exception if typereference thinks it's referencing a .dll,
				// but actually there's .winmd file in the current directory. RRW will fix this
				// at a later step, so we will not try to resolve this type. This is OK, as any
				// type defined in a winmd cannot be serialized.
				typeReference.Resolve();
			}
			catch
			{
				return true;
			}

			return false;
		}

		private static bool IsFieldTypeSerializable(ITypeDescriptor typeReference, FieldDefinition fieldDefinition)
		{
			return IsTypeSerializable(typeReference) || IsSupportedCollection(typeReference.ToTypeSignature()) || IsFixedBuffer(fieldDefinition);
		}

		private static bool IsValueTypeSerializable(TypeSignature typeReference)
		{
			if (typeReference.IsPrimitive())
			{
				return IsSerializablePrimitive((CorLibTypeSignature)typeReference);
			}

			return EngineTypePredicates.IsSerializableUnityStruct(typeReference) ||
				typeReference.IsEnum() ||
				ShouldImplementIDeserializable(typeReference);
		}

		private static bool IsReferenceTypeSerializable(ITypeDescriptor typeReference)
		{
			if (typeReference.ToTypeSignature() is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.String)
			{
				return IsSerializablePrimitive(corLibTypeSignature);
			}

			if (IsGenericDictionary(typeReference))
			{
				return false;
			}

			if (IsUnityEngineObject(typeReference) ||
				ShouldImplementIDeserializable(typeReference) ||
				EngineTypePredicates.IsSerializableUnityClass(typeReference))
			{
				return true;
			}

			return false;
		}

		private static bool IsTypeSerializable(ITypeDescriptor typeReference)
		{
			if (typeReference.ToTypeSignature() is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.String)
			{
				return true;
			}

			if (typeReference.IsValueType)
			{
				return IsValueTypeSerializable(typeReference.ToTypeSignature());
			}

			return IsReferenceTypeSerializable(typeReference);
		}

		private static bool IsGenericDictionary(ITypeDescriptor typeReference) => AsmUtils.IsGenericDictionary(typeReference);

		public static bool IsFixedBuffer(FieldDefinition fieldDefinition)
		{
			return GetFixedBufferAttribute(fieldDefinition) != null;
		}

		public static CustomAttribute? GetFixedBufferAttribute(FieldDefinition fieldDefinition)
		{
			return fieldDefinition.CustomAttributes.Count switch
			{
				0 => null,
				_ => fieldDefinition.CustomAttributes.SingleOrDefault(a => a.Constructor?.DeclaringType?.FullName == "System.Runtime.CompilerServices.FixedBufferAttribute")
			};
		}

		public static int GetFixedBufferLength(FieldDefinition fieldDefinition)
		{
			CustomAttribute? fixedBufferAttribute = GetFixedBufferAttribute(fieldDefinition);

			if (fixedBufferAttribute == null)
			{
				throw new ArgumentException(string.Format("Field '{0}' is not a fixed buffer field.", fieldDefinition.FullName));
			}

			int size = (int)(fixedBufferAttribute.Signature?.FixedArguments[1].Element ?? 0);

			return size;
		}

		public static int PrimitiveTypeSize(CorLibTypeSignature type)
		{
			return type.ElementType switch
			{
				ElementType.Boolean or ElementType.U1 or ElementType.I1 => 1,
				ElementType.Char or ElementType.I2 or ElementType.U2 => 2,
				ElementType.I4 or ElementType.U4 or ElementType.R4 => 4,
				ElementType.I8 or ElementType.U8 or ElementType.R8 => 8,
				_ => throw new ArgumentException(string.Format("Unsupported {0}", type.ElementType)),
			};
		}

		private static bool IsSerializablePrimitive(CorLibTypeSignature typeReference)
		{
			switch (typeReference.ElementType)
			{
				case ElementType.Boolean:
				case ElementType.I1:
				case ElementType.U1:
				case ElementType.Char:
				case ElementType.I2:
				case ElementType.U2:
				case ElementType.I4:
				case ElementType.U4:
				case ElementType.I8:
				case ElementType.U8:
				case ElementType.R4:
				case ElementType.R8:
				case ElementType.String:
					return true;
				default:
					return false;
			}
		}

		public static bool IsSupportedCollection(TypeSignature typeReference)
		{
			// We don't support arrays like byte[,] etc
			//if (typeReference is ArrayTypeSignature arrayType && arrayType.Dimensions.Count != 1)
			//{
			//	return false;
			//}
			//Redundant

			if (typeReference is not SzArrayTypeSignature && !AsmUtils.IsGenericList(typeReference))
			{
				return false;
			}

			return IsTypeSerializable(AsmUtils.ElementTypeOfCollection(typeReference));
		}

		private static bool ShouldHaveHadAllFieldsPublic(FieldDefinition field)
		{
			return EngineTypePredicates.IsUnityEngineValueType(field.DeclaringType);
		}

		private static bool IsUnityEngineObject(ITypeDescriptor typeReference)
		{
			return EngineTypePredicates.IsUnityEngineObject(typeReference);
		}

		public static bool IsNonSerialized(ITypeDescriptor typeDeclaration)
		{
			if (typeDeclaration == null)
			{
				return true;
			}

			if (typeDeclaration.ToTypeSignature() is GenericInstanceTypeSignature genericInstanceTypeSignature
				&& genericInstanceTypeSignature.TypeArguments.Any(t => t is GenericParameterSignature))
			{
				return true;
			}

			if (typeDeclaration.ToTypeSignature() is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.Object)
			{
				return true;
			}

			string fullName = typeDeclaration.FullName;
			if (fullName.StartsWith("System.")) //can this be done better?
			{
				return true;
			}

			if (typeDeclaration.IsArray())
			{
				return true;
			}

			if (fullName == EngineTypePredicates.MonoBehaviour)
			{
				return true;
			}

			if (fullName == EngineTypePredicates.ScriptableObject)
			{
				return true;
			}

			if (typeDeclaration.IsEnum())
			{
				return true;
			}

			return false;
		}

		public static bool ShouldImplementIDeserializable(ITypeDescriptor typeDeclaration)
		{
			if (typeDeclaration.FullName == "UnityEngine.ExposedReference`1")
			{
				return true;
			}

			if (IsNonSerialized(typeDeclaration))
			{
				return false;
			}

			try
			{
				if (EngineTypePredicates.ShouldHaveHadSerializableAttribute(typeDeclaration))
				{
					return true;
				}

				TypeDefinition resolvedTypeDeclaration = typeDeclaration.CheckedResolve();
				if (resolvedTypeDeclaration.IsValueType)
				{
					return resolvedTypeDeclaration.IsSerializable && !resolvedTypeDeclaration.CustomAttributes.Any(a => a.Constructor.DeclaringType.FullName.Contains("System.Runtime.CompilerServices.CompilerGenerated"));
				}
				else
				{
					return (resolvedTypeDeclaration.IsSerializable && !resolvedTypeDeclaration.CustomAttributes.Any(a => a.Constructor.DeclaringType.FullName.Contains("System.Runtime.CompilerServices.CompilerGenerated"))) ||
						resolvedTypeDeclaration.IsSubclassOf(EngineTypePredicates.MonoBehaviour, EngineTypePredicates.ScriptableObject);
				}
			}
			catch (Exception)
			{
				return false;
			}
		}
	}
}

```

`AssetRipper.SerializationLogic/ResolutionException.cs`:

```cs
using AsmResolver.DotNet;
using System;

namespace AssetRipper.SerializationLogic
{
	internal class ResolutionException : Exception
	{
		public ResolutionException()
		{
		}

		public ResolutionException(IFullNameProvider reference) : base($"Could not resolve {reference.FullName}")
		{
		}
	}
}

```

`AssetRipper.SerializationLogic/TypeDefinitionConverter.cs`:

```cs
using AsmResolver.DotNet;
using AsmResolver.DotNet.Signatures.Types;
using AsmResolver.PE.DotNet.Metadata.Tables.Rows;
using System;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.SerializationLogic
{
	public sealed class TypeDefinitionConverter
	{
		private readonly TypeDefinition TypeDef;

		public TypeDefinitionConverter(TypeDefinition typeDef)
		{
			TypeDef = typeDef;
		}

		private bool WillUnitySerialize(FieldDefinition fieldDefinition)
		{
			try
			{
				TypeSignature? resolvedFieldType = fieldDefinition.Signature?.FieldType;
				if (resolvedFieldType is null || FieldSerializationLogic.ShouldNotTryToResolve(resolvedFieldType))
				{
					return false;
				}
				if (!EngineTypePredicates.IsUnityEngineObject(resolvedFieldType))
				{
					if (resolvedFieldType.FullName == fieldDefinition.DeclaringType?.FullName)
					{
						return false;
					}
				}
				return FieldSerializationLogic.WillUnitySerialize(fieldDefinition);
			}
			catch (Exception ex)
			{
				throw new Exception(string.Format("Exception while processing {0} {1}, error {2}", fieldDefinition.Signature?.FieldType.FullName, fieldDefinition.FullName, ex.Message));
			}
		}

		private static bool IsHiddenByParentClass(IEnumerable<TypeReference> parentTypes, FieldDefinition fieldDefinition, TypeDefinition processingType)
		{
			return processingType.Fields.Any(f => f.Name == fieldDefinition.Name) || parentTypes.Any(t => t.Resolve().Fields.Any(f => f.Name == fieldDefinition.Name));
		}

		private IEnumerable<FieldDefinition> FilteredFields()
		{
			return TypeDef.Fields.Where(WillUnitySerialize).Where(f =>
				FieldSerializationLogic.IsSupportedCollection(f.Signature.FieldType) ||
				f.Signature.FieldType is not GenericInstanceTypeSignature ||
				FieldSerializationLogic.ShouldImplementIDeserializable(f.Signature.FieldType.Resolve()));
		}

		private static bool RequiresAlignment(ITypeDescriptor typeRef) => RequiresAlignment(typeRef.ToTypeSignature());

		private static bool RequiresAlignment(TypeSignature typeRef)
		{
			if (typeRef is CorLibTypeSignature corLibTypeSignature)
			{
				return RequiresAlignment(corLibTypeSignature.ElementType);
			}
			else
			{
				return FieldSerializationLogic.IsSupportedCollection(typeRef) && RequiresAlignment(AsmUtils.ElementTypeOfCollection(typeRef));
			}
		}

		private static bool RequiresAlignment(ElementType elementType)
		{
			return elementType is ElementType.Boolean or ElementType.Char or ElementType.I1 or ElementType.U1 or ElementType.I2 or ElementType.U2;
		}

		private static bool IsSystemString(ITypeDescriptor typeRef) => IsSystemString(typeRef.ToTypeSignature());

		private static bool IsSystemString(TypeSignature typeRef)
		{
			return typeRef is CorLibTypeSignature corLibTypeSignature && corLibTypeSignature.ElementType == ElementType.String;
		}
	}
}

```

`AssetRipper.SystemTester/AssetRipper.SystemTester.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<OutputPath>..\Bins\AssetRipper.SystemTester\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipper.SystemTester\$(Configuration)\</IntermediateOutputPath>
		<Configurations>DebugWindows;ReleaseWindows;DebugMac;ReleaseMac;DebugLinux;ReleaseLinux</Configurations>
		<Platforms>x64</Platforms>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='DebugMac' or '$(Configuration)'=='DebugLinux'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperLibrary\AssetRipperLibrary.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipper.SystemTester/Program.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.Core.Utils;
using AssetRipper.Library;
using System;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.SystemTester
{
	static class Program
	{
		private const string TestsDirectory = "../../Tests";

		static void Main(string[] args)
		{
			if (args.Length != 0)
			{
				Console.WriteLine("This program does not accept command line arguments.");
				Console.ReadLine();
				return;
			}

			Logger.Add(new ConsoleLogger(true));
			Logger.Add(new FileLogger("AssetRipper.SystemTester.log"));
			Logger.LogSystemInformation("System Tester");
			Logger.BlankLine();

			RunTests();
			Console.ReadLine();
		}

		static void RunTests()
		{
			if (!Directory.Exists(TestsDirectory))
			{
				Logger.Log(LogType.Warning, LogCategory.General, "Tests folder did not exist. Creating...");
				Directory.CreateDirectory(TestsDirectory);
				Logger.Info(LogCategory.General, "Created. Program will now exit.");
				return;
			}

			Logger.Info(LogCategory.General, $"Running tests in {Path.GetFullPath(TestsDirectory)}");
			Logger.BlankLine();

			int numTests = 0;
			int numSuccessful = 0;
			List<(string, string)> successfulTests = new();
			List<(string, string)> unsuccessfulTests = new();
			foreach (string versionPath in Directory.GetDirectories(TestsDirectory))
			{
				string versionName = Path.GetRelativePath(TestsDirectory, versionPath);
				foreach (string testPath in Directory.GetDirectories(versionPath))
				{
					string testName = Path.GetRelativePath(versionPath, testPath);
					Logger.Info(LogCategory.General, $"Found test: '{testName}' for Unity version: '{versionName}'");
					numTests++;
					string inputPath = Path.Combine(testPath, "Input");
					if (!Directory.Exists(inputPath))
					{
						Logger.Log(LogType.Error, LogCategory.General, $"No input folder for '{testName}' on Unity version '{versionName}'");
						unsuccessfulTests.Add((versionName, testName));
					}
					else
					{
						try
						{
							string[] inputFiles = Directory.GetFiles(inputPath);
							string[] inputDirectories = Directory.GetDirectories(inputPath);
							string[] inputPaths = ArrayUtils.Combine(inputFiles, inputDirectories);
							string outputPath = Path.Combine(testPath, "Output");

							Ripper ripper = new Ripper();
							GameStructure gameStructure = ripper.Load(inputPaths);
							PrepareExportDirectory(outputPath);
							ripper.ExportProject(outputPath);
							Logger.Info(LogCategory.General, $"Completed test: '{testName}' for Unity version: '{versionName}'");
							Logger.BlankLine(2);
							numSuccessful++;
							successfulTests.Add((versionName, testName));
						}
						catch (Exception ex)
						{
							Logger.Log(LogType.Error, LogCategory.General, ex.ToString());
							Logger.BlankLine(2);
							unsuccessfulTests.Add((versionName, testName));
						}
					}
				}
			}

			Logger.Info(LogCategory.General, $"{numSuccessful}/{numTests} tests successfully completed");
			if (numSuccessful > 0)
			{
				Logger.Info(LogCategory.General, "Successful:");
				foreach ((string version, string test) in successfulTests)
				{
					Logger.Info(LogCategory.General, $"\t{version,-12} {test}");
				}
			}
			if (numSuccessful < numTests)
			{
				Logger.Info(LogCategory.General, "Unsuccessful:");
				foreach ((string version, string test) in unsuccessfulTests)
				{
					Logger.Info(LogCategory.General, $"\t{version,-12} {test}");
				}
			}
		}

		private static void PrepareExportDirectory(string path)
		{
			if (Directory.Exists(path))
			{
				Logger.Info(LogCategory.Export, "Clearing export directory...");
				Directory.Delete(path, true);
			}
		}
	}
}

```

`AssetRipper.SystemTester/README.md`:

```md
# AssetRipper.SystemTester

This is an automated system testing program.

## File Structure

```
Bins
 |--Tests
 |   |--2019.4.3 //just an example
 |   |   |--Test1Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test2Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |--2020.2.0 //just an example
 |   |   |--Test3Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test4Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 |   |   |--Test5Name
 |   |   |   |--Input
 |   |   |   |   |-- any files or folders to be processed
 |   |   |   |--Output
 |   |   |   |   |-- the test output
 ```
```

`AssetRipper.Tests/AssetRipper.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<RootNamespace>AssetRipper.Tests</RootNamespace>
		<IsPackable>false</IsPackable>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
		<PackageReference Include="NUnit" Version="3.13.3" />
		<PackageReference Include="NUnit3TestAdapter" Version="4.2.1" />
		<PackageReference Include="coverlet.collector" Version="3.1.2" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperCommon\AssetRipperCommon.csproj" />
	</ItemGroup>

</Project>

```

`AssetRipper.Tests/GuidTests.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using NUnit.Framework;
using System;
using System.Text;

namespace AssetRipper.Tests
{
	public class GuidTests
	{
		private const string randomGuidString = "352a5b3897136ed2702a283243520538";
		private const string sequentialGuidString = "0123456789abcdef0fedcba987654321";

		[Test]
		public void MissingReferenceSerializedCorrectly()
		{
			Assert.AreEqual("0000000deadbeef15deadf00d0000000", UnityGUID.MissingReference.ToString());
		}

		[Test]
		public void ToByteArrayIsConsistentWithConstructorFromByteArray()
		{
			UnityGUID guid = UnityGUID.NewGuid();
			byte[] bytes = guid.ToByteArray();
			UnityGUID fromBytes = new UnityGUID(bytes);
			Assert.AreEqual(guid, fromBytes);
			Assert.AreEqual(guid.ToString(), fromBytes.ToString());
		}

		[Test]
		public void ConversionFromSystemGuidToUnityGuidProducesSameString()
		{
			Guid systemGuid = Guid.NewGuid();
			UnityGUID unityGUID = new UnityGUID(systemGuid);
			Assert.AreEqual(systemGuid.ToString().Replace("-", ""), unityGUID.ToString());
		}

		[Test]
		public void IsZeroReturnsTrueForTheZeroGuid()
		{
			UnityGUID unityGUID = new UnityGUID(0, 0, 0, 0);
			Assert.IsTrue(unityGUID.IsZero);
		}

		[Test]
		public void IsZeroReturnsFalseForRandomGuid()
		{
			UnityGUID unityGUID = UnityGUID.NewGuid();
			Assert.IsFalse(unityGUID.IsZero);
		}

		[Test]
		public void ParsedGuidOutputsSameString()
		{
			UnityGUID parsedGUID = UnityGUID.Parse(randomGuidString);
			string outputedString = parsedGUID.ToString();
			Assert.AreEqual(randomGuidString, outputedString);
		}

		[Test]
		public void ConversionsAreInverses()
		{
			UnityGUID unityGuid = UnityGUID.NewGuid();
			Guid systemGuid = (Guid)unityGuid;
			Assert.AreEqual(unityGuid, (UnityGUID)systemGuid);
		}

		[Test]
		public void ByteConversionIsItsOwnInverse()
		{
			UnityGUID originalGuid = UnityGUID.NewGuid();
			UnityGUID inverseGuid = new UnityGUID(originalGuid.ToByteArray());
			UnityGUID equivalentGuid = new UnityGUID(inverseGuid.ToByteArray());
			Assert.AreEqual(originalGuid, equivalentGuid);
		}

		private static string GetLongRandomString(int numSetsOf32Characters = 4)
		{
			StringBuilder sb = new(numSetsOf32Characters * 32);
			for (int i = 0; i < numSetsOf32Characters; i++)
			{
				sb.Append(Guid.NewGuid().ToString());
			}
			return sb.ToString();
		}
	}
}

```

`AssetRipper.Tests/NearEqualityTests.cs`:

```cs
using AssetRipper.Core.Equality;
using NUnit.Framework;

namespace AssetRipper.Tests
{
	public class NearEqualityTests
	{
		const float oneHundredth = .01f;
		private const float randomConstantFloat = 12.5f;
		private const double randomConstantDouble = randomConstantFloat;

		[Test]
		public void NanConstantReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(float.NaN, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(float.NaN, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(double.NaN, randomConstantDouble, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(double.NaN, randomConstantDouble, oneHundredth));
		}

		[Test]
		public void NanNanReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(float.NaN, float.NaN, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(float.NaN, float.NaN, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(double.NaN, double.NaN, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(double.NaN, double.NaN, oneHundredth));
		}

		[Test]
		public void PosInfinConstantReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(float.PositiveInfinity, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(float.PositiveInfinity, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(double.PositiveInfinity, randomConstantDouble, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(double.PositiveInfinity, randomConstantDouble, oneHundredth));
		}

		[Test]
		public void PosInfinPosInfinReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(float.PositiveInfinity, float.PositiveInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(float.PositiveInfinity, float.PositiveInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(double.PositiveInfinity, double.PositiveInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(double.PositiveInfinity, double.PositiveInfinity, oneHundredth));
		}

		[Test]
		public void NegInfinConstantReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(float.NegativeInfinity, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(float.NegativeInfinity, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(double.NegativeInfinity, randomConstantDouble, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(double.NegativeInfinity, randomConstantDouble, oneHundredth));
		}

		[Test]
		public void NegInfinNegInfinReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(float.NegativeInfinity, float.NegativeInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(float.NegativeInfinity, float.NegativeInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(double.NegativeInfinity, double.NegativeInfinity, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(double.NegativeInfinity, double.NegativeInfinity, oneHundredth));
		}

		[Test]
		public void ProportionZeroConstantReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(0f, randomConstantFloat, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(0d, randomConstantDouble, oneHundredth));
		}

		[Test]
		public void ZeroZeroReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(0f, 0f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(0f, 0f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(0d, 0d, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(0d, 0d, oneHundredth));
		}

		[Test]
		public void Proportion100WithAlmost101ReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100f, 100.9999f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100d, 100.9999d, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100.9999f, 100f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100.9999d, 100d, oneHundredth));
		}

		[Test]
		public void Proportion100With100ReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100f, 100f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByProportion(100d, 100d, oneHundredth));
		}

		[Test]
		public void Proportion100With99ReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(100f, 99f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(100d, 99d, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(99f, 100f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(99d, 100d, oneHundredth));
		}

		[Test]
		public void ProportionNeg1WithPos1ReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(1f, -1f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(1d, -1d, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(-1f, 1f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByProportion(-1d, 1d, oneHundredth));
		}

		[Test]
		public void Deviation1With1_02ReturnsFalse()
		{
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(1f, 1.02f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(1d, 1.02d, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(1.02f, 1f, oneHundredth));
			Assert.IsFalse(NearEquality.AlmostEqualByDeviation(1.02d, 1d, oneHundredth));
		}

		[Test]
		public void Deviation1WithAlmost1_01ReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1f, 1.0099f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1d, 1.0099d, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1.0099f, 1f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1.0099d, 1d, oneHundredth));
		}

		[Test]
		public void Deviation0_995WithAlmost1_005ReturnsTrue()
		{
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(0.995f, 1.00499f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(0.995d, 1.00499d, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1.00499f, 0.995f, oneHundredth));
			Assert.IsTrue(NearEquality.AlmostEqualByDeviation(1.00499d, 0.995d, oneHundredth));
		}
	}
}

```

`AssetRipper.Tests/PackedBitVectorTests/FloatVectorTests.cs`:

```cs
using AssetRipper.Core.Equality;
using AssetRipper.Core.Math.PackedBitVectors;
using NUnit.Framework;
using System;

namespace AssetRipperTests.PackedBitVectorTests
{
	/// <summary>
	/// Tests for <see cref="PackedFloatVector"/>
	/// </summary>
	public class FloatVectorTests
	{
		private static readonly Random random = new Random(57089);
		private static readonly float[] floats = MakeFloats(20);

		private static float[] MakeFloats(int count)
		{
			float[] result = new float[count];
			for (int i = 0; i < count; i++)
			{
				result[i] = 10f * random.NextSingle();
			}
			return result;
		}

		[Test]
		public void BitSize24ProducesHighlyAccurateResults()
		{
			PackedFloatVector packedVector = new PackedFloatVector();
			packedVector.PackFloats(floats, 24, false);
			float[] unpackedValues = packedVector.Unpack();
			AreAlmostEqual(floats, unpackedValues, 0.000001f);
		}

		[Test]
		public void BitSizeAdjustmentAlsoProducesUsableResults()
		{
			PackedFloatVector packedVector = new PackedFloatVector();
			packedVector.PackFloats(floats, 8, true);
			float[] unpackedValues = packedVector.Unpack();
			AreAlmostEqual(floats, unpackedValues, 0.01f);
		}

		private static void AreAlmostEqual(float[] expected, float[] actual, float maxDeviation)
		{
			if (expected.Length != actual.Length)
			{
				Assert.Fail($"Lengths were inequal.\nExpected: {expected.Length}\nBut was: {actual.Length}");
			}

			for (int i = 0; i < expected.Length; i++)
			{
				if (!NearEquality.AlmostEqualByDeviation(expected[i], actual[i], maxDeviation))
				{
					Assert.Fail($"Values significantly differ at index {i}\nExpected: {expected[i]}\nBut was: {actual[i]}");
				}
			}
		}
	}
}

```

`AssetRipper.Tests/PackedBitVectorTests/IntVectorTests.cs`:

```cs
using AssetRipper.Core.Math.PackedBitVectors;
using NUnit.Framework;
using System;
using System.Linq;

namespace AssetRipperTests.PackedBitVectorTests
{
	/// <summary>
	/// Tests for <see cref="PackedIntVector"/>
	/// </summary>
	public class IntVectorTests
	{
		private static readonly Random random = new Random(57089);
		private static readonly uint[] ints = MakeInts(20);
		private static readonly ushort[] shorts = MakeShorts(20);

		[Test]
		public void UnpackedIntsAreTheSameAsTheOriginals()
		{
			PackedIntVector packedVector = new PackedIntVector();
			packedVector.PackUInts(ints);
			uint[] unpackedInts = packedVector.UnpackUInts();

			Assert.AreEqual(ints, unpackedInts);
		}

		[Test]
		public void UnpackedShortsAreTheSameAsTheOriginals()
		{
			PackedIntVector packedVector = new PackedIntVector();
			packedVector.PackUShorts(shorts);
			ushort[] unpackedShorts = packedVector.UnpackUShorts();

			Assert.AreEqual(shorts, unpackedShorts);
		}

		[Test]
		public void OldUnpackMethodIsConsistent()
		{
			PackedIntVector packedVector = new PackedIntVector();
			packedVector.PackUInts(ints);
			uint[] unpackedInts = packedVector.UnpackInts().Select(x => unchecked((uint)x)).ToArray();

			Assert.AreEqual(ints, unpackedInts);
		}

		private static uint[] MakeInts(int count)
		{
			uint[] result = new uint[count];
			for (int i = 0; i < count; i++)
			{
				result[i] = unchecked((uint)random.Next());
			}
			return result;
		}

		private static ushort[] MakeShorts(int count)
		{
			ushort[] result = new ushort[count];
			for (int i = 0; i < count; i++)
			{
				result[i] = unchecked((ushort)random.Next(ushort.MaxValue));
			}
			return result;
		}
	}
}

```

`AssetRipper.Tests/PackedBitVectorTests/QuatVectorTests.cs`:

```cs
using AssetRipper.Core.Math.PackedBitVectors;
using AssetRipper.Core.Math.Vectors;
using NUnit.Framework;
using System;

namespace AssetRipperTests.PackedBitVectorTests
{
	/// <summary>
	/// Tests for <see cref="PackedQuatVector"/>
	/// </summary>
	public class QuatVectorTests
	{
		private static readonly Random random = new Random(57089);
		private static readonly Quaternionf[] quaternions = MakeQuaternions(20);

		private static Quaternionf[] MakeQuaternions(int count)
		{
			Quaternionf[] result = new Quaternionf[count];
			for (int i = 0; i < count; i++)
			{
				result[i] = GetRandomQuaternion();
			}
			return result;
		}

		private static Quaternionf GetRandomQuaternion() => GetRandomEuler().ToQuaternion(false);

		private static Vector3f GetRandomEuler()
		{
			return new Vector3f(GetRandomAngle(), GetRandomAngle(), GetRandomAngle());
		}

		private static float GetRandomAngle()
		{
			return (float)(random.NextDouble() * 2d * System.Math.PI);
		}

		[Test]
		public void PackingAndUnpackingGiveTheSameValues()
		{
			PackedQuatVector packedVector = new PackedQuatVector();
			packedVector.Pack(quaternions);
			Quaternionf[] unpackedQuaternions = packedVector.Unpack();

			for (int i = 0; i < quaternions.Length; i++)
			{
				bool equal = quaternions[i].IsEqualUsingDot(unpackedQuaternions[i]);
				if (!equal)
				{
					throw new Exception($"Index {i}: Original: {quaternions[i]} Unpacked: {unpackedQuaternions[i]} Dot: {quaternions[i].Dot(unpackedQuaternions[i])}");
				}
			}
		}
	}
}

```

`AssetRipper.Tests/QuaternionTests.cs`:

```cs
using AssetRipper.Core.Math.Vectors;
using NUnit.Framework;

namespace AssetRipper.Tests
{
	public class QuaternionTests
	{
		[Test]
		public void ConvertingToQuaternionAndBackGivesTheSameValues()
		{
			//Many sets of values give exactly equal results
			Vector3f euler1 = new Vector3f(-67f, 45f, -162f);
			Vector3f converted1 = ConvertEulerToQuaternionAndBackToEuler(euler1);
			Assert.AreEqual(euler1, converted1);

			//Some however are only near equal due to rounding errors
			Vector3f euler2 = new Vector3f(-67f, 45f, 178f);
			Vector3f converted2 = ConvertEulerToQuaternionAndBackToEuler(euler2);
			Assert.IsTrue(euler2.IsEqualByDot(converted2));
		}

		private static Vector3f ConvertEulerToQuaternionAndBackToEuler(Vector3f original)
		{
			Quaternionf quaternion = original.ToQuaternion(true);
			return quaternion.ToEulerAngle(true);
		}

		[Test]
		public void ToQuaternionCreatesUnitQuaternions()
		{
			Vector3f euler = new Vector3f(-67f, 45f, -182f);
			Quaternionf quaternion = euler.ToQuaternion(true);
			Assert.IsTrue(quaternion.IsUnitQuaternion());
		}
	}
}

```

`AssetRipper.Yaml.Tests/AssetRipper.Yaml.Tests.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <Nullable>enable</Nullable>

    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.2.0" />
    <PackageReference Include="NUnit" Version="3.13.2" />
    <PackageReference Include="NUnit3TestAdapter" Version="4.0.0" />
    <PackageReference Include="coverlet.collector" Version="3.1.0" />
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\AssetRipper.Yaml\AssetRipper.Yaml.csproj" />
  </ItemGroup>

</Project>

```

`AssetRipper.Yaml.Tests/FlowMappingTests.cs`:

```cs
using NUnit.Framework;

namespace AssetRipper.Yaml.Tests
{
	public static class FlowMappingTests
	{
		[Test]
		public static void Vector2FlowMappingTest()
		{
			MemoryTextWriter writer = new MemoryTextWriter();
			Emitter emitter = new Emitter(writer, false);
			YamlMappingNode mappingNode = new YamlMappingNode(MappingStyle.Flow);
			mappingNode.Add("x", 2);
			mappingNode.Add("y", 3);
			mappingNode.Emit(emitter);
			string output = writer.ToString();
			Assert.AreEqual("{x: 2, y: 3}", output);
		}
	}
}

```

`AssetRipper.Yaml.Tests/MemoryTextWriter.cs`:

```cs
using System.IO;
using System.Text;

namespace AssetRipper.Yaml.Tests
{
	public sealed class MemoryTextWriter : TextWriter
	{
		private readonly StringBuilder sb = new();

		public override Encoding Encoding { get; } = Encoding.UTF8;

		public override void Write(char value)
		{
			sb.Append(value);
		}

		public void Clear() => sb.Clear();

		public override string ToString() => sb.ToString();
	}
}

```

`AssetRipper.Yaml/AssetRipper.Yaml.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<OutputPath>..\Bins\AssetRipper.Fundamentals\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipper.Yaml\$(Configuration)\</IntermediateOutputPath>
		<AssemblyName>AssetRipper.Yaml</AssemblyName>
		<RootNamespace>AssetRipper.Yaml</RootNamespace>
		<Copyright>Copyright ©  2022</Copyright>
		<Authors>ds5678</Authors>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipper.Yaml/Emitter.cs`:

```cs
using System;
using System.IO;
using System.Text;

namespace AssetRipper.Yaml
{
	internal class Emitter
	{
		public Emitter(TextWriter writer, bool formatKeys)
		{
			m_stream = writer ?? throw new ArgumentNullException(nameof(writer));
			IsFormatKeys = formatKeys;
			if (formatKeys)
			{
				m_sb = new StringBuilder();
			}
		}

		public Emitter IncreaseIndent()
		{
			m_indent++;
			return this;
		}

		public Emitter DecreaseIndent()
		{
			if (m_indent == 0)
			{
				throw new Exception($"Increase/decrease indent mismatch");
			}

			m_indent--;
			return this;
		}

		public Emitter Write(char value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter WriteRaw(char value)
		{
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(byte value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(ushort value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(short value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(uint value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(int value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(ulong value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(long value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(float value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(double value)
		{
			WriteDelayed();
			m_stream.Write(value);
			return this;
		}

		public Emitter Write(string value)
		{
			if (!string.IsNullOrEmpty(value))
			{
				WriteDelayed();
				m_stream.Write(value);
			}
			return this;
		}

		public Emitter WriteFormat(string value)
		{
			if (value.Length > 0)
			{
				WriteDelayed();
				if (value.Length > 2 && value.StartsWith("m_", StringComparison.Ordinal))
				{
					ThrowIfNullStringBuilder();
					m_sb.Append(value, 2, value.Length - 2);
					if (char.IsUpper(m_sb[0]))
					{
						m_sb[0] = char.ToLower(m_sb[0]);
					}

					value = m_sb.ToString();
					m_sb.Clear();
				}
				m_stream.Write(value);
			}
			return this;
		}

		public Emitter WriteRaw(string value)
		{
			m_stream.Write(value);
			return this;
		}

		public Emitter WriteClose(char @char)
		{
			m_isNeedSeparator = false;
			m_isNeedWhitespace = false;
			m_isNeedLineBreak = false;
			return Write(@char);
		}

		public Emitter WriteClose(string @string)
		{
			m_isNeedSeparator = false;
			m_isNeedWhitespace = false;
			return Write(@string);
		}

		public Emitter WriteWhitespace()
		{
			m_isNeedWhitespace = true;
			return this;
		}

		public Emitter WriteSeparator()
		{
			m_isNeedSeparator = true;
			return this;
		}

		public Emitter WriteLine()
		{
			m_isNeedLineBreak = true;
			return this;
		}

		public void WriteMeta(MetaType type, string value)
		{
			Write('%').Write(type.ToStringRepresentation()).WriteWhitespace();
			Write(value).WriteLine();
		}

		public void WriteDelayed()
		{
			if (m_isNeedLineBreak)
			{
				m_stream.Write('\n');
				m_isNeedSeparator = false;
				m_isNeedWhitespace = false;
				m_isNeedLineBreak = false;
				WriteIndent();
			}
			if (m_isNeedSeparator)
			{
				m_stream.Write(',');
				m_isNeedSeparator = false;
			}
			if (m_isNeedWhitespace)
			{
				m_stream.Write(' ');
				m_isNeedWhitespace = false;
			}
		}

		private void WriteIndent()
		{
			for (int i = 0; i < m_indent * 2; i++)
			{
				m_stream.Write(' ');
			}
		}

		[System.Diagnostics.CodeAnalysis.MemberNotNull(nameof(m_sb))]
		private void ThrowIfNullStringBuilder()
		{
			if (m_sb is null)
			{
				throw new NullReferenceException("m_sb cannot be null here");
			}
		}

		public bool IsFormatKeys { get; }
		public bool IsKey { get; set; }

		private readonly TextWriter m_stream;
		private readonly StringBuilder? m_sb;

		private int m_indent = 0;
		private bool m_isNeedWhitespace = false;
		private bool m_isNeedSeparator = false;
		private bool m_isNeedLineBreak = false;
	}
}

```

`AssetRipper.Yaml/Extensions/EmitterExtensions.cs`:

```cs
using System;

namespace AssetRipper.Yaml.Extensions
{
	internal static class EmitterExtensions
	{
		public static Emitter WriteHex(this Emitter _this, byte value)
		{
			_this.Write(HexAlphabet[value >> 4]);
			_this.Write(HexAlphabet[value & 0xF]);
			return _this;
		}

		public static Emitter WriteHex(this Emitter _this, ushort value)
		{
			_this.Write(HexAlphabet[(value >> 4) & 0xF]);
			_this.Write(HexAlphabet[(value >> 0) & 0xF]);
			_this.Write(HexAlphabet[(value >> 12) & 0xF]);
			_this.Write(HexAlphabet[(value >> 8) & 0xF]);
			return _this;
		}

		public static Emitter WriteHex(this Emitter _this, short value)
		{
			return _this.WriteHex(unchecked((ushort)value));
		}

		public static Emitter WriteHex(this Emitter _this, uint value)
		{
			_this.Write(HexAlphabet[unchecked((int)(value >> 4) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 0) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 12) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 8) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 20) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 16) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 28) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 24) & 0xF)]);
			return _this;
		}

		public static Emitter WriteHex(this Emitter _this, int value)
		{
			return _this.WriteHex(unchecked((uint)value));
		}

		public static Emitter WriteHex(this Emitter _this, ulong value)
		{
			_this.Write(HexAlphabet[unchecked((int)(value >> 4) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 0) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 12) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 8) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 20) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 16) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 28) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 24) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 36) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 32) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 44) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 40) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 52) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 48) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 60) & 0xF)]);
			_this.Write(HexAlphabet[unchecked((int)(value >> 56) & 0xF)]);
			return _this;
		}

		public static Emitter WriteHex(this Emitter _this, long value)
		{
			return _this.WriteHex(unchecked((ulong)value));
		}

		public static Emitter WriteHex(this Emitter _this, float value)
		{
			return _this.WriteHex(BitConverter.SingleToUInt32Bits(value));
		}

		public static Emitter WriteHex(this Emitter _this, double value)
		{
			return _this.WriteHex(BitConverter.DoubleToUInt64Bits(value));
		}

		private static readonly string HexAlphabet = "0123456789ABCDEF";
	}
}

```

`AssetRipper.Yaml/Extensions/PrimitiveExtensions.cs`:

```cs
using System;

namespace AssetRipper.Yaml.Extensions
{
	internal static class PrimitiveExtensions
	{
		public static string ToHexString(this byte _this)
		{
			return _this.ToString("x2");
		}

		public static string ToHexString(this sbyte _this)
		{
			byte value = unchecked((byte)_this);
			return value.ToHexString();
		}

		public static string ToHexString(this short _this)
		{
			ushort value = unchecked((ushort)_this);
			return value.ToHexString();
		}

		public static string ToHexString(this ushort _this)
		{
			ushort reverse = unchecked((ushort)(((0xFF00 & _this) >> 8) | ((0x00FF & _this) << 8)));
			return reverse.ToString("x4");
		}

		public static string ToHexString(this int _this)
		{
			uint value = unchecked((uint)_this);
			return value.ToHexString();
		}

		public static string ToHexString(this uint _this)
		{
			uint reverse = ((0xFF000000 & _this) >> 24) | ((0x00FF0000 & _this) >> 8) | ((0x0000FF00 & _this) << 8) | ((0x000000FF & _this) << 24);
			return reverse.ToString("x8");
		}

		public static string ToHexString(this long _this)
		{
			ulong value = unchecked((ulong)_this);
			return value.ToHexString();
		}

		public static string ToHexString(this ulong _this)
		{
			ulong reverse = ((_this & 0x00000000000000FFUL) << 56) | ((_this & 0x000000000000FF00UL) << 40) |
					((_this & 0x0000000000FF0000UL) << 24) | ((_this & 0x00000000FF000000UL) << 8) |
					((_this & 0x000000FF00000000UL) >> 8) | ((_this & 0x0000FF0000000000UL) >> 24) |
					((_this & 0x00FF000000000000UL) >> 40) | ((_this & 0xFF00000000000000UL) >> 56);
			return reverse.ToString("x16");
		}

		public static string ToHexString(this float _this)
		{
			uint value = BitConverter.SingleToUInt32Bits(_this);
			return value.ToHexString();
		}

		public static string ToHexString(this double _this)
		{
			ulong value = BitConverter.DoubleToUInt64Bits(_this);
			return value.ToHexString();
		}

		public static int ToClosestInt(this long _this)
		{
			if (_this > int.MaxValue)
			{
				return int.MaxValue;
			}

			if (_this < int.MinValue)
			{
				return int.MinValue;
			}

			return unchecked((int)_this);
		}
	}
}

```

`AssetRipper.Yaml/Extensions/StringBuilderExtensions.cs`:

```cs
using System;
using System.Text;

namespace AssetRipper.Yaml.Extensions
{
	public static class StringBuilderExtensions
	{
		static StringBuilderExtensions()
		{
			for (int i = 0; i <= byte.MaxValue; i++)
			{
				ByteHexRepresentations[i] = i.ToString("x2");
			}
		}

		public static StringBuilder AppendHex(this StringBuilder _this, byte value)
		{
			_this.Append(ByteHexRepresentations[value]);
			return _this;
		}

		public static StringBuilder AppendHex(this StringBuilder _this, ushort value)
		{
			_this.Append(ByteHexRepresentations[(value >> 0) & 0xFF]);
			_this.Append(ByteHexRepresentations[(value >> 8) & 0xFF]);
			return _this;
		}

		public static StringBuilder AppendHex(this StringBuilder _this, short value)
		{
			return _this.AppendHex(unchecked((ushort)value));
		}

		public static StringBuilder AppendHex(this StringBuilder _this, uint value)
		{
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 0) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 8) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 16) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 24) & 0xFF)]);
			return _this;
		}

		public static StringBuilder AppendHex(this StringBuilder _this, int value)
		{
			return _this.AppendHex(unchecked((uint)value));
		}

		public static StringBuilder AppendHex(this StringBuilder _this, ulong value)
		{
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 0) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 8) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 16) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 24) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 32) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 40) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 48) & 0xFF)]);
			_this.Append(ByteHexRepresentations[unchecked((int)(value >> 56) & 0xFF)]);
			return _this;
		}

		public static StringBuilder AppendHex(this StringBuilder _this, long value)
		{
			return _this.AppendHex(unchecked((ulong)value));
		}

		public static StringBuilder AppendHex(this StringBuilder _this, float value)
		{
			return _this.AppendHex(BitConverter.SingleToUInt32Bits(value));
		}

		public static StringBuilder AppendHex(this StringBuilder _this, double value)
		{
			return _this.AppendHex(BitConverter.DoubleToUInt64Bits(value));
		}

		public static StringBuilder AppendIndent(this StringBuilder _this, int count)
		{
			for (int i = 0; i < count; i++)
			{
				_this.Append('\t');
			}

			return _this;
		}

		public static readonly string HexAlphabet = "0123456789abcdef";
		public static readonly string[] ByteHexRepresentations = new string[256];
	}
}

```

`AssetRipper.Yaml/Extensions/YamlArrayExtensions.cs`:

```cs
using System.Text;

namespace AssetRipper.Yaml.Extensions
{
	public static class YamlArrayExtensions
	{
		public static YamlNode ExportYaml(this byte[] _this)
		{
			StringBuilder sb = new StringBuilder(_this.Length * 2);
			for (int i = 0; i < _this.Length; i++)
			{
				sb.AppendHex(_this[i]);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static void AddTypelessData(this YamlMappingNode mappingNode, string name, byte[] data)
		{
			mappingNode.Add(name, data.Length);
			mappingNode.Add(TypelessdataName, data.ExportYaml());
		}

		public const string TypelessdataName = "_typelessdata";
	}
}

```

`AssetRipper.Yaml/Extensions/YamlDictionaryExtensions.cs`:

```cs
using System;
using System.Collections.Generic;

namespace AssetRipper.Yaml.Extensions
{
	public static class YamlDictionaryExtensions
	{
		public static YamlNode ExportYaml(this IReadOnlyDictionary<uint, string> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode(MappingStyle.Block);
				map.Add(kvp.Key, kvp.Value);
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<long, string> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode(MappingStyle.Block);
				map.Add(kvp.Key, kvp.Value);
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<string, string> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode(MappingStyle.Block);
				map.Add(kvp.Key, kvp.Value);
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<string, int> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode(MappingStyle.Block);
				map.Add(kvp.Key, kvp.Value);
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<string, float> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode map = new YamlMappingNode(MappingStyle.Block);
				map.Add(kvp.Key, kvp.Value);
				node.Add(map);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<Tuple<ushort, ushort>, float> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode keyNode = new YamlMappingNode();
				keyNode.Add(kvp.Key.Item1, kvp.Key.Item2);
				YamlMappingNode kvpMap = new YamlMappingNode();
				kvpMap.Add("first", keyNode);
				kvpMap.Add("second", kvp.Value);
				node.Add(kvpMap);
			}
			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyDictionary<Tuple<int, long>, string> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode keyNode = new YamlMappingNode();
				keyNode.Add(kvp.Key.Item1, kvp.Key.Item2);
				YamlMappingNode kvpMap = new YamlMappingNode();
				kvpMap.Add("first", keyNode);
				kvpMap.Add("second", kvp.Value);
				node.Add(kvpMap);
			}
			return node;
		}

		public static YamlNode ExportYaml<T>(this IReadOnlyDictionary<Tuple<T, long>, string> _this, Func<T, int> converter)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.BlockCurve);
			foreach (var kvp in _this)
			{
				YamlMappingNode keyNode = new YamlMappingNode();
				keyNode.Add(converter(kvp.Key.Item1), kvp.Key.Item2);
				YamlMappingNode kvpMap = new YamlMappingNode();
				kvpMap.Add("first", keyNode);
				kvpMap.Add("second", kvp.Value);
				node.Add(kvpMap);
			}
			return node;
		}
	}
}

```

`AssetRipper.Yaml/Extensions/YamlEnumerableExtensions.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace AssetRipper.Yaml.Extensions
{
	public static class YamlEnumerableExtensions
	{
		public static YamlNode ExportYaml(this IEnumerable<bool> _this)
		{
			StringBuilder sb = new StringBuilder();
			foreach (bool value in _this)
			{
				byte bvalue = unchecked((byte)(value ? 1 : 0));
				sb.AppendHex(bvalue);
			}
			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IEnumerable<char> _this)
		{
			StringBuilder sb = new StringBuilder();
			foreach (char value in _this)
			{
				sb.AppendHex(value);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IEnumerable<byte> _this)
		{
			StringBuilder sb = new StringBuilder();
			foreach (byte value in _this)
			{
				sb.AppendHex(value);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IEnumerable<ushort> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (ushort value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (ushort value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<short> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (short value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (short value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<uint> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (uint value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (uint value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<int> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (int value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (int value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<ulong> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (ulong value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (ulong value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<long> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder();
				foreach (long value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (long value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IEnumerable<float> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (float value in _this)
			{
				node.Add(value);
			}

			return node;
		}

		public static YamlNode ExportYaml(this IEnumerable<double> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (double value in _this)
			{
				node.Add(value);
			}

			return node;
		}

		public static YamlNode ExportYaml(this IEnumerable<string> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (string value in _this)
			{
				node.Add(value);
			}

			return node;
		}

		public static YamlNode ExportYaml(this IEnumerable<IEnumerable<string>> _this)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (IEnumerable<string> export in _this)
			{
				node.Add(export.ExportYaml());
			}

			return node;
		}
	}
}

```

`AssetRipper.Yaml/Extensions/YamlListExtensions.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace AssetRipper.Yaml.Extensions
{
	public static class YamlListExtensions
	{
		public static YamlNode ExportYaml(this IReadOnlyList<bool> _this)
		{
			StringBuilder sb = new StringBuilder(_this.Count * 2);
			foreach (bool value in _this)
			{
				byte bvalue = unchecked((byte)(value ? 1 : 0));
				sb.AppendHex(bvalue);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IReadOnlyList<char> _this)
		{
			StringBuilder sb = new StringBuilder(_this.Count * 4);
			foreach (char value in _this)
			{
				sb.AppendHex(value);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IReadOnlyList<byte> _this)
		{
			StringBuilder sb = new StringBuilder(_this.Count * 2);
			foreach (byte value in _this)
			{
				sb.AppendHex(value);
			}

			return new YamlScalarNode(sb.ToString(), true);
		}

		public static YamlNode ExportYaml(this IReadOnlyList<ushort> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 4);
				foreach (ushort value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (ushort value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IReadOnlyList<short> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 4);
				foreach (short value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (short value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IReadOnlyList<uint> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 8);
				foreach (uint value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (uint value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IReadOnlyList<IReadOnlyList<uint>> _this, bool isRaw)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (var value in _this)
			{
				node.Add(value.ExportYaml(isRaw));
			}

			return node;
		}

		public static YamlNode ExportYaml(this IReadOnlyList<int> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 8);
				foreach (int value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (int value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IReadOnlyList<ulong> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 16);
				foreach (ulong value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (ulong value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}

		public static YamlNode ExportYaml(this IReadOnlyList<long> _this, bool isRaw)
		{
			if (isRaw)
			{
				StringBuilder sb = new StringBuilder(_this.Count * 16);
				foreach (long value in _this)
				{
					sb.AppendHex(value);
				}

				return new YamlScalarNode(sb.ToString(), true);
			}
			else
			{
				YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
				foreach (long value in _this)
				{
					node.Add(value);
				}

				return node;
			}
		}
	}
}

```

`AssetRipper.Yaml/MappingStyle.cs`:

```cs
namespace AssetRipper.Yaml
{
	/// <summary>
	/// Specifies the style of a mapping.
	/// </summary>
	public enum MappingStyle
	{
		/// <summary>
		/// The block mapping style.
		/// </summary>
		Block,

		/// <summary>
		/// The flow mapping style.
		/// </summary>
		Flow
	}
}

```

`AssetRipper.Yaml/MetaType.cs`:

```cs
using System;

namespace AssetRipper.Yaml
{
	internal enum MetaType
	{
		Yaml,
		Tag,
	}

	internal static class MetaTypeExtensions
	{
		public static string ToStringRepresentation(this MetaType metaType)
		{
			return metaType switch
			{
				MetaType.Yaml => "YAML",
				MetaType.Tag => "TAG",
				_ => throw new ArgumentOutOfRangeException(nameof(metaType), $"Value: {metaType}"),
			};
		}
	}
}

```

`AssetRipper.Yaml/Properties/AssemblyInfo.cs`:

```cs
using System.Runtime.CompilerServices;

[assembly: InternalsVisibleTo("AssetRipper.Yaml.Tests")]

```

`AssetRipper.Yaml/ScalarStyle.cs`:

```cs
namespace AssetRipper.Yaml
{
	/// <summary>
	/// Specifies the style of a Yaml scalar.
	/// </summary>
	public enum ScalarStyle
	{
		/// <summary>
		/// The plain scalar style.
		/// </summary>
		Plain,

		/// <summary>
		/// 
		/// </summary>
		Hex,

		/// <summary>
		/// The single-quoted scalar style.
		/// </summary>
		SingleQuoted,

		/// <summary>
		/// The double-quoted scalar style.
		/// </summary>
		DoubleQuoted,
	}
}

```

`AssetRipper.Yaml/ScalarType.cs`:

```cs
namespace AssetRipper.Yaml
{
	internal enum ScalarType
	{
		Boolean,
		Byte,
		SByte,
		UInt16,
		Int16,
		UInt32,
		Int32,
		UInt64,
		Int64,
		Single,
		Double,
		String,
	}
}

```

`AssetRipper.Yaml/SequenceStyle.cs`:

```cs
namespace AssetRipper.Yaml
{
	/// <summary>
	/// Specifies the style of a sequence.
	/// </summary>
	public enum SequenceStyle
	{
		/// <summary>
		/// The block sequence style
		/// </summary>
		Block,

		/// <summary>
		/// The block sequence style but with curly braces
		/// </summary>
		BlockCurve,

		/// <summary>
		/// The flow sequence style
		/// </summary>
		Flow,

		/// <summary>
		/// Single line with hex data
		/// </summary>
		Raw,
	}

	public static class SequenceStyleExtensions
	{
		public static bool IsRaw(this SequenceStyle _this)
		{
			return _this == SequenceStyle.Raw;
		}

		public static bool IsAnyBlock(this SequenceStyle _this)
		{
			return _this == SequenceStyle.Block || _this == SequenceStyle.BlockCurve;
		}

		/// <summary>
		/// Get scalar style corresponding to current sequence style
		/// </summary>
		/// <param name="_this">Sequence style</param>
		/// <returns>Corresponding scalar style</returns>
		public static ScalarStyle ToScalarStyle(this SequenceStyle _this)
		{
			return _this == SequenceStyle.Raw ? ScalarStyle.Hex : ScalarStyle.Plain;
		}
	}
}

```

`AssetRipper.Yaml/YAMLDocument.cs`:

```cs
using System;

namespace AssetRipper.Yaml
{
	public sealed class YamlDocument
	{
		public YamlDocument() { }

		public YamlScalarNode CreateScalarRoot()
		{
			YamlScalarNode root = new YamlScalarNode();
			Root = root;
			return root;
		}

		public YamlSequenceNode CreateSequenceRoot()
		{
			YamlSequenceNode root = new YamlSequenceNode();
			Root = root;
			return root;
		}

		public YamlMappingNode CreateMappingRoot()
		{
			YamlMappingNode root = new YamlMappingNode();
			Root = root;
			return root;
		}

		internal void Emit(Emitter emitter, bool isSeparator)
		{
			if (isSeparator)
			{
				emitter.Write("---").WriteWhitespace();
			}

			ThrowIfNullRoot();
			Root.Emit(emitter);
		}

		[System.Diagnostics.CodeAnalysis.MemberNotNull(nameof(Root))]
		private void ThrowIfNullRoot()
		{
			if (Root is null)
			{
				throw new NullReferenceException("Root cannot be null here");
			}
		}

		public YamlNode? Root { get; private set; }
	}
}

```

`AssetRipper.Yaml/YAMLMappingNode.cs`:

```cs
using System;
using System.Collections.Generic;

namespace AssetRipper.Yaml
{
	public sealed class YamlMappingNode : YamlNode
	{
		public YamlMappingNode() { }

		public YamlMappingNode(MappingStyle style)
		{
			Style = style;
		}

		public void Add(int key, long value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(int key, string value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(int key, YamlNode value)
		{
			YamlScalarNode keyNode = new(key);
			InsertEnd(keyNode, value);
		}

		public void Add(uint key, string value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(uint key, YamlNode value)
		{
			YamlScalarNode keyNode = new(key);
			InsertEnd(keyNode, value);
		}

		public void Add(long key, string value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(long key, YamlNode value)
		{
			YamlScalarNode keyNode = new(key);
			InsertEnd(keyNode, value);
		}

		public void Add(string key, bool value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, byte value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, short value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, ushort value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, int value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, uint value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, long value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, ulong value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, float value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, double value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, string value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(string key, YamlNode value)
		{
			YamlScalarNode keyNode = new(key, true);
			InsertEnd(keyNode, value);
		}

		public void Add(YamlNode key, bool value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, byte value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, short value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, ushort value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, int value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, uint value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, long value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, ulong value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, float value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, string value)
		{
			YamlScalarNode valueNode = new(value);
			Add(key, valueNode);
		}

		public void Add(YamlNode key, YamlNode value)
		{
			if (key.NodeType != YamlNodeType.Scalar)
			{
				throw new Exception($"Only {YamlNodeType.Scalar} node as a key supported");
			}

			InsertEnd(key, value);
		}

		public void Append(YamlMappingNode map)
		{
			foreach (KeyValuePair<YamlNode, YamlNode> child in map.m_children)
			{
				Add(child.Key, child.Value);
			}
		}

		public void InsertBegin(string key, int value)
		{
			YamlScalarNode valueNode = new(value);
			InsertBegin(key, valueNode);
		}

		public void InsertBegin(string key, YamlNode value)
		{
			YamlScalarNode keyNode = new(key, true);
			InsertBegin(keyNode, value);
		}

		public void InsertBegin(YamlNode key, YamlNode value)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}

			KeyValuePair<YamlNode, YamlNode> pair = new(key, value);
			m_children.Insert(0, pair);
		}

		internal override void Emit(Emitter emitter)
		{
			base.Emit(emitter);

			StartChildren(emitter);
			foreach (KeyValuePair<YamlNode, YamlNode> kvp in m_children)
			{
				YamlNode key = kvp.Key;
				YamlNode value = kvp.Value;

				bool iskey = emitter.IsKey;
				emitter.IsKey = true;
				key.Emit(emitter);
				emitter.IsKey = false;
				StartTransition(emitter, value);
				value.Emit(emitter);
				EndTransition(emitter, value);
				emitter.IsKey = iskey;
			}
			EndChildren(emitter);
		}

		private void StartChildren(Emitter emitter)
		{
			if (Style == MappingStyle.Block)
			{
				if (m_children.Count == 0)
				{
					emitter.Write('{');
				}
			}
			else if (Style == MappingStyle.Flow)
			{
				emitter.Write('{');
			}
		}

		private void EndChildren(Emitter emitter)
		{
			if (Style == MappingStyle.Block)
			{
				if (m_children.Count == 0)
				{
					emitter.Write('}');
				}

				emitter.WriteLine();
			}
			else if (Style == MappingStyle.Flow)
			{
				emitter.WriteClose('}');
			}
		}

		private void StartTransition(Emitter emitter, YamlNode next)
		{
			emitter.Write(':').WriteWhitespace();
			if (Style == MappingStyle.Block)
			{
				if (next.IsMultiline)
				{
					emitter.WriteLine();
				}
			}

			if (next.IsIndent)
			{
				emitter.IncreaseIndent();
			}
		}

		private void EndTransition(Emitter emitter, YamlNode next)
		{
			if (Style == MappingStyle.Block)
			{
				emitter.WriteLine();
			}
			else if (Style == MappingStyle.Flow)
			{
				emitter.WriteSeparator().WriteWhitespace();
			}

			if (next.IsIndent)
			{
				emitter.DecreaseIndent();
			}
		}

		private void InsertEnd(YamlNode key, YamlNode value)
		{
			if (value == null)
			{
				throw new ArgumentNullException(nameof(value));
			}

			KeyValuePair<YamlNode, YamlNode> pair = new(key, value);
			m_children.Add(pair);
		}

		public static YamlMappingNode Empty { get; } = new YamlMappingNode(MappingStyle.Flow);

		public override YamlNodeType NodeType => YamlNodeType.Mapping;
		public override bool IsMultiline => Style == MappingStyle.Block && m_children.Count > 0;
		public override bool IsIndent => Style == MappingStyle.Block;

		public MappingStyle Style { get; set; }

		public readonly List<KeyValuePair<YamlNode, YamlNode>> m_children = new();
	}
}

```

`AssetRipper.Yaml/YAMLNode.cs`:

```cs
namespace AssetRipper.Yaml
{
	public abstract class YamlNode
	{
		internal virtual void Emit(Emitter emitter)
		{
			bool isWrote = false;
			if (!CustomTag.IsEmpty)
			{
				emitter.Write(CustomTag.ToString()).WriteWhitespace();
				isWrote = true;
			}
			if (Anchor.Length > 0)
			{
				emitter.Write("&").Write(Anchor).WriteWhitespace();
				isWrote = true;
			}

			if (isWrote)
			{
				if (IsMultiline)
				{
					emitter.WriteLine();
				}
			}
		}

		public abstract YamlNodeType NodeType { get; }
		public abstract bool IsMultiline { get; }
		public abstract bool IsIndent { get; }

		public string Tag
		{
			get => CustomTag.Content;
			set => CustomTag = new YamlTag(YamlWriter.DefaultTagHandle, value);
		}
		public YamlTag CustomTag { get; set; }
		public string Anchor { get; set; } = string.Empty;
	}
}

```

`AssetRipper.Yaml/YAMLNodeType.cs`:

```cs
namespace AssetRipper.Yaml
{
	public enum YamlNodeType
	{
		/// <summary>
		/// The node is a <see cref="YamlMappingNode"/>.
		/// </summary>
		Mapping,

		/// <summary>
		/// The node is a <see cref="YamlScalarNode"/>.
		/// </summary>
		Scalar,

		/// <summary>
		/// The node is a <see cref="YamlSequenceNode"/>.
		/// </summary>
		Sequence
	}
}

```

`AssetRipper.Yaml/YAMLScalarNode.cs`:

```cs
//#define USE_HEX_FLOAT
using AssetRipper.Yaml.Extensions;
using System;
using System.Globalization;
using System.Text.RegularExpressions;

namespace AssetRipper.Yaml
{
	public sealed class YamlScalarNode : YamlNode
	{
		public YamlScalarNode() { }

		public YamlScalarNode(bool value) : this(value, false) { }

		public YamlScalarNode(bool value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(byte value) : this(value, false) { }

		public YamlScalarNode(byte value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(sbyte value) : this(value, false) { }

		public YamlScalarNode(sbyte value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(short value) : this(value, false) { }

		public YamlScalarNode(short value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(ushort value) : this(value, false) { }

		public YamlScalarNode(ushort value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(int value) : this(value, false) { }

		public YamlScalarNode(int value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(uint value) : this(value, false) { }

		public YamlScalarNode(uint value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(long value) : this(value, false) { }

		public YamlScalarNode(long value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(ulong value) : this(value, false) { }

		public YamlScalarNode(ulong value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(float value) : this(value, false) { }

		public YamlScalarNode(float value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(double value) : this(value, false) { }

		public YamlScalarNode(double value, bool isHex)
		{
			SetValue(value);
			Style = isHex ? ScalarStyle.Hex : ScalarStyle.Plain;
		}

		public YamlScalarNode(string value)
		{
			SetValue(value);
			Style = GetStringStyle(value);
		}

		internal YamlScalarNode(string value, bool _)
		{
			SetValue(value);
			Style = ScalarStyle.Plain;
		}

		public void SetValue(bool value)
		{
			m_value = value ? 1u : 0u;
			m_objectType = ScalarType.Boolean;
		}

		public void SetValue(byte value)
		{
			m_value = value;
			m_objectType = ScalarType.Byte;
		}

		public void SetValue(short value)
		{
			m_value = unchecked((ushort)value);
			m_objectType = ScalarType.Int16;
		}

		public void SetValue(ushort value)
		{
			m_value = value;
			m_objectType = ScalarType.UInt16;
		}

		public void SetValue(int value)
		{
			m_value = unchecked((uint)value);
			m_objectType = ScalarType.Int32;
		}

		public void SetValue(uint value)
		{
			m_value = value;
			m_objectType = ScalarType.UInt32;
		}

		public void SetValue(long value)
		{
			m_value = unchecked((ulong)value);
			m_objectType = ScalarType.Int64;
		}

		public void SetValue(ulong value)
		{
			m_value = value;
			m_objectType = ScalarType.UInt64;
		}

		public void SetValue(float value)
		{
#if USE_HEX_FLOAT
			// It is more precise technic but output looks vague and less readable
			uint hex = BitConverter.SingleToUInt32Bits(value);
			m_string = $"0x{hex.ToHexString()}({value.ToString(CultureInfo.InvariantCulture)})";
			m_objectType = ScalarType.String;
#else
			m_value = BitConverter.SingleToUInt32Bits(value);
			m_objectType = ScalarType.Single;
#endif
		}

		public void SetValue(double value)
		{
#if USE_HEX_FLOAT
			// It is more precise technic but output looks vague and less readable
			ulong hex = BitConverter.DoubleToUInt64Bits(value);
			m_string = $"0x{hex.ToHexString()}({value.ToString(CultureInfo.InvariantCulture)})";
			m_objectType = ScalarType.String;
#else
			m_value = BitConverter.DoubleToUInt64Bits(value);
			m_objectType = ScalarType.Double;
#endif
		}

		public void SetValue(string value)
		{
			m_string = value;
			m_objectType = ScalarType.String;
		}

		internal Emitter ToString(Emitter emitter)
		{
			if (Style == ScalarStyle.Hex)
			{
				return m_objectType switch
				{
					ScalarType.Byte => emitter.WriteHex((byte)m_value),
					ScalarType.SByte => emitter.WriteHex(unchecked((sbyte)m_value)),
					ScalarType.Int16 => emitter.WriteHex(unchecked((short)m_value)),
					ScalarType.UInt16 => emitter.WriteHex((ushort)m_value),
					ScalarType.Int32 => emitter.WriteHex(unchecked((int)m_value)),
					ScalarType.UInt32 => emitter.WriteHex((uint)m_value),
					ScalarType.Int64 => emitter.WriteHex(unchecked((long)m_value)),
					ScalarType.UInt64 => emitter.WriteHex(m_value),
					ScalarType.Single => emitter.WriteHex((uint)m_value),
					ScalarType.Double => emitter.WriteHex(m_value),
					_ => throw new NotImplementedException(m_objectType.ToString()),
				};
			}

			return m_objectType switch
			{
				ScalarType.Boolean => emitter.Write(m_value),
				ScalarType.Byte => emitter.Write(m_value),
				ScalarType.SByte => emitter.Write(unchecked((sbyte)m_value)),
				ScalarType.Int16 => emitter.Write(unchecked((short)m_value)),
				ScalarType.UInt16 => emitter.Write(m_value),
				ScalarType.Int32 => emitter.Write(unchecked((int)m_value)),
				ScalarType.UInt32 => emitter.Write(m_value),
				ScalarType.Int64 => emitter.Write(unchecked((long)m_value)),
				ScalarType.UInt64 => emitter.Write(m_value),
				ScalarType.Single => emitter.Write(BitConverter.UInt32BitsToSingle((uint)m_value)),
				ScalarType.Double => emitter.Write(BitConverter.UInt64BitsToDouble(m_value)),
				ScalarType.String => WriteString(emitter),
				_ => throw new NotImplementedException(m_objectType.ToString()),
			};
		}

		internal override void Emit(Emitter emitter)
		{
			base.Emit(emitter);

			switch (Style)
			{
				case ScalarStyle.Hex:
				case ScalarStyle.Plain:
					ToString(emitter);
					break;

				case ScalarStyle.SingleQuoted:
					emitter.Write('\'');
					ToString(emitter);
					emitter.Write('\'');
					break;

				case ScalarStyle.DoubleQuoted:
					emitter.Write('"');
					ToString(emitter);
					emitter.Write('"');
					break;

				default:
					throw new Exception($"Unsupported scalar style {Style}");
			}
		}

		private Emitter WriteString(Emitter emitter)
		{
			if (Style == ScalarStyle.Plain)
			{
				if (emitter.IsFormatKeys && emitter.IsKey)
				{
					emitter.WriteFormat(m_string);
				}
				else
				{
					emitter.Write(m_string);
				}
			}
			else if (Style == ScalarStyle.SingleQuoted)
			{
				emitter.WriteDelayed();
				for (int i = 0; i < m_string.Length; i++)
				{
					char c = m_string[i];
					emitter.WriteRaw(c);
					if (c == '\'')
					{
						emitter.WriteRaw(c);
					}
					else if (c == '\n')
					{
						emitter.WriteRaw("\n	");
					}
				}
			}
			else if (Style == ScalarStyle.DoubleQuoted)
			{
				emitter.WriteDelayed();
				for (int i = 0; i < m_string.Length; i++)
				{
					char c = m_string[i];
					switch (c)
					{
						case '\\':
							emitter.WriteRaw('\\').WriteRaw('\\');
							break;
						case '\n':
							emitter.WriteRaw('\\').WriteRaw('n');
							break;
						case '\r':
							emitter.WriteRaw('\\').WriteRaw('r');
							break;
						case '\t':
							emitter.WriteRaw('\\').WriteRaw('t');
							break;
						case '"':
							emitter.WriteRaw('\\').WriteRaw('"');
							break;

						default:
							emitter.WriteRaw(c);
							break;
					}
				}
			}
			else
			{
				throw new NotSupportedException(Style.ToString());
			}

			return emitter;
		}

		private static ScalarStyle GetStringStyle(string value)
		{
			if (!string.IsNullOrEmpty(value) && s_illegal.IsMatch(value))
			{
				return value.Contains("\n ") ? ScalarStyle.DoubleQuoted : ScalarStyle.SingleQuoted;
			}

			return ScalarStyle.Plain;
		}

		public static YamlScalarNode Empty { get; } = new YamlScalarNode();

		public override YamlNodeType NodeType => YamlNodeType.Scalar;
		public override bool IsMultiline => false;
		public override bool IsIndent => false;

		public string Value
		{
			get
			{
				if (Style == ScalarStyle.Hex)
				{
					return m_objectType switch
					{
						ScalarType.Byte => unchecked((byte)m_value).ToHexString(),
						ScalarType.SByte => unchecked((sbyte)m_value).ToHexString(),
						ScalarType.Int16 => unchecked((short)m_value).ToHexString(),
						ScalarType.UInt16 => unchecked((ushort)m_value).ToHexString(),
						ScalarType.Int32 => unchecked((int)m_value).ToHexString(),
						ScalarType.UInt32 => unchecked((uint)m_value).ToHexString(),
						ScalarType.Int64 => unchecked((long)m_value).ToHexString(),
						ScalarType.UInt64 => m_value.ToHexString(),
						ScalarType.Single => BitConverter.UInt32BitsToSingle((uint)m_value).ToHexString(),
						ScalarType.Double => BitConverter.UInt64BitsToDouble(m_value).ToHexString(),
						_ => throw new NotImplementedException(m_objectType.ToString()),
					};
				}

				return m_objectType switch
				{
					ScalarType.Boolean => m_value == 1 ? "true" : "false",
					ScalarType.Byte => m_value.ToString(),
					ScalarType.SByte => unchecked((sbyte)m_value).ToString(),
					ScalarType.Int16 => unchecked((short)m_value).ToString(),
					ScalarType.UInt16 => m_value.ToString(),
					ScalarType.Int32 => unchecked((int)m_value).ToString(),
					ScalarType.UInt32 => m_value.ToString(),
					ScalarType.Int64 => unchecked((long)m_value).ToString(),
					ScalarType.UInt64 => m_value.ToString(),
					ScalarType.Single => BitConverter.UInt32BitsToSingle((uint)m_value).ToString(CultureInfo.InvariantCulture),
					ScalarType.Double => BitConverter.UInt64BitsToDouble(m_value).ToString(CultureInfo.InvariantCulture),
					ScalarType.String => m_string,
					_ => throw new NotImplementedException(m_objectType.ToString()),
				};
			}
			set => m_string = value;
		}
		public ScalarStyle Style { get; }

		private static readonly Regex s_illegal = new("(^\\s)|(^-\\s)|(^-$)|(^[\\:\\[\\]'\"*&!@#%{}?<>,\\`])|([:@]\\s)|([\\n\\r])|([:\\s]$)", RegexOptions.Compiled);

		private ScalarType m_objectType = ScalarType.String;
		private string m_string = string.Empty;
		private ulong m_value = 0;
	}
}

```

`AssetRipper.Yaml/YAMLSequenceNode.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Yaml
{
	public sealed class YamlSequenceNode : YamlNode
	{
		public YamlSequenceNode() { }

		public YamlSequenceNode(SequenceStyle style)
		{
			Style = style;
		}

		public void Add(bool value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(byte value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(short value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(ushort value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(int value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(uint value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(long value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(ulong value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(float value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(double value)
		{
			YamlScalarNode node = new YamlScalarNode(value, Style.IsRaw());
			Add(node);
		}

		public void Add(string value)
		{
			YamlScalarNode node = new YamlScalarNode(value);
			Add(node);
		}

		public void Add(YamlNode child)
		{
			m_children.Add(child);
		}

		internal override void Emit(Emitter emitter)
		{
			base.Emit(emitter);

			StartChildren(emitter);
			foreach (YamlNode child in m_children)
			{
				StartChild(emitter, child);
				child.Emit(emitter);
				EndChild(emitter, child);
			}
			EndChildren(emitter);
		}

		private void StartChildren(Emitter emitter)
		{
			switch (Style)
			{
				case SequenceStyle.Block:
					if (m_children.Count == 0)
					{
						emitter.Write('[');
					}

					break;

				case SequenceStyle.BlockCurve:
					if (m_children.Count == 0)
					{
						emitter.Write('{');
					}

					break;

				case SequenceStyle.Flow:
					emitter.Write('[');
					break;

				case SequenceStyle.Raw:
					if (m_children.Count == 0)
					{
						emitter.Write('[');
					}

					break;
			}
		}

		private void EndChildren(Emitter emitter)
		{
			switch (Style)
			{
				case SequenceStyle.Block:
					if (m_children.Count == 0)
					{
						emitter.Write(']');
					}

					emitter.WriteLine();
					break;

				case SequenceStyle.BlockCurve:
					if (m_children.Count == 0)
					{
						emitter.WriteClose('}');
					}

					emitter.WriteLine();
					break;

				case SequenceStyle.Flow:
					emitter.WriteClose(']');
					break;

				case SequenceStyle.Raw:
					if (m_children.Count == 0)
					{
						emitter.Write(']');
					}

					emitter.WriteLine();
					break;
			}
		}

		private void StartChild(Emitter emitter, YamlNode next)
		{
			if (Style.IsAnyBlock())
			{
				emitter.Write('-').Write(' ');

				if (next.NodeType == NodeType)
				{
					emitter.IncreaseIndent();
				}
			}
			if (next.IsIndent)
			{
				emitter.IncreaseIndent();
			}
		}

		private void EndChild(Emitter emitter, YamlNode next)
		{
			if (Style.IsAnyBlock())
			{
				emitter.WriteLine();
				if (next.NodeType == NodeType)
				{
					emitter.DecreaseIndent();
				}
			}
			else if (Style == SequenceStyle.Flow)
			{
				emitter.WriteSeparator().WriteWhitespace();
			}

			if (next.IsIndent)
			{
				emitter.DecreaseIndent();
			}
		}

		public static YamlSequenceNode Empty { get; } = new YamlSequenceNode();

		public override YamlNodeType NodeType => YamlNodeType.Sequence;
		public override bool IsMultiline => Style.IsAnyBlock() && m_children.Count > 0;
		public override bool IsIndent => false;

		public SequenceStyle Style { get; }

		public readonly List<YamlNode> m_children = new List<YamlNode>();
	}
}

```

`AssetRipper.Yaml/YAMLTag.cs`:

```cs
namespace AssetRipper.Yaml
{
	public readonly struct YamlTag
	{
		public YamlTag(string handle, string content)
		{
			Handle = handle;
			Content = content;
		}

		public override string ToString()
		{
			return IsEmpty ? string.Empty : $"{Handle}{Content}";
		}

		public string ToHeaderString()
		{
			return IsEmpty ? string.Empty : $"{Handle} {Content}";
		}

		public bool IsEmpty => string.IsNullOrEmpty(Handle);

		public string Handle { get; }
		public string Content { get; }
	}
}

```

`AssetRipper.Yaml/YAMLWriter.cs`:

```cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Yaml
{
	public class YamlWriter
	{
		public void AddDocument(YamlDocument document)
		{
#if DEBUG
			if (document == null)
				throw new ArgumentNullException(nameof(document));
			if (m_documents.Contains(document))
				throw new ArgumentException($"Document {document} is added already", nameof(document));
#endif
			m_documents.Add(document);
		}

		public void AddTag(string handle, string content)
		{
			if (m_tags.Any(t => t.Handle == handle))
			{
				throw new Exception($"Writer already contains tag {handle}");
			}

			YamlTag tag = new YamlTag(handle, content);
			m_tags.Add(tag);
		}

		public void Write(TextWriter output)
		{
			WriteHead(output);
			foreach (YamlDocument doc in m_documents)
			{
				WriteDocument(doc);
			}

			WriteTail(output);
		}

		public void WriteHead(TextWriter output)
		{
			m_emitter = new Emitter(output, IsFormatKeys);
			m_isWriteSeparator = false;

			if (IsWriteVersion)
			{
				m_emitter.WriteMeta(MetaType.Yaml, Version.ToString());
				m_isWriteSeparator = true;
			}

			if (IsWriteDefaultTag)
			{
				m_emitter.WriteMeta(MetaType.Tag, DefaultTag.ToHeaderString());
				m_isWriteSeparator = true;
			}
			foreach (YamlTag tag in m_tags)
			{
				m_emitter.WriteMeta(MetaType.Tag, tag.ToHeaderString());
				m_isWriteSeparator = true;
			}
		}

		public void WriteDocument(YamlDocument doc)
		{
			ThrowIfNullEmitter();
			doc.Emit(m_emitter, m_isWriteSeparator);
			m_isWriteSeparator = true;
		}

		public void WriteTail(TextWriter output)
		{
			output.Write('\n');
		}

		[System.Diagnostics.CodeAnalysis.MemberNotNull(nameof(m_emitter))]
		private void ThrowIfNullEmitter()
		{
			if (m_emitter is null)
			{
				throw new NullReferenceException("Emitter cannot be null");
			}
		}

		public static Version Version { get; } = new Version(1, 1);

		public const string DefaultTagHandle = "!u!";
		public const string DefaultTagContent = "tag:unity3d.com,2011:";

		public readonly YamlTag DefaultTag = new YamlTag(DefaultTagHandle, DefaultTagContent);

		public bool IsWriteVersion { get; set; } = true;
		public bool IsWriteDefaultTag { get; set; } = true;
		public bool IsFormatKeys { get; set; }

		private readonly HashSet<YamlDocument> m_documents = new HashSet<YamlDocument>();
		private readonly List<YamlTag> m_tags = new List<YamlTag>();

		private Emitter? m_emitter;
		private bool m_isWriteSeparator;
	}
}

```

`AssetRipper.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.0.31815.197
MinimumVisualStudioVersion = 10.0.40219.1
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipperConsole", "AssetRipperConsole\AssetRipperConsole.csproj", "{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipperCore", "AssetRipperCore\AssetRipperCore.csproj", "{CA9420F4-4B54-4727-91E6-CCE20916D795}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Solution Items", "Solution Items", "{825F97E7-5A2D-4D93-81AD-292F54FE2AC7}"
	ProjectSection(SolutionItems) = preProject
		.editorconfig = .editorconfig
		.gitignore = .gitignore
		LICENSE.md = LICENSE.md
		README.md = README.md
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Licenses", "Licenses", "{56F5A3D3-3388-476F-9852-D531BE14A9F8}"
	ProjectSection(SolutionItems) = preProject
		Licenses\AsmResolver.md = Licenses\AsmResolver.md
		Licenses\AssetStudio.md = Licenses\AssetStudio.md
		Licenses\Avalonia.md = Licenses\Avalonia.md
		Licenses\CommandLineParser.md = Licenses\CommandLineParser.md
		Licenses\Cpp2IL.md = Licenses\Cpp2IL.md
		Licenses\Crunch.md = Licenses\Crunch.md
		Licenses\Fmod5Sharp.md = Licenses\Fmod5Sharp.md
		Licenses\ILSpy.md = Licenses\ILSpy.md
		Licenses\ImageSharp.md = Licenses\ImageSharp.md
		Licenses\LibVLCSharp.md = Licenses\LibVLCSharp.md
		Licenses\Lz4.md = Licenses\Lz4.md
		Licenses\MeshSharp.md = Licenses\MeshSharp.md
		Licenses\MessageBoxAvalonia.md = Licenses\MessageBoxAvalonia.md
		Licenses\MonoCecil.md = Licenses\MonoCecil.md
		Licenses\NAudio.md = Licenses\NAudio.md
		Licenses\NAudioLame.md = Licenses\NAudioLame.md
		Licenses\NAudioVorbis.md = Licenses\NAudioVorbis.md
		Licenses\NVorbis.md = Licenses\NVorbis.md
		Licenses\SharpCompress.md = Licenses\SharpCompress.md
		Licenses\SharpGLTF.md = Licenses\SharpGLTF.md
		Licenses\SharpZipLib.md = Licenses\SharpZipLib.md
		Licenses\texgenpack.md = Licenses\texgenpack.md
		Licenses\uTinyRipper.md = Licenses\uTinyRipper.md
		Licenses\uTinyRipperExporter.md = Licenses\uTinyRipperExporter.md
		Licenses\Xiph.md = Licenses\Xiph.md
		Licenses\YamlDotNet.md = Licenses\YamlDotNet.md
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipperLibrary", "AssetRipperLibrary\AssetRipperLibrary.csproj", "{36C3C081-547B-4C0C-98D0-BB90BA07B976}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.SystemTester", "AssetRipper.SystemTester\AssetRipper.SystemTester.csproj", "{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "IssueTemplates", "IssueTemplates", "{38C0DDA2-6C7D-41F1-90F6-0B1DDA86C0EC}"
	ProjectSection(SolutionItems) = preProject
		.github\ISSUE_TEMPLATE\bug_report.yaml = .github\ISSUE_TEMPLATE\bug_report.yaml
		.github\ISSUE_TEMPLATE\config.yaml = .github\ISSUE_TEMPLATE\config.yaml
		.github\ISSUE_TEMPLATE\enhancement.yaml = .github\ISSUE_TEMPLATE\enhancement.yaml
		.github\ISSUE_TEMPLATE\other.yaml = .github\ISSUE_TEMPLATE\other.yaml
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.FileAnalyzer", "AssetRipper.FileAnalyzer\AssetRipper.FileAnalyzer.csproj", "{80284066-08A7-496A-A9EB-732966584CE8}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Workflows", "Workflows", "{88179FFC-0863-4C4F-9860-68EB1471E59F}"
	ProjectSection(SolutionItems) = preProject
		.github\workflows\auxiliary.yml = .github\workflows\auxiliary.yml
		.github\workflows\codeql.yml = .github\workflows\codeql.yml
		.github\workflows\docfx_build.yml = .github\workflows\docfx_build.yml
		.github\workflows\greetings.yml = .github\workflows\greetings.yml
		.github\workflows\publish.yml = .github\workflows\publish.yml
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipperGUI", "AssetRipperGUI\AssetRipperGUI.csproj", "{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Docs", "Docs", "{E3A52FDC-1C4D-430F-A1BA-BFC5671181D4}"
	ProjectSection(SolutionItems) = preProject
		docs\articles\CommonIssues.md = docs\articles\CommonIssues.md
		CONTRIBUTING.md = CONTRIBUTING.md
		docs\articles\Credits.md = docs\articles\Credits.md
		docs\docfx.json = docs\docfx.json
		docs\articles\Downloads.md = docs\articles\Downloads.md
		docs\index.md = docs\index.md
		docs\articles\Requirements.md = docs\articles\Requirements.md
		docs\articles\RoadMap.md = docs\articles\RoadMap.md
		docs\articles\RunningOnMac.md = docs\articles\RunningOnMac.md
		docs\articles\toc.yml = docs\articles\toc.yml
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipperCommon", "AssetRipperCommon\AssetRipperCommon.csproj", "{676FEE4F-6353-4D8B-B8E6-D89801D25575}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.Tests", "AssetRipper.Tests\AssetRipper.Tests.csproj", "{365C791E-431B-40E5-B724-BE375126AA11}"
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "ShellScripts", "ShellScripts", "{06FFA747-F995-4696-A09E-7559161EBA42}"
	ProjectSection(SolutionItems) = preProject
		generate_all.sh = generate_all.sh
		get_names.sh = get_names.sh
	EndProjectSection
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "ShaderTextRestorer", "ShaderTextRestorer\ShaderTextRestorer.csproj", "{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "Smolv", "Smolv\Smolv.csproj", "{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "SpirV", "SpirV\SpirV.csproj", "{2135442C-E861-486D-A07B-0367A09177F9}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.Fundamentals", "AssetRipper.Fundamentals\AssetRipper.Fundamentals.csproj", "{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.Yaml", "AssetRipper.Yaml\AssetRipper.Yaml.csproj", "{E3458355-E654-41B9-A06C-9E2A00EA9CE2}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.SerializationLogic", "AssetRipper.SerializationLogic\AssetRipper.SerializationLogic.csproj", "{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}"
EndProject
Project("{9A19103F-16F7-4668-BE54-9A1E7A4F7556}") = "AssetRipper.Yaml.Tests", "AssetRipper.Yaml.Tests\AssetRipper.Yaml.Tests.csproj", "{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AssetRipper.IO.Endian", "AssetRipper.IO.Endian\AssetRipper.IO.Endian.csproj", "{82436B39-9077-407B-9FE6-51E1BEADB855}"
EndProject
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AssetRipper.IO.Files", "AssetRipper.IO.Files\AssetRipper.IO.Files.csproj", "{95684DEF-EFC1-4649-AD9E-4660DA7A584A}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		DebugLinux|x64 = DebugLinux|x64
		DebugMac|x64 = DebugMac|x64
		DebugWindows|x64 = DebugWindows|x64
		ReleaseLinux|x64 = ReleaseLinux|x64
		ReleaseMac|x64 = ReleaseMac|x64
		ReleaseWindows|x64 = ReleaseWindows|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugLinux|x64.ActiveCfg = DebugLinux|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugLinux|x64.Build.0 = DebugLinux|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugMac|x64.ActiveCfg = DebugMac|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugMac|x64.Build.0 = DebugMac|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugWindows|x64.ActiveCfg = DebugWindows|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.DebugWindows|x64.Build.0 = DebugWindows|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseLinux|x64.ActiveCfg = ReleaseLinux|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseLinux|x64.Build.0 = ReleaseLinux|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseMac|x64.ActiveCfg = ReleaseMac|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseMac|x64.Build.0 = ReleaseMac|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseWindows|x64.ActiveCfg = ReleaseWindows|x64
		{C9583270-6D3E-4CBF-8011-A818A7D8F3DC}.ReleaseWindows|x64.Build.0 = ReleaseWindows|x64
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugMac|x64.Build.0 = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{CA9420F4-4B54-4727-91E6-CCE20916D795}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugLinux|x64.ActiveCfg = DebugLinux|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugLinux|x64.Build.0 = DebugLinux|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugMac|x64.ActiveCfg = DebugMac|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugMac|x64.Build.0 = DebugMac|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugWindows|x64.ActiveCfg = DebugWindows|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.DebugWindows|x64.Build.0 = DebugWindows|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseLinux|x64.ActiveCfg = ReleaseLinux|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseLinux|x64.Build.0 = ReleaseLinux|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseMac|x64.ActiveCfg = ReleaseMac|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseMac|x64.Build.0 = ReleaseMac|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseWindows|x64.ActiveCfg = ReleaseWindows|x64
		{36C3C081-547B-4C0C-98D0-BB90BA07B976}.ReleaseWindows|x64.Build.0 = ReleaseWindows|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugLinux|x64.ActiveCfg = DebugLinux|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugLinux|x64.Build.0 = DebugLinux|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugMac|x64.ActiveCfg = DebugMac|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugMac|x64.Build.0 = DebugMac|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugWindows|x64.ActiveCfg = DebugWindows|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.DebugWindows|x64.Build.0 = DebugWindows|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseLinux|x64.ActiveCfg = ReleaseLinux|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseLinux|x64.Build.0 = ReleaseLinux|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseMac|x64.ActiveCfg = ReleaseMac|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseMac|x64.Build.0 = ReleaseMac|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseWindows|x64.ActiveCfg = ReleaseWindows|x64
		{7B061A55-5B4A-4A22-B0A6-A4BF2093BF42}.ReleaseWindows|x64.Build.0 = ReleaseWindows|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugLinux|x64.ActiveCfg = DebugLinux|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugLinux|x64.Build.0 = DebugLinux|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugMac|x64.ActiveCfg = DebugMac|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugMac|x64.Build.0 = DebugMac|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugWindows|x64.ActiveCfg = DebugWindows|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.DebugWindows|x64.Build.0 = DebugWindows|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseLinux|x64.ActiveCfg = ReleaseLinux|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseLinux|x64.Build.0 = ReleaseLinux|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseMac|x64.ActiveCfg = ReleaseMac|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseMac|x64.Build.0 = ReleaseMac|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseWindows|x64.ActiveCfg = ReleaseWindows|x64
		{80284066-08A7-496A-A9EB-732966584CE8}.ReleaseWindows|x64.Build.0 = ReleaseWindows|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugLinux|x64.ActiveCfg = DebugLinux|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugLinux|x64.Build.0 = DebugLinux|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugMac|x64.ActiveCfg = DebugMac|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugMac|x64.Build.0 = DebugMac|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugWindows|x64.ActiveCfg = DebugWindows|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.DebugWindows|x64.Build.0 = DebugWindows|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseLinux|x64.ActiveCfg = ReleaseLinux|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseLinux|x64.Build.0 = ReleaseLinux|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseMac|x64.ActiveCfg = ReleaseMac|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseMac|x64.Build.0 = ReleaseMac|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseWindows|x64.ActiveCfg = ReleaseWindows|x64
		{8CDB3DC9-77D2-4295-BB04-CEA24CA59B93}.ReleaseWindows|x64.Build.0 = ReleaseWindows|x64
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugMac|x64.Build.0 = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{676FEE4F-6353-4D8B-B8E6-D89801D25575}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugMac|x64.Build.0 = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{365C791E-431B-40E5-B724-BE375126AA11}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugMac|x64.Build.0 = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{38B51E0B-9F05-4BFA-B6B4-49DEAAA876A3}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugMac|x64.Build.0 = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{8985E7C1-DFCB-45B2-8369-130A1C45C6D3}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugMac|x64.Build.0 = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{2135442C-E861-486D-A07B-0367A09177F9}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugMac|x64.Build.0 = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{AC2D1259-7BFF-4960-A9B9-A5B4D4CD4F04}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugMac|x64.Build.0 = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{E3458355-E654-41B9-A06C-9E2A00EA9CE2}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugMac|x64.Build.0 = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{0077BA34-CA1E-4A08-8B3A-49B8EA57EA40}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugMac|x64.Build.0 = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{838B66B6-B54D-4BEE-B7E3-888E8FDE7CAE}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugMac|x64.Build.0 = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{82436B39-9077-407B-9FE6-51E1BEADB855}.ReleaseWindows|x64.Build.0 = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugLinux|x64.ActiveCfg = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugLinux|x64.Build.0 = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugMac|x64.ActiveCfg = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugMac|x64.Build.0 = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugWindows|x64.ActiveCfg = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.DebugWindows|x64.Build.0 = Debug|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseLinux|x64.ActiveCfg = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseLinux|x64.Build.0 = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseMac|x64.ActiveCfg = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseMac|x64.Build.0 = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseWindows|x64.ActiveCfg = Release|Any CPU
		{95684DEF-EFC1-4649-AD9E-4660DA7A584A}.ReleaseWindows|x64.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{56F5A3D3-3388-476F-9852-D531BE14A9F8} = {825F97E7-5A2D-4D93-81AD-292F54FE2AC7}
		{38C0DDA2-6C7D-41F1-90F6-0B1DDA86C0EC} = {825F97E7-5A2D-4D93-81AD-292F54FE2AC7}
		{88179FFC-0863-4C4F-9860-68EB1471E59F} = {825F97E7-5A2D-4D93-81AD-292F54FE2AC7}
		{E3A52FDC-1C4D-430F-A1BA-BFC5671181D4} = {825F97E7-5A2D-4D93-81AD-292F54FE2AC7}
		{06FFA747-F995-4696-A09E-7559161EBA42} = {825F97E7-5A2D-4D93-81AD-292F54FE2AC7}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {ED4FF66B-4A6D-4440-8721-23C5ED09791C}
	EndGlobalSection
EndGlobal

```

`AssetRipper.sln.DotSettings`:

```DotSettings
<wpf:ResourceDictionary xml:space="preserve" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" xmlns:s="clr-namespace:System;assembly=mscorlib" xmlns:ss="urn:shemas-jetbrains-com:settings-storage-xaml" xmlns:wpf="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
	<s:String x:Key="/Default/CodeStyle/Naming/CSharpNaming/Abbreviations/=YAML/@EntryIndexedValue">YAML</s:String></wpf:ResourceDictionary>
```

`AssetRipperCommon/AssetRipperCommon.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<OutputPath>..\Bins\AssetRipperCommon\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipperCommon\$(Configuration)\</IntermediateOutputPath>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<AssemblyName>AssetRipperCommon</AssemblyName>
		<RootNamespace>AssetRipper.Core</RootNamespace>
		<Copyright>Copyright ©  2022</Copyright>
		<Authors>ds5678</Authors>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='Debug'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.VersionUtilities" Version="1.2.1" />
		<PackageReference Include="K4os.Compression.LZ4" Version="1.2.16" />
		<PackageReference Include="Mono.Cecil" Version="0.11.4" />
		<PackageReference Include="Samboy063.Cpp2IL.Core" Version="2022.0.5" />
		<PackageReference Include="SharpCompress" Version="0.32.1" />
		<PackageReference Include="SharpZipLib" Version="1.3.3" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="AssetRipper.SourceGenerated">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>../Libraries/AssetRipper.SourceGenerated.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
	  <ProjectReference Include="..\AssetRipper.Fundamentals\AssetRipper.Fundamentals.csproj" />
	  <ProjectReference Include="..\AssetRipper.Yaml\AssetRipper.Yaml.csproj" />
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

</Project>

```

`AssetRipperCommon/Classes/Animation/AnimationCullingType.cs`:

```cs
namespace AssetRipper.Core.Classes.Animation
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Animation/ScriptBindings/Animation.bindings.cs"/>
	/// </summary>
	public enum AnimationCullingType
	{
		AlwaysAnimate = 0,
		BasedOnRenderers = 1,
		BasedOnClipBounds = 2,
		BasedOnUserBounds = 3,
	}
}

```

`AssetRipperCommon/Classes/AnimationClip/AnimationType.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimationClip
{
	public enum AnimationType
	{
		Legacy = 1,
		Mecanim = 2,
		Human = 3,
	}
}

```

`AssetRipperCommon/Classes/AnimationClip/GenericBinding/BindingCustomType.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimationClip.GenericBinding
{
	public enum BindingCustomType : byte
	{
		None = 0,
		Transform = 4,
		AnimatorMuscle = 8,

		BlendShape = 20,
		Renderer = 21,
		RendererMaterial = 22,
		SpriteRenderer = 23,
		MonoBehaviour = 24,
		Light = 25,
		RendererShadows = 26,
		ParticleSystem = 27,
		RectTransform = 28,
		LineRenderer = 29,
		TrailRenderer = 30,
		PositionConstraint = 31,
		RotationConstraint = 32,
		ScaleConstraint = 33,
		AimConstraint = 34,
		ParentConstraint = 35,
		LookAtConstraint = 36,
		Camera = 37,
		VisualEffect = 38,
		ParticleForceField = 39,
		UserDefined = 40,
		MeshFilter = 41,
	}
}
/*BindType
kUnbound 0x0
kBindTransformPosition 0x1
kBindTransformRotation 0x2
kBindTransformScale 0x3
kBindTransformEuler 0x4
kMinSinglePropertyBinding 0x5
kBindFloat 0x5
kBindFloatToBool 0x6
kBindGameObjectActive 0x7
kBindMuscle 0x8
kBindScriptObjectReference 0x9
kBindFloatToInt 0xa
kBindDiscreteInt 0xb
kBlendShapeWeightBinding 0x14
kRendererMaterialPPtrBinding 0x15
kRendererMaterialPropertyBinding 0x16
kSpriteRendererPPtrBinding 0x17
kMonoBehaviourPropertyBinding 0x18
kLightPropertyBinding 0x19
kRendererOtherPropertyBinding 0x1a
kParticleSystemPropertyBindings 0x1b
kRectTransformPropertyBindings 0x1c
kLineRendererPropertyBindings 0x1d
kTrailRendererPropertyBindings 0x1e
kPositionConstraintPropertyBindings 0x1f
kRotationConstraintPropertyBindings 0x20
kScaleConstraintPropertyBindings 0x21
kAimConstraintPropertyBindings 0x22
kParentConstraintPropertyBindings 0x23
kLookAtConstraintPropertyBindings 0x24
kCameraPropertyBindings 0x25
kVisualEffectPropertyBindings 0x26
kParticleForceFieldPropertyBinding 0x27
kUserDefinedBinding 0x28
kMeshFilterBinding 0x29
kAllBindingCount 0x2a    */

```

`AssetRipperCommon/Classes/AnimationClip/GenericBinding/TransformType.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimationClip.GenericBinding
{
	public enum TransformType
	{
		Translation = 1,
		Rotation = 2,
		Scaling = 3,
		EulerRotation = 4,
	}

	public static class BindingTypeExtensions
	{
		public static bool IsValid(this TransformType _this)
		{
			return _this >= TransformType.Translation && _this <= TransformType.EulerRotation;
		}

		public static int GetDimension(this TransformType _this)
		{
			switch (_this)
			{
				case TransformType.Translation:
				case TransformType.Scaling:
				case TransformType.EulerRotation:
					return 3;

				case TransformType.Rotation:
					return 4;

				default:
					throw new NotImplementedException($"Binding type {_this} is not implemented");
			}
		}
	}
}

```

`AssetRipperCommon/Classes/AnimationClip/HumanoidMuscleType.cs`:

```cs
using AssetRipper.Core.Classes.Misc.Bones;

namespace AssetRipper.Core.Classes.AnimationClip
{
	public enum HumanoidMuscleType
	{
		Motion = 0,
		Root = Motion + 7,
		Limbs = Root + 7,
		Muscles = Limbs + LimbType.Last * 7,
		Fingers = Muscles + MuscleType.Last,
		TDoFBones = Fingers + ArmType.Last * FingerType.Last * FingerDoFType.Last,

		Last = TDoFBones + TDoFBoneType.Last * 3,
	}

	public static class HumanoidMuscleTypeExtensions
	{
		public static HumanoidMuscleType Update(this HumanoidMuscleType _this, UnityVersion version)
		{
			if (_this < HumanoidMuscleType.Muscles)
			{
				return _this;
			}

			MuscleType muscle = (MuscleType)(_this - HumanoidMuscleType.Muscles);
			MuscleType fixedMuscle = muscle.Update(version);
			_this = HumanoidMuscleType.Muscles + (int)fixedMuscle;
			if (_this < HumanoidMuscleType.TDoFBones)
			{
				return _this;
			}

			TDoFBoneType tdof = (TDoFBoneType)(_this - HumanoidMuscleType.TDoFBones);
			TDoFBoneType fixedTdof = tdof.Update(version);
			_this = HumanoidMuscleType.TDoFBones + (int)fixedTdof;
			return _this;
		}

		public static string ToAttributeString(this HumanoidMuscleType _this)
		{
			if (_this < HumanoidMuscleType.Root)
			{
				int delta = _this - HumanoidMuscleType.Motion;
				return nameof(HumanoidMuscleType.Motion) + GetTransformPostfix(delta % 7);
			}
			if (_this < HumanoidMuscleType.Limbs)
			{
				int delta = _this - HumanoidMuscleType.Root;
				return nameof(HumanoidMuscleType.Root) + GetTransformPostfix(delta % 7);
			}
			if (_this < HumanoidMuscleType.Muscles)
			{
				int delta = _this - HumanoidMuscleType.Limbs;
				LimbType limb = (LimbType)(delta / 7);
				return limb.ToBoneType().ToAttributeString() + GetTransformPostfix(delta % 7);
			}
			if (_this < HumanoidMuscleType.Fingers)
			{
				int delta = _this - HumanoidMuscleType.Muscles;
				MuscleType muscle = (MuscleType)delta;
				return muscle.ToAttributeString();
			}
			if (_this < HumanoidMuscleType.TDoFBones)
			{
				const int armSize = (int)FingerType.Last * (int)FingerDoFType.Last;
				const int dofSize = (int)FingerDoFType.Last;
				int delta = _this - HumanoidMuscleType.Fingers;
				ArmType arm = (ArmType)(delta / armSize);
				delta = delta % armSize;
				FingerType finger = (FingerType)(delta / dofSize);
				delta = delta % dofSize;
				FingerDoFType dof = (FingerDoFType)delta;
				return $"{arm.ToBoneType().ToAttributeString()}.{finger.ToAttributeString()}.{dof.ToAttributeString()}";
			}
			if (_this < HumanoidMuscleType.Last)
			{
				int delta = _this - HumanoidMuscleType.TDoFBones;
				TDoFBoneType tdof = (TDoFBoneType)(delta / 3);
				return $"{tdof.ToBoneType().ToAttributeString()}{GetTDoFTransformPostfix(delta % 3)}";
			}
			throw new ArgumentException(_this.ToString());
		}

		private static string GetTransformPostfix(int index)
		{
			return index switch
			{
				0 => "T.x",
				1 => "T.y",
				2 => "T.z",
				3 => "Q.x",
				4 => "Q.y",
				5 => "Q.z",
				6 => "Q.w",
				_ => throw new ArgumentException(index.ToString()),
			};
		}

		private static string GetTDoFTransformPostfix(int index)
		{
			return index switch
			{
				0 => "TDOF.x",
				1 => "TDOF.y",
				2 => "TDOF.z",
				_ => throw new ArgumentException(index.ToString()),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/AnimationClip/WrapMode.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimationClip
{
	/// <summary>
	/// Determines how time is treated outside of the keyframed range of an AnimationClip or AnimationCurve.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Animation/AnimationCurve.bindings.cs"/>
	/// </summary>
	public enum WrapMode
	{
		/// <summary>
		/// Reads the default repeat mode set higher up.
		/// </summary>
		Default = 0,
		Clamp = 1,
		/// <summary>
		/// When time reaches the end of the animation clip, the clip will automatically stop playing and time will be reset to beginning of the clip.
		/// </summary>
		Once = 1,
		/// <summary>
		/// When time reaches the end of the animation clip, time will continue at the beginning.
		/// </summary>
		Loop = 2,
		/// <summary>
		/// When time reaches the end of the animation clip, time will ping pong back between beginning and end.
		/// </summary>
		PingPong = 4,
		/// <summary>
		/// Plays back the animation. When it reaches the end, it will keep playing the last frame and never stop playing.
		/// </summary>
		ClampForever = 8,
	}
}

```

`AssetRipperCommon/Classes/Animator/AnimatorCullingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Animator
{
	/// <summary>
	/// Culling mode for the Animator.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Animation/ScriptBindings/Animator.bindings.cs"/>
	/// </summary>
	public enum AnimatorCullingMode
	{
		/// <summary>
		/// Always animate the entire character. Object is animated even when offscreen.
		/// </summary>
		AlwaysAnimate = 0,
		/// <summary>
		/// Retarget, IK and write of Transforms are disabled when renderers are not visible.
		/// </summary>
		CullUpdateTransforms = 1,
		BasedOnRenderers = 1,
		/// <summary>
		/// Animation is completely disabled when renderers are not visible.
		/// </summary>
		CullCompletely = 2,
	}
}

```

`AssetRipperCommon/Classes/Animator/AnimatorUpdateMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Animator
{
	/// <summary>
	/// The update mode of the Animator.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Animation/ScriptBindings/Animator.bindings.cs"/>
	/// </summary>
	public enum AnimatorUpdateMode
	{
		/// <summary>
		/// Normal update of the animator.
		/// </summary>
		Normal = 0,
		/// <summary>
		/// Updates the animator during the physic loop in order to have the animation system synchronized with the physics engine.
		/// </summary>
		AnimatePhysics = 1,
		/// <summary>
		/// Animator updates independently of Time.timeScale.
		/// </summary>
		UnscaledTime = 2,
	}
}

```

`AssetRipperCommon/Classes/AnimatorController/Constants/IBlend1dDataConstant.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Classes.AnimatorController.Constants
{
	public interface IBlend1dDataConstant : IAsset
	{
		float[] ChildThresholdArray { get; set; }
	}
}

```

`AssetRipperCommon/Classes/AnimatorController/Constants/TransitionInterruptionSource.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimatorController.Constants
{
	/// <summary>
	/// Which AnimatorState transitions can interrupt the Transition.
	/// </summary>
	public enum TransitionInterruptionSource
	{
		/// <summary>
		/// The Transition cannot be interrupted. Formely know as Atomic.
		/// </summary>
		None = 0,
		/// <summary>
		/// The Transition can be interrupted by transitions in the source AnimatorState.
		/// </summary>
		Source = 1,
		/// <summary>
		/// The Transition can be interrupted by transitions in the destination AnimatorState.
		/// </summary>
		Destination = 2,
		/// <summary>
		/// The Transition can be interrupted by transitions in the source or the destination AnimatorState.
		/// </summary>
		SourceThenDestination = 3,
		/// <summary>
		/// The Transition can be interrupted by transitions in the source or the destination AnimatorState.
		/// </summary>
		DestinationThenSource = 4
	}
}

```

`AssetRipperCommon/Classes/AnimatorController/Editor/AnimatorControllerLayer/AnimatorLayerBlendingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerLayer
{
	/// <summary>
	/// Specifies how the layer is blended with the previous layers.
	/// </summary>
	public enum AnimatorLayerBlendingMode
	{
		/// <summary>
		/// Animations are added to the previous layers.
		/// </summary>
		Override,
		/// <summary>
		/// Animations overrides to the previous layers.
		/// </summary>
		Additive,
	}
}

```

`AssetRipperCommon/Classes/AnimatorController/Editor/AnimatorControllerParameter/AnimatorControllerParameterType.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerParameter
{
	/// <summary>
	/// The type of the parameter.
	/// </summary>
	public enum AnimatorControllerParameterType
	{
		/// <summary>
		/// Float type parameter.
		/// </summary>
		Float = 1,
		/// <summary>
		/// Int type parameter.
		/// </summary>
		Int = 3,
		/// <summary>
		/// Boolean type parameter.
		/// </summary>
		Bool = 4,
		/// <summary>
		/// Trigger type parameter.
		/// </summary>
		Trigger = 9
	}
}

```

`AssetRipperCommon/Classes/AnimatorTransition/AnimatorConditionMode.cs`:

```cs
namespace AssetRipper.Core.Classes.AnimatorTransition
{
	/// <summary>
	/// The mode of the condition.
	/// </summary>
	public enum AnimatorConditionMode
	{
		/// <summary>
		/// The condition is true when the parameter value is true.
		/// </summary>
		If = 1,
		/// <summary>
		/// The condition is true when the parameter value is false.
		/// </summary>
		IfNot = 2,
		/// <summary>
		/// The condition is true when parameter value is greater than the threshold.
		/// </summary>
		Greater = 3,
		/// <summary>
		/// The condition is true when the parameter value is less than the threshold.
		/// </summary>
		Less = 4,
		/// <summary>
		/// The condition is true when the source state has stepped over the exit time value.
		/// </summary>
		ExitTime = 5,
		/// <summary>
		/// The condition is true when parameter value is equal to the threshold.
		/// </summary>
		Equals = 6,
		/// <summary>
		/// The condition is true when the parameter value is not equal to the threshold.
		/// </summary>
		NotEqual = 7,
	}
}

```

`AssetRipperCommon/Classes/AudioClip/AudioClipLoadType.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioClip
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Audio/Public/ScriptBindings/Audio.bindings.cs"/>
	/// </summary>
	public enum AudioClipLoadType
	{
		DecompressOnLoad = 0,
		CompressedInMemory = 1,
		/// <summary>
		/// StreamFromDisc previously
		/// </summary>
		Streaming = 2,
	}
}

```

`AssetRipperCommon/Classes/AudioClip/AudioCompressionFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioClip
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Audio/Public/ScriptBindings/Audio.bindings.cs"/>
	/// </summary>
	public enum AudioCompressionFormat
	{
		PCM = 0,
		Vorbis = 1,
		ADPCM = 2,
		MP3 = 3,
		VAG = 4,
		HEVAG = 5,
		XMA = 6,
		AAC = 7,
		GCADPCM = 8,
		ATRAC9 = 9,
	}

	public static class AudioCompressionFormatExtentions
	{
		public static string ToRawExtension(this AudioCompressionFormat compressionFormat)
		{
			switch (compressionFormat)
			{
				case AudioCompressionFormat.PCM:
				case AudioCompressionFormat.Vorbis:
				case AudioCompressionFormat.ADPCM:
				case AudioCompressionFormat.MP3:
				case AudioCompressionFormat.GCADPCM:
					return "fsb";
				case AudioCompressionFormat.VAG:
				case AudioCompressionFormat.HEVAG:
					return "vag";
				case AudioCompressionFormat.XMA:
					return "wav";
				case AudioCompressionFormat.AAC:
					return "m4a";
				case AudioCompressionFormat.ATRAC9:
					return "at9";
				default:
					return "audioClip";
			}
		}
	}
}

```

`AssetRipperCommon/Classes/AudioClip/AudioType.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioClip
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Audio/AudioType.cs"/>
	/// </summary>
	public enum AudioType
	{
		/// <summary>
		/// 3rd party / unknown plugin format.
		/// </summary>
		UNKNOWN = 0,
		/// <summary>
		/// Depreciated at some point
		/// </summary>
		ACC = 1,
		/// <summary>
		/// aiff
		/// </summary>
		AIFF = 2,
		/// <summary>
		/// Microsoft Advanced Systems Format (ie WMA/ASF/WMV).
		/// </summary>
		ASF = 3,
		/// <summary>
		/// Sony ATRAC 3 format
		/// </summary>
		AT3 = 4,
		/// <summary>
		/// Digital CD audio.
		/// </summary>
		CDDA = 5,
		/// <summary>
		/// Sound font / downloadable sound bank.
		/// </summary>
		DLS = 6,
		/// <summary>
		/// FLAC lossless codec.
		/// </summary>
		FLAC = 7,
		/// <summary>
		/// FMOD Sample Bank.
		/// </summary>
		FSB = 8,
		/// <summary>
		/// GameCube ADPCM
		/// </summary>
		GCADPCM = 9,
		/// <summary>
		/// Impulse Tracker
		/// </summary>
		IT = 10,
		/// <summary>
		/// MIDI.
		/// </summary>
		MIDI = 11,
		/// <summary>
		/// Protracker / Fasttracker MOD.
		/// </summary>
		MOD = 12,
		/// <summary>
		/// MP2/MP3 MPEG.
		/// </summary>
		MPEG = 13,
		/// <summary>
		/// ogg vorbis
		/// </summary>
		OGGVORBIS = 14,
		/// <summary>
		/// Information only from ASX/PLS/M3U/WAX playlists
		/// </summary>
		PLAYLIST = 15,
		/// <summary>
		/// Raw PCM data.
		/// </summary>
		RAW = 16,
		/// <summary>
		/// ScreamTracker 3.
		/// </summary>
		S3M = 17,
		/// <summary>
		/// Sound font 2 format.
		/// </summary>
		SF2 = 18,
		/// <summary>
		/// User created sound.
		/// </summary>
		USER = 19,
		/// <summary>
		/// Microsoft WAV.
		/// </summary>
		WAV = 20,
		/// <summary>
		/// FastTracker 2 XM.
		/// </summary>
		XM = 21,
		/// <summary>
		/// XboxOne XMA(2)
		/// </summary>
		XMA = 22,
		/// <summary>
		/// PlayStation 2 / PlayStation Portable adpcm VAG format.
		/// </summary>
		VAG = 23,
		/// <summary>
		/// iPhone hardware decoder, supports AAC, ALAC and MP3. Extracodecdata is a pointer to an FMOD_AUDIOQUEUE_EXTRACODECDATA structure.
		/// </summary>
		AUDIOQUEUE = 24,
		/// <summary>
		/// Xbox360 XWMA
		/// </summary>
		XWMA = 25,
		/// <summary>
		/// 3DS BCWAV container format for DSP ADPCM and PCM
		/// </summary>
		BCWAV = 26,
		/// <summary>
		/// NGP ATRAC 9 format
		/// </summary>
		AT9 = 27,
		PCM = 28,
		ADPCM = 29,
	}
}

```

`AssetRipperCommon/Classes/AudioClip/FMODSoundFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioClip
{
	public enum FMODSoundFormat
	{
		NONE = 0x0,
		PCM8 = 0x1,
		PCM16 = 0x2,
		PCM24 = 0x3,
		PCM32 = 0x4,
		PCMFLOAT = 0x5,
		GCADPCM = 0x6,
		IMAADPCM = 0x7,
		VAG = 0x8,
		HEVAG = 0x9,
		XMA = 0x0A,
		MPEG = 0x0B,
		CELT = 0x0C,
		AT9 = 0x0D,
		XWMA = 0x0E,
		VORBIS = 0x0F,
		MAX = 0x10,
		FORCEINT = 0x10000,
	}
}

```

`AssetRipperCommon/Classes/AudioClip/FMODSoundType.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioClip
{
	public enum FMODSoundType
	{
		Unknown = 0x0,
		ACC = 0x1,
		AIFF = 0x2,
		ASF = 0x3,
		AT3 = 0x4,
		CDDA = 0x5,
		DLS = 0x6,
		FLAC = 0x7,
		FSB = 0x8,
		GCADPCM = 0x9,
		IT = 0xA,
		MIDI = 0xB,
		MOD = 0xC,
		MPEG = 0xD,
		OGGVORBIS = 0xE,
		PLAYLIST = 0xF,
		RAW = 0x10,
		S3M = 0x11,
		SF2 = 0x12,
		USER = 0x13,
		WAV = 0x14,
		XM = 0x15,
		XMA = 0x16,
		VAG = 0x17,
		AUDIOQUEUE = 0x18,
		XWMA = 0x19,
		BCWAV = 0x1A,
		AT9 = 0x1B,
		VORBIS = 0x1C,
		MEDIA_FOUNDATION = 0x1D,
		MAX = 0x1E,
		FORCEINT = 0x10000,
	}

	public static class FMODSoundTypeExtensions
	{
		public static string ToRawExtension(this FMODSoundType soundType) => soundType switch
		{
			FMODSoundType.ACC => "m4a",
			FMODSoundType.AIFF => "aif",
			FMODSoundType.IT => "it",
			FMODSoundType.MOD => "mod",
			FMODSoundType.MPEG => "mp3",
			FMODSoundType.OGGVORBIS => "ogg",
			FMODSoundType.S3M => "s3m",
			FMODSoundType.WAV => "wav",
			FMODSoundType.XM => "xm",
			FMODSoundType.XMA => "wav",
			FMODSoundType.VAG => "vag",
			FMODSoundType.AUDIOQUEUE => "fsb",
			_ => "audioClip",
		};
	}
}

```

`AssetRipperCommon/Classes/AudioManager/AudioSpeakerMode.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioManager
{
	public enum AudioSpeakerMode
	{
		/// <summary>
		/// Channel count is unaffected.
		/// </summary>
		Raw = 0,
		/// <summary>
		/// Channel count is set to 1. The speakers are monaural.
		/// </summary>
		Mono = 1,
		/// <summary>
		/// Channel count is set to 2. The speakers are stereo. This is the editor default.
		/// </summary>
		Stereo = 2,
		/// <summary>
		/// Channel count is set to 4. 4 speaker setup. This includes front left, front right, rear left, rear right.
		/// </summary>
		Quad = 3,
		/// <summary>
		/// Channel count is set to 5. 5 speaker setup. This includes front left, front right, center, rear left, rear right.
		/// </summary>
		Surround = 4,
		/// <summary>
		/// Channel count is set to 6. 5.1 speaker setup. This includes front left, front right, center, rear left, rear right and a subwoofer.
		/// </summary>
		Mode5point1 = 5,
		/// <summary>
		/// Channel count is set to 8. 7.1 speaker setup. This includes front left, front right, center, rear left, rear right, side left, side right and a subwoofer.
		/// </summary>
		Mode7point1 = 6,
		/// <summary>
		/// Channel count is set to 2. Stereo output, but data is encoded in a way that is picked up by a Prologic/Prologic2 decoder and split into a 5.1 speaker setup.
		/// </summary>
		Prologic = 7,
	}
}

```

`AssetRipperCommon/Classes/AudioReverbFilter/AudioReverbPreset.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioReverbFilter
{
	/// <summary>
	/// <see href="https://docs.unity3d.com/ScriptReference/AudioReverbPreset.html"/>
	/// </summary>
	public enum AudioReverbPreset
	{
		Off = 0,
		Generic = 1,
		PaddedCell = 2,
		Room = 3,
		Bathroom = 4,
		Livingroom = 5,
		Stoneroom = 6,
		Auditorium = 7,
		Concerthall = 8,
		Cave = 9,
		Arena = 10,
		Hangar = 11,
		CarpetedHallway = 12,
		Hallway = 13,
		StoneCorridor = 14,
		Alley = 15,
		Forest = 16,
		City = 17,
		Mountains = 18,
		Quarry = 19,
		Plain = 20,
		ParkingLot = 21,
		SewerPipe = 22,
		Underwater = 23,
		Drugged = 24,
		Dizzy = 25,
		Psychotic = 26,
		User = 27
	}
}

```

`AssetRipperCommon/Classes/AudioSource/AudioRolloffMode.cs`:

```cs
namespace AssetRipper.Core.Classes.AudioSource
{
	public enum AudioRolloffMode
	{
		Logarithmic = 0,
		Linear = 1,
		Custom = 2
	}
}

```

`AssetRipperCommon/Classes/Avatar/BodyDoF.cs`:

```cs
namespace AssetRipper.Core.Classes.Avatar
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Animation/ScriptBindings/Avatar.bindings.cs"/>
	/// </summary>
	public enum BodyDoF
	{
		SpineFrontBack = 0,
		SpineLeftRight = 1,
		SpineRollLeftRight = 2,
#warning TODO: check since reference has this as 3 not 4
		ChestFrontBack = 4,
		ChestLeftRight = 5,
		ChestRollLeftRight = 6,
		UpperChestFrontBack = 7,
		UpperChestLeftRight = 8,
		UpperChestRollLeftRight = 9,
		LastBodyDoF = 10,
	}
}

```

`AssetRipperCommon/Classes/BlendTree/BlendTreeType.cs`:

```cs
namespace AssetRipper.Core.Classes.BlendTree
{
	/// <summary>
	/// The type of blending algorithm that the blend tree uses.
	/// </summary>
	public enum BlendTreeType
	{
		/// <summary>
		/// Basic blending using a single parameter.
		/// </summary>
		Simple1D = 0,
		/// <summary>
		/// Best used when your motions represent different directions, such as "walk forward",
		/// "walk backward", "walk left", and "walk right", or "aim up", "aim down", "aim left", and "aim right".
		/// </summary>
		SimpleDirectional2D = 1,
		/// <summary>
		/// This blend type is used when your motions represent different directions, however you can have multiple
		/// motions in the same direction, for example "walk forward" and "run forward".
		/// </summary>
		FreeformDirectional2D = 2,
		/// <summary>
		/// Best used when your motions do not represent different directions.
		/// </summary>
		FreeformCartesian2D = 3,
		/// <summary>
		/// Direct control of blending weight for each node.
		/// </summary>
		Direct = 4,
	}
}

```

`AssetRipperCommon/Classes/Camera/FieldOfViewAxis.cs`:

```cs
namespace AssetRipper.Core.Classes.Camera
{
	/// <summary>
	/// Enumerates which axis to use when expressing the value for the field of view
	/// </summary>
	public enum FieldOfViewAxis
	{
		/// <summary>
		/// Specifies the field of view as vertical
		/// </summary>
		Vertical = 0,
		/// <summary>
		/// Specifies the field of view as horizontal
		/// </summary>
		Horizontal = 1,
	}
}

```

`AssetRipperCommon/Classes/Camera/GateFitMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Camera
{
	public enum GateFitMode
	{
		/// <summary>
		/// Stretch the sensor gate to fit exactly into the resolution gate.
		/// </summary>
		None = 0,
		/// <summary>
		/// Fit the resolution gate vertically within the sensor gate.
		/// </summary>
		Vertical = 1,
		/// <summary>
		/// Fit the resolution gate horizontally within the sensor gate.
		/// </summary>
		Horizontal = 2,
		/// <summary>
		/// Automatically selects a horizontal or vertical fit so that the sensor gate fits completely inside the resolution gate.
		/// </summary>
		Fill = 3,
		/// <summary>
		/// Automatically selects a horizontal or vertical fit so that the render frame fits completely inside the resolution gate.
		/// </summary>
		Overscan = 4,
	}
}

```

`AssetRipperCommon/Classes/Camera/ProjectionMatrixMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Camera
{
	public enum ProjectionMatrixMode
	{
		Explicit = 0,
		Implicit = 1,
		PhysicalPropertiesBased = 2,
	}
}

```

`AssetRipperCommon/Classes/Camera/RenderingPath.cs`:

```cs
namespace AssetRipper.Core.Classes.Camera
{
	/// <summary>
	/// Rendering path of a Camera.
	/// </summary>
	public enum RenderingPath
	{
		UsePlayerSettings = -1,
		VertexLit = 0,
		Forward = 1,
		DeferredLighting = 2,
		DeferredShading = 3
	}
}

```

`AssetRipperCommon/Classes/Camera/StereoTargetEyeMask.cs`:

```cs
namespace AssetRipper.Core.Classes.Camera
{
	[Flags]
	public enum StereoTargetEyeMask
	{
		None = 0,
		Left = 1,
		Right = 2,
		Both = Left | Right
	}
}

```

`AssetRipperCommon/Classes/CapsuleCollider2D/CapsuleDirection2D.cs`:

```cs
namespace AssetRipper.Core.Classes.CapsuleCollider2D
{
	public enum CapsuleDirection2D
	{
		/// <summary>
		/// Vertical (radii top/bottom)
		/// </summary>
		Vertical = 0,
		/// <summary>
		/// Horizontal (radii left/right)
		/// </summary>
		Horizontal = 1,
	}
}

```

`AssetRipperCommon/Classes/ClusterInputManager/ClusterInputType.cs`:

```cs
namespace AssetRipper.Core.Classes.ClusterInputManager
{
	/// <summary>
	/// Values to determine the type of input value to be expect from one entry of ClusterInput.
	/// </summary>
	public enum ClusterInputType
	{
		/// <summary>
		/// Device that return a binary result of pressed or not pressed.
		/// </summary>
		Button = 0,
		/// <summary>
		/// Device is an analog axis that provides continuous value represented by a float.
		/// </summary>
		Axis = 1,
		/// <summary>
		/// Device that provide position and orientation values.
		/// </summary>
		Tracker = 2,
		/// <summary>
		/// A user customized input.
		/// </summary>
		CustomProvidedInput = 3,
	}
}

```

`AssetRipperCommon/Classes/CompositeCollider2D/GenerationType.cs`:

```cs
namespace AssetRipper.Core.Classes.CompositeCollider2D
{
	public enum GenerationType
	{
		Synchronous = 0,
		Manual = 1,
	}
}

```

`AssetRipperCommon/Classes/CompositeCollider2D/GeometryType.cs`:

```cs
namespace AssetRipper.Core.Classes.CompositeCollider2D
{
	public enum GeometryType
	{
		Outlines = 0,
		Polygons = 1,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/AssetPipelineMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// Selects the Assetpipeline mode to use.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum AssetPipelineMode
	{
		/// <summary>
		/// Use this if you want to use assetpipeline version 1.
		/// </summary>
		Version1 = 0,
		/// <summary>
		/// Use this if you want to use assetpipeline version 2.
		/// </summary>
		Version2 = 1,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/CacheServerMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// Selects the cache server configuration mode.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum CacheServerMode
	{
		/// <summary>
		/// Use this if you want to use the global cache server settings.
		/// </summary>
		AsPreferences = 0,
		/// <summary>
		/// Use this if you want to enable use of the project specific cache server settings.
		/// </summary>
		Enabled = 1,
		/// <summary>
		/// Use this if you want to disable the use of cache server for the project.
		/// </summary>
		Disabled = 2,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/EditorBehaviorMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum EditorBehaviorMode
	{
		Mode3D = 0,
		Mode2D = 1,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/EnterPlayModeOptions.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	[Flags]
	public enum EnterPlayModeOptions
	{
		None = 0,
		DisableDomainReload = 1,
		DisableSceneReload = 2,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/ExternalVersionControl.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	public enum ExternalVersionControl
	{
		AutoDetect = -1,
		Disabled = 0,
		Generic = 1,
		Subversion = 2,
		Perforce = 3,
		AssetServer = 4,
	}

	public static class ExternalVersionControlExtensions
	{
		private const string HiddenMeta = "Hidden Meta Files";
		private const string VisibleMeta = "Visible Meta Files";

		public static string ConvertToString(this ExternalVersionControl support)
		{
			return support switch
			{
				ExternalVersionControl.AutoDetect => "Auto detect",
				ExternalVersionControl.Disabled => HiddenMeta,
				ExternalVersionControl.Generic or ExternalVersionControl.AssetServer => VisibleMeta,
				ExternalVersionControl.Subversion => "Subversion",
				ExternalVersionControl.Perforce => "Perforce",
				_ => HiddenMeta,
			};
		}

		public static string ToStringExact(this ExternalVersionControl support)
		{
			return support switch
			{
				ExternalVersionControl.AutoDetect => "Auto detect",
				ExternalVersionControl.Disabled => "Disabled",
				ExternalVersionControl.Generic => VisibleMeta,
				ExternalVersionControl.AssetServer => "Asset Server",
				ExternalVersionControl.Subversion => "Subversion",
				ExternalVersionControl.Perforce => "Perforce",
				_ => HiddenMeta,
			};
		}

		public static ExternalVersionControl FromStringExact(string str)
		{
			return str switch
			{
				"Auto detect" => ExternalVersionControl.AutoDetect,
				"Disabled" => ExternalVersionControl.Disabled,
				"Asset Server" => ExternalVersionControl.AssetServer,
				"Subversion" => ExternalVersionControl.Subversion,
				"Perforce" => ExternalVersionControl.Perforce,
				VisibleMeta => ExternalVersionControl.Generic,
				HiddenMeta => ExternalVersionControl.Disabled,
				_ => ExternalVersionControl.Disabled,
			};
		}
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/LineEndingsMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum LineEndingsMode
	{
		OSNative = 0,
		Unix = 1,
		Windows = 2,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/SerializationMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum SerializationMode
	{
		Mixed = 0,
		ForceBinary = 1,
		ForceText = 2,
	}
}

```

`AssetRipperCommon/Classes/EditorSettings/SpritePackerMode.cs`:

```cs
namespace AssetRipper.Core.Classes.EditorSettings
{
	/// <summary>
	/// Sprite Packer mode for the current project.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/EditorSettings.bindings.cs"/>
	/// </summary>
	public enum SpritePackerMode
	{
		/// <summary>
		/// Doesn't pack sprites.
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Updates the sprite atlas cache when the Player or bundles builds containing Sprite with the legacy packing tag.
		/// </summary>
		BuildTimeOnly = 1,
		/// <summary>
		/// Always maintain an up-to-date sprite atlas cache for Sprite with packing tag (legacy).
		/// </summary>
		AlwaysOn = 2,
		/// <summary>
		/// Pack all the SpriteAtlas when building player/bundles.
		/// </summary>
		BuildTimeOnlyAtlas = 3,
		/// <summary>
		/// Always pack all the SpriteAtlas.
		/// </summary>
		AlwaysOnAtlas = 4,
		SpriteAtlasV2 = 5,
		SpriteAtlasV2Build = 6,
	}
}

```

`AssetRipperCommon/Classes/Flare/TextureLayout.cs`:

```cs
namespace AssetRipper.Core.Classes.Flare
{
	/// <summary>
	/// Enum describing how the individual Flare Element images are laid out inside the Flare Texture.<br/>
	/// <see href="https://docs.unity3d.com/Manual/class-Flare.html"/>
	/// </summary>
	public enum TextureLayout
	{
		OneLargeFourSmall = 0,
		OneLargeTwoMediumEightSmall = 1,
		OneTexture = 2,
		TwoGrid = 3,
		ThreeGrid = 4,
		FourGrid = 5
	}
}
```

`AssetRipperCommon/Classes/GameObject/IGameObject.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Core.Utils;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.GameObject
{
	public interface IGameObject : IEditorExtension, IHasNameString
	{
		ushort Tag { get; set; }
		string TagString { get; set; }
		bool IsActive { get; set; }
		uint Layer { get; set; }
		PPtr<IComponent>[] FetchComponents();
	}

	public static class GameObjectExtensions
	{
		/// <summary>
		/// Release or less than 2.1.0
		/// </summary>
		public static bool HasTag(UnityVersion version, TransferInstructionFlags flags) => flags.IsRelease() || version.IsLess(2, 1);
		/// <summary>
		/// 2.1.0 and greater and Not Release
		/// </summary>
		public static bool HasTagString(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2, 1) && !flags.IsRelease();
		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool IsActiveInherited(UnityVersion version) => version.IsLess(4);

		public static bool GetIsActive(this IGameObject gameObject)
		{
			if (IsActiveInherited(gameObject.SerializedFile.Version))
			{
				return gameObject.SerializedFile.Collection.IsScene(gameObject.SerializedFile) ? gameObject.IsActive : true;
			}
			return gameObject.IsActive;
		}

		public static ushort GetTag(this IGameObject gameObject, IExportContainer container)
		{
			if (HasTag(gameObject.SerializedFile.Version, gameObject.SerializedFile.Flags))
			{
				return gameObject.Tag;
			}
			return container.TagNameToID(gameObject.TagString);
		}

		public static string GetTagString(this IGameObject gameObject, IExportContainer container)
		{
			if (HasTagString(gameObject.SerializedFile.Version, gameObject.SerializedFile.Flags))
			{
				return gameObject.TagString;
			}
			return container.TagIDToName(gameObject.Tag);
		}

		public static T? FindComponent<T>(this IGameObject gameObject) where T : IComponent
		{
			foreach (PPtr<IComponent> ptr in gameObject.FetchComponents())
			{
				// component could have not implemented asset type
				IComponent? comp = ptr.FindAsset(gameObject.SerializedFile);
				if (comp is T t)
				{
					return t;
				}
			}
			return default;
		}

		public static T GetComponent<T>(this IGameObject gameObject) where T : IComponent
		{
			T? component = gameObject.FindComponent<T>();
			if (component == null)
			{
				throw new Exception($"Component of type {nameof(T)} hasn't been found");
			}
			return component;
		}

		public static ITransform GetTransform(this IGameObject gameObject)
		{
			foreach (PPtr<IComponent> ptr in gameObject.FetchComponents())
			{
				IComponent? comp = ptr.FindAsset(gameObject.SerializedFile);
				if (comp == null)
				{
					continue;
				}

				if (comp is ITransform transform)
				{
					return transform;
				}
			}
			throw new Exception("Can't find transform component");
		}

		public static IGameObject GetRoot(this IGameObject gameObject)
		{
			ITransform root = gameObject.GetTransform();
			while (true)
			{
				ITransform? parent = root.FatherPtr.TryGetAsset(root.SerializedFile);
				if (parent == null)
				{
					break;
				}
				else
				{
					root = parent;
				}
			}
			return root.GameObjectPtr.GetAsset(root.SerializedFile);
		}

		public static int GetRootDepth(this IGameObject gameObject)
		{
			ITransform root = gameObject.GetTransform();
			int depth = 0;
			while (true)
			{
				ITransform? parent = root.FatherPtr.TryGetAsset(root.SerializedFile);
				if (parent == null)
				{
					break;
				}

				root = parent;
				depth++;
			}
			return depth;
		}

		public static IEnumerable<IEditorExtension> FetchHierarchy(this IGameObject root)
		{
			yield return root;

			ITransform? transform = null;
			foreach (PPtr<IComponent> ptr in root.FetchComponents())
			{
				IComponent? component = ptr.FindAsset(root.SerializedFile);
				if (component == null)
				{
					continue;
				}

				yield return component;
				if (component is ITransform trfm)
				{
					transform = trfm;
				}
			}

			if (transform is null)
			{
				throw new NullReferenceException($"{nameof(transform)} cannot be null");
			}

			foreach (PPtr<ITransform> pchild in transform.ChildrenPtrs)
			{
				ITransform child = pchild.GetAsset(transform.SerializedFile);
				IGameObject childGO = child.GameObjectPtr.GetAsset(root.SerializedFile);
				foreach (IEditorExtension childElement in FetchHierarchy(childGO))
				{
					yield return childElement;
				}
			}
		}

		public static IReadOnlyDictionary<uint, string> BuildTOS(this IGameObject gameObject)
		{
			Dictionary<uint, string> tos = new Dictionary<uint, string>() { { 0, string.Empty } };
			gameObject.BuildTOS(gameObject, string.Empty, tos);
			return tos;
		}

		private static void BuildTOS(this IGameObject gameObject, IGameObject parent, string parentPath, Dictionary<uint, string> tos)
		{
			ITransform transform = parent.GetTransform();
			foreach (PPtr<ITransform> childPtr in transform.ChildrenPtrs)
			{
				ITransform childTransform = childPtr.GetAsset(gameObject.SerializedFile);
				IGameObject child = childTransform.GameObjectPtr.GetAsset(gameObject.SerializedFile);
				string path = string.IsNullOrEmpty(parentPath) ? child.NameString : $"{parentPath}/{child.NameString}";
				uint pathHash = CrcUtils.CalculateDigestUTF8(path);
				tos[pathHash] = path;

				gameObject.BuildTOS(child, path, tos);
			}
		}
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/BuiltinShaderMode.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum BuiltinShaderMode
	{
		None = 0,
		Builtin = 1,
		Custom = 2,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/CameraHDRMode.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	/// <summary>
	/// The HDR mode to use for rendering.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum CameraHDRMode
	{
		/// <summary>
		/// Uses RenderTextureFormat.ARGBHalf.
		/// </summary>
		FP16 = 1,
		/// <summary>
		/// Uses RenderTextureFormat.RGB111110Float.
		/// </summary>
		R11G11B10 = 2,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/GraphicsTier.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	/// <summary>
	/// Graphics Tier.
	/// </summary>
	public enum GraphicsTier
	{
		/// <summary>
		/// The first graphics tier (Low) - corresponds to shader define UNITY_HARDWARE_TIER1.
		/// </summary>
		Tier1 = 0,
		/// <summary>
		/// The second graphics tier (Medium) - corresponds to shader define UNITY_HARDWARE_TIER2.
		/// </summary>
		Tier2 = 1,
		/// <summary>
		/// The third graphics tier (High) - corresponds to shader define UNITY_HARDWARE_TIER3.
		/// </summary>
		Tier3 = 2,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/InstancingStrippingVariant.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	public enum InstancingStrippingVariant
	{
		StripUnused = 0,
		StripAll = 1,
		KeepAll = 2,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/LightmapStrippingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	public enum LightmapStrippingMode
	{
		Automatic = 0,
		Custom = 1,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/RealtimeGICPUUsage.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	/// <summary>
	/// How much CPU usage to assign to the final lighting calculations at runtime.
	/// </summary>
	public enum RealtimeGICPUUsage
	{
		/// <summary>
		/// 25% of the allowed CPU threads are used as worker threads.
		/// </summary>
		Low = 25,
		/// <summary>
		/// 50% of the allowed CPU threads are used as worker threads.
		/// </summary>
		Medium = 50,
		/// <summary>
		/// 75% of the allowed CPU threads are used as worker threads.
		/// </summary>
		High = 75,
		/// <summary>
		/// 100% of the allowed CPU threads are used as worker threads.
		/// </summary>
		Unlimited = 100
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/ShaderQuality.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	/// <summary>
	/// Shader quality preset.
	/// </summary>
	public enum ShaderQuality
	{
		/// <summary>
		/// Low quality shader preset.
		/// </summary>
		Low = 0,
		/// <summary>
		/// Medium quality shader preset.
		/// </summary>
		Medium = 1,
		/// <summary>
		/// High quality shader preset.
		/// </summary>
		High = 2,
	}
}

```

`AssetRipperCommon/Classes/GraphicsSettings/TransparencySortMode.cs`:

```cs
namespace AssetRipper.Core.Classes.GraphicsSettings
{
	public enum TransparencySortMode
	{
		Default = 0,
		Perspective = 1,
		Orthographic = 2,
		CustomAxis = 3,
	}
}

```

`AssetRipperCommon/Classes/IComponent.cs`:

```cs
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Classes.Misc;

namespace AssetRipper.Core.Classes
{
	public interface IComponent : IEditorExtension
	{
		PPtr<IGameObject> GameObjectPtr { get; }
	}

	public static class ComponentExtensions
	{
		public static IGameObject GetGameObject(this IComponent component)
		{
			return component.GameObjectPtr.GetAsset(component.SerializedFile);
		}

		public static IGameObject TryGetGameObject(this IComponent component)
		{
			return component.GameObjectPtr.TryGetAsset(component.SerializedFile);
		}

		public static IGameObject GetRoot(this IComponent component)
		{
			return component.GetGameObject().GetRoot();
		}

		public static int GetRootDepth(this IComponent component)
		{
			return component.GetGameObject().GetRootDepth();
		}
	}
}

```

`AssetRipperCommon/Classes/IEditorExtension.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.PrefabInstance;
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.Classes
{
	public interface IEditorExtension : IUnityObjectBase
	{
		/// <summary>
		/// Added in 2018.2 as m_PrefabInternal<br/>
		/// Changed in 2018.3 to m_PrefabInstance
		/// </summary>
		PPtr<IPrefabInstance> PrefabInstance { get; set; }
	}
}
```

`AssetRipperCommon/Classes/INamedObject.cs`:

```cs
//using AssetRipper.Core.Classes.Shader;
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.Classes
{
	public interface INamedObject : IHasNameString, IUnityObjectBase
	{
	}

	public static class NamedObjectExtensions
	{
		public static string GetValidName(this INamedObject named)
		{
			//if (named is IShader shader)
			//{
			//	return shader.GetValidShaderName();
			//}
			//else
			//{
				return named.GetNameNotEmpty();
			//}
		}
	}
}

```

`AssetRipperCommon/Classes/ITransform.cs`:

```cs
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Math.Vectors;

namespace AssetRipper.Core.Classes
{
	public interface ITransform : IComponent
	{
		PPtr<ITransform> FatherPtr { get; }
		PPtr<ITransform>[] ChildrenPtrs { get; }
		Vector3f LocalPosition { get; set; }
		Quaternionf LocalRotation { get; set; }
		Vector3f LocalScale { get; set; }
	}

	public static class TransformExtensions
	{
		private const char PathSeparator = '/';

		public static string GetRootPath(this ITransform transform)
		{
			string pre = string.Empty;
			if (!transform.FatherPtr.IsNull)
			{
				pre = transform.FatherPtr.GetAsset(transform.SerializedFile).GetRootPath() + PathSeparator;
			}
			return pre + transform.GetGameObject().NameString;
		}

		/// <summary>
		/// Find the sibling index (aka the root order) of the transform
		/// </summary>
		/// <param name="transform">The relevant transform</param>
		/// <returns>The sibling index of the transform</returns>
		/// <exception cref="Exception">if the transform cannot be found among the father's children</exception>
		public static int GetSiblingIndex(this ITransform transform)
		{
			if (transform.FatherPtr.IsNull)
			{
				return 0;
			}
			ITransform father = transform.FatherPtr.GetAsset(transform.SerializedFile);
			PPtr<ITransform>[] children = father.ChildrenPtrs;
			for (int i = 0; i < children.Length; i++)
			{
				PPtr<ITransform> child = children[i];
				if (child.PathIndex == transform.PathID)
				{
					return i;
				}
			}
			throw new Exception("Transform hasn't been found among father's children");
		}

		public static ITransform FindChild(this ITransform transform, string path)
		{
			if (path.Length == 0)
			{
				return transform;
			}
			return FindChild(transform, path, 0);
		}

		private static ITransform FindChild(this ITransform transform, string path, int startIndex)
		{
			int separatorIndex = path.IndexOf(PathSeparator, startIndex);
			string childName = separatorIndex == -1 ?
				path.Substring(startIndex, path.Length - startIndex) :
				path.Substring(startIndex, separatorIndex - startIndex);
			foreach (PPtr<ITransform> childPtr in transform.ChildrenPtrs)
			{
				ITransform child = childPtr.GetAsset(transform.SerializedFile);
				IGameObject childGO = child.GetGameObject();
				if (childGO.NameString == childName)
				{
					return separatorIndex == -1 ? child : child.FindChild(path, separatorIndex + 1);
				}
			}
			return default;
		}
	}
}

```

`AssetRipperCommon/Classes/InputManager/InputAxesDirection.cs`:

```cs
namespace AssetRipper.Core.Classes.InputManager
{
	public enum InputAxesDirection
	{
		X = 0,
		Y = 1,
		ScrollWheel = 2,
		_4 = 3,
		_5 = 4,
		_6 = 5,
		_7 = 6,
		_8 = 7,
		_9 = 8,
		_10 = 9,
		_11 = 10,
		_12 = 11,
		_13 = 12,
		_14 = 13,
		_15 = 14,
		_16 = 15,
		_17 = 16,
		_18 = 17,
		_19 = 18,
		_20 = 19,
		_21 = 20,
		_22 = 21,
		_23 = 22,
		_24 = 23,
		_25 = 24,
		_26 = 25,
		_27 = 26,
		_28 = 27,
	}
}

```

`AssetRipperCommon/Classes/InputManager/InputAxisType.cs`:

```cs
namespace AssetRipper.Core.Classes.InputManager
{
	public enum InputAxisType
	{
		/// <summary>
		/// Actually it is any button, not just keyboard or mouse
		/// </summary>
		KeyOrMouseButton = 0,
		MouseMovement = 1,
		JoystickAxis = 2,
	}
}

```

`AssetRipperCommon/Classes/InputManager/JoystickType.cs`:

```cs
namespace AssetRipper.Core.Classes.InputManager
{
	public enum JoystickType
	{
		AllJoysticks = 0,
		Joystick1 = 1,
		Joystick2 = 2,
		Joystick3 = 3,
		Joystick4 = 4,
		Joystick5 = 5,
		Joystick6 = 6,
		Joystick7 = 7,
		Joystick8 = 8,
		Joystick9 = 9,
		Joystick10 = 10,
		Joystick11 = 11,
		Joystick12 = 12,
		Joystick13 = 13,
		Joystick14 = 14,
		Joystick15 = 15,
		Joystick16 = 16,
	}
}

```

`AssetRipperCommon/Classes/LODGroup/LODFadeMode.cs`:

```cs
namespace AssetRipper.Core.Classes.LODGroup
{
	/// <summary>
	/// The LOD fade modes. Modes other than LODFadeMode.None will result in Unity calculating a blend factor
	/// for blending/interpolating between two neighbouring LODs and pass it to your shader.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/LOD.bindings.cs"/>
	/// </summary>
	public enum LODFadeMode
	{
		/// <summary>
		/// Indicates the LOD fading is turned off.
		/// </summary>
		None = 0,
		/// <summary>
		/// Perform cross-fade style blending between the current LOD and the next LOD if the distance to camera falls
		/// in the range specified by the LOD.fadeTransitionWidth of each LOD.
		/// </summary>
		CrossFade = 1,
		/// <summary>
		/// By specifying this mode, your LODGroup will perform a SpeedTree-style LOD fading scheme:
		/// * For all the mesh LODs other than the last (most crude) mesh LOD, the fade factor is calculated as the percentage of the object's current screen height, compared to the whole range of the LOD. It is 1, if the camera is right at the position where the previous LOD switches out and 0, if the next LOD is just about to switch in.
		/// * For the last mesh LOD and the billboard LOD, the cross-fade mode is used.
		/// </summary>
		SpeedTree = 2,
	}
}

```

`AssetRipperCommon/Classes/Light/LightRenderMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LightRenderMode
	{
		Auto,
		ForcePixel,
		ForceVertex,
	}
}

```

`AssetRipperCommon/Classes/Light/LightShadowCasterMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// Allows mixed lights to control shadow caster culling when Shadowmasks are present.
	/// </summary>
	public enum LightShadowCasterMode
	{
		/// <summary>
		/// Use the global Shadowmask Mode from the quality settings.
		/// </summary>
		Default = 0,
		/// <summary>
		/// Render only non-lightmapped objects into the shadow map. This corresponds with the Shadowmask mode.
		/// </summary>
		NonLightmappedOnly = 1,
		/// <summary>
		/// Render all shadow casters into the shadow map. This corresponds with the distance Shadowmask mode.
		/// </summary>
		Everything = 2,
	}
}

```

`AssetRipperCommon/Classes/Light/LightShadows.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// Shadow casting options for a Light.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LightShadows
	{
		None,
		Hard,
		Soft,
	}
}

```

`AssetRipperCommon/Classes/Light/LightShape.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// Describes the shape of a spot light.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LightShape
	{
		/// <summary>
		/// The shape of the spot light resembles a cone. This is the default shape for spot lights.
		/// </summary>
		Cone = 0,
		/// <summary>
		/// The shape of the spotlight resembles a pyramid or frustum. You can use this to simulate a screening or barn door effect on a normal spotlight.
		/// </summary>
		Pyramid = 1,
		/// <summary>
		/// The shape of the spot light resembles a box oriented along the ray direction.
		/// </summary>
		Box = 2,
	}
}

```

`AssetRipperCommon/Classes/Light/LightType.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LightType
	{
		Spot = 0,
		Directional = 1,
		Point = 2,
		/// <summary>
		/// Replaced with Rectangle
		/// </summary>
		Area = 3,
		Rectangle = 3,
		Disc = 4,
	}
}

```

`AssetRipperCommon/Classes/Light/LightmapBakeType.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// Enum describing what part of a light contribution can be baked.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	[Flags]
	public enum LightmapBakeType
	{
		Mixed = 1,
		Baked = 2,
		Realtime = 4,
	}
}

```

`AssetRipperCommon/Classes/Light/LightmappingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	[Flags]
	public enum LightmappingMode
	{
		Mixed = 1,
		Baked = 2,
		Realtime = 4,
	}
}

```

`AssetRipperCommon/Classes/Light/MixedLightingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Light
{
	/// <summary>
	/// Enum describing what lighting mode to be used with Mixed lights.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum MixedLightingMode
	{
		IndirectOnly = 0,
		Subtractive = 1,
		Shadowmask = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/DenoiserType.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	/// <summary>
	/// Which path tracer denoiser is used.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/GI/LightingSettings.bindings.cs"/>
	/// </summary>
	public enum DenoiserType
	{
		/// <summary>
		/// No denoiser
		/// </summary>
		None = 0,
		/// <summary>
		/// The NVIDIA Optix AI denoiser is applied.
		/// </summary>
		Optix = 1,
		/// <summary>
		/// The Intel Open Image AI denoiser is applied.
		/// </summary>
		OpenImage = 2,
		/// <summary>
		/// The AMD Radeon Pro Image Processing denoiser is applied.
		/// </summary>
		RadeonPro = 3,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/FilterMode.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	/// <summary>
	/// Set the path tracer filter mode.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/GI/LightingSettings.bindings.cs"/>
	/// </summary>
	public enum FilterMode
	{
		/// <summary>
		/// Do not filter.
		/// </summary>
		None = 0,
		/// <summary>
		/// Select settings for filtering automatically
		/// </summary>
		Auto = 1,
		/// <summary>
		/// Setup filtering manually
		/// </summary>
		Advanced = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/FilterType.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	/// <summary>
	/// Which path tracer filter is used.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/GI/LightingSettings.bindings.cs"/>
	/// </summary>
	public enum FilterType
	{
		/// <summary>
		/// A Gaussian filter is applied.
		/// </summary>
		Gaussian = 0,
		/// <summary>
		/// An A-Trous filter is applied.
		/// </summary>
		ATrous = 1,
		/// <summary>
		/// No filter
		/// </summary>
		None = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/GISettings/EnvironmentAmbientMode.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings.GISettings
{
	public enum EnvironmentAmbientMode
	{
		Realtime = 0,
		Baked = 1,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/GIWorkflowMode.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	public enum GIWorkflowMode
	{
		Iterative = 0,
		OnDemand = 1,
		Legacy = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/Lightmapper.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	/// <summary>
	/// Which baking backend is used.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/GI/LightingSettings.bindings.cs"/>
	/// </summary>
	public enum Lightmapper
	{
		Radiosity = 0,
		/// <summary>
		/// Lightmaps are baked by Enlighten
		/// </summary>
		Enlighten = 0,
		PathTracer = 1,
		/// <summary>
		/// Lightmaps are baked by the CPU Progressive lightmapper (Wintermute + OpenRL based).
		/// </summary>
		ProgressiveCPU = 1,
		/// <summary>
		/// Lightmaps are baked by the GPU Progressive lightmapper (RadeonRays + OpenCL based).
		/// </summary>
		ProgressiveGPU = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/LightmapsMode.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	[Flags]
	public enum LightmapsMode
	{
		/// <summary>
		/// Light intensity (no directional information), encoded as 1 lightmap.
		/// </summary>
		NonDirectional = 0,
		Single = 0,
		/// <summary>
		/// Directional information for direct light is combined with directional information for indirect light, encoded as 2 lightmaps.
		/// </summary>
		CombinedDirectional = 1,
		Dual = 1,
		/// <summary>
		/// Directional information for direct light is stored separately from directional information for indirect light, encoded as 4 lightmaps.
		/// </summary>
		SeparateDirectional = 2,
		Directional = 2
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/ReflectionCubemapCompression.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	public enum ReflectionCubemapCompression
	{
		Uncompressed = 0,
		Compressed = 1,
		Auto = 2,
	}
}

```

`AssetRipperCommon/Classes/LightmapSettings/Sampling.cs`:

```cs
namespace AssetRipper.Core.Classes.LightmapSettings
{
	/// <summary>
	/// Which path tracer sampling scheme is used.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/GI/LightingSettings.bindings.cs"/>
	/// </summary>
	public enum Sampling
	{
		/// <summary>
		/// Convergence testing is automatic, stops when lightmap has converged.
		/// </summary>
		Auto = 0,
		/// <summary>
		/// No convergence testing, always uses the given number of samples.
		/// </summary>
		Fixed = 1,
	}
}

```

`AssetRipperCommon/Classes/Mesh/IChannelInfoLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface IChannelInfoLegacy : IAsset
	{
		/// <summary>
		/// Stream index
		/// BinaryData:[Stream0][Align][Stream1][Align]...
		/// </summary>
		byte Stream { get; set; }
		/// <summary>
		/// Offset inside stream
		/// Stream:[FirstVertex: VertexOffset,NormalOffset,TangentOffset...][SecondVertex: VertexOffset,NormalOffset,TangentOffset...]...
		/// </summary>
		byte Offset { get; set; }
		/// <summary>
		/// Data format: float, int, byte
		/// </summary>
		byte Format { get; set; }
		/// <summary>
		/// An unprocessed byte value containing the data dimension
		/// </summary>
		byte Dimension { get; set; }
	}

	public static class ChannelInfoExtensions
	{
		public static bool IsSet(this IChannelInfoLegacy channelInfo) => channelInfo.Dimension > 0;

		/// <summary>
		/// Data dimention: Vector3, Vector2, Vector1
		/// </summary>
		public static byte GetDataDimension(this IChannelInfoLegacy channelInfo)
		{
			return (byte)(channelInfo.Dimension & 0b00001111);
		}

		/// <summary>
		/// Data dimention: Vector3, Vector2, Vector1
		/// </summary>
		public static void SetDataDimension(this IChannelInfoLegacy channelInfo, byte value)
		{
			channelInfo.Dimension = (byte)((channelInfo.Dimension & 0b11110000) | (value & 0b00001111));
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/ICompressedMeshLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.PackedBitVectors;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface ICompressedMeshLegacy : IAsset
	{
		IPackedFloatVector Vertices { get; }
		IPackedFloatVector UV { get; }
		/// <summary>
		/// Less than 5.0.0
		/// </summary>
		IPackedFloatVector BindPoses { get; }
		IPackedFloatVector Normals { get; }
		IPackedFloatVector Tangents { get; }
		IPackedIntVector Weights { get; }
		IPackedIntVector NormalSigns { get; }
		IPackedIntVector TangentSigns { get; }
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		IPackedFloatVector FloatColors { get; }
		IPackedIntVector BoneIndices { get; }
		IPackedIntVector Triangles { get; }
		/// <summary>
		/// 3.5.0 to 5.0.0 exclusive
		/// </summary>
		IPackedIntVector Colors { get; }
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		uint UVInfo { get; set; }
	}

	public static class CompressedMeshExtensions
	{
		public static void CopyValues(this ICompressedMeshLegacy destination, ICompressedMeshLegacy source)
		{
			destination.Vertices.CopyValuesFrom(source.Vertices);
			destination.UV.CopyValuesFrom(source.UV);
			destination.BindPoses.CopyValuesFrom(source.BindPoses);
			destination.Normals.CopyValuesFrom(source.Normals);
			destination.Tangents.CopyValuesFrom(source.Tangents);
			destination.Weights.CopyValuesFrom(source.Weights);
			destination.NormalSigns.CopyValuesFrom(source.NormalSigns);
			destination.TangentSigns.CopyValuesFrom(source.TangentSigns);
			destination.FloatColors.CopyValuesFrom(source.FloatColors);
			destination.BoneIndices.CopyValuesFrom(source.BoneIndices);
			destination.Triangles.CopyValuesFrom(source.Triangles);
			destination.Colors.CopyValuesFrom(source.Colors);
			destination.UVInfo = source.UVInfo;
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/IMeshBlendShapeChannelLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Utils;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface IMeshBlendShapeChannelLegacy : IAsset
	{
		Utf8StringBase Name { get; }
		uint NameHash { get; set; }
		int FrameIndex { get; set; }
		int FrameCount { get; set; }
	}

	public static class MeshBlendShapeChannelExtensions
	{
		public static void SetValues(this IMeshBlendShapeChannelLegacy channel, string name, int frameIndex, int frameCount)
		{
			channel.Name.String = name;
			channel.NameHash = CrcUtils.CalculateDigestUTF8(name);
			channel.FrameIndex = frameIndex;
			channel.FrameCount = frameCount;
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/IMeshBlendShapeLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Utils;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface IMeshBlendShapeLegacy : IAsset
	{
		/// <summary>
		/// Less than 4.3
		/// </summary>
		Utf8StringBase Name { get; }
		uint FirstVertex { get; set; }
		uint VertexCount { get; set; }
		bool HasNormals { get; set; }
		bool HasTangents { get; set; }
		/// <summary>
		/// Less than 4.3
		/// </summary>
		IVector3f AabbMinDelta { get; }
		/// <summary>
		/// Less than 4.3
		/// </summary>
		IVector3f AabbMaxDelta { get; }
	}

	public static class MeshBlendShapeExtensions
	{
		public static bool IsCRCMatch(this IMeshBlendShapeLegacy blendShape, uint crc)
		{
			if (blendShape.Name is null)
			{
				return false;
			}
			else
			{
				return CrcUtils.VerifyDigestUTF8(blendShape.Name, crc);
			}
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/IStreamInfoLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface IStreamInfoLegacy : IAsset
	{
		uint ChannelMask { get; set; }
		uint Offset { get; set; }
		uint Stride { get; set; }
		uint Align { get; set; }
		byte DividerOp { get; set; }
		ushort Frequency { get; set; }
	}
}

```

`AssetRipperCommon/Classes/Mesh/ISubMeshLegacy.cs`:

```cs
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface ISubMeshLegacy : IAsset
	{
		/// <summary>
		/// Offset in index buffer
		/// </summary>
		uint FirstByte { get; set; }
		uint IndexCount { get; set; }
		/// <summary>
		/// For versions &lt; 4, IsTriStrip is used here instead.<br/>
		/// For it, 0 cooresponds to <see cref="MeshTopology.Triangles"/>,<br/>
		/// and 1 cooresponds to <see cref="MeshTopology.TriangleStrip"/>.<br/>
		/// This conveniently matches the <see cref="MeshTopology"/> enumeration.
		/// </summary>
		MeshTopology Topology { get; set; }
		uint TriangleCount { get; set; }
		uint BaseVertex { get; set; }
		/// <summary>
		/// Offset in Vertices
		/// </summary>
		uint FirstVertex { get; set; }
		uint VertexCount { get; set; }
		IAABB LocalAABB { get; }
	}
}

```

`AssetRipperCommon/Classes/Mesh/IVertexDataLegacy.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.IO.Endian;
using System.Collections;
using System.Linq;

namespace AssetRipper.Core.Classes.Mesh
{
	public interface IVertexDataLegacy : IUnityAssetBase
	{
		/// <summary>
		/// Less than 2018.1
		/// </summary>
		uint CurrentChannels { get; set; }
		uint VertexCount { get; set; }
		/// <summary>
		/// 4.0.0 and greater
		/// </summary>
		IChannelInfoLegacy[] Channels { get; }
		/// <summary>
		/// Less than 5.0.0
		/// </summary>
		IStreamInfoLegacy[] Streams { get; }
		/// <summary>
		/// Actually called m_DataSize
		/// </summary>
		byte[] Data { get; set; }
	}

	public static class VertexDataExtensions
	{
		public static bool IsSet(this IVertexDataLegacy instance) => instance.VertexCount > 0;

		public static void ReadData(
			this IVertexDataLegacy instance, 
			UnityVersion version,
			EndianType endianType,
			out int vertexCount,
			out Vector3f[] vertices,
			out Vector3f[] normals,
			out Vector4f[] tangents,
			out ColorRGBA32[] colors,
			out BoneWeights4[] skin,
			out Vector2f[] uv0,
			out Vector2f[] uv1,
			out Vector2f[] uv2,
			out Vector2f[] uv3,
			out Vector2f[] uv4,
			out Vector2f[] uv5,
			out Vector2f[] uv6,
			out Vector2f[] uv7)
		{
			vertexCount = (int)instance.VertexCount;

			vertices = default;
			normals = default;
			tangents = default;
			colors = default;
			skin = default;
			uv0 = default;
			uv1 = default;
			uv2 = default;
			uv3 = default;
			uv4 = default;
			uv5 = default;
			uv6 = default;
			uv7 = default;

			for (var chn = 0; chn < instance.Channels.Length; chn++)
			{
				var m_Channel = instance.Channels[chn];
				if (m_Channel.GetDataDimension() > 0)
				{
					var m_Stream = instance.Streams[m_Channel.Stream];
					var channelMask = new BitArray(BitConverter.GetBytes(m_Stream.ChannelMask));
					if (channelMask.Get(chn))
					{
						if (version.IsLess(2018) && chn == 2 && m_Channel.Format == 2) //kShaderChannelColor && kChannelFormatColor
						{
							m_Channel.SetDataDimension(4);
						}

						var vertexFormat = MeshHelper.ToVertexFormat(m_Channel.Format, version);
						var componentByteSize = (int)MeshHelper.GetFormatSize(vertexFormat);
						var componentBytes = new byte[vertexCount * m_Channel.GetDataDimension() * componentByteSize];
						for (int v = 0; v < vertexCount; v++)
						{
							var vertexOffset = (int)m_Stream.Offset + m_Channel.Offset + (int)m_Stream.Stride * v;
							for (int d = 0; d < m_Channel.GetDataDimension(); d++)
							{
								var componentOffset = vertexOffset + componentByteSize * d;
								Buffer.BlockCopy(instance.Data, componentOffset, componentBytes, componentByteSize * (v * m_Channel.GetDataDimension() + d), componentByteSize);
							}
						}

						if (endianType == EndianType.BigEndian && componentByteSize > 1) //swap bytes
						{
							for (var i = 0; i < componentBytes.Length / componentByteSize; i++)
							{
								var buff = new byte[componentByteSize];
								Buffer.BlockCopy(componentBytes, i * componentByteSize, buff, 0, componentByteSize);
								buff = buff.Reverse().ToArray();
								Buffer.BlockCopy(buff, 0, componentBytes, i * componentByteSize, componentByteSize);
							}
						}

						int[] componentsIntArray = null;
						float[] componentsFloatArray = null;
						if (MeshHelper.IsIntFormat(vertexFormat))
						{
							componentsIntArray = MeshHelper.BytesToIntArray(componentBytes, vertexFormat);
						}
						else
						{
							componentsFloatArray = MeshHelper.BytesToFloatArray(componentBytes, vertexFormat);
						}

						if (version.IsGreaterEqual(2018))
						{
							switch (chn)
							{
								case 0: //kShaderChannelVertex
									vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 1: //kShaderChannelNormal
									normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 2: //kShaderChannelTangent
									tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 3: //kShaderChannelColor
									colors = MeshHelper.FloatArrayToColorRGBA32(componentsFloatArray);
									break;
								case 4: //kShaderChannelTexCoord0
									uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 5: //kShaderChannelTexCoord1
									uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 6: //kShaderChannelTexCoord2
									uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 7: //kShaderChannelTexCoord3
									uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 8: //kShaderChannelTexCoord4
									uv4 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 9: //kShaderChannelTexCoord5
									uv5 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 10: //kShaderChannelTexCoord6
									uv6 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 11: //kShaderChannelTexCoord7
									uv7 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								//2018.2 and up
								case 12: //kShaderChannelBlendWeight
									if (skin == null)
									{
										skin = MakeInitializedArray<BoneWeights4>(vertexCount);
									}
									for (int i = 0; i < vertexCount; i++)
									{
										for (int j = 0; j < m_Channel.GetDataDimension(); j++)
										{
											skin[i].Weights[j] = componentsFloatArray[i * m_Channel.GetDataDimension() + j];
										}
									}
									break;
								case 13: //kShaderChannelBlendIndices
									if (skin == null)
									{
										skin = MakeInitializedArray<BoneWeights4>(vertexCount);
									}
									for (int i = 0; i < vertexCount; i++)
									{
										for (int j = 0; j < m_Channel.GetDataDimension(); j++)
										{
											skin[i].BoneIndices[j] = componentsIntArray[i * m_Channel.GetDataDimension() + j];
										}
									}
									break;
							}
						}
						else
						{
							switch (chn)
							{
								case 0: //kShaderChannelVertex
									vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 1: //kShaderChannelNormal
									normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 2: //kShaderChannelColor
									colors = MeshHelper.FloatArrayToColorRGBA32(componentsFloatArray);
									break;
								case 3: //kShaderChannelTexCoord0
									uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 4: //kShaderChannelTexCoord1
									uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 5:
									if (version.IsGreaterEqual(5)) //kShaderChannelTexCoord2
									{
										uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									}
									else //kShaderChannelTangent
									{
										tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									}
									break;
								case 6: //kShaderChannelTexCoord3
									uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 7: //kShaderChannelTangent
									tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									break;
							}
						}
					}
				}
			}
		}

		private static T[] MakeInitializedArray<T>(int size) where T : new()
		{
			T[] array = new T[size];
			for(int i = 0; i < size; i++)
			{
				array[i] = new();
			}
			return array;
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/IndexFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.Mesh
{
	/// <summary>
	/// Format of the mesh index buffer data<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum IndexFormat
	{
		/// <summary>
		/// 16 bit mesh index buffer format
		/// </summary>
		UInt16 = 0,
		/// <summary>
		/// 32 bit mesh index buffer format
		/// </summary>
		UInt32 = 1,
	}
}

```

`AssetRipperCommon/Classes/Mesh/MeshCompression.cs`:

```cs
namespace AssetRipper.Core.Classes.Mesh
{
	/// <summary>
	/// Compressing meshes saves space in the built game, but more compression introduces more artifacts in vertex data.
	/// </summary>
	public enum MeshCompression : byte
	{
		/// <summary>
		/// No mesh compression (default).
		/// </summary>
		Off = 0,
		/// <summary>
		/// Low amount of mesh compression.
		/// </summary>
		Low = 1,
		/// <summary>
		/// Medium amount of mesh compression.
		/// </summary>
		Med = 2,
		/// <summary>
		/// High amount of mesh compression.
		/// </summary>
		High = 3,
		Count,
	}
}

```

`AssetRipperCommon/Classes/Mesh/MeshHelper.cs`:

```cs
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;

namespace AssetRipper.Core.Classes.Mesh
{
	public static class MeshHelper
	{
		public enum VertexChannelFormat
		{
			kChannelFormatFloat,
			kChannelFormatFloat16,
			kChannelFormatColor,
			kChannelFormatByte,
			kChannelFormatUInt32
		}

		public enum VertexFormat2017
		{
			kVertexFormatFloat,
			kVertexFormatFloat16,
			kVertexFormatColor,
			kVertexFormatUNorm8,
			kVertexFormatSNorm8,
			kVertexFormatUNorm16,
			kVertexFormatSNorm16,
			kVertexFormatUInt8,
			kVertexFormatSInt8,
			kVertexFormatUInt16,
			kVertexFormatSInt16,
			kVertexFormatUInt32,
			kVertexFormatSInt32
		}

		public enum VertexFormat
		{
			kVertexFormatFloat,
			kVertexFormatFloat16,
			kVertexFormatUNorm8,
			kVertexFormatSNorm8,
			kVertexFormatUNorm16,
			kVertexFormatSNorm16,
			kVertexFormatUInt8,
			kVertexFormatSInt8,
			kVertexFormatUInt16,
			kVertexFormatSInt16,
			kVertexFormatUInt32,
			kVertexFormatSInt32
		}

		public static VertexFormat ToVertexFormat(int format, UnityVersion version)
		{
			if (version.IsLess(2017))
			{
				return (VertexChannelFormat)format switch
				{
					VertexChannelFormat.kChannelFormatFloat => VertexFormat.kVertexFormatFloat,
					VertexChannelFormat.kChannelFormatFloat16 => VertexFormat.kVertexFormatFloat16,
					//in 4.x is size 4
					VertexChannelFormat.kChannelFormatColor => VertexFormat.kVertexFormatUNorm8,
					VertexChannelFormat.kChannelFormatByte => VertexFormat.kVertexFormatUInt8,
					//in 5.x
					VertexChannelFormat.kChannelFormatUInt32 => VertexFormat.kVertexFormatUInt32,
					_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
				};
			}
			else if (version.IsLess(2019))
			{
				return (VertexFormat2017)format switch
				{
					VertexFormat2017.kVertexFormatFloat => VertexFormat.kVertexFormatFloat,
					VertexFormat2017.kVertexFormatFloat16 => VertexFormat.kVertexFormatFloat16,
					VertexFormat2017.kVertexFormatColor or VertexFormat2017.kVertexFormatUNorm8 => VertexFormat.kVertexFormatUNorm8,
					VertexFormat2017.kVertexFormatSNorm8 => VertexFormat.kVertexFormatSNorm8,
					VertexFormat2017.kVertexFormatUNorm16 => VertexFormat.kVertexFormatUNorm16,
					VertexFormat2017.kVertexFormatSNorm16 => VertexFormat.kVertexFormatSNorm16,
					VertexFormat2017.kVertexFormatUInt8 => VertexFormat.kVertexFormatUInt8,
					VertexFormat2017.kVertexFormatSInt8 => VertexFormat.kVertexFormatSInt8,
					VertexFormat2017.kVertexFormatUInt16 => VertexFormat.kVertexFormatUInt16,
					VertexFormat2017.kVertexFormatSInt16 => VertexFormat.kVertexFormatSInt16,
					VertexFormat2017.kVertexFormatUInt32 => VertexFormat.kVertexFormatUInt32,
					VertexFormat2017.kVertexFormatSInt32 => VertexFormat.kVertexFormatSInt32,
					_ => throw new ArgumentOutOfRangeException(nameof(format), format, null),
				};
			}
			else
			{
				return (VertexFormat)format;
			}
		}


		public static uint GetFormatSize(VertexFormat format)
		{
			switch (format)
			{
				case VertexFormat.kVertexFormatFloat:
				case VertexFormat.kVertexFormatUInt32:
				case VertexFormat.kVertexFormatSInt32:
					return 4u;
				case VertexFormat.kVertexFormatFloat16:
				case VertexFormat.kVertexFormatUNorm16:
				case VertexFormat.kVertexFormatSNorm16:
				case VertexFormat.kVertexFormatUInt16:
				case VertexFormat.kVertexFormatSInt16:
					return 2u;
				case VertexFormat.kVertexFormatUNorm8:
				case VertexFormat.kVertexFormatSNorm8:
				case VertexFormat.kVertexFormatUInt8:
				case VertexFormat.kVertexFormatSInt8:
					return 1u;
				default:
					throw new ArgumentOutOfRangeException(nameof(format), format, null);
			}
		}

		public static bool IsIntFormat(VertexFormat format)
		{
			return format >= VertexFormat.kVertexFormatUInt8;
		}

		public static float[] BytesToFloatArray(byte[] inputBytes, VertexFormat format)
		{
			if (inputBytes == null)
			{
				throw new ArgumentNullException(nameof(inputBytes));
			}

			var size = GetFormatSize(format);
			if (inputBytes.Length % size != 0)
			{
				throw new Exception($"Input array length {inputBytes.Length} is not divisible by size {size}");
			}

			var len = inputBytes.Length / size;
			var result = new float[len];
			for (int i = 0; i < len; i++)
			{
				switch (format)
				{
					case VertexFormat.kVertexFormatFloat:
						result[i] = BitConverter.ToSingle(inputBytes, i * 4);
						break;
					case VertexFormat.kVertexFormatFloat16:
						result[i] = (float)BitConverter.ToHalf(inputBytes, i * 2);
						break;
					case VertexFormat.kVertexFormatUNorm8:
						result[i] = inputBytes[i] / 255f;
						break;
					case VertexFormat.kVertexFormatSNorm8:
						result[i] = System.Math.Max(unchecked((sbyte)inputBytes[i]) / 127f, -1f);
						break;
					case VertexFormat.kVertexFormatUNorm16:
						result[i] = BitConverter.ToUInt16(inputBytes, i * 2) / 65535f;
						break;
					case VertexFormat.kVertexFormatSNorm16:
						result[i] = System.Math.Max(BitConverter.ToInt16(inputBytes, i * 2) / 32767f, -1f);
						break;
				}
			}
			return result;
		}

		public static int[] BytesToIntArray(byte[] inputBytes, VertexFormat format)
		{
			var size = GetFormatSize(format);
			var len = inputBytes.Length / size;
			var result = new int[len];
			for (int i = 0; i < len; i++)
			{
				switch (format)
				{
					case VertexFormat.kVertexFormatUInt8:
					case VertexFormat.kVertexFormatSInt8:
						result[i] = inputBytes[i];
						break;
					case VertexFormat.kVertexFormatUInt16:
					case VertexFormat.kVertexFormatSInt16:
						result[i] = BitConverter.ToInt16(inputBytes, i * 2);
						break;
					case VertexFormat.kVertexFormatUInt32:
					case VertexFormat.kVertexFormatSInt32:
						result[i] = BitConverter.ToInt32(inputBytes, i * 4);
						break;
				}
			}
			return result;
		}

		public static Vector2f[] FloatArrayToVector2(float[] input) => FloatArrayToVector2(input, 2);
		public static Vector2f[] FloatArrayToVector2(float[] input, int dimension)
		{
			if (input == null)
			{
				throw new ArgumentNullException(nameof(input));
			}

			if (dimension < 1)
			{
				throw new ArgumentOutOfRangeException(nameof(dimension));
			}

			if (input.Length % dimension != 0)
			{
				throw new ArgumentException($"Input array length {input.Length} is not divisible by dimension {dimension}", nameof(input));
			}

			Vector2f[] result = new Vector2f[input.Length / dimension];
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = dimension switch
				{
					1 => new Vector2f(input[dimension * i], 0),
					_ => new Vector2f(input[dimension * i], input[dimension * i + 1]),
				};
			}
			return result;
		}

		public static Vector3f[] FloatArrayToVector3(float[] input) => FloatArrayToVector3(input, 3);
		public static Vector3f[] FloatArrayToVector3(float[] input, int dimension)
		{
			if (input == null)
			{
				throw new ArgumentNullException(nameof(input));
			}

			if (dimension < 1)
			{
				throw new ArgumentOutOfRangeException(nameof(dimension));
			}

			if (input.Length % dimension != 0)
			{
				throw new ArgumentException($"Input array length {input.Length} is not divisible by dimension {dimension}", nameof(input));
			}

			Vector3f[] result = new Vector3f[input.Length / dimension];
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = dimension switch
				{
					1 => new Vector3f(input[dimension * i], input[dimension * i + 1], input[dimension * i + 2]),
					2 => new Vector3f(input[dimension * i], input[dimension * i + 1], input[dimension * i + 2]),
					_ => new Vector3f(input[dimension * i], input[dimension * i + 1], input[dimension * i + 2]),//In the four dimensional case for Normals, the fourth dimension was always zero
																												//This is seemingly intended to maintain data alignment
				};
			}
			return result;
		}

		public static Vector4f[] FloatArrayToVector4(float[] input) => FloatArrayToVector4(input, 4);
		public static Vector4f[] FloatArrayToVector4(float[] input, int dimension)
		{
			if (input == null)
			{
				throw new ArgumentNullException(nameof(input));
			}

			if (dimension < 1)
			{
				throw new ArgumentOutOfRangeException(nameof(dimension));
			}

			if (input.Length % dimension != 0)
			{
				throw new ArgumentException($"Input array length {input.Length} is not divisible by dimension {dimension}", nameof(input));
			}

			Vector4f[] result = new Vector4f[input.Length / dimension];
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = dimension switch
				{
					1 => new Vector4f(input[dimension * i], 0, 0, 0),
					2 => new Vector4f(input[dimension * i], input[dimension * i + 1], 0, 0),
					3 => new Vector4f(input[dimension * i], input[dimension * i + 1], input[dimension * i + 2], 0),
					_ => new Vector4f(input[dimension * i], input[dimension * i + 1], input[dimension * i + 2], input[dimension * i + 3]),
				};
			}
			return result;
		}

		public static ColorRGBAf[] FloatArrayToColorRGBAf(float[] input)
		{
			if (input == null)
			{
				throw new ArgumentNullException(nameof(input));
			}

			if (input.Length % 4 != 0)
			{
				throw new ArgumentException($"Input array length {input.Length} is not divisible by four", nameof(input));
			}

			ColorRGBAf[] result = new ColorRGBAf[input.Length / 4];
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = new ColorRGBAf(input[4 * i], input[4 * i + 1], input[4 * i + 2], input[4 * i + 3]);
			}
			return result;
		}

		public static ColorRGBA32[] FloatArrayToColorRGBA32(float[] input)
		{
			if (input == null)
			{
				throw new ArgumentNullException(nameof(input));
			}

			if (input.Length % 4 != 0)
			{
				throw new ArgumentException($"Input array length {input.Length} is not divisible by four", nameof(input));
			}

			ColorRGBA32[] result = new ColorRGBA32[input.Length / 4];
			for (int i = 0; i < result.Length; i++)
			{
				result[i] = (ColorRGBA32)new ColorRGBAf(input[4 * i], input[4 * i + 1], input[4 * i + 2], input[4 * i + 3]);
			}
			return result;
		}
	}
}

```

`AssetRipperCommon/Classes/Mesh/MeshOptimizationFlags.cs`:

```cs
namespace AssetRipper.Core.Classes.Mesh
{
	/// <summary>
	/// Options to control the optimization of mesh data during asset import
	/// </summary>
	[Flags]
	public enum MeshOptimizationFlags
	{
		/// <summary>
		/// Optimize the order of polygons in the mesh to make better use of the GPUs internal caches to improve rendering performance
		/// </summary>
		PolygonOrder = 1,
		/// <summary>
		/// Optimize the order of vertices in the mesh to make better use of the GPUs internal caches to improve rendering performance
		/// </summary>
		VertexOrder = 2,
		/// <summary>
		/// Perform maximum optimization of the mesh data, enables all optimization options
		/// </summary>
		Everything = -1,
	}
}

```

`AssetRipperCommon/Classes/Mesh/MeshTopology.cs`:

```cs
namespace AssetRipper.Core.Classes.Mesh
{
	/// <summary>
	/// Topology of Mesh faces.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum MeshTopology
	{
		/// <summary>
		/// Mesh is made from triangles.
		/// </summary>
		Triangles = 0,
		/// <summary>
		/// Mesh is a triangle strip.
		/// </summary>
		TriangleStrip = 1,
		/// <summary>
		/// Mesh is made from quads.
		/// </summary>
		Quads = 2,
		/// <summary>
		/// Mesh is made from lines.
		/// </summary>
		Lines = 3,
		/// <summary>
		/// Mesh is a line strip.
		/// </summary>
		LineStrip = 4,
		/// <summary>
		/// Mesh is made from points.
		/// </summary>
		Points = 5,
	}
}

```

`AssetRipperCommon/Classes/MeshCollider/MeshColliderCookingOptions.cs`:

```cs
namespace AssetRipper.Core.Classes.MeshCollider
{
	/// <summary>
	/// Cooking options that are available with MeshCollider
	/// </summary>
	[Flags]
	public enum MeshColliderCookingOptions
	{
		/// <summary>
		/// No optional cooking steps will be run.
		/// </summary>
		None = 0x0,
		/// <summary>
		/// Allow the physics engine to increase the volume of the input mesh in attempt to generate a valid convex mesh.
		/// </summary>
		InflateConvexMesh = 0x1,
		/// <summary>
		/// Toggle between cooking for faster simulation or faster cooking time.
		/// </summary>
		CookForFasterSimulation = 0x2,
		/// <summary>
		/// Toggle cleaning of the mesh.
		/// </summary>
		EnableMeshCleaning = 0x4,
		/// <summary>
		/// Toggle the removal of equal vertices.
		/// </summary>
		WeldColocatedVertices = 0x8,
		/// <summary>
		/// Determines whether to use the fast midphase structure that doesn't require R-trees (only available on Desktop targets).
		/// </summary>
		UseFastMidphase = 0x10,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/AndroidETC2FallbackOverride.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// This enumeration has values for different qualities to decompress an ETC2 texture on Android devices
	/// that don't support the ETC2 texture format.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum AndroidETC2FallbackOverride
	{
		/// <summary>
		/// Use the value defined in Player build settings.
		/// </summary>
		UseBuildSettings = 0,
		/// <summary>
		/// Texture is decompressed to the TextureFormat.RGBA32 format.
		/// </summary>
		Quality32Bit = 1,
		/// <summary>
		/// Texture is decompressed to a suitable 16-bit format.
		/// </summary>
		Quality16Bit = 2,
		/// <summary>
		/// Texture is decompressed to the TextureFormat.RGBA32 format and downscaled to half of the original texture width and height.
		/// </summary>
		Quality32BitDownscaled = 3,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/SpriteAlignment.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// How a Sprite's graphic rectangle is aligned with its pivot point.
	/// </summary>
	public enum SpriteAlignment
	{
		/// <summary>
		/// Pivot is at the center of the graphic rectangle.
		/// </summary>
		Center = 0,
		/// <summary>
		/// Pivot is at the top left corner of the graphic rectangle.
		/// </summary>
		TopLeft = 1,
		/// <summary>
		/// Pivot is at the center of the top edge of the graphic rectangle.
		/// </summary>
		TopCenter = 2,
		/// <summary>
		/// Pivot is at the top right corner of the graphic rectangle.
		/// </summary>
		TopRight = 3,
		/// <summary>
		/// Pivot is at the center of the left edge of the graphic rectangle.
		/// </summary>
		LeftCenter = 4,
		/// <summary>
		/// Pivot is at the center of the right edge of the graphic rectangle.
		/// </summary>
		RightCenter = 5,
		/// <summary>
		/// Pivot is at the bottom left corner of the graphic rectangle.
		/// </summary>
		BottomLeft = 6,
		/// <summary>
		/// Pivot is at the center of the bottom edge of the graphic rectangle.
		/// </summary>
		BottomCenter = 7,
		/// <summary>
		/// Pivot is at the bottom right corner of the graphic rectangle.
		/// </summary>
		BottomRight = 8,
		/// <summary>
		/// Pivot is at a custom position within the graphic rectangle.
		/// </summary>
		Custom = 9,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/SpriteImportMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Texture importer modes for Sprite import.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum SpriteImportMode
	{
		/// <summary>
		/// Graphic is not a Sprite.
		/// </summary>
		None = 0,
		/// <summary>
		/// Sprite is a single image section extracted automatically from the texture.
		/// </summary>
		Single = 1,
		/// <summary>
		/// Sprites are multiple image sections extracted from the texture.
		/// </summary>
		Multiple = 2,
		/// <summary>
		/// Sprite has it own mesh outline defined.
		/// </summary>
		Polygon = 3,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterAlphaSource.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Select how the alpha of the imported texture is generated.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterAlphaSource
	{
		/// <summary>
		/// No Alpha will be used.
		/// </summary>
		None = 0,
		/// <summary>
		/// Use Alpha from the input texture if one is provided.
		/// </summary>
		FromInput = 1,
		/// <summary>
		/// Generate Alpha from image gray scale.
		/// </summary>
		FromGrayScale = 2,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterCompression.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Select the kind of compression you want for your texture.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterCompression
	{
		/// <summary>
		/// Texture will not be compressed.
		/// </summary>
		Uncompressed = 0,
		/// <summary>
		/// Texture will be compressed using a standard format depending on the platform (DXT, ASTC, ...).
		/// </summary>
		Compressed = 1,
		/// <summary>
		/// Texture will be compressed using a high quality format depending on the platform and availability (BC7, ASTC4x4, ...).
		/// </summary>
		CompressedHQ = 2,
		/// <summary>
		/// Texture will be compressed using a low quality but high performance, high compression format depending on the platform and availability (2bpp PVRTC, ASTC8x8, ...).
		/// </summary>
		CompressedLQ = 3,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterGenerateCubemap.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Cubemap generation mode for TextureImporter.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterGenerateCubemap
	{
		/// <summary>
		/// Do not generate cubemap (default).
		/// </summary>
		None = 0,
		/// <summary>
		/// Generate cubemap from spheremap texture.
		/// </summary>
		Spheremap = 1,
		/// <summary>
		/// Generate cubemap from cylindrical texture.
		/// </summary>
		Cylindrical = 2,
		SimpleSpheremap = 3,
		NiceSpheremap = 4,
		/// <summary>
		/// Generate cubemap from vertical or horizontal cross texture.
		/// </summary>
		FullCubemap = 5,
		/// <summary>
		/// Automatically determine type of cubemap generation from the source image.
		/// </summary>
		AutoCubemap = 6,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterMipFilter.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Mip map filter for TextureImporter.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterMipFilter
	{
		/// <summary>
		/// Box mipmap filter.
		/// </summary>
		BoxFilter,
		/// <summary>
		/// Kaiser mipmap filter.
		/// </summary>
		KaiserFilter
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterNPOTScale.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterNPOTScale
	{
		/// <summary>
		/// Keep non power of two textures as is.
		/// </summary>
		None = 0,
		/// <summary>
		/// Scale to nearest power of two.
		/// </summary>
		ToNearest = 1,
		/// <summary>
		/// Scale to larger power of two.
		/// </summary>
		ToLarger = 2,
		/// <summary>
		/// Scale to smaller power of two.
		/// </summary>
		ToSmaller = 3,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterNormalFilter.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Normal map filtering mode for TextureImporter.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterNormalFilter
	{
		/// <summary>
		/// Standard normal map filter.
		/// </summary>
		Standard,
		/// <summary>
		/// Sobel normal map filter.
		/// </summary>
		Sobel
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterShape.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Select the kind of shape of your texture.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	[Flags]
	public enum TextureImporterShape
	{
		/// <summary>
		/// Texture is 2D.
		/// </summary>
		Texture2D = 1,
		/// <summary>
		/// Texture is a Cubemap.
		/// </summary>
		TextureCube = 2,
		Texture2DArray = 4,
		Texture3D = 8,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureImporterType.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// Select this to set basic parameters depending on the purpose of your texture.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureImporterType
	{
		/// <summary>
		/// This is the most common setting used for all the textures in general.
		/// </summary>
		Default = 0,
		/// <summary>
		/// This is the most common setting used for all the textures in general.
		/// </summary>
		Image = 0,
		/// <summary>
		/// Select this to turn the color channels into a format suitable for real-time normal mapping.
		/// </summary>
		NormalMap = 1,
		Bump = 1,
		/// <summary>
		/// Use this if your texture is going to be used on any HUD/GUI Controls.
		/// </summary>
		GUI = 2,
		Cubemap = 3,
		Reflection = 3,
		/// <summary>
		/// This sets up your texture with the basic parameters used for the Cookies of your lights.
		/// </summary>
		Cookie = 4,
		Advanced = 5,
		/// <summary>
		/// This sets up your texture with the parameters used by the lightmap.
		/// </summary>
		Lightmap = 6,
		/// <summary>
		/// Use this if your texture is going to be used as a cursor.
		/// </summary>
		Cursor = 7,
		/// <summary>
		/// Select this if you will be using your texture for Sprite graphics.
		/// </summary>
		Sprite = 8,
		HDRI = 9,
		/// <summary>
		/// Use this for texture containing a single channel.
		/// </summary>
		SingleChannel = 10,
		Shadowmask = 11,
		DirectionalLightmap = 12,
	}
}

```

`AssetRipperCommon/Classes/Meta/Importers/Texture/TextureResizeAlgorithm.cs`:

```cs
namespace AssetRipper.Core.Classes.Meta.Importers.Texture
{
	/// <summary>
	/// For Texture to be scaled down choose resize algorithm.
	/// ( Applyed only when Texture dimension is bigger than Max Size ).<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureResizeAlgorithm
	{
		/// <summary>
		/// Default high quality resize algorithm.
		/// </summary>
		Mitchell = 0,
		/// <summary>
		/// Might provide better result than Mitchell for some noise textures preserving more sharp details.
		/// </summary>
		Bilinear = 1,
	}
}

```

`AssetRipperCommon/Classes/Misc/IStreamingInfo.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;

namespace AssetRipper.Core.Classes.Misc
{
	public interface IStreamingInfo : IUnityAssetBase
	{
		/// <summary>
		/// uint on versions &lt; 2020
		/// </summary>
		long Offset { get; set; }
		uint Size { get; set; }
		string Path { get; set; }
	}

	public static class StreamingInfoExtensions
	{
		public static bool IsSet(this IStreamingInfo streamingInfo) => !string.IsNullOrEmpty(streamingInfo.Path);

		public static bool CheckIntegrity(this IStreamingInfo streamingInfo, ISerializedFile file)
		{
			if (!streamingInfo.IsSet())
			{
				return true;
			}
			return file.Collection.FindResourceFile(streamingInfo.Path) != null;
		}

		public static byte[] GetContent(this IStreamingInfo streamingInfo, ISerializedFile file)
		{
			IResourceFile res = file.Collection.FindResourceFile(streamingInfo.Path);
			if (res == null)
			{
				return null;
			}

			byte[] data = new byte[streamingInfo.Size];
			res.Stream.Position = streamingInfo.Offset;
			res.Stream.ReadBuffer(data, 0, data.Length);
			return data;
		}

		public static void CopyValues(this IStreamingInfo destination, IStreamingInfo source)
		{
			destination.Offset = source.Offset;
			destination.Size = source.Size;
			destination.Path = source.Path;
		}
	}
}

```

`AssetRipperCommon/Classes/NavMeshAgent/ObstacleAvoidanceType.cs`:

```cs
namespace AssetRipper.Core.Classes.NavMeshAgent
{
	/// <summary>
	/// Level of obstacle avoidance.
	/// </summary>
	public enum ObstacleAvoidanceType
	{
		/// <summary>
		/// Disable avoidance.
		/// </summary>
		NoObstacleAvoidance = 0,
		/// <summary>
		/// Enable simple avoidance. Low performance impact.
		/// </summary>
		LowQualityObstacleAvoidance = 1,
		/// <summary>
		/// Medium avoidance. Medium performance impact.
		/// </summary>
		MedQualityObstacleAvoidance = 2,
		/// <summary>
		/// Good avoidance. High performance impact.
		/// </summary>
		GoodQualityObstacleAvoidance = 3,
		/// <summary>
		/// Enable highest precision. Highest performance impact.
		/// </summary>
		HighQualityObstacleAvoidance = 4
	}
}

```

`AssetRipperCommon/Classes/NavMeshObstacle/NavMeshObstacleShape.cs`:

```cs
namespace AssetRipper.Core.Classes.NavMeshObstacle
{
	/// <summary>
	/// Shape of the obstacle.
	/// </summary>
	public enum NavMeshObstacleShape
	{
		/// <summary>
		/// Capsule shaped obstacle.
		/// </summary>
		Capsule = 0,
		/// <summary>
		/// Box shaped obstacle.
		/// </summary>
		Box = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/CollisionModule/ParticleSystemCollisionMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.CollisionModule
{
	/// <summary>
	/// Whether to use 2D or 3D colliders for particle collisions.
	/// </summary>
	public enum ParticleSystemCollisionMode
	{
		/// <summary>
		/// Use 3D colliders to collide particles against.
		/// </summary>
		Collision3D = 0,
		/// <summary>
		/// Use 2D colliders to collide particles against.
		/// </summary>
		Collision2D = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/CollisionModule/ParticleSystemCollisionQuality.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.CollisionModule
{
	/// <summary>
	/// Quality of world collisions. Medium and low quality are approximate and may leak particles.
	/// </summary>
	public enum ParticleSystemCollisionQuality
	{
		/// <summary>
		/// The most accurate world collisions.
		/// </summary>
		High = 0,
		/// <summary>
		/// Approximate world collisions.
		/// </summary>
		Medium = 1,
		/// <summary>
		/// Fastest and most approximate world collisions.
		/// </summary>
		Low = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/CollisionModule/ParticleSystemCollisionType.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.CollisionModule
{
	/// <summary>
	/// The type of collisions to use for a given particle system.
	/// </summary>
	public enum ParticleSystemCollisionType
	{
		/// <summary>
		/// Collide with a list of planes.
		/// </summary>
		Planes = 0,
		/// <summary>
		/// Collide with the world geometry.
		/// </summary>
		World = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Curve/ParticleSystemCurveMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Curve
{
	public enum ParticleSystemCurveMode : ushort
	{
		Constant = 0,
		Curve = 1,
		TwoCurves = 2,
		TwoConstants = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/CustomDataModule/ParticleSystemCustomDataMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.CustomDataModule
{
	/// <summary>
	/// Which mode the Custom Data module uses to generate its data.
	/// </summary>
	public enum ParticleSystemCustomDataMode
	{
		/// <summary>
		/// Don't generate any data.
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Generate data using ParticleSystem.MinMaxCurve.
		/// </summary>
		// Token: 0x04000412 RID: 1042
		Vector = 1,
		/// <summary>
		/// Generate data using ParticleSystem.MinMaxGradient.
		/// </summary>
		Color = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Emission/EmissionType.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Emission
{
	public enum EmissionType
	{
		Time = 0,
		Distance = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/InheritVelocity/InheritVelocityMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.InheritVelocity
{
	public enum InheritVelocityMode
	{
		Initial = 0,
		Current = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/MinMaxGradient/MinMaxGradientState.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.MinMaxGradient
{
	public enum MinMaxGradientState : ushort
	{
		Color = 0,
		Gradient = 1,
		RandomBetweenTwoColors = 2,
		RandomBetweenTwoGradients = 3,
		RandomColor = 4,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/NoiseModule/ParticleSystemNoiseQuality.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.NoiseModule
{
	/// <summary>
	/// The quality of the generated noise.
	/// </summary>
	public enum ParticleSystemNoiseQuality
	{
		/// <summary>
		/// Low quality 1D noise.
		/// </summary>
		Low = 0,
		/// <summary>
		/// Medium quality 2D noise.
		/// </summary>
		Medium = 1,
		/// <summary>
		/// High quality 3D noise.
		/// </summary>
		High = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/ParticleSystemCullingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem
{
	/// <summary>
	/// The action to perform when the Particle System is offscreen.
	/// </summary>
	public enum ParticleSystemCullingMode
	{
		/// <summary>
		/// For looping effects, the simulation is paused when offscreen, and for one-shot effects, the simulation will continue playing.
		/// </summary>
		Automatic = 0,
		/// <summary>
		/// Pause the Particle System simulation when it is offscreen, and perform an extra simulation when the system comes back onscreen, creating the impression that it was never paused.
		/// </summary>
		PauseAndCatchup = 1,
		/// <summary>
		/// Pause the Particle System simulation when it is offscreen.
		/// </summary>
		Pause = 2,
		/// <summary>
		/// Continue simulating the Particle System when it is offscreen.
		/// </summary>
		AlwaysSimulate = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/ParticleSystemRingBufferMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem
{
	/// <summary>
	/// Control how particles are removed from the Particle System.
	/// </summary>
	public enum ParticleSystemRingBufferMode
	{
		/// <summary>
		/// Particles are removed when their age exceeds their lifetime.
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Particles are removed when creating new particles would exceed the Max Particles property.
		/// </summary>
		PauseUntilReplaced = 1,
		/// <summary>
		/// Particles are removed when creating new particles would exceed the Max Particles property. Before being removed, particles remain alive until their age exceeds their lifetime.
		/// </summary>
		LoopUntilReplaced = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/ParticleSystemScalingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem
{
	/// <summary>
	/// Control how particle systems apply transform scale.
	/// </summary>
	public enum ParticleSystemScalingMode
	{
		/// <summary>
		/// Scale the particle system using the entire transform hierarchy.
		/// </summary>
		Hierarchy = 0,
		/// <summary>
		/// Scale the particle system using only its own transform scale. (Ignores parent scale).
		/// </summary>
		Local = 1,
		/// <summary>
		/// Only apply transform scale to the shape component, which controls where particles
		/// are spawned, but does not affect their size or movement.
		/// </summary>
		Shape = 2
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/ParticleSystemSimulationSpace.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem
{
	/// <summary>
	/// The space to simulate particles in.
	/// </summary>
	public enum ParticleSystemSimulationSpace
	{
		/// <summary>
		/// Simulate particles in local space.
		/// </summary>
		Local = 0,
		/// <summary>
		/// Simulate particles in world space.
		/// </summary>
		World = 1,
		/// <summary>
		/// Simulate particles relative to a custom transform component, defined by ParticleSystem.MainModule.customSimulationSpace.
		/// </summary>
		Custom = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/ParticleSystemStopAction.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem
{
	/// <summary>
	/// The action to perform when the Particle System stops.
	/// </summary>
	public enum ParticleSystemStopAction
	{
		/// <summary>
		/// Do nothing.
		/// </summary>
		None = 0,
		/// <summary>
		/// Disable the GameObject containing the Particle System.
		/// </summary>
		Disable = 1,
		/// <summary>
		/// Destroy the GameObject containing the Particle System.
		/// </summary>
		Destroy = 2,
		/// <summary>
		/// Call OnParticleSystemStopped on the ParticleSystem script.
		/// </summary>
		Callback = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Shape/ParticleSystemShapeMultiModeValue.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Shape
{
	/// <summary>
	/// The mode used to generate new points in a shape.
	/// </summary>
	public enum ParticleSystemShapeMultiModeValue
	{
		/// <summary>
		/// Generate points randomly.
		/// </summary>
		Random = 0,
		/// <summary>
		/// Animate the emission point around the shape.
		/// </summary>
		Loop = 1,
		/// <summary>
		/// Animate the emission point around the shape, alternating between clockwise and counter-clockwise directions.
		/// </summary>
		PingPong = 2,
		/// <summary>
		/// Distribute new particles around the shape evenly.
		/// </summary>
		BurstSpread = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Shape/ParticleSystemShapeType.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Shape
{
	/// <summary>
	/// The emission shape.
	/// </summary>
	public enum ParticleSystemShapeType
	{
		/// <summary>
		/// Emit from a sphere.
		/// </summary>
		Sphere = 0,
		/// <summary>
		/// Emit from the surface of a sphere.
		/// </summary>
		SphereShell = 1,
		/// <summary>
		/// Emit from a half-sphere.
		/// </summary>
		Hemisphere = 2,
		/// <summary>
		/// Emit from the surface of a half-sphere.
		/// </summary>
		HemisphereShell = 3,
		/// <summary>
		/// Emit from the base of a cone.
		/// </summary>
		Cone = 4,
		/// <summary>
		/// Emit from the volume of a box.
		/// </summary>
		Box = 5,
		/// <summary>
		/// Emit from a mesh.
		/// </summary>
		Mesh = 6,
		/// <summary>
		/// Emit from the base surface of a cone.
		/// </summary>
		ConeShell = 7,
		/// <summary>
		/// Emit from a cone.
		/// </summary>
		ConeVolume = 8,
		/// <summary>
		/// Emit from the surface of a cone.
		/// </summary>
		ConeVolumeShell = 9,
		/// <summary>
		/// Emit from a circle.
		/// </summary>
		Circle = 10,
		/// <summary>
		/// Emit from the edge of a circle.
		/// </summary>
		CircleEdge = 11,
		/// <summary>
		/// Emit from an edge.
		/// </summary>
		SingleSidedEdge = 12,
		/// <summary>
		/// Emit from a mesh renderer.
		/// </summary>
		MeshRenderer = 13,
		/// <summary>
		/// Emit from a skinned mesh renderer.
		/// </summary>
		SkinnedMeshRenderer = 14,
		/// <summary>
		/// Emit from the surface of a box.
		/// </summary>
		BoxShell = 15,
		/// <summary>
		/// Emit from the edges of a box.
		/// </summary>
		BoxEdge = 16,
		/// <summary>
		/// Emit from a Donut.
		/// </summary>
		Donut = 17
	}

	public static class ParticleSystemShapeTypeExtensions
	{
		public static bool IsBoxAny(this ParticleSystemShapeType _this)
		{
			switch (_this)
			{
				case ParticleSystemShapeType.Box:
				case ParticleSystemShapeType.BoxEdge:
				case ParticleSystemShapeType.BoxShell:
					return true;

				default:
					return false;
			}
		}
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Shape/PlacementMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Shape
{
	public enum PlacementMode
	{
		BoxVolume = 0,
		ConeBase = 0,
		MeshVertex = 0,
		BoxShell = 1,
		ConeVolume = 1,
		MeshEdge = 1,
		BoxEdge = 2,
		MeshTriangle = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/SubEmitter/ParticleSystemSubEmitterProperties.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.SubEmitter
{
	/// <summary>
	/// The properties of sub-emitter particles.
	/// </summary>
	[Flags]
	public enum ParticleSystemSubEmitterProperties
	{
		/// <summary>
		/// When spawning new particles, do not inherit any properties from the parent particles.
		/// </summary>
		InheritNothing = 0,
		/// <summary>
		/// When spawning new particles, multiply the start color by the color of the parent particles.
		/// </summary>
		InheritColor = 1,
		/// <summary>
		/// When spawning new particles, multiply the start size by the size of the parent particles.
		/// </summary>
		InheritSize = 2,
		/// <summary>
		/// When spawning new particles, add the start rotation to the rotation of the parent particles.
		/// </summary>
		InheritRotation = 4,
		/// <summary>
		/// New particles will have a shorter lifespan, the closer their parent particles are to death.
		/// </summary>
		InheritLifetime = 8,
		/// <summary>
		/// When spawning new particles, use the duration and age properties from the parent system, when sampling Main module curves in the Sub-Emitter.
		/// </summary>
		InheritDuration = 16,

		/// <summary>
		/// When spawning new particles, inherit all available properties from the parent particles.
		/// </summary>
		InheritEverything = 0x1F,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/SubEmitter/ParticleSystemSubEmitterType.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.SubEmitter
{
	public enum ParticleSystemSubEmitterType
	{
		Birth = 0,
		Collision = 1,
		Death = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/TrailModule/ParticleSystemTrailMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.TrailModule
{
	/// <summary>
	/// Choose how Particle Trails are generated.
	/// </summary>
	public enum ParticleSystemTrailMode
	{
		/// <summary>
		/// Makes a trail behind each particle as the particle moves.
		/// </summary>
		PerParticle = 0,
		/// <summary>
		/// Draws a line between each particle, connecting the youngest particle to the oldest.
		/// </summary>
		Ribbon = 1
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/TrailModule/ParticleSystemTrailTextureMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.TrailModule
{
	/// <summary>
	/// Choose how textures are applied to Particle Trails.
	/// </summary>
	public enum ParticleSystemTrailTextureMode
	{
		/// <summary>
		/// Map the texture once along the entire length of the trail.
		/// </summary>
		Stretch = 0,
		/// <summary>
		/// Repeat the texture along the trail. To set the tiling rate, use Material.SetTextureScale.
		/// </summary>
		Tile = 1,
		/// <summary>
		/// Map the texture once along the entire length of the trail, assuming all vertices are evenly spaced.
		/// </summary>
		DistributePerSegment = 2,
		/// <summary>
		/// Repeat the texture along the trail, repeating at a rate of once per trail segment. To adjust the tiling rate, use Material.SetTextureScale.
		/// </summary>
		RepeatPerSegment = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/Trigger/TriggerAction.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.Trigger
{
	public enum TriggerAction
	{
		Ignore = 0,
		Kill = 1,
		Callback = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/UV/ParticleSystemAnimationMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.UV
{
	/// <summary>
	/// The animation mode.
	/// </summary>
	public enum ParticleSystemAnimationMode
	{
		/// <summary>
		/// Use a regular grid to construct a sequence of animation frames.
		/// </summary>
		Grid = 0,
		/// <summary>
		/// Use a list of sprites to construct a sequence of animation frames.
		/// </summary>
		Sprites = 1,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/UV/ParticleSystemAnimationRowMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.UV
{
	/// <summary>
	/// The mode used for selecting rows of an animation in the Texture Sheet Animation Module
	/// </summary>
	public enum ParticleSystemAnimationRowMode
	{
		/// <summary>
		/// Use a specific row for all particles
		/// </summary>
		Custom = 0,
		/// <summary>
		/// Use a random row for each particle
		/// </summary>
		Random = 1,
		/// <summary>
		/// Use the mesh index as the row, so that meshes can be mapped to specific animation frames
		/// </summary>
		MeshIndex = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/UV/ParticleSystemAnimationTimeMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.UV
{
	/// <summary>
	/// Control how animation frames are selected.
	/// </summary>
	public enum ParticleSystemAnimationTimeMode
	{
		/// <summary>
		/// Select animation frames based on the particle ages.
		/// </summary>
		Lifetime = 0,
		/// <summary>
		/// Select animation frames based on the particle speeds.
		/// </summary>
		Speed = 1,
		/// <summary>
		/// Select animation frames sequentially at a constant rate of the specified frames per second.
		/// </summary>
		FPS = 2,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystem/UV/ParticleSystemAnimationType.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystem.UV
{
	/// <summary>
	/// The animation type.
	/// </summary>
	public enum ParticleSystemAnimationType
	{
		/// <summary>
		/// Animate over the whole texture sheet from left to right, top to bottom.
		/// </summary>
		WholeSheet,
		/// <summary>
		/// Animate a single row in the sheet from left to right.
		/// </summary>
		SingleRow
	}
}

```

`AssetRipperCommon/Classes/ParticleSystemForceField/ParticleSystemForceFieldShape.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystemForceField
{
	public enum ParticleSystemForceFieldShape
	{
		/// <summary>
		/// Influence particles inside a sphere shape.
		/// </summary>
		Sphere = 0,
		/// <summary>
		/// Influence particles inside a hemisphere shape.
		/// </summary>
		Hemisphere = 1,
		/// <summary>
		/// Influence particles inside a cylinder shape.
		/// </summary>
		Cylinder = 2,
		/// <summary>
		/// Influence particles inside a box shape.
		/// </summary>
		Box = 3,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystemRenderer/ParticleSystemRenderMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystemRenderer
{
	/// <summary>
	/// The rendering mode for particle systems
	/// </summary>
	public enum ParticleSystemRenderMode
	{
		/// <summary>
		/// Render particles as billboards facing the active camera.
		/// </summary>
		Billboard = 0,
		/// <summary>
		/// Stretch particles in the direction of motion.
		/// </summary>
		Stretch = 1,
		/// <summary>
		/// Render particles as billboards always facing up along the y-Axis.
		/// </summary>
		HorizontalBillboard = 2,
		/// <summary>
		/// Render particles as billboards always facing the player, but not pitching along the x-Axis.
		/// </summary>
		VerticalBillboard = 3,
		/// <summary>
		/// Render particles as meshes.
		/// </summary>
		Mesh = 4,
		/// <summary>
		/// Do not render particles.
		/// </summary>
		None = 5,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystemRenderer/ParticleSystemRenderSpace.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystemRenderer
{
	/// <summary>
	/// How particles are aligned when rendered.
	/// </summary>
	public enum ParticleSystemRenderSpace
	{
		/// <summary>
		/// Particles face the camera plane.
		/// </summary>
		View = 0,
		/// <summary>
		/// Particles align with the world.
		/// </summary>
		World = 1,
		/// <summary>
		/// Particles align with their local transform.
		/// </summary>
		Local = 2,
		/// <summary>
		/// Particles face the eye position.
		/// </summary>
		Facing = 3,
		/// <summary>
		/// Particles are aligned to their direction of travel.
		/// </summary>
		Velocity = 4,
	}
}

```

`AssetRipperCommon/Classes/ParticleSystemRenderer/ParticleSystemSortMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ParticleSystemRenderer
{
	/// <summary>
	/// The sorting mode for particle systems.
	/// </summary>
	public enum ParticleSystemSortMode
	{
		/// <summary>
		/// No sorting.
		/// </summary>
		None = 0,
		/// <summary>
		/// Sort based on distance.
		/// </summary>
		Distance = 1,
		/// <summary>
		/// Sort the oldest particles to the front.
		/// </summary>
		OldestInFront = 2,
		/// <summary>
		/// Sort the youngest particles to the front.
		/// </summary>
		YoungestInFront = 3,
	}
}

```

`AssetRipperCommon/Classes/PhysicsManager/BroadphaseType.cs`:

```cs
namespace AssetRipper.Core.Classes.PhysicsManager
{
	public enum BroadphaseType
	{
		SweepAndPruneBroadphase = 0,
		MultiboxPruningBroadphase = 1,
	}
}

```

`AssetRipperCommon/Classes/PhysicsManager/ContactPairsMode.cs`:

```cs
namespace AssetRipper.Core.Classes.PhysicsManager
{
	public enum ContactPairsMode
	{
		DefaultContactPairs = 0,
		EnableKinematicKinematicPairs = 1,
		EnableKinematicStaticPairs = 2,
		EnableAllContactPairs = 3,
	}
}

```

`AssetRipperCommon/Classes/PhysicsManager/ContactsGeneration.cs`:

```cs
namespace AssetRipper.Core.Classes.PhysicsManager
{
	public enum ContactsGeneration
	{
		LegacyContactsGeneration = 0,
		PersistentContactManifold = 1,
	}
}

```

`AssetRipperCommon/Classes/PhysicsManager/FrictionType.cs`:

```cs
namespace AssetRipper.Core.Classes.PhysicsManager
{
	public enum FrictionType
	{
		Patch = 0,
		OneDirectional = 1,
		TwoDirectional = 2,
	}
}

```

`AssetRipperCommon/Classes/PhysicsManager/SolverType.cs`:

```cs
namespace AssetRipper.Core.Classes.PhysicsManager
{
	public enum SolverType
	{
		ProjectedGaussSiedel = 0,
		TemporalGaussSiedel = 1,
	}
}

```

`AssetRipperCommon/Classes/PrefabInstance/IPrefabInstance.cs`:

```cs
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.PrefabInstance
{
	/// <summary>
	/// PrefabInstance - versions &gt;= 2018.3<br/>
	/// Prefab - versions &gt;= 3.5<br/>
	/// DataTemplate - versions &lt; 3.5
	/// </summary>
	public interface IPrefabInstance : IUnityObjectBase
	{
		/// <summary>
		/// Only on versions &gt;= 3.5
		/// </summary>
		PPtr<IGameObject> RootGameObjectPtr { get; set; }
		/// <summary>
		/// m_SourcePrefab - versions &gt;= 2018.2<br/>
		/// m_ParentPrefab - versions &gt;= 3.5<br/>
		/// m_Father - versions &lt; 3.5
		/// </summary>
		PPtr<IPrefabInstance> SourcePrefabPtr { get; set; }
		/// <summary>
		/// Only on versions &lt; 2018.3<br/>
		/// m_IsPrefabAsset - versions &gt;= 2018.2<br/>
		/// m_IsPrefabParent - versions &gt;= 3.5<br/>
		/// m_IsDataTemplate - versions &lt; 3.5
		/// </summary>
		bool IsPrefabAsset { get; set; }
	}

	public static class PrefabInstanceExtensions
	{
		public static string GetName(this IPrefabInstance prefab, IAssetContainer file)
		{
			if (prefab is IHasNameString hasName && string.IsNullOrEmpty(hasName.NameString))
			{
				return hasName.NameString;
			}
			else
			{
				return prefab.RootGameObjectPtr.TryGetAsset(file)?.NameString;
			}
		}

		public static IEnumerable<IEditorExtension> FetchObjects(this IPrefabInstance prefab, IAssetContainer file)
		{
#warning TEMP HACK:
			//if (file.Layout.PrefabInstance.IsModificationFormat)
			{
				foreach (IEditorExtension asset in prefab.RootGameObjectPtr.GetAsset(file).FetchHierarchy())
				{
					yield return asset;
				}
			}
			/*else
			{
				foreach (PPtr<EditorExtension> asset in Objects)
				{
					yield return asset.GetAsset(file);
				}
			}*/
		}
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/AnisotropicFiltering.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// Anisotropic filtering mode.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum AnisotropicFiltering
	{
		/// <summary>
		/// Disable anisotropic filtering for all textures.
		/// </summary>
		Disable = 0,
		/// <summary>
		/// Enable anisotropic filtering, as set for each texture.
		/// </summary>
		Enable = 1,
		/// <summary>
		/// Enable anisotropic filtering for all textures.
		/// </summary>
		ForceEnable = 2,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/AntiAliasing.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	public enum AntiAliasing
	{
		Disabled = 0,
		_2X = 2,
		_4X = 4,
		_8X = 8,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/QualityLevel.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum QualityLevel
	{
		Fastest = 0,
		Fast = 1,
		Simple = 2,
		Good = 3,
		Beautiful = 4,
		Fantastic = 5,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/ShadowCascades.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	public enum ShadowCascades
	{
		NoCascades = 1,
		TwoCascades = 2,
		FourCascades = 4,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/ShadowProjection.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// Shadow projection type for Quality Settings.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShadowProjection
	{
		/// <summary>
		/// Close fit shadow maps with linear fadeout.
		/// </summary>
		CloseFit = 0,
		/// <summary>
		/// Stable shadow maps with spherical fadeout.
		/// </summary>
		StableFit = 1,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/ShadowQuality.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// Determines which type of shadows should be used.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShadowQuality
	{
		/// <summary>
		/// Disable Shadows.
		/// </summary>
		Disable = 0,
		/// <summary>
		/// Hard Shadows Only.
		/// </summary>
		HardOnly = 1,
		/// <summary>
		/// Hard and Soft Shadows.
		/// </summary>
		All = 2,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/ShadowResolution.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// Default shadow resolution.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShadowResolution
	{
		/// <summary>
		/// Low shadow map resolution.
		/// </summary>
		Low = 0,
		/// <summary>
		/// Medium shadow map resolution.
		/// </summary>
		Medium = 1,
		/// <summary>
		/// High shadow map resolution.
		/// </summary>
		High = 2,
		/// <summary>
		/// Very high shadow map resolution.
		/// </summary>
		VeryHigh = 3,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/ShadowmaskMode.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// The rendering mode of Shadowmask.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShadowmaskMode
	{
		/// <summary>
		/// Static shadow casters won't be rendered into realtime shadow maps.
		/// ll shadows from static casters are handled via Shadowmasks and occlusion from Light Probes.
		/// </summary>
		Shadowmask = 2,
		/// <summary>
		/// Static shadow casters will be rendered into realtime shadow maps.
		/// Shadowmasks and occlusion from Light Probes will only be used past the realtime shadow distance.
		/// </summary>
		DistanceShadowmask = 1,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/SkinWeights.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	/// <summary>
	/// How many bones affect each vertex.
	/// BlendWeights previously<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum SkinWeights
	{
		/// <summary>
		/// One bone affects each vertex.
		/// </summary>
		OneBone = 1,
		/// <summary>
		/// Two bones affect each vertex.
		/// </summary>
		TwoBones = 2,
		/// <summary>
		/// Four bones affect each vertex.
		/// </summary>
		FourBones = 4,
		/// <summary>
		/// An unlimited number of bones affect each vertex
		/// </summary>
		Unlimited = 255,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/TextureQuality.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	public enum TextureQuality
	{
		FullRes = 0,
		HalfRes = 1,
		QuarterRes = 2,
		EighthRes = 3,
	}
}

```

`AssetRipperCommon/Classes/QualitySettings/VSyncCount.cs`:

```cs
namespace AssetRipper.Core.Classes.QualitySettings
{
	public enum VSyncCount
	{
		DontSync = 0,
		EveryVBlank = 1,
		EverySecondVBlank = 2,
	}
}

```

`AssetRipperCommon/Classes/ReflectionProbe/ReflectionProbeClearFlags.cs`:

```cs
namespace AssetRipper.Core.Classes.ReflectionProbe
{
	public enum ReflectionProbeClearFlags
	{
		/// <summary>
		/// Values for ReflectionProbe.clearFlags, determining what to clear when rendering a ReflectionProbe.
		/// </summary>
		Skybox = 1,
		/// <summary>
		/// Clear with a background color.
		/// </summary>
		SolidColor = 2,
	}
}

```

`AssetRipperCommon/Classes/ReflectionProbe/ReflectionProbeMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ReflectionProbe
{
	/// <summary>
	/// Reflection probe's update mode.
	/// </summary>
	public enum ReflectionProbeMode
	{
		/// <summary>
		/// Reflection probe is baked in the Editor.
		/// </summary>
		Baked = 0,
		/// <summary>
		/// Reflection probe is updating in realtime.
		/// </summary>
		Realtime = 1,
		/// <summary>
		/// Reflection probe uses a custom texture specified by the user.
		/// </summary>
		Custom = 2,
	}
}

```

`AssetRipperCommon/Classes/ReflectionProbe/ReflectionProbeRefreshMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ReflectionProbe
{
	public enum ReflectionProbeRefreshMode
	{
		/// <summary>
		/// Causes the probe to update only on the first frame it becomes visible. The probe will no longer update automatically, however you may subsequently use RenderProbe to refresh the probe
		/// See Also: ReflectionProbe.RenderProbe.
		/// </summary>
		OnAwake = 0,
		/// <summary>
		/// Causes Unity to update the probe's cubemap every frame.
		/// Note that updating a probe is very costly. Setting this option on too many probes could have a significant negative effect on frame rate. Use time-slicing to help improve performance.
		/// See Also: ReflectionProbeTimeSlicingMode.
		/// </summary>
		EveryFrame = 1,
		/// <summary>
		/// Sets the probe to never be automatically updated by Unity while your game is running. Use this to completely control the probe refresh behavior by script.
		/// See Also: ReflectionProbe.RenderProbe.
		/// </summary>
		ViaScripting = 2,
	}
}

```

`AssetRipperCommon/Classes/ReflectionProbe/ReflectionProbeTimeSlicingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.ReflectionProbe
{
	/// <summary>
	/// When a probe's ReflectionProbe.refreshMode is set to ReflectionProbeRefreshMode.EveryFrame, this enum specify whether or not Unity should update the probe's cubemap over several frames or update the whole cubemap in one frame.
	/// Updating a probe's cubemap is a costly operation. Unity needs to render the entire Scene for each face of the cubemap, as well as perform special blurring in order to get glossy reflections. The impact on frame rate can be significant. Time-slicing helps maintaning a more constant frame rate during these updates by performing the rendering over several frames.
	/// </summary>
	public enum ReflectionProbeTimeSlicingMode
	{
		/// <summary>
		/// Instructs Unity to use time-slicing by first rendering all faces at once, then spreading the remaining work over the next 8 frames. Using this option, updating the probe will take 9 frames.
		/// </summary>
		AllFacesAtOnce = 0,
		/// <summary>
		/// Instructs Unity to spread the rendering of each face over several frames. Using this option, updating the cubemap will take 14 frames. This option greatly reduces the impact on frame rate, however it may produce incorrect results, especially in Scenes where lighting conditions change over these 14 frames.
		/// </summary>
		IndividualFaces = 1,
		/// <summary>
		/// Unity will render the probe entirely in one frame.
		/// </summary>
		NoTimeSlicing = 2,
	}
}

```

`AssetRipperCommon/Classes/ReflectionProbe/ReflectionProbeType.cs`:

```cs
namespace AssetRipper.Core.Classes.ReflectionProbe
{
	public enum ReflectionProbeType
	{
		/// <summary>
		/// Surrounding of the reflection probe is rendered into cubemap.
		/// </summary>
		Cube = 0,
		/// <summary>
		/// Surrounding of the reflection probe is rendered onto a quad.
		/// </summary>
		Card = 1,
	}
}

```

`AssetRipperCommon/Classes/RenderSettings/AmbientMode.cs`:

```cs
namespace AssetRipper.Core.Classes.RenderSettings
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum AmbientMode
	{
		/// <summary>
		/// Skybox-based or custom ambient lighting.
		/// </summary>
		Skybox = 0,
		/// <summary>
		/// Trilight ambient lighting.
		/// </summary>
		Trilight = 1,
		/// <summary>
		/// Flat ambient lighting.
		/// </summary>
		Flat = 3,
		/// <summary>
		/// Ambient lighting is defined by a custom cubemap.
		/// </summary>
		Custom = 4,
	}
}

```

`AssetRipperCommon/Classes/RenderSettings/FogMode.cs`:

```cs
namespace AssetRipper.Core.Classes.RenderSettings
{
	/// <summary>
	/// Fog mode to use.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum FogMode
	{
		/// <summary>
		/// Unknown fog.
		/// </summary>
		Unknown = -1,
		/// <summary>
		/// Disabled fog.
		/// </summary>
		Disabled = 0,
		/// <summary>
		/// Linear fog.
		/// </summary>
		Linear = 1,
		/// <summary>
		/// Exponential fog.
		/// </summary>
		Exponential = 2,
		/// <summary>
		/// Exponential squared fog (default).
		/// </summary>
		ExponentialSquared = 3
	}
}

```

`AssetRipperCommon/Classes/RenderTexture/RenderTextureFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.RenderTexture
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum RenderTextureFormat
	{
		ARGB32 = 0,
		Depth = 1,
		ARGBHalf = 2,
		Shadowmap = 3,
		RGB565 = 4,
		ARGB4444 = 5,
		ARGB1555 = 6,
		Default = 7,
		ARGB2101010 = 8,
		DefaultHDR = 9,
		ARGB64 = 10,
		ARGBFloat = 11,
		RGFloat = 12,
		RGHalf = 13,
		RFloat = 14,
		RHalf = 15,
		R8 = 16,
		ARGBInt = 17,
		RGInt = 18,
		RInt = 19,
		BGRA32 = 20,
		kRTFormatVideo = 21,
		RGB111110Float = 22,
		RG32 = 23,
		RGBAUShort = 24,
		RG16 = 25,
		BGRA10101010_XR = 26,
		BGR101010_XR = 27,
		R16 = 28,
	}
}

```

`AssetRipperCommon/Classes/Renderer/EditorSelectedRenderState.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// The editor selected render mode for Scene View selection.
	/// </summary>
	public enum EditorSelectedRenderState
	{
		/// <summary>
		/// The Renderer has no selection highlight or wireframe in the Editor.
		/// </summary>
		Hidden = 0,
		/// <summary>
		/// The Renderer has wireframe but not selection highlight in the Editor.
		/// </summary>
		Wireframe = 1,
		/// <summary>
		/// The Renderer has selection highlight but no wireframe in the Editor.
		/// </summary>
		Highlight = 2
	}
}

```

`AssetRipperCommon/Classes/Renderer/LightProbeUsage.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// Light probe interpolation type.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LightProbeUsage : byte
	{
		/// <summary>
		/// Light Probes are not used. The scene's ambient probe is provided to the shader.
		/// </summary>
		Off = 0,
		/// <summary>
		/// Simple light probe interpolation is used.
		/// </summary>
		BlendProbes = 1,
		/// <summary>
		/// Uses a 3D grid of interpolated light probes.
		/// </summary>
		UseProxyVolume = 2,
		/// <summary>
		/// Internal use only
		/// </summary>
		ExplicitIndex = 3,
		/// <summary>
		/// The light probe shader uniform values are extracted from the material property block set on the renderer.
		/// </summary>
		CustomProvided = 4,
	}
}

```

`AssetRipperCommon/Classes/Renderer/MotionVectorGenerationMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// The type of motion vectors that should be generated.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum MotionVectorGenerationMode : byte
	{
		/// <summary>
		/// Use only camera movement to track motion.
		/// </summary>
		Camera = 0,
		/// <summary>
		/// Use a specific pass (if required) to track motion.
		/// </summary>
		Object = 1,
		/// <summary>
		/// Do not track motion. Motion vectors will be 0.
		/// </summary>
		ForceNoMotion = 2,
	}
}

```

`AssetRipperCommon/Classes/Renderer/RayTracingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// Indicates how a Renderer is updated<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum RayTracingMode
	{
		/// <summary>
		/// Renderers with this mode are not ray traced
		/// </summary>
		Off = 0,
		/// <summary>
		/// Renderers with this mode never update
		/// </summary>
		Static = 1,
		/// <summary>
		/// Renderers with this mode update their Transform, but not their Mesh
		/// </summary>
		DynamicTransform = 2,
		/// <summary>
		/// Renderers with this mode have animated geometry and update their Mesh and Transform
		/// </summary>
		DynamicGeometry = 3,
	}
}

```

`AssetRipperCommon/Classes/Renderer/ReceiveGI.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// Determines if the object receives Global Illumination from its surroundings through either Lightmaps or LightProbes.
	/// Forced to LightProbes if Contribute GI is turned off<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ReceiveGI
	{
		Off = 0,
		/// <summary>
		/// Makes the GameObject use lightmaps to receive Global Illumination
		/// </summary>
		Lightmaps = 1,
		/// <summary>
		/// The object will have the option to use Light Probes to receive Global Illumination. See LightProbeUsage
		/// </summary>
		LightProbes = 2,
	}
}

```

`AssetRipperCommon/Classes/Renderer/ReflectionProbeUsage.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// Reflection Probe usage.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ReflectionProbeUsage
	{
		/// <summary>
		/// Reflection probes are disabled, skybox will be used for reflection.
		/// </summary>
		Off = 0,
		/// <summary>
		/// Reflection probes are enabled. Blending occurs only between probes, useful in indoor environments.
		/// The renderer will use default reflection if there are no reflection probes nearby,
		/// but no blending between default reflection and probe will occur.
		/// </summary>
		BlendProbes = 1,
		/// <summary>
		/// Reflection probes are enabled. Blending occurs between probes or probes and default reflection, useful for outdoor environments.
		/// </summary>
		BlendProbesAndSkybox = 2,
		/// <summary>
		/// Reflection probes are enabled, but no blending will occur between probes when there are two overlapping volumes.
		/// </summary>
		Simple = 3,
	}
}

```

`AssetRipperCommon/Classes/Renderer/ShadowCastingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Renderer
{
	/// <summary>
	/// How shadows are cast from this object.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShadowCastingMode : byte
	{
		/// <summary>
		/// No shadows are cast from this object.
		/// </summary>
		Off = 0,
		/// <summary>
		/// Shadows are cast from this object.
		/// </summary>
		On = 1,
		/// <summary>
		/// Shadows are cast from this object, treating it as two-sided.
		/// </summary>
		TwoSided = 2,
		/// <summary>
		/// Object casts shadows, but is otherwise invisible in the scene.
		/// </summary>
		ShadowsOnly = 3,
	}
}

```

`AssetRipperCommon/Classes/Rigidbody/CollisionDetectionMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody
{
	public enum CollisionDetectionMode
	{
		Discrete = 0,
		Continuous = 1,
		ContinuousDynamic = 2
	}
}

```

`AssetRipperCommon/Classes/Rigidbody/RigidbodyConstraints.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody
{
	public enum RigidbodyConstraints
	{
		/// <summary>
		/// No constraints
		/// </summary>
		None = 0,
		/// <summary>
		/// Freeze motion along the X-axis.
		/// </summary>
		FreezePositionX = 0x02,
		/// <summary>
		/// Freeze motion along the Y-axis.
		/// </summary>
		FreezePositionY = 0x04,
		/// <summary>
		/// Freeze motion along the Z-axis.
		/// </summary>
		FreezePositionZ = 0x08,
		/// <summary>
		/// Freeze rotation along the X-axis.
		/// </summary>
		FreezeRotationX = 0x10,
		/// <summary>
		/// Freeze rotation along the Y-axis.
		/// </summary>
		FreezeRotationY = 0x20,
		/// <summary>
		/// Freeze rotation along the Z-axis.
		/// </summary>
		FreezeRotationZ = 0x40,
		/// <summary>
		/// Freeze motion along all axes.
		/// </summary>
		FreezePosition = 0x0e,
		/// <summary>
		/// Freeze rotation along all axes.
		/// </summary>
		FreezeRotation = 0x70,
		/// <summary>
		/// Freeze rotation and motion along all axes.
		/// </summary>
		FreezeAll = 0x7e,
	}
}

```

`AssetRipperCommon/Classes/Rigidbody/RigidbodyInterpolation.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody
{
	public enum RigidbodyInterpolation : byte
	{
		/// <summary>
		/// No Interpolation.
		/// </summary>
		None = 0,
		/// <summary>
		/// Interpolation will always lag a little bit behind but can be smoother than extrapolation.
		/// </summary>
		Interpolate = 1,
		/// <summary>
		/// Extrapolation will predict the position of the rigidbody based on the current velocity.
		/// </summary>
		Extrapolate = 2
	}
}

```

`AssetRipperCommon/Classes/Rigidbody2D/CollisionDetectionMode2D.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody2D
{
	public enum CollisionDetectionMode2D
	{
		/// <summary>
		/// Obsolete. Use Discrete instead.
		/// </summary>
		None = 0,
		/// <summary>
		/// Bodies move but may cause colliders to pass through other colliders at higher speeds
		/// but is much faster to calculate than continuous mode.
		/// </summary>
		Discrete = 0,
		/// <summary>
		/// Provides the most accurate collision detection to prevent colliders passing through other colliders at higher speeds
		/// but is much more expensive to calculate.
		/// </summary>
		Continuous = 1
	}
}

```

`AssetRipperCommon/Classes/Rigidbody2D/RigidbodyConstraints2D.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody2D
{
	[Flags]
	public enum RigidbodyConstraints2D
	{
		/// <summary>
		/// No constraints
		/// </summary>
		None = 0,
		/// <summary>
		/// Freeze motion along the X-axis.
		/// </summary>
		FreezePositionX = 1,
		/// <summary>
		/// Freeze motion along the Y-axis.
		/// </summary>
		FreezePositionY = 2,
		/// <summary>
		/// Freeze rotation along the Z-axis.
		/// </summary>
		FreezeRotation = 4,

		/// <summary>
		/// Freeze motion along all axes.
		/// </summary>
		FreezePosition = FreezePositionX | FreezePositionY,
		/// <summary>
		/// Freeze rotation and motion along all axes.
		/// </summary>
		FreezeAll = FreezePosition | FreezeRotation,
	}
}

```

`AssetRipperCommon/Classes/Rigidbody2D/RigidbodyInterpolation2D.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody2D
{
	public enum RigidbodyInterpolation2D
	{
		/// <summary>
		/// No Interpolation.
		/// </summary>
		None = 0,
		/// <summary>
		/// Interpolation will always lag a little bit behind but can be smoother than extrapolation.
		/// </summary>
		Interpolate = 1,
		/// <summary>
		/// Extrapolation will predict the position of the rigidbody based on the current velocity.
		/// </summary>
		Extrapolate = 2
	}
}

```

`AssetRipperCommon/Classes/Rigidbody2D/RigidbodySleepMode2D.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody2D
{
	public enum RigidbodySleepMode2D
	{
		/// <summary>
		/// Never sleep.
		/// </summary>
		NeverSleep = 0,
		/// <summary>
		/// Start the rigid body awake.
		/// </summary>
		StartAwake = 1,
		/// <summary>
		/// Start the rigid body asleep.
		/// </summary>
		StartAsleep = 2
	}
}

```

`AssetRipperCommon/Classes/Rigidbody2D/RigidbodyType2D.cs`:

```cs
namespace AssetRipper.Core.Classes.Rigidbody2D
{
	public enum RigidbodyType2D
	{
		/// <summary>
		/// Dynamic body.
		/// </summary>
		Dynamic = 0,
		/// <summary>
		/// Kinematic body.
		/// </summary>
		Kinematic = 1,
		/// <summary>
		/// Static body.
		/// </summary>
		Static = 2,
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/GPUPlatform.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums
{
	/// <summary>
	/// Graphic API. Also called ShaderCompilerPlatform<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/Graphics/ShaderCompilerData.cs"/>
	/// </summary>
	public enum GPUPlatform
	{
		/// <summary>
		/// For inner use only
		/// </summary>
		unknown = -1,
		/// <summary>
		/// For non initialized variable.
		/// </summary>
		none = 0,
		openGL = 0,
		d3d9 = 1,
		xbox360 = 2,
		ps3 = 3,
		/// <summary>
		/// Direct3D 11 (FL10.0 and up) and Direct3D 12, compiled with MS D3DCompiler
		/// </summary>
		d3d11 = 4,
		/// <summary>
		/// OpenGL ES 2.0 / WebGL 1.0, compiled with MS D3DCompiler + HLSLcc
		/// </summary>
		gles = 5,
		/// <summary>
		/// OpenGL ES 3.0+ / WebGL 2.0, compiled with MS D3DCompiler + HLSLcc
		/// </summary>
		glesdesktop = 6,
		flash = 7,
		d3d11_9x = 8,
		gles3 = 9,
		psp2 = 10,
		/// <summary>
		/// Sony PS4
		/// </summary>
		ps4 = 11,
		/// <summary>
		/// MS XboxOne
		/// </summary>
		xboxone = 12,
		psm = 13,
		/// <summary>
		/// Apple Metal, compiled with MS D3DCompiler + HLSLcc
		/// </summary>
		metal = 14,
		/// <summary>
		/// Desktop OpenGL 3+, compiled with MS D3DCompiler + HLSLcc
		/// </summary>
		glcore = 15,
		n3ds = 16,
		wiiu = 17,
		/// <summary>
		/// Vulkan SPIR-V, compiled with MS D3DCompiler + HLSLcc
		/// </summary>
		vulkan = 18,
		/// <summary>
		/// Nintendo Switch (NVN)
		/// </summary>
		Switch = 19,
		/// <summary>
		/// Xbox One D3D12
		/// </summary>
		xboxone_d3d12 = 20,
		/// <summary>
		/// Game Core
		/// </summary>
		GameCoreXboxOne = 21,
		GameCoreScarlett = 22,
		/// <summary>
		/// PS5
		/// </summary>
		PS5 = 23,
		/// <summary>
		/// PS5 NGGC
		/// </summary>
		PS5NGGC = 24,
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/GpuProgramType/ShaderGpuProgramType.cs`:

```cs
using AssetRipper.Core.Parser.Files;


namespace AssetRipper.Core.Classes.Shader.Enums.GpuProgramType
{
	public enum ShaderGpuProgramType
	{
		Unknown,
		GLLegacy,
		GLES31AEP,
		GLES31,
		GLES3,
		GLES,
		GLCore32,
		GLCore41,
		GLCore43,
		DX9VertexSM20,
		DX9VertexSM30,
		DX9PixelSM20,
		DX9PixelSM30,
		DX10Level9Vertex,
		DX10Level9Pixel,
		DX11VertexSM40,
		DX11VertexSM50,
		DX11PixelSM40,
		DX11PixelSM50,
		DX11GeometrySM40,
		DX11GeometrySM50,
		DX11HullSM50,
		DX11DomainSM50,
		MetalVS,
		MetalFS,
		SPIRV,

#warning Console is omitted in AssetStudio
		Console,

		ConsoleVS,
		ConsoleFS,
		ConsoleHS,
		ConsoleDS,
		ConsoleGS,
		RayTracing,
	}

	public static class ShaderGpuProgramTypeExtensions
	{
		/// <summary>
		/// 5.5.0 and greater
		/// </summary>
		public static bool GpuProgramType55Relevant(UnityVersion version) => version.IsGreaterEqual(5, 5);

		public static bool IsGL(this ShaderGpuProgramType _this)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.GLLegacy:
				case ShaderGpuProgramType.GLCore32:
				case ShaderGpuProgramType.GLCore41:
				case ShaderGpuProgramType.GLCore43:
				case ShaderGpuProgramType.GLES:
				case ShaderGpuProgramType.GLES3:
				case ShaderGpuProgramType.GLES31:
				case ShaderGpuProgramType.GLES31AEP:
					return true;

				default:
					return false;
			}
		}

		public static bool IsMetal(this ShaderGpuProgramType _this)
		{
			return _this switch
			{
				ShaderGpuProgramType.MetalFS or ShaderGpuProgramType.MetalVS => true,
				_ => false,
			};
		}

		public static bool IsDX(this ShaderGpuProgramType _this)
		{
			switch(_this)
			{
				case ShaderGpuProgramType.DX9PixelSM20:
				case ShaderGpuProgramType.DX9PixelSM30:
				case ShaderGpuProgramType.DX9VertexSM20:
				case ShaderGpuProgramType.DX9VertexSM30:
				case ShaderGpuProgramType.DX10Level9Pixel:
				case ShaderGpuProgramType.DX10Level9Vertex:
				case ShaderGpuProgramType.DX11DomainSM50:
				case ShaderGpuProgramType.DX11GeometrySM40:
				case ShaderGpuProgramType.DX11GeometrySM50:
				case ShaderGpuProgramType.DX11HullSM50:
				case ShaderGpuProgramType.DX11PixelSM40:
				case ShaderGpuProgramType.DX11PixelSM50:
				case ShaderGpuProgramType.DX11VertexSM40:
				case ShaderGpuProgramType.DX11VertexSM50:
					return true;

				default:
					return false;
			}
		}

		public static bool IsDX9(this ShaderGpuProgramType _this)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.DX9PixelSM20:
				case ShaderGpuProgramType.DX9PixelSM30:
				case ShaderGpuProgramType.DX9VertexSM20:
				case ShaderGpuProgramType.DX9VertexSM30:
					return true;

				default:
					return false;
			}
		}

		public static GPUPlatform ToGPUPlatform(this ShaderGpuProgramType _this, BuildTarget platform)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.Unknown:
					return GPUPlatform.unknown;

				case ShaderGpuProgramType.GLES:
					return GPUPlatform.gles;

				case ShaderGpuProgramType.GLES3:
				case ShaderGpuProgramType.GLES31:
				case ShaderGpuProgramType.GLES31AEP:
					return GPUPlatform.gles3;

				case ShaderGpuProgramType.GLCore32:
				case ShaderGpuProgramType.GLCore41:
				case ShaderGpuProgramType.GLCore43:
					return GPUPlatform.glcore;

				case ShaderGpuProgramType.GLLegacy:
					return GPUPlatform.openGL;

				case ShaderGpuProgramType.DX9VertexSM20:
				case ShaderGpuProgramType.DX9VertexSM30:
				case ShaderGpuProgramType.DX9PixelSM20:
				case ShaderGpuProgramType.DX9PixelSM30:
					return GPUPlatform.d3d9;

				case ShaderGpuProgramType.DX10Level9Pixel:
				case ShaderGpuProgramType.DX10Level9Vertex:
					return GPUPlatform.d3d11_9x;

				case ShaderGpuProgramType.DX11VertexSM40:
				case ShaderGpuProgramType.DX11VertexSM50:
				case ShaderGpuProgramType.DX11PixelSM40:
				case ShaderGpuProgramType.DX11PixelSM50:
				case ShaderGpuProgramType.DX11GeometrySM40:
				case ShaderGpuProgramType.DX11GeometrySM50:
				case ShaderGpuProgramType.DX11HullSM50:
				case ShaderGpuProgramType.DX11DomainSM50:
					return GPUPlatform.d3d11;

				case ShaderGpuProgramType.MetalVS:
				case ShaderGpuProgramType.MetalFS:
					return GPUPlatform.metal;

				case ShaderGpuProgramType.SPIRV:
					return GPUPlatform.vulkan;

				case ShaderGpuProgramType.Console:
				case ShaderGpuProgramType.ConsoleVS:
				case ShaderGpuProgramType.ConsoleFS:
				case ShaderGpuProgramType.ConsoleHS:
				case ShaderGpuProgramType.ConsoleDS:
				case ShaderGpuProgramType.ConsoleGS:
					switch (platform)
					{
						case BuildTarget.PS3:
							return GPUPlatform.ps3;
						case BuildTarget.PS4:
							return GPUPlatform.ps4;
						case BuildTarget.PSM:
							return GPUPlatform.psm;
						case BuildTarget.PSP2:
							return GPUPlatform.psp2;

						case BuildTarget.XBox360:
							return GPUPlatform.xbox360;
						case BuildTarget.XboxOne:
							return GPUPlatform.xboxone;
#warning		 TODO:
						//return GPUPlatform.xboxone_d3d12;

						case BuildTarget.WiiU:
							return GPUPlatform.wiiu;

						case BuildTarget.N3DS:
							return GPUPlatform.n3ds;

						case BuildTarget.GoogleNaCl:
							return GPUPlatform.glesdesktop;

						case BuildTarget.Flash:
							return GPUPlatform.flash;

						case BuildTarget.Switch:
							return GPUPlatform.Switch;

						default:
							throw new NotSupportedException($"Unsupported console platform {platform}");
					}

				default:
					throw new NotSupportedException($"Unsupported gpu program type {_this}");
			}
		}

		public static string ToProgramDataKeyword(this ShaderGpuProgramType _this, BuildTarget platform, ShaderType type)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.Unknown:
					return nameof(ShaderGpuProgramType.Unknown);

				case ShaderGpuProgramType.GLES:
					return "!!GLES";
				case ShaderGpuProgramType.GLES3:
				case ShaderGpuProgramType.GLES31:
				case ShaderGpuProgramType.GLES31AEP:
					return "!!GLES3";

				case ShaderGpuProgramType.GLCore32:
					return "!!GL3x";
				case ShaderGpuProgramType.GLCore41:
				case ShaderGpuProgramType.GLCore43:
					return "!!GL4x";

				case ShaderGpuProgramType.GLLegacy:
					{
						// for ver < 5.0
						/*if (type == ShaderType.Vertex)
						{
							return "!!ARBvp1.0";
						}
						else if (type == ShaderType.Fragment)
						{
							return "!!ARBfp1.0";
						}*/
						// but since serialization work only for >= 5.4 always return
						return "!!GLSL"; // v1.20
					}

				case ShaderGpuProgramType.DX9VertexSM20:
					return "vs_2_0";
				case ShaderGpuProgramType.DX9VertexSM30:
					return "vs_3_0";
				case ShaderGpuProgramType.DX9PixelSM20:
					return "ps_2_0";
				case ShaderGpuProgramType.DX9PixelSM30:
					return "ps_3_0";

				case ShaderGpuProgramType.DX10Level9Vertex:
					return "vs_4_0_level_9_1";
				case ShaderGpuProgramType.DX10Level9Pixel:
					return "ps_4_0_level_9_1";

				case ShaderGpuProgramType.DX11VertexSM40:
					return "vs_4_0";
				case ShaderGpuProgramType.DX11VertexSM50:
					return "vs_5_0";
				case ShaderGpuProgramType.DX11PixelSM40:
					return "ps_4_0";
				case ShaderGpuProgramType.DX11PixelSM50:
					return "ps_5_0";
				case ShaderGpuProgramType.DX11GeometrySM40:
					return "gs_4_0";
				case ShaderGpuProgramType.DX11GeometrySM50:
					return "gs_5_0";
				case ShaderGpuProgramType.DX11HullSM50:
					return "hs_5_0";
				case ShaderGpuProgramType.DX11DomainSM50:
					return "ds_5_0";

				case ShaderGpuProgramType.MetalVS:
					return "metal_vs";
				case ShaderGpuProgramType.MetalFS:
					return "metal_fs";

				case ShaderGpuProgramType.SPIRV:
					return "spirv";
			}

			switch (platform)
			{
				case BuildTarget.Flash:
					{
						if (_this == ShaderGpuProgramType.Console)
						{
							switch (type)
							{
								case ShaderType.Vertex:
									return "agal_vs";
								case ShaderType.Fragment:
									return "agal_ps";
							}
						}
					}
					break;

				case BuildTarget.PS4:
					{
						switch (_this)
						{
							case ShaderGpuProgramType.Console:
								{
									switch (type)
									{
										case ShaderType.Vertex:
											return "pssl_vs";
										case ShaderType.Fragment:
											return "pssl_ps";
										case ShaderType.Geometry:
											return "pssl_gs";
									}
								}
								break;

							case ShaderGpuProgramType.ConsoleVS:
								return "pssl_vs";
							case ShaderGpuProgramType.ConsoleFS:
								return "pssl_ps";
							case ShaderGpuProgramType.ConsoleGS:
								return "pssl_gs";
						}
					}
					break;

				case BuildTarget.Switch:
					{
						if (_this == ShaderGpuProgramType.Console)
						{
							switch (type)
							{
								case ShaderType.Vertex:
									return "nssl_vs";
								case ShaderType.Fragment:
									return "nssl_ps";
								case ShaderType.Geometry:
									return "nssl_gs";
								case ShaderType.Hull:
									return "nssl_hs";
							}
						}
					}
					break;
			}

			throw new NotSupportedException($"Unsupported gpu program type {_this} [{platform}, {type}]");
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/GpuProgramType/ShaderGpuProgramType53.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.GpuProgramType
{
	public enum ShaderGpuProgramType53
	{
		Unknown = 0,
		GLLegacy = 1,
		GLES31AEP = 2,
		GLES31 = 3,
		GLES3 = 4,
		GLES = 5,
		GLCore32 = 6,
		GLCore41 = 7,
		GLCore43 = 8,
		DX9VertexSM20 = 9,
		DX9VertexSM30 = 10,
		DX9PixelSM20 = 11,
		DX9PixelSM30 = 12,
		DX10Level9Vertex = 13,
		DX10Level9Pixel = 14,
		DX11VertexSM40 = 15,
		DX11VertexSM50 = 16,
		DX11PixelSM40 = 17,
		DX11PixelSM50 = 18,
		DX11GeometrySM40 = 19,
		DX11GeometrySM50 = 20,
		DX11HullSM50 = 21,
		DX11DomainSM50 = 22,
		MetalVS = 23,
		MetalFS = 24,
		ConsoleVS = 25,
		ConsoleFS = 26,
		ConsoleHS = 27,
		ConsoleDS = 28,
		ConsoleGS = 29,
	}

	public static class ShaderGpuProgramType53Extensions
	{
		public static ShaderGpuProgramType ToGpuProgramType(this ShaderGpuProgramType53 _this)
		{
			return _this switch
			{
				ShaderGpuProgramType53.Unknown => ShaderGpuProgramType.Unknown,
				ShaderGpuProgramType53.GLLegacy => ShaderGpuProgramType.GLLegacy,
				ShaderGpuProgramType53.GLES31AEP => ShaderGpuProgramType.GLES31AEP,
				ShaderGpuProgramType53.GLES31 => ShaderGpuProgramType.GLES31,
				ShaderGpuProgramType53.GLES3 => ShaderGpuProgramType.GLES3,
				ShaderGpuProgramType53.GLES => ShaderGpuProgramType.GLES,
				ShaderGpuProgramType53.GLCore32 => ShaderGpuProgramType.GLCore32,
				ShaderGpuProgramType53.GLCore41 => ShaderGpuProgramType.GLCore41,
				ShaderGpuProgramType53.GLCore43 => ShaderGpuProgramType.GLCore43,
				ShaderGpuProgramType53.DX9VertexSM20 => ShaderGpuProgramType.DX9VertexSM20,
				ShaderGpuProgramType53.DX9VertexSM30 => ShaderGpuProgramType.DX9VertexSM30,
				ShaderGpuProgramType53.DX9PixelSM20 => ShaderGpuProgramType.DX9PixelSM20,
				ShaderGpuProgramType53.DX9PixelSM30 => ShaderGpuProgramType.DX9PixelSM30,
				ShaderGpuProgramType53.DX10Level9Vertex => ShaderGpuProgramType.DX10Level9Vertex,
				ShaderGpuProgramType53.DX10Level9Pixel => ShaderGpuProgramType.DX10Level9Pixel,
				ShaderGpuProgramType53.DX11VertexSM40 => ShaderGpuProgramType.DX11VertexSM40,
				ShaderGpuProgramType53.DX11VertexSM50 => ShaderGpuProgramType.DX11VertexSM50,
				ShaderGpuProgramType53.DX11PixelSM40 => ShaderGpuProgramType.DX11PixelSM40,
				ShaderGpuProgramType53.DX11PixelSM50 => ShaderGpuProgramType.DX11PixelSM50,
				ShaderGpuProgramType53.DX11GeometrySM40 => ShaderGpuProgramType.DX11GeometrySM40,
				ShaderGpuProgramType53.DX11GeometrySM50 => ShaderGpuProgramType.DX11GeometrySM50,
				ShaderGpuProgramType53.DX11HullSM50 => ShaderGpuProgramType.DX11HullSM50,
				ShaderGpuProgramType53.DX11DomainSM50 => ShaderGpuProgramType.DX11DomainSM50,
				ShaderGpuProgramType53.MetalVS => ShaderGpuProgramType.MetalVS,
				ShaderGpuProgramType53.MetalFS => ShaderGpuProgramType.MetalFS,
				ShaderGpuProgramType53.ConsoleVS => ShaderGpuProgramType.ConsoleVS,
				ShaderGpuProgramType53.ConsoleFS => ShaderGpuProgramType.ConsoleFS,
				ShaderGpuProgramType53.ConsoleHS => ShaderGpuProgramType.ConsoleHS,
				ShaderGpuProgramType53.ConsoleDS => ShaderGpuProgramType.ConsoleDS,
				ShaderGpuProgramType53.ConsoleGS => ShaderGpuProgramType.ConsoleGS,
				_ => throw new Exception($"Unsupported gpu program type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/GpuProgramType/ShaderGpuProgramType55.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.GpuProgramType
{
	public enum ShaderGpuProgramType55
	{
		Unknown = 0,
		GLLegacy = 1,
		GLES31AEP = 2,
		GLES31 = 3,
		GLES3 = 4,
		GLES = 5,
		GLCore32 = 6,
		GLCore41 = 7,
		GLCore43 = 8,
		DX9VertexSM20 = 9,
		DX9VertexSM30 = 10,
		DX9PixelSM20 = 11,
		DX9PixelSM30 = 12,
		DX10Level9Vertex = 13,
		DX10Level9Pixel = 14,
		DX11VertexSM40 = 15,
		DX11VertexSM50 = 16,
		DX11PixelSM40 = 17,
		DX11PixelSM50 = 18,
		DX11GeometrySM40 = 19,
		DX11GeometrySM50 = 20,
		DX11HullSM50 = 21,
		DX11DomainSM50 = 22,
		MetalVS = 23,
		MetalFS = 24,
		SPIRV = 25,
		Console = 26,
		//ConsoleVS			= 26,
		ConsoleFS = 27,
		ConsoleHS = 28,
		ConsoleDS = 29,
		ConsoleGS = 30,
		RayTracing = 31,
	}

	public static class ShaderGpuProgramType55Extensions
	{
		public static ShaderGpuProgramType ToGpuProgramType(this ShaderGpuProgramType55 _this)
		{
			return _this switch
			{
				ShaderGpuProgramType55.Unknown => ShaderGpuProgramType.Unknown,
				ShaderGpuProgramType55.GLLegacy => ShaderGpuProgramType.GLLegacy,
				ShaderGpuProgramType55.GLES31AEP => ShaderGpuProgramType.GLES31AEP,
				ShaderGpuProgramType55.GLES31 => ShaderGpuProgramType.GLES31,
				ShaderGpuProgramType55.GLES3 => ShaderGpuProgramType.GLES3,
				ShaderGpuProgramType55.GLES => ShaderGpuProgramType.GLES,
				ShaderGpuProgramType55.GLCore32 => ShaderGpuProgramType.GLCore32,
				ShaderGpuProgramType55.GLCore41 => ShaderGpuProgramType.GLCore41,
				ShaderGpuProgramType55.GLCore43 => ShaderGpuProgramType.GLCore43,
				ShaderGpuProgramType55.DX9VertexSM20 => ShaderGpuProgramType.DX9VertexSM20,
				ShaderGpuProgramType55.DX9VertexSM30 => ShaderGpuProgramType.DX9VertexSM30,
				ShaderGpuProgramType55.DX9PixelSM20 => ShaderGpuProgramType.DX9PixelSM20,
				ShaderGpuProgramType55.DX9PixelSM30 => ShaderGpuProgramType.DX9PixelSM30,
				ShaderGpuProgramType55.DX10Level9Vertex => ShaderGpuProgramType.DX10Level9Vertex,
				ShaderGpuProgramType55.DX10Level9Pixel => ShaderGpuProgramType.DX10Level9Pixel,
				ShaderGpuProgramType55.DX11VertexSM40 => ShaderGpuProgramType.DX11VertexSM40,
				ShaderGpuProgramType55.DX11VertexSM50 => ShaderGpuProgramType.DX11VertexSM50,
				ShaderGpuProgramType55.DX11PixelSM40 => ShaderGpuProgramType.DX11PixelSM40,
				ShaderGpuProgramType55.DX11PixelSM50 => ShaderGpuProgramType.DX11PixelSM50,
				ShaderGpuProgramType55.DX11GeometrySM40 => ShaderGpuProgramType.DX11GeometrySM40,
				ShaderGpuProgramType55.DX11GeometrySM50 => ShaderGpuProgramType.DX11GeometrySM50,
				ShaderGpuProgramType55.DX11HullSM50 => ShaderGpuProgramType.DX11HullSM50,
				ShaderGpuProgramType55.DX11DomainSM50 => ShaderGpuProgramType.DX11DomainSM50,
				ShaderGpuProgramType55.MetalVS => ShaderGpuProgramType.MetalVS,
				ShaderGpuProgramType55.MetalFS => ShaderGpuProgramType.MetalFS,
				ShaderGpuProgramType55.SPIRV => ShaderGpuProgramType.SPIRV,
				ShaderGpuProgramType55.Console => ShaderGpuProgramType.Console,
				ShaderGpuProgramType55.ConsoleFS => ShaderGpuProgramType.Console,
				ShaderGpuProgramType55.ConsoleHS => ShaderGpuProgramType.Console,
				ShaderGpuProgramType55.ConsoleDS => ShaderGpuProgramType.Console,
				ShaderGpuProgramType55.ConsoleGS => ShaderGpuProgramType.Console,
				ShaderGpuProgramType55.RayTracing => ShaderGpuProgramType.RayTracing,
				_ => throw new Exception($"Unsupported gpu program type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderChannel/ShaderChannel.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;


namespace AssetRipper.Core.Classes.Shader.Enums.ShaderChannel
{
	/// <summary>
	/// Changed several times. Also called VertexAttribute<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShaderChannel
	{
		/// <summary>
		/// Also called Position
		/// </summary>
		Vertex,
		Normal,
		Tangent,
		/// <summary>
		/// Vertex Color
		/// </summary>
		Color,
		UV0,
		UV1,
		UV2,
		UV3,
		UV4,
		UV5,
		UV6,
		UV7,
		/// <summary>
		/// Also called BlendWeight
		/// </summary>
		SkinWeight,
		/// <summary>
		/// Also called BlendIndices
		/// </summary>
		SkinBoneIndex,
	}

	public static class ShaderChannelExtensions
	{
		/// <summary>
		/// 2018.1 and greater
		/// </summary>
		public static bool ShaderChannel2018Relevant(UnityVersion version) => version.IsGreaterEqual(2018);
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool ShaderChannel5Relevant(UnityVersion version) => version.IsGreaterEqual(5);

		public static int GetChannelCount(UnityVersion version)
		{
			if (ShaderChannel2018Relevant(version))
			{
				return 14;
			}
			else if (ShaderChannel5Relevant(version))
			{
				return 8;
			}
			else
			{
				return 6;
			}
		}

		public static VertexFormat.VertexFormat GetVertexFormat(this ShaderChannel _this, UnityVersion version)
		{
			switch (_this)
			{
				case ShaderChannel.Vertex:
					return VertexFormat.VertexFormat.Float;
				case ShaderChannel.Normal:
					return VertexFormat.VertexFormat.Float;
				case ShaderChannel.Tangent:
					return VertexFormat.VertexFormat.Float;
				case ShaderChannel.Color:
					return VertexFormatExtensions.VertexFormat2019Relevant(version) ? VertexFormat.VertexFormat.Byte : VertexFormat.VertexFormat.Color;

				case ShaderChannel.UV0:
				case ShaderChannel.UV1:
				case ShaderChannel.UV2:
				case ShaderChannel.UV3:
				case ShaderChannel.UV4:
				case ShaderChannel.UV5:
				case ShaderChannel.UV6:
				case ShaderChannel.UV7:
					return VertexFormat.VertexFormat.Float;

				case ShaderChannel.SkinWeight:
					return VertexFormat.VertexFormat.Float;
				case ShaderChannel.SkinBoneIndex:
					return VertexFormat.VertexFormat.Int;

				default:
					throw new Exception($"Unsupported channel type {_this}");
			}
		}

		public static byte GetDimention(this ShaderChannel _this, UnityVersion version)
		{
			switch (_this)
			{
				case ShaderChannel.Vertex:
					return 3;
				case ShaderChannel.Normal:
					return 3;
				case ShaderChannel.Tangent:
					return 4;
				case ShaderChannel.Color:
					return ShaderChannel5Relevant(version) ? (byte)4 : (byte)1;

				case ShaderChannel.UV0:
				case ShaderChannel.UV1:
				case ShaderChannel.UV2:
				case ShaderChannel.UV3:
				case ShaderChannel.UV4:
				case ShaderChannel.UV5:
				case ShaderChannel.UV6:
				case ShaderChannel.UV7:
					return 2;

				case ShaderChannel.SkinWeight:
				case ShaderChannel.SkinBoneIndex:
					throw new Exception($"Skin's dimention is varying");

				default:
					throw new Exception($"Unsupported channel type {_this}");
			}
		}

		public static byte GetStride(this ShaderChannel _this, UnityVersion version)
		{
			VertexFormat.VertexFormat format = _this.GetVertexFormat(version);
			int dimention = _this.GetDimention(version);
			return format.CalculateStride(version, dimention);
		}

		public static bool HasChannel(this ShaderChannel _this, UnityVersion version)
		{
			if (ShaderChannel2018Relevant(version))
			{
				return true;
			}
			else if (ShaderChannel5Relevant(version))
			{
				return _this <= ShaderChannel.UV3;
			}
			else
			{
				return _this <= ShaderChannel.UV1;
			}
		}

		public static int ToChannel(this ShaderChannel _this, UnityVersion version)
		{
			if (ShaderChannel2018Relevant(version))
			{
				return (int)ToShaderChannel2018(_this);
			}
			else if (ShaderChannel5Relevant(version))
			{
				return (int)ToShaderChannel5(_this);
			}
			else
			{
				return (int)ToShaderChannel4(_this);
			}
		}

		public static ShaderChannel4 ToShaderChannel4(this ShaderChannel _this)
		{
			return _this switch
			{
				ShaderChannel.Vertex => ShaderChannel4.Vertex,
				ShaderChannel.Normal => ShaderChannel4.Normal,
				ShaderChannel.Color => ShaderChannel4.Color,
				ShaderChannel.UV0 => ShaderChannel4.UV0,
				ShaderChannel.UV1 => ShaderChannel4.UV1,
				ShaderChannel.Tangent => ShaderChannel4.Tangent,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}

		public static ShaderChannel5 ToShaderChannel5(this ShaderChannel _this)
		{
			return _this switch
			{
				ShaderChannel.Vertex => ShaderChannel5.Vertex,
				ShaderChannel.Normal => ShaderChannel5.Normal,
				ShaderChannel.Color => ShaderChannel5.Color,
				ShaderChannel.UV0 => ShaderChannel5.UV0,
				ShaderChannel.UV1 => ShaderChannel5.UV1,
				ShaderChannel.UV2 => ShaderChannel5.UV2,
				ShaderChannel.UV3 => ShaderChannel5.UV3,
				ShaderChannel.Tangent => ShaderChannel5.Tangent,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}

		public static ShaderChannel2018 ToShaderChannel2018(this ShaderChannel _this)
		{
			return _this switch
			{
				ShaderChannel.Vertex => ShaderChannel2018.Vertex,
				ShaderChannel.Normal => ShaderChannel2018.Normal,
				ShaderChannel.Tangent => ShaderChannel2018.Tangent,
				ShaderChannel.Color => ShaderChannel2018.Color,
				ShaderChannel.UV0 => ShaderChannel2018.UV0,
				ShaderChannel.UV1 => ShaderChannel2018.UV1,
				ShaderChannel.UV2 => ShaderChannel2018.UV2,
				ShaderChannel.UV3 => ShaderChannel2018.UV3,
				ShaderChannel.UV4 => ShaderChannel2018.UV4,
				ShaderChannel.UV5 => ShaderChannel2018.UV5,
				ShaderChannel.UV6 => ShaderChannel2018.UV6,
				ShaderChannel.UV7 => ShaderChannel2018.UV7,
				ShaderChannel.SkinWeight => ShaderChannel2018.SkinWeight,
				ShaderChannel.SkinBoneIndex => ShaderChannel2018.SkinBoneIndex,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderChannel/ShaderChannel2018.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.ShaderChannel
{
	/// <summary>
	/// 2018.1 and greater version
	/// </summary>
	public enum ShaderChannel2018
	{
		Vertex = 0,
		Normal = 1,
		Tangent = 2,
		Color = 3,
		UV0 = 4,
		UV1 = 5,
		UV2 = 6,
		UV3 = 7,
		UV4 = 8,
		UV5 = 9,
		UV6 = 10,
		UV7 = 11,
		SkinWeight = 12,
		SkinBoneIndex = 13,
	}

	public static class ShaderChannelV2018Extensions
	{
		public static ShaderChannel ToShaderChannel(this ShaderChannel2018 _this)
		{
			return _this switch
			{
				ShaderChannel2018.Vertex => ShaderChannel.Vertex,
				ShaderChannel2018.Normal => ShaderChannel.Normal,
				ShaderChannel2018.Tangent => ShaderChannel.Tangent,
				ShaderChannel2018.Color => ShaderChannel.Color,
				ShaderChannel2018.UV0 => ShaderChannel.UV0,
				ShaderChannel2018.UV1 => ShaderChannel.UV1,
				ShaderChannel2018.UV2 => ShaderChannel.UV2,
				ShaderChannel2018.UV3 => ShaderChannel.UV3,
				ShaderChannel2018.UV4 => ShaderChannel.UV4,
				ShaderChannel2018.UV5 => ShaderChannel.UV5,
				ShaderChannel2018.UV6 => ShaderChannel.UV6,
				ShaderChannel2018.UV7 => ShaderChannel.UV7,
				ShaderChannel2018.SkinWeight => ShaderChannel.SkinWeight,
				ShaderChannel2018.SkinBoneIndex => ShaderChannel.SkinBoneIndex,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderChannel/ShaderChannel4.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.ShaderChannel
{
	/// <summary>
	/// Less than 5.0.0 version
	/// </summary>
	public enum ShaderChannel4
	{
		Vertex = 0,
		Normal = 1,
		Color = 2,
		UV0 = 3,
		UV1 = 4,
		Tangent = 5,
	}

	public static class ShaderChannelV4Extensions
	{
		public static ShaderChannel ToShaderChannel(this ShaderChannel4 _this)
		{
			return _this switch
			{
				ShaderChannel4.Vertex => ShaderChannel.Vertex,
				ShaderChannel4.Normal => ShaderChannel.Normal,
				ShaderChannel4.Color => ShaderChannel.Color,
				ShaderChannel4.UV0 => ShaderChannel.UV0,
				ShaderChannel4.UV1 => ShaderChannel.UV1,
				ShaderChannel4.Tangent => ShaderChannel.Tangent,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderChannel/ShaderChannel5.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.ShaderChannel
{
	/// <summary>
	/// 5.0.0 to 2017.x versions
	/// </summary>
	public enum ShaderChannel5
	{
		Vertex = 0,
		Normal = 1,
		Color = 2,
		UV0 = 3,
		UV1 = 4,
		UV2 = 5,
		UV3 = 6,
		Tangent = 7,
	}

	public static class ShaderChannelV5Extensions
	{
		public static ShaderChannel ToShaderChannel(this ShaderChannel5 _this)
		{
			return _this switch
			{
				ShaderChannel5.Vertex => ShaderChannel.Vertex,
				ShaderChannel5.Normal => ShaderChannel.Normal,
				ShaderChannel5.Color => ShaderChannel.Color,
				ShaderChannel5.UV0 => ShaderChannel.UV0,
				ShaderChannel5.UV1 => ShaderChannel.UV1,
				ShaderChannel5.UV2 => ShaderChannel.UV2,
				ShaderChannel5.UV3 => ShaderChannel.UV3,
				ShaderChannel5.Tangent => ShaderChannel.Tangent,
				_ => throw new Exception($"Unsupported channel type {_this}"),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderParamType.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ShaderParamType
	{
		Float = 0x0,
		Int = 0x1,
		Bool = 0x2,
		Half = 0x3,
		Short = 0x4,
		UInt = 0x5,
		TypeCount = 0x6,
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/ShaderType.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums
{
	public enum ShaderType
	{
		None = 0,
		Vertex = 1,
		Fragment = 2,
		Geometry = 3,
		Hull = 4,
		Domain = 5,
		/// <summary>
		/// 2019.3 and greater
		/// </summary>
		RayTracing = 6,

		TypeCount,
	}

	public static class ShaderTypeExtensions
	{
		public static string ToProgramTypeString(this ShaderType _this)
		{
			return _this switch
			{
				ShaderType.Vertex => "vp",
				ShaderType.Fragment => "fp",
				ShaderType.Geometry => "gp",
				ShaderType.Hull => "hp",
				ShaderType.Domain => "dp",
				ShaderType.RayTracing => "rtp",
				_ => throw new NotSupportedException($"ShaderType {_this} isn't supported"),
			};
		}

		public static int ToProgramMask(this ShaderType _this)
		{
			return 1 << (int)_this;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/VertexComponent.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums
{
	public enum VertexComponent : uint
	{
		None = 0xFFFFFFFF,
		Vertex = 0x0,
		Color = 0x1,
		Normal = 0x2,
		TexCoord = 0x3,
		TexCoord0 = 0x4,
		TexCoord1 = 0x5,
		TexCoord2 = 0x6,
		TexCoord3 = 0x7,
		TexCoord4 = 0x8,
		TexCoord5 = 0x9,
		TexCoord6 = 0xA,
		TexCoord7 = 0xB,
		Attrib0 = 0xC,
		Attrib1 = 0xD,
		Attrib2 = 0xE,
		Attrib3 = 0xF,
		Attrib4 = 0x10,
		Attrib5 = 0x11,
		Attrib6 = 0x12,
		Attrib7 = 0x13,
		Attrib8 = 0x14,
		Attrib9 = 0x15,
		Attrib10 = 0x16,
		Attrib11 = 0x17,
		Attrib12 = 0x18,
		Attrib13 = 0x19,
		Attrib14 = 0x1A,
		Attrib15 = 0x1B,
		Count = 0x1C,
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/VertexFormat/VertexChannelFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.VertexFormat
{
	/// <summary>
	/// Less than 2017.1
	/// </summary>
	public enum VertexChannelFormat : byte
	{
		Float = 0,
		Float16 = 1,
		Color = 2,
		Byte = 3,
		UInt = 4,
	}

	public static class VertexChannelFormatV4Extension
	{
		public static VertexFormat ToVertexFormat(this VertexChannelFormat _this)
		{
			return _this switch
			{
				VertexChannelFormat.Float => VertexFormat.Float,
				VertexChannelFormat.Float16 => VertexFormat.Float16,
				VertexChannelFormat.Color => VertexFormat.Color,
				_ => throw new Exception(_this.ToString()),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/VertexFormat/VertexFormat.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;


namespace AssetRipper.Core.Classes.Shader.Enums.VertexFormat
{
	/// <summary>
	/// Also called VertexAttributeFormat<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum VertexFormat
	{
		Float,
		Float16,
		Color,
		Byte,
		Int,
	}

	public static class VertexFormatExtensions
	{
		/// <summary>
		/// 2019.1 and greater
		/// </summary>
		public static bool VertexFormat2019Relevant(UnityVersion version) => version.IsGreaterEqual(2019);
		/// <summary>
		/// 2017.1 and greater
		/// </summary>
		public static bool VertexFormat2017Relevant(UnityVersion version) => version.IsGreaterEqual(2017);

		public static byte CalculateStride(this VertexFormat _this, UnityVersion version, int dimention)
		{
			return (byte)(_this.GetSize(version) * dimention);
		}

		public static int GetSize(this VertexFormat _this, UnityVersion version)
		{
			return _this switch
			{
				VertexFormat.Float => 4,
				VertexFormat.Float16 => 2,
				VertexFormat.Color => ShaderChannelExtensions.ShaderChannel5Relevant(version) ? 1 : 4,
				VertexFormat.Byte => 1,
				VertexFormat.Int => 4,
				_ => throw new Exception(_this.ToString()),
			};
		}

		public static byte ToFormat(this VertexFormat _this, UnityVersion version)
		{
			if (VertexFormat2019Relevant(version))
			{
				return (byte)_this.ToVertexFormat2019();
			}
			else if (VertexFormat2017Relevant(version))
			{
				return (byte)_this.ToVertexFormat2017();
			}
			else
			{
				return (byte)_this.ToVertexChannelFormat();
			}
		}

		public static VertexChannelFormat ToVertexChannelFormat(this VertexFormat _this)
		{
			return _this switch
			{
				VertexFormat.Float => VertexChannelFormat.Float,
				VertexFormat.Float16 => VertexChannelFormat.Float16,
				VertexFormat.Color => VertexChannelFormat.Color,
				_ => throw new Exception(_this.ToString()),
			};
		}

		public static VertexFormat2017 ToVertexFormat2017(this VertexFormat _this)
		{
			return _this switch
			{
				VertexFormat.Float => VertexFormat2017.Float,
				VertexFormat.Float16 => VertexFormat2017.Float16,
				VertexFormat.Color => VertexFormat2017.Color,
				VertexFormat.Byte => VertexFormat2017.UInt8,
				VertexFormat.Int => VertexFormat2017.UInt32,
				_ => throw new Exception(_this.ToString()),
			};
		}

		public static VertexFormat2019 ToVertexFormat2019(this VertexFormat _this)
		{
			return _this switch
			{
				VertexFormat.Float => VertexFormat2019.Float,
				VertexFormat.Float16 => VertexFormat2019.Float16,
				VertexFormat.Color or VertexFormat.Byte => VertexFormat2019.UNorm8,
				VertexFormat.Int => VertexFormat2019.UInt32,
				_ => throw new Exception(_this.ToString()),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/VertexFormat/VertexFormat2017.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.VertexFormat
{
	/// <summary>
	/// 2017.1 to 2018.x.x
	/// </summary>
	public enum VertexFormat2017 : byte
	{
		Float = 0,
		Float16 = 1,
		Color = 2,
		UNorm8 = 3,
		SNorm8 = 4,
		UNorm16 = 5,
		SNorm16 = 6,
		UInt8 = 7,
		SInt8 = 8,
		UInt16 = 9,
		SInt16 = 10,
		UInt32 = 11,
		SInt32 = 12,
	}

	public static class VertexFormatV5Extension
	{
		public static VertexFormat ToVertexFormat(this VertexFormat2017 _this)
		{
			return _this switch
			{
				VertexFormat2017.Float => VertexFormat.Float,
				VertexFormat2017.Float16 => VertexFormat.Float16,
				VertexFormat2017.Color => VertexFormat.Color,
				VertexFormat2017.UNorm8 => VertexFormat.Byte,
				VertexFormat2017.UInt32 => VertexFormat.Int,
				_ => throw new Exception(_this.ToString()),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/Enums/VertexFormat/VertexFormat2019.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.Enums.VertexFormat
{
	/// <summary>
	/// 2019.1 and greater
	/// </summary>
	public enum VertexFormat2019 : byte
	{
		Float = 0,
		Float16 = 1,
		UNorm8 = 2,
		SNorm8 = 3,
		UNorm16 = 4,
		SNorm16 = 5,
		UInt8 = 6,
		SInt8 = 7,
		UInt16 = 8,
		SInt16 = 9,
		UInt32 = 10,
		SInt32 = 11,
	}

	public static class VertexFormat2019Extension
	{
		public static VertexFormat ToVertexFormat(this VertexFormat2019 _this)
		{
			return _this switch
			{
				VertexFormat2019.Float => VertexFormat.Float,
				VertexFormat2019.Float16 => VertexFormat.Float16,
				VertexFormat2019.UNorm8 => VertexFormat.Byte,
				VertexFormat2019.UInt32 => VertexFormat.Int,
				_ => throw new Exception(_this.ToString()),
			};
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/BlendMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum BlendMode
	{
		Zero = 0,
		One = 1,
		DstColor = 2,
		SrcColor = 3,
		OneMinusDstColor = 4,
		SrcAlpha = 5,
		OneMinusSrcColor = 6,
		DstAlpha = 7,
		OneMinusDstAlpha = 8,
		SrcAlphaSaturate = 9,
		OneMinusSrcAlpha = 10,
		Count,
	}

	public static class BlendFactorExtensions
	{
		public static bool IsZero(this BlendMode _this)
		{
			return _this == BlendMode.Zero;
		}

		public static bool IsOne(this BlendMode _this)
		{
			return _this == BlendMode.One;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/BlendOp.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum BlendOp
	{
		Add = 0,
		Sub = 1,
		RevSub = 2,
		Min = 3,
		Max = 4,
		LogicalClear = 5,
		LogicalSet = 6,
		LogicalCopy = 7,
		LogicalCopyInverted = 8,
		LogicalNoop = 9,
		LogicalInvert = 10,
		LogicalAnd = 11,
		LogicalNand = 12,
		LogicalOr = 13,
		LogicalNor = 14,
		LogicalXor = 15,
		LogicalEquivalence = 16,
		LogicalAndReverse = 17,
		LogicalAndInverted = 18,
		LogicalOrReverse = 19,
		LogicalOrInverted = 20,
		Multiply = 21,
		Screen = 22,
		Overlay = 23,
		Darken = 24,
		Lighten = 25,
		ColorDodge = 26,
		ColorBurn = 27,
		HardLight = 28,
		SoftLight = 29,
		Difference = 30,
		Exclusion = 31,
		HSLHue = 32,
		HSLSaturation = 33,
		HSLColor = 34,
		HSLLuminosity = 35,
		Count,
	}

	public static class BlendOpExtensions
	{
		public static bool IsAdd(this BlendOp _this)
		{
			return _this == BlendOp.Add;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/ColorWriteMask.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	[Flags]
	public enum ColorWriteMask
	{
		None = 0x0,
		Alpha = 0x1,
		Red = 0x2,
		Green = 0x4,
		Blue = 0x8,

		All = Red | Green | Blue | Alpha, // 15
	}

	public static class ColorMaskExtensions
	{
		public static bool IsNone(this ColorWriteMask _this)
		{
			return _this == ColorWriteMask.None;
		}

		public static bool IsRed(this ColorWriteMask _this)
		{
			return (_this & ColorWriteMask.Red) != 0;
		}

		public static bool IsGreen(this ColorWriteMask _this)
		{
			return (_this & ColorWriteMask.Green) != 0;
		}

		public static bool IsBlue(this ColorWriteMask _this)
		{
			return (_this & ColorWriteMask.Blue) != 0;
		}

		public static bool IsAlpha(this ColorWriteMask _this)
		{
			return (_this & ColorWriteMask.Alpha) != 0;
		}

		public static bool IsRBGA(this ColorWriteMask _this)
		{
			return _this == ColorWriteMask.All;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/CullMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum CullMode
	{
		Off = 0,
		Front = 1,
		Back = 2,
		Count,

		Unknown = -1,
	}

	public static class CullExtensions
	{
		public static bool IsOff(this CullMode _this)
		{
			return _this == CullMode.Off;
		}

		public static bool IsFront(this CullMode _this)
		{
			return _this == CullMode.Front;
		}

		public static bool IsBack(this CullMode _this)
		{
			return _this == CullMode.Back;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/FogMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// Duplicate of RenderSettings FogMode<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum FogMode
	{
		Off = 0,
		Linear = 1,
		Exp = 2,
		Exp2 = 3,
		Count,

		Unknown = -1,
	}

	public static class FogModeExtensions
	{
		public static bool IsUnknown(this FogMode _this)
		{
			return _this == FogMode.Unknown;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/SerializedPassType.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum SerializedPassType
	{
		Pass = 0,
		UsePass = 1,
		GrabPass = 2,
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/SerializedPropertyFlag.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Shaders/ShaderProperties.cs"/>
	/// </summary>
	[Flags]
	public enum SerializedPropertyFlag : uint
	{
		None = 0,
		HideInInspector = 1 << 0,
		PerRendererData = 1 << 1,
		NoScaleOffset = 1 << 2,
		Normal = 1 << 3,
		HDR = 1 << 4,
		Gamma = 1 << 5,
		NonModifiableTextureData = 1 << 6,
		MainTexture = 1 << 7,
		MainColor = 1 << 8,
	}

	public static class SerializedPropertyFlagExtensions
	{
		public static bool IsHideInInspector(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.HideInInspector) != 0;
		}

		public static bool IsPerRendererData(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.PerRendererData) != 0;
		}

		public static bool IsNoScaleOffset(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.NoScaleOffset) != 0;
		}

		public static bool IsNormal(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.Normal) != 0;
		}

		public static bool IsHDR(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.HDR) != 0;
		}

		public static bool IsGamma(this SerializedPropertyFlag _this)
		{
			return (_this & SerializedPropertyFlag.Gamma) != 0;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/SerializedPropertyType.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Shaders/ShaderProperties.cs"/>
	/// </summary>
	public enum SerializedPropertyType
	{
		Color = 0,
		Vector = 1,
		Int = 2,
		Float = 2,
		Range = 3,
		_2D = 4,
		_2DArray = 4,
		_3D = 4,
		Cube = 4,
		CubeArray = 4,
	}

	public static class SerializedPropertyTypeExtensions
	{
		public static bool IsTexture(this SerializedPropertyType _this)
		{
			return _this == SerializedPropertyType._2D || _this == SerializedPropertyType._3D || _this == SerializedPropertyType.Cube;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/StencilComp.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum StencilComp
	{
		Disabled = 0,
		Never = 1,
		Less = 2,
		Equal = 3,
		LEqual = 4,
		Greater = 5,
		NotEqual = 6,
		GEqual = 7,
		Always = 8,
		Count,

		Unknown = -1,
	}

	public static class StencilCompExtensions
	{
		public static bool IsAlways(this StencilComp _this)
		{
			return _this == StencilComp.Always;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/StencilOp.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum StencilOp
	{
		Keep = 0,
		Zero = 1,
		Replace = 2,
		IncrementSaturate = 3,
		DecrementSaturate = 4,
		Invert = 5,
		IncrementWrap = 6,
		DecrementWrap = 7,
		Count,
	}

	public static class StencilOpExtensions
	{
		public static bool IsKeep(this StencilOp _this)
		{
			return _this == StencilOp.Keep;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/StencilType.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum StencilType
	{
		Base,
		Front,
		Back,
	}

	public static class StencilTypeExtensions
	{
		public static string ToSuffixString(this StencilType _this)
		{
			if (_this == StencilType.Base)
			{
				return string.Empty;
			}
			return _this.ToString();
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/ZClip.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum ZClip
	{
		Off = 0,
		On = 1,
	}

	public static class ZClipExtensions
	{
		public static bool IsOn(this ZClip _this)
		{
			return _this == ZClip.On;
		}

		public static bool IsOff(this ZClip _this)
		{
			return _this == ZClip.Off;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/ZTest.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum ZTest
	{
		None = 0,
		Unknown = 1,
		Less = 2,
		Equal = 3,
		LEqual = 4,
		Greater = 5,
		NotEqual = 6,
		GEqual = 7,
		Always = 8,
	}

	public static class ZTestExtensions
	{
		public static bool IsNone(this ZTest _this)
		{
			return _this == ZTest.None;
		}
		public static bool IsLEqual(this ZTest _this)
		{
			return _this == ZTest.LEqual;
		}
	}
}

```

`AssetRipperCommon/Classes/Shader/SerializedShader/Enum/ZWrite.cs`:

```cs
namespace AssetRipper.Core.Classes.Shader.SerializedShader.Enum
{
	public enum ZWrite
	{
		Off = 0,
		On = 1,
	}

	public static class ZWriteExtensions
	{
		public static bool IsOff(this ZWrite _this)
		{
			return _this == ZWrite.Off;
		}

		public static bool IsOn(this ZWrite _this)
		{
			return _this == ZWrite.On;
		}
	}
}

```

`AssetRipperCommon/Classes/ShaderVariantCollection/PassType.cs`:

```cs

namespace AssetRipper.Core.Classes.ShaderVariantCollection
{
	/// <summary>
	/// Shader pass type for Unity's lighting pipeline.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum PassType
	{
		/// <summary>
		/// Regular shader pass that does not interact with lighting.
		/// </summary>
		Normal = 0,
		/// <summary>
		/// Legacy vertex-lit shader pass.
		/// </summary>
		Vertex = 1,
		/// <summary>
		/// Legacy vertex-lit shader pass, with mobile lightmaps.
		/// </summary>
		VertexLM = 2,
		/// <summary>
		/// Legacy vertex-lit shader pass, with desktop (RGBM) lightmaps.
		/// </summary>
		VertexLMRGBM = 3,
		/// <summary>
		/// Forward rendering base pass.
		/// </summary>
		ForwardBase = 4,
		/// <summary>
		/// Forward rendering additive pixel light pass.
		/// </summary>
		ForwardAdd = 5,
		/// <summary>
		/// Legacy deferred lighting (light pre-pass) base pass.
		/// </summary>
		LightPrePassBase = 6,
		/// <summary>
		/// Legacy deferred lighting (light pre-pass) final pass.
		/// </summary>
		LightPrePassFinal = 7,
		/// <summary>
		/// Shadow caster and depth texure shader pass.
		/// </summary>
		ShadowCaster = 8,
		/// <summary>
		/// Not needed starting with 5.0
		/// </summary>
		ShadowCollector = 9,
		/// <summary>
		/// Deferred Shading shader pass.
		/// </summary>
		Deferred = 10,
		/// <summary>
		/// Shader pass used to generate the albedo and emissive values used as input to lightmapping.
		/// </summary>
		Meta = 11,
		/// <summary>
		/// Motion vector render pass.
		/// </summary>
		MotionVectors = 12,
		/// <summary>
		/// Custom scriptable pipeline.
		/// </summary>
		ScriptableRenderPipeline = 13,
		/// <summary>
		/// Custom scriptable pipeline when lightmode is set to default unlit or no light mode is set.
		/// </summary>
		ScriptableRenderPipelineDefaultUnlit = 14,
	}
}

```

`AssetRipperCommon/Classes/Sprite/SpriteMeshType.cs`:

```cs
namespace AssetRipper.Core.Classes.Sprite
{
	/// <summary>
	/// Defines the type of mesh generated for a sprite.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/Sprites.bindings.cs"/>
	/// </summary>
	public enum SpriteMeshType
	{
		/// <summary>
		/// Rectangle mesh equal to the user specified sprite size.
		/// </summary>
		FullRect = 0,
		/// <summary>
		/// Tight mesh based on pixel alpha values. As many excess pixels are cropped as possible.
		/// </summary>
		Tight = 1,
	}
}

```

`AssetRipperCommon/Classes/Sprite/SpritePackingMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Sprite
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/Sprites.bindings.cs"/>
	/// </summary>
	public enum SpritePackingMode
	{
		Tight = 0,
		Rectangle = 1,
	}
}

```

`AssetRipperCommon/Classes/Sprite/SpritePackingRotation.cs`:

```cs
namespace AssetRipper.Core.Classes.Sprite
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/Sprites.bindings.cs"/>
	/// </summary>
	public enum SpritePackingRotation
	{
		None = 0,
		FlipHorizontal = 1,
		FlipVertical = 2,
		Rotate180 = 3,
		Rotate90 = 4,
		Any = 5,
		Any_4 = 15,
	}
}

```

`AssetRipperCommon/Classes/SpriteRenderer/SpriteDrawMode.cs`:

```cs
namespace AssetRipper.Core.Classes.SpriteRenderer
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/SpriteRenderer.bindings.cs"/>
	/// </summary>
	public enum SpriteDrawMode
	{
		/// <summary>
		/// Displays the full sprite.
		/// </summary>
		Simple = 0,
		/// <summary>
		/// The SpriteRenderer will render the sprite as a 9-slice image where the corners
		/// will remain constant and the other sections will scale.
		/// </summary>
		Sliced = 1,
		/// <summary> 
		/// The SpriteRenderer will render the sprite as a 9-slice image where the corners
		/// will remain constant and the other sections will tile.
		/// </summary>
		Tiled = 2
	}
}

```

`AssetRipperCommon/Classes/SpriteRenderer/SpriteMaskInteraction.cs`:

```cs
namespace AssetRipper.Core.Classes.SpriteRenderer
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/SpriteRenderer.bindings.cs"/>
	/// </summary>
	public enum SpriteMaskInteraction
	{
		/// <summary>
		/// The sprite will not interact with the masking system.
		/// </summary>
		None = 0,
		/// <summary>
		/// The sprite will be visible only in areas where a mask is present.
		/// </summary>
		VisibleInsideMask = 1,
		/// <summary>
		/// The sprite will be visible only in areas where no mask is present.
		/// </summary>
		VisibleOutsideMask = 2
	}
}

```

`AssetRipperCommon/Classes/SpriteRenderer/SpriteSortPoint.cs`:

```cs
namespace AssetRipper.Core.Classes.SpriteRenderer
{
	/// <summary>
	/// Determines the position of the Sprite used for sorting the Renderer.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/SpriteRenderer.bindings.cs"/>
	/// </summary>
	public enum SpriteSortPoint
	{
		/// <summary>
		/// The center of the Sprite is used as the point for sorting the Renderer.
		/// </summary>
		Center = 0,
		/// <summary>
		/// The pivot of the Sprite is used as the point for sorting the Renderer.
		/// </summary>
		Pivot = 1
	}
}

```

`AssetRipperCommon/Classes/SpriteRenderer/SpriteTileMode.cs`:

```cs
namespace AssetRipper.Core.Classes.SpriteRenderer
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/2D/Common/ScriptBindings/SpriteRenderer.bindings.cs"/>
	/// </summary>
	public enum SpriteTileMode
	{
		/// <summary>
		/// Sprite Renderer tiles the sprite continuously when is set to SpriteRenderer.tileMode.
		/// </summary>
		Continuous = 0,
		/// <summary>
		/// Sprite Renderer tiles the sprite once the Sprite Renderer size is above SpriteRenderer.adaptiveModeThreshold.
		/// </summary>
		Adaptive = 1
	}
}
```

`AssetRipperCommon/Classes/TagManager/TagManagerConstants.cs`:

```cs
namespace AssetRipper.Core.Classes.TagManager
{
	public static class TagManagerConstants
	{
		public const string UntaggedTag = "Untagged";
		public const string RespawnTag = "Respawn";
		public const string FinishTag = "Finish";
		public const string EditorOnlyTag = "EditorOnly";
		public const string MainCameraTag = "MainCamera";
		public const string PlayerTag = "Player";
		public const string GameControllerTag = "GameController";
	}
}

```

`AssetRipperCommon/Classes/Terrain/MaterialType.cs`:

```cs
namespace AssetRipper.Core.Classes.Terrain
{
	/// <summary>
	/// The type of the material used to render a terrain object. Could be one of the built-in types or custom.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Terrain/Public/Terrain.deprecated.cs"/>
	/// </summary>
	public enum MaterialType
	{
		/// <summary>
		/// A built-in material that uses the standard physically-based lighting model. Inputs supported: smoothness, metallic / specular, normal.
		/// </summary>
		BuiltInStandard = 0,
		/// <summary>
		/// A built-in material that uses the legacy Lambert (diffuse) lighting model and has optional normal map support.
		/// </summary>
		BuiltInLegacyDiffuse = 1,
		/// <summary>
		/// A built-in material that uses the legacy BlinnPhong (specular) lighting model and has optional normal map support.
		/// </summary>
		BuiltInLegacySpecular = 2,
		/// <summary>
		/// Use a custom material given by Terrain.materialTemplate.
		/// </summary>
		Custom = 3,
	}
}

```

`AssetRipperCommon/Classes/TerrainData/DetailRenderMode.cs`:

```cs
namespace AssetRipper.Core.Classes.TerrainData
{
	/// <summary>
	/// Render mode for detail prototypes.<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/Terrain/Public/TerrainData.bindings.cs"/>
	/// </summary>
	public enum DetailRenderMode
	{
		/// <summary>
		/// The detail prototype will be rendered as billboards that are always facing the camera.
		/// </summary>
		GrassBillboard = 0,
		/// <summary>
		/// Will show the prototype using diffuse shading.
		/// </summary>
		VertexLit = 1,
		/// <summary>
		/// The detail prototype will use the grass shader.
		/// </summary>
		Grass = 2,
	}
}

```

`AssetRipperCommon/Classes/Texture2D/ColorSpace.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum ColorSpace
	{
		Gamma = 0,
		Linear = 1,

		Uninitialized = -1,
	}
}
```

`AssetRipperCommon/Classes/Texture2D/FilterMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum FilterMode
	{
		Point = 0,
		Bilinear,
		Trilinear,
	}
}

```

`AssetRipperCommon/Classes/Texture2D/TextureDimension.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// TextureDimension enum as it present in Engine 2017.3<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum TextureDimension
	{
		/// <summary>
		/// Texture type is not initialized or unknown.
		/// </summary>
		Unknown = -1,
		/// <summary>
		/// No texture is assigned.
		/// </summary>
		None = 0,
		/// <summary>
		/// Any texture type.
		/// </summary>
		Any = 1,
		Deprecated1D = 1,
		/// <summary>
		/// 2D texture (Texture2D).
		/// </summary>
		Tex2D = 2,
		/// <summary>
		/// 3D volume texture (Texture3D).
		/// </summary>
		Tex3D = 3,
		/// <summary>
		/// Cubemap texture.
		/// </summary>
		Cube = 4,
		/// <summary>
		/// 2D array texture (Texture2DArray).
		/// </summary>
		Tex2DArray = 5,
		AnyOld = 5,
		/// <summary>
		/// Cubemap array texture (CubemapArray).
		/// </summary>
		CubeArray = 6,
		CountOld = 6,
		Force32Bit = 2147483647,
	}
}

```

`AssetRipperCommon/Classes/Texture2D/TextureFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum TextureFormat
	{
		PVRTC_2BPP_RGB = -127,
		PVRTC_2BPP_RGBA = -127,
		PVRTC_4BPP_RGB = -127,
		PVRTC_4BPP_RGBA = -127,
		/// <summary>
		/// Choose a compressed HDR format automatically.
		/// </summary>
		AutomaticCompressedHDR = -7,
		/// <summary>
		/// Choose an HDR format automatically.
		/// </summary>
		AutomaticHDR = -6,
		/// <summary>
		/// Choose a crunched format automatically.
		/// </summary>
		AutomaticCrunched = -5,
		/// <summary>
		/// Choose a Truecolor format automatically.
		/// </summary>
		AutomaticTruecolor = -3,
		/// <summary>
		/// Choose a 16 bit format automatically.
		/// </summary>
		Automatic16bit = -2,
		/// <summary>
		/// Choose texture format automatically based on the texture parameters.
		/// </summary>
		Automatic = -1,
		/// <summary>
		/// Choose a compressed format automatically.
		/// </summary>
		AutomaticCompressed = -1,
		/// <summary>
		/// Alpha-only texture format.
		/// </summary>
		Alpha8 = 1,
		/// <summary>
		/// A 16 bits/pixel texture format. Texture stores color with an alpha channel.
		/// </summary>
		ARGB4444 = 2,
		/// <summary>
		/// Color texture format, 8-bits per channel.
		/// </summary>
		RGB24 = 3,
		/// <summary>
		/// Color with alpha texture format, 8-bits per channel.
		/// </summary>
		RGBA32 = 4,
		/// <summary>
		/// Color with alpha texture format, 8-bits per channel.
		/// </summary>
		ARGB32 = 5,
		/// <summary>
		/// A 16 bit color texture format.
		/// </summary>
		RGB565 = 7,
		/// <summary>
		/// A 16 bit color texture format that only has a red channel.
		/// </summary>
		R16 = 9,
		/// <summary>
		/// Compressed color texture format.
		/// </summary>
		DXT1 = 10,
		DXT3 = 11,
		/// <summary>
		/// Compressed color with alpha channel texture format.
		/// </summary>
		DXT5 = 12,
		/// <summary>
		/// Color and alpha texture format, 4 bit per channel.
		/// </summary>
		RGBA4444 = 13,
		/// <summary>
		/// Color with alpha texture format, 8-bits per channel.
		/// </summary>
		BGRA32 = 14,
		/// <summary>
		/// Scalar (R) texture format, 16 bit floating point.
		/// </summary>
		RHalf = 15,
		/// <summary>
		/// Two color (RG) texture format, 16 bit floating point per channel.
		/// </summary>
		RGHalf = 16,
		/// <summary>
		/// RGB color and alpha texture format, 16 bit floating point per channel.
		/// </summary>
		RGBAHalf = 17,
		/// <summary>
		/// Scalar (R) texture format, 32 bit floating point.
		/// </summary>
		RFloat = 18,
		/// <summary>
		/// Two color (RG) texture format, 32 bit floating point per channel.
		/// </summary>
		RGFloat = 19,
		/// <summary>
		/// RGB color and alpha texture format, 32-bit floats per channel.
		/// </summary>
		RGBAFloat = 20,
		/// <summary>
		/// A format that uses the YUV color space and is often used for video encoding or playback.
		/// </summary>
		YUY2 = 21,
		/// <summary>
		/// RGB HDR format, with 9 bit mantissa per channel and a 5 bit shared exponent.
		/// </summary>
		RGB9e5Float = 22,
		/// <summary>
		/// HDR compressed color texture format.
		/// </summary>
		BC6H = 24,
		/// <summary>
		/// High quality compressed color texture format.
		/// </summary>
		BC7 = 25,
		/// <summary>
		/// Compressed one channel (R) texture format.
		/// </summary>
		BC4 = 26,
		/// <summary>
		/// Compressed two-channel (RG) texture format.
		/// </summary>
		BC5 = 27,
		/// <summary>
		/// Compressed color texture format with Crunch compression for smaller storage sizes.
		/// </summary>
		DXT1Crunched = 28,
		/// <summary>
		/// Compressed color with alpha channel texture format with Crunch compression for smaller storage sizes.
		/// </summary>
		DXT5Crunched = 29,
		/// <summary>
		/// PowerVR (iOS) 2 bits/pixel compressed color texture format.
		/// </summary>
		PVRTC_RGB2 = 30,
		/// <summary>
		/// PowerVR (iOS) 2 bits/pixel compressed with alpha channel texture format.
		/// </summary>
		PVRTC_RGBA2 = 31,
		/// <summary>
		/// PowerVR (iOS) 4 bits/pixel compressed color texture format.
		/// </summary>
		PVRTC_RGB4 = 32,
		/// <summary>
		/// PowerVR (iOS) 4 bits/pixel compressed with alpha channel texture format.
		/// </summary>
		PVRTC_RGBA4 = 33,
		/// <summary>
		/// ETC (GLES2.0) 4 bits/pixel compressed RGB texture format.
		/// </summary>
		ETC_RGB4 = 34,
		/// <summary>
		/// ATC (ATITC) 4 bits/pixel compressed RGB texture format.
		/// </summary>
		ATC_RGB4 = 35,
		/// <summary>
		/// ATC (ATITC) 8 bits/pixel compressed RGB texture format.
		/// </summary>
		ATC_RGBA8 = 36,
		/// <summary>
		/// ETC2 EAC (GL ES 3.0) 4 bitspixel compressed unsigned single-channel texture format.
		/// </summary>
		EAC_R = 41,
		/// <summary>
		/// ETC2 EAC (GL ES 3.0) 4 bitspixel compressed signed single-channel texture format.
		/// </summary>
		EAC_R_SIGNED = 42,
		/// <summary>
		/// ETC2 EAC (GL ES 3.0) 8 bitspixel compressed unsigned dual-channel (RG) texture format.
		/// </summary>
		EAC_RG = 43,
		/// <summary>
		/// ETC2 EAC (GL ES 3.0) 8 bitspixel compressed signed dual-channel (RG) texture format.
		/// </summary>
		EAC_RG_SIGNED = 44,
		/// <summary>
		/// ETC2 (GL ES 3.0) 4 bits/pixel compressed RGB texture format.
		/// </summary>
		ETC2_RGB = 45,
		/// <summary>
		/// ETC2 (GL ES 3.0) 4 bits/pixel RGB+1-bit alpha texture format.
		/// </summary>
		ETC2_RGBA1 = 46,
		/// <summary>
		/// ETC2 (GL ES 3.0) 8 bits/pixel compressed RGBA texture format.
		/// </summary>
		ETC2_RGBA8 = 47,
		/// <summary>
		/// ASTC (4x4 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_4x4 = 48,
		/// <summary>
		/// ASTC (5x5 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_5x5 = 49,
		/// <summary>
		/// ASTC (6x6 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_6x6 = 50,
		/// <summary>
		/// ASTC (8x8 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_8x8 = 51,
		/// <summary>
		/// ASTC (10x10 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_10x10 = 52,
		/// <summary>
		/// ASTC (12x12 pixel block in 128 bits) compressed RGB texture format.
		/// </summary>
		ASTC_RGB_12x12 = 53,
		/// <summary>
		/// ASTC (4x4 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_4x4 = 54,
		/// <summary>
		/// ASTC (5x5 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_5x5 = 55,
		/// <summary>
		/// ASTC (6x6 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_6x6 = 56,
		/// <summary>
		/// ASTC (8x8 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_8x8 = 57,
		/// <summary>
		/// ASTC (10x10 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_10x10 = 58,
		/// <summary>
		/// ASTC (12x12 pixel block in 128 bits) compressed RGBA texture format.
		/// </summary>
		ASTC_RGBA_12x12 = 59,
		/// <summary>
		/// ETC 4 bits/pixel compressed RGB texture format.
		/// </summary>
		ETC_RGB4_3DS = 60,
		/// <summary>
		/// ETC 4 bitspixel RGB + 4 bitspixel Alpha compressed texture format.
		/// </summary>
		ETC_RGBA8_3DS = 61,
		/// <summary>
		/// Two color (RG) texture format, 8-bits per channel.
		/// </summary>
		RG16 = 62,
		/// <summary>
		/// Scalar (R) render texture format, 8 bit fixed point.
		/// </summary>
		R8 = 63,
		/// <summary>
		/// Compressed color texture format with Crunch compression for smaller storage sizes.
		/// </summary>
		ETC_RGB4Crunched = 64,
		/// <summary>
		/// Compressed color with alpha channel texture format with Crunch compression for smaller storage sizes.
		/// </summary>
		ETC2_RGBA8Crunched = 65,
		ASTC_HDR_4x4 = 66,
		ASTC_HDR_5x5 = 67,
		ASTC_HDR_6x6 = 68,
		ASTC_HDR_8x8 = 69,
		ASTC_HDR_10x10 = 70,
		ASTC_HDR_12x12 = 71,
		RG32 = 72,
		RGB48 = 73,
		RGBA64 = 74,
	}

	public static class TextureFormatExtensions
	{
#warning TODO: check version?
		public static TextureFormat ToDefaultFormat(this TextureFormat _this)
		{
			if (_this == TextureFormat.R8)
			{
				return _this;
			}
			return TextureFormat.Automatic;
		}
	}
}

```

`AssetRipperCommon/Classes/Texture2D/TextureUsageMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// Lightmap format of a [[Texture2D|texture]]<br/>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Editor/Mono/AssetPipeline/TextureImporterEnums.cs"/>
	/// </summary>
	public enum TextureUsageMode
	{
		/// <summary>
		/// Not a lightmap
		/// </summary>
		Default = 0,
		/// <summary>
		/// Range [0;2] packed to [0;1] with loss of precision
		/// </summary>
		BakedLightmapDoubleLDR = 1,
		/// <summary>
		/// Range [0;kLightmapRGBMMax] packed to [0;1] with multiplier stored in the alpha channel
		/// </summary>
		BakedLightmapRGBM = 2,
		/// <summary>
		/// Compressed DXT5 normal map
		/// </summary>
		NormalmapDXT5nm = 3,
		/// <summary>
		/// Plain RGB normal map
		/// </summary>
		NormalmapPlain = 4,
		RGBMEncoded = 5,
		/// <summary>
		/// Texture is always padded if NPOT and on low-end hardware
		/// </summary>
		AlwaysPadded = 6,
		DoubleLDR = 7,
		/// <summary>
		/// Baked lightmap without any encoding
		/// </summary>
		BakedLightmapFullHDR = 8,
		RealtimeLightmapRGBM = 9,
		NormalmapASTCnm = 10,
		SingleChannelRed = 11,
		SingleChannelAlpha = 12,
	}

	public static class TextureUsageModeExtensions
	{
		public static bool IsNormalmap(this TextureUsageMode _this)
		{
			return _this == TextureUsageMode.NormalmapDXT5nm || _this == TextureUsageMode.NormalmapPlain || _this == TextureUsageMode.NormalmapASTCnm;
		}
	}
}

```

`AssetRipperCommon/Classes/Texture2D/TextureWrapMode.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2D
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum TextureWrapMode
	{
		/// <summary>
		/// Tiles the texture, creating a repeating pattern.
		/// </summary>
		Repeat = 0,
		/// <summary>
		/// Clamps the texture to the last pixel at the edge.
		/// </summary>
		Clamp = 1,
		/// <summary>
		/// Tiles the texture, creating a repeating pattern by mirroring it at every integer boundary.
		/// </summary>
		Mirror = 2,
		/// <summary>
		/// Mirrors the texture once, then clamps to edge pixels.
		/// </summary>
		MirrorOnce = 3
	}
}

```

`AssetRipperCommon/Classes/Texture2DArray/GraphicsFormat.cs`:

```cs
namespace AssetRipper.Core.Classes.Texture2DArray
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum GraphicsFormat
	{
		None = 0,

		R8_SRGB = 1,
		R8G8_SRGB = 2,
		R8G8B8_SRGB = 3,
		R8G8B8A8_SRGB = 4,

		R8_UNorm = 5,
		R8G8_UNorm = 6,
		R8G8B8_UNorm = 7,
		R8G8B8A8_UNorm = 8,
		R8_SNorm = 9,
		R8G8_SNorm = 10,
		R8G8B8_SNorm = 11,
		R8G8B8A8_SNorm = 12,
		R8_UInt = 13,
		R8G8_UInt = 14,
		R8G8B8_UInt = 15,
		R8G8B8A8_UInt = 16,
		R8_SInt = 17,
		R8G8_SInt = 18,
		R8G8B8_SInt = 19,
		R8G8B8A8_SInt = 20,

		R16_UNorm = 21,
		R16G16_UNorm = 22,
		R16G16B16_UNorm = 23,
		R16G16B16A16_UNorm = 24,
		R16_SNorm = 25,
		R16G16_SNorm = 26,
		R16G16B16_SNorm = 27,
		R16G16B16A16_SNorm = 28,
		R16_UInt = 29,
		R16G16_UInt = 30,
		R16G16B16_UInt = 31,
		R16G16B16A16_UInt = 32,
		R16_SInt = 33,
		R16G16_SInt = 34,
		R16G16B16_SInt = 35,
		R16G16B16A16_SInt = 36,

		R32_UInt = 37,
		R32G32_UInt = 38,
		R32G32B32_UInt = 39,
		R32G32B32A32_UInt = 40,
		R32_SInt = 41,
		R32G32_SInt = 42,
		R32G32B32_SInt = 43,
		R32G32B32A32_SInt = 44,

		R16_SFloat = 45,
		R16G16_SFloat = 46,
		R16G16B16_SFloat = 47,
		R16G16B16A16_SFloat = 48,
		R32_SFloat = 49,
		R32G32_SFloat = 50,
		R32G32B32_SFloat = 51,
		R32G32B32A32_SFloat = 52,

		B8G8R8_SRGB = 56,
		B8G8R8A8_SRGB = 57,
		B8G8R8_UNorm = 58,
		B8G8R8A8_UNorm = 59,
		B8G8R8_SNorm = 60,
		B8G8R8A8_SNorm = 61,
		B8G8R8_UInt = 62,
		B8G8R8A8_UInt = 63,
		B8G8R8_SInt = 64,
		B8G8R8A8_SInt = 65,

		R4G4B4A4_UNormPack16 = 66,
		B4G4R4A4_UNormPack16 = 67,
		R5G6B5_UNormPack16 = 68,
		B5G6R5_UNormPack16 = 69,
		R5G5B5A1_UNormPack16 = 70,
		B5G5R5A1_UNormPack16 = 71,
		A1R5G5B5_UNormPack16 = 72,

		E5B9G9R9_UFloatPack32 = 73,
		B10G11R11_UFloatPack32 = 74,

		A2B10G10R10_UNormPack32 = 75,
		A2B10G10R10_UIntPack32 = 76,
		A2B10G10R10_SIntPack32 = 77,
		A2R10G10B10_UNormPack32 = 78,
		A2R10G10B10_UIntPack32 = 79,
		A2R10G10B10_SIntPack32 = 80,
		A2R10G10B10_XRSRGBPack32 = 81,
		A2R10G10B10_XRUNormPack32 = 82,
		R10G10B10_XRSRGBPack32 = 83,
		R10G10B10_XRUNormPack32 = 84,
		A10R10G10B10_XRSRGBPack32 = 85,
		A10R10G10B10_XRUNormPack32 = 86,

		D16_UNorm = 90,
		D24_UNorm = 91,
		D24_UNorm_S8_UInt = 92,
		D32_SFloat = 93,
		D32_SFloat_S8_UInt = 94,
		S8_UInt = 95,

		RGB_DXT1_SRGB = 96,
		RGBA_DXT1_SRGB = 96,
		RGB_DXT1_UNorm = 97,
		RGBA_DXT1_UNorm = 97,
		RGBA_DXT3_SRGB = 98,
		RGBA_DXT3_UNorm = 99,
		RGBA_DXT5_SRGB = 100,
		RGBA_DXT5_UNorm = 101,
		R_BC4_UNorm = 102,
		R_BC4_SNorm = 103,
		RG_BC5_UNorm = 104,
		RG_BC5_SNorm = 105,
		RGB_BC6H_UFloat = 106,
		RGB_BC6H_SFloat = 107,
		RGBA_BC7_SRGB = 108,
		RGBA_BC7_UNorm = 109,

		RGB_PVRTC_2Bpp_SRGB = 110,
		RGB_PVRTC_2Bpp_UNorm = 111,
		RGB_PVRTC_4Bpp_SRGB = 112,
		RGB_PVRTC_4Bpp_UNorm = 113,
		RGBA_PVRTC_2Bpp_SRGB = 114,
		RGBA_PVRTC_2Bpp_UNorm = 115,
		RGBA_PVRTC_4Bpp_SRGB = 116,
		RGBA_PVRTC_4Bpp_UNorm = 117,

		RGB_ETC_UNorm = 118,
		RGB_ETC2_SRGB = 119,
		RGB_ETC2_UNorm = 120,
		RGB_A1_ETC2_SRGB = 121,
		RGB_A1_ETC2_UNorm = 122,
		RGBA_ETC2_SRGB = 123,
		RGBA_ETC2_UNorm = 124,

		R_EAC_UNorm = 125,
		R_EAC_SNorm = 126,
		RG_EAC_UNorm = 127,
		RG_EAC_SNorm = 128,

		RGBA_ASTC4X4_SRGB = 129,
		RGBA_ASTC4X4_UNorm = 130,
		RGBA_ASTC5X5_SRGB = 131,
		RGBA_ASTC5X5_UNorm = 132,
		RGBA_ASTC6X6_SRGB = 133,
		RGBA_ASTC6X6_UNorm = 134,
		RGBA_ASTC8X8_SRGB = 135,
		RGBA_ASTC8X8_UNorm = 136,
		RGBA_ASTC10X10_SRGB = 137,
		RGBA_ASTC10X10_UNorm = 138,
		RGBA_ASTC12X12_SRGB = 139,
		RGBA_ASTC12X12_UNorm = 140,

		YUV2 = 141,
		DepthAuto = 142,
		ShadowAuto = 143,
		VideoAuto = 144,

		RGBA_ASTC4X4_UFloat = 145,
		RGBA_ASTC5X5_UFloat = 146,
		RGBA_ASTC6X6_UFloat = 147,
		RGBA_ASTC8X8_UFloat = 148,
		RGBA_ASTC10X10_UFloat = 149,
		RGBA_ASTC12X12_UFloat = 150,

		D16_UNorm_S8_UInt = 151,
	}
}

```

`AssetRipperCommon/Classes/TrailRenderer/LineAlignment.cs`:

```cs
namespace AssetRipper.Core.Classes.TrailRenderer
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LineAlignment
	{
		View = 0,
		/// <summary>
		/// Replaced with TransformZ
		/// </summary>
		Local = 1,
		TransformZ = 1,
	}
}

```

`AssetRipperCommon/Classes/TrailRenderer/LineTextureMode.cs`:

```cs
namespace AssetRipper.Core.Classes.TrailRenderer
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Runtime/Export/Graphics/GraphicsEnums.cs"/>
	/// </summary>
	public enum LineTextureMode
	{
		Stretch = 0,
		Tile = 1,
		DistributePerSegment = 2,
		RepeatPerSegment = 3,
		Static = 4,
	}
}

```

`AssetRipperCommon/Classes/UI/Canvas/RenderMode.cs`:

```cs
namespace AssetRipper.Core.Classes.UI.Canvas
{
	/// <summary>
	/// <see href="https://github.com/Unity-Technologies/UnityCsReference/blob/master/Modules/UI/ScriptBindings/UICanvas.bindings.cs"/>
	/// </summary>
	public enum RenderMode
	{
		/// <summary>
		/// Render at the end of the scene using a 2D Canvas.
		/// </summary>
		ScreenSpaceOverlay = 0,
		/// <summary>
		/// Render using the Camera configured on the Canvas.
		/// </summary>
		ScreenSpaceCamera = 1,
		/// <summary>
		/// Render using any Camera in the scene that can render the layer.
		/// </summary>
		WorldSpace = 2
	}
}

```

`AssetRipperCommon/Exceptions/UnbackedPropertyException.cs`:

```cs
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.Exceptions
{
	public sealed class UnbackedPropertyException : Exception
	{
		public IUnityAssetBase Asset { get; }
		public string PropertyName { get; }

		public UnbackedPropertyException(IUnityAssetBase asset, string propertyName)
		{
			Asset = asset;
			PropertyName = propertyName;
		}

		public override string Message => $"{Asset.GetType().Name}.{PropertyName} is not backed by a field.";
	}
}

```

`AssetRipperCommon/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipperCommon/Parser/Asset/AssetFactory.cs`:

```cs
using AssetRipper.Core.Interfaces;

namespace AssetRipper.Core.Parser.Asset
{
	public class AssetFactory : AssetFactoryBase
	{
		public override IUnityObjectBase? CreateAsset(AssetInfo assetInfo, UnityVersion version)
		{
			return SourceGenerated.AssetFactory.CreateAsset(version, assetInfo);
		}

		public override ClassIDType GetClassIdForType(Type type)
		{
			if(SourceGenerated.ClassIDTypeMap.dictionary.TryGetValue(type, out SourceGenerated.ClassIDType value))
			{
				return (ClassIDType)value;
			}
			else
			{
				//throw new NotSupportedException(type.FullName);
				return ClassIDType.UnknownType;
			}
		}
	}
}

```

`AssetRipperCommon/Project/Collections/AssetExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_1034;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public class AssetExportCollection : ExportCollection
	{
		public AssetExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset)
		{
			AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
			Asset = asset ?? throw new ArgumentNullException(nameof(asset));
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subPath;
			string fileName;
			if (container.TryGetAssetPathFromAssets(Assets, out IUnityObjectBase? asset, out string assetPath))
			{
				string resourcePath = Path.Combine(dirPath, $"{assetPath}.{GetExportExtension(asset)}");
				subPath = Path.GetDirectoryName(resourcePath)!;
				string resFileName = Path.GetFileName(resourcePath);
#warning TODO: combine assets with the same res path into one big asset
				// Unity distinguish assets with non unique path by its type, but file system doesn't support it
				fileName = GetUniqueFileName(subPath, resFileName);
			}
			else
			{
				string subFolder = Asset.ExportPath;
				subPath = Path.Combine(dirPath, subFolder);
				fileName = GetUniqueFileName(container.File, Asset, subPath);
			}

			Directory.CreateDirectory(subPath);

			string filePath = Path.Combine(subPath, fileName);
			bool result = ExportInner(container, filePath, dirPath);
			if (result)
			{
				Meta meta = new Meta(Asset.GUID, CreateImporter(container));
				ExportMeta(container, meta, filePath);
				return true;
			}
			return false;
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return Asset.AssetInfo == asset.AssetInfo;
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			if (asset.AssetInfo == Asset.AssetInfo)
			{
				return ExportIdHandler.GetMainExportID(Asset);
			}
			throw new ArgumentException(nameof(asset));
		}

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			long exportID = GetExportID(asset);
			return isLocal ?
				new MetaPtr(exportID) :
				new MetaPtr(exportID, Asset.GUID, AssetExporter.ToExportType(Asset));
		}

		/// <summary>
		/// 
		/// </summary>
		/// <param name="container"></param>
		/// <param name="filePath">The full path to the exported asset destination</param>
		/// <param name="dirPath">The full path to the project export directory</param>
		/// <returns>True if export was successful, false otherwise</returns>
		protected virtual bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			return AssetExporter.Export(container, Convert(Asset, container), filePath);
		}

		protected virtual IUnityObjectBase CreateImporter(IExportContainer container)
		{
			INativeFormatImporter importer = NativeFormatImporterFactory.CreateAsset(container.ExportVersion);
			importer.MainObjectFileID_C1034 = GetExportID(Asset);
			return importer;
		}

		public override IAssetExporter AssetExporter { get; }
		public override ISerializedFile File => Asset.SerializedFile;
		public override IEnumerable<IUnityObjectBase> Assets
		{
			get { yield return Asset; }
		}
		public override string Name
		{
			get
			{
				if (Asset is IHasNameString hasName)
				{
					return hasName.GetNameNotEmpty();
				}
				else
				{
					return Asset.AssetClassName;
				}
			}
		}
		public IUnityObjectBase Asset { get; }
	}
}

```

`AssetRipperCommon/Project/Collections/AssetsExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.Utils;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Project.Collections
{
	public abstract class AssetsExportCollection : AssetExportCollection
	{
		public AssetsExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset) { }

		public override bool IsContains(IUnityObjectBase asset)
		{
			if (base.IsContains(asset))
			{
				return true;
			}
			return m_exportIDs.ContainsKey(asset.AssetInfo);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			if (asset.AssetInfo == Asset.AssetInfo)
			{
				return base.GetExportID(asset);
			}
			return m_exportIDs[asset.AssetInfo];
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			return AssetExporter.Export(container, Assets.Select(t => Convert(t, container)), filePath);
		}

		public override IEnumerable<IUnityObjectBase> Assets
		{
			get
			{
				foreach (IUnityObjectBase asset in base.Assets)
				{
					yield return asset;
				}
				foreach (IUnityObjectBase asset in m_assets)
				{
					yield return asset;
				}
			}
		}

		protected virtual long GenerateExportID(IUnityObjectBase asset)
		{
			return ObjectUtils.GenerateExportID(asset, ContainsID);
		}

		protected void AddAsset(IUnityObjectBase asset)
		{
			long exportID = GenerateExportID(asset);
			m_assets.Add(asset);
			m_exportIDs.Add(asset.AssetInfo, exportID);
		}

		private bool ContainsID(long id)
		{
			return m_exportIDs.ContainsValue(id);
		}

		protected readonly List<IUnityObjectBase> m_assets = new List<IUnityObjectBase>();
		protected readonly Dictionary<AssetInfo, long> m_exportIDs = new Dictionary<AssetInfo, long>();
	}
}

```

`AssetRipperCommon/Project/Collections/BuildSettingsExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1045;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_159;
using AssetRipper.SourceGenerated.Subclasses.Scene;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public sealed class BuildSettingsExportCollection : ManagerExportCollection
	{
		public BuildSettingsExportCollection(IAssetExporter assetExporter, VirtualSerializedFile file, IUnityObjectBase asset) : this(assetExporter, file, (IBuildSettings)asset) { }

		public BuildSettingsExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IBuildSettings asset) : base(assetExporter, asset)
		{
			EditorBuildSettings = CreateVirtualEditorBuildSettings(virtualFile);
			EditorSettings = CreateVirtualEditorSettings(virtualFile);
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subPath = Path.Combine(dirPath, ProjectSettingsName);
			string fileName = "EditorBuildSettings.asset";
			string filePath = Path.Combine(subPath, fileName);

			Directory.CreateDirectory(subPath);

			IBuildSettings buildSettings = (IBuildSettings)Asset;
			InitializeEditorBuildSettings(EditorBuildSettings, buildSettings, container);
			AssetExporter.Export(container, EditorBuildSettings, filePath);

			fileName = "EditorSettings.asset";
			filePath = Path.Combine(subPath, fileName);

			AssetExporter.Export(container, EditorSettings, filePath);

			return true;
		}

		public static IEditorSettings CreateVirtualEditorSettings(VirtualSerializedFile virtualFile)
		{
			IEditorSettings result = virtualFile.CreateAsset<IEditorSettings>(ClassIDType.EditorSettings);
			result.SetToDefaults();
			return result;
		}

		public static IEditorBuildSettings CreateVirtualEditorBuildSettings(VirtualSerializedFile virtualFile)
		{
			return virtualFile.CreateAsset<IEditorBuildSettings>(ClassIDType.EditorBuildSettings);
		}

		public static void InitializeEditorBuildSettings(IEditorBuildSettings editorBuildSettings, IBuildSettings buildSettings, IProjectAssetContainer container)
		{
			int numScenes = buildSettings.Scenes_C141.Count;
			editorBuildSettings.Scenes_C1045.Capacity = numScenes;
			for (int i = 0; i < numScenes; i++)
			{
				string scenePath = buildSettings.Scenes_C141[i].String;
				IScene scene = editorBuildSettings.Scenes_C1045.AddNew();
				scene.Enabled = true;
				scene.Path.String = scenePath;
				if(scene.Has_Guid())
				{
					scene.Guid.SetValues(container.SceneNameToGUID(scenePath));
				}
			}
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			if (asset is IEditorBuildSettings)
			{
				return asset == EditorBuildSettings;
			}
			else if (asset is IEditorSettings)
			{
				return asset == EditorSettings;
			}
			else
			{
				return base.IsContains(asset);
			}
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			return 1;
		}

		public override IEnumerable<IUnityObjectBase> Assets
		{
			get
			{
				yield return Asset;
				yield return EditorBuildSettings;
				yield return EditorSettings;
			}
		}

		public IEditorBuildSettings EditorBuildSettings { get; }
		public IEditorSettings EditorSettings { get; }
	}
}

```

`AssetRipperCommon/Project/Collections/EmptyExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Project.Collections
{
	public sealed class EmptyExportCollection : IExportCollection
	{
		public bool Export(IProjectAssetContainer container, string dirPath)
		{
			return false;
		}

		public bool IsContains(IUnityObjectBase asset)
		{
			return false;
		}

		public long GetExportID(IUnityObjectBase asset)
		{
			throw new NotSupportedException();
		}

		public UnityGUID GetExportGUID(IUnityObjectBase asset)
		{
			throw new NotSupportedException();
		}

		public MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			throw new NotSupportedException();
		}

		public ISerializedFile File => throw new NotSupportedException();
		public TransferInstructionFlags Flags => throw new NotSupportedException();
		public IEnumerable<IUnityObjectBase> Assets => Enumerable.Empty<IUnityObjectBase>();
		public string Name => throw new NotSupportedException();
	}
}

```

`AssetRipperCommon/Project/Collections/EngineExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Project.Exporters.Engine;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1113;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using System.Collections.Generic;


namespace AssetRipper.Core.Project.Collections
{
	public class EngineExportCollection : IExportCollection
	{
		public EngineExportCollection(IUnityObjectBase asset, UnityVersion version)
		{
			if (asset == null)
			{
				throw new ArgumentNullException(nameof(asset));
			}

			File = asset.SerializedFile;
			m_version = version;
			if (IsEngineFile(asset.SerializedFile.Name))
			{
				foreach (IUnityObjectBase builtInAsset in File.FetchAssets())
				{
					if (IsEngineAsset(builtInAsset, version))
					{
						m_assets.Add(builtInAsset);
					}
				}
			}
			else
			{
				m_assets.Add(asset);
			}
		}

		public static bool IsEngineAsset(IUnityObjectBase asset, UnityVersion version)
		{
			if (!GetEngineBuildInAsset(asset, version, out EngineBuiltInAsset builtinAsset))
			{
				return false;
			}
			if (IsEngineFile(asset?.SerializedFile.Name))
			{
				return true;
			}

			if (asset is IMaterial material)
			{
				if (material.NameString == EngineBuiltInAssets.FontMaterialName)
				{
					return false;
				}
				IShader? shader = material.Shader_C21.FindAsset(material.SerializedFile);
				if (shader == null)
				{
					return true;
				}
				return IsEngineAsset(shader, version);
			}
			else if (asset is IShader)
			{
				return true;
			}
			else if (asset is ITexture2D texture)
			{
				return builtinAsset.Parameter == texture.GetCompleteImageSize();
			}
			else if (asset is ISprite sprite)
			{
				ITexture2D? spriteTexture = sprite.RD_C213.Texture.FindAsset(sprite.SerializedFile);
				if (spriteTexture == null)
				{
					return false;
				}
				return IsEngineAsset(spriteTexture, version);
			}
			else
			{
				return false;
			}
		}

		private static bool IsEngineFile(string? fileName)
		{
			return fileName is not null 
				&& (FilenameUtils.IsDefaultResource(fileName) || FilenameUtils.IsBuiltinExtra(fileName) || FilenameUtils.IsEngineGeneratedF(fileName));
		}

		private static bool GetEngineBuildInAsset(IUnityObjectBase asset, UnityVersion version, out EngineBuiltInAsset engineAsset)
		{
			if (asset is IMaterial material)
			{
				if (EngineBuiltInAssets.TryGetMaterial(material.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is ITexture2D texture)
			{
				if (EngineBuiltInAssets.TryGetTexture(texture.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is IMesh mesh)
			{
				if (EngineBuiltInAssets.TryGetMesh(mesh.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is IShader shader)
			{
				if (EngineBuiltInAssets.TryGetShader(shader.TryGetName() ?? "", version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is IFont font)
			{
				if (EngineBuiltInAssets.TryGetFont(font.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is ISprite sprite)
			{
				if (EngineBuiltInAssets.TryGetSprite(sprite.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is ILightmapParameters lightParams)
			{
				if (EngineBuiltInAssets.TryGetLightmapParams(lightParams.NameString, version, out engineAsset))
				{
					return true;
				}
			}
			else if (asset is SourceGenerated.Classes.ClassID_114.IMonoBehaviour behaviour)
			{
				if (behaviour.NameString != string.Empty)
				{
					if (EngineBuiltInAssets.TryGetBehaviour(behaviour.NameString, version, out engineAsset))
					{
						return true;
					}
				}
			}

			engineAsset = default;
			return false;
		}

		public bool Export(IProjectAssetContainer container, string dirPath)
		{
			//return false;
			return true; //successfully redirected to an engine asset
		}

		public bool IsContains(IUnityObjectBase asset)
		{
			return m_assets.Contains(asset);
		}

		public long GetExportID(IUnityObjectBase asset)
		{
			GetEngineBuildInAsset(asset, m_version, out EngineBuiltInAsset engneAsset);
			return engneAsset.ExportID;
		}

		public MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}
			GetEngineBuildInAsset(asset, m_version, out EngineBuiltInAsset engineAsset);
			if (!engineAsset.IsValid)
			{
				throw new NotImplementedException($"Unknown ExportID for asset {asset.PathID} from file {asset.SerializedFile.Name}");
			}
			long exportID = engineAsset.ExportID;
			UnityGUID guid = engineAsset.GUID;
			return new MetaPtr(exportID, guid, AssetType.Internal);
		}

		public ISerializedFile File { get; }
		public TransferInstructionFlags Flags => File.Flags;
		public IEnumerable<IUnityObjectBase> Assets => m_assets;
		public string Name => $"Engine {m_version}";

		private readonly HashSet<IUnityObjectBase> m_assets = new HashSet<IUnityObjectBase>();

		private readonly UnityVersion m_version;
	}
}

```

`AssetRipperCommon/Project/Collections/ExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_1113;
using AssetRipper.SourceGenerated.Classes.ClassID_121;
using AssetRipper.SourceGenerated.Classes.ClassID_134;
using AssetRipper.SourceGenerated.Classes.ClassID_157;
using AssetRipper.SourceGenerated.Classes.ClassID_19;
using AssetRipper.SourceGenerated.Classes.ClassID_1953259897;
using AssetRipper.SourceGenerated.Classes.ClassID_196;
using AssetRipper.SourceGenerated.Classes.ClassID_200;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_218;
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_30;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_47;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_62;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_84;
using AssetRipper.SourceGenerated.Classes.ClassID_850595691;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.Yaml;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Project.Collections
{
	public abstract class ExportCollection : IExportCollection
	{
		protected static void ExportMeta(IExportContainer container, Meta meta, string filePath)
		{
			string metaPath = $"{filePath}{MetaExtension}";
			using FileStream fileStream = System.IO.File.Create(metaPath);
			using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, new UTF8Encoding(false));

			YamlWriter writer = new();
			writer.IsWriteDefaultTag = false;
			writer.IsWriteVersion = false;
			writer.IsFormatKeys = true;
			YamlDocument doc = meta.ExportYamlDocument(container);
			writer.AddDocument(doc);
			writer.Write(streamWriter);
		}

		public abstract bool Export(IProjectAssetContainer container, string dirPath);
		public abstract bool IsContains(IUnityObjectBase asset);
		public abstract long GetExportID(IUnityObjectBase asset);
		public abstract MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal);

		protected void ExportAsset(IProjectAssetContainer container, IUnityObjectBase importer, IUnityObjectBase asset, string path, string name)
		{
			if (!Directory.Exists(path))
			{
				Directory.CreateDirectory(path);
			}

			string fullName = $"{name}.{GetExportExtension(asset)}";
			string uniqueName = FileUtils.GetUniqueName(path, fullName, FileUtils.MaxFileNameLength - MetaExtension.Length);
			string filePath = Path.Combine(path, uniqueName);
			AssetExporter.Export(container, asset, filePath);
			Meta meta = new Meta(asset.GUID, importer);
			ExportMeta(container, meta, filePath);
		}

		protected string GetUniqueFileName(ISerializedFile file, IUnityObjectBase asset, string dirPath)
		{
			string? fileName = asset switch
			{
				IPrefabInstance prefab => prefab.GetName(file),
				IHasNameString hasName => hasName.GetNameNotEmpty(),
				_ => null,
			};
			if (string.IsNullOrWhiteSpace(fileName))
			{
				fileName = asset.AssetClassName;
			}

			fileName = FileUtils.RemoveCloneSuffixes(fileName);
			fileName = FileUtils.FixInvalidNameCharacters(fileName);

			fileName = $"{fileName}.{GetExportExtension(asset)}";
			return GetUniqueFileName(dirPath, fileName);
		}

		protected static string GetUniqueFileName(string directoryPath, string fileName)
		{
			return FileUtils.GetUniqueName(directoryPath, fileName, FileUtils.MaxFileNameLength - MetaExtension.Length);
		}

		protected virtual string GetExportExtension(IUnityObjectBase asset)
		{
			return asset switch
			{
				IShader => "shader",
				IMaterial => "mat",
				IAnimationClip => "anim",
				IAnimatorController => "controller",
				IAnimatorOverrideController => "overrideController",
				SourceGenerated.Classes.ClassID_319.IAvatarMask or SourceGenerated.Classes.ClassID_1011.IAvatarMask => "mask",
				IShaderVariantCollection => "shadervariants",
				ICubemap => "cubemap",
				IFlare => "flare",
				ILightingSettings => "lighting",
				ILightmapParameters => "giparams",
				IPhysicMaterial => "physicMaterial",
				IPhysicsMaterial2D => "physicsMaterial2D",
				IRenderTexture => "renderTexture",
				ITerrainLayer => "terrainlayer",
				_ => asset.ExportExtension
			};
		}

		protected static IUnityObjectBase Convert(IUnityObjectBase asset, IExportContainer container)
		{
			switch (asset)
			{
				//ordered by approximate frequency
				case IGameObject gameObject:
					gameObject.ConvertToEditorFormat(container);
					break;
				case ITransform transform:
					transform.ConvertToEditorFormat();
					break;
				case IRenderer renderer:
					renderer.ConvertToEditorFormat();
					break;
				case IMesh mesh:
					mesh.ConvertToEditorFormat();
					break;
				case ISpriteAtlas spriteAtlas:
					spriteAtlas.ConvertToEditorFormat();
					break;
				case ITerrain terrain:
					terrain.ConvertToEditorFormat();
					break;
				case IGraphicsSettings graphicsSettings:
					graphicsSettings.ConvertToEditorFormat();
					break;
				case IQualitySettings qualitySettings:
					qualitySettings.ConvertToEditorFormat();
					break;
				case IPhysics2DSettings physics2DSettings:
					physics2DSettings.ConvertToEditorFormat();
					break;
				case ILightmapSettings lightmapSettings:
					lightmapSettings.ConvertToEditorFormat();
					break;
				case INavMeshSettings navMeshSettings:
					navMeshSettings.ConvertToEditorFormat();
					break;
			}
			return asset;
		}

		public abstract IAssetExporter AssetExporter { get; }
		public abstract ISerializedFile File { get; }
		public virtual TransferInstructionFlags Flags => TransferInstructionFlags.NoTransferInstructionFlags;
		public abstract IEnumerable<IUnityObjectBase> Assets { get; }
		public abstract string Name { get; }

		private const string MetaExtension = ".meta";
	}
}

```

`AssetRipperCommon/Project/Collections/FailExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Collections
{
	public class FailExportCollection : IExportCollection
	{
		public FailExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset)
		{
			if (assetExporter == null)
			{
				throw new ArgumentNullException(nameof(assetExporter));
			}
			if (asset == null)
			{
				throw new ArgumentNullException(nameof(asset));
			}

			AssetExporter = assetExporter;
			m_asset = asset;
		}

		public bool Export(IProjectAssetContainer container, string dirPath)
		{
			Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to export asset {Name}");
			return false;
		}

		public bool IsContains(IUnityObjectBase asset)
		{
			return asset == m_asset;
		}

		public long GetExportID(IUnityObjectBase asset)
		{
			if (asset == m_asset)
			{
				return ExportIdHandler.GetMainExportID(m_asset);
			}
			throw new ArgumentException(nameof(asset));
		}

		public UnityGUID GetExportGUID(IUnityObjectBase _)
		{
			throw new NotSupportedException();
		}

		public MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			if (isLocal)
			{
				throw new ArgumentException(nameof(isLocal));
			}

			long exportId = GetExportID(asset);
			AssetType type = AssetExporter.ToExportType(asset);
			return new MetaPtr(exportId, UnityGUID.MissingReference, type);
		}

		public IAssetExporter AssetExporter { get; }
		public ISerializedFile File => m_asset.SerializedFile;
		public TransferInstructionFlags Flags => File.Flags;
		public IEnumerable<IUnityObjectBase> Assets
		{
			get { yield return m_asset; }
		}
		public string Name => m_asset is IHasNameString namedAsset ? namedAsset.GetNameNotEmpty() : m_asset.AssetClassName;

		private readonly IUnityObjectBase m_asset;
	}
}

```

`AssetRipperCommon/Project/Collections/ManagerExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_6;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public class ManagerExportCollection : AssetExportCollection
	{
		public ManagerExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset) : this(assetExporter, (GlobalGameManager)asset) { }

		public ManagerExportCollection(IAssetExporter assetExporter, GlobalGameManager asset) : base(assetExporter, asset) { }

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subPath = Path.Combine(dirPath, ProjectSettingsName);
			string name = GetCorrectName(Asset.AssetClassName);
			string fileName = $"{name}.asset";
			string filePath = Path.Combine(subPath, fileName);

			Directory.CreateDirectory(subPath);

			ExportInner(container, filePath, dirPath);
			return true;
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			if (asset == Asset)
			{
				return 1;
			}
			throw new ArgumentException(nameof(asset));
		}

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			throw new NotSupportedException();
		}

		private static string GetCorrectName(string typeName)
		{
			return typeName switch
			{
				PlayerSettingsName => ProjectSettingsName,
				NavMeshProjectSettingsName => NavMeshAreasName,
				PhysicsManagerName => DynamicsManagerName,
				_ => typeName,
			};
		}

		//Type names
		protected const string PlayerSettingsName = "PlayerSettings";
		protected const string NavMeshProjectSettingsName = "NavMeshProjectSettings";
		protected const string PhysicsManagerName = "PhysicsManager";

		//Altered names
		protected const string ProjectSettingsName = "ProjectSettings";
		protected const string NavMeshAreasName = "NavMeshAreas";
		protected const string DynamicsManagerName = "DynamicsManager";
	}
}

```

`AssetRipperCommon/Project/Collections/PrefabExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Project.Collections
{
	public sealed class PrefabExportCollection : AssetsExportCollection
	{
		public PrefabExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IUnityObjectBase asset) : this(assetExporter, virtualFile, GetAssetRoot(asset)) { }

		private PrefabExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IGameObject root) : this(assetExporter, root.SerializedFile, CreateVirtualPrefab(virtualFile, root)) { }

		private PrefabExportCollection(IAssetExporter assetExporter, IAssetContainer file, IPrefabInstance prefab) : base(assetExporter, prefab)
		{
			foreach (IEditorExtension asset in prefab.FetchObjects(file))
			{
				AddAsset(asset);

				//This section might not be necessary. This seems to be quite different from normal prefab files
				SetPrefabInstance(asset, prefab);
			}
		}

		private static void SetPrefabInstance(IEditorExtension asset, IPrefabInstance prefab)
		{
			if (asset is IGameObject gameObject)
			{
				if (gameObject.Has_PrefabInstance_C1())//2018.3 +
				{
					gameObject.PrefabInstance_C1.CopyValues(prefab.SerializedFile.CreatePPtr(prefab));
				}
				else if (gameObject.Has_PrefabAsset_C1())//3.5 +
				{
					gameObject.PrefabAsset_C1.CopyValues(prefab.SerializedFile.CreatePPtr(prefab));
				}
			}
			else if (asset is IComponent component)
			{

				if (component.Has_PrefabInstance_C2())//2018.3 +
				{
					component.PrefabInstance_C2.CopyValues(prefab.SerializedFile.CreatePPtr(prefab));
				}
				else if (component.Has_PrefabAsset_C2())//3.5 +
				{
					component.PrefabAsset_C2.CopyValues(prefab.SerializedFile.CreatePPtr(prefab));
				}
			}
		}

		public static bool IsValidAsset(IUnityObjectBase asset)
		{
			if (asset is IGameObject)
			{
				return true;
			}
			else if (asset is IComponent component)
			{
				return component.GameObject_C2.FindAsset(component.SerializedFile) is not null;
			}
			return false;
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return PrefabKeyword;
		}

		private static IGameObject GetAssetRoot(IUnityObjectBase asset)
		{
			if (asset is IGameObject gameObject)
			{
				return gameObject.GetRoot();
			}
			else if (asset is IComponent component)
			{
				return component.GetGameObject().GetRoot();
			}
			else
			{
				throw new NotSupportedException();
			}
		}
		public override ISerializedFile File => m_file;
		public override TransferInstructionFlags Flags => base.Flags | TransferInstructionFlags.SerializeForPrefabSystem;

		//This might not be necessary. 2019.4.3 doesn't use this in normally created prefabs
		private static IPrefabInstance CreateVirtualPrefab(VirtualSerializedFile virtualFile, IGameObject root)
		{
			IPrefabInstance instance = virtualFile.CreateAsset<IPrefabInstance>(ClassIDType.PrefabInstance);
			instance.RootGameObject_C1001?.CopyValues(root.SerializedFile.CreatePPtr(root));
			instance.IsPrefabAsset_C1001 = true;
			if (instance is IHasNameString hasName)
			{
				hasName.NameString = root.NameString;
			}
			return instance;
		}

#warning TODO:
		// HACK: prefab's assets may be stored in different files
		// Need to find a way to set a file for current asset nicely
		public override IEnumerable<IUnityObjectBase> Assets
		{
			get
			{
				m_file = m_exportIDs.Keys.First().File;
				yield return Asset;

				foreach (IUnityObjectBase asset in m_assets)
				{
					m_file = asset.SerializedFile;
					yield return asset;
				}
			}
		}

		public const string PrefabKeyword = "prefab";

		private ISerializedFile m_file;
	}
}

```

`AssetRipperCommon/Project/Collections/RawExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public class RawExportCollection : ExportCollection
	{
		IUnityObjectBase Asset { get; }
		public override IAssetExporter AssetExporter { get; }

		public RawExportCollection(IAssetExporter exporter, IUnityObjectBase asset)
		{
			Asset = asset;
			AssetExporter = exporter;
		}

		public override ISerializedFile File => Asset.SerializedFile;

		public override TransferInstructionFlags Flags => Asset.SerializedFile.Flags;

		public override IEnumerable<IUnityObjectBase> Assets
		{
			get { yield return Asset; }
		}

		private string AssetTypeName => Asset.GetType().Name;

		public override string Name => $"RawObject_{AssetTypeName}";

		protected override string GetExportExtension(IUnityObjectBase asset) => "bytes";

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			throw new NotSupportedException();
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subPath = Path.Combine(dirPath, "AssetRipper", "RawData", AssetTypeName);
			Directory.CreateDirectory(subPath);
			string fileName = GetUniqueFileName(container.File, Asset, subPath);
			string filePath = Path.Combine(subPath, fileName);
			return AssetExporter.Export(container, Asset, filePath);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			throw new NotSupportedException();
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return asset == Asset;
		}
	}
}

```

`AssetRipperCommon/Project/Collections/SceneExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_1030;
using AssetRipper.SourceGenerated.Classes.ClassID_1034;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_29;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Classes.ClassID_363;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;


namespace AssetRipper.Core.Project.Collections
{
	public sealed class SceneExportCollection : ExportCollection, IComparer<IUnityObjectBase>
	{
		public SceneExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, ISerializedFile file)
		{
			if (assetExporter == null)
			{
				throw new ArgumentNullException(nameof(assetExporter));
			}
			if (file == null)
			{
				throw new ArgumentNullException(nameof(file));
			}

			AssetExporter = assetExporter;
			Name = file.Name;
			m_file = file;

			List<IUnityObjectBase> components = new List<IUnityObjectBase>();
			foreach (IUnityObjectBase asset in file.FetchAssets())
			{
				if (IsSceneCompatible(asset))
				{
					components.Add(asset);
					m_exportIDs.Add(asset.AssetInfo, asset.PathID);
				}
			}
			m_components = components.OrderBy(t => t, this).ToArray();

			IOcclusionCullingSettings? sceneSettings = Components.Where(t => t is IOcclusionCullingSettings).Select(t => (IOcclusionCullingSettings)t).FirstOrDefault();
			if (sceneSettings != null)
			{
				GUID = sceneSettings.GUID;
			}
			if (GUID.IsZero)
			{
				GUID = UnityGUID.NewGuid();
			}

			foreach (IUnityObjectBase comp in Components)
			{
				if (comp is IOcclusionCullingSettings settings)
				{
					if (settings.PVSData_C29?.Length > 0)
					{
						m_occlusionCullingSettings = settings;
						break;
					}
				}
			}
		}

		/// <summary>
		/// Less than 5.3.0
		/// </summary>
		public static bool HasMainData(UnityVersion version) => version.IsLess(5, 3);

		public static string SceneIndexToFileName(int index, UnityVersion version)
		{
			if (HasMainData(version))
			{
				if (index == 0)
				{
					return MainSceneName;
				}
				return LevelName + (index - 1).ToString();
			}
			return LevelName + index.ToString();
		}

		public static int FileNameToSceneIndex(string name, UnityVersion version)
		{
			if (HasMainData(version))
			{
				if (name == MainSceneName)
				{
					return 0;
				}

				string indexStr = name.Substring(LevelName.Length);
				return int.Parse(indexStr) + 1;
			}
			else
			{
				string indexStr = name.Substring(LevelName.Length);
				return int.Parse(indexStr);
			}
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string folderPath = Path.Combine(dirPath, UnityObjectBase.AssetsKeyword, "Scene");
			string sceneSubPath = GetSceneName(container);
			string fileName = $"{sceneSubPath}.unity";
			string filePath = Path.Combine(folderPath, fileName);

			if (IsDuplicate(container))
			{
				if (System.IO.File.Exists(filePath))
				{
					Logger.Log(LogType.Warning, LogCategory.Export, $"Duplicate scene '{sceneSubPath}' has been found. Skipping");
					return false;
				}
			}

			folderPath = Path.GetDirectoryName(filePath)!;
			Directory.CreateDirectory(folderPath);

			AssetExporter.Export(container, Components.Select(t => Convert(t, container)), filePath);
			IDefaultImporter sceneImporter = DefaultImporterFactory.CreateAsset(container.ExportVersion);
			Meta meta = new Meta(GUID, sceneImporter);
			ExportMeta(container, meta, filePath);

			string sceneName = Path.GetFileName(sceneSubPath);
			string subFolderPath = Path.Combine(folderPath, sceneName);
			if (OcclusionCullingData is not null && m_occlusionCullingSettings is not null)
			{
				OcclusionCullingData.Initialize(container, m_occlusionCullingSettings);
				ExportAsset(container, OcclusionCullingData, subFolderPath);
			}

			return true;
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			if (asset == OcclusionCullingData)
			{
				return true;
			}
			return m_exportIDs.ContainsKey(asset.AssetInfo);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			return IsComponent(asset) ? m_exportIDs[asset.AssetInfo] : ExportIdHandler.GetMainExportID(asset);
		}

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			long exportID = GetExportID(asset);
			if (isLocal && IsComponent(asset))
			{
				return new MetaPtr(exportID);
			}
			else
			{
				UnityGUID guid = IsComponent(asset) ? GUID : asset.GUID;
				return new MetaPtr(exportID, guid, AssetType.Serialized);
			}
		}

		public int Compare(IUnityObjectBase? obj1, IUnityObjectBase? obj2)
		{
			if (obj1?.ClassID == obj2?.ClassID)
			{
				return 0;
			}

			if (obj1 is ILevelGameManager)
			{
				if (obj2 is ILevelGameManager)
				{
					return obj1.ClassID < obj2.ClassID ? -1 : 1;
				}
				else
				{
					return -1;
				}
			}
			else if (obj2 is ILevelGameManager)
			{
				return 1;
			}
			else
			{
				return 0;
			}
		}

		private void ExportAsset(IProjectAssetContainer container, IHasNameString asset, string path)
		{
			INativeFormatImporter importer = NativeFormatImporterFactory.CreateAsset(container.ExportVersion);
			importer.MainObjectFileID_C1034 = GetExportID((IUnityObjectBase)asset);
			ExportAsset(container, importer, (IUnityObjectBase)asset, path, asset.NameString);
		}

		private bool IsComponent(IUnityObjectBase asset)
		{
			return asset != OcclusionCullingData;
		}

		private string GetSceneName(IExportContainer container)
		{
			if (IsSceneName)
			{
				int index = FileNameToSceneIndex(Name, File.Version);
				string scenePath = container.SceneIndexToName(index);
				if (scenePath.StartsWith(AssetsName, StringComparison.Ordinal))
				{
					string extension = Path.GetExtension(scenePath);
					return scenePath.Substring(AssetsName.Length, scenePath.Length - AssetsName.Length - extension.Length);
				}
				else if (Path.IsPathRooted(scenePath))
				{
					// pull/617
					// NOTE: absolute project path may contain Assets/ in its name so in this case we get incorrect scene path, but there is no way to bypass this issue
					int assetIndex = scenePath.IndexOf(AssetsName);
					string extension = Path.GetExtension(scenePath);
					return scenePath.Substring(assetIndex + AssetsName.Length, scenePath.Length - assetIndex - AssetsName.Length - extension.Length);
				}
				else if (scenePath.Length == 0)
				{
					// if you build a game without included scenes, Unity create one with empty name
					return Name;
				}
				else
				{
					return scenePath;
				}
			}
			return Name;
		}

		private bool IsDuplicate(IExportContainer container)
		{
			if (IsSceneName)
			{
				int index = FileNameToSceneIndex(Name, File.Version);
				return container.IsSceneDuplicate(index);
			}
			return false;
		}

		private bool IsSceneName => Name == MainSceneName || s_sceneNameFormat.IsMatch(Name);

		public override IAssetExporter AssetExporter { get; }
		public override IEnumerable<IUnityObjectBase> Assets
		{
			get
			{
				foreach (IUnityObjectBase asset in Components)
				{
					yield return asset;
				}
				if (OcclusionCullingData != null)
				{
					yield return OcclusionCullingData;
				}
			}
		}

		/// <summary>
		/// GameObject, Classes Inherited From Level Game Manager, Monobehaviours with GameObjects, Components
		/// </summary>
		public static bool IsSceneCompatible(IUnityObjectBase asset)
		{
			if (asset is IGameObject)
			{
				return true;
			}
			if (asset is ILevelGameManager)
			{
				return true;
			}
			if (asset is IMonoBehaviour monoBeh)
			{
				if (!monoBeh.IsSceneObject())
				{
					return false;
				}
			}

			return asset is IComponent;
		}

		public override string Name { get; }
		public override ISerializedFile File => m_file;

		public IOcclusionCullingData? OcclusionCullingData { get; }
		public UnityGUID GUID { get; }

		private IEnumerable<IUnityObjectBase> Components => m_components;

		private const string AssetsName = "Assets/";
		private const string LevelName = "level";
		private const string MainSceneName = "maindata";

		private static readonly Regex s_sceneNameFormat = new Regex($"^{LevelName}(0|[1-9][0-9]*)$");

		private readonly IUnityObjectBase[] m_components;
		private readonly Dictionary<AssetInfo, long> m_exportIDs = new Dictionary<AssetInfo, long>();
		private readonly ISerializedFile m_file;
		private readonly IOcclusionCullingSettings? m_occlusionCullingSettings;
	}
}

```

`AssetRipperCommon/Project/Collections/SkipExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Project.Collections
{
	public sealed class SkipExportCollection : IExportCollection
	{
		public SkipExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset)
		{
			AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
			m_asset = asset ?? throw new ArgumentNullException(nameof(asset));
		}

		public bool Export(IProjectAssetContainer container, string dirPath)
		{
			return false;
		}

		public bool IsContains(IUnityObjectBase asset)
		{
			return asset == m_asset;
		}

		public long GetExportID(IUnityObjectBase asset)
		{
			if (asset == m_asset)
			{
				return ExportIdHandler.GetMainExportID(m_asset);
			}
			throw new ArgumentException(nameof(asset));
		}

		public UnityGUID GetExportGUID(IUnityObjectBase _)
		{
			throw new NotSupportedException();
		}

		public MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			if (isLocal)
			{
				throw new ArgumentException(nameof(isLocal));
			}

			long exportId = GetExportID(asset);
			AssetType type = AssetExporter.ToExportType(asset);
			return new MetaPtr(exportId, UnityGUID.MissingReference, type);
		}

		public IAssetExporter AssetExporter { get; }
		public ISerializedFile File => m_asset.SerializedFile;
		public TransferInstructionFlags Flags => File.Flags;
		public IEnumerable<IUnityObjectBase> Assets => Enumerable.Empty<IUnityObjectBase>();
		public string Name => m_asset.GetType().Name;

		private readonly IUnityObjectBase m_asset;
	}
}

```

`AssetRipperCommon/Project/Collections/UnknownExportCollection.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public sealed class UnknownExportCollection : ExportCollection
	{
		UnknownObject Asset { get; }
		public override IAssetExporter AssetExporter { get; }

		public UnknownExportCollection(IAssetExporter exporter, UnknownObject asset)
		{
			Asset = asset;
			AssetExporter = exporter;
		}

		public override ISerializedFile File => Asset.SerializedFile;

		public override TransferInstructionFlags Flags => Asset.SerializedFile.Flags;

		public override IEnumerable<IUnityObjectBase> Assets
		{
			get { yield return Asset; }
		}

		public override string Name => $"UnknownObject_{Asset.ClassID}";

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			throw new NotSupportedException();
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subFolder = Asset.ExportPath;
			string subPath = Path.Combine(dirPath, subFolder);
			Directory.CreateDirectory(subPath);
			string fileName = GetUniqueFileName(container.File, Asset, subPath);
			string filePath = Path.Combine(subPath, fileName);
			return AssetExporter.Export(container, Asset, filePath);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			throw new NotSupportedException();
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return asset == Asset;
		}
	}
}

```

`AssetRipperCommon/Project/Collections/UnreadableExportCollection.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Collections
{
	public class UnreadableExportCollection : ExportCollection
	{
		UnreadableObject Asset { get; }
		public override IAssetExporter AssetExporter { get; }

		public UnreadableExportCollection(IAssetExporter exporter, UnreadableObject asset)
		{
			Asset = asset;
			AssetExporter = exporter;
		}

		public override ISerializedFile File => Asset.SerializedFile;

		public override TransferInstructionFlags Flags => Asset.SerializedFile.Flags;

		public override IEnumerable<IUnityObjectBase> Assets
		{
			get { yield return Asset; }
		}

		public override string Name => string.IsNullOrWhiteSpace(Asset.NameString) ? $"UnreadableObject_{Asset.ClassID}" : $"UnreadableObject_{Asset.NameString}";

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			throw new NotSupportedException();
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			string subFolder = Asset.ExportPath;
			string subPath = Path.Combine(dirPath, subFolder);
			Directory.CreateDirectory(subPath);
			string fileName = GetUniqueFileName(container.File, Asset, subPath);
			string filePath = Path.Combine(subPath, fileName);
			return AssetExporter.Export(container, Asset, filePath);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			throw new NotSupportedException();
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return asset == Asset;
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/BinaryAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Exporters
{
	public class BinaryAssetExporter : IAssetExporter
	{
		public virtual bool IsHandle(IUnityObjectBase asset)
		{
			return true;
		}

		public virtual bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			throw new NotSupportedException();
		}

		public virtual void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			Export(container, asset, path);
			callback?.Invoke(container, asset, path);
		}

		public virtual bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			throw new NotSupportedException();
		}

		public virtual void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException();
		}

		public virtual IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AssetExportCollection(this, asset);
		}

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			return AssetType.Meta;
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Meta;
			return true;
		}

		protected static bool IsValidData(byte[]? data) => data != null && data.Length > 0;
	}
}

```

`AssetRipperCommon/Project/Exporters/BuildSettingsExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_141;

namespace AssetRipper.Core.Project.Exporters
{
	public class BuildSettingsExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IBuildSettings;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new BuildSettingsExportCollection(this, virtualFile, asset);
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/DefaultYamlExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Core.Project.Exporters
{
	public class DefaultYamlExporter : YamlExporterBase
	{
		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AssetExportCollection(this, asset);
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/DummyAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Exporters
{
	public class DummyAssetExporter : IAssetExporter
	{
		public void SetUpClassType(ClassIDType classType, bool isEmptyCollection, bool isMetaType)
		{
			m_emptyTypes[classType] = isEmptyCollection;
			m_metaTypes[classType] = isMetaType;
		}

		public bool IsHandle(IUnityObjectBase asset)
		{
			return true;
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			throw new NotSupportedException();
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException();
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			throw new NotSupportedException();
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException();
		}

		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			if (m_emptyTypes.TryGetValue(asset.ClassID, out bool isEmptyCollection))
			{
				if (isEmptyCollection)
				{
					return new EmptyExportCollection();
				}
				else
				{
					return new SkipExportCollection(this, asset);
				}
			}
			else
			{
				throw new NotSupportedException(asset.ClassID.ToString());
			}
		}

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			ToUnknownExportType(asset.ClassID, out AssetType assetType);
			return assetType;
		}

		public bool ToUnknownExportType(ClassIDType classID, out AssetType assetType)
		{
			if (m_metaTypes.TryGetValue(classID, out bool isMetaType))
			{
				assetType = isMetaType ? AssetType.Meta : AssetType.Serialized;
				return true;
			}
			else
			{
				throw new NotSupportedException(classID.ToString());
			}
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			ClassIDType classID = VersionHandling.VersionManager.AssetFactory.GetClassIdForType(type);
			return ToUnknownExportType(classID, out assetType);
		}

		private readonly Dictionary<ClassIDType, bool> m_emptyTypes = new Dictionary<ClassIDType, bool>();
		private readonly Dictionary<ClassIDType, bool> m_metaTypes = new Dictionary<ClassIDType, bool>();
	}
}

```

`AssetRipperCommon/Project/Exporters/Engine/EngineAssetExporter.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Exporters.Engine
{
	public class EngineAssetExporter : IAssetExporter
	{
		private UnityVersion Version { get; }
		public EngineAssetExporter(CoreConfiguration configuration) => Version = configuration.Version;

		public bool IsHandle(IUnityObjectBase asset)
		{
			return EngineExportCollection.IsEngineAsset(asset, Version);
		}

		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new EngineExportCollection(asset, virtualFile.Version);
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			throw new NotSupportedException();
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException();
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			throw new NotSupportedException();
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException();
		}

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			return AssetType.Internal;
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Internal;
			return false;
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/Engine/EngineBuiltInAsset.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Asset;

namespace AssetRipper.Core.Project.Exporters.Engine
{
	public struct EngineBuiltInAsset
	{
		public EngineBuiltInAsset(uint exportID, uint parameter, bool isF)
		{
			ExportID = exportID;
			Parameter = parameter;
			m_isF = isF;
		}

		public MetaPtr ToExportPointer()
		{
			return new MetaPtr(ExportID, GUID, AssetType.Internal);
		}

		public UnityGUID GUID => m_isF ? EngineBuiltInAssets.FGUID : EngineBuiltInAssets.EGUID;

		public bool IsValid => ExportID != 0;
		public uint ExportID { get; }
		public uint Parameter { get; }

		/// <summary>
		///  Is assets located in DefaultResources file
		/// </summary>
		private readonly bool m_isF;
	}
}

```

`AssetRipperCommon/Project/Exporters/Engine/EngineBuiltInAssetInfo.cs`:

```cs
using System.Collections.Generic;


namespace AssetRipper.Core.Project.Exporters.Engine
{
	internal struct EngineBuiltInAssetInfo
	{
		public EngineBuiltInAssetInfo(UnityVersion version, EngineBuiltInAsset asset)
		{
			KeyValuePair<UnityVersion, EngineBuiltInAsset> kvp = new KeyValuePair<UnityVersion, EngineBuiltInAsset>(version, asset);
			m_variations = new List<KeyValuePair<UnityVersion, EngineBuiltInAsset>>(1);
			m_variations.Add(kvp);
		}

		public void AddVariation(UnityVersion version, EngineBuiltInAsset asset)
		{
			KeyValuePair<UnityVersion, EngineBuiltInAsset> kvp = new KeyValuePair<UnityVersion, EngineBuiltInAsset>(version, asset);
			for (int i = 0; i < m_variations.Count; i++)
			{
				UnityVersion key = m_variations[i].Key;
				if (key < version)
				{
					m_variations.Insert(i, kvp);
					return;
				}
			}
			m_variations.Add(kvp);
		}

		public bool ContainsAsset(UnityVersion version)
		{
			foreach (KeyValuePair<UnityVersion, EngineBuiltInAsset> kvp in m_variations)
			{
				if (version >= kvp.Key)
				{
					return true;
				}
			}
			return false;
		}

		public EngineBuiltInAsset GetAsset(UnityVersion version)
		{
			foreach (KeyValuePair<UnityVersion, EngineBuiltInAsset> kvp in m_variations)
			{
				if (version >= kvp.Key)
				{
					return kvp.Value;
				}
			}
			throw new Exception($"There is no asset for {version} version");
		}

		public bool TryGetAsset(UnityVersion version, out EngineBuiltInAsset asset)
		{
			foreach (KeyValuePair<UnityVersion, EngineBuiltInAsset> kvp in m_variations)
			{
				if (version >= kvp.Key)
				{
					asset = kvp.Value;
					return true;
				}
			}
			asset = default;
			return false;
		}

		private readonly List<KeyValuePair<UnityVersion, EngineBuiltInAsset>> m_variations;
	}
}

```

`AssetRipperCommon/Project/Exporters/Engine/EngineBuiltInAssets.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using System.Collections.Generic;


namespace AssetRipper.Core.Project.Exporters.Engine
{
	public static class EngineBuiltInAssets
	{
		static EngineBuiltInAssets()
		{
			///////////////////////////////////////////////////////
			// New extra
			///////////////////////////////////////////////////////

			AddShader("Autodesk Interactive", 47, true);
			AddShader("Legacy Shaders/Particles/Additive", 200, true);
			AddShader("Legacy Shaders/Particles/~Additive-Multiply", 201, true);
			AddShader("Legacy Shaders/Particles/Additive (Soft)", 202, true);
			AddShader("Legacy Shaders/Particles/Alpha Blended", 203, true);
			AddShader("Legacy Shaders/Particles/Multiply", 205, true);
			AddShader("Legacy Shaders/Particles/Multiply (Double)", 206, true);
			AddShader("Legacy Shaders/Particles/Alpha Blended Premultiply", 207, true);
			AddShader("Legacy Shaders/Particles/VertexLit Blended", 208, true);
			AddShader("Legacy Shaders/Particles/Anim Alpha Blended", 209, true);
			AddShader("Mobile/Bumped Specular (1 Directional Realtime Light)", 10706, true);
			AddShader("Hidden/VideoComposite", new UnityVersion(2019), 16000, true);
			AddShader("Hidden/VideoDecode", new UnityVersion(2019), 16001, true);
			AddShader("Hidden/VideoDecodeOSX", new UnityVersion(2019), 16002, true);
			AddShader("Hidden/VideoDecodeAndroid", new UnityVersion(2019), 16003, true);
			AddShader("Hidden/VideoDecodeML", new UnityVersion(2019), 16004, true);

			///////////////////////////////////////////////////////
			// Current default
			///////////////////////////////////////////////////////

			AddMaterial(FontMaterialName, 10100, false);
			AddMaterial("FrameDebuggerRenderTargetDisplay", 10756, true);

			AddTexture("Soft", 10001, false);
			AddTexture("Font Texture", 10103, false);
			AddTexture("UnityWatermark-small", 10400, false);
			AddTexture("EscToExit_back", 10401, false);
			AddTexture("EscToExit_Text", 10402, false);
			AddTexture("UnitySplash-cube", 10403, false);
			AddTexture("UnityWatermark-trial-big", 10406, false);
			AddTexture("UnityWatermark-trial", 10407, false);
			AddTexture("UnityWatermark-beta", 10408, false);
			AddTexture("UnityWatermark-edu", 10409, false);
			AddTexture("UnityWatermark-dev", 10410, false);
			AddTexture("WarningSign", 10411, false);
			AddTexture("UnityWatermark-proto", 10413, false);
			AddTexture("UnityWatermarkPlugin-beta", 10414, false);
			AddTexture("box", 11001, false);
			AddTexture("button active", 11002, false);
			AddTexture("button hover", 11003, false);
			AddTexture("button on hover", 11004, false);
			AddTexture("button on", 11005, false);
			AddTexture("button", 11006, false);
			AddTexture("horizontal scrollbar thumb", 11007, false);
			AddTexture("horizontal scrollbar", 11008, false);
			AddTexture("horizontalslider", 11009, false);
			AddTexture("slider thumb active", 11010, false);
			AddTexture("slider thumb", 11011, false);
			AddTexture("slidert humb hover", 11012, false);
			AddTexture("toggle active", 11013, false);
			AddTexture("toggle hover", 11014, false);
			AddTexture("toggle on hover", 11015, false);
			AddTexture("toggle on", 11016, false);
			AddTexture("toggle on active", 11017, false);
			AddTexture("toggle", 11018, false);
			AddTexture("vertical scrollbar thumb", 11019, false);
			AddTexture("vertical scrollbar", 11020, false);
			AddTexture("verticalslider", 11021, false);
			AddTexture("window on", 11022, false);
			AddTexture("window", 11023, false);
			AddTexture("textfield", 11024, false);
			AddTexture("textfield on", 11025, false);
			AddTexture("textfield hover", 11026, false);
			AddTexture("UnitySplash-HolographicTrackingLoss", 15000, false);

			AddMesh("pSphere1", 10200, false);
			AddMesh("Cube", 10202, false);
			AddMesh("pCylinder1", 10203, false);
			AddMesh("pPlane1", 10204, false);
			AddMesh("polySurface2", 10205, false);
			AddMesh("Cylinder", 10206, false);
			AddMesh("Sphere", 10207, false);
			AddMesh("Capsule", 10208, false);
			AddMesh("Plane", 10209, false);
			AddMesh("Quad", 10210, false);
			AddMesh("Icosphere", 10211, false);
			AddMesh("icosahedron", 10212, false);
			AddMesh("pyramid", 10213, false);

			AddFont("Arial", 10102, false);

			AddShader("Hidden/InternalErrorShader", 17, true);
			AddShader("Hidden/InternalClear", 68, false);
			AddShader("Hidden/Internal-Colored", 69, false);
			AddShader("GUI/Text Shader", 10101, false);
			AddShader("Hidden/FrameDebuggerRenderTargetDisplay", 10755, false);

			AddSprite("UnitySplash-cube", 10404, false);

			///////////////////////////////////////////////////////
			// Current extra
			///////////////////////////////////////////////////////

			AddMaterial("Default-Particle", 10301, true);
			AddMaterial("Default-Diffuse", 10302, true);
			AddMaterial("Default-Material", 10303, true);
			AddMaterial("Default-Skybox", 10304, true);
			AddMaterial("Default-Line", 10306, true);
			AddMaterial("Default-ParticleSystem", 10308, true);
			AddMaterial(DefaultTerrainDiffuseName, 10650, true);
			AddMaterial(DefaultTerrainSpecularName, 10651, true);
			AddMaterial(DefaultTerrainStandardName, 10652, true);
			AddMaterial("Sprites-Default", 10754, false);
			AddMaterial("Sprites-Mask", 10758, false);
			AddMaterial("SpatialMappingOcclusion", 15302, true);
			AddMaterial("SpatialMappingWireframe", 15303, true);

			AddTexture("Default-Particle", 10300, true);
			AddTexture("Default-Checker", 10305, true);
			AddTexture("Default-ParticleSystem", 10307, true);
			AddTexture("Default-Checker-Gray", 10309, true);
			AddTexture("Checkmark", 10900, true);
			AddTexture("UISprite", UnityVersion.MinVersion, 10904, 5460, true);
			AddTexture("Background", 10906, true);
			AddTexture("InputFieldBackground", 10910, true);
			AddTexture("Knob", 10912, true);
			AddTexture("DropdownArrow", 10914, true);
			AddTexture("UIMask", 10916, true);

			AddShader("Legacy Shaders/Diffuse Fast", 1, true);
			AddShader("Legacy Shaders/Bumped Diffuse", 2, true);
			AddShader("Legacy Shaders/Specular", 3, true);
			AddShader("Legacy Shaders/Bumped Specular", 4, true);
			AddShader("Legacy Shaders/Diffuse Detail", 5, true);
			AddShader("Legacy Shaders/VertexLit", 6, true);
			AddShader(LegacyDiffuse, 7, true);
			AddShader("Legacy Shaders/Parallax Diffuse", 8, true);
			AddShader("Legacy Shaders/Parallax Specular", 9, true);
			AddShader("Legacy Shaders/Self-Illumin/Diffuse", 10, true);
			AddShader("Legacy Shaders/Self-Illumin/Bumped Diffuse", 11, true);
			AddShader("Legacy Shaders/Self-Illumin/Specular", 12, true);
			AddShader("Legacy Shaders/Self-Illumin/Bumped Specular", 13, true);
			AddShader("Legacy Shaders/Self-Illumin/VertexLit", 14, true);
			AddShader("Legacy Shaders/Self-Illumin/Parallax Diffuse", 15, true);
			AddShader("Legacy Shaders/Self-Illumin/Parallax Specular", 16, true);
			AddShader("Hidden/Internal-StencilWrite", 19, true);
			AddShader("Legacy Shaders/Reflective/Diffuse", 20, true);
			AddShader("Legacy Shaders/Reflective/Bumped Diffuse", 21, true);
			AddShader("Legacy Shaders/Reflective/Specular", 22, true);
			AddShader("Legacy Shaders/Reflective/Bumped Specular", 23, true);
			AddShader("Legacy Shaders/Reflective/VertexLit", 24, true);
			AddShader("Legacy Shaders/Reflective/Bumped Unlit", 25, true);
			AddShader("Legacy Shaders/Reflective/Bumped VertexLit", 26, true);
			AddShader("Legacy Shaders/Reflective/Parallax Diffuse", 27, true);
			AddShader("Legacy Shaders/Reflective/Parallax Specular", 28, true);
			AddShader("Legacy Shaders/Transparent/Diffuse", 30, true);
			AddShader("Legacy Shaders/Transparent/Bumped Diffuse", 31, true);
			AddShader("Legacy Shaders/Transparent/Specular", 32, true);
			AddShader("Legacy Shaders/Transparent/Bumped Specular", 33, true);
			AddShader("Legacy Shaders/Transparent/VertexLit", 34, true);
			AddShader("Legacy Shaders/Transparent/Parallax Diffuse", 35, true);
			AddShader("Legacy Shaders/Transparent/Parallax Specular", 36, true);
			AddShader("Legacy Shaders/Lightmapped/VertexLit", 40, true);
			AddShader("Legacy Shaders/Lightmapped/Diffuse", 41, true);
			AddShader("Legacy Shaders/Lightmapped/Bumped Diffuse", 42, true);
			AddShader("Legacy Shaders/Lightmapped/Specular", 43, true);
			AddShader("Legacy Shaders/Lightmapped/Bumped Specular", 44, true);
			AddShader("Standard (Specular setup)", 45, true);
			AddShader("Standard", 46, true);
			AddShader("Standard (Roughness setup)", 47, true);
			AddShader("Legacy Shaders/Transparent/Cutout/VertexLit", 50, true);
			AddShader("Legacy Shaders/Transparent/Cutout/Diffuse", 51, true);
			AddShader("Legacy Shaders/Transparent/Cutout/Bumped Diffuse", 52, true);
			AddShader("Legacy Shaders/Transparent/Cutout/Specular", 53, true);
			AddShader("Legacy Shaders/Transparent/Cutout/Bumped Specular", 54, true);
			AddShader("Hidden/Internal-DepthNormalsTexture", 62, true);
			AddShader("Hidden/Internal-PrePassLighting", 63, true);
			AddShader("Hidden/Internal-ScreenSpaceShadows", 64, true);
			AddShader("Hidden/Internal-CombineDepthNormals", 65, true);
			AddShader("Hidden/BlitCopy", 66, true);
			AddShader("Hidden/BlitCopyDepth", 67, true);
			AddShader("Hidden/ConvertTexture", 68, true);
			AddShader("Hidden/Internal-DeferredShading", 69, true);
			AddShader("Hidden/Internal-DeferredReflections", 74, true);
			AddShader("Hidden/Internal-MotionVectors", 75, true);
			AddShader("Legacy Shaders/Decal", 100, true);
			AddShader("FX/Flare", 101, true);
			AddShader("Hidden/Internal-Flare", 102, true);
			AddShader("Skybox/Cubemap", 103, true);
			AddShader("Skybox/6 Sided", 104, true);
			AddShader("Hidden/Internal-Halo", 105, true);
			AddShader("Skybox/Procedural", 106, true);
			AddShader("Hidden/BlitCopyWithDepth", 107, true);
			AddShader("Skybox/Panoramic", 108, true);
			AddShader("Hidden/BlitToDepth", 109, true);
			AddShader("Hidden/BlitToDepth_MSAA", 110, true);
			AddShader("Particles/Additive", 200, true);
			AddShader("Particles/~Additive-Multiply", 201, true);
			AddShader("Particles/Additive (Soft)", 202, true);
			AddShader("Particles/Alpha Blended", 203, true);
			AddShader("Particles/Multiply", 205, true);
			AddShader("Particles/Multiply (Double)", 206, true);
			AddShader("Particles/Alpha Blended Premultiply", 207, true);
			AddShader("Particles/VertexLit Blended", 208, true);
			AddShader("Particles/Anim Alpha Blended", 209, true);
			AddShader("Particles/Standard Surface", 210, true);
			AddShader("Particles/Standard Unlit", 211, true);
			AddShader("Hidden/Internal-GUITextureClip", 9000, true);
			AddShader("Hidden/Internal-GUITextureClipText", 9001, true);
			AddShader("Hidden/Internal-GUITexture", 9002, true);
			AddShader("Hidden/Internal-GUITextureBlit", 9003, true);
			AddShader("Hidden/Internal-GUIRoundedRect", 9004, true);
			AddShader("Hidden/Internal-UIRDefault", 9005, true);
			AddShader("Hidden/Internal-UIRAtlasBlitCopy", 9006, true);
			AddShader("Hidden/Internal-GUIRoundedRectWithColorPerBorder", 9007, true);
			AddShader("Hidden/Nature/Terrain/Utilities", 10490, true);
			AddShader("Hidden/TerrainEngine/Details/Vertexlit", 10500, true);
			AddShader("Hidden/TerrainEngine/Details/WavingDoublePass", 10501, true);
			AddShader(TerrainBillboardWavingDoublePass, 10502, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Diffuse-AddPass", 10503, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Diffuse-Base", 10504, true);
			AddShader("Nature/Terrain/Diffuse", 10505, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Diffuse-BaseGen", 10506, true);
			AddShader("Hidden/TerrainEngine/BillboardTree", 10507, true);
			AddShader("Hidden/Nature/Tree Soft Occlusion Bark Rendertex", 10508, true);
			AddShader("Nature/Tree Soft Occlusion Bark", 10509, true);
			AddShader("Hidden/Nature/Tree Soft Occlusion Leaves Rendertex", 10510, true);
			AddShader("Nature/Tree Soft Occlusion Leaves", 10511, true);
			AddShader("Legacy Shaders/Transparent/Cutout/Soft Edge Unlit", 10512, true);
			AddShader("Hidden/TerrainEngine/CameraFacingBillboardTree", 10513, true);
			AddShader("Nature/Tree Creator Bark", 10600, true);
			AddShader("Nature/Tree Creator Leaves", 10601, true);
			AddShader("Hidden/Nature/Tree Creator Bark Rendertex", 10602, true);
			AddShader("Hidden/Nature/Tree Creator Leaves Rendertex", 10603, true);
			AddShader("Hidden/Nature/Tree Creator Bark Optimized", 10604, true);
			AddShader("Hidden/Nature/Tree Creator Leaves Optimized", 10605, true);
			AddShader("Nature/Tree Creator Leaves Fast", 10606, true);
			AddShader("Hidden/Nature/Tree Creator Leaves Fast Optimized", 10607, true);
			AddShader("Hidden/Nature/Tree Creator Albedo Rendertex", 10608, true);
			AddShader("Hidden/Nature/Tree Creator Normal Rendertex", 10609, true);
			AddShader("Nature/Terrain/Specular", 10620, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Specular-AddPass", 10621, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Specular-Base", 10622, true);
			AddShader("Nature/Terrain/Standard", 10623, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Standard-AddPass", 10624, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Standard-Base", 10625, true);
			AddShader("Hidden/TerrainEngine/Splatmap/Standard-BaseGen", 10626, true);
			AddShader("Mobile/Skybox", 10700, true);
			AddShader("Mobile/VertexLit", 10701, true);
			AddShader("Mobile/Diffuse", 10703, true);
			AddShader("Mobile/Bumped Diffuse", 10704, true);
			AddShader("Mobile/Bumped Specular", 10705, true);
			AddShader("Mobile/Bumped Specular (1 Directional Light)", 10706, true);
			AddShader("Mobile/VertexLit (Only Directional Lights)", 10707, true);
			AddShader("Mobile/Unlit (Supports Lightmap)", 10708, true);
			AddShader("Mobile/Particles/Additive", 10720, true);
			AddShader("Mobile/Particles/Alpha Blended", 10721, true);
			AddShader("Mobile/Particles/VertexLit Blended", 10722, true);
			AddShader("Mobile/Particles/Multiply", 10723, true);
			AddShader("Unlit/Transparent", 10750, true);
			AddShader("Unlit/Transparent Cutout", 10751, true);
			AddShader("Unlit/Texture", 10752, true);
			AddShader(SpriteDefault, 10753, true);
			AddShader("Unlit/Color", 10755, true);
			AddShader("Sprites/Mask", 10757, true);
			AddShader("UI/Unlit/Transparent", 10760, true);
			AddShader("UI/Unlit/Detail", 10761, true);
			AddShader("UI/Unlit/Text", 10762, true);
			AddShader("UI/Unlit/Text Detail", 10763, true);
			AddShader("UI/Lit/Transparent", 10764, true);
			AddShader("UI/Lit/Bumped", 10765, true);
			AddShader("UI/Lit/Detail", 10766, true);
			AddShader("UI/Lit/Refraction", 10767, true);
			AddShader("UI/Lit/Refraction Detail", 10768, true);
			AddShader(UIDefault, 10770, true);
			AddShader("UI/Default Font", 10782, true);
			AddShader("UI/DefaultETC1", 10783, true);
			AddShader("Hidden/UI/CompositeOverdraw", 10784, true);
			AddShader("Hidden/UI/Overdraw", 10785, true);
			AddShader("Sprites/Diffuse", 10800, true);
			AddShader("Nature/SpeedTree", 14000, true);
			AddShader("Nature/SpeedTree Billboard", 14001, true);
			AddShader("Nature/SpeedTree8", 14002, true);
			AddShader("Hidden/GIDebug/TextureUV", 15100, true);
			AddShader("Hidden/GIDebug/ShowLightMask", 15101, true);
			AddShader("Hidden/GIDebug/UV1sAsPositions", 15102, true);
			AddShader("Hidden/GIDebug/VertexColors", 15103, true);
			AddShader(CubeBlur, 15104, true);
			AddShader(CubeCopy, 15105, true);
			AddShader(CubeBlend, 15106, true);
			AddShader("VR/SpatialMapping/Occlusion", 15300, true);
			AddShader("VR/SpatialMapping/Wireframe", 15301, true);
			AddShader("Hidden/VR/BlitCopyFromTexArray", 15304, true);
			AddShader("Hidden/VR/BlitTexArraySlice", 15304, true);
			AddShader("Hidden/VR/Internal-VRDistortion", 15305, true);
			AddShader("Hidden/VR/BlitTexArraySliceToDepth", 15306, true);
			AddShader("Hidden/VR/BlitTexArraySliceToDepth_MSAA", 15307, true);
			AddShader("Hidden/Internal-ODSWorldTexture", 15308, true);
			AddShader("Hidden/Internal-CubemapToEquirect", 15309, true);
			AddShader("Hidden/VR/ClippingMask", 15310, true);
			AddShader("Hidden/VR/VideoBackground", 15311, true);
			AddShader("Hidden/VR/BlitFromTex2DToTexArraySlice", 15312, true);
			AddShader("AR/TangoARRender", 15401, true);
			AddShader("Hidden/VideoDecode", 16000, true);
			AddShader("Hidden/VideoDecodeOSX", 16001, true);
			AddShader("Hidden/VideoDecodeAndroid", 16002, true);
			AddShader("Hidden/Compositing", 17000, true);
			AddShader("Hidden/TerrainEngine/PaintHeight", 18000, true);
			AddShader("Hidden/TerrainEngine/HeightBlitCopy", 18001, true);
			AddShader("Hidden/TerrainEngine/GenerateNormalmap", 18002, true);
			AddShader("Hidden/TerrainEngine/TerrainLayerUtils", 18003, true);
			AddShader("Hidden/TerrainEngine/BrushPreview", 18004, true);
			AddShader("Hidden/TerrainEngine/CrossBlendNeighbors", 18005, true);
			AddShader("Hidden/TextCore/Distance Field", 19010, true);
			AddShader("Hidden/TextCore/Distance Field SSD", 19011, true);

			AddSprite("Checkmark", 10901, true);
			AddSprite("UISprite", 10905, true);
			AddSprite("Background", 10907, true);
			AddSprite("InputFieldBackground", 10911, true);
			AddSprite("Knob", 10913, true);
			AddSprite("DropdownArrow", 10915, true);
			AddSprite("UIMask", 10917, true);

			AddLightmapParams("Default-HighResolution", 15200, true);
			AddLightmapParams("Default-LowResolution", 15201, true);
			AddLightmapParams("Default-VeryLowResolution", 15203, true);
			AddLightmapParams("Default-Medium", 15204, true);

			AddBehaviour("GameSkin", 11000, false);

			///////////////////////////////////////////////////////
			// Old default
			///////////////////////////////////////////////////////

			AddTexture("UnitySplash", 10403, false);
			AddTexture("UnitySplash2", 10404, false);
			AddTexture("UnitySplash-text", 10404, false);
			AddTexture("UnitySplash3", 10405, false);
			AddTexture("UnitySplash-free", 10405, false);
			AddTexture("UnitySplashBack", 10406, false);
			AddTexture("UnityWatermark-DebugFlashPlayer", 10412, false);
			AddTexture("UnitySplashVRLogo", 10415, false);
			AddTexture("UnitySplashVRPoweredBy", 10416, false);

			AddShader("Internal-ErrorShader", 17, true);
			AddShader("Shadow-ScreenBlur", 60, false);
			AddShader("Camera-DepthTexture", 61, false);
			AddShader("Camera-DepthNormalTexture", 62, false);
			AddShader("Internal-PrePassLighting", 63, false);
			AddShader("Internal-PrePassCollectShadows", 64, false);
			AddShader("Internal-CombineDepthNormals", 65, false);
			AddShader("Internal-BlitCopy", 66, false);
			AddShader("Shadow-ScreenBlurRotated", 67, false);
			AddShader("Internal-Clear", 68, false);
			AddShader("Internal-Colored", 69, false);
			AddShader("Internal-SplashShadowCaster", 70, false);
			AddShader("Internal-SplashShadowBlur", 71, false);
			AddShader("Internal-SplashShadowReceiver", 72, false);
			AddShader("Internal-SplashShadowReceiverSimple", 73, false);
			AddShader("Internal-Flare", 102, true);
			AddShader("Internal-Halo", 105, true);
			AddShader("Internal-GUITextureClip", 9000, true);
			AddShader("Internal-GUITextureClipText", 9001, true);
			AddShader("Internal-GUITexture", 9002, true);
			AddShader("Internal-GUITextureBlit", 9003, true);
			AddShader("Font", 10101, false);
			AddShader("Sprites-Default", 10753, true);

			///////////////////////////////////////////////////////
			// Old Extra
			///////////////////////////////////////////////////////

			AddShader("Normal-DiffuseFast", 1, true);
			AddShader("Normal-Bumped", 2, true);
			AddShader("Normal-Glossy", 3, true);
			AddShader("Normal-BumpSpec", 4, true);
			AddShader("Normal-DiffuseDetail", 5, true);
			AddShader("Normal-VertexLit", 6, true);
			AddShader("Normal-Diffuse", 7, true);
			AddShader("Normal-Parallax", 8, true);
			AddShader("Normal-ParallaxSpec", 9, true);
			AddShader("Illumin-Diffuse", 10, true);
			AddShader("Illumin-Bumped", 11, true);
			AddShader("Illumin-Glossy", 12, true);
			AddShader("Illumin-BumpSpec", 13, true);
			AddShader("Illumin-VertexLit", 14, true);
			AddShader("Illumin-Parallax", 15, true);
			AddShader("Illumin-ParallaxSpec", 16, true);
			AddShader("Reflect-Diffuse", 20, true);
			AddShader("Reflect-Bumped", 21, true);
			AddShader("Reflect-Glossy", 22, true);
			AddShader("Reflect-BumpSpec", 23, true);
			AddShader("Reflect-VertexLit", 24, true);
			AddShader("Reflect-BumpNolight", 25, true);
			AddShader("Reflect-BumpVertexLit", 26, true);
			AddShader("Reflect-Parallax", 27, true);
			AddShader("Reflect-ParallaxSpec", 28, true);
			AddShader("Alpha-Diffuse", 30, true);
			AddShader("Alpha-Bumped", 31, true);
			AddShader("Alpha-Glossy", 32, true);
			AddShader("Alpha-BumpSpec", 33, true);
			AddShader("Alpha-VertexLit", 34, true);
			AddShader("Alpha-Parallax", 35, true);
			AddShader("Alpha-ParallaxSpec", 36, true);
			AddShader("Lightmap-VertexLit", 40, true);
			AddShader("Lightmap-Diffuse", 41, true);
			AddShader("Lightmap-Bumped", 42, true);
			AddShader("Lightmap-Glossy", 43, true);
			AddShader("Lightmap-BumpSpec", 44, true);
			AddShader("StandardSpecular", 45, true);
			AddShader("Shader", new UnityVersion(5), 46, true);
			AddShader("AlphaTest-VertexLit", 50, true);
			AddShader("AlphaTest-Diffuse", 51, true);
			AddShader("AlphaTest-Bumped", 52, true);
			AddShader("AlphaTest-Glossy", 53, true);
			AddShader("AlphaTest-BumpSpec", 54, true);
			AddShader("Internal-DeferredShading", 69, false);
			AddShader("Internal-DeferredReflections", 74, false);
			AddShader("Shader", UnityVersion.MinVersion, 100, true);
			AddShader("Decal", 100, false);
			AddShader("Flare", 101, true);
			AddShader("skybox cubed", 103, true);
			AddShader("Skybox-Cubed", 103, false);
			AddShader("Skybox", 104, true);
			AddShader("Skybox-Procedural", 106, false);
			AddShader("Particle Add", 200, true);
			AddShader("Particle AddMultiply", 201, true);
			AddShader("Particle AddSmooth", 202, true);
			AddShader("Particle Alpha Blend", 203, true);
			AddShader("Particle Multiply", 205, true);
			AddShader("Particle MultiplyDouble", 206, true);
			AddShader("Particle Premultiply Blend", 207, true);
			AddShader("Particle VertexLit Blended", 208, true);
			AddShader("VertexLit", 10500, true);
			AddShader("WavingGrass", 10501, true);
			AddShader("WavingGrassBillboard", 10502, true);
			AddShader("AddPass", 10503, true);
			AddShader("FirstPass", 10505, true);
			AddShader("BillboardTree", 10507, true);
			AddShader("TreeSoftOcclusionBarkRendertex", 10508, true);
			AddShader("TreeSoftOcclusionBark", 10509, true);
			AddShader("TreeSoftOcclusionLeavesRendertex", 10510, true);
			AddShader("TreeSoftOcclusionLeaves", 10511, true);
			AddShader("AlphaTest-SoftEdgeUnlit", 10512, true);
			AddShader("TreeCreatorBark", 10600, true);
			AddShader("TreeCreatorLeaves", 10601, true);
			AddShader("TreeCreatorBarkRendertex", 10602, true);
			AddShader("TreeCreatorLeavesRendertex", 10603, true);
			AddShader("TreeCreatorBarkOptimized", 10604, true);
			AddShader("TreeCreatorLeavesOptimized", 10605, true);
			AddShader("TreeCreatorLeavesFast", 10606, true);
			AddShader("TreeCreatorLeavesFastOptimized", 10607, true);
			AddShader("TerrBumpFirstPass", 10620, true);
			AddShader("Specular-FirstPass", 10620, false);
			AddShader("TerrBumpAddPass", 10621, true);
			AddShader("Specular-AddPass", 10621, false);
			AddShader("Specular-Base", 10622, false);
			AddShader("Standard-FirstPass", 10623, false);
			AddShader("Standard-AddPass", 10624, false);
			AddShader("Standard-Base", 10625, false);
			AddShader("Mobile-Skybox", 10700, true);
			AddShader("Mobile-VertexLit", 10701, true);
			AddShader("Mobile-Diffuse", 10703, true);
			AddShader("Mobile-Bumped", 10704, true);
			AddShader("Mobile-BumpSpec", 10705, true);
			AddShader("Mobile-BumpSpec-1DirectionalLight", 10706, true);
			AddShader("Mobile-VertexLit-OnlyDirectionalLights", 10707, true);
			AddShader("Mobile-Lightmap-Unlit", 10708, true);
			AddShader("Mobile-Particle-Add", 10720, true);
			AddShader("Mobile-Particle-Alpha", 10721, true);
			AddShader("Mobile-Particle-Alpha-VertexLit", 10722, true);
			AddShader("Mobile-Particle-Multiply", 10723, true);
			AddShader("Unlit-Alpha", 10750, true);
			AddShader("Unlit-AlphaTest", 10751, true);
			AddShader("Unlit-Normal", 10752, true);
			AddShader("Unlit-Color", 10755, false);
			AddShader("UI-Lit-Refraction", 10767, false);
			AddShader("UI-Lit-RefractionDetail", 10768, false);
			AddShader("UI-Unlit-Transparent", 10760, true);
			AddShader("UI-Unlit-Detail", 10761, true);
			AddShader("UI-Unlit-Text", 10762, true);
			AddShader("UI-Unlit-TextDetail", 10763, true);
			AddShader("UI-Lit-Transparent", 10764, true);
			AddShader("UI-Lit-Bumped", 10765, true);
			AddShader("UI-Lit-Detail", 10766, true);
			AddShader("UI-Lit-Refraction(ProOnly)", 10767, true);
			AddShader("UI-Lit-RefractionDetail(ProOnly)", 10768, true);
			AddShader("UI-Default", 10770, true);
			AddShader("UI-DefaultFont", 10782, true);
			AddShader("Sprites-Diffuse", 10800, true);
			AddShader("SpeedTree", 14000, false);
			AddShader("SpeedTreeBillboard", 14001, false);
			AddShader("TextureUV", 15100, false);
			AddShader("UV1sAsPositions", 15102, false);
			AddShader("VertexColors", 15103, false);
			AddShader("CubeBlur", 15104, false);
			AddShader("CubeCopy", 15105, false);
			AddShader("CubeBlend", 15106, false);
		}

		public static bool ContainsMaterial(string name, UnityVersion version)
		{
			return ContainsAsset(m_materials, name, version);
		}
		public static bool ContainsTexture(string name, UnityVersion version)
		{
			return ContainsAsset(m_textures, name, version);
		}
		public static bool ContainsMesh(string name, UnityVersion version)
		{
			return ContainsAsset(m_meshes, name, version);
		}
		public static bool ContainsFont(string name, UnityVersion version)
		{
			return ContainsAsset(m_fonts, name, version);
		}
		public static bool ContainsShader(string name, UnityVersion version)
		{
			return ContainsAsset(m_shaders, name, version);
		}
		public static bool ContainsSprite(string name, UnityVersion version)
		{
			return ContainsAsset(m_sprites, name, version);
		}
		public static bool ContainsLightmapParams(string name, UnityVersion version)
		{
			return ContainsAsset(m_lightmapParams, name, version);
		}
		public static bool ContainsBehaviour(string name, UnityVersion version)
		{
			return ContainsAsset(m_behaviours, name, version);
		}

		public static EngineBuiltInAsset GetMaterial(string name, UnityVersion version)
		{
			return m_materials[name].GetAsset(version);
		}
		public static bool TryGetMaterial(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_materials, name, version, out asset);
		}
		public static EngineBuiltInAsset GetTexture(string name, UnityVersion version)
		{
			return m_textures[name].GetAsset(version);
		}
		public static bool TryGetTexture(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_textures, name, version, out asset);
		}
		public static EngineBuiltInAsset GetMesh(string name, UnityVersion version)
		{
			return m_meshes[name].GetAsset(version);
		}
		public static bool TryGetMesh(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_meshes, name, version, out asset);
		}
		public static EngineBuiltInAsset GetFont(string name, UnityVersion version)
		{
			return m_fonts[name].GetAsset(version);
		}
		public static bool TryGetFont(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_fonts, name, version, out asset);
		}
		public static EngineBuiltInAsset GetShader(string name, UnityVersion version)
		{
			return m_shaders[name].GetAsset(version);
		}
		public static bool TryGetShader(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_shaders, name, version, out asset);
		}
		public static EngineBuiltInAsset GetSprite(string name, UnityVersion version)
		{
			return m_sprites[name].GetAsset(version);
		}
		public static bool TryGetSprite(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_sprites, name, version, out asset);
		}
		public static EngineBuiltInAsset GetLightmapParams(string name, UnityVersion version)
		{
			return m_lightmapParams[name].GetAsset(version);
		}
		public static bool TryGetLightmapParams(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_lightmapParams, name, version, out asset);
		}
		public static EngineBuiltInAsset GetBehaviour(string name, UnityVersion version)
		{
			return m_behaviours[name].GetAsset(version);
		}
		public static bool TryGetBehaviour(string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			return TryGetAsset(m_behaviours, name, version, out asset);
		}

		private static void AddMaterial(string name, uint exportID, bool isF)
		{
			AddMaterial(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddMaterial(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_materials, name, version, exportID, 0, isF);
		}

		private static void AddTexture(string name, uint exportID, bool isF)
		{
			AddTexture(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddTexture(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_textures, name, version, exportID, 0, isF);
		}
		private static void AddTexture(string name, UnityVersion version, uint exportID, uint param, bool isF)
		{
			AddAsset(m_textures, name, version, exportID, param, isF);
		}

		private static void AddMesh(string name, uint exportID, bool isF)
		{
			AddMesh(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddMesh(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_meshes, name, version, exportID, 0, isF);
		}

		private static void AddFont(string name, uint exportID, bool isF)
		{
			AddFont(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddFont(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_fonts, name, version, exportID, 0, isF);
		}

		private static void AddShader(string name, uint exportID, bool isF)
		{
			AddShader(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddShader(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_shaders, name, version, exportID, 0, isF);
		}

		private static void AddSprite(string name, uint exportID, bool isF)
		{
			AddSprite(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddSprite(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_sprites, name, version, exportID, 0, isF);
		}

		private static void AddLightmapParams(string name, uint exportID, bool isF)
		{
			AddLightmapParams(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddLightmapParams(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_lightmapParams, name, version, exportID, 0, isF);
		}

		private static void AddBehaviour(string name, uint exportID, bool isF)
		{
			AddBehaviour(name, UnityVersion.MinVersion, exportID, isF);
		}
		private static void AddBehaviour(string name, UnityVersion version, uint exportID, bool isF)
		{
			AddAsset(m_behaviours, name, version, exportID, 0, isF);
		}

		private static bool ContainsAsset(Dictionary<string, EngineBuiltInAssetInfo> lookup, string name, UnityVersion version)
		{
			if (lookup.TryGetValue(name, out EngineBuiltInAssetInfo info))
			{
				return info.ContainsAsset(version);
			}
			return false;
		}

		private static bool TryGetAsset(Dictionary<string, EngineBuiltInAssetInfo> lookup, string name, UnityVersion version, out EngineBuiltInAsset asset)
		{
			if (lookup.TryGetValue(name, out EngineBuiltInAssetInfo info))
			{
				return info.TryGetAsset(version, out asset);
			}
			asset = default;
			return false;
		}

		private static void AddAsset(Dictionary<string, EngineBuiltInAssetInfo> lookup, string name, UnityVersion version, uint exportID, uint param, bool isF)
		{
			EngineBuiltInAsset asset = new EngineBuiltInAsset(exportID, param, isF);
			if (lookup.TryGetValue(name, out EngineBuiltInAssetInfo assetInfo))
			{
				assetInfo.AddVariation(version, asset);
			}
			else
			{
				assetInfo = new EngineBuiltInAssetInfo(version, asset);
				lookup.Add(name, assetInfo);
			}
		}

		public const string FontMaterialName = "Font Material";
		public const string DefaultTerrainDiffuseName = "Default-Terrain-Diffuse";
		public const string DefaultTerrainSpecularName = "Default-Terrain-Specular";
		public const string DefaultTerrainStandardName = "Default-Terrain-Standard";

		public const string LegacyDiffuse = "Legacy Shaders/Diffuse";
		public const string SpriteDefault = "Sprites/Default";
		public const string UIDefault = "UI/Default";
		public const string CubeBlur = "Hidden/CubeBlur";
		public const string CubeCopy = "Hidden/CubeCopy";
		public const string CubeBlend = "Hidden/CubeBlend";
		public const string TerrainVertexLit = "Hidden/TerrainEngine/Details/Vertexlit";
		public const string TerrainWavingDoublePass = "Hidden/TerrainEngine/Details/WavingDoublePass";
		public const string TerrainBillboardWavingDoublePass = "Hidden/TerrainEngine/Details/BillboardWavingDoublePass";

		public static readonly UnityGUID DGUID = new UnityGUID(0x00000000, 0x00000000, 0x0000000D, 0x00000000);
		public static readonly UnityGUID EGUID = new UnityGUID(0x00000000, 0x00000000, 0x0000000E, 0x00000000);
		public static readonly UnityGUID FGUID = new UnityGUID(0x00000000, 0x00000000, 0x0000000F, 0x00000000);

		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_materials = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_textures = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_meshes = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_shaders = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_fonts = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_sprites = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_lightmapParams = new Dictionary<string, EngineBuiltInAssetInfo>();
		private static readonly Dictionary<string, EngineBuiltInAssetInfo> m_behaviours = new Dictionary<string, EngineBuiltInAssetInfo>();
	}
}

```

`AssetRipperCommon/Project/Exporters/IAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;

namespace AssetRipper.Core.Project.Exporters
{
	public interface IAssetExporter
	{
		bool IsHandle(IUnityObjectBase asset);

		bool Export(IExportContainer container, IUnityObjectBase asset, string path);
		void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback);
		bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path);
		void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback);

		IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset);
		AssetType ToExportType(IUnityObjectBase asset);
		bool ToUnknownExportType(Type type, out AssetType assetType);
	}
}

```

`AssetRipperCommon/Project/Exporters/ManagerAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_6;

namespace AssetRipper.Core.Project.Exporters
{
	public class ManagerAssetExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is GlobalGameManager && asset is not IBuildSettings;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new ManagerExportCollection(this, asset);
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/RawAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.IO.Endian;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Project.Exporters
{
	public class RawAssetExporter : BinaryAssetExporter
	{
		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new RawExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			//return WriteRawToPath(container, asset, path);
			return WriteDumpToPath(container, asset, path);
		}

		private static bool WriteDumpToPath(IExportContainer container, IUnityObjectBase asset, string path)
		{
			StringBuilder sb = new StringBuilder();
			sb.AppendLine("Raw export currently has issues. Dumping instead...");
			sb.AppendLine();
			sb.AppendLine("Asset Information:");
			if (asset is IHasNameString hasName)
			{
				sb.AppendLine($"Name: {hasName.NameString}");
			}
			sb.AppendLine($"Asset Type: {asset.GetType().FullName}");
			sb.AppendLine($"Path: {path}");
			sb.AppendLine($"Unity Version: {asset.SerializedFile.Version}");
			sb.AppendLine($"Endianess: {asset.SerializedFile.EndianType}");
			sb.AppendLine($"GUID: {asset.GUID}");
			sb.AppendLine($"File: {asset.SerializedFile.Name}");
			sb.AppendLine($"Path ID: {asset.PathID}");
			sb.AppendLine();
			sb.AppendLine("Container Information:");
			sb.AppendLine($"Name: {container.Name}");
			sb.AppendLine($"Unity Version: {container.Version}");
			sb.AppendLine($"Export Version: {container.ExportVersion}");
			sb.AppendLine($"Platform: {container.Platform}");
			sb.AppendLine($"Export Platform: {container.ExportPlatform}");
			File.WriteAllText(path, sb.ToString());
			return true;
		}

		private static bool WriteRawToPath(IExportContainer container, IUnityObjectBase asset, string path)
		{
			Logger.Info(LogCategory.Export, $"Writing raw to {path}");
			try
			{
				using MemoryStream memoryStream = new MemoryStream();
				using AssetWriter writer = new AssetWriter(memoryStream, asset.SerializedFile.EndianType, asset.SerializedFile.Layout);
				asset.Write(writer);
				File.WriteAllBytes(path, memoryStream.ToArray());
				return true;
			}
			catch (Exception ex)
			{
				File.WriteAllText(path, ex.ToString());
				return false;
			}
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/SceneYamlExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Core.Project.Exporters
{
	public class SceneYamlExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return SceneExportCollection.IsSceneCompatible(asset);
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			if (asset.SerializedFile.Collection.IsScene(asset.SerializedFile))
			{
				return new SceneExportCollection(this, virtualFile, asset.SerializedFile);
			}
			else if (PrefabExportCollection.IsValidAsset(asset))
			{
				return new PrefabExportCollection(this, virtualFile, asset);
			}
			else
			{
				return new FailExportCollection(this, asset);
			}
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/ScriptableObjectExporter.cs`:

```cs
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Core.Project.Exporters
{
	public class ScriptableObjectExporter : YamlExporterBase
	{
		public override bool IsHandle(Interfaces.IUnityObjectBase asset)
		{
			return asset is IMonoBehaviour;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, Interfaces.IUnityObjectBase asset)
		{
			IMonoBehaviour monoBehaviour = (IMonoBehaviour)asset;
			if (monoBehaviour.IsScriptableObject())
			{
				return new AssetExportCollection(this, asset);
			}
			else
			{
				// such MonoBehaviours as StateMachineBehaviour in AnimatorController
				return new EmptyExportCollection();
			}
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/UnknownObjectExporter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Exporters
{
	public sealed class UnknownObjectExporter : IAssetExporter
	{
		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new UnknownExportCollection(this, (UnknownObject)asset);
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			using var fileStream = File.Create(path);
			using BinaryWriter writer = new BinaryWriter(fileStream);
			writer.Write(((UnknownObject)asset).RawData);
			return true;
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			if (Export(container, asset, path))
			{
				callback?.Invoke(container, asset, path);
			}
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			bool success = true;
			foreach (var asset in assets)
			{
				success &= Export(container, asset, path);
			}
			return success;
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			foreach (IUnityObjectBase asset in assets)
			{
				Export(container, asset, path, callback);
			}
		}

		public bool IsHandle(IUnityObjectBase asset)
		{
			return asset is UnknownObject;
		}

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			return AssetType.Meta;
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Meta;
			return true;
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/UnreadableObjectExporter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Core.Project.Exporters
{
	internal class UnreadableObjectExporter : IAssetExporter
	{
		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new UnreadableExportCollection(this, (UnreadableObject)asset);
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			using FileStream fileStream = File.Create(path);
			using BinaryWriter writer = new BinaryWriter(fileStream);
			writer.Write(((UnreadableObject)asset).RawData);
			return true;
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			if (Export(container, asset, path))
			{
				callback?.Invoke(container, asset, path);
			}
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			bool success = true;
			foreach (IUnityObjectBase? asset in assets)
			{
				success &= Export(container, asset, path);
			}
			return success;
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			foreach (IUnityObjectBase asset in assets)
			{
				Export(container, asset, path, callback);
			}
		}

		public bool IsHandle(IUnityObjectBase asset)
		{
			return asset is UnreadableObject;
		}

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			return AssetType.Meta;
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Meta;
			return true;
		}
	}
}

```

`AssetRipperCommon/Project/Exporters/YamlExporterBase.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Yaml;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Project.Exporters
{
	public abstract class YamlExporterBase : IAssetExporter
	{
		public virtual bool IsHandle(IUnityObjectBase asset)
		{
			return true;
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			using Stream fileStream = File.Create(path);
			using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, UTF8);
			YamlWriter writer = new YamlWriter();
			YamlDocument doc = asset.ExportYamlDocument(container);
			writer.AddDocument(doc);
			writer.Write(streamWriter);
			return true;
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			Export(container, asset, path);
			callback?.Invoke(container, asset, path);
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path)
		{
			using Stream fileStream = File.Create(path);
			using InvariantStreamWriter streamWriter = new InvariantStreamWriter(fileStream, UTF8);
			YamlWriter writer = new YamlWriter();
			writer.WriteHead(streamWriter);
			foreach (IUnityObjectBase asset in assets)
			{
				YamlDocument doc = asset.ExportYamlDocument(container);
				writer.WriteDocument(doc);
			}
			writer.WriteTail(streamWriter);
			return true;
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException("Yaml supports only single file export");
		}

		public abstract IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset);

		public AssetType ToExportType(IUnityObjectBase asset)
		{
			return AssetType.Serialized;
		}

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Serialized;
			return true;
		}

		private static readonly Encoding UTF8 = new UTF8Encoding(false);
	}
}

```

`AssetRipperCommon/Project/ProjectAssetContainer.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_147;
using AssetRipper.SourceGenerated.Classes.ClassID_78;
using AssetRipper.SourceGenerated.Subclasses.AssetInfo;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object_;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.IO;


namespace AssetRipper.Core.Project
{
	public class ProjectAssetContainer : IExportContainer, IProjectAssetContainer
	{
		public ProjectAssetContainer(ProjectExporter exporter, CoreConfiguration options, VirtualSerializedFile file, IEnumerable<IUnityObjectBase> assets,
			IReadOnlyList<IExportCollection> collections)
		{
			m_exporter = exporter ?? throw new ArgumentNullException(nameof(exporter));
			m_BundledAssetsExportMode = options.BundledAssetsExportMode;
			VirtualFile = file ?? throw new ArgumentNullException(nameof(file));
			ExportLayout = file.Layout;

			foreach (IUnityObjectBase asset in assets)
			{
				if (asset is IBuildSettings buildSettings)
				{
					m_buildSettings = buildSettings;
				}
				else if (asset is ITagManager tagManager)
				{
					m_tagManager = tagManager;
				}
				else if (asset is IAssetBundle assetBundle)
				{
					AddBundleAssets(assetBundle);
				}
				else if (asset is IResourceManager resourceManager)
				{
					AddResources(resourceManager);
				}
			}

			List<SceneExportCollection> scenes = new List<SceneExportCollection>();
			foreach (IExportCollection collection in collections)
			{
				foreach (IUnityObjectBase asset in collection.Assets)
				{
#warning TODO: unique asset:collection (m_assetCollections.Add)
					m_assetCollections[asset.AssetInfo] = collection;
				}
				if (collection is SceneExportCollection scene)
				{
					scenes.Add(scene);
				}
			}
			m_scenes = scenes.ToArray();
		}

#warning TODO: get rid of IEnumerable. pass only main asset (issues: prefab, texture with sprites, animatorController)
		public bool TryGetAssetPathFromAssets(IEnumerable<IUnityObjectBase> assets, [NotNullWhen(true)] out IUnityObjectBase? selectedAsset, out string assetPath)
		{
			selectedAsset = null;
			assetPath = string.Empty;
			if (m_pathAssets.Count > 0)
			{
				foreach (IUnityObjectBase asset in assets)
				{
					if (m_pathAssets.TryGetValue(asset, out ProjectAssetPath projectPath))
					{
						selectedAsset = asset;
						assetPath = projectPath.SubstituteExportPath(asset);
						return true;
					}
				}
			}

			return false;
		}

		public IUnityObjectBase GetAsset(long pathID)
		{
			return File.GetAsset(pathID);
		}

		public virtual IUnityObjectBase? FindAsset(int fileIndex, long pathID)
		{
			if (fileIndex == VirtualSerializedFile.VirtualFileIndex)
			{
				return VirtualFile.FindAsset(pathID);
			}
			else
			{
				return File.FindAsset(fileIndex, pathID);
			}
		}

		public virtual IUnityObjectBase GetAsset(int fileIndex, long pathID)
		{
			if (fileIndex == VirtualSerializedFile.VirtualFileIndex)
			{
				return VirtualFile.GetAsset(pathID);
			}
			else
			{
				return File.GetAsset(fileIndex, pathID);
			}
		}

		public IUnityObjectBase? FindAsset(ClassIDType classID)
		{
			return File.FindAsset(classID);
		}

		public virtual IUnityObjectBase? FindAsset(ClassIDType classID, string name)
		{
			return File.FindAsset(classID, name);
		}

		public ClassIDType GetAssetType(long pathID)
		{
			return File.GetAssetType(pathID);
		}

		public long GetExportID(IUnityObjectBase asset)
		{
			if (m_assetCollections.TryGetValue(asset.AssetInfo, out IExportCollection? collection))
			{
				return collection.GetExportID(asset);
			}

			return ExportIdHandler.GetMainExportID(asset);
		}

		public AssetType ToExportType(Type type)
		{
			return m_exporter.ToExportType(type);
		}

		public MetaPtr CreateExportPointer(IUnityObjectBase asset)
		{
			if (m_assetCollections.TryGetValue(asset.AssetInfo, out IExportCollection? collection))
			{
				return collection.CreateExportPointer(asset, collection == CurrentCollection);
			}

			long exportID = ExportIdHandler.GetMainExportID(asset);
			return new MetaPtr(exportID, UnityGUID.MissingReference, AssetType.Meta);
		}

		public UnityGUID SceneNameToGUID(string name)
		{
			if (m_buildSettings == null)
			{
				return default;
			}

			int index = m_buildSettings.Scenes_C141.IndexOf(s => s.String == name);
			if (index == -1)
			{
				throw new Exception($"Scene '{name}' hasn't been found in build settings");
			}

			string fileName = SceneExportCollection.SceneIndexToFileName(index, Version);
			foreach (SceneExportCollection scene in m_scenes)
			{
				if (scene.Name == fileName)
				{
					return scene.GUID;
				}
			}
			return default;
		}

		public string SceneIndexToName(int sceneIndex)
		{
			return m_buildSettings == null ? $"level{sceneIndex}" : m_buildSettings.Scenes_C141[sceneIndex].String;
		}

		public bool IsSceneDuplicate(int sceneIndex)
		{
			if (m_buildSettings == null)
			{
				return false;
			}

			string sceneName = m_buildSettings.Scenes_C141[sceneIndex].String;
			for (int i = 0; i < m_buildSettings.Scenes_C141.Count; i++)
			{
				if (m_buildSettings.Scenes_C141[i] == sceneName)
				{
					if (i != sceneIndex)
					{
						return true;
					}
				}
			}
			return false;
		}

		public string TagIDToName(int tagID)
		{
			switch (tagID)
			{
				case 0:
					return Classes.TagManager.TagManagerConstants.UntaggedTag;
				case 1:
					return Classes.TagManager.TagManagerConstants.RespawnTag;
				case 2:
					return Classes.TagManager.TagManagerConstants.FinishTag;
				case 3:
					return Classes.TagManager.TagManagerConstants.EditorOnlyTag;
				//case 4:
				case 5:
					return Classes.TagManager.TagManagerConstants.MainCameraTag;
				case 6:
					return Classes.TagManager.TagManagerConstants.PlayerTag;
				case 7:
					return Classes.TagManager.TagManagerConstants.GameControllerTag;
			}
			if (m_tagManager != null)
			{
				// Unity doesn't verify tagID on export?
				int tagIndex = tagID - 20000;
				if (tagIndex < m_tagManager.Tags_C78.Count)
				{
					if (tagIndex >= 0)
					{
						return m_tagManager.Tags_C78[tagIndex].String;
					}
					else if (!m_tagManager.IsBrokenCustomTags())
					{
						throw new Exception($"Unknown default tag {tagID}");
					}
				}
			}
			return $"unknown_{tagID}";
		}

		public ushort TagNameToID(string tagName)
		{
			switch (tagName)
			{
				case Classes.TagManager.TagManagerConstants.UntaggedTag:
					return 0;
				case Classes.TagManager.TagManagerConstants.RespawnTag:
					return 1;
				case Classes.TagManager.TagManagerConstants.FinishTag:
					return 2;
				case Classes.TagManager.TagManagerConstants.EditorOnlyTag:
					return 3;
				case Classes.TagManager.TagManagerConstants.MainCameraTag:
					return 5;
				case Classes.TagManager.TagManagerConstants.PlayerTag:
					return 6;
				case Classes.TagManager.TagManagerConstants.GameControllerTag:
					return 7;
			}
			if (m_tagManager != null)
			{
				for (int i = 0; i < m_tagManager.Tags_C78.Count; i++)
				{
					if (m_tagManager.Tags_C78[i] == tagName)
					{
						return (ushort)(20000 + i);
					}
				}
			}
			return 0;
		}

		private void AddResources(IResourceManager manager)
		{
			foreach (NullableKeyValuePair<Utf8String, IPPtr_Object_> kvp in manager.Container_C147)
			{
				IUnityObjectBase? asset = kvp.Value.FindAsset(manager.SerializedFile);
				if (asset == null)
				{
					continue;
				}

				string resourcePath = kvp.Key.String;
				if (m_pathAssets.TryGetValue(asset, out ProjectAssetPath projectPath))
				{
					// for paths like "Resources/inner/resources/extra/file" engine creates 2 resource entries
					// "inner/resources/extra/file" and "extra/file"
					if (projectPath.AssetPath.Length >= resourcePath.Length)
					{
						continue;
					}
				}
				m_pathAssets[asset] = new ProjectAssetPath(ResourceFullPath, resourcePath);
			}
		}

		private void AddBundleAssets(IAssetBundle bundle)
		{
			if (m_BundledAssetsExportMode == BundledAssetsExportMode.GroupByAssetType)
			{
				return;
			}

			string bundleName = bundle.GetAssetBundleName();
			string bundleDirectory = bundleName + ObjectUtils.DirectorySeparator;
			string directory = Path.Combine(AssetBundleFullPath, bundleName);
			foreach (NullableKeyValuePair<Utf8String, IAssetInfo> kvp in bundle.Container_C142)
			{
				// skip shared bundle assets, because we need to export them in their bundle directory
				if (kvp.Value.Asset.FileIndex != 0)
				{
					continue;
				}
				UnityObjectBase? asset = kvp.Value.Asset.FindAsset(bundle.SerializedFile);
				if (asset == null)
				{
					continue;
				}

				string assetPath = kvp.Key.String;
				if (bundle.HasPathExtension())
				{
					// custom names may not have extensions
					int extensionIndex = assetPath.LastIndexOf('.');
					if (extensionIndex != -1)
					{
						assetPath = assetPath.Substring(0, extensionIndex);
					}
				}

				if (m_BundledAssetsExportMode == BundledAssetsExportMode.DirectExport)
				{
					m_pathAssets.Add(asset, new ProjectAssetPath(string.Empty, assetPath));
				}
				else if (m_BundledAssetsExportMode == BundledAssetsExportMode.GroupByBundleName)
				{
					if (assetPath.StartsWith(AssetsDirectory, StringComparison.OrdinalIgnoreCase))
					{
						assetPath = assetPath.Substring(AssetsDirectory.Length);
					}
					if (assetPath.StartsWith(bundleDirectory, StringComparison.OrdinalIgnoreCase))
					{
						assetPath = assetPath.Substring(bundleDirectory.Length);
					}
					m_pathAssets.TryAdd(asset, new ProjectAssetPath(directory, assetPath));
					//TryAdd because Unity sometimes includes duplicates (issue #378)
				}
				else
				{
					throw new Exception($"Invalid {nameof(BundledAssetsExportMode)} for {nameof(m_BundledAssetsExportMode)} : {m_BundledAssetsExportMode}");
				}
			}
#warning TODO: asset bundle may contain more assets than listed in Container. Need to export them in AssetBundleFullPath directory if m_BundledAssetsExportMode is GroupByBundleName
		}

		public IExportCollection CurrentCollection { get; set; }
		public VirtualSerializedFile VirtualFile { get; }
		public virtual ISerializedFile File => CurrentCollection.File;
		public string Name => File.Name;
		public LayoutInfo Layout => File.Layout;
		public UnityVersion Version => File.Version;
		public BuildTarget Platform => File.Platform;
		public TransferInstructionFlags Flags => File.Flags;
		public LayoutInfo ExportLayout { get; }
		public UnityVersion ExportVersion => ExportLayout.Version;
		public BuildTarget ExportPlatform => ExportLayout.Platform;
		public virtual TransferInstructionFlags ExportFlags => ExportLayout.Flags | CurrentCollection.Flags;
		public virtual IReadOnlyList<FileIdentifier> Dependencies => File.Dependencies;

		private const string ResourcesKeyword = "Resources";
		private const string AssetBundleKeyword = "AssetBundles";
		private const string AssetsDirectory = UnityObjectBase.AssetsKeyword + ObjectUtils.DirectorySeparator;
		private const string ResourceFullPath = AssetsDirectory + ResourcesKeyword;
		//private const string AssetBundleFullPath = AssetsDirectory + AssetBundleKeyword;
		private const string AssetBundleFullPath = AssetsDirectory + "Asset_Bundles";

		private readonly ProjectExporter m_exporter;
		private readonly BundledAssetsExportMode m_BundledAssetsExportMode;
		private readonly Dictionary<Parser.Asset.AssetInfo, IExportCollection> m_assetCollections = new Dictionary<Parser.Asset.AssetInfo, IExportCollection>();
		private readonly Dictionary<IUnityObjectBase, ProjectAssetPath> m_pathAssets = new Dictionary<IUnityObjectBase, ProjectAssetPath>();

		private readonly IBuildSettings? m_buildSettings;
		private readonly ITagManager? m_tagManager;
		private readonly SceneExportCollection[] m_scenes;
	}
}

```

`AssetRipperCommon/Project/ProjectAssetPath.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Utils;
using System.IO;

namespace AssetRipper.Core.Project
{
	public struct ProjectAssetPath
	{
		public ProjectAssetPath(string root, string path)
		{
			Root = root;
			AssetPath = path;
		}

		public string SubstituteExportPath(IUnityObjectBase asset)
		{
			string projectPath = SubstitutePath(asset.GetOriginalName());
			projectPath = DirectoryUtils.FixInvalidPathCharacters(projectPath);
			return Path.Combine(Root, projectPath);
		}

		private string SubstitutePath(string assetName)
		{
			if (assetName.Length > 0 && assetName != AssetPath && AssetPath.EndsWith(assetName, StringComparison.OrdinalIgnoreCase))
			{
				if (assetName.Length == AssetPath.Length)
				{
					return assetName;
				}
				if (AssetPath[AssetPath.Length - assetName.Length - 1] == ObjectUtils.DirectorySeparatorChar)
				{
					string directoryPath = AssetPath.Substring(0, AssetPath.Length - assetName.Length);
					return directoryPath + assetName;
				}
			}
			return AssetPath;
		}

		public string Root { get; }
		public string AssetPath { get; }
	}
}

```

`AssetRipperCommon/Project/ProjectExporter.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.Structure;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_116;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_142;
using AssetRipper.SourceGenerated.Classes.ClassID_147;
using AssetRipper.SourceGenerated.Classes.ClassID_150;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_3;
using AssetRipper.SourceGenerated.Classes.ClassID_6;
using System.Collections.Generic;

namespace AssetRipper.Core.Project
{
	public class ProjectExporter
	{
		public event Action? EventExportPreparationStarted;
		public event Action? EventExportPreparationFinished;
		public event Action? EventExportStarted;
		public event Action<int, int>? EventExportProgressUpdated;
		public event Action? EventExportFinished;

		/// <summary>
		/// Exact type to the exporters that handle that type
		/// </summary>
		private readonly Dictionary<Type, Stack<IAssetExporter>> typeMap = new Dictionary<Type, Stack<IAssetExporter>>();
		/// <summary>
		/// List of type-exporter-allow pairs<br/>
		/// Type: the asset type<br/>
		/// IAssetExporter: the exporter that can handle that asset type<br/>
		/// Bool: allow the exporter to apply on inherited asset types?
		/// </summary>
		private readonly List<(Type, IAssetExporter, bool)> registeredExporters = new List<(Type, IAssetExporter, bool)>();

		//Exporters
		protected DefaultYamlExporter DefaultExporter { get; } = new DefaultYamlExporter();
		protected SceneYamlExporter SceneExporter { get; } = new SceneYamlExporter();
		protected ManagerAssetExporter ManagerExporter { get; } = new ManagerAssetExporter();
		protected BuildSettingsExporter BuildSettingsExporter { get; } = new BuildSettingsExporter();
		protected ScriptableObjectExporter ScriptableExporter { get; } = new ScriptableObjectExporter();
		protected DummyAssetExporter DummyExporter { get; } = new DummyAssetExporter();

		public ProjectExporter()
		{
			OverrideExporter<IUnityObjectBase>(new RawAssetExporter(), true);
			OverrideExporter<IUnityObjectBase>(DefaultExporter, true);

			OverrideExporter<IGlobalGameManager>(ManagerExporter, true);

			OverrideExporter<IBuildSettings>(BuildSettingsExporter, true);

			OverrideExporter<IMonoBehaviour>(ScriptableExporter, true);

			OverrideExporter<IGameObject>(SceneExporter, true);
			OverrideExporter<IComponent>(SceneExporter, true);
			OverrideExporter<ILevelGameManager>(SceneExporter, true);

			OverrideDummyExporter<IPreloadData>(ClassIDType.PreloadData, true, false);
			OverrideDummyExporter<IMonoManager>(ClassIDType.MonoManager, true, false);
			OverrideDummyExporter<IAssetBundle>(ClassIDType.AssetBundle, true, false);
			OverrideDummyExporter<IResourceManager>(ClassIDType.ResourceManager, true, false);

			OverrideExporter<Classes.UnknownObject>(new UnknownObjectExporter(), false);
			OverrideExporter<Classes.UnreadableObject>(new UnreadableObjectExporter(), false);
		}

		/// <summary>Adds an exporter to the stack of exporters for this asset type.</summary>
		/// <typeparam name="T">The c sharp type of this asset type. Any inherited types also get this exporter.</typeparam>
		/// <param name="exporter">The new exporter. If it doesn't work, the next one in the stack is used.</param>
		/// <param name="allowInheritance">Should types that inherit from this type also use the exporter?</param>
		public void OverrideExporter<T>(IAssetExporter exporter, bool allowInheritance)
		{
			OverrideExporter(typeof(T), exporter, allowInheritance);
		}

		/// <summary>Adds an exporter to the stack of exporters for this asset type.</summary>
		/// <param name="type">The c sharp type of this asset type. Any inherited types also get this exporter.</param>
		/// <param name="exporter">The new exporter. If it doesn't work, the next one in the stack is used.</param>
		/// <param name="allowInheritance">Should types that inherit from this type also use the exporter?</param>
		public void OverrideExporter(Type type, IAssetExporter exporter, bool allowInheritance)
		{
			if (exporter == null)
			{
				throw new ArgumentNullException(nameof(exporter));
			}

			registeredExporters.Add((type, exporter, allowInheritance));
			if (typeMap.Count > 0)//Just in case an exporter gets added after CreateCollection or ToExportType have already been used
			{
				RecalculateTypeMap();
			}
		}

		public AssetType ToExportType(Type type)
		{
			Stack<IAssetExporter> exporters = GetExporterStack(type);
			foreach (IAssetExporter exporter in exporters)
			{
				if (exporter.ToUnknownExportType(type, out AssetType assetType))
				{
					return assetType;
				}
			}
			throw new NotSupportedException($"There is no exporter that know {nameof(AssetType)} for unknown asset '{type}'");
		}

		protected IExportCollection CreateCollection(VirtualSerializedFile file, IUnityObjectBase asset)
		{
			Stack<IAssetExporter> exporters = GetExporterStack(asset);
			foreach (IAssetExporter exporter in exporters)
			{
				if (exporter.IsHandle(asset))
				{
					return exporter.CreateCollection(file, asset);
				}
			}
			throw new Exception($"There is no exporter that can handle '{asset}'");
		}

		private Stack<IAssetExporter> GetExporterStack(IUnityObjectBase asset) => GetExporterStack(asset.GetType());
		private Stack<IAssetExporter> GetExporterStack(Type type)
		{
			if (!typeMap.TryGetValue(type, out Stack<IAssetExporter>? exporters))
			{
				exporters = CalculateAssetExporterStack(type);
				typeMap.Add(type, exporters);
			}
			return exporters;
		}

		private void RecalculateTypeMap()
		{
			foreach (Type type in typeMap.Keys)
			{
				typeMap[type] = CalculateAssetExporterStack(type);
			}
		}

		private Stack<IAssetExporter> CalculateAssetExporterStack(Type type)
		{
			Stack<IAssetExporter> result = new Stack<IAssetExporter>();
			foreach ((Type baseType, IAssetExporter exporter, bool allowInheritance) in registeredExporters)
			{
				if (type == baseType || (allowInheritance && type.IsAssignableTo(baseType)))
				{
					result.Push(exporter);
				}
			}
			return result;
		}

		protected void OverrideDummyExporter<T>(ClassIDType classType, bool isEmptyCollection, bool isMetaType)
		{
			DummyExporter.SetUpClassType(classType, isEmptyCollection, isMetaType);
			OverrideExporter<T>(DummyExporter, true);
		}

		public void Export(GameCollection fileCollection, CoreConfiguration options) => Export(fileCollection, fileCollection.FetchSerializedFiles(), options);
		public void Export(GameCollection fileCollection, SerializedFile file, CoreConfiguration options) => Export(fileCollection, new SerializedFile[] { file }, options);
		public void Export(GameCollection fileCollection, IEnumerable<SerializedFile> files, CoreConfiguration options)
		{
			EventExportPreparationStarted?.Invoke();

			LayoutInfo exportLayout = new LayoutInfo(options.Version, options.Platform, options.Flags);
			VirtualSerializedFile virtualFile = new VirtualSerializedFile(exportLayout);
			List<IExportCollection> collections = new List<IExportCollection>();

			// speed up fetching
			List<IUnityObjectBase> depList = new List<IUnityObjectBase>();
			HashSet<IUnityObjectBase> depSet = new HashSet<IUnityObjectBase>();
			HashSet<IUnityObjectBase> queued = new HashSet<IUnityObjectBase>();

			foreach (SerializedFile file in files)
			{
				foreach (IUnityObjectBase asset in file.FetchAssets())
				{
					if (!options.Filter(asset))
					{
						continue;
					}

					depList.Add(asset);
					depSet.Add(asset);
				}
			}


			for (int i = 0; i < depList.Count; i++)
			{
				IUnityObjectBase asset = depList[i];
				if (!queued.Contains(asset))
				{
					IExportCollection collection = CreateCollection(virtualFile, asset);
					foreach (IUnityObjectBase element in collection.Assets)
					{
						queued.Add(element);
					}
					collections.Add(collection);
				}

				if (options.ExportDependencies && asset is IDependent dependent)
				{
					DependencyContext context = new DependencyContext(exportLayout, true);
					foreach (PPtr<IUnityObjectBase> pointer in dependent.FetchDependencies(context))
					{
						if (pointer.IsNull)
						{
							continue;
						}

						IUnityObjectBase? dependency = pointer.FindAsset(asset.SerializedFile);
						if (dependency == null)
						{
							string hierarchy = $"[{asset.SerializedFile.Name}]" + asset.SerializedFile.GetAssetLogString(asset.PathID) + "." + context.GetPointerPath();
							Logger.Log(LogType.Warning, LogCategory.Export, $"{hierarchy}'s dependency {context.PointerName} = {pointer.ToLogString(asset.SerializedFile)} wasn't found");
							continue;
						}

						if (!depSet.Contains(dependency))
						{
							depList.Add(dependency);
							depSet.Add(dependency);
						}
					}
				}
			}
			depList.Clear();
			depSet.Clear();
			queued.Clear();
			EventExportPreparationFinished?.Invoke();

			EventExportStarted?.Invoke();
			ProjectAssetContainer container = new ProjectAssetContainer(this, options, virtualFile, fileCollection.FetchAssets(), collections);
			for (int i = 0; i < collections.Count; i++)
			{
				IExportCollection collection = collections[i];
				container.CurrentCollection = collection;
				bool isExported = collection.Export(container, options.ProjectRootPath);
				if (isExported)
				{
					Logger.Info(LogCategory.ExportedFile, $"'{collection.Name}' exported");
				}
				else if (collection is not EmptyExportCollection)
				{
					Logger.Warning(LogCategory.ExportedFile, $"'{collection.Name}' failed to export");
				}
				EventExportProgressUpdated?.Invoke(i, collections.Count);
			}
			EventExportFinished?.Invoke();
		}
	}
}

```

`AssetRipperCommon/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle(AssetRipper.Core.BuildInfo.CommonName)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(AssetRipper.Core.BuildInfo.Author)]
[assembly: AssemblyProduct(AssetRipper.Core.BuildInfo.CommonName)]
[assembly: AssemblyCopyright(AssetRipper.Core.BuildInfo.CopyRight)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: AssemblyVersion(AssetRipper.Core.BuildInfo.Version)]
[assembly: AssemblyFileVersion(AssetRipper.Core.BuildInfo.Version)]

[assembly: InternalsVisibleTo("AssetRipperCore")]
```

`AssetRipperCommon/SourceGenExtensions/AnimationClipBindingConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimationClip.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipBindingConstant;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimationClipBindingConstantExtensions
	{
		public static IGenericBinding FindBinding(this IAnimationClipBindingConstant constant, int index)
		{
			int curves = 0;
			for (int i = 0; i < constant.GenericBindings.Count; i++)
			{
				IGenericBinding gb = constant.GenericBindings[i];
				if (gb.GetClassID() == ClassIDType.Transform)
				{
					curves += gb.TransformType().GetDimension();
				}
				else
				{
					curves += 1;
				}

				if (curves > index)
				{
					return gb;
				}
			}
			throw new ArgumentException($"Binding with index {index} hasn't been found", nameof(index));
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimationClipExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimationClip;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_90;
using AssetRipper.SourceGenerated.Classes.ClassID_95;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimationClipExtensions
	{
		public static bool GetLegacy(this IAnimationClip clip)
		{
			if (clip.Has_Legacy_C74())
			{
				return clip.Legacy_C74;
			}
			return clip.AnimationType_C74 == (int)AnimationType.Legacy;
		}

		public static IEnumerable<IGameObject> FindRoots(this IAnimationClip clip)
		{
			foreach (IUnityObjectBase asset in clip.SerializedFile.Collection.FetchAssets())
			{
				if(asset is IAnimator animator)
				{
					if (clip.IsAnimatorContainsClip(animator))
					{
						yield return animator.GameObject_C8.GetAsset(animator.SerializedFile);
					}
				}
				else if (asset is IAnimation animation)
				{
					if (clip.IsAnimationContainsClip(animation))
					{
						yield return animation.GameObject_C8.GetAsset(animation.SerializedFile);
					}
				}
			}

			yield break;
		}

		private static bool IsAnimatorContainsClip(this IAnimationClip clip, IAnimator animator)
		{
			return animator.IsContainsAnimationClip(clip);
		}

		private static bool IsAnimationContainsClip(this IAnimationClip clip, IAnimation animation)
		{
			return animation.IsContainsAnimationClip(clip);
		}

		public static IReadOnlyDictionary<uint, string> FindTOS(this IAnimationClip clip)
		{
			Dictionary<uint, string> tos = new Dictionary<uint, string>() { { 0, string.Empty } };

			foreach (IAvatar avatar in clip.SerializedFile.Collection.FetchAssetsOfType<IAvatar>())
			{
				if (clip.AddAvatarTOS(avatar, tos))
				{
					return tos;
				}
			}

			foreach (IAnimator animator in clip.SerializedFile.Collection.FetchAssetsOfType<IAnimator>())
			{
				if (clip.IsAnimatorContainsClip(animator))
				{
					if (clip.AddAnimatorTOS(animator, tos))
					{
						return tos;
					}
				}
			}

			foreach (IAnimation animation in clip.SerializedFile.Collection.FetchAssetsOfType<IAnimation>())
			{
				if (clip.IsAnimationContainsClip(animation))
				{
					if (clip.AddAnimationTOS(animation, tos))
					{
						return tos;
					}
				}
			}

			return tos;
		}

		private static bool AddAvatarTOS(this IAnimationClip clip, IAvatar avatar, Dictionary<uint, string> tos)
		{
			return clip.AddTOS(avatar.TOS_C90, tos);
		}

		private static bool AddAnimatorTOS(this IAnimationClip clip, IAnimator animator, Dictionary<uint, string> tos)
		{
			IAvatar? avatar = animator.Avatar_C95.FindAsset(animator.SerializedFile);
			if (avatar != null)
			{
				if (clip.AddAvatarTOS(avatar, tos))
				{
					return true;
				}
			}

			IReadOnlyDictionary<uint, string> animatorTOS = animator.BuildTOS();
			return clip.AddTOS(animatorTOS, tos);
		}

		private static bool AddAnimationTOS(this IAnimationClip clip, IAnimation animation, Dictionary<uint, string> tos)
		{
			IGameObject go = animation.GameObject_C8.GetAsset(animation.SerializedFile);
			IReadOnlyDictionary<uint, string> animationTOS = go.BuildTOS();
			return clip.AddTOS(animationTOS, tos);
		}

		private static bool AddTOS(this IAnimationClip clip, IReadOnlyDictionary<uint, string> src, Dictionary<uint, string> dest)
		{
			if (clip.Has_ClipBindingConstant_C74())
			{
				int tosCount = clip.ClipBindingConstant_C74.GenericBindings.Count;
				for (int i = 0; i < tosCount; i++)
				{
					IGenericBinding binding = clip.ClipBindingConstant_C74.GenericBindings[i];
					if (src.TryGetValue(binding.Path, out string? path))
					{
						dest[binding.Path] = path;
						if (dest.Count == tosCount)
						{
							return true;
						}
					}
				}
			}
			return false;
		}

		private static bool AddTOS(this IAnimationClip clip, AssetDictionary<uint, Utf8String> src, Dictionary<uint, string> dest)
		{
			if (clip.Has_ClipBindingConstant_C74())
			{
				int tosCount = clip.ClipBindingConstant_C74.GenericBindings.Count;
				for (int i = 0; i < tosCount; i++)
				{
					IGenericBinding binding = clip.ClipBindingConstant_C74.GenericBindings[i];
					if (src.TryGetValue(binding.Path, out Utf8String? path))
					{
						dest[binding.Path] = path.String;
						if (dest.Count == tosCount)
						{
							return true;
						}
					}
				}
			}
			return false;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimationCurveExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc.Serializable.AnimationCurveTpl;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_float;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_Vector3f;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_float;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimationCurveExtensions
	{
		public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_float animationCurve)
		{
			animationCurve.PreInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.PostInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.RotationOrder = (int)RotationOrder.OrderZXY;
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, float defaultValue, float defaultWeight)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = 2;
			animationCurve.Curve.AddNew().SetValues(version, 0.0f, defaultValue, defaultWeight);
			animationCurve.Curve.AddNew().SetValues(version, 1.0f, defaultValue, defaultWeight);
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, float value1, float value2, float defaultWeight)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = 2;
			animationCurve.Curve.AddNew().SetValues(version, 0.0f, value1, defaultWeight);
			animationCurve.Curve.AddNew().SetValues(version, 1.0f, value2, defaultWeight);
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, float value1, float inSlope1, float outSlope1, float value2, float inSlope2, float outSlope2, float defaultWeight)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = 2;
			animationCurve.Curve.AddNew().SetValues(version, 0.0f, value1, inSlope1, outSlope1, defaultWeight);
			animationCurve.Curve.AddNew().SetValues(version, 1.0f, value2, inSlope2, outSlope2, defaultWeight);
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, IKeyframe_float keyframe)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = 1;
			animationCurve.Curve.AddNew().CopyValues(keyframe);
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, IKeyframe_float keyframe1, IKeyframe_float keyframe2)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = 2;
			animationCurve.Curve.AddNew().CopyValues(keyframe1);
			animationCurve.Curve.AddNew().CopyValues(keyframe2);
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, IReadOnlyList<IKeyframe_float> keyframes)
		{
			animationCurve.SetDefaultRotationOrderAndCurveLoopType();
			animationCurve.Curve.Capacity = keyframes.Count;
			for (int i = 0; i < keyframes.Count; i++)
			{
				animationCurve.Curve.AddNew().CopyValues(keyframes[i]);
			}
		}

		public static void SetValues(this IAnimationCurve_float animationCurve, UnityVersion version, IReadOnlyList<IKeyframe_float> keyframes, CurveLoopTypes preInfinity, CurveLoopTypes postInfinity)
		{
			animationCurve.PreInfinity = (int)preInfinity;
			animationCurve.PostInfinity = (int)postInfinity;
			animationCurve.RotationOrder = (int)RotationOrder.OrderZXY;
			animationCurve.Curve.Capacity = keyframes.Count;
			for (int i = 0; i < keyframes.Count; i++)
			{
				animationCurve.Curve.AddNew().CopyValues(keyframes[i]);
			}
		}

		public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_Vector3f animationCurve)
		{
			animationCurve.PreInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.PostInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.RotationOrder = (int)RotationOrder.OrderZXY;
		}

		public static void SetDefaultRotationOrderAndCurveLoopType(this IAnimationCurve_Quaternionf animationCurve)
		{
			animationCurve.PreInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.PostInfinity = (int)CurveLoopTypes.CycleWithOffset;
			animationCurve.RotationOrder = (int)RotationOrder.OrderZXY;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimationExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_111;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimationClip_;
using WrapMode = AssetRipper.Core.Classes.AnimationClip.WrapMode;
using AnimationCullingType = AssetRipper.Core.Classes.Animation.AnimationCullingType;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimationExtensions
	{
		public static bool IsContainsAnimationClip(this IAnimation animation, IAnimationClip clip)
		{
			foreach (IPPtr_AnimationClip_ clipPtr in animation.Animations_C111)
			{
				if (clipPtr.IsAsset(animation.SerializedFile, clip))
				{
					return true;
				}
			}
			return false;
		}

		public static WrapMode GetWrapMode(this IAnimation animation)
		{
			return (WrapMode)animation.WrapMode_C111;
		}

		public static bool GetAnimateOnlyIfVisible(this IAnimation animation)
		{
			// 2.6.0 to 3.4.0 exclusive
			if (animation.Has_AnimateOnlyIfVisible_C111())
			{
				return animation.AnimateOnlyIfVisible_C111;
			}
			//else if (animation.Has_CullingType_C111())
			//{
				return (AnimationCullingType)animation.CullingType_C111 != AnimationCullingType.AlwaysAnimate;
			//}
			//else
			//{
			//	return false;
			//}
		}

		public static AnimationCullingType GetAnimationCullingType(this IAnimation animation)
		{
			// 2.6.0 to 3.4.0 exclusive
			if (animation.Has_AnimateOnlyIfVisible_C111())
			{
				return animation.AnimateOnlyIfVisible_C111 ? AnimationCullingType.BasedOnRenderers : AnimationCullingType.AlwaysAnimate;
			}
			//else if (animation.Has_CullingType_C111())
			//{
				return (AnimationCullingType)animation.CullingType_C111;
			//}
			//else
			//{
			//	return default;
			//}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorConditionExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorTransition;
using AssetRipper.SourceGenerated.Subclasses.AnimatorCondition;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorConditionExtensions
	{
		public static AnimatorConditionMode GetConditionMode(this IAnimatorCondition condition)
		{
			return (AnimatorConditionMode)condition.ConditionMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorControllerExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimationClip_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour_;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateKey;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.StateRange;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorControllerExtensions
	{
		public static bool IsContainsAnimationClip(this IAnimatorController controller, IAnimationClip clip)
		{
			foreach (IPPtr_AnimationClip_ clipPtr in controller.AnimationClips_C91)
			{
				if (clipPtr.IsAsset(controller.SerializedFile, clip))
				{
					return true;
				}
			}
			return false;
		}

		public static PPtr_MonoBehaviour__5_0_0_f4[] GetStateBehaviours(this IAnimatorController controller, int layerIndex)
		{
			if (controller.Has_StateMachineBehaviourVectorDescription_C91())
			{
				uint layerID = controller.Controller_C91.LayerArray[layerIndex].Data.Binding;
				StateKey key = new();
				key.SetValues(layerIndex, layerID);
				if (controller.StateMachineBehaviourVectorDescription_C91.StateMachineBehaviourRanges.TryGetValue(key, out StateRange? range))
				{
					return controller.GetStateBehaviours(range);
				}
			}
			return Array.Empty<PPtr_MonoBehaviour__5_0_0_f4>();
		}

		public static PPtr_MonoBehaviour__5_0_0_f4[] GetStateBehaviours(this IAnimatorController controller, int stateMachineIndex, int stateIndex)
		{
			if (controller.Has_StateMachineBehaviourVectorDescription_C91())
			{
				int layerIndex = controller.Controller_C91.GetLayerIndexByStateMachineIndex(stateMachineIndex);
				IStateMachineConstant stateMachine = controller.Controller_C91.StateMachineArray[stateMachineIndex].Data;
				IStateConstant state = stateMachine.StateConstantArray[stateIndex].Data;
				uint stateID = GetIdForStateConstant(state);
				StateKey key = new();
				key.SetValues(layerIndex, stateID);
				if (controller.StateMachineBehaviourVectorDescription_C91.StateMachineBehaviourRanges.TryGetValue(key, out StateRange? range))
				{
					return controller.GetStateBehaviours(range);
				}
			}
			return Array.Empty<PPtr_MonoBehaviour__5_0_0_f4>();
		}

		private static PPtr_MonoBehaviour__5_0_0_f4[] GetStateBehaviours(this IAnimatorController controller, StateRange range)
		{
			PPtr_MonoBehaviour__5_0_0_f4[] stateMachineBehaviours = new PPtr_MonoBehaviour__5_0_0_f4[range.Count];
			for (int i = 0; i < range.Count; i++)
			{
				int index = (int)controller.StateMachineBehaviourVectorDescription_C91.StateMachineBehaviourIndices[range.StartIndex + i];
				stateMachineBehaviours[i] = controller.StateMachineBehaviours_C91[index];
			}
			return stateMachineBehaviours;
		}

		private static uint GetIdForStateConstant(IStateConstant stateConstant)
		{
			if (stateConstant.Has_FullPathID())
			{
				return stateConstant.FullPathID;
			}
			else if (stateConstant.Has_NameID())
			{
				return stateConstant.NameID;
			}
			else
			{
				return stateConstant.ID;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorControllerLayerExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerLayer;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerLayer;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorControllerLayerExtensions
	{
		public static void Initialize(this IAnimatorControllerLayer animatorControllerLayer, IAnimatorStateMachine stateMachine, IAnimatorController controller, int layerIndex)
		{
			ILayerConstant layer = controller.Controller_C91.LayerArray[layerIndex].Data;

			stateMachine.ParentStateMachinePosition_C1107.SetValues(800.0f, 20.0f, 0.0f);//not sure why this happens here

			animatorControllerLayer.Name.CopyValues(controller.TOS_C91[layer.Binding]);

			
			if (animatorControllerLayer.Has_StateMachine_PPtr_AnimatorStateMachine_())
			{
				animatorControllerLayer.StateMachine_PPtr_AnimatorStateMachine_.CopyValues(stateMachine.SerializedFile.CreatePPtr(stateMachine));
			}
			else if (animatorControllerLayer.Has_StateMachine_PPtr_StateMachine_())
			{
				animatorControllerLayer.StateMachine_PPtr_StateMachine_.CopyValues(stateMachine.SerializedFile.CreatePPtr(stateMachine));
			}

#warning TODO: animator
			//Mask = new();

			animatorControllerLayer.BlendingMode = layer.LayerBlendingMode;
			animatorControllerLayer.SyncedLayerIndex = layer.StateMachineSynchronizedLayerIndex == 0 ? -1 : (int)layer.StateMachineIndex;
			animatorControllerLayer.DefaultWeight = layer.DefaultWeight;
			animatorControllerLayer.IKPass = layer.IKPass;
			animatorControllerLayer.SyncedLayerAffectsTiming = layer.SyncedLayerAffectsTiming;
			animatorControllerLayer.Controller?.CopyValues(controller.SerializedFile.CreatePPtr(controller));
		}

		public static AnimatorLayerBlendingMode GetBlendingMode(this IAnimatorControllerLayer animatorControllerLayer)
		{
			return (AnimatorLayerBlendingMode)animatorControllerLayer.BlendingMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorControllerParameterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerParameter;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.AnimatorControllerParameter;
using AssetRipper.SourceGenerated.Subclasses.ValueConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorControllerParameterExtensions
	{
		public static void Initialize(this IAnimatorControllerParameter parameter, IAnimatorController controller, int paramIndex)
		{
			IValueConstant value = controller.Controller_C91.Values.Data.ValueArray[paramIndex];
			parameter.Name.CopyValues(controller.TOS_C91[value.ID]);
			AnimatorControllerParameterType type = value.GetTypeValue();
			switch (type)
			{
				case AnimatorControllerParameterType.Trigger:
					parameter.DefaultBool = controller.Controller_C91.DefaultValues.Data.BoolValues[value.Index];
					break;

				case AnimatorControllerParameterType.Bool:
					parameter.DefaultBool = controller.Controller_C91.DefaultValues.Data.BoolValues[value.Index];
					break;

				case AnimatorControllerParameterType.Int:
					parameter.DefaultInt = controller.Controller_C91.DefaultValues.Data.IntValues[value.Index];
					break;

				case AnimatorControllerParameterType.Float:
					parameter.DefaultFloat = controller.Controller_C91.DefaultValues.Data.FloatValues[value.Index];
					break;

				default:
					throw new NotSupportedException($"Parameter type '{type}' isn't supported");
			}
			parameter.Type = (int)type;
			if (parameter.Has_Controller())
			{
				parameter.Controller.CopyValues(controller.SerializedFile.CreatePPtr(controller));
			}
		}

		public static AnimatorControllerParameterType GetTypeValue(this IAnimatorControllerParameter parameter)
		{
			return (AnimatorControllerParameterType)parameter.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Animator;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Classes.ClassID_93;
using AssetRipper.SourceGenerated.Classes.ClassID_95;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorExtensions
	{
		public static bool IsContainsAnimationClip(this IAnimator animator, IAnimationClip clip)
		{
			if (animator.Has_Controller_C95_PPtr_AnimatorController__4_0_0_f7())
			{
				IAnimatorController? controller = animator.Controller_C95_PPtr_AnimatorController__4_0_0_f7.FindAsset(animator.SerializedFile);
				return controller is not null && controller.IsContainsAnimationClip(clip);
			}
			else if (animator.Has_Controller_C95_PPtr_RuntimeAnimatorController__4_3_0_f4())
			{
				IRuntimeAnimatorController? controller = animator.Controller_C95_PPtr_RuntimeAnimatorController__4_3_0_f4.FindAsset(animator.SerializedFile);
				return controller is not null && controller.IsContainsAnimationClip(clip);
			}
			else if (animator.Has_Controller_C95_PPtr_RuntimeAnimatorController__5_0_0_f4())
			{
				IRuntimeAnimatorController? controller = animator.Controller_C95_PPtr_RuntimeAnimatorController__5_0_0_f4.FindAsset(animator.SerializedFile);
				return controller is not null && controller.IsContainsAnimationClip(clip);
			}
			else
			{
				return false;
			}
		}

		public static IReadOnlyDictionary<uint, string> BuildTOS(this IAnimator animator)
		{
			if (animator.Has_HasTransformHierarchy_C95())
			{
				if (animator.HasTransformHierarchy_C95)
				{
					IGameObject go = animator.GameObject_C95.GetAsset(animator.SerializedFile);
					return go.BuildTOS();
				}
				else
				{
					return new Dictionary<uint, string>() { { 0, string.Empty } };
				}
			}
			else
			{
				IGameObject go = animator.GameObject_C95.GetAsset(animator.SerializedFile);
				return go.BuildTOS();
			}
		}

		public static AnimatorCullingMode GetCullingMode(this IAnimator animator)
		{
			return (AnimatorCullingMode)animator.CullingMode_C95;
		}

		public static AnimatorUpdateMode GetUpdateMode(this IAnimator animator)
		{
			return animator.Has_UpdateMode_C95() ? (AnimatorUpdateMode)animator.UpdateMode_C95 : AnimatorUpdateMode.Normal;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AnimatorOverrideControllerExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_93;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipOverride;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AnimatorOverrideControllerExtensions
	{
		public static bool IsContainsAnimationClip(this IAnimatorOverrideController controller, IAnimationClip clip)
		{
			foreach (IAnimationClipOverride overClip in controller.Clips_C221)
			{
				if (overClip.OriginalClip.IsAsset(controller.SerializedFile, clip))
				{
					return true;
				}
				else if (overClip.OverrideClip.IsAsset(controller.SerializedFile, clip))
				{
					return true;
				}
			}
			IRuntimeAnimatorController? baseController = controller.Controller_C221.FindAsset(controller.SerializedFile);
			if (baseController != null)
			{
				return baseController.IsContainsAnimationClip(clip);
			}
			return false;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AssetBundleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_142;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AssetBundleExtensions
	{
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool HasPathExtension(UnityVersion version) => version.IsGreaterEqual(5);

		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool HasPathExtension(this IAssetBundle bundle) => HasPathExtension(bundle.SerializedFile.Version);

		public static string GetAssetBundleName(this IAssetBundle bundle)
		{
			return bundle.Has_AssetBundleName_C142() ? bundle.AssetBundleName_C142.String : bundle.SerializedFile.Name;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AudioClipExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AudioClip;
using AssetRipper.Core.Extensions;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AudioClipExtensions
	{
		public static byte[] GetAudioData(this IAudioClip audioClip)
		{
			if (!audioClip.AudioData_C83.IsNullOrEmpty())
			{
				return audioClip.AudioData_C83;
			}
			else if (audioClip.Resource_C83 != null)
			{
				return audioClip.Resource_C83.GetContent(audioClip.SerializedFile) ?? Array.Empty<byte>();
			}
			//else if (audioClip.StreamingInfo_C83 != null && audioClip.LoadType_C83 == (int)Classes.AudioClip.AudioClipLoadType.Streaming)
			//{
			//	return audioClip.StreamingInfo_C83.GetContent(audioClip.SerializedFile) ?? Array.Empty<byte>();
			//}
			else
			{
				return Array.Empty<byte>();
			}
		}

		public static bool CheckAssetIntegrity(this IAudioClip audioClip)
		{
			if (!audioClip.AudioData_C83.IsNullOrEmpty())
			{
				return true;
			}
			else if (audioClip.Resource_C83 != null)
			{
				return audioClip.Resource_C83.CheckIntegrity(audioClip.SerializedFile);
			}
			//else if (audioClip.StreamingInfo != null && audioClip.LoadType_C83 == (int)Classes.AudioClip.AudioClipLoadType.Streaming)
			//{
			//	return audioClip.StreamingInfo.CheckIntegrity(audioClip.SerializedFile);
			//}
			else
			{
				return true;
			}
		}

		public static AudioClipLoadType GetLoadType(this IAudioClip audioClip) => (AudioClipLoadType)audioClip.LoadType_C83;

		/// <summary>
		/// Only present when <see cref="IAudioClip.Has_CompressionFormat_C83"/> is true.
		/// </summary>
		public static AudioCompressionFormat GetCompressionFormat(this IAudioClip audioClip) => (AudioCompressionFormat)audioClip.CompressionFormat_C83;

		public static FMODSoundFormat GetSoundFormat(this IAudioClip audioClip) => (FMODSoundFormat)audioClip.Format_C83;

		/// <summary>
		/// Only present when <see cref="IAudioClip.Has_Type_C83"/> is true.
		/// </summary>
		public static FMODSoundType GetSoundType(this IAudioClip audioClip) => (FMODSoundType)audioClip.Type_C83;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AudioManagerExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AudioManager;
using AssetRipper.SourceGenerated.Classes.ClassID_11;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AudioManagerExtensions
	{
		public static AudioSpeakerMode GetDefaultSpeakerMode(this IAudioManager audioManager)
		{
			return (AudioSpeakerMode)audioManager.Default_Speaker_Mode_C11;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AudioReverbFilterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AudioReverbFilter;
using AssetRipper.SourceGenerated.Classes.ClassID_164;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AudioReverbFilterExtensions
	{
		public static AudioReverbPreset GetReverbPreset(this IAudioReverbFilter audioReverbFilter)
		{
			return (AudioReverbPreset)audioReverbFilter.ReverbPreset_C164;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AudioSourceExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AudioSource;
using AssetRipper.SourceGenerated.Classes.ClassID_82;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AudioSourceExtensions
	{
		public static AudioRolloffMode GetRolloffMode(this IAudioSource source)
		{
			return (AudioRolloffMode)source.RolloffMode_C82;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AvatarConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.AvatarConstant;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_SkeletonPose;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AvatarConstantExtensions
	{
		public static IOffsetPtr_SkeletonPose GetDefaultPose(this IAvatarConstant constant)
		{
			return constant.Has_DefaultPose() ? constant.DefaultPose : constant.SkeletonPose!;
		}

		public static uint[] GetSkeletonNameIDArray(this IAvatarConstant constant)
		{
			return constant.Has_SkeletonNameIDArray() ? constant.SkeletonNameIDArray : constant.Skeleton!.Data.ID;
		}

		public static int[] GetRootMotionSkeletonIndexArray(this IAvatarConstant constant)
		{
			return constant.RootMotionSkeletonIndexArray ?? Array.Empty<int>();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/AvatarExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_90;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class AvatarExtensions
	{
		public static Utf8String? FindBonePath(this IAvatar avatar, uint hash)
		{
			avatar.TOS_C90.TryGetValue(hash, out Utf8String? result);
			return result;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/BlendShapeDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BlendShapeData;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShapeChannel;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class BlendShapeDataExtensions
	{
		public static string? FindShapeNameByCRC(this IBlendShapeData blendShapeData, uint crc)
		{
			foreach (MeshBlendShapeChannel blendChannel in blendShapeData.Channels)
			{
				if (blendChannel.NameHash == crc)
				{
					return blendChannel.Name.String;
				}
			}
			return null;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/BlendTreeExtensions.cs`:

```cs
using AssetRipper.Core.Classes.BlendTree;
using AssetRipper.SourceGenerated.Classes.ClassID_206;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class BlendTreeExtensions
	{
		public static BlendTreeType GetBlendType(this IBlendTree tree)
		{
			return tree.Has_BlendType_C206_Int32() ? (BlendTreeType)tree.BlendType_C206_Int32 : (BlendTreeType)tree.BlendType_C206_UInt32;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/BlendTreeNodeConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.BlendTree;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimationClip_;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class BlendTreeNodeConstantExtensions
	{
		public static IPPtr_AnimationClip_ CreateMotion(this IBlendTreeNodeConstant constant, IAnimatorController controller, int clipIndex)
		{
			if (clipIndex == -1)
			{
				return PPtr_AnimationClip_Factory.CreateAsset(controller.SerializedFile.Version);
			}
			else
			{
				return controller.AnimationClips_C91[clipIndex];
			}
		}

		public static float GetThreshold(this IBlendTreeNodeConstant constant, int index)
		{
			if (constant.Has_Blend1dData())
			{
				if (constant.GetBlendType() == BlendTreeType.Simple1D)
				{
					return constant.Blend1dData.Data.ChildThresholdArray[index];
				}
			}
			else if (constant.Has_ChildThresholdArray())
			{
				return constant.ChildThresholdArray[index];
			}
			return 0.0f;
		}

		public static Vector2f_3_5_0_f5 GetPosition(this IBlendTreeNodeConstant constant, int index)
		{
			if (constant.Has_Blend2dData())
			{
				if (constant.GetBlendType() != BlendTreeType.Simple1D && constant.GetBlendType() != BlendTreeType.Direct)
				{
					return constant.Blend2dData.Data.m_ChildPositionArray[index];
				}
			}
			return new();
		}

		public static float GetMinThreshold(this IBlendTreeNodeConstant constant)
		{
			if (constant.Has_Blend1dData())
			{
				if (constant.GetBlendType() == BlendTreeType.Simple1D)
				{
					return constant.Blend1dData.Data.ChildThresholdArray.Min();
				}
			}
			return 0.0f;
		}

		public static float GetMaxThreshold(this IBlendTreeNodeConstant constant)
		{
			if (constant.Has_Blend1dData())
			{
				if (constant.GetBlendType() == BlendTreeType.Simple1D)
				{
					return constant.Blend1dData.Data.ChildThresholdArray.Max();
				}
			}
			return 1.0f;
		}

		public static uint GetDirectBlendParameter(this IBlendTreeNodeConstant constant, int index)
		{
			if (constant.Has_BlendDirectData())
			{
				if (constant.GetBlendType() == BlendTreeType.Direct)
				{
					return constant.BlendDirectData.Data.m_ChildBlendEventIDArray[index];
				}
			}
			return 0;
		}

		public static bool IsBlendTree(this IBlendTreeNodeConstant constant) => constant.ChildIndices.Length > 0;
		public static BlendTreeType GetBlendType(this IBlendTreeNodeConstant constant) => (BlendTreeType)constant.BlendType;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/BufferBindingExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BufferBinding;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class BufferBindingExtensions
	{
		public static void SetValues(this IBufferBinding binding, string name, int index)
		{
			//binding.Name = name;//Name doesn't exist
			binding.NameIndex = -1;
			binding.Index = index;
			binding.ArraySize = 0;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/BuiltinShaderSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.GraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.BuiltinShaderSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class BuiltinShaderSettingsExtensions
	{
		public static BuiltinShaderMode GetMode(this IBuiltinShaderSettings settings)
		{
			return (BuiltinShaderMode)settings.Mode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CameraExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Camera;
using AssetRipper.SourceGenerated.Classes.ClassID_20;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CameraExtensions
	{
		public static FieldOfViewAxis GetFOVAxisMode(this ICamera camera) => (FieldOfViewAxis)camera.FOVAxisMode_C20;

		public static ProjectionMatrixMode GetProjectionMatrixMode(this ICamera camera) => (ProjectionMatrixMode)camera.ProjectionMatrixMode_C20;

		public static GateFitMode GetGateFitMode(this ICamera camera) => (GateFitMode)camera.GateFitMode_C20;

		public static RenderingPath GetRenderingPath(this ICamera camera) => (RenderingPath)camera.RenderingPath_C20;

		public static StereoTargetEyeMask GetStereoTargetEyeMask(this ICamera camera) => (StereoTargetEyeMask)camera.TargetEye_C20;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CanvasExtensions.cs`:

```cs
using AssetRipper.Core.Classes.UI.Canvas;
using AssetRipper.SourceGenerated.Classes.ClassID_223;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CanvasExtensions
	{
		public static RenderMode GetRenderMode(this ICanvas canvas)
		{
			return (RenderMode)canvas.RenderMode_C223;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CapsuleCollider2DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.CapsuleCollider2D;
using AssetRipper.SourceGenerated.Classes.ClassID_70;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CapsuleCollider2DExtensions
	{
		public static CapsuleDirection2D GetDirection(this ICapsuleCollider2D collider)
		{
			return (CapsuleDirection2D)collider.Direction_C70;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ChannelInfoExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.SourceGenerated.Subclasses.ChannelInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	/*
		/// <summary>
		/// Stream index
		/// BinaryData:[Stream0][Align][Stream1][Align]...
		/// </summary>
		byte Stream { get; set; }
		/// <summary>
		/// Offset inside stream
		/// Stream:[FirstVertex: VertexOffset,NormalOffset,TangentOffset...][SecondVertex: VertexOffset,NormalOffset,TangentOffset...]...
		/// </summary>
		byte Offset { get; set; }
		/// <summary>
		/// Data format: float, int, byte
		/// </summary>
		byte Format { get; set; }
		/// <summary>
		/// An unprocessed byte value containing the data dimension
		/// </summary>
		byte Dimension { get; set; }
	 */

	public static class ChannelInfoExtensions
	{
		public static bool IsSet(this IChannelInfo channelInfo) => channelInfo.Dimension > 0;

		/// <summary>
		/// Data dimention: Vector3, Vector2, Vector1
		/// </summary>
		public static byte GetDataDimension(this IChannelInfo channelInfo)
		{
			return (byte)(channelInfo.Dimension & 0b00001111);
		}

		/// <summary>
		/// Data dimention: Vector3, Vector2, Vector1
		/// </summary>
		public static void SetDataDimension(this IChannelInfo channelInfo, byte value)
		{
			channelInfo.Dimension = (byte)((channelInfo.Dimension & 0b11110000) | (value & 0b00001111));
		}

		public static byte GetStride(this IChannelInfo channelInfo, UnityVersion version)
		{
			return channelInfo.GetVertexFormat(version).CalculateStride(version, channelInfo.GetDataDimension());
		}

		public static VertexFormat GetVertexFormat(this IChannelInfo channelInfo, UnityVersion version)
		{
			if (VertexFormatExtensions.VertexFormat2019Relevant(version))
			{
				return ((VertexFormat2019)channelInfo.Format).ToVertexFormat();
			}
			else if (VertexFormatExtensions.VertexFormat2017Relevant(version))
			{
				return ((VertexFormat2017)channelInfo.Format).ToVertexFormat();
			}
			else
			{
				return ((VertexChannelFormat)channelInfo.Format).ToVertexFormat();
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ChildMotionExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeConstant;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using AssetRipper.SourceGenerated.Subclasses.ChildMotion;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ChildMotionExtensions
	{
		public static void SetValues(this IChildMotion childMotion, VirtualSerializedFile file, IAnimatorController controller, IStateConstant state, int nodeIndex, int childIndex)
		{
			IBlendTreeConstant treeConstant = state.GetBlendTree();
			IBlendTreeNodeConstant node = treeConstant.NodeArray[nodeIndex].Data;
			int childNodeIndex = (int)node.ChildIndices[childIndex];
			childMotion.Motion.CopyValues(state.CreateMotion(file, controller, childNodeIndex));

			childMotion.Threshold = node.GetThreshold(childIndex);
			childMotion.Position?.CopyValues(node.GetPosition(childIndex));
			childMotion.TimeScale = 1.0f;
			childMotion.CycleOffset = node.CycleOffset;

			uint directID = node.GetDirectBlendParameter(childIndex);
			childMotion.DirectBlendParameter?.CopyValues(controller.TOS_C91[directID]);

			childMotion.Mirror = node.Mirror;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ClipExtensions.cs`:

```cs
using AssetRipper.Core.IO;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipBindingConstant;
using AssetRipper.SourceGenerated.Subclasses.Clip;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_ValueArrayConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ClipExtensions
	{
		public static bool IsSet(this IClip clip)
		{
			return clip.StreamedClip.IsSet() 
				|| clip.DenseClip.IsSet() 
				|| (clip.Has_ConstantClip() && clip.ConstantClip.IsSet());
		}

		public static void ConvertValueArrayToGenericBinding(this IClip clip, IAnimationClipBindingConstant bindings)
		{
			if (clip.Has_Binding())
			{
				AccessListBase<IGenericBinding> genericBindings = bindings.GenericBindings;
				IOffsetPtr_ValueArrayConstant values = clip.Binding;
				for (int i = 0; i < values.Data.ValueArray.Count;)
				{
					uint curveID = values.Data.ValueArray[i].ID;
					uint curveTypeID = values.Data.ValueArray[i].TypeID;
					IGenericBinding binding = genericBindings.AddNew();

					if (curveTypeID == 4174552735) //CRC(PositionX))
					{
						binding.Path = curveID;
						binding.Attribute = 1; //kBindTransformPosition
						binding.SetClassID(ClassIDType.Transform);
						i += 3;
					}
					else if (curveTypeID == 2211994246) //CRC(QuaternionX))
					{
						binding.Path = curveID;
						binding.Attribute = 2; //kBindTransformRotation
						binding.SetClassID(ClassIDType.Transform);
						i += 4;
					}
					else if (curveTypeID == 1512518241) //CRC(ScaleX))
					{
						binding.Path = curveID;
						binding.Attribute = 3; //kBindTransformScale
						binding.SetClassID(ClassIDType.Transform);
						i += 3;
					}
					else
					{
						binding.Path = 0;
						binding.Attribute = curveID;
						binding.SetClassID(ClassIDType.Animator);
						i++;
					}
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CollisionModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.CollisionModule;
using AssetRipper.SourceGenerated.Subclasses.CollisionModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CollisionModuleExtensions
	{
		public static ParticleSystemCollisionType GetCollisionType(this ICollisionModule module)
		{
			return (ParticleSystemCollisionType)module.Type;
		}
		
		public static ParticleSystemCollisionMode GetCollisionMode(this ICollisionModule module)
		{
			return (ParticleSystemCollisionMode)module.CollisionMode;
		}

		public static ParticleSystemCollisionQuality GetCollisionQuality(this ICollisionModule module)
		{
			return (ParticleSystemCollisionQuality)module.Quality;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ColorRGBA32Extensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ColorRGBA32;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ColorRGBA32Extensions
	{
		public static void SetValues(this IColorRGBA32 color, byte r, byte g, byte b, byte a)
		{
			color.Rgba = unchecked((uint)(r | g << 8 | b << 16 | a << 24));
		}

		public static void SetAsBlack(this IColorRGBA32 color) => color.SetValues(byte.MinValue, byte.MinValue, byte.MinValue, byte.MaxValue);

		public static void SetAsWhite(this IColorRGBA32 color) => color.SetValues(uint.MaxValue);

		public static byte GetR(this IColorRGBA32 color)
		{
			return unchecked((byte)color.Rgba);
		}

		public static byte GetG(this IColorRGBA32 color)
		{
			return unchecked((byte)(color.Rgba >> 8));
		}

		public static byte GetB(this IColorRGBA32 color)
		{
			return unchecked((byte)(color.Rgba >> 16));
		}

		public static byte GetA(this IColorRGBA32 color)
		{
			return unchecked((byte)(color.Rgba >> 24));
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ColorRGBAfExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ColorRGBAf;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ColorRGBAfExtensions
	{
		public static void SetAsBlack(this IColorRGBAf color) => color.SetValues(0f, 0f, 0f, 1f);

		public static void SetAsWhite(this IColorRGBAf color) => color.SetValues(1f, 1f, 1f, 1f);
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ComponentExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_2;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ComponentExtensions
	{
		public static IGameObject GetGameObject(this IComponent component)
		{
			return component.GameObject_C2.GetAsset(component.SerializedFile);
		}

		public static IGameObject? TryGetGameObject(this IComponent component)
		{
			return component.GameObject_C2.TryGetAsset(component.SerializedFile);
		}

		public static IGameObject GetRoot(this IComponent component)
		{
			return component.GetGameObject().GetRoot();
		}

		public static int GetRootDepth(this IComponent component)
		{
			return component.GetGameObject().GetRootDepth();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CompositeCollider2DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.CompositeCollider2D;
using AssetRipper.SourceGenerated.Classes.ClassID_66;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CompositeCollider2DExtensions
	{
		public static GeometryType GetGeometryType(this ICompositeCollider2D collider)
		{
			return (GeometryType)collider.GeometryType_C66;
		}

		public static GenerationType GetGenerationType(this ICompositeCollider2D collider)
		{
			return (GenerationType)collider.GenerationType_C66;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CompressedAnimationCurveExtensions.cs`:

```cs
using AssetRipper.Core.IO;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.CompressedAnimationCurve;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CompressedAnimationCurveExtensions
	{
		public static void Unpack(this CompressedAnimationCurve compressedAnimationCurve, UnityVersion version, IQuaternionCurve destinationCurve)
		{
			int[] timesValues = compressedAnimationCurve.Times.UnpackInts();
			float[] times = new float[timesValues.Length];
			for (int i = 0; i < times.Length; i++)
			{
				times[i] = timesValues[i] * 0.01f;
			}
			Quaternionf[] rotations = compressedAnimationCurve.Values.Unpack();
			float[] slopes = compressedAnimationCurve.Slopes.Unpack();


			AccessListBase<IKeyframe_Quaternionf> keyframes = destinationCurve.Curve.Curve; //new KeyframeTpl<Quaternionf>[rotations.Length];
			keyframes.Clear();
			keyframes.Capacity = rotations.Length;

			for (int i = 0, j = 4; i < rotations.Length; i++, j += 4)
			{
				float time = times[i];
				Quaternionf rotation = rotations[i];
				Quaternionf inSlope = new Quaternionf(slopes[j - 4], slopes[j - 3], slopes[j - 2], slopes[j - 1]);
				Quaternionf outSlope = new Quaternionf(slopes[j + 0], slopes[j + 1], slopes[j + 2], slopes[j + 3]);
				IKeyframe_Quaternionf keyframe = keyframes.AddNew();
				keyframe.SetValues(version, time, rotation, inSlope, outSlope, 1.0f / 3.0f);
			}
			destinationCurve.Path.CopyValues(compressedAnimationCurve.Path);
			destinationCurve.Curve.SetDefaultRotationOrderAndCurveLoopType();
			destinationCurve.Curve.PreInfinity = compressedAnimationCurve.PreInfinity;
			destinationCurve.Curve.PostInfinity = compressedAnimationCurve.PostInfinity;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CompressedMeshExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.CompressedMesh;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CompressedMeshExtensions
	{
		public static void DecompressCompressedMesh(this ICompressedMesh compressedMesh,
			UnityVersion version,
			out int vertexCount,
			out Vector3f[]? vertices,
			out Vector3f[]? normals,
			out Vector4f[]? tangents,
			out ColorRGBA32[]? colors,
			out BoneWeights4[]? skin,
			out Vector2f[]? uv0,
			out Vector2f[]? uv1,
			out Vector2f[]? uv2,
			out Vector2f[]? uv3,
			out Vector2f[]? uv4,
			out Vector2f[]? uv5,
			out Vector2f[]? uv6,
			out Vector2f[]? uv7,
			out Matrix4x4f[]? bindPose,
			out uint[]? processedIndexBuffer)
		{
			vertexCount = default;
			vertices = default;
			normals = default;
			tangents = default;
			colors = default;
			skin = default;
			uv0 = default;
			uv1 = default;
			uv2 = default;
			uv3 = default;
			uv4 = default;
			uv5 = default;
			uv6 = default;
			uv7 = default;
			bindPose = default;
			processedIndexBuffer = default;

			//Vertex
			if (compressedMesh.Vertices.NumItems > 0)
			{
				vertexCount = (int)compressedMesh.Vertices.NumItems / 3;
				float[] verticesData = compressedMesh.Vertices.UnpackFloats(3, 3 * 4);
				vertices = MeshHelper.FloatArrayToVector3(verticesData);
			}
			//UV
			if (compressedMesh.UV.NumItems > 0)
			{
				uint m_UVInfo = compressedMesh.UVInfo;
				if (m_UVInfo != 0)
				{
					const int kInfoBitsPerUV = 4;
					const int kUVDimensionMask = 3;
					const int kUVChannelExists = 4;
					const int kMaxTexCoordShaderChannels = 8;

					int uvSrcOffset = 0;
					for (int uvIndex = 0; uvIndex < kMaxTexCoordShaderChannels; uvIndex++)
					{
						uint texCoordBits = m_UVInfo >> (uvIndex * kInfoBitsPerUV);
						texCoordBits &= (1u << kInfoBitsPerUV) - 1u;
						if ((texCoordBits & kUVChannelExists) != 0)
						{
							int uvDim = 1 + (int)(texCoordBits & kUVDimensionMask);
							Vector2f[] m_UV = MeshHelper.FloatArrayToVector2(compressedMesh.UV.UnpackFloats(uvDim, uvDim * 4, uvSrcOffset, vertexCount));
							switch (uvIndex)
							{
								case 0:
									uv0 = m_UV;
									break;
								case 1:
									uv1 = m_UV;
									break;
								case 2:
									uv2 = m_UV;
									break;
								case 3:
									uv3 = m_UV;
									break;
								case 4:
									uv4 = m_UV;
									break;
								case 5:
									uv5 = m_UV;
									break;
								case 6:
									uv6 = m_UV;
									break;
								case 7:
									uv7 = m_UV;
									break;
								default:
									throw new IndexOutOfRangeException();
							}
							uvSrcOffset += uvDim * vertexCount;
						}
					}
				}
				else
				{
					uv0 = MeshHelper.FloatArrayToVector2(compressedMesh.UV.UnpackFloats(2, 2 * 4, 0, vertexCount));
					if (compressedMesh.UV.NumItems >= vertexCount * 4)
					{
						uv1 = MeshHelper.FloatArrayToVector2(compressedMesh.UV.UnpackFloats(2, 2 * 4, vertexCount * 2, vertexCount));
					}
				}
			}
			//BindPose
			if (compressedMesh.Has_BindPoses())
			{
				if (compressedMesh.BindPoses.NumItems > 0)
				{
					bindPose = new Matrix4x4f[compressedMesh.BindPoses.NumItems / 16];
					float[] m_BindPoses_Unpacked = compressedMesh.BindPoses.UnpackFloats(16, 4 * 16);
					float[] buffer = new float[16];
					for (int i = 0; i < bindPose.Length; i++)
					{
						Array.Copy(m_BindPoses_Unpacked, i * 16, buffer, 0, 16);
						bindPose[i] = new Matrix4x4f(buffer);
					}
				}
			}
			//Normal
			if (compressedMesh.Normals.NumItems > 0)
			{
				float[] normalData = compressedMesh.Normals.UnpackFloats(2, 4 * 2);
				int[] signs = compressedMesh.NormalSigns.UnpackInts();
				normals = new Vector3f[compressedMesh.Normals.NumItems / 2];
				for (int i = 0; i < compressedMesh.Normals.NumItems / 2; ++i)
				{
					float x = normalData[i * 2 + 0];
					float y = normalData[i * 2 + 1];
					float zsqr = 1 - x * x - y * y;
					float z;
					if (zsqr >= 0f)
					{
						z = (float)System.Math.Sqrt(zsqr);
					}
					else
					{
						z = 0;
						Vector3f normal = new Vector3f(x, y, z);
						normal.Normalize();
						x = normal.X;
						y = normal.Y;
						z = normal.Z;
					}
					if (signs[i] == 0)
					{
						z = -z;
					}

					normals[i] = new Vector3f(x, y, z);
				}
			}
			//Tangent
			if (compressedMesh.Tangents.NumItems > 0)
			{
				float[] tangentData = compressedMesh.Tangents.UnpackFloats(2, 4 * 2);
				int[] signs = compressedMesh.TangentSigns.UnpackInts();
				tangents = new Vector4f[compressedMesh.Tangents.NumItems / 2];
				for (int i = 0; i < compressedMesh.Tangents.NumItems / 2; ++i)
				{
					float x = tangentData[i * 2 + 0];
					float y = tangentData[i * 2 + 1];
					float zsqr = 1 - x * x - y * y;
					float z;
					if (zsqr >= 0f)
					{
						z = (float)System.Math.Sqrt(zsqr);
					}
					else
					{
						z = 0;
						Vector3f vector3f = new Vector3f(x, y, z);
						vector3f.Normalize();
						x = vector3f.X;
						y = vector3f.Y;
						z = vector3f.Z;
					}
					if (signs[i * 2 + 0] == 0)
					{
						z = -z;
					}

					float w = signs[i * 2 + 1] > 0 ? 1.0f : -1.0f;
					tangents[i] = new Vector4f(x, y, z, w);
				}
			}
			//FloatColor
			if (compressedMesh.Has_FloatColors())
			{
				if (compressedMesh.FloatColors.NumItems > 0)
				{
					colors = MeshHelper.FloatArrayToColorRGBA32(compressedMesh.FloatColors.UnpackFloats(1, 4));
				}
			}
			//Skin
			if (compressedMesh.Weights.NumItems > 0)
			{
				int[] weights = compressedMesh.Weights.UnpackInts();
				int[] boneIndices = compressedMesh.BoneIndices.UnpackInts();

				skin = new BoneWeights4[vertexCount];
				for (int i = 0; i < vertexCount; i++)
				{
					skin[i] = new BoneWeights4();
				}

				int bonePos = 0;
				int boneIndexPos = 0;
				int j = 0;
				int sum = 0;

				for (int i = 0; i < compressedMesh.Weights.NumItems; i++)
				{
					//read bone index and weight.
					skin[bonePos].Weights[j] = weights[i] / 31.0f;
					skin[bonePos].BoneIndices[j] = boneIndices[boneIndexPos++];
					j++;
					sum += weights[i];

					//the weights add up to one. fill the rest for this vertex with zero, and continue with next one.
					if (sum >= 31)
					{
						for (; j < 4; j++)
						{
							skin[bonePos].Weights[j] = 0;
							skin[bonePos].BoneIndices[j] = 0;
						}
						bonePos++;
						j = 0;
						sum = 0;
					}
					//we read three weights, but they don't add up to one. calculate the fourth one, and read
					//missing bone index. continue with next vertex.
					else if (j == 3)
					{
						skin[bonePos].Weights[j] = (31 - sum) / 31.0f;
						skin[bonePos].BoneIndices[j] = boneIndices[boneIndexPos++];
						bonePos++;
						j = 0;
						sum = 0;
					}
				}
			}
			//IndexBuffer
			if (compressedMesh.Triangles.NumItems > 0)
			{
				processedIndexBuffer = Array.ConvertAll(compressedMesh.Triangles.UnpackInts(), x => (uint)x);
			}
			//Color
			if (compressedMesh.Has_Colors() && compressedMesh.Colors.NumItems > 0)
			{
				compressedMesh.Colors.NumItems *= 4;
				compressedMesh.Colors.BitSize /= 4;
				int[] tempColors = compressedMesh.Colors.UnpackInts();
				colors = new ColorRGBA32[compressedMesh.Colors.NumItems / 4];
				for (int v = 0; v < compressedMesh.Colors.NumItems / 4; v++)
				{
					colors[v] = new ColorRGBA32((byte)tempColors[4 * v], (byte)tempColors[4 * v + 1], (byte)tempColors[4 * v + 2], (byte)tempColors[4 * v + 3]);
				}
				compressedMesh.Colors.NumItems /= 4;
				compressedMesh.Colors.BitSize *= 4;
			}
		}

	}
}

```

`AssetRipperCommon/SourceGenExtensions/ConditionConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorTransition;
using AssetRipper.SourceGenerated.Subclasses.ConditionConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ConditionConstantExtensions
	{
		public static AnimatorConditionMode GetConditionMode(this ConditionConstant constant)
		{
			return (AnimatorConditionMode)constant.ConditionMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ConstantClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ConstantClip;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ConstantClipExtensions
	{
		public static bool IsSet(this IConstantClip clip) => clip.Data.Length > 0;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ControllerConstantExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ControllerConstant;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ControllerConstantExtensions
	{
		public static ILayerConstant GetLayerByStateMachineIndex(this IControllerConstant controllerConstant, int index)
		{
			for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
			{
				ILayerConstant layer = controllerConstant.LayerArray[i].Data;
				if (layer.StateMachineIndex == index && layer.StateMachineSynchronizedLayerIndex == 0)
				{
					return layer;
				}
			}
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		public static int GetLayerIndexByStateMachineIndex(this IControllerConstant controllerConstant, int index)
		{
			for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
			{
				ILayerConstant layer = controllerConstant.LayerArray[i].Data;
				if (layer.StateMachineIndex == index && layer.StateMachineSynchronizedLayerIndex == 0)
				{
					return i;
				}
			}
			throw new ArgumentOutOfRangeException(nameof(index));
		}

		public static int GetLayerIndex(this IControllerConstant controllerConstant, ILayerConstant layer)
		{
			for (int i = 0; i < controllerConstant.LayerArray.Count; i++)
			{
				ILayerConstant checkLayer = controllerConstant.LayerArray[i].Data;
				if (checkLayer.StateMachineIndex == layer.StateMachineIndex && checkLayer.StateMachineSynchronizedLayerIndex == layer.StateMachineSynchronizedLayerIndex)
				{
					return i;
				}
			}
			throw new ArgumentException("Layer hasn't been found", nameof(layer));
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CrashReportingSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.CrashReportingSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CrashReportingSettingsExtensions
	{
		public static void ConvertToEditorFormat(this ICrashReportingSettings settings)
		{
			if(settings.Has_NativeEventUrl() && settings.NativeEventUrl.Data.Length == 0)
			{
				settings.NativeEventUrl.String = "https://perf-events.cloud.unity3d.com/symbolicate"; //not sure where this url came from
			}

			// NOTE: editor has different value than player
			settings.LogBufferSize = 10;

			settings.CaptureEditorExceptions = true;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/CustomDataModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.CustomDataModule;
using AssetRipper.SourceGenerated.Subclasses.CustomDataModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class CustomDataModuleExtensions
	{
		public static ParticleSystemCustomDataMode GetMode0(this ICustomDataModule module)
		{
			return (ParticleSystemCustomDataMode)module.Mode0;
		}

		public static ParticleSystemCustomDataMode GetMode1(this ICustomDataModule module)
		{
			return (ParticleSystemCustomDataMode)module.Mode1;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/DenseClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.DenseClip;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class DenseClipExtensions
	{
		public static bool IsSet(this IDenseClip clip) => clip.SampleArray.Length > 0;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/DetailPrototypeExtensions.cs`:

```cs
using AssetRipper.Core.Classes.TerrainData;
using AssetRipper.SourceGenerated.Subclasses.DetailPrototype;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class DetailPrototypeExtensions
	{
		public static DetailRenderMode GetRenderMode(this IDetailPrototype info)
		{
			return (DetailRenderMode)info.RenderMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/EditorSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.EditorSettings;
using AssetRipper.SourceGenerated.Classes.ClassID_159;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class EditorSettingsExtensions
	{
		private const string DefaultExtensions = "txt;xml;fnt;cd;asmdef;rsp" + ";" + AsmrefExtension;
		private const string AsmrefExtension = "asmref";
		private const string HiddenMeta = "Hidden Meta Files";
		private const string VisibleMeta = "Visible Meta Files";

		public static void SetToDefaults(this IEditorSettings settings)
		{
			settings.ExternalVersionControlSupport_C159_Utf8String.TrySet(VisibleMeta);
			settings.ExternalVersionControlSupport_C159_Int32 = (int)ExternalVersionControl.Generic;

			settings.SerializationMode_C159 = (int)SerializationMode.ForceText;
			settings.SpritePackerPaddingPower_C159 = 1;
			settings.EtcTextureCompressorBehavior_C159 = 1;
			settings.EtcTextureFastCompressor_C159 = 1;
			settings.EtcTextureNormalCompressor_C159 = 2;
			settings.EtcTextureBestCompressor_C159 = 4;
			settings.ProjectGenerationIncludedExtensions_C159.TrySet(DefaultExtensions);
			settings.ProjectGenerationRootNamespace_C159.TrySet(string.Empty);
			if(settings.Has_CollabEditorSettings_C159())
			{
				settings.CollabEditorSettings_C159.InProgressEnabled = true;
			}
			settings.UserGeneratedProjectSuffix_C159.TrySet(string.Empty);
			settings.EnableTextureStreamingInEditMode_C159 = true;
			settings.EnableTextureStreamingInPlayMode_C159 = true;
			settings.AsyncShaderCompilation_C159 = true;
			settings.AssetPipelineMode_C159 = (int)AssetPipelineMode.Version1;
			settings.CacheServerMode_C159 = (int)CacheServerMode.AsPreferences;
			settings.CacheServerEndpoint_C159.TrySet(string.Empty);
			settings.CacheServerNamespacePrefix_C159.TrySet("default");
			settings.CacheServerEnableDownload_C159 = false;
			settings.CacheServerEnableUpload_C159 = false;

			settings.ShowLightmapResolutionOverlay_C159 = true;
			settings.UseLegacyProbeSampleCount_C159 = true;
			settings.EnterPlayModeOptions_C159 = (int)(EnterPlayModeOptions.DisableDomainReload | EnterPlayModeOptions.DisableSceneReload);
		}

		private static void TrySet(this Utf8StringBase? utf8String, string str)
		{
			if(utf8String is not null)
			{
				utf8String.String = str;
			}
		}

		public static SerializationMode GetSerializationMode(this IEditorSettings settings)
		{
			return (SerializationMode)settings.SerializationMode_C159;
		}

		public static AssetPipelineMode GetAssetPipelineMode(this IEditorSettings settings)
		{
			return (AssetPipelineMode)settings.AssetPipelineMode_C159;
		}

		public static CacheServerMode GetCacheServerMode(this IEditorSettings settings)
		{
			return (CacheServerMode)settings.CacheServerMode_C159;
		}

		public static EnterPlayModeOptions GetEnterPlayModeOptions(this IEditorSettings settings)
		{
			return (EnterPlayModeOptions)settings.EnterPlayModeOptions_C159;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/EmissionModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.Emission;
using AssetRipper.SourceGenerated.Subclasses.EmissionModule;
using AssetRipper.SourceGenerated.Subclasses.MinMaxCurve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class EmissionModuleExtensions
	{
		public static IMinMaxCurve? GetRateOverTime(this IEmissionModule module)
		{
			if (module.Has_RateOverTime())
			{
				return module.RateOverTime;
			}
			else if (module.Has_Type() && module.Type == (int)EmissionType.Time)
			{
				return module.Rate;
			}
			else
			{
				return null;
			}
		}

		public static IMinMaxCurve? GetRateOverDistance(this IEmissionModule module)
		{
			if (module.Has_RateOverDistance())
			{
				return module.RateOverDistance;
			}
			else if (module.Has_Type() && module.Type == (int)EmissionType.Distance)
			{
				return module.Rate;
			}
			else
			{
				return null;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ExternalForcesModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ExternalForcesModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ExternalForcesModuleExtensions
	{
		public static void SetToDefault(this IExternalForcesModule module, UnityVersion version)
		{
			module.MultiplierCurve?.SetValues(version, 1f);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/FlareExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Flare;
using AssetRipper.SourceGenerated.Classes.ClassID_121;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class FlareExtensions
	{
		public static TextureLayout GetTextureLayout(this IFlare flare)
		{
			return (TextureLayout)flare.TextureLayout_C121;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/FloatCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.FloatCurve;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoScript_;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class FloatCurveExtensions
	{
		public static void SetValues(this IFloatCurve curve, string path, string attribute, ClassIDType classID, IPPtr_MonoScript_ script)
		{
			curve.Path.String = path;
			curve.Attribute.String = attribute;
			curve.ClassID = (int)classID;
			curve.Script.CopyValues(script);
			curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/FontExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Font;
using AssetRipper.SourceGenerated.Classes.ClassID_128;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class FontExtensions
	{
		public static FontStyle GetDefaultStyle(this IFont font)
		{
			return (FontStyle)font.DefaultStyle_C128;
		}

		public static FontRenderingMode GetFontRenderingMode(this IFont font)
		{
			return (FontRenderingMode)font.FontRenderingMode_C128;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GISettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.LightmapSettings.GISettings;
using AssetRipper.SourceGenerated.Subclasses.GISettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GISettingsExtensions
	{
		public static void Initialize(this IGISettings settings)
		{
			settings.BounceScale = 1.0f;
			settings.IndirectOutputScale = 1.0f;
			settings.AlbedoBoost = 1.0f;
			settings.TemporalCoherenceThreshold = 1.0f;
			settings.EnvironmentLightingMode = (uint)EnvironmentAmbientMode.Realtime;
			settings.EnableBakedLightmaps = true;
			settings.EnableRealtimeLightmaps = true;
		}

		public static EnvironmentAmbientMode GetEnvironmentLightingMode(this IGISettings settings)
		{
			return (EnvironmentAmbientMode)settings.EnvironmentLightingMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GLTextureSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.GLTextureSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GLTextureSettingsExtensions
	{
		public static void SetToDefault(this IGLTextureSettings settings)
		{
			settings.FilterMode = (int)(Classes.Texture2D.FilterMode)(-1);
			settings.Aniso = -1;
			settings.MipBias = -100;
			settings.WrapMode = (int)(Classes.Texture2D.TextureWrapMode)(-1);
			settings.WrapU = (int)(Classes.Texture2D.TextureWrapMode)(-1);
			settings.WrapV = (int)(Classes.Texture2D.TextureWrapMode)(-1);
			settings.WrapW = (int)(Classes.Texture2D.TextureWrapMode)(-1);
		}

		public static void CopyValues(this IGLTextureSettings destination, IGLTextureSettings source)
		{
			destination.Aniso = source.Aniso;
			destination.FilterMode = source.FilterMode;
			destination.MipBias = source.MipBias;
			destination.WrapMode = source.WrapMode;
			destination.WrapU = source.WrapU;
			destination.WrapV = source.WrapV;
			destination.WrapW = source.WrapW;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GUITextExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Font;
using AssetRipper.Core.Classes.GUIText;
using AssetRipper.SourceGenerated.Classes.ClassID_132;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GUITextExtensions
	{
		public static TextAnchor GetAnchor(this IGUIText text)
		{
			return (TextAnchor)text.Anchor_C132;
		}

		public static TextAlignment GetAlignment(this IGUIText text)
		{
			return (TextAlignment)text.Alignment_C132;
		}

		public static FontStyle GetFontStyle(this IGUIText text)
		{
			return (FontStyle)text.FontStyle_C132;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GameObjectExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Project;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Classes.ClassID_2;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Component_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Transform_;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GameObjectExtensions
	{
		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool IsActiveInherited(UnityVersion version) => version.IsLess(4);

		private static bool IsActive(this IGameObject gameObject) => gameObject.IsActive_C1_Boolean || gameObject.IsActive_C1_Byte > 0;

		private static bool GetIsActive(this IGameObject gameObject)
		{
			if (IsActiveInherited(gameObject.SerializedFile.Version))
			{
				return gameObject.SerializedFile.Collection.IsScene(gameObject.SerializedFile) ? gameObject.IsActive() : true;
			}
			return gameObject.IsActive();
		}

		public static void ConvertToEditorFormat(this IGameObject gameObject, IExportContainer container)
		{
			bool isActive = gameObject.GetIsActive();
			gameObject.IsActive_C1_Byte = isActive ? (byte)1 : (byte)0;
			gameObject.IsActive_C1_Boolean = isActive;
			gameObject.TagString_C1.String = container.TagIDToName(gameObject.Tag_C1);
		}

		public static IEnumerable<IPPtr_Component_> FetchComponents(this IGameObject gameObject)
		{
			if(gameObject.Component_C1_AssetList_ComponentPair is not null)
			{
				return gameObject.Component_C1_AssetList_ComponentPair.Select(pair => pair.m_Component);
			}
			else if (gameObject.Component_C1_AssetList_NullableKeyValuePair_Int32_PPtr_Component__3_0_0_f5 is not null)
			{
				return gameObject.Component_C1_AssetList_NullableKeyValuePair_Int32_PPtr_Component__3_0_0_f5.Select(pair => pair.Value);
			}
			else if (gameObject.Component_C1_AssetList_NullableKeyValuePair_Int32_PPtr_Component__5_0_0_f4 is not null)
			{
				return gameObject.Component_C1_AssetList_NullableKeyValuePair_Int32_PPtr_Component__5_0_0_f4.Select(pair => pair.Value);
			}
			else
			{
				throw new Exception("All three component properties returned null");
			}
		}

		public static T? FindComponent<T>(this IGameObject gameObject) where T : IComponent
		{
			foreach (IPPtr_Component_ ptr in gameObject.FetchComponents())
			{
				// component could have not implemented asset type
				IComponent? comp = ptr.FindAsset(gameObject.SerializedFile);
				if (comp is T t)
				{
					return t;
				}
			}
			return default;
		}

		public static T GetComponent<T>(this IGameObject gameObject) where T : IComponent
		{
			T? component = gameObject.FindComponent<T>();
			if (component == null)
			{
				throw new Exception($"Component of type {nameof(T)} hasn't been found");
			}
			return component;
		}

		public static ITransform GetTransform(this IGameObject gameObject)
		{
			foreach (IPPtr_Component_ ptr in gameObject.FetchComponents())
			{
				IComponent? comp = ptr.FindAsset(gameObject.SerializedFile);
				if (comp == null)
				{
					continue;
				}

				if (comp is ITransform transform)
				{
					return transform;
				}
			}
			throw new Exception("Can't find transform component");
		}

		public static IGameObject GetRoot(this IGameObject gameObject)
		{
			ITransform root = gameObject.GetTransform();
			while (true)
			{
				ITransform? parent = root.Father_C4.TryGetAsset(root.SerializedFile);
				if (parent == null)
				{
					break;
				}
				else
				{
					root = parent;
				}
			}
			return root.GameObject_C4.GetAsset(root.SerializedFile);
		}

		public static int GetRootDepth(this IGameObject gameObject)
		{
			ITransform root = gameObject.GetTransform();
			int depth = 0;
			while (true)
			{
				ITransform? parent = root.Father_C4.TryGetAsset(root.SerializedFile);
				if (parent == null)
				{
					break;
				}

				root = parent;
				depth++;
			}
			return depth;
		}

		public static IEnumerable<IEditorExtension> FetchHierarchy(this IGameObject root)
		{
			yield return root;

			ITransform? transform = null;
			foreach (IPPtr_Component_ ptr in root.FetchComponents())
			{
				IComponent? component = ptr.FindAsset(root.SerializedFile);
				if (component == null)
				{
					continue;
				}

				yield return component;
				if (component is ITransform trfm)
				{
					transform = trfm;
				}
			}

			if(transform is null)
			{
				throw new Exception("GameObject has no transform");
			}

			foreach (IPPtr_Transform_ pchild in transform.Children_C4)
			{
				ITransform child = pchild.GetAsset(transform.SerializedFile);
				IGameObject childGO = child.GameObject_C4.GetAsset(root.SerializedFile);
				foreach (IEditorExtension childElement in FetchHierarchy(childGO))
				{
					yield return childElement;
				}
			}
		}

		public static IReadOnlyDictionary<uint, string> BuildTOS(this IGameObject gameObject)
		{
			Dictionary<uint, string> tos = new Dictionary<uint, string>() { { 0, string.Empty } };
			gameObject.BuildTOS(gameObject, string.Empty, tos);
			return tos;
		}

		private static void BuildTOS(this IGameObject gameObject, IGameObject parent, string parentPath, Dictionary<uint, string> tos)
		{
			ITransform transform = parent.GetTransform();
			foreach (IPPtr_Transform_ childPtr in transform.Children_C4)
			{
				ITransform childTransform = childPtr.GetAsset(gameObject.SerializedFile);
				IGameObject child = childTransform.GameObject_C4.GetAsset(gameObject.SerializedFile);
				string path = string.IsNullOrEmpty(parentPath) ? child.NameString : $"{parentPath}/{child.NameString}";
				uint pathHash = CrcUtils.CalculateDigestUTF8(path);
				tos[pathHash] = path;

				gameObject.BuildTOS(child, path, tos);
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GenericBindingExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimationClip;
using AssetRipper.Core.Classes.AnimationClip.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GenericBindingExtensions
	{
		public static HumanoidMuscleType GetHumanoidMuscle(this IGenericBinding binding, UnityVersion version)
		{
			return ((HumanoidMuscleType)binding.Attribute).Update(version);
		}

		public static bool IsTransform(this IGenericBinding binding)
		{
			return binding.GetClassID() == ClassIDType.Transform 
				|| binding.GetClassID() == ClassIDType.RectTransform 
				&& binding.TransformType().IsValid();
		}

		public static TransformType TransformType(this IGenericBinding binding)
		{
			return unchecked((TransformType)binding.Attribute);
		}

		public static ClassIDType GetClassID(this IGenericBinding binding)
		{
			return binding.Has_ClassID_UInt16() ? (ClassIDType)binding.ClassID_UInt16 : (ClassIDType)binding.ClassID_Int32;
		}

		public static void SetClassID(this IGenericBinding binding, ClassIDType classID)
		{
			if (binding.Has_ClassID_UInt16())
			{
				binding.ClassID_UInt16 = (ushort)classID;
			}
			else
			{
				binding.ClassID_Int32 = (int)classID;
			}
		}

		public static bool IsPPtrCurve(this IGenericBinding binding)
		{
			return binding.IsPPtrCurve != 0;
		}

		public static bool IsIntCurve(this IGenericBinding binding)
		{
			return binding.IsIntCurve != 0;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GraphicsSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Camera;
using AssetRipper.Core.Classes.GraphicsSettings;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_30;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GraphicsSettingsExtensions
	{
		public static void ConvertToEditorFormat(this IGraphicsSettings settings)
		{
			settings.DefaultMobileRenderingPath_C30 = (int)RenderingPath.Forward;
			settings.DefaultRenderingPath_C30 = (int)RenderingPath.Forward;
			settings.FogKeepExp_C30 = true;
			settings.FogKeepExp2_C30 = true;
			settings.FogKeepLinear_C30 = true;
			settings.FogStripping_C30 = (int)LightmapStrippingMode.Automatic;
			settings.InstancingStripping_C30 = (int)InstancingStrippingVariant.StripUnused;
			settings.LightmapKeepDirCombined_C30 = true;
			settings.LightmapKeepDirSeparate_C30 = true;
			settings.LightmapKeepDynamicDirCombined_C30 = true;
			settings.LightmapKeepDynamicDirSeparate_C30 = true;
			settings.LightmapKeepDynamicPlain_C30 = true;
			settings.LightmapKeepDynamic_C30 = true;
			settings.LightmapKeepPlain_C30 = true;
			settings.LightmapKeepShadowMask_C30 = true;
			settings.LightmapKeepSubtractive_C30 = true;
			settings.LightmapStripping_C30 = (int)LightmapStrippingMode.Automatic;

			if (settings.Has_TierSettings_C30())
			{
				settings.TierSettings_C30.Clear();//protection against converting GraphicsSettings multiple times
				if(settings.Has_TierSettings_Tier1_C30() && settings.Has_TierSettings_Tier2_C30() && settings.Has_TierSettings_Tier3_C30())
				{
					settings.TierSettings_C30.Capacity = 3;
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier1_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier2_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier2);
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.TierSettings_Tier3_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier3);
				}
				else if (settings.Has_ShaderSettings_Tier1_C30() && settings.Has_ShaderSettings_Tier2_C30() && settings.Has_ShaderSettings_Tier3_C30())
				{
					settings.TierSettings_C30.Capacity = 3;
					settings.ShaderSettings_Tier1_C30.ConvertToEditorFormat();
					settings.ShaderSettings_Tier2_C30.ConvertToEditorFormat();
					settings.ShaderSettings_Tier2_C30.ConvertToEditorFormat();
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier1_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier2_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier2);
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.ShaderSettings_Tier3_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier3);
				}
				else if (settings.Has_ShaderSettings_C30())
				{
					settings.TierSettings_C30.Capacity = 1;
					settings.ShaderSettings_C30.ConvertToEditorFormat();
					settings.TierSettings_C30.AddNew().ConvertToEditorFormat(settings.ShaderSettings_C30, settings.GetBuildTargetGroup(), GraphicsTier.Tier1);
				}
			}
		}

		private static BuildTargetGroup GetBuildTargetGroup(this IGraphicsSettings settings)
		{
			return settings.AssetInfo is not null ? settings.AssetInfo.File.Platform.PlatformToBuildGroup() : BuildTargetGroup.Standalone;
		}

		public static TransparencySortMode GetTransparencySortMode(this IGraphicsSettings settings)
		{
			return (TransparencySortMode)settings.TransparencySortMode_C30;
		}

		/// <summary>
		/// Default: <see cref="RenderingPath.Forward"/>
		/// </summary>
		public static RenderingPath GetDefaultRenderingPath(this IGraphicsSettings settings)
		{
			return settings.Has_DefaultRenderingPath_C30() 
				? (RenderingPath)settings.DefaultRenderingPath_C30 
				: RenderingPath.Forward;
		}

		/// <summary>
		/// Default: <see cref="RenderingPath.Forward"/>
		/// </summary>
		public static RenderingPath GetDefaultMobileRenderingPath(this IGraphicsSettings settings)
		{
			return settings.Has_DefaultMobileRenderingPath_C30() 
				? (RenderingPath)settings.DefaultMobileRenderingPath_C30
				: RenderingPath.Forward;
		}

		/// <summary>
		/// Default: <see cref="LightmapStrippingMode.Automatic"/>
		/// </summary>
		public static LightmapStrippingMode GetLightmapStripping(this IGraphicsSettings settings)
		{
			return (LightmapStrippingMode)settings.LightmapStripping_C30; //default is 0, so no need to check if present
		}

		/// <summary>
		/// Default: <see cref="LightmapStrippingMode.Automatic"/>
		/// </summary>
		public static LightmapStrippingMode GetFogStripping(this IGraphicsSettings settings)
		{
			return (LightmapStrippingMode)settings.FogStripping_C30; //default is 0, so no need to check if present
		}

		/// <summary>
		/// Default: <see cref="InstancingStrippingVariant.StripUnused"/>
		/// </summary>
		public static InstancingStrippingVariant GetInstancingStripping(this IGraphicsSettings settings)
		{
			return (InstancingStrippingVariant)settings.InstancingStripping_C30; //default is 0, so no need to check if present
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/GuidExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Subclasses.GUID;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class GuidExtensions
	{
		public static void SetValues(this GUID destination, UnityGUID source)
		{
			destination.m_Data_0_ = source.Data0;
			destination.m_Data_1_ = source.Data1;
			destination.m_Data_2_ = source.Data2;
			destination.m_Data_3_ = source.Data3;
		}

		public static void CopyValues(this GUID destination, GUID source)
		{
			destination.m_Data_0_ = source.m_Data_0_;
			destination.m_Data_1_ = source.m_Data_1_;
			destination.m_Data_2_ = source.m_Data_2_;
			destination.m_Data_3_ = source.m_Data_3_;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/HeightmapExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Heightmap;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class HeightmapExtensions
	{
		public static int GetWidth(this IHeightmap heightmap)
		{
			return heightmap.Has_Width() ? heightmap.Width : heightmap.Resolution;
		}

		public static int GetHeight(this IHeightmap heightmap)
		{
			return heightmap.Has_Height() ? heightmap.Height : heightmap.Resolution;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/HumanExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc.Bones;
using AssetRipper.SourceGenerated.Subclasses.Human;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class HumanExtensions
	{
		public static void UpdateBoneArray(this IHuman human, UnityVersion version)
		{
			human.HumanBoneIndex = UpdateBoneArray(human.HumanBoneIndex, version);
			human.HumanBoneMass = UpdateBoneArray(human.HumanBoneMass, version);
			if (human.Has_ColliderIndex())
			{
				human.ColliderIndex = UpdateBoneArray(human.ColliderIndex, version);
			}
		}

		private static int[] UpdateBoneArray(int[] array, UnityVersion version)
		{
			if (!BoneTypeExtensions.IsIncludeUpperChest(version))
			{
				int[] fixedArray = new int[array.Length + 1];
				BoneType bone;
				for (bone = BoneType.Hips; bone < BoneType.UpperChest; bone++)
				{
					fixedArray[(int)bone] = array[(int)bone];
				}
				fixedArray[(int)bone] = -1;
				for (bone = BoneType.UpperChest + 1; bone < BoneType.Last; bone++)
				{
					fixedArray[(int)bone] = array[(int)bone - 1];
				}
				return fixedArray;
			}
			return array;
		}

		private static float[] UpdateBoneArray(float[] array, UnityVersion version)
		{
			if (!BoneTypeExtensions.IsIncludeUpperChest(version))
			{
				float[] fixedArray = new float[array.Length + 1];
				BoneType bone;
				for (bone = BoneType.Hips; bone < BoneType.UpperChest; bone++)
				{
					fixedArray[(int)bone] = array[(int)bone];
				}
				fixedArray[(int)bone] = 0.0f;
				for (bone = BoneType.UpperChest + 1; bone < BoneType.Last; bone++)
				{
					fixedArray[(int)bone] = array[(int)bone - 1];
				}
				return fixedArray;
			}
			return array;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/IHVImageFormatImporterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_1055;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class IHVImageFormatImporterExtensions
	{
		public static void SetToDefault(this IIHVImageFormatImporter importer)
		{
			importer.TextureSettings_C1055.FilterMode = (int)Classes.Texture2D.FilterMode.Bilinear;
			importer.TextureSettings_C1055.Aniso = 1;
			importer.SRGBTexture_C1055 = true;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/InheritVelocityModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.InheritVelocity;
using AssetRipper.SourceGenerated.Subclasses.InheritVelocityModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class InheritVelocityModuleExtensions
	{
		public static InheritVelocityMode GetMode(this IInheritVelocityModule module)
		{
			return (InheritVelocityMode)module.Mode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/InputAxisExtensions.cs`:

```cs
using AssetRipper.Core.Classes.InputManager;
using AssetRipper.SourceGenerated.Subclasses.InputAxis;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class InputAxisExtensions
	{
		public static InputAxisType GetType(this IInputAxis input)
		{
			return (InputAxisType)input.Type;
		}

		public static InputAxesDirection GetAxis(this IInputAxis input)
		{
			return (InputAxesDirection)input.Axis;
		}

		public static JoystickType GetJoyNum(this IInputAxis input)
		{
			return (JoystickType)input.JoyNum;
		}

		public static void Initialize(this IInputAxis input, string name, string positive, string altPositive)
		{
			input.Name.String = name;
			input.PositiveButton.String = positive;
			input.AltPositiveButton.String = altPositive;
			input.Gravity = 1000.0f;
			input.Dead = 0.001f;
			input.Sensitivity = 1000.0f;
			input.Snap = false;
			input.Invert = false;
			input.Type = (int)InputAxisType.KeyOrMouseButton;
			input.Axis = (int)InputAxesDirection.X;
			input.JoyNum = (int)JoystickType.AllJoysticks;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/KeyframeExtensions.Float.cs`:

```cs
using AssetRipper.Core.Classes.Misc.KeyframeTpl;
using AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_float;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static partial class KeyframeExtensions
	{
		public const float DefaultFloatWeight = (float)(1.0 / 3.0);

		public static void SetValues(this IKeyframe_float keyframe, UnityVersion version, float time, float value, float weight)
		{
			keyframe.Time = time;
			keyframe.Value = value;
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight = weight;
			keyframe.OutWeight = weight;
		}

		public static void SetValues(this IKeyframe_float keyframe, UnityVersion version, float time, float value, float inSlope, float outSlope, float weight)
		{
			keyframe.Time = time;
			keyframe.Value = value;
			keyframe.InSlope = inSlope;
			keyframe.OutSlope = outSlope;
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight = weight;
			keyframe.OutWeight = weight;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/KeyframeExtensions.Quaternionf.cs`:

```cs
using AssetRipper.Core.Classes.Misc.KeyframeTpl;
using AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static partial class KeyframeExtensions
	{
		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, IQuaternionf weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.CopyValuesFrom(weight);
			keyframe.OutWeight?.CopyValuesFrom(weight);
		}

		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, float weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.SetValues(weight, weight, weight, weight);
			keyframe.OutWeight?.SetValues(weight, weight, weight, weight);
		}

		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, float weightX, float weightY, float weightZ, float weightW)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.SetValues(weightX, weightY, weightZ, weightW);
			keyframe.OutWeight?.SetValues(weightX, weightY, weightZ, weightW);
		}

		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, IQuaternionf inSlope, IQuaternionf outSlope, IQuaternionf weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			keyframe.InSlope.CopyValuesFrom(inSlope);
			keyframe.OutSlope.CopyValuesFrom(outSlope);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.CopyValuesFrom(weight);
			keyframe.OutWeight?.CopyValuesFrom(weight);
		}

		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, IQuaternionf inSlope, IQuaternionf outSlope, float weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			keyframe.InSlope.CopyValuesFrom(inSlope);
			keyframe.OutSlope.CopyValuesFrom(outSlope);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.SetValues(weight, weight, weight, weight);
			keyframe.OutWeight?.SetValues(weight, weight, weight, weight);
		}

		public static void SetValues(this IKeyframe_Quaternionf keyframe, UnityVersion version, float time, IQuaternionf value, IQuaternionf inSlope, IQuaternionf outSlope, float weightX, float weightY, float weightZ, float weightW)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			keyframe.InSlope.CopyValuesFrom(inSlope);
			keyframe.OutSlope.CopyValuesFrom(outSlope);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.SetValues(weightX, weightY, weightZ, weightW);
			keyframe.OutWeight?.SetValues(weightX, weightY, weightZ, weightW);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/KeyframeExtensions.Vector3f.cs`:

```cs
using AssetRipper.Core.Classes.Misc.KeyframeTpl;
using AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Vector3f;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static partial class KeyframeExtensions
	{
		public static void SetValues(this IKeyframe_Vector3f keyframe, UnityVersion version, float time, IVector3f value, IVector3f weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeSmooth.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.CopyValuesFrom(weight);
			keyframe.OutWeight?.CopyValuesFrom(weight);
		}

		public static void SetValues(this IKeyframe_Vector3f keyframe, UnityVersion version, float time, IVector3f value, IVector3f inSlope, IVector3f outSlope, IVector3f weight)
		{
			keyframe.Time = time;
			keyframe.Value.CopyValuesFrom(value);
			keyframe.InSlope.CopyValuesFrom(inSlope);
			keyframe.OutSlope.CopyValuesFrom(outSlope);
			// this enum member is version agnostic
			keyframe.TangentMode = TangentMode.FreeFree.ToTangent(version);
			keyframe.WeightedMode = (int)WeightedMode.None;
			keyframe.InWeight?.CopyValuesFrom(weight);
			keyframe.OutWeight?.CopyValuesFrom(weight);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LODExtensions.cs`:

```cs
using AssetRipper.Core.Classes.LODGroup;
using AssetRipper.SourceGenerated.Subclasses.LOD;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LODExtensions
	{
		public static LODFadeMode GetFadeMode(this ILOD lod)
		{
			return (LODFadeMode)lod.FadeMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LODGroupExtensions.cs`:

```cs
using AssetRipper.Core.Classes.LODGroup;
using AssetRipper.SourceGenerated.Classes.ClassID_205;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LODGroupExtensions
	{
		public static LODFadeMode GetFadeMode(this ILODGroup group)
		{
			return group.Has_FadeMode_C205() 
				? (LODFadeMode)group.FadeMode_C205 
				: group.LODs_C205.FirstOrDefault()?.GetFadeMode() ?? LODFadeMode.None;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LayerConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerLayer;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LayerConstantExtensions
	{
		public static AnimatorLayerBlendingMode GetLayerBlendingMode(this ILayerConstant constant)
		{
			return (AnimatorLayerBlendingMode)constant.LayerBlendingMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LightExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Light;
using AssetRipper.SourceGenerated.Classes.ClassID_108;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LightExtensions
	{
		public static LightType GetType(this ILight light)
		{
			return (LightType)light.Type_C108;
		}
		public static LightShape GetShape(this ILight light)
		{
			return (LightShape)light.Shape_C108;
		}
		public static LightRenderMode GetRenderMode(this ILight light)
		{
			return (LightRenderMode)light.RenderMode_C108;
		}
		public static LightmappingMode GetLightmapping(this ILight light)
		{
			return (LightmappingMode)light.Lightmapping_C108;
		}
		public static LightShadowCasterMode GetLightShadowCasterMode(this ILight light)
		{
			return (LightShadowCasterMode)light.LightShadowCasterMode_C108;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LightmapBakeModeExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Light;
using AssetRipper.SourceGenerated.Subclasses.LightmapBakeMode;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LightmapBakeModeExtensions
	{
		public static LightmapBakeType GetLightmapBakeType(this ILightmapBakeMode light)
		{
			return (LightmapBakeType)light.LightmapBakeType;
		}
		public static MixedLightingMode GetMixedLightingMode(this ILightmapBakeMode light)
		{
			return (MixedLightingMode)light.MixedLightingMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LightmapEditorSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Light;
using AssetRipper.Core.Classes.LightmapSettings;
using AssetRipper.SourceGenerated.Subclasses.LightmapEditorSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LightmapEditorSettingsExtensions
	{
		public static void SetToDefault(this ILightmapEditorSettings settings)
		{
			settings.Resolution = 2.0f;
			settings.BakeResolution = 40.0f;
			settings.TextureWidth = 1024;
			settings.TextureHeight = 1024;
			settings.AO = false;
			settings.AOMaxDistance = 1.0f;
			settings.CompAOExponent = 1.0f;
			settings.CompAOExponentDirect = 0.0f;
			settings.ExtractAmbientOcclusion = false;
			settings.Padding = 2;
			settings.LightmapsBakeMode = (int)LightmapsMode.CombinedDirectional;
			settings.TextureCompression = true;
			settings.FinalGather = false;
			settings.FinalGatherFiltering = true;
			settings.FinalGatherRayCount = 256;
			settings.ReflectionCompression = (int)ReflectionCubemapCompression.Auto;
			settings.MixedBakeMode = (int)MixedLightingMode.Shadowmask;
			settings.BakeBackend = (int)Lightmapper.Enlighten;
			settings.PVRSampling = (int)Sampling.Fixed;
			settings.PVRDirectSampleCount = 32;
			settings.PVRSampleCount = 500;
			settings.PVRBounces = 2;
			settings.PVREnvironmentSampleCount = 256;
			settings.PVREnvironmentReferencePointCount = 2048;
			settings.PVRFilteringMode = (int)FilterMode.Auto;
			settings.PVRDenoiserTypeDirect = (int)DenoiserType.Optix;
			settings.PVRDenoiserTypeIndirect = (int)DenoiserType.Optix;
			settings.PVRDenoiserTypeAO = (int)DenoiserType.Optix;
			settings.PVRFilterTypeDirect = (int)FilterType.Gaussian;
			settings.PVRFilterTypeIndirect = (int)FilterType.Gaussian;
			settings.PVRFilterTypeAO = (int)FilterType.Gaussian;
			settings.PVREnvironmentMIS = 1;
			settings.PVRCulling = true;
			settings.PVRFilteringGaussRadiusDirect = 1;
			settings.PVRFilteringGaussRadiusIndirect = 5;
			settings.PVRFilteringGaussRadiusAO = 2;
			settings.PVRFilteringAtrousPositionSigmaDirect = 0.5f;
			settings.PVRFilteringAtrousPositionSigmaIndirect = 2.0f;
			settings.PVRFilteringAtrousPositionSigmaAO = 1.0f;
			settings.ShowResolutionOverlay = true;
			settings.ExportTrainingData = false;
			if(settings.Has_TrainingDataDestination())
			{
				settings.TrainingDataDestination.String = "TrainingData";
			}
			settings.LightProbeSampleCountMultiplier = 4.0f;
		}

		public static LightmapsMode GetLightmapsBakeMode(this ILightmapEditorSettings settings)
		{
			return (LightmapsMode)settings.LightmapsBakeMode;
		}

		public static ReflectionCubemapCompression GetReflectionCompression(this ILightmapEditorSettings settings)
		{
			return (ReflectionCubemapCompression)settings.ReflectionCompression;
		}

		public static MixedLightingMode GetMixedBakeMode(this ILightmapEditorSettings settings)
		{
			if(settings.Has_MixedBakeMode())
			{
				return (MixedLightingMode)settings.MixedBakeMode;
			}
			else
			{
				return (MixedLightingMode)settings.StationaryBakeMode;//need to rename
			}
		}

		public static Lightmapper GetBakeBackend(this ILightmapEditorSettings settings)
		{
			return (Lightmapper)settings.BakeBackend;
		}

		public static Sampling GetPVRSampling(this ILightmapEditorSettings settings)
		{
			return (Sampling)settings.PVRSampling;
		}

		public static FilterMode GetPVRFilteringMode(this ILightmapEditorSettings settings)
		{
			return (FilterMode)settings.PVRFilteringMode;
		}

		public static DenoiserType GetPVRDenoiserTypeDirect(this ILightmapEditorSettings settings)
		{
			return (DenoiserType)settings.PVRDenoiserTypeDirect;
		}

		public static DenoiserType GetPVRDenoiserTypeIndirect(this ILightmapEditorSettings settings)
		{
			return (DenoiserType)settings.PVRDenoiserTypeIndirect;
		}

		public static DenoiserType GetPVRDenoiserTypeAO(this ILightmapEditorSettings settings)
		{
			return (DenoiserType)settings.PVRDenoiserTypeAO;
		}

		public static FilterType GetPVRFilterTypeDirect(this ILightmapEditorSettings settings)
		{
			return (FilterType)settings.PVRFilterTypeDirect;
		}

		public static FilterType GetPVRFilterTypeIndirect(this ILightmapEditorSettings settings)
		{
			return (FilterType)settings.PVRFilterTypeIndirect;
		}

		public static FilterType GetPVRFilterTypeAO(this ILightmapEditorSettings settings)
		{
			return (FilterType)settings.PVRFilterTypeAO;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LightmapSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.LightmapSettings;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.SourceGenerated.Classes.ClassID_157;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LightmapSettingsExtensions
	{
		public static void ConvertToEditorFormat(this ILightmapSettings settings)
		{
			settings.GIWorkflowMode_C157 = (int)GIWorkflowMode.OnDemand;
			settings.LightmapEditorSettings_C157.SetToDefault();
		}

		public static GIWorkflowMode GetGIWorkflowMode(this ILightmapSettings settings)
		{
			return (GIWorkflowMode)settings.GIWorkflowMode_C157;
		}

		public static LightmapsMode GetLightmapsMode(this ILightmapSettings settings)
		{
			return (LightmapsMode)settings.LightmapsMode_C157;
		}

		public static ColorSpace GetBakedColorSpace(this ILightmapSettings settings)
		{
			return (ColorSpace)settings.BakedColorSpace_C157;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LightsModuleExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.LightsModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LightsModuleExtensions
	{
		public static void SetToDefault(this ILightsModule module, UnityVersion version)
		{
			module.RandomDistribution = true;
			module.Color = true;
			module.Range = true;
			module.Intensity = true;
			module.RangeCurve.SetValues(version, 1.0f);
			module.IntensityCurve.SetValues(version, 1.0f);
			module.MaxLights = 20;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/LineParametersExtensions.cs`:

```cs
using AssetRipper.Core.Classes.TrailRenderer;
using AssetRipper.SourceGenerated.Subclasses.LineParameters;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class LineParametersExtensions
	{
		public static void Initialize(this ILineParameters lineParameters, UnityVersion version)
		{
			lineParameters.WidthMultiplier = 1.0f;
			if (lineParameters.Has_WidthCurve())
			{
				lineParameters.WidthCurve.SetDefaultRotationOrderAndCurveLoopType();
				lineParameters.WidthCurve.Curve.AddNew().SetValues(version, 0.0f, 1.0f, KeyframeExtensions.DefaultFloatWeight);
			}
			else
			{
				lineParameters.StartWidth = 1f;
				lineParameters.EndWidth = 1f;
				//Just guessing. I did not verify these values anywhere.
			}
			if (lineParameters.Has_ColorGradient())
			{
				lineParameters.ColorGradient.Ctime0 = 0;
				lineParameters.ColorGradient.Atime0 = 0;
				lineParameters.ColorGradient.Ctime1 = ushort.MaxValue;
				lineParameters.ColorGradient.Atime1 = ushort.MaxValue;
				lineParameters.ColorGradient.NumColorKeys = 2;
				lineParameters.ColorGradient.NumAlphaKeys = 2;
				if (lineParameters.ColorGradient.Has_Key0_ColorRGBA32())
				{
					lineParameters.ColorGradient.Key0_ColorRGBA32.SetAsWhite();
					lineParameters.ColorGradient.Key1_ColorRGBA32!.SetAsWhite();
				}
				else
				{
					lineParameters.ColorGradient.Key0_ColorRGBAf_3_5_0_f5!.SetAsWhite();
					lineParameters.ColorGradient.Key1_ColorRGBAf_3_5_0_f5!.SetAsWhite();
				}
			}
			else if (lineParameters.Has_EndColor() && lineParameters.Has_StartColor())
			{
				lineParameters.StartColor.SetAsWhite();
				lineParameters.EndColor.SetAsWhite();
			}
			lineParameters.NumCornerVertices = 0;
			lineParameters.NumCapVertices = 0;
			lineParameters.Alignment = (int)LineAlignment.View;
			lineParameters.TextureMode = (int)LineTextureMode.Stretch;
			lineParameters.ShadowBias = 0.5f;
			lineParameters.GenerateLightingData = false;
		}

		public static LineAlignment GetAlignment(this ILineParameters parameters)
		{
			return (LineAlignment)parameters.Alignment;
		}

		public static LineTextureMode GetTextureMode(this ILineParameters parameters)
		{
			return (LineTextureMode)parameters.TextureMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MaterialExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_21;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MaterialExtensions
	{
		public static string? FindPropertyNameByCRC28(this IMaterial material, uint crc)
		{
			return material.SavedProperties_C21.FindPropertyNameByCRC28(crc);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MatrixParameterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.SourceGenerated.Subclasses.MatrixParameter;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MatrixParameterExtensions
	{
		public static void SetValues(this IMatrixParameter parameter, string name, ShaderParamType type, int index, int rowCount, int columnCount)
		{
			//parameter.Name = name;//Name doesn't exist
			parameter.NameIndex = -1;
			parameter.Index = index;
			parameter.ArraySize = 0;
			parameter.Type = (sbyte)type;
			parameter.RowCount = (sbyte)rowCount;
			//parameter.ColumnCount = (sbyte)columnCount;//doesn't exist; default value is 4
		}

		public static ShaderParamType GetType_(this IMatrixParameter parameter)
		{
			return (ShaderParamType)parameter.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshBlendShapeChannelExtensions.cs`:

```cs
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShapeChannel;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MeshBlendShapeChannelExtensions
	{
		public static void SetValues(this IMeshBlendShapeChannel channel, string name, int frameIndex, int frameCount)
		{
			channel.Name.String = name;
			channel.NameHash = CrcUtils.CalculateDigestUTF8(name);
			channel.FrameIndex = frameIndex;
			channel.FrameCount = frameCount;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshBlendShapeExtensions.cs`:

```cs
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShape;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MeshBlendShapeExtensions
	{
		public static bool IsCRCMatch(this IMeshBlendShape blendShape, uint crc)
		{
			return blendShape.Name_R is not null && CrcUtils.VerifyDigestUTF8(blendShape.Name_R.String, crc);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshColliderExtensions.cs`:

```cs
using AssetRipper.Core.Classes.MeshCollider;
using AssetRipper.SourceGenerated.Classes.ClassID_64;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MeshColliderExtensions
	{
		public static MeshColliderCookingOptions GetCookingOptions(this IMeshCollider collider)
		{
			if (collider.Has_CookingOptions_C64())
			{
				return (MeshColliderCookingOptions)collider.CookingOptions_C64;
			}
			else
			{
				MeshColliderCookingOptions options = 
					MeshColliderCookingOptions.CookForFasterSimulation | 
					MeshColliderCookingOptions.EnableMeshCleaning | 
					MeshColliderCookingOptions.WeldColocatedVertices;

				if (collider.InflateMesh_C64)
				{
					options |= MeshColliderCookingOptions.InflateConvexMesh;
				}
				return options;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Subclasses.MeshBlendShape;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MeshExtensions
	{
		public static bool IsCombinedMesh(this IMesh mesh) => mesh?.NameString == "Combined Mesh (root scene)";

		public static void ConvertToEditorFormat(this IMesh mesh)
		{
			mesh.SetMeshOptimizationFlags(MeshOptimizationFlags.Everything);
		}

		public static bool CheckAssetIntegrity(this IMesh mesh)
		{
			if (mesh.Has_StreamData_C43() && mesh.Has_VertexData_C43() && mesh.SerializedFile is not null)
			{
				if (mesh.VertexData_C43.IsSet())
				{
					return mesh.StreamData_C43.CheckIntegrity(mesh.SerializedFile);
				}
			}
			return true;
		}

		public static byte[] GetChannelsData(this IMesh mesh)
		{
			if (mesh.Has_StreamData_C43() && mesh.StreamData_C43.IsSet())
			{
				return mesh.StreamData_C43.GetContent(mesh.SerializedFile);
			}
			else
			{
				return mesh.VertexData_C43?.Data ?? Array.Empty<byte>();
			}
		}

		public static string? FindBlendShapeNameByCRC(this IMesh mesh, uint crc)
		{
			if (mesh.Has_Shapes_C43())
			{
				return mesh.Shapes_C43.FindShapeNameByCRC(crc);
			}
			else if (mesh.Has_ShapesList_C43())
			{
				foreach (MeshBlendShape_4_1_0_f4 blendShape in mesh.ShapesList_C43)
				{
					if (blendShape.IsCRCMatch(crc))
					{
						return blendShape.Name.String;
					}
				}
			}
			return null;
		}

		public static bool Is16BitIndices(this IMesh mesh)
		{
			if (mesh.Has_Use16BitIndices_C43())
			{
				return mesh.Use16BitIndices_C43 != 0;
			}
			else if (mesh.Has_IndexFormat_C43())
			{
				return mesh.IndexFormat_C43 == (int)IndexFormat.UInt16;
			}
			return true;
		}

		public static MeshOptimizationFlags GetMeshOptimizationFlags(this IMesh mesh)
		{
			if (mesh.Has_MeshOptimizationFlags_C43())
			{
				return (MeshOptimizationFlags)mesh.MeshOptimizationFlags_C43;
			}
			else if (mesh.Has_MeshOptimized_C43())
			{
				return mesh.MeshOptimized_C43 ? MeshOptimizationFlags.Everything : MeshOptimizationFlags.PolygonOrder;
			}
			else
			{
				return default;
			}
		}

		public static void SetMeshOptimizationFlags(this IMesh mesh, MeshOptimizationFlags value)
		{
			if (mesh.Has_MeshOptimizationFlags_C43())
			{
				mesh.MeshOptimizationFlags_C43 = (int)value;
			}
			else if (mesh.Has_MeshOptimized_C43())
			{
				mesh.MeshOptimized_C43 = value == MeshOptimizationFlags.Everything;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshFilterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_33;
using AssetRipper.SourceGenerated.Classes.ClassID_43;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MeshFilterExtensions
	{
		public static IMesh GetMesh(this IMeshFilter meshFilter)
		{
			return meshFilter.Mesh_C33.GetAsset(meshFilter.SerializedFile);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MeshOutlineGenerator.cs`:

```cs
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.SourceGenExtensions
{
	public class MeshOutlineGenerator
	{
		private class Outline
		{
			private struct Outside
			{
				public Outside(int triIndex, int vertex)
				{
					Triangle = triIndex;
					Member = vertex;
				}

				public override string ToString()
				{
					return $"{Triangle}:{Member}";
				}

				public int Triangle { get; }
				public int Member { get; }
			}

			public Outline(IReadOnlyList<Vector3i> triangles, int startTriangle)
			{
				if (triangles == null)
				{
					throw new ArgumentNullException(nameof(triangles));
				}
				m_triangles = triangles;

				GenerateIndexes(startTriangle);
				GenerateOutsiders();
			}

			public void GenerateOutline()
			{
				List<int> outline = new List<int>();
				Outside outsider = m_outsiders[0];
				Vector3i tri = m_triangles[outsider.Triangle];
				int first = tri.GetValueByMember(outsider.Member);
				int second = tri.GetValueByMember(outsider.Member + 1);
				int startTriIndex = outsider.Triangle;
				outline.Add(first);
				outline.Add(second);

				Vector3i lastTri = tri;
				int lastMember = outsider.Member + 1;
				int lastVertex = lastTri.GetValueByMember(outsider.Member);
				int lastTriIndex = outsider.Triangle;
				while (true)
				{
					if (GetNextOutsider(lastTri, lastMember, out outsider))
					{
						lastTri = m_triangles[outsider.Triangle];
						lastMember = outsider.Member + 1;
						lastVertex = lastTri.GetValueByMember(outsider.Member);
						lastTriIndex = outsider.Triangle;
					}
					else
					{
						lastMember++;
						if (lastTri.GetValueByMember(lastMember) == lastVertex)
						{
							if (lastVertex != first)
							{
								break;
							}
						}
					}

					int nextVertex = lastTri.GetValueByMember(lastMember);
					if (nextVertex == first)
					{
						break;
					}

					outline.Add(nextVertex);
				}

				GeneratedOutline = outline;
			}

			public bool IsContain(int triIndex)
			{
				return m_indexes.Contains(triIndex);
			}

			private int GetEdgeMask(Vector3i triangle, IReadOnlyList<int> indexes)
			{
				int edgeMask = 0;
				for (int i = 0; i < indexes.Count; i++)
				{
					Vector3i check = m_triangles[indexes[i]];
					if (check == triangle)
					{
						continue;
					}
					int edge = GetNeighborEdge(triangle, check);
					if (edge == 0)
					{
						continue;
					}
					edgeMask |= edge;
				}
				return edgeMask;
			}

			private static int GetNeighborEdge(Vector3i tri1, Vector3i tri2)
			{
				if (IsNeighbors(tri1.X, tri1.Y, tri2))
				{
					return 1 << 0;
				}
				if (IsNeighbors(tri1.Y, tri1.Z, tri2))
				{
					return 1 << 1;
				}
				if (IsNeighbors(tri1.Z, tri1.X, tri2))
				{
					return 1 << 2;
				}
				return 0;
			}

			private static bool IsNeighbors(int a, int b, Vector3i tri2)
			{
				if (a == tri2.X && b == tri2.Z)
				{
					return true;
				}
				if (b == tri2.Y && a == tri2.Z)
				{
					return true;
				}
				if (b == tri2.X && a == tri2.Y)
				{
					return true;
				}
				return false;
			}

			private void GenerateIndexes(int startTriangle)
			{
				List<int> indexes = new List<int>();
				indexes.Add(startTriangle);
				m_indexes.Add(startTriangle);
				for (int i = 0; i < indexes.Count; i++)
				{
					int index = indexes[i];
					Vector3i triangle = m_triangles[index];
					//int edgeMask = GetEdgeMask(triangle, indexes);
					for (int j = 0; j < m_triangles.Count; j++)
					{
						if (m_indexes.Contains(j))
						{
							continue;
						}
						Vector3i check = m_triangles[j];
						int edge = GetNeighborEdge(triangle, check);
						if (edge == 0)
						{
							continue;
						}
						// allow only one neighbor per edge
						//if ((edgeMask & edge) != 0)
						{
							//continue;
						}

						indexes.Add(j);
						m_indexes.Add(j);
						//edgeMask |= edge;
					}
				}
			}

			private void GenerateOutsiders()
			{
				foreach (int index in m_indexes)
				{
					if (GenerateOutsider(index, out Outside outsider))
					{
						m_outsiders.Add(outsider);
					}
				}
			}

			private bool GenerateOutsider(int index, out Outside outsider)
			{
				Vector3i triangle = m_triangles[index];
				int neighborCount = 0;
				bool xy = true;
				bool yz = true;
				bool zx = true;
				outsider = new();
				foreach (int checkIndex in m_indexes)
				{
					if (checkIndex == index)
					{
						continue;
					}
					Vector3i check = m_triangles[checkIndex];
					if (check.ContainsValue(triangle.X))
					{
						if (check.ContainsValue(triangle.Y))
						{
							xy = false;
							if (++neighborCount == 3)
							{
								return false;
							}
						}
						else if (check.ContainsValue(triangle.Z))
						{
							zx = false;
							if (++neighborCount == 3)
							{
								return false;
							}
						}
					}
					else if (check.ContainsValue(triangle.Y) && check.ContainsValue(triangle.Z))
					{
						yz = false;
						if (++neighborCount == 3)
						{
							return false;
						}
					}
				}
				int vertex = xy ? zx ? 2 : 0 : yz ? 1 : 2;
				outsider = new Outside(index, vertex);
				return true;
			}

			private bool GetNextOutsider(Vector3i triangle, int member, out Outside result)
			{
				int vertex = triangle.GetValueByMember(member);
				foreach (Outside outsider in m_outsiders)
				{
					Vector3i check = m_triangles[outsider.Triangle];
					if (check.GetValueByMember(outsider.Member) == vertex)
					{
						if (IsConnectedNeighbors(triangle, check, vertex))
						{
							result = outsider;
							return true;
						}
					}
				}
				result = default;
				return false;
			}

			private bool GetNextNeighbor(Vector3i tri, int vertex, [NotNullWhen(true)] out Vector3i? result)
			{
				int member = tri.GetMemberByValue(vertex);
				int nextVertex = tri.GetValueByMember(member + 1);
				foreach (int index in m_indexes)
				{
					Vector3i check = m_triangles[index];
					if (check.ContainsValue(vertex) && check.ContainsValue(nextVertex))
					{
						if (check != tri)
						{
							result = check;
							return true;
						}
					}
				}
				result = default;
				return false;
			}

			private bool IsConnectedNeighbors(Vector3i tri1, Vector3i tri2, int vertex)
			{
				if (GetNeighborEdge(tri1, tri2) != 0)
				{
					return true;
				}

				Vector3i next = tri1;
				while (GetNextNeighbor(next, vertex, out next))
				{
					if (next == tri2)
					{
						return true;
					}
				}
				return false;
			}

			public int TriangleCount => m_indexes.Count;
			public IReadOnlyList<int> GeneratedOutline { get; private set; }

			private readonly IReadOnlyList<Vector3i> m_triangles;
			private readonly HashSet<int> m_indexes = new HashSet<int>();
			private readonly List<Outside> m_outsiders = new List<Outside>();
		}

		public MeshOutlineGenerator(IReadOnlyList<Vector3f_3_5_0_f5> vertices, IReadOnlyList<Vector3i> triangles)
		{
			if (vertices == null)
			{
				throw new ArgumentNullException(nameof(vertices));
			}
			if (triangles == null)
			{
				throw new ArgumentNullException(nameof(triangles));
			}
			m_vertices = vertices;
			foreach (Vector3i triangle in triangles)
			{
				if (IsValidTriangle(triangle))
				{
					m_triangles.Add(triangle);
				}
			}
		}

		public List<Vector2f[]> GenerateOutlines()
		{
			List<Outline> outlines = new List<Outline>();
			for (int i = 0; i < m_triangles.Count; i++)
			{
				bool isKnown = false;
				for (int j = 0; j < outlines.Count; j++)
				{
					if (outlines[j].IsContain(i))
					{
						isKnown = true;
						break;
					}
				}
				if (isKnown)
				{
					continue;
				}

				Outline outline = new Outline(m_triangles, i);
				outline.GenerateOutline();
				outlines.Add(outline);
			}

			List<Vector2f[]> result = new List<Vector2f[]>();
			List<Vector2f> resultLine = new List<Vector2f>();
			for (int i = 0; i < outlines.Count; i++)
			{
				resultLine.Clear();
				Outline outline = outlines[i];
				for (int j = 0; j < outline.GeneratedOutline.Count; j++)
				{
					int vertex = outline.GeneratedOutline[j];
					// include outlines that has common vertex with current outline
					/*for (int k = i + 1; k < outlines.Count; k++)
					{
						Outline nextOutline = outlines[k];
						int index = nextOutline.GeneratedOutline.IndexOf(vertex);
						if (index != -1)
						{
							for (int l = index; l < nextOutline.GeneratedOutline.Count; l++)
							{
								int nextVertex = nextOutline.GeneratedOutline[l];
								resultLine.Add((Vector2f)m_vertices[nextVertex]);
							}
							for (int m = 0; m < index; m++)
							{
								int nextVertex = nextOutline.GeneratedOutline[m];
								resultLine.Add((Vector2f)m_vertices[nextVertex]);
							}
							outlines.RemoveAt(k--);
						}
					}*/
					resultLine.Add(ConvertToVector2f(m_vertices[vertex]));
				}
				result.Add(resultLine.ToArray());
			}

			return result;
		}

		private static Vector2f ConvertToVector2f(Vector3f_3_5_0_f5 v3) => new Vector2f(v3.X, v3.Y);

		private static bool IsValidTriangle(Vector3i triangle)
		{
			return triangle.X != triangle.Y && triangle.X != triangle.Z && triangle.Y != triangle.Z;
		}

		private readonly IReadOnlyList<Vector3f_3_5_0_f5> m_vertices;
		private readonly List<Vector3i> m_triangles = new List<Vector3i>();
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MinMaxCurveExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.Curve;
using AssetRipper.SourceGenerated.Subclasses.MinMaxCurve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MinMaxCurveExtensions
	{
		public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float value)
		{
			curve.SetValues(version, ParticleSystemCurveMode.Constant, value, value, 1.0f, 1.0f);
		}

		public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue)
		{
			curve.SetValues(version, ParticleSystemCurveMode.Constant, minValue, maxValue, 1.0f, 1.0f);
		}

		public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue, float minCurve, float maxCurve)
		{
			curve.SetValues(version, ParticleSystemCurveMode.Constant, minValue, maxValue, minCurve, maxCurve);
		}

		public static void SetValues(this IMinMaxCurve curve, UnityVersion version, float minValue, float maxValue, float minCurve, float maxCurve1, float maxCurve2)
		{
			curve.SetMinMaxState(ParticleSystemCurveMode.Curve);
			curve.Scalar = maxValue;
			curve.MinScalar = minValue;

			curve.MinCurve.SetValues(version, minCurve, KeyframeExtensions.DefaultFloatWeight);
			curve.MaxCurve.SetValues(version, maxCurve1, 0.0f, 1.0f, maxCurve2, 1.0f, 0.0f, KeyframeExtensions.DefaultFloatWeight);
		}

		public static void SetValues(this IMinMaxCurve curve, UnityVersion version, ParticleSystemCurveMode mode, float minValue, float maxValue, float minCurve, float maxCurve)
		{
			curve.SetMinMaxState(mode);
			curve.MinScalar = minValue;
			curve.Scalar = maxValue;

			curve.MinCurve.SetValues(version, minCurve, KeyframeExtensions.DefaultFloatWeight);
			curve.MaxCurve.SetValues(version, maxCurve, KeyframeExtensions.DefaultFloatWeight);
		}

		public static ParticleSystemCurveMode GetMinMaxState(this IMinMaxCurve curve)
		{
			return curve.Has_MinMaxState_Int16()
				? unchecked((ParticleSystemCurveMode)curve.MinMaxState_Int16)
				: (ParticleSystemCurveMode)curve.MinMaxState_UInt16;
		}

		public static void SetMinMaxState(this IMinMaxCurve curve, ParticleSystemCurveMode mode)
		{
			curve.MinMaxState_Int16 = unchecked((short)mode);
			curve.MinMaxState_UInt16 = (ushort)mode;
		}

		private static float GetExportScalar(this IMinMaxCurve curve)
		{
			if (curve.Has_MinScalar())
			{
				return curve.Scalar;
			}
			else
			{
				if (curve.GetMinMaxState() == ParticleSystemCurveMode.TwoConstants)
				{
					return curve.Scalar * curve.MaxCurve.Curve[0].Value;
				}
				else
				{
					return curve.Scalar;
				}
			}
		}

		private static float GetExportMinScalar(this IMinMaxCurve curve)
		{
			if (curve.Has_MinScalar())
			{
				return curve.MinScalar;
			}
			else
			{
				if (curve.GetMinMaxState() == ParticleSystemCurveMode.TwoConstants)
				{
					return curve.Scalar * curve.MinCurve.Curve[0].Value;
				}
				else
				{
					return curve.Scalar;
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MinMaxGradientExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.MinMaxGradient;
using AssetRipper.SourceGenerated.Subclasses.MinMaxGradient;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MinMaxGradientExtensions
	{
		public static MinMaxGradientState GetMinMaxState(this IMinMaxGradient gradient)
		{
			return gradient.Has_MinMaxState_Int16()
				? unchecked((MinMaxGradientState)gradient.MinMaxState_Int16)
				: (MinMaxGradientState)gradient.MinMaxState_UInt16;
		}

		public static void SetMinMaxState(this IMinMaxGradient gradient, MinMaxGradientState state)
		{
			gradient.MinMaxState_Int16 = unchecked((short)state);
			gradient.MinMaxState_UInt16 = (ushort)state;
		}

		public static void SetToDefault(this IMinMaxGradient gradient)
		{
			gradient.SetMinMaxState(MinMaxGradientState.Color);

			if (gradient.Has_MinColor_ColorRGBA32())
			{
				gradient.MinColor_ColorRGBA32.SetAsWhite();
			}
			else if (gradient.Has_MinColor_ColorRGBAf_3_5_0_f5())
			{
				gradient.MinColor_ColorRGBAf_3_5_0_f5.SetAsWhite();
			}

			if (gradient.Has_MaxColor_ColorRGBA32())
			{
				gradient.MaxColor_ColorRGBA32.SetAsWhite();
			}
			else if (gradient.Has_MaxColor_ColorRGBAf_3_5_0_f5())
			{
				gradient.MaxColor_ColorRGBAf_3_5_0_f5.SetAsWhite();
			}

			//gradient.MaxGradient = new Gradient(ColorRGBAf.White, ColorRGBAf.White);
			//gradient.MinGradient = new Gradient(ColorRGBAf.White, ColorRGBAf.White);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MonoBehaviourExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_114;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MonoBehaviourExtensions
	{
		/// <summary>
		/// Whether this MonoBehaviour belongs to scene/prefab hierarchy or not<br/>
		/// TODO: find out why GameObject may have a value like PPtr(0, 894) even though such game object doesn't exist
		/// </summary>
		public static bool IsSceneObject(this IMonoBehaviour monoBehaviour) => !monoBehaviour.GameObject_C114.IsNull();
		public static bool IsScriptableObject(this IMonoBehaviour monoBehaviour) => monoBehaviour.NameString.Length > 0;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MonoScriptExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Utils;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Structure.Assembly.Serializable;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using Mono.Cecil;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MonoScriptExtensions
	{
		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasNamespace(UnityVersion version) => version.IsGreaterEqual(3);
		/// <summary>
		/// Less than 2018.1.2 or Release
		/// </summary>
		public static bool HasAssemblyName(UnityVersion version, TransferInstructionFlags flags) => flags.IsRelease() || version.IsLess(2018, 1, 2);
		/*
		public static bool HasAssemblyName(this IMonoScript monoScript) => !string.IsNullOrEmpty(monoScript.AssemblyName);

		public static bool HasNamespace(this IMonoScript monoScript) => !string.IsNullOrEmpty(monoScript.Namespace);

		public static string GetValidAssemblyName(this IMonoScript monoScript)
		{
			string name = FilenameUtils.FixAssemblyName(monoScript.AssemblyName);
			return string.IsNullOrEmpty(name) ? "Assembly-CSharp" : name;
		}
		*/

		public static string GetAssemblyNameFixed(this IMonoScript monoScript)
		{
			return FilenameUtils.FixAssemblyName(monoScript.AssemblyName_C115.String);
		}

		public static SerializableType GetBehaviourType(this IMonoScript monoScript)
		{
			ScriptIdentifier scriptID = HasNamespace(monoScript.SerializedFile.Version) ?
				monoScript.SerializedFile.Collection.AssemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.Namespace_C115.String, monoScript.ClassName_C115.String) :
				monoScript.SerializedFile.Collection.AssemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.ClassName_C115.String);
			if (monoScript.SerializedFile.Collection.AssemblyManager.IsValid(scriptID))
			{
				return monoScript.SerializedFile.Collection.AssemblyManager.GetSerializableType(scriptID) as SerializableType;
			}
			return null;
		}

		public static string GetFullName(this IMonoScript monoScript)
		{
			if (string.IsNullOrEmpty(monoScript.Namespace_C115.String))
			{
				return monoScript.ClassName_C115.String;
			}
			else
			{
				return $"{monoScript.Namespace_C115.String}.{monoScript.ClassName_C115.String}";
			}
		}

		public static ScriptIdentifier GetScriptID(this IMonoScript monoScript, bool includeNamespace)
		{
			bool useNamespace = includeNamespace && monoScript.Namespace_C115 is not null;
			return useNamespace ? monoScript.SerializedFile.Collection.AssemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.Namespace_C115.String, monoScript.ClassName_C115.String)
				: monoScript.SerializedFile.Collection.AssemblyManager.GetScriptID(monoScript.GetAssemblyNameFixed(), monoScript.ClassName_C115.String);
		}

		public static ScriptIdentifier GetScriptID(this IMonoScript monoScript) => monoScript.GetScriptID(false);

		public static TypeDefinition GetTypeDefinition(this IMonoScript monoScript)
		{
			ScriptIdentifier scriptID = monoScript.GetScriptID(true);
			return monoScript.SerializedFile.Collection.AssemblyManager.GetTypeDefinition(scriptID);
		}

		public static bool IsScriptPresents(this IMonoScript monoScript)
		{
			ScriptIdentifier scriptID = monoScript.GetScriptID(true);
			return monoScript.SerializedFile.Collection.AssemblyManager.IsPresent(scriptID);
		}

		public static Hash128 GetPropertiesHash(this IMonoScript monoScript)
		{
			return monoScript.Has_PropertiesHash_C115_Hash128()
				? (Hash128)monoScript.PropertiesHash_C115_Hash128
				: new Hash128(monoScript.PropertiesHash_C115_UInt32);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MultiModeParameterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.Shape;
using AssetRipper.SourceGenerated.Subclasses.MultiModeParameter;
using AssetRipper.SourceGenerated.Subclasses.MultiModeParameter_MeshSpawn;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MultiModeParameterExtensions
	{
		public static ParticleSystemShapeMultiModeValue GetMode(this IMultiModeParameter parameter)
		{
			return (ParticleSystemShapeMultiModeValue)parameter.Mode;
		}

		public static void SetValues(this IMultiModeParameter parameter, UnityVersion version, float value)
		{
			parameter.Value = value;
			parameter.Mode = (int)ParticleSystemShapeMultiModeValue.Random;
			parameter.Spread = 0.0f;
			parameter.Speed.SetValues(version, 1.0f);
		}

		public static ParticleSystemShapeMultiModeValue GetMode(this IMultiModeParameter_MeshSpawn parameter)
		{
			return (ParticleSystemShapeMultiModeValue)parameter.Mode;
		}

		public static void SetValues(this IMultiModeParameter_MeshSpawn parameter, UnityVersion version)
		{
			parameter.Mode = (int)ParticleSystemShapeMultiModeValue.Random;
			parameter.Spread = 0.0f;
			parameter.Speed.SetValues(version, 1.0f);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/MuscleClipInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.MuscleClipConstant;
using AssetRipper.SourceGenerated.Subclasses.MuscleClipInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class MuscleClipInfoExtensions
	{
		public static void Initialize(this IMuscleClipInfo info)
		{
			info.StopTime = 1.0f;
			info.KeepOriginalPositionY = true;
		}

		public static void Initialize(this IMuscleClipInfo info, IMuscleClipConstant muscleConst)
		{
			info.AdditiveReferencePoseTime = 0.0f;
			info.StartTime = muscleConst.StartTime;
			info.StopTime = muscleConst.StopTime;
			info.OrientationOffsetY = muscleConst.OrientationOffsetY;
			info.Level = muscleConst.Level;
			info.CycleOffset = muscleConst.CycleOffset;
			info.HasAdditiveReferencePose = false;
			info.LoopTime = muscleConst.LoopTime;
			info.LoopBlend = muscleConst.LoopBlend;
			info.LoopBlendOrientation = muscleConst.LoopBlendOrientation;
			info.LoopBlendPositionY = muscleConst.LoopBlendPositionY;
			info.LoopBlendPositionXZ = muscleConst.LoopBlendPositionXZ;
			info.KeepOriginalOrientation = muscleConst.KeepOriginalOrientation;
			info.KeepOriginalPositionY = muscleConst.KeepOriginalPositionY;
			info.KeepOriginalPositionXZ = muscleConst.KeepOriginalPositionXZ;
			info.HeightFromFeet = muscleConst.HeightFromFeet;
			info.Mirror = false;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/NavMeshAgentExtensions.cs`:

```cs
using AssetRipper.Core.Classes.NavMeshAgent;
using AssetRipper.SourceGenerated.Classes.ClassID_195;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class NavMeshAgentExtensions
	{
		public static ObstacleAvoidanceType GetObstacleAvoidanceType(this INavMeshAgent agent)
		{
			return (ObstacleAvoidanceType)agent.ObstacleAvoidanceType_C195;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/NavMeshBuildSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.NavMeshBuildSettings;
using AssetRipper.SourceGenerated.Subclasses.NavMeshParams;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class NavMeshBuildSettingsExtensions
	{
		public static void SetToDefault(this INavMeshBuildSettings settings)
		{
			settings.AgentTypeID = 0;
			settings.AgentRadius = 0.5f;
			settings.AgentHeight = 2.0f;
			settings.AgentSlope = 45.0f;
			settings.AgentClimb = 0.4f;
			settings.LedgeDropHeight = 0.0f;
			settings.MaxJumpAcrossDistance = 0.0f;
			settings.MinRegionArea = 2.0f;
			settings.ManualCellSize_Int32 = 0;
			settings.ManualCellSize_Boolean = false;
			settings.CellSize = 1.0f / 6.0f;
			settings.ManualTileSize_Int32 = 0;
			settings.ManualTileSize_Boolean = false;
			settings.TileSize = 256;
			settings.AccuratePlacement_Int32 = 0;
			settings.AccuratePlacement_Boolean = false;
			settings.MaxJobWorkers = 0;
			settings.PreserveTilesOutsideBounds = 0;
		}

		public static void SetValues(this INavMeshBuildSettings settings, float agentClimb, float cellSize)
		{
			settings.AgentClimb = agentClimb;
			settings.ManualCellSize_Int32 = 1;
			settings.ManualCellSize_Boolean = true;
			settings.CellSize = cellSize;
		}

		public static void SetValues(this INavMeshBuildSettings settings, INavMeshParams navParams)
		{
			settings.SetToDefault();
			settings.AgentRadius = navParams.WalkableRadius;
			settings.AgentHeight = navParams.WalkableHeight;
			settings.AgentClimb = navParams.WalkableClimb;
			settings.TileSize = (int)navParams.TileSize;
			settings.CellSize = navParams.CellSize;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/NavMeshObstacleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.NavMeshObstacle;
using AssetRipper.SourceGenerated.Classes.ClassID_208;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class NavMeshObstacleExtensions
	{
		public static NavMeshObstacleShape GetShape(this INavMeshObstacle obstacle)
		{
			return obstacle.Has_Shape_C208() 
				? (NavMeshObstacleShape)obstacle.Shape_C208 
				: NavMeshObstacleShape.Capsule;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/NavMeshSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_196;
using AssetRipper.SourceGenerated.Classes.ClassID_238;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class NavMeshSettingsExtensions
	{
		public static void ConvertToEditorFormat(this INavMeshSettings settings)
		{
			INavMeshData? data = settings.NavMeshData_C196?.FindAsset(settings.SerializedFile);
			if (data == null)
			{
				settings.BuildSettings_C196.SetToDefault();
			}
			else
			{
				if (data.Has_NavMeshParams_C238())
				{
					settings.BuildSettings_C196.SetValues(data.NavMeshParams_C238);
				}
				else
				{
					//settings.BuildSettings_C196.CopyValues(data.NavMeshBuildSettings_C238);
					settings.BuildSettings_C196.SetToDefault();
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/NoiseModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.NoiseModule;
using AssetRipper.SourceGenerated.Subclasses.NoiseModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class NoiseModuleExtensions
	{
		public static void SetToDefaults(this INoiseModule module, UnityVersion version)
		{
			module.Strength.SetValues(version, 1.0f);
			module.StrengthY.SetValues(version, 1.0f);
			module.StrengthZ.SetValues(version, 1.0f);
			module.Frequency = 0.5f;
			module.Damping = true;
			module.Octaves = 1;
			module.OctaveMultiplier = 0.5f;
			module.OctaveScale = 2.0f;
			module.Quality = (int)ParticleSystemNoiseQuality.High;
			module.ScrollSpeed.SetValues(version, 0.0f);
			module.Remap.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
			module.RemapY.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
			module.RemapZ.SetValues(version, 1.0f, 1.0f, 1.0f, 0.0f, 1.0f);
			module.PositionAmount?.SetValues(version, 1.0f);
			module.RotationAmount?.SetValues(version, 0.0f);
			module.SizeAmount?.SetValues(version, 0.0f);
		}

		public static ParticleSystemNoiseQuality GetQuality(this INoiseModule module)
		{
			return (ParticleSystemNoiseQuality)module.Quality;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/OcclusionCullingDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_29;
using AssetRipper.SourceGenerated.Classes.ClassID_363;
using AssetRipper.SourceGenerated.Classes.ClassID_41;
using AssetRipper.SourceGenerated.Subclasses.GUID;
using AssetRipper.SourceGenerated.Subclasses.OcclusionScene;
using AssetRipper.SourceGenerated.Subclasses.PPtr_OcclusionPortal_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Renderer_;
using AssetRipper.SourceGenerated.Subclasses.SceneObjectIdentifier;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class OcclusionCullingDataExtensions
	{
		public static void Initialize(this IOcclusionCullingData occlusionCullingData, IExportContainer container, IOcclusionCullingSettings cullingSetting)
		{
			occlusionCullingData.PVSData_C363 = cullingSetting.PVSData_C29;
			int renderCount = cullingSetting.StaticRenderers_C29?.Count ?? 0;
			int portalCount = cullingSetting.Portals_C29?.Count ?? 0;
			occlusionCullingData.Scenes_C363.InitializeList(1);
			OcclusionScene scene = occlusionCullingData.Scenes_C363[0];
			scene.Initialize(cullingSetting.SceneGUID_C29, renderCount, portalCount);

			occlusionCullingData.StaticRenderers_C363.InitializeList(scene.SizeRenderers);
			occlusionCullingData.Portals_C363.InitializeList(scene.SizePortals);
			occlusionCullingData.SetIDs(container, cullingSetting, scene);
		}

		private static void InitializeList<T>(this AssetList<T> list, int size) where T : new()
		{
			list.Clear();
			list.Capacity = size;
			for(int i = 0; i < size; i++)
			{
				list.AddNew();
			}
		}

		public static void Initialize(this OcclusionScene occlusionScene, GUID scene, int renderSize, int portalSize)
		{
			occlusionScene.Scene.CopyValues(scene);
			occlusionScene.IndexRenderers = 0;
			occlusionScene.SizeRenderers = renderSize;
			occlusionScene.IndexPortals = 0;
			occlusionScene.SizePortals = portalSize;
		}

		public static void SetExportData(this IOcclusionCullingData occlusionCullingData, IExportContainer container)
		{
			// if < 3.0.0 this asset doesn't exist

			// 3.0.0 to 5.5.0 this asset is created by culling settings so it has set data already
			if (container.Version.IsLess(5,5))
			{
				return;
			}

			// if >= 5.5.0 and !Release this asset containts renderer data
			if (!container.Flags.IsRelease())
			{
				return;
			}

			// if >= 5.5.0 and Release this asset doesn't containt renderers data so we need to create it
			List<IOcclusionCullingSettings> cullingSettings = new List<IOcclusionCullingSettings>();
			foreach (IUnityObjectBase asset in occlusionCullingData.SerializedFile.Collection.FetchAssets())
			{
				if (asset is IOcclusionCullingSettings cullingSetting)
				{
					if (cullingSetting.Has_OcclusionCullingData_C29() && cullingSetting.OcclusionCullingData_C29.IsAsset(cullingSetting.SerializedFile, occlusionCullingData))
					{
						cullingSettings.Add(cullingSetting);
					}
				}
			}

			int maxRenderer = occlusionCullingData.Scenes_C363.Max(j => j.IndexRenderers + j.SizeRenderers);
			occlusionCullingData.StaticRenderers_C363.InitializeList(maxRenderer);
			int maxPortal = occlusionCullingData.Scenes_C363.Max(j => j.IndexPortals + j.SizePortals);
			occlusionCullingData.Portals_C363.InitializeList(maxPortal);

			foreach (IOcclusionCullingSettings cullingSetting in cullingSettings)
			{
				int sceneIndex = occlusionCullingData.Scenes_C363.IndexOf(t => (UnityGUID)t.Scene == (UnityGUID)cullingSetting.SceneGUID_C29);
				if (sceneIndex == -1)
				{
					Logger.Log(LogType.Error, LogCategory.Export, $"Unable to find scene data with GUID {cullingSetting.SceneGUID_C29} in {occlusionCullingData.GetNameNotEmpty()}");
					continue;
				}

				IOcclusionScene scene = occlusionCullingData.Scenes_C363[sceneIndex];
				if (scene.SizeRenderers != cullingSetting.StaticRenderers_C29.Count)
				{
					throw new Exception($"Scene renderer count {scene.SizeRenderers} doesn't match with given {cullingSetting.StaticRenderers_C29.Count}");
				}
				if (scene.SizePortals != cullingSetting.Portals_C29.Count)
				{
					throw new Exception($"Scene portal count {scene.SizePortals} doesn't match with given {cullingSetting.Portals_C29.Count}");
				}
				SetIDs(occlusionCullingData, container, cullingSetting, scene);
			}
		}

		private static void SetIDs(this IOcclusionCullingData occlusionCullingData, IExportContainer container, IOcclusionCullingSettings cullingSetting, IOcclusionScene scene)
		{
			for (int i = 0; i < cullingSetting.StaticRenderers_C29.Count; i++)
			{
				PPtr_Renderer__5_0_0_f4 prenderer = cullingSetting.StaticRenderers_C29[i];
				IRenderer renderer = prenderer.FindAsset(cullingSetting.SerializedFile);
				occlusionCullingData.StaticRenderers_C363[scene.IndexRenderers + i].SetObjectID(container, renderer);
			}

			for (int i = 0; i < cullingSetting.Portals_C29.Count; i++)
			{
				PPtr_OcclusionPortal__5_5_0_f3 pportal = cullingSetting.Portals_C29[i];
				IOcclusionPortal portal = pportal.FindAsset(cullingSetting.SerializedFile);
				occlusionCullingData.Portals_C363[scene.IndexPortals + i].SetObjectID(container, portal);
			}
		}

		private static void SetObjectID(this ISceneObjectIdentifier sceneObjectIdentifier, IExportContainer container, IUnityObjectBase asset)
		{
			if (sceneObjectIdentifier is null)
			{
				throw new ArgumentNullException(nameof(sceneObjectIdentifier));
			}

			long lid = asset == null ? 0 : container.GetExportID(asset);
			sceneObjectIdentifier.TargetObject = lid;
			sceneObjectIdentifier.TargetPrefab = 0;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PPtrCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoScript_;
using AssetRipper.SourceGenerated.Subclasses.PPtrCurve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PPtrCurveExtensions
	{
		public static void SetValues(this IPPtrCurve curve, string path, string attribute, ClassIDType classID, IPPtr_MonoScript_ script)
		{
			curve.Path.String = path;
			curve.Attribute.String = attribute;
			curve.ClassID = (int)classID;
			curve.Script.CopyValues(script);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PackedFloatVectorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_float;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PackedFloatVectorExtensions
	{
		public static bool IsSet(this PackedBitVector_float packedVector) => packedVector.NumItems > 0;

		public static void CopyValuesFrom(this PackedBitVector_float instance, PackedBitVector_float source)
		{
			instance.NumItems = source.NumItems;
			instance.Range = source.Range;
			instance.Start = source.Start;
			instance.Data = source.Data.ToArray();
			instance.BitSize = source.BitSize;
		}

		public static float[] Unpack(this PackedBitVector_float packedVector)
		{
			return packedVector.Unpack(packedVector.NumItems, 0);
		}

		public static float[] Unpack(this PackedBitVector_float packedVector, uint chunkCount, int offset)
		{
			int bitIndex = packedVector.BitSize * offset % 8;
			int byteIndex = packedVector.BitSize * offset / 8;

			float scale = 1.0f / packedVector.Range;
			float halfMaxValue = scale * ((1 << packedVector.BitSize) - 1);
			float[] buffer = new float[chunkCount];

			for (int i = 0; i < chunkCount; i++)
			{
				int value = 0;
				int bits = 0;
				while (bits < packedVector.BitSize)
				{
					value |= packedVector.Data[byteIndex] >> bitIndex << bits;
					int num = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
					bitIndex += num;
					bits += num;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				value &= (1 << packedVector.BitSize) - 1;
				buffer[i] = packedVector.Start + value / halfMaxValue;
			}
			return buffer;
		}

		public static float[] Unpack(this PackedBitVector_float packedVector, uint chunkSize, uint chunkCount, int offset)
		{
			return packedVector.Unpack(chunkSize * chunkCount, offset);
		}

		public static float[] UnpackFloats(this PackedBitVector_float packedVector, int itemCountInChunk, int chunkStride, int start = 0, int numChunks = -1)
		{
			if (chunkStride % 4 != 0)
			{
				throw new ArgumentException(nameof(chunkStride));
			}

			int bitIndex = packedVector.BitSize * start;
			int byteIndex = bitIndex / 8;
			bitIndex %= 8;

			float scale = 1.0f / packedVector.Range;
			if (numChunks == -1)
			{
				numChunks = (int)packedVector.NumItems / itemCountInChunk;
			}

			int end = chunkStride * numChunks / 4;
			List<float> data = new List<float>();
			for (int index = 0; index != end; index += chunkStride / 4)
			{
				for (int i = 0; i < itemCountInChunk; ++i)
				{
					uint x = 0;

					int bits = 0;
					while (bits < packedVector.BitSize)
					{
						x |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bits));
						int read = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
						bitIndex += read;
						bits += read;
						if (bitIndex == 8)
						{
							byteIndex++;
							bitIndex = 0;
						}
					}
					x &= unchecked((uint)(1 << packedVector.BitSize) - 1u);
					data.Add(x / (scale * ((1 << packedVector.BitSize) - 1)) + packedVector.Start);
				}
			}
			return data.ToArray();
		}

		public static void PackFloats(this PackedBitVector_float packedVector, float[] data, int itemCountInChunk, int chunkStride, int numChunks, int bitSize, bool adjustBitSize)
		{
			if (data.Length != itemCountInChunk * numChunks)
			{
				throw new ArgumentException(null, nameof(data));
			}

			if (chunkStride != itemCountInChunk * 4)
			{
				throw new ArgumentException(null, nameof(chunkStride));
			}

			packedVector.PackFloats(data, bitSize, adjustBitSize);
		}

		public static void PackFloats(this PackedBitVector_float packedVector, float[] data, int bitSize, bool adjustBitSize)
		{
			float maxf = float.NegativeInfinity;
			float minf = float.PositiveInfinity;
			for (int i = 0; i < data.Length; ++i)
			{
				if (maxf < data[i])
				{
					maxf = data[i];
				}

				if (minf > data[i])
				{
					minf = data[i];
				}
			}

			packedVector.Range = maxf - minf;

			if (adjustBitSize)
			{
				bitSize += GetBitCount(packedVector.Range);
			}

			if (bitSize > 32)
			{
				bitSize = 32;
			}

			packedVector.Start = minf;
			packedVector.NumItems = (uint)(data.Length);
			packedVector.BitSize = (byte)bitSize;
			packedVector.Data = new byte[(packedVector.NumItems * bitSize + 7) / 8];


			double scale = 1.0d / packedVector.Range;

			int bitIndex = 0;
			int byteIndex = 0;

			for (int i = 0; i < data.Length; ++i)
			{
				double scaled = (data[i] - packedVector.Start) * scale;
				if (scaled < 0)
				{
					scaled = 0d;
				}
				else if (scaled > 1)
				{
					scaled = 1d;
				}

				float f = BitConverter.Int32BitsToSingle((1 << (packedVector.BitSize)) - 1);
				double d = scaled * f;
				uint x = BitConverter.SingleToUInt32Bits((float)d);

				int bits = 0;
				while (bits < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((x >> bits) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bits, 8 - bitIndex);
					bitIndex += read;
					bits += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		private static int GetBitCount(double value)
		{
			double log = System.Math.Log2(value);
			return (int)System.Math.Ceiling(log);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PackedIntVectorExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_int;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PackedIntVectorExtensions
	{
		public static bool IsSet(this PackedBitVector_int packedVector) => packedVector.NumItems > 0;

		public static void CopyValuesFrom(this PackedBitVector_int instance, PackedBitVector_int source)
		{
			instance.NumItems = source.NumItems;
			instance.Data = source.Data.ToArray();
			instance.BitSize = source.BitSize;
		}

		public static void PackUInts(this PackedBitVector_int packedVector, uint[] data)
		{
			uint maxDataValue = 0;
			for (int i = 0; i < data.Length; i++)
			{
				if (maxDataValue < data[i])
				{
					maxDataValue = data[i];
				}
			}

			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
			packedVector.Data = new byte[(data.Length * packedVector.BitSize + 7) / 8];

			int bitIndex = 0;
			int byteIndex = 0;
			for (int i = 0; i < data.Length; i++)
			{
				int bitOffset = 0;
				while (bitOffset < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((data[i] >> bitOffset) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		public static void PackUShorts(this PackedBitVector_int packedVector, ushort[] data)
		{
			uint maxDataValue = 0;
			for (int i = 0; i < data.Length; i++)
			{
				if (maxDataValue < data[i])
				{
					maxDataValue = data[i];
				}
			}

			packedVector.NumItems = (uint)data.Length;
			packedVector.BitSize = maxDataValue == 0xFFFFFFFF ? (byte)32 : GetBitCount(maxDataValue + 1U);
			packedVector.Data = new byte[(data.Length * packedVector.BitSize + 7) / 8];

			int bitIndex = 0;
			int byteIndex = 0;
			for (int i = 0; i < data.Length; i++)
			{
				int bitOffset = 0;
				while (bitOffset < packedVector.BitSize)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((data[i] >> bitOffset) << bitIndex));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
			}
		}

		public static int[] UnpackInts(this PackedBitVector_int packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			int[] buffer = new int[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= packedVector.Data[byteIndex] >> bitIndex << bitOffset;
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= unchecked((1 << packedVector.BitSize) - 1);
			}
			return buffer;
		}

		public static uint[] UnpackUInts(this PackedBitVector_int packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			uint[] buffer = new uint[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= unchecked((uint)((packedVector.Data[byteIndex] >> bitIndex) << bitOffset));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= (1U << packedVector.BitSize) - 1;
			}
			return buffer;
		}

		public static ushort[] UnpackUShorts(this PackedBitVector_int packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			ushort[] buffer = new ushort[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				int bitOffset = 0;
				buffer[i] = 0;
				while (bitOffset < packedVector.BitSize)
				{
					buffer[i] |= unchecked((ushort)((packedVector.Data[byteIndex] >> bitIndex) << bitOffset));
					int read = System.Math.Min(packedVector.BitSize - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				buffer[i] &= unchecked((ushort)((1U << packedVector.BitSize) - 1));
			}
			return buffer;
		}

		private static byte GetBitCount(uint value)
		{
			double log = System.Math.Log2(value);
			return (byte)System.Math.Ceiling(log);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PackedQuatVectorExtensions.cs`:

```cs
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.PackedBitVector_Quaternionf;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PackedQuatVectorExtensions
	{
		public static void CopyValuesFrom(this PackedBitVector_Quaternionf instance, PackedBitVector_Quaternionf source)
		{
			instance.NumItems = source.NumItems;
			instance.Data = source.Data.ToArray();
		}

		public static void Pack(this PackedBitVector_Quaternionf packedVector, IQuaternionf[] inputData)
		{
			packedVector.NumItems = (uint)inputData.Length;
			packedVector.Data = new byte[inputData.Length * 4];

			int bitIndex = 0;
			int byteIndex = 0;

			for (int i = 0; i < inputData.Length; i++)
			{
				IQuaternionf q = inputData[i];
				byte flags = unchecked((byte)(q.X < 0 ? 4 : 0));

				float max = System.Math.Abs(q.X);
				if (System.Math.Abs(q.Y) > max)
				{
					max = System.Math.Abs(q.Y);
					flags = 1;
					if (q.Y < 0)
					{
						flags |= 4;
					}
				}
				if (System.Math.Abs(q.Z) > max)
				{
					max = System.Math.Abs(q.Z);
					flags = 2;
					if (q.Z < 0)
					{
						flags |= 4;
					}
				}
				if (System.Math.Abs(q.W) > max)
				{
					max = System.Math.Abs(q.W);
					flags = 3;
					if (q.W < 0)
					{
						flags |= 4;
					}
				}
				int bitOffset = 0;
				while (bitOffset < 3)
				{
					packedVector.Data[byteIndex] |= unchecked((byte)((flags >> bitOffset) << bitIndex));
					int num = System.Math.Min(3 - bitOffset, 8 - bitIndex);
					bitIndex += num;
					bitOffset += num;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				for (int j = 0; j < 4; j++)
				{
					if ((flags & 3) != j)
					{
						int bitSize = (((flags & 3) + 1) % 4 == j) ? 9 : 10;
						double scaled = (q.GetAt(j) + 1d) * 0.5d;
						if (scaled < 0)
						{
							scaled = 0d;
						}
						else if (scaled > 1)
						{
							scaled = 1d;
						}

						float f = BitConverter.Int32BitsToSingle((1 << bitSize) - 1);
						uint x = BitConverter.SingleToUInt32Bits((float)(scaled * f));

						bitOffset = 0;
						while (bitOffset < bitSize)
						{
							packedVector.Data[byteIndex] |= unchecked((byte)((x >> bitOffset) << bitIndex));
							int read = System.Math.Min(bitSize - bitOffset, 8 - bitIndex);
							bitIndex += read;
							bitOffset += read;
							if (bitIndex == 8)
							{
								byteIndex++;
								bitIndex = 0;
							}
						}
					}
				}
			}
		}

		public static Quaternionf[] Unpack(this PackedBitVector_Quaternionf packedVector)
		{
			int bitIndex = 0;
			int byteIndex = 0;
			Quaternionf[] buffer = new Quaternionf[packedVector.NumItems];
			for (int i = 0; i < packedVector.NumItems; i++)
			{
				uint flags = 0;
				int bitOffset = 0;
				while (bitOffset < 3)
				{
					flags |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
					int read = System.Math.Min(3 - bitOffset, 8 - bitIndex);
					bitIndex += read;
					bitOffset += read;
					if (bitIndex == 8)
					{
						byteIndex++;
						bitIndex = 0;
					}
				}
				flags &= 7;

				double sum = 0;
				Quaternionf quaternion = new Quaternionf();
				for (int j = 0; j < 4; j++)
				{
					if ((flags & 3) != j)
					{
						int bitSize = (((flags & 3) + 1) % 4 == j) ? 9 : 10;

						uint value = 0;
						bitOffset = 0;
						while (bitOffset < bitSize)
						{
							value |= unchecked((uint)(packedVector.Data[byteIndex] >> bitIndex << bitOffset));
							int num = System.Math.Min(bitSize - bitOffset, 8 - bitIndex);
							bitIndex += num;
							bitOffset += num;
							if (bitIndex == 8)
							{
								byteIndex++;
								bitIndex = 0;
							}
						}
						value &= unchecked((uint)((1 << bitSize) - 1));

						// final value's range is [-1.0f : 1.0f]
						double halfMaxValue = 0.5d * ((1 << bitSize) - 1);
						double quaternion_j = value / halfMaxValue - 1.0d;
						quaternion.SetAt(j, (float)quaternion_j);
						sum += quaternion_j * quaternion_j;
					}
				}

				int lastComponent = unchecked((int)(flags & 3));
				quaternion.SetAt(lastComponent, (float)System.Math.Sqrt(1.0d - sum));
				if ((flags & 4) != 0)
				{
					quaternion.FlipSignAt(lastComponent);
				}

				buffer[i] = quaternion;
			}
			return buffer;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PackingSettingsExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PackingParameters;
using AssetRipper.SourceGenerated.Subclasses.PackingSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PackingSettingsExtensions
	{
		public static void Initialize(this IPackingSettings settings)
		{
			settings.Padding = 2;
			settings.BlockOffset = 1;
			settings.AllowAlphaSplitting = false;
			settings.EnableRotation = true;
			settings.EnableTightPacking = true;
			settings.EnableAlphaDilation = true;
		}

		public static void Initialize(this IPackingParameters settings) //maybe rename to PackingSettings?
		{
			settings.Padding = 2;
			settings.PaddingPower = 2; //todo: rename to Padding
			settings.BlockOffset = 1;
			settings.AllowAlphaSplitting = 0;
			settings.EnableRotation = 1;
			settings.EnableTightPacking = 1;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ParticleSystemEmissionBurstExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.ParticleSystemEmissionBurst;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ParticleSystemEmissionBurstExtensions
	{
		public static void SetValues(this IParticleSystemEmissionBurst burst, UnityVersion version, float time, int minValue, int maxValue)
		{
			burst.Time = time;
			burst.CycleCount_Int32 = 1;
			burst.CycleCount_UInt32 = 1;
			burst.RepeatInterval = 0.01f;
			burst.CountCurve?.SetValues(version, minValue, maxValue);
			burst.Probability = 1.0f;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ParticleSystemExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem;
using AssetRipper.SourceGenerated.Classes.ClassID_198;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ParticleSystemExtensions
	{
		public static ParticleSystemStopAction GetStopAction(this IParticleSystem system)
		{
			return (ParticleSystemStopAction)system.StopAction_C198;
		}

		public static ParticleSystemCullingMode GetCullingMode(this IParticleSystem system)
		{
			return (ParticleSystemCullingMode)system.CullingMode_C198;
		}

		public static ParticleSystemRingBufferMode GetRingBufferMode(this IParticleSystem system)
		{
			return (ParticleSystemRingBufferMode)system.RingBufferMode_C198;
		}

		public static ParticleSystemSimulationSpace GetMoveWithTransform(this IParticleSystem system)
		{
			if (system.Has_MoveWithTransform_C198_Boolean())
			{
				return system.MoveWithTransform_C198_Boolean ? ParticleSystemSimulationSpace.Local : ParticleSystemSimulationSpace.World;
			}
			else
			{
				return (ParticleSystemSimulationSpace)system.MoveWithTransform_C198_Int32;
			}
		}

		public static ParticleSystemScalingMode GetScalingMode(this IParticleSystem system)
		{
			return (ParticleSystemScalingMode)system.ScalingMode_C198;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ParticleSystemForceFieldParametersExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystemForceField;
using AssetRipper.SourceGenerated.Subclasses.ParticleSystemForceFieldParameters;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ParticleSystemForceFieldParametersExtensions
	{
		public static ParticleSystemForceFieldShape GetShape(this IParticleSystemForceFieldParameters parameters)
		{
			return (ParticleSystemForceFieldShape)parameters.Shape;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ParticleSystemRendererExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystemRenderer;
using AssetRipper.Core.Classes.SpriteRenderer;
using AssetRipper.SourceGenerated.Classes.ClassID_199;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ParticleSystemRendererExtensions
	{
		public static ParticleSystemRenderMode GetRenderMode(this IParticleSystemRenderer renderer)
		{
			return renderer.Has_RenderMode_C199_UInt16()
				? (ParticleSystemRenderMode)renderer.RenderMode_C199_UInt16
				: (ParticleSystemRenderMode)renderer.RenderMode_C199_Int32;
		}

		public static ParticleSystemSortMode GetSortMode(this IParticleSystemRenderer renderer)
		{
			return renderer.Has_SortMode_C199_Byte()
				? (ParticleSystemSortMode)renderer.SortMode_C199_Byte
				: renderer.Has_SortMode_C199_UInt16()
					? (ParticleSystemSortMode)renderer.SortMode_C199_UInt16
					: (ParticleSystemSortMode)renderer.SortMode_C199_Int32;
		}

		public static ParticleSystemRenderSpace GetRenderAlignment(this IParticleSystemRenderer renderer)
		{
			return renderer.Has_RenderAlignment_C199()
				? (ParticleSystemRenderSpace)renderer.RenderAlignment_C199
				: renderer.GetRenderMode() == ParticleSystemRenderMode.Mesh
					? ParticleSystemRenderSpace.Local
					: ParticleSystemRenderSpace.View;
		}

		public static SpriteMaskInteraction GetMaskInteraction(this IParticleSystemRenderer renderer)
		{
			return (SpriteMaskInteraction)renderer.MaskInteraction_C199;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Physics2DSettings.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_19;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Physics2DSettings
	{
		public static void ConvertToEditorFormat(this IPhysics2DSettings settings)
		{
			settings.AlwaysShowColliders_C19 = false;
			settings.ColliderAABBColor_C19?.SetValues(1.0f, 1.0f, 0.0f, 0.2509804f);
			settings.ColliderAsleepColor_C19?.SetValues(0.5686275f, 0.95686275f, 0.54509807f, 0.36078432f);
			settings.ColliderAwakeColor_C19?.SetValues(0.5686275f, 0.95686275f, 0.54509807f, 0.7529412f);
			settings.ColliderContactColor_C19?.SetValues(1.0f, 0.0f, 1.0f, 0.6862745f);
			settings.ContactArrowScale_C19 = 0.2f;
			settings.ShowColliderAABB_C19 = false;
			settings.ShowColliderContacts_C19 = false;
			settings.ShowColliderSleep_C19 = true;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PhysicsJobOptions2DExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.PhysicsJobOptions2D;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PhysicsJobOptions2DExtensions
	{
		public static void SetToDefault(this IPhysicsJobOptions2D options)
		{
			options.UseMultithreading = false;
			options.UseConsistencySorting = false;
			options.InterpolationPosesPerJob = 100;
			options.NewContactsPerJob = 30;
			options.CollideContactsPerJob = 100;
			options.ClearFlagsPerJob = 200;
			options.ClearBodyForcesPerJob = 200;
			options.SyncDiscreteFixturesPerJob = 50;
			options.SyncContinuousFixturesPerJob = 50;
			options.FindNearestContactsPerJob = 100;
			options.UpdateTriggerContactsPerJob = 100;
			options.IslandSolverCostThreshold = 100;
			options.IslandSolverBodyCostScale = 1;
			options.IslandSolverContactCostScale = 10;
			options.IslandSolverJointCostScale = 10;
			options.IslandSolverBodiesPerJob = 50;
			options.IslandSolverContactsPerJob = 50;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PhysicsManagerExtensions.cs`:

```cs
using AssetRipper.Core.Classes.PhysicsManager;
using AssetRipper.SourceGenerated.Classes.ClassID_55;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PhysicsManagerExtensions
	{
		public static ContactsGeneration GetContactsGeneration(this IPhysicsManager manager)
		{
			if (manager.Has_ContactsGeneration_C55())
			{
				return (ContactsGeneration)manager.ContactsGeneration_C55;
			}
			else
			{
				return manager.EnablePCM_C55 ? ContactsGeneration.PersistentContactManifold : ContactsGeneration.LegacyContactsGeneration;
			}
		}

		public static ContactPairsMode GetContactPairsMode(this IPhysicsManager manager)
		{
			return (ContactPairsMode)manager.ContactPairsMode_C55;
		}

		public static BroadphaseType GetBroadphaseType(this IPhysicsManager manager)
		{
			return (BroadphaseType)manager.BroadphaseType_C55;
		}

		public static FrictionType GetFrictionType(this IPhysicsManager manager)
		{
			return (FrictionType)manager.FrictionType_C55;
		}

		public static SolverType GetSolverType(this IPhysicsManager manager)
		{
			return (SolverType)manager.SolverType_C55;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PlatformShaderDefinesExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.SourceGenerated.Subclasses.PlatformShaderDefines;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PlatformShaderDefinesExtensions
	{
		public static GPUPlatform GetSerializationMode(this IPlatformShaderDefines settings)
		{
			return (GPUPlatform)settings.ShaderPlatform;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/PrefabInstanceExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.SourceGenerated.Classes.ClassID_1001;
using AssetRipper.SourceGenerated.Classes.ClassID_18;
using AssetRipper.SourceGenerated.Subclasses.PPtr_EditorExtension_;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class PrefabInstanceExtensions
	{
		public static string GetName(this IPrefabInstance prefab, IAssetContainer rootGameObjectFile)
		{
			if (prefab is IHasNameString hasName && string.IsNullOrEmpty(hasName.NameString))
			{
				return hasName.NameString;
			}
			else
			{
				return prefab.RootGameObject_C1001?.TryGetAsset(rootGameObjectFile)?.NameString ?? prefab.AssetClassName;
			}
		}

		public static IEnumerable<IEditorExtension> FetchObjects(this IPrefabInstance prefab, IAssetContainer file)
		{
			if (prefab.Has_RootGameObject_C1001())
			{
				foreach (IEditorExtension asset in prefab.RootGameObject_C1001.GetAsset(file).FetchHierarchy())
				{
					yield return asset;
				}
			}
			else if (prefab.Has_Objects_C1001())//DataTemplate
			{
				foreach (PPtr_EditorExtension__3_0_0_f5 asset in prefab.Objects_C1001)
				{
					yield return asset.GetAsset(file);
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/QualitySettingExtensions.cs`:

```cs
using AssetRipper.Core.Classes.QualitySettings;
using AssetRipper.SourceGenerated.Subclasses.QualitySetting;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class QualitySettingExtensions
	{
		public static void ConvertToEditorFormat(this IQualitySetting setting)
		{
			setting.ShadowProjection = (int)ShadowProjection.StableFit;
			setting.ShadowNearPlaneOffset = 3.0f;
			setting.ShadowCascade2Split = 1.0f / 3.0f;
			setting.ShadowCascade4Split?.SetValues(2.0f / 30.0f, 0.2f, 14.0f / 30.0f);
			setting.StreamingMipmapsAddAllCameras = true;
			setting.StreamingMipmapsMemoryBudget = 512.0f;
			setting.StreamingMipmapsRenderersPerFrame = 512;
			setting.StreamingMipmapsMaxLevelReduction = 2;
			setting.StreamingMipmapsMaxFileIORequests = 1024;
			setting.AsyncUploadTimeSlice = 2;
			setting.AsyncUploadBufferSize = 4;
			setting.ResolutionScalingFixedDPIFactor = 1.0f;
		}

		public static ShadowQuality GetShadows(this IQualitySetting setting)
		{
			return (ShadowQuality)setting.Shadows;
		}

		public static ShadowResolution GetShadowResolution(this IQualitySetting setting)
		{
			return (ShadowResolution)setting.ShadowResolution;
		}

		public static ShadowProjection Get(this IQualitySetting setting)
		{
			return (ShadowProjection)setting.ShadowProjection;
		}

		public static ShadowCascades GetShadowCascades(this IQualitySetting setting)
		{
			return (ShadowCascades)setting.ShadowCascades;
		}

		public static ShadowmaskMode GetShadowmaskMode(this IQualitySetting setting)
		{
			return (ShadowmaskMode)setting.ShadowmaskMode;
		}

		public static SkinWeights GetSkinWeights(this IQualitySetting setting)
		{
			return (SkinWeights)(setting.Has_SkinWeights() ? setting.SkinWeights : setting.BlendWeights); 
			//todo: merge BlendWeights into SkinWeights in the source generation
		}

		public static TextureQuality GetTextureQuality(this IQualitySetting setting)
		{
			return (TextureQuality)setting.TextureQuality;
		}

		public static AnisotropicFiltering GetAnisotropicTextures(this IQualitySetting setting)
		{
			return (AnisotropicFiltering)setting.AnisotropicTextures;
		}

		public static AntiAliasing GetAntiAliasing(this IQualitySetting setting)
		{
			return (AntiAliasing)setting.AntiAliasing;
		}

		public static VSyncCount GetVSyncCount(this IQualitySetting setting)
		{
			return (VSyncCount)setting.VSyncCount;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/QualitySettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.QualitySettings;
using AssetRipper.Core.IO;
using AssetRipper.SourceGenerated.Classes.ClassID_47;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class QualitySettingsExtensions
	{
		public static void ConvertToEditorFormat(this IQualitySettings settings)
		{
			settings.PerPlatformDefaultQuality_C47?.SetDefaultPlatformQuality();
		}
		
		private static void SetDefaultPlatformQuality(this AssetDictionary<Utf8String, int> dictionary)
		{
			dictionary.Clear();
			dictionary.Capacity = 14;

			dictionary.Add(BuildTargetGroup.Android, QualityLevel.Simple);
			dictionary.Add(BuildTargetGroup.N3DS, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.Switch, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.PS4, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.PSM, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.PSP2, QualityLevel.Simple);
			dictionary.Add(BuildTargetGroup.Standalone, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.Tizen, QualityLevel.Simple);
			dictionary.Add(BuildTargetGroup.WebGL, QualityLevel.Good);
			dictionary.Add(BuildTargetGroup.WiiU, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.Metro, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.XboxOne, QualityLevel.Fantastic);
			dictionary.Add(BuildTargetGroup.iOS, QualityLevel.Simple);
			dictionary.Add(BuildTargetGroup.tvOS, QualityLevel.Simple);
		}

		private static void Add(this AssetDictionary<Utf8String, int> dictionary, BuildTargetGroup buildTargetGroup, QualityLevel qualityLevel)
		{
			Utf8String str = new();
			str.String = buildTargetGroup.ToExportString();
			dictionary.Add(str, (int)qualityLevel);
		}

		public static QualityLevel GetDefaultMobileQuality(this IQualitySettings settings)
		{
			return (QualityLevel)settings.DefaultMobileQuality_C47;
		}

		public static QualityLevel GetDefaultStandaloneQuality(this IQualitySettings settings)
		{
			return (QualityLevel)settings.DefaultStandaloneQuality_C47;
		}

		public static QualityLevel GetDefaultWebPlayerQuality(this IQualitySettings settings)
		{
			return (QualityLevel)settings.DefaultWebPlayerQuality_C47;
		}

		public static QualityLevel GetEditorQuality(this IQualitySettings settings)
		{
			return (QualityLevel)settings.EditorQuality_C47;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/QuaternionCurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class QuaternionCurveExtensions
	{
		public static void SetValues(this IQuaternionCurve curve, string path)
		{
			curve.Path.String = path;
			curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RectfExtensions.cs`:

```cs
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.Rectf;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RectfExtensions
	{
		public static Vector2f Center(this IRectf rectangle) => new Vector2f(rectangle.X + rectangle.Width / 2.0f, rectangle.Y + rectangle.Height / 2.0f);
		public static Vector2f Position(this IRectf rectangle) => new Vector2f(rectangle.X, rectangle.Y);
		public static Vector2f Size(this IRectf rectangle) => new Vector2f(rectangle.Width, rectangle.Height);
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ReflectionProbeExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ReflectionProbe;
using AssetRipper.SourceGenerated.Classes.ClassID_215;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ReflectionProbeExtensions
	{
		public static ReflectionProbeType GetType_(this IReflectionProbe probe)
		{
			return (ReflectionProbeType)probe.Type_C215;
		}

		public static ReflectionProbeMode GetMode(this IReflectionProbe probe)
		{
			return (ReflectionProbeMode)probe.Mode_C215;
		}

		public static ReflectionProbeRefreshMode GetRefreshMode(this IReflectionProbe probe)
		{
			return (ReflectionProbeRefreshMode)probe.RefreshMode_C215;
		}

		public static ReflectionProbeTimeSlicingMode GetTimeSlicingMode(this IReflectionProbe probe)
		{
			return (ReflectionProbeTimeSlicingMode)probe.TimeSlicingMode_C215;
		}

		public static ReflectionProbeClearFlags GetClearFlags(this IReflectionProbe probe)
		{
			return (ReflectionProbeClearFlags)probe.ClearFlags_C215;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RenderSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.RenderSettings;
using AssetRipper.SourceGenerated.Classes.ClassID_104;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RenderSettingsExtensions
	{
		public static FogMode GetFogMode(this IRenderSettings settings)
		{
			return (FogMode)settings.FogMode_C104;
		}

		public static AmbientMode GetAmbientMode(this IRenderSettings settings)
		{
			return (AmbientMode)settings.AmbientMode_C104;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RenderTextureExtensions.cs`:

```cs
using AssetRipper.Core.Classes.RenderTexture;
using AssetRipper.SourceGenerated.Classes.ClassID_84;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RenderTextureExtensions
	{
		public static RenderTextureFormat GetColorFormat(this IRenderTexture texture)
		{
			return (RenderTextureFormat)texture.ColorFormat_C84;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RendererExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Renderer;
using AssetRipper.SourceGenerated.Classes.ClassID_120;
using AssetRipper.SourceGenerated.Classes.ClassID_137;
using AssetRipper.SourceGenerated.Classes.ClassID_161;
using AssetRipper.SourceGenerated.Classes.ClassID_1971053207;
using AssetRipper.SourceGenerated.Classes.ClassID_199;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_212;
using AssetRipper.SourceGenerated.Classes.ClassID_227;
using AssetRipper.SourceGenerated.Classes.ClassID_23;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_26;
using AssetRipper.SourceGenerated.Classes.ClassID_331;
using AssetRipper.SourceGenerated.Classes.ClassID_483693784;
using AssetRipper.SourceGenerated.Classes.ClassID_73398921;
using AssetRipper.SourceGenerated.Classes.ClassID_96;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Material_;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RendererExtensions
	{
		public static string? FindMaterialPropertyNameByCRC28(this IRenderer renderer, uint crc)
		{
			foreach (IPPtr_Material_ materialPtr in renderer.GetMaterials())
			{
				IMaterial? material = materialPtr.FindAsset(renderer.SerializedFile);
				if (material == null)
				{
					continue;
				}
				string? property = material.FindPropertyNameByCRC28(crc);
				if (property == null)
				{
					continue;
				}

				return property;
			}
			return null;
		}

		public static IEnumerable<IPPtr_Material_> GetMaterials(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => meshRenderer.Materials_C23,
				IParticleRenderer particleRenderer => particleRenderer.Materials_C26,
				ITrailRenderer trailRenderer => trailRenderer.Materials_C96,
				ILineRenderer lineRenderer => lineRenderer.Materials_C120,
				ISkinnedMeshRenderer skinnedMeshRenderer => skinnedMeshRenderer.Materials_C137,
				IClothRenderer clothRenderer => clothRenderer.Materials_C161,
				IParticleSystemRenderer particleSystemRenderer => particleSystemRenderer.Materials_C199,
				ISpriteRenderer spriteRenderer => spriteRenderer.Materials_C212,
				IBillboardRenderer billboardRenderer => billboardRenderer.Materials_C227,
				ISpriteMask spriteMask => spriteMask.Materials_C331,
				ITilemapRenderer tilemapRenderer => tilemapRenderer.Materials_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => spriteShapeRenderer.Materials_C1971053207,
				IVFXRenderer vfxRenderer => vfxRenderer.Materials_C73398921 ?? Enumerable.Empty<IPPtr_Material_>(),
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static ShadowCastingMode GetShadowCastingMode(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => meshRenderer.Has_CastShadows_C23_Byte()
					? (ShadowCastingMode)meshRenderer.CastShadows_C23_Byte
					: meshRenderer.CastShadows_C23_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				IParticleRenderer particleRenderer => particleRenderer.Has_CastShadows_C26_Byte()
					? (ShadowCastingMode)particleRenderer.CastShadows_C26_Byte
					: particleRenderer.CastShadows_C26_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				ITrailRenderer trailRenderer => trailRenderer.Has_CastShadows_C96_Byte()
					? (ShadowCastingMode)trailRenderer.CastShadows_C96_Byte
					: trailRenderer.CastShadows_C96_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				ILineRenderer lineRenderer => lineRenderer.Has_CastShadows_C120_Byte()
					? (ShadowCastingMode)lineRenderer.CastShadows_C120_Byte
					: lineRenderer.CastShadows_C120_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				ISkinnedMeshRenderer skinnedMeshRenderer => skinnedMeshRenderer.Has_CastShadows_C137_Byte()
					? (ShadowCastingMode)skinnedMeshRenderer.CastShadows_C137_Byte
					: skinnedMeshRenderer.CastShadows_C137_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				IClothRenderer clothRenderer => clothRenderer.CastShadows_C161
					? ShadowCastingMode.On
					: ShadowCastingMode.Off,
				IParticleSystemRenderer particleSystemRenderer => particleSystemRenderer.Has_CastShadows_C199_Byte()
					? (ShadowCastingMode)particleSystemRenderer.CastShadows_C199_Byte
					: particleSystemRenderer.CastShadows_C199_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				ISpriteRenderer spriteRenderer => spriteRenderer.Has_CastShadows_C212_Byte()
					? (ShadowCastingMode)spriteRenderer.CastShadows_C212_Byte
					: spriteRenderer.CastShadows_C212_Boolean
						? ShadowCastingMode.On
						: ShadowCastingMode.Off,
				IBillboardRenderer billboardRenderer => (ShadowCastingMode)billboardRenderer.CastShadows_C227,
				ISpriteMask spriteMask => (ShadowCastingMode)spriteMask.CastShadows_C331,
				ITilemapRenderer tilemapRenderer => (ShadowCastingMode)tilemapRenderer.CastShadows_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => (ShadowCastingMode)spriteShapeRenderer.CastShadows_C1971053207,
				IVFXRenderer vfxRenderer => (ShadowCastingMode)vfxRenderer.CastShadows_C73398921,
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static MotionVectorGenerationMode GetMotionVectors(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => (MotionVectorGenerationMode)meshRenderer.MotionVectors_C23,
				IParticleRenderer particleRenderer => (MotionVectorGenerationMode)particleRenderer.MotionVectors_C26,
				ITrailRenderer trailRenderer => (MotionVectorGenerationMode)trailRenderer.MotionVectors_C96,
				ILineRenderer lineRenderer => (MotionVectorGenerationMode)lineRenderer.MotionVectors_C120,
				ISkinnedMeshRenderer skinnedMeshRenderer => (MotionVectorGenerationMode)skinnedMeshRenderer.MotionVectors_C137,
				IClothRenderer => default,
				IParticleSystemRenderer particleSystemRenderer => (MotionVectorGenerationMode)particleSystemRenderer.MotionVectors_C199,
				ISpriteRenderer spriteRenderer => (MotionVectorGenerationMode)spriteRenderer.MotionVectors_C212,
				IBillboardRenderer billboardRenderer => (MotionVectorGenerationMode)billboardRenderer.MotionVectors_C227,
				ISpriteMask spriteMask => (MotionVectorGenerationMode)spriteMask.MotionVectors_C331,
				ITilemapRenderer tilemapRenderer => (MotionVectorGenerationMode)tilemapRenderer.MotionVectors_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => (MotionVectorGenerationMode)spriteShapeRenderer.MotionVectors_C1971053207,
				IVFXRenderer vfxRenderer => (MotionVectorGenerationMode)vfxRenderer.MotionVectors_C73398921,
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static LightProbeUsage GetLightProbeUsage(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => meshRenderer.Has_LightProbeUsage_C23() 
					? (LightProbeUsage)meshRenderer.LightProbeUsage_C23 
					: meshRenderer.UseLightProbes_C23
						? LightProbeUsage.BlendProbes 
						: LightProbeUsage.Off,
				IParticleRenderer particleRenderer => particleRenderer.Has_LightProbeUsage_C26()
					? (LightProbeUsage)particleRenderer.LightProbeUsage_C26
					: particleRenderer.UseLightProbes_C26
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				ITrailRenderer trailRenderer => trailRenderer.Has_LightProbeUsage_C96()
					? (LightProbeUsage)trailRenderer.LightProbeUsage_C96
					: trailRenderer.UseLightProbes_C96
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				ILineRenderer lineRenderer => lineRenderer.Has_LightProbeUsage_C120()
					? (LightProbeUsage)lineRenderer.LightProbeUsage_C120
					: lineRenderer.UseLightProbes_C120
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				ISkinnedMeshRenderer skinnedMeshRenderer => skinnedMeshRenderer.Has_LightProbeUsage_C137()
					? (LightProbeUsage)skinnedMeshRenderer.LightProbeUsage_C137
					: skinnedMeshRenderer.UseLightProbes_C137
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				IClothRenderer => default,
				IParticleSystemRenderer particleSystemRenderer => particleSystemRenderer.Has_LightProbeUsage_C199()
					? (LightProbeUsage)particleSystemRenderer.LightProbeUsage_C199
					: particleSystemRenderer.UseLightProbes_C199
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				ISpriteRenderer spriteRenderer => spriteRenderer.Has_LightProbeUsage_C212()
					? (LightProbeUsage)spriteRenderer.LightProbeUsage_C212
					: spriteRenderer.UseLightProbes_C212
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				IBillboardRenderer billboardRenderer => billboardRenderer.Has_LightProbeUsage_C227()
					? (LightProbeUsage)billboardRenderer.LightProbeUsage_C227
					: billboardRenderer.UseLightProbes_C227
						? LightProbeUsage.BlendProbes
						: LightProbeUsage.Off,
				ISpriteMask spriteMask => (LightProbeUsage)spriteMask.LightProbeUsage_C331,
				ITilemapRenderer tilemapRenderer => (LightProbeUsage)tilemapRenderer.LightProbeUsage_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => (LightProbeUsage)spriteShapeRenderer.LightProbeUsage_C1971053207,
				IVFXRenderer vfxRenderer => (LightProbeUsage)vfxRenderer.LightProbeUsage_C73398921,
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static ReflectionProbeUsage GetReflectionProbeUsage(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => meshRenderer.Has_ReflectionProbeUsage_C23_Int32()
					? (ReflectionProbeUsage)meshRenderer.ReflectionProbeUsage_C23_Int32
					: (ReflectionProbeUsage)meshRenderer.ReflectionProbeUsage_C23_Byte,
				IParticleRenderer particleRenderer => particleRenderer.Has_ReflectionProbeUsage_C26_Int32()
					? (ReflectionProbeUsage)particleRenderer.ReflectionProbeUsage_C26_Int32
					: (ReflectionProbeUsage)particleRenderer.ReflectionProbeUsage_C26_Byte,
				ITrailRenderer trailRenderer => trailRenderer.Has_ReflectionProbeUsage_C96_Int32()
					? (ReflectionProbeUsage)trailRenderer.ReflectionProbeUsage_C96_Int32
					: (ReflectionProbeUsage)trailRenderer.ReflectionProbeUsage_C96_Byte,
				ILineRenderer lineRenderer => lineRenderer.Has_ReflectionProbeUsage_C120_Int32()
					? (ReflectionProbeUsage)lineRenderer.ReflectionProbeUsage_C120_Int32
					: (ReflectionProbeUsage)lineRenderer.ReflectionProbeUsage_C120_Byte,
				ISkinnedMeshRenderer skinnedMeshRenderer => skinnedMeshRenderer.Has_ReflectionProbeUsage_C137_Int32()
					? (ReflectionProbeUsage)skinnedMeshRenderer.ReflectionProbeUsage_C137_Int32
					: (ReflectionProbeUsage)skinnedMeshRenderer.ReflectionProbeUsage_C137_Byte,
				IClothRenderer => default,
				IParticleSystemRenderer particleSystemRenderer => particleSystemRenderer.Has_ReflectionProbeUsage_C199_Int32()
					? (ReflectionProbeUsage)particleSystemRenderer.ReflectionProbeUsage_C199_Int32
					: (ReflectionProbeUsage)particleSystemRenderer.ReflectionProbeUsage_C199_Byte,
				ISpriteRenderer spriteRenderer => spriteRenderer.Has_ReflectionProbeUsage_C212_Int32()
					? (ReflectionProbeUsage)spriteRenderer.ReflectionProbeUsage_C212_Int32
					: (ReflectionProbeUsage)spriteRenderer.ReflectionProbeUsage_C212_Byte,
				IBillboardRenderer billboardRenderer => billboardRenderer.Has_ReflectionProbeUsage_C227_Int32()
					? (ReflectionProbeUsage)billboardRenderer.ReflectionProbeUsage_C227_Int32
					: (ReflectionProbeUsage)billboardRenderer.ReflectionProbeUsage_C227_Byte,
				ISpriteMask spriteMask => (ReflectionProbeUsage)spriteMask.ReflectionProbeUsage_C331,
				ITilemapRenderer tilemapRenderer => (ReflectionProbeUsage)tilemapRenderer.ReflectionProbeUsage_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => (ReflectionProbeUsage)spriteShapeRenderer.ReflectionProbeUsage_C1971053207,
				IVFXRenderer vfxRenderer => (ReflectionProbeUsage)vfxRenderer.ReflectionProbeUsage_C73398921,
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static RayTracingMode GetRayTracingMode(this IRenderer renderer)
		{
			return renderer switch
			{
				IMeshRenderer meshRenderer => (RayTracingMode)meshRenderer.RayTracingMode_C23,
				IParticleRenderer particleRenderer => default,
				ITrailRenderer trailRenderer => (RayTracingMode)trailRenderer.RayTracingMode_C96,
				ILineRenderer lineRenderer => (RayTracingMode)lineRenderer.RayTracingMode_C120,
				ISkinnedMeshRenderer skinnedMeshRenderer => (RayTracingMode)skinnedMeshRenderer.RayTracingMode_C137,
				IClothRenderer => default,
				IParticleSystemRenderer particleSystemRenderer => (RayTracingMode)particleSystemRenderer.RayTracingMode_C199,
				ISpriteRenderer spriteRenderer => (RayTracingMode)spriteRenderer.RayTracingMode_C212,
				IBillboardRenderer billboardRenderer => (RayTracingMode)billboardRenderer.RayTracingMode_C227,
				ISpriteMask spriteMask => (RayTracingMode)spriteMask.RayTracingMode_C331,
				ITilemapRenderer tilemapRenderer => (RayTracingMode)tilemapRenderer.RayTracingMode_C483693784,
				ISpriteShapeRenderer spriteShapeRenderer => (RayTracingMode)spriteShapeRenderer.RayTracingMode_C1971053207,
				IVFXRenderer vfxRenderer => (RayTracingMode)vfxRenderer.RayTracingMode_C73398921,
				_ => throw new NotSupportedException(renderer.GetType().FullName)
			};
		}

		public static void ConvertToEditorFormat(this IRenderer renderer)
		{
			switch (renderer)
			{
				case IMeshRenderer meshRenderer:
					ConvertToEditorFormat(meshRenderer);
					break;
				case IParticleRenderer particleRenderer:
					ConvertToEditorFormat(particleRenderer);
					break;
				case ITrailRenderer trailRenderer:
					ConvertToEditorFormat(trailRenderer);
					break;
				case ILineRenderer lineRenderer:
					ConvertToEditorFormat(lineRenderer);
					break;
				case ISkinnedMeshRenderer skinnedMeshRenderer:
					ConvertToEditorFormat(skinnedMeshRenderer);
					break;
				case IClothRenderer clothRenderer:
					ConvertToEditorFormat(clothRenderer);
					break;
				case IParticleSystemRenderer particleSystemRenderer:
					ConvertToEditorFormat(particleSystemRenderer);
					break;
				case ISpriteRenderer spriteRenderer:
					ConvertToEditorFormat(spriteRenderer);
					break;
				case IBillboardRenderer billboardRenderer:
					ConvertToEditorFormat(billboardRenderer);
					break;
				case ISpriteMask spriteMask:
					ConvertToEditorFormat(spriteMask);
					break;
				case ITilemapRenderer tilemapRenderer:
					ConvertToEditorFormat(tilemapRenderer);
					break;
				case ISpriteShapeRenderer spriteShapeRenderer:
					ConvertToEditorFormat(spriteShapeRenderer);
					break;
				case IVFXRenderer vfxRenderer:
					ConvertToEditorFormat(vfxRenderer);
					break;
				default:
					throw new NotSupportedException(renderer.GetType().FullName);
			}
		}

		private static void ConvertToEditorFormat(IVFXRenderer vfxRenderer)
		{
			vfxRenderer.ScaleInLightmap_C73398921 = 1.0f;
			vfxRenderer.ReceiveGI_C73398921 = (int)ReceiveGI.Lightmaps;
			vfxRenderer.PreserveUVs_C73398921 = false;
			vfxRenderer.IgnoreNormalsForChartDetection_C73398921 = false;
			vfxRenderer.ImportantGI_C73398921 = false;
			vfxRenderer.StitchLightmapSeams_C73398921 = false;
			vfxRenderer.SelectedEditorRenderState_C73398921 = (int)(EditorSelectedRenderState)3;
			vfxRenderer.MinimumChartSize_C73398921 = 4;
			vfxRenderer.AutoUVMaxDistance_C73398921 = 0.5f;
			vfxRenderer.AutoUVMaxAngle_C73398921 = 89.0f;
			vfxRenderer.LightmapParameters_C73398921?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ISpriteShapeRenderer spriteShapeRenderer)
		{
			spriteShapeRenderer.ScaleInLightmap_C1971053207 = 1.0f;
			spriteShapeRenderer.ReceiveGI_C1971053207 = (int)ReceiveGI.Lightmaps;
			spriteShapeRenderer.PreserveUVs_C1971053207 = false;
			spriteShapeRenderer.IgnoreNormalsForChartDetection_C1971053207 = false;
			spriteShapeRenderer.ImportantGI_C1971053207 = false;
			spriteShapeRenderer.StitchLightmapSeams_C1971053207 = false;
			spriteShapeRenderer.SelectedEditorRenderState_C1971053207 = (int)(EditorSelectedRenderState)3;
			spriteShapeRenderer.MinimumChartSize_C1971053207 = 4;
			spriteShapeRenderer.AutoUVMaxDistance_C1971053207 = 0.5f;
			spriteShapeRenderer.AutoUVMaxAngle_C1971053207 = 89.0f;
			spriteShapeRenderer.LightmapParameters_C1971053207?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ITilemapRenderer tilemapRenderer)
		{
			tilemapRenderer.ScaleInLightmap_C483693784 = 1.0f;
			tilemapRenderer.ReceiveGI_C483693784 = (int)ReceiveGI.Lightmaps;
			tilemapRenderer.PreserveUVs_C483693784 = false;
			tilemapRenderer.IgnoreNormalsForChartDetection_C483693784 = false;
			tilemapRenderer.ImportantGI_C483693784 = false;
			tilemapRenderer.StitchLightmapSeams_C483693784 = false;
			tilemapRenderer.SelectedEditorRenderState_C483693784 = (int)(EditorSelectedRenderState)3;
			tilemapRenderer.MinimumChartSize_C483693784 = 4;
			tilemapRenderer.AutoUVMaxDistance_C483693784 = 0.5f;
			tilemapRenderer.AutoUVMaxAngle_C483693784 = 89.0f;
			tilemapRenderer.LightmapParameters_C483693784?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ISpriteMask spriteMask)
		{
			spriteMask.ScaleInLightmap_C331 = 1.0f;
			spriteMask.ReceiveGI_C331 = (int)ReceiveGI.Lightmaps;
			spriteMask.PreserveUVs_C331 = false;
			spriteMask.IgnoreNormalsForChartDetection_C331 = false;
			spriteMask.ImportantGI_C331 = false;
			spriteMask.StitchLightmapSeams_C331 = false;
			spriteMask.SelectedEditorRenderState_C331 = (int)(EditorSelectedRenderState)3;
			spriteMask.MinimumChartSize_C331 = 4;
			spriteMask.AutoUVMaxDistance_C331 = 0.5f;
			spriteMask.AutoUVMaxAngle_C331 = 89.0f;
			spriteMask.LightmapParameters_C331?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(IBillboardRenderer billboardRenderer)
		{
			billboardRenderer.ScaleInLightmap_C227 = 1.0f;
			billboardRenderer.ReceiveGI_C227 = (int)ReceiveGI.Lightmaps;
			billboardRenderer.PreserveUVs_C227 = false;
			billboardRenderer.IgnoreNormalsForChartDetection_C227 = false;
			billboardRenderer.ImportantGI_C227 = false;
			billboardRenderer.StitchLightmapSeams_C227 = false;
			billboardRenderer.SelectedEditorRenderState_C227 = (int)(EditorSelectedRenderState)3;
			billboardRenderer.MinimumChartSize_C227 = 4;
			billboardRenderer.AutoUVMaxDistance_C227 = 0.5f;
			billboardRenderer.AutoUVMaxAngle_C227 = 89.0f;
			billboardRenderer.LightmapParameters_C227?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ISpriteRenderer spriteRenderer)
		{
			spriteRenderer.ScaleInLightmap_C212 = 1.0f;
			spriteRenderer.ReceiveGI_C212 = (int)ReceiveGI.Lightmaps;
			spriteRenderer.PreserveUVs_C212 = false;
			spriteRenderer.IgnoreNormalsForChartDetection_C212 = false;
			spriteRenderer.ImportantGI_C212 = false;
			spriteRenderer.StitchLightmapSeams_C212 = false;
			spriteRenderer.SelectedEditorRenderState_C212 = (int)(EditorSelectedRenderState)3;
			spriteRenderer.MinimumChartSize_C212 = 4;
			spriteRenderer.AutoUVMaxDistance_C212 = 0.5f;
			spriteRenderer.AutoUVMaxAngle_C212 = 89.0f;
			spriteRenderer.LightmapParameters_C212?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(IParticleSystemRenderer particleSystemRenderer)
		{
			particleSystemRenderer.ScaleInLightmap_C199 = 1.0f;
			particleSystemRenderer.ReceiveGI_C199 = (int)ReceiveGI.Lightmaps;
			particleSystemRenderer.PreserveUVs_C199 = false;
			particleSystemRenderer.IgnoreNormalsForChartDetection_C199 = false;
			particleSystemRenderer.ImportantGI_C199 = false;
			particleSystemRenderer.StitchLightmapSeams_C199 = false;
			particleSystemRenderer.SelectedEditorRenderState_C199 = (int)(EditorSelectedRenderState)3;
			particleSystemRenderer.MinimumChartSize_C199 = 4;
			particleSystemRenderer.AutoUVMaxDistance_C199 = 0.5f;
			particleSystemRenderer.AutoUVMaxAngle_C199 = 89.0f;
			particleSystemRenderer.LightmapParameters_C199?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(IClothRenderer clothRenderer)
		{
			clothRenderer.ScaleInLightmap_C161 = 1.0f;
			//others absent because cloth renderer not used in Unity 5+
		}

		private static void ConvertToEditorFormat(ISkinnedMeshRenderer skinnedMeshRenderer)
		{
			skinnedMeshRenderer.ScaleInLightmap_C137 = 1.0f;
			skinnedMeshRenderer.ReceiveGI_C137 = (int)ReceiveGI.Lightmaps;
			skinnedMeshRenderer.PreserveUVs_C137 = false;
			skinnedMeshRenderer.IgnoreNormalsForChartDetection_C137 = false;
			skinnedMeshRenderer.ImportantGI_C137 = false;
			skinnedMeshRenderer.StitchLightmapSeams_C137 = false;
			skinnedMeshRenderer.SelectedEditorRenderState_C137 = (int)(EditorSelectedRenderState)3;
			skinnedMeshRenderer.MinimumChartSize_C137 = 4;
			skinnedMeshRenderer.AutoUVMaxDistance_C137 = 0.5f;
			skinnedMeshRenderer.AutoUVMaxAngle_C137 = 89.0f;
			skinnedMeshRenderer.LightmapParameters_C137?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ILineRenderer lineRenderer)
		{
			lineRenderer.ScaleInLightmap_C120 = 1.0f;
			lineRenderer.ReceiveGI_C120 = (int)ReceiveGI.Lightmaps;
			lineRenderer.PreserveUVs_C120 = false;
			lineRenderer.IgnoreNormalsForChartDetection_C120 = false;
			lineRenderer.ImportantGI_C120 = false;
			lineRenderer.StitchLightmapSeams_C120 = false;
			lineRenderer.SelectedEditorRenderState_C120 = (int)(EditorSelectedRenderState)3;
			lineRenderer.MinimumChartSize_C120 = 4;
			lineRenderer.AutoUVMaxDistance_C120 = 0.5f;
			lineRenderer.AutoUVMaxAngle_C120 = 89.0f;
			lineRenderer.LightmapParameters_C120?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(ITrailRenderer trailRenderer)
		{
			trailRenderer.ScaleInLightmap_C96 = 1.0f;
			trailRenderer.ReceiveGI_C96 = (int)ReceiveGI.Lightmaps;
			trailRenderer.PreserveUVs_C96 = false;
			trailRenderer.IgnoreNormalsForChartDetection_C96 = false;
			trailRenderer.ImportantGI_C96 = false;
			trailRenderer.StitchLightmapSeams_C96 = false;
			trailRenderer.SelectedEditorRenderState_C96 = (int)(EditorSelectedRenderState)3;
			trailRenderer.MinimumChartSize_C96 = 4;
			trailRenderer.AutoUVMaxDistance_C96 = 0.5f;
			trailRenderer.AutoUVMaxAngle_C96 = 89.0f;
			trailRenderer.LightmapParameters_C96?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(IParticleRenderer particleRenderer)
		{
			particleRenderer.ScaleInLightmap_C26 = 1.0f;
			//ReceiveGI only present in Unity 2019+
			particleRenderer.PreserveUVs_C26 = false;
			particleRenderer.IgnoreNormalsForChartDetection_C26 = false;
			particleRenderer.ImportantGI_C26 = false;
			particleRenderer.StitchLightmapSeams_C26 = false;
			particleRenderer.SelectedEditorRenderState_C26 = (int)(EditorSelectedRenderState)3;
			particleRenderer.MinimumChartSize_C26 = 4;
			particleRenderer.AutoUVMaxDistance_C26 = 0.5f;
			particleRenderer.AutoUVMaxAngle_C26 = 89.0f;
			particleRenderer.LightmapParameters_C26?.SetValues(0, 0);
		}

		private static void ConvertToEditorFormat(IMeshRenderer meshRenderer)
		{
			meshRenderer.ScaleInLightmap_C23 = 1.0f;
			meshRenderer.ReceiveGI_C23 = (int)ReceiveGI.Lightmaps;
			meshRenderer.PreserveUVs_C23 = false;
			meshRenderer.IgnoreNormalsForChartDetection_C23 = false;
			meshRenderer.ImportantGI_C23 = false;
			meshRenderer.StitchLightmapSeams_C23 = false;
			meshRenderer.SelectedEditorRenderState_C23 = (int)(EditorSelectedRenderState)3;
			meshRenderer.MinimumChartSize_C23 = 4;
			meshRenderer.AutoUVMaxDistance_C23 = 0.5f;
			meshRenderer.AutoUVMaxAngle_C23 = 89.0f;
			meshRenderer.LightmapParameters_C23?.SetValues(0, 0);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Rigidbody2DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Rigidbody2D;
using AssetRipper.SourceGenerated.Classes.ClassID_50;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Rigidbody2DExtensions
	{
		public static RigidbodyType2D GetBodyType(this IRigidbody2D body)
		{
			if (body.Has_IsKinematic_C50())
			{
				return body.IsKinematic_C50 ? RigidbodyType2D.Kinematic : RigidbodyType2D.Static;
			}
			else
			{
				return (RigidbodyType2D)body.BodyType_C50;
			}
		}

		public static RigidbodyInterpolation2D GetInterpolate(this IRigidbody2D body)
		{
			if(body.Has_Interpolate_C50_Byte())
			{
				return (RigidbodyInterpolation2D)body.Interpolate_C50_Byte;
			}
			else
			{
				return (RigidbodyInterpolation2D)body.Interpolate_C50_Int32;
			}
		}

		public static RigidbodySleepMode2D GetSleepingMode(this IRigidbody2D body)
		{
			if (body.Has_SleepingMode_C50_Byte())
			{
				return (RigidbodySleepMode2D)body.SleepingMode_C50_Byte;
			}
			else
			{
				return (RigidbodySleepMode2D)body.SleepingMode_C50_Int32;
			}
		}

		public static CollisionDetectionMode2D GetCollisionDetection(this IRigidbody2D body)
		{
			if (body.Has_CollisionDetection_C50_Byte())
			{
				return (CollisionDetectionMode2D)body.CollisionDetection_C50_Byte;
			}
			else
			{
				return (CollisionDetectionMode2D)body.CollisionDetection_C50_Int32;
			}
		}

		public static RigidbodyConstraints2D GetConstraints(this IRigidbody2D body)
		{
			if (body.Has_FixedAngle_C50())
			{
				return body.FixedAngle_C50 ? RigidbodyConstraints2D.FreezeRotation : RigidbodyConstraints2D.None;
			}
			else
			{
				return (RigidbodyConstraints2D)body.Constraints_C50;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RigidbodyExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Rigidbody;
using AssetRipper.SourceGenerated.Classes.ClassID_54;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RigidbodyExtensions
	{
		public static RigidbodyInterpolation GetInterpolate(this IRigidbody body)
		{
			return (RigidbodyInterpolation)body.Interpolate_C54;
		}

		public static RigidbodyConstraints GetConstraints(this IRigidbody body)
		{
			if (body.Has_FreezeRotation_C54())
			{
				return body.FreezeRotation_C54 ? RigidbodyConstraints.FreezeRotation : RigidbodyConstraints.None;
			}
			else
			{
				return (RigidbodyConstraints)body.Constraints_C54;
			}
		}

		public static CollisionDetectionMode GetCollisionDetection(this IRigidbody body)
		{
			return (CollisionDetectionMode)body.CollisionDetection_C54;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/RuntimeAnimatorControllerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_221;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Classes.ClassID_93;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class RuntimeAnimatorControllerExtensions
	{
		public static bool IsContainsAnimationClip(this IRuntimeAnimatorController controller, IAnimationClip clip)
		{
			if (controller is IAnimatorController animatorController)
			{
				return animatorController.IsContainsAnimationClip(clip);
			}
			else if (controller is IAnimatorOverrideController overrideController)
			{
				return overrideController.IsContainsAnimationClip(clip);
			}
			else
			{
				throw new Exception($"{controller.GetType()} inherits from {nameof(IRuntimeAnimatorController)} but not {nameof(IAnimatorController)} or {nameof(IAnimatorOverrideController)}");
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedPassExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.SourceGenerated.Subclasses.SerializedPass;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedPassExtensions
	{
		public static SerializedPassType GetType_(this ISerializedPass pass)
		{
			return (SerializedPassType)pass.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedProgramExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedProgram;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedProgramExtensions
	{
		public static int GetTierCount(this ISerializedProgram program)
		{
			int tierCount = 1;
			int tier = program.SubPrograms[0].ShaderHardwareTier;
			for (int i = 1; i < program.SubPrograms.Count; i++)
			{
				if (program.SubPrograms[i].ShaderHardwareTier <= tier)
				{
					break;
				}

				tierCount++;
			}

			return tierCount;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedPropertyExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedPropertyExtensions
	{
		public static SerializedPropertyType GetType_(this ISerializedProperty property)
		{
			return (SerializedPropertyType)property.Type;
		}

		public static SerializedPropertyFlag GetFlags(this ISerializedProperty property)
		{
			return (SerializedPropertyFlag)property.Flags;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedShaderFloatValueExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderFloatValue;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedShaderFloatValueExtensions
	{
		public static bool IsZero(this ISerializedShaderFloatValue value) => value.Val == 0.0f;
		public static bool IsMax(this ISerializedShaderFloatValue value) => value.Val == 255.0f;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedShaderRTBlendStateExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderRTBlendState;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedShaderRTBlendStateExtensions
	{
		public static BlendMode SrcBlendValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.SrcBlend.Val;
		public static BlendMode DestBlendValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.DestBlend.Val;
		public static BlendMode SrcBlendAlphaValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.SrcBlendAlpha.Val;
		public static BlendMode DestBlendAlphaValue(this ISerializedShaderRTBlendState state) => (BlendMode)state.DestBlendAlpha.Val;
		public static BlendOp BlendOpValue(this ISerializedShaderRTBlendState state) => (BlendOp)state.BlendOp.Val;
		public static BlendOp BlendOpAlphaValue(this ISerializedShaderRTBlendState state) => (BlendOp)state.BlendOpAlpha.Val;
		public static ColorWriteMask ColMaskValue(this ISerializedShaderRTBlendState state) => (ColorWriteMask)state.ColMask.Val;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedShaderStateExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderState;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedShaderStateExtensions
	{
		public static FogMode FogModeValue(this ISerializedShaderState state) => (FogMode)state.FogMode;
		public static ZClip ZClipValue(this ISerializedShaderState state) => (ZClip)(state.ZClip?.Val ?? 0);
		public static ZTest ZTestValue(this ISerializedShaderState state) => (ZTest)state.ZTest.Val;
		public static ZWrite ZWriteValue(this ISerializedShaderState state) => (ZWrite)state.ZWrite.Val;
		public static CullMode CullingValue(this ISerializedShaderState state) => (CullMode)state.Culling.Val;
		public static bool AlphaToMaskValue(this ISerializedShaderState state) => state.AlphaToMask.Val > 0;
		public static string LightingValue(this ISerializedShaderState state) => state.Lighting ? "On" : "Off";
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedShaderVectorValueExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderVectorValue;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedShaderVectorValueExtensions
	{
		public static bool IsZero(this ISerializedShaderVectorValue value)
		{
			return value.X.IsZero() 
				&& value.Y.IsZero() 
				&& value.Z.IsZero() 
				&& value.W.IsZero();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedStencilOpExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.SourceGenerated.Subclasses.SerializedStencilOp;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedStencilOpExtensions
	{
		public static StencilOp PassValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.Pass.Val;
		public static StencilOp FailValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.Fail.Val;
		public static StencilOp ZFailValue(this ISerializedStencilOp stencilOp) => (StencilOp)stencilOp.ZFail.Val;
		public static StencilComp CompValue(this ISerializedStencilOp stencilOp) => (StencilComp)stencilOp.Comp.Val;
		public static bool IsDefault(this ISerializedStencilOp stencilOp)
		{
			return stencilOp.PassValue().IsKeep()
				&& stencilOp.FailValue().IsKeep()
				&& stencilOp.ZFailValue().IsKeep()
				&& stencilOp.CompValue().IsAlways();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SerializedSubProgramExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using AssetRipper.SourceGenerated.Subclasses.SerializedSubProgram;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SerializedSubProgramExtensions
	{
		public static ShaderGpuProgramType GetProgramType(this ISerializedSubProgram subProgram, UnityVersion version)
		{
			if (ShaderGpuProgramTypeExtensions.GpuProgramType55Relevant(version))
			{
				return ((ShaderGpuProgramType55)subProgram.GpuProgramType).ToGpuProgramType();
			}
			else
			{
				return ((ShaderGpuProgramType53)subProgram.GpuProgramType).ToGpuProgramType();
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ShaderBindChannelExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.SourceGenerated.Subclasses.ShaderBindChannel;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ShaderBindChannelExtensions
	{
		public static VertexComponent GetTarget(this IShaderBindChannel channel)
		{
			return (VertexComponent)channel.Target;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ShaderErrorExtensions.cs`:

```cs
using AssetRipper.Core.Parser.Files;
using AssetRipper.SourceGenerated.Subclasses.ShaderError;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ShaderErrorExtensions
	{
		public static BuildTarget GetCompilerPlatform(this IShaderError error)
		{
			return (BuildTarget)error.CompilerPlatform;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ShaderExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ShaderExtensions
	{
		public static IEnumerable<GPUPlatform>? GetPlatforms(this IShader shader)
		{
			return shader.Platforms_C48?.Select(p => unchecked((GPUPlatform)p));
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ShadowSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Light;
using AssetRipper.SourceGenerated.Subclasses.ShadowSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ShadowSettingsExtensions
	{
		public static LightShadows GetLightmapBakeType(this IShadowSettings settings)
		{
			return (LightShadows)settings.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ShapeModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.Shape;
using AssetRipper.SourceGenerated.Subclasses.ShapeModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ShapeModuleExtensions
	{
		public static ParticleSystemShapeType GetShapeType(this IShapeModule module)
		{
			return (ParticleSystemShapeType)module.Type;
		}

		public static PlacementMode GetPlacementMode(this IShapeModule module)
		{
			return (PlacementMode)module.PlacementMode;
		}

		private static ParticleSystemShapeType GetExportType(this IShapeModule module)
		{
			if (module.Has_RadiusThickness())
			{
				return module.GetShapeType();
			}
			return module.GetShapeType() switch
			{
				ParticleSystemShapeType.SphereShell => ParticleSystemShapeType.Sphere,
				ParticleSystemShapeType.HemisphereShell => ParticleSystemShapeType.Hemisphere,
				ParticleSystemShapeType.ConeShell => ParticleSystemShapeType.Cone,
				ParticleSystemShapeType.ConeVolumeShell => ParticleSystemShapeType.ConeVolume,
				ParticleSystemShapeType.CircleEdge => ParticleSystemShapeType.Circle,
				_ => module.GetShapeType(),
			};
		}
		
		private static float GetExportRadiusThickness(this IShapeModule module)
		{
			if (module.Has_RadiusThickness())
			{
				return module.RadiusThickness;
			}

			switch (module.GetShapeType())
			{
				case ParticleSystemShapeType.SphereShell:
				case ParticleSystemShapeType.HemisphereShell:
				case ParticleSystemShapeType.ConeShell:
				case ParticleSystemShapeType.ConeVolumeShell:
				case ParticleSystemShapeType.CircleEdge:
					return 0.0f;

				default:
					return 1.0f;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteAtlasDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Sprite;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteAtlasDataExtensions
	{
		public static bool IsPacked(this ISpriteAtlasData data) => (data.SettingsRaw & 1) != 0;
		public static SpritePackingMode GetPackingMode(this ISpriteAtlasData data) => (SpritePackingMode)((data.SettingsRaw >> 1) & 1);
		public static SpritePackingRotation GetPackingRotation(this ISpriteAtlasData data) => (SpritePackingRotation)((data.SettingsRaw >> 2) & 0xF);
		public static SpriteMeshType GetMeshType(this ISpriteAtlasData data) => (SpriteMeshType)((data.SettingsRaw >> 6) & 0x1);
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteAtlasEditorDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Sprite_;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasEditorData;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteAtlasEditorDataExtensions
	{
		public static void ConvertToEditorFormat(this ISpriteAtlasEditorData data, IReadOnlyList<PPtr_Sprite__5_0_0_f4> packedSprites)
		{
			data.TextureSettings.Initialize();
			data.PackingParameters?.Initialize();
			data.PackingSettings?.Initialize();
			data.VariantMultiplier = 1;
			data.BindAsDefault = true;

			data.Packables.Clear();
			data.Packables.Capacity = packedSprites.Count;
			foreach (PPtr_Sprite__5_0_0_f4 sprite in packedSprites)
			{
				data.Packables.AddNew().CopyValues(sprite);
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteAtlasExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteAtlasExtensions
	{
		public static void ConvertToEditorFormat(this ISpriteAtlas atlas)
		{
			atlas.EditorData_C687078895.ConvertToEditorFormat(atlas.PackedSprites_C687078895);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteBoneExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteBoneExtensions
	{
		public static void CopyValues(this ISpriteBone destination, ISpriteBone source)
		{
			if(destination.Has_Color() && source.Has_Color())
			{
				destination.Color.CopyValues(source.Color);
			}
			if(destination.Has_Guid() && source.Has_Guid())
			{
				destination.Guid.CopyValues(source.Guid);
			}
			destination.Length = source.Length;
			destination.Name_R.CopyValues(source.Name_R);
			destination.ParentId = source.ParentId;
			destination.Position.CopyValues(source.Position);
			destination.Rotation.CopyValues(source.Rotation);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Sprite;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.IO;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Subclasses.Rectf;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using AssetRipper.SourceGenerated.Subclasses.Vector4f;
using System.Buffers.Binary;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteExtensions
	{
		public static ISpriteMetaData GenerateSpriteMetaData(this ISprite sprite, IExportContainer container, ISpriteAtlas atlas)
		{
			sprite.GetSpriteCoordinatesInAtlas(atlas, out Rectf rect, out Vector2f_3_5_0_f5 pivot, out Vector4f_3_5_0_f5 border);

			ISpriteMetaData instance = SpriteMetaDataFactory.CreateAsset(container.ExportVersion);
			instance.NameString = sprite.NameString;
			instance.Rect.CopyValues(rect);
			instance.Alignment = (int)Classes.Meta.Importers.Texture.SpriteAlignment.Custom;
			instance.Pivot.CopyValues(pivot);
			instance.Border?.CopyValues(border);
			if (instance.Has_Outline())
			{
				sprite.GenerateOutline(container.Version, atlas, rect, pivot, instance.Outline);
			}
			if (instance.Has_PhysicsShape() && sprite.Has_PhysicsShape_C213())
			{
				sprite.GeneratePhysicsShape(atlas, rect, pivot, instance.PhysicsShape);
			}
			instance.TessellationDetail = 0;
			if (instance.Has_Bones() && sprite.Has_Bones_C213() && instance.Has_SpriteID())
			{
				// Scale bones based off of the sprite's PPU
				foreach (ISpriteBone bone in sprite.Bones_C213)
				{
					bone.Position.Scale(sprite.PixelsToUnits_C213);
					bone.Length *= sprite.PixelsToUnits_C213;

					// Set root bone position
					if (bone.ParentId == -1)
					{
						bone.Position.X += sprite.Rect_C213.Width / 2;
						bone.Position.Y += sprite.Rect_C213.Height / 2;
					}
				}

				instance.Bones.Clear();
				instance.Bones.Capacity = sprite.Bones_C213.Count;
				foreach (ISpriteBone bone in sprite.Bones_C213)
				{
					instance.Bones.AddNew().CopyValues(bone);
				}

				// NOTE: sprite ID is generated by sprite binary content, but we just generate a random value
				instance.SpriteID.String = Guid.NewGuid().ToString("N");

				instance.SetBoneGeometry(sprite);
			}
			return instance;
		}

		private static void SetBoneGeometry(this ISpriteMetaData instance, ISprite origin)
		{
			Vector3f[]? vertices = null;
			BoneWeights4[]? skin = null;

			origin.RD_C213.VertexData?.ReadData(origin.SerializedFile.Version, origin.SerializedFile.EndianType,
				out int _,
				out vertices,
				out Vector3f[]? _,//normals,
				out Vector4f[]? _,//tangents,
				out ColorRGBA32[]? _,//colors,
				out skin,
				out Vector2f[]? _,//uv0,
				out Vector2f[]? _,//uv1,
				out Vector2f[]? _,//uv2,
				out Vector2f[]? _,//uv3,
				out Vector2f[]? _,//uv4,
				out Vector2f[]? _,//uv5,
				out Vector2f[]? _,//uv6,
				out Vector2f[]? _);//uv7);

			if (instance.Has_Vertices())
			{
				instance.Vertices.Clear();

				// Convert Vector3f into Vector2f
				if (vertices is null)
				{
					instance.Vertices.Capacity = 0;
				}
				else
				{
					Vector2f_3_5_0_f5[] verts = new Vector2f_3_5_0_f5[vertices.Length];
					for (int i = 0; i < vertices.Length; i++)
					{
						verts[i] = new Vector2f_3_5_0_f5();

						verts[i].X = vertices[i].X;
						verts[i].Y = vertices[i].Y;

						// Scale and translate vertices properly
						verts[i].X *= origin.PixelsToUnits_C213;
						verts[i].Y *= origin.PixelsToUnits_C213;

						verts[i].X += origin.Rect_C213.Width / 2;
						verts[i].Y += origin.Rect_C213.Height / 2;
					}

					instance.Vertices.Capacity = verts.Length;
					instance.Vertices.AddRange(verts);
				}
			}

			if (!origin.RD_C213.Has_IndexBuffer() || origin.RD_C213.IndexBuffer.Length == 0)
			{
				instance.Indices = Array.Empty<int>();
			}
			else
			{
				instance.Indices = new int[origin.RD_C213.IndexBuffer.Length / 2];
				for (int i = 0, j = 0; i < origin.RD_C213.IndexBuffer.Length / 2; i++, j += 2)
				{
					instance.Indices[i] = BinaryPrimitives.ReadInt16LittleEndian(origin.RD_C213.IndexBuffer.AsSpan(j, 2));
				}
			}

#warning TODO: SpriteConverter does not generate instance.Edges

			if (instance.Has_Weights())
			{
				instance.Weights.Clear();
				if (skin is not null)
				{
					instance.Weights.EnsureCapacity(skin.Length);
					for (int i = 0; i < skin.Length; i++)
					{
						instance.Weights.Add((SourceGenerated.Subclasses.BoneWeights4.BoneWeights4_2017_1_0_b1)skin[i]);
					}
				}
			}
		}

		public static void GetSpriteCoordinatesInAtlas(this ISprite sprite, ISpriteAtlas? atlas, out Rectf sAtlasRect, out Vector2f_3_5_0_f5 sAtlasPivot, out Vector4f_3_5_0_f5 sAtlasBorder)
		{
			// sprite values are relative to original image (image, it was created from).
			// since atlas shuffle and crop sprite images, we need to recalculate those values.
			// if sprite doesn't belong to an atlas, consider its image as single sprite atlas

			Vector2f cropBotLeft;
			Vector2f cropTopRight;
			if (atlas is null || !sprite.Has_RenderDataKey_C213())
			{
				sAtlasRect = new();
				sAtlasRect.CopyValues(sprite.RD_C213.TextureRect);
				cropBotLeft = (Vector2f)sprite.RD_C213.TextureRectOffset;
			}
			else
			{
				ISpriteAtlasData atlasData = atlas.RenderDataMap_C687078895[sprite.RenderDataKey_C213];
				sAtlasRect = new();
				sAtlasRect.CopyValues(atlasData.TextureRect);
				cropBotLeft = (Vector2f)atlasData.TextureRectOffset;
			}

			Vector2f sizeDelta = sprite.Rect_C213.Size() - sAtlasRect.Size();
			cropTopRight = new Vector2f(sizeDelta.X - cropBotLeft.X, sizeDelta.Y - cropBotLeft.Y);

			Vector2f pivot;
			if (sprite.Has_Pivot_C213())
			{
				pivot = (Vector2f)sprite.Pivot_C213;
			}
			else
			{
				Vector2f center = new Vector2f(sprite.Rect_C213.Size().X / 2.0f, sprite.Rect_C213.Size().Y / 2.0f);
				Vector2f pivotOffset = center + (Vector2f)sprite.Offset_C213;
				pivot = new Vector2f(pivotOffset.X / sprite.Rect_C213.Size().X, pivotOffset.Y / sprite.Rect_C213.Size().Y);
			}

			Vector2f pivotPosition = new Vector2f(pivot.X * sprite.Rect_C213.Size().X, pivot.Y * sprite.Rect_C213.Size().Y);
			Vector2f aAtlasPivotPosition = pivotPosition - cropBotLeft;
			sAtlasPivot = new();
			sAtlasPivot.SetValues(aAtlasPivotPosition.X / sAtlasRect.Size().X, aAtlasPivotPosition.Y / sAtlasRect.Size().Y);
			
			sAtlasBorder = new();
			if (sprite.Has_Border_C213())
			{
				float borderL = sprite.Border_C213.X == 0.0f ? 0.0f : sprite.Border_C213.X - cropBotLeft.X;
				float borderB = sprite.Border_C213.Y == 0.0f ? 0.0f : sprite.Border_C213.Y - cropBotLeft.Y;
				float borderR = sprite.Border_C213.Z == 0.0f ? 0.0f : sprite.Border_C213.Z - cropTopRight.X;
				float borderT = sprite.Border_C213.W == 0.0f ? 0.0f : sprite.Border_C213.W - cropTopRight.Y;
				sAtlasBorder.SetValues(borderL, borderB, borderR, borderT);
			}
		}

		public static void GenerateOutline(
			this ISprite sprite, 
			UnityVersion version, 
			ISpriteAtlas atlas, 
			Rectf rect, 
			Vector2f_3_5_0_f5 pivot,
			AssetList<AssetList<Vector2f_3_5_0_f5>> outlines)
		{
			sprite.RD_C213.GenerateOutline(version, outlines);
			float pivotShiftX = rect.Width * pivot.X - rect.Width * 0.5f;
			float pivotShiftY = rect.Height * pivot.Y - rect.Height * 0.5f;
			Vector2f pivotShift = new Vector2f(pivotShiftX, pivotShiftY);
			foreach (AssetList<Vector2f_3_5_0_f5> outline in outlines)
			{
				for (int i = 0; i < outline.Count; i++)
				{
					Vector2f point = (Vector2f)outline[i] * sprite.PixelsToUnits_C213;
					outline[i] = (Vector2f_3_5_0_f5)(point + pivotShift);
				}
			}
			sprite.FixRotation(atlas, outlines);
		}

		public static void GeneratePhysicsShape(
			this ISprite sprite, 
			ISpriteAtlas atlas, 
			Rectf rect, 
			Vector2f_3_5_0_f5 pivot, 
			AssetList<AssetList<Vector2f_3_5_0_f5>> shape)
		{
			if (sprite.Has_PhysicsShape_C213() && sprite.PhysicsShape_C213.Count > 0)
			{
				shape.Clear();
				shape.Capacity = sprite.PhysicsShape_C213.Count;
				float pivotShiftX = rect.Width * pivot.X - rect.Width * 0.5f;
				float pivotShiftY = rect.Height * pivot.Y - rect.Height * 0.5f;
				Vector2f pivotShift = new Vector2f(pivotShiftX, pivotShiftY);
				for (int i = 0; i < sprite.PhysicsShape_C213.Count; i++)
				{
					shape.Add(new AssetList<Vector2f_3_5_0_f5>(sprite.PhysicsShape_C213[i].Count));
					for (int j = 0; j < sprite.PhysicsShape_C213[i].Count; j++)
					{
						Vector2f point = (Vector2f)sprite.PhysicsShape_C213[i][j] * sprite.PixelsToUnits_C213;
						shape[i].Add((Vector2f_3_5_0_f5)(point + pivotShift));
					}
				}
				sprite.FixRotation(atlas, shape);
			}
		}

		private static void FixRotation(this ISprite sprite, ISpriteAtlas atlas, AssetList<AssetList<Vector2f_3_5_0_f5>> outlines)
		{
			bool isPacked = sprite.RD_C213.IsPacked();
			SpritePackingRotation rotation = sprite.RD_C213.GetPackingRotation();
			if (atlas is not null && sprite.Has_RenderDataKey_C213())
			{
				ISpriteAtlasData atlasData = atlas.RenderDataMap_C687078895[sprite.RenderDataKey_C213];
				isPacked = atlasData.IsPacked();
				rotation = atlasData.GetPackingRotation();
			}

			if (isPacked)
			{
				switch (rotation)
				{
					case SpritePackingRotation.FlipHorizontal:
						{
							foreach (AssetList<Vector2f_3_5_0_f5> outline in outlines)
							{
								for (int i = 0; i < outline.Count; i++)
								{
									Vector2f_3_5_0_f5 vertex = outline[i];
									outline[i].SetValues(-vertex.X, vertex.Y);
								}
							}
						}
						break;

					case SpritePackingRotation.FlipVertical:
						{
							foreach (AssetList<Vector2f_3_5_0_f5> outline in outlines)
							{
								for (int i = 0; i < outline.Count; i++)
								{
									Vector2f_3_5_0_f5 vertex = outline[i];
									outline[i].SetValues(vertex.X, -vertex.Y);
								}
							}
						}
						break;

					case SpritePackingRotation.Rotate90:
						{
							foreach (AssetList<Vector2f_3_5_0_f5> outline in outlines)
							{
								for (int i = 0; i < outline.Count; i++)
								{
									Vector2f_3_5_0_f5 vertex = outline[i];
									outline[i].SetValues(vertex.Y, vertex.X);
								}
							}
						}
						break;

					case SpritePackingRotation.Rotate180:
						{
							foreach (AssetList<Vector2f_3_5_0_f5> outline in outlines)
							{
								for (int i = 0; i < outline.Count; i++)
								{
									Vector2f_3_5_0_f5 vertex = outline[i];
									outline[i].SetValues(-vertex.X, -vertex.Y);
								}
							}
						}
						break;
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteMaskExtensions.cs`:

```cs
using AssetRipper.Core.Classes.SpriteRenderer;
using AssetRipper.SourceGenerated.Classes.ClassID_331;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteMaskExtensions
	{
		public static SpriteSortPoint GetSpriteSortPoint(this ISpriteMask mask)
		{
			return (SpriteSortPoint)mask.SpriteSortPoint_C331;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteMetaDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteMetaDataExtensions
	{
		public static SpriteAlignment GetAlignment(this ISpriteMetaData data)
		{
			return (SpriteAlignment)data.Alignment;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteRenderDataExtensions.cs`:

```cs
using System.Collections.Generic;
using SpritePackingMode = AssetRipper.Core.Classes.Sprite.SpritePackingMode;
using SpritePackingRotation = AssetRipper.Core.Classes.Sprite.SpritePackingRotation;
using SpriteMeshType = AssetRipper.Core.Classes.Sprite.SpriteMeshType;
using AssetRipper.SourceGenerated.Subclasses.SpriteRenderData;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using AssetRipper.Core.IO;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteRenderDataExtensions
	{
		//Notes:
		//
		// TextureRect:
		// Actual sprite rectangle inside atlas texture (or in original texture for non atlas sprite)
		// It is a retangle of cropped image if tight mode is used. Otherwise, its size matches the original size
		//
		// TextureRectOffset:
		// Offset of actual (cropped) sprite rectangle relative to Sprite.Rect .
		// Unity crops rectangle to save atlas space if tight mode is used. So final atlas image is a cropped version
		// of a rectangle, developer specified in original texture.
		// In other words, this value show how much Unity cropped the Sprite.Rect from bottom-left corner

		public static bool IsPacked(this ISpriteRenderData spriteRenderData) => (spriteRenderData.SettingsRaw & 1) != 0;

		public static SpritePackingMode GetPackingMode(this ISpriteRenderData spriteRenderData)
		{
			return (SpritePackingMode)((spriteRenderData.SettingsRaw >> 1) & 1);
		}

		public static SpritePackingRotation GetPackingRotation(this ISpriteRenderData spriteRenderData)
		{
			return (SpritePackingRotation)((spriteRenderData.SettingsRaw >> 2) & 0xF);
		}

		public static SpriteMeshType GetMeshType(this ISpriteRenderData spriteRenderData)
		{
			return (SpriteMeshType)((spriteRenderData.SettingsRaw >> 6) & 0x1);
		}

		public static void GenerateOutline(this ISpriteRenderData spriteRenderData, UnityVersion version, AssetList<AssetList<Vector2f_3_5_0_f5>> outlines)
		{
			outlines.Clear();
			if (spriteRenderData.Has_VertexData() && spriteRenderData.SubMeshes!.Count != 0)
			{
				for (int i = 0; i < spriteRenderData.SubMeshes.Count; i++)
				{
					Vector3f_3_5_0_f5[] vertices = spriteRenderData.VertexData.GenerateVertices(version, spriteRenderData.SubMeshes[i]);
					List<Vector2f[]> vectorArrayList = spriteRenderData.VertexDataToOutline(vertices, spriteRenderData.SubMeshes[i]);
					outlines.AddRanges(vectorArrayList);
				}
			}
			else if (spriteRenderData.Has_Vertices() && spriteRenderData.Vertices.Count != 0)
			{
				List<Vector2f[]> vectorArrayList = spriteRenderData.VerticesToOutline();
				outlines.Capacity = vectorArrayList.Count;
				outlines.AddRanges(vectorArrayList);
			}
		}

		private static List<Vector2f[]> VerticesToOutline(this ISpriteRenderData spriteRenderData)
		{
			Vector3f_3_5_0_f5[] vertices = new Vector3f_3_5_0_f5[spriteRenderData.Vertices.Count];
			for (int i = 0; i < vertices.Length; i++)
			{
				vertices[i] = spriteRenderData.Vertices[i].Pos;
			}

			Vector3i[] triangles = new Vector3i[spriteRenderData.Indices.Length / 3];
			for (int i = 0, j = 0; i < triangles.Length; i++)
			{
				int x = spriteRenderData.Indices[j++];
				int y = spriteRenderData.Indices[j++];
				int z = spriteRenderData.Indices[j++];
				triangles[i] = new Vector3i(x, y, z);
			}

			MeshOutlineGenerator outlineGenerator = new MeshOutlineGenerator(vertices, triangles);
			return outlineGenerator.GenerateOutlines();
		}

		private static List<Vector2f[]> VertexDataToOutline(this ISpriteRenderData spriteRenderData, Vector3f_3_5_0_f5[] vertices, ISubMesh submesh)
		{
			Vector3i[] triangles = new Vector3i[submesh.IndexCount / 3];
			for (int o = (int)submesh.FirstByte, ti = 0; ti < triangles.Length; o += 6, ti++)
			{
				int x = BitConverter.ToUInt16(spriteRenderData.IndexBuffer, o + 0);
				int y = BitConverter.ToUInt16(spriteRenderData.IndexBuffer, o + 2);
				int z = BitConverter.ToUInt16(spriteRenderData.IndexBuffer, o + 4);
				triangles[ti] = new Vector3i(x, y, z);
			}
			MeshOutlineGenerator outlineGenerator = new MeshOutlineGenerator(vertices, triangles);
			return outlineGenerator.GenerateOutlines();
		}

		private static void AddRanges(this AssetList<AssetList<Vector2f_3_5_0_f5>> instance, List<Vector2f[]> vectorArrayList)
		{
			foreach (Vector2f[] vectorArray in vectorArrayList)
			{
				AssetList<Vector2f_3_5_0_f5> assetList = new AssetList<Vector2f_3_5_0_f5>(vectorArray.Length);
				instance.Add(assetList);
				foreach (Vector2f v in vectorArray)
				{
					assetList.Add((Vector2f_3_5_0_f5)v);
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteRendererExtensions.cs`:

```cs
using AssetRipper.Core.Classes.SpriteRenderer;
using AssetRipper.SourceGenerated.Classes.ClassID_212;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteRendererExtensions
	{
		public static SpriteDrawMode GetDrawMode(this ISpriteRenderer renderer)
		{
			return (SpriteDrawMode)renderer.DrawMode_C212;
		}

		public static void SetDrawMode(this ISpriteRenderer renderer, SpriteDrawMode drawMode)
		{
			renderer.DrawMode_C212 = (int)drawMode;
		}

		public static SpriteTileMode GetTileMode(this ISpriteRenderer renderer)
		{
			return (SpriteTileMode)renderer.SpriteTileMode_C212;
		}

		public static void SetTileMode(this ISpriteRenderer renderer, SpriteTileMode tileMode)
		{
			renderer.SpriteTileMode_C212 = (int)tileMode;
		}

		public static SpriteMaskInteraction GetMaskInteraction(this ISpriteRenderer renderer)
		{
			return (SpriteMaskInteraction)renderer.MaskInteraction_C212;
		}

		public static void SetMaskInteraction(this ISpriteRenderer renderer, SpriteMaskInteraction maskInteraction)
		{
			renderer.MaskInteraction_C212 = (int)maskInteraction;
		}

		public static SpriteSortPoint GetSpriteSortPoint(this ISpriteRenderer renderer)
		{
			return (SpriteSortPoint)renderer.SpriteSortPoint_C212;
		}

		public static void SetSpriteSortPoint(this ISpriteRenderer renderer, SpriteSortPoint spriteSortPoint)
		{
			renderer.SpriteSortPoint_C212 = (int)spriteSortPoint;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SpriteSheetMetaDataExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.BoneWeights4;
using AssetRipper.SourceGenerated.Subclasses.SpriteBone;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using AssetRipper.SourceGenerated.Subclasses.SpriteSheetMetaData;
using AssetRipper.SourceGenerated.Subclasses.Vector2f;
using AssetRipper.SourceGenerated.Subclasses.Vector2Int;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SpriteSheetMetaDataExtensions
	{
		public static ISpriteMetaData GetSpriteMetaData(this ISpriteSheetMetaData data, string name)
		{
			for (int i = 0; i < data.Sprites.Count; i++)
			{
				if (data.Sprites[i].Name == name)
				{
					return data.Sprites[i];
				}
			}
			throw new ArgumentException($"There is no sprite metadata with name {name}", nameof(name));
		}

		public static void CopyFromSpriteMetaData(this ISpriteSheetMetaData instance, ISpriteMetaData spriteMetaData)
		{
			if (instance.Has_Outline() && spriteMetaData.Has_Outline())
			{
				instance.Outline.Clear();
				instance.Outline.AddRange(spriteMetaData.Outline);
			}
			if (instance.Has_PhysicsShape() && spriteMetaData.Has_PhysicsShape())
			{
				instance.PhysicsShape.Clear();
				instance.PhysicsShape.AddRange(spriteMetaData.PhysicsShape);
			}
			if (instance.Has_Bones() && spriteMetaData.Has_Bones())
			{
				instance.Bones.Clear();
				instance.Bones.Capacity = spriteMetaData.Bones.Count;
				foreach(ISpriteBone bone in spriteMetaData.Bones)
				{
					instance.Bones.AddNew().CopyValues(bone);
				}
			}
			if (instance.Has_SpriteID() && spriteMetaData.Has_SpriteID())
			{
				instance.SpriteID.CopyValues(instance.SpriteID);
			}
			if (instance.Has_Vertices() && spriteMetaData.Has_Vertices())
			{
				instance.Vertices.Clear();
				instance.Vertices.Capacity = spriteMetaData.Vertices.Count;
				foreach (Vector2f_3_5_0_f5 vertex in spriteMetaData.Vertices)
				{
					instance.Vertices.AddNew().CopyValues(vertex);
				}
			}
			if (instance.Has_Indices() && spriteMetaData.Has_Indices())
			{
				instance.Indices = spriteMetaData.Indices.ToArray();
			}
			if (instance.Has_Edges() && spriteMetaData.Has_Edges())
			{
				instance.Edges.Clear();
				instance.Edges.Capacity = spriteMetaData.Edges.Count;
				foreach (Vector2Int edge in spriteMetaData.Edges)
				{
					instance.Edges.AddNew().CopyValues(edge);
				}
			}
			if (instance.Has_Weights() && spriteMetaData.Has_Weights())
			{
				instance.Weights.Clear();
				instance.Weights.Capacity = spriteMetaData.Weights.Count;
				foreach (IBoneWeights4 weight in spriteMetaData.Weights)
				{
					instance.Weights.AddNew().CopyValues(weight);
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StateBehavioursPairExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Subclasses.StateBehavioursPair;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StateBehavioursPairExtensions
	{
		public static void SetValues(this IStateBehavioursPair pair, IAnimatorState state, IMonoBehaviour[] behaviours)
		{
			if (state == null)
			{
				throw new ArgumentNullException(nameof(state));
			}
			if (behaviours == null || behaviours.Length == 0)
			{
				throw new ArgumentNullException(nameof(behaviours));
			}

			pair.State.CopyValues(state.SerializedFile.CreatePPtr(state));

			pair.StateMachineBehaviours.Clear();
			pair.StateMachineBehaviours.Capacity = behaviours.Length;
			for (int i = 0; i < behaviours.Length; i++)
			{
				IMonoBehaviour behaviour = behaviours[i];
				pair.StateMachineBehaviours.AddNew().CopyValues(behaviour.SerializedFile.CreatePPtr(behaviour));
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StateConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeConstant;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using AssetRipper.SourceGenerated.Subclasses.LeafInfoConstant;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StateConstantExtensions
	{
		public static PPtr<Motion> CreateMotion(this IStateConstant stateConstant, VirtualSerializedFile file, IAnimatorController controller, int nodeIndex)
		{
			if (stateConstant.BlendTreeConstantArray.Count == 0)
			{
				return new();
			}
			else
			{
				IBlendTreeNodeConstant node = stateConstant.GetBlendTree().NodeArray[nodeIndex].Data;
				if (node.IsBlendTree())
				{
					IBlendTree blendTree = VirtualAnimationFactory.CreateBlendTree(file, controller, stateConstant, nodeIndex);
					return blendTree.SerializedFile.CreatePPtr(blendTree).CastTo<Motion>();
				}
				else
				{
					int clipIndex = -1;
					if (stateConstant.Has_LeafInfoArray())
					{
						for (int i = 0; i < stateConstant.LeafInfoArray.Count; i++)
						{
							LeafInfoConstant leafInfo = stateConstant.LeafInfoArray[i];
							int index = leafInfo.m_IDArray.IndexOf(node.ClipID);
							if (index >= 0)
							{
								clipIndex = (int)leafInfo.m_IndexOffset + index;
								break;
							}
						}
					}
					else
					{
						clipIndex = unchecked((int)node.ClipID);
					}
					return node.CreateMotion(controller, clipIndex).CastTo<Motion>();
				}
			}
		}

		public static bool IsBlendTree(this IStateConstant stateConstant)
		{
			if (stateConstant.BlendTreeConstantArray.Count == 0)
			{
				return false;
			}
			return stateConstant.GetBlendTree().NodeArray.Count > 1;
		}

		public static IBlendTreeConstant GetBlendTree(this IStateConstant stateConstant)
		{
			return stateConstant.BlendTreeConstantArray[0].Data;
		}

		public static bool GetWriteDefaultValues(this IStateConstant stateConstant)
		{
			return !stateConstant.Has_WriteDefaultValues() || stateConstant.WriteDefaultValues;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StateMotionPairExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Subclasses.StateMotionPair;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StateMotionPairExtensions
	{
		public static void SetValues(this IStateMotionPair pair, IAnimatorState state, IMotion motion)
		{
			if (state == null)
			{
				throw new ArgumentNullException(nameof(state));
			}
			if (motion == null)
			{
				throw new ArgumentNullException(nameof(motion));
			}
			pair.State.CopyValues(state.SerializedFile.CreatePPtr(state));
			pair.Motion.CopyValues(motion.SerializedFile.CreatePPtr(motion));
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StaticBatchInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.StaticBatchInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StaticBatchInfoExtensions
	{
		public static void Initialize(this IStaticBatchInfo staticBatchInfo, uint[] subsetIndices)
		{
			if (subsetIndices.Length == 0)
			{
				staticBatchInfo.FirstSubMesh = 0;
				staticBatchInfo.SubMeshCount = 0;
			}
			else
			{
				staticBatchInfo.FirstSubMesh = (ushort)subsetIndices[0];
				staticBatchInfo.SubMeshCount = (ushort)subsetIndices.Length;
				for (int i = 0, j = staticBatchInfo.FirstSubMesh; i < staticBatchInfo.SubMeshCount; i++, j++)
				{
					if (subsetIndices[i] != j)
					{
						throw new Exception("Can't create static batch info from subset indices");
					}
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StreamInfoExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.StreamInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StreamInfoExtensions
	{
		public static uint GetStride(this IStreamInfo streamInfo)
		{
			return streamInfo.Has_Stride_UInt32() ? streamInfo.Stride_UInt32 : streamInfo.Stride_Byte;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StreamedClipExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.StreamedClip;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StreamedClipExtensions
	{
		public static bool IsSet(this IStreamedClip clip) => clip.Data.Length > 0;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StreamedResourceExtensions.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Subclasses.StreamedResource;
using System.Diagnostics.CodeAnalysis;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StreamedResourceExtensions
	{
		public static bool CheckIntegrity(this IStreamedResource streamedResource, ISerializedFile file)
		{
			if (!streamedResource.IsSet())
			{
				return true;
			}
			if (streamedResource.Size == 0)
			{
				// I think they read data by its type for this verison, so I can't even export raw data :/
				return false;
			}

			return file.Collection.FindResourceFile(streamedResource.Source?.String) != null;
		}

		public static byte[]? GetContent(this IStreamedResource streamedResource, ISerializedFile file)
		{
			IResourceFile? res = file.Collection.FindResourceFile(streamedResource.Source?.String);
			if (res == null)
			{
				return null;
			}
			if (streamedResource.Size == 0)
			{
				return null;
			}

			byte[] data = new byte[streamedResource.Size];
			res.Stream.Position = (long)streamedResource.Offset;
			res.Stream.ReadBuffer(data, 0, data.Length);
			return data;
		}

		public static bool TryGetContent(this IStreamedResource streamedResource, ISerializedFile file, [NotNullWhen(true)] out byte[]? data)
		{
			data = streamedResource.GetContent(file);
			return !data.IsNullOrEmpty();
		}

		public static bool IsSet(this IStreamedResource streamedResource) => !string.IsNullOrEmpty(streamedResource.Source?.String);
	}
}

```

`AssetRipperCommon/SourceGenExtensions/StreamingInfoExtensions.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Subclasses.StreamingInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class StreamingInfoExtensions
	{
		public static bool IsSet(this IStreamingInfo streamingInfo) => !streamingInfo.Path.Data.IsNullOrEmpty();

		public static bool CheckIntegrity(this IStreamingInfo streamingInfo, ISerializedFile file)
		{
			if (!streamingInfo.IsSet())
			{
				return true;
			}
			return file.Collection.FindResourceFile(streamingInfo.Path.String) != null;
		}

		public static byte[] GetContent(this IStreamingInfo streamingInfo, ISerializedFile file)
		{
			IResourceFile? res = file.Collection.FindResourceFile(streamingInfo.Path.String);
			if (res == null)
			{
				return Array.Empty<byte>();
			}

			byte[] data = new byte[streamingInfo.Size];
			res.Stream.Position = (long)streamingInfo.GetOffset();
			res.Stream.ReadBuffer(data, 0, data.Length);
			return data;
		}

		public static ulong GetOffset(this IStreamingInfo streamingInfo)
		{
			return streamingInfo.Has_Offset_UInt64() ? streamingInfo.Offset_UInt64 : streamingInfo.Offset_UInt32;
		}

		public static void SetOffset(this IStreamingInfo streamingInfo, ulong value)
		{
			if (streamingInfo.Has_Offset_UInt64())
			{
				streamingInfo.Offset_UInt64 = value;
			}
			else
			{
				streamingInfo.Offset_UInt32 = (uint)value;
			}
		}

		public static void CopyValues(this IStreamingInfo destination, IStreamingInfo source)
		{
			destination.SetOffset(source.GetOffset());
			destination.Size = source.Size;
			destination.Path.String = source.Path.String;
		}

		public static void ClearValues(this IStreamingInfo streamingInfo)
		{
			streamingInfo.Offset_UInt32 = default;
			streamingInfo.Offset_UInt64 = default;
			streamingInfo.Path.Data = Array.Empty<byte>();
			streamingInfo.Size = default;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SubEmitterDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.ParticleSystem.SubEmitter;
using AssetRipper.SourceGenerated.Classes.ClassID_198;
using AssetRipper.SourceGenerated.Subclasses.SubEmitterData;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SubEmitterDataExtensions
	{
		public static void SetValues(this ISubEmitterData data, ParticleSystemSubEmitterType type, IPPtr<IParticleSystem> emitter)
		{
			data.Emitter.CopyValues(emitter);
			data.Type = (int)type;
			data.Properties = (int)ParticleSystemSubEmitterProperties.InheritNothing;
			data.EmitProbability = 1.0f;
		}

		public static ParticleSystemSubEmitterType GetSubEmitterType(this ISubEmitterData data)
		{
			return (ParticleSystemSubEmitterType)data.Type;
		}

		public static ParticleSystemSubEmitterProperties GetProperties(this ISubEmitterData data)
		{
			return (ParticleSystemSubEmitterProperties)data.Properties;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/SubMeshExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class SubMeshExtensions
	{
		/// <summary>
		/// For versions &lt; 4, IsTriStrip is used here instead.<br/>
		/// For it, 0 cooresponds to <see cref="MeshTopology.Triangles"/>,<br/>
		/// and 1 cooresponds to <see cref="MeshTopology.TriangleStrip"/>.<br/>
		/// This conveniently matches the <see cref="MeshTopology"/> enumeration.
		/// </summary>
		public static MeshTopology GetTopology(this ISubMesh subMesh)
		{
			if (subMesh.Has_Topology())
			{
				return (MeshTopology)subMesh.Topology;
			}
			else
			{
				return (MeshTopology)subMesh.IsTriStrip;
			}
		}

		/*
		/// <summary>
		/// Offset in index buffer
		/// </summary>
		uint FirstByte { get; set; }
		/// <summary>
		/// Offset in Vertices
		/// </summary>
		uint FirstVertex { get; set; }
		 */
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TagManagerExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_78;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TagManagerExtensions
	{
		/// <summary>
		/// 5.0.0 to 5.5.0 exclusive
		/// </summary>
		public static bool IsBrokenCustomTags(UnityVersion version) => version.IsGreaterEqual(5) && version.IsLess(5, 5);

		/// <summary>
		/// 5.0.0 to 5.5.0 exclusive
		/// </summary>
		public static bool IsBrokenCustomTags(this ITagManager tagManager) => IsBrokenCustomTags(tagManager.SerializedFile.Version);
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TerrainExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Renderer;
using AssetRipper.Core.Classes.Terrain;
using AssetRipper.SourceGenerated.Classes.ClassID_218;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TerrainExtensions
	{
		public static void ConvertToEditorFormat(this ITerrain terrain)
		{
			terrain.ScaleInLightmap_C218 = 0.0512f;
		}

		public static ShadowCastingMode GetShadowCastingMode(this ITerrain terrain)
		{
			if (terrain.Has_ShadowCastingMode_C218())
			{
				return (ShadowCastingMode)terrain.ShadowCastingMode_C218;
			}
			else
			{
				return terrain.CastShadows_C218 ? ShadowCastingMode.TwoSided : ShadowCastingMode.Off;
			}
		}

		public static bool GetCastShadows(this ITerrain terrain)
		{
			if (terrain.Has_CastShadows_C218())
			{
				return terrain.CastShadows_C218;
			}
			else
			{
				return terrain.ShadowCastingMode_C218 != (int)ShadowCastingMode.Off;
			}
		}

		public static MaterialType GetMaterialType(this ITerrain terrain)
		{
			//if (ToSerializedVersion(version) > 2)
			//{
			//	return MaterialType;
			//}
			//return MaterialType == MaterialType.BuiltInStandard ? MaterialType.BuiltInLegacyDiffuse : MaterialType.Custom;
			return (MaterialType)terrain.MaterialType_C218;
		}

		public static ReflectionProbeUsage GetReflectionProbeUsage(this ITerrain terrain)
		{
			return (ReflectionProbeUsage)terrain.ReflectionProbeUsage_C218;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TextMeshExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Font;
using AssetRipper.Core.Classes.GUIText;
using AssetRipper.SourceGenerated.Classes.ClassID_102;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TextMeshExtensions
	{
		public static TextAnchor GetAnchor(this ITextMesh textMesh)
		{
			return (TextAnchor)textMesh.Anchor_C102;
		}
		public static TextAlignment GetAlignment(this ITextMesh textMesh)
		{
			return (TextAlignment)textMesh.Alignment_C102;
		}
		public static FontStyle GetFontStyle(this ITextMesh textMesh)
		{
			return (FontStyle)textMesh.FontStyle_C102;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Texture2DArrayExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Classes.Texture2DArray;
using AssetRipper.SourceGenerated.Classes.ClassID_187;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Texture2DArrayExtensions
	{
		public static byte[] GetImageData(this ITexture2DArray texture)
		{
			if (texture.ImageData_C187.Length > 0)
			{
				return texture.ImageData_C187;
			}
			else if (texture.Has_StreamData_C187() && texture.StreamData_C187.IsSet())
			{
				return texture.StreamData_C187.GetContent(texture.SerializedFile);
			}
			else
			{
				return Array.Empty<byte>();
			}
		}

		public static bool CheckAssetIntegrity(this ITexture2DArray texture)
		{
			if (texture.ImageData_C187.Length > 0)
			{
				return true;
			}
			else if (texture.Has_StreamData_C187())
			{
				return texture.StreamData_C187.CheckIntegrity(texture.SerializedFile);
			}
			else
			{
				return false;
			}
		}

		public static ColorSpace GetColorSpace(this ITexture2DArray texture)
		{
			return (ColorSpace)texture.ColorSpace_C187;
		}

		public static GraphicsFormat GetFormat(this ITexture2DArray texture)
		{
			return (GraphicsFormat)texture.Format_C187;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Texture2DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Texture2DExtensions
	{
		public static long GetCompleteImageSize(this SourceGenerated.Classes.ClassID_28.ITexture2D texture)
		{
			return System.Math.Max(texture.CompleteImageSize_C28_Int32, texture.CompleteImageSize_C28_UInt32);
		}

		public static bool CheckAssetIntegrity(this SourceGenerated.Classes.ClassID_28.ITexture2D texture)
		{
			if (!texture.ImageData_C28.IsNullOrEmpty())
			{
				return true;
			}
			else if (texture.StreamData_C28 is not null)
			{
				return texture.StreamData_C28.CheckIntegrity(texture.SerializedFile);
			}
			else
			{
				return false;
			}
		}

		public static byte[] GetImageData(this SourceGenerated.Classes.ClassID_28.ITexture2D texture)
		{
			byte[] data = texture.ImageData_C28;

			if (!data.IsNullOrEmpty())
			{
				return texture.ImageData_C28;
			}
			else if (texture.StreamData_C28 is not null && texture.StreamData_C28.IsSet())
			{
				data = texture.StreamData_C28.GetContent(texture.SerializedFile);
			}

			data ??= Array.Empty<byte>();

			if (IsSwapBytes(texture.SerializedFile.Platform, (TextureFormat)texture.TextureFormat_C28))
			{
				for (int i = 0; i < data.Length; i += 2)
				{
					(data[i], data[i + 1]) = (data[i + 1], data[i]);
				}
			}

			return data;
		}

		public static bool IsSwapBytes(BuildTarget platform, TextureFormat format)
		{
			if (platform == BuildTarget.XBox360)
			{
				switch (format)
				{
					case TextureFormat.ARGB4444:
					case TextureFormat.RGB565:
					case TextureFormat.DXT1:
					case TextureFormat.DXT1Crunched:
					case TextureFormat.DXT3:
					case TextureFormat.DXT5:
					case TextureFormat.DXT5Crunched:
						return true;
				}
			}
			return false;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Texture3DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.SourceGenerated.Classes.ClassID_117;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Texture3DExtensions
	{
		public static byte[] GetImageData(this ITexture3D texture)
		{
			if (texture.ImageData_C117.Length > 0)
			{
				return texture.ImageData_C117;
			}
			else if (texture.Has_StreamData_C117() && texture.StreamData_C117.IsSet())
			{
				return texture.StreamData_C117.GetContent(texture.SerializedFile);
			}
			else
			{
				return Array.Empty<byte>();
			}
		}

		public static ColorSpace GetColorSpace(this ITexture3D texture)
		{
			return (ColorSpace)texture.ColorSpace_C117;
		}

		public static TextureFormat GetTextureFormat(this ITexture3D texture)
		{
			if (texture.Has_Format_C117_Int32())
			{
				return (TextureFormat)texture.Format_C117_Int32;
			}
			else if (texture.Has_Format_C117_UInt32())
			{
				return (TextureFormat)texture.Format_C117_UInt32;
			}
			else
			{
				return (TextureFormat)texture.TextureFormat_C117;
			}
		}

		public static TextureDimension GetTextureDimension(this ITexture3D texture)
		{
			return (TextureDimension)texture.TextureDimension_C117;
		}

		public static TextureUsageMode GetLightmapFormat(this ITexture3D texture)
		{
			return (TextureUsageMode)texture.LightmapFormat_C117;
		}

		public static int GetCompleteImageSize(this ITexture3D texture)
		{
			if (texture.Has_DataSize_C117())
			{
				return (int)texture.DataSize_C117;
			}
			else
			{
				return texture.CompleteImageSize_C117;
			}
		}

		public static int GetMipCount(this ITexture3D texture)
		{
			if (texture.Has_MipCount_C117())
			{
				return texture.MipCount_C117;
			}
			else
			{
				if (texture.MipMap_C117)
				{
					int maxSide = System.Math.Max(texture.Width_C117, texture.Height_C117);
					return Convert.ToInt32(System.Math.Log(maxSide) / System.Math.Log(2));
				}
				else
				{
					return 1;
				}
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TextureImporterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.Sprite;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TextureImporterExtensions
	{
		public static TextureImporterMipFilter GetTextureCompression(this ITextureImporter importer)
		{
			return (TextureImporterMipFilter)importer.MipMaps_C1006.MipMapMode;
		}

		public static TextureImporterNormalFilter GetNormalMapFilter(this ITextureImporter importer)
		{
			return (TextureImporterNormalFilter)importer.BumpMap_C1006.NormalMapFilter;
		}

		public static TextureImporterGenerateCubemap GetGenerateCubemap(this ITextureImporter importer)
		{
			return (TextureImporterGenerateCubemap)importer.GenerateCubemap_C1006;
		}

		public static TextureFormat GetTextureFormat(this ITextureImporter importer)
		{
			return (TextureFormat)importer.TextureFormat_C1006;
		}

		public static TextureImporterNPOTScale GetNPOTScale(this ITextureImporter importer)
		{
			return (TextureImporterNPOTScale)importer.NPOTScale_C1006;
		}

		public static SpriteImportMode GetSpriteMode(this ITextureImporter importer)
		{
			return (SpriteImportMode)importer.SpriteMode_C1006;
		}

		public static SpriteMeshType GetSpriteMeshType(this ITextureImporter importer)
		{
			return (SpriteMeshType)importer.SpriteMeshType_C1006;
		}

		public static SpriteAlignment GetAlignment(this ITextureImporter importer)
		{
			return (SpriteAlignment)importer.Alignment_C1006;
		}

		public static TextureImporterAlphaSource GetAlphaUsage(this ITextureImporter importer)
		{
			return (TextureImporterAlphaSource)importer.AlphaUsage_C1006;
		}

		public static TextureImporterType GetTextureType(this ITextureImporter importer)
		{
			return (TextureImporterType)importer.TextureType_C1006;
		}

		public static TextureImporterShape GetTextureShape(this ITextureImporter importer)
		{
			return (TextureImporterShape)importer.TextureShape_C1006;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TextureImporterPlatformSettings.cs`:

```cs
using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.SourceGenerated.Subclasses.TextureImporterPlatformSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TextureImporterPlatformSettings
	{
		public static TextureResizeAlgorithm GetResizeAlgorithm(this ITextureImporterPlatformSettings settings)
		{
			return (TextureResizeAlgorithm)settings.ResizeAlgorithm;
		}

		public static TextureFormat GetTextureFormat(this ITextureImporterPlatformSettings settings)
		{
			/*if (settings.ToSerializedVersion() > 1)// TextureFormat.ATC_RGB4/ATC_RGBA8 has been replaced by ETC_RGB4/ETC2_RGBA8
			{
				if (settings.TextureFormat == TextureFormat.ATC_RGB4)
				{
					return TextureFormat.ETC_RGB4;
				}
				if (settings.TextureFormat == TextureFormat.ATC_RGBA8)
				{
					return TextureFormat.ETC2_RGBA8;
				}
			}*/
			return (TextureFormat)settings.TextureFormat;
		}

		public static TextureImporterCompression GetTextureCompression(this ITextureImporterPlatformSettings settings)
		{
			return (TextureImporterCompression)settings.TextureCompression;
		}

		public static AndroidETC2FallbackOverride GetAndroidETC2FallbackOverride(this ITextureImporterPlatformSettings settings)
		{
			return (AndroidETC2FallbackOverride)settings.AndroidETC2FallbackOverride;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TextureParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.TextureParameter;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TextureParameterExtensions
	{
		public static void SetValues(this ITextureParameter parameter, string name, int index, sbyte dimension, int sampler)
		{
			//parameter.Name = name;//Name doesn't exist
			parameter.NameIndex = -1;
			parameter.Index = index;
			parameter.Dim = dimension;
			parameter.SamplerIndex = sampler;
			parameter.MultiSampled = false;
		}

		public static void SetValues(this ITextureParameter parameter, string name, int index, sbyte dimension, int sampler, bool multiSampled)
		{
			//parameter.Name = name;//Name doesn't exist
			parameter.NameIndex = -1;
			parameter.Index = index;
			parameter.Dim = dimension;
			parameter.SamplerIndex = sampler;
			parameter.MultiSampled = multiSampled;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TextureSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.SourceGenerated.Subclasses.TextureSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TextureSettingsExtensions
	{
		public static TextureImporterCompression GetTextureCompression(this ITextureSettings settings)
		{
			return (TextureImporterCompression)settings.TextureCompression;
		}

		public static void SetTextureCompression(this ITextureSettings settings, TextureImporterCompression compression)
		{
			settings.TextureCompression = (int)compression;
		}

		public static FilterMode GetFilterMode(this ITextureSettings settings)
		{
			return (FilterMode)settings.FilterMode;
		}

		public static void SetFilterMode(this ITextureSettings settings, FilterMode filterMode)
		{
			settings.FilterMode = (int)filterMode;
		}

		public static ColorSpace GetColorSpace(this ITextureSettings settings)
		{
			return settings.Has_ColorSpace()
				? (ColorSpace)settings.ColorSpace
				: settings.Has_SRGB_Boolean()
					? settings.SRGB_Boolean ? ColorSpace.Linear : ColorSpace.Gamma //Not 100% sure on this
					: (ColorSpace)settings.SRGB_Int32; //Not 100% sure on this
		}

		public static bool GetSRGB(this ITextureSettings settings)
		{
			return settings.Has_SRGB_Boolean()
				? settings.SRGB_Boolean
				: settings.Has_SRGB_Int32()
					? settings.SRGB_Int32 != 0
					: settings.ColorSpace != (int)ColorSpace.Gamma; //Not 100% sure on this
		}

		public static void SetSRGB(this ITextureSettings settings, bool value)
		{
			settings.SRGB_Boolean = value;
			settings.SRGB_Int32 = value ? 1 : 0;
			settings.ColorSpace = value ? (int)ColorSpace.Linear : (int)ColorSpace.Gamma;
		}

		public static int GetAnisoLevel(this ITextureSettings settings)
		{
			return settings.Has_AnisoLevel_Int32()
				? settings.AnisoLevel_Int32
				: unchecked((int)settings.AnisoLevel_UInt32);
		}

		public static void SetAnisoLevel(this ITextureSettings settings, int value)
		{
			settings.AnisoLevel_Int32 = value;
			settings.AnisoLevel_UInt32 = unchecked((uint)value);
		}

		public static int GetCompressionQuality(this ITextureSettings settings)
		{
			return settings.Has_CompressionQuality_Int32()
				? settings.CompressionQuality_Int32
				: unchecked((int)settings.CompressionQuality_UInt32);
		}

		public static void SetCompressionQuality(this ITextureSettings settings, int value)
		{
			settings.CompressionQuality_Int32 = value;
			settings.CompressionQuality_UInt32 = unchecked((uint)value);
		}

		public static int GetMaxTextureSize(this ITextureSettings settings)
		{
			return settings.Has_MaxTextureSize_Int32()
				? settings.MaxTextureSize_Int32
				: unchecked((int)settings.MaxTextureSize_UInt32);
		}

		public static void SetMaxTextureSize(this ITextureSettings settings, int value)
		{
			settings.MaxTextureSize_Int32 = value;
			settings.MaxTextureSize_UInt32 = unchecked((uint)value);
		}

		public static bool GetGenerateMipMaps(this ITextureSettings settings)
		{
			return settings.Has_GenerateMipMaps_Int32()
				? settings.GenerateMipMaps_Int32 != 0
				: settings.GenerateMipMaps_Boolean;
		}

		public static void SetGenerateMipMaps(this ITextureSettings settings, bool value)
		{
			settings.GenerateMipMaps_Int32 = value ? 1 : 0;
			settings.GenerateMipMaps_Boolean = value;
		}

		public static bool GetReadable(this ITextureSettings settings)
		{
			return settings.Has_Readable_Int32()
				? settings.Readable_Int32 != 0
				: settings.Readable_Boolean;
		}

		public static void SetReadable(this ITextureSettings settings, bool value)
		{
			settings.Readable_Int32 = value ? 1 : 0;
			settings.Readable_Boolean = value;
		}

		public static bool GetCrunchedCompression(this ITextureSettings settings)
		{
			return settings.Has_CrunchedCompression_Int32()
				? settings.CrunchedCompression_Int32 != 0
				: settings.CrunchedCompression_Boolean;
		}

		public static void SetCrunchedCompression(this ITextureSettings settings, bool value)
		{
			settings.CrunchedCompression_Int32 = value ? 1 : 0;
			settings.CrunchedCompression_Boolean = value;
		}

		public static void Initialize(this ITextureSettings settings)
		{
			settings.SetAnisoLevel(1);
			settings.SetCompressionQuality(50);
			settings.SetMaxTextureSize(2048);
			settings.SetTextureCompression(TextureImporterCompression.Uncompressed);
			settings.SetFilterMode(FilterMode.Bilinear);
			settings.SetGenerateMipMaps(false);
			settings.SetReadable(false);
			settings.SetCrunchedCompression(false);
			settings.SetSRGB(true);
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TierGraphicsSettingsEditorExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Camera;
using AssetRipper.Core.Classes.GraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettingsEditor;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TierGraphicsSettingsEditorExtensions
	{
		public static void ConvertToEditorFormat(this ITierGraphicsSettingsEditor settings)
		{
			settings.StandardShaderQuality = (int)ShaderQuality.High;
			settings.RenderingPath = (int)RenderingPath.Forward;
			settings.HdrMode = (int)CameraHDRMode.FP16;
			settings.RealtimeGICPUUsage = (int)RealtimeGICPUUsage.Low;
			settings.UseReflectionProbeBoxProjection = true;
			settings.UseReflectionProbeBlending = true;
			settings.UseHDR = true;
			settings.UseDetailNormalMap = true;
			settings.UseCascadedShadowMaps = true;
			settings.Prefer32BitShadowMaps = false;
			settings.EnableLPPV = true;
			settings.UseDitherMaskForAlphaBlendedShadows = true;
		}

		public static void ConvertToEditorFormat(this ITierGraphicsSettingsEditor settings, ITierGraphicsSettings tierGraphicsSettings)
		{
			settings.StandardShaderQuality = (int)ShaderQuality.High;
			settings.RenderingPath = tierGraphicsSettings.RenderingPath;
			settings.HdrMode = tierGraphicsSettings.Has_HdrMode() 
				? tierGraphicsSettings.HdrMode 
				: (int)CameraHDRMode.FP16;
			settings.RealtimeGICPUUsage = tierGraphicsSettings.Has_RealtimeGICPUUsage() 
				? tierGraphicsSettings.RealtimeGICPUUsage
				: (int)RealtimeGICPUUsage.Low;
			settings.UseReflectionProbeBoxProjection = true;
			settings.UseReflectionProbeBlending = true;
			settings.UseHDR = !tierGraphicsSettings.Has_UseHDR() || tierGraphicsSettings.UseHDR;
			settings.UseDetailNormalMap = true;
			settings.UseCascadedShadowMaps = tierGraphicsSettings.UseCascadedShadowMaps;
			settings.Prefer32BitShadowMaps = tierGraphicsSettings.Prefer32BitShadowMaps;
			settings.EnableLPPV = !tierGraphicsSettings.Has_EnableLPPV() || tierGraphicsSettings.EnableLPPV;
			settings.UseDitherMaskForAlphaBlendedShadows = true;
		}

		public static ShaderQuality GetStandardShaderQuality(this ITierGraphicsSettingsEditor settings)
		{
			return (ShaderQuality)settings.StandardShaderQuality;
		}

		public static RenderingPath GetRenderingPath(this ITierGraphicsSettingsEditor settings)
		{
			return (RenderingPath)settings.RenderingPath;
		}

		public static CameraHDRMode GetHdrMode(this ITierGraphicsSettingsEditor settings)
		{
			return (CameraHDRMode)settings.HdrMode;
		}

		public static RealtimeGICPUUsage GetRealtimeGICPUUsage(this ITierGraphicsSettingsEditor settings)
		{
			return (RealtimeGICPUUsage)settings.RealtimeGICPUUsage;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TierGraphicsSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Camera;
using AssetRipper.Core.Classes.GraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TierGraphicsSettingsExtensions
	{
		public static RenderingPath GetRenderingPath(this ITierGraphicsSettings settings)
		{
			return (RenderingPath)settings.RenderingPath;
		}

		public static CameraHDRMode GetHdrMode(this ITierGraphicsSettings settings)
		{
			return (CameraHDRMode)settings.HdrMode;
		}

		public static RealtimeGICPUUsage GetRealtimeGICPUUsage(this ITierGraphicsSettings settings)
		{
			return (RealtimeGICPUUsage)settings.RealtimeGICPUUsage;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TierSettingsExtensions.cs`:

```cs
using AssetRipper.Core.Classes.GraphicsSettings;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettings;
using AssetRipper.SourceGenerated.Subclasses.TierGraphicsSettingsEditor;
using AssetRipper.SourceGenerated.Subclasses.TierSettings;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TierSettingsExtensions
	{
		public static void ConvertToEditorFormat(this ITierSettings settings, ITierGraphicsSettingsEditor tierGraphicsSettingsEditor, BuildTargetGroup buildTarget, GraphicsTier tier)
		{
			settings.Automatic = false;
			settings.SetBuildTarget(buildTarget);
			settings.Settings.CopyValues(tierGraphicsSettingsEditor);
			settings.Tier = (int)tier;
		}

		public static void ConvertToEditorFormat(this ITierSettings settings, ITierGraphicsSettings tierGraphicsSettings, BuildTargetGroup buildTarget, GraphicsTier tier)
		{
			settings.Automatic = false;
			settings.SetBuildTarget(buildTarget);
			settings.Settings.ConvertToEditorFormat(tierGraphicsSettings);
			settings.Tier = (int)tier;
		}

		public static GraphicsTier GetTier(this ITierSettings settings)
		{
			return (GraphicsTier)settings.Tier;
		}

		public static BuildTargetGroup GetBuildTargetAsEnum(this ITierSettings settings)
		{
			if (settings.Has_BuildTarget_Utf8String())
			{
				return StringToBuildGroup(settings.BuildTarget_Utf8String.String);
			}
			else
			{
				return (BuildTargetGroup)settings.BuildTarget_Int32;
			}
		}

		public static string GetBuildTargetAsString(this ITierSettings settings)
		{
			if (settings.Has_BuildTarget_Utf8String())
			{
				return settings.BuildTarget_Utf8String.String;
			}
			else
			{
				return BuildGroupToString((BuildTargetGroup)settings.BuildTarget_Int32);
			}
		}

		public static void SetBuildTarget(this ITierSettings settings, BuildTargetGroup buildTarget)
		{
			if (settings.Has_BuildTarget_Utf8String())
			{
				settings.BuildTarget_Utf8String.String = BuildGroupToString(buildTarget);
			}
			else
			{
				settings.BuildTarget_Int32 = (int)buildTarget;
			}
		}

		private static BuildTargetGroup StringToBuildGroup(string group)
		{
			return group switch
			{
				"Standalone" => BuildTargetGroup.Standalone,
				"Web" => BuildTargetGroup.WebPlayer,
				"iPhone" => BuildTargetGroup.iPhone,
				"Android" => BuildTargetGroup.Android,
				"WebGL" => BuildTargetGroup.WebGL,
				"Windows Store Apps" => BuildTargetGroup.WSA,
				"Tizen" => BuildTargetGroup.Tizen,
				"PSP2" => BuildTargetGroup.PSP2,
				"PS4" => BuildTargetGroup.PS4,
				"PSM" => BuildTargetGroup.PSM,
				"XboxOne" => BuildTargetGroup.XboxOne,
				"Samsung TV" => BuildTargetGroup.SamsungTV,
				"Nintendo 3DS" => BuildTargetGroup.N3DS,
				"WiiU" => BuildTargetGroup.WiiU,
				"tvOS" => BuildTargetGroup.tvOS,
				_ => BuildTargetGroup.Standalone,
			};
		}

		private static string BuildGroupToString(BuildTargetGroup group)
		{
			return group switch
			{
				BuildTargetGroup.Standalone => "Standalone",
				BuildTargetGroup.WebPlayer => "Web",
				BuildTargetGroup.iPhone => "iPhone",
				BuildTargetGroup.Android => "Android",
				BuildTargetGroup.WebGL => "WebGL",
				BuildTargetGroup.WSA => "Windows Store Apps",
				BuildTargetGroup.Tizen => "Tizen",
				BuildTargetGroup.PSP2 => "PSP2",
				BuildTargetGroup.PS4 => "PS4",
				BuildTargetGroup.PSM => "PSM",
				BuildTargetGroup.XboxOne => "XboxOne",
				BuildTargetGroup.SamsungTV => "Samsung TV",
				BuildTargetGroup.N3DS => "Nintendo 3DS",
				BuildTargetGroup.WiiU => "WiiU",
				BuildTargetGroup.tvOS => "tvOS",
				_ => "Standalone",
			};
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TrailModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.TrailModule;
using AssetRipper.SourceGenerated.Subclasses.TrailModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TrailModuleExtensions
	{
		public static void SetToDefault(this ITrailModule module, UnityVersion version)
		{
			module.Ratio = 1.0f;
			module.Lifetime.SetValues(version, 1.0f);
			module.MinVertexDistance = 0.2f;
			module.RibbonCount = 1;
			module.DieWithParticles = true;
			module.SizeAffectsWidth = true;
			module.InheritParticleColor = true;
			module.ColorOverLifetime.SetToDefault();
			module.WidthOverTrail.SetValues(version, 1.0f);
			module.ColorOverTrail.SetToDefault();
		}

		public static ParticleSystemTrailMode GetMode(this ITrailModule module)
		{
			return (ParticleSystemTrailMode)module.Mode;
		}

		public static ParticleSystemTrailTextureMode GetTextureMode(this ITrailModule module)
		{
			return (ParticleSystemTrailTextureMode)module.TextureMode;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TransformExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.IO;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Transform_;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TransformExtensions
	{
		private const char PathSeparator = '/';

		public static string GetRootPath(this ITransform transform)
		{
			string pre = string.Empty;
			if (!transform.Father_C4.IsNull())
			{
				pre = transform.Father_C4.GetAsset(transform.SerializedFile).GetRootPath() + PathSeparator;
			}
			return pre + transform.GetGameObject().NameString;
		}

		/// <summary>
		/// Find the sibling index (aka the root order) of the transform
		/// </summary>
		/// <param name="transform">The relevant transform</param>
		/// <returns>The sibling index of the transform</returns>
		/// <exception cref="Exception">if the transform cannot be found among the father's children</exception>
		public static int GetSiblingIndex(this ITransform transform)
		{
			if (transform.Father_C4.IsNull())
			{
				return 0;
			}
			ITransform father = transform.Father_C4.GetAsset(transform.SerializedFile);
			for (int i = 0; i < father.Children_C4.Count; i++)
			{
				IPPtr_Transform_ child = father.Children_C4[i];
				if (child.PathIndex == transform.PathID)
				{
					return i;
				}
			}
			throw new Exception("Transform hasn't been found among father's children");
		}

		public static ITransform? FindChild(this ITransform transform, string path)
		{
			if (path.Length == 0)
			{
				return transform;
			}
			return FindChild(transform, path, 0);
		}

		private static ITransform? FindChild(this ITransform transform, string path, int startIndex)
		{
			int separatorIndex = path.IndexOf(PathSeparator, startIndex);
			string childName = separatorIndex == -1 ?
				path.Substring(startIndex, path.Length - startIndex) :
				path.Substring(startIndex, separatorIndex - startIndex);
			foreach (IPPtr_Transform_ childPtr in transform.Children_C4)
			{
				ITransform child = childPtr.GetAsset(transform.SerializedFile);
				IGameObject childGO = child.GetGameObject();
				if (childGO.NameString == childName)
				{
					return separatorIndex == -1 ? child : child.FindChild(path, separatorIndex + 1);
				}
			}
			return default;
		}

		public static void ConvertToEditorFormat(this ITransform transform)
		{
			if (transform.Has_RootOrder_C4())
			{
				transform.RootOrder_C4 = transform.CalculateRootOrder();
			}
			if (transform.Has_LocalEulerAnglesHint_C4())
			{
				Vector3f eulerHints = new Quaternionf(
					transform.LocalRotation_C4.X, 
					transform.LocalRotation_C4.Y, 
					transform.LocalRotation_C4.Z, 
					transform.LocalRotation_C4.W).ToEulerAngle();
				transform.LocalEulerAnglesHint_C4.SetValues(eulerHints.X, eulerHints.Y, eulerHints.Z);
			}
		}

		private static int CalculateRootOrder(this ITransform transform)
		{
			if (transform.Father_C4.IsNull())
			{
				return 0;
			}
			ITransform father = transform.Father_C4.GetAsset(transform.SerializedFile);
			AccessListBase<IPPtr_Transform_> children = father.Children_C4;
			for (int i = 0; i < children.Count; i++)
			{
				IPPtr_Transform_ child = children[i];
				if (child.PathIndex == transform.PathID)
				{
					return i;
				}
			}
			throw new Exception("Transform hasn't been found among father's children");
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TransitionConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorController.Constants;
using AssetRipper.Core.Classes.AnimatorTransition;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_ConditionConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TransitionConstantExtensions
	{
		public static bool GetHasFixedDuration(this ITransitionConstant transitionConstant)
		{
			return !transitionConstant.Has_HasFixedDuration() || transitionConstant.HasFixedDuration;
		}

		public static TransitionInterruptionSource GetInterruptionSource(this ITransitionConstant transitionConstant)
		{
			if (transitionConstant.Has_InterruptionSource())
			{
				return (TransitionInterruptionSource)transitionConstant.InterruptionSource;
			}
			else
			{
				return transitionConstant.Atomic ? TransitionInterruptionSource.None : TransitionInterruptionSource.Destination;
			}
		}

		public static float GetExitTime(this ITransitionConstant transitionConstant)
		{
			if (transitionConstant.Has_ExitTime())
			{
				return transitionConstant.ExitTime;
			}
			else
			{
				foreach (OffsetPtr_ConditionConstant conditionPtr in transitionConstant.ConditionConstantArray)
				{
					if (conditionPtr.Data.ConditionMode == (int)AnimatorConditionMode.ExitTime)
					{
						return conditionPtr.Data.ExitTime;
					}
				}
				return 1.0f;
			}
		}

		public static bool GetHasExitTime(this ITransitionConstant transitionConstant)
		{
			if (transitionConstant.Has_HasExitTime())
			{
				return transitionConstant.HasExitTime;
			}
			else
			{
				foreach (OffsetPtr_ConditionConstant conditionPtr in transitionConstant.ConditionConstantArray)
				{
					if (conditionPtr.Data.ConditionMode == (int)AnimatorConditionMode.ExitTime)
					{
						return true;
					}
				}
				return false;
			}
		}

		public static bool IsExit(this ITransitionConstant transitionConstant) => transitionConstant.DestinationState >= 30000;
	}
}

```

`AssetRipperCommon/SourceGenExtensions/TriggerModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.Trigger;
using AssetRipper.Core.Classes.ParticleSystemForceField;
using AssetRipper.SourceGenerated.Subclasses.ParticleSystemForceFieldParameters;
using AssetRipper.SourceGenerated.Subclasses.TriggerModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class TriggerModuleExtensions
	{
		public static void SetToDefault(this ITriggerModule module)
		{
			module.Inside = (int)TriggerAction.Kill;
			module.RadiusScale = 1;
		}

		public static TriggerAction GetInside(this ITriggerModule module)
		{
			return (TriggerAction)module.Inside;
		}

		public static TriggerAction GetOutside(this ITriggerModule module)
		{
			return (TriggerAction)module.Outside;
		}

		public static TriggerAction GetEnter(this ITriggerModule module)
		{
			return (TriggerAction)module.Enter;
		}

		public static TriggerAction GetExit(this ITriggerModule module)
		{
			return (TriggerAction)module.Exit;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/UAVParameterExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.UAVParameter;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class UAVParameterExtensions
	{
		public static void SetValues(this IUAVParameter parameter, string name, int index, int originalIndex)
		{
			//parameter.Name = name;//Name doesn't exist
			parameter.NameIndex = -1;
			parameter.Index = index;
			parameter.OriginalIndex = originalIndex;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/UVModuleExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ParticleSystem.UV;
using AssetRipper.SourceGenerated.Subclasses.UVModule;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class UVModuleExtensions
	{
		public static ParticleSystemAnimationMode GetMode(this IUVModule module)
		{
			return (ParticleSystemAnimationMode)module.Mode;
		}

		public static ParticleSystemAnimationTimeMode GetTimeMode(this IUVModule module)
		{
			return (ParticleSystemAnimationTimeMode)module.TimeMode;
		}

		public static ParticleSystemAnimationType GetAnimationType(this IUVModule module)
		{
			return (ParticleSystemAnimationType)module.AnimationType;
		}

		public static ParticleSystemAnimationRowMode GetRowMode(this IUVModule module)
		{
			if(module.Has_RowMode())
			{
				return (ParticleSystemAnimationRowMode)module.RowMode;
			}
			else
			{
				return module.RandomRow ? ParticleSystemAnimationRowMode.Random : ParticleSystemAnimationRowMode.Custom;
			}
		}

		public static bool GetRandomRow(this IUVModule module)
		{
			return module.RandomRow || module.RowMode == (int)ParticleSystemAnimationRowMode.Random;
		}

		public static void SetRandomRow(this IUVModule module, bool value)
		{
			if (module.Has_RandomRow())
			{
				module.RandomRow = value;
			}
			else
			{
				module.RowMode = (int)(value ? ParticleSystemAnimationRowMode.Random : ParticleSystemAnimationRowMode.Custom);
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/UnityConnectSettingsExtensions.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files;
using AssetRipper.SourceGenerated.Classes.ClassID_310;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class UnityConnectSettingsExtensions
	{
		public static void ConvertToEditorFormat(this IUnityConnectSettings settings)
		{
			settings.CrashReportingSettings_C310?.ConvertToEditorFormat();
		}

		/// <summary>
		/// 5.4.0 and greater and (Not Release or IsSupported)
		/// </summary>
		public static bool HasCrashReportingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			if (version.IsLess(5, 4))
			{
				return false;
			}
			if (!flags.IsRelease())
			{
				return true;
			}
			switch (platform)
			{
				case BuildTarget.NoTarget:
				case BuildTarget.Android:
				case BuildTarget.iOS:
				case BuildTarget.tvOS:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerARM:
				case BuildTarget.WebPlayerLZMA:
				case BuildTarget.WebPlayerLZMAStreamed:
				case BuildTarget.WebGL:
					return true;

				case BuildTarget.Tizen:
					return version.IsGreaterEqual(5, 6);

				default:
					return false;
			}
		}
		/// <summary>
		/// Less than 5.4.0 or Not Release or IsSupported
		/// </summary>
		public static bool HasUnityPurchasingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			if (version.IsLess(5, 4))
			{
				return true;
			}
			if (!flags.IsRelease())
			{
				return true;
			}
			switch (platform)
			{
				case BuildTarget.NoTarget:
				case BuildTarget.Android:
				case BuildTarget.iOS:
				case BuildTarget.tvOS:
				case BuildTarget.Tizen:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerARM:
				case BuildTarget.WebGL:
					return true;

				default:
					return false;
			}
		}
		/// <summary>
		/// Less than 5.4.0 or Not Release or IsSupported
		/// </summary>
		public static bool HasUnityAnalyticsSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			if (version.IsLess(5, 4))
			{
				return true;
			}
			if (!flags.IsRelease())
			{
				return true;
			}
			switch (platform)
			{
				case BuildTarget.NoTarget:
				case BuildTarget.Android:
				case BuildTarget.iOS:
				case BuildTarget.tvOS:
				case BuildTarget.Tizen:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerARM:
				case BuildTarget.WebGL:
					return true;

				default:
					return false;
			}
		}
		/// <summary>
		/// 5.5.0 and greater and (Not Release or IsSupported)
		/// </summary>
		public static bool HasUnityAdsSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			if (version.IsLess(5, 5))
			{
				return false;
			}
			if (!flags.IsRelease())
			{
				return true;
			}
			switch (platform)
			{
				case BuildTarget.NoTarget:
				case BuildTarget.Android:
				case BuildTarget.iOS:
				case BuildTarget.tvOS:
				case BuildTarget.Tizen:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerARM:
				case BuildTarget.WebGL:
					return true;

				default:
					return false;
			}
		}
		/// <summary>
		/// 5.6.0 and greater and (Not Release or IsSupported)
		/// </summary>
		public static bool HasPerformanceReportingSettings(UnityVersion version, BuildTarget platform, TransferInstructionFlags flags)
		{
			if (version.IsLess(5, 6))
			{
				return false;
			}
			if (!flags.IsRelease())
			{
				return true;
			}
			switch (platform)
			{
				case BuildTarget.NoTarget:
				case BuildTarget.Android:
				case BuildTarget.iOS:
				case BuildTarget.tvOS:
				case BuildTarget.Tizen:
				case BuildTarget.StandaloneWinPlayer:
				case BuildTarget.StandaloneWin64Player:
				case BuildTarget.StandaloneLinux:
				case BuildTarget.StandaloneLinux64:
				case BuildTarget.StandaloneLinuxUniversal:
				case BuildTarget.StandaloneOSXUniversal:
				case BuildTarget.StandaloneOSXIntel:
				case BuildTarget.StandaloneOSXIntel64:
				case BuildTarget.MetroPlayerX64:
				case BuildTarget.MetroPlayerX86:
				case BuildTarget.MetroPlayerARM:
				case BuildTarget.WebGL:
					return true;

				default:
					return false;
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/UnityPropertySheetExtensions.cs`:

```cs
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Subclasses.UnityPropertySheet;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class UnityPropertySheetExtensions
	{
		private const string HDRPostfixName = "_HDR";
		private const string STPostfixName = "_ST";
		private const string TexelSizePostfixName = "_TexelSize";

		public static string? FindPropertyNameByCRC28(this IUnityPropertySheet sheet, uint crc)
		{
			foreach (Utf8String property in sheet.GetTexEnvNames())
			{
				string propertyString = property.String;
				string hdrName = propertyString + HDRPostfixName;
				if (CrcUtils.Verify28DigestUTF8(hdrName, crc))
				{
					return hdrName;
				}
				string stName = propertyString + STPostfixName;
				if (CrcUtils.Verify28DigestUTF8(stName, crc))
				{
					return stName;
				}
				string texelName = propertyString + TexelSizePostfixName;
				if (CrcUtils.Verify28DigestUTF8(texelName, crc))
				{
					return texelName;
				}
			}
			foreach (Utf8String property in sheet.GetFloatNames())
			{
				string propertyString = property.String;
				if (CrcUtils.Verify28DigestUTF8(propertyString, crc))
				{
					return propertyString;
				}
			}
			foreach (Utf8String property in sheet.GetIntNames())
			{
				string propertyString = property.String;
				if (CrcUtils.Verify28DigestUTF8(propertyString, crc))
				{
					return propertyString;
				}
			}
			foreach (Utf8String property in sheet.GetColorNames())
			{
				string propertyString = property.String;
				if (CrcUtils.Verify28DigestUTF8(propertyString, crc))
				{
					return propertyString;
				}
			}
			return null;
		}

		private static IEnumerable<Utf8String> GetTexEnvNames(this IUnityPropertySheet sheet)
		{
			if (sheet.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_0_0_f5())
			{
				return sheet.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_0_0_f5.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5_0_f5())
			{
				return sheet.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_3_5_0_f5.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5_0_0_f4())
			{
				return sheet.TexEnvs_AssetDictionary_FastPropertyName_UnityTexEnv_5_0_0_f4.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5_0_0_f4())
			{
				return sheet.TexEnvs_AssetDictionary_Utf8String_UnityTexEnv_5_0_0_f4.Keys;
			}
			else
			{
				throw new NotSupportedException(sheet.GetType().FullName);
			}
		}

		private static IEnumerable<Utf8String> GetColorNames(this IUnityPropertySheet sheet)
		{
			if (sheet.Has_Colors_AssetDictionary_FastPropertyName_ColorRGBAf_3_0_0_f5())
			{
				return sheet.Colors_AssetDictionary_FastPropertyName_ColorRGBAf_3_0_0_f5.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_Colors_AssetDictionary_FastPropertyName_ColorRGBAf_3_5_0_f5())
			{
				return sheet.Colors_AssetDictionary_FastPropertyName_ColorRGBAf_3_5_0_f5.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_Colors_AssetDictionary_Utf8String_ColorRGBAf_3_5_0_f5())
			{
				return sheet.Colors_AssetDictionary_Utf8String_ColorRGBAf_3_5_0_f5.Keys;
			}
			else
			{
				throw new NotSupportedException(sheet.GetType().FullName);
			}
		}

		private static IEnumerable<Utf8String> GetFloatNames(this IUnityPropertySheet sheet)
		{
			if (sheet.Has_Floats_AssetDictionary_FastPropertyName_Single())
			{
				return sheet.Floats_AssetDictionary_FastPropertyName_Single.Keys.Select(n => n.Name);
			}
			else if (sheet.Has_Floats_AssetDictionary_Utf8String_Single())
			{
				return sheet.Floats_AssetDictionary_Utf8String_Single.Keys;
			}
			else
			{
				throw new NotSupportedException(sheet.GetType().FullName);
			}
		}

		private static IEnumerable<Utf8String> GetIntNames(this IUnityPropertySheet sheet)
		{
			if (sheet.Has_Ints())
			{
				return sheet.Ints.Keys;
			}
			else
			{
				return Enumerable.Empty<Utf8String>();
			}
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/ValueConstantExtensions.cs`:

```cs
using AssetRipper.Core.Classes.AnimatorController.Editor.AnimatorControllerParameter;
using AssetRipper.SourceGenerated.Subclasses.ValueConstant;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class ValueConstantExtensions
	{
		public static AnimatorControllerParameterType GetTypeValue(this IValueConstant valueConstant)
		{
			return (AnimatorControllerParameterType)valueConstant.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/VariantInfoExtensions.cs`:

```cs
using AssetRipper.Core.Classes.ShaderVariantCollection;
using AssetRipper.SourceGenerated.Subclasses.VariantInfo;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class VariantInfoExtensions
	{
		public static PassType GetPassType(this IVariantInfo info)
		{
			return (PassType)info.PassType;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Vector2fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector2f;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Vector2fExtensions
	{
		public static void Scale(this IVector2f vector, float scalar)
		{
			vector.X *= scalar;
			vector.Y *= scalar;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Vector3CurveExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector3Curve;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Vector3CurveExtensions
	{
		public static void SetValues(this IVector3Curve curve, string path)
		{
			curve.Path.String = path;
			curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Vector3fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector3f;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Vector3fExtensions
	{
		public static void Scale(this IVector3f vector, float scalar)
		{
			vector.X *= scalar;
			vector.Y *= scalar;
			vector.Z *= scalar;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/Vector4fExtensions.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.Vector4f;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class Vector4fExtensions
	{
		public static void Scale(this IVector4f vector, float scalar)
		{
			vector.X *= scalar;
			vector.Y *= scalar;
			vector.Z *= scalar;
			vector.W *= scalar;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/VectorParameterExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.SourceGenerated.Subclasses.VectorParameter;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class VectorParameterExtensions
	{
		public static void SetValues(this IVectorParameter parameter, string name, ShaderParamType type, int index, int columns)
		{
			//parameter.Name = name;//Name doesn't exist
			parameter.NameIndex = -1;
			parameter.Index = index;
			parameter.ArraySize = 0;
			parameter.Type = (sbyte)type;
			parameter.Dim = (sbyte)columns;
		}

		public static ShaderParamType GetType_(this IVectorParameter parameter)
		{
			return (ShaderParamType)parameter.Type;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/VertexDataExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.IO;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.IO.Endian;
using AssetRipper.SourceGenerated.Subclasses.ChannelInfo;
using AssetRipper.SourceGenerated.Subclasses.StreamInfo;
using AssetRipper.SourceGenerated.Subclasses.SubMesh;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using AssetRipper.SourceGenerated.Subclasses.VertexData;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using MeshHelper = AssetRipper.Core.Classes.Mesh.MeshHelper;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class VertexDataExtensions
	{
		private const int StaticStreamCount = 4;
		private const int VertexStreamAlign = 16;

		public static bool IsSet(this IVertexData instance) => instance.VertexCount > 0;

		/// <summary>
		/// 5.6.0
		/// </summary>
		private static bool AllowUnsetVertexChannel(UnityVersion version) => version.IsEqual(5, 6, 0);

		public static ChannelInfo GetChannel(this IVertexData instance, UnityVersion version, ShaderChannel channelType)
		{
			if (instance.Has_Channels())
			{
				return instance.Channels[channelType.ToChannel(version)];
			}
			else
			{
				return new();
				//return StreamInfoConverter.GenerateChannelInfo(version, instance.Streams, channelType);
			}
		}

		public static void ReadData(
			this IVertexData instance,
			UnityVersion version,
			EndianType endianType,
			out int vertexCount,
			out Vector3f[]? vertices,
			out Vector3f[]? normals,
			out Vector4f[]? tangents,
			out ColorRGBA32[]? colors,
			out BoneWeights4[]? skin,
			out Vector2f[]? uv0,
			out Vector2f[]? uv1,
			out Vector2f[]? uv2,
			out Vector2f[]? uv3,
			out Vector2f[]? uv4,
			out Vector2f[]? uv5,
			out Vector2f[]? uv6,
			out Vector2f[]? uv7)
		{
			vertexCount = (int)instance.VertexCount;

			vertices = default;
			normals = default;
			tangents = default;
			colors = default;
			skin = default;
			uv0 = default;
			uv1 = default;
			uv2 = default;
			uv3 = default;
			uv4 = default;
			uv5 = default;
			uv6 = default;
			uv7 = default;

			IReadOnlyList<ChannelInfo> channels = instance.GetChannels(version);
			List<IStreamInfo> streams = instance.GetStreams(version);

			for (int chn = 0; chn < channels.Count; chn++)
			{
				ChannelInfo? m_Channel = channels[chn];
				if (m_Channel.GetDataDimension() > 0)
				{
					IStreamInfo m_Stream = streams[m_Channel.Stream];
					BitArray? channelMask = new BitArray(BitConverter.GetBytes(m_Stream.ChannelMask));
					if (channelMask.Get(chn))
					{
						if (version.IsLess(2018) && chn == 2 && m_Channel.Format == 2) //kShaderChannelColor && kChannelFormatColor
						{
							m_Channel.SetDataDimension(4);
						}

						MeshHelper.VertexFormat vertexFormat = MeshHelper.ToVertexFormat(m_Channel.Format, version);
						int componentByteSize = (int)MeshHelper.GetFormatSize(vertexFormat);
						byte[]? componentBytes = new byte[vertexCount * m_Channel.GetDataDimension() * componentByteSize];
						for (int v = 0; v < vertexCount; v++)
						{
							int vertexOffset = (int)m_Stream.Offset + m_Channel.Offset + (int)m_Stream.GetStride() * v;
							for (int d = 0; d < m_Channel.GetDataDimension(); d++)
							{
								int componentOffset = vertexOffset + componentByteSize * d;
								Buffer.BlockCopy(instance.Data, componentOffset, componentBytes, componentByteSize * (v * m_Channel.GetDataDimension() + d), componentByteSize);
							}
						}

						if (endianType == EndianType.BigEndian && componentByteSize > 1) //swap bytes
						{
							for (int i = 0; i < componentBytes.Length / componentByteSize; i++)
							{
								byte[] buff = new byte[componentByteSize];
								Buffer.BlockCopy(componentBytes, i * componentByteSize, buff, 0, componentByteSize);
								buff = buff.Reverse().ToArray();
								Buffer.BlockCopy(buff, 0, componentBytes, i * componentByteSize, componentByteSize);
							}
						}

						int[]? componentsIntArray = null;
						float[]? componentsFloatArray = null;
						if (MeshHelper.IsIntFormat(vertexFormat))
						{
							componentsIntArray = MeshHelper.BytesToIntArray(componentBytes, vertexFormat);
						}
						else
						{
							componentsFloatArray = MeshHelper.BytesToFloatArray(componentBytes, vertexFormat);
						}

						if (version.IsGreaterEqual(2018))
						{
							switch (chn)
							{
								case 0: //kShaderChannelVertex
									vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 1: //kShaderChannelNormal
									normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 2: //kShaderChannelTangent
									tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 3: //kShaderChannelColor
									colors = MeshHelper.FloatArrayToColorRGBA32(componentsFloatArray);
									break;
								case 4: //kShaderChannelTexCoord0
									uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 5: //kShaderChannelTexCoord1
									uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 6: //kShaderChannelTexCoord2
									uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 7: //kShaderChannelTexCoord3
									uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 8: //kShaderChannelTexCoord4
									uv4 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 9: //kShaderChannelTexCoord5
									uv5 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 10: //kShaderChannelTexCoord6
									uv6 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 11: //kShaderChannelTexCoord7
									uv7 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								//2018.2 and up
								case 12: //kShaderChannelBlendWeight
									if (skin == null)
									{
										skin = MakeInitializedArray<BoneWeights4>(vertexCount);
									}
									for (int i = 0; i < vertexCount; i++)
									{
										for (int j = 0; j < m_Channel.GetDataDimension(); j++)
										{
											skin[i].Weights[j] = componentsFloatArray[i * m_Channel.GetDataDimension() + j];
										}
									}
									break;
								case 13: //kShaderChannelBlendIndices
									if (skin == null)
									{
										skin = MakeInitializedArray<BoneWeights4>(vertexCount);
									}
									for (int i = 0; i < vertexCount; i++)
									{
										for (int j = 0; j < m_Channel.GetDataDimension(); j++)
										{
											skin[i].BoneIndices[j] = componentsIntArray[i * m_Channel.GetDataDimension() + j];
										}
									}
									break;
							}
						}
						else
						{
							switch (chn)
							{
								case 0: //kShaderChannelVertex
									vertices = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 1: //kShaderChannelNormal
									normals = MeshHelper.FloatArrayToVector3(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 2: //kShaderChannelColor
									colors = MeshHelper.FloatArrayToColorRGBA32(componentsFloatArray);
									break;
								case 3: //kShaderChannelTexCoord0
									uv0 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 4: //kShaderChannelTexCoord1
									uv1 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 5:
									if (version.IsGreaterEqual(5)) //kShaderChannelTexCoord2
									{
										uv2 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									}
									else //kShaderChannelTangent
									{
										tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									}
									break;
								case 6: //kShaderChannelTexCoord3
									uv3 = MeshHelper.FloatArrayToVector2(componentsFloatArray, m_Channel.GetDataDimension());
									break;
								case 7: //kShaderChannelTangent
									tangents = MeshHelper.FloatArrayToVector4(componentsFloatArray, m_Channel.GetDataDimension());
									break;
							}
						}
					}
				}
			}
		}

		public static BoneWeights4[] GenerateSkin(this IVertexData instance, IExportContainer container)
		{
			ChannelInfo weightChannel = instance.Channels[(int)ShaderChannel2018.SkinWeight];
			ChannelInfo indexChannel = instance.Channels[(int)ShaderChannel2018.SkinBoneIndex];
			if (!weightChannel.IsSet())
			{
				return Array.Empty<BoneWeights4>();
			}

			BoneWeights4[] skin = new BoneWeights4[instance.VertexCount];
			int weightStride = instance.Channels.Where(t => t.Stream == weightChannel.Stream).Sum(t => t.GetStride(container.Version));
			int weightStreamOffset = instance.GetStreamOffset(container.Version, weightChannel.Stream);
			int indexStride = instance.Channels.Where(t => t.Stream == indexChannel.Stream).Sum(t => t.GetStride(container.Version));
			int indexStreamOffset = instance.GetStreamOffset(container.Version, indexChannel.Stream);

			using MemoryStream memStream = new MemoryStream(instance.Data);
			using BinaryReader reader = new BinaryReader(memStream);

			int weightCount = System.Math.Min((int)weightChannel.GetDataDimension(), 4);
			int indexCount = System.Math.Min((int)indexChannel.GetDataDimension(), 4);
			float[] weights = new float[System.Math.Max(weightCount, 4)];
			int[] indices = new int[System.Math.Max(indexCount, 4)];
			for (int v = 0; v < instance.VertexCount; v++)
			{
				memStream.Position = weightStreamOffset + v * weightStride + weightChannel.Offset;
				for (int i = 0; i < weightCount; i++)
				{
					weights[i] = reader.ReadSingle();
				}

				memStream.Position = indexStreamOffset + v * indexStride + indexChannel.Offset;
				for (int i = 0; i < indexCount; i++)
				{
					indices[i] = reader.ReadInt32();
				}

				skin[v] = new BoneWeights4(weights[0], weights[1], weights[2], weights[3], indices[0], indices[1], indices[2], indices[3]);
			}
			return skin;
		}

		public static Vector3f_3_5_0_f5[] GenerateVertices(this IVertexData instance, UnityVersion version, ISubMesh submesh)
		{
			IChannelInfo channel = instance.GetChannel(version, ShaderChannel.Vertex);
			if (!channel.IsSet())
			{
				if (AllowUnsetVertexChannel(version))
				{
					return Array.Empty<Vector3f_3_5_0_f5>();
				}
				else
				{
					throw new Exception("Vertices hasn't been found");
				}
			}

			Vector3f_3_5_0_f5[] verts = new Vector3f_3_5_0_f5[submesh.VertexCount];
			int streamStride = instance.Channels.Where(t => t.Stream == channel.Stream).Sum(t => t.GetStride(version));
			int streamOffset = instance.GetStreamOffset(version, channel.Stream);
			using (MemoryStream memStream = new MemoryStream(instance.Data))
			{
				using BinaryReader reader = new BinaryReader(memStream);
				memStream.Position = streamOffset + submesh.FirstVertex * streamStride + channel.Offset;
				for (int v = 0; v < submesh.VertexCount; v++)
				{
					float x = reader.ReadSingle();
					float y = reader.ReadSingle();
					float z = reader.ReadSingle();
					verts[v] = new();
					verts[v].SetValues(x, y, z);
					memStream.Position += streamStride - 12;
				}
			}
			return verts;
		}

		public static int GetStreamStride(this IVertexData instance, UnityVersion version, int stream)
		{
			return instance.Has_Streams() ?
				(int)instance.Streams[stream].GetStride() : instance.Channels.Where(t => t.IsSet() && t.Stream == stream).Sum(t => t.GetStride(version));
		}

		public static int GetStreamSize(this IVertexData instance, UnityVersion version, int stream)
		{
			return instance.GetStreamStride(version, stream) * (int)instance.VertexCount;
		}

		public static int GetStreamOffset(this IVertexData instance, UnityVersion version, int stream)
		{
			int offset = 0;
			for (int i = 0; i < stream; i++)
			{
				offset += instance.GetStreamSize(version, i);
				offset = (offset + (VertexStreamAlign - 1)) & ~(VertexStreamAlign - 1);
			}
			return offset;
		}
		
		private static List<IStreamInfo> GetStreams(this IVertexData instance, UnityVersion version)
		{
			if (instance.HasStreamsInvariant())
			{
				return instance.GetStreamsInvariant();
			}
			int streamCount = instance.Channels.Max(x => x.Stream) + 1;
			List<IStreamInfo> streams = new List<IStreamInfo>(streamCount);
			long offset = 0;
			for (int s = 0; s < streamCount; s++)
			{
				uint chnMask = 0;
				uint stride = 0;
				for (int chn = 0; chn < instance.Channels.Count; chn++)
				{
					ChannelInfo m_Channel = instance.Channels[chn];
					if (m_Channel.Stream == s)
					{
						if (m_Channel.GetDataDimension() > 0)
						{
							chnMask |= 1u << chn;
							stride += m_Channel.GetDataDimension() * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.Format, version));
						}
					}
				}

				StreamInfo_4_0_0_f7 newStream = new StreamInfo_4_0_0_f7
				{
					ChannelMask = chnMask,
					Offset = (uint)offset,
					Stride_Byte = (byte)stride,
					DividerOp = 0,
					Frequency = 0
				};
				streams.Add(newStream);

				offset += instance.VertexCount * stride;
				//static size_t AlignStreamSize (size_t size) { return (size + (kVertexStreamAlign-1)) & ~(kVertexStreamAlign-1); }
				offset = (offset + (16u - 1u)) & ~(16u - 1u);
			}
			return streams;
		}

		private static bool HasStreamsInvariant(this IVertexData instance) => instance.Has_Streams() || instance.Has_Streams_0_();

		private static List<IStreamInfo> GetStreamsInvariant(this IVertexData instance)
		{
			if (instance.Has_Streams())
			{
				return instance.Streams.Select(s => (IStreamInfo)s).ToList();
			}
			else if (instance.Has_Streams_0_())
			{
				return new List<IStreamInfo>()
				{
					instance.Streams_0_,
					instance.Streams_1_!,
					instance.Streams_2_!,
					instance.Streams_3_!
				};
			}
			else
			{
				return new();
			}
		}

		private static IReadOnlyList<ChannelInfo> GetChannels(this IVertexData instance, UnityVersion version)
		{
			if (instance.Has_Channels())
			{
				return instance.Channels;
			}
			AssetList<ChannelInfo> channels = new AssetList<ChannelInfo>(6);
			List<IStreamInfo> streams = instance.GetStreamsInvariant();
			for (int s = 0; s < streams.Count; s++)
			{
				IStreamInfo m_Stream = streams[s];
				BitArray channelMask = new BitArray(new[] { (int)m_Stream.ChannelMask });
				byte offset = 0;
				for (int i = 0; i < 6; i++)
				{
					if (channelMask.Get(i))
					{
						ChannelInfo m_Channel = channels.AddNew();
						m_Channel.Stream = (byte)s;
						m_Channel.Offset = offset;
						switch (i)
						{
							case 0: //kShaderChannelVertex
							case 1: //kShaderChannelNormal
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(3);
								break;
							case 2: //kShaderChannelColor
								m_Channel.Format = 2; //kChannelFormatColor
								m_Channel.SetDataDimension(4);
								break;
							case 3: //kShaderChannelTexCoord0
							case 4: //kShaderChannelTexCoord1
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(2);
								break;
							case 5: //kShaderChannelTangent
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(4);
								break;
						}
						offset += (byte)(m_Channel.GetDataDimension() * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.Format, version)));
					}
				}
			}
			return channels;
		}
		
		private static T[] MakeInitializedArray<T>(int size) where T : new()
		{
			T[] array = new T[size];
			for (int i = 0; i < size; i++)
			{
				array[i] = new();
			}
			return array;
		}
	}
}

```

`AssetRipperCommon/SourceGenExtensions/VirtualAnimationFactory.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Object;
using AssetRipper.Core.IO;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.AnimatorCondition;
using AssetRipper.SourceGenerated.Subclasses.BlendTreeNodeConstant;
using AssetRipper.SourceGenerated.Subclasses.ChildAnimatorState;
using AssetRipper.SourceGenerated.Subclasses.ConditionConstant;
using AssetRipper.SourceGenerated.Subclasses.LayerConstant;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_SelectorStateConstant;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorState_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorTransition_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour_;
using AssetRipper.SourceGenerated.Subclasses.SelectorStateConstant;
using AssetRipper.SourceGenerated.Subclasses.SelectorTransitionConstant;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;
using AssetRipper.SourceGenerated.Subclasses.Vector3f;
using System.Collections.Generic;

namespace AssetRipper.Core.SourceGenExtensions
{
	public static class VirtualAnimationFactory
	{
		public static IBlendTree CreateBlendTree(VirtualSerializedFile virtualFile, IAnimatorController controller, IStateConstant state, int nodeIndex)
		{
			IBlendTree blendTree = virtualFile.CreateAsset<IBlendTree>(ClassIDType.BlendTree);
			blendTree.ObjectHideFlags = HideFlags.HideInHierarchy;

			IBlendTreeNodeConstant node = state.GetBlendTree().NodeArray[nodeIndex].Data;

			blendTree.NameString = "BlendTree";

			blendTree.Childs_C206.Capacity = node.ChildIndices.Length;
			for (int i = 0; i < node.ChildIndices.Length; i++)
			{
				blendTree.Childs_C206.AddNew().SetValues(virtualFile, controller, state, nodeIndex, i);
			}

			if(node.BlendEventID != uint.MaxValue)
			{
				blendTree.BlendParameter_C206.CopyValues(controller.TOS_C91[node.BlendEventID]);
			}
			if(node.BlendEventYID != uint.MaxValue)
			{
				blendTree.BlendParameterY_C206.CopyValues(controller.TOS_C91[node.BlendEventYID]);
			}
			blendTree.MinThreshold_C206 = node.GetMinThreshold();
			blendTree.MaxThreshold_C206 = node.GetMaxThreshold();
			blendTree.UseAutomaticThresholds_C206 = false;
			blendTree.NormalizedBlendValues_C206 = node.BlendDirectData.Data.m_NormalizedBlendValues;
			if (blendTree.Has_BlendType_C206_Int32())
			{
				blendTree.BlendType_C206_Int32 = (int)node.BlendType;
			}
			else
			{
				blendTree.BlendType_C206_UInt32 = node.BlendType;
			}
			return blendTree;
		}

		private static void CreateEntryTransitions(
			AssetList<PPtr_AnimatorTransition_> entryTransitionList,
			IStateMachineConstant stateMachineConstant,
			VirtualSerializedFile file,
			uint ID,
			IReadOnlyList<IAnimatorState> States,
			AssetDictionary<uint, Utf8String> TOS)
		{
			if (stateMachineConstant.Has_SelectorStateConstantArray())
			{
				foreach (OffsetPtr_SelectorStateConstant selectorPtr in stateMachineConstant.SelectorStateConstantArray)
				{
					SelectorStateConstant selector = selectorPtr.Data;
					if (selector.FullPathID == ID && selector.IsEntry)
					{
						for (int i = 0; i < selector.TransitionConstantArray.Count - 1; i++)
						{
							SelectorTransitionConstant selectorTrans = selector.TransitionConstantArray[i].Data;
							IAnimatorTransition transition = CreateAnimatorTransition(file, stateMachineConstant, States, TOS, selectorTrans);
							entryTransitionList.AddNew().CopyValues(transition.SerializedFile.CreatePPtr(transition));
						}
					}
				}
			}
		}

		public static IAnimatorStateMachine CreateAnimatorStateMachine(VirtualSerializedFile virtualFile, IAnimatorController controller, int stateMachineIndex)
		{
			const float StateOffset = 250.0f;

			IAnimatorStateMachine generatedStateMachine = virtualFile.CreateAsset<IAnimatorStateMachine>(ClassIDType.AnimatorStateMachine);
			generatedStateMachine.ObjectHideFlags = HideFlags.HideInHierarchy;

			int layerIndex = controller.Controller_C91.GetLayerIndexByStateMachineIndex(stateMachineIndex);
			ILayerConstant layer = controller.Controller_C91.LayerArray[layerIndex].Data;
			generatedStateMachine.Name.CopyValues(controller.TOS_C91[layer.Binding]);

			IStateMachineConstant stateMachine = controller.Controller_C91.StateMachineArray[stateMachineIndex].Data;

			int stateCount = stateMachine.StateConstantArray.Count;
			int stateMachineCount = 0;
			int count = stateCount + stateMachineCount;
			int side = (int)System.Math.Ceiling(System.Math.Sqrt(count));

			List<IAnimatorState> states = new List<IAnimatorState>();
			if (generatedStateMachine.Has_ChildStates_C1107())
			{
				generatedStateMachine.ChildStates_C1107.Clear();
				generatedStateMachine.ChildStates_C1107.Capacity = stateCount;
			}
			else if (generatedStateMachine.Has_States_C1107())
			{
				generatedStateMachine.States_C1107.Clear();
				generatedStateMachine.States_C1107.Capacity = stateCount;
			}
			for (int y = 0, stateIndex = 0; y < side && stateIndex < stateCount; y++)
			{
				for (int x = 0; x < side && stateIndex < stateCount; x++, stateIndex++)
				{
					Vector3f_3_5_0_f5 position = new Vector3f_3_5_0_f5() { X = x * StateOffset, Y = y * StateOffset };
					IAnimatorState state = CreateAnimatorState(virtualFile, controller, stateMachineIndex, stateIndex, position);

					if (generatedStateMachine.Has_ChildStates_C1107())
					{
						ChildAnimatorState childState = generatedStateMachine.ChildStates_C1107.AddNew();
						childState.Position.CopyValues(position);
						childState.State.CopyValues(state.SerializedFile.CreatePPtr(state));
					}
					else if (generatedStateMachine.Has_States_C1107())
					{
						generatedStateMachine.States_C1107.AddNew().CopyValues(state.SerializedFile.CreatePPtr(state));
					}

					states.Add(state);
				}
			}

#warning TODO: child StateMachines
			//generatedStateMachine.ChildStateMachines_C1107 = new ChildAnimatorStateMachine[stateMachineCount];

			// set destination state for transitions here because all states has become valid only now
			for (int i = 0; i < stateMachine.StateConstantArray.Count; i++)
			{
				IAnimatorState state = states[i];
				IStateConstant stateConstant = stateMachine.StateConstantArray[i].Data;
				
				if (state.Has_Transitions_C1102())
				{
					state.Transitions_C1102.EnsureCapacity(state.Transitions_C1102.Count + stateConstant.TransitionConstantArray.Count);
				}

				for (int j = 0; j < stateConstant.TransitionConstantArray.Count; j++)
				{
					ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[j].Data;
					IAnimatorStateTransition transition = CreateAnimatorStateTransition(virtualFile, stateMachine, states, controller.TOS_C91, transitionConstant);
					if (state.Has_Transitions_C1102())
					{
						state.Transitions_C1102.AddNew().CopyValues(transition.SerializedFile.CreatePPtr(transition));
					}
				}
			}

			if (generatedStateMachine.Has_AnyStateTransitions_C1107())
			{
				generatedStateMachine.AnyStateTransitions_C1107.Clear();
				generatedStateMachine.AnyStateTransitions_C1107.Capacity = stateMachine.AnyStateTransitionConstantArray.Count;
				for (int i = 0; i < stateMachine.AnyStateTransitionConstantArray.Count; i++)
				{
					ITransitionConstant transitionConstant = stateMachine.AnyStateTransitionConstantArray[i].Data;
					IAnimatorStateTransition transition = CreateAnimatorStateTransition(virtualFile, stateMachine, states, controller.TOS_C91, transitionConstant);
					generatedStateMachine.AnyStateTransitions_C1107.AddNew().CopyValues(transition.SerializedFile.CreatePPtr(transition));
				}
			}

			CreateEntryTransitions(generatedStateMachine.EntryTransitions_C1107, stateMachine, virtualFile, layer.Binding, states, controller.TOS_C91);

#warning TEMP: remove comment when AnimatorStateMachine's child StateMachines has been implemented
			//StateMachineBehaviours = controller.GetStateBehaviours(layerIndex);
			generatedStateMachine.StateMachineBehaviours_C1107?.Clear();

			generatedStateMachine.AnyStatePosition_C1107.SetValues(0.0f, -StateOffset, 0.0f);
			generatedStateMachine.EntryPosition_C1107?.SetValues(StateOffset, -StateOffset, 0.0f);
			generatedStateMachine.ExitPosition_C1107?.SetValues(2.0f * StateOffset, -StateOffset, 0.0f);
			generatedStateMachine.ParentStateMachinePosition_C1107.SetValues(0.0f, -2.0f * StateOffset, 0.0f);

			if (generatedStateMachine.Has_ChildStates_C1107() && generatedStateMachine.ChildStates_C1107.Count > 0)
			{
				PPtr_AnimatorState_ defaultStatePPtr = generatedStateMachine.ChildStates_C1107[(int)stateMachine.DefaultState].State;
				
				if (generatedStateMachine.Has_DefaultState_C1107_PPtr_State_())
				{
					generatedStateMachine.DefaultState_C1107_PPtr_State_.CopyValues(defaultStatePPtr);
				}
				else if (generatedStateMachine.Has_DefaultState_C1107_PPtr_AnimatorState_())
				{
					generatedStateMachine.DefaultState_C1107_PPtr_AnimatorState_.CopyValues(defaultStatePPtr);
				}
			}

			return generatedStateMachine;
		}

		public static IAnimatorState CreateAnimatorState(VirtualSerializedFile virtualFile, IAnimatorController controller, int stateMachineIndex, int stateIndex, Vector3f_3_5_0_f5 position)
		{
			IAnimatorState generatedState = virtualFile.CreateAsset<IAnimatorState>(ClassIDType.AnimatorState);
			generatedState.ObjectHideFlags = HideFlags.HideInHierarchy;

			AssetDictionary<uint, Utf8String> TOS = controller.TOS_C91;
			if (!TOS.ContainsKey(0))
			{
				AssetDictionary<uint, Utf8String> tos = new AssetDictionary<uint, Utf8String>() { { 0, new Utf8String() } };
				tos.AddRange(controller.TOS_C91);
				TOS = tos;
			}
			IStateMachineConstant stateMachine = controller.Controller_C91.StateMachineArray[stateMachineIndex].Data;
			IStateConstant state = stateMachine.StateConstantArray[stateIndex].Data;

			generatedState.Name.CopyValues(TOS[state.NameID]);

			generatedState.Speed_C1102 = state.Speed;
			generatedState.CycleOffset_C1102 = state.CycleOffset;

			// skip Transitions because not all state exists at this moment

			if (generatedState.Has_StateMachineBehaviours_C1102())
			{
				// exclude StateMachine's behaviours
				int layerIndex = controller.Controller_C91.GetLayerIndexByStateMachineIndex(stateMachineIndex);
				PPtr_MonoBehaviour__5_0_0_f4[] machineBehaviours = controller.GetStateBehaviours(layerIndex);
				PPtr_MonoBehaviour__5_0_0_f4[] stateBehaviours = controller.GetStateBehaviours(stateMachineIndex, stateIndex);
				PPtr_MonoBehaviour__5_0_0_f4[] behaviours = stateBehaviours;
#warning TEMP: remove comment when AnimatorStateMachine's child StateMachines has been implemented
				//List<PPtr_MonoBehaviour__5_0_0_f4> behaviours = new List<PPtr_MonoBehaviour__5_0_0_f4>(stateBehaviours.Length);
				//foreach (PPtr_MonoBehaviour__5_0_0_f4 ptr in stateBehaviours)
				//{
				//if (!machineBehaviours.Contains(ptr))
				//{
				//	behaviours.Add(ptr);
				//}
				//}
				generatedState.StateMachineBehaviours_C1102.Clear();
				generatedState.StateMachineBehaviours_C1102.AddRange(behaviours);
				//generatedState.StateMachineBehaviours_C1102.AddRange(behaviours.ToArray());
			}

			generatedState.Position_C1102.CopyValues(position);
			generatedState.IKOnFeet_C1102 = state.IKOnFeet;
			generatedState.WriteDefaultValues_C1102 = state.GetWriteDefaultValues();
			generatedState.Mirror_C1102 = state.Mirror;
			generatedState.SpeedParameterActive_C1102 = state.SpeedParamID > 0;
			generatedState.MirrorParameterActive_C1102 = state.MirrorParamID > 0;
			generatedState.CycleOffsetParameterActive_C1102 = state.CycleOffsetParamID > 0;
			generatedState.TimeParameterActive_C1102 = state.TimeParamID > 0;

			generatedState.Motion_C1102?.CopyValues(state.CreateMotion(virtualFile, controller, 0));

			generatedState.Tag_C1102.CopyValues(TOS[state.TagID]);
			generatedState.SpeedParameter_C1102?.CopyValues(TOS[state.SpeedParamID]);
			generatedState.MirrorParameter_C1102?.CopyValues(TOS[state.MirrorParamID]);
			generatedState.CycleOffsetParameter_C1102?.CopyValues(TOS[state.CycleOffsetParamID]);
			generatedState.TimeParameter_C1102?.CopyValues(TOS[state.TimeParamID]);

			return generatedState;
		}

		public static IAnimatorStateTransition CreateAnimatorStateTransition(
			VirtualSerializedFile virtualFile,
			IStateMachineConstant StateMachine,
			IReadOnlyList<IAnimatorState> States,
			AssetDictionary<uint, Utf8String> TOS, 
			ITransitionConstant Transition)
		{
			IAnimatorStateTransition animatorStateTransition = virtualFile.CreateAsset<IAnimatorStateTransition>(ClassIDType.AnimatorStateTransition);
			animatorStateTransition.ObjectHideFlags_C1101 = (uint)HideFlags.HideInHierarchy;

			animatorStateTransition.Conditions_C1101.Capacity = Transition.ConditionConstantArray.Count;
			for (int i = 0; i < Transition.ConditionConstantArray.Count; i++)
			{
				ConditionConstant conditionConstant = Transition.ConditionConstantArray[i].Data;
				if (conditionConstant.ConditionMode != (int)Classes.AnimatorTransition.AnimatorConditionMode.ExitTime)
				{
					IAnimatorCondition condition = animatorStateTransition.Conditions_C1101.AddNew();
					condition.ConditionMode = (int)(Classes.AnimatorTransition.AnimatorConditionMode)conditionConstant.ConditionMode;
					condition.ConditionEvent.CopyValues(TOS[conditionConstant.EventID]);
					condition.EventTreshold = conditionConstant.EventThreshold;
				}
			}

			IAnimatorState? state = GetDestinationState(Transition.DestinationState, StateMachine, States);
			if (state is not null)
			{
				if (animatorStateTransition.Has_DstState_C1101_PPtr_State_())
				{
					animatorStateTransition.DstState_C1101_PPtr_State_.CopyValues(state.SerializedFile.CreatePPtr(state));
				}
				else if (animatorStateTransition.Has_DstState_C1101_PPtr_AnimatorState_())
				{
					animatorStateTransition.DstState_C1101_PPtr_AnimatorState_.CopyValues(state.SerializedFile.CreatePPtr(state));
				}
			}

			animatorStateTransition.Name.CopyValues(TOS[Transition.UserID]);
			animatorStateTransition.IsExit_C1101 = Transition.IsExit();

			animatorStateTransition.TransitionDuration_C1101 = Transition.TransitionDuration;
			animatorStateTransition.TransitionOffset_C1101 = Transition.TransitionOffset;
			animatorStateTransition.ExitTime_C1101 = Transition.GetExitTime();
			animatorStateTransition.HasExitTime_C1101 = Transition.GetHasExitTime();
			animatorStateTransition.HasFixedDuration_C1101 = Transition.GetHasFixedDuration();
			animatorStateTransition.InterruptionSource_C1101 = (int)Transition.GetInterruptionSource();
			animatorStateTransition.OrderedInterruption_C1101 = Transition.OrderedInterruption;
			animatorStateTransition.CanTransitionToSelf_C1101 = Transition.CanTransitionToSelf;

			return animatorStateTransition;
		}

		public static IAnimatorTransition CreateAnimatorTransition(
			VirtualSerializedFile virtualFile,
			IStateMachineConstant StateMachine,
			IReadOnlyList<IAnimatorState> States,
			AssetDictionary<uint, Utf8String> TOS,
			SelectorTransitionConstant Transition)
		{
			IAnimatorTransition animatorTransition = virtualFile.CreateAsset<IAnimatorTransition>(ClassIDType.AnimatorTransition);
			animatorTransition.ObjectHideFlags_C1109 = (uint)HideFlags.HideInHierarchy;

			animatorTransition.Conditions_C1109.Capacity = Transition.ConditionConstantArray.Count;
			for (int i = 0; i < Transition.ConditionConstantArray.Count; i++)
			{
				ConditionConstant conditionConstant = Transition.ConditionConstantArray[i].Data;
				if (conditionConstant.ConditionMode != (int)Classes.AnimatorTransition.AnimatorConditionMode.ExitTime)
				{
					IAnimatorCondition condition = animatorTransition.Conditions_C1109.AddNew();
					condition.ConditionMode = (int)(Classes.AnimatorTransition.AnimatorConditionMode)conditionConstant.ConditionMode;
					condition.ConditionEvent.CopyValues(TOS[conditionConstant.EventID]);
					condition.EventTreshold = conditionConstant.EventThreshold;
				}
			}

			IAnimatorState? state = GetDestinationState(Transition.Destination, StateMachine, States);
			if(state is not null)
			{
				animatorTransition.DstState_C1109.CopyValues(state.SerializedFile.CreatePPtr(state));
			}
			
			return animatorTransition;
		}

		private static IAnimatorState? GetDestinationState(uint destinationState, IStateMachineConstant stateMachine, IReadOnlyList<IAnimatorState> states)
		{
			if (destinationState == uint.MaxValue)
			{
				return null;
			}
			else if (destinationState >= 30000)
			{
				// Entry and Exit states
				uint stateIndex = destinationState % 30000;
				if (stateIndex == 0 || stateIndex == 1)
				{
					// base layer node. Default value is valid
					return null;
				}
				else
				{
					SelectorStateConstant selectorState = stateMachine.SelectorStateConstantArray[(int)stateIndex].Data;
#warning		HACK: take default Entry destination. TODO: child StateMachines
					SelectorTransitionConstant selectorTransition = selectorState.TransitionConstantArray[selectorState.TransitionConstantArray.Count - 1].Data;
					return GetDestinationState(selectorTransition.Destination, stateMachine, states);
				}
			}
			else
			{
				return states[(int)destinationState];
			}
		}
	}
}

```

`AssetRipperCommon/Structure/GameStructure/GameStructure.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.Structure.GameStructure.Platforms;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;

namespace AssetRipper.Core.Structure.GameStructure
{
	public sealed class GameStructure : IDisposable
	{
		public GameCollection? FileCollection { get; private set; }
		public ProjectExporter Exporter { get; private set; } = new ProjectExporter();
		public PlatformGameStructure? PlatformStructure { get; private set; }
		public PlatformGameStructure? MixedStructure { get; private set; }

		private GameStructure() { }

		[MemberNotNullWhen(true, nameof(FileCollection))]
		public bool IsValid => FileCollection is not null;

		public string? Name => PlatformStructure?.Name ?? MixedStructure?.Name;

		public static GameStructure Load(IEnumerable<string> paths, CoreConfiguration configuration) => Load(paths, configuration, null);
		public static GameStructure Load(IEnumerable<string> paths, CoreConfiguration configuration, LayoutInfo? layinfo)
		{
			List<string> toProcess = Preprocessor.Process(paths);
			if (toProcess.Count == 0)
			{
				throw new ArgumentException("Game files not found", nameof(paths));
			}

			GameStructure structure = new GameStructure();//an empty constructor
			structure.Load(toProcess, configuration, layinfo);
			return structure;
		}

		private void Load(List<string> paths, CoreConfiguration configuration, LayoutInfo? layinfo)
		{
			Logger.SendStatusChange("loading_step_detect_platform");
			PlatformChecker.CheckPlatform(paths, out PlatformGameStructure? platformStructure, out MixedGameStructure? mixedStructure);
			PlatformStructure = platformStructure;
			PlatformStructure?.CollectFiles(configuration.IgnoreStreamingAssets);
			MixedStructure = mixedStructure;
			//The PlatformGameStructure constructor adds all the paths to the Assemblies and Files dictionaries
			//No bundles or assemblies have been loaded yet

			using GameStructureProcessor processor = new GameStructureProcessor();
			//This block adds all the files to the processor
			//It determines each of their file types, but still no extraction
			if (PlatformStructure != null)
			{
				ProcessPlatformStructure(processor, PlatformStructure);
			}

			if (MixedStructure != null)
			{
				ProcessPlatformStructure(processor, MixedStructure);
			}

			processor.AddDependencySchemes(RequestDependency);

			if (!processor.IsValid)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, "The game structure processor could not find any valid assets.");
			}
			else
			{
				Logger.SendStatusChange("loading_step_initialize_layout");

				//Assigns a layout if one wasn't already provided
				layinfo ??= processor.GetLayoutInfo();

				InitializeGameCollection(configuration, layinfo);

				Logger.SendStatusChange("loading_step_begin_scheme_processing");

				//Creates new objects for each scheme in the collection
				processor.ProcessSchemes(FileCollection);
			}
		}

		public void Export(CoreConfiguration options)
		{
			Logger.Info(LogCategory.Export, $"Game files have these Unity versions:{GetListOfVersions()}");
			UnityVersion version = FileCollection.GameFiles.Values.Max(t => t.Version);
			Logger.Info(LogCategory.Export, $"Exporting to Unity version {version}");
			options.SetProjectSettings(version, BuildTarget.NoTarget, TransferInstructionFlags.NoTransferInstructionFlags);
			Exporter.Export(FileCollection, options);
		}

		private string GetListOfVersions()
		{
			StringBuilder sb = new();
			foreach(UnityVersion version in FileCollection.GameFiles.Values.DistinctBy(t => t.Version).Select(s => s.Version))
			{
				sb.Append(' ');
				sb.Append(version.ToString());
			}
			return sb.ToString();
		}

		/// <summary>Attempts to find the path for the dependency with that name.</summary>
		public string? RequestDependency(string dependency)
		{
			if (PlatformStructure != null)
			{
				string? path = PlatformStructure.RequestDependency(dependency);
				if (path != null)
				{
					return path;
				}
			}
			if (MixedStructure != null)
			{
				string? path = MixedStructure.RequestDependency(dependency);
				if (path != null)
				{
					return path;
				}
			}
			return null;
		}

		/// <summary>Processes all files, gets their file type, and adds it to one big list.</summary>
		private static void ProcessPlatformStructure(GameStructureProcessor processor, PlatformGameStructure structure)
		{
			foreach (KeyValuePair<string, string> file in structure.Files)
			{
				processor.AddScheme(file.Value, file.Key);
			}
		}

		private void InitializeGameCollection(CoreConfiguration configuration, LayoutInfo layout)
		{
			Logger.SendStatusChange("loading_step_create_file_collection");

			//Sets its fields and creates the Project Exporter
			FileCollection = new GameCollection(layout);

			FileCollection.ResourceCallback = RequestResource;

			ScriptingBackend scriptBackend = GetScriptingBackend(configuration.DisableScriptImport);
			Logger.Info(LogCategory.Import, $"Files use the '{scriptBackend}' scripting backend.");

			switch (scriptBackend)
			{
				case ScriptingBackend.Mono:
					FileCollection.AssemblyManager = new MonoManager(layout, OnRequestAssembly);
					break;
				case ScriptingBackend.IL2Cpp:
					FileCollection.AssemblyManager = new IL2CppManager(layout, OnRequestAssembly, configuration.ScriptContentLevel);
					break;
				case ScriptingBackend.Unknown:
					FileCollection.AssemblyManager = new BaseManager(layout, OnRequestAssembly);
					break;
			}

			Logger.SendStatusChange("loading_step_load_assemblies");

			try
			{
				//Loads any Mono or IL2Cpp assemblies
				FileCollection.AssemblyManager.Initialize(
					PlatformStructure ?? MixedStructure ?? throw new Exception("No platform structure"));
			}
			catch (Exception ex)
			{
				Logger.Error(LogCategory.Import, "Could not initialize assembly manager. Switching to the 'Unknown' scripting backend.");
				Logger.Error(ex);
				FileCollection.AssemblyManager = new BaseManager(layout, OnRequestAssembly);
			}
		}

		private ScriptingBackend GetScriptingBackend(bool disableScriptImport)
		{
			if (disableScriptImport)
			{
				Logger.Info(LogCategory.Import, "Script import disabled by settings.");
				return ScriptingBackend.Unknown;
			}
			if (PlatformStructure != null)
			{
				ScriptingBackend backend = PlatformStructure.Backend;
				if (backend != ScriptingBackend.Unknown)
				{
					return backend;
				}
			}
			if (MixedStructure != null)
			{
				ScriptingBackend backend = MixedStructure.Backend;
				if (backend != ScriptingBackend.Unknown)
				{
					return backend;
				}
			}
			return ScriptingBackend.Unknown;
		}

		private void OnRequestAssembly(string assembly)
		{
			string assemblyName = $"{assembly}.dll";
			if (FileCollection.TryGetResourceFile(assemblyName, out ResourceFile? resFile) && resFile != null)
			{
				resFile.Stream.Position = 0;
				FileCollection.AssemblyManager.Read(resFile.Stream, assemblyName);
			}
			else
			{
				string? path = RequestAssembly(assembly);
				if (path == null)
				{
					Logger.Log(LogType.Warning, LogCategory.Import, $"Assembly '{assembly}' hasn't been found");
					return;
				}
				FileCollection.AssemblyManager.Load(path);
			}
			Logger.Info(LogCategory.Import, $"Assembly '{assembly}' has been loaded");
		}

		public string? RequestAssembly(string assembly)
		{
			if (PlatformStructure != null)
			{
				string? assemblyPath = PlatformStructure.RequestAssembly(assembly);
				if (assemblyPath != null)
				{
					return assemblyPath;
				}
			}
			if (MixedStructure != null)
			{
				string? assemblyPath = MixedStructure.RequestAssembly(assembly);
				if (assemblyPath != null)
				{
					return assemblyPath;
				}
			}
			return null;
		}

		public string? RequestResource(string resource)
		{
			if (PlatformStructure != null)
			{
				string? path = PlatformStructure.RequestResource(resource);
				if (path != null)
				{
					return path;
				}
			}
			if (MixedStructure != null)
			{
				string? path = MixedStructure.RequestResource(resource);
				if (path != null)
				{
					return path;
				}
			}
			return null;
		}

		public void Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}
		private void Dispose(bool _) => FileCollection?.Dispose();
		~GameStructure() => Dispose(false);
	}
}

```

`AssetRipperCommon/Utils/TypeTreeHelper.cs`:

```cs
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;
using System.Collections.Generic;
using System.Collections.Specialized;
using System.IO;
using System.Text;

namespace AssetRipper.Core.Utils
{
	public static class TypeTreeHelper
	{
		public static string ReadTypeString(TypeTree m_Type, BinaryReader reader)
		{
			StringBuilder? sb = new StringBuilder();
			List<TypeTreeNode>? m_Nodes = m_Type.Nodes;
			for (int i = 0; i < m_Nodes.Count; i++)
			{
				ReadStringValue(sb, m_Nodes, reader, ref i);
			}
			return sb.ToString();
		}

		private static void ReadStringValue(StringBuilder sb, List<TypeTreeNode> m_Nodes, BinaryReader reader, ref int i)
		{
			TypeTreeNode? m_Node = m_Nodes[i];
			byte level = m_Node.Level;
			string? varTypeStr = m_Node.Type;
			string? varNameStr = m_Node.Name;
			object? value = null;
			bool append = true;
			bool align = m_Node.MetaFlag.IsAlignBytes();
			switch (varTypeStr)
			{
				case "SInt8":
					value = reader.ReadSByte();
					break;
				case "UInt8":
				case "char":
					value = reader.ReadByte();
					break;
				case "short":
				case "SInt16":
					value = reader.ReadInt16();
					break;
				case "UInt16":
				case "unsigned short":
					value = reader.ReadUInt16();
					break;
				case "int":
				case "SInt32":
					value = reader.ReadInt32();
					break;
				case "UInt32":
				case "unsigned int":
				case "Type*":
					value = reader.ReadUInt32();
					break;
				case "long long":
				case "SInt64":
					value = reader.ReadInt64();
					break;
				case "UInt64":
				case "unsigned long long":
				case "FileSize":
					value = reader.ReadUInt64();
					break;
				case "float":
					value = reader.ReadSingle();
					break;
				case "double":
					value = reader.ReadDouble();
					break;
				case "bool":
					value = reader.ReadBoolean();
					break;
				case "string":
					append = false;
					string? str = reader.ReadAlignedString();
					sb.AppendFormat("{0}{1} {2} = \"{3}\"\r\n", (new string('\t', level)), varTypeStr, varNameStr, str);
					i += 3;
					break;
				case "map":
					{
						if ((m_Nodes[i + 1].MetaFlag.IsAlignBytes()))
						{
							align = true;
						}

						append = false;
						sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
						sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 1)), "Array", "Array");
						int size = reader.ReadInt32();
						sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level + 1)), "int", "size", size);
						List<TypeTreeNode>? map = GetNodes(m_Nodes, i);
						i += map.Count - 1;
						List<TypeTreeNode>? first = GetNodes(map, 4);
						int next = 4 + first.Count;
						List<TypeTreeNode>? second = GetNodes(map, next);
						for (int j = 0; j < size; j++)
						{
							sb.AppendFormat("{0}[{1}]\r\n", (new string('\t', level + 2)), j);
							sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 2)), "pair", "data");
							int tmp1 = 0;
							int tmp2 = 0;
							ReadStringValue(sb, first, reader, ref tmp1);
							ReadStringValue(sb, second, reader, ref tmp2);
						}
						break;
					}
				case "TypelessData":
					{
						append = false;
						int size = reader.ReadInt32();
						reader.ReadBytes(size);
						i += 2;
						sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
						sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level)), "int", "size", size);
						break;
					}
				default:
					{
						if (i < m_Nodes.Count - 1 && m_Nodes[i + 1].Type == "Array") //Array
						{
							if (m_Nodes[i + 1].MetaFlag.IsAlignBytes())
							{
								align = true;
							}

							append = false;
							sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
							sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level + 1)), "Array", "Array");
							int size = reader.ReadInt32();
							sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level + 1)), "int", "size", size);
							List<TypeTreeNode>? vector = GetNodes(m_Nodes, i);
							i += vector.Count - 1;
							for (int j = 0; j < size; j++)
							{
								sb.AppendFormat("{0}[{1}]\r\n", (new string('\t', level + 2)), j);
								int tmp = 3;
								ReadStringValue(sb, vector, reader, ref tmp);
							}
							break;
						}
						else //Class
						{
							append = false;
							sb.AppendFormat("{0}{1} {2}\r\n", (new string('\t', level)), varTypeStr, varNameStr);
							List<TypeTreeNode>? @class = GetNodes(m_Nodes, i);
							i += @class.Count - 1;
							for (int j = 1; j < @class.Count; j++)
							{
								ReadStringValue(sb, @class, reader, ref j);
							}
							break;
						}
					}
			}
			if (append)
			{
				sb.AppendFormat("{0}{1} {2} = {3}\r\n", (new string('\t', level)), varTypeStr, varNameStr, value);
			}

			if (align)
			{
				reader.AlignStream();
			}
		}

		public static OrderedDictionary ReadType(TypeTree m_Types, BinaryReader reader)
		{
			OrderedDictionary? obj = new OrderedDictionary();
			List<TypeTreeNode>? m_Nodes = m_Types.Nodes;
			for (int i = 1; i < m_Nodes.Count; i++)
			{
				TypeTreeNode? m_Node = m_Nodes[i];
				string? varNameStr = m_Node.Name;
				obj[varNameStr] = ReadValue(m_Nodes, reader, ref i);
			}
			return obj;
		}

		private static object ReadValue(List<TypeTreeNode> m_Nodes, BinaryReader reader, ref int i)
		{
			TypeTreeNode? m_Node = m_Nodes[i];
			string? varTypeStr = m_Node.Type;
			object value;
			bool align = (m_Node.MetaFlag.IsAlignBytes());
			switch (varTypeStr)
			{
				case "SInt8":
					value = reader.ReadSByte();
					break;
				case "UInt8":
				case "char":
					value = reader.ReadByte();
					break;
				case "short":
				case "SInt16":
					value = reader.ReadInt16();
					break;
				case "UInt16":
				case "unsigned short":
					value = reader.ReadUInt16();
					break;
				case "int":
				case "SInt32":
					value = reader.ReadInt32();
					break;
				case "UInt32":
				case "unsigned int":
				case "Type*":
					value = reader.ReadUInt32();
					break;
				case "long long":
				case "SInt64":
					value = reader.ReadInt64();
					break;
				case "UInt64":
				case "unsigned long long":
				case "FileSize":
					value = reader.ReadUInt64();
					break;
				case "float":
					value = reader.ReadSingle();
					break;
				case "double":
					value = reader.ReadDouble();
					break;
				case "bool":
					value = reader.ReadBoolean();
					break;
				case "string":
					value = reader.ReadAlignedString();
					i += 3;
					break;
				case "map":
					{
						if (m_Nodes[i + 1].MetaFlag.IsAlignBytes())
						{
							align = true;
						}

						List<TypeTreeNode>? map = GetNodes(m_Nodes, i);
						i += map.Count - 1;
						List<TypeTreeNode>? first = GetNodes(map, 4);
						int next = 4 + first.Count;
						List<TypeTreeNode>? second = GetNodes(map, next);
						int size = reader.ReadInt32();
						List<KeyValuePair<object, object>>? dic = new List<KeyValuePair<object, object>>(size);
						for (int j = 0; j < size; j++)
						{
							int tmp1 = 0;
							int tmp2 = 0;
							dic.Add(new KeyValuePair<object, object>(ReadValue(first, reader, ref tmp1), ReadValue(second, reader, ref tmp2)));
						}
						value = dic;
						break;
					}
				case "TypelessData":
					{
						int size = reader.ReadInt32();
						value = reader.ReadBytes(size);
						i += 2;
						break;
					}
				default:
					{
						if (i < m_Nodes.Count - 1 && m_Nodes[i + 1].Type == "Array") //Array
						{
							if ((m_Nodes[i + 1].MetaFlag.IsAlignBytes()))
							{
								align = true;
							}

							List<TypeTreeNode>? vector = GetNodes(m_Nodes, i);
							i += vector.Count - 1;
							int size = reader.ReadInt32();
							List<object>? list = new List<object>(size);
							for (int j = 0; j < size; j++)
							{
								int tmp = 3;
								list.Add(ReadValue(vector, reader, ref tmp));
							}
							value = list;
							break;
						}
						else //Class
						{
							List<TypeTreeNode>? @class = GetNodes(m_Nodes, i);
							i += @class.Count - 1;
							OrderedDictionary? obj = new OrderedDictionary();
							for (int j = 1; j < @class.Count; j++)
							{
								TypeTreeNode? classmember = @class[j];
								string? name = classmember.Name;
								obj[name] = ReadValue(@class, reader, ref j);
							}
							value = obj;
							break;
						}
					}
			}
			if (align)
			{
				reader.AlignStream();
			}

			return value;
		}

		private static List<TypeTreeNode> GetNodes(List<TypeTreeNode> m_Nodes, int index)
		{
			List<TypeTreeNode>? nodes = new List<TypeTreeNode>();
			nodes.Add(m_Nodes[index]);
			byte level = m_Nodes[index].Level;
			for (int i = index + 1; i < m_Nodes.Count; i++)
			{
				TypeTreeNode? member = m_Nodes[i];
				byte level2 = member.Level;
				if (level2 <= level)
				{
					return nodes;
				}
				nodes.Add(member);
			}
			return nodes;
		}
	}
}

```

`AssetRipperConsole/App.config`:

```config
<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
    </startup>
    <runtime>
      <AppContextSwitchOverrides value="Switch.System.IO.UseLegacyPathHandling=false;Switch.System.IO.BlockLongPaths=false"/>
    </runtime>
</configuration>

```

`AssetRipperConsole/App.manifest`:

```manifest
<?xml version="1.0" encoding="utf-8"?>
<assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1">
  
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel level="asInvoker" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
			<longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  
</assembly>

```

`AssetRipperConsole/AssetRipperConsole.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>AssetRipperConsole</AssemblyName>
		<RootNamespace>AssetRipper.Console</RootNamespace>
		<OutputPath>..\Bins\AssetRipperConsole\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipperConsole\$(Configuration)\</IntermediateOutputPath>
		<Configurations>DebugWindows;ReleaseWindows;DebugMac;ReleaseMac;DebugLinux;ReleaseLinux</Configurations>
		<Platforms>x64</Platforms>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='DebugMac' or '$(Configuration)'=='DebugLinux'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<None Remove="App.config" />
		<None Remove="App.manifest" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="CommandLineParser" Version="2.9.1" />
		<PackageReference Include="System.Security.AccessControl" Version="6.0.0" />
		<PackageReference Include="System.Security.Principal.Windows" Version="5.0.0" />
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperLibrary\AssetRipperLibrary.csproj" />
	</ItemGroup>

</Project>

```

`AssetRipperConsole/Directory.Build.props`:

```props
<Project>

  <PropertyGroup>
    <BaseIntermediateOutputPath>..\Bins\obj\core\</BaseIntermediateOutputPath>
  </PropertyGroup>
  
</Project>
```

`AssetRipperConsole/Program.cs`:

```cs
using AssetRipper.Core.IO.MultiFile;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Utils;
using AssetRipper.Library;
using CommandLine;
using System;
using System.Collections.Generic;
using System.IO;

namespace AssetRipper.Console
{
	public class Program
	{
		private const string DefaultLogFileName = "AssetRipperConsole.log";

		internal class Options
		{
			[Value(0, Required = true, HelpText = "Input files or directory to export.")]
			public IReadOnlyList<string> FilesToExport { get; set; }

			[Option('o', "output", HelpText = "Directory to export to. Will be cleared if already exists.")]
			public DirectoryInfo OutputDirectory { get; set; }

			[Option("logFile", HelpText = "(Default: " + DefaultLogFileName + ") File to log to.")]
			public FileInfo LogFile { get; set; }

			[Option('v', "verbose", Default = false, HelpText = "Verbose logging output.")]
			public bool verbose { get; set; }

			[Option('q', "quit", Default = false, HelpText = "Close console after export.")]
			public bool Quit { get; set; }
		}

		public static void Main(string[] args)
		{
			CommandLine.Parser.Default.ParseArguments<Options>(args)
				.WithParsed(options =>
				{
					if (ValidateOptions(options))
					{
						Run(options);
					}
					else
					{
						Environment.ExitCode = 1;
					}

					if (!options.Quit)
					{
						System.Console.ReadKey();
					}
				});
		}

		private static bool ValidateOptions(Options options)
		{
			foreach (string arg in options.FilesToExport)
			{
				if (MultiFileStream.Exists(arg))
				{
					continue;
				}

				if (Directory.Exists(arg))
				{
					continue;
				}

				System.Console.WriteLine(MultiFileStream.IsMultiFile(arg)
					? $"File '{arg}' doesn't have all parts for combining"
					: $"Neither file nor directory with path '{arg}' exists");

				return false;
			}

			try
			{
				if (options.LogFile == null)
				{
					options.LogFile = new FileInfo(ExecutingDirectory.Combine(DefaultLogFileName));
				}

				if (options.OutputDirectory == null)
				{
					options.OutputDirectory = new DirectoryInfo(ExecutingDirectory.Combine("Ripped"));
				}
			}
			catch (Exception ex)
			{
				System.Console.WriteLine($"Failed to initialize the output and log paths.");
				System.Console.WriteLine(ex.ToString());
				return false;
			}

			return true;
		}

		private static void Run(Options options)
		{
			Logger.AllowVerbose = options.verbose;
			Logger.Add(new ConsoleLogger(false));
			Logger.Add(new FileLogger(options.LogFile.FullName));
			Logger.LogSystemInformation("AssetRipper Console Version");

			try
			{
				Ripper ripper = new Ripper();
				ripper.Settings.LogConfigurationValues();
				ripper.Load(options.FilesToExport);
				PrepareExportDirectory(options.OutputDirectory.FullName);
				ripper.ExportProject(options.OutputDirectory.FullName);
			}
			catch (Exception ex)
			{
				Logger.Log(LogType.Error, LogCategory.General, ex.ToString());
			}
		}

		private static void PrepareExportDirectory(string path)
		{
			if (Directory.Exists(path))
			{
				Logger.Info("Clearing export directory...");
				Directory.Delete(path, true);
			}
		}
	}
}

```

`AssetRipperConsole/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle(AssetRipper.Core.BuildInfo.ConsoleName)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(AssetRipper.Core.BuildInfo.Author)]
[assembly: AssemblyProduct(AssetRipper.Core.BuildInfo.ConsoleName)]
[assembly: AssemblyCopyright(AssetRipper.Core.BuildInfo.CopyRight)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: AssemblyVersion(AssetRipper.Core.BuildInfo.Version)]
[assembly: AssemblyFileVersion(AssetRipper.Core.BuildInfo.Version)]

```

`AssetRipperConsole/Properties/PublishProfiles/linux_console.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseLinux</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipperConsole_linux64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>linux-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperConsole/Properties/PublishProfiles/mac_console.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseMac</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipperConsole_mac64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>osx-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperConsole/Properties/PublishProfiles/windows_console.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseWindows</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipperConsole_win64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishReadyToRun>False</PublishReadyToRun>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperConsole/README.md`:

```md
# AssetRipperConsole

This is a cross-platform command line application for extracting game assets.

## Usage

Drag and drop resource file(s) or/and folder(s) onto the executable to retrieve the assets. 

Alternatively, use the command prompt / terminal to execute it. For example, on linux:
```
./AssetRipperConsole yourBundle.unity3d
```

While running, it will automaticly try to find resource dependencies, create a 'Ripped' folder, and extract all supported assets into the created directory.

## Command Line Arguments
```
  -o, --output    Directory to export to. Will be cleared if already exists.

  --logFile       (Default: AssetRipperConsole.log) File to log to.

  -q, --quit      (Default: false) Close console after export.

  --help          Display this help screen.

  --version       Display version information.

  value pos. 0    Required. Input files or directory to export.
```

## Platform Limitations

Although this is a cross-platform application, some exporters (such as audio, images, and decompiled shaders) are windows-only. On other platforms, these assets will be outputted in the native Unity format.

```

`AssetRipperCore/AssetRipperCore.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>AssetRipperCore</AssemblyName>
		<RootNamespace>AssetRipper.Core</RootNamespace>
		<OutputPath>..\Bins\AssetRipperCore\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipperCore\$(Configuration)\</IntermediateOutputPath>
		<Copyright>Copyright ©  2022</Copyright>
		<Authors>ds5678</Authors>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<Platforms>AnyCPU</Platforms>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='Debug'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperCommon\AssetRipperCommon.csproj" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="AssetRipper.SourceGenerated">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>../Libraries/AssetRipper.SourceGenerated.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

</Project>

```

`AssetRipperCore/Classes/Component.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes
{
	public abstract class Component : EditorExtension, IComponent
	{
		protected Component(LayoutInfo layout) : base(layout) { }

		protected Component(AssetInfo assetInfo) : base(assetInfo) { }

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			GameObject.Read(reader);
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			GameObject.Write(writer);
		}

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}

			yield return context.FetchDependency(GameObject, GameObjectName);
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			node.Add(GameObjectName, GameObject.ExportYaml(container));
			return node;
		}

		public override string ExportExtension => throw new NotSupportedException();

		public PPtr<GameObject.GameObject> GameObject = new();

		public PPtr<GameObject.IGameObject> GameObjectPtr => GameObject.CastTo<GameObject.IGameObject>();

		public const string GameObjectName = "m_GameObject";
	}
}

```

`AssetRipperCore/Classes/EditorExtension.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.PrefabInstance;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes
{
	public abstract class EditorExtension : Object.Object, IEditorExtension
	{
		protected EditorExtension(LayoutInfo layout) : base(layout) { }

		protected EditorExtension(AssetInfo assetInfo) : base(assetInfo) { }

		/// <summary>
		/// Less than 3.5.0 and Not Release
		/// </summary>
		public static bool HasExtensionPtr(UnityVersion version, TransferInstructionFlags flags) => version.IsLess(3, 5) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 and greater and Not Release
		/// </summary>
		public static bool HasCorrespondingSourceObjectInvariant(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && !flags.IsRelease();
		/// <summary>
		/// 2018.2 and greater and Not Release
		/// </summary>
		public static bool HasCorrespondingSourceObject(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2018, 2) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 to 2018.2 exclusive and Not Release
		/// </summary>
		public static bool HasPrefabParentObject(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && version.IsLess(2018, 2) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 and greater and Not Release
		/// </summary>
		public static bool HasPrefabInstanceInvariant(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && !flags.IsRelease();
		/// <summary>
		/// 2018.3 and greater and Not Release
		/// </summary>
		public static bool HasPrefabInstance(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2018, 3) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 to 2018.3 exclusive and Not Release
		/// </summary>
		public static bool HasPrefabInternal(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && version.IsLess(2018, 3) && !flags.IsRelease();
		/// <summary>
		/// 2018.3 and greater and Not Release
		/// </summary>
		public static bool HasPrefabAsset(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2018, 3) && !flags.IsRelease();

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			if (HasExtensionPtr(container.ExportVersion, container.ExportFlags))
			{
				node.Add(ExtensionPtrName, ExtensionPtr.ExportYaml(container));
			}
			if (HasCorrespondingSourceObject(container.ExportVersion, container.ExportFlags))
			{
				node.Add(CorrespondingSourceObjectInvariantName(container.ExportVersion, container.ExportFlags), CorrespondingSourceObject.ExportYaml(container));
				node.Add(PrefabInstanceInvariantName(container.ExportVersion, container.ExportFlags), PrefabInstance.ExportYaml(container));
			}
			if (HasPrefabAsset(container.ExportVersion, container.ExportFlags))
			{
				node.Add(PrefabAssetName, PrefabAsset.ExportYaml(container));
			}
			return node;
		}

		protected void ReadObject(AssetReader reader)
		{
			base.Read(reader);
		}

		protected void WriteObject(AssetWriter writer)
		{
			base.Write(writer);
		}

		protected YamlMappingNode ExportYamlRootObject(IExportContainer container)
		{
			return base.ExportYamlRoot(container);
		}

		protected IEnumerable<PPtr<IUnityObjectBase>> FetchDependenciesObject(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}
		}

		public static string CorrespondingSourceObjectInvariantName(UnityVersion version, TransferInstructionFlags flags)
		{
			return HasCorrespondingSourceObject(version, flags) ? CorrespondingSourceObjectName : PrefabParentObjectName;
		}
		public static string PrefabInstanceInvariantName(UnityVersion version, TransferInstructionFlags flags)
		{
			return HasPrefabInstance(version, flags) ? PrefabInstanceName : PrefabInternalName;
		}

		private PPtr<Object.Object> ExtensionPtr => new();
		private PPtr<EditorExtension> CorrespondingSourceObject => new();
		private PPtr<Prefab> PrefabAsset => new();

		public PPtr<IPrefabInstance> PrefabInstance { get; set; } = new();

		public const string ExtensionPtrName = "m_ExtensionPtr";
		public const string CorrespondingSourceObjectName = "m_CorrespondingSourceObject";
		public const string PrefabParentObjectName = "m_PrefabParentObject";
		public const string PrefabInstanceName = "m_PrefabInstance";
		public const string PrefabInternalName = "m_PrefabInternal";
		public const string PrefabAssetName = "m_PrefabAsset";
	}
}

```

`AssetRipperCore/Classes/GameObject/ComponentPair.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.GameObject
{
	public sealed class ComponentPair : IAsset, IDependent
	{
		public void Read(AssetReader reader)
		{
			Component.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			Component.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(ComponentName, Component.ExportYaml(container));
			return node;
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			yield return context.FetchDependency(Component, ComponentName);
		}

		public PPtr<Component> Component = new();
		public const string ComponentName = "component";
	}
}

```

`AssetRipperCore/Classes/GameObject/GameObject.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Converters.GameObject;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Classes.GameObject
{
	public sealed class GameObject : EditorExtension, IHasNameString, IGameObject
	{
		public GameObject(LayoutInfo layout) : base(layout)
		{
			if (IsComponentTuple(layout.Version))
			{
				ComponentTuple = Array.Empty<Tuple<ClassIDType, PPtr<Component>>>();
			}
			else
			{
				Component = Array.Empty<ComponentPair>();
			}
			NameString = string.Empty;
			TagString = TagManager.TagManagerConstants.UntaggedTag;
			IsActive = true;
		}

		public GameObject(AssetInfo assetInfo) : base(assetInfo) { }

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(5, 5))
			{
				// unknown
				return 5;
			}
			else if (version.IsGreaterEqual(4))
			{
				// active state inheritance
				return 4;
			}
			else
			{
				// min is 3
				// tag is ushort for Release, otherwise string. For later versions for yaml only string left
				return 3;

				// tag is string
				// Version = 2;
				// tag is ushort
				// Version = 1;
			}
		}

		public IUnityObjectBase ConvertLegacy(IExportContainer container)
		{
			return GameObjectConverter.Convert(container, this);
		}

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			if (IsComponentTuple(reader.Version))
			{
				ComponentTuple = reader.ReadTupleEnum32TArray<ClassIDType, PPtr<Component>>((t) => (ClassIDType)t);
			}
			else
			{
				Component = reader.ReadAssetArray<ComponentPair>();
			}

			Layer = reader.ReadUInt32();
			NameString = reader.ReadString();

			if (HasTag(reader.Version, reader.Flags))
			{
				Tag = reader.ReadUInt16();
			}
			IsActive = reader.ReadBoolean();
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			if (IsComponentTuple(writer.Version))
			{
				ComponentTuple.Write(writer, (t) => (int)t);
			}
			else
			{
				Component.Write(writer);
			}

			writer.Write(Layer);
			writer.Write(NameString);

			if (HasTag(writer.Version, writer.Flags))
			{
				writer.Write(Tag);
			}
			writer.Write(IsActive);
		}

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}

			if (IsComponentTuple(context.Version))
			{
				foreach (PPtr<IUnityObjectBase> asset in context.FetchDependencies(ComponentTuple.Select(t => t.Item2), ComponentName))
				{
					yield return asset;
				}
			}
			else
			{
				foreach (PPtr<IUnityObjectBase> asset in context.FetchDependenciesFromArray(Component, ComponentName))
				{
					yield return asset;
				}
			}
		}

		public override string ToString()
		{
			if (string.IsNullOrEmpty(NameString))
			{
				return base.ToString();
			}
			return $"{NameString}({GetType().Name})";
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			if (IsComponentTuple(container.ExportVersion))
			{
				node.Add(ComponentName, ComponentTuple.ExportYaml(container, (t) => (int)t));
			}
			else
			{
				node.Add(ComponentName, ExportYaml(Component, container));
			}

			node.Add(LayerName, Layer);
			node.Add(NameName, NameString);
			if (HasTag(container.ExportVersion, container.ExportFlags))
			{
				node.Add(TagName, Tag);
			}
			else
			{
				node.Add(TagStringName, TagString);
			}

			if (HasIcon(container.ExportVersion, container.ExportFlags) && IsIconFirst(container.ExportVersion))
			{
				node.Add(IconName, Icon.ExportYaml(container));
			}
			if (HasNavMeshLayer(container.ExportVersion, container.ExportFlags))
			{
				node.Add(NavMeshLayerName, NavMeshLayer);
				node.Add(StaticEditorFlagsName, StaticEditorFlags);
			}
			node.Add(IsActiveName, IsActive);
			if (HasIsStatic(container.ExportVersion, container.ExportFlags))
			{
				node.Add(IsStaticName, IsStatic);
			}
			if (HasIcon(container.ExportVersion, container.ExportFlags) && !IsIconFirst(container.ExportVersion))
			{
				node.Add(IconName, Icon.ExportYaml(container));
			}
			return node;
		}

		private static YamlNode ExportYaml(IEnumerable<ComponentPair> _this, IExportContainer container)
		{
			YamlSequenceNode node = new YamlSequenceNode(SequenceStyle.Block);
			foreach (ComponentPair pair in _this)
			{
				if (pair.Component.IsValid(container))
				{
					node.Add(pair.ExportYaml(container));
				}
			}
			return node;
		}

		public PPtr<IComponent>[] FetchComponents()
		{
			if (IsComponentTuple(SerializedFile.Version))
			{
				return ComponentTuple.Select(t => t.Item2.CastTo<IComponent>()).ToArray();
			}
			else
			{
				return Component.Select(t => t.Component.CastTo<IComponent>()).ToArray();
			}
		}

		public override string ExportExtension => throw new NotSupportedException();

		/// <summary>
		/// Release or less than 2.1.0
		/// </summary>
		public static bool HasTag(UnityVersion version, TransferInstructionFlags flags) => flags.IsRelease() || version.IsLess(2, 1);
		/// <summary>
		/// 2.1.0 and greater and Not Release
		/// </summary>
		public static bool HasTagString(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2, 1) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 and greater and Not Release
		/// </summary>
		public static bool HasNavMeshLayer(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && !flags.IsRelease();
		/// <summary>
		/// 3.5.0 and greater and Not Release
		/// </summary>
		public static bool HasStaticEditorFlags(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 5) && !flags.IsRelease();
		/// <summary>
		/// 3.0.0 to 3.5.0 exclusive and Not Release
		/// </summary>
		public static bool HasIsStatic(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3) && version.IsLess(3, 5) && !flags.IsRelease();
		/// <summary>
		/// At least 3.4.0 and Not Release
		/// </summary>
		public static bool HasIcon(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(3, 4) && !flags.IsRelease();
		/// <summary>
		/// Less than 5.5.0
		/// </summary>
		public static bool IsComponentTuple(UnityVersion version) => version.IsLess(5, 5);
		/// <summary>
		/// 3.5.0 and greater
		/// </summary>
		public static bool IsIconFirst(UnityVersion version) => version.IsGreaterEqual(3, 5);
		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool IsActiveInherited(UnityVersion version) => version.IsLess(4);

		public ComponentPair[] Component
		{
			get => (ComponentPair[])m_component;
			set => m_component = value;
		}
		public Tuple<ClassIDType, PPtr<Component>>[] ComponentTuple
		{
			get => (Tuple<ClassIDType, PPtr<Component>>[])m_component;
			set => m_component = value;
		}
		public uint Layer { get; set; }
		public string NameString { get; set; }
		public ushort Tag { get; set; }
		public string TagString { get; set; }

		private uint NavMeshLayer => 0;
		private uint StaticEditorFlags => 0;
		public bool IsActive { get; set; }

		private bool IsStatic => false;
		private PPtr<Object.Object> Icon => new();

		private object m_component;

		public const string ComponentName = "m_Component";
		public const string LayerName = "m_Layer";
		public const string NameName = "m_Name";
		public const string TagName = "m_Tag";
		public const string TagStringName = "m_TagString";
		public const string NavMeshLayerName = "m_NavMeshLayer";
		public const string StaticEditorFlagsName = "m_StaticEditorFlags";
		public const string IsActiveName = "m_IsActive";
		public const string IsStaticName = "m_IsStatic";
		public const string IconName = "m_Icon";
	}
}

```

`AssetRipperCore/Classes/Mesh/BlendShapeData.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;

using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Linq;


namespace AssetRipper.Core.Classes.Mesh
{
	public static class BlendShapeDataExtensions
	{
		public static string? FindShapeNameByCRC(this BlendShapeData blendShapeData, uint crc)
		{
			foreach (IMeshBlendShapeChannelLegacy blendChannel in blendShapeData.Channels)
			{
				if (blendChannel.NameHash == crc)
				{
					return blendChannel.Name.String;
				}
			}
			return null;
		}
	}

	public sealed class BlendShapeData
	{
		public BlendShapeVertex[] Vertices { get; set; } = Array.Empty<BlendShapeVertex>();
		public IMeshBlendShapeLegacy[] Shapes { get; set; } = Array.Empty<IMeshBlendShapeLegacy>();
		public IMeshBlendShapeChannelLegacy[] Channels { get; set; } = Array.Empty<IMeshBlendShapeChannelLegacy>();
		public float[] FullWeights { get; set; } = Array.Empty<float>();

		/// <summary>
		/// 2017.1 and greater
		/// </summary>
		private static bool IsAlign(UnityVersion version) => version.IsGreaterEqual(2017);

		public BlendShapeData Convert()
		{
			BlendShapeData instance = new BlendShapeData();
			instance.Vertices = Vertices.ToArray();
			instance.Shapes = Shapes.ToArray();
			instance.Channels = Channels.ToArray();
			instance.FullWeights = FullWeights.ToArray();
			return instance;
		}

		public void Read(AssetReader reader)
		{
			Vertices = reader.ReadAssetArray<BlendShapeVertex>();
			Shapes = reader.ReadAssetArray<MeshBlendShape>();
			Channels = reader.ReadAssetArray<MeshBlendShapeChannel>();
			if (IsAlign(reader.Version))
			{
				reader.AlignStream();
			}

			FullWeights = reader.ReadSingleArray();
		}

		public void Write(AssetWriter writer)
		{
			Vertices.Write(writer);
			Shapes.Write(writer);
			Channels.Write(writer);
			if (IsAlign(writer.Version))
			{
				writer.AlignStream();
			}

			FullWeights.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(VerticesName, Vertices.ExportYaml(container));
			node.Add(ShapesName, Shapes.ExportYaml(container));
			node.Add(ChannelsName, Channels.ExportYaml(container));
			node.Add(FullWeightsName, FullWeights.ExportYaml());
			return node;
		}

		public const string VerticesName = "vertices";
		public const string ShapesName = "shapes";
		public const string ChannelsName = "channels";
		public const string FullWeightsName = "fullWeights";
	}
}

```

`AssetRipperCore/Classes/Mesh/BlendShapeVertex.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class BlendShapeVertex : IAsset
	{
		public void Read(AssetReader reader)
		{
			Vertex.Read(reader);
			Normal.Read(reader);
			Tangent.Read(reader);
			Index = reader.ReadUInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.WriteAsset(Vertex);
			writer.WriteAsset(Normal);
			writer.WriteAsset(Tangent);
			writer.Write(Index);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(VertexName, Vertex.ExportYaml(container));
			node.Add(NormalName, Normal.ExportYaml(container));
			node.Add(TangentName, Tangent.ExportYaml(container));
			node.Add(IndexName, Index);
			return node;
		}

		public uint Index { get; set; }
		public IVector3f Vertex { get; } = new Vector3f();
		public IVector3f Normal { get; } = new Vector3f();
		public IVector3f Tangent { get; } = new Vector3f();

		public const string VertexName = "vertex";
		public const string NormalName = "normal";
		public const string TangentName = "tangent";
		public const string IndexName = "index";
	}
}

```

`AssetRipperCore/Classes/Mesh/ChannelInfo.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Converters.Mesh;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class ChannelInfo : IChannelInfoLegacy
	{
		public ChannelInfo() { }
		public ChannelInfo(byte stream, byte offset, byte format, byte rawDimention)
		{
			Stream = stream;
			Offset = offset;
			Format = format;
			Dimension = rawDimention;
		}

		public byte GetStride(UnityVersion version)
		{
			return GetVertexFormat(version).CalculateStride(version, this.GetDataDimension());
		}

		public VertexFormat GetVertexFormat(UnityVersion version)
		{
			if (VertexFormatExtensions.VertexFormat2019Relevant(version))
			{
				return ((VertexFormat2019)Format).ToVertexFormat();
			}
			else if (VertexFormatExtensions.VertexFormat2017Relevant(version))
			{
				return ((VertexFormat2017)Format).ToVertexFormat();
			}
			else
			{
				return ((VertexChannelFormat)Format).ToVertexFormat();
			}
		}

		public ChannelInfo Convert(IExportContainer container)
		{
			return ChannelInfoConverter.Convert(container, this);
		}

		public ChannelInfo Clone()
		{
			ChannelInfo instance = new();
			instance.Stream = Stream;
			instance.Offset = Offset;
			instance.Format = Format;
			instance.Dimension = Dimension;
			return instance;
		}

		public void Read(AssetReader reader)
		{
			Stream = reader.ReadByte();
			Offset = reader.ReadByte();
			Format = reader.ReadByte();
			Dimension = reader.ReadByte();
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Stream);
			writer.Write(Offset);
			writer.Write(Format);
			writer.Write(Dimension);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(StreamName, Stream);
			node.Add(OffsetName, Offset);
			node.Add(FormatName, Format);
			node.Add(DimensionName, Dimension);
			return node;
		}

		public override string ToString()
		{
			return $"S[{Stream}];\tO[{Offset}];\tF[{Format}];\tD[{Dimension}]";
		}

		/// <summary>
		/// Stream index
		/// BinaryData:[Stream0][Align][Stream1][Align]...
		/// </summary>
		public byte Stream { get; set; }
		/// <summary>
		/// Offset inside stream
		/// Stream:[FirstVertex: VertexOffset,NormalOffset,TangentOffset...][SecondVertex: VertexOffset,NormalOffset,TangentOffset...]...
		/// </summary>
		public byte Offset { get; set; }
		/// <summary>
		/// Data format: float, int, byte
		/// </summary>
		public byte Format { get; set; }
		/// <summary>
		/// An unprocessed byte value containing the data dimension
		/// </summary>
		public byte Dimension { get; set; }

		public const string StreamName = "stream";
		public const string OffsetName = "offset";
		public const string FormatName = "format";
		public const string DimensionName = "dimension";
	}
}

```

`AssetRipperCore/Classes/Mesh/CompressedMesh.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.PackedBitVectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class CompressedMesh : ICompressedMeshLegacy
	{
		public IPackedFloatVector Vertices { get; } = new PackedFloatVector();
		public IPackedFloatVector UV { get; } = new PackedFloatVector();
		public IPackedFloatVector BindPoses { get; } = new PackedFloatVector();
		public IPackedFloatVector Normals { get; } = new PackedFloatVector();
		public IPackedFloatVector Tangents { get; } = new PackedFloatVector();
		public IPackedIntVector Weights { get; } = new PackedIntVector();
		public IPackedIntVector NormalSigns { get; } = new PackedIntVector();
		public IPackedIntVector TangentSigns { get; } = new PackedIntVector();
		public IPackedFloatVector FloatColors { get; } = new PackedFloatVector();
		public IPackedIntVector BoneIndices { get; } = new PackedIntVector();
		public IPackedIntVector Triangles { get; } = new PackedIntVector();
		public IPackedIntVector Colors { get; } = new PackedIntVector();
		public uint UVInfo { get; set; }

		/// <summary>
		/// Less than 5.0.0
		/// </summary>
		public static bool HasBindPoses(UnityVersion version) => version.IsLess(5);
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool HasFloatColors(UnityVersion version) => version.IsGreaterEqual(5);
		/// <summary>
		/// 3.5.0 to 5.0.0 exclusive
		/// </summary>
		public static bool HasColors(UnityVersion version) => version.IsGreaterEqual(3, 5) && version.IsLess(5);
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool HasUVInfo(UnityVersion version) => version.IsGreaterEqual(5);

		public void Read(AssetReader reader)
		{
			Vertices.Read(reader);
			UV.Read(reader);
			if (HasBindPoses(reader.Version))
			{
				BindPoses.Read(reader);
			}

			Normals.Read(reader);
			Tangents.Read(reader);
			Weights.Read(reader);
			NormalSigns.Read(reader);
			TangentSigns.Read(reader);
			if (HasFloatColors(reader.Version))
			{
				FloatColors.Read(reader);
			}

			BoneIndices.Read(reader);
			Triangles.Read(reader);
			if (HasColors(reader.Version))
			{
				Colors.Read(reader);
			}
			if (HasUVInfo(reader.Version))
			{
				UVInfo = reader.ReadUInt32();
			}
		}

		public void Write(AssetWriter writer)
		{
			Vertices.Write(writer);
			UV.Write(writer);
			if (HasBindPoses(writer.Version))
			{
				BindPoses.Write(writer);
			}

			Normals.Write(writer);
			Tangents.Write(writer);
			Weights.Write(writer);
			NormalSigns.Write(writer);
			TangentSigns.Write(writer);
			if (HasFloatColors(writer.Version))
			{
				FloatColors.Write(writer);
			}

			BoneIndices.Write(writer);
			Triangles.Write(writer);
			if (HasColors(writer.Version))
			{
				Colors.Write(writer);
			}
			if (HasUVInfo(writer.Version))
			{
				writer.Write(UVInfo);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(VerticesName, Vertices.ExportYaml(container));
			node.Add(UVName, UV.ExportYaml(container));
			if (HasBindPoses(container.ExportVersion))
			{
				node.Add(BindPosesName, BindPoses.ExportYaml(container));
			}

			node.Add(NormalsName, Normals.ExportYaml(container));
			node.Add(TangentsName, Tangents.ExportYaml(container));
			node.Add(WeightsName, Weights.ExportYaml(container));
			node.Add(NormalSignsName, NormalSigns.ExportYaml(container));
			node.Add(TangentSignsName, TangentSigns.ExportYaml(container));
			if (HasFloatColors(container.ExportVersion))
			{
				node.Add(FloatColorsName, FloatColors.ExportYaml(container));
			}

			node.Add(BoneIndicesName, BoneIndices.ExportYaml(container));
			node.Add(TrianglesName, Triangles.ExportYaml(container));
			if (HasColors(container.ExportVersion))
			{
				node.Add(ColorsName, Colors.ExportYaml(container));
			}
			if (HasUVInfo(container.ExportVersion))
			{
				node.Add(UVInfoName, UVInfo);
			}
			return node;
		}

		public const string VerticesName = "m_Vertices";
		public const string UVName = "m_UV";
		public const string BindPosesName = "m_BindPoses";
		public const string NormalsName = "m_Normals";
		public const string TangentsName = "m_Tangents";
		public const string WeightsName = "m_Weights";
		public const string NormalSignsName = "m_NormalSigns";
		public const string TangentSignsName = "m_TangentSigns";
		public const string FloatColorsName = "m_FloatColors";
		public const string BoneIndicesName = "m_BoneIndices";
		public const string TrianglesName = "m_Triangles";
		public const string ColorsName = "m_Colors";
		public const string UVInfoName = "m_UVInfo";
	}
}

```

`AssetRipperCore/Classes/Mesh/Mesh.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.Converters.Mesh;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.PackedBitVectors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.Mesh
{
	/// <summary>
	/// LodMesh previously
	/// </summary>
	public sealed class Mesh : NamedObject
	{
		public BlendShapeData Shapes { get; set; } = new BlendShapeData();
		public VariableBoneCountWeights VariableBoneCountWeights { get; } = new VariableBoneCountWeights();
		public VertexData VertexData { get; set; } = new VertexData();
		public CompressedMesh CompressedMesh { get; } = new CompressedMesh();
		public AABB LocalAABB { get; } = new AABB();
		public byte[] BakedConvexCollisionMesh { get; set; } = Array.Empty<byte>();
		public byte[] BakedTriangleCollisionMesh { get; set; } = Array.Empty<byte>();
		public StreamingInfo StreamData { get; } = new StreamingInfo();
		public uint Use16BitIndices
		{
			get => IndexFormat == IndexFormat.UInt16 ? 1U : 0U;
			set => IndexFormat = value == 0 ? IndexFormat.UInt32 : IndexFormat.UInt16;
		}

		#region IndexBuffer
		public byte[] RawIndexBuffer
		{
			get => m_RawIndexBuffer;
			set
			{
				m_RawIndexBuffer = value;
				ProcessedIndexBufferFromRaw();
			}
		}
		private byte[] m_RawIndexBuffer;
		public uint[] ProcessedIndexBuffer
		{
			get => m_ProcessedIndexBuffer;
			set
			{
				m_ProcessedIndexBuffer = value;
				RawIndexBufferFromProcessed();
			}
		}
		private uint[] m_ProcessedIndexBuffer;
		private ushort[] UintToUshort(uint[] array)
		{
			ushort[] result = new ushort[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				result[i] = (ushort)array[i];
			}
			return result;
		}
		private uint[] UshortToUint(ushort[] array)
		{
			uint[] result = new uint[array.Length];
			for (int i = 0; i < array.Length; i++)
			{
				result[i] = array[i];
			}
			return result;
		}
		private void ProcessedIndexBufferFromRaw()
		{
			if (Use16BitIndices != 0)
			{
				var outputBuffer = new ushort[m_RawIndexBuffer.Length / sizeof(ushort)];
				Buffer.BlockCopy(m_RawIndexBuffer, 0, outputBuffer, 0, m_RawIndexBuffer.Length);
				m_ProcessedIndexBuffer = UshortToUint(outputBuffer);
			}
			else
			{
				m_ProcessedIndexBuffer = new uint[m_RawIndexBuffer.Length / sizeof(uint)];
				Buffer.BlockCopy(m_RawIndexBuffer, 0, m_ProcessedIndexBuffer, 0, m_RawIndexBuffer.Length);
			}
		}
		private void RawIndexBufferFromProcessed()
		{
			if (Use16BitIndices != 0)
			{
				m_RawIndexBuffer = new byte[m_ProcessedIndexBuffer.Length * sizeof(ushort)];
				var inputBuffer = UintToUshort(m_ProcessedIndexBuffer);
				Buffer.BlockCopy(inputBuffer, 0, m_RawIndexBuffer, 0, m_RawIndexBuffer.Length);
			}
			else
			{
				m_RawIndexBuffer = new byte[m_ProcessedIndexBuffer.Length * sizeof(uint)];
				Buffer.BlockCopy(m_ProcessedIndexBuffer, 0, m_RawIndexBuffer, 0, m_RawIndexBuffer.Length);
			}
		}
		#endregion

		public SubMesh[] SubMeshes { get; set; }
		/// <summary>
		/// Shapes - real name
		/// </summary>
		public IMeshBlendShapeLegacy[] BlendShapes
		{
			get => Shapes.Shapes;
			set => Shapes.Shapes = value;
		}
		public BlendShapeVertex[] ShapeVertices
		{
			get => Shapes.Vertices;
			set => Shapes.Vertices = value;
		}
		public Matrix4x4f[] BindPose { get; set; }
		public uint[] BoneNameHashes { get; set; }
		public uint RootBoneNameHash { get; set; }
		public MinMaxAABB[] BonesAABB { get; set; }
		public MeshCompression MeshCompression { get; set; }
		public byte StreamCompression { get; set; }
		public bool IsReadable { get; set; }
		public bool KeepVertices { get; set; }
		public bool KeepIndices { get; set; }
		public IndexFormat IndexFormat { get; set; }
		public Vector3f[] Vertices { get; set; }
		public int VertexCount { get; private set; }
		public BoneWeights4[] Skin { get; set; }
		public Vector2f[] UV0 { get; set; }
		public Vector2f[] UV1 { get; set; }
		public Vector2f[] UV2 { get; set; }
		public Vector2f[] UV3 { get; set; }
		public Vector2f[] UV4 { get; set; }
		public Vector2f[] UV5 { get; set; }
		public Vector2f[] UV6 { get; set; }
		public Vector2f[] UV7 { get; set; }
		public Vector4f[] Tangents { get; set; }
		public Vector3f[] Normals { get; set; }
		public ColorRGBA32[] Colors { get; set; }
		public uint[] CollisionTriangles { get; set; }
		public int CollisionVertexCount { get; set; }
		public int MeshUsageFlags { get; set; }
		public float[] MeshMetrics { get; set; }
		public List<uint> Indices { get; set; } = new List<uint>();
		public List<List<uint>> Triangles { get; set; } = new List<List<uint>>();

		public Mesh(AssetInfo assetInfo) : base(assetInfo) { }

		public static int ToSerializedVersion(UnityVersion version)
		{
			// MeshOptimized has been extended to MeshOptimizationFlags
			if (version.IsGreaterEqual(2019))
			{
				return 10;
			}
			// Skin has been moved to VertexData
			if (version.IsGreaterEqual(2018, 2))
			{
				return 9;
			}
			// MeshTopology == 1 has become deprecated
			// unknown alpha/beta version
			if (version.IsGreaterEqual(4, 0, 0, UnityVersionType.Beta))
			{
				return 8;
			}
			// unknown conversion
			if (version.IsGreaterEqual(4))
			{
				return 7;
			}
			// VertexData has been added
			if (version.IsGreaterEqual(3, 5))
			{
				return 6;
			}
			// SubMesh's vertex range (FirstVertex, VertexCount and LocalAABB) has been added
			if (version.IsGreaterEqual(3))
			{
				return 5;
			}
			// MeshCompression has been added
			// unknown alpha/beta version
			if (version.IsGreaterEqual(2, 6, 0, UnityVersionType.Beta))
			{
				return 4;
			}
			// TangentSpace has been replaced by Tangents and Normals
			if (version.IsGreaterEqual(2, 6))
			{
				return 3;
			}
			// LODData has been replaced by IndexBuffer and SubMeshes
			if (version.IsGreaterEqual(2))
			{
				return 2;
			}
			return 1;
		}

		#region Version Methods
		/// <summary>
		/// Less than 2.0.0
		/// </summary>
		public static bool HasLODData(UnityVersion version) => version.IsLess(2, 0, 0);
		/// <summary>
		/// 2.0.0 to 3.5.0 exclusive
		/// </summary>
		public static bool HasUse16bitIndices(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// 4.3.0 and greater
		/// </summary>
		public static bool HasBlendChannels(UnityVersion version) => version.IsGreaterEqual(4, 3);
		/// <summary>
		/// Greater than 4.1.0a
		/// </summary>
		public static bool HasBlendShapes(UnityVersion version) => version.IsGreater(4, 1, 0, UnityVersionType.Alpha);
		/// <summary>
		/// 4.3.0 and greater
		/// </summary>
		public static bool HasBoneNameHashes(UnityVersion version) => version.IsGreaterEqual(4, 3);
		/// <summary>
		/// 2019.1 and greater
		/// </summary>
		public static bool HasBonesAABB(UnityVersion version) => version.IsGreaterEqual(2019);
		/// <summary>
		/// 2.6.0 and greater
		/// </summary>
		public static bool HasMeshCompression(UnityVersion version) => version.IsGreaterEqual(2, 6);
		/// <summary>
		/// 4.0.0 to 5.0.0 exclusive
		/// </summary>
		public static bool HasStreamCompression(UnityVersion version) => version.IsGreaterEqual(4) && version.IsLess(5);
		/// <summary>
		/// 4.0.0 and greater
		/// </summary>
		public static bool HasIsReadable(UnityVersion version) => version.IsGreaterEqual(4);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool HasIndexFormat(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// Less than 2018.2
		/// </summary>
		public static bool HasSkin(UnityVersion version) => version.IsLess(2018, 2);
		/// <summary>
		/// 2.1.0 and greater
		/// </summary>
		public static bool HasBindPose(UnityVersion version) => version.IsGreaterEqual(2, 1);
		/// <summary>
		/// 1.6.0 and greater
		/// </summary>
		public static bool HasUV1(UnityVersion version) => version.IsGreaterEqual(1, 6);
		/// <summary>
		/// Less than 2.6.0
		/// </summary>
		public static bool HasTangentSpace(UnityVersion version) => version.IsLess(2, 6);
		/// <summary>
		/// 3.5.0 and greater
		/// </summary>
		public static bool HasVertexData(UnityVersion version) => version.IsGreaterEqual(3, 5);
		/// <summary>
		/// 3.5.1 and greater
		/// </summary>
		public static bool IsOnlyVertexData(UnityVersion version) => version.IsGreaterEqual(3, 5, 1);
		/// <summary>
		/// 2.6.0 and greater
		/// </summary>
		public static bool HasCompressedMesh(UnityVersion version) => version.IsGreaterEqual(2, 6);
		/// <summary>
		/// Less than 3.5.0f1
		/// </summary>
		public static bool HasCollisionTriangles(UnityVersion version) => version.IsLessEqual(3, 5, 0, UnityVersionType.Beta);
		/// <summary>
		/// 2.5.0 and greater
		/// </summary>
		public static bool HasMeshUsageFlags(UnityVersion version) => version.IsGreaterEqual(2, 5);
		/// <summary>
		/// 5.0.0 and greater
		/// </summary>
		public static bool HasCollision(UnityVersion version) => version.IsGreaterEqual(5);
		/// <summary>
		/// 2018.2 and greater
		/// </summary>
		public static bool HasMeshMetrics(UnityVersion version) => version.IsGreaterEqual(2018, 2);
		/// <summary>
		/// 3.5.0 and greater and Not Release
		/// </summary>
		public static bool HasMeshOptimization(UnityVersion version, TransferInstructionFlags flags) => !flags.IsRelease() && version.IsGreaterEqual(3, 5);
		/// <summary>
		/// 2018.3 and greater
		/// </summary>
		public static bool HasStreamData(UnityVersion version) => version.IsGreaterEqual(2018, 3);

		/// <summary>
		/// Less than 2.6.0
		/// </summary>
		private static bool IsIndexBufferFirst(UnityVersion version) => version.IsLess(2, 6);
		/// <summary>
		/// 4.3.0 and greater
		/// </summary>
		private static bool IsBindPoseFirst(UnityVersion version) => version.IsGreaterEqual(4, 3);
		/// <summary>
		/// 2.6.0 and greater
		/// </summary>
		private static bool IsAlignVertex(UnityVersion version) => version.IsGreaterEqual(2, 6);
		/// <summary>
		/// 2.6.0 and greater
		/// </summary>
		private static bool IsAlignFlags(UnityVersion version) => version.IsGreaterEqual(2, 6);
		/// <summary>
		/// Less than 2017.3.1p1
		/// </summary>
		private static bool IsIndexFormatCondition(UnityVersion version) => version.IsLess(2017, 3, 1, UnityVersionType.Patch);
		/// <summary>
		/// 2019.1 and greater and Not Release
		/// </summary>
		private static bool IsMeshOptimizationFlags(UnityVersion version) => version.IsGreaterEqual(2019);
		#endregion

		public bool CheckAssetIntegrity()
		{
			if (HasStreamData(SerializedFile.Version))
			{
				if (VertexData.IsSet())
				{
					return StreamData.CheckIntegrity(SerializedFile);
				}
			}
			return true;
		}

		public string? FindBlendShapeNameByCRC(uint crc)
		{
			if (HasBlendChannels(SerializedFile.Version))
			{
				return Shapes.FindShapeNameByCRC(crc);
			}
			else
			{
				foreach (MeshBlendShape blendShape in BlendShapes)
				{
					if (blendShape.IsCRCMatch(crc))
					{
						return blendShape.Name.String;
					}
				}
				return null;
			}
		}

		// TEMP: argument
		public bool Is16BitIndices(UnityVersion version)
		{
			if (HasLODData(version))
			{
				return true;
			}
			else if (HasUse16bitIndices(version))
			{
				return Use16BitIndices != 0;
			}
			else if (HasIndexFormat(version))
			{
				return IndexFormat == IndexFormat.UInt16;
			}
			return true;
		}

		public IUnityObjectBase ConvertLegacy(IExportContainer container)
		{
			return MeshConverter.Convert(container, this);
		}

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			if (HasUse16bitIndices(reader.Version))
			{
				Use16BitIndices = reader.ReadUInt32();
			}
			SubMeshes = reader.ReadAssetArray<SubMesh>();

			if (HasBlendShapes(reader.Version))
			{
				if (HasBlendChannels(reader.Version))
				{
					Shapes.Read(reader);
				}
				else
				{
					BlendShapes = reader.ReadAssetArray<MeshBlendShape>();
					reader.AlignStream();
					ShapeVertices = reader.ReadAssetArray<BlendShapeVertex>();
				}
			}
			if (IsBindPoseFirst(reader.Version))
			{
				BindPose = reader.ReadAssetArray<Matrix4x4f>();
			}
			if (HasBoneNameHashes(reader.Version))
			{
				BoneNameHashes = reader.ReadUInt32Array();
				RootBoneNameHash = reader.ReadUInt32();
			}
			if (HasBonesAABB(reader.Version))
			{
				BonesAABB = reader.ReadAssetArray<MinMaxAABB>();
				VariableBoneCountWeights.Read(reader);
			}

			MeshCompression = (MeshCompression)reader.ReadByte();

			if (HasStreamCompression(reader.Version))
			{
				StreamCompression = reader.ReadByte();
			}
			if (HasIsReadable(reader.Version))
			{
				IsReadable = reader.ReadBoolean();
				KeepVertices = reader.ReadBoolean();
				KeepIndices = reader.ReadBoolean();
			}
			reader.AlignStream();

			if (HasIndexFormat(reader.Version))
			{
				if (IsIndexFormatCondition(reader.Version))
				{
					if (MeshCompression == MeshCompression.Off)
					{
						IndexFormat = (IndexFormat)reader.ReadInt32();
					}
				}
				else
				{
					IndexFormat = (IndexFormat)reader.ReadInt32();
				}
			}

			RawIndexBuffer = reader.ReadByteArray();
			reader.AlignStream();

			if (HasVertexData(reader.Version))
			{
				if (!IsOnlyVertexData(reader.Version)) //3.5.0 only
				{
					if (MeshCompression != MeshCompression.Off)
					{
						Vertices = reader.ReadAssetArray<Vector3f>();
					}
				}
			}
			else //lower than 3.5.0
			{
				Vertices = reader.ReadAssetArray<Vector3f>();
			}

			if (HasSkin(reader.Version))
			{
				Skin = reader.ReadAssetArray<BoneWeights4>();
			}
			if (!IsBindPoseFirst(reader.Version))
			{
				BindPose = reader.ReadAssetArray<Matrix4x4f>();
			}

			if (HasVertexData(reader.Version))
			{
				if (IsOnlyVertexData(reader.Version)) //3.5.1 and greater
				{
					VertexData.Read(reader);
				}
				else //3.5.0
				{
					if (MeshCompression == MeshCompression.Off)
					{
						VertexData.Read(reader);
					}
					else
					{
						UV0 = reader.ReadAssetArray<Vector2f>();
						UV1 = reader.ReadAssetArray<Vector2f>();
						Tangents = reader.ReadAssetArray<Vector4f>();
						Normals = reader.ReadAssetArray<Vector3f>();
						Colors = reader.ReadAssetArray<ColorRGBA32>();
					}
				}
			}
			else //less than 3.5.0
			{
				UV0 = reader.ReadAssetArray<Vector2f>();
				UV1 = reader.ReadAssetArray<Vector2f>();
				Tangents = reader.ReadAssetArray<Vector4f>();
				Normals = reader.ReadAssetArray<Vector3f>();
			}
			reader.AlignStream();

			CompressedMesh.Read(reader);

			LocalAABB.Read(reader);
			if (!HasVertexData(reader.Version))
			{
				Colors = reader.ReadAssetArray<ColorRGBA32>();
			}
			if (HasCollisionTriangles(reader.Version))
			{
				CollisionTriangles = reader.ReadUInt32Array();
				CollisionVertexCount = reader.ReadInt32();
			}
			MeshUsageFlags = reader.ReadInt32();

			if (HasCollision(reader.Version))
			{
				BakedConvexCollisionMesh = reader.ReadByteArray();
				reader.AlignStream();
				BakedTriangleCollisionMesh = reader.ReadByteArray();
				reader.AlignStream();
			}
			if (HasMeshMetrics(reader.Version))
			{
				MeshMetrics = new float[2];
				MeshMetrics[0] = reader.ReadSingle();
				MeshMetrics[1] = reader.ReadSingle();
			}
			if (HasStreamData(reader.Version))
			{
				reader.AlignStream();
				StreamData.Read(reader);
			}

			ProcessData();
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			if (HasUse16bitIndices(writer.Version))
			{
				writer.Write(Use16BitIndices);
			}

			SubMeshes.Write(writer);

			if (HasBlendShapes(writer.Version))
			{
				if (HasBlendChannels(writer.Version))
				{
					Shapes.Write(writer);
				}
				else
				{
					BlendShapes.Write(writer);
					writer.AlignStream();
					ShapeVertices.Write(writer);
				}
			}
			if (IsBindPoseFirst(writer.Version))
			{
				BindPose.Write(writer);
			}
			if (HasBoneNameHashes(writer.Version))
			{
				BoneNameHashes.Write(writer);
				writer.Write(RootBoneNameHash);
			}
			if (HasBonesAABB(writer.Version))
			{
				BonesAABB.Write(writer);
				VariableBoneCountWeights.Write(writer);
			}

			writer.Write((byte)MeshCompression);

			if (HasStreamCompression(writer.Version))
			{
				writer.Write(StreamCompression);
			}
			if (HasIsReadable(writer.Version))
			{
				writer.Write(IsReadable);
				writer.Write(KeepVertices);
				writer.Write(KeepIndices);
			}
			writer.AlignStream();

			if (HasIndexFormat(writer.Version))
			{
				if (IsIndexFormatCondition(writer.Version))
				{
					if (MeshCompression == MeshCompression.Off)
					{
						writer.Write((int)IndexFormat);
					}
				}
				else
				{
					writer.Write((int)IndexFormat);
				}
			}

			RawIndexBuffer.Write(writer);
			writer.AlignStream();

			if (HasVertexData(writer.Version))
			{
				if (!IsOnlyVertexData(writer.Version))
				{
					if (MeshCompression != MeshCompression.Off)
					{
						Vertices.Write(writer);
					}
				}
			}
			else
			{
				Vertices.Write(writer);
			}

			if (HasSkin(writer.Version))
			{
				Skin.Write(writer);
			}
			if (!IsBindPoseFirst(writer.Version))
			{
				BindPose.Write(writer);
			}

			if (HasVertexData(writer.Version))
			{
				if (IsOnlyVertexData(writer.Version))
				{
					VertexData.Write(writer);
				}
				else
				{
					if (MeshCompression == MeshCompression.Off)
					{
						VertexData.Write(writer);
					}
					else
					{
						UV0.Write(writer);
						UV1.Write(writer);
						Tangents.Write(writer);
						Normals.Write(writer);
						Colors.Write(writer);
					}
				}
			}
			else
			{
				UV0.Write(writer);
				UV1.Write(writer);
				Tangents.Write(writer);
				Normals.Write(writer);
			}
			writer.AlignStream();

			CompressedMesh.Write(writer);

			LocalAABB.Write(writer);
			if (!HasVertexData(writer.Version))
			{
				Colors.Write(writer);
			}
			if (HasCollisionTriangles(writer.Version))
			{
				CollisionTriangles.Write(writer);
				writer.Write(CollisionVertexCount);
			}
			writer.Write(MeshUsageFlags);

			if (HasCollision(writer.Version))
			{
				writer.Write(BakedConvexCollisionMesh);
				writer.AlignStream();
				writer.Write(BakedTriangleCollisionMesh);
				writer.AlignStream();
			}
			if (HasMeshMetrics(writer.Version))
			{
				writer.Write(MeshMetrics[0]);
				writer.Write(MeshMetrics[1]);
			}
			if (HasStreamData(writer.Version))
			{
				writer.AlignStream();
				StreamData.Write(writer);
			}
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			if (HasUse16bitIndices(container.ExportVersion))
			{
				node.Add(Use16BitIndicesName, Use16BitIndices);
			}
			node.Add(SubMeshesName, SubMeshes.ExportYaml(container));

			if (HasBlendShapes(container.ExportVersion))
			{
				if (HasBlendChannels(container.ExportVersion))
				{
					node.Add(ShapesName, Shapes.ExportYaml(container));
				}
				else
				{
					node.Add(ShapesName, BlendShapes.ExportYaml(container));
					node.Add(ShapeVerticesName, ShapeVertices.ExportYaml(container));
				}
			}
			if (IsBindPoseFirst(container.ExportVersion))
			{
				node.Add(BindPoseName, BindPose.ExportYaml(container));
			}
			if (HasBoneNameHashes(container.ExportVersion))
			{
				node.Add(BoneNameHashesName, BoneNameHashes.ExportYaml(true));
				node.Add(RootBoneNameHashName, RootBoneNameHash);
			}
			if (HasBonesAABB(container.ExportVersion))
			{
				node.Add(BonesAABBName, BonesAABB.ExportYaml(container));
				node.Add(VariableBoneCountWeightsName, VariableBoneCountWeights.ExportYaml(container));
			}

			node.Add(MeshCompressionName, (byte)MeshCompression);

			if (HasStreamCompression(container.ExportVersion))
			{
				node.Add(StreamCompressionName, StreamCompression);
			}
			if (HasIsReadable(container.ExportVersion))
			{
				node.Add(IsReadableName, IsReadable);
				node.Add(KeepVerticesName, KeepVertices);
				node.Add(KeepIndicesName, KeepIndices);
			}

			if (HasIndexFormat(container.ExportVersion))
			{
				node.Add(IndexFormatName, (int)IndexFormat);
			}

			node.Add(IndexBufferName, RawIndexBuffer.ExportYaml());

			if (HasVertexData(container.ExportVersion))
			{
				if (!IsOnlyVertexData(container.ExportVersion))
				{
					if (MeshCompression != MeshCompression.Off)
					{
						node.Add(VerticesName, Vertices.ExportYaml(container));
					}
				}
			}
			else
			{
				node.Add(VerticesName, Vertices.ExportYaml(container));
			}

			if (HasSkin(container.ExportVersion))
			{
				node.Add(SkinName, Skin.ExportYaml(container));
			}
			if (!IsBindPoseFirst(container.ExportVersion))
			{
				node.Add(BindPoseName, BindPose.ExportYaml(container));
			}

			if (HasVertexData(container.ExportVersion))
			{
				if (IsOnlyVertexData(container.ExportVersion))
				{
					node.Add(VertexDataName, VertexData.ExportYaml(container));
				}
				else
				{
					if (MeshCompression == MeshCompression.Off)
					{
						node.Add(VertexDataName, VertexData.ExportYaml(container));
					}
					else
					{
						node.Add(UVName, UV0.ExportYaml(container));
						node.Add(UV1Name, UV1.ExportYaml(container));
						node.Add(TangentsName, Tangents.ExportYaml(container));
						node.Add(NormalsName, Normals.ExportYaml(container));
						node.Add(ColorsName, Colors.ExportYaml(container));
					}
				}
			}
			else
			{
				node.Add(UVName, UV0.ExportYaml(container));
				node.Add(UV1Name, UV1.ExportYaml(container));
				node.Add(TangentsName, Tangents.ExportYaml(container));
				node.Add(NormalsName, Normals.ExportYaml(container));
			}

			node.Add(CompressedMeshName, CompressedMesh.ExportYaml(container));

			node.Add(LocalAABBName, LocalAABB.ExportYaml(container));
			if (!HasVertexData(container.ExportVersion))
			{
				node.Add(ColorsName, Colors.ExportYaml(container));
			}
			if (HasCollisionTriangles(container.ExportVersion))
			{
				node.Add(CollisionTrianglesName, CollisionTriangles.ExportYaml(true));
				node.Add(CollisionVertexCountName, CollisionVertexCount);
			}
			node.Add(MeshUsageFlagsName, MeshUsageFlags);

			if (HasCollision(container.ExportVersion))
			{
				node.Add(BakedConvexCollisionMeshName, BakedConvexCollisionMesh.ExportYaml());
				node.Add(BakedTriangleCollisionMeshName, BakedTriangleCollisionMesh.ExportYaml());
			}
			if (HasMeshMetrics(container.ExportVersion))
			{
				node.Add(MeshMetricsName + "[0]", MeshMetrics[0]);
				node.Add(MeshMetricsName + "[1]", MeshMetrics[1]);
			}
			if (HasMeshOptimization(container.ExportVersion, container.ExportFlags))
			{
				if (IsMeshOptimizationFlags(container.ExportVersion))
				{
					node.Add(MeshOptimizationFlagsName, (int)MeshOptimizationFlags);
				}
				else
				{
					node.Add(MeshOptimizedName, MeshOptimized);
				}
			}
			if (HasStreamData(container.ExportVersion))
			{
				StreamingInfo streamData = new StreamingInfo();
				node.Add(StreamDataName, streamData.ExportYaml(container));
			}
			return node;
		}

		public byte[] GetChannelsData()
		{
			if (HasStreamData(SerializedFile.Version) && StreamData.IsSet())
			{
				return StreamData.GetContent(SerializedFile);
			}
			else
			{
				return VertexData.Data;
			}
		}

		private void ProcessData()
		{
			UnityVersion version = SerializedFile.Version;
			if (!string.IsNullOrEmpty(StreamData.Path))
			{
				if (VertexData.VertexCount > 0)
				{
					VertexData.Data = StreamData.GetContent(this.AssetInfo.File);
				}
			}
			if (version.IsGreaterEqual(3, 5)) //3.5 and up
			{
				ReadVertexData();
			}

			if (version.IsGreaterEqual(2, 6)) //2.6.0 and later
			{
				DecompressCompressedMesh(version);
			}

			ReadTriangles(version);

			if (Vertices == null)
			{
				Logger.Warning(LogCategory.Import, $"Null Vertices for {NameString}");
			}
			if (UV0 == null)
			{
				Logger.Verbose(LogCategory.Import, $"Null UV0 for {NameString}");
			}
			if (Normals == null)
			{
				Logger.Verbose(LogCategory.Import, $"Null Normals for {NameString}");
			}
		}

		private void ReadVertexData()
		{
			VertexData.ReadData(SerializedFile.Version, SerializedFile.EndianType,
				out int vertexCount,
				out Vector3f[] vertices,
				out Vector3f[] normals,
				out Vector4f[] tangents,
				out ColorRGBA32[] colors,
				out BoneWeights4[] skin,
				out Vector2f[] uv0,
				out Vector2f[] uv1,
				out Vector2f[] uv2,
				out Vector2f[] uv3,
				out Vector2f[] uv4,
				out Vector2f[] uv5,
				out Vector2f[] uv6,
				out Vector2f[] uv7);
			VertexCount = vertexCount;
			Vertices ??= vertices;
			Normals ??= normals;
			Tangents ??= tangents;
			Colors ??= colors;
			Skin ??= skin;
			UV0 ??= uv0;
			UV1 ??= uv1;
			UV2 ??= uv2;
			UV3 ??= uv3;
			UV4 ??= uv4;
			UV5 ??= uv5;
			UV6 ??= uv6;
			UV7 ??= uv7;
		}

		private void DecompressCompressedMesh(UnityVersion version)
		{
			//Vertex
			if (CompressedMesh.Vertices.NumItems > 0)
			{
				VertexCount = (int)CompressedMesh.Vertices.NumItems / 3;
				var vertices = CompressedMesh.Vertices.UnpackFloats(3, 3 * 4);
				Vertices = MeshHelper.FloatArrayToVector3(vertices);
			}
			//UV
			if (CompressedMesh.UV.NumItems > 0)
			{
				var m_UVInfo = CompressedMesh.UVInfo;
				if (m_UVInfo != 0)
				{
					const int kInfoBitsPerUV = 4;
					const int kUVDimensionMask = 3;
					const int kUVChannelExists = 4;
					const int kMaxTexCoordShaderChannels = 8;

					int uvSrcOffset = 0;
					for (int uv = 0; uv < kMaxTexCoordShaderChannels; uv++)
					{
						var texCoordBits = m_UVInfo >> (uv * kInfoBitsPerUV);
						texCoordBits &= (1u << kInfoBitsPerUV) - 1u;
						if ((texCoordBits & kUVChannelExists) != 0)
						{
							var uvDim = 1 + (int)(texCoordBits & kUVDimensionMask);
							var m_UV = CompressedMesh.UV.UnpackFloats(uvDim, uvDim * 4, uvSrcOffset, VertexCount);
							SetUV(uv, m_UV);
							uvSrcOffset += uvDim * VertexCount;
						}
					}
				}
				else
				{
					UV0 = MeshHelper.FloatArrayToVector2(CompressedMesh.UV.UnpackFloats(2, 2 * 4, 0, VertexCount));
					if (CompressedMesh.UV.NumItems >= VertexCount * 4)
					{
						UV1 = MeshHelper.FloatArrayToVector2(CompressedMesh.UV.UnpackFloats(2, 2 * 4, VertexCount * 2, VertexCount));
					}
				}
			}
			//BindPose
			if (version.IsLess(5))
			{
				if (CompressedMesh.BindPoses.NumItems > 0)
				{
					BindPose = new Matrix4x4f[CompressedMesh.BindPoses.NumItems / 16];
					var m_BindPoses_Unpacked = CompressedMesh.BindPoses.UnpackFloats(16, 4 * 16);
					var buffer = new float[16];
					for (int i = 0; i < BindPose.Length; i++)
					{
						Array.Copy(m_BindPoses_Unpacked, i * 16, buffer, 0, 16);
						BindPose[i] = new Matrix4x4f(buffer);
					}
				}
			}
			//Normal
			if (CompressedMesh.Normals.NumItems > 0)
			{
				var normalData = CompressedMesh.Normals.UnpackFloats(2, 4 * 2);
				var signs = CompressedMesh.NormalSigns.UnpackInts();
				Normals = new Vector3f[CompressedMesh.Normals.NumItems / 2];
				for (int i = 0; i < CompressedMesh.Normals.NumItems / 2; ++i)
				{
					var x = normalData[(i * 2) + 0];
					var y = normalData[(i * 2) + 1];
					var zsqr = 1 - (x * x) - (y * y);
					float z;
					if (zsqr >= 0f)
					{
						z = (float)System.Math.Sqrt(zsqr);
					}
					else
					{
						z = 0;
						var normal = new Vector3f(x, y, z);
						normal.Normalize();
						x = normal.X;
						y = normal.Y;
						z = normal.Z;
					}
					if (signs[i] == 0)
					{
						z = -z;
					}

					Normals[i] = new Vector3f(x, y, z);
				}
			}
			//Tangent
			if (CompressedMesh.Tangents.NumItems > 0)
			{
				var tangentData = CompressedMesh.Tangents.UnpackFloats(2, 4 * 2);
				var signs = CompressedMesh.TangentSigns.UnpackInts();
				Tangents = new Vector4f[CompressedMesh.Tangents.NumItems / 2];
				for (int i = 0; i < CompressedMesh.Tangents.NumItems / 2; ++i)
				{
					var x = tangentData[(i * 2) + 0];
					var y = tangentData[(i * 2) + 1];
					var zsqr = 1 - (x * x) - (y * y);
					float z;
					if (zsqr >= 0f)
					{
						z = (float)System.Math.Sqrt(zsqr);
					}
					else
					{
						z = 0;
						var vector3f = new Vector3f(x, y, z);
						vector3f.Normalize();
						x = vector3f.X;
						y = vector3f.Y;
						z = vector3f.Z;
					}
					if (signs[(i * 2) + 0] == 0)
					{
						z = -z;
					}

					var w = signs[(i * 2) + 1] > 0 ? 1.0f : -1.0f;
					Tangents[i] = new Vector4f(x, y, z, w);
				}
			}
			//FloatColor
			if (version.IsGreaterEqual(5))
			{
				if (CompressedMesh.FloatColors.NumItems > 0)
				{
					Colors = MeshHelper.FloatArrayToColorRGBA32(CompressedMesh.FloatColors.UnpackFloats(1, 4));
				}
			}
			//Skin
			if (CompressedMesh.Weights.NumItems > 0)
			{
				var weights = CompressedMesh.Weights.UnpackInts();
				var boneIndices = CompressedMesh.BoneIndices.UnpackInts();

				InitMSkin();

				int bonePos = 0;
				int boneIndexPos = 0;
				int j = 0;
				int sum = 0;

				for (int i = 0; i < CompressedMesh.Weights.NumItems; i++)
				{
					//read bone index and weight.
					Skin[bonePos].Weights[j] = weights[i] / 31.0f;
					Skin[bonePos].BoneIndices[j] = boneIndices[boneIndexPos++];
					j++;
					sum += weights[i];

					//the weights add up to one. fill the rest for this vertex with zero, and continue with next one.
					if (sum >= 31)
					{
						for (; j < 4; j++)
						{
							Skin[bonePos].Weights[j] = 0;
							Skin[bonePos].BoneIndices[j] = 0;
						}
						bonePos++;
						j = 0;
						sum = 0;
					}
					//we read three weights, but they don't add up to one. calculate the fourth one, and read
					//missing bone index. continue with next vertex.
					else if (j == 3)
					{
						Skin[bonePos].Weights[j] = (31 - sum) / 31.0f;
						Skin[bonePos].BoneIndices[j] = boneIndices[boneIndexPos++];
						bonePos++;
						j = 0;
						sum = 0;
					}
				}
			}
			//IndexBuffer
			if (CompressedMesh.Triangles.NumItems > 0)
			{
				ProcessedIndexBuffer = Array.ConvertAll(CompressedMesh.Triangles.UnpackInts(), x => (uint)x);
			}
			//Color
			if (CompressedMesh.Colors.NumItems > 0)
			{
				CompressedMesh.Colors.NumItems *= 4;
				CompressedMesh.Colors.BitSize /= 4;
				var tempColors = CompressedMesh.Colors.UnpackInts();
				Colors = new ColorRGBA32[CompressedMesh.Colors.NumItems / 4];
				for (int v = 0; v < CompressedMesh.Colors.NumItems / 4; v++)
				{
					Colors[v] = new ColorRGBA32((byte)tempColors[4 * v], (byte)tempColors[(4 * v) + 1], (byte)tempColors[(4 * v) + 2], (byte)tempColors[(4 * v) + 3]);
				}
				CompressedMesh.Colors.NumItems /= 4;
				CompressedMesh.Colors.BitSize *= 4;
			}
		}

		private void ReadTriangles(UnityVersion version)
		{
			foreach (var iter in SubMeshes)
			{
				var m_SubMesh = iter;
				var m_Triangles = new List<uint>();
				Triangles.Add(m_Triangles);
				var firstIndex = m_SubMesh.FirstByte / 2;
				if (Use16BitIndices == 0)
				{
					firstIndex /= 2;
				}
				var indexCount = m_SubMesh.IndexCount;
				var topology = m_SubMesh.Topology;
				if (topology == MeshTopology.Triangles)
				{
					for (int i = 0; i < indexCount; i += 3)
					{
						Indices.Add(ProcessedIndexBuffer[firstIndex + i]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + i + 1]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + i + 2]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + i]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + i + 1]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + i + 2]);
					}
				}
				else if (version.IsLess(4) || topology == MeshTopology.TriangleStrip)
				{
					// de-stripify :
					uint triIndex = 0;
					for (int i = 0; i < indexCount - 2; i++)
					{
						var a = ProcessedIndexBuffer[firstIndex + i];
						var b = ProcessedIndexBuffer[firstIndex + i + 1];
						var c = ProcessedIndexBuffer[firstIndex + i + 2];

						// skip degenerates
						if (a == b || a == c || b == c)
						{
							continue;
						}

						// do the winding flip-flop of strips :
						if ((i & 1) == 1)
						{
							Indices.Add(b);
							Indices.Add(a);
							m_Triangles.Add(b);
							m_Triangles.Add(a);
						}
						else
						{
							Indices.Add(a);
							Indices.Add(b);
							m_Triangles.Add(a);
							m_Triangles.Add(b);
						}
						Indices.Add(c);
						m_Triangles.Add(c);
						triIndex += 3;
					}
					//fix indexCount
					m_SubMesh.IndexCount = triIndex;
				}
				else if (topology == MeshTopology.Quads)
				{
					for (int q = 0; q < indexCount; q += 4)
					{
						Indices.Add(ProcessedIndexBuffer[firstIndex + q]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + q + 1]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + q + 2]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + q]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + q + 2]);
						Indices.Add(ProcessedIndexBuffer[firstIndex + q + 3]);

						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q + 1]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q + 2]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q + 2]);
						m_Triangles.Add(ProcessedIndexBuffer[firstIndex + q + 3]);
					}
					//fix indexCount
					m_SubMesh.IndexCount = indexCount / 2 * 3;
				}
				else
				{
					//throw new NotSupportedException("Failed getting triangles. Submesh topology is lines or points.");
				}
			}
		}

		private void InitMSkin()
		{
			Skin = new BoneWeights4[VertexCount];
			for (int i = 0; i < VertexCount; i++)
			{
				Skin[i] = new BoneWeights4();
			}
		}

		private void SetUV(int uv, float[] m_UV) => SetUV(uv, MeshHelper.FloatArrayToVector2(m_UV));
		private void SetUV(int uv, Vector2f[] m_UV)
		{
			switch (uv)
			{
				case 0:
					UV0 = m_UV;
					break;
				case 1:
					UV1 = m_UV;
					break;
				case 2:
					UV2 = m_UV;
					break;
				case 3:
					UV3 = m_UV;
					break;
				case 4:
					UV4 = m_UV;
					break;
				case 5:
					UV5 = m_UV;
					break;
				case 6:
					UV6 = m_UV;
					break;
				case 7:
					UV7 = m_UV;
					break;
				default:
					throw new ArgumentOutOfRangeException();
			}
		}

		public Vector2f[] GetUV(int uv)
		{
			return uv switch
			{
				0 => UV0,
				1 => UV1,
				2 => UV2,
				3 => UV3,
				4 => UV4,
				5 => UV5,
				6 => UV6,
				7 => UV7,
				_ => throw new ArgumentOutOfRangeException(),
			};
		}

		public bool MeshOptimized
		{
			get => MeshOptimizationFlags == MeshOptimizationFlags.Everything;
			set => MeshOptimizationFlags = value ? MeshOptimizationFlags.Everything : MeshOptimizationFlags.PolygonOrder;
		}
		public MeshOptimizationFlags MeshOptimizationFlags { get; set; } = MeshOptimizationFlags.Everything;

		public const string LODDataName = "m_LODData";
		public const string Use16BitIndicesName = "m_Use16BitIndices";
		public const string IndexBufferName = "m_IndexBuffer";
		public const string SubMeshesName = "m_SubMeshes";
		public const string ShapesName = "m_Shapes";
		public const string ShapeVerticesName = "m_ShapeVertices";
		public const string BindPoseName = "m_BindPose";
		public const string BoneNameHashesName = "m_BoneNameHashes";
		public const string RootBoneNameHashName = "m_RootBoneNameHash";
		public const string BonesAABBName = "m_BonesAABB";
		public const string VariableBoneCountWeightsName = "m_VariableBoneCountWeights";
		public const string MeshCompressionName = "m_MeshCompression";
		public const string StreamCompressionName = "m_StreamCompression";
		public const string IsReadableName = "m_IsReadable";
		public const string KeepVerticesName = "m_KeepVertices";
		public const string KeepIndicesName = "m_KeepIndices";
		public const string IndexFormatName = "m_IndexFormat";
		public const string VerticesName = "m_Vertices";
		public const string SkinName = "m_Skin";
		public const string UVName = "m_UV";
		public const string UV1Name = "m_UV1";
		public const string TangentSpaceName = "m_TangentSpace";
		public const string TangentsName = "m_Tangents";
		public const string NormalsName = "m_Normals";
		public const string ColorsName = "m_Colors";
		public const string VertexDataName = "m_VertexData";
		public const string CompressedMeshName = "m_CompressedMesh";
		public const string LocalAABBName = "m_LocalAABB";
		public const string CollisionTrianglesName = "m_CollisionTriangles";
		public const string CollisionVertexCountName = "m_CollisionVertexCount";
		public const string MeshUsageFlagsName = "m_MeshUsageFlags";
		public const string BakedConvexCollisionMeshName = "m_BakedConvexCollisionMesh";
		public const string BakedTriangleCollisionMeshName = "m_BakedTriangleCollisionMesh";
		public const string MeshMetricsName = "m_MeshMetrics";
		public const string MeshOptimizedName = "m_MeshOptimized";
		public const string MeshOptimizationFlagsName = "m_MeshOptimizationFlags";
		public const string StreamDataName = "m_StreamData";
	}
}

```

`AssetRipperCore/Classes/Mesh/MeshBlendShape.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class MeshBlendShape : IMeshBlendShapeLegacy
	{
		/// <summary>
		/// Less than 4.3.0
		/// </summary>
		public static bool HasName(UnityVersion version) => version.IsLess(4, 3);
		/// <summary>
		/// Less than 4.3
		/// </summary>
		public static bool HasAABB(UnityVersion version) => version.IsLess(4, 3);

		/// <summary>
		/// 4.3.0 and greater
		/// </summary>
		private static bool IsAlign(UnityVersion version) => version.IsGreaterEqual(4, 3);

		public void Read(AssetReader reader)
		{
			if (HasName(reader.Version))
			{
				Name.Read(reader);
			}

			FirstVertex = reader.ReadUInt32();
			VertexCount = reader.ReadUInt32();
			if (HasAABB(reader.Version))
			{
				AabbMinDelta.Read(reader);
				AabbMaxDelta.Read(reader);
			}

			HasNormals = reader.ReadBoolean();
			HasTangents = reader.ReadBoolean();
			if (IsAlign(reader.Version))
			{
				reader.AlignStream();
			}
		}

		public void Write(AssetWriter writer)
		{
			if (HasName(writer.Version))
			{
				Name.Write(writer);
			}

			writer.Write(FirstVertex);
			writer.Write(VertexCount);
			if (HasAABB(writer.Version))
			{
				AabbMinDelta.Write(writer);
				AabbMaxDelta.Write(writer);
			}

			writer.Write(HasNormals);
			writer.Write(HasTangents);
			if (IsAlign(writer.Version))
			{
				writer.AlignStream();
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			if (HasName(container.ExportVersion))
			{
				node.Add(NameName, Name.String);
			}

			node.Add(FirstVertexName, FirstVertex);
			node.Add(VertexCountName, VertexCount);
			if (HasAABB(container.ExportVersion))
			{
				node.Add(AabbMinDeltaName, AabbMinDelta.ExportYaml(container));
				node.Add(AabbMaxDeltaName, AabbMaxDelta.ExportYaml(container));
			}

			node.Add(HasNormalsName, HasNormals);
			node.Add(HasTangentsName, HasTangents);
			return node;
		}

		/// <summary>
		/// Less than 4.3
		/// </summary>
		public Utf8StringBase Name { get; } = new Utf8StringLegacy();
		public uint FirstVertex { get; set; }
		public uint VertexCount { get; set; }
		public bool HasNormals { get; set; }
		public bool HasTangents { get; set; }
		/// <summary>
		/// Less than 4.3
		/// </summary>
		public IVector3f AabbMinDelta { get; } = new Vector3f();
		/// <summary>
		/// Less than 4.3
		/// </summary>
		public IVector3f AabbMaxDelta { get; } = new Vector3f();

		public const string NameName = "name";
		public const string FirstVertexName = "firstVertex";
		public const string VertexCountName = "vertexCount";
		public const string AabbMinDeltaName = "aabbMinDelta";
		public const string AabbMaxDeltaName = "aabbMaxDelta";
		public const string HasNormalsName = "hasNormals";
		public const string HasTangentsName = "hasTangents";
	}
}

```

`AssetRipperCore/Classes/Mesh/MeshBlendShapeChannel.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class MeshBlendShapeChannel : IMeshBlendShapeChannelLegacy
	{
		public MeshBlendShapeChannel() { }
		public MeshBlendShapeChannel(string name, int frameIndex, int frameCount)
		{
			this.SetValues(name, frameIndex, frameCount);
		}

		public void Read(AssetReader reader)
		{
			Name.Read(reader);
			NameHash = reader.ReadUInt32();
			FrameIndex = reader.ReadInt32();
			FrameCount = reader.ReadInt32();
		}

		public void Write(AssetWriter writer)
		{
			writer.WriteAsset(Name);
			writer.Write(NameHash);
			writer.Write(FrameIndex);
			writer.Write(FrameCount);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(NameName, Name.String);
			node.Add(NameHashName, NameHash);
			node.Add(FrameIndexName, FrameIndex);
			node.Add(FrameCountName, FrameCount);
			return node;
		}

		public Utf8StringBase Name { get; } = new Utf8StringLegacy();
		public uint NameHash { get; set; }
		public int FrameIndex { get; set; }
		public int FrameCount { get; set; }

		public const string NameName = "name";
		public const string NameHashName = "nameHash";
		public const string FrameIndexName = "frameIndex";
		public const string FrameCountName = "frameCount";
	}
}

```

`AssetRipperCore/Classes/Mesh/StreamInfo.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class StreamInfo : IStreamInfoLegacy
	{
		public uint ChannelMask { get; set; }
		public uint Offset { get; set; }
		public uint Stride { get; set; }
		public uint Align { get; set; }
		public byte DividerOp { get; set; }
		public ushort Frequency { get; set; }

		public const string ChannelMaskName = "channelMask";
		public const string OffsetName = "offset";
		public const string StrideName = "stride";
		public const string AlignName = "align";
		public const string DividerOpMaskName = "dividerOp";
		public const string FrequencyMaskName = "frequency";

		public StreamInfo() { }

		public StreamInfo(uint mask, uint offset, uint stride)
		{
			ChannelMask = mask;
			Offset = offset;
			Stride = stride;
			Align = 0;
			DividerOp = 0;
			Frequency = 0;
		}

		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool HasAlign(UnityVersion version) => version.IsLess(4);

		public bool IsMatch(ShaderChannel4 channel)
		{
			return (ChannelMask & (1 << (int)channel)) != 0;
		}

		public void Read(AssetReader reader)
		{
			ChannelMask = reader.ReadUInt32();
			Offset = reader.ReadUInt32();

			if (HasAlign(reader.Version))
			{
				Stride = reader.ReadUInt32();
				Align = reader.ReadUInt32();
			}
			else
			{
				Stride = reader.ReadByte();
				DividerOp = reader.ReadByte();
				Frequency = reader.ReadUInt16();
			}
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(ChannelMask);
			writer.Write(Offset);

			if (HasAlign(writer.Version))
			{
				writer.Write(Stride);
				writer.Write(Align);
			}
			else
			{
				writer.Write((byte)Stride);
				writer.Write(DividerOp);
				writer.Write(Frequency);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(ChannelMaskName, ChannelMask);
			node.Add(OffsetName, Offset);
			node.Add(StrideName, Stride);

			if (HasAlign(container.ExportVersion))
			{
				node.Add(AlignName, Align);
			}
			else
			{
				node.Add(DividerOpMaskName, DividerOp);
				node.Add(FrequencyMaskName, Frequency);
			}
			return node;
		}
	}
}

```

`AssetRipperCore/Classes/Mesh/SubMesh.cs`:

```cs
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class SubMesh : ISubMeshLegacy
	{
		/// <summary>Offset in index buffer</summary>
		public uint FirstByte { get; set; }
		public uint IndexCount { get; set; }
		public MeshTopology Topology { get; set; }
		public uint TriangleCount { get; set; }
		public uint BaseVertex { get; set; }
		/// <summary>Offset in Vertices</summary>
		public uint FirstVertex { get; set; }
		public uint VertexCount { get; set; }
		public IAABB LocalAABB { get; } = new AABB();
		public uint IsTriStrip => (uint)Topology;

		public static int ToSerializedVersion(UnityVersion version)
		{
			// IsTriStrip has been replaced by Topology
			if (version.IsGreaterEqual(4))
			{
				return 2;
			}
			return 1;
		}

		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool HasTriangleCount(UnityVersion version) => version.IsLess(4);
		/// <summary>
		/// 3.0.0 and greater
		/// </summary>
		public static bool HasVertex(UnityVersion version) => version.IsGreaterEqual(3);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool HasBaseVertex(UnityVersion version) => version.IsGreaterEqual(2017, 3);

		public void Read(AssetReader reader)
		{
			FirstByte = reader.ReadUInt32();
			IndexCount = reader.ReadUInt32();
			Topology = (MeshTopology)reader.ReadInt32();
			if (HasTriangleCount(reader.Version))
			{
				TriangleCount = reader.ReadUInt32();
			}
			if (HasBaseVertex(reader.Version))
			{
				BaseVertex = reader.ReadUInt32();
			}
			if (HasVertex(reader.Version))
			{
				FirstVertex = reader.ReadUInt32();
				VertexCount = reader.ReadUInt32();
				LocalAABB.Read(reader);
			}
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(FirstByte);
			writer.Write(IndexCount);
			writer.Write((int)Topology);
			if (HasTriangleCount(writer.Version))
			{
				writer.Write(TriangleCount);
			}
			if (HasBaseVertex(writer.Version))
			{
				writer.Write(BaseVertex);
			}
			if (HasVertex(writer.Version))
			{
				writer.Write(FirstVertex);
				writer.Write(VertexCount);
				LocalAABB.Write(writer);
			}
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			node.Add(FirstByteName, FirstByte);
			node.Add(IndexCountName, IndexCount);
			if (HasTriangleCount(container.ExportVersion))
			{
				node.Add(IsTriStripName, (int)Topology);
				node.Add(TriangleCountName, TriangleCount);
			}
			else
			{
				node.Add(TopologyName, (int)Topology);
			}
			if (HasBaseVertex(container.ExportVersion))
			{
				node.Add(BaseVertexName, BaseVertex);
			}
			if (HasVertex(container.ExportVersion))
			{
				node.Add(FirstVertexName, FirstVertex);
				node.Add(VertexCountName, VertexCount);
				node.Add(LocalAABBName, LocalAABB.ExportYaml(container));
			}
			return node;
		}

		public MeshTopology GetTopology(UnityVersion version)
		{
			if (ToSerializedVersion(version) >= 2)
			{
				return Topology;
			}
			else
			{
				return IsTriStrip == 0 ? MeshTopology.Triangles : MeshTopology.TriangleStrip;
			}
		}


		public const string FirstByteName = "firstByte";
		public const string IndexCountName = "indexCount";
		public const string IsTriStripName = "isTriStrip";
		public const string TopologyName = "topology";
		public const string TriangleCountName = "triangleCount";
		public const string BaseVertexName = "baseVertex";
		public const string FirstVertexName = "firstVertex";
		public const string VertexCountName = "vertexCount";
		public const string LocalAABBName = "localAABB";
	}
}

```

`AssetRipperCore/Classes/Mesh/VariableBoneCountWeights.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;

namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class VariableBoneCountWeights
	{
		public void Read(AssetReader reader)
		{
			Data = reader.ReadUInt32Array();
		}

		public void Write(AssetWriter writer)
		{
			Data.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(DataName, Data.ExportYaml(true));
			return node;
		}

		public uint[] Data { get; set; } = Array.Empty<uint>();

		public const string DataName = "m_Data";
	}
}

```

`AssetRipperCore/Classes/Mesh/VertexData.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Converters.Mesh;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.Core.Utils;

using AssetRipper.Yaml;
using AssetRipper.Yaml.Extensions;
using System.Collections;
using System.IO;
using System.Linq;


namespace AssetRipper.Core.Classes.Mesh
{
	public sealed class VertexData : UnityAssetBase, IVertexDataLegacy
	{
		public static int ToSerializedVersion(UnityVersion version)
		{
			// VertexFormat enum has been changed
			if (VertexFormatExtensions.VertexFormat2019Relevant(version))
			{
				return 3;
			}
			// ShaderChannel enum has been changed
			if (ShaderChannelExtensions.ShaderChannel2018Relevant(version))
			{
				return 2;
			}
			return 1;
		}

		/// <summary>
		/// Less than 2018.1
		/// </summary>
		public static bool HasCurrentChannels(UnityVersion version) => version.IsLess(2018);
		/// <summary>
		/// 4.0.0 and greater
		/// </summary>
		public static bool HasChannels(UnityVersion version) => version.IsGreaterEqual(4);
		/// <summary>
		/// Less than 5.0.0
		/// </summary>
		public static bool HasStreams(UnityVersion version) => version.IsLess(5);

		/// <summary>
		/// Less than 4.0.0
		/// </summary>
		public static bool IsStreamStatic(UnityVersion version) => version.IsLess(4);

		/// <summary>
		/// 5.6.0
		/// </summary>
		private static bool AllowUnsetVertexChannel(UnityVersion version) => version.IsEqual(5, 6, 0);

		public ChannelInfo GetChannel(UnityVersion version, ShaderChannel channelType)
		{
			if (HasChannels(version))
			{
				return m_Channels[channelType.ToChannel(version)];
			}
			else
			{
				return StreamInfoConverter.GenerateChannelInfo(version, m_Streams, channelType);
			}
		}

		public BoneWeights4[] GenerateSkin(IExportContainer container)
		{
			ChannelInfo weightChannel = m_Channels[(int)ShaderChannel2018.SkinWeight];
			ChannelInfo indexChannel = m_Channels[(int)ShaderChannel2018.SkinBoneIndex];
			if (!weightChannel.IsSet())
			{
				return Array.Empty<BoneWeights4>();
			}

			BoneWeights4[] skin = new BoneWeights4[VertexCount];
			int weightStride = m_Channels.Where(t => t.Stream == weightChannel.Stream).Sum(t => t.GetStride(container.Version));
			int weightStreamOffset = GetStreamOffset(container.Version, weightChannel.Stream);
			int indexStride = m_Channels.Where(t => t.Stream == indexChannel.Stream).Sum(t => t.GetStride(container.Version));
			int indexStreamOffset = GetStreamOffset(container.Version, indexChannel.Stream);

			using MemoryStream memStream = new MemoryStream(Data);
			using BinaryReader reader = new BinaryReader(memStream);

			int weightCount = System.Math.Min((int)weightChannel.GetDataDimension(), 4);
			int indexCount = System.Math.Min((int)indexChannel.GetDataDimension(), 4);
			float[] weights = new float[System.Math.Max(weightCount, 4)];
			int[] indices = new int[System.Math.Max(indexCount, 4)];
			for (int v = 0; v < VertexCount; v++)
			{
				memStream.Position = weightStreamOffset + (v * weightStride) + weightChannel.Offset;
				for (int i = 0; i < weightCount; i++)
				{
					weights[i] = reader.ReadSingle();
				}

				memStream.Position = indexStreamOffset + (v * indexStride) + indexChannel.Offset;
				for (int i = 0; i < indexCount; i++)
				{
					indices[i] = reader.ReadInt32();
				}

				skin[v] = new BoneWeights4(weights[0], weights[1], weights[2], weights[3], indices[0], indices[1], indices[2], indices[3]);
			}
			return skin;
		}

		public Vector3f[] GenerateVertices(UnityVersion version, ISubMeshLegacy submesh)
		{
			ChannelInfo channel = GetChannel(version, ShaderChannel.Vertex);
			if (!channel.IsSet())
			{
				if (AllowUnsetVertexChannel(version))
				{
					return Array.Empty<Vector3f>();
				}
				else
				{
					throw new Exception("Vertices hasn't been found");
				}
			}

			Vector3f[] verts = new Vector3f[submesh.VertexCount];
			int streamStride = m_Channels.Where(t => t.Stream == channel.Stream).Sum(t => t.GetStride(version));
			int streamOffset = GetStreamOffset(version, channel.Stream);
			using (MemoryStream memStream = new MemoryStream(Data))
			{
				using BinaryReader reader = new BinaryReader(memStream);
				memStream.Position = streamOffset + (submesh.FirstVertex * streamStride) + channel.Offset;
				for (int v = 0; v < submesh.VertexCount; v++)
				{
					float x = reader.ReadSingle();
					float y = reader.ReadSingle();
					float z = reader.ReadSingle();
					verts[v] = new Vector3f(x, y, z);
					memStream.Position += streamStride - 12;
				}
			}
			return verts;
		}

		public override void Read(AssetReader reader)
		{
			if (HasCurrentChannels(reader.Version))
			{
				CurrentChannels = reader.ReadUInt32();
			}
			VertexCount = reader.ReadUInt32();

			if (HasChannels(reader.Version)) // 4 and greater
			{
				m_Channels = reader.ReadAssetArray<ChannelInfo>();
				reader.AlignStream();
			}

			if (HasStreams(reader.Version)) // less than 5
			{
				if (IsStreamStatic(reader.Version)) // less than 4
				{
					m_Streams = new StreamInfo[StaticStreamCount];
					for (int i = 0; i < StaticStreamCount; i++)
					{
						m_Streams[i] = reader.ReadAsset<StreamInfo>();
					}
				}
				else // 4.x.x
				{
					m_Streams = reader.ReadAssetArray<StreamInfo>();
				}
			}
			else //5 and higher
			{
				//Uses channels to get streams
				GetStreams(reader.Version);
			}

			if (!HasChannels(reader.Version)) //less than 4
			{
				//Uses streams to get channels
				GetChannels(reader.Version);
			}

			Data = reader.ReadByteArray();
			reader.AlignStream();
		}

		public override void Write(AssetWriter writer)
		{
			if (HasCurrentChannels(writer.Version))
			{
				writer.Write(CurrentChannels);
			}
			writer.Write(VertexCount);

			if (HasChannels(writer.Version))
			{
				m_Channels.Write(writer);
				writer.AlignStream();
			}
			if (HasStreams(writer.Version))
			{
				if (IsStreamStatic(writer.Version))
				{
					for (int i = 0; i < StaticStreamCount; i++)
					{
						writer.WriteAsset(m_Streams[i]);
					}
				}
				else
				{
					m_Channels.Write(writer);
				}
			}

			Data.Write(writer);
			writer.AlignStream();
		}

		public override YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
			if (HasCurrentChannels(container.ExportVersion))
			{
				node.Add(CurrentChannelsName, CurrentChannels);
			}
			node.Add(VertexCountName, VertexCount);

			if (HasChannels(container.ExportVersion))
			{
				node.Add(ChannelsName, m_Channels.ExportYaml(container));
			}
			if (HasStreams(container.ExportVersion))
			{
				if (IsStreamStatic(container.ExportVersion))
				{
					for (int i = 0; i < StaticStreamCount; i++)
					{
						node.Add($"{StreamsName}[{i}]", m_Streams[i].ExportYaml(container));
					}
				}
				else
				{
					node.Add(StreamsName, m_Streams.ExportYaml(container));
				}
			}

			node.Add(DataSizeName, Data.Length);
			node.Add(Layout.ClassNameHandler.TypelessdataName, Data.ExportYaml());
			return node;
		}

		public int GetStreamStride(UnityVersion version, int stream)
		{
			return HasStreams(version) ?
				(int)m_Streams[stream].Stride : m_Channels.Where(t => t.IsSet() && t.Stream == stream).Sum(t => t.GetStride(version));
		}

		public int GetStreamSize(UnityVersion version, int stream)
		{
			return GetStreamStride(version, stream) * (int)VertexCount;
		}

		public int GetStreamOffset(UnityVersion version, int stream)
		{
			int offset = 0;
			for (int i = 0; i < stream; i++)
			{
				offset += GetStreamSize(version, i);
				offset = (offset + (VertexStreamAlign - 1)) & ~(VertexStreamAlign - 1);
			}
			return offset;
		}

		private void GetStreams(UnityVersion version)
		{
			var streamCount = m_Channels.Max(x => x.Stream) + 1;
			m_Streams = new StreamInfo[streamCount];
			long offset = 0;
			for (int s = 0; s < streamCount; s++)
			{
				uint chnMask = 0;
				uint stride = 0;
				for (int chn = 0; chn < m_Channels.Length; chn++)
				{
					var m_Channel = m_Channels[chn];
					if (m_Channel.Stream == s)
					{
						if (m_Channel.GetDataDimension() > 0)
						{
							chnMask |= 1u << chn;
							stride += m_Channel.GetDataDimension() * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.Format, version));
						}
					}
				}
				m_Streams[s] = new StreamInfo
				{
					ChannelMask = chnMask,
					Offset = (uint)offset,
					Stride = stride,
					DividerOp = 0,
					Frequency = 0
				};
				offset += VertexCount * stride;
				//static size_t AlignStreamSize (size_t size) { return (size + (kVertexStreamAlign-1)) & ~(kVertexStreamAlign-1); }
				offset = (offset + (16u - 1u)) & ~(16u - 1u);
			}
		}

		private void GetChannels(UnityVersion version)
		{
			m_Channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(6);
			for (var s = 0; s < m_Streams.Length; s++)
			{
				var m_Stream = m_Streams[s];
				var channelMask = new BitArray(new[] { (int)m_Stream.ChannelMask });
				byte offset = 0;
				for (int i = 0; i < 6; i++)
				{
					if (channelMask.Get(i))
					{
						ChannelInfo m_Channel = m_Channels[i];
						m_Channel.Stream = (byte)s;
						m_Channel.Offset = offset;
						switch (i)
						{
							case 0: //kShaderChannelVertex
							case 1: //kShaderChannelNormal
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(3);
								break;
							case 2: //kShaderChannelColor
								m_Channel.Format = 2; //kChannelFormatColor
								m_Channel.SetDataDimension(4);
								break;
							case 3: //kShaderChannelTexCoord0
							case 4: //kShaderChannelTexCoord1
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(2);
								break;
							case 5: //kShaderChannelTangent
								m_Channel.Format = 0; //kChannelFormatFloat
								m_Channel.SetDataDimension(4);
								break;
						}
						offset += (byte)(m_Channel.GetDataDimension() * MeshHelper.GetFormatSize(MeshHelper.ToVertexFormat(m_Channel.Format, version)));
					}
				}
			}
		}

		public uint CurrentChannels { get; set; }
		public uint VertexCount { get; set; }
		public ChannelInfo[] m_Channels { get; set; }
		public IChannelInfoLegacy[] Channels => m_Channels;
		public StreamInfo[] m_Streams { get; set; }
		public IStreamInfoLegacy[] Streams => m_Streams;
		public byte[] Data { get; set; }

		public const string CurrentChannelsName = "m_CurrentChannels";
		public const string VertexCountName = "m_VertexCount";
		public const string ChannelsName = "m_Channels";
		public const string StreamsName = "m_Streams";
		public const string DataSizeName = "m_DataSize";

		private const int StaticStreamCount = 4;
		private const int VertexStreamAlign = 16;
	}
}

```

`AssetRipperCore/Classes/Misc/StreamingInfo.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Misc
{
	public sealed class StreamingInfo : UnityAssetBase, IStreamingInfo
	{
		/// <summary>
		/// 2020 and greater
		/// </summary>
		public static bool IsOffsetInt64(UnityVersion version) => version.IsGreaterEqual(2020);

		public override void Read(AssetReader reader)
		{
			if (IsOffsetInt64(reader.Version))
			{
				Offset = reader.ReadInt64();
			}
			else
			{
				Offset = reader.ReadUInt32();
			}

			Size = reader.ReadUInt32();
			Path = reader.ReadString();
		}

		/// <summary>
		/// Exclusively for AudioClip in Unity versions less than 5
		/// </summary>
		public void Read(AssetReader reader, string path)
		{
			Size = reader.ReadUInt32();
			Offset = reader.ReadUInt32();
			Path = path;
		}

		public override void Write(AssetWriter writer)
		{
			writer.Write((uint)Offset);
			writer.Write(Size);
			writer.Write(Path);
		}

		public override YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(OffsetName, (uint)Offset);
			node.Add(SizeName, Size);
			node.Add(PathName, Path);
			return node;
		}

		public const string OffsetName = "offset";
		public const string SizeName = "size";
		public const string PathName = "path";

		public long Offset { get; set; }
		public uint Size { get; set; }
		public string Path { get; set; } = string.Empty;
	}
}

```

`AssetRipperCore/Classes/NamedObject.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes
{
	public abstract class NamedObject : EditorExtension, INamedObject
	{
		protected NamedObject(LayoutInfo layout) : base(layout)
		{
			NameString = string.Empty;
		}

		protected NamedObject(AssetInfo assetInfo) : base(assetInfo) { }

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			NameString = reader.ReadString();
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			writer.Write(NameString);
		}

		public override string ToString()
		{
			return $"{this.GetValidName()}({GetType().Name})";
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode root = base.ExportYamlRoot(container);
			root.Add(NameName, NameString);
			return root;
		}

		public string NameString { get; set; }

		public const string NameName = "m_Name";
	}
}

```

`AssetRipperCore/Classes/Object/Object.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;

namespace AssetRipper.Core.Classes.Object
{
	public abstract class Object : UnityObjectBase
	{
		protected Object(LayoutInfo layout) : base(layout) { }

		protected Object(AssetInfo assetInfo) : base(assetInfo) { }

		public override void Read(AssetReader reader)
		{
			if (HasHideFlag(reader.Version, reader.Flags))
			{
				m_ObjectHideFlags = reader.ReadUInt32();
			}
		}

		public override void Write(AssetWriter writer)
		{
			if (HasHideFlag(writer.Version, writer.Flags))
			{
				writer.Write(m_ObjectHideFlags);
			}
		}

		public sealed override YamlNode ExportYaml(IExportContainer container)
		{
			return ExportYamlRoot(container);
		}

		protected virtual YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			if (HasHideFlag(container.ExportVersion, container.ExportFlags))
			{
				node.Add(ObjectHideFlagsName, m_ObjectHideFlags);
			}
			return node;
		}

		/// <summary>
		/// greater than 2.0.0 and Not Release
		/// </summary>
		public static bool HasHideFlag(UnityVersion version, TransferInstructionFlags flags) => version.IsGreaterEqual(2) && !flags.IsRelease();

		private uint m_ObjectHideFlags;

		public const string ObjectHideFlagsName = "m_ObjectHideFlags";
		public const string InstanceIDName = "m_InstanceID";
		public const string LocalIdentfierInFileName = "m_LocalIdentfierInFile";
	}
}

```

`AssetRipperCore/Classes/Prefab.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes
{
	public sealed class Prefab : Object.Object
	{
		public Prefab(LayoutInfo layout) : base(layout) { }

		public Prefab(AssetInfo assetInfo) : base(assetInfo) { }

		/// <summary>
		/// 2020 and greater
		/// </summary>
		public static bool HasHideFlagsBehavior(UnityVersion version) => version.IsGreaterEqual(2020);
		/// <summary>
		/// 2021.2 and greater
		/// </summary>
		public static bool HasContainsMissingSerializeReferenceTypes(UnityVersion version) => version.IsGreaterEqual(2021, 2);

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			RootGameObject.Read(reader);

			if (HasHideFlagsBehavior(reader.Version))
			{
				HideFlagsBehavior = reader.ReadInt32();
			}

			if (HasContainsMissingSerializeReferenceTypes(reader.Version))
			{
				reader.ReadBoolean();
			}
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			RootGameObject.Write(writer);

			if (HasHideFlagsBehavior(writer.Version))
			{
				writer.Write(HideFlagsBehavior);
			}
		}

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}

			yield return context.FetchDependency(RootGameObject, RootGameObjectName);
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			node.Add(RootGameObjectName, RootGameObject.ExportYaml(container));
			return node;
		}

		public override ClassIDType ClassID => ClassIDType.Prefab;

		public PPtr<GameObject.GameObject> RootGameObject = new();
		public int HideFlagsBehavior { get; set; }
		public const string RootGameObjectName = "m_RootGameObject";
	}
}

```

`AssetRipperCore/Classes/PrefabInstance/PrefabInstance.cs`:

```cs
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.PrefabInstance
{
	public sealed class PrefabInstance : NamedObject, IPrefabInstance
	{
		public PrefabInstance(LayoutInfo layout) : base(layout)
		{
			Objects = Array.Empty<PPtr<EditorExtension>>();
		}

		public PrefabInstance(AssetInfo assetInfo) : base(assetInfo)
		{
			Objects = Array.Empty<PPtr<EditorExtension>>();
		}

		public static int ToSerializedVersion(UnityVersion version)
		{
			if (version.IsGreaterEqual(3, 5))
			{
				// NOTE: unknown conversion
				return 2;
			}
			else
			{
				return 1;
			}
		}

		public override void Read(AssetReader reader)
		{
			if (IsModificationFormat(reader.Version))
			{
				ReadObject(reader);

				if (HasRootGameObject(reader.Version, reader.Flags) && IsRootGameObjectFirst(reader.Version))
				{
					RootGameObject.Read(reader);
				}

				Modification.Read(reader);
				SourcePrefab.Read(reader);
				if (!IsRootGameObjectFirst(reader.Version))
				{
					RootGameObject.Read(reader);
				}
				if (HasIsPrefabAsset(reader.Version))
				{
					IsPrefabAsset = reader.ReadBoolean();
				}
				if (HasIsExploded(reader.Version))
				{
					IsExploded = reader.ReadBoolean();
				}
				reader.AlignStream();
			}
			else
			{
				LastMergeIdentifier.Read(reader);
				if (HasLastTemplateIdentifier(reader.Version))
				{
					LastTemplateIdentifier.Read(reader);
				}
				Objects = reader.ReadAssetArray<PPtr<EditorExtension>>();
				Father = reader.ReadAsset<PPtr<PrefabInstance>>();
				IsDataTemplate = reader.ReadBoolean();
				reader.AlignStream();

				base.Read(reader);
			}
		}

		public override void Write(AssetWriter writer)
		{
			if (IsModificationFormat(writer.Version))
			{
				WriteObject(writer);

				if (HasRootGameObject(writer.Version, writer.Flags) && IsRootGameObjectFirst(writer.Version))
				{
					RootGameObject.Write(writer);
				}

				Modification.Write(writer);
				SourcePrefab.Write(writer);
				if (!IsRootGameObjectFirst(writer.Version))
				{
					RootGameObject.Write(writer);
				}
				if (HasIsPrefabAsset(writer.Version))
				{
					writer.Write(IsPrefabAsset);
				}
				if (HasIsExploded(writer.Version))
				{
					writer.Write(IsExploded);
				}
				writer.AlignStream();
			}
			else
			{
				LastMergeIdentifier.Write(writer);
				if (HasLastTemplateIdentifier(writer.Version))
				{
					LastTemplateIdentifier.Write(writer);
				}
				Objects.Write(writer);
				Father.Write(writer);
				writer.Write(IsDataTemplate);
				writer.AlignStream();

				base.Write(writer);
			}
		}

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			if (IsModificationFormat(context.Version))
			{
				foreach (PPtr<IUnityObjectBase> asset in FetchDependenciesObject(context))
				{
					yield return asset;
				}

				if (HasRootGameObject(context.Version, context.Flags))
				{
					yield return context.FetchDependency(RootGameObject, RootGameObjectName);
				}
				foreach (PPtr<IUnityObjectBase> asset in context.FetchDependenciesFromDependent(Modification, ModificationName))
				{
					yield return asset;
				}
				yield return context.FetchDependency(SourcePrefab, SourcePrefabName);
			}
			else
			{
				foreach (PPtr<IUnityObjectBase> asset in context.FetchDependencies(Objects, ObjectsName))
				{
					yield return asset;
				}
				yield return context.FetchDependency(Father, FatherName);

				foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
				{
					yield return asset;
				}
			}
		}

		public override string ToString()
		{
			return $"{NameString}({nameof(PrefabInstance)})";
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			if (IsModificationFormat(container.ExportVersion))
			{
				YamlMappingNode node = ExportYamlRootObject(container);
				node.AddSerializedVersion(ToSerializedVersion(container.ExportVersion));
				if (HasRootGameObject(container.ExportVersion, container.ExportFlags) && IsRootGameObjectFirst(container.ExportVersion))
				{
					node.Add(RootGameObjectName, RootGameObject.ExportYaml(container));
				}

				node.Add(ModificationName, Modification.ExportYaml(container));
				node.Add(SourcePrefabInvariantName(container.ExportVersion), SourcePrefab.ExportYaml(container));
				if (!IsRootGameObjectFirst(container.ExportVersion))
				{
					node.Add(RootGameObjectName, RootGameObject.ExportYaml(container));
				}
				if (HasIsPrefabAssetInvariant(container.ExportVersion))
				{
					node.Add(IsPrefabAssetInvariantName(container.ExportVersion), IsPrefabAsset);
				}
				if (HasIsExploded(container.ExportVersion))
				{
					node.Add(IsExplodedName, IsExploded);
				}
				return node;
			}
			else
			{
				YamlMappingNode node = new YamlMappingNode();
				node.Add(LastMergeIdentifierName, LastMergeIdentifier.ExportYaml(container));
				if (HasLastTemplateIdentifier(container.ExportVersion))
				{
					node.Add(LastTemplateIdentifierName, LastTemplateIdentifier.ExportYaml(container));
				}
				node.Add(ObjectsName, Objects.ExportYaml(container));
				node.Add(FatherName, Father.ExportYaml(container));
				node.Add(IsDataTemplateName, IsDataTemplate);

				YamlMappingNode baseNode = base.ExportYamlRoot(container);
				node.Append(baseNode);
				return node;
			}
		}

		public static string SourcePrefabInvariantName(UnityVersion version)
		{
			if (version.IsGreaterEqual(2018, 2))
			{
				return SourcePrefabName;
			}
			else if (version.IsGreaterEqual(3, 5))
			{
				return ParentPrefabName;
			}
			else
			{
				return FatherName;
			}
		}

		public static string IsPrefabAssetInvariantName(UnityVersion version)
		{
			if (version.IsGreaterEqual(2018, 2))
			{
				return IsPrefabAssetName;
			}
			else if (version.IsGreaterEqual(3, 5))
			{
				return IsPrefabParentName;
			}
			else
			{
				return IsDataTemplateName;
			}
		}

		#region VersionMethods
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasLastMergeIdentifier(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// Less than 2.6.0
		/// </summary>
		public static bool HasLastTemplateIdentifier(UnityVersion version) => version.IsLess(2, 6);
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasObjects(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// 3.5.0 and greater
		/// </summary>
		public static bool HasModification(UnityVersion version) => version.IsGreaterEqual(3, 5);
		/// <summary>
		/// 2018.2 and greater
		/// </summary>
		public static bool HasSourcePrefab(UnityVersion version) => version.IsGreaterEqual(2018, 2);
		/// <summary>
		/// 3.5.0 to 2018.2 exclusive
		/// </summary>
		public static bool HasParentPrefab(UnityVersion version) => version.IsGreaterEqual(3, 5) && version.IsLess(2018, 2);
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasFather(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// (3.5.0 to 2018.3 exclusive) or (2018.3 and greater and Editor Scene)
		/// </summary>
		public static bool HasRootGameObject(UnityVersion version, TransferInstructionFlags flags)
		{
			return (version.IsGreaterEqual(3, 5) && version.IsLess(2018, 3)) ||
				(flags.IsEditorScene() && version.IsGreaterEqual(2018, 3));
		}
		/// <summary>
		/// Less than 2018.3
		/// </summary>
		public static bool HasIsPrefabAssetInvariant(UnityVersion version) => version.IsLess(2018, 3);
		/// <summary>
		/// 2018.2 and greater
		/// </summary>
		public static bool HasIsPrefabAsset(UnityVersion version) => version.IsGreaterEqual(2018, 2);
		/// <summary>
		/// 3.5.0 to 2018.2 exclusive
		/// </summary>
		public static bool HasIsPrefabParent(UnityVersion version) => version.IsGreaterEqual(3, 5) && version.IsLess(2018, 2);
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasIsDataTemplate(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool HasIsExploded(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// 3.5.0 and greater
		/// </summary>
		public static bool IsModificationFormat(UnityVersion version) => version.IsGreaterEqual(3, 5);
		/// <summary>
		/// 3.5.0 and greater
		/// </summary>
		public static bool IsInheritedFromObject(UnityVersion version) => version.IsGreaterEqual(3, 5);
		/// <summary>
		/// Less than 3.5.0
		/// </summary>
		public static bool IsInheritedFromNamedObject(UnityVersion version) => version.IsLess(3, 5);
		/// <summary>
		/// 2018.3 and greater
		/// </summary>
		public static bool IsRootGameObjectFirst(UnityVersion version) => version.IsGreaterEqual(2018, 3);
		#endregion


		public override string ExportExtension => PrefabKeyword;

		public PPtr<EditorExtension>[] Objects { get; set; }
		public PPtr<PrefabInstance> ParentPrefab
		{
			get => SourcePrefab;
			set => SourcePrefab = value;
		}
		// NOTE: unknown version
		public PPtr<PrefabInstance> Prefab
		{
			get => SourcePrefab;
			set => SourcePrefab = value;
		}
		public PPtr<PrefabInstance> Father
		{
			get => SourcePrefab;
			set => SourcePrefab = value;
		}
		public bool IsPrefabAsset { get; set; }
		public bool IsPrefabParent
		{
			get => IsPrefabAsset;
			set => IsPrefabAsset = value;
		}
		public bool IsDataTemplate
		{
			get => IsPrefabAsset;
			set => IsPrefabAsset = value;
		}
		public bool IsExploded { get; set; }

		public const string PrefabKeyword = "prefab";

		public UnityGUID LastMergeIdentifier = new();
		public UnityGUID LastTemplateIdentifier = new();
		public PrefabModification Modification = new();
		public PPtr<PrefabInstance> SourcePrefab = new();
		public PPtr<GameObject.GameObject> RootGameObject = new();

		public PPtr<IGameObject> RootGameObjectPtr
		{
			get => RootGameObject.CastTo<IGameObject>();
			set => RootGameObject = value.CastTo<GameObject.GameObject>();
		}
		public PPtr<IPrefabInstance> SourcePrefabPtr
		{
			get => SourcePrefab.CastTo<IPrefabInstance>();
			set => SourcePrefab = value.CastTo<PrefabInstance>();
		}

		public const string LastMergeIdentifierName = "m_LastMergeIdentifier";
		public const string LastTemplateIdentifierName = "m_LastTemplateIdentifier";
		public const string ObjectsName = "m_Objects";
		public const string ModificationName = "m_Modification";
		public const string SourcePrefabName = "m_SourcePrefab";
		public const string ParentPrefabName = "m_ParentPrefab";
		public const string FatherName = "m_Father";
		public const string RootGameObjectName = "m_RootGameObject";
		public const string IsPrefabAssetName = "m_IsPrefabAsset";
		public const string IsPrefabParentName = "m_IsPrefabParent";
		public const string IsDataTemplateName = "m_IsDataTemplate";
		public const string IsExplodedName = "m_IsExploded";
	}
}

```

`AssetRipperCore/Classes/PrefabInstance/PrefabModification.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.PrefabInstance
{
	public sealed class PrefabModification : IAsset, IDependent
	{
		public void Read(AssetReader reader)
		{
			TransformParent.Read(reader);
			Modifications = reader.ReadAssetArray<PropertyModification>();
			RemovedComponents = reader.ReadAssetArray<PPtr<Component>>();
		}

		public void Write(AssetWriter writer)
		{
			TransformParent.Write(writer);
			Modifications.Write(writer);
			RemovedComponents.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(TransformParentName, TransformParent.ExportYaml(container));
			node.Add(ModificationsName, Modifications.ExportYaml(container));
			node.Add(RemovedComponentsName, RemovedComponents.ExportYaml(container));
			return node;
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			yield return context.FetchDependency(TransformParent, TransformParentName);
			foreach (PPtr<IUnityObjectBase> asset in context.FetchDependenciesFromArray(Modifications, ModificationsName))
			{
				yield return asset;
			}
			foreach (PPtr<IUnityObjectBase> asset in context.FetchDependencies(RemovedComponents, RemovedComponentsName))
			{
				yield return asset;
			}
		}

		public PropertyModification[] Modifications { get; set; } = Array.Empty<PropertyModification>();
		/// <summary>
		/// PPtr Object [] before 2018.3
		/// </summary>
		public PPtr<Component>[] RemovedComponents { get; set; } = Array.Empty<PPtr<Component>>();

		public PPtr<Transform> TransformParent = new();

		public const string TransformParentName = "m_TransformParent";
		public const string ModificationsName = "m_Modifications";
		public const string RemovedComponentsName = "m_RemovedComponents";
	}
}

```

`AssetRipperCore/Classes/PrefabInstance/PropertyModification.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.Core.Classes.PrefabInstance
{
	public sealed class PropertyModification : IAsset, IDependent
	{
		public PropertyModification() { }
		public PropertyModification(LayoutInfo info)
		{
			PropertyPath = string.Empty;
			Value = string.Empty;
			Target = new();
			ObjectReference = new();
		}

		public void Read(AssetReader reader)
		{
			Target.Read(reader);
			PropertyPath = reader.ReadString();
			Value = reader.ReadString();
			ObjectReference.Read(reader);
		}

		public void Write(AssetWriter writer)
		{
			Target.Write(writer);
			writer.Write(PropertyPath);
			writer.Write(Value);
			ObjectReference.Write(writer);
		}

		public YamlNode ExportYaml(IExportContainer container)
		{
			YamlMappingNode node = new YamlMappingNode();
			node.Add(TargetName, Target.ExportYaml(container));
			node.Add(PropertyPathName, PropertyPath);
			node.Add(ValueName, Value);
			node.Add(ObjectReferenceName, ObjectReference.ExportYaml(container));
			return node;
		}

		public IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			yield return context.FetchDependency(Target, TargetName);
			yield return context.FetchDependency(ObjectReference, ObjectReferenceName);
		}

		public string PropertyPath { get; set; }
		public string Value { get; set; }

		public PPtr<Object.Object> Target = new();
		public PPtr<Object.Object> ObjectReference = new();

		public const string TargetName = "target";
		public const string PropertyPathName = "propertyPath";
		public const string ValueName = "value";
		public const string ObjectReferenceName = "objectReference";
	}
}

```

`AssetRipperCore/Classes/Transform.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Converters;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.IO.Extensions;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Core.Classes
{
	public class Transform : Component, ITransform
	{
		/// <summary>
		/// 4.5.0 and greater and Not Release
		/// </summary>
		public static bool HasRootOrder(UnityVersion version, TransferInstructionFlags flags)
		{
			return version.IsGreaterEqual(4, 5) && !flags.IsRelease();
		}
		/// <summary>
		/// 5.0.0 and greater and Not Release
		/// </summary>
		public static bool HasLocalEulerAnglesHint(UnityVersion version, TransferInstructionFlags flags)
		{
			return version.IsGreaterEqual(5) && !flags.IsRelease();
		}

		/// <summary>
		/// 2021.2 and greater
		/// </summary>
		public static bool HasConstrainProportionsScale(UnityVersion version) => version.IsGreaterEqual(2021, 2);

		public Transform(LayoutInfo layout) : base(layout)
		{
			Children = Array.Empty<PPtr<Transform>>();
		}

		public Transform(AssetInfo assetInfo) : base(assetInfo) { }

		public IUnityObjectBase ConvertLegacy(IExportContainer container)
		{
			return TransformConverter.Convert(container, this);
		}

		public override void Read(AssetReader reader)
		{
			base.Read(reader);

			m_LocalRotation.Read(reader);
			m_LocalPosition.Read(reader);
			m_LocalScale.Read(reader);

			if (HasConstrainProportionsScale(reader.Version))
			{
				if (!reader.Flags.IsRelease())
				{
					reader.ReadBoolean(); //ConstraintProportionsScale
				}

				reader.AlignStream(); //Either way we have to align here.
			}

			Children = reader.ReadAssetArray<PPtr<Transform>>();
			Father.Read(reader);
		}

		public override void Write(AssetWriter writer)
		{
			base.Write(writer);

			m_LocalRotation.Write(writer);
			m_LocalPosition.Write(writer);
			m_LocalScale.Write(writer);
			Children.Write(writer);
			Father.Write(writer);
		}

		public override IEnumerable<PPtr<IUnityObjectBase>> FetchDependencies(DependencyContext context)
		{
			foreach (PPtr<IUnityObjectBase> asset in base.FetchDependencies(context))
			{
				yield return asset;
			}

			foreach (PPtr<IUnityObjectBase> asset in context.FetchDependencies(Children, ChildrenName))
			{
				yield return asset;
			}
			yield return context.FetchDependency(Father, FatherName);
		}

		protected override YamlMappingNode ExportYamlRoot(IExportContainer container)
		{
			YamlMappingNode node = base.ExportYamlRoot(container);
			node.Add(LocalRotationName, m_LocalRotation.ExportYaml(container));
			node.Add(LocalPositionName, m_LocalPosition.ExportYaml(container));
			node.Add(LocalScaleName, m_LocalScale.ExportYaml(container));
			node.Add(ChildrenName, Children.ExportYaml(container));
			node.Add(FatherName, Father.ExportYaml(container));
			node.Add(RootOrderName, RootOrder);
			node.Add(LocalEulerAnglesHintName, LocalEulerAnglesHint.ExportYaml(container));
			return node;
		}

		public PPtr<ITransform> FatherPtr => Father.CastTo<ITransform>();
		public PPtr<ITransform>[] ChildrenPtrs => Children.Select(child => child.CastTo<ITransform>()).ToArray();

		public PPtr<Transform>[] Children { get; set; }

		private int RootOrder
		{
			get
			{
				if (this.Father.IsNull)
				{
					return 0;
				}
				Transform father = Father.GetAsset(SerializedFile);
				PPtr<Transform>[] children = father.Children;
				for (int i = 0; i < children.Length; i++)
				{
					PPtr<Transform> child = children[i];
					if (child.PathIndex == PathID)
					{
						return i;
					}
				}
				throw new Exception("Transform hasn't been found among father's children");
			}
		}

		private Vector3f LocalEulerAnglesHint => m_LocalRotation.ToEulerAngle();

		public Vector3f LocalPosition { get => m_LocalPosition; set => m_LocalPosition = value; }
		public Quaternionf LocalRotation { get => m_LocalRotation; set => m_LocalRotation = value; }
		public Vector3f LocalScale { get => m_LocalScale; set => m_LocalScale = value; }

		public const char PathSeparator = '/';

		public Quaternionf m_LocalRotation = new();
		public Vector3f m_LocalPosition = new();
		public Vector3f m_LocalScale = new();
		public PPtr<Transform> Father = new();

		public const string TransformName = "Transform";
		public const string LocalRotationName = "m_LocalRotation";
		public const string LocalPositionName = "m_LocalPosition";
		public const string LocalScaleName = "m_LocalScale";
		public const string ChildrenName = "m_Children";
		public const string FatherName = "m_Father";
		public const string RootOrderName = "m_RootOrder";
		public const string LocalEulerAnglesHintName = "m_LocalEulerAnglesHint";
	}
}

```

`AssetRipperCore/Classes/Utf8StringLegacy.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Core.Classes
{
	public sealed class Utf8StringLegacy : Utf8StringBase
	{
		public override byte[] Data { get; set; }

		public Utf8StringLegacy() { }

		public Utf8StringLegacy(string content)
		{
			String = content;
		}

		public override void ReadRelease(AssetReader reader)
		{
			Data = reader.ReadByteArray();
			reader.AlignStream();
		}

		public override void ReadEditor(AssetReader reader)
		{
			Data = reader.ReadByteArray();
			reader.AlignStream();
		}
	}
}

```

`AssetRipperCore/Converters/DoesNothing/ComponentConverter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters
{
	public static class ComponentConverter
	{
		public static void Convert(IExportContainer container, Component origin, Component instance)
		{
			EditorExtensionConverter.Convert(container, origin, instance);
			instance.GameObject = origin.GameObject;
		}
	}
}

```

`AssetRipperCore/Converters/DoesNothing/EditorExtensionConverter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters
{
	public static class EditorExtensionConverter
	{
		public static void Convert(IExportContainer container, EditorExtension origin, EditorExtension instance)
		{
			instance.AssetInfo = origin.AssetInfo;
			instance.PrefabInstance.CopyValues(origin.PrefabInstance);
		}
	}
}

```

`AssetRipperCore/Converters/DoesNothing/GameObject/ComponentPairConverter.cs`:

```cs
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters.GameObject
{
	public static class ComponentPairConverter
	{
		public static ComponentPair Convert(IExportContainer container, ComponentPair origin)
		{
			return origin;
		}
	}
}

```

`AssetRipperCore/Converters/DoesNothing/NamedObjectConverter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters
{
	public static class NamedObjectConverter
	{
		public static void Convert(IExportContainer container, NamedObject origin, NamedObject instance)
		{
			EditorExtensionConverter.Convert(container, origin, instance);
			instance.NameString = origin.NameString;
		}
	}
}

```

`AssetRipperCore/Converters/DoesNothing/TransformConverter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Project;
using System.Linq;

namespace AssetRipper.Core.Converters
{
	public static class TransformConverter
	{
		public static Transform Convert(IExportContainer container, Transform origin)
		{
			Transform instance = new Transform(container.ExportLayout);
			Convert(container, origin, instance);
			return instance;
		}

		public static void Convert(IExportContainer container, Transform origin, Transform instance)
		{
			ComponentConverter.Convert(container, origin, instance);
			instance.m_LocalRotation = origin.m_LocalRotation;
			instance.m_LocalPosition = origin.m_LocalPosition;
			instance.m_LocalScale = origin.m_LocalScale;
			instance.Children = origin.Children.ToArray();
			instance.Father = origin.Father;
		}
	}
}

```

`AssetRipperCore/Converters/GameObject/GameObjectConverter.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Classes.GameObject;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Project;
using System.Linq;
using GObject = AssetRipper.Core.Classes.GameObject.GameObject;

namespace AssetRipper.Core.Converters.GameObject
{
	public static class GameObjectConverter
	{
		public static GObject Convert(IExportContainer container, GObject origin)
		{
			GObject instance = new GObject(container.ExportLayout);
			EditorExtensionConverter.Convert(container, origin, instance);
			if (GObject.IsComponentTuple(container.ExportVersion))
			{
				instance.ComponentTuple = origin.ComponentTuple.ToArray();
			}
			else
			{
				instance.Component = GetComponent(container, origin);
			}
			instance.IsActive = GetIsActive(container, origin);
			instance.Layer = origin.Layer;
			instance.NameString = origin.NameString;
			if (GObject.HasTag(container.ExportVersion, container.ExportFlags))
			{
				instance.Tag = GetTag(container, origin);
			}
			if (GObject.HasTagString(container.ExportVersion, container.ExportFlags))
			{
				instance.TagString = GetTagString(container, origin);
			}
			return instance;
		}

		private static ComponentPair[] GetComponent(IExportContainer container, GObject origin)
		{
			if (GObject.IsComponentTuple(container.Version))
			{
				Tuple<ClassIDType, PPtr<Component>>[] originComponent = origin.ComponentTuple;
				ComponentPair[] pairs = new ComponentPair[originComponent.Length];
				for (int i = 0; i < pairs.Length; i++)
				{
					ComponentPair pair = new ComponentPair();
					pair.Component = originComponent[i].Item2;
					pairs[i] = pair;
				}
				return pairs;
			}
			else
			{
				return origin.Component.Select(t => ComponentPairConverter.Convert(container, t)).ToArray();
			}
		}

		private static bool GetIsActive(IExportContainer container, GObject origin)
		{
			if (GObject.IsActiveInherited(container.Version))
			{
				return origin.SerializedFile.Collection.IsScene(origin.SerializedFile) ? origin.IsActive : true;
			}
			return origin.IsActive;
		}

		private static ushort GetTag(IExportContainer container, GObject origin)
		{
			if (GObject.HasTag(container.Version, container.Flags))
			{
				return origin.Tag;
			}
			return container.TagNameToID(origin.TagString);
		}

		private static string GetTagString(IExportContainer container, GObject origin)
		{
			if (GObject.HasTagString(container.Version, container.Flags))
			{
				return origin.TagString;
			}
			return container.TagIDToName(origin.Tag);
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/BlendShapeConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;

namespace AssetRipper.Core.Converters.Mesh
{
	public static class BlendShapeConverter
	{
		public static IMeshBlendShapeChannelLegacy[] GenerateBlendChannels(IMeshBlendShapeLegacy[] shapes)
		{
			IMeshBlendShapeChannelLegacy[] channels = new IMeshBlendShapeChannelLegacy[shapes.Length];
			for (int i = 0; i < shapes.Length; i++)
			{
				channels[i] = new MeshBlendShapeChannel(shapes[i].Name.String, i, 1);
			}
			return channels;
		}

		public static float[] GenerateFullWeights(IMeshBlendShapeLegacy[] shapes)
		{
			float[] fullWeights = new float[shapes.Length];
			for (int i = 0; i < shapes.Length; i++)
			{
				fullWeights[i] = 100.0f;
			}
			return fullWeights;
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/ChannelInfoConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters.Mesh
{
	public static class ChannelInfoConverter
	{
		public static ChannelInfo Convert(IExportContainer container, ChannelInfo origin)
		{
			ChannelInfo instance = origin.Clone();
			if (origin.IsSet())
			{
				if (VertexFormatExtensions.VertexFormat2019Relevant(container.Version))
				{
				}
				else if (ShaderChannelExtensions.ShaderChannel5Relevant(container.Version))
				{
					if (VertexFormatExtensions.VertexFormat2019Relevant(container.ExportVersion))
					{
						instance.Format = origin.GetVertexFormat(container.Version).ToFormat(container.ExportVersion);
					}
				}
				else
				{
					if (container.ExportVersion.IsGreaterEqual(5))
					{
						VertexChannelFormat formatv4 = (VertexChannelFormat)origin.Format;
						instance.Format = formatv4.ToVertexFormat().ToFormat(container.ExportVersion);
						if (formatv4 == VertexChannelFormat.Color)
						{
							// replace Color4b[1] to Color1b[4]
							instance.Dimension = (byte)(instance.GetDataDimension() * 4);
						}
					}
				}
			}
			return instance;
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/MeshConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Project;
using AssetRipper.Core.Utils;
using AssetRipper.IO.Endian;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Core.Converters.Mesh
{
	public static class MeshConverter
	{
		public static Classes.Mesh.Mesh Convert(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			Classes.Mesh.Mesh instance = new Classes.Mesh.Mesh(origin.AssetInfo);
			NamedObjectConverter.Convert(container, origin, instance);

			if (Classes.Mesh.Mesh.HasBlendShapes(container.ExportVersion))
			{
				if (Classes.Mesh.Mesh.HasBlendChannels(container.ExportVersion))
				{
					instance.Shapes = GetShapes(container, origin);
				}
				else
				{
					instance.BlendShapes = GetBlendShapes(container, origin);
					instance.ShapeVertices = GetShapeVertices(container, origin);
				}
			}
			if (Classes.Mesh.Mesh.HasBindPose(container.ExportVersion))
			{
				instance.BindPose = GetBindPose(container, origin);
			}
			if (Classes.Mesh.Mesh.HasBoneNameHashes(container.ExportVersion))
			{
				instance.BoneNameHashes = GetBoneNameHashes(container, origin);
				instance.RootBoneNameHash = GetRootBoneNameHash(container, origin);
			}
			if (Classes.Mesh.Mesh.HasBonesAABB(container.ExportVersion))
			{
				instance.BonesAABB = GetBonesAABB(container, origin);
			}
			instance.VariableBoneCountWeights.CopyValues(origin.VariableBoneCountWeights ?? new VariableBoneCountWeights());
			if (Classes.Mesh.Mesh.HasMeshCompression(container.ExportVersion))
			{
				instance.MeshCompression = GetMeshCompression(container, origin);
			}
			if (Classes.Mesh.Mesh.HasStreamCompression(container.ExportVersion))
			{
				instance.StreamCompression = GetStreamCompression(container, origin);
			}
			if (Classes.Mesh.Mesh.HasIsReadable(container.ExportVersion))
			{
				instance.IsReadable = GetIsReadable(container, origin);
				instance.KeepVertices = GetKeepVertices(container, origin);
				instance.KeepIndices = GetKeepIndices(container, origin);
			}
			if (Classes.Mesh.Mesh.HasSkin(container.ExportVersion))
			{
				instance.Skin = origin.Skin;
			}

			instance.Vertices = origin.Vertices?.ToArray();
			instance.UV0 = origin.UV0?.ToArray();
			instance.UV1 = origin.UV1?.ToArray();
			instance.UV2 = origin.UV2?.ToArray();
			instance.UV3 = origin.UV3?.ToArray();
			instance.UV4 = origin.UV4?.ToArray();
			instance.UV5 = origin.UV5?.ToArray();
			instance.UV6 = origin.UV6?.ToArray();
			instance.UV7 = origin.UV7?.ToArray();
			instance.Tangents = origin.Tangents?.ToArray();
			instance.Normals = origin.Normals?.ToArray();
			instance.Colors = origin.Colors?.ToArray();
			instance.Indices = new List<uint>(origin.Indices.ToArray());
			instance.Triangles = new List<List<uint>>(origin.Triangles.ConvertAll(x => x.ToArray()).ConvertAll(y => new List<uint>(y)).ToArray());

			if (Classes.Mesh.Mesh.HasVertexData(container.ExportVersion))
			{
				if (Classes.Mesh.Mesh.IsOnlyVertexData(container.ExportVersion))
				{
					instance.VertexData = GetVertexData(container, origin);
				}
				else if (instance.MeshCompression == MeshCompression.Off)
				{
					instance.VertexData = GetVertexData(container, origin);
				}
			}
			else
			{
				instance.UV1 = origin.UV1.ToArray();
				instance.Tangents = origin.Tangents.ToArray();
				instance.Normals = origin.Normals.ToArray();
			}

			instance.CompressedMesh.CopyValues(origin.CompressedMesh);
			instance.LocalAABB.CopyValuesFrom(origin.LocalAABB);
			if (Classes.Mesh.Mesh.HasCollisionTriangles(container.ExportVersion))
			{
				instance.CollisionTriangles = origin.CollisionTriangles.ToArray();
				instance.CollisionVertexCount = origin.CollisionVertexCount;
			}
			instance.MeshUsageFlags = origin.MeshUsageFlags;
			if (Classes.Mesh.Mesh.HasCollision(container.ExportVersion))
			{
				instance.BakedConvexCollisionMesh = origin.BakedConvexCollisionMesh?.ToArray() ?? Array.Empty<byte>();
				instance.BakedTriangleCollisionMesh = origin.BakedTriangleCollisionMesh?.ToArray() ?? Array.Empty<byte>();
			}
			if (Classes.Mesh.Mesh.HasMeshMetrics(container.ExportVersion))
			{
				instance.MeshMetrics = GetMeshMetrics(container, origin);
			}

			instance.StreamData.CopyValues(origin.StreamData ?? new StreamingInfo());

			if (Classes.Mesh.Mesh.HasUse16bitIndices(container.ExportVersion))
			{
				instance.Use16BitIndices = GetUse16bitIndices(container, origin);
			}
			else if (Classes.Mesh.Mesh.HasIndexFormat(container.ExportVersion))
			{
				instance.IndexFormat = GetIndexFormat(container, origin);
			}
			instance.RawIndexBuffer = GetIndexBuffer(container, origin);
			// since this method uses instance, we need to call it last
			instance.SubMeshes = SubMeshConverter.Convert(container, instance, origin.SubMeshes);

			return instance;
		}

		private static uint GetUse16bitIndices(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			if (Classes.Mesh.Mesh.HasUse16bitIndices(container.Version))
			{
				return origin.Use16BitIndices;
			}
			return 1;
		}

		private static IMeshBlendShapeLegacy[] GetBlendShapes(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBlendShapes(container.Version) ? origin.Shapes.Shapes : Array.Empty<MeshBlendShape>();
		}

		private static BlendShapeVertex[] GetShapeVertices(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBlendShapes(container.Version) ? origin.Shapes.Vertices : Array.Empty<BlendShapeVertex>();
		}

		private static BlendShapeData GetShapes(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			if (Classes.Mesh.Mesh.HasBlendShapes(container.Version))
			{
				if (Classes.Mesh.Mesh.HasBlendChannels(container.Version))
				{
					return origin.Shapes.Convert();
				}
				else
				{
					BlendShapeData instance = new BlendShapeData();
					instance.Vertices = origin.ShapeVertices.ToArray();
					instance.Shapes = origin.BlendShapes.ToArray();
					instance.Channels = BlendShapeConverter.GenerateBlendChannels(origin.BlendShapes);
					instance.FullWeights = BlendShapeConverter.GenerateFullWeights(origin.BlendShapes);
					return instance;
				}
			}
			else
			{
				return new BlendShapeData();
			}
		}

		private static Matrix4x4f[] GetBindPose(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBindPose(container.Version) ? origin.BindPose.ToArray() : Array.Empty<Matrix4x4f>();
		}

		private static uint[] GetBoneNameHashes(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBoneNameHashes(container.Version) ? origin.BoneNameHashes.ToArray() : Array.Empty<uint>();
		}

		private static uint GetRootBoneNameHash(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBoneNameHashes(container.Version) ? origin.RootBoneNameHash : 0;
		}

		private static MinMaxAABB[] GetBonesAABB(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasBonesAABB(container.Version) ? origin.BonesAABB.ToArray() : Array.Empty<MinMaxAABB>();
		}

		private static MeshCompression GetMeshCompression(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasMeshCompression(container.Version) ? origin.MeshCompression : MeshCompression.Off;
		}

		private static byte GetStreamCompression(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasStreamCompression(container.Version) ? origin.StreamCompression : (byte)0;
		}

		private static bool GetIsReadable(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasIsReadable(container.Version) ? origin.IsReadable : true;
		}

		private static bool GetKeepVertices(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasIsReadable(container.Version) ? origin.KeepVertices : true;
		}

		private static bool GetKeepIndices(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasIsReadable(container.Version) ? origin.KeepIndices : true;
		}

		private static IndexFormat GetIndexFormat(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			if (Classes.Mesh.Mesh.HasIndexFormat(container.Version))
			{
				return origin.IndexFormat;
			}
			if (Classes.Mesh.Mesh.HasUse16bitIndices(container.Version))
			{
				return origin.Use16BitIndices == 0 ? IndexFormat.UInt32 : IndexFormat.UInt16;
			}
			return IndexFormat.UInt16;
		}

		private static byte[] GetIndexBuffer(IExportContainer container, Classes.Mesh.Mesh origin)
		{
#warning TODO: convert MeshTopology.Deprecated indices to MeshTopology.Triangles
			if (container.Platform == container.ExportPlatform ||
				(container.Platform != BuildTarget.XBox360 && container.ExportPlatform != BuildTarget.XBox360))
			{
				return origin.RawIndexBuffer.ToArray();
			}
			else
			{
				int size = GetUse16bitIndices(container, origin) == 0 ? 4 : 2;
				return origin.RawIndexBuffer.SwapBytes(size);
			}
		}

		private static VertexData GetVertexData(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			if (Classes.Mesh.Mesh.HasVertexData(container.Version))
			{
				if (Classes.Mesh.Mesh.IsOnlyVertexData(container.Version))
				{
					return VertexDataConverter.Convert(container, origin);
				}
				else
				{
					if (origin.MeshCompression == MeshCompression.Off)
					{
						return VertexDataConverter.Convert(container, origin);
					}
					else
					{
						return GenerateVertexData(container, origin);
					}
				}
			}
			else
			{
				return GenerateVertexData(container, origin);
			}
		}

		private static float[] GetMeshMetrics(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			return Classes.Mesh.Mesh.HasMeshMetrics(container.Version) ? origin.MeshMetrics.ToArray() : new float[] { 1.0f, 1.0f };
		}

		private static VertexData GenerateVertexData(IExportContainer container, Classes.Mesh.Mesh origin)
		{
			VertexData instance = new VertexData();
			bool hasVertices = origin.Vertices.Length > 0;
			bool hasNormals = origin.Normals.Length > 0;
			bool hasColors = origin.Colors.Length > 0;
			bool hasUV0 = origin.UV0.Length > 0;
			bool hasUV1 = origin.UV1.Length > 0;
			bool hasTangents = origin.Tangents.Length > 0;
			bool hasChannels = VertexData.HasChannels(container.ExportVersion);

			if (hasChannels)
			{
				int channelCount = ShaderChannelExtensions.GetChannelCount(container.ExportVersion);
				instance.m_Channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(channelCount);
			}

			byte stride = 0;
			BitArray curChannels = new BitArray(32);
			if (hasVertices)
			{
				int index = ShaderChannel.Vertex.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.Vertex.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.Vertex.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.Vertex.GetStride(container.ExportVersion);
			}
			if (hasNormals)
			{
				int index = ShaderChannel.Normal.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.Normal.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.Normal.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.Normal.GetStride(container.ExportVersion);
			}
			if (hasColors)
			{
				int index = ShaderChannel.Color.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.Color.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.Color.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.Color.GetStride(container.ExportVersion);
			}
			if (hasUV0)
			{
				int index = ShaderChannel.UV0.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.UV0.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.UV0.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.UV0.GetStride(container.ExportVersion);
			}
			if (hasUV1)
			{
				int index = ShaderChannel.UV1.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.UV1.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.UV1.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.UV1.GetStride(container.ExportVersion);
			}
			if (hasTangents)
			{
				int index = ShaderChannel.Tangent.ToChannel(container.ExportVersion);
				curChannels.Set(index, true);
				if (hasChannels)
				{
					byte format = ShaderChannel.Tangent.GetVertexFormat(container.ExportVersion).ToFormat(container.ExportVersion);
					byte dimention = ShaderChannel.Tangent.GetDimention(container.ExportVersion);
					instance.m_Channels[index] = new ChannelInfo(0, stride, format, dimention);
				}
				stride += ShaderChannel.Tangent.GetStride(container.ExportVersion);
			}

			if (VertexData.HasCurrentChannels(container.ExportVersion))
			{
				instance.CurrentChannels = curChannels.ToUInt32();
			}
			instance.VertexCount = (uint)origin.Vertices.Length;
			if (VertexData.HasStreams(container.ExportVersion))
			{
				StreamInfo info = new StreamInfo(instance.CurrentChannels, 0, stride);
				if (VertexData.IsStreamStatic(container.ExportVersion))
				{
					instance.m_Streams = new StreamInfo[] { info, new(), new(), new(), };
				}
				else
				{
					instance.m_Streams = new StreamInfo[] { info, };
				}
			}

			instance.Data = new byte[instance.VertexCount * stride];
			using (MemoryStream stream = new MemoryStream(instance.Data))
			{
				using AssetWriter writer = new AssetWriter(stream, EndianType.LittleEndian, container.ExportLayout);
				for (int i = 0; i < instance.VertexCount; i++)
				{
					if (hasVertices)
					{
						origin.Vertices[i].Write(writer);
					}
					if (hasNormals)
					{
						origin.Normals[i].Write(writer);
					}
					if (hasColors)
					{
						origin.Colors[i].Write(writer);
					}
					if (hasUV0)
					{
						origin.UV0[i].Write(writer);
					}
					if (hasUV1)
					{
						origin.UV1[i].Write(writer);
					}
					if (hasTangents)
					{
						origin.Tangents[i].Write(writer);
					}
				}
			}

			return instance;
		}

		private static void CopyValues(this VariableBoneCountWeights destination, VariableBoneCountWeights source)
		{
			destination.Data = source.Data?.ToArray() ?? Array.Empty<uint>();
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/StreamInfoConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Project;

namespace AssetRipper.Core.Converters.Mesh
{
	public static class StreamInfoConverter
	{
		public static ChannelInfo GenerateChannelInfo(IExportContainer container, StreamInfo[] origin, ShaderChannel channelType)
		{
			return GenerateChannelInfo(container.ExportVersion, origin, channelType);
		}

		public static ChannelInfo GenerateChannelInfo(UnityVersion instanceVersion, StreamInfo[] origin, ShaderChannel channelType)
		{
			ChannelInfo instance = new ChannelInfo();
			ShaderChannel4 channelv4 = channelType.ToShaderChannel4();
			int streamIndex = origin.IndexOf(t => t.IsMatch(channelv4));
			if (streamIndex >= 0)
			{
				byte offset = 0;
				StreamInfo stream = origin[streamIndex];
				for (ShaderChannel4 i = 0; i < channelv4; i++)
				{
					if (stream.IsMatch(i))
					{
						offset += i.ToShaderChannel().GetStride(instanceVersion);
					}
				}

				instance.Stream = (byte)streamIndex;
				instance.Offset = offset;
				instance.Format = channelType.GetVertexFormat(instanceVersion).ToFormat(instanceVersion);
				instance.Dimension = channelType.GetDimention(instanceVersion);
			}
			return instance;
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/SubMeshConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Misc.Serializable.Boundaries;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Math.PackedBitVectors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Project;
using AssetRipper.IO.Endian;
using System.IO;


namespace AssetRipper.Core.Converters.Mesh
{
	public static class SubMeshConverter
	{
		public static void CalculateSubMeshVertexRangeAndBounds(LayoutInfo layout, AssetRipper.Core.Classes.Mesh.Mesh mesh, SubMesh submesh)
		{
			UpdateSubMeshVertexRange(layout.Version, mesh, submesh);
			RecalculateSubmeshBounds(layout, mesh, submesh);
		}

		public static SubMesh[] Convert(IExportContainer container, AssetRipper.Core.Classes.Mesh.Mesh instanceMesh, SubMesh[] origin)
		{
			SubMesh[] instances = new SubMesh[origin.Length];
			for (int i = 0; i < origin.Length; i++)
			{
				instances[i] = Convert(container, instanceMesh, origin[i]);
			}
			return instances;
		}

		private static SubMesh Convert(IExportContainer container, AssetRipper.Core.Classes.Mesh.Mesh instanceMesh, SubMesh origin)
		{
			SubMesh instance = new SubMesh();
			instance.FirstByte = origin.FirstByte;
			instance.IndexCount = origin.IndexCount;
			instance.Topology = origin.GetTopology(container.Version);
			if (SubMesh.HasTriangleCount(container.ExportVersion))
			{
				instance.TriangleCount = origin.TriangleCount;
			}
			if (SubMesh.HasBaseVertex(container.ExportVersion))
			{
				instance.BaseVertex = (uint)GetBaseVertex(container, origin);
			}
			if (SubMesh.HasVertex(container.ExportVersion))
			{
				SetVertex(container, instanceMesh, origin, instance);
			}
			return instance;
		}

		private static int GetBaseVertex(IExportContainer container, SubMesh origin)
		{
			if (SubMesh.HasBaseVertex(container.Version))
			{
				return (int)origin.BaseVertex;
			}
#warning TODO: calculate or default value?
			return 0;
		}

		private static void SetVertex(IExportContainer container, AssetRipper.Core.Classes.Mesh.Mesh instanceMesh, SubMesh origin, SubMesh instance)
		{
			if (SubMesh.HasVertex(container.Version))
			{
				instance.FirstVertex = origin.FirstVertex;
				instance.VertexCount = origin.VertexCount;
				instance.LocalAABB.CopyValuesFrom(origin.LocalAABB);
			}
			else
			{
				CalculateSubMeshVertexRangeAndBounds(container.ExportLayout, instanceMesh, instance);
			}
		}

		private static void UpdateSubMeshVertexRange(UnityVersion version, AssetRipper.Core.Classes.Mesh.Mesh mesh, SubMesh submesh)
		{
			if (submesh.IndexCount == 0)
			{
				submesh.FirstVertex = 0;
				submesh.VertexCount = 0;
				return;
			}

			FindMinMaxIndices(version, mesh, submesh, out int minIndex, out int maxIndex);
			submesh.FirstVertex = (uint)minIndex;
			submesh.VertexCount = (uint)(maxIndex - minIndex + 1);
		}

		private static void FindMinMaxIndices(UnityVersion version, AssetRipper.Core.Classes.Mesh.Mesh mesh, SubMesh submesh, out int min, out int max)
		{
			bool is16bits = mesh.Is16BitIndices(version);
			if (AssetRipper.Core.Classes.Mesh.Mesh.HasCompressedMesh(version))
			{
				if (mesh.CompressedMesh.Triangles.IsSet())
				{
					int[] triangles = mesh.CompressedMesh.Triangles.UnpackInts();
					int firstByte = (int)(is16bits ? submesh.FirstByte * 2 : submesh.FirstByte);
					FindMinMaxIndices(triangles, (int)(firstByte / sizeof(int)), (int)submesh.IndexCount, out min, out max);
					return;
				}
			}

			if (is16bits)
			{
				FindMinMax16Indices(mesh.RawIndexBuffer, (int)submesh.FirstByte, (int)submesh.IndexCount, out min, out max);
			}
			else
			{
				FindMinMax32Indices(mesh.RawIndexBuffer, (int)submesh.FirstByte, (int)submesh.IndexCount, out min, out max);
			}
		}

		private static void FindMinMaxIndices(int[] indexBuffer, int offset, int indexCount, out int min, out int max)
		{
			min = indexBuffer[offset];
			max = indexBuffer[offset];
			int end = offset + indexCount;
			for (int i = offset; i < end; i++)
			{
				int index = indexBuffer[i];
				if (index > max)
				{
					max = index;
				}
				else if (index < min)
				{
					min = index;
				}
			}
		}

		private static void FindMinMax16Indices(byte[] indexBuffer, int offset, int indexCount, out int min, out int max)
		{
			min = BitConverter.ToUInt16(indexBuffer, offset);
			max = BitConverter.ToUInt16(indexBuffer, offset);
			int end = offset + (indexCount * sizeof(ushort));
			for (int i = offset; i < end; i += sizeof(ushort))
			{
				int index = BitConverter.ToUInt16(indexBuffer, i);
				if (index > max)
				{
					max = index;
				}
				else if (index < min)
				{
					min = index;
				}
			}
		}

		private static void FindMinMax32Indices(byte[] indexBuffer, int offset, int indexCount, out int min, out int max)
		{
			min = BitConverter.ToInt32(indexBuffer, offset);
			max = BitConverter.ToInt32(indexBuffer, offset);
			int end = offset + (indexCount * sizeof(int));
			for (int i = offset; i < end; i += sizeof(int))
			{
				int index = BitConverter.ToInt32(indexBuffer, i);
				if (index > max)
				{
					max = index;
				}
				else if (index < min)
				{
					min = index;
				}
			}
		}

		private static void RecalculateSubmeshBounds(LayoutInfo layout, AssetRipper.Core.Classes.Mesh.Mesh mesh, SubMesh submesh)
		{
			if (submesh.VertexCount == 0)
			{
				submesh.LocalAABB.Reset();
				return;
			}

			FindMinMaxBounds(layout, mesh, submesh, out Vector3f min, out Vector3f max);
			Vector3f center = (min + max) / 2.0f;
			Vector3f extent = max - center;
			submesh.LocalAABB.CopyValuesFrom(center, extent);
		}

		private static void FindMinMaxBounds(LayoutInfo layout, AssetRipper.Core.Classes.Mesh.Mesh mesh, SubMesh submesh, out Vector3f min, out Vector3f max)
		{
			if (AssetRipper.Core.Classes.Mesh.Mesh.HasCompressedMesh(layout.Version))
			{
				if (mesh.CompressedMesh.Vertices.IsSet())
				{
					float[] vertices = mesh.CompressedMesh.Vertices.Unpack();
					FindMinMaxBounds(vertices, (int)submesh.FirstVertex, (int)submesh.VertexCount, out min, out max);
					return;
				}
			}

			if (AssetRipper.Core.Classes.Mesh.Mesh.HasVertexData(layout.Version))
			{
				if (AssetRipper.Core.Classes.Mesh.Mesh.IsOnlyVertexData(layout.Version))
				{
					FindMinMaxBounds(layout, mesh.VertexData, (int)submesh.FirstVertex, (int)submesh.VertexCount, out min, out max);
				}
				else
				{
					if (mesh.MeshCompression == MeshCompression.Off)
					{
						FindMinMaxBounds(layout, mesh.VertexData, (int)submesh.FirstVertex, (int)submesh.VertexCount, out min, out max);
					}
					else
					{
						FindMinMaxBounds(mesh.Vertices, (int)submesh.FirstVertex, (int)submesh.VertexCount, out min, out max);
					}
				}
			}
			else
			{
				FindMinMaxBounds(mesh.Vertices, (int)submesh.FirstVertex, (int)submesh.VertexCount, out min, out max);
			}
		}

		private static void FindMinMaxBounds(float[] vertexBuffer, int firstVertex, int vertexCount, out Vector3f min, out Vector3f max)
		{
			int offset = firstVertex * 3;
			min = new Vector3f(vertexBuffer[offset], vertexBuffer[offset + 1], vertexBuffer[offset + 2]);
			max = new Vector3f(vertexBuffer[offset], vertexBuffer[offset + 1], vertexBuffer[offset + 2]);
			int end = offset + (vertexCount * 3);
			for (int i = offset; i < end;)
			{
				float x = vertexBuffer[i++];
				float y = vertexBuffer[i++];
				float z = vertexBuffer[i++];

				if (x > max.X)
				{
					max.X = x;
				}
				else if (x < min.X)
				{
					min.X = x;
				}
				if (y > max.Y)
				{
					max.Y = y;
				}
				else if (y < min.Y)
				{
					min.Y = y;
				}
				if (z > max.Z)
				{
					max.Z = z;
				}
				else if (z < min.Z)
				{
					min.Z = z;
				}
			}
		}

		private static void FindMinMaxBounds(Vector3f[] vertices, int firstVertex, int vertexCount, out Vector3f min, out Vector3f max)
		{
			min = vertices[firstVertex];
			max = vertices[firstVertex];
			int end = firstVertex + vertexCount;
			for (int i = firstVertex; i < end; i++)
			{
				Vector3f vertex = vertices[i];
				if (vertex.X > max.X)
				{
					max.X = vertex.X;
				}
				else if (vertex.X < min.X)
				{
					min.X = vertex.X;
				}
				if (vertex.Y > max.Y)
				{
					max.Y = vertex.Y;
				}
				else if (vertex.Y < min.Y)
				{
					min.Y = vertex.Y;
				}
				if (vertex.Z > max.Z)
				{
					max.Z = vertex.Z;
				}
				else if (vertex.Z < min.Z)
				{
					min.Z = vertex.Z;
				}
			}
		}

		private static void FindMinMaxBounds(LayoutInfo layout, VertexData vertexData, int firstVertex, int vertexCount, out Vector3f min, out Vector3f max)
		{
			ChannelInfo channel = vertexData.GetChannel(layout.Version, ShaderChannel.Vertex);
			int streamOffset = vertexData.GetStreamOffset(layout.Version, channel.Stream);
			int streamStride = vertexData.GetStreamStride(layout.Version, channel.Stream);
			int extraStride = streamStride - ShaderChannel.Vertex.GetStride(layout.Version);
			int vertexOffset = firstVertex * streamStride;
			int begin = streamOffset + vertexOffset + channel.Offset;
			using MemoryStream stream = new MemoryStream(vertexData.Data);
			using AssetReader reader = new AssetReader(stream, EndianType.LittleEndian, layout);
			stream.Position = begin;
			Vector3f dummyVertex = reader.ReadAsset<Vector3f>();
			min = dummyVertex;
			max = dummyVertex;

			stream.Position = begin;
			for (int i = 0; i < vertexCount; i++)
			{
				Vector3f vertex = reader.ReadAsset<Vector3f>();
				if (vertex.X > max.X)
				{
					max.X = vertex.X;
				}
				else if (vertex.X < min.X)
				{
					min.X = vertex.X;
				}
				if (vertex.Y > max.Y)
				{
					max.Y = vertex.Y;
				}
				else if (vertex.Y < min.Y)
				{
					min.Y = vertex.Y;
				}
				if (vertex.Z > max.Z)
				{
					max.Z = vertex.Z;
				}
				else if (vertex.Z < min.Z)
				{
					min.Z = vertex.Z;
				}
				stream.Position += extraStride;
			}
		}
	}
}

```

`AssetRipperCore/Converters/Mesh/VertexDataConverter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Shader.Enums.ShaderChannel;
using AssetRipper.Core.Classes.Shader.Enums.VertexFormat;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Project;
using AssetRipper.Core.Utils;
using AssetRipper.IO.Endian;
using System.Collections;
using System.IO;
using System.Linq;

namespace AssetRipper.Core.Converters.Mesh
{
	public static class VertexDataConverter
	{
		public static VertexData Convert(IExportContainer container, Classes.Mesh.Mesh originMesh)
		{
			VertexData instance = new VertexData();
			if (VertexData.HasCurrentChannels(container.ExportVersion))
			{
				instance.CurrentChannels = GetCurrentChannels(container, originMesh.VertexData);
			}
			instance.VertexCount = originMesh.VertexData.VertexCount;
			if (VertexData.HasChannels(container.ExportVersion))
			{
				instance.m_Channels = GetChannels(container, originMesh);
			}
			if (VertexData.HasStreams(container.ExportVersion))
			{
				instance.m_Streams = originMesh.VertexData.m_Streams.ToArray();
			}
			instance.Data = GetData(container, originMesh, instance);
			return instance;
		}

		private static uint GetCurrentChannels(IExportContainer container, VertexData origin)
		{
			if (ShaderChannelExtensions.ShaderChannel5Relevant(container.Version))
			{
				return origin.CurrentChannels;
			}
			else
			{
				BitArray curBits = new BitArray(BitConverter.GetBytes(origin.CurrentChannels));
				curBits.Set((int)ShaderChannel5.Tangent, curBits.Get((int)ShaderChannel4.Tangent));
				curBits.Set((int)ShaderChannel4.Tangent, false);
				return curBits.ToUInt32();
			}
		}

		private static ChannelInfo[] GetChannels(IExportContainer container, Classes.Mesh.Mesh originMesh)
		{
			VertexData origin = originMesh.VertexData;
			if (ShaderChannelExtensions.ShaderChannel2018Relevant(container.Version)) // 2018.1 <= Version
			{
				return origin.m_Channels.Select(t => t.Convert(container)).ToArray();
			}
			else if (ShaderChannelExtensions.ShaderChannel5Relevant(container.Version)) // 5.0.0 <= Version < 2018.1
			{
				if (ShaderChannelExtensions.ShaderChannel2018Relevant(container.ExportVersion))
				{
					ChannelInfo[] channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(14);
					channels[(int)ShaderChannel2018.Vertex] = origin.m_Channels[(int)ShaderChannel5.Vertex].Convert(container);
					channels[(int)ShaderChannel2018.Normal] = origin.m_Channels[(int)ShaderChannel5.Normal].Convert(container);
					channels[(int)ShaderChannel2018.Tangent] = origin.m_Channels[(int)ShaderChannel5.Tangent].Convert(container);
					channels[(int)ShaderChannel2018.Color] = origin.m_Channels[(int)ShaderChannel5.Color].Convert(container);
					channels[(int)ShaderChannel2018.UV0] = origin.m_Channels[(int)ShaderChannel5.UV0].Convert(container);
					channels[(int)ShaderChannel2018.UV1] = origin.m_Channels[(int)ShaderChannel5.UV1].Convert(container);
					channels[(int)ShaderChannel2018.UV2] = origin.m_Channels[(int)ShaderChannel5.UV2].Convert(container);
					channels[(int)ShaderChannel2018.UV3] = origin.m_Channels[(int)ShaderChannel5.UV3].Convert(container);
					ConvertSkinChannels(container, originMesh, channels);
					return channels;
				}
				else
				{
					return origin.m_Channels.ToArray();
				}
			}
			else if (VertexData.HasChannels(container.Version)) // 4.0.0 <= Version < 5.0.0
			{
				if (ShaderChannelExtensions.ShaderChannel2018Relevant(container.ExportVersion))
				{
					ChannelInfo[] channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(14);
					channels[(int)ShaderChannel2018.Vertex] = origin.m_Channels[(int)ShaderChannel4.Vertex].Convert(container);
					channels[(int)ShaderChannel2018.Normal] = origin.m_Channels[(int)ShaderChannel4.Normal].Convert(container);
					channels[(int)ShaderChannel2018.Tangent] = origin.m_Channels[(int)ShaderChannel4.Tangent].Convert(container);
					channels[(int)ShaderChannel2018.Color] = origin.m_Channels[(int)ShaderChannel4.Color].Convert(container);
					channels[(int)ShaderChannel2018.UV0] = origin.m_Channels[(int)ShaderChannel4.UV0].Convert(container);
					channels[(int)ShaderChannel2018.UV1] = origin.m_Channels[(int)ShaderChannel4.UV1].Convert(container);
					ConvertSkinChannels(container, originMesh, channels);
					return channels;
				}
				else if (ShaderChannelExtensions.ShaderChannel5Relevant(container.ExportVersion))
				{
					ChannelInfo[] channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(8);
					channels[(int)ShaderChannel5.Vertex] = origin.m_Channels[(int)ShaderChannel4.Vertex].Convert(container);
					channels[(int)ShaderChannel5.Normal] = origin.m_Channels[(int)ShaderChannel4.Normal].Convert(container);
					channels[(int)ShaderChannel5.Color] = origin.m_Channels[(int)ShaderChannel4.Color].Convert(container);
					channels[(int)ShaderChannel5.UV0] = origin.m_Channels[(int)ShaderChannel4.UV0].Convert(container);
					channels[(int)ShaderChannel5.UV1] = origin.m_Channels[(int)ShaderChannel4.UV1].Convert(container);
					channels[(int)ShaderChannel5.Tangent] = origin.m_Channels[(int)ShaderChannel4.Tangent].Convert(container);
					return channels;
				}
				else
				{
					return origin.m_Channels.ToArray();
				}
			}
			else  // Version < 4.0.0 - convert streams to channels
			{
				if (ShaderChannelExtensions.ShaderChannel2018Relevant(container.ExportVersion))
				{
					ChannelInfo[] channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(14);
					channels[(int)ShaderChannel2018.Vertex] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Vertex);
					channels[(int)ShaderChannel2018.Normal] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Normal);
					channels[(int)ShaderChannel2018.Tangent] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Tangent);
					channels[(int)ShaderChannel2018.Color] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Color);
					channels[(int)ShaderChannel2018.UV0] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV0);
					channels[(int)ShaderChannel2018.UV1] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV1);
					ConvertSkinChannels(container, originMesh, channels);
					return channels;
				}
				else if (ShaderChannelExtensions.ShaderChannel5Relevant(container.ExportVersion))
				{
					ChannelInfo[] channels = ArrayUtils.CreateAndInitializeArray<ChannelInfo>(8);
					channels[(int)ShaderChannel5.Vertex] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Vertex);
					channels[(int)ShaderChannel5.Normal] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Normal);
					channels[(int)ShaderChannel5.Color] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Color);
					channels[(int)ShaderChannel5.UV0] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV0);
					channels[(int)ShaderChannel5.UV1] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV1);
					channels[(int)ShaderChannel5.Tangent] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Tangent);
					return channels;
				}
				else
				{
					ChannelInfo[] channels = new ChannelInfo[6];
					channels[(int)ShaderChannel4.Vertex] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Vertex);
					channels[(int)ShaderChannel4.Normal] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Normal);
					channels[(int)ShaderChannel4.Color] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Color);
					channels[(int)ShaderChannel4.UV0] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV0);
					channels[(int)ShaderChannel4.UV1] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.UV1);
					channels[(int)ShaderChannel4.Tangent] = StreamInfoConverter.GenerateChannelInfo(container, origin.m_Streams, ShaderChannel.Tangent);
					return channels;
				}
			}
		}

		private static void ConvertSkinChannels(IExportContainer container, Classes.Mesh.Mesh origin, ChannelInfo[] channels)
		{
			if (origin.Skin.Length > 0)
			{
				byte skinStream = (byte)(channels.Where(t => t.IsSet()).Max(t => t.Stream) + 1);
				byte offset = 0;

				VertexFormat weightVFormat = ShaderChannel.SkinWeight.GetVertexFormat(container.ExportVersion);
				byte weightFormat = weightVFormat.ToFormat(container.ExportVersion);
				byte weightDimention = BoneWeights4.Dimention;
				channels[(int)ShaderChannel2018.SkinWeight] = new ChannelInfo(skinStream, offset, weightFormat, weightDimention);
				offset += (byte)(BoneWeights4.Dimention * weightVFormat.GetSize(container.ExportVersion));

				VertexFormat indexVFormat = ShaderChannel.SkinBoneIndex.GetVertexFormat(container.ExportVersion);
				byte indexFormat = indexVFormat.ToFormat(container.ExportVersion);
				byte indexDimention = BoneWeights4.Dimention;
				channels[(int)ShaderChannel2018.SkinBoneIndex] = new ChannelInfo(skinStream, offset, indexFormat, indexDimention);
			}
		}

		private static byte[] GetData(IExportContainer container, Classes.Mesh.Mesh originMesh, VertexData instance)
		{
			if (!originMesh.CheckAssetIntegrity())
			{
				return Array.Empty<byte>();
			}

			if (NeedCopyData(container))
			{
				return CopyChannelsData(container, originMesh, instance);
			}
			else if (NeedAppendSkin(container, instance))
			{
				return AppendSkin(originMesh);
			}
			else
			{
				byte[] data = originMesh.GetChannelsData();
				return data == originMesh.VertexData.Data ? data.ToArray() : data;
			}
		}

		private static bool NeedCopyData(IExportContainer container)
		{
			if (container.Platform == BuildTarget.XBox360 && container.ExportPlatform != BuildTarget.XBox360)
			{
				return true;
			}

			return false;
		}

		private static bool NeedAppendSkin(IExportContainer container, VertexData instance)
		{
			if (VertexData.ToSerializedVersion(container.Version) < 2)
			{
				if (VertexData.ToSerializedVersion(container.ExportVersion) >= 2)
				{
					if (instance.m_Channels[(int)ShaderChannel2018.SkinWeight].IsSet())
					{
						return true;
					}
				}
			}
			return false;
		}

		private static byte[] CopyChannelsData(IExportContainer container, Classes.Mesh.Mesh originMesh, VertexData instance)
		{
			int maxStream = instance.m_Channels.Max(t => t.Stream);
			int lastSize = instance.GetStreamSize(container.ExportVersion, maxStream);
			int lastOffset = instance.GetStreamOffset(container.ExportVersion, maxStream);
			byte[] buffer = new byte[lastOffset + lastSize];
			using (MemoryStream dstStream = new MemoryStream(buffer))
			{
				EndianType oendian = container.ExportPlatform == BuildTarget.XBox360 ? EndianType.BigEndian : EndianType.LittleEndian;
				using EndianWriter dst = new EndianWriter(dstStream, oendian);
				using MemoryStream srcStream = new MemoryStream(originMesh.GetChannelsData());
				EndianType iendian = container.Platform == BuildTarget.XBox360 ? EndianType.BigEndian : EndianType.LittleEndian;
				using EndianReader src = new EndianReader(srcStream, iendian);
				CopyChannelsData(container, originMesh.VertexData, instance, src, dst);
				if (NeedAppendSkin(container, instance))
				{
					dstStream.Position = lastOffset;
					AppendSkin(originMesh.Skin, dst);
				}
			}
			return buffer;
		}

		private static void CopyChannelsData(IExportContainer container, VertexData origin, VertexData instance, BinaryReader src, BinaryWriter dst)
		{
			for (ShaderChannel c = 0; c <= ShaderChannel.SkinBoneIndex; c++)
			{
				if (!c.HasChannel(container.Version))
				{
					continue;
				}
				ChannelInfo ochannel = origin.m_Channels[c.ToChannel(container.Version)];
				if (!ochannel.IsSet())
				{
					continue;
				}

				if (!c.HasChannel(container.ExportVersion))
				{
					continue;
				}
				ChannelInfo ichannel = instance.m_Channels[c.ToChannel(container.ExportVersion)];
				if (!ichannel.IsSet())
				{
					continue;
				}

				uint vertexCount = origin.VertexCount;
				int ostride = origin.GetStreamStride(container.Version, ochannel.Stream);
				int istride = instance.GetStreamStride(container.ExportVersion, ichannel.Stream);
				int oextraStride = ostride - ochannel.GetStride(container.Version);
				int iextraStride = istride - ichannel.GetStride(container.ExportVersion);
				src.BaseStream.Position = origin.GetStreamOffset(container.Version, ochannel.Stream) + ochannel.Offset;
				dst.BaseStream.Position = instance.GetStreamOffset(container.ExportVersion, ichannel.Stream) + ichannel.Offset;
				VertexFormat format = ochannel.GetVertexFormat(container.Version);
				switch (format)
				{
					case VertexFormat.Float:
					case VertexFormat.Int:
						for (int i = 0; i < vertexCount; i++)
						{
							for (int j = 0; j < ochannel.GetDataDimension(); j++)
							{
								dst.Write(src.ReadUInt32());
							}
							src.BaseStream.Position += oextraStride;
							dst.BaseStream.Position += iextraStride;
						}
						break;
					case VertexFormat.Color:
						int size = format.GetSize(container.Version);
						if (size == 1)
						{
							for (int i = 0; i < vertexCount; i++)
							{
								for (int j = 0; j < ochannel.GetDataDimension(); j++)
								{
									dst.Write(src.ReadByte());
								}
								src.BaseStream.Position += oextraStride;
								dst.BaseStream.Position += iextraStride;
							}
						}
						else
						{
							for (int i = 0; i < vertexCount; i++)
							{
								for (int j = 0; j < ochannel.GetDataDimension(); j++)
								{
									dst.Write(src.ReadUInt32());
								}
								src.BaseStream.Position += oextraStride;
								dst.BaseStream.Position += iextraStride;
							}
						}
						break;
					case VertexFormat.Float16:
						for (int i = 0; i < vertexCount; i++)
						{
							for (int j = 0; j < ochannel.GetDataDimension(); j++)
							{
								dst.Write(src.ReadUInt16());
							}
							src.BaseStream.Position += oextraStride;
							dst.BaseStream.Position += iextraStride;
						}
						break;
					case VertexFormat.Byte:
						for (int i = 0; i < vertexCount; i++)
						{
							for (int j = 0; j < ochannel.GetDataDimension(); j++)
							{
								dst.Write(src.ReadByte());
							}
							src.BaseStream.Position += oextraStride;
							dst.BaseStream.Position += iextraStride;
						}
						break;

					default:
						throw new NotSupportedException(ochannel.Format.ToString());
				}
			}
		}

		private static byte[] AppendSkin(Classes.Mesh.Mesh originMesh)
		{
			byte[] odata = originMesh.GetChannelsData();
			int dataSize = odata.Length + GetSkinLength(originMesh.Skin);
			byte[] idata = new byte[dataSize];
			Buffer.BlockCopy(odata, 0, idata, 0, odata.Length);
			using MemoryStream stream = new MemoryStream(idata, odata.Length, idata.Length - odata.Length);
			using BinaryWriter writer = new BinaryWriter(stream);
			AppendSkin(originMesh.Skin, writer);
			return idata;
		}

		private static void AppendSkin(BoneWeights4[] skin, BinaryWriter writer)
		{
			for (int i = 0; i < skin.Length; i++)
			{
				BoneWeights4 weight = skin[i];
				writer.Write(weight.Weight_0_);
				writer.Write(weight.Weight_1_);
				writer.Write(weight.Weight_2_);
				writer.Write(weight.Weight_3_);
				writer.Write(weight.BoneIndex_0_);
				writer.Write(weight.BoneIndex_1_);
				writer.Write(weight.BoneIndex_2_);
				writer.Write(weight.BoneIndex_3_);
			}
		}

		private static int GetSkinLength(BoneWeights4[] skin)
		{
			int weightSize = BoneWeights4.Dimention * sizeof(float);
			int indexSize = BoneWeights4.Dimention * sizeof(int);
			return (weightSize + indexSize) * skin.Length;
		}
	}
}

```

`AssetRipperCore/Directory.Build.props`:

```props
<Project>

  <PropertyGroup>
	<BaseIntermediateOutputPath>..\Bins\obj\standard\</BaseIntermediateOutputPath>
  </PropertyGroup>
  
</Project>
```

`AssetRipperCore/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipperCore/Project/Collections/AnimatorControllerExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Classes.Object;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.ChildMotion;
using AssetRipper.SourceGenerated.Subclasses.ControllerConstant;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorState_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorStateTransition_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorTransition_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour_;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;

namespace AssetRipper.Core.Project.Collections
{
	internal class AnimatorControllerExportCollection : AssetsExportCollection
	{
		public AnimatorControllerExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IUnityObjectBase asset) : this(assetExporter, virtualFile, (IAnimatorController)asset) { }

		public AnimatorControllerExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IAnimatorController asset) : base(assetExporter, asset)
		{
			IControllerConstant controller = asset.Controller_C91;
			AccessListBase<IOffsetPtr_StateMachineConstant> stateMachinesConst = controller.StateMachineArray;
			StateMachines = new IAnimatorStateMachine[stateMachinesConst.Count];
			for (int i = 0; i < stateMachinesConst.Count; i++)
			{
				IAnimatorStateMachine stateMachine = CreateVirtualStateMachine(virtualFile, asset, i);
				StateMachines[i] = stateMachine;
			}

			for (int i = 0; i < StateMachines.Length; i++)
			{
				IAnimatorStateMachine stateMachine = StateMachines[i];
				IStateMachineConstant stateMachineConstant = asset.Controller_C91.StateMachineArray[i].Data;
				AddAsset(stateMachine);
				AddBehaviours(asset, stateMachine.StateMachineBehaviours_C1107);

				foreach (PPtr_AnimatorStateTransition_ transitionPtr in stateMachine.AnyStateTransitions_C1107)
				{
					IAnimatorStateTransition transition = transitionPtr.GetAsset(virtualFile);
					AddAsset(transition);
				}
				foreach (PPtr_AnimatorTransition_ transitionPtr in stateMachine.EntryTransitions_C1107)
				{
					IAnimatorTransition transition = transitionPtr.GetAsset(virtualFile);
					AddAsset(transition);
				}

				for (int j = 0; j < stateMachine.ChildStates_C1107.Count; j++)
				{
					PPtr_AnimatorState_ statePtr = stateMachine.ChildStates_C1107[j].State;
					IAnimatorState state = statePtr.GetAsset(virtualFile);
					IStateConstant stateConstant = stateMachineConstant.StateConstantArray[j].Data;
					AddAsset(state);
					AddBehaviours(asset, state.StateMachineBehaviours_C1102);

					if (state.Motion_C1102.IsVirtual())
					{
						Motion motion = state.Motion_C1102.GetAsset(virtualFile);
						AddBlendTree(virtualFile, (IBlendTree)motion);
					}

					for (int k = 0; k < state.Transitions_C1102.Count; k++)
					{
						PPtr_AnimatorStateTransition_ transitionPtr = state.Transitions_C1102[k];
						IAnimatorStateTransition transition = transitionPtr.GetAsset(virtualFile);
						ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[k].Data;

						AddAsset(transition);
					}
				}
			}
		}

		private void AddBlendTree(VirtualSerializedFile virtualFile, IBlendTree blendTree)
		{
			AddAsset(blendTree);
			foreach (IChildMotion childMotion in blendTree.Childs_C206)
			{
				if (childMotion.Motion.IsVirtual())
				{
					Motion motion = childMotion.Motion.GetAsset(virtualFile);
					AddBlendTree(virtualFile, (IBlendTree)motion);
				}
			}
		}

		private void AddBehaviours(IAnimatorController asset, AssetList<PPtr_MonoBehaviour__5_0_0_f4> behaviours)
		{
			foreach (PPtr_MonoBehaviour__5_0_0_f4 pbehaviour in behaviours)
			{
				IMonoBehaviour? behaviour = pbehaviour.FindAsset(asset.SerializedFile);
				if (behaviour != null)
				{
#warning HACK: skip duplicates. remove it when AnimatorStateMachine's child StateMachines has been implemented
					if (!m_exportIDs.ContainsKey(behaviour.AssetInfo))
					{
						AddAsset(behaviour);
					}
				}
			}
		}

		private static IAnimatorStateMachine CreateStateMachine(LayoutInfo layout, AssetInfo assetInfo, IAnimatorController controller, int stateMachineIndex)
		{
			IAnimatorStateMachine generatedStateMachine = AnimatorStateMachineFactory.CreateAsset(layout.Version, assetInfo);
			generatedStateMachine.ObjectHideFlags = HideFlags.HideInHierarchy;
			/*
			VirtualSerializedFile virtualFile = (VirtualSerializedFile)assetInfo.File;

			int layerIndex = controller.Controller_C91.GetLayerIndexByStateMachineIndex(stateMachineIndex);
			ILayerConstant layer = controller.Controller_C91.LayerArray[layerIndex].Data;
			generatedStateMachine.NameString = controller.TOS_C91[layer.Binding];

			IStateMachineConstant stateMachine = controller.Controller_C91.StateMachineArray[stateMachineIndex].Data;

			int stateCount = stateMachine.StateConstantArray.Count;
			int stateMachineCount = 0;
			int count = stateCount + stateMachineCount;
			int side = (int)System.Math.Ceiling(System.Math.Sqrt(count));

			List<IAnimatorState> states = new List<IAnimatorState>();
			generatedStateMachine.ChildStates_C1107.Clear();
			generatedStateMachine.ChildStates_C1107.Capacity = stateCount;
			for (int y = 0, stateIndex = 0; y < side && stateIndex < stateCount; y++)
			{
				for (int x = 0; x < side && stateIndex < stateCount; x++, stateIndex++)
				{
					Vector3f position = new Vector3f(x * StateOffset, y * StateOffset, 0.0f);
					IAnimatorState state = CreateVirtualState(virtualFile, controller, stateMachineIndex, stateIndex, position);
					ChildAnimatorState childState = new ChildAnimatorState(state, position);
					generatedStateMachine.ChildStates_C1107[stateIndex] = childState;
					states.Add(state);
				}
			}

#warning TODO: child StateMachines
			//generatedStateMachine.ChildStateMachines_C1107 = new ChildAnimatorStateMachine[stateMachineCount];

			// set destination state for transitions here because all states has become valid only now
			for (int i = 0; i < stateMachine.StateConstantArray.Count; i++)
			{
				IAnimatorState state = states[i];
				IStateConstant stateConstant = stateMachine.StateConstantArray[i].Data;
				PPtr_AnimatorStateTransition_[] transitions = new PPtr_AnimatorStateTransition_[stateConstant.TransitionConstantArray.Count];
				for (int j = 0; j < stateConstant.TransitionConstantArray.Count; j++)
				{
					ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[j].Data;
					AnimatorStateTransition.Parameters parameters = new AnimatorStateTransition.Parameters
					{
						StateMachine = stateMachine,
						States = states,
						TOS = controller.TOS_C91,
						Transition = transitionConstant,
						Version = controller.SerializedFile.Version,
					};
					IAnimatorStateTransition transition = AnimatorStateTransition.CreateVirtualInstance(virtualFile, parameters);
					transitions[j] = new();
					transitions[j].CopyValues(transition.SerializedFile.CreatePPtr(transition));
				}
				state.Transitions_C1102.AddRange(transitions);
			}

			AnyStateTransitions = new PPtr<AnimatorStateTransition>[stateMachine.AnyStateTransitionConstantArray.Count];
			for (int i = 0; i < stateMachine.AnyStateTransitionConstantArray.Count; i++)
			{
				ITransitionConstant transitionConstant = stateMachine.AnyStateTransitionConstantArray[i].Data;
				AnimatorStateTransition.Parameters parameters = new AnimatorStateTransition.Parameters
				{
					StateMachine = stateMachine,
					States = states,
					TOS = controller.TOS_C91,
					Transition = transitionConstant,
					Version = controller.SerializedFile.Version,
				};
				IAnimatorStateTransition transition = AnimatorStateTransition.CreateVirtualInstance(virtualFile, parameters);
				AnyStateTransitions[i] = transition.SerializedFile.CreatePPtr(transition);
			}

			StateMachineConstant.Parameters stateParameters = new StateMachineConstant.Parameters
			{
				ID = layer.Binding,
				States = states,
				TOS = controller.TOS_C91,
				Version = controller.SerializedFile.Version,
			};
			generatedStateMachine.EntryTransitions_C1107 = stateMachine.CreateEntryTransitions(virtualFile, stateParameters);
#warning TEMP: remove comment when AnimatorStateMachine's child StateMachines has been implemented
			//StateMachineBehaviours = controller.GetStateBehaviours(layerIndex);
			generatedStateMachine.StateMachineBehaviours_C1107.Clear();

			generatedStateMachine.AnyStatePosition_C1107 = new Vector3f(0.0f, -StateOffset, 0.0f);
			generatedStateMachine.EntryPosition_C1107 = new Vector3f(StateOffset, -StateOffset, 0.0f);
			generatedStateMachine.ExitPosition_C1107 = new Vector3f(2.0f * StateOffset, -StateOffset, 0.0f);
			generatedStateMachine.ParentStateMachinePosition_C1107 = new Vector3f(0.0f, -2.0f * StateOffset, 0.0f);

			generatedStateMachine.DefaultState = generatedStateMachine.ChildStates_C1107.Count > 0 ? generatedStateMachine.ChildStates_C1107[(int)stateMachine.DefaultState].State : new();
			*/
			return generatedStateMachine;
		}

		public static IAnimatorStateMachine CreateVirtualStateMachine(VirtualSerializedFile virtualFile, IAnimatorController controller, int stateMachineIndex)
		{
			return virtualFile.CreateAsset((assetInfo) => CreateStateMachine(virtualFile.Layout, assetInfo, controller, stateMachineIndex));
		}
		/*
		private static IAnimatorState CreateState(LayoutInfo layout, AssetInfo assetInfo, IAnimatorController controller, int stateMachineIndex, int stateIndex, Vector3f position)
		{
			IAnimatorState generatedState = AnimatorStateFactory.CreateAsset(layout.Version, assetInfo);
			generatedState.ObjectHideFlags = HideFlags.HideInHierarchy;
			
			VirtualSerializedFile virtualFile = (VirtualSerializedFile)assetInfo.File;

			AssetDictionary<uint, Utf8String> TOS = controller.TOS_C91;
			if (!TOS.ContainsKey(0))
			{
				AssetDictionary<uint, Utf8String> tos = new AssetDictionary<uint, Utf8String>() { { 0, new Utf8String() } };
				tos.AddRange(controller.TOS_C91);
				TOS = tos;
			}
			IStateMachineConstant stateMachine = controller.Controller_C91.StateMachineArray[stateMachineIndex].Data;
			IStateConstant state = stateMachine.StateConstantArray[stateIndex].Data;

			generatedState.NameString = TOS[state.NameID];

			generatedState.Speed_C1102 = state.Speed;
			generatedState.CycleOffset_C1102 = state.CycleOffset;

			// skip Transitions because not all state exists at this moment
			
			// exclude StateMachine's behaviours
			int layerIndex = controller.Controller_C91.GetLayerIndexByStateMachineIndex(stateMachineIndex);
			PPtr<MonoBehaviour>[] machineBehaviours = controller.GetStateBehaviours(layerIndex);
			PPtr<MonoBehaviour>[] stateBehaviours = controller.GetStateBehaviours(stateMachineIndex, stateIndex);
			List<PPtr<MonoBehaviour>> behaviours = new List<PPtr<MonoBehaviour>>(stateBehaviours.Length);
			foreach (PPtr<MonoBehaviour> ptr in stateBehaviours)
			{
#warning TEMP: remove comment when AnimatorStateMachine's child StateMachines has been implemented
				//if (!machineBehaviours.Contains(ptr))
				{
					behaviours.Add(ptr);
				}
			}
			generatedState.StateMachineBehaviours_C1102 = behaviours.ToArray();

			generatedState.Position_C1102 = position;
			generatedState.IKOnFeet_C1102 = state.IKOnFeet;
			generatedState.WriteDefaultValues_C1102 = state.GetWriteDefaultValues(controller.SerializedFile.Version);
			generatedState.Mirror_C1102 = state.Mirror;
			generatedState.SpeedParameterActive_C1102 = state.SpeedParamID > 0;
			generatedState.MirrorParameterActive_C1102 = state.MirrorParamID > 0;
			generatedState.CycleOffsetParameterActive_C1102 = state.CycleOffsetParamID > 0;
			generatedState.TimeParameterActive_C1102 = state.TimeParamID > 0;

			generatedState.Motion_C1102 = state.CreateMotion(virtualFile, controller, 0);

			generatedState.Tag_C1102 = TOS[state.TagID];
			generatedState.SpeedParameter_C1102 = TOS[state.SpeedParamID];
			generatedState.MirrorParameter_C1102 = TOS[state.MirrorParamID];
			generatedState.CycleOffsetParameter_C1102 = TOS[state.CycleOffsetParamID];
			generatedState.TimeParameter_C1102 = TOS[state.TimeParamID];
			
			return generatedState;
		}
		
		public static IAnimatorState CreateVirtualState(VirtualSerializedFile virtualFile, IAnimatorController controller, int stateMachineIndex,
			int stateIndex, Vector3f position)
		{
			return virtualFile.CreateAsset((assetInfo) => CreateState(virtualFile.Layout, assetInfo, controller, stateMachineIndex, stateIndex, position));
		}
		*/
		public IAnimatorStateMachine[] StateMachines { get; set; }
	}
}

```

`AssetRipperCore/Project/Exporters/AnimatorControllerExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_91;

namespace AssetRipper.Core.Project.Exporters
{
	internal class AnimatorControllerExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAnimatorController;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AnimatorControllerExportCollection(this, virtualFile, asset);
		}
	}
}

```

`AssetRipperCore/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle(AssetRipper.Core.BuildInfo.CoreName)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(AssetRipper.Core.BuildInfo.Author)]
[assembly: AssemblyProduct(AssetRipper.Core.BuildInfo.CoreName)]
[assembly: AssemblyCopyright(AssetRipper.Core.BuildInfo.CopyRight)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: AssemblyVersion(AssetRipper.Core.BuildInfo.Version)]
[assembly: AssemblyFileVersion(AssetRipper.Core.BuildInfo.Version)]
```

`AssetRipperGUI/App.axaml`:

```axaml
<Application xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             x:Class="AssetRipper.GUI.App">
    <Application.Styles>
		<StyleInclude Source="avares://Avalonia.Themes.Default/DefaultTheme.xaml"/>
		<!--<StyleInclude Source="avares://Avalonia.Themes.Default/Accents/BaseLight.xaml"/>-->
		<StyleInclude Source="avares://Avalonia.Themes.Default/Accents/BaseDark.xaml"/>
		<StyleInclude Source="avares://Avalonia.Controls.DataGrid/Themes/Default.xaml"/>
    </Application.Styles>
</Application>

```

`AssetRipperGUI/App.axaml.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.GUI.Logging;
using Avalonia;
using Avalonia.Controls;
using Avalonia.Markup.Xaml;

namespace AssetRipper.GUI
{
	public class App : Application
	{

		public override void Initialize()
		{
			AvaloniaXamlLoader.Load(this);
		}

		public static void AppMain(Application app, string[] args)
		{
			Avalonia.Logging.Logger.Sink = new RipperAvaloniaSink();

			AppDomain.CurrentDomain.UnhandledException += (sender, e) =>
			{
				try
				{
					Logger.Error(LogCategory.General, "Unhandled app-level fatal exception!", e.ExceptionObject as Exception);
				}
				catch (Exception)
				{
					//Ignore, that's all we can do.
				}
			};

			app.Run(new MainWindow());
		}
	}
}
```

`AssetRipperGUI/AssetInfo/AssetYamlNode.cs`:

```cs
using AssetRipper.Yaml;
using System.Collections.Generic;

namespace AssetRipper.GUI.AssetInfo
{
	public class AssetYamlNode
	{
		//Nodes can be either key-value (YamlScalarNode) or object (YamlMappingNode)/array (YamlSequenceNode).
		//If key-value, display name is "key: value"
		//If object/array, display name is "key", nested children are array elements.

		//Read from UI
		public string DisplayName { get; }
		//Read from UI
		public List<AssetYamlNode> Children { get; } = new();

		public AssetYamlNode(string key, YamlScalarNode value)
		{
			if (key == "_typelessdata")
			{
				//Potentially huge block of data, narrow it down
				DisplayName = $"{key}: <Byte Array of length {value.Value.Length / 2}>";
				return;
			}

			DisplayName = $"{key}: {value.Value}";

			if (string.IsNullOrEmpty(value.Value))
				DisplayName += "<Null or Empty Value>";
		}

		public AssetYamlNode(string key, YamlMappingNode value)
		{
			DisplayName = key;
			foreach (var (keyNode, valueNode) in value.m_children)
			{
				string subKey = keyNode is YamlScalarNode s ? s.Value : keyNode.ToString()!;

				AppendChild(subKey, valueNode);
			}

			if (value.m_children.Count == 0)
			{
				DisplayName += ": <Empty Dictionary>";
			}
			else
			{
				DisplayName += $" (Dictionary with {value.m_children.Count} key{(value.m_children.Count == 1 ? "" : "s")})";
			}
		}

		public AssetYamlNode(string key, YamlSequenceNode value)
		{
			DisplayName = key;
			int i = 0;
			foreach (var valueNode in value.m_children)
			{
				string subKey = $"[{i}]";

				AppendChild(subKey, valueNode);

				i++;
			}

			if (value.m_children.Count == 0)
			{
				DisplayName += ": <Empty Array>";
			}
			else
			{
				DisplayName += $" (Array of size {value.m_children.Count})";
			}
		}

		private void AppendChild(string subKey, YamlNode valueNode)
		{
			AssetYamlNode child;
			if (valueNode is YamlScalarNode scalarNode)
			{
				child = new AssetYamlNode(subKey, scalarNode);
			}
			else if (valueNode is YamlMappingNode mappingNode)
			{
				child = new AssetYamlNode(subKey, mappingNode);
			}
			else if (valueNode is YamlSequenceNode sequenceNode)
			{
				child = new AssetYamlNode(subKey, sequenceNode);
			}
			else
			{
				return;
			}

			Children.Add(child);
		}
	}
}
```

`AssetRipperGUI/AssetInfo/AvaloniaBitmapFromDirectBitmap.cs`:

```cs
using AssetRipper.Library.Configuration;
using AssetRipper.Library.Utils;
using Avalonia.Media.Imaging;
using System.IO;

namespace AssetRipper.GUI.AssetInfo
{
	public static class AvaloniaBitmapFromDirectBitmap
	{
		/// <summary>
		/// Converts a DirectBitmap into an Avalonia Bitmap. Disposes the DirectBitmap.
		/// </summary>
		public static Bitmap? Make(DirectBitmap directBitmap)
		{
			MemoryStream resultStream = new();
			if (directBitmap.Save(resultStream, ImageExportFormat.Png))
			{
				directBitmap.Dispose();
				resultStream.Seek(0, SeekOrigin.Begin);
				return new Bitmap(resultStream);
			}
			else
			{
				directBitmap.Dispose();
				resultStream.Dispose();
				return null;
			}
		}
	}
}
```

`AssetRipperGUI/AssetInfo/SelectedAsset.cs`:

```cs
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Project;
using AssetRipper.Library.Exporters.Audio;
using AssetRipper.Library.Exporters.Shaders;
using AssetRipper.Library.Exporters.Terrains;
using AssetRipper.Library.Exporters.Textures;
using AssetRipper.Library.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.Yaml;
using Avalonia.Media;
using LibVLCSharp.Shared;
using System.IO;
using System.Text;
using System.Threading;

namespace AssetRipper.GUI.AssetInfo
{
	public sealed class SelectedAsset : BaseViewModel, IDisposable
	{
		private static readonly LibVLC? LibVlc;

		public IUnityObjectBase Asset { get; }
		private readonly IExportContainer? _uiAssetContainer;

		private readonly MemoryStream? _audioStream;
		private readonly MediaPlayer? _mediaPlayer;
		private readonly Media? _media;

		private float _lengthSeconds;
		private float _positionSeconds;
		private string _positionString = "00:00:00/<unknown>";
		private bool _isPaused = true;

		static SelectedAsset()
		{
			try
			{
				LibVLCSharp.Shared.Core.Initialize();
			}
			catch (Exception)
			{
				return;
			}

			LibVlc = new();
			// LibVlc.Log += VlcLogHandler;
		}

		private static void VlcLogHandler(object? _, LogEventArgs e)
		{
			LogType level = e.Level switch
			{
				LogLevel.Debug => LogType.Debug,
				LogLevel.Notice => LogType.Info,
				LogLevel.Warning => LogType.Warning,
				LogLevel.Error => LogType.Error,
				_ => throw new()
			};
			Logger.Log(level, LogCategory.LibVlc, $"[{e.Module ?? "General"}] [{e.Level}] {e.Message}");
		}

		public SelectedAsset(IUnityObjectBase asset, IExportContainer? uiAssetContainer)
		{
			Asset = asset;
			_uiAssetContainer = uiAssetContainer;

			BuildYamlTree();

			if (asset is IAudioClip clip && LibVlc != null)
			{
				DateTime start = DateTime.Now;
				bool success = AudioClipDecoder.TryGetDecodedAudioClipData(clip, out byte[] rawClipAudioData, out string _);
				if (!success || rawClipAudioData == null)
				{
					//Unsupported sound type
					return;
				}

				_audioStream = new(rawClipAudioData);

				_media = new(LibVlc, new StreamMediaInput(_audioStream));
				_mediaPlayer = new(_media);

				_mediaPlayer.LengthChanged += (_, e) => AudioLengthSeconds = e.Length / 1000f;
				_mediaPlayer.PositionChanged += (_, e) => AudioPositionSeconds = e.Position * AudioLengthSeconds;
				_mediaPlayer.EndReached += (_, _) => ThreadPool.QueueUserWorkItem(_ => _mediaPlayer.Stop());
				_mediaPlayer.Stopped += (_, _) =>
				{
					IsPaused = true;
					AudioPositionSeconds = 0;
					_mediaPlayer.Position = 0;
					UpdatePositionString();
				};
			}
		}

		private void BuildYamlTree()
		{
			try
			{
				YamlMappingNode yamlRoot = (YamlMappingNode)Asset.ExportYaml(_uiAssetContainer);

				YamlTree = new[] { new AssetYamlNode(Name ?? Asset.GetType().Name, yamlRoot) };
			}
			catch (Exception e)
			{
				YamlTreeIsSupported = false;

				if (e is NotImplementedException or NotSupportedException)
				{
					YamlTree = new[] { new AssetYamlNode("Asset Doesn't Support Yaml Export", new YamlScalarNode(true)) };
					return;
				}
				Logger.Error(e);
				YamlTree = new[] { new AssetYamlNode($"Asset threw {e.GetType().Name} when exporting as Yaml", new YamlScalarNode(true)) };
			}
		}

		//Read from UI
		public AssetYamlNode[] YamlTree { get; private set; } = { new("Tree loading...", YamlScalarNode.Empty) };

		//Read from UI
		public bool HasImageData => Asset is ITexture2D or ITerrainData;

		//Read from UI
		public bool HasAudioData => Asset is IAudioClip;

		//Read from UI
		public bool YamlTreeIsSupported { get; private set; } = true;

		//Read from UI
		public bool HasTextData => Asset switch
		{
			IShader => true,
			ITextAsset txt => txt.Script_C49.Data.Length > 0,
			IHasRawData rawDataAsset => rawDataAsset.RawData.Length > 0,
			_ => false,
		};

		//Read from UI
		public string? TextAssetData => (Asset switch
		{
			IShader shader => DumpShaderDataAsText(shader),
			ITextAsset txt => txt.Script_C49.String,
			IHasRawData rawDataAsset => rawDataAsset.RawData.ToFormattedHex(),
			_ => null
		})?.Replace("\t", "    ");

		//Read from UI
		public IImage? ImageData
		{
			get
			{
				switch (Asset)
				{
					case ITexture2D texture:
						{
							DirectBitmap? directBitmap = TextureAssetExporter.ConvertToBitmap(texture);
							return directBitmap is null ? null : AvaloniaBitmapFromDirectBitmap.Make(directBitmap);
						}
					case ITerrainData terrain:
						{
							DirectBitmap? directBitmap = TerrainHeatmapExporter.GetBitmap(terrain);
							return AvaloniaBitmapFromDirectBitmap.Make(directBitmap);
						}
					default:
						return null;
				}
			}
		}

		private bool HasName => Asset switch
		{
			IHasNameString hasName => !string.IsNullOrEmpty(hasName.NameString),
			_ => false
		};

		private string? Name => Asset switch
		{
			IHasNameString hasName => hasName.NameString,
			_ => null
		};

		private Core.Classes.Texture2D.TextureFormat TextureFormat => Asset switch
		{
			ITexture2D img => (Core.Classes.Texture2D.TextureFormat)img.TextureFormat_C28,
			ITerrainData => Core.Classes.Texture2D.TextureFormat.RGBA32,
			_ => Core.Classes.Texture2D.TextureFormat.Automatic,
		};

		private int ImageWidth => Asset switch
		{
			ITexture2D img => img.Width_C28,
			ITerrainData terrain => terrain.Heightmap_C156.Width,
			_ => -1,
		};

		private int ImageHeight => Asset switch
		{
			ITexture2D img => img.Height_C28,
			ITerrainData terrain => terrain.Heightmap_C156.Height,
			_ => -1,
		};

		public float AudioLengthSeconds
		{
			get => _lengthSeconds;
			set
			{
				_lengthSeconds = value;
				OnPropertyChanged();
				UpdatePositionString();
			}
		}

		public float AudioPositionSeconds
		{
			get => _positionSeconds;
			set
			{
				_positionSeconds = value;
				OnPropertyChanged();
				UpdatePositionString();
			}
		}

		public string PositionString
		{
			get => _positionString;
			set
			{
				_positionString = value;
				OnPropertyChanged();
			}
		}

		public bool IsPaused
		{
			get => _isPaused;
			set
			{
				_isPaused = value;
				OnPropertyChanged();
			}
		}

		//Read from UI

		public string BasicInformation
		{
			get
			{
				StringBuilder builder = new StringBuilder();
				builder.Append($"Asset Class: {Asset.GetType()}\n");

				builder.Append($"Asset Type ID: {Asset.ClassID}\n");

				if (HasName)
				{
					builder.Append($"Name: {Name}\n");
				}

				if (HasImageData)
				{
					builder.Append($"Image Format: {TextureFormat}\n");
					builder.Append($"Image Dimensions (width x height): {ImageWidth} x {ImageHeight} pixels");
				}

				return builder.ToString();
			}
		}

		public void PlayClip()
		{
			IsPaused = false;
			_mediaPlayer?.Play();
		}

		public void PauseClip()
		{
			IsPaused = true;
			_mediaPlayer?.Pause();
		}

		//Called from UI
		public void TogglePause()
		{
			if (IsPaused)
			{
				PlayClip();
			}
			else
			{
				PauseClip();
			}
		}

		public void Dispose()
		{
			_audioStream?.Dispose();
			_mediaPlayer?.Dispose();
			_media?.Dispose();
		}

		private void UpdatePositionString()
		{
			PositionString = $"{TimeSpan.FromSeconds(AudioPositionSeconds):hh\\:mm\\:ss}/{TimeSpan.FromSeconds(AudioLengthSeconds):g}";
		}

		private string DumpShaderDataAsText(IShader shader)
		{
			using MemoryStream stream = new();
			DummyShaderTextExporter.ExportShader(shader, _uiAssetContainer, stream);

			return Encoding.UTF8.GetString(stream.GetBuffer());
		}
	}
}

```

`AssetRipperGUI/AssetRipperGUI.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">
	<PropertyGroup>
		<OutputType>Exe</OutputType>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<Nullable>enable</Nullable>
		<OutputPath>..\Bins\AssetRipperGUI\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipperGUI\$(Configuration)\</IntermediateOutputPath>
		<Configurations>DebugWindows;ReleaseWindows;DebugMac;ReleaseMac;DebugLinux;ReleaseLinux</Configurations>
		<AssemblyName>AssetRipper</AssemblyName>
		<RootNamespace>AssetRipper.GUI</RootNamespace>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<Copyright>Copyright © 2022</Copyright>
		<Authors>ds5678</Authors>
		<Platforms>x64</Platforms>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='DebugMac' or '$(Configuration)'=='DebugLinux'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<PropertyGroup>
		<ApplicationIcon>Resources\GUI_Icon.ico</ApplicationIcon>
	</PropertyGroup>

	<ItemGroup>
		<AvaloniaResource Include="Resources\**" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="AssetRipper.SourceGenerated">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>../Libraries/AssetRipper.SourceGenerated.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="Avalonia" Version="0.10.15" />
		<PackageReference Include="Avalonia.Desktop" Version="0.10.15" />
		<PackageReference Include="Avalonia.Diagnostics" Version="0.10.15" />
		<PackageReference Include="LibVLCSharp" Version="3.6.6" />
		<PackageReference Include="LibVLCSharp.Avalonia" Version="3.6.6" />
		<PackageReference Include="MessageBox.Avalonia" Version="2.0.1" />
		<PackageReference Include="System.IO.FileSystem" Version="4.3.0" />
		<PackageReference Include="System.IO.FileSystem.AccessControl" Version="5.0.0" />
		<PackageReference Include="System.Security.AccessControl" Version="6.0.0" />
	</ItemGroup>
	<ItemGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='ReleaseWindows'">
		<PackageReference Include="VideoLAN.LibVLC.Windows" Version="3.0.17.4" />
	</ItemGroup>
	<ItemGroup Condition="'$(Configuration)'=='DebugMac' or '$(Configuration)'=='ReleaseMac'">
		<PackageReference Include="VideoLAN.LibVLC.Mac" Version="3.1.3.1" />
	</ItemGroup>
	<ItemGroup>
		<ProjectReference Include="..\AssetRipperCore\AssetRipperCore.csproj" />
		<ProjectReference Include="..\AssetRipperLibrary\AssetRipperLibrary.csproj" />
	</ItemGroup>
	<ItemGroup>
		<None Remove="..\Localizations\*.json" />
		<EmbeddedResource Include="..\Localizations\*.json" />
	</ItemGroup>
</Project>

```

`AssetRipperGUI/BaseViewModel.cs`:

```cs
using JetBrains.Annotations;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace AssetRipper.GUI
{
	public abstract class BaseViewModel : INotifyPropertyChanged
	{
		public event PropertyChangedEventHandler? PropertyChanged;

		[NotifyPropertyChangedInvocator]
		protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
		{
			PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
		}
	}
}
```

`AssetRipperGUI/Components/AudioExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class AudioExportConfigDropdown : BaseConfigurationDropdown<AudioExportFormat>
	{
		protected override string GetValueDisplayName(AudioExportFormat value) => value switch
		{
			AudioExportFormat.Yaml => MainWindow.Instance.LocalizationManager["audio_format_yaml"],
			AudioExportFormat.Native => MainWindow.Instance.LocalizationManager["audio_format_native"],
			AudioExportFormat.PreferWav => MainWindow.Instance.LocalizationManager["audio_format_force_wav"],
			AudioExportFormat.Default => MainWindow.Instance.LocalizationManager["audio_format_default"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(AudioExportFormat value) => value switch
		{
			AudioExportFormat.Yaml => MainWindow.Instance.LocalizationManager["audio_format_yaml_description"],
			AudioExportFormat.Native => MainWindow.Instance.LocalizationManager["audio_format_native_description"],
			AudioExportFormat.PreferWav => MainWindow.Instance.LocalizationManager["audio_format_force_wav_description"],
			AudioExportFormat.Default => MainWindow.Instance.LocalizationManager["audio_format_default_description"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/BaseConfigurationDropdown.axaml`:

```axaml
<UserControl xmlns="https://github.com/avaloniaui"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450">
    <Grid RowDefinitions="25,40,*">
        <TextBlock Grid.Row="0" Text="{Binding OptionTitle, FallbackValue='Title'}"></TextBlock>
        <ComboBox Grid.Row="1" Items="{Binding Values}" SelectedItem="{Binding RawSelectedValue, FallbackValue='Value'}"></ComboBox>
        <TextBlock Grid.Row="2" Text="{Binding SelectedValueDescription, FallbackValue='NO DESCRIPTION SET'}" FontSize="14"
                   TextWrapping="Wrap"></TextBlock>
    </Grid>
</UserControl>

```

`AssetRipperGUI/Components/BaseConfigurationDropdown.axaml.cs`:

```cs
using Avalonia;
using Avalonia.Controls;
using Avalonia.Data;
using Avalonia.Markup.Xaml;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.GUI.Components
{
	public abstract class BaseConfigurationDropdown<T> : UserControlWithPropChange where T : struct, Enum
	{
		private string _optionTitle = $"<Missing Title##{typeof(T).Name}>";
		private ItemWrapper? _selectedValue;
		private string? _selectedValueDesc;

		public static DirectProperty<BaseConfigurationDropdown<T>, List<ItemWrapper>> ValuesProperty =
			AvaloniaProperty.RegisterDirect<BaseConfigurationDropdown<T>, List<ItemWrapper>>(nameof(Values), obj => obj.Values);

		public static DirectProperty<BaseConfigurationDropdown<T>, ItemWrapper> RawSelectedValueProperty =
			AvaloniaProperty.RegisterDirect<BaseConfigurationDropdown<T>, ItemWrapper>(nameof(RawSelectedValue), obj => obj.RawSelectedValue, (obj, val) => obj.RawSelectedValue = val);

		public static DirectProperty<BaseConfigurationDropdown<T>, T> SelectedValueProperty =
			AvaloniaProperty.RegisterDirect<BaseConfigurationDropdown<T>, T>(nameof(SelectedValue), obj => obj.SelectedValue, (obj, val) => obj.SelectedValue = val);

		public static DirectProperty<BaseConfigurationDropdown<T>, string> OptionTitleProperty =
			AvaloniaProperty.RegisterDirect<BaseConfigurationDropdown<T>, string>(nameof(OptionTitle), obj => obj.OptionTitle, (obj, val) => obj.OptionTitle = val);

		public static DirectProperty<BaseConfigurationDropdown<T>, string?> SelectedValueDescriptionProperty =
			AvaloniaProperty.RegisterDirect<BaseConfigurationDropdown<T>, string?>(nameof(SelectedValueDescription), obj => obj.SelectedValueDescription, (obj, val) => obj.SelectedValueDescription = val);

		public List<ItemWrapper> Values { get; }

		public string OptionTitle
		{
			get => _optionTitle;
			set
			{
				var oldValue = _optionTitle;
				_optionTitle = value;
				OnPropertyChanged();
				RaisePropertyChanged(OptionTitleProperty, oldValue, value);
			}
		}

		public ItemWrapper RawSelectedValue
		{
			get => _selectedValue!;
			set
			{
				var oldValue = _selectedValue;
				_selectedValue = value;
				OnPropertyChanged();
				RaisePropertyChanged(RawSelectedValueProperty, oldValue, value);
				RaisePropertyChanged(SelectedValueProperty, oldValue == null ? Optional<T>.Empty : oldValue.Item, value.Item);
				SelectedValueDescription = GetValueDescription(value.Item);
			}
		}

		public string? SelectedValueDescription
		{
			get => _selectedValueDesc;
			set
			{
				var oldValue = _selectedValueDesc;
				_selectedValueDesc = value;
				OnPropertyChanged();
				RaisePropertyChanged(SelectedValueDescriptionProperty, oldValue, value);
			}
		}

		public T SelectedValue
		{
			get => RawSelectedValue.Item;
			set => RawSelectedValue = new(value, GetValueDisplayName(value));
		}

		public BaseConfigurationDropdown()
		{
			Values = Enum.GetValues<T>().Select(e => new ItemWrapper(e, GetValueDisplayName(e))).ToList();
			InitializeComponent();

			MainWindow.Instance.LocalizationManager.OnLanguageChanged += () =>
			{
				//Reload all localized strings
				Values.ForEach(v => v.DisplayName = GetValueDisplayName(v.Item));
				RaisePropertyChanged(ValuesProperty, Optional<List<ItemWrapper>>.Empty, Values);

				RawSelectedValue = new(RawSelectedValue.Item, GetValueDisplayName(RawSelectedValue.Item));
			};
		}

		private void InitializeComponent()
		{
			Content = AvaloniaXamlLoader.Load(new Uri("avares://AssetRipper/Components/BaseConfigurationDropdown.axaml"));
			((UserControl)Content).DataContext = this;
		}

		protected virtual string GetValueDisplayName(T value) => Enum.GetName(typeof(T), value) ?? throw new($"Value {value} is not defined in the enum {typeof(T)}, but has ended up in a dropdown?");

		protected virtual string? GetValueDescription(T value) => null;

		public class ItemWrapper
		{
			public T Item;
			public string DisplayName;

			public ItemWrapper(T item, string displayName)
			{
				Item = item;
				DisplayName = displayName;
			}

			public override string ToString() => DisplayName;

			protected bool Equals(ItemWrapper other)
			{
				return Item.Equals(other.Item) && DisplayName == other.DisplayName;
			}

			public override bool Equals(object? obj)
			{
				if (ReferenceEquals(null, obj))
				{
					return false;
				}

				if (ReferenceEquals(this, obj))
				{
					return true;
				}

				if (obj.GetType() != this.GetType())
				{
					return false;
				}

				return Equals((ItemWrapper)obj);
			}

			public override int GetHashCode()
			{
				return HashCode.Combine(Item, DisplayName);
			}
		}
	}
}
```

`AssetRipperGUI/Components/BundledAssetsExportModeConfigDropdown.cs`:

```cs
using AssetRipper.Core.Configuration;

namespace AssetRipper.GUI.Components
{
	public class BundledAssetsExportConfigDropdown : BaseConfigurationDropdown<BundledAssetsExportMode>
	{
		protected override string GetValueDisplayName(BundledAssetsExportMode value) => value switch
		{
			BundledAssetsExportMode.GroupByAssetType => MainWindow.Instance.LocalizationManager["bundled_assets_export_group_by_asset_type"],
			BundledAssetsExportMode.GroupByBundleName => MainWindow.Instance.LocalizationManager["bundled_assets_export_group_by_bundle_name"],
			BundledAssetsExportMode.DirectExport => MainWindow.Instance.LocalizationManager["bundled_assets_export_direct_export"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(BundledAssetsExportMode value) => value switch
		{
			BundledAssetsExportMode.GroupByAssetType => MainWindow.Instance.LocalizationManager["bundled_assets_export_group_by_asset_type_description"],
			BundledAssetsExportMode.GroupByBundleName => MainWindow.Instance.LocalizationManager["bundled_assets_export_group_by_bundle_name_description"],
			BundledAssetsExportMode.DirectExport => MainWindow.Instance.LocalizationManager["bundled_assets_export_direct_export_description"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/ImageExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class ImageExportConfigDropdown : BaseConfigurationDropdown<ImageExportFormat>
	{
		protected override string? GetValueDescription(ImageExportFormat value) => value switch
		{
			_ => MainWindow.Instance.LocalizationManager["image_format_description"],
		};
	}
}
```

`AssetRipperGUI/Components/MeshExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class MeshExportConfigDropdown : BaseConfigurationDropdown<MeshExportFormat>
	{
		protected override string GetValueDisplayName(MeshExportFormat value) => value switch
		{
			MeshExportFormat.Native => MainWindow.Instance.LocalizationManager["mesh_format_native"],
			MeshExportFormat.Obj => MainWindow.Instance.LocalizationManager["mesh_format_obj"],
			MeshExportFormat.StlAscii => MainWindow.Instance.LocalizationManager["mesh_format_stl_ascii"],
			MeshExportFormat.StlBinary => MainWindow.Instance.LocalizationManager["mesh_format_stl_binary"],
			MeshExportFormat.PlyAscii => MainWindow.Instance.LocalizationManager["mesh_format_ply_ascii"],
			MeshExportFormat.GlbPrimitive => MainWindow.Instance.LocalizationManager["mesh_format_glb_primitive"],
			MeshExportFormat.FbxPrimitive => MainWindow.Instance.LocalizationManager["mesh_format_fbx_primitive"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(MeshExportFormat value) => value switch
		{
			MeshExportFormat.Native => MainWindow.Instance.LocalizationManager["mesh_format_native_description"],
			//MeshExportFormat.Obj => MainWindow.Instance.LocalizationManager["mesh_format_obj_description"],
			//MeshExportFormat.StlAscii => MainWindow.Instance.LocalizationManager["mesh_format_stl_ascii_description"],
			//MeshExportFormat.StlBinary => MainWindow.Instance.LocalizationManager["mesh_format_stl_binary_description"],
			//MeshExportFormat.PlyAscii => MainWindow.Instance.LocalizationManager["mesh_format_ply_ascii_description"],
			//MeshExportFormat.GlbPrimitive => MainWindow.Instance.LocalizationManager["mesh_format_glb_primitive_description"],
			//MeshExportFormat.FbxPrimitive => MainWindow.Instance.LocalizationManager["mesh_format_fbx_primitive_description"],
			MeshExportFormat.Obj => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			MeshExportFormat.StlAscii => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			MeshExportFormat.StlBinary => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			MeshExportFormat.PlyAscii => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			MeshExportFormat.GlbPrimitive => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			MeshExportFormat.FbxPrimitive => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/ScriptContentLevelConfigDropdown.cs`:

```cs
using AssetRipper.Core.Configuration;

namespace AssetRipper.GUI.Components
{
	public class ScriptContentLevelConfigDropdown : BaseConfigurationDropdown<ScriptContentLevel>
	{
		protected override string GetValueDisplayName(ScriptContentLevel value) => value switch
		{
			ScriptContentLevel.Level0 => MainWindow.Instance.LocalizationManager["script_content_level_0"],
			ScriptContentLevel.Level1 => MainWindow.Instance.LocalizationManager["script_content_level_1"],
			ScriptContentLevel.Level2 => MainWindow.Instance.LocalizationManager["script_content_level_2"],
			ScriptContentLevel.Level3 => MainWindow.Instance.LocalizationManager["script_content_level_3"],
			ScriptContentLevel.Level4 => MainWindow.Instance.LocalizationManager["script_content_level_4"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(ScriptContentLevel value) => value switch
		{
			ScriptContentLevel.Level0 => MainWindow.Instance.LocalizationManager["script_content_level_0_description"],
			ScriptContentLevel.Level1 => MainWindow.Instance.LocalizationManager["script_content_level_1_description"],
			ScriptContentLevel.Level2 => MainWindow.Instance.LocalizationManager["script_content_level_2_description"],
			ScriptContentLevel.Level3 => MainWindow.Instance.LocalizationManager["script_content_level_3_description"],
			ScriptContentLevel.Level4 => MainWindow.Instance.LocalizationManager["script_content_level_4_description"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/ScriptExportModeConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class ScriptExportModeConfigDropdown : BaseConfigurationDropdown<ScriptExportMode>
	{
		protected override string GetValueDisplayName(ScriptExportMode value) => value switch
		{
			ScriptExportMode.Decompiled => MainWindow.Instance.LocalizationManager["script_export_format_decompiled"],
			ScriptExportMode.Hybrid => MainWindow.Instance.LocalizationManager["script_export_format_hybrid"],
			ScriptExportMode.DllExportWithRenaming => MainWindow.Instance.LocalizationManager["script_export_format_dll_with_renaming"],
			ScriptExportMode.DllExportWithoutRenaming => MainWindow.Instance.LocalizationManager["script_export_format_dll_without_renaming"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(ScriptExportMode value) => value switch
		{
			ScriptExportMode.Decompiled => MainWindow.Instance.LocalizationManager["script_export_format_decompiled_description"],
			ScriptExportMode.Hybrid => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			ScriptExportMode.DllExportWithRenaming => MainWindow.Instance.LocalizationManager["not_implemented_yet"],
			ScriptExportMode.DllExportWithoutRenaming => MainWindow.Instance.LocalizationManager["script_export_format_dll_without_renaming_description"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/ScriptLanguageVersionConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class ScriptLanguageVersionConfigDropdown : BaseConfigurationDropdown<ScriptLanguageVersion>
	{
		protected override string GetValueDisplayName(ScriptLanguageVersion value) => value switch
		{
			ScriptLanguageVersion.CSharp1 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_1"],
			ScriptLanguageVersion.CSharp2 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_2"],
			ScriptLanguageVersion.CSharp3 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_3"],
			ScriptLanguageVersion.CSharp4 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_4"],
			ScriptLanguageVersion.CSharp5 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_5"],
			ScriptLanguageVersion.CSharp6 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_6"],
			ScriptLanguageVersion.CSharp7 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_7"],
			ScriptLanguageVersion.CSharp7_1 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_7_1"],
			ScriptLanguageVersion.CSharp7_2 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_7_2"],
			ScriptLanguageVersion.CSharp7_3 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_7_3"],
			ScriptLanguageVersion.CSharp8_0 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_8_0"],
			ScriptLanguageVersion.CSharp9_0 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_9_0"],
			ScriptLanguageVersion.CSharp10_0 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_10_0"],
			ScriptLanguageVersion.CSharp11_0 => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_11_0"],
			ScriptLanguageVersion.Latest => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_latest"],
			ScriptLanguageVersion.AutoSafe => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_auto_safe"],
			ScriptLanguageVersion.AutoExperimental => MainWindow.Instance.LocalizationManager["c_sharp_langage_version_config_auto_experimental"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(ScriptLanguageVersion value)
		{
			return MainWindow.Instance.LocalizationManager["c_sharp_language_version_config_description"];
		}
	}
}

```

`AssetRipperGUI/Components/ShaderExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class ShaderExportConfigDropdown : BaseConfigurationDropdown<ShaderExportMode>
	{
		protected override string GetValueDisplayName(ShaderExportMode value) => value switch
		{
			ShaderExportMode.Dummy => MainWindow.Instance.LocalizationManager["shader_asset_format_dummy"],
			ShaderExportMode.Yaml => MainWindow.Instance.LocalizationManager["shader_asset_format_yaml"],
			ShaderExportMode.Disassembly => MainWindow.Instance.LocalizationManager["shader_asset_format_disassembly"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(ShaderExportMode value) => value switch
		{
			ShaderExportMode.Dummy => MainWindow.Instance.LocalizationManager["shader_asset_format_dummy_description"],
			ShaderExportMode.Yaml => MainWindow.Instance.LocalizationManager["shader_asset_format_yaml_description"],
			ShaderExportMode.Disassembly => MainWindow.Instance.LocalizationManager["shader_asset_format_disassembly_description"],
			_ => null,
		};
	}
}

```

`AssetRipperGUI/Components/SpriteExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class SpriteExportConfigDropdown : BaseConfigurationDropdown<SpriteExportMode>
	{
		protected override string GetValueDisplayName(SpriteExportMode value) => value switch
		{
			SpriteExportMode.Native => MainWindow.Instance.LocalizationManager["sprite_format_native"],
			SpriteExportMode.Texture2D => MainWindow.Instance.LocalizationManager["sprite_format_texture"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(SpriteExportMode value) => value switch
		{
			SpriteExportMode.Native => MainWindow.Instance.LocalizationManager["sprite_format_native_description"],
			SpriteExportMode.Texture2D => MainWindow.Instance.LocalizationManager["sprite_format_texture_description"],
			_ => null,
		};
	}
}
```

`AssetRipperGUI/Components/TerrainExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class TerrainExportConfigDropdown : BaseConfigurationDropdown<TerrainExportMode>
	{
		protected override string GetValueDisplayName(TerrainExportMode value) => value switch
		{
			TerrainExportMode.Native => MainWindow.Instance.LocalizationManager["terrain_format_native"],
			TerrainExportMode.Obj => MainWindow.Instance.LocalizationManager["terrain_format_obj"],
			TerrainExportMode.Heatmap => MainWindow.Instance.LocalizationManager["terrain_format_heatmap"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(TerrainExportMode value) => value switch
		{
			TerrainExportMode.Native => MainWindow.Instance.LocalizationManager["terrain_format_native_description"],
			TerrainExportMode.Obj => MainWindow.Instance.LocalizationManager["terrain_format_obj_description"],
			TerrainExportMode.Heatmap => MainWindow.Instance.LocalizationManager["terrain_format_heatmap_description"],
			_ => null,
		};
	}
}
```

`AssetRipperGUI/Components/TextExportConfigDropdown.cs`:

```cs
using AssetRipper.Library.Configuration;

namespace AssetRipper.GUI.Components
{
	public class TextExportConfigDropdown : BaseConfigurationDropdown<TextExportMode>
	{
		protected override string GetValueDisplayName(TextExportMode value) => value switch
		{
			TextExportMode.Bytes => MainWindow.Instance.LocalizationManager["text_asset_format_binary"],
			TextExportMode.Txt => MainWindow.Instance.LocalizationManager["text_asset_format_text"],
			TextExportMode.Parse => MainWindow.Instance.LocalizationManager["text_asset_format_parse"],
			_ => base.GetValueDisplayName(value),
		};

		protected override string? GetValueDescription(TextExportMode value) => value switch
		{
			TextExportMode.Bytes => MainWindow.Instance.LocalizationManager["text_asset_format_binary_description"],
			TextExportMode.Txt => MainWindow.Instance.LocalizationManager["text_asset_format_text_description"],
			TextExportMode.Parse => MainWindow.Instance.LocalizationManager["text_asset_format_parse_description"],
			_ => null,
		};
	}
}
```

`AssetRipperGUI/Components/UserControlWithPropChange.cs`:

```cs
using Avalonia.Controls;
using JetBrains.Annotations;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace AssetRipper.GUI.Components
{
	public abstract class UserControlWithPropChange : UserControl, INotifyPropertyChanged
	{
		public new event PropertyChangedEventHandler? PropertyChanged;

		[NotifyPropertyChangedInvocator]
		protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
		{
			PropertyChanged?.Invoke(this, new(propertyName));
		}
	}
}
```

`AssetRipperGUI/DummyAssetForLooseResourceFile.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Smart;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Project;
using AssetRipper.Yaml;
using System.IO;
using System.Threading.Tasks;

namespace AssetRipper.GUI
{
	public class DummyAssetForLooseResourceFile : UnityObjectBase, IDisposable, IHasNameString
	{
		private bool disposedValue;

		public ResourceFile AssociatedFile { get; }

		public string NameString
		{
			get => AssociatedFile.Name;
			set => throw new NotSupportedException();
		}

		private readonly SmartStream smartStream;

		public DummyAssetForLooseResourceFile(ResourceFile associatedFile)
		{
			AssociatedFile = associatedFile;
			smartStream = SmartStream.CreateTemp();
			AssociatedFile.Stream.CopyTo(smartStream);
		}

		public override YamlNode ExportYaml(IExportContainer container)
		{
			throw new NotSupportedException();
		}

		public void SaveToFile(string path)
		{
			using FileStream fileStream = System.IO.File.Create(path);
			smartStream.Position = 0;
			smartStream.CopyTo(fileStream);
		}

		public async Task SaveToFileAsync(string path)
		{
			FileStream fileStream = System.IO.File.Create(path);
			smartStream.Position = 0;
			await smartStream.CopyToAsync(fileStream);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (!disposedValue)
			{
				if (disposing)
				{
					smartStream?.Dispose();
				}

				AssociatedFile?.Dispose();
				disposedValue = true;
			}
		}

		public void Dispose()
		{
			// Do not change this code. Put cleanup code in 'Dispose(bool disposing)' method
			Dispose(disposing: true);
			GC.SuppressFinalize(this);
		}
	}
}
```

`AssetRipperGUI/Exceptions/GameNotFoundException.cs`:

```cs
namespace AssetRipper.GUI.Exceptions
{
	public class GameNotFoundException : Exception
	{

	}
}
```

`AssetRipperGUI/Extensions/UIExtentions.cs`:

```cs
using Avalonia.Threading;
using MessageBox.Avalonia;

namespace AssetRipper.GUI.Extensions
{
	public static class UIExtentions
	{
		public static void ShowPopup(this BaseViewModel _, string body, string title = "Message") => Dispatcher.UIThread.Post(() => ShowPopup(body, title));

		private static void ShowPopup(string body, string title)
		{
			MessageBoxManager.GetMessageBoxStandardWindow(title, body)
				.Show();
		}
	}
}
```

`AssetRipperGUI/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipperGUI/LocalizationManager.cs`:

```cs
using AssetRipper.Core.Logging;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text.Json;
using System.Text.RegularExpressions;

namespace AssetRipper.GUI
{
	public class LocalizationManager : BaseViewModel
	{
		private const string LocalizationFilePrefix = "AssetRipper.GUI.";
		private static readonly Regex SortOrderRegex = new("\\(Sort Order=([A-Z]+)\\)", RegexOptions.Compiled);

		// ReSharper disable once MemberInitializerValueIgnored
		private Dictionary<string, string> CurrentLocale = null!; //To suppress warning as it's initialized indirectly in constructor
		private Dictionary<string, string> FallbackLocale;
		private string? CurrentLang;
		public SupportedLanguage[] SupportedLanguages { get; private set; }

		public event Action OnLanguageChanged = () => { };

		public LocalizationManager()
		{

		}

		public void Init()
		{
			LoadLanguage("en_US");
			FallbackLocale = CurrentLocale;

			var supportedLanguageCodes = Assembly.GetExecutingAssembly()
				.GetManifestResourceNames()
				.Where(l => l.StartsWith(LocalizationFilePrefix))
				.Select(l => l[LocalizationFilePrefix.Length..^5])
				.ToArray();

			var supportedLanguageNames = supportedLanguageCodes.Select(code => new CultureInfo(code.Replace('_', '-'))).Select(ExtractCultureName).ToArray();

			List<SupportedLanguage> languages = new();
			for (int i = 0; i < supportedLanguageNames.Length; i++)
			{
				languages.Add(new(supportedLanguageNames[i], supportedLanguageCodes[i]));
			}

			SupportedLanguages = languages.ToArray();
		}

		private static string ExtractCultureName(CultureInfo culture)
		{
			return SortOrderRegex.Replace(culture.NativeName, match => $"({match.Groups[1].Value})");
		}

		[SuppressMessage("ReSharper", "NotResolvedInText")]
		public void LoadLanguage(string code)
		{
			CurrentLang = code;
			Logger.Info(LogCategory.System, $"Loading locale {code}.json");
			using var stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(LocalizationFilePrefix + code + ".json") ?? throw new Exception($"Could not load language file {code}.json");

			CurrentLocale = JsonSerializer.Deserialize<Dictionary<string, string>>(stream) ?? throw new Exception($"Could not parse language file {code}.json");

			OnPropertyChanged("Item");
			OnPropertyChanged("Item[]");
			OnLanguageChanged();
		}

		public string this[string key]
		{
			get
			{
				if (CurrentLocale.TryGetValue(key, out var ret) && !string.IsNullOrEmpty(ret))
				{
					return ret;
				}

				if (FallbackLocale.TryGetValue(key, out ret))
				{
					Logger.Verbose(LogCategory.System, $"Locale {CurrentLang} is missing a definition for {key}. Using fallback language (en_US)");
					return ret;
				}

				Logger.Warning(LogCategory.System, $"Locale {CurrentLang} is missing a definition for {key}, and it also could not be found in the fallback language (en_US)");
				return $"__{key}__?";
			}
		}

		public class SupportedLanguage : BaseViewModel
		{
			public string DisplayName { get; }
			public string LanguageCode { get; }

			public bool IsActive
			{
				get => MainWindow.Instance.LocalizationManager.CurrentLang == LanguageCode;
			}

			public SupportedLanguage(string displayName, string languageCode)
			{
				DisplayName = displayName;
				LanguageCode = languageCode;

				Logger.Verbose(LogCategory.System, $"Language {displayName} isActive {IsActive}");

				MainWindow.Instance.LocalizationManager.OnLanguageChanged += () => OnPropertyChanged(nameof(IsActive));
			}

			public void Apply()
			{
				MainWindow.Instance.LocalizationManager.LoadLanguage(LanguageCode);
			}

			public override string ToString() => DisplayName;
		}
	}
}

```

`AssetRipperGUI/LocalizeExtension.cs`:

```cs
using Avalonia.Data;
using Avalonia.Markup.Xaml;
using Avalonia.Markup.Xaml.MarkupExtensions;

namespace AssetRipper.GUI
{
	public class LocalizeExtension : MarkupExtension
	{
		public LocalizeExtension(string key)
		{
			this.Key = key;
		}

		public string Key { get; set; }

		public string? Context { get; set; }

		public override object ProvideValue(IServiceProvider serviceProvider)
		{
			var keyToUse = Key;
			if (!string.IsNullOrWhiteSpace(Context))
				keyToUse = $"{Context}/{Key}";

			var binding = new ReflectionBindingExtension($"[{keyToUse}]")
			{
				Mode = BindingMode.OneWay,
				Source = MainWindow.Instance.LocalizationManager,
			};

			return binding.ProvideValue(serviceProvider);
		}
	}
}
```

`AssetRipperGUI/Logging/RipperAvaloniaSink.cs`:

```cs
using AssetRipper.Core.Logging;
using Avalonia.Logging;
using Avalonia.Utilities;
using System.Text;
using Logger = AssetRipper.Core.Logging.Logger;

namespace AssetRipper.GUI.Logging
{
	public class RipperAvaloniaSink : ILogSink
	{
		public bool IsEnabled(LogEventLevel level, string area) => level switch
		{
			LogEventLevel.Warning => true,
			LogEventLevel.Error => true,
			LogEventLevel.Fatal => true,
			_ => false,
		};

		public void Log(LogEventLevel level, string area, object source, string messageTemplate)
		{
			if (IsEnabled(level, area))
				Logger.Verbose(LogCategory.Avalonia, Format<object, object, object>(area, messageTemplate, source));
		}

		public void Log<T0>(LogEventLevel level, string area, object source, string messageTemplate, T0 propertyValue0)
		{
			if (IsEnabled(level, area))
				Logger.Verbose(LogCategory.Avalonia, Format<T0, object, object>(area, messageTemplate, source, propertyValue0));
		}

		public void Log<T0, T1>(LogEventLevel level, string area, object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1)
		{
			if (IsEnabled(level, area))
				Logger.Verbose(LogCategory.Avalonia, Format<T0, T1, object>(area, messageTemplate, source, propertyValue0, propertyValue1));
		}

		public void Log<T0, T1, T2>(LogEventLevel level, string area, object source, string messageTemplate, T0 propertyValue0, T1 propertyValue1, T2 propertyValue2)
		{
			if (IsEnabled(level, area))
				Logger.Verbose(LogCategory.Avalonia, Format(area, messageTemplate, source, propertyValue0, propertyValue1, propertyValue2));
		}

		public void Log(LogEventLevel level, string area, object source, string messageTemplate, params object[] propertyValues)
		{
			if (IsEnabled(level, area))
				Logger.Verbose(LogCategory.Avalonia, Format(area, messageTemplate, source, propertyValues));
		}

		private static string Format<T0, T1, T2>(
			string area,
			string template,
			object source,
			T0? v0 = default,
			T1? v1 = default,
			T2? v2 = default)
		{
			var result = new StringBuilder(template.Length);
			var r = new CharacterReader(template.AsSpan());
			var i = 0;

			result.Append('[');
			result.Append(area);
			result.Append("] ");

			while (!r.End)
			{
				var c = r.Take();

				if (c != '{')
				{
					result.Append(c);
				}
				else
				{
					if (r.Peek != '{')
					{
						result.Append('\'');
						result.Append(i++ switch
						{
							0 => v0,
							1 => v1,
							2 => v2,
							_ => null
						});
						result.Append('\'');
						r.TakeUntil('}');
						r.Take();
					}
					else
					{
						result.Append('{');
						r.Take();
					}
				}
			}

			if (source is object)
			{
				result.Append(" (");
				result.Append(source.GetType().Name);
				result.Append(" #");
				result.Append(source.GetHashCode());
				result.Append(')');
			}

			return result.ToString();
		}

		private static string Format(
			string area,
			string template,
			object source,
			object[] v)
		{
			var result = new StringBuilder(template.Length);
			var r = new CharacterReader(template.AsSpan());
			var i = 0;

			result.Append('[');
			result.Append(area);
			result.Append(']');

			while (!r.End)
			{
				var c = r.Take();

				if (c != '{')
				{
					result.Append(c);
				}
				else
				{
					if (r.Peek != '{')
					{
						result.Append('\'');
						result.Append(i < v.Length ? v[i++] : null);
						result.Append('\'');
						r.TakeUntil('}');
						r.Take();
					}
					else
					{
						result.Append('{');
						r.Take();
					}
				}
			}

			if (source is object)
			{
				result.Append('(');
				result.Append(source.GetType().Name);
				result.Append(" #");
				result.Append(source.GetHashCode());
				result.Append(')');
			}

			return result.ToString();
		}
	}
}

```

`AssetRipperGUI/MainWindow.ViewModel.Configuration.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Library.Configuration;
using Avalonia.Data;

namespace AssetRipper.GUI
{
	public partial class MainWindowViewModel
	{
		public BundledAssetsExportMode BundledAssetsExportMode
		{
			get => _ripper.Settings.BundledAssetsExportMode;
			set
			{
				_ripper.Settings.BundledAssetsExportMode = value;
				OnPropertyChanged();
			}
		}

		public bool IgnoreStreamingAssets
		{
			get => _ripper.Settings.IgnoreStreamingAssets;
			set
			{
				_ripper.Settings.IgnoreStreamingAssets = value;
				OnPropertyChanged();
			}
		}

		public AudioExportFormat AudioExportFormat
		{
			get => _ripper.Settings.AudioExportFormat;
			set
			{
				_ripper.Settings.AudioExportFormat = value;
				OnPropertyChanged();
			}
		}

		public ImageExportFormat ImageExportFormat
		{
			get => _ripper.Settings.ImageExportFormat;
			set
			{
				_ripper.Settings.ImageExportFormat = value;
				OnPropertyChanged();
			}
		}

		public MeshExportFormat MeshExportFormat
		{
			get => _ripper.Settings.MeshExportFormat;
			set
			{
				_ripper.Settings.MeshExportFormat = value;
				OnPropertyChanged();
			}
		}

		public SpriteExportMode SpriteExportMode
		{
			get => _ripper.Settings.SpriteExportMode;
			set
			{
				_ripper.Settings.SpriteExportMode = value;
				OnPropertyChanged();
			}
		}

		public TerrainExportMode TerrainExportMode
		{
			get => _ripper.Settings.TerrainExportMode;
			set
			{
				_ripper.Settings.TerrainExportMode = value;
				OnPropertyChanged();
			}
		}

		public TextExportMode TextExportMode
		{
			get => _ripper.Settings.TextExportMode;
			set
			{
				_ripper.Settings.TextExportMode = value;
				OnPropertyChanged();
			}
		}

		public ShaderExportMode ShaderExportMode
		{
			get => _ripper.Settings.ShaderExportMode;
			set
			{
				_ripper.Settings.ShaderExportMode = value;
				OnPropertyChanged();
			}
		}

		public ScriptExportMode ScriptExportMode
		{
			get => _ripper.Settings.ScriptExportMode;
			set
			{
				_ripper.Settings.ScriptExportMode = value;
				OnPropertyChanged();
			}
		}

		public ScriptContentLevel ScriptContentLevel
		{
			get => _ripper.Settings.ScriptContentLevel;
			set
			{
				_ripper.Settings.ScriptContentLevel = value;
				OnPropertyChanged();
			}
		}

		public ScriptLanguageVersion ScriptLanguageVersion
		{
			get => _ripper.Settings.ScriptLanguageVersion;
			set
			{
				_ripper.Settings.ScriptLanguageVersion = value;
				OnPropertyChanged();
			}
		}

		public Binding MeshExportModeBinding { get; set; }
	}
}

```

`AssetRipperGUI/MainWindow.ViewModel.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.GUI.AssetInfo;
using AssetRipper.GUI.Exceptions;
using AssetRipper.GUI.Extensions;
using AssetRipper.GUI.Managers;
using AssetRipper.Library;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Threading;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Linq;

namespace AssetRipper.GUI
{
	public partial class MainWindowViewModel : BaseViewModel
	{

		//Exposed-to-ui properties
		private bool _hasFile;
		private bool _hasLoaded;
		private bool _isExporting;
		private string? _loadingText;
		private string? _unityVersionText;
		private string _logText = "";
		private string _exportingText = "";
		private SelectedAsset? _selectedAsset;

		public ObservableCollection<NewUiFileListItem> AssetFiles { get; } = new();

		//Not-exposed-to-UI properties
		private string? _lastExportPath;
		private readonly Ripper _ripper = new();
		private UIAssetContainer? _assetContainer;
		private string? _importingFrom;
		private bool _updatingLoadingText = false;

		public bool HasFile
		{
			get => _hasFile;
			set
			{
				_hasFile = value;
				OnPropertyChanged();
			}
		}

		public bool HasLoaded
		{
			get => _hasLoaded;
			set
			{
				_hasLoaded = value;
				OnPropertyChanged();
			}
		}

		public bool IsExporting
		{
			get => _isExporting;
			set
			{
				_isExporting = value;
				OnPropertyChanged();
			}
		}

		public string? LoadingText
		{
			get => _loadingText;
			set
			{
				_loadingText = value;
				OnPropertyChanged();
			}
		}

		public string? UnityVersion
		{
			get => _unityVersionText;
			set
			{
				_unityVersionText = value?.Split("f")?[0];
				OnPropertyChanged(nameof(UnityVersionText));
			}
		}
		public string? UnityVersionText
		{
			get
			{
				string? version = UnityVersion;

				if (version == null)
				{
					return null;
				}

				return "Unity " + version;
			}
		}

		public string LogText
		{
			get => _logText;
			set
			{
				_logText = value;
				OnPropertyChanged();
			}
		}

		public string ExportingText
		{
			get => _exportingText;
			set
			{
				_exportingText = value;
				OnPropertyChanged();
			}
		}

		public SelectedAsset? SelectedAsset
		{
			get => _selectedAsset;
			set
			{
				_selectedAsset = value;
				OnPropertyChanged();
			}
		}

		public LocalizationManager LocalizationManager => MainWindow.Instance.LocalizationManager;

		public MainWindowViewModel()
		{
			Logger.OnStatusChanged += OnImportStatusUpdated;

			OnPropertyChanged(nameof(AudioExportFormat));
		}

		private void UpdateGamePathInUi(string path)
		{
			LoadingText = string.Format(MainWindow.Instance.LocalizationManager["loading_game_content_from"], _importingFrom, "");
			_importingFrom = path;
		}

		private void OnImportStatusUpdated(string statusKey, object? context)
		{
			// Logger.Log(LogType.Info, LogCategory.System, $"{newStatus} at {DateTime.Now:hh:mm:ss.fff}");

			if (_updatingLoadingText)
				return;

			var newStatus = context == null ? MainWindow.Instance.LocalizationManager[statusKey] : string.Format(MainWindow.Instance.LocalizationManager[statusKey], context);

			_updatingLoadingText = true;
			LoadingText = string.Format(MainWindow.Instance.LocalizationManager["loading_game_content_from"], _importingFrom, newStatus);
			_updatingLoadingText = false;
		}

		public void OnFileDropped(DragEventArgs e)
		{
			if (IsExporting || (HasFile && !HasLoaded))
				return;

			string[]? filesDropped = e.Data.GetFileNames()?.ToArray();

			DoLoad(filesDropped);
		}

		private void DoLoad(string[]? filesDropped)
		{
			if (filesDropped == null || filesDropped.Length < 1)
			{
				return;
			}

			_ripper.ResetData();
			SelectedAsset?.Dispose();
			SelectedAsset = null;
			_assetContainer = null;

			string gamePath = filesDropped[0];

			HasFile = true;
			HasLoaded = false;
			Dispatcher.UIThread.Post(() => AssetFiles.Clear(), DispatcherPriority.Send);

			_ripper.Settings.LogConfigurationValues();

			UpdateGamePathInUi(gamePath);

			UIImportManager.ImportFromPath(_ripper, filesDropped, gameStructure =>
			{
				HasLoaded = true;
				UnityVersion = _ripper.GameStructure.FileCollection.GameFiles.Values.Max(t => t.Version).ToString();
				_assetContainer = new UIAssetContainer(_ripper);

				Dispatcher.UIThread.Post(() =>
				{
					List<NewUiFileListItem> items = UIFileListing.GetItemsFromStructure(gameStructure);
					items.ForEach(AssetFiles.Add);
				}, DispatcherPriority.Send);
			}, error =>
			{
				HasFile = false;
				HasLoaded = false;

				Logger.Error(error);

				if (error is GameNotFoundException)
				{
					this.ShowPopup(MainWindow.Instance.LocalizationManager["no_game_files_found"], MainWindow.Instance.LocalizationManager["error"]);
				}
				else
				{
					//this.ShowPopup(string.Format(MainWindow.Instance.LocalizationManager["error_importing_with_reason"], error.Message), MainWindow.Instance.LocalizationManager["error"]);
					this.ShowPopup(MainWindow.Instance.LocalizationManager["check_log_for_more_details"], MainWindow.Instance.LocalizationManager["error"]);
				}
			});
		}

		public async void ExportAll()
		{
			if (_ripper.GameStructure == null)
			{
				return;
			}

			OpenFolderDialog openFolderDialog = new();

			string? chosenFolder = await openFolderDialog.ShowAsync(MainWindow.Instance);

			if (string.IsNullOrEmpty(chosenFolder))
			{
				return;
			}

			IsExporting = true;
			ExportingText = "Clearing out existing files...";

			string exportPath = Path.Combine(chosenFolder, _ripper.GameStructure.Name ?? ("AssetRipperExport" + DateTime.Now.Ticks));
			_lastExportPath = exportPath;

			Logger.Info(LogCategory.General, $"About to begin export to {exportPath}");

			Logger.Info(LogCategory.General, $"Removing any files from a previous export...");

			await UIExportManager.PrepareExportDirectory(exportPath);
			UIExportManager.ConfigureExportEvents(_ripper.GameStructure.Exporter, this);

			UIExportManager.Export(_ripper, exportPath, () =>
			{
				IsExporting = false;
				this.ShowPopup(MainWindow.Instance.LocalizationManager["export_complete"], MainWindow.Instance.LocalizationManager["success"]);
				Logger.Info(LogCategory.General, "Export Complete!");
			}, error =>
			{
				IsExporting = false;
				Logger.Error(error);
				//this.ShowPopup(string.Format(MainWindow.Instance.LocalizationManager["error_exporting_with_reason"], error.Message), MainWindow.Instance.LocalizationManager["error"]);
				this.ShowPopup(MainWindow.Instance.LocalizationManager["check_log_for_more_details"], MainWindow.Instance.LocalizationManager["error"]);
			});
		}

		public async void ExportSelectedAssetToProject()
		{
			if (_ripper.GameStructure == null || SelectedAsset == null)
			{
				return;
			}

			if (SelectedAsset.Asset is DummyAssetForLooseResourceFile da)
			{
				SaveFileDialog saveFileDialog = new();
				string fileName = Path.GetFileName(da.AssociatedFile.Name);
				saveFileDialog.DefaultExtension = Path.GetExtension(fileName);
				saveFileDialog.InitialFileName = fileName;

				string? saveLoc = await saveFileDialog.ShowAsync(MainWindow.Instance);

				if (saveLoc == null)
					return;

				await da.SaveToFileAsync(saveLoc);
				
				Logger.Info(LogCategory.ExportedFile, $"Loose file saved at: {saveLoc}");

				return;
			}

			OpenFolderDialog openFolderDialog = new();

			string? chosenFolder = await openFolderDialog.ShowAsync(MainWindow.Instance);

			if (string.IsNullOrEmpty(chosenFolder))
			{
				return;
			}

			IsExporting = true;
			ExportingText = MainWindow.Instance.LocalizationManager["export_deleting_old_files"];

			string exportPath = Path.Combine(chosenFolder, _ripper.GameStructure.Name ?? ("AssetRipperExport" + DateTime.Now.Ticks));
			_lastExportPath = exportPath;

			Logger.Info(LogCategory.General, $"About to begin export to {exportPath}");

			Logger.Info(LogCategory.General, $"Removing any files from a previous export...");

			await UIExportManager.PrepareExportDirectory(exportPath);
			UIExportManager.ConfigureExportEvents(_ripper.GameStructure.Exporter, this);

			UIExportManager.Export(_ripper, exportPath, SelectedAsset.Asset, () =>
			{
				IsExporting = false;
				this.ShowPopup(MainWindow.Instance.LocalizationManager["export_complete"], MainWindow.Instance.LocalizationManager["success"]);
				Logger.Info(LogCategory.General, "Export Complete!");
			}, error =>
			{
				IsExporting = false;
				Logger.Error(error);
				this.ShowPopup(string.Format(MainWindow.Instance.LocalizationManager["error_exporting_with_reason"], error.Message), MainWindow.Instance.LocalizationManager["error"]);
			});
		}

		public async void ExportSelectedAssetTypeToProject()
		{
			if (_ripper.GameStructure == null || SelectedAsset == null || SelectedAsset.Asset is DummyAssetForLooseResourceFile)
			{
				return;
			}

			OpenFolderDialog openFolderDialog = new();

			string? chosenFolder = await openFolderDialog.ShowAsync(MainWindow.Instance);

			if (string.IsNullOrEmpty(chosenFolder))
			{
				return;
			}

			IsExporting = true;
			ExportingText = MainWindow.Instance.LocalizationManager["export_deleting_old_files"];

			string exportPath = Path.Combine(chosenFolder, _ripper.GameStructure.Name ?? ("AssetRipperExport" + DateTime.Now.Ticks));
			_lastExportPath = exportPath;

			Logger.Info(LogCategory.General, $"About to begin export to {exportPath}");

			Logger.Info(LogCategory.General, $"Removing any files from a previous export...");

			await UIExportManager.PrepareExportDirectory(exportPath);
			UIExportManager.ConfigureExportEvents(_ripper.GameStructure.Exporter, this);

			UIExportManager.Export(_ripper, exportPath, SelectedAsset.Asset.GetType(), () =>
			{
				IsExporting = false;
				this.ShowPopup(MainWindow.Instance.LocalizationManager["export_complete"], MainWindow.Instance.LocalizationManager["success"]);
				Logger.Info(LogCategory.General, "Export Complete!");
			}, error =>
			{
				IsExporting = false;
				Logger.Error(error);
				this.ShowPopup(string.Format(MainWindow.Instance.LocalizationManager["error_exporting_with_reason"], error.Message), MainWindow.Instance.LocalizationManager["error"]);
			});
		}

		// Called from UI
		public void OpenUnityDownloadPage()
		{
			string url = "https://unity3d.com/unity/whats-new/" + UnityVersion;
			if (OperatingSystem.IsWindows())
			{
				Process.Start(new ProcessStartInfo(url) { UseShellExecute = true });
			}
			else if (OperatingSystem.IsLinux())
			{
				Process.Start("xdg-open", url);
			}
			else if (OperatingSystem.IsMacOS())
			{
				Process.Start("open", url);
			}
		}

		//Called from UI
		public async void ShowOpenFileDialog()
		{
			OpenFileDialog openFileDialog = new();
			openFileDialog.AllowMultiple = true;
			string[]? result = await openFileDialog.ShowAsync(MainWindow.Instance);

			if (result == null)
				return;

			DoLoad(result);
		}

		//Called from UI
		public async void ShowOpenFolderDialog()
		{
			OpenFolderDialog openFolderDialog = new();
			string? result = await openFolderDialog.ShowAsync(MainWindow.Instance);

			if (string.IsNullOrEmpty(result))
				return;

			DoLoad(new[] { result });
		}

		//Called from UI
		public void Reset()
		{
			if (!HasFile)
				return;

			_ripper.ResetData();
			AssetFiles.Clear();
			_assetContainer = null;
			HasFile = false;
			HasLoaded = false;
			IsExporting = false;

			SelectedAsset?.Dispose();
			SelectedAsset = null;

			LogText = "";
			Logger.Log(LogType.Info, LogCategory.General, "UI Reset");
		}

		//Called from UI indirectly
		public void OnAssetSelected(NewUiFileListItem selectedItem, IUnityObjectBase selectedAsset)
		{
			_assetContainer.LastAccessedAsset = selectedAsset;

			SelectedAsset?.Dispose();
			SelectedAsset = new(selectedAsset, _assetContainer);
		}
	}
}

```

`AssetRipperGUI/MainWindow.axaml`:

```axaml
<Window xmlns="https://github.com/avaloniaui"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:ar="using:AssetRipper.GUI"
        xmlns:cc="using:AssetRipper.GUI.Components"
        xmlns:i18n="clr-namespace:AssetRipper.GUI" 
        mc:Ignorable="d" d:DesignWidth="800" d:DesignHeight="450"
        x:Class="AssetRipper.GUI.MainWindow"
        Icon="/Resources/GUI_Icon.ico"
        Title="Asset Ripper GUI">
    <DragDrop.AllowDrop>
        <MultiBinding Converter="{x:Static BoolConverters.And}">
            <Binding Path="!IsExporting" />
            <MultiBinding Converter="{x:Static BoolConverters.Or}">
                <Binding Path="!HasFile" />
                <Binding Path="HasLoaded" />
            </MultiBinding>
        </MultiBinding>
    </DragDrop.AllowDrop>
    <Design.DataContext>
        <ar:MainWindowViewModel />
    </Design.DataContext>
    <Grid RowDefinitions="20,*">

        <!--Top Menu-->
        <Menu Grid.Row="0">
            <!--File Menu-->
            <MenuItem Header="{i18n:Localize menu_file}">

                <!--File->Open File-->
                <MenuItem Header="{i18n:Localize menu_file_open_file}" Command="{Binding ShowOpenFileDialog}">
                    <MenuItem.IsEnabled>
                        <MultiBinding Converter="{x:Static BoolConverters.And}">
                            <Binding Path="!IsExporting" />
                            <MultiBinding Converter="{x:Static BoolConverters.Or}">
                                <Binding Path="!HasFile" />
                                <Binding Path="HasLoaded" />
                            </MultiBinding>
                        </MultiBinding>
                    </MenuItem.IsEnabled>
                </MenuItem>

                <!--File->Open Folder-->
                <MenuItem Header="{i18n:Localize menu_file_open_folder}" Command="{Binding ShowOpenFolderDialog}">
                    <MenuItem.IsEnabled>
                        <MultiBinding Converter="{x:Static BoolConverters.And}">
                            <Binding Path="!IsExporting" />
                            <MultiBinding Converter="{x:Static BoolConverters.Or}">
                                <Binding Path="!HasFile" />
                                <Binding Path="HasLoaded" />
                            </MultiBinding>
                        </MultiBinding>
                    </MenuItem.IsEnabled>
                </MenuItem>

                <MenuItem Header="{i18n:Localize menu_file_reset}" Command="{Binding Reset}">
                    <MenuItem.IsEnabled>
                        <MultiBinding Converter="{x:Static BoolConverters.And}">
                            <Binding Path="HasFile" />
                            <Binding Path="HasLoaded" />
                            <Binding Path="!IsExporting" />
                        </MultiBinding>
                    </MenuItem.IsEnabled>
                </MenuItem>


                <!--File->Exit-->
                <MenuItem Header="{i18n:Localize menu_file_exit}" Click="ExitClicked" />
            </MenuItem>

            <!--Export Menu-->
            <MenuItem Header="{i18n:Localize menu_export}" IsEnabled="{Binding !IsExporting}">
                <MenuItem Header="{i18n:Localize menu_export_all}" Click="ExportAllClicked" />
                <MenuItem Header="{i18n:Localize menu_export_selected}" Click="ExportSelectedAssetToProjectClicked" />
                <MenuItem Header="{i18n:Localize menu_export_selected_type}" Click="ExportSelectedAssetTypeToProjectClicked" />
            </MenuItem>
            
            <!--Language Menu-->
            <MenuItem Header="{i18n:Localize menu_language}" Items="{Binding LocalizationManager.SupportedLanguages}" Click="LanguageMenuItemClicked">
                <MenuItem.ItemTemplate>
                    <DataTemplate>
                        <MenuItem Command="{Binding Apply}" CommandParameter="{Binding}" Header="{Binding DisplayName}">
                            <MenuItem.IsEnabled>
                                <Binding Converter="{x:Static BoolConverters.Not}" Path="IsActive"></Binding>
                            </MenuItem.IsEnabled>
                        </MenuItem>
                    </DataTemplate>
                </MenuItem.ItemTemplate>
            </MenuItem>

            <!-- Unity Version Menu -->
            <MenuItem Header="{Binding UnityVersionText}" IsVisible="{Binding HasLoaded}">
                <!--Unity {Version}->Download-->
                <MenuItem Header="Download" Command="{Binding OpenUnityDownloadPage}" />
            </MenuItem>
        </Menu>

        <!--Introduction Screens-->

        <!--Drag-drop prompt-->
        <Grid Grid.Row="1"
              IsVisible="{Binding !HasFile}"
              RowDefinitions="50, 50, 650, *">

            <TextBlock Text="{i18n:Localize welcome_title}"
                       FontSize="24"
                       TextAlignment="Center"
                       VerticalAlignment="Center" />
            
            <TextBlock Grid.Row="1" Text="{i18n:Localize config_options}"
                       FontSize="20"
                       TextAlignment="Center"
                       VerticalAlignment="Center" />

            <Grid Grid.Row="2" RowDefinitions="50, 140, 140, 140, 140" ColumnDefinitions="*, 400, 400, 400, *" Margin="100, 0, 100, 0">
                <WrapPanel Grid.Column="2" Grid.Row="0" HorizontalAlignment="Left" Margin="20, 0">
                    <CheckBox IsChecked="{Binding IgnoreStreamingAssets, Mode=TwoWay}" />
                    <TextBlock Text="{i18n:Localize skip_streaming_assets}" Margin="0, 7, 0, 10" />
                </WrapPanel>
                <cc:MeshExportConfigDropdown 
                    Grid.Column="1" 
                    Grid.Row="1"
                    OptionTitle="{i18n:Localize mesh_export_title}"
                    SelectedValue="{Binding MeshExportFormat, Mode=TwoWay}"
                    Margin="0, 0, 10, 0">
                </cc:MeshExportConfigDropdown>
                <cc:AudioExportConfigDropdown 
                    Grid.Column="2" 
                    Grid.Row="1"
                    OptionTitle="{i18n:Localize audio_export_title}"
                    SelectedValue="{Binding AudioExportFormat, Mode=TwoWay}"
                    Margin="10, 0, 10, 0">
                </cc:AudioExportConfigDropdown>
				<cc:ShaderExportConfigDropdown
                    Grid.Column="3"
                    Grid.Row="1"
                    OptionTitle="{i18n:Localize shader_asset_export_title}"
                    SelectedValue="{Binding ShaderExportMode, Mode=TwoWay}"
                    Margin="10, 0, 0, 0">
				</cc:ShaderExportConfigDropdown>
                <cc:ImageExportConfigDropdown 
                    Grid.Column="1" 
                    Grid.Row="2"
                    OptionTitle="{i18n:Localize image_export_title}"
                    SelectedValue="{Binding ImageExportFormat, Mode=TwoWay}"
                    Margin="0, 0, 10, 0">
                </cc:ImageExportConfigDropdown>
                <cc:SpriteExportConfigDropdown 
                    Grid.Column="2" 
                    Grid.Row="2"
                    OptionTitle="{i18n:Localize sprite_export_title}"
                    SelectedValue="{Binding SpriteExportMode, Mode=TwoWay}"
                    Margin="10, 0, 10, 0">
                </cc:SpriteExportConfigDropdown>
				<cc:BundledAssetsExportConfigDropdown
                    Grid.Column="3"
                    Grid.Row="2"
                    OptionTitle="{i18n:Localize bundled_assets_export_title}"
                    SelectedValue="{Binding BundledAssetsExportMode, Mode=TwoWay}"
                    Margin="10, 0, 0, 0">
				</cc:BundledAssetsExportConfigDropdown>
                <cc:TerrainExportConfigDropdown 
                    Grid.Column="1" 
                    Grid.Row="3"
                    OptionTitle="{i18n:Localize terrain_export_title}"
                    SelectedValue="{Binding TerrainExportMode, Mode=TwoWay}"
                    Margin="0, 0, 10, 0">
                </cc:TerrainExportConfigDropdown>
                <cc:TextExportConfigDropdown 
                    Grid.Column="2" 
                    Grid.Row="3"
                    OptionTitle="{i18n:Localize text_asset_export_title}"
                    SelectedValue="{Binding TextExportMode, Mode=TwoWay}"
                    Margin="10, 0, 10, 0">
                </cc:TextExportConfigDropdown>
				<cc:ScriptExportModeConfigDropdown
                    Grid.Column="1"
                    Grid.Row="4"
                    OptionTitle="{i18n:Localize script_export_title}"
                    SelectedValue="{Binding ScriptExportMode, Mode=TwoWay}"
                    Margin="0, 0, 10, 0">
				</cc:ScriptExportModeConfigDropdown>
                <cc:ScriptContentLevelConfigDropdown
                    Grid.Column="2"
                    Grid.Row="4"
                    OptionTitle="{i18n:Localize script_content_level_title}"
                    SelectedValue="{Binding ScriptContentLevel, Mode=TwoWay}"
                    Margin="10, 0, 10, 0">
                </cc:ScriptContentLevelConfigDropdown>
                <cc:ScriptLanguageVersionConfigDropdown
                    Grid.Column="3"
                    Grid.Row="4"
                    OptionTitle="{i18n:Localize script_language_version_title}"
                    SelectedValue="{Binding ScriptLanguageVersion, Mode=TwoWay}"
                    Margin="10, 0, 0, 0">
                </cc:ScriptLanguageVersionConfigDropdown>
            
		</Grid>

            <TextBlock Grid.Row="3"
                       Text="{i18n:Localize config_screen_drag_drop_prompt}"
                       TextAlignment="Center" 
                       VerticalAlignment="Bottom"
                       Margin="0, 0, 0, 50"/>
        </Grid>

        <!--Loading prompt-->
        <TextBlock Grid.Row="1" Text="{Binding LoadingText}"
                   TextAlignment="Center"
                   VerticalAlignment="Center">
            <TextBlock.IsVisible>
                <MultiBinding Converter="{x:Static BoolConverters.And}">
                    <Binding Path="HasFile" />
                    <Binding Path="!HasLoaded" />
                </MultiBinding>
            </TextBlock.IsVisible>
        </TextBlock>

        <!--Main content-->
        <Grid Grid.Row="1" IsVisible="{Binding HasLoaded}">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="500" MinWidth="300" />
                <ColumnDefinition Width="Auto" />
                <ColumnDefinition Width="*" MinWidth="800" />
            </Grid.ColumnDefinitions>


            <!--File browser-->
            <TreeView Grid.Column="0" Items="{Binding AssetFiles}"
                      SelectionMode="Single"
                      SelectionChanged="OnAssetSelected">
                <TreeView.ItemTemplate>
                    <TreeDataTemplate ItemsSource="{Binding SubItems}">
                        <TextBlock Text="{Binding DisplayAs}" />
                    </TreeDataTemplate>
                </TreeView.ItemTemplate>
            </TreeView>

            <!--Splitter-->
            <GridSplitter Grid.Column="1"
                          ResizeDirection="Columns"
                          Background="#ccc"
                          Width="2" />

            <!--Right half of main content-->
            <Grid Grid.Column="2" RowDefinitions="*">
                <Grid Grid.Row="0">
                    <!--File content-->

                    <!--Placeholder for if no asset selected-->
                    <TextBlock Text="{i18n:Localize select_asset_to_view_info}" TextAlignment="Center"
                               VerticalAlignment="Center" FontSize="18">
                        <TextBlock.IsVisible>
                            <MultiBinding Converter="{x:Static BoolConverters.And}">
                                <Binding Path="!IsExporting" />
                                <Binding Path="HasFile" />
                                <Binding Path="HasLoaded" />
                                <Binding Path="SelectedAsset" Converter="{x:Static ObjectConverters.IsNull}" />
                            </MultiBinding>
                        </TextBlock.IsVisible>
                    </TextBlock>

                    <!--Tab list for when an asset is selected-->
                    <TabControl>
                        <TabControl.IsVisible>
                            <MultiBinding Converter="{x:Static BoolConverters.And}">
                                <Binding Path="!IsExporting" />
                                <Binding Path="HasFile" />
                                <Binding Path="HasLoaded" />
                                <Binding Path="SelectedAsset" Converter="{x:Static ObjectConverters.IsNotNull}" />
                            </MultiBinding>
                        </TabControl.IsVisible>

                        <!--Basic Info Tab-->
                        <TabItem Header="{i18n:Localize asset_tab_basic}">
                            <TextBox Text="{Binding SelectedAsset.BasicInformation, FallbackValue='No Asset Selected'}" />
                        </TabItem>

                        <!--Text Tab-->
                        <TabItem Header="{i18n:Localize asset_tab_text}"
                                 IsVisible="{Binding SelectedAsset.HasTextData, FallbackValue=False}">
                            <TextBox IsReadOnly="True"
                                     Text="{Binding SelectedAsset.TextAssetData, FallbackValue='No text asset found'}" />
                        </TabItem>

                        <!--Image Tab-->
                        <TabItem Header="{i18n:Localize asset_tab_image}" IsVisible="{Binding SelectedAsset.HasImageData, FallbackValue=False}">
                            <Image Source="{Binding SelectedAsset.ImageData, FallbackValue=null}"
                                   HorizontalAlignment="Center"
                                   VerticalAlignment="Center" />
                        </TabItem>

                        <!--Audio Tab-->
                        <TabItem Header="{i18n:Localize asset_tab_audio}"
                                 IsVisible="{Binding SelectedAsset.HasAudioData, FallbackValue=False}">

                            <Grid RowDefinitions="*, 40, 40, *">

                                <Button Grid.Row="1" Command="{Binding SelectedAsset.TogglePause, FallbackValue=null}"
                                        IsEnabled="True" HorizontalAlignment="Center">
                                    <Panel>
                                        <TextBlock IsVisible="{Binding SelectedAsset.IsPaused}" Text="{i18n:Localize asset_tab_audio_play}"></TextBlock>
                                        <TextBlock IsVisible="{Binding !SelectedAsset.IsPaused}" Text="{i18n:Localize asset_tab_audio_pause}"></TextBlock>
                                    </Panel>
                                </Button>
                                <TextBlock Grid.Row="2" Text="{Binding SelectedAsset.PositionString}"
                                           VerticalAlignment="Center" TextAlignment="Center" />
                            </Grid>
                        </TabItem>

                        <!--Yaml Tab-->
                        <TabItem Header="{i18n:Localize asset_tab_yaml}"
                                 IsVisible="{Binding SelectedAsset.YamlTreeIsSupported, FallbackValue=False}">
                            <TreeView Items="{Binding SelectedAsset.YamlTree, FallbackValue=[]}">
                                <TreeView.ItemTemplate>
                                    <TreeDataTemplate ItemsSource="{Binding Children}">
                                        <TextBlock Text="{Binding DisplayName}" />
                                    </TreeDataTemplate>
                                </TreeView.ItemTemplate>
                            </TreeView>
                        </TabItem>
                    </TabControl>

                    <!--Export Progress-->
                    <TextBlock FontSize="18" Text="{Binding ExportingText}" TextAlignment="Center"
                               VerticalAlignment="Center" IsVisible="{Binding IsExporting}" />
                </Grid>
            </Grid>
        </Grid>
    </Grid>
</Window>
```

`AssetRipperGUI/MainWindow.axaml.cs`:

```cs
using AssetRipper.Core.Logging;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Markup.Xaml;
using System.Linq;
#if DEBUG
using Avalonia;
#endif

namespace AssetRipper.GUI
{
	public partial class MainWindow : Window
	{
		public static MainWindow Instance;

		private MainWindowViewModel VM;
		public readonly LocalizationManager LocalizationManager = new();

		public MainWindow()
		{
			Instance = this;
			DataContext = VM = new();

			LocalizationManager.Init();

			Logger.Verbose(LogCategory.System, $"Available languages: {string.Join(", ", LocalizationManager.SupportedLanguages.Select(l => l.LanguageCode))}");

			InitializeComponent();
#if DEBUG
            this.AttachDevTools();
#endif

			AddHandler(DragDrop.DropEvent, (sender, args) => VM.OnFileDropped(args));
		}

		protected override void OnDataContextChanged(EventArgs e)
		{
			base.OnDataContextChanged(e);

			VM.HasFile = false;
			VM.HasLoaded = false;
		}

		private void InitializeComponent()
		{
			AvaloniaXamlLoader.Load(this);
		}

		//Called from UI
		private void ExitClicked(object? sender, RoutedEventArgs e) => Close();

		//Called from UI
		private void ExportAllClicked(object? sender, RoutedEventArgs e) => VM.ExportAll();

		//Called from UI
		private void ExportSelectedAssetToProjectClicked(object? sender, RoutedEventArgs e) => VM.ExportSelectedAssetToProject();

		//Called from UI
		private void ExportSelectedAssetTypeToProjectClicked(object? sender, RoutedEventArgs e) => VM.ExportSelectedAssetTypeToProject();

		private void OnAssetSelected(object? sender, SelectionChangedEventArgs e)
		{
			NewUiFileListItem selectedItem = (NewUiFileListItem)e.AddedItems[0]!;
			if (selectedItem.AsObjectAsset == null)
			{
				//Ignore non-asset files
				return;
			}

			VM.OnAssetSelected(selectedItem, selectedItem.AsObjectAsset);
		}

		private void LanguageMenuItemClicked(object? sender, RoutedEventArgs e)
		{
			if (sender is not MenuItem { SelectedItem: LocalizationManager.SupportedLanguage language })
				return;

			Logger.Info(LogCategory.System, $"User selected language {language}");

			language.Apply();
		}
	}
}

```

`AssetRipperGUI/Managers/UIExportManager.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Project;
using AssetRipper.GUI.Utils;
using AssetRipper.Library;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using System.IO;
using System.Threading;
using System.Threading.Tasks;

namespace AssetRipper.GUI.Managers
{
	public static class UIExportManager
	{
		public static async Task PrepareExportDirectory(string path)
		{
			string directory = Directory.GetCurrentDirectory();
			if (!PermissionValidator.CheckAccess(directory))
			{
				PermissionValidator.RestartAsAdministrator();
			}

			if (Directory.Exists(path))
			{
				await Task.Factory.StartNew(s_path => Directory.Delete((string)s_path, true), path);
			}
		}

		public static void Export(Ripper ripper, string toRoot, Action onSuccess, Action<Exception> onError) => new Thread(() => ExportInternal(ripper, toRoot, onSuccess, onError))
		{
			Name = "Background Game Export Thread",
			IsBackground = true
		}.Start();

		public static void Export(Ripper ripper, string toRoot, IUnityObjectBase asset, Action onSuccess, Action<Exception> onError) => new Thread(() => ExportInternal(ripper, toRoot, asset, onSuccess, onError))
		{
			Name = "Background Game Export Thread",
			IsBackground = true
		}.Start();

		public static void Export(Ripper ripper, string toRoot, Type assetType, Action onSuccess, Action<Exception> onError) => new Thread(() => ExportInternal(ripper, toRoot, assetType, onSuccess, onError))
		{
			Name = "Background Game Export Thread",
			IsBackground = true
		}.Start();

		private static void ExportInternal(Ripper ripper, string toRoot, Action onSuccess, Action<Exception> onError)
		{
			try
			{
				ripper.ExportProject(toRoot);
			}
			catch (Exception ex)
			{
				onError(ex);
				return;
			}

			onSuccess();
		}

		private static void ExportInternal(Ripper ripper, string toRoot, IUnityObjectBase asset, Action onSuccess, Action<Exception> onError)
		{
			try
			{
				ripper.ExportProject(toRoot, asset);
			}
			catch (Exception ex)
			{
				onError(ex);
				return;
			}

			onSuccess();
		}

		private static void ExportInternal(Ripper ripper, string toRoot, Type assetType, Action onSuccess, Action<Exception> onError)
		{
			try
			{
				if (assetType.IsAssignableTo(typeof(ISprite))) // Sprite wont be exported as it's a form of Texture2D
					assetType = typeof(ITexture2D);

				ripper.ExportProject(toRoot, assetType);
			}
			catch (Exception ex)
			{
				onError(ex);
				return;
			}

			onSuccess();
		}

		public static void ConfigureExportEvents(ProjectExporter exporter, MainWindowViewModel vm)
		{
			exporter.EventExportPreparationStarted += () =>
			{
				vm.ExportingText = MainWindow.Instance.LocalizationManager["export_preparing"];
				Logger.Info(LogCategory.Export, "Preparing for export...");
			};

			exporter.EventExportPreparationFinished += () =>
			{
				vm.ExportingText = MainWindow.Instance.LocalizationManager["export_in_progress_no_file_count_yet"];
				Logger.Info(LogCategory.Export, "Preparation complete. Starting to export now...");
			};

			exporter.EventExportProgressUpdated += (index, count) =>
			{
				double progress = (double)index / count * 100.0;
				vm.ExportingText = string.Format(MainWindow.Instance.LocalizationManager["export_in_progress"], progress.ToString("f0"), index, count);
			};
		}
	}
}

```

`AssetRipperGUI/Managers/UIImportManager.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.GUI.Exceptions;
using AssetRipper.Library;
using System.Linq;
using System.Threading;

namespace AssetRipper.GUI.Managers
{
	public static class UIImportManager
	{
		public static void ImportFromPath(Ripper ripper, string[] paths, Action<GameStructure> onComplete, Action<Exception> onError) => new Thread(() => ImportFromPathInternal(ripper, paths, onComplete, onError))
		{
			Name = "Background Game Load Thread",
			IsBackground = true,
		}.Start();

		private static void ImportFromPathInternal(Ripper ripper, string[] paths, Action<GameStructure> onComplete, Action<Exception> onError)
		{
			try
			{
				GameStructure gameStructure = ripper.Load(paths);

				if (!gameStructure.IsValid)
				{
					onError(new GameNotFoundException());
					return;
				}

				gameStructure.CheckVersionsAreAllTheSame();
				onComplete(gameStructure);
			}
			catch (Exception e)
			{
				onError(e);
			}
		}

		private static void CheckVersionsAreAllTheSame(this GameStructure structure)
		{
			UnityVersion[] versions = structure.FileCollection
				.GameFiles
				.Values
				.Select(t => t.Version)
				.Distinct()
				.ToArray();

			if (versions.Length <= 1)
			{
				return;
			}

			Logger.Log(LogType.Warning, LogCategory.Import, $"Asset collection has versions probably incompatible with each other. Here they are:");
			foreach (UnityVersion version in versions)
			{
				Logger.Log(LogType.Warning, LogCategory.Import, version.ToString());
			}
		}
	}
}
```

`AssetRipperGUI/Program.cs`:

```cs
using AssetRipper.Core.Logging;
using Avalonia;

namespace AssetRipper.GUI
{
	class Program
	{
		[STAThread]
		public static void Main(string[] args)
		{
			Logger.Add(new FileLogger());
			Logger.Add(new ConsoleLogger());
			Logger.LogSystemInformation("AssetRipper GUI Version");

			// Initialization code. Don't use any Avalonia, third-party APIs or any
			// SynchronizationContext-reliant code before AppMain is called: things aren't initialized
			// yet and stuff might break.
			BuildAvaloniaApp().Start(App.AppMain, args);
		}

		// Avalonia configuration, don't remove; also used by visual designer.
		public static AppBuilder BuildAvaloniaApp()
			=> AppBuilder.Configure<App>()
				.UsePlatformDetect()
				.LogToTrace();
	}
}

```

`AssetRipperGUI/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle(AssetRipper.Core.BuildInfo.GUIName)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(AssetRipper.Core.BuildInfo.Author)]
[assembly: AssemblyProduct(AssetRipper.Core.BuildInfo.GUIName)]
[assembly: AssemblyCopyright(AssetRipper.Core.BuildInfo.CopyRight)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: AssemblyVersion(AssetRipper.Core.BuildInfo.Version)]
[assembly: AssemblyFileVersion(AssetRipper.Core.BuildInfo.Version)]

```

`AssetRipperGUI/Properties/PublishProfiles/linux_gui.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseLinux</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipper_linux64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>linux-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperGUI/Properties/PublishProfiles/mac_gui.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseMac</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipper_mac64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>osx-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperGUI/Properties/PublishProfiles/windows_gui.pubxml`:

```pubxml
<?xml version="1.0" encoding="utf-8"?>
<!--
https://go.microsoft.com/fwlink/?LinkID=208121. 
-->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration>ReleaseWindows</Configuration>
    <Platform>x64</Platform>
    <PublishDir>..\Bins\Publish\AssetRipper_win64</PublishDir>
    <PublishProtocol>FileSystem</PublishProtocol>
    <TargetFramework>net6.0</TargetFramework>
    <RuntimeIdentifier>win-x64</RuntimeIdentifier>
    <SelfContained>true</SelfContained>
    <PublishSingleFile>True</PublishSingleFile>
    <PublishReadyToRun>False</PublishReadyToRun>
    <PublishTrimmed>False</PublishTrimmed>
  </PropertyGroup>
</Project>
```

`AssetRipperGUI/UIAssetContainer.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Library;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace AssetRipper.GUI
{
	public class UIAssetContainer : ProjectAssetContainer
	{

		public UIAssetContainer(Ripper ripper) : base(
			ripper.GameStructure.Exporter,
			ripper.Settings,
			new VirtualSerializedFile(ripper.GameStructure.FileCollection.Layout),
			ripper.GameStructure.FileCollection.FetchAssets(),
			new Collection<IExportCollection>())
		{
		}
		public override IReadOnlyList<FileIdentifier> Dependencies => new List<FileIdentifier>();

		internal IUnityObjectBase LastAccessedAsset { get; set; }

		public override ISerializedFile File => LastAccessedAsset.SerializedFile;

		public override TransferInstructionFlags ExportFlags => ExportLayout.Flags;
	}

}
```

`AssetRipperGUI/UIFileListing.cs`:

```cs
using AssetRipper.Core.Classes;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Structure.GameStructure;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using SerializedFile = AssetRipper.Core.Parser.Files.SerializedFiles.SerializedFile;

namespace AssetRipper.GUI
{
	public static class UIFileListing
	{
		public static List<NewUiFileListItem> GetItemsFromStructure(GameStructure structure)
		{
			List<NewUiFileListItem> ret = new();
			foreach ((string name, SerializedFile resourceFile) in structure.FileCollection.GameFiles)
			{
				//Create a top-level tree view entry for each file
				NewUiFileListItem? topLevelEntry = new(name!, resourceFile);

				//Create a dictionary to hold the sub-categories.
				Dictionary<string, NewUiFileListItem> categories = new();

				foreach (IUnityObjectBase asset in resourceFile.FetchAssets())
				{
					//Get the name of the category this asset should go in.
					string categoryName = asset.AssetClassName;

					//Get or create the category.
					NewUiFileListItem category;
					if (!categories.TryGetValue(categoryName, out category!))
					{
						category = new NewUiFileListItem(categoryName);
						categories[categoryName] = category;
					}

					//Create the asset tree view item
					NewUiFileListItem assetListItem = new(asset);

					//Add it to the category.
					category.SubItems.Add(assetListItem);
				}

				//Add categories to the top-level file.
				categories.Values.ToList().ForEach(item =>
				{
					item.UpdateOnceAllAssetsAdded();
					topLevelEntry.SubItems.Add(item);
				});

				//Add the top-level entry to our result
				ret.Add(topLevelEntry);
			}

			//Create a top-level tree view entry for any loose resource files
			NewUiFileListItem? looseFiles = new("Loose Resource Files");
			foreach (ResourceFile? resourceFile in structure.FileCollection.GameResourceFiles)
			{
				if (resourceFile != null)
					looseFiles.SubItems.Add(new(new DummyAssetForLooseResourceFile(resourceFile)));
			}

			ret.Add(looseFiles);

			return ret;
		}
	}

	public class NewUiFileListItem : BaseViewModel
	{
		private string _displayAs;
		private IUnityObjectBase? _associatedObject;
		private SerializedFile? _associatedFile;

		//Read from UI
		public string DisplayAs
		{
			get => _displayAs;
			set
			{
				_displayAs = value;
				OnPropertyChanged();
			}
		}

		public IUnityObjectBase? AsObjectAsset => _associatedObject;

		//Read from UI
		public ObservableCollection<NewUiFileListItem> SubItems { get; } = new();

		/// <summary>
		/// Creates a top-level tree view item from a SerializedFile and the given display name.
		/// </summary>

		public NewUiFileListItem(string name, SerializedFile resourceFile)
		{
			_displayAs = name;
			_associatedFile = resourceFile;
		}

		/// <summary>
		/// Creates a sub-level tree view item from an individual asset. Inherits the name of the asset if it is a NamedObject,
		/// otherwise takes the name of the asset's class.
		/// </summary>
		public NewUiFileListItem(IUnityObjectBase asset)
		{
			_associatedObject = asset;

			if (_associatedObject is IHasNameString hasName)
			{
				_displayAs = hasName.GetNameNotEmpty();
			}

			if (_associatedObject is UnknownObject)
			{
				_displayAs = asset.ClassID.ToString();
			}

			if (string.IsNullOrEmpty(_displayAs))
			{
				_displayAs = _associatedObject.GetType().Name;
			}

		}

		/// <summary>
		/// Creates an intermediate-level tree view item from a category name. Takes the name of the category as its name.
		/// </summary>
		public NewUiFileListItem(string categoryName)
		{
			_displayAs = categoryName;
		}

		public void UpdateOnceAllAssetsAdded()
		{
			DisplayAs += $" ({SubItems.Count})";

			//Sort alphabetically
			List<NewUiFileListItem> itemsCopy = SubItems.ToList();
			itemsCopy.Sort((a, b) => string.Compare(a.DisplayAs, b.DisplayAs, StringComparison.Ordinal));
			SubItems.Clear();
			itemsCopy.ForEach(SubItems.Add);
		}
	}
}

```

`AssetRipperGUI/Utils/PermissionValidator.cs`:

```cs
using AssetRipper.Core.Logging;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Security.AccessControl;
using System.Security.Principal;

namespace AssetRipper.GUI.Utils
{
	public static class PermissionValidator
	{
		public static void RestartAsAdministrator()
		{
			if (OperatingSystem.IsWindows())
			{
				WindowsIdentity identity = WindowsIdentity.GetCurrent();
				WindowsPrincipal principal = new WindowsPrincipal(identity);
				// is run as administrator?
				if (principal.IsInRole(WindowsBuiltInRole.Administrator))
				{
					return;
				}
			}

			// try run as admin
			Process proc = new Process();
			string[] args = Environment.GetCommandLineArgs();
			proc.StartInfo.FileName = args[0];
			proc.StartInfo.UseShellExecute = true;
			proc.StartInfo.Verb = "runas";

			try
			{
				proc.Start();
				Environment.Exit(0);
			}
			catch (Win32Exception ex)
			{
				//The operation was canceled by the user.
				const int ERROR_CANCELLED = 1223;
				if (ex.NativeErrorCode == ERROR_CANCELLED)
				{
					Logger.Log(LogType.Error, LogCategory.General, $"You can't execute desired action without Administrator permission");
				}
				else
				{
					Logger.Log(LogType.Error, LogCategory.General, $"You have to restart application as Administator in order execute desired action");
				}
			}
		}

		public static bool CheckAccess(string path)
		{
			if (!OperatingSystem.IsWindows())
			{
				return true;
			}

			WindowsIdentity identity = WindowsIdentity.GetCurrent();
			WindowsPrincipal principal = new WindowsPrincipal(identity);
			bool isInRoleWithAccess = true;
			try
			{
				DirectoryInfo di = new(path);
				DirectorySecurity ds = di.GetAccessControl();
				AuthorizationRuleCollection rules = ds.GetAccessRules(true, true, typeof(NTAccount));

				foreach (AuthorizationRule rule in rules)
				{
					if (rule is not FileSystemAccessRule fsAccessRule)
					{
						continue;
					}

					if ((fsAccessRule.FileSystemRights & FileSystemRights.CreateDirectories) == 0 && (fsAccessRule.FileSystemRights & FileSystemRights.DeleteSubdirectoriesAndFiles) == 0)
					{
						continue;
					}

					if (rule.IdentityReference is not NTAccount ntAccount)
					{
						continue;
					}

					if (!principal.IsInRole(ntAccount.Value))
					{
						continue;
					}

					if (fsAccessRule.AccessControlType == AccessControlType.Deny)
					{
						isInRoleWithAccess = false;
						break;
					}
				}
			}
			catch (UnauthorizedAccessException)
			{
				isInRoleWithAccess = false;
			}
			return isInRoleWithAccess;
		}
	}
}

```

`AssetRipperLibrary/AssetRipperLibrary.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<Nullable>enable</Nullable>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<GenerateAssemblyInfo>false</GenerateAssemblyInfo>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>AssetRipperLibrary</AssemblyName>
		<RootNamespace>AssetRipper.Library</RootNamespace>
		<AllowUnsafeBlocks>true</AllowUnsafeBlocks>
		<OutputPath>..\Bins\AssetRipperLibrary\$(Configuration)\</OutputPath>
		<IntermediateOutputPath>..\Bins\obj\AssetRipperLibrary\$(Configuration)\</IntermediateOutputPath>
		<Platforms>x64</Platforms>
		<Configurations>DebugWindows;ReleaseWindows;DebugMac;ReleaseMac;DebugLinux;ReleaseLinux</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<DefineConstants>TRACE;NET_CORE</DefineConstants>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='DebugMac' or '$(Configuration)'=='DebugLinux'">
		<DefineConstants>DEBUG</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<PackageReference Include="AssetRipper.TextureDecoder" Version="1.1.0" />
		<PackageReference Include="Fmod5Sharp" Version="2.0.1" />
		<PackageReference Include="ICSharpCode.Decompiler" Version="8.0.0.7007-preview1" />
		<PackageReference Include="Kyaru.Texture2DDecoder" Version="0.16.40" />
		<PackageReference Include="NAudio.Core" Version="2.1.0" />
		<PackageReference Include="NAudio.Vorbis" Version="1.5.0" />
		<PackageReference Include="SharpGLTF.Core" Version="1.0.0-alpha0026" />
		<PackageReference Include="SharpGLTF.Toolkit" Version="1.0.0-alpha0026" />
		<PackageReference Include="System.Drawing.Common" Version="6.0.0" />
		<PackageReference Include="SixLabors.ImageSharp" Version="2.1.3" />
		<PackageReference Include="YamlDotNet" Version="11.2.1" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="MeshSharp">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>Libraries\MeshSharp.dll</HintPath>
		</Reference>
		<Reference Include="MeshSharp.FBX">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>Libraries\MeshSharp.FBX.dll</HintPath>
		</Reference>
		<Reference Include="MeshSharp.OBJ">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>Libraries\MeshSharp.OBJ.dll</HintPath>
		</Reference>
		<Reference Include="MeshSharp.PLY">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>Libraries\MeshSharp.PLY.dll</HintPath>
		</Reference>
		<Reference Include="MeshSharp.STL">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>Libraries\MeshSharp.STL.dll</HintPath>
		</Reference>
		<Reference Include="AssetRipper.SourceGenerated">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>../Libraries/AssetRipper.SourceGenerated.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperCore\AssetRipperCore.csproj" />
		<ProjectReference Include="..\ShaderTextRestorer\ShaderTextRestorer.csproj" />
	</ItemGroup>

	<ItemGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='ReleaseWindows'">
		<PackageReference Include="Kyaru.Texture2DDecoder.Windows" Version="0.1.0" />
	</ItemGroup>

	<ItemGroup Condition="'$(Configuration)'=='DebugMac' or '$(Configuration)'=='ReleaseMac'">
		<PackageReference Include="Kyaru.Texture2DDecoder.macOS" Version="0.1.0" />
	</ItemGroup>
	
	<ItemGroup Condition="'$(Configuration)'=='DebugLinux' or '$(Configuration)'=='ReleaseLinux'">
		<PackageReference Include="Kyaru.Texture2DDecoder.Linux" Version="0.1.0" />
	</ItemGroup>

	<ItemGroup Condition="'$(Configuration)'=='DebugWindows' or '$(Configuration)'=='ReleaseWindows'">
		<ContentWithTargetPath Include="Libraries\x64\texgenpack_x64.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<TargetPath>texgenpack.dll</TargetPath>
		</ContentWithTargetPath>
		<ContentWithTargetPath Include="Libraries\x64\crunch_x64.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<TargetPath>crunch.dll</TargetPath>
		</ContentWithTargetPath>
		<ContentWithTargetPath Include="Libraries\x64\crunchunity_x64.dll">
			<CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
			<TargetPath>crunchunity.dll</TargetPath>
		</ContentWithTargetPath>
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

	<ItemGroup>
		<None Remove="Exporters\Shaders\Templates\*" />
		<EmbeddedResource Include="Exporters\Shaders\Templates\*" />
	</ItemGroup>

	<ItemGroup>
	  <Content Remove="C:\Users\jrpri\.nuget\packages\icsharpcode.decompiler\8.0.0.7007-preview1\contentFiles\any\netstandard2.0\Humanizer\LICENSE" />
	  <Content Remove="C:\Users\jrpri\.nuget\packages\icsharpcode.decompiler\8.0.0.7007-preview1\contentFiles\any\netstandard2.0\Pattern Matching.html" />
	</ItemGroup>

	<ItemGroup>
	  <None Remove="C:\Users\jrpri\.nuget\packages\naudio.vorbis\1.5.0\contentFiles\any\netstandard2.0\README.md" />
	</ItemGroup>

</Project>

```

`AssetRipperLibrary/Attributes/RegisterPluginAttribute.cs`:

```cs
namespace AssetRipper.Library.Attributes
{
	[AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
	public sealed class RegisterPluginAttribute : Attribute
	{
		public Type PluginType { get; }

		public RegisterPluginAttribute(Type pluginType)
		{
			PluginType = pluginType;
		}
	}
}

```

`AssetRipperLibrary/Configuration/AudioExportFormat.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum AudioExportFormat
	{
		/// <summary>
		/// Export as a yaml asset and resS file. This is a safe option and is the backup when things go wrong.
		/// </summary>
		Yaml,
		/// <summary>
		/// For advanced users. This exports in a native format, usually FSB (FMOD Sound Bank). FSB files cannot be used in Unity Editor.
		/// </summary>
		Native,
		/// <summary>
		/// This is the recommended option. Audio assets are exported in the compression of the source, usually OGG.
		/// </summary>
		Default,
		/// <summary>
		/// Not advised if rebundling. This converts audio to the WAV format when possible
		/// </summary>
		PreferWav,
	}
}

```

`AssetRipperLibrary/Configuration/ImageExportFormat.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum ImageExportFormat
	{
		/// <summary>
		/// Lossless. Bitmap<br/>
		/// <see href="https://en.wikipedia.org/wiki/BMP_file_format"/>
		/// </summary>
		Bmp,
		/// <summary>
		/// Lossy. Graphics Interchange Format<br/>
		/// <see href="https://en.wikipedia.org/wiki/GIF"/>
		/// </summary>
		Gif,
		/// <summary>
		/// Lossy. Joint Photographic Experts Group<br/>
		/// <see href="https://en.wikipedia.org/wiki/JPEG"/>
		/// </summary>
		Jpeg,
		/// <summary>
		/// Lossless. Portable Bitmap<br/>
		/// <see href="https://en.wikipedia.org/wiki/Netpbm"/>
		/// </summary>
		Pbm,
		/// <summary>
		/// Lossless. Portable Network Graphics<br/>
		/// <see href="https://en.wikipedia.org/wiki/Portable_Network_Graphics"/>
		/// </summary>
		Png,
		/// <summary>
		/// Lossless. Truevision TGA<br/>
		/// <see href="https://en.wikipedia.org/wiki/Truevision_TGA"/>
		/// </summary>
		Tga,
		/// <summary>
		/// Lossless. Tag Image File Format<br/>
		/// <see href="https://en.wikipedia.org/wiki/TIFF"/>
		/// </summary>
		Tiff,
		/// <summary>
		/// Lossy. Google's WebP format<br/>
		/// <see href="https://en.wikipedia.org/wiki/WebP"/>
		/// </summary>
		Webp,
	}

	public static class ImageExportFormatExtensions
	{
		public static string GetFileExtension(this ImageExportFormat _this)
		{
			return _this switch
			{
				ImageExportFormat.Bmp => "bmp",
				ImageExportFormat.Gif => "gif",
				ImageExportFormat.Jpeg => "jpeg",
				ImageExportFormat.Pbm => "pbm",
				ImageExportFormat.Png => "png",
				ImageExportFormat.Tga => "tga",
				ImageExportFormat.Tiff => "tiff",
				ImageExportFormat.Webp => "webp",
				_ => throw new ArgumentOutOfRangeException(nameof(_this)),
			};
		}
	}
}

```

`AssetRipperLibrary/Configuration/LibraryConfiguration.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Logging;

namespace AssetRipper.Library.Configuration
{
	public class LibraryConfiguration : CoreConfiguration
	{
		/// <summary>
		/// The file format that audio clips get exported in. Recommended: Ogg
		/// </summary>
		public AudioExportFormat AudioExportFormat { get; set; }
		/// <summary>
		/// The file format that images (like textures) get exported in.
		/// </summary>
		public ImageExportFormat ImageExportFormat { get; set; }
		/// <summary>
		/// The coordinate space that meshes get exported in for non-yaml export.
		/// </summary>
		public MeshCoordinateSpace MeshCoordinateSpace { get; set; }
		/// <summary>
		/// The format that meshes get exported in. Recommended: Native
		/// </summary>
		public MeshExportFormat MeshExportFormat { get; set; }
		/// <summary>
		/// How are MonoScripts exported? Recommended: Decompiled
		/// </summary>
		public ScriptExportMode ScriptExportMode { get; set; }
		/// <summary>
		/// The C# language version of decompiled scripts.
		/// </summary>
		public ScriptLanguageVersion ScriptLanguageVersion { get; set; }
		/// <summary>
		/// How to export shaders?
		/// </summary>
		public ShaderExportMode ShaderExportMode { get; set; }
		/// <summary>
		/// Should sprites be exported as a texture? Recommended: Native
		/// </summary>
		public SpriteExportMode SpriteExportMode { get; set; }
		/// <summary>
		/// How terrain data is exported. Recommended: Native
		/// </summary>
		public TerrainExportMode TerrainExportMode { get; set; }
		/// <summary>
		/// How are text assets exported?
		/// </summary>
		public TextExportMode TextExportMode { get; set; }

		public override void ResetToDefaultValues()
		{
			base.ResetToDefaultValues();
			AudioExportFormat = AudioExportFormat.Default;
			ImageExportFormat = ImageExportFormat.Png;
			MeshCoordinateSpace = MeshCoordinateSpace.Unity;
			MeshExportFormat = MeshExportFormat.Native;
			ScriptExportMode = ScriptExportMode.Decompiled;
			ScriptLanguageVersion = ScriptLanguageVersion.AutoSafe;
			ShaderExportMode = ShaderExportMode.Dummy;
			SpriteExportMode = SpriteExportMode.Native;
			TerrainExportMode = TerrainExportMode.Native;
			TextExportMode = TextExportMode.Parse;
		}

		public override void LogConfigurationValues()
		{
			base.LogConfigurationValues();
			Logger.Info(LogCategory.General, $"{nameof(AudioExportFormat)}: {AudioExportFormat}");
			Logger.Info(LogCategory.General, $"{nameof(ImageExportFormat)}: {ImageExportFormat}");
			Logger.Info(LogCategory.General, $"{nameof(MeshCoordinateSpace)}: {MeshCoordinateSpace}");
			Logger.Info(LogCategory.General, $"{nameof(MeshExportFormat)}: {MeshExportFormat}");
			Logger.Info(LogCategory.General, $"{nameof(ScriptExportMode)}: {ScriptExportMode}");
			Logger.Info(LogCategory.General, $"{nameof(ScriptLanguageVersion)}: {ScriptLanguageVersion}");
			Logger.Info(LogCategory.General, $"{nameof(ShaderExportMode)}: {ShaderExportMode}");
			Logger.Info(LogCategory.General, $"{nameof(SpriteExportMode)}: {SpriteExportMode}");
			Logger.Info(LogCategory.General, $"{nameof(TerrainExportMode)}: {TerrainExportMode}");
			Logger.Info(LogCategory.General, $"{nameof(TextExportMode)}: {TextExportMode}");
		}
	}
}

```

`AssetRipperLibrary/Configuration/MeshCoordinateSpace.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum MeshCoordinateSpace
	{
		/// <summary>
		/// Coordinates for non-yaml export will remain in the Unity Coordinate space
		/// </summary>
		Unity,
		/// <summary>
		/// Coordinates for non-yaml export will be converted to the Left-Handed Coordinate space
		/// </summary>
		Left,
		/// <summary>
		/// Coordinates for non-yaml export will be converted to the Right-Handed Coordinate space
		/// </summary>
		Right
	}
}

```

`AssetRipperLibrary/Configuration/MeshExportFormat.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum MeshExportFormat
	{
		/// <summary>
		/// A robust format for using meshes in the editor. Can be converted to other formats by a variety of unity packages.
		/// </summary>
		Native,
		/// <summary>
		/// A common text format usuable in a variety of applications. However, this also breaks exported references to the mesh asset.
		/// </summary>
		Obj,
		/// <summary>
		/// A common text format used in the 3D printing industry. Unity does not support importing this format.
		/// </summary>
		StlAscii,
		/// <summary>
		/// A common binary format used in the 3D printing industry. Unity does not support importing this format.
		/// </summary>
		StlBinary,
		/// <summary>
		/// Stanford Triangle Format for storing mesh data as text. Unity does not support importing this format.
		/// </summary>
		PlyAscii,
		/// <summary>
		/// An opensource alternative to FBX. It is the binary version of GLTF. Primitive export only contains mesh data. Unity does not support importing this format.
		/// </summary>
		GlbPrimitive,
		/// <summary>
		/// FBX. Primitive export only contains mesh data. This option breaks exported references to the mesh asset.
		/// </summary>
		FbxPrimitive,
	}

	/* Unity supported mesh import formats: (https://docs.unity3d.com/2019.3/Documentation/Manual/3D-formats.html)
	 * .fbx
	 * .dae (Collada)
	 * .3ds
	 * .dxf
	 * .obj
	 */

	public static class MeshExportFormatExtensions
	{
		public static string GetFileExtension(this MeshExportFormat format) => format switch
		{
			MeshExportFormat.Native => "asset",
			MeshExportFormat.Obj => "obj",
			MeshExportFormat.StlAscii => "stl",
			MeshExportFormat.StlBinary => "stl",
			MeshExportFormat.PlyAscii => "ply",
			MeshExportFormat.GlbPrimitive => "glb",
			MeshExportFormat.FbxPrimitive => "fbx",
			_ => null,
		};

		public static bool IsFBX(this MeshExportFormat format) => format == MeshExportFormat.FbxPrimitive;
		public static bool IsGLB(this MeshExportFormat format) => format == MeshExportFormat.GlbPrimitive;
		public static bool IsOBJ(this MeshExportFormat format) => format == MeshExportFormat.Obj;
		public static bool IsPLY(this MeshExportFormat format) => format == MeshExportFormat.PlyAscii;
		public static bool IsSTL(this MeshExportFormat format) => format == MeshExportFormat.StlAscii || format == MeshExportFormat.StlBinary;
		public static bool IsYaml(this MeshExportFormat format) => format == MeshExportFormat.Native;
	}
}
```

`AssetRipperLibrary/Configuration/ScriptExportMode.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum ScriptExportMode
	{
		/// <summary>
		/// Use the ILSpy decompiler to generate CS scripts. This is reliable. However, it's also time-consuming and contains many compile errors.
		/// </summary>
		Decompiled,
		/// <summary>
		/// Special assemblies, such as Assembly-CSharp, are decompiled to CS scripts with the ILSpy decompiler. Other assemblies are saved as DLL files.
		/// </summary>
		Hybrid,
		/// <summary>
		/// Special assemblies, such as Assembly-CSharp, are renamed to have compatible names.
		/// </summary>
		DllExportWithRenaming,
		/// <summary>
		/// Export assemblies in their compiled Dll form. Experimental. Might not work at all.
		/// </summary>
		DllExportWithoutRenaming,
	}
}

```

`AssetRipperLibrary/Configuration/ScriptLanguageVersion.cs`:

```cs
using ICSharpCode.Decompiler.CSharp;

namespace AssetRipper.Library.Configuration
{
	public enum ScriptLanguageVersion
	{
		AutoExperimental = -2,
		AutoSafe = -1,
		CSharp1 = 1,
		CSharp2 = 2,
		CSharp3 = 3,
		CSharp4 = 4,
		CSharp5 = 5,
		CSharp6 = 6,
		CSharp7 = 7,
		CSharp7_1 = 701,
		CSharp7_2 = 702,
		CSharp7_3 = 703,
		CSharp8_0 = 800,
		CSharp9_0 = 900,
		CSharp10_0 = 1000,
		CSharp11_0 = 1100,
		Latest = int.MaxValue
	}

	public static class ScriptLanguageVersionExtensions
	{
		public static LanguageVersion ToCSharpLanguageVersion(this ScriptLanguageVersion scriptLanguageVersion, UnityVersion unityVersion)
		{
			return scriptLanguageVersion switch
			{
				ScriptLanguageVersion.AutoExperimental => GetAutomaticCSharpLanguageVersion(unityVersion, true),
				ScriptLanguageVersion.AutoSafe => GetAutomaticCSharpLanguageVersion(unityVersion, false),
				ScriptLanguageVersion.CSharp1 => LanguageVersion.CSharp1,
				ScriptLanguageVersion.CSharp2 => LanguageVersion.CSharp2,
				ScriptLanguageVersion.CSharp3 => LanguageVersion.CSharp3,
				ScriptLanguageVersion.CSharp4 => LanguageVersion.CSharp4,
				ScriptLanguageVersion.CSharp5 => LanguageVersion.CSharp5,
				ScriptLanguageVersion.CSharp6 => LanguageVersion.CSharp6,
				ScriptLanguageVersion.CSharp7 => LanguageVersion.CSharp7,
				ScriptLanguageVersion.CSharp7_1 => LanguageVersion.CSharp7_1,
				ScriptLanguageVersion.CSharp7_2 => LanguageVersion.CSharp7_2,
				ScriptLanguageVersion.CSharp7_3 => LanguageVersion.CSharp7_3,
				ScriptLanguageVersion.CSharp8_0 => LanguageVersion.CSharp8_0,
				ScriptLanguageVersion.CSharp9_0 => LanguageVersion.CSharp9_0,
				ScriptLanguageVersion.CSharp10_0 => LanguageVersion.CSharp10_0,
				ScriptLanguageVersion.CSharp11_0 => LanguageVersion.CSharp11_0,
				ScriptLanguageVersion.Latest => LanguageVersion.Latest,
				_ => throw new ArgumentOutOfRangeException(nameof(scriptLanguageVersion), $"{scriptLanguageVersion}"),
			};
		}

		private static LanguageVersion GetAutomaticCSharpLanguageVersion(UnityVersion unityVersion, bool experimental)
		{
			if (unityVersion.IsGreaterEqual(2021, 2))
			{
				return LanguageVersion.CSharp9_0;
			}
			else if (unityVersion.IsGreaterEqual(2020, 2))
			{
				return LanguageVersion.CSharp8_0;
			}
			else if (unityVersion.IsGreaterEqual(2019, 2))
			{
				return LanguageVersion.CSharp7_3;
			}
			else if (experimental && unityVersion.IsGreaterEqual(2018, 3))
			{
				return LanguageVersion.CSharp7_3;
			}
			else if (experimental && unityVersion.IsGreaterEqual(2017, 1))
			{
				return LanguageVersion.CSharp6;
			}
			else
			{
				return LanguageVersion.CSharp4;
			}
		}
	}
}

```

`AssetRipperLibrary/Configuration/ShaderExportMode.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum ShaderExportMode
	{
		/// <summary>
		/// Export as dummy shaders which compile in the editor
		/// </summary>
		Dummy,
		/// <summary>
		/// Export as yaml assets which can be viewed in the editor
		/// </summary>
		Yaml,
		/// <summary>
		/// Export as disassembly which does not compile in the editor
		/// </summary>
		Disassembly,
	}
}

```

`AssetRipperLibrary/Configuration/SpriteExportMode.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum SpriteExportMode
	{
		/// <summary>
		/// Export in the native asset format
		/// </summary>
		Native,
		/// <summary>
		/// Export as a Texture2D png image
		/// </summary>
		Texture2D,
	}
}

```

`AssetRipperLibrary/Configuration/TerrainExportMode.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum TerrainExportMode
	{
		/// <summary>
		/// The default export mode. This is the only one that exports in a format Unity can use for terrains.
		/// </summary>
		Native,
		/// <summary>
		/// This experimental mode converts the terrain data into an OBJ mesh. Exported mesh size, position, and proportions may not be correct.
		/// </summary>
		Obj,
		/// <summary>
		/// A heatmap of the terrain height. Probably not usable for anything but a visual representation.
		/// </summary>
		Heatmap,
	}
}

```

`AssetRipperLibrary/Configuration/TextExportMode.cs`:

```cs
namespace AssetRipper.Library.Configuration
{
	public enum TextExportMode
	{
		/// <summary>
		/// Export as bytes
		/// </summary>
		Bytes,
		/// <summary>
		/// Export as plain text files
		/// </summary>
		Txt,
		/// <summary>
		/// Export as plain text files, but try to guess the file extension
		/// </summary>
		Parse,
	}
}

```

`AssetRipperLibrary/Exporters/AnimationClips/AnimationClipConverter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Classes.AnimationClip.GenericBinding;
using AssetRipper.Core.Classes.Misc.KeyframeTpl.TangentMode;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Utils;
using AssetRipper.IO.Endian;
using AssetRipper.Library.Exporters.AnimatorControllers.Editor;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Subclasses.AnimationClipBindingConstant;
using AssetRipper.SourceGenerated.Subclasses.Clip;
using AssetRipper.SourceGenerated.Subclasses.ConstantClip;
using AssetRipper.SourceGenerated.Subclasses.DenseClip;
using AssetRipper.SourceGenerated.Subclasses.FloatCurve;
using AssetRipper.SourceGenerated.Subclasses.GenericBinding;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_float;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Quaternionf;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_Vector3f;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Object_;
using AssetRipper.SourceGenerated.Subclasses.PPtrCurve;
using AssetRipper.SourceGenerated.Subclasses.PPtrKeyframe;
using AssetRipper.SourceGenerated.Subclasses.QuaternionCurve;
using AssetRipper.SourceGenerated.Subclasses.StreamedClip;
using AssetRipper.SourceGenerated.Subclasses.Vector3Curve;
using System.Collections.Generic;
using System.IO;
using System.Text.RegularExpressions;

namespace AssetRipper.Library.Exporters.AnimationClips
{
#warning to resolve
	/// <summary>
	/// This class permanently alters the asset and will cause issues if ripping is done twice without reloading
	/// </summary>
	public class AnimationClipConverter
	{
		private AnimationClipConverter(IAnimationClip clip)
		{
			if (clip == null)
			{
				throw new ArgumentNullException(nameof(clip));
			}
			m_clip = clip;
			m_customCurveResolver = new CustomCurveResolver(clip);
		}

		public static AnimationClipConverter Process(IAnimationClip clip)
		{
			AnimationClipConverter converter = new AnimationClipConverter(clip);
			converter.ProcessInner();
			return converter;
		}

		private void ProcessInner()
		{
			if (m_clip.Has_MuscleClip_C74())
			{
				IClip clip = m_clip.MuscleClip_C74.Clip.Data;
				IAnimationClipBindingConstant bindings = m_clip.ClipBindingConstant_C74!;
				IReadOnlyDictionary<uint, string> tos = m_clip.FindTOS();

				IReadOnlyList<StreamedFrame> streamedFrames = GenerateFramesFromStreamedClip(clip.StreamedClip, Layout);
				float lastDenseFrame = clip.DenseClip.FrameCount / clip.DenseClip.SampleRate;
				float lastSampleFrame = streamedFrames.Count > 1 ? streamedFrames[streamedFrames.Count - 2].Time : 0.0f;
				float lastFrame = Math.Max(lastDenseFrame, lastSampleFrame);

				ProcessStreams(streamedFrames, bindings, tos, clip.DenseClip.SampleRate);
				ProcessDenses(clip, bindings, tos);
				if (clip.Has_ConstantClip())
				{
					ProcessConstant(clip, bindings, tos, lastFrame);
				}
				if (m_clip.Has_MuscleClipInfo_C74())
				{
					m_clip.MuscleClipInfo_C74.Initialize(m_clip.MuscleClip_C74);
				}
			}
		}

		private void ProcessStreams(IReadOnlyList<StreamedFrame> streamFrames, IAnimationClipBindingConstant bindings, IReadOnlyDictionary<uint, string> tos, float sampleRate)
		{
			float[] curveValues = new float[4];
			float[] inSlopeValues = new float[4];
			float[] outSlopeValues = new float[4];
			float interval = 1.0f / sampleRate;

			// first (index [0]) stream frame is for slope calculation for the first real frame (index [1])
			// last one (index [count - 1]) is +Infinity
			// it is made for slope processing, but we don't need them
			bool frameIndex0 = true;
			for (int frameIndex = 0; frameIndex < streamFrames.Count - 1; frameIndex++)
			{
				StreamedFrame frame = streamFrames[frameIndex];
				for (int curveIndex = 0; curveIndex < frame.Curves.Length;)
				{
					StreamedCurveKey curve = frame.Curves[curveIndex];
					IGenericBinding binding = bindings.FindBinding(curve.Index);

					string path = GetCurvePath(tos, binding.Path);
					if (binding.IsTransform())
					{
						if (frameIndex0) 
						{ 
							curveIndex = GetNextCurve(frame, curveIndex); 
							continue; 
						}
						GetPreviousFrame(streamFrames, curve.Index, frameIndex, out int prevFrameIndex, out int prevCurveIndex);
						int dimension = binding.TransformType().GetDimension();
						for (int key = 0; key < dimension; key++)
						{
							StreamedCurveKey keyCurve = frame.Curves[curveIndex];//index out of bounds
							StreamedFrame prevFrame = streamFrames[prevFrameIndex];
							StreamedCurveKey prevKeyCurve = prevFrame.Curves[prevCurveIndex + key];
							float deltaTime = frame.Time - prevFrame.Time;
							curveValues[key] = keyCurve.Value;
							inSlopeValues[key] = prevKeyCurve.CalculateNextInSlope(deltaTime, keyCurve.Value);
							outSlopeValues[key] = keyCurve.OutSlope;
							curveIndex = GetNextCurve(frame, curveIndex);
						}

						AddTransformCurve(frame.Time, binding.TransformType(), curveValues, inSlopeValues, outSlopeValues, 0, path);
					}
					else if (binding.CustomType == (byte)BindingCustomType.None)
					{
						if (frameIndex0) { curveIndex = GetNextCurve(frame, curveIndex); continue; }
						AddDefaultCurve(binding, path, frame.Time, frame.Curves[curveIndex].Value);
						curveIndex = GetNextCurve(frame, curveIndex);
					}
					else
					{
						AddCustomCurve(bindings, binding, path, frame.Time, frame.Curves[curveIndex].Value);
						curveIndex = GetNextCurve(frame, curveIndex);
					}
				}
				if (frameIndex0)
				{
					frameIndex0 = false;
				}
			}
		}

		private void ProcessDenses(IClip clip, IAnimationClipBindingConstant bindings, IReadOnlyDictionary<uint, string> tos)
		{
			DenseClip dense = clip.DenseClip;
			int streamCount = (int)clip.StreamedClip.CurveCount;
			float[] slopeValues = new float[4]; // no slopes - 0 values
			for (int frameIndex = 0; frameIndex < dense.FrameCount; frameIndex++)
			{
				float time = frameIndex / dense.SampleRate;
				int frameOffset = frameIndex * (int)dense.CurveCount;
				for (int curveIndex = 0; curveIndex < dense.CurveCount;)
				{
					int index = streamCount + curveIndex;
					IGenericBinding binding = bindings.FindBinding(index);
					string path = GetCurvePath(tos, binding.Path);
					int framePosition = frameOffset + curveIndex;
					if (binding.IsTransform())
					{
						AddTransformCurve(time, binding.TransformType(), dense.SampleArray, slopeValues, slopeValues, framePosition, path);
						curveIndex += binding.TransformType().GetDimension();
					}
					else if (binding.CustomType == (byte)BindingCustomType.None)
					{
						AddDefaultCurve(binding, path, time, dense.SampleArray[framePosition]);
						curveIndex++;
					}
					else
					{
						AddCustomCurve(bindings, binding, path, time, dense.SampleArray[framePosition]);
						curveIndex++;
					}
				}
			}
		}

		private void ProcessConstant(IClip clip, IAnimationClipBindingConstant bindings, IReadOnlyDictionary<uint, string> tos, float lastFrame)
		{
			IConstantClip constant = clip.ConstantClip;
			int streamCount = (int)clip.StreamedClip.CurveCount;
			int denseCount = (int)clip.DenseClip.CurveCount;
			float[] slopeValues = new float[4]; // no slopes - 0 values

			// only first and last frames
			float time = 0.0f;
			for (int i = 0; i < 2; i++, time += lastFrame)
			{
				for (int curveIndex = 0; curveIndex < constant.Data.Length;)
				{
					int index = streamCount + denseCount + curveIndex;
					IGenericBinding binding = bindings.FindBinding(index);
					string path = GetCurvePath(tos, binding.Path);
					if (binding.IsTransform())
					{
						AddTransformCurve(time, binding.TransformType(), constant.Data, slopeValues, slopeValues, curveIndex, path);
						curveIndex += binding.TransformType().GetDimension();
					}
					else if (binding.CustomType == (byte)BindingCustomType.None)
					{
						AddDefaultCurve(binding, path, time, constant.Data[curveIndex]);
						curveIndex++;
					}
					else
					{
						AddCustomCurve(bindings, binding, path, time, constant.Data[curveIndex]);
						curveIndex++;
					}
				}
			}
		}

		private void AddCustomCurve(IAnimationClipBindingConstant bindings, IGenericBinding binding, string path, float time, float value)
		{
			bool ProcessStreams_frameIndex0 = time != FrameIndex0Time;
			switch ((BindingCustomType)binding.CustomType)
			{
				case BindingCustomType.AnimatorMuscle:
					if (ProcessStreams_frameIndex0)
					{
						AddAnimatorMuscleCurve(binding, time, value);
					}

					break;

				default:
					string attribute = m_customCurveResolver.ToAttributeName((BindingCustomType)binding.CustomType, binding.Attribute, path);
					if (binding.IsPPtrCurve())
					{
						if (!ProcessStreams_frameIndex0)
						{
							time = 0.0f;
						}

						CurveData curve = new CurveData(path, attribute, binding.GetClassID(), binding.Script.FileIndex, binding.Script.PathIndex);
						AddPPtrKeyframe(curve, bindings, time, (int)value);
					}
					else if (ProcessStreams_frameIndex0)
					{
						CurveData curve = new CurveData(path, attribute, binding.GetClassID(), binding.Script.FileIndex, binding.Script.PathIndex);
						AddFloatKeyframe(curve, time, value);
					}
					break;
			}
		}

		private void AddTransformCurve(float time, TransformType transType, IReadOnlyList<float> curveValues,
			IReadOnlyList<float> inSlopeValues, IReadOnlyList<float> outSlopeValues, int offset, string path)
		{
			switch (transType)
			{
				case TransformType.Translation:
					{
						if (!m_translations.TryGetValue(path, out IVector3Curve? curve))
						{
							curve = m_clip.PositionCurves_C74.AddNew();
							curve.SetValues(path);
							m_translations.Add(path, curve);
						}

						float x = curveValues[offset + 0];
						float y = curveValues[offset + 1];
						float z = curveValues[offset + 2];

						float inX = inSlopeValues[0];
						float inY = inSlopeValues[1];
						float inZ = inSlopeValues[2];

						float outX = outSlopeValues[0];
						float outY = outSlopeValues[1];
						float outZ = outSlopeValues[2];

						IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

						key.Value.SetValues(x, y, z);
						key.InSlope.SetValues(inX, inY, inZ);
						key.OutSlope.SetValues(outX, outY, outZ);
						key.Time = time;
						// this enum member is version agnostic
						key.TangentMode = TangentMode.FreeFree.ToTangent(Layout.Version);
						key.WeightedMode = (int)Core.Classes.Misc.KeyframeTpl.WeightedMode.None;
						key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
						key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					}
					break;

				case TransformType.Rotation:
					{
						if (!m_rotations.TryGetValue(path, out IQuaternionCurve? curve))
						{
							curve = m_clip.RotationCurves_C74.AddNew();
							curve.SetValues(path);
							m_rotations.Add(path, curve);
						}

						float x = curveValues[offset + 0];
						float y = curveValues[offset + 1];
						float z = curveValues[offset + 2];
						float w = curveValues[offset + 3];

						float inX = inSlopeValues[0];
						float inY = inSlopeValues[1];
						float inZ = inSlopeValues[2];
						float inW = inSlopeValues[3];

						float outX = outSlopeValues[0];
						float outY = outSlopeValues[1];
						float outZ = outSlopeValues[2];
						float outW = outSlopeValues[3];

						IKeyframe_Quaternionf key = curve.Curve.Curve.AddNew();

						key.Value.SetValues(x, y, z, w);
						key.InSlope.SetValues(inX, inY, inZ, inW);
						key.OutSlope.SetValues(outX, outY, outZ, outW);
						key.Time = time;
						// this enum member is version agnostic
						key.TangentMode = TangentMode.FreeFree.ToTangent(Layout.Version);
						key.WeightedMode = (int)Core.Classes.Misc.KeyframeTpl.WeightedMode.None;
						key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
						key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					}
					break;

				case TransformType.Scaling:
					{
						if (!m_scales.TryGetValue(path, out IVector3Curve? curve))
						{
							curve = m_clip.ScaleCurves_C74.AddNew();
							curve.SetValues(path);
							m_scales.Add(path, curve);
						}

						float x = curveValues[offset + 0];
						float y = curveValues[offset + 1];
						float z = curveValues[offset + 2];

						float inX = inSlopeValues[0];
						float inY = inSlopeValues[1];
						float inZ = inSlopeValues[2];

						float outX = outSlopeValues[0];
						float outY = outSlopeValues[1];
						float outZ = outSlopeValues[2];

						IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

						key.Value.SetValues(x, y, z);
						key.InSlope.SetValues(inX, inY, inZ);
						key.OutSlope.SetValues(outX, outY, outZ);
						key.Time = time;
						// this enum member is version agnostic
						key.TangentMode = TangentMode.FreeFree.ToTangent(Layout.Version);
						key.WeightedMode = (int)Core.Classes.Misc.KeyframeTpl.WeightedMode.None;
						key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
						key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					}
					break;

				case TransformType.EulerRotation:
					{
						if (!m_eulers.TryGetValue(path, out IVector3Curve? curve))
						{
							curve = m_clip.EulerCurves_C74.AddNew();
							curve.SetValues(path);
							m_eulers.Add(path, curve);
						}

						float x = curveValues[offset + 0];
						float y = curveValues[offset + 1];
						float z = curveValues[offset + 2];

						float inX = inSlopeValues[0];
						float inY = inSlopeValues[1];
						float inZ = inSlopeValues[2];

						float outX = outSlopeValues[0];
						float outY = outSlopeValues[1];
						float outZ = outSlopeValues[2];

						IKeyframe_Vector3f key = curve.Curve.Curve.AddNew();

						key.Value.SetValues(x, y, z);
						key.InSlope.SetValues(inX, inY, inZ);
						key.OutSlope.SetValues(outX, outY, outZ);
						key.Time = time;
						// this enum member is version agnostic
						key.TangentMode = TangentMode.FreeFree.ToTangent(Layout.Version);
						key.WeightedMode = (int)Core.Classes.Misc.KeyframeTpl.WeightedMode.None;
						key.InWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
						key.OutWeight?.SetValues(DefaultFloatWeight, DefaultFloatWeight, DefaultFloatWeight);
					}
					break;

				default:
					throw new NotImplementedException(transType.ToString());
			}
		}

		private void AddDefaultCurve(IGenericBinding binding, string path, float time, float value)
		{
			switch (binding.GetClassID())
			{
				case ClassIDType.GameObject:
					{
						AddGameObjectCurve(binding, path, time, value);
					}
					break;

				case ClassIDType.MonoBehaviour:
					{
						AddScriptCurve(binding, path, time, value);
					}
					break;

				default:
					AddEngineCurve(binding, path, time, value);
					break;
			}
		}

		private void AddGameObjectCurve(IGenericBinding binding, string path, float time, float value)
		{
			if (binding.Attribute == CrcUtils.CalculateDigestAscii("m_IsActive"))
			{
				CurveData curve = new CurveData(path, "m_IsActive", ClassIDType.GameObject);
				AddFloatKeyframe(curve, time, value);
				return;
			}
			else
			{
				// that means that dev exported animation clip with missing component
				CurveData curve = new CurveData(path, MissedPropertyPrefix + binding.Attribute, ClassIDType.GameObject);
				AddFloatKeyframe(curve, time, value);
			}
		}

		private void AddScriptCurve(IGenericBinding binding, string path, float time, float value)
		{
#warning TODO:
			CurveData curve = new CurveData(path, ScriptPropertyPrefix + binding.Attribute, ClassIDType.MonoBehaviour, binding.Script.FileIndex, binding.Script.PathIndex);
			AddFloatKeyframe(curve, time, value);
		}

		private void AddEngineCurve(IGenericBinding binding, string path, float time, float value)
		{
#warning TODO:
			CurveData curve = new CurveData(path, TypeTreePropertyPrefix + binding.Attribute, binding.GetClassID());
			AddFloatKeyframe(curve, time, value);
		}

		private void AddAnimatorMuscleCurve(IGenericBinding binding, float time, float value)
		{
			string attributeString = Core.Classes.AnimationClip.HumanoidMuscleTypeExtensions.ToAttributeString(binding.GetHumanoidMuscle(Layout.Version));
			CurveData curve = new CurveData(string.Empty, attributeString, ClassIDType.Animator);
			AddFloatKeyframe(curve, time, value);
		}

		private void AddFloatKeyframe(CurveData curveData, float time, float value)
		{
			if (!m_floats.TryGetValue(curveData, out IFloatCurve? curve))
			{
				curve = m_clip.FloatCurves_C74.AddNew();
				curve.Path.String = curveData.path;
				curve.Attribute.String = curveData.attribute;
				curve.ClassID = (int)curveData.classId;
				curve.Script.FileIndex = curveData.fileId;
				curve.Script.PathIndex = curveData.pathId;
				curve.Curve.SetDefaultRotationOrderAndCurveLoopType();
				m_floats.Add(curveData, curve);
			}

			IKeyframe_float floatKey = curve.Curve.Curve.AddNew();
			floatKey.SetValues(Layout.Version, time, value, DefaultFloatWeight);
		}

		private void AddPPtrKeyframe(CurveData curveData, IAnimationClipBindingConstant bindings, float time, int index)
		{
			if (!m_pptrs.TryGetValue(curveData, out IPPtrCurve? curve))
			{
				curve = m_clip.PPtrCurves_C74.AddNew();
				curve.Path.String = curveData.path;
				curve.Attribute.String = curveData.attribute;
				curve.ClassID = (int)curveData.classId;
				curve.Script.FileIndex = curveData.fileId;
				curve.Script.PathIndex = curveData.pathId;
				m_pptrs.Add(curveData, curve);
			}

			IPPtr_Object_ value = bindings.PptrCurveMapping[index];
			IPPtrKeyframe key = curve.Curve.AddNew();
			key.Time = time;
			key.Value.FileIndex = value.FileIndex;
			key.Value.PathIndex = value.PathIndex;
		}

		private void GetPreviousFrame(IReadOnlyList<StreamedFrame> streamFrames, int curveID, int currentFrame, out int frameIndex, out int curveIndex)
		{
			for (frameIndex = currentFrame - 1; frameIndex >= 0; frameIndex--)
			{
				StreamedFrame frame = streamFrames[frameIndex];
				for (curveIndex = 0; curveIndex < frame.Curves.Length; curveIndex++)
				{
					StreamedCurveKey curve = frame.Curves[curveIndex];
					if (curve.Index == curveID)
					{
						return;
					}
				}
			}
			throw new Exception($"There is no curve with index {curveID} in any of previous frames");
		}

		private int GetNextCurve(StreamedFrame frame, int currentCurve)
		{
			StreamedCurveKey curve = frame.Curves[currentCurve];
			int i = currentCurve + 1;
			for (; i < frame.Curves.Length; i++)
			{
				if (frame.Curves[i].Index != curve.Index)
				{
					return i;
				}
			}
			return i;
		}

		private static string GetCurvePath(IReadOnlyDictionary<uint, string> tos, uint hash)
		{
			if (tos.TryGetValue(hash, out string? path))
			{
				return path;
			}
			else
			{
				return UnknownPathPrefix + hash;
			}
		}

		public static IReadOnlyList<StreamedFrame> GenerateFramesFromStreamedClip(StreamedClip clip, LayoutInfo layout)
		{
			List<StreamedFrame> frames = new List<StreamedFrame>();
			byte[] memStreamBuffer = new byte[clip.Data.Length * sizeof(uint)];
			Buffer.BlockCopy(clip.Data, 0, memStreamBuffer, 0, memStreamBuffer.Length);
			using MemoryStream stream = new MemoryStream(memStreamBuffer);
			using AssetReader reader = new AssetReader(stream, EndianType.LittleEndian, layout);
			while (reader.BaseStream.Position < reader.BaseStream.Length)
			{
				StreamedFrame frame = new StreamedFrame();
				frame.Read(reader);
				frames.Add(frame);
			}
			return frames;
		}

		private LayoutInfo Layout => m_clip.SerializedFile.Layout;

		public static readonly Regex UnknownPathRegex = new Regex($@"^{UnknownPathPrefix}[0-9]{{1,10}}$", RegexOptions.Compiled);

		private const string UnknownPathPrefix = "path_";
		private const string MissedPropertyPrefix = "missed_";
		private const string ScriptPropertyPrefix = "script_";
		private const string TypeTreePropertyPrefix = "typetree_";

		/// <summary>
		/// Used to detect when a StreamedFrame is from index 0.
		/// </summary>
		private const float FrameIndex0Time = float.MinValue;

		private readonly Dictionary<string, IVector3Curve> m_translations = new();
		private readonly Dictionary<string, IQuaternionCurve> m_rotations = new();
		private readonly Dictionary<string, IVector3Curve> m_scales = new();
		private readonly Dictionary<string, IVector3Curve> m_eulers = new();
		private readonly Dictionary<CurveData, IFloatCurve> m_floats = new();
		private readonly Dictionary<CurveData, IPPtrCurve> m_pptrs = new();

		private readonly IAnimationClip m_clip;
		private readonly CustomCurveResolver m_customCurveResolver;
		private const float DefaultFloatWeight = 1.0f / 3.0f;
		//default vector3 is 1/3, 1/3, 1/3
		//default quaternion is 1/3, 1/3, 1/3, 1/3

		private readonly struct CurveData
		{
			public readonly string path;
			public readonly string attribute;
			public readonly ClassIDType classId;
			public readonly int fileId;
			public readonly long pathId;

			public CurveData(string path, string attribute, ClassIDType classId) : this()
			{
				this.path = path;
				this.attribute = attribute;
				this.classId = classId;
			}

			public CurveData(string path, string attribute, ClassIDType classId, int fileId, long pathId)
			{
				this.path = path;
				this.attribute = attribute;
				this.classId = classId;
				this.fileId = fileId;
				this.pathId = pathId;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/AnimationClips/AnimationClipExportCollection.cs`:

```cs
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.AnimationClips
{
	public sealed class AnimationClipExportCollection : AssetExportCollection
	{
		private static HashSet<IAnimationClip> convertedClips = new();
		public AnimationClipExportCollection(IAssetExporter assetExporter, IAnimationClip asset) : base(assetExporter, asset)
		{
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			IAnimationClip animationClip = (IAnimationClip)Asset;
			if (!convertedClips.Contains(animationClip))
			{
				//this permanently alters the asset and should only be done once
				AnimationClipConverter.Process(animationClip);
				convertedClips.Add(animationClip);
			}
			return base.ExportInner(container, filePath, dirPath);
		}
	}
}

```

`AssetRipperLibrary/Exporters/AnimationClips/AnimationClipExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_74;

namespace AssetRipper.Library.Exporters.AnimationClips
{
	public sealed class AnimationClipExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAnimationClip;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AnimationClipExportCollection(this, (IAnimationClip)asset);
		}
	}
}

```

`AssetRipperLibrary/Exporters/AnimationClips/CustomCurveResolver.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1;
using AssetRipper.SourceGenerated.Classes.ClassID_137;
using AssetRipper.SourceGenerated.Classes.ClassID_25;
using AssetRipper.SourceGenerated.Classes.ClassID_4;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using System.Linq;
using BindingCustomType = AssetRipper.Core.Classes.AnimationClip.GenericBinding.BindingCustomType;

namespace AssetRipper.Library.Exporters.AnimationClips
{
	public sealed class CustomCurveResolver
	{
		public CustomCurveResolver(IAnimationClip clip)
		{
			if (clip == null)
			{
				throw new ArgumentNullException(nameof(clip));
			}
			m_clip = clip;
		}

		public string ToAttributeName(BindingCustomType type, uint attribute, string path)
		{
			switch (type)
			{
				case BindingCustomType.BlendShape:
					{
						const string Prefix = "blendShape.";
						if (AnimationClipConverter.UnknownPathRegex.IsMatch(path))
						{
							return Prefix + attribute;
						}

						foreach (IGameObject root in Roots)
						{
							ITransform rootTransform = root.GetTransform();
							ITransform? child = rootTransform.FindChild(path);
							if (child == null)
							{
								continue;
							}
							ISkinnedMeshRenderer? skin = child.GetGameObject().FindComponent<ISkinnedMeshRenderer>();
							if (skin == null)
							{
								continue;
							}
							IMesh? mesh = skin.Mesh_C137.FindAsset(skin.SerializedFile);
							if (mesh == null)
							{
								continue;
							}
							string? shapeName = mesh.FindBlendShapeNameByCRC(attribute);
							if (shapeName == null)
							{
								continue;
							}

							return Prefix + shapeName;
						}
						return Prefix + attribute;
					}

				case BindingCustomType.Renderer:
					return "m_Materials" 
						+ "." + "Array" //from the common string
						+ "." + "data" //from the common string
						+ $"[{attribute}]";

				case BindingCustomType.RendererMaterial:
					{
						const string Prefix = "material.";
						if (AnimationClipConverter.UnknownPathRegex.IsMatch(path))
						{
							return Prefix + attribute;
						}

						foreach (IGameObject root in Roots)
						{
							ITransform rootTransform = root.GetTransform();
							ITransform? child = rootTransform.FindChild(path);
							if (child == null)
							{
								continue;
							}

							uint crc28 = attribute & 0xFFFFFFF;
							IRenderer? renderer = child.GetGameObject().FindComponent<IRenderer>();
							if (renderer == null)
							{
								continue;
							}
							string? property = renderer.FindMaterialPropertyNameByCRC28(crc28);
							if (property == null)
							{
								continue;
							}

							if ((attribute & 0x80000000) != 0)
							{
								return Prefix + property;
							}

							uint subPropIndex = attribute >> 28 & 3;
							bool isRgba = (attribute & 0x40000000) != 0;
							char subProperty = subPropIndex switch
							{
								0 => isRgba ? 'r' : 'x',
								1 => isRgba ? 'g' : 'y',
								2 => isRgba ? 'b' : 'z',
								_ => isRgba ? 'a' : 'w',
							};
							return Prefix + property + "." + subProperty;
						}
						return Prefix + attribute;
					}

				case BindingCustomType.SpriteRenderer:
					{
						if (attribute == 0)
						{
							return "m_Sprite";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

				case BindingCustomType.MonoBehaviour:
					{
						if (attribute == CrcUtils.CalculateDigestAscii("m_Enabled"))
						{
							return "m_Enabled";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

				case BindingCustomType.Light:
					{
						const string ColorR = "m_Color" + "." + "r";
						if (attribute == CrcUtils.CalculateDigestAscii(ColorR))
						{
							return ColorR;
						}
						const string ColorG = "m_Color" + "." + "g";
						if (attribute == CrcUtils.CalculateDigestAscii(ColorG))
						{
							return ColorG;
						}
						const string ColorB = "m_Color" + "." + "b";
						if (attribute == CrcUtils.CalculateDigestAscii(ColorB))
						{
							return ColorB;
						}
						const string ColorA = "m_Color" + "." + "a";
						if (attribute == CrcUtils.CalculateDigestAscii(ColorA))
						{
							return ColorA;
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_CookieSize"))
						{
							return "m_CookieSize";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_DrawHalo"))
						{
							return "m_DrawHalo";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_Intensity"))
						{
							return "m_Intensity";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_Range"))
						{
							return "m_Range";
						}
						const string ShadowsStrength = "m_Shadows" + "." + "m_Strength";
						if (attribute == CrcUtils.CalculateDigestAscii(ShadowsStrength))
						{
							return ShadowsStrength;
						}
						const string ShadowsBias = "m_Shadows" + "." + "m_Bias";
						if (attribute == CrcUtils.CalculateDigestAscii(ShadowsBias))
						{
							return ShadowsBias;
						}
						const string ShadowsNormalBias = "m_Shadows" + "." + "m_NormalBias";
						if (attribute == CrcUtils.CalculateDigestAscii(ShadowsNormalBias))
						{
							return ShadowsNormalBias;
						}
						const string ShadowsNearPlane = "m_Shadows" + "." + "m_NearPlane";
						if (attribute == CrcUtils.CalculateDigestAscii(ShadowsNearPlane))
						{
							return ShadowsNearPlane;
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_SpotAngle"))
						{
							return "m_SpotAngle";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_InnerSpotAngle"))
						{
							return "m_InnerSpotAngle";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_ColorTemperature"))
						{
							return "m_ColorTemperature";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

				case BindingCustomType.RendererShadows:
					{
						if (attribute == CrcUtils.CalculateDigestAscii("m_ReceiveShadows"))
						{
							return "m_ReceiveShadows";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_SortingOrder"))
						{
							return "m_SortingOrder";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.ParticleSystem:
					return "ParticleSystem_" + attribute;
				/*{
#warning TODO: ordinal propertyName
				}
				throw new ArgumentException($"Unknown attribute {attribute} for {_this}");*/

				case BindingCustomType.RectTransform:
					{
						string LocalPositionZ = "m_LocalPosition" + "." + "z";
						if (attribute == CrcUtils.CalculateDigestAscii(LocalPositionZ))
						{
							return LocalPositionZ;
						}
						string AnchoredPositionX = "m_AnchoredPosition" + "." + "x";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchoredPositionX))
						{
							return AnchoredPositionX;
						}
						string AnchoredPositionY = "m_AnchoredPosition" + "." + "y";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchoredPositionY))
						{
							return AnchoredPositionY;
						}
						string AnchorMinX = "m_AnchorMin" + "." + "x";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchorMinX))
						{
							return AnchorMinX;
						}
						string AnchorMinY = "m_AnchorMin" + "." + "y";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchorMinY))
						{
							return AnchorMinY;
						}
						string AnchorMaxX = "m_AnchorMax" + "." + "x";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchorMaxX))
						{
							return AnchorMaxX;
						}
						string AnchorMaxY = "m_AnchorMax" + "." + "y";
						if (attribute == CrcUtils.CalculateDigestAscii(AnchorMaxY))
						{
							return AnchorMaxY;
						}
						string SizeDeltaX = "m_SizeDelta" + "." + "x";
						if (attribute == CrcUtils.CalculateDigestAscii(SizeDeltaX))
						{
							return SizeDeltaX;
						}
						string SizeDeltaY = "m_SizeDelta" + "." + "y";
						if (attribute == CrcUtils.CalculateDigestAscii(SizeDeltaY))
						{
							return SizeDeltaY;
						}
						string PivotX = "m_Pivot" + "." + "x";
						if (attribute == CrcUtils.CalculateDigestAscii(PivotX))
						{
							return PivotX;
						}
						string PivotY = "m_Pivot" + "." + "y";
						if (attribute == CrcUtils.CalculateDigestAscii(PivotY))
						{
							return PivotY;
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.LineRenderer:
					{
						const string ParametersWidthMultiplier = "m_Parameters" + "." + "widthMultiplier";
						if (attribute == CrcUtils.CalculateDigestAscii(ParametersWidthMultiplier))
						{
							return ParametersWidthMultiplier;
						}
					}
#warning TODO: old versions animate all properties as custom curves
					return "LineRenderer_" + attribute;

#warning TODO:
				case BindingCustomType.TrailRenderer:
					{
						const string ParametersWidthMultiplier = "m_Parameters" + "." + "widthMultiplier";
						if (attribute == CrcUtils.CalculateDigestAscii(ParametersWidthMultiplier))
						{
							return ParametersWidthMultiplier;
						}
					}
#warning TODO: old versions animate all properties as custom curves
					return "TrailRenderer_" + attribute;

#warning TODO:
				case BindingCustomType.PositionConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_RestTranslation.x";
							case 1:
								return "m_RestTranslation.y";
							case 2:
								return "m_RestTranslation.z";
							case 3:
								return "m_Weight";
							case 4:
								return "m_TranslationOffset.x";
							case 5:
								return "m_TranslationOffset.y";
							case 6:
								return "m_TranslationOffset.z";
							case 7:
								return "m_AffectTranslationX";
							case 8:
								return "m_AffectTranslationY";
							case 9:
								return "m_AffectTranslationZ";
							case 10:
								return "m_Active";
							case 11:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 12:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.RotationConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_RestRotation.x";
							case 1:
								return "m_RestRotation.y";
							case 2:
								return "m_RestRotation.z";
							case 3:
								return "m_Weight";
							case 4:
								return "m_RotationOffset.x";
							case 5:
								return "m_RotationOffset.y";
							case 6:
								return "m_RotationOffset.z";
							case 7:
								return "m_AffectRotationX";
							case 8:
								return "m_AffectRotationY";
							case 9:
								return "m_AffectRotationZ";
							case 10:
								return "m_Active";
							case 11:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 12:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.ScaleConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_ScaleAtRest.x";
							case 1:
								return "m_ScaleAtRest.y";
							case 2:
								return "m_ScaleAtRest.z";
							case 3:
								return "m_Weight";
							case 4:
								return "m_ScalingOffset.x";
							case 5:
								return "m_ScalingOffset.y";
							case 6:
								return "m_ScalingOffset.z";
							case 7:
								return "m_AffectScalingX";
							case 8:
								return "m_AffectScalingY";
							case 9:
								return "m_AffectScalingZ";
							case 10:
								return "m_Active";
							case 11:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 12:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.AimConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_Weight";
							case 1:
								return "m_AffectRotationX";
							case 2:
								return "m_AffectRotationY";
							case 3:
								return "m_AffectRotationZ";
							case 4:
								return "m_Active";
							case 5:
								return "m_WorldUpObject";
							case 6:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 7:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.ParentConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_Weight";
							case 1:
								return "m_AffectTranslationX";
							case 2:
								return "m_AffectTranslationY";
							case 3:
								return "m_AffectTranslationZ";
							case 4:
								return "m_AffectRotationX";
							case 5:
								return "m_AffectRotationY";
							case 6:
								return "m_AffectRotationZ";
							case 7:
								return "m_Active";
							case 8:
								return $"m_TranslationOffsets.Array.data[{attribute >> 8}].x";
							case 9:
								return $"m_TranslationOffsets.Array.data[{attribute >> 8}].y";
							case 10:
								return $"m_TranslationOffsets.Array.data[{attribute >> 8}].z";
							case 11:
								return $"m_RotationOffsets.Array.data[{attribute >> 8}].x";
							case 12:
								return $"m_RotationOffsets.Array.data[{attribute >> 8}].y";
							case 13:
								return $"m_RotationOffsets.Array.data[{attribute >> 8}].z";
							case 14:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 15:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

#warning TODO:
				case BindingCustomType.LookAtConstraint:
					{
						uint property = attribute & 0xF;
						switch (property)
						{
							case 0:
								return "m_Weight";
							case 1:
								return "m_Active";
							case 2:
								return "m_WorldUpObject";
							case 3:
								return $"m_Sources.Array.data[{attribute >> 8}].sourceTransform";
							case 4:
								return $"m_Sources.Array.data[{attribute >> 8}].weight";
							case 5:
								return "m_Roll";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

				case BindingCustomType.Camera:
					{
						if (attribute == CrcUtils.CalculateDigestAscii("field of view"))
						{
							return "field of view";
						}
						if (attribute == CrcUtils.CalculateDigestAscii("m_FocalLength"))
						{
							return "m_FocalLength";
						}
					}
					throw new ArgumentException($"Unknown attribute {attribute} for {type}");

				case BindingCustomType.VisualEffect:
					return "VisualEffect_" + attribute;

				case BindingCustomType.ParticleForceField:
					return "ParticleForceField_" + attribute;

				case BindingCustomType.UserDefined:
					return "UserDefined_" + attribute;

				case BindingCustomType.MeshFilter:
					return "MeshFilter_" + attribute;

				default:
					throw new ArgumentException($"Binding type {type} not implemented", nameof(type));
			}
		}

		private IGameObject[] Roots
		{
			get
			{
				if (!m_rootInited)
				{
					m_roots = m_clip.FindRoots().ToArray();
					m_rootInited = true;
				}
				return m_roots;
			}
		}

		private readonly IAnimationClip m_clip;
		private IGameObject[] m_roots = Array.Empty<IGameObject>();
		private bool m_rootInited = false;
	}
}

```

`AssetRipperLibrary/Exporters/AnimatorControllers/AnimatorControllerExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1101;
using AssetRipper.SourceGenerated.Classes.ClassID_1102;
using AssetRipper.SourceGenerated.Classes.ClassID_1107;
using AssetRipper.SourceGenerated.Classes.ClassID_1109;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_206;
using AssetRipper.SourceGenerated.Classes.ClassID_207;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using AssetRipper.SourceGenerated.Subclasses.ChildMotion;
using AssetRipper.SourceGenerated.Subclasses.ControllerConstant;
using AssetRipper.SourceGenerated.Subclasses.OffsetPtr_StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorState_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorStateTransition_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_AnimatorTransition_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_MonoBehaviour_;
using AssetRipper.SourceGenerated.Subclasses.PPtr_State_;
using AssetRipper.SourceGenerated.Subclasses.StateConstant;
using AssetRipper.SourceGenerated.Subclasses.StateMachineConstant;
using AssetRipper.SourceGenerated.Subclasses.TransitionConstant;

namespace AssetRipper.Library.Exporters.AnimatorControllers
{
	public sealed class AnimatorControllerExportCollection : AssetsExportCollection
	{
		public AnimatorControllerExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IUnityObjectBase asset) : this(assetExporter, virtualFile, (IAnimatorController)asset) { }

		public AnimatorControllerExportCollection(IAssetExporter assetExporter, VirtualSerializedFile virtualFile, IAnimatorController asset) : base(assetExporter, asset)
		{
			IControllerConstant controller = asset.Controller_C91;
			AccessListBase<IOffsetPtr_StateMachineConstant> stateMachinesConst = controller.StateMachineArray;
			StateMachines = new IAnimatorStateMachine[stateMachinesConst.Count];
			for (int i = 0; i < stateMachinesConst.Count; i++)
			{
				IAnimatorStateMachine stateMachine = VirtualAnimationFactory.CreateAnimatorStateMachine(virtualFile, asset, i);
				StateMachines[i] = stateMachine;
			}

			for (int i = 0; i < StateMachines.Length; i++)
			{
				IAnimatorStateMachine stateMachine = StateMachines[i];
				IStateMachineConstant stateMachineConstant = asset.Controller_C91.StateMachineArray[i].Data;
				AddAsset(stateMachine);
				if (stateMachine.Has_StateMachineBehaviours_C1107())
				{
					AddBehaviours(asset, stateMachine.StateMachineBehaviours_C1107);
				}

				if (stateMachine.Has_AnyStateTransitions_C1107())
				{
					foreach (PPtr_AnimatorStateTransition_ transitionPtr in stateMachine.AnyStateTransitions_C1107)
					{
						IAnimatorStateTransition transition = transitionPtr.GetAsset(virtualFile);
						AddAsset(transition);
					}
				}
				if (stateMachine.Has_EntryTransitions_C1107())
				{
					foreach (PPtr_AnimatorTransition_ transitionPtr in stateMachine.EntryTransitions_C1107)
					{
						IAnimatorTransition transition = transitionPtr.GetAsset(virtualFile);
						AddAsset(transition);
					}
				}

				if (stateMachine.Has_ChildStates_C1107())
				{
					for (int j = 0; j < stateMachine.ChildStates_C1107.Count; j++)
					{
						PPtr_AnimatorState_ statePtr = stateMachine.ChildStates_C1107[j].State;
						IAnimatorState state = statePtr.GetAsset(virtualFile);
						IStateConstant stateConstant = stateMachineConstant.StateConstantArray[j].Data;
						AddAsset(state);
						if (state.Has_StateMachineBehaviours_C1102())
						{
							AddBehaviours(asset, state.StateMachineBehaviours_C1102);
						}

						if (state.Has_Motion_C1102() && state.Motion_C1102.IsVirtual())
						{
							Motion motion = state.Motion_C1102.GetAsset(virtualFile);
							AddBlendTree(virtualFile, (IBlendTree)motion);
						}

						if (state.Has_Transitions_C1102())
						{
							for (int k = 0; k < state.Transitions_C1102.Count; k++)
							{
								PPtr_AnimatorStateTransition_ transitionPtr = state.Transitions_C1102[k];
								IAnimatorStateTransition transition = transitionPtr.GetAsset(virtualFile);
								ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[k].Data;

								AddAsset(transition);
							}
						}
					}
				}
				else if (stateMachine.Has_States_C1107())
				{
					for (int j = 0; j < stateMachine.States_C1107.Count; j++)
					{
						PPtr_State_ statePtr = stateMachine.States_C1107[j];
						IAnimatorState state = statePtr.GetAsset(virtualFile);
						IStateConstant stateConstant = stateMachineConstant.StateConstantArray[j].Data;
						AddAsset(state);
						if (state.Has_StateMachineBehaviours_C1102())
						{
							AddBehaviours(asset, state.StateMachineBehaviours_C1102);
						}

						if (state.Has_Motion_C1102() && state.Motion_C1102.IsVirtual())
						{
							Motion motion = state.Motion_C1102.GetAsset(virtualFile);
							AddBlendTree(virtualFile, (IBlendTree)motion);
						}

						if (state.Has_Transitions_C1102())
						{
							for (int k = 0; k < state.Transitions_C1102.Count; k++)
							{
								PPtr_AnimatorStateTransition_ transitionPtr = state.Transitions_C1102[k];
								IAnimatorStateTransition transition = transitionPtr.GetAsset(virtualFile);
								ITransitionConstant transitionConstant = stateConstant.TransitionConstantArray[k].Data;

								AddAsset(transition);
							}
						}
					}
				}
			}
		}

		private void AddBlendTree(VirtualSerializedFile virtualFile, IBlendTree blendTree)
		{
			AddAsset(blendTree);
			foreach (IChildMotion childMotion in blendTree.Childs_C206)
			{
				if (childMotion.Motion.IsVirtual())
				{
					Motion motion = childMotion.Motion.GetAsset(virtualFile);
					AddBlendTree(virtualFile, (IBlendTree)motion);
				}
			}
		}

		private void AddBehaviours(IAnimatorController asset, AssetList<PPtr_MonoBehaviour__5_0_0_f4> behaviours)
		{
			foreach (PPtr_MonoBehaviour__5_0_0_f4 pbehaviour in behaviours)
			{
				IMonoBehaviour? behaviour = pbehaviour.FindAsset(asset.SerializedFile);
				if (behaviour != null)
				{
#warning HACK: skip duplicates. remove it when AnimatorStateMachine's child StateMachines has been implemented
					if (!m_exportIDs.ContainsKey(behaviour.AssetInfo))
					{
						AddAsset(behaviour);
					}
				}
			}
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			Process((IAnimatorController)Asset);
			return base.ExportInner(container, filePath, dirPath);
		}

		private void Process(IAnimatorController controller)
		{
			controller.AnimatorParameters_C91.Clear();
			controller.AnimatorParameters_C91.Capacity = controller.Controller_C91.Values.Data.ValueArray.Count;
			for (int i = 0; i < controller.Controller_C91.Values.Data.ValueArray.Count; i++)
			{
				controller.AnimatorParameters_C91.AddNew().Initialize(controller, i);
			}

			controller.AnimatorLayers_C91.Clear();
			controller.AnimatorLayers_C91.Capacity = controller.Controller_C91.LayerArray.Count;
			for (int i = 0; i < controller.Controller_C91.LayerArray.Count; i++)
			{
				uint stateMachineIndex = controller.Controller_C91.LayerArray[i].Data.StateMachineIndex;
				IAnimatorStateMachine stateMachine = StateMachines[stateMachineIndex];
				controller.AnimatorLayers_C91.AddNew().Initialize(stateMachine, controller, i);
			}
		}

		public IAnimatorStateMachine[] StateMachines { get; set; }
	}
}

```

`AssetRipperLibrary/Exporters/AnimatorControllers/AnimatorControllerExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_91;

namespace AssetRipper.Library.Exporters.AnimatorControllers
{
	public sealed class AnimatorControllerExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAnimatorController;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AnimatorControllerExportCollection(this, virtualFile, asset);
		}
	}
}

```

`AssetRipperLibrary/Exporters/AnimatorControllers/Editor/StreamedCurveKey.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.SourceGenerated.Subclasses.AnimationCurve_float;
using AssetRipper.SourceGenerated.Subclasses.Keyframe_float;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.AnimatorControllers.Editor
{
	public sealed class StreamedCurveKey : IAssetReadable
	{
		public StreamedCurveKey() { }
		public StreamedCurveKey(int index, float value, IVector3f coefs)
		{
			Index = index;
			Value = value;
			Coefficient = coefs;
		}

		public static StreamedCurveKey CalculateStreamedFrame(IAnimationCurve_float curve, int lhsIndex, int rhsIndex, float timeOffset)
		{
			IReadOnlyList<IKeyframe_float> keyframes = curve.Curve;
			IKeyframe_float lhs = keyframes[lhsIndex];
			int curveKeyIndex = lhsIndex;
			IKeyframe_float rhs = keyframes[rhsIndex];
			float frameTime = lhs.Time + timeOffset;
			//TimeEnd = rhs.Time + timeOffset;
			float deltaTime = rhs.Time - lhs.Time;
			if (deltaTime < 0.00009999999747378752)
			{
				deltaTime = 0.000099999997f;
			}
			float deltaValue = rhs.Value - lhs.Value;
			float inverseTime = 1.0f / (deltaTime * deltaTime);
			float outTangent = lhs.OutSlope * deltaTime;
			float inTangent = rhs.InSlope * deltaTime;
			float curveKeyCoefX = (inTangent + outTangent - deltaValue - deltaValue) * inverseTime / deltaTime;
			float curveKeyCoefY = inverseTime * (deltaValue + deltaValue + deltaValue - outTangent - outTangent - inTangent);
			float curveKeyCoefZ = lhs.OutSlope;
			float curveKeyValue = lhs.Value;
			if (lhs.OutSlope == float.PositiveInfinity || rhs.InSlope == float.PositiveInfinity)
			{
				curveKeyCoefX = 0.0f;
				curveKeyCoefY = 0.0f;
				curveKeyCoefZ = 0.0f;
				curveKeyValue = lhs.Value;
			}
			Vector3f curveKeyCoef = new Vector3f(curveKeyCoefX, curveKeyCoefY, curveKeyCoefZ);
			StreamedCurveKey curveKey = new StreamedCurveKey(curveKeyIndex, curveKeyValue, curveKeyCoef);
			return curveKey;
		}

		public void Read(AssetReader reader)
		{
			Index = reader.ReadInt32();
			Coefficient.Read(reader);
			Value = reader.ReadSingle();
		}

		/// <summary>
		/// Calculate value between two KeyframeTpl Float at given time
		/// </summary>
		/// <param name="deltaTimeFraction">(time - leftTime) / (rightTime - leftTime)</param>
		/// <param name="leftVaue">lhs.Value</param>
		/// <param name="outTangent">lhs.OutSlope * (rightTime - leftTime)</param>
		/// <param name="rightValue">rhs.Value</param>
		/// <param name="inTangent">rhs.OutSlope * (rightTime - leftTime)</param>
		/// <returns>Value between two keyframes</returns>
		public static float HermiteInterpolate(float deltaTimeFraction, float leftVaue, float outTangent, float rightValue, float inTangent)
		{
			float tt = deltaTimeFraction * deltaTimeFraction;
			float ttt = tt * deltaTimeFraction;
			float tttx2 = ttt * 2.0f;
			float ttx3 = tt * 3.0f;
			float v1 = deltaTimeFraction + ttt - 2.0f * tt * outTangent + (tttx2 - ttx3 + 1.0f) * leftVaue;
			float v2 = (ttt - tt) * inTangent;
			float v3 = ttx3 - tttx2;
			return v1 + v2 + v3 * rightValue;
		}

		public float CalculateNextInSlope(float deltaTime, float nextValue)
		{
			if (deltaTime >= 3.40282347e38f)
			{
				return 0;
			}
			if (deltaTime < 0.00009999999747378752)
			{
				deltaTime = 0.000099999997f;
			}
			float deltaValue = nextValue - Value;
			float inverseTime = 1.0f / (deltaTime * deltaTime);
			float outTangent = OutSlope * deltaTime;
			float inTangent = deltaValue + deltaValue + deltaValue - outTangent - outTangent - Coefficient.Y / inverseTime;
			return inTangent / deltaTime;
		}

		public float OutSlope => Coefficient.Z;

		public int Index { get; set; }
		public float Value { get; set; }
		public IVector3f Coefficient { get; set; } = new Vector3f();
	}
}

```

`AssetRipperLibrary/Exporters/AnimatorControllers/Editor/StreamedFrame.cs`:

```cs
using AssetRipper.Core.IO.Asset;

namespace AssetRipper.Library.Exporters.AnimatorControllers.Editor
{
	public sealed class StreamedFrame : IAssetReadable
	{
		public void Read(AssetReader reader)
		{
			Time = reader.ReadSingle();
			Curves = reader.ReadAssetArray<StreamedCurveKey>();
		}

		public float Time { get; set; }
		public StreamedCurveKey[] Curves { get; set; } = Array.Empty<StreamedCurveKey>();
	}
}

```

`AssetRipperLibrary/Exporters/Audio/AudioClipDecoder.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using Fmod5Sharp;
using Fmod5Sharp.FmodTypes;
using Fmod5Sharp.Util;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;

namespace AssetRipper.Library.Exporters.Audio
{
	public static class AudioClipDecoder
	{
		/// <summary>
		/// Size of the magic number currently
		/// </summary>
		private const int MinimumFsbSize = 4;

		public static bool CanDecode(IAudioClip audioClip)
		{
			byte[] rawData = audioClip.GetAudioData();
			if (!IsDataUsable(rawData))
			{
				return false;
			}

			FmodAudioType audioType = GetAudioType(rawData);
			if (FmodAudioTypeExtensions.IsSupported(audioType))
			{
				return true;
			}
			else
			{
				Logger.Info(LogCategory.Export, $"Can't decode audio clip '{audioClip.NameString}' with default decoder because it's '{audioType}' encoded.");
				return false;
			}
		}

		public static bool TryGetDecodedAudioClipData(IAudioClip audioClip, [NotNullWhen(true)] out byte[]? decodedData, [NotNullWhen(true)] out string? fileExtension)
		{
			return TryGetDecodedAudioClipData(audioClip?.GetAudioData(), out decodedData, out fileExtension);
		}
		public static bool TryGetDecodedAudioClipData([NotNullWhen(true)] byte[]? rawData, [NotNullWhen(true)] out byte[]? decodedData, [NotNullWhen(true)] out string? fileExtension)
		{
			decodedData = null;
			fileExtension = null;

			if (!IsDataUsable(rawData))
			{
				return false;
			}

			FmodSoundBank fsbData = FsbLoader.LoadFsbFromByteArray(rawData);

			FmodAudioType audioType = fsbData.Header.AudioType;
			try
			{
				if (audioType.IsSupported() && fsbData.Samples.Single().RebuildAsStandardFileFormat(out decodedData, out fileExtension))
				{
					return true;
				}
				else
				{
					return false;
				}
			}
			catch (Exception ex)
			{
				Logger.Error(LogCategory.Export, $"Failed to convert audio ({Enum.GetName(audioType)})", ex);
				return false;
			}
		}

		/// <summary>
		/// Decodes WAV data from an AudioClip
		/// </summary>
		/// <param name="audioClip">The audio clip to extract the data from</param>
		/// <param name="decodedData">The decoded data in the wav audio format</param>
		/// <returns>True if the audio could be exported in the wav format</returns>
		public static bool TryGetDecodedWavData(IAudioClip audioClip, [NotNullWhen(true)] out byte[]? decodedData)
		{
			return TryGetDecodedWavData(audioClip?.GetAudioData(), out decodedData);
		}
		/// <summary>
		/// Decodes WAV data from FSB data
		/// </summary>
		/// <param name="fsbData">The data from an FSB file</param>
		/// <param name="decodedData">The decoded data in the wav audio format</param>
		/// <returns>True if the audio could be exported in the wav format</returns>
		public static bool TryGetDecodedWavData([NotNullWhen(true)] byte[]? fsbData, [NotNullWhen(true)] out byte[]? decodedData)
		{
			if (TryGetDecodedAudioClipData(fsbData, out decodedData, out string? fileExtension))
			{
				if (fileExtension == "ogg")
				{
					decodedData = AudioConverter.OggToWav(decodedData);
					return true;
				}
				else
				{
					return fileExtension == "wav";
				}
			}
			else
			{
				decodedData = null;
				return false;
			}
		}

		public static FmodAudioType GetAudioType(byte[]? rawData)
		{
			if (!IsDataUsable(rawData))
			{
				return FmodAudioType.NONE;
			}

			using MemoryStream input = new MemoryStream(rawData);
			using BinaryReader reader = new BinaryReader(input);
			try
			{
				return new FmodAudioHeader(reader).AudioType;
			}
			catch (Exception ex)
			{
				Logger.Warning($"An exception was thrown while attempting to determine the audio type:{Environment.NewLine}{ex.Message}");
				return FmodAudioType.NONE;
			}
		}

		public static string GetFileExtension(IAudioClip audioClip) => GetFileExtension(audioClip.GetAudioData()?.ToArray());
		public static string GetFileExtension(byte[]? rawData)
		{
			FmodAudioType audioType = GetAudioType(rawData);
			return audioType.FileExtension() ?? throw new Exception($"No extension for {audioType}");
		}

		/// <summary>
		/// Not null and at least the minimum size
		/// </summary>
		private static bool IsDataUsable([NotNullWhen(true)] byte[]? data) => data is not null && data.Length >= MinimumFsbSize;
	}
}

```

`AssetRipperLibrary/Exporters/Audio/AudioClipExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Library.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Library.Exporters.Audio
{
	public sealed class AudioClipExportCollection : AssetExportCollection
	{
		public AudioClipExportCollection(AudioClipExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			string defaultExtension = AudioClipDecoder.GetFileExtension((IAudioClip)asset);
			if (IsWavExtension((AudioClipExporter)AssetExporter, defaultExtension))
			{
				return "wav";
			}
			else
			{
				return defaultExtension;
			}
		}

		private static bool IsWavExtension(AudioClipExporter assetExporter, string defaultExtension)
		{
			return assetExporter.AudioFormat == AudioExportFormat.PreferWav 
				&& defaultExtension == "ogg";
		}
	}
}

```

`AssetRipperLibrary/Exporters/Audio/AudioClipExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Library.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using System.IO;

namespace AssetRipper.Library.Exporters.Audio
{
	public sealed class AudioClipExporter : BinaryAssetExporter
	{
		public AudioExportFormat AudioFormat { get; }
		public AudioClipExporter(LibraryConfiguration configuration) => AudioFormat = configuration.AudioExportFormat;

		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAudioClip audio && AudioClipDecoder.CanDecode(audio);
		}

		public static bool IsSupportedExportFormat(AudioExportFormat format) => format switch
		{
			AudioExportFormat.Default or AudioExportFormat.PreferWav => true,
			_ => false,
		};

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AudioClipExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			if (!AudioClipDecoder.TryGetDecodedAudioClipData((IAudioClip)asset, out byte[]? decodedData, out string? fileExtension))
			{
				return false;
			}

			if (AudioFormat == AudioExportFormat.PreferWav && fileExtension == "ogg")
			{
				decodedData = AudioConverter.OggToWav(decodedData);
			}

			if (decodedData.IsNullOrEmpty())
			{
				return false;
			}

			TaskManager.AddTask(File.WriteAllBytesAsync(path, decodedData));
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Audio/AudioConverter.cs`:

```cs
using AssetRipper.Core.Logging;
using NAudio.Vorbis;
using NAudio.Wave;
using System.IO;

namespace AssetRipper.Library.Exporters.Audio
{
	public static class AudioConverter
	{
		public static byte[] OggToWav(byte[] oggData)
		{
			if (oggData == null)
			{
				throw new ArgumentNullException(nameof(oggData));
			}

			if (oggData.Length == 0)
			{
				return Array.Empty<byte>();
			}

			try
			{
				using VorbisWaveReader vorbisStream = new VorbisWaveReader(new MemoryStream(oggData), true);
				using MemoryStream writeStream = new MemoryStream();
				WaveFileWriter.WriteWavFileToStream(writeStream, vorbisStream);
				return writeStream.ToArray();
			}
			catch (Exception ex)
			{
				Logger.Error(LogCategory.Export, "Failed to convert audio from OGG to WAV", ex);
				return Array.Empty<byte>();
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Audio/NativeAudioExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.AudioClip;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Library.Exporters.Audio
{
	public sealed class NativeAudioExportCollection : AssetExportCollection
	{
		public NativeAudioExportCollection(NativeAudioExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			IAudioClip audioClip = (IAudioClip)asset;
			if (audioClip.Has_Type_C83())
			{
				return audioClip.GetSoundType().ToRawExtension();
			}
			else
			{
				return audioClip.GetCompressionFormat().ToRawExtension();
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Audio/NativeAudioExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using System.IO;

namespace AssetRipper.Library.Exporters.Audio
{
	public class NativeAudioExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAudioClip;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new NativeAudioExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			IAudioClip audioClip = (IAudioClip)asset;

			byte[] data = audioClip.GetAudioData();
			if (data.IsNullOrEmpty())
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{audioClip.GetNameNotEmpty()}' because no valid data was found");
				return false;
			}
			else
			{
				TaskManager.AddTask(File.WriteAllBytesAsync(path, data));
				return true;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Audio/YamlAudioExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Subclasses.StreamedResource;

namespace AssetRipper.Library.Exporters.Audio
{
	public sealed class YamlAudioExportCollection : AssetExportCollection
	{
		public YamlAudioExportCollection(IAssetExporter assetExporter, IAudioClip asset) : base(assetExporter, asset)
		{
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			IAudioClip asset = (IAudioClip)Asset;
			IStreamedResource? resource = asset.Resource_C83;
			if (resource is not null)
			{
				byte[] originalSource = resource.Source.Data;
				ulong originalOffset = resource.Offset;
				ulong originalSize = resource.Size;
				if (resource.TryGetContent(asset.SerializedFile, out byte[]? data))
				{
					string resPath = filePath + ".resS";
					System.IO.File.WriteAllBytes(resPath, data);
					resource.Source.String = System.IO.Path.GetRelativePath(dirPath, resPath);
				}
				else
				{
					resource.Source.Data = Array.Empty<byte>();
					resource.Offset = 0;
					resource.Size = 0;
				}
				bool result = base.ExportInner(container, filePath, dirPath);
				resource.Source.Data = originalSource;
				resource.Offset = originalOffset;
				resource.Size = originalSize;
				return result;
			}
			else
			{
				return base.ExportInner(container, filePath, dirPath);
			}
		}

		protected override string GetExportExtension(IUnityObjectBase asset) => "audioclip";
	}
}

```

`AssetRipperLibrary/Exporters/Audio/YamlAudioExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_83;

namespace AssetRipper.Library.Exporters.Audio
{
	public sealed class YamlAudioExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IAudioClip;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new YamlAudioExportCollection(this, (IAudioClip)asset);
		}
	}
}

```

`AssetRipperLibrary/Exporters/IPostExporter.cs`:

```cs
namespace AssetRipper.Library.Exporters
{
	public interface IPostExporter
	{
		void DoPostExport(Ripper ripper);
	}
}

```

`AssetRipperLibrary/Exporters/Meshes/GlbMeshExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Library.Exporters.Meshes
{
	public sealed class GlbMeshExportCollection : AssetExportCollection
	{
		public GlbMeshExportCollection(GlbMeshExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset) => "glb";
	}
}

```

`AssetRipperLibrary/Exporters/Meshes/GlbMeshExporter.cs`:

```cs
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Library.Configuration;
using SharpGLTF.Geometry;
using SharpGLTF.Geometry.VertexTypes;
using SharpGLTF.Materials;
using SharpGLTF.Scenes;
using System.IO;

namespace AssetRipper.Library.Exporters.Meshes
{
	public sealed class GlbMeshExporter : BinaryAssetExporter
	{
		private MeshExportFormat ExportFormat { get; set; }
		public GlbMeshExporter(LibraryConfiguration configuration) : base() => ExportFormat = configuration.MeshExportFormat;

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new GlbMeshExportCollection(this, asset);
		}

		public override bool IsHandle(IUnityObjectBase asset)
		{
			if (asset is Mesh mesh)
			{
				return IsHandle(mesh);
			}
			else
			{
				return false;
			}
		}

		public bool IsHandle(Mesh mesh)
		{
			return ExportFormat == MeshExportFormat.GlbPrimitive &&
				mesh.Vertices != null &&
				mesh.Vertices.Length > 0 &&
				mesh.Indices != null &&
				mesh.Indices.Count > 0 &&
				mesh.Indices.Count % 3 == 0;
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			byte[] data = ExportBinary((Mesh)asset);
			if (data == null || data.Length == 0)
			{
				return false;
			}

			using FileStream fileStream = File.Create(path);
			fileStream.Write(data);
			return true;
		}

		private byte[] ExportBinary(Mesh mesh)
		{
			bool hasNormals = mesh.Normals != null && mesh.Normals.Length == mesh.Vertices.Length;
			bool hasTangents = hasNormals && mesh.Tangents != null && mesh.Tangents.Length == mesh.Vertices.Length;
			bool hasUV0 = mesh.UV0 != null && mesh.UV0.Length == mesh.Vertices.Length;
			bool hasUV1 = hasUV0 && mesh.UV1 != null && mesh.UV1.Length == mesh.Vertices.Length;

			SceneBuilder? sceneBuilder = new SceneBuilder();
			MaterialBuilder? material = new MaterialBuilder("material");

			if (hasTangents)
			{
				if (hasUV1)
				{
					AddMeshToScene<VertexPositionNormalTangent, VertexTexture2>(mesh, sceneBuilder, material);
				}
				else if (hasUV0)
				{
					AddMeshToScene<VertexPositionNormalTangent, VertexTexture1>(mesh, sceneBuilder, material);
				}
				else
				{
					AddMeshToScene<VertexPositionNormalTangent, VertexEmpty>(mesh, sceneBuilder, material);
				}
			}
			else if (hasNormals)
			{
				if (hasUV1)
				{
					AddMeshToScene<VertexPositionNormal, VertexTexture2>(mesh, sceneBuilder, material);
				}
				else if (hasUV0)
				{
					AddMeshToScene<VertexPositionNormal, VertexTexture1>(mesh, sceneBuilder, material);
				}
				else
				{
					AddMeshToScene<VertexPositionNormal, VertexEmpty>(mesh, sceneBuilder, material);
				}
			}
			else
			{
				if (hasUV1)
				{
					AddMeshToScene<VertexPosition, VertexTexture2>(mesh, sceneBuilder, material);
				}
				else if (hasUV0)
				{
					AddMeshToScene<VertexPosition, VertexTexture1>(mesh, sceneBuilder, material);
				}
				else
				{
					AddMeshToScene<VertexPosition, VertexEmpty>(mesh, sceneBuilder, material);
				}
			}

			SharpGLTF.Schema2.ModelRoot? model = sceneBuilder.ToGltf2();

			//Write settings can be used in the write glb method if desired
			//var writeSettings = new SharpGLTF.Schema2.WriteSettings();

			return model.WriteGLB().ToArray();
		}

		private static void AddMeshToScene<TvG, TvM>(Mesh mesh, SceneBuilder sceneBuilder, MaterialBuilder material) where TvG : struct, IVertexGeometry where TvM : struct, IVertexMaterial
		{
			MeshBuilder<TvG, TvM, VertexEmpty>? meshBuilder = VertexBuilder<TvG, TvM, VertexEmpty>.CreateCompatibleMesh(mesh.NameString);
			PrimitiveBuilder<MaterialBuilder, TvG, TvM, VertexEmpty>? primitiveBuilder = meshBuilder.UsePrimitive(material);
			for (int j = 0; j < mesh.Indices.Count; j += 3)
			{
				primitiveBuilder.AddTriangle(GetVertex<TvG, TvM>(mesh, mesh.Indices[j]), GetVertex<TvG, TvM>(mesh, mesh.Indices[j + 1]), GetVertex<TvG, TvM>(mesh, mesh.Indices[j + 2]));
			}
			sceneBuilder.AddRigidMesh(meshBuilder, System.Numerics.Matrix4x4.Identity);
		}

		private static VertexBuilder<TvG, TvM, VertexEmpty> GetVertex<TvG, TvM>(Mesh mesh, uint index) where TvG : struct, IVertexGeometry where TvM : struct, IVertexMaterial
		{
			IVertexGeometry geometry;
			if (typeof(TvG) == typeof(VertexPosition))
			{
				geometry = new VertexPosition(mesh.Vertices[index]);
			}
			else if (typeof(TvG) == typeof(VertexPositionNormal))
			{
				geometry = new VertexPositionNormal(mesh.Vertices[index], mesh.Normals[index]);
			}
			else if (typeof(TvG) == typeof(VertexPositionNormalTangent))
			{
				geometry = new VertexPositionNormalTangent(mesh.Vertices[index], mesh.Normals[index], mesh.Tangents[index]);
			}
			else
			{
				geometry = default(TvG);
			}

			IVertexMaterial material;
			if (typeof(TvM) == typeof(VertexTexture1))
			{
				material = new VertexTexture1(mesh.UV0[index]);
			}
			else if (typeof(TvM) == typeof(VertexTexture2))
			{
				material = new VertexTexture2(mesh.UV0[index], mesh.UV1[index]);
			}
			else
			{
				material = default(TvM);
			}

			return new VertexBuilder<TvG, TvM, VertexEmpty>((TvG)geometry, (TvM)material);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Meshes/UnifiedMeshExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Library.Configuration;

namespace AssetRipper.Library.Exporters.Meshes
{
	public sealed class UnifiedMeshExportCollection : AssetExportCollection
	{
		public UnifiedMeshExportCollection(UnifiedMeshExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return ((UnifiedMeshExporter)AssetExporter).ExportFormat.GetFileExtension();
		}
	}
}

```

`AssetRipperLibrary/Exporters/Meshes/UnifiedMeshExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Classes.Mesh;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Library.Configuration;
using MeshSharp;
using MeshSharp.Elements;
using MeshSharp.Elements.Geometries.Layers;
using MeshSharp.FBX;
using MeshSharp.OBJ;
using MeshSharp.PLY;
using MeshSharp.STL;
using System.IO;
using System.Linq;

namespace AssetRipper.Library.Exporters.Meshes
{
	public sealed class UnifiedMeshExporter : BinaryAssetExporter
	{
		public MeshExportFormat ExportFormat { get; }
		public MeshCoordinateSpace ExportSpace { get; }
		public UnifiedMeshExporter(LibraryConfiguration configuration)
		{
			ExportFormat = configuration.MeshExportFormat;
			ExportSpace = configuration.MeshCoordinateSpace;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new UnifiedMeshExportCollection(this, asset);
		}

		public override bool IsHandle(IUnityObjectBase asset)
		{
			if (asset is Mesh mesh)
			{
				return IsSupported(ExportFormat) && HasValidMeshData(mesh);
			}
			else
			{
				return false;
			}
		}

		public static bool HasValidMeshData(Mesh mesh)
		{
			return mesh != null &&
				mesh.Vertices != null &&
				mesh.Vertices.Length > 0 &&
				mesh.Indices != null &&
				mesh.Indices.Count > 0 &&
				mesh.Indices.Count % 3 == 0 &&
				IsNotLinesOrPoints(mesh);
		}

		private static bool IsNotLinesOrPoints(Mesh mesh)
		{
			if (mesh.SerializedFile.Version.IsLess(4))
			{
				return true;
			}

			foreach (SubMesh? submesh in mesh.SubMeshes)
			{
				switch (submesh.Topology)
				{
					case MeshTopology.Lines:
					case MeshTopology.LineStrip:
					case MeshTopology.Points:
						return false;
				}
			}
			return true;
		}

		public static bool IsSupported(MeshExportFormat format) => format switch
		{
			MeshExportFormat.FbxPrimitive => true,
			MeshExportFormat.StlBinary => true,
			MeshExportFormat.StlAscii => true,
			MeshExportFormat.Obj => true,
			MeshExportFormat.PlyAscii => true,
			_ => false,
		};

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			byte[] data = ExportBinary((Mesh)asset);
			if (data == null || data.Length == 0)
			{
				return false;
			}

			TaskManager.AddTask(File.WriteAllBytesAsync(path, data));
			return true;
		}

		private byte[] ExportBinary(Mesh mesh)
		{
			Scene scene = ConvertToScene(mesh);
			using MemoryStream memoryStream = new MemoryStream();
			switch (ExportFormat)
			{
				case MeshExportFormat.FbxPrimitive:
					FbxWriter.WriteAscii(memoryStream, scene, FbxVersion.v7400);
					break;
				case MeshExportFormat.StlBinary:
					StlWriter.WriteBinary(memoryStream, scene);
					break;
				case MeshExportFormat.StlAscii:
					StlWriter.WriteAscii(memoryStream, scene);
					break;
				case MeshExportFormat.Obj:
					ObjWriter.Write(memoryStream, scene);
					break;
				case MeshExportFormat.PlyAscii:
					PlyWriter.WriteAscii(memoryStream, scene);
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(ExportFormat));
			}
			return memoryStream.ToArray();
		}

		private Scene ConvertToScene(Mesh unityMesh)
		{
			MeshSharp.Elements.Geometries.Mesh? outputMesh = ConvertToMeshSharpMesh(unityMesh);
			Scene scene = new Scene();
			scene.Name = unityMesh.NameString;
			Node node = new Node();
			node.Name = unityMesh.NameString;
			node.Children.Add(outputMesh);
			scene.Nodes.Add(node);
			return scene;
		}

		private MeshSharp.Elements.Geometries.Mesh ConvertToMeshSharpMesh(Mesh unityMesh)
		{
			bool hasVertexNormals = unityMesh.Normals != null && unityMesh.Normals.Length == unityMesh.Vertices.Length;
			bool hasTangents = unityMesh.Tangents != null && unityMesh.Tangents.Length == unityMesh.Vertices.Length;
			bool hasUV0 = unityMesh.UV0 != null && unityMesh.UV0.Length == unityMesh.Vertices.Length;
			bool hasUV1 = unityMesh.UV1 != null && unityMesh.UV1.Length == unityMesh.Vertices.Length;
			bool hasColors = unityMesh.Colors != null && unityMesh.Colors.Length == unityMesh.Vertices.Length;
			//Logger.Info($"VertexNormals: {hasVertexNormals}");
			//Logger.Info($"Tangents: {hasTangents}");
			//Logger.Info($"UV 0: {hasUV0}");
			//Logger.Info($"UV 1: {hasUV1}");
			//Logger.Info($"Colors: {hasColors}");
			MeshSharp.Elements.Geometries.Mesh? outputMesh = new MeshSharp.Elements.Geometries.Mesh();
			outputMesh.Name = unityMesh.NameString;

			//Vertices
			foreach (Vector3f? vertex in unityMesh.Vertices)
			{
				outputMesh.Vertices.Add(Convert(ToCoordinateSpace(vertex, ExportSpace)));
			}

			//Polygons
			for (int i = 0; i + 2 < unityMesh.Indices.Count; i += 3)
			{
				if (ExportSpace == MeshCoordinateSpace.Right) //Switching to a right handed coordinate system requires reversing the polygon vertex order
				{
					outputMesh.Polygons.Add(new Triangle(unityMesh.Indices[i + 2], unityMesh.Indices[i + 1], unityMesh.Indices[i]));
				}
				else
				{
					outputMesh.Polygons.Add(new Triangle(unityMesh.Indices[i], unityMesh.Indices[i + 1], unityMesh.Indices[i + 2]));
				}
			}

			//Normals
			LayerElementNormal? normalElement = new LayerElementNormal(outputMesh);
			outputMesh.Layers.Add(normalElement);
			if (hasVertexNormals)
			{
				normalElement.MappingInformationType = MappingMode.ByPolygonVertex;
				normalElement.ReferenceInformationType = ReferenceMode.Direct;
				foreach (Polygon? polygon in outputMesh.Polygons)
				{
					foreach (uint index in polygon.Indices)
					{
						normalElement.Normals.Add(Convert(ToCoordinateSpace(unityMesh.Normals[index], ExportSpace)));
					}
				}
			}
			else if (ExportFormat.IsSTL())
			{
				normalElement.CalculateFlatNormals();
			}
			else
			{
				normalElement.CalculateVertexNormals();
			}

			//Tangents
			if (hasTangents)
			{
				LayerElementTangent? tangentElement = new MeshSharp.Elements.Geometries.Layers.LayerElementTangent(outputMesh);
				outputMesh.Layers.Add(tangentElement);
				tangentElement.MappingInformationType = MappingMode.ByPolygonVertex;
				tangentElement.ReferenceInformationType = ReferenceMode.Direct;
				tangentElement.Tangents.AddRange(unityMesh.Tangents.Select(t => Convert(ToCoordinateSpace((Vector3f)t, ExportSpace))));
				//We're excluding W here because it's not supported by MeshSharp
				//For Unity, the tangent W coordinate denotes the direction of the binormal vector and is always 1 or -1
				//https://docs.unity3d.com/ScriptReference/Mesh-tangents.html
			}

			//UV
			if (hasUV0)
			{
				LayerElementUV? uv0Element = new MeshSharp.Elements.Geometries.Layers.LayerElementUV(outputMesh);
				outputMesh.Layers.Add(uv0Element);
				uv0Element.MappingInformationType = MappingMode.ByPolygonVertex;
				uv0Element.ReferenceInformationType = ReferenceMode.IndexToDirect;
				uv0Element.UV.AddRange(unityMesh.UV0.Select(v => Convert(v)));
				uv0Element.UVIndex.AddRange(Enumerable.Range(0, unityMesh.UV0.Length));
			}
			if (hasUV1)
			{
				LayerElementUV? uv1Element = new MeshSharp.Elements.Geometries.Layers.LayerElementUV(outputMesh);
				outputMesh.Layers.Add(uv1Element);
				uv1Element.MappingInformationType = MappingMode.ByPolygonVertex;
				uv1Element.ReferenceInformationType = ReferenceMode.IndexToDirect;
				uv1Element.UV.AddRange(unityMesh.UV1.Select(v => Convert(v)));
				uv1Element.UVIndex.AddRange(Enumerable.Range(0, unityMesh.UV1.Length));
			}

			//Colors
			if (hasColors)
			{
				LayerElementVertexColor? colorElement = new MeshSharp.Elements.Geometries.Layers.LayerElementVertexColor(outputMesh);
				outputMesh.Layers.Add(colorElement);
				colorElement.MappingInformationType = MappingMode.ByPolygonVertex;
				colorElement.ReferenceInformationType = ReferenceMode.IndexToDirect;
				colorElement.Colors.AddRange(unityMesh.Colors.Select(v => Convert(v)));
				colorElement.ColorIndex.AddRange(Enumerable.Range(0, unityMesh.Colors.Length));
			}

			return outputMesh;
		}

		private static XY Convert(Vector2f vector) => new XY(vector.X, vector.Y);
		private static XYZ Convert(Vector3f vector) => new XYZ(vector.X, vector.Y, vector.Z);
		private static XYZM Convert(Vector4f vector) => new XYZM(vector.X, vector.Y, vector.Z, vector.W);
		private static XYZM Convert(ColorRGBAf vector) => new XYZM(vector.R, vector.G, vector.B, vector.A);
		private static XYZM Convert(ColorRGBA32 vector) => Convert((ColorRGBAf)vector);

		private static Vector3f ToCoordinateSpace(Vector3f point, MeshCoordinateSpace space)
		{
			return space switch
			{
				MeshCoordinateSpace.Left => new Vector3f(-point.Y, point.Z, point.X),
				MeshCoordinateSpace.Right => new Vector3f(point.Z, -point.X, point.Y),
				MeshCoordinateSpace.Unity => point,
				_ => throw new ArgumentOutOfRangeException(nameof(space)),
			};
		}
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/FontAssetExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.SourceGenerated.Classes.ClassID_128;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class FontAssetExportCollection : AssetExportCollection
	{
		public FontAssetExportCollection(FontAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			byte[] fontData = ((IFont)asset).FontData_C128;
			uint type = BitConverter.ToUInt32(fontData, 0);
			return type == OttoAsciiFourCC ? "otf" : "ttf";
		}

		/// <summary>
		/// OTTO ascii
		/// </summary>
		private const int OttoAsciiFourCC = 0x4F54544F;
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/FontAssetExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using System.IO;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class FontAssetExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IFont font && IsValidData(font.FontData_C128);
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new FontAssetExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			TaskManager.AddTask(File.WriteAllBytesAsync(path, ((IFont)asset).FontData_C128));
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/MovieTextureAssetExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class MovieTextureAssetExportCollection : AssetExportCollection
	{
		public MovieTextureAssetExportCollection(MovieTextureAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset) => "ogv";
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/MovieTextureAssetExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_152;
using System.IO;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class MovieTextureAssetExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IMovieTexture texture && IsValidData(texture.MovieData_C152);
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new MovieTextureAssetExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			TaskManager.AddTask(File.WriteAllBytesAsync(path, ((IMovieTexture)asset).MovieData_C152!));
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/TextAssetExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Library.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using System.Linq;
using System.Text.Json;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class TextAssetExportCollection : AssetExportCollection
	{
		private const string JsonExtension = "json";
		private const string TxtExtension = "txt";
		private const string BytesExtension = "bytes";
		
		public TextAssetExportCollection(TextAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return ((TextAssetExporter)AssetExporter).ExportMode switch
			{
				TextExportMode.Txt => TxtExtension,
				TextExportMode.Parse => GetExtension((ITextAsset)asset),
				_ => BytesExtension,
			};
		}

		private static string GetExtension(ITextAsset asset)
		{
			string text = asset.Script_C49.String;
			if (IsValidJson(text))
			{
				return JsonExtension;
			}
			else if (IsPlainText(text))
			{
				return TxtExtension;
			}
			else
			{
				return BytesExtension;
			}
		}

		private static bool IsValidJson(string text)
		{
			try
			{
				using JsonDocument? parsed = JsonDocument.Parse(text);
				return parsed != null;
			}
			catch
			{
				return false;
			}
		}

		private static bool IsPlainText(string text) => text.All(c => !char.IsControl(c) || char.IsWhiteSpace(c));
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/TextAssetExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Library.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using System.IO;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class TextAssetExporter : BinaryAssetExporter
	{
		public TextExportMode ExportMode { get; }
		public TextAssetExporter(LibraryConfiguration configuration)
		{
			ExportMode = configuration.TextExportMode;
		}

		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is ITextAsset textAsset && !textAsset.Script_C49.Data.IsNullOrEmpty();
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new TextAssetExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			TaskManager.AddTask(File.WriteAllBytesAsync(path, ((ITextAsset)asset).Script_C49.Data));
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/VideoClipExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using System.IO;

using IVideoClip327 = AssetRipper.SourceGenerated.Classes.ClassID_327.IVideoClip;
using IVideoClip329 = AssetRipper.SourceGenerated.Classes.ClassID_329.IVideoClip;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class VideoClipExportCollection : AssetExportCollection
	{
		public VideoClipExportCollection(VideoClipExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			if (asset is IVideoClip329 videoClip329)
			{
				return Path.GetExtension(videoClip329.OriginalPath_C329.String);
			}
			else if (asset is IVideoClip327 videoClip327)
			{
				return Path.GetExtension(videoClip327.OriginalPath_C327.String);
			}
			else
			{
				return base.GetExportExtension(asset);
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Miscellaneous/VideoClipExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using System.Diagnostics.CodeAnalysis;
using System.IO;

using IVideoClip327 = AssetRipper.SourceGenerated.Classes.ClassID_327.IVideoClip;
using IVideoClip329 = AssetRipper.SourceGenerated.Classes.ClassID_329.IVideoClip;

namespace AssetRipper.Library.Exporters.Miscellaneous
{
	public sealed class VideoClipExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return IsValidVideoClip329(asset) || IsValidVideoClip327(asset);
		}

		private static bool IsValidVideoClip327(IUnityObjectBase asset)
		{
			return asset is IVideoClip327 clip && clip.ExternalResources_C327.CheckIntegrity(clip.SerializedFile);
		}

		private static bool IsValidVideoClip329(IUnityObjectBase asset)
		{
			return asset is IVideoClip329 clip && clip.ExternalResources_C329.CheckIntegrity(clip.SerializedFile);
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new VideoClipExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			if (TryGetData(asset, out byte[]? data))
			{
				TaskManager.AddTask(File.WriteAllBytesAsync(path, data));
				return true;
			}
			else
			{
				return false;
			}
		}

		private static bool TryGetData(IUnityObjectBase clip, [NotNullWhen(true)] out byte[]? data)
		{
			if (clip is IVideoClip329 videoClip329 && videoClip329.ExternalResources_C329.TryGetContent(videoClip329.SerializedFile, out data))
			{
				return true;
			}
			else if (clip is IVideoClip327 videoClip327 && videoClip327.ExternalResources_C327.TryGetContent(videoClip327.SerializedFile, out data))
			{
				return true;
			}
			else
			{
				data = null;
				return false;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/ProjectVersionPostExporter.cs`:

```cs
using AssetRipper.Core.IO;
using System.IO;
using System.Text;

namespace AssetRipper.Library.Exporters
{
	public sealed class ProjectVersionPostExporter : IPostExporter
	{
		private static UnityVersion DefaultUnityVersion => new UnityVersion(2017, 3, 0, UnityVersionType.Final, 3);

		public void DoPostExport(Ripper ripper)
		{
			SaveExactProjectVersion(ripper.Settings.ProjectSettingsPath, ripper.Settings.Version);
		}

		private static void SaveDefaultProjectVersion(string projectSettingsDirectory)
		{
			SaveProjectVersion(projectSettingsDirectory, DefaultUnityVersion);
		}

		private static void SaveMaxProjectVersion(string projectSettingsDirectory, UnityVersion exactVersion)
		{
			UnityVersion projectVersion = UnityVersion.Max(DefaultUnityVersion, exactVersion);
			SaveProjectVersion(projectSettingsDirectory, projectVersion);
		}

		private static void SaveExactProjectVersion(string projectSettingsDirectory, UnityVersion exactVersion)
		{
			SaveProjectVersion(projectSettingsDirectory, exactVersion);
		}

		private static void SaveProjectVersion(string projectSettingsDirectory, UnityVersion version)
		{
			Directory.CreateDirectory(projectSettingsDirectory);
			using Stream fileStream = File.Create(Path.Combine(projectSettingsDirectory, "ProjectVersion.txt"));
			using StreamWriter writer = new InvariantStreamWriter(fileStream, new UTF8Encoding(false));
			writer.Write($"m_EditorVersion: {version}");
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyDefinitions/AssemblyDefinitionAsset.cs`:

```cs
using System.Collections.Generic;
using System.Text.Json.Serialization;

namespace AssetRipper.Library.Exporters.Scripts.AssemblyDefinitions
{
	public sealed class AssemblyDefinitionAsset
	{
		[JsonPropertyName("name")]
		public string Name { get; set; }
		[JsonPropertyName("references")]
		public List<string> References { get; set; }
		[JsonPropertyName("allowUnsafeCode")]
		public bool AllowUnsafeCode { get; set; }

		public AssemblyDefinitionAsset(string name)
		{
			Name = name;
			AllowUnsafeCode = true;
			References = new();
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyDefinitions/AssemblyDefinitionDetails.cs`:

```cs
using Mono.Cecil;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.Scripts.AssemblyDefinitions
{
	public readonly struct AssemblyDefinitionDetails : IEquatable<AssemblyDefinitionDetails>
	{
		public readonly string AssemblyName;
		public readonly string OutputFolder;
		public readonly AssemblyDefinition? Assembly;

		public AssemblyDefinitionDetails(AssemblyDefinition assembly, string outputFolder)
		{
			AssemblyName = assembly.Name.Name;
			OutputFolder = outputFolder;
			Assembly = assembly;
		}

		public AssemblyDefinitionDetails(string assemblyName, string outputFolder)
		{
			AssemblyName = assemblyName;
			OutputFolder = outputFolder;
			Assembly = null;
		}

		public override bool Equals(object? obj)
		{
			return obj is AssemblyDefinitionDetails details && Equals(details);
		}

		public bool Equals(AssemblyDefinitionDetails other)
		{
			return AssemblyName == other.AssemblyName &&
				   OutputFolder == other.OutputFolder &&
				   EqualityComparer<AssemblyDefinition?>.Default.Equals(Assembly, other.Assembly);
		}

		public override int GetHashCode()
		{
			return HashCode.Combine(AssemblyName, OutputFolder, Assembly);
		}

		public static bool operator ==(AssemblyDefinitionDetails left, AssemblyDefinitionDetails right)
		{
			return left.Equals(right);
		}

		public static bool operator !=(AssemblyDefinitionDetails left, AssemblyDefinitionDetails right)
		{
			return !(left == right);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyDefinitions/AssemblyDefinitionExporter.cs`:

```cs
using Mono.Cecil;
using System.IO;
using System.Text.Json;

namespace AssetRipper.Library.Exporters.Scripts.AssemblyDefinitions
{
	public static class AssemblyDefinitionExporter
	{
		public static void Export(AssemblyDefinitionDetails details)
		{
			string assetPath = Path.Combine(details.OutputFolder, $"{details.AssemblyName}.asmdef");

			AssemblyDefinitionAsset asset = new AssemblyDefinitionAsset(details.AssemblyName);
			if (details.Assembly is not null)
			{
				foreach (AssemblyNameReference reference in details.Assembly.MainModule.AssemblyReferences)
				{
					if (ReferenceAssemblies.IsReferenceAssembly(reference.Name))
					{
						continue;
					}

					asset.References.Add(reference.Name);
				}
			}

			string assetData = JsonSerializer.Serialize(asset, AssemblyDefinitionSerializerContext.Default.AssemblyDefinitionAsset);
			File.WriteAllText(assetPath, assetData);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyDefinitions/AssemblyDefinitionSerializerContext.cs`:

```cs
using System.Text.Json.Serialization;

namespace AssetRipper.Library.Exporters.Scripts.AssemblyDefinitions
{
	[JsonSourceGenerationOptions(WriteIndented = true)]
	[JsonSerializable(typeof(AssemblyDefinitionAsset))]
	internal sealed partial class AssemblyDefinitionSerializerContext : JsonSerializerContext
	{
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyDllExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Library.Configuration;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.Scripts
{
	public class AssemblyDllExporter : IAssetExporter
	{
		public IAssemblyManager AssemblyManager { get; }
		public ScriptExportMode ScriptExportMode { get; }

		public AssemblyDllExporter(IAssemblyManager assemblyManager, LibraryConfiguration configuration)
		{
			AssemblyManager = assemblyManager;
			ScriptExportMode = configuration.ScriptExportMode;
		}

		public bool IsHandle(IUnityObjectBase asset)
		{
			return ScriptExportMode == ScriptExportMode.DllExportWithoutRenaming && asset is IMonoScript;
		}

		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AssemblyExportCollection(this, (IMonoScript)asset);
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			throw new NotSupportedException("Need to export all scripts at once");
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException("Need to export all scripts at once");
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string dirPath)
		{
			throw new NotSupportedException("Assemblies are exported inside the export collection");
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string dirPath, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException("Assemblies are exported inside the export collection");
		}

		public AssetType ToExportType(IUnityObjectBase asset) => AssetType.Meta;

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Meta;
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/AssemblyExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1030;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace AssetRipper.Library.Exporters.Scripts
{
	public class AssemblyExportCollection : ExportCollection
	{
		public override IAssetExporter AssetExporter { get; }
		public override ISerializedFile File { get; }
		public override IEnumerable<IUnityObjectBase> Assets => m_scripts.Keys;
		public override string Name => nameof(ScriptExportCollection);

		private static readonly UnityGUID UnityEngineGUID = new UnityGUID(0x1F55507F, 0xA1948D44, 0x4080F528, 0xC176C90E);

		private readonly List<IMonoScript> m_export = new List<IMonoScript>();
		private readonly HashSet<IMonoScript> m_unique = new HashSet<IMonoScript>();
		private readonly Dictionary<IUnityObjectBase, IMonoScript> m_scripts = new Dictionary<IUnityObjectBase, IMonoScript>();
		private readonly Dictionary<string, long> ScriptId = new Dictionary<string, long>();
		private readonly Dictionary<string, UnityGUID> AssemblyHash = new Dictionary<string, UnityGUID>();


		public AssemblyExportCollection(IAssetExporter assetExporter, IMonoScript script)
		{
			AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));

			File = script.SerializedFile;

			// find copies in whole project and skip them
			foreach (IUnityObjectBase asset in script.SerializedFile.Collection.FetchAssets())
			{
				if (asset is not IMonoScript assetScript)
				{
					continue;
				}

				IMonoScript unique = assetScript;
				foreach (IMonoScript export in m_unique)
				{
					if (assetScript.ClassName_C115 != export.ClassName_C115)
					{
						continue;
					}
					if (assetScript.Namespace_C115 != export.Namespace_C115)
					{
						continue;
					}
					if (assetScript.GetAssemblyNameFixed() != export.GetAssemblyNameFixed())
					{
						continue;
					}

					unique = export;
					break;
				}

				m_scripts.Add(assetScript, unique);
				if (assetScript == unique)
				{
					m_unique.Add(assetScript);
					if (assetScript.IsScriptPresents())
					{
						m_export.Add(assetScript);
					}
				}
			}
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			if (m_export.Count == 0)
			{
				return false;
			}

			Logger.Info(LogCategory.Export, "Exporting scripts...");

			string scriptFolder = m_export[0].ExportPath;
			string scriptPath = Path.Combine(dirPath, scriptFolder);

			foreach (Mono.Cecil.AssemblyDefinition? assembly in ((AssemblyDllExporter)AssetExporter).AssemblyManager.GetAssemblies())
			{
				string assemblyName = assembly.Name.Name;
				if (!assemblyName.EndsWith(".dll"))
				{
					assemblyName = assemblyName + ".dll";
				}

				if (ReferenceAssemblies.IsReferenceAssembly(assemblyName))
				{
					continue;
				}

				string path = Path.Combine(scriptPath, assemblyName);
				Directory.CreateDirectory(scriptPath);
				using FileStream file = System.IO.File.Create(path);
				assembly.Write(file);
				OnAssemblyExported(container, path);
			}
			Logger.Info(LogCategory.Export, "Finished exporting scripts");
			return true;
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return m_scripts.ContainsKey(asset);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			return ExportIdHandler.GetMainExportID(asset);
		}

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}

			IMonoScript script = m_scripts[asset];
			if (!MonoScriptExtensions.HasAssemblyName(script.SerializedFile.Version, script.SerializedFile.Flags) || ReferenceAssemblies.IsUnityEngineAssembly(script.GetAssemblyNameFixed()))
			{
				if (MonoScriptExtensions.HasNamespace(script.SerializedFile.Version))
				{
					int fileID = Compute(script.Namespace_C115.String, script.ClassName_C115.String);
					return new MetaPtr(fileID, UnityEngineGUID, AssetExporter.ToExportType(asset));
				}
				else
				{
					ScriptIdentifier scriptInfo = script.GetScriptID();
					if (!scriptInfo.IsDefault)
					{
						int fileID = Compute(scriptInfo.Namespace, scriptInfo.Name);
						return new MetaPtr(fileID, UnityEngineGUID, AssetExporter.ToExportType(asset));
					}
				}
			}

			string? scriptKey = $"{script.AssemblyName_C115.String}{script.Namespace_C115.String}{script.ClassName_C115.String}";
			if (!ScriptId.ContainsKey(scriptKey))
			{
				ScriptId[scriptKey] = Compute(script.Namespace_C115.String, script.ClassName_C115.String);
			}

			return new MetaPtr(ScriptId[scriptKey], GetAssemblyGuid(script.AssemblyName_C115.String), AssetExporter.ToExportType(asset));
		}

		private static int Compute(string @namespace, string name)
		{
			string toBeHashed = $"s\0\0\0{@namespace}{name}";
			using HashAlgorithm hash = new MD4();
			byte[] hashed = hash.ComputeHash(Encoding.UTF8.GetBytes(toBeHashed));

			int result = 0;
			for (int i = 3; i >= 0; --i)
			{
				result <<= 8;
				result |= hashed[i];
			}

			return result;
		}

		public UnityGUID GetAssemblyGuid(string assemblyName)
		{
			if (AssemblyHash.TryGetValue(assemblyName, out UnityGUID result))
			{
				return result;
			}
			else
			{
				UnityGUID guid = CalculateAssemblyHashGuid(assemblyName);
				AssemblyHash[assemblyName] = guid;
				return guid;
			}
		}

		private static UnityGUID CalculateAssemblyHashGuid(string assemblyPath)
		{
			string shortName = Path.GetFileNameWithoutExtension(assemblyPath);
			return UnityGUID.Md5Hash(shortName);
		}

		private void OnAssemblyExported(IExportContainer container, string path)
		{
			UnityGUID guid = GetAssemblyGuid(Path.GetFileName(path));
			IDefaultImporter importer = DefaultImporterFactory.CreateAsset(container.ExportVersion);//Might need to use PluginImporter
			Meta meta = new Meta(guid, importer);
			ExportMeta(container, meta, path);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/CecilAssemblyResolver.cs`:

```cs
using AssetRipper.Core.Structure.Assembly.Managers;
using ICSharpCode.Decompiler.Metadata;
using Mono.Cecil;
using System.Collections.Concurrent;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace AssetRipper.Library.Exporters.Scripts
{
	internal class CecilAssemblyResolver : ICSharpCode.Decompiler.Metadata.IAssemblyResolver
	{
		private readonly ConcurrentDictionary<string, PEFile> peAssemblies = new();
		public CecilAssemblyResolver(IAssemblyManager manager) : this(manager.GetAssemblies()) { }
		public CecilAssemblyResolver(ReadOnlySpan<AssemblyDefinition> assemblies)
		{
			foreach (AssemblyDefinition assembly in assemblies)
			{
				PEFile peFile = CreatePEFile(assembly);
				if (!peAssemblies.TryAdd(assembly.FullName, peFile))
				{
					throw new Exception($"Could not add pe assembly: {assembly.FullName} to name dictionary!");
				}
			}
		}
		public CecilAssemblyResolver(AssemblyDefinition loneAssembly)
		{
			PEFile peFile = CreatePEFile(loneAssembly);
			if (!peAssemblies.TryAdd(loneAssembly.FullName, peFile))
			{
				throw new Exception($"Could not add pe assembly: {loneAssembly.FullName} to name dictionary!");
			}
		}

		private static PEFile CreatePEFile(AssemblyDefinition assembly)
		{
			if (assembly == null)
			{
				throw new ArgumentNullException(nameof(assembly));
			}

			MemoryStream memoryStream = new MemoryStream();
			assembly.Write(memoryStream);
			memoryStream.Position = 0;

			return new PEFile(assembly.Name.Name, memoryStream);
		}

		public PEFile? Resolve(IAssemblyReference reference) => Resolve(reference.FullName);

		public PEFile? Resolve(AssemblyDefinition assembly) => Resolve(assembly.FullName);

		public PEFile? Resolve(string fullName)
		{
			if (peAssemblies.TryGetValue(fullName, out PEFile? result))
			{
				return result;
			}
			else
			{
				return null;
			}
		}

		public Task<PEFile?> ResolveAsync(IAssemblyReference reference)
		{
			return Task.Run(() => Resolve(reference));
		}

		/// <summary>
		/// Finds a module in the same directory as another
		/// </summary>
		/// <param name="mainModule"></param>
		/// <param name="moduleName"></param>
		/// <returns></returns>
		public PEFile? ResolveModule(PEFile mainModule, string moduleName)
		{
			return peAssemblies.Values.Where(x => x.Name == moduleName).SingleOrDefault();
		}

		public Task<PEFile?> ResolveModuleAsync(PEFile mainModule, string moduleName)
		{
			return Task.Run(() => ResolveModule(mainModule, moduleName));
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/DllPostExporter.cs`:

```cs
using AssetRipper.Core.Logging;
using Mono.Cecil;
using System.IO;

namespace AssetRipper.Library.Exporters.Scripts
{
	public class DllPostExporter : IPostExporter
	{
		public void DoPostExport(Ripper ripper)
		{
			string outputDirectory = Path.Combine(ripper.Settings.AuxiliaryFilesPath, "GameAssemblies");

			Logger.Info(LogCategory.Export, "Saving game assemblies...");
			AssemblyDefinition[] assemblies = ripper.GameStructure.FileCollection.AssemblyManager.GetAssemblies();
			if (assemblies.Length != 0)
			{
				Directory.CreateDirectory(outputDirectory);
				foreach (AssemblyDefinition? assembly in assemblies)
				{
					string filepath = Path.Combine(outputDirectory, assembly.Name.Name);
					if (!filepath.EndsWith(".dll"))
					{
						filepath += ".dll";
					}

					assembly.Write(filepath);
				}
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/FilePathCleanup.cs`:

```cs
using System.IO;
using System.Text;

namespace AssetRipper.Library.Exporters.Scripts
{
	internal static class FilePathCleanup
	{
		const int maxSegmentLength = 255;

		/// <summary>
		/// Cleans up a node name for use as a file name.
		/// </summary>
		public static string CleanUpFileName(string text)
		{
			return CleanUpName(text, separateAtDots: false, treatAsFileName: false);
		}

		/// <summary>
		/// Removes invalid characters from file names and reduces their length,
		/// but keeps file extensions and path structure intact.
		/// </summary>
		public static string SanitizeFileName(string fileName)
		{
			return CleanUpName(fileName, separateAtDots: false, treatAsFileName: true);
		}

		/// <summary>
		/// Cleans up a node name for use as a file system name. If <paramref name="separateAtDots"/> is active,
		/// dots are seen as segment separators. Each segment is limited to maxSegmentLength characters.
		/// (see <see cref="GetLongPathSupport"/>) If <paramref name="treatAsFileName"/> is active,
		/// we check for file a extension and try to preserve it, if it's valid.
		/// </summary>
		static string CleanUpName(string text, bool separateAtDots, bool treatAsFileName)
		{
			int pos = text.IndexOf(':');
			if (pos > 0)
			{
				text = text.Substring(0, pos);
			}

			pos = text.IndexOf('`');
			if (pos > 0)
			{
				text = text.Substring(0, pos);
			}

			text = text.Trim();
			string? extension = null;
			int currentSegmentLength = 0;
			if (treatAsFileName)
			{
				// Check if input is a file name, i.e., has a valid extension
				// If yes, preserve extension and append it at the end.
				// But only, if the extension length does not exceed maxSegmentLength,
				// if that's the case we just give up and treat the extension no different
				// from the file name.
				int lastDot = text.LastIndexOf('.');
				if (lastDot >= 0 && text.Length - lastDot < maxSegmentLength)
				{
					string originalText = text;
					extension = text.Substring(lastDot);
					text = text.Remove(lastDot);
					foreach (char c in extension)
					{
						if (!(char.IsLetterOrDigit(c) || c == '-' || c == '_' || c == '.'))
						{
							// extension contains an invalid character, therefore cannot be a valid extension.
							extension = null;
							text = originalText;
							break;
						}
					}
				}
			}
			// Whitelist allowed characters, replace everything else:
			StringBuilder b = new StringBuilder(text.Length + (extension?.Length ?? 0));
			foreach (char c in text)
			{
				currentSegmentLength++;
				if (char.IsLetterOrDigit(c) || c == '-' || c == '_')
				{
					// if the current segment exceeds maxSegmentLength characters,
					// skip until the end of the segment.
					if (currentSegmentLength <= maxSegmentLength)
					{
						b.Append(c);
					}
				}
				else if (c == '.' && b.Length > 0 && b[b.Length - 1] != '.')
				{
					// if the current segment exceeds maxSegmentLength characters,
					// skip until the end of the segment.
					if (separateAtDots || currentSegmentLength <= maxSegmentLength)
					{
						b.Append('.'); // allow dot, but never two in a row
					}

					// Reset length at end of segment.
					if (separateAtDots)
					{
						currentSegmentLength = 0;
					}
				}
				else if (treatAsFileName && (c == '/' || c == '\\') && currentSegmentLength > 0)
				{
					// if we treat this as a file name, we've started a new segment
					b.Append(c);
					currentSegmentLength = 0;
				}
				else
				{
					// if the current segment exceeds maxSegmentLength characters,
					// skip until the end of the segment.
					if (currentSegmentLength <= maxSegmentLength)
					{
						b.Append('-');
					}
				}
			}
			if (b.Length == 0)
			{
				b.Append('-');
			}

			string name = b.ToString();
			if (extension != null)
			{
				name += extension;
			}

			if (IsReservedFileSystemName(name))
			{
				return name + "_";
			}
			else if (name == ".")
			{
				return "_";
			}
			else
			{
				return name;
			}
		}

		/// <summary>
		/// Cleans up a node name for use as a directory name.
		/// </summary>
		public static string CleanUpDirectoryName(string text)
		{
			return CleanUpName(text, separateAtDots: false, treatAsFileName: false);
		}

		public static string CleanUpPath(string text)
		{
			return CleanUpName(text, separateAtDots: true, treatAsFileName: false)
				.Replace('.', Path.DirectorySeparatorChar);
		}

		private static bool IsReservedFileSystemName(string name)
		{
			switch (name.ToUpperInvariant())
			{
				case "AUX":
				case "COM1":
				case "COM2":
				case "COM3":
				case "COM4":
				case "COM5":
				case "COM6":
				case "COM7":
				case "COM8":
				case "COM9":
				case "CON":
				case "LPT1":
				case "LPT2":
				case "LPT3":
				case "LPT4":
				case "LPT5":
				case "LPT6":
				case "LPT7":
				case "LPT8":
				case "LPT9":
				case "NUL":
				case "PRN":
					return true;
				default:
					return false;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ReferenceAssemblies.cs`:

```cs
using System.Collections.Generic;
using System.Text.RegularExpressions;

namespace AssetRipper.Library.Exporters.Scripts
{
	public static class ReferenceAssemblies
	{
		private static readonly Regex unityRegex = new Regex(@"^Unity(\.[0-9a-zA-Z]+)*(\.dll)?$", RegexOptions.Compiled);
		private static readonly Regex unityEngineRegex = new Regex(@"^UnityEngine(\.[0-9a-zA-Z]+)*(\.dll)?$", RegexOptions.Compiled);
		private static readonly Regex unityEditorRegex = new Regex(@"^UnityEditor(\.[0-9a-zA-Z]+)*(\.dll)?$", RegexOptions.Compiled);
		private static readonly Regex systemRegex = new Regex(@"^System(\.[0-9a-zA-Z]+)*(\.dll)?$", RegexOptions.Compiled);
		private static readonly HashSet<string> whitelistAssemblies = new HashSet<string>()
		{
			
		};
		private static readonly HashSet<string> blacklistAssemblies = new HashSet<string>()
		{
			"mscorlib.dll",
			"mscorlib",
			"netstandard.dll",
			"netstandard",
			"Mono.Security.dll",
			"Mono.Security"
		};
		private static readonly HashSet<string> predefinedAssemblies = new()
		{
			"Assembly-CSharp.dll",
			"Assembly-CSharp",
			"Assembly-CSharp-firstpass.dll",
			"Assembly-CSharp-firstpass"
		};

		public static bool IsPredefinedAssembly(string assemblyName)
		{
			if (assemblyName is null)
			{
				throw new ArgumentNullException(assemblyName);
			}

			return predefinedAssemblies.Contains(assemblyName);
		}

		public static bool IsReferenceAssembly(string assemblyName)
		{
			if (assemblyName is null)
			{
				throw new ArgumentNullException(assemblyName);
			}

			if (IsWhiteListAssembly(assemblyName))
			{
				return false;
			}

			return IsBlackListAssembly(assemblyName)
				|| IsUnityEngineAssembly(assemblyName)
				//|| IsUnityAssembly(assemblyName)
				|| IsSystemAssembly(assemblyName)
				|| IsUnityEditorAssembly(assemblyName);
		}

		private static bool IsUnityAssembly(string assemblyName) => unityRegex.IsMatch(assemblyName);
		public static bool IsUnityEngineAssembly(string assemblyName) => unityEngineRegex.IsMatch(assemblyName);
		private static bool IsUnityEditorAssembly(string assemblyName) => unityEditorRegex.IsMatch(assemblyName);
		private static bool IsSystemAssembly(string assemblyName) => systemRegex.IsMatch(assemblyName);
		private static bool IsWhiteListAssembly(string assemblyName) => whitelistAssemblies.Contains(assemblyName);
		private static bool IsBlackListAssembly(string assemblyName) => blacklistAssemblies.Contains(assemblyName);
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ScriptDecompiler.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Library.Exporters.Scripts.Transform;
using AssetRipper.Library.Exporters.Scripts.Transforms;
using ICSharpCode.Decompiler.CSharp;
using Mono.Cecil;

namespace AssetRipper.Library.Exporters.Scripts
{
	internal class ScriptDecompiler
	{
		private readonly CecilAssemblyResolver assemblyResolver;
		public LanguageVersion LanguageVersion { get; set; } = LanguageVersion.CSharp7_3;
		public ScriptContentLevel ScriptContentLevel { get; set; } = ScriptContentLevel.Level2;
		public ScriptingBackend ScriptingBackend { get; set; } = ScriptingBackend.Unknown;

		public ScriptDecompiler(IAssemblyManager assemblyManager) : this(new CecilAssemblyResolver(assemblyManager), assemblyManager.ScriptingBackend) { }
		public ScriptDecompiler(AssemblyDefinition assembly, ScriptingBackend scriptingBackend) : this(new CecilAssemblyResolver(assembly), scriptingBackend) { }
		public ScriptDecompiler(AssemblyDefinition[] assemblies, ScriptingBackend scriptingBackend) : this(new CecilAssemblyResolver(assemblies), scriptingBackend) { }
		private ScriptDecompiler(CecilAssemblyResolver cecilAssemblyResolver, ScriptingBackend scriptingBackend)
		{
            assemblyResolver = cecilAssemblyResolver;
			ScriptingBackend = scriptingBackend;
		}

		public void DecompileWholeProject(AssemblyDefinition assembly, string outputFolder)
		{
			WholeAssemblyDecompiler decompiler = new(assemblyResolver);
			// these settings may need to be changed later because
			// CSharpDecompiler.IsMemberHidden seems to contradict
			// what these settings state they do.
			decompiler.Settings.AnonymousTypes = false;
			decompiler.Settings.AnonymousMethods = false;
			decompiler.Settings.AsyncEnumerator = false;

			decompiler.Settings.AlwaysShowEnumMemberValues = true;
			decompiler.Settings.ShowXmlDocumentation = true;

			decompiler.Settings.SetLanguageVersion(LanguageVersion);
			decompiler.Settings.UseNestedDirectoriesForNamespaces = true;

			if (ScriptContentLevel == ScriptContentLevel.Level1)
			{
				decompiler.CustomTransforms.Add(new MemberStubTransform());
			}

			// code quality
			if (ScriptingBackend == ScriptingBackend.IL2Cpp && ScriptContentLevel <= ScriptContentLevel.Level2)
			{
				decompiler.CustomTransforms.Add(new RemoveInvalidMemberTransform(ScriptingBackend == ScriptingBackend.IL2Cpp));
				decompiler.CustomTransforms.Add(new FixOptionalParametersTransform());
				decompiler.CustomTransforms.Add(new ValidateNullCastsTransform());
				decompiler.CustomTransforms.Add(new FixExplicitInterfaceImplementationTransform());
				decompiler.CustomTransforms.Add(new FixStructLayoutAmbiguityTransform());
				decompiler.CustomTransforms.Add(new RemoveCompilerAttributeTransform());
				decompiler.CustomTransforms.Add(new FixGenericStructConstraintTransform());
			}
			
			// il2cpp fixes
			if (ScriptContentLevel == ScriptContentLevel.Level1 || // level one stubs everything, so it needs to be fixed up.
				(ScriptingBackend == ScriptingBackend.IL2Cpp && ScriptContentLevel <= ScriptContentLevel.Level2))
			{
				// maybe could be moved to code quality?
				decompiler.CustomTransforms.Add(new FixCompilerGeneratedAccessorsTransform());
				decompiler.CustomTransforms.Add(new EnsureOutParamsSetTransform());
				decompiler.CustomTransforms.Add(new EnsureStructFieldsSetTransform());
				decompiler.CustomTransforms.Add(new EnsureValidBaseConstructorTransform());
				decompiler.CustomTransforms.Add(new FixEventDeclarationsTransform());
			}

			DecompileWholeProject(decompiler, assembly, outputFolder);
		}

		private void DecompileWholeProject(WholeAssemblyDecompiler decompiler, AssemblyDefinition assembly, string outputFolder)
		{
			decompiler.DecompileProject(
				 assemblyResolver.Resolve(assembly) ?? throw new Exception($"Could not resolve {assembly.FullName}"),
				 outputFolder);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ScriptExportCollection.MonoScriptInfo.cs`:

```cs
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_115;

namespace AssetRipper.Library.Exporters.Scripts
{
	public partial class ScriptExportCollection
	{
		private struct MonoScriptInfo : IEquatable<MonoScriptInfo>
		{
			public readonly string @class;
			public readonly string @namespace;
			public readonly string assembly;

			public MonoScriptInfo(string @class, string @namespace, string assembly)
			{
				this.@class = @class;
				this.@namespace = @namespace;
				this.assembly = assembly;
			}

			public static MonoScriptInfo From(IMonoScript monoScript)
			{
				return new MonoScriptInfo(monoScript.ClassName_C115.String, monoScript.Namespace_C115.String, monoScript.GetAssemblyNameFixed());
			}

			public override bool Equals(object? obj)
			{
				return obj is MonoScriptInfo info && Equals(info);
			}

			public bool Equals(MonoScriptInfo other)
			{
				return @class == other.@class &&
					   @namespace == other.@namespace &&
					   assembly == other.assembly;
			}

			public override int GetHashCode()
			{
				return HashCode.Combine(@class, @namespace, assembly);
			}

			public static bool operator ==(MonoScriptInfo left, MonoScriptInfo right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(MonoScriptInfo left, MonoScriptInfo right)
			{
				return !(left == right);
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ScriptExportCollection.cs`:

```cs
using AssetRipper.Core.Classes.Meta;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Structure.Assembly;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1035;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Collections.Generic;
using System.IO;
using System.Security.Cryptography;
using System.Text;

namespace AssetRipper.Library.Exporters.Scripts
{
	public partial class ScriptExportCollection : ExportCollection
	{
		public ScriptExportCollection(ScriptExporter assetExporter, IMonoScript script)
		{
			AssetExporter = assetExporter ?? throw new ArgumentNullException(nameof(assetExporter));
			File = script.SerializedFile;

			// find copies in whole project and skip them
			Dictionary<MonoScriptInfo, IMonoScript> uniqueDictionary = new();
			foreach (IUnityObjectBase asset in script.SerializedFile.Collection.FetchAssets())
			{
				if (asset is not IMonoScript assetScript)
				{
					continue;
				}

				MonoScriptInfo info = MonoScriptInfo.From(assetScript);
				if(uniqueDictionary.TryGetValue(info, out IMonoScript? uniqueScript))
				{
					m_scripts.Add(assetScript, uniqueScript);
				}
				else
				{
					m_scripts.Add(assetScript, assetScript);
					uniqueDictionary.Add(info, assetScript);
					if (!assetExporter.AssemblyManager.IsSet || assetScript.IsScriptPresents())
					{
						m_export.Add(assetScript);
					}
				}
			}
		}

		public override bool Export(IProjectAssetContainer container, string dirPath)
		{
			if (m_export.Count == 0)
			{
				return false;
			}

			string scriptFolder = m_export[0].ExportPath;
			string scriptPath = Path.Combine(dirPath, scriptFolder);

			AssetExporter.Export(container, m_export, scriptPath, OnScriptExported);
			return true;
		}

		public override bool IsContains(IUnityObjectBase asset)
		{
			return m_scripts.ContainsKey(asset);
		}

		public override long GetExportID(IUnityObjectBase asset)
		{
			return ExportIdHandler.GetMainExportID(asset);
		}

		public override MetaPtr CreateExportPointer(IUnityObjectBase asset, bool isLocal)
		{
			if (isLocal)
			{
				throw new NotSupportedException();
			}

			IMonoScript script = m_scripts[asset];
			if (IsEngineScript(script))
			{
				if (MonoScriptExtensions.HasNamespace(script.SerializedFile.Version))
				{
					int fileID = Compute(script.Namespace_C115.String, script.ClassName_C115.String);
					return new MetaPtr(fileID, UnityEngineGUID, AssetExporter.ToExportType(asset));
				}
				else
				{
					ScriptIdentifier scriptInfo = script.GetScriptID();
					if (!scriptInfo.IsDefault)
					{
						int fileID = Compute(scriptInfo.Namespace, scriptInfo.Name);
						return new MetaPtr(fileID, UnityEngineGUID, AssetExporter.ToExportType(asset));
					}
				}
			}

			long exportID = GetExportID(asset);
			UnityGUID uniqueGUID = script.GUID;
			return new MetaPtr(exportID, uniqueGUID, AssetExporter.ToExportType(asset));
		}

		private static int Compute(string @namespace, string name)
		{
			string toBeHashed = $"s\0\0\0{@namespace}{name}";
			using HashAlgorithm hash = new MD4();
			byte[] hashed = hash.ComputeHash(Encoding.UTF8.GetBytes(toBeHashed));

			int result = 0;
			for (int i = 3; i >= 0; --i)
			{
				result <<= 8;
				result |= hashed[i];
			}

			return result;
		}

		private void OnScriptExported(IExportContainer container, IUnityObjectBase asset, string path)
		{
			IMonoScript script = (IMonoScript)asset;
			IMonoImporter importer = MonoImporterFactory.CreateAsset(container.ExportVersion);
			importer.ExecutionOrder_C1035 = (short)script.ExecutionOrder_C115;
			Meta meta = new Meta(script.GUID, importer);
			ExportMeta(container, meta, path);
		}

		public static bool IsEngineScript(IMonoScript script)
		{
			return ReferenceAssemblies.IsUnityEngineAssembly(script.GetAssemblyNameFixed());
		}

		public override IAssetExporter AssetExporter { get; }
		public override ISerializedFile File { get; }
		public override IEnumerable<IUnityObjectBase> Assets => m_scripts.Keys;
		public override string Name => nameof(ScriptExportCollection);

		private static readonly UnityGUID UnityEngineGUID = new UnityGUID(0x1F55507F, 0xA1948D44, 0x4080F528, 0xC176C90E);

		private readonly List<IMonoScript> m_export = new();
		private readonly Dictionary<IUnityObjectBase, IMonoScript> m_scripts = new();
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ScriptExporter.cs`:

```cs
using AssetRipper.Core.Configuration;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Structure.Assembly.Managers;
using AssetRipper.Core.Utils;
using AssetRipper.Library.Configuration;
using AssetRipper.Library.Exporters.Scripts.AssemblyDefinitions;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using Mono.Cecil;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Library.Exporters.Scripts
{
	public class ScriptExporter : IAssetExporter
	{
		public ScriptExporter(IAssemblyManager assemblyManager, LibraryConfiguration configuration)
		{
			AssemblyManager = assemblyManager;
			ScriptExportMode = configuration.ScriptExportMode;
			Decompiler = new ScriptDecompiler(AssemblyManager);
			LanguageVersion = configuration.ScriptLanguageVersion.ToCSharpLanguageVersion(configuration.Version);
			ScriptContentLevel = configuration.ScriptContentLevel;
			Enabled = ScriptExportMode == ScriptExportMode.Decompiled;
		}

		public IAssemblyManager AssemblyManager { get; }
		private ScriptExportMode ScriptExportMode { get; }
		private ICSharpCode.Decompiler.CSharp.LanguageVersion LanguageVersion { get; }
		private ScriptContentLevel ScriptContentLevel { get; }
		public bool Enabled { get; }
		private ScriptDecompiler Decompiler { get; set; }

		public bool IsHandle(IUnityObjectBase asset) => Enabled && asset is IMonoScript;

		public IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new ScriptExportCollection(this, (IMonoScript)asset);
		}

		public bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			throw new NotSupportedException("Need to export all scripts at once");
		}

		public void Export(IExportContainer container, IUnityObjectBase asset, string path, Action<IExportContainer, IUnityObjectBase, string> callback)
		{
			throw new NotSupportedException("Need to export all scripts at once");
		}

		public bool Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string dirPath)
		{
			Export(container, assets, dirPath, null);
			return true;
		}

		public AssetType ToExportType(IUnityObjectBase asset) => AssetType.Meta;

		public bool ToUnknownExportType(Type type, out AssetType assetType)
		{
			assetType = AssetType.Meta;
			return true;
		}

		public void Export(IExportContainer container, IEnumerable<IUnityObjectBase> assets, string dirPath, Action<IExportContainer, IUnityObjectBase, string>? callback)
		{
			Logger.Info(LogCategory.Export, "Exporting scripts...");

			if (string.IsNullOrEmpty(dirPath))
			{
				throw new ArgumentNullException(nameof(dirPath));
			}

			Dictionary<string, AssemblyDefinitionDetails> assemblyDefinitionDetailsDictionary = new();

			if (AssemblyManager.IsSet)
			{
				Decompiler.LanguageVersion = LanguageVersion;
				Decompiler.ScriptContentLevel = ScriptContentLevel;

				foreach (AssemblyDefinition assembly in AssemblyManager.GetAssemblies())
				{
					if (ReferenceAssemblies.IsReferenceAssembly(assembly.Name.Name))
					{
						continue;
					}

					Logger.Info(LogCategory.Export, $"Decompiling {assembly.Name.Name}");
					string outputDirectory = Path.Combine(dirPath, assembly.Name.Name);
					Directory.CreateDirectory(outputDirectory);
					Decompiler.DecompileWholeProject(assembly, outputDirectory);

					assemblyDefinitionDetailsDictionary.TryAdd(assembly.Name.Name, new AssemblyDefinitionDetails(assembly, outputDirectory));
				}
			}

			foreach (IMonoScript asset in assets.Cast<IMonoScript>())
			{
				if (ScriptExportCollection.IsEngineScript(asset))
				{
					continue;
				}

				GetExportSubPath(asset, out string subFolderPath, out string fileName);
				string folderPath = Path.Combine(dirPath, subFolderPath);
				string filePath = Path.Combine(folderPath, fileName);
				if (!File.Exists(filePath))
				{
					Directory.CreateDirectory(folderPath);
					File.WriteAllText(filePath, GetEmptyScriptContent(asset));
					string assemblyName = BaseManager.ToAssemblyName(asset.GetAssemblyNameFixed());
					assemblyDefinitionDetailsDictionary.TryAdd(assemblyName, 
						new AssemblyDefinitionDetails(assemblyName, Path.Combine(dirPath, assemblyName)));
				}

				if (callback is not null)
				{
					if (File.Exists($"{filePath}.meta"))
					{
						Logger.Error(LogCategory.Export, $"Metafile already exists at {filePath}.meta");
						//throw new Exception($"Metafile already exists at {filePath}.meta");
					}
					else
					{
						callback.Invoke(container, asset, filePath);
					}
				}
			}

			// assembly definitions were added in 2017.3
			//     see: https://blog.unity.com/technology/unity-2017-3b-feature-preview-assembly-definition-files-and-transform-tool
			if (assemblyDefinitionDetailsDictionary.Count > 0 && container.ExportVersion.IsGreaterEqual(2017, 3))
			{
				foreach (AssemblyDefinitionDetails details in assemblyDefinitionDetailsDictionary.Values)
				{
					// exclude predefined assemblies like Assembly-CSharp.dll
					//    see: https://docs.unity3d.com/2017.3/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html
					if (!ReferenceAssemblies.IsPredefinedAssembly(details.AssemblyName))
					{
						AssemblyDefinitionExporter.Export(details);
					}
				}
			}
		}

		private static void GetExportSubPath(string assembly, string @namespace, string @class, out string folderPath, out string fileName)
		{
			string assemblyFolder = BaseManager.ToAssemblyName(assembly);
			string namespaceFolder = @namespace.Replace('.', Path.DirectorySeparatorChar);
			folderPath = DirectoryUtils.FixInvalidPathCharacters(Path.Combine(assemblyFolder, namespaceFolder));
			fileName = $"{DirectoryUtils.FixInvalidPathCharacters(@class)}.cs";
		}

		private static void GetExportSubPath(IMonoScript script, out string folderPath, out string fileName)
		{
			GetExportSubPath(script.GetAssemblyNameFixed(), script.Namespace_C115.String, script.ClassName_C115.String, out folderPath, out fileName);
		}

		private static string GetEmptyScriptContent(IMonoScript script)
		{
			return GetEmptyScriptContent(script.Namespace_C115.String, script.ClassName_C115.String);
		}

		private static string GetEmptyScriptContent(string? @namespace, string name)
		{
			if (string.IsNullOrEmpty(@namespace))
			{
				return $@"using UnityEngine;

public class {name} : MonoBehaviour
{{
	//Dummy class. Use different settings or provide .NET dll files for better decompilation output
}}";
			}
			else
			{
				return $@"using UnityEngine;

namespace {@namespace}
{{
	public class {name} : MonoBehaviour
	{{
		//Dummy class. Use different settings or provide .NET dll files for better decompilation output
	}}
}}";
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/ScriptUtilities.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.TypeSystem;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.Scripts
{
	/// <summary>
	/// Utilities for script exporting to reduce code duplication.
	/// </summary>
	internal static class ScriptUtilities
	{
		public static AstType ConvertType(TypeSystemAstBuilder typeSystem, IType type)
		{
			AstType nonGenericType = typeSystem.ConvertType(new FullTypeName(type.FullName));
			return AddGenericParameters(typeSystem, nonGenericType, type.TypeArguments);
		}

		private static AstType AddGenericParameters(TypeSystemAstBuilder typeSystem, AstType type, IReadOnlyList<IType> parameters)
		{
			if (type is SimpleType simpleType)
			{
				return AddGenericParameters(typeSystem, simpleType, parameters);
			}
			else if (type is MemberType memberType)
			{
				return AddGenericParameters(typeSystem, memberType, parameters);
			}
			else if (type is ComposedType composedType)
			{
				return AddGenericParameters(typeSystem, composedType, parameters);
			}
			return type;
		}

		private static AstType AddGenericParameters(TypeSystemAstBuilder typeSystem, SimpleType type, IReadOnlyList<IType> parameters)
		{
			foreach (IType parameter in parameters)
			{
				type.TypeArguments.Add(ConvertType(typeSystem, parameter));
			}
			return type;
		}
		private static AstType AddGenericParameters(TypeSystemAstBuilder typeSystem, MemberType type, IReadOnlyList<IType> parameters)
		{
			foreach (IType parameter in parameters)
			{
				type.TypeArguments.Add(ConvertType(typeSystem, parameter));
			}
			return type;
		}
		private static AstType AddGenericParameters(TypeSystemAstBuilder typeSystem, ComposedType type, IReadOnlyList<IType> parameters)
		{
			AddGenericParameters(typeSystem, type.BaseType, parameters);
			return type;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/EnsureOutParamsSetTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transformer that ensure all out parameters on methods are set.
	/// </summary>
	internal class EnsureOutParamsSetTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitMethodDeclaration(MethodDeclaration methodDeclaration)
		{
			base.VisitMethodDeclaration(methodDeclaration);

			if (methodDeclaration.Body == null || methodDeclaration.Body.IsNull)
			{
				return;
			}	

			foreach (ParameterDeclaration parameter in methodDeclaration.Parameters)
			{
				if ((parameter.ParameterModifier & ParameterModifier.Out) != ParameterModifier.Out)
				{
					continue;
				}

				ExpressionStatement assignment = new(new AssignmentExpression(new IdentifierExpression(parameter.Name), new DefaultValueExpression(parameter.Type.Clone())));
				Statement? firstStatement = methodDeclaration.Body.Statements.FirstOrNullObject();
				if (firstStatement == null || firstStatement.IsNull)
				{
					methodDeclaration.Body.Statements.Add(assignment);
				}
				else
				{
					methodDeclaration.Body.Statements.InsertBefore(firstStatement, assignment);
				}
			}
		}
		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/EnsureStructFieldsSetTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transform that ensures all fields of a struct are assigned in each
	/// declared constructor.
	/// </summary>
	internal class EnsureStructFieldsSetTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			base.VisitTypeDeclaration(typeDeclaration);

			if (typeDeclaration.ClassType != ClassType.Struct)
			{
				return;
			}

			List<(AstType, List<string>)> requiredFields = new();
			foreach (EntityDeclaration member in typeDeclaration.Members)
			{

				if ((member.Modifiers & Modifiers.Static) == Modifiers.Static)
				{
					continue;
				}

				if ((member.Modifiers & Modifiers.Const) == Modifiers.Const)
				{
					continue;
				}

				if (member is PropertyDeclaration property && !property.Getter.IsNull && property.Getter.Body.IsNull)
				{
					requiredFields.Add((property.ReturnType, new List<string>(new string[] { property.Name })));
					continue;
				}

				if (member is not FieldDeclaration field)
				{
					continue;
				}

				AstType fieldType = field.ReturnType;
				if (fieldType is ComposedType composedType && composedType.PointerRank > 0)
				{
					typeDeclaration.Modifiers |= Modifiers.Unsafe;
				}

				(AstType, List<string>) fieldInfo = new(fieldType, new());

				foreach (VariableInitializer variable in field.Variables)
				{
					fieldInfo.Item2.Add(variable.Name);
				}

				requiredFields.Add(fieldInfo);
			}

			IEnumerable<ConstructorDeclaration> constructors = typeDeclaration.Members.Select((member) => member as ConstructorDeclaration).Where((constructor) => constructor is not null)!;

			foreach (ConstructorDeclaration? constructorDeclaration in constructors)
			{
				Debug.Assert(constructorDeclaration != null);

				if ((constructorDeclaration.Modifiers & Modifiers.Static) == Modifiers.Static)
				{
					continue;
				}

				if (constructorDeclaration.Initializer != null && !constructorDeclaration.Initializer.IsNull)
				{
					continue;
				}

				Debug.Assert(constructorDeclaration.Body != null);

				foreach ((AstType, List<string>) requiredField in requiredFields)
				{
					foreach (string fieldName in requiredField.Item2)
					{
						ExpressionStatement assignment = new ExpressionStatement(new AssignmentExpression(new MemberReferenceExpression(new ThisReferenceExpression(), fieldName), new DefaultValueExpression(requiredField.Item1.Clone())));
						Statement? firstStatement = constructorDeclaration.Body.Statements.FirstOrDefault();
						if (firstStatement == null || firstStatement.IsNull)
						{
							constructorDeclaration.Body.Statements.Add(assignment);
						}
						else
						{
							constructorDeclaration.Body.Statements.InsertBefore(firstStatement, assignment);
						}
					}
				}
			}
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/EnsureValidBaseConstructorTransform.cs`:

```cs
using AssetRipper.Core.Logging;
using ICSharpCode.Decompiler.CSharp;
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using ICSharpCode.Decompiler.TypeSystem;
using System.Collections.Generic;
using System.Diagnostics.CodeAnalysis;
using System.Linq;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transform that ensures each constructor that doesn't define an initializer
	/// calls a valid base constructor
	/// </summary>
	internal class EnsureValidBaseConstructorTransform : DepthFirstAstVisitor, IAstTransform
	{
		private TransformContext context;

		public EnsureValidBaseConstructorTransform()
		{
			this.context = null!;
		}

		private static int GetConstructorCost(IMethod constructor, ConstructorDeclaration? currentConstructor, bool onlyAccessible = false)
		{
			// return max value cost for a non-accessible constructor (if toggled)
			if (onlyAccessible && !(constructor.Accessibility == Accessibility.Public || constructor.Accessibility == Accessibility.Protected))
			{
				return int.MaxValue;
			}
			int cost = 0;
			int parameterPosition = 0;
			foreach (IParameter parameter in constructor.Parameters)
			{
				// 3 cost per parameter
				cost += 3;
				int paramPosition = 0;
				if (currentConstructor != null)
				{
					foreach (ParameterDeclaration param in currentConstructor.Parameters)
					{
						if (param.Name == parameter.Name)
						{
							cost--;
							// todo: remove cost for parameter with same type
							break;
						}

						paramPosition++;
					}
				}

				parameterPosition++;
			}
			return cost;
		}

		private static bool TryGetBestConstructor(ITypeDefinition type, ConstructorDeclaration currentConstructor, [NotNullWhen(true)] out IMethod? bestConstructor, out bool isBaseConstructor)
		{
			bestConstructor = null;
			isBaseConstructor = default;

			if (type.IsStatic)
			{
				return false;
			}

			IMethod ctorMethod = (IMethod)currentConstructor.GetSymbol();
			IType? baseType = type.DirectBaseTypes?.Where((t) => t.Kind != TypeKind.Interface).FirstOrDefault();
			if (baseType == null)
			{
				return false;
			}

			if (currentConstructor.Initializer?.GetSymbol() is not IMethod)
			{
				// higher score is worse
				int bestCost = int.MaxValue;
				bestConstructor = null;
				isBaseConstructor = false;
				foreach (IMethod constructor in type.GetConstructors())
				{
					// exclude own constructor
					if (constructor.MetadataToken == ctorMethod.MetadataToken)
					{
						continue;
					}

					int cost = GetConstructorCost(constructor, currentConstructor);
					// subtract 1 cost to prefer defined constructors over base constructors
					cost--;

					if (cost < bestCost)
					{
						bestCost = cost;
						bestConstructor = constructor;
						isBaseConstructor = false;
					}
				}

				foreach (IMethod constructor in baseType.GetConstructors())
				{
					int cost = GetConstructorCost(constructor, currentConstructor, true);

					if (cost < bestCost)
					{
						bestCost = cost;
						bestConstructor = constructor;
						isBaseConstructor = true;
					}
				}

				return bestConstructor != null;
			}

			return false;
		}

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			base.VisitTypeDeclaration(typeDeclaration);

			if (typeDeclaration.ClassType != ClassType.Class)
			{
				return;
			}

			bool hasBaseConstructor = false;
			IMethod? bestConstructor = null;

			if (typeDeclaration.GetSymbol() is not ITypeDefinition type)
			{
				Logger.Warning($"Skip ensuring valid base constructor for type declaration {typeDeclaration.Name}, as failed to get type definition");
				return;
			}

			IEnumerable<ConstructorDeclaration> nonStaticConstructors = typeDeclaration.Members
				.Select((member) => member as ConstructorDeclaration)
				.Where((constructor) => constructor is not null && (constructor.Modifiers & Modifiers.Static) != Modifiers.Static)!;

			foreach (ConstructorDeclaration constructorDeclaration in nonStaticConstructors)
			{
				hasBaseConstructor = true;

				if (constructorDeclaration.Initializer != null && !constructorDeclaration.Initializer.IsNull)
				{
					continue;
				}

				if (TryGetBestConstructor(type, constructorDeclaration, out bestConstructor, out bool isBaseConstructor))
				{
					ConstructorInitializer initializer = new()
					{
						ConstructorInitializerType = isBaseConstructor ? ConstructorInitializerType.Base : ConstructorInitializerType.This
					};

					foreach (IParameter parameter in bestConstructor.Parameters)
					{
						bool hasParameterMatch = false;
						foreach (ParameterDeclaration param in constructorDeclaration.Parameters)
						{
							if (param.Name == parameter.Name)
							{
								hasParameterMatch = true;
								break;
							}
						}

						if (hasParameterMatch)
						{
							initializer.Arguments.Add(new IdentifierExpression(parameter.Name));
						}
						else
						{
							initializer.Arguments.Add(new DefaultValueExpression(ScriptUtilities.ConvertType(context.TypeSystemAstBuilder, parameter.Type)));
						}
					}

					constructorDeclaration.Initializer = initializer;
					if (constructorDeclaration.Body.IsNull)
					{
						constructorDeclaration.Body = new BlockStatement();
						constructorDeclaration.Modifiers &= ~Modifiers.Extern;
					}
				}
			}

			if (hasBaseConstructor)
			{
				return;
			}

			IType? baseType = type.DirectBaseTypes?.Where((t) => t.Kind != TypeKind.Interface)
				.FirstOrDefault();
			if (baseType == null || type.IsStatic)
			{
				return;
			}

			bestConstructor = baseType.GetConstructors()
				.OrderBy((ctor) => GetConstructorCost(ctor, null, true)).FirstOrDefault();
			if (bestConstructor != null)
			{
				ConstructorInitializer initializer = new()
				{
					ConstructorInitializerType = ConstructorInitializerType.Base
				};

				foreach (IParameter parameter in bestConstructor.Parameters)
				{
					initializer.Arguments.Add(new DefaultValueExpression(ScriptUtilities.ConvertType(context.TypeSystemAstBuilder, parameter.Type)));
				}


				ConstructorDeclaration constructorDeclaration = new()
				{
					Initializer = initializer,
					Body = new BlockStatement(),
					Modifiers = Modifiers.Public
				};

				typeDeclaration.Members.Add(constructorDeclaration);
			}

		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			this.context = context;
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixCompilerGeneratedAccessorsTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using Attribute = ICSharpCode.Decompiler.CSharp.Syntax.Attribute;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Fixes compiler generated accessors from IL2CPP.
	/// <para>
	/// Replaces:
	/// <code>PropertyType PropertyName
	/// {
	///     [CompilerGenerated]
	///     get
	///     {
	///			return default(PropertyType);
	///     }
	///     [CompilerGenerated]
	///     set
	///     {
	///     }
	/// }</code>
	/// </para>
	/// <para>
	/// With:
	/// <code>PropertyType PropertyName
	/// {
	///		get;
	///		set;
	/// }</code>
	/// </para>
	/// </summary>
	internal class FixCompilerGeneratedAccessorsTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitAccessor(Accessor accessor)
		{
			bool compilerGenerated = false;
			foreach (AttributeSection attributeSection in accessor.Attributes)
			{
				foreach (Attribute attribute in attributeSection.Attributes)
				{
					if (attribute.Type is SimpleType type && type.Identifier == "CompilerGenerated")
					{
						compilerGenerated = true;
						attribute.Remove();
					}
				}

				if (attributeSection.Attributes.Count == 0)
				{
					attributeSection.Remove();
				}
			}

			if (compilerGenerated && !accessor.Body.IsNull)
			{
				accessor.Body = BlockStatement.Null;
			}
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixEventDeclarationsTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Fixes event declarations that look like:
	/// <code>
	/// event MyEvent
	/// {
	///     add;
	///     remove;
	/// }
	/// </code>
	/// And instead replaces them with:
	/// <code>
	/// event MyEvent;
	/// </code>
	/// </summary>
	internal class FixEventDeclarationsTransform : DepthFirstAstVisitor, IAstTransform
	{
		private static bool AccessorHasImplementation(Accessor accessor)
		{
			return !accessor.IsNull && !accessor.Body.IsNull;
		}

		public override void VisitCustomEventDeclaration(CustomEventDeclaration eventDeclaration)
		{
			base.VisitCustomEventDeclaration(eventDeclaration);

			bool hasAccessorImplementation = AccessorHasImplementation(eventDeclaration.AddAccessor) || AccessorHasImplementation(eventDeclaration.RemoveAccessor);

			if (hasAccessorImplementation)
			{
				return;
			}

			EventDeclaration declaration = new EventDeclaration();
			declaration.Modifiers = eventDeclaration.Modifiers;
			declaration.ReturnType = eventDeclaration.ReturnType.Clone();
			declaration.Variables.Add(new VariableInitializer(eventDeclaration.Name));
			((TypeDeclaration)eventDeclaration.Parent!).Members.Add(declaration);
			eventDeclaration.Remove();
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixExplicitInterfaceImplementationTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using Attribute = ICSharpCode.Decompiler.CSharp.Syntax.Attribute;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Fixes implicit interface implementations as ILSpy sometimes exports properties as seperate
	/// methods which won't compile.
	/// </summary>
	internal class FixExplicitInterfaceImplementationTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitMethodDeclaration(MethodDeclaration methodDeclaration)
		{
			if (methodDeclaration.Parent is not TypeDeclaration type)
			{
				return;
			}

			bool isSpecialName = false;
			foreach (AttributeSection attributeSection in methodDeclaration.Attributes)
			{
				foreach (Attribute attribute in attributeSection.Attributes)
				{
					if (attribute.Type is SimpleType attributeType && attributeType.Identifier == "SpecialName")
					{
						isSpecialName = true;
						attribute.Remove();
						break;
					}
				}

				if (attributeSection.Attributes.Count == 0)
				{
					attributeSection.Remove();
				}
			}
			if (!isSpecialName)
			{
				return;
			}

			SpecialMemberType memberType = SpecialMemberType.Unknown;
			string memberName = methodDeclaration.Name;
			if (memberName.StartsWith("get_"))
			{
				memberName = memberName.Substring(4);
				memberType = SpecialMemberType.Getter;
			}
			else if (memberName.StartsWith("set_"))
			{
				memberName = memberName.Substring(4);
				memberType = SpecialMemberType.Setter;
			}

			if (memberType != SpecialMemberType.Getter && memberType != SpecialMemberType.Setter)
			{
				return;
			}

			PropertyDeclaration? property = null;

			foreach (EntityDeclaration member in type.Members)
			{
				if (member is PropertyDeclaration prop)
				{
					if (prop.Name == memberName &&
						// todo: better type checking
						prop.PrivateImplementationType.ToString() == methodDeclaration.PrivateImplementationType.ToString())
					{
						property = prop;
						break;
					}
				}
			}

			if (property == null)
			{
				property = new PropertyDeclaration()
				{
					Name = memberName,
					PrivateImplementationType = methodDeclaration.PrivateImplementationType.Clone()
				};
				type.Members.Add(property);
			}


			switch (memberType)
			{
				case SpecialMemberType.Getter:
					if (property.ReturnType == AstType.Null)
					{
						property.ReturnType = methodDeclaration.ReturnType.Clone();
					}

					property.Getter = new Accessor();
					property.Getter.Body = (BlockStatement)methodDeclaration.Body.Clone();
					break;
				case SpecialMemberType.Setter:

					property.Setter = new Accessor();
					property.Setter.Body = (BlockStatement)methodDeclaration.Body.Clone();
					break;
			}

			methodDeclaration.Remove();
		}

		private enum SpecialMemberType
		{
			Unknown,
			Getter,
			Setter,
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixGenericStructConstraintTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Fixes the struct constraint when the generic parameter is used as a pointer.
	/// <para>
	/// To fix this in code, you replace <see langword="struct"/> with <see langword="unmanaged"/>
	/// </para>
	/// </summary>
	internal class FixGenericStructConstraintTransform : DepthFirstAstVisitor, IAstTransform
	{
		/// <summary>
		/// A stack containing all current generic type identifiers
		/// </summary>
		private readonly Stack<string> currentGenerics = new();
		/// <summary>
		/// A set containing all generic types from <see cref="currentGenerics"/> that have
		/// been found to be used as a pointer
		/// </summary>
		private readonly HashSet<string> genericPointers = new();

		private void InitTypeParameters(AstNodeCollection<TypeParameterDeclaration> typeParameters)
		{
			foreach (TypeParameterDeclaration typeParameter in typeParameters)
			{
				currentGenerics.Push(typeParameter.Name);
			}
		}

		private void ConvertConstraints(int typeParameterCount, AstNodeCollection<Constraint> constraints)
		{
			List<string> contraintsToConvert = new();
			for (int count = 0; count < typeParameterCount; count++)
			{
				string parameter = currentGenerics.Pop();
				if (genericPointers.Contains(parameter))
				{
					contraintsToConvert.Add(parameter);
					genericPointers.Remove(parameter);
				}
			}

			foreach (Constraint constraint in constraints)
			{
				if (!contraintsToConvert.Contains(constraint.TypeParameter.Identifier))
				{
					continue;
				}

				foreach (AstType type in constraint.BaseTypes)
				{
					if (type is PrimitiveType primitiveType && primitiveType.Keyword == "struct")
					{
						primitiveType.Keyword = "unmanaged";
					}
				}
			}
		}

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			InitTypeParameters(typeDeclaration.TypeParameters);

			base.VisitTypeDeclaration(typeDeclaration);

			ConvertConstraints(typeDeclaration.TypeParameters.Count, typeDeclaration.Constraints);
		}

		public override void VisitMethodDeclaration(MethodDeclaration methodDeclaration)
		{
			InitTypeParameters(methodDeclaration.TypeParameters);

			base.VisitMethodDeclaration(methodDeclaration);

			ConvertConstraints(methodDeclaration.TypeParameters.Count, methodDeclaration.Constraints);
		}

		public override void VisitComposedType(ComposedType composedType)
		{
			base.VisitComposedType(composedType);
			if (composedType.PointerRank > 0 && composedType.BaseType is SimpleType type && currentGenerics.Contains(type.Identifier))
			{
				genericPointers.Add(type.Identifier);
			}
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixOptionalParametersTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using Attribute = ICSharpCode.Decompiler.CSharp.Syntax.Attribute;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transformer that modifiers all parameters that have an [Optional]
	/// attribute, removing that attribute and setting a default value.
	/// </summary>
	internal class FixOptionalParametersTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitParameterDeclaration(ParameterDeclaration parameterDeclaration)
		{
			foreach (AttributeSection attributeSection in parameterDeclaration.Attributes)
			{
				foreach (Attribute attribute in attributeSection.Attributes)
				{
					if (attribute.Type is SimpleType type && type.Identifier == "Optional")
					{
						attribute.Remove();
						parameterDeclaration.DefaultExpression = new DefaultValueExpression(parameterDeclaration.Type.Clone());
					}
				}
				if (attributeSection.Attributes.Count == 0)
				{
					attributeSection.Remove();
				}
			}

			base.VisitParameterDeclaration(parameterDeclaration);
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/FixStructLayoutAmbiguityTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using System.Runtime.InteropServices;
using Attribute = ICSharpCode.Decompiler.CSharp.Syntax.Attribute;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Fixes ILSpy generated code which can generate <see cref="StructLayoutAttribute"/>s on
	/// structs. For <see cref="LayoutKind.Sequential"/>, ILSpy generated the attribute as
	/// <c>StructLayout(0, ...)</c>, which is ambiguous between
	/// <see cref="StructLayoutAttribute(short)"/>, and
	/// <see cref="StructLayoutAttribute(LayoutKind)"/>
	/// </summary>
	internal class FixStructLayoutAmbiguityTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			base.VisitTypeDeclaration(typeDeclaration);
			if (typeDeclaration.ClassType != ClassType.Struct && typeDeclaration.ClassType != ClassType.Class)
			{
				return;
			}

			foreach (AttributeSection attributeSection in typeDeclaration.Attributes)
			{
				foreach (Attribute attribute in attributeSection.Attributes)
				{
					if (attribute.Type is not SimpleType attributeTypeName)
					{
						continue;
					}

					if (attributeTypeName.Identifier != "StructLayout" && attributeTypeName.Identifier != "StructLayoutAttribute")
					{
						continue;
					}

					Expression? firstArgument = attribute.Arguments.FirstOrNullObject();
					if (firstArgument != null && firstArgument is PrimitiveExpression primitive)
					{
						if (primitive.Value.Equals(0))
						{
							SimpleType type = new(nameof(LayoutKind));
							TypeReferenceExpression typeExpression = new(type);
							MemberReferenceExpression newArgument = new(typeExpression, nameof(LayoutKind.Sequential));

							attribute.Arguments.InsertBefore(firstArgument, newArgument);
							firstArgument.Remove();

							// we could implement conversion of classes to structs,
							// but can be added later if relevant.
						}
					}
				}
			}
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/MemberStubTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;

namespace AssetRipper.Library.Exporters.Scripts.Transform
{
	/// <summary>
	/// Converts all members to stubs. Is activated for Scripted Level 1.
	/// </summary>
	internal class MemberStubTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			foreach (EntityDeclaration? member in typeDeclaration.Members)
			{
				if (member is TypeDeclaration nestedType)
				{
					VisitTypeDeclaration(nestedType);
				}
				else if (member is ConstructorDeclaration constructor)
				{
					constructor.Body = new BlockStatement();
				}
				else if (member is PropertyDeclaration property)
				{
					if (!property.Getter.IsNull && !property.Getter.Body.IsNull)
					{
						property.Getter.Body = new BlockStatement();
						property.Getter.Body.Statements.Add(new ReturnStatement(new DefaultValueExpression(property.ReturnType.Clone())));
					}
					if (!property.Setter.IsNull && !property.Setter.Body.IsNull)
					{
						property.Setter.Body = new BlockStatement();
					}
					member.Remove();
				}
				else if (member is CustomEventDeclaration ev)
				{
					if (!ev.AddAccessor.IsNull && !ev.AddAccessor.Body.IsNull)
					{
						ev.AddAccessor.Body = new BlockStatement();
					}
					if (!ev.RemoveAccessor.IsNull && !ev.RemoveAccessor.Body.IsNull)
					{
						ev.RemoveAccessor.Body = new BlockStatement();
					}
				}
				else if (member is MethodDeclaration method)
				{
					method.Body = new BlockStatement();
					if (method.ReturnType is not PrimitiveType returnType || returnType.Keyword != "void")
					{
						method.Body.Statements.Add(new ReturnStatement(new DefaultValueExpression(method.ReturnType.Clone())));
					}
				}
			}
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/RemoveCompilerAttributeTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using System.Runtime.CompilerServices;
using Attribute = ICSharpCode.Decompiler.CSharp.Syntax.Attribute;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// Removes all compiler-generated attributes, like
	/// <see cref="AsyncStateMachineAttribute"/>, 
	/// <see cref="IteratorStateMachineAttribute"/>, and
	/// <see cref="IsReadOnlyAttribute"/>
	/// </summary>
	internal class RemoveCompilerAttributeTransform : DepthFirstAstVisitor, IAstTransform
	{
		private static void RemoveCompilerGeneratedAttributes(EntityDeclaration entity)
		{
			RemoveCompilerGeneratedAttributes(entity.Attributes);
		}
		private static void RemoveCompilerGeneratedAttributes(AstNodeCollection<AttributeSection> attributes)
		{
			foreach (AttributeSection attributeSection in attributes)
			{
				foreach (Attribute attribute in attributeSection.Attributes)
				{
					if (attribute.Type is SimpleType simpleType)
					{
						if (simpleType.Identifier == "AsyncStateMachine" ||
							simpleType.Identifier == "IteratorStateMachine" ||
							simpleType.Identifier == "IsReadOnly")
						{ 
							attribute.Remove();
						}
					}
				}

				if (attributeSection.Attributes.Count == 0)
				{
					attributeSection.Remove();
				}
			}
		}


		public override void VisitParameterDeclaration(ParameterDeclaration parameterDeclaration)
		{
			base.VisitParameterDeclaration(parameterDeclaration);
			RemoveCompilerGeneratedAttributes(parameterDeclaration.Attributes);
		}

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			base.VisitTypeDeclaration(typeDeclaration);
			RemoveCompilerGeneratedAttributes(typeDeclaration);
		}

		public override void VisitMethodDeclaration(MethodDeclaration methodDeclaration)
		{
			base.VisitMethodDeclaration(methodDeclaration);
			RemoveCompilerGeneratedAttributes(methodDeclaration);
		}

		public override void VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
		{
			base.VisitFieldDeclaration(fieldDeclaration);
			RemoveCompilerGeneratedAttributes(fieldDeclaration);
		}

		public override void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration)
		{
			base.VisitConstructorDeclaration(constructorDeclaration);
			RemoveCompilerGeneratedAttributes(constructorDeclaration);
		}

		public override void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration)
		{
			base.VisitPropertyDeclaration(propertyDeclaration);
			RemoveCompilerGeneratedAttributes(propertyDeclaration);
		}

		public override void VisitEnumMemberDeclaration(EnumMemberDeclaration enumMemberDeclaration)
		{
			base.VisitEnumMemberDeclaration(enumMemberDeclaration);
			RemoveCompilerGeneratedAttributes(enumMemberDeclaration);
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/RemoveInvalidMemberTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transformer that removes all invalid members
	/// </summary>
	internal class RemoveInvalidMemberTransform : DepthFirstAstVisitor, IAstTransform
	{
		/// <summary>
		/// Whether or not this transform handles il2cpp scripts.
		/// <para>
		/// IL2CPP Scripts have special members start with '_003C' instead of
		/// "&lt;" with the new Cpp2IL/ILSpy update.
		/// </para>
		/// </summary>
		private readonly bool il2cpp;

		public RemoveInvalidMemberTransform(bool il2cpp)
		{
			this.il2cpp = il2cpp;
		}

        private bool RemoveInvalidEntity(EntityDeclaration entityDeclaration)
		{
			if (!IsValidName(entityDeclaration.Name))
			{
				entityDeclaration.Remove();
				return true;
			}
			else if (entityDeclaration is FieldDeclaration fieldDeclaration)
			{
				foreach (VariableInitializer variable in fieldDeclaration.Variables)
				{
					if (!IsValidName(variable.Name))
					{
						variable.Remove();
					}
				}

				if (fieldDeclaration.Variables.Count == 0)
				{
					fieldDeclaration.Remove();
					return true;
				}
			}

			bool IsValidName(string name)
			{
				return !name.StartsWith("<") && (!il2cpp || !name.StartsWith("_003C"));
			}

			return false;
		}

		public override void VisitMethodDeclaration(MethodDeclaration methodDeclaration)
		{
			if (RemoveInvalidEntity(methodDeclaration))
			{
				return;
			}

			base.VisitMethodDeclaration(methodDeclaration);
		}

		public override void VisitFieldDeclaration(FieldDeclaration fieldDeclaration)
		{
			if (RemoveInvalidEntity(fieldDeclaration))
			{
				return;
			}

			base.VisitFieldDeclaration(fieldDeclaration);
		}

		public override void VisitConstructorDeclaration(ConstructorDeclaration constructorDeclaration)
		{
			base.VisitConstructorDeclaration(constructorDeclaration);
		}

		public override void VisitPropertyDeclaration(PropertyDeclaration propertyDeclaration)
		{
			if (RemoveInvalidEntity(propertyDeclaration))
			{
				return;
			}

			base.VisitPropertyDeclaration(propertyDeclaration);
		}

		public override void VisitTypeDeclaration(TypeDeclaration typeDeclaration)
		{
			if (RemoveInvalidEntity(typeDeclaration))
			{
				return;
			}

			base.VisitTypeDeclaration(typeDeclaration);
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/Transforms/ValidateNullCastsTransform.cs`:

```cs
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;

namespace AssetRipper.Library.Exporters.Scripts.Transforms
{
	/// <summary>
	/// A transform that validates all casts of null to a type
	/// by instead using the default expression.
	/// </summary>
	internal class ValidateNullCastsTransform : DepthFirstAstVisitor, IAstTransform
	{
		public override void VisitCastExpression(CastExpression castExpression)
		{
			if (castExpression.Expression is NullReferenceExpression)
			{
				castExpression.Expression = new DefaultValueExpression(castExpression.Type.Clone());
			}
			base.VisitCastExpression(castExpression);
		}

		public void Run(AstNode rootNode, TransformContext context)
		{
			rootNode.AcceptVisitor(this);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Scripts/WholeAssemblyDecompiler.cs`:

```cs
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection.Metadata;
using System.Threading;
using System.Threading.Tasks;
using ICSharpCode.Decompiler;
using ICSharpCode.Decompiler.CSharp;
using ICSharpCode.Decompiler.CSharp.OutputVisitor;
using ICSharpCode.Decompiler.CSharp.ProjectDecompiler;
using ICSharpCode.Decompiler.CSharp.Syntax;
using ICSharpCode.Decompiler.CSharp.Transforms;
using ICSharpCode.Decompiler.Metadata;
using ICSharpCode.Decompiler.TypeSystem;
using ICSharpCode.Decompiler.Util;
using static ICSharpCode.Decompiler.Metadata.MetadataExtensions;

namespace AssetRipper.Library.Exporters.Scripts
{
	/// <summary>
	/// Decompiles an assembly into a visual studio project file.
	/// </summary>
	public sealed class WholeAssemblyDecompiler
	{
		/// <summary>
		/// Gets the setting this instance uses for decompiling.
		/// </summary>
		public DecompilerSettings Settings { get; } = new();

		public IAssemblyResolver AssemblyResolver { get; }

		public int MaxDegreeOfParallelism { get; set; } = Environment.ProcessorCount;

		public IProgress<DecompilationProgress>? ProgressIndicator { get; set; }

		public List<IAstTransform> CustomTransforms { get; } = new();

		// per-run members
		private readonly HashSet<string> directories = new HashSet<string>(Platform.FileNameComparer);

		public WholeAssemblyDecompiler(IAssemblyResolver assemblyResolver)
		{
			AssemblyResolver = assemblyResolver ?? throw new ArgumentNullException(nameof(assemblyResolver));
		}

		public void DecompileProject(PEFile moduleDefinition, string targetDirectory, CancellationToken cancellationToken = default)
		{
			directories.Clear();
			WriteCodeFilesInProject(moduleDefinition, targetDirectory, cancellationToken);
		}

		private bool IncludeTypeWhenDecompilingProject(PEFile module, TypeDefinitionHandle type)
		{
			MetadataReader metadata = module.Metadata;
			TypeDefinition typeDef = metadata.GetTypeDefinition(type);
			if (metadata.GetString(typeDef.Name) == "<Module>" || CSharpDecompiler.MemberIsHidden(module, type, Settings))
			{
				return false;
			}

			if (metadata.GetString(typeDef.Namespace) == "XamlGeneratedNamespace" && metadata.GetString(typeDef.Name) == "GeneratedInternalTypeHelper")
			{
				return false;
			}

			return true;
		}

		private void WriteCodeFilesInProject(PEFile module, string targetDirectory, CancellationToken cancellationToken)
		{
			List<IGrouping<string, TypeDefinitionHandle>> files = GetFiles(module, targetDirectory);
			DecompilerTypeSystem ts = new DecompilerTypeSystem(module, AssemblyResolver, Settings);

			if(CustomTransforms.Count > 0) //Transforms are not thread-safe
			{
				DecompileInSerial(files, module, ts, targetDirectory, ProgressIndicator, cancellationToken);
			}
			else
			{
				DecompileInParallel(files, module, ts, targetDirectory, ProgressIndicator, cancellationToken);
			}
		}

		private List<IGrouping<string, TypeDefinitionHandle>> GetFiles(PEFile module, string targetDirectory)
		{
			MetadataReader metadata = module.Metadata;
			return metadata
				.GetTopLevelTypeDefinitions()
				.Where(td => IncludeTypeWhenDecompilingProject(module, td))
				.GroupBy(
					(TypeDefinitionHandle handle) => GetOutputPath(handle, metadata, targetDirectory), 
					StringComparer.OrdinalIgnoreCase)
				.ToList();
		}

		private string GetOutputPath(TypeDefinitionHandle handle, MetadataReader metadata, string targetDirectory)
		{
			TypeDefinition type = metadata.GetTypeDefinition(handle);
			string file = FilePathCleanup.CleanUpFileName(metadata.GetString(type.Name)) + ".cs";
			string ns = metadata.GetString(type.Namespace);
			if (string.IsNullOrEmpty(ns))
			{
				return file;
			}
			else
			{
				string dir = Settings.UseNestedDirectoriesForNamespaces ? FilePathCleanup.CleanUpPath(ns) : FilePathCleanup.CleanUpDirectoryName(ns);
				if (directories.Add(dir))
				{
					Directory.CreateDirectory(Path.Combine(targetDirectory, dir));
				}

				return Path.Combine(dir, file);
			}
		}

		private void DecompileInParallel(
			List<IGrouping<string, TypeDefinitionHandle>> files,
			PEFile module,
			DecompilerTypeSystem ts,
			string targetDirectory,
			IProgress<DecompilationProgress>? progress,
			CancellationToken cancellationToken)
		{
			int total = files.Count;
			Parallel.ForEach(
				Partitioner.Create(files, loadBalance: true),
				new ParallelOptions
				{
					MaxDegreeOfParallelism = MaxDegreeOfParallelism,
					CancellationToken = cancellationToken
				},
				(IGrouping<string, TypeDefinitionHandle> file) => DecompileSingleFile(file, module, ts, targetDirectory, total, progress, cancellationToken));
		}

		private void DecompileInSerial(
			List<IGrouping<string, TypeDefinitionHandle>> files,
			PEFile module,
			DecompilerTypeSystem ts,
			string targetDirectory,
			IProgress<DecompilationProgress>? progress,
			CancellationToken cancellationToken)
		{
			int total = files.Count;
			for(int i = 0; i < total; i++)
			{
				IGrouping<string, TypeDefinitionHandle> file = files[i];
				DecompileSingleFile(file, module, ts, targetDirectory, total, progress, cancellationToken);
			}
		}

		private void DecompileSingleFile(
			IGrouping<string, TypeDefinitionHandle> file, 
			PEFile module, 
			DecompilerTypeSystem ts,
			string targetDirectory,
			int total,
			IProgress<DecompilationProgress>? progress,
			CancellationToken cancellationToken)
		{
			using StreamWriter w = new StreamWriter(Path.Combine(targetDirectory, file.Key));
			try
			{
				CSharpDecompiler decompiler = CreateDecompiler(ts);
				decompiler.CancellationToken = cancellationToken;
				SyntaxTree syntaxTree = decompiler.DecompileTypes(file.ToArray());
				syntaxTree.AcceptVisitor(new CSharpOutputVisitor(w, Settings.CSharpFormattingOptions));
			}
			catch (Exception innerException) when (innerException is not OperationCanceledException && innerException is not DecompilerException)
			{
				throw new DecompilerException(module, $"Error decompiling for '{file.Key}'", innerException);
			}
			progress?.Report(new DecompilationProgress(total, file.Key));
		}

		private CSharpDecompiler CreateDecompiler(DecompilerTypeSystem ts)
		{
			CSharpDecompiler decompiler = new CSharpDecompiler(ts, Settings);
			decompiler.AstTransforms.Add(new EscapeInvalidIdentifiers());
			decompiler.AstTransforms.Add(new RemoveCLSCompliantAttribute());
			for (int i = 0; i < CustomTransforms.Count; i++)
			{
				decompiler.AstTransforms.Add(CustomTransforms[i]);
			}
			return decompiler;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/DummyShaderTextExporter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using System.Globalization;
using System.IO;

namespace AssetRipper.Library.Exporters.Shaders
{
	public class DummyShaderTextExporter : BinaryAssetExporter
	{
		private const string FALLBACK_DUMMY_SHADER = @"
	SubShader{
		Tags { ""RenderType"" = ""Opaque"" }
		LOD 200
		CGPROGRAM
#pragma surface surf Standard fullforwardshadows
#pragma target 3.0
		sampler2D _MainTex;
		struct Input
		{
			float2 uv_MainTex;
		};
		void surf(Input IN, inout SurfaceOutputStandard o)
		{
			fixed4 c = tex2D(_MainTex, IN.uv_MainTex);
			o.Albedo = c.rgb;
		}
		ENDCG
	}
";

		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IShader;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new AssetExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			IShader shader = (IShader)asset;

			//Importing Hidden/Internal shaders causes the unity editor screen to turn black
			if (shader.ParsedForm_C48?.NameString?.StartsWith("Hidden/Internal", StringComparison.Ordinal) ?? false)
			{
				return false;
			}

			using (FileStream fileStream = File.Create(path))
			{
				ExportShader(shader, container, fileStream);
			}
			return true;
		}

		public static void ExportShader(IShader shader, IExportContainer container, Stream stream)
		{
			if (shader.Has_ParsedForm_C48())
			{
				using InvariantStreamWriter writer = new InvariantStreamWriter(stream);
				writer.Write("Shader \"{0}\" {{\n", shader.ParsedForm_C48.NameString);
				Export(shader.ParsedForm_C48.PropInfo, writer);

				TemplateShader templateShader = TemplateList.GetBestTemplate(shader);
				writer.Write("\t//DummyShaderTextExporter\n");
				if (templateShader != null)
				{
					writer.Write(templateShader.ShaderText);
				}
				else
				{
					writer.WriteIndent(1);
					writer.Write(FALLBACK_DUMMY_SHADER.Replace("\r", ""));
				}
				writer.Write('\n');

				if (shader.ParsedForm_C48.FallbackName != string.Empty)
				{
					writer.WriteIndent(1);
					writer.Write("Fallback \"{0}\"\n", shader.ParsedForm_C48.FallbackName);
				}
				if (shader.ParsedForm_C48.CustomEditorName != string.Empty)
				{
					writer.WriteIndent(1);
					writer.Write("//CustomEditor \"{0}\"\n", shader.ParsedForm_C48.CustomEditorName);
				}
				writer.Write('}');
			}
			else if (shader is ITextAsset textAsset)
			{
				using InvariantStreamWriter writer = new InvariantStreamWriter(stream);
				string header = textAsset.Script_C49.String;
				int subshaderIndex = header.IndexOf("SubShader");
				writer.WriteString(header, 0, subshaderIndex);

				writer.Write("\t//DummyShaderTextExporter\n");
				writer.WriteIndent(1);
				writer.Write(FALLBACK_DUMMY_SHADER.Replace("\r", ""));

				writer.Write('}');
			}
			else //should never happen
			{
				throw new NotSupportedException();
			}
		}

		private static void Export(SourceGenerated.Subclasses.SerializedProperties.ISerializedProperties _this, TextWriter writer)
		{
			writer.WriteIndent(1);
			writer.Write("Properties {\n");
			foreach (SourceGenerated.Subclasses.SerializedProperty.ISerializedProperty prop in _this.Props)
			{
				Export(prop, writer);
			}
			writer.WriteIndent(1);
			writer.Write("}\n");
		}

		private static void Export(SourceGenerated.Subclasses.SerializedProperty.ISerializedProperty _this, TextWriter writer)
		{
			writer.WriteIndent(2);
			foreach (SourceGenerated.Subclasses.Utf8String.Utf8String? attribute in _this.Attributes)
			{
				writer.Write("[{0}] ", attribute);
			}
			SerializedPropertyFlag flags = (SerializedPropertyFlag)_this.Flags;
			if (flags.IsHideInInspector())
			{
				writer.Write("[HideInInspector] ");
			}
			if (flags.IsPerRendererData())
			{
				writer.Write("[PerRendererData] ");
			}
			if (flags.IsNoScaleOffset())
			{
				writer.Write("[NoScaleOffset] ");
			}
			if (flags.IsNormal())
			{
				writer.Write("[Normal] ");
			}
			if (flags.IsHDR())
			{
				writer.Write("[HDR] ");
			}
			if (flags.IsGamma())
			{
				writer.Write("[Gamma] ");
			}

			writer.Write("{0} (\"{1}\", ", _this.NameString, _this.Description);

			switch ((SerializedPropertyType)_this.Type)
			{
				case SerializedPropertyType.Color:
				case SerializedPropertyType.Vector:
					writer.Write(nameof(SerializedPropertyType.Vector));
					break;

				case SerializedPropertyType.Int:
					//case SerializedPropertyType.Float:
					writer.Write(nameof(SerializedPropertyType.Float));
					break;

				case SerializedPropertyType.Range:
					writer.Write("{0}({1}, {2})",
						nameof(SerializedPropertyType.Range),
						_this.DefValue_1_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_2_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType._2D:
					//case SerializedPropertyType._3D:
					//case SerializedPropertyType.Cube:
					switch (_this.DefTexture.TexDim)
					{
						case 1:
							writer.Write("any");
							break;
						case 2:
							writer.Write("2D");
							break;
						case 3:
							writer.Write("3D");
							break;
						case 4:
							writer.Write("Cube");
							break;
						case 5:
							writer.Write("2DArray");
							break;
						case 6:
							writer.Write("CubeArray");
							break;
						default:
							throw new NotSupportedException("Texture dimension isn't supported");

					}
					break;

				default:
					throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
			}
			writer.Write(") = ");

			switch ((SerializedPropertyType)_this.Type)
			{
				case SerializedPropertyType.Color:
				case SerializedPropertyType.Vector:
					writer.Write("({0},{1},{2},{3})",
						_this.DefValue_0_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_1_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_2_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_3_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType.Int:
				//case SerializedPropertyType.Float:
				case SerializedPropertyType.Range:
					writer.Write(_this.DefValue_0_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType._2D:
					//case SerializedPropertyType._3D:
					//case SerializedPropertyType.Cube:
					writer.Write("\"{0}\" {{}}", _this.DefTexture.DefaultName);
					break;

				default:
					throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
			}
			writer.Write('\n');
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/PropertyType.cs`:

```cs
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;

public enum PropertyType
{
	Color = 0,
	Vector = 1,
	Single = 2,
	Range = 3,
	Texture = 4,
}

public static class PropertyTypeExtensions
{
	public static bool IsMatch(this PropertyType _this, SerializedPropertyType type) => (int)_this == (int)type;
	public static bool IsMatch(this PropertyType _this, int type) => (int)_this == type;
}

```

`AssetRipperLibrary/Exporters/Shaders/RequiredProperty.cs`:

```cs
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;

namespace AssetRipper.Library.Exporters.Shaders
{
	public class RequiredProperty
	{
		public RequiredProperty() { }
		public RequiredProperty(string name, PropertyType type)
		{
			PropertyName = name ?? throw new ArgumentNullException(nameof(name));
			PropertyType = type;
		}

		public string PropertyName { get; set; }
		public string PropertyTypeName
		{
			get => PropertyType.ToString();
			set => PropertyType = Enum.Parse<PropertyType>(value);
		}
		public PropertyType PropertyType { get; set; }

		public bool IsMatch(ISerializedProperty property)
		{
			return this.PropertyName == property.NameString && PropertyType.IsMatch(property.Type);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/ShaderDisassemblyExporter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using ShaderTextRestorer.Exporters;
using ShaderTextRestorer.Exporters.DirectX;
using ShaderTextRestorer.IO;
using System.IO;

namespace AssetRipper.Library.Exporters.Shaders
{
	public sealed class ShaderDisassemblyExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IShader;
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			IShader shader = (IShader)asset;

			//Importing Hidden/Internal shaders causes the unity editor screen to turn black
			if (shader.ParsedForm_C48?.NameString?.StartsWith("Hidden/Internal") ?? false)
			{
				return false;
			}

			using Stream fileStream = File.Create(path);
			ExportBinary(shader, fileStream, ShaderExporterInstantiator);
			return true;
		}

		private ShaderTextExporter ShaderExporterInstantiator(UnityVersion version, GPUPlatform graphicApi)
		{
			switch (graphicApi)
			{
				case GPUPlatform.d3d11_9x:
				case GPUPlatform.d3d11:
				case GPUPlatform.d3d9:
					return new ShaderDXExporter(graphicApi);

				case GPUPlatform.vulkan:
					return new ShaderVulkanExporter();

				case GPUPlatform.openGL:
				case GPUPlatform.gles:
				case GPUPlatform.gles3:
				case GPUPlatform.glcore:
					return new ShaderGLESExporter();

				case GPUPlatform.metal:
					return new ShaderMetalExporter();

				case GPUPlatform.unknown:
					return new ShaderTextExporter();

				default:
					return new ShaderUnknownExporter(graphicApi);
			}
		}

		private void ExportBinary(IShader shader, Stream stream, Func<UnityVersion, GPUPlatform, ShaderTextExporter> exporterInstantiator)
		{
			if (shader.Has_ParsedForm_C48())
			{
				using ShaderWriter writer = new ShaderWriter(stream, shader, exporterInstantiator);
				(shader.ParsedForm_C48).Export(writer);
			}
			else if (shader.Has_SubProgramBlob_C48())
			{
				using ShaderWriter writer = new ShaderWriter(stream, shader, exporterInstantiator);
				string? header = shader.Script_C48?.String;
				if (writer.Blobs.Length == 0)
				{
					writer.Write(header);
				}
				else
				{
					writer.Blobs[0].Export(writer, header);
				}
			}
			else
			{
				using BinaryWriter writer = new BinaryWriter(stream);
				writer.Write(shader.Script_C48?.Data ?? Array.Empty<byte>());
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/SimpleShaderExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using System.IO;

namespace AssetRipper.Library.Exporters.Shaders
{
	/// <summary>
	/// An exporter for the occasional situation where a shader asset actually contains the shader source code
	/// </summary>
	public class SimpleShaderExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IShader && asset is ITextAsset textAsset && HasDecompiledShaderText(textAsset.Script_C49.String);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			TaskManager.AddTask(File.WriteAllBytesAsync(path, ((ITextAsset)asset).Script_C49.Data));
			return true;
		}

		private static bool HasDecompiledShaderText(string text)
		{
			return !string.IsNullOrEmpty(text) 
				&& !text.Contains("Program") 
				&& !text.Contains("SubProgram");
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/TemplateJson.cs`:

```cs
using System.Collections.Generic;

namespace AssetRipper.Library.Exporters.Shaders
{
	internal class TemplateJson
	{
		public List<TemplateShader> Templates { get; set; }
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/TemplateList.cs`:

```cs
using AssetRipper.Core.Logging;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text.Json;

namespace AssetRipper.Library.Exporters.Shaders
{
	public static class TemplateList
	{
		public const string ShaderTemplatePrefix = "AssetRipper.Library.Exporters.Shaders.Templates.";
		public const string ShaderTemplateExtension = ".txt";
		public const string TemplatesJsonPath = ShaderTemplatePrefix + "Templates.json";
		public static List<TemplateShader> Templates { get; }

		static TemplateList()
		{
			Templates = LoadTemplates();
		}

		public static TemplateShader GetBestTemplate(IShader shader)
		{
			return Templates.Where(tmp => tmp.IsMatch(shader)).MaxBy(matchedTmp => matchedTmp.RequiredProperties.Count);
		}

		private static List<TemplateShader> LoadTemplates()
		{
			Logger.Verbose("Loading shader templates");
			string jsonText = GetTextFromResource(TemplatesJsonPath);

			List<TemplateShader> templates = JsonSerializer.Deserialize<TemplateJson>(jsonText).Templates;
			foreach (TemplateShader template in templates)
			{
				string path = ShaderTemplatePrefix + template.TemplateName + ShaderTemplateExtension;
				template.ShaderText = GetTextFromResource(path);
			}
			return templates;
		}

		private static string GetTextFromResource(string path)
		{
			Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(path);
			using StreamReader reader = new(stream);
			return reader.ReadToEnd().Replace("\r", "");
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/TemplateShader.cs`:

```cs
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Library.Exporters.Shaders
{
	public class TemplateShader
	{
		public string TemplateName { get; set; }
		public List<RequiredProperty> RequiredProperties { get; set; }
		public string ShaderText { get; set; }


		public bool IsMatch(IShader shader)
		{
			if (RequiredProperties == null)
			{
				throw new System.NullReferenceException("requiredProperties cannot be null");
			}

			if (RequiredProperties.Count == 0)
			{
				return true;
			}

			Core.IO.AccessListBase<SourceGenerated.Subclasses.SerializedProperty.ISerializedProperty>? properties = shader.ParsedForm_C48.PropInfo.Props;
			if (properties == null || properties.Count == 0)
			{
				return false;
			}

			foreach (RequiredProperty? reqProp in RequiredProperties)
			{
				int matches = properties.Where(prop => reqProp.IsMatch(prop)).Count();
				if (matches == 0)
				{
					return false;
				}
			}
			return true;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/Templates/Billboard.txt`:

```txt
	SubShader
	{
		Tags{ "RenderType" = "Transparent"  "Queue" = "Geometry+0" "IgnoreProjector" = "True" }
		Cull Off
		Blend SrcAlpha OneMinusSrcAlpha
		
		AlphaToMask On
		CGINCLUDE
		#include "UnityPBSLighting.cginc"
		#include "Lighting.cginc"
		#pragma target 2.0
		struct Input
		{
			float2 uv_texcoord;
		};
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		uniform float _Clipping;
		void surf( Input i , inout SurfaceOutputStandard o )
		{
			float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
			float4 tex2DNode1 = tex2D( _MainTex, uv_MainTex );
			o.Albedo = tex2DNode1.rgb;
			o.Alpha = 1;
			clip( tex2DNode1.a - _Clipping );
		}
		ENDCG
		CGPROGRAM
		#pragma surface surf Standard keepalpha fullforwardshadows exclude_path:deferred 
		ENDCG
		Pass
		{
			Name "ShadowCaster"
			Tags{ "LightMode" = "ShadowCaster" }
			ZWrite On
			AlphaToMask Off
			CGPROGRAM
			#pragma vertex vert
			#pragma fragment frag
			#pragma target 2.0
			#pragma multi_compile_shadowcaster
			#pragma multi_compile UNITY_PASS_SHADOWCASTER
			#pragma skip_variants FOG_LINEAR FOG_EXP FOG_EXP2
			#include "HLSLSupport.cginc"
			#if ( SHADER_API_D3D11 || SHADER_API_GLCORE || SHADER_API_GLES || SHADER_API_GLES3 || SHADER_API_METAL || SHADER_API_VULKAN )
				#define CAN_SKIP_VPOS
			#endif
			#include "UnityCG.cginc"
			#include "Lighting.cginc"
			#include "UnityPBSLighting.cginc"
			struct v2f
			{
				V2F_SHADOW_CASTER;
				float2 customPack1 : TEXCOORD1;
				float3 worldPos : TEXCOORD2;
				UNITY_VERTEX_INPUT_INSTANCE_ID
				UNITY_VERTEX_OUTPUT_STEREO
			};
			v2f vert( appdata_full v )
			{
				v2f o;
				UNITY_SETUP_INSTANCE_ID( v );
				UNITY_INITIALIZE_OUTPUT( v2f, o );
				UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO( o );
				UNITY_TRANSFER_INSTANCE_ID( v, o );
				Input customInputData;
				float3 worldPos = mul( unity_ObjectToWorld, v.vertex ).xyz;
				half3 worldNormal = UnityObjectToWorldNormal( v.normal );
				o.customPack1.xy = customInputData.uv_texcoord;
				o.customPack1.xy = v.texcoord;
				o.worldPos = worldPos;
				TRANSFER_SHADOW_CASTER_NORMALOFFSET( o )
				return o;
			}
			half4 frag( v2f IN
			#if !defined( CAN_SKIP_VPOS )
			, UNITY_VPOS_TYPE vpos : VPOS
			#endif
			) : SV_Target
			{
				UNITY_SETUP_INSTANCE_ID( IN );
				Input surfIN;
				UNITY_INITIALIZE_OUTPUT( Input, surfIN );
				surfIN.uv_texcoord = IN.customPack1.xy;
				float3 worldPos = IN.worldPos;
				half3 worldViewDir = normalize( UnityWorldSpaceViewDir( worldPos ) );
				SurfaceOutputStandard o;
				UNITY_INITIALIZE_OUTPUT( SurfaceOutputStandard, o )
				surf( surfIN, o );
				#if defined( CAN_SKIP_VPOS )
				float2 vpos = IN.pos;
				#endif
				SHADOW_CASTER_FRAGMENT( IN )
			}
			ENDCG
		}
	}

```

`AssetRipperLibrary/Exporters/Shaders/Templates/Default.txt`:

```txt
	SubShader{
		Tags { "RenderType" = "Opaque" }
		LOD 200
		CGPROGRAM
#pragma surface surf Standard
#pragma target 3.0

		struct Input
		{
			float2 uv_MainTex;
		};

		void surf(Input IN, inout SurfaceOutputStandard o)
		{
			o.Albedo = 1;
		}
		ENDCG
	}
```

`AssetRipperLibrary/Exporters/Shaders/Templates/ParticlesLit.txt`:

```txt
	Category 
	{
		SubShader
		{
		LOD 0
			Tags { "Queue"="Transparent" "IgnoreProjector"="True" "RenderType"="Transparent" "PreviewType"="Plane" }
			Blend SrcAlpha OneMinusSrcAlpha
			ColorMask RGB
			Cull Off
			Lighting Off 
			ZWrite Off
			ZTest LEqual
			Pass {
				CGPROGRAM
				#ifndef UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX
				#define UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(input)
				#endif
				#pragma vertex vert
				#pragma fragment frag
				#pragma target 2.0
				#pragma multi_compile_instancing
				#pragma multi_compile_particles
				#pragma multi_compile_fog
				#include "UnityShaderVariables.cginc"
				#include "UnityCG.cginc"
				struct appdata_t 
				{
					float4 vertex : POSITION;
					fixed4 color : COLOR;
					float4 texcoord : TEXCOORD0;
					UNITY_VERTEX_INPUT_INSTANCE_ID
					
				};
				struct v2f 
				{
					float4 vertex : SV_POSITION;
					fixed4 color : COLOR;
					float4 texcoord : TEXCOORD0;
					UNITY_FOG_COORDS(1)
					#ifdef SOFTPARTICLES_ON
					float4 projPos : TEXCOORD2;
					#endif
					UNITY_VERTEX_INPUT_INSTANCE_ID
					UNITY_VERTEX_OUTPUT_STEREO
					
				};
				#if UNITY_VERSION >= 560
				UNITY_DECLARE_DEPTH_TEXTURE( _CameraDepthTexture );
				#else
				uniform sampler2D_float _CameraDepthTexture;
				#endif
				uniform sampler2D _MainTex;
				uniform fixed4 _TintColor;
				uniform float4 _MainTex_ST;
				uniform float _InvFade;
				v2f vert ( appdata_t v  )
				{
					v2f o;
					UNITY_SETUP_INSTANCE_ID(v);
					UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
					UNITY_TRANSFER_INSTANCE_ID(v, o);
					

					v.vertex.xyz += _SinTime.xyz;
					o.vertex = UnityObjectToClipPos(v.vertex);
					#ifdef SOFTPARTICLES_ON
						o.projPos = ComputeScreenPos (o.vertex);
						COMPUTE_EYEDEPTH(o.projPos.z);
					#endif
					o.color = v.color;
					o.texcoord = v.texcoord;
					UNITY_TRANSFER_FOG(o,o.vertex);
					return o;
				}

				fixed4 frag ( v2f i  ) : SV_Target
				{
					UNITY_SETUP_INSTANCE_ID( i );
					UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX( i );

					#ifdef SOFTPARTICLES_ON
						float sceneZ = LinearEyeDepth (SAMPLE_DEPTH_TEXTURE_PROJ(_CameraDepthTexture, UNITY_PROJ_COORD(i.projPos)));
						float partZ = i.projPos.z;
						float fade = saturate (_InvFade * (sceneZ-partZ));
						i.color.a *= fade;
					#endif

					

					fixed4 col = 2.0f * i.color * _TintColor * tex2D(_MainTex, i.texcoord.xy*_MainTex_ST.xy + _MainTex_ST.zw );
					UNITY_APPLY_FOG(i.fogCoord, col);
					return col;
				}
				ENDCG 
			}
		}	
	}

```

`AssetRipperLibrary/Exporters/Shaders/Templates/SingleColor.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200
		CGPROGRAM
#pragma surface surf Standard
#pragma target 3.0

		fixed4 _Color;
		struct Input
		{
			float2 uv_MainTex;
		};
		
		void surf(Input IN, inout SurfaceOutputStandard o)
		{
			o.Albedo = _Color.rgb;
			o.Alpha = _Color.a;
		}
		ENDCG
	}
```

`AssetRipperLibrary/Exporters/Shaders/Templates/SingleTexture.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200
		CGPROGRAM
#pragma surface surf Standard
#pragma target 3.0

		sampler2D _MainTex;
		struct Input
		{
			float2 uv_MainTex;
		};

		void surf(Input IN, inout SurfaceOutputStandard o)
		{
			fixed4 c = tex2D(_MainTex, IN.uv_MainTex);
			o.Albedo = c.rgb;
			o.Alpha = c.a;
		}
		ENDCG
	}
```

`AssetRipperLibrary/Exporters/Shaders/Templates/Templates.json`:

```json
{
	"Templates" : [
		{
			"TemplateName" : "Default",
			"RequiredProperties" : []
		},
		{
			"TemplateName" : "SingleTexture",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				}]
		},
		{
			"TemplateName" : "SingleColor",
			"RequiredProperties" : [
				{
					"PropertyName" : "_Color",
					"PropertyTypeName" : "Color"
				}]
		},
		{
			"TemplateName" : "TransparentDiffuse",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				},
				{
					"PropertyName" : "_Color",
					"PropertyTypeName" : "Color"
				}]
		},
		{
			"TemplateName" : "Billboard",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				},
				{
					"PropertyName" : "_Clipping",
					"PropertyTypeName" : "Range"
				}
			]
		},
		{
			"TemplateName" : "ParticlesLit",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				},
				{
					"PropertyName" : "_InvFade",
					"PropertyTypeName" : "Range"
				},
				{
					"PropertyName" : "_TintColor",
					"PropertyTypeName" : "Color"
				}
			]
		},
		{
			"TemplateName" : "Unlit",
			"RequiredProperties" : [
				{
					"PropertyName" : "_MainTex",
					"PropertyTypeName" : "Texture"
				},
				{
					"PropertyName" : "_Culling",
					"PropertyTypeName" : "Range"
				}
			]
		}
	]
}
```

`AssetRipperLibrary/Exporters/Shaders/Templates/TransparentDiffuse.txt`:

```txt
	SubShader{
		Tags { "RenderType"="Opaque" }
		LOD 200
		CGPROGRAM
#pragma surface surf Standard
#pragma target 3.0

		sampler2D _MainTex;
		fixed4 _Color;
		struct Input
		{
			float2 uv_MainTex;
		};
		
		void surf(Input IN, inout SurfaceOutputStandard o)
		{
			fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
			o.Albedo = c.rgb;
			o.Alpha = c.a;
		}
		ENDCG
	}
```

`AssetRipperLibrary/Exporters/Shaders/Templates/Unlit.txt`:

```txt
	SubShader
	{
		Tags{ "RenderType" = "Opaque"  "Queue" = "Geometry+0" }
		Cull [_Culling]
		CGPROGRAM
		#pragma target 2.0
		#pragma surface surf Standard keepalpha noshadow 
		struct Input
		{
			float2 uv_texcoord;
		};
		uniform float _Culling;
		uniform sampler2D _MainTex;
		uniform float4 _MainTex_ST;
		void surf( Input i , inout SurfaceOutputStandard o )
		{
			float2 uv_MainTex = i.uv_texcoord * _MainTex_ST.xy + _MainTex_ST.zw;
			o.Albedo = tex2D( _MainTex, uv_MainTex ).rgb;
			o.Alpha = 1;
		}
		ENDCG
	}
```

`AssetRipperLibrary/Exporters/Shaders/YamlShaderExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Library.Exporters.Shaders
{
	public sealed class YamlShaderExportCollection : AssetExportCollection
	{
		public YamlShaderExportCollection(YamlShaderExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset) => "asset";
	}
}

```

`AssetRipperLibrary/Exporters/Shaders/YamlShaderExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_48;

namespace AssetRipper.Library.Exporters.Shaders
{
	/// <summary>
	/// An exporter for exporting shaders as unity assets. Shader.Find will not work in the Unity Editor with this exporter.
	/// </summary>
	public sealed class YamlShaderExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset) => asset is IShader;

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new YamlShaderExportCollection(this, asset);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Terrains/TerrainHeatmapExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Library.Configuration;

namespace AssetRipper.Library.Exporters.Terrains
{
	public sealed class TerrainHeatmapExportCollection : AssetExportCollection
	{
		public TerrainHeatmapExportCollection(TerrainHeatmapExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return ((TerrainHeatmapExporter)AssetExporter).ImageFormat.GetFileExtension();
		}
	}
}

```

`AssetRipperLibrary/Exporters/Terrains/TerrainHeatmapExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Math.Colors;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Library.Configuration;
using AssetRipper.Library.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_156;

namespace AssetRipper.Library.Exporters.Terrains
{
	public sealed class TerrainHeatmapExporter : BinaryAssetExporter
	{
		public ImageExportFormat ImageFormat { get; }
		public TerrainHeatmapExporter(LibraryConfiguration configuration)
		{
			ImageFormat = configuration.ImageExportFormat;
		}

		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is ITerrainData;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new TerrainHeatmapExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			ITerrainData terrain = (ITerrainData)asset;
			using DirectBitmap bitmap = GetBitmap(terrain);
			if (bitmap == null)
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{terrain.NameString}' to bitmap");
				return false;
			}
			if (OperatingSystem.IsWindows())
			{
				bitmap.Save(path, ImageFormat);
			}
			else
			{
				TaskManager.AddTask(bitmap.SaveAsync(path, ImageFormat));
			}
			return true;
		}

		public static DirectBitmap GetBitmap(ITerrainData terrain)
		{
			DirectBitmap bitmap = new DirectBitmap(
				Math.Max(terrain.Heightmap_C156.Width, terrain.Heightmap_C156.Resolution),
				Math.Max(terrain.Heightmap_C156.Height, terrain.Heightmap_C156.Resolution), 
				GetBGRA32Data(terrain));
			bitmap.FlipY();
			return bitmap;
		}

		public static byte[] GetBGRA32Data(ITerrainData terrain)
		{
			short[] heights = terrain.Heightmap_C156.Heights;
			byte[] result = new byte[heights.Length * 4];
			for (int y = 0; y < heights.Length; y++)
			{
				ColorRGBA32 color = (ColorRGBA32)ConvertToColor((float)heights[y] / short.MaxValue);
				result[4 * y] = color.B();
				result[4 * y + 1] = color.G();
				result[4 * y + 2] = color.R();
				result[4 * y + 3] = byte.MaxValue; //small optimization
			}
			return result;
		}

		private static ColorRGBAf ConvertToColor(float value)
		{
			if (value <= 0f)
			{
				return zero;
			}
			else if (value < q1point)
			{
				return Average(zero, 0f, q1, q1point, value);
			}
			else if (value < q2point)
			{
				return Average(q1, q1point, q2, q2point, value);
			}
			else if (value < q3point)
			{
				return Average(q2, q2point, q3, q3point, value);
			}
			else if (value < 1f)
			{
				return Average(q3, q3point, one, 1f, value);
			}
			else
			{
				return one;
			}
		}

		private static float Normalize(float min, float max, float value)
		{
			if (value <= min)
			{
				return 0f;
			}
			else if (value >= max)
			{
				return 1f;
			}
			else
			{
				return (value - min) / (max - min);
			}
		}

		private static ColorRGBAf Average(ColorRGBAf minColor, float min, ColorRGBAf maxColor, float max, float value)
		{
			float normalized = Normalize(min, max, value);
			return (1 - normalized) * minColor + normalized * maxColor;
		}

		private static readonly ColorRGBAf zero = new(0, 0, 0.4f, 1);
		private static readonly ColorRGBAf q1 = new(0, 0, 1, 1);
		private static readonly ColorRGBAf q2 = new(0, 1, 0, 1);
		private static readonly ColorRGBAf q3 = new(1, 0, 0, 1);
		private static readonly ColorRGBAf one = ColorRGBAf.White;

		private const float q1point = 0.15f;
		private const float q2point = 0.3f;
		private const float q3point = 0.6f;
	}
}

```

`AssetRipperLibrary/Exporters/Terrains/TerrainObjExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;

namespace AssetRipper.Library.Exporters.Terrains
{
	public sealed class TerrainObjExportCollection : AssetExportCollection
	{
		public TerrainObjExportCollection(TerrainObjExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset) => "obj";
	}
}

```

`AssetRipperLibrary/Exporters/Terrains/TerrainObjExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Math.Vectors;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using System.IO;
using System.Text;

namespace AssetRipper.Library.Exporters.Terrains
{
	public sealed class TerrainObjExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is ITerrainData;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new TerrainObjExportCollection(this, asset);
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			string text = ExportTerrainToObj((ITerrainData)asset);
			if (string.IsNullOrEmpty(text))
			{
				return false;
			}

			using (FileStream fileStream = File.Create(path))
			{
				using StreamWriter sw = new StreamWriter(fileStream);
				sw.Write(text);
			}
			return true;
		}

		private static string ExportTerrainToObj(ITerrainData terrain)
		{
			StringBuilder sb = new StringBuilder();
			int tw = Math.Max(terrain.Heightmap_C156.Width, terrain.Heightmap_C156.Resolution);
			int th = Math.Max(terrain.Heightmap_C156.Height, terrain.Heightmap_C156.Resolution);

			//Vector3f meshScale = terrain.Heightmap.Scale;
			Vector3f meshScale = new Vector3f(-1, 1, 1);
			meshScale = new Vector3f(meshScale.X / (tw - 1), meshScale.Y, meshScale.Z / (th - 1));
			Vector2f uvScale = new Vector2f(1.0f / (tw - 1), 1.0f / (th - 1));

			int w = th;
			int h = tw;

			int startX = 0;
			int startY = 0;

			float[,] tData = GetHeights(terrain);
			Vector3f[] tVertices = new Vector3f[w * h];
			Vector2f[] tUV = new Vector2f[w * h];

			int[] tPolys = new int[(w - 1) * (h - 1) * 6];

			for (int y = 0; y < h; y++)
			{
				for (int x = 0; x < w; x++)
				{
					Vector3f pos = new Vector3f(-(startY + y), tData[startX + x, startY + y], (startX + x));
					tVertices[y * w + x] = Vector3f.Scale(meshScale, pos);
					tUV[y * w + x] = Vector2f.Scale(new Vector2f(x, y), uvScale);
				}
			}
			int index = 0;
			for (int y = 0; y < h - 1; y++)
			{
				for (int x = 0; x < w - 1; x++)
				{
					tPolys[index++] = (y * w) + x;
					tPolys[index++] = ((y + 1) * w) + x;
					tPolys[index++] = (y * w) + x + 1;
					tPolys[index++] = ((y + 1) * w) + x;
					tPolys[index++] = ((y + 1) * w) + x + 1;
					tPolys[index++] = (y * w) + x + 1;
				}
			}

			for (int i = 0; i < tVertices.Length; i++)
			{
				sb.AppendFormat("v {0} {1} {2}\n", tVertices[i].X, tVertices[i].Y, tVertices[i].Z);
			}
			for (int i = 0; i < tUV.Length; i++)
			{
				sb.AppendFormat("vt {0} {1}\n", tUV[i].X, tUV[i].Y);
			}
			for (int i = 0; i < tPolys.Length; i += 3)
			{
				int x = tPolys[i] + 1;
				int y = tPolys[i + 1] + 1;
				int z = tPolys[i + 2] + 1;
				sb.AppendFormat("f {0} {1} {2}\n", x, y, z);
			}
			return sb.ToString();
		}

		private static float[,] GetHeights(ITerrainData terrain)
		{
			int width = Math.Max(terrain.Heightmap_C156.Width, terrain.Heightmap_C156.Resolution);
			int height = Math.Max(terrain.Heightmap_C156.Height, terrain.Heightmap_C156.Resolution);
			short[] heights = terrain.Heightmap_C156.Heights;
			float[,] result = new float[width, height];
			for (int y = 0; y < height; y++)
			{
				for (int x = 0; x < width; x++)
				{
					result[x, y] = (float)heights[x + y * width] / short.MaxValue;
				}
			}
			return result;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/CrunchHandler.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Logging;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

namespace AssetRipper.Library.Exporters.Textures
{
	internal static class CrunchHandler
	{
		public static byte[] DecompressCrunch(TextureFormat textureFormat, int width, int height, UnityVersion unityVersion, byte[] data)
		{
			if (OperatingSystem.IsWindows())
			{
				return DecompressCrunchWithUtinyDecoder(textureFormat, width, height, unityVersion, data);
			}
			else
			{
				return DecompressCrunchWithStudioDecoder(textureFormat, width, height, unityVersion, data);
			}
		}

		private static bool IsUseUnityCrunch(UnityVersion version, TextureFormat format)
		{
			if (version.IsGreaterEqual(2017, 3))
			{
				return true;
			}
			return format == TextureFormat.ETC_RGB4Crunched || format == TextureFormat.ETC2_RGBA8Crunched;
		}

		[SupportedOSPlatform("windows")]
		[DllImport("crunch", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool DecompressCRN(byte[] pSrcFileData, int srcFileSize, out IntPtr uncompressedData, out int uncompressedSize);

		[SupportedOSPlatform("windows")]
		[DllImport("crunchunity", CallingConvention = CallingConvention.Cdecl)]
		private static extern bool DecompressUnityCRN(byte[] pSrc_file_data, int src_file_size, out IntPtr uncompressedData, out int uncompressedSize);

		[SupportedOSPlatform("windows")]
		private static byte[] DecompressCrunchWithUtinyDecoder(TextureFormat textureFormat, int width, int height, UnityVersion unityVersion, byte[] data)
		{
			IntPtr uncompressedData = default;
			try
			{
				bool result = IsUseUnityCrunch(unityVersion, textureFormat) ?
					DecompressUnityCRN(data, data.Length, out uncompressedData, out int uncompressedSize) :
					DecompressCRN(data, data.Length, out uncompressedData, out uncompressedSize);
				if (result)
				{
					byte[] uncompressedBytes = new byte[uncompressedSize];
					Marshal.Copy(uncompressedData, uncompressedBytes, 0, uncompressedSize);
					return uncompressedBytes;
				}
				else
				{
					throw new Exception("Unable to decompress crunched texture");
				}
			}
			finally
			{
				Marshal.FreeHGlobal(uncompressedData);
			}
		}

		private static byte[] DecompressCrunchWithStudioDecoder(TextureFormat textureFormat, int width, int height, UnityVersion unityVersion, byte[] data)
		{
			bool result = IsUseUnityCrunch(unityVersion, textureFormat) ?
					DecompressUnityCrunchWithStudioDecoder(data, out byte[] uncompressedBytes) :
					DecompressNormalCrunchWithStudioDecoder(data, out uncompressedBytes);
			if (result)
			{
				return uncompressedBytes;
			}
			else
			{
				throw new Exception("Unable to decompress crunched texture");
			}
		}

		private static bool DecompressNormalCrunchWithStudioDecoder(byte[] data, out byte[] uncompressedBytes)
		{
			if (data is null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			if (data.Length == 0)
			{
				throw new ArgumentException(nameof(data));
			}

			Logger.Info("About to unpack normal crunch...");
			uncompressedBytes = Texture2DDecoder.TextureDecoder.UnpackCrunch(data);
			return uncompressedBytes != null;
		}

		private static bool DecompressUnityCrunchWithStudioDecoder(byte[] data, out byte[] uncompressedBytes)
		{
			if (data is null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			if (data.Length == 0)
			{
				throw new ArgumentException(nameof(data));
			}

			Logger.Info("About to unpack unity crunch...");
			uncompressedBytes = Texture2DDecoder.TextureDecoder.UnpackUnityCrunch(data);
			return uncompressedBytes != null;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/Enums/KTXBaseInternalFormat.cs`:

```cs
namespace AssetRipper.Library.Exporters.Textures.Enums
{
	public enum KTXBaseInternalFormat : uint
	{
		DEPTH_COMPONENT = 0x1902,
		DEPTH_STENCIL = 0x84F9,
		RED = 0x1903,
		RG = 0x8227,
		RGB = 0x1907,
		RGBA = 0x1908,
		STENCIL_INDEX = 0x1901,
	}
}

```

`AssetRipperLibrary/Exporters/Textures/Enums/TexgenpackTexturetype.cs`:

```cs
namespace AssetRipper.Library.Exporters.Textures.Enums
{
	public enum TexgenpackTexturetype
	{
		RGTC1,
		RGTC2,
		BPTC_FLOAT,
		BPTC
	}
}

```

`AssetRipperLibrary/Exporters/Textures/Extensions/Texture2DExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Library.Exporters.Textures.Enums;

namespace AssetRipper.Library.Exporters.Textures.Extensions
{
	public static class Texture2DExtensions
	{
		/// <summary>
		/// Get the applicable KTX base format for a texture
		/// </summary>
		/// <param name="_this">The texture</param>
		/// <param name="safe">If true, this method will return RG rather than throwing an exception.</param>
		/// <returns>The format</returns>
		/// <exception cref="NotSupportedException">if not safe and not an pvrtc texture</exception>
		public static KTXBaseInternalFormat GetKTXBaseInternalFormat(this SourceGenerated.Classes.ClassID_28.ITexture2D _this, bool safe)
		{
			switch ((TextureFormat)_this.TextureFormat_C28)
			{
				case TextureFormat.RHalf:
				case TextureFormat.RFloat:
				case TextureFormat.BC4:
				case TextureFormat.EAC_R:
				case TextureFormat.EAC_R_SIGNED:
					return KTXBaseInternalFormat.RED;

				case TextureFormat.RGHalf:
				case TextureFormat.RGFloat:
				case TextureFormat.BC5:
				case TextureFormat.EAC_RG:
				case TextureFormat.EAC_RG_SIGNED:
					return KTXBaseInternalFormat.RG;

				case TextureFormat.BC6H:
				case TextureFormat.PVRTC_RGB2:
				case TextureFormat.PVRTC_RGB4:
				case TextureFormat.ETC_RGB4Crunched:
				case TextureFormat.ETC_RGB4_3DS:
				case TextureFormat.ETC_RGB4:
				case TextureFormat.ATC_RGB4:
				case TextureFormat.ETC2_RGB:
					return KTXBaseInternalFormat.RGB;

				case TextureFormat.RGBAHalf:
				case TextureFormat.RGBAFloat:
				case TextureFormat.BC7:
				case TextureFormat.PVRTC_RGBA2:
				case TextureFormat.PVRTC_RGBA4:
				case TextureFormat.ATC_RGBA8:
				case TextureFormat.ETC2_RGBA8Crunched:
				case TextureFormat.ETC_RGBA8_3DS:
				case TextureFormat.ETC2_RGBA8:
				case TextureFormat.ETC2_RGBA1:
					return KTXBaseInternalFormat.RGBA;

				default:
					{
						if (safe)
						{
							return KTXBaseInternalFormat.RG;
						}
						else
						{
							throw new NotSupportedException(((TextureFormat)_this.TextureFormat_C28).ToString());
						}
					}
			}
		}

		/// <summary>
		/// Get the cooresponding PVRTC bit count for a texture
		/// </summary>
		/// <param name="_this">The texture</param>
		/// <param name="safe">If true, this method will return zero rather than throwing an exception.</param>
		/// <returns>The bit count</returns>
		/// <exception cref="NotSupportedException">if not safe and not an pvrtc texture</exception>
		public static int PVRTCBitCount(this SourceGenerated.Classes.ClassID_28.ITexture2D _this, bool safe)
		{
			switch ((TextureFormat)_this.TextureFormat_C28)
			{
				case TextureFormat.PVRTC_RGB2:
				case TextureFormat.PVRTC_RGBA2:
					return 2;

				case TextureFormat.PVRTC_RGB4:
				case TextureFormat.PVRTC_RGBA4:
					return 4;

				default:
					{
						if (safe)
						{
							return 0;
						}
						else
						{
							throw new NotSupportedException(((TextureFormat)_this.TextureFormat_C28).ToString());
						}
					}
			}
		}

		/// <summary>
		/// Get the cooresponding ASTC block size for a texture
		/// </summary>
		/// <param name="_this">The texture</param>
		/// <param name="safe">If true, this method will return zero rather than throwing an exception.</param>
		/// <returns>The length of one side of the block</returns>
		/// <exception cref="NotSupportedException">if not safe and not an astc texture</exception>
		public static int ASTCBlockSize(this SourceGenerated.Classes.ClassID_28.ITexture2D _this, bool safe)
		{
			switch ((TextureFormat)_this.TextureFormat_C28)
			{
				case TextureFormat.ASTC_RGB_4x4:
				case TextureFormat.ASTC_RGBA_4x4:
					return 4;

				case TextureFormat.ASTC_RGB_5x5:
				case TextureFormat.ASTC_RGBA_5x5:
					return 5;

				case TextureFormat.ASTC_RGB_6x6:
				case TextureFormat.ASTC_RGBA_6x6:
					return 6;

				case TextureFormat.ASTC_RGB_8x8:
				case TextureFormat.ASTC_RGBA_8x8:
					return 8;

				case TextureFormat.ASTC_RGB_10x10:
				case TextureFormat.ASTC_RGBA_10x10:
					return 10;

				case TextureFormat.ASTC_RGB_12x12:
				case TextureFormat.ASTC_RGBA_12x12:
					return 12;

				default:
					{
						if (safe)
						{
							return 0;
						}
						else
						{
							throw new NotSupportedException(((TextureFormat)_this.TextureFormat_C28).ToString());
						}
					}
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/ImporterFactory.cs`:

```cs
using AssetRipper.Core.Classes.Meta.Importers.Texture;
using AssetRipper.Core.Classes.Sprite;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Project;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Classes.ClassID_1055;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_89;
using AssetRipper.SourceGenerated.Subclasses.TextureImporterPlatformSettings;

namespace AssetRipper.Library.Exporters.Textures
{
	public static class ImporterFactory
	{
		public static ITextureImporter GenerateTextureImporter(IExportContainer container, ITexture2D origin)
		{
			ITextureImporter instance = TextureImporterFactory.CreateAsset(container.ExportLayout.Version);
			instance.MipMaps_C1006.EnableMipMap = origin.MipCount_C28 > 1 ? 1 : 0;
			instance.MipMaps_C1006.SRGBTexture = origin.ColorSpace_C28 == (int)ColorSpace.Linear ? 1 : 0;
			instance.MipMaps_C1006.AlphaTestReferenceValue = 0.5f;
			instance.MipMaps_C1006.MipMapFadeDistanceStart = 1;
			instance.MipMaps_C1006.MipMapFadeDistanceEnd = 3;
			instance.BumpMap_C1006.HeightScale = .25f;
			instance.GenerateCubemap_C1006 = (int)TextureImporterGenerateCubemap.AutoCubemap;
			instance.StreamingMipmaps_C1006 = origin.StreamingMipmaps_C28 ? 1 : 0;
			instance.StreamingMipmapsPriority_C1006 = origin.StreamingMipmapsPriority_C28;
			instance.IsReadable_C1006 = origin.IsReadable_C28 ? 1 : 0;
			instance.TextureFormat_C1006 = origin.TextureFormat_C28;
			instance.MaxTextureSize_C1006 = Math.Min(2048, Math.Max(origin.Width_C28, origin.Height_C28));
			instance.TextureSettings_C1006.CopyValues(origin.TextureSettings_C28);
			instance.NPOTScale_C1006 = (int)TextureImporterNPOTScale.None;
			instance.CompressionQuality_C1006 = 50;

			instance.SpriteMode_C1006 = (int)SpriteImportMode.Single;
			instance.SpriteExtrude_C1006 = 1;
			instance.SpriteMeshType_C1006 = (int)SpriteMeshType.Tight;
			instance.SpritePivot_C1006?.SetValues(0.5f, 0.5f);
			instance.SpritePixelsToUnits_C1006 = 100.0f;
			instance.SpriteGenerateFallbackPhysicsShape_C1006 = 1;
			instance.AlphaUsage_C1006 = (int)TextureImporterAlphaSource.FromInput;
			instance.AlphaIsTransparency_C1006 = 1;
			instance.SpriteTessellationDetail_C1006 = -1;
			instance.TextureType_C1006 = GetTextureTypeFromLightmapFormat(origin);
			instance.TextureShape_C1006 = origin is ICubemap
				? (int)TextureImporterShape.TextureCube
				: (int)TextureImporterShape.Texture2D;

			ITextureImporterPlatformSettings platformSettings = instance.PlatformSettings_C1006.AddNew();
			platformSettings.BuildTarget.String = "DefaultTexturePlatform";
			platformSettings.MaxTextureSize = 2048;
			platformSettings.ResizeAlgorithm = (int)TextureResizeAlgorithm.Mitchell;
			platformSettings.TextureFormat = (int)TextureFormat.Automatic;
			platformSettings.TextureCompression = (int)TextureImporterCompression.Uncompressed;
			platformSettings.CompressionQuality = 50;
			platformSettings.CrunchedCompression = false;
			platformSettings.AllowsAlphaSplitting = false;
			platformSettings.Overridden = false;
			platformSettings.AndroidETC2FallbackOverride = (int)AndroidETC2FallbackOverride.UseBuildSettings;
			platformSettings.ForceMaximumCompressionQuality_BC6H_BC7 = false;

			return instance;
		}

		private static int GetTextureTypeFromLightmapFormat(ITexture2D origin)
		{
			return ((TextureUsageMode)origin.LightmapFormat_C28).IsNormalmap()
				? (int)TextureImporterType.NormalMap
				: (int)TextureImporterType.Default;
		}

		public static IIHVImageFormatImporter GenerateIHVImporter(IExportContainer container, ITexture2D origin)
		{
			if (container.ExportLayout.Version.IsLess(5, 6))
			{
				Logger.Warning("IHVImageFormatImporter doesn't exist on versions less than 5.6. A different importer needs to be used on this version");
			}
			IIHVImageFormatImporter instance = IHVImageFormatImporterFactory.CreateAsset(container.ExportLayout.Version);
			instance.SetToDefault();
			instance.IsReadable_C1055 = origin.IsReadable_C28;
			instance.SRGBTexture_C1055 = origin.ColorSpace_C28 == (int)ColorSpace.Linear;
			instance.StreamingMipmaps_C1055 = origin.StreamingMipmaps_C28;
			instance.StreamingMipmapsPriority_C1055 = origin.StreamingMipmapsPriority_C28;
			return instance;
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/RawTextureExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_28;

namespace AssetRipper.Library.Exporters.Textures
{
	internal class RawTextureExportCollection : AssetExportCollection
	{
		public RawTextureExportCollection(IAssetExporter assetExporter, ITexture2D asset) : base(assetExporter, asset)
		{
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			return ((Core.Classes.Texture2D.TextureFormat)((ITexture2D)asset).TextureFormat_C28).ToString();
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/RawTextureExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using System.IO;

namespace AssetRipper.Library.Exporters.Textures
{
	internal class RawTextureExporter : BinaryAssetExporter
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is ITexture2D;
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			File.WriteAllBytes(path, ((ITexture2D)asset).GetImageData());
			return true;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new RawTextureExportCollection(this, (ITexture2D)asset);
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/TexGenPackHandler.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Library.Exporters.Textures.Enums;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

namespace AssetRipper.Library.Exporters.Textures
{
	internal static class TexGenPackHandler
	{
		[SupportedOSPlatform("windows")]
		[DllImport("texgenpack", CallingConvention = CallingConvention.Cdecl)]
		private static extern void texgenpackdecode(int texturetype, byte[] texturedata, int width, int height, IntPtr bmp, bool fixAlpha);

		public static bool IsAvailable() => OperatingSystem.IsWindows();

		public static bool Decode(TextureFormat textureFormat, byte[] texturedata, int width, int height, IntPtr bmp, bool fixAlpha)
		{
			if (!OperatingSystem.IsWindows())
			{
				return false;
			}

			texgenpackdecode((int)ToTexgenpackTexturetype(textureFormat), texturedata, width, height, bmp, fixAlpha);
			return true;
		}

		private static TexgenpackTexturetype ToTexgenpackTexturetype(TextureFormat format)
		{
			return format switch
			{
				TextureFormat.BC4 => TexgenpackTexturetype.RGTC1,
				TextureFormat.BC5 => TexgenpackTexturetype.RGTC2,
				TextureFormat.BC6H => TexgenpackTexturetype.BPTC_FLOAT,
				TextureFormat.BC7 => TexgenpackTexturetype.BPTC,
				_ => throw new NotSupportedException(format.ToString()),
			};
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/TextureAssetExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Library.Configuration;
using AssetRipper.Library.Exporters.Textures.Enums;
using AssetRipper.Library.Exporters.Textures.Extensions;
using AssetRipper.Library.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_213;

namespace AssetRipper.Library.Exporters.Textures
{
	public class TextureAssetExporter : BinaryAssetExporter
	{
		private ImageExportFormat ImageExportFormat { get; set; }
		private SpriteExportMode SpriteExportMode { get; set; }

		public TextureAssetExporter(LibraryConfiguration configuration)
		{
			ImageExportFormat = configuration.ImageExportFormat;
			SpriteExportMode = configuration.SpriteExportMode;
		}

		public override bool IsHandle(IUnityObjectBase asset)
		{
			if (asset is SourceGenerated.Classes.ClassID_28.ITexture2D texture)
			{
				return texture.CheckAssetIntegrity();
			}
			if (asset is ISprite)
			{
				return SpriteExportMode == SpriteExportMode.Texture2D;
			}
			return false;
		}

		public override bool Export(IExportContainer container, IUnityObjectBase asset, string path)
		{
			SourceGenerated.Classes.ClassID_28.ITexture2D texture = (SourceGenerated.Classes.ClassID_28.ITexture2D)asset;
			if (!texture.CheckAssetIntegrity())
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Can't export '{texture.NameString}' because resources file '{texture.StreamData_C28.Path}' hasn't been found");
				return false;
			}

			using DirectBitmap? bitmap = ConvertToBitmap(texture);
			if (bitmap is null)
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Unable to convert '{texture.NameString}' to bitmap");
				return false;
			}
			if (OperatingSystem.IsWindows())
			{
				bitmap.Save(path, ImageExportFormat);
			}
			else
			{
				TaskManager.AddTask(bitmap.SaveAsync(path, ImageExportFormat));
			}
			return true;
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			if (asset is ISprite sprite)
			{
				return TextureExportCollection.CreateExportCollection(this, sprite);
			}
			TextureExportCollection collection = new TextureExportCollection(this, (SourceGenerated.Classes.ClassID_28.ITexture2D)asset, true);
			collection.FileExtension = ImageExportFormat.GetFileExtension();
			return collection;
		}

		public static DirectBitmap? ConvertToBitmap(SourceGenerated.Classes.ClassID_28.ITexture2D texture)
		{
			byte[] buffer = texture.GetImageData();
			if (buffer.Length == 0)
			{
				return null;
			}

			int pvrtcBitCount = texture.PVRTCBitCount(true);
			int astcBlockSize = texture.ASTCBlockSize(true);
			KTXBaseInternalFormat baseInternalFormat = texture.GetKTXBaseInternalFormat(true);

			DirectBitmap? bitmap = ConvertToBitmap((TextureFormat)texture.TextureFormat_C28, texture.Width_C28, texture.Height_C28, texture.SerializedFile.Version, buffer, pvrtcBitCount, astcBlockSize, baseInternalFormat);

			if (bitmap == null)
			{
				return null;
			}

			// despite the name, this packing works for different formats
			if (texture.LightmapFormat_C28 == (int)TextureUsageMode.NormalmapDXT5nm)
			{
				TextureConverter.UnpackNormal(bitmap.BitsPtr, bitmap.Bits.Length);
			}

			return bitmap;
		}

		public static DirectBitmap? ConvertToBitmap(TextureFormat textureFormat, int width, int height, UnityVersion version, byte[] data, int pvrtcBitCount, int astcBlockSize, KTXBaseInternalFormat ktxBaseInternalFormat)
		{
			if (width == 0 || height == 0)
			{
				return new DirectBitmap(1, 1);
			}

			switch (textureFormat)
			{
				case TextureFormat.DXT1:
				case TextureFormat.DXT3:
				case TextureFormat.DXT5:
					return TextureConverter.DXTTextureToBitmap(textureFormat, width, height, data);

				case TextureFormat.Alpha8:
				case TextureFormat.ARGB4444:
				case TextureFormat.RGB24:
				case TextureFormat.RGBA32:
				case TextureFormat.ARGB32:
				case TextureFormat.RGB565:
				case TextureFormat.R16:
				case TextureFormat.RGBA4444:
				case TextureFormat.BGRA32:
				case TextureFormat.RHalf:
				case TextureFormat.RGHalf:
				case TextureFormat.RGBAHalf:
				case TextureFormat.RFloat:
				case TextureFormat.RGFloat:
				case TextureFormat.RGBAFloat:
				case TextureFormat.RGB9e5Float:
				case TextureFormat.RG16:
				case TextureFormat.R8:
					return TextureConverter.RGBTextureToBitmap(textureFormat, width, height, data);

				case TextureFormat.YUY2:
					return TextureConverter.YUY2TextureToBitmap(textureFormat, width, height, data);

				case TextureFormat.PVRTC_RGB2:
				case TextureFormat.PVRTC_RGBA2:
				case TextureFormat.PVRTC_RGB4:
				case TextureFormat.PVRTC_RGBA4:
					return TextureConverter.PVRTCTextureToBitmap(pvrtcBitCount, textureFormat, width, height, data);

				case TextureFormat.ETC_RGB4:
				case TextureFormat.EAC_R:
				case TextureFormat.EAC_R_SIGNED:
				case TextureFormat.EAC_RG:
				case TextureFormat.EAC_RG_SIGNED:
				case TextureFormat.ETC2_RGB:
				case TextureFormat.ETC2_RGBA1:
				case TextureFormat.ETC2_RGBA8:
				case TextureFormat.ETC_RGB4_3DS:
				case TextureFormat.ETC_RGBA8_3DS:
					return TextureConverter.ETCTextureToBitmap(textureFormat, width, height, data);

				case TextureFormat.ATC_RGB4:
				case TextureFormat.ATC_RGBA8:
					return TextureConverter.ATCTextureToBitmap(textureFormat, width, height, data);

				case TextureFormat.ASTC_RGB_4x4:
				case TextureFormat.ASTC_RGB_5x5:
				case TextureFormat.ASTC_RGB_6x6:
				case TextureFormat.ASTC_RGB_8x8:
				case TextureFormat.ASTC_RGB_10x10:
				case TextureFormat.ASTC_RGB_12x12:
				case TextureFormat.ASTC_RGBA_4x4:
				case TextureFormat.ASTC_RGBA_5x5:
				case TextureFormat.ASTC_RGBA_6x6:
				case TextureFormat.ASTC_RGBA_8x8:
				case TextureFormat.ASTC_RGBA_10x10:
				case TextureFormat.ASTC_RGBA_12x12:
					return TextureConverter.ASTCTextureToBitmap(astcBlockSize, width, height, data);

				case TextureFormat.BC4:
				case TextureFormat.BC5:
				case TextureFormat.BC6H:
				case TextureFormat.BC7:
					return TextureConverter.TexgenpackTextureToBitmap(ktxBaseInternalFormat, textureFormat, width, height, data);

				case TextureFormat.DXT1Crunched:
				case TextureFormat.DXT5Crunched:
					return TextureConverter.DXTCrunchedTextureToBitmap(textureFormat, width, height, version, data);

				case TextureFormat.ETC_RGB4Crunched:
				case TextureFormat.ETC2_RGBA8Crunched:
					return TextureConverter.ETCCrunchedTextureToBitmap(textureFormat, width, height, version, data);

				default:
					Logger.Log(LogType.Error, LogCategory.Export, $"Unsupported texture format '{textureFormat}'");
					return null;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/TextureConverter.cs`:

```cs
using AssetRipper.Core.Classes.Texture2D;
using AssetRipper.Core.Logging;
using AssetRipper.Library.Exporters.Textures.Enums;
using AssetRipper.Library.Utils;
using AssetRipper.TextureDecoder.Astc;
using AssetRipper.TextureDecoder.Atc;
using AssetRipper.TextureDecoder.Dxt;
using AssetRipper.TextureDecoder.Etc;
using AssetRipper.TextureDecoder.Pvrtc;
using AssetRipper.TextureDecoder.Rgb;
using AssetRipper.TextureDecoder.Yuy2;


namespace AssetRipper.Library.Exporters.Textures
{
	public static class TextureConverter
	{
		public static DirectBitmap DXTTextureToBitmap(TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				switch (textureFormat)
				{
					case TextureFormat.DXT1:
					case TextureFormat.DXT1Crunched:
						DxtDecoder.DecompressDXT1(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.DXT3:
						DxtDecoder.DecompressDXT3(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.DXT5:
					case TextureFormat.DXT5Crunched:
						DxtDecoder.DecompressDXT5(data, width, height, bitmap.Bits);
						break;

					default:
						throw new Exception(textureFormat.ToString());

				}
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap DXTCrunchedTextureToBitmap(TextureFormat textureFormat, int width, int height, UnityVersion unityVersion, byte[] data)
		{
			byte[] decompressed = CrunchHandler.DecompressCrunch(textureFormat, width, height, unityVersion, data);
			return DXTTextureToBitmap(textureFormat, width, height, decompressed);
		}

		public static DirectBitmap RGBTextureToBitmap(TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				switch (textureFormat)
				{
					case TextureFormat.Alpha8:
						RgbConverter.A8ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.ARGB4444:
						RgbConverter.ARGB16ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGB24:
						RgbConverter.RGB24ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGBA32:
						RgbConverter.RGBA32ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.ARGB32:
						RgbConverter.ARGB32ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGB565:
						RgbConverter.RGB16ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.R16:
						RgbConverter.R16ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGBA4444:
						RgbConverter.RGBA16ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.BGRA32:
						Buffer.BlockCopy(data, 0, bitmap.Bits, 0, bitmap.Bits.Length);
						break;
					case TextureFormat.RG16:
						RgbConverter.RG16ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.R8:
						RgbConverter.R8ToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RHalf:
						RgbConverter.RHalfToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGHalf:
						RgbConverter.RGHalfToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGBAHalf:
						RgbConverter.RGBAHalfToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RFloat:
						RgbConverter.RFloatToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGFloat:
						RgbConverter.RGFloatToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGBAFloat:
						RgbConverter.RGBAFloatToBGRA32(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.RGB9e5Float:
						RgbConverter.RGB9e5FloatToBGRA32(data, width, height, bitmap.Bits);
						break;

					default:
						throw new Exception(textureFormat.ToString());

				}
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap ETCTextureToBitmap(TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				switch (textureFormat)
				{
					case TextureFormat.ETC_RGB4:
					case TextureFormat.ETC_RGB4_3DS:
					case TextureFormat.ETC_RGB4Crunched:
						EtcDecoder.DecompressETC(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.EAC_R:
						EtcDecoder.DecompressEACRUnsigned(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.EAC_R_SIGNED:
						EtcDecoder.DecompressEACRSigned(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.EAC_RG:
						EtcDecoder.DecompressEACRGUnsigned(data, width, height, bitmap.Bits);
						break;
					case TextureFormat.EAC_RG_SIGNED:
						EtcDecoder.DecompressEACRGSigned(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.ETC2_RGB:
						EtcDecoder.DecompressETC2(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.ETC2_RGBA1:
						EtcDecoder.DecompressETC2A1(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.ETC2_RGBA8:
					case TextureFormat.ETC_RGBA8_3DS:
					case TextureFormat.ETC2_RGBA8Crunched:
						EtcDecoder.DecompressETC2A8(data, width, height, bitmap.Bits);
						break;

					default:
						throw new Exception(textureFormat.ToString());

				}
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap ETCCrunchedTextureToBitmap(TextureFormat textureFormat, int width, int height, UnityVersion unityVersion, byte[] data)
		{
			byte[] decompressed = CrunchHandler.DecompressCrunch(textureFormat, width, height, unityVersion, data);
			return ETCTextureToBitmap(textureFormat, width, height, decompressed);
		}

		public static DirectBitmap ATCTextureToBitmap(TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				switch (textureFormat)
				{
					case TextureFormat.ATC_RGB4:
						AtcDecoder.DecompressAtcRgb4(data, width, height, bitmap.Bits);
						break;

					case TextureFormat.ATC_RGBA8:
						AtcDecoder.DecompressAtcRgba8(data, width, height, bitmap.Bits);
						break;

					default:
						throw new Exception(textureFormat.ToString());

				}
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap YUY2TextureToBitmap(TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				Yuy2Decoder.DecompressYUY2(data, width, height, bitmap.Bits);
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap PVRTCTextureToBitmap(int bitCount, TextureFormat textureFormat, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				PvrtcDecoder.DecompressPVRTC(data, width, height, bitmap.Bits, bitCount == 2);
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap ASTCTextureToBitmap(int blockSize, int width, int height, byte[] data)
		{
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				AstcDecoder.DecodeASTC(data, width, height, blockSize, blockSize, bitmap.Bits);
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		public static DirectBitmap TexgenpackTextureToBitmap(KTXBaseInternalFormat baseInternalFormat, TextureFormat textureFormat, int width, int height, byte[] data)
		{
			Logger.Verbose("Uses texgenpack!");
			Logger.Verbose($"KTXBaseInternalFormat: {baseInternalFormat}");
			bool fixAlpha = baseInternalFormat is KTXBaseInternalFormat.RED or KTXBaseInternalFormat.RG;
			Logger.Verbose($"Fix alpha: {fixAlpha}");
			DirectBitmap bitmap = new DirectBitmap(width, height);
			try
			{
				if (TexGenPackHandler.Decode(textureFormat, data, width, height, bitmap.BitsPtr, fixAlpha))
				{
					Logger.Verbose($"Byte array length: {bitmap.Bits.Length} Width: {width} Height: {height}");
					CheckEqual(DecodeBC(data, textureFormat, width, height), bitmap.Bits);
				}
				else
				{
					DecodeBC(data, textureFormat, width, height, bitmap.Bits);
				}
				bitmap.FlipY();
				return bitmap;
			}
			catch
			{
				bitmap.Dispose();
				throw;
			}
		}

		private static byte[] DecodeBC(byte[] inputData, TextureFormat textureFormat, int width, int height)
		{
			byte[] result = new byte[4 * width * height];
			DecodeBC(inputData, textureFormat, width, height, result);
			return result;
		}

		private static bool DecodeBC(byte[] inputData, TextureFormat textureFormat, int width, int height, byte[] outputData)
		{
			Logger.Verbose($"Performing alternate decoding for {textureFormat}");

			switch (textureFormat)
			{
				case TextureFormat.BC4:
					Texture2DDecoder.TextureDecoder.DecodeBC4(inputData, width, height, outputData);
					return true;
				case TextureFormat.BC5:
					Texture2DDecoder.TextureDecoder.DecodeBC5(inputData, width, height, outputData);
					return true;
				case TextureFormat.BC6H:
					Texture2DDecoder.TextureDecoder.DecodeBC6(inputData, width, height, outputData);
					return true;
				case TextureFormat.BC7:
					Texture2DDecoder.TextureDecoder.DecodeBC7(inputData, width, height, outputData);
					return true;
				default:
					return false;
			}
		}

		private static void CheckEqual(byte[] left, byte[] right)
		{
			if (left == null)
			{
				Logger.Verbose("In byte array comparison, left was null");
				return;
			}
			if (right == null)
			{
				Logger.Verbose("In byte array comparison, left was null");
				return;
			}
			if (left.Length != right.Length)
			{
				Logger.Verbose("In byte array comparison, lengths were inequal");
				Logger.Verbose($"Left: {left.Length}");
				Logger.Verbose($"Right: {right.Length}");
				return;
			}
			int length = left.Length;
			int count = 0;
			for (int i = 0; i < length; i++)
			{
				if (left[i] != right[i])
				{
					count++;
				}
			}
			if (count == 0)
			{
				Logger.Verbose("Byte arrays were equal at all indices!");
			}
			else
			{
				Logger.Verbose($"Byte arrays were inequal in {count}/{length} places!");
			}
		}

		public unsafe static void UnpackNormal(IntPtr inputOutput, int length)
		{
			byte* dataPtr = (byte*)inputOutput;
			int count = length / 4;
			for (int i = 0; i < count; i++, dataPtr += 4)
			{
				byte r = dataPtr[3];
				byte g = dataPtr[1];
				byte a = dataPtr[2];
				dataPtr[2] = r;
				dataPtr[3] = a;

				const double MagnitudeSqr = 255.0 * 255.0;
				double vr = r * 2.0 - 255.0;
				double vg = g * 2.0 - 255.0;
				double hypotenuseSqr = vr * vr + vg * vg;
				hypotenuseSqr = hypotenuseSqr > MagnitudeSqr ? MagnitudeSqr : hypotenuseSqr;
				double b = (Math.Sqrt(MagnitudeSqr - hypotenuseSqr) + 255.0) / 2.0;
				dataPtr[0] = (byte)b;
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/Textures/TextureExportCollection.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Utils;
using AssetRipper.SourceGenerated.Classes.ClassID_1006;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_687078895;
using AssetRipper.SourceGenerated.Subclasses.PPtr_Sprite_;
using AssetRipper.SourceGenerated.Subclasses.SpriteAtlasData;
using AssetRipper.SourceGenerated.Subclasses.SpriteMetaData;
using System.Collections.Generic;
using System.Linq;

namespace AssetRipper.Library.Exporters.Textures
{
	public class TextureExportCollection : AssetsExportCollection
	{
		public TextureExportCollection(IAssetExporter assetExporter, ITexture2D texture, bool convert) : base(assetExporter, texture)
		{
			m_convert = convert;
			if (convert)
			{
				foreach (ISprite sprite in texture.SerializedFile.Collection.FetchAssetsOfType<ISprite>())
				{
					if (sprite.RD_C213.Texture.IsAsset(sprite.SerializedFile, texture))
					{
						ISpriteAtlas? atlas = sprite.Has_SpriteAtlas_C213() ? sprite.SpriteAtlas_C213.FindAsset(sprite.SerializedFile) : null;
						m_sprites.Add(sprite, atlas);
						AddAsset(sprite);
					}
				}

				foreach (ISpriteAtlas atlas in texture.SerializedFile.Collection.FetchAssetsOfType<ISpriteAtlas>())
				{
					if (atlas.RenderDataMap_C687078895.Count > 0)
					{
						foreach (PPtr_Sprite__5_0_0_f4 spritePtr in atlas.PackedSprites_C687078895)
						{
							ISprite? sprite = spritePtr.FindAsset(atlas.SerializedFile);
							if (sprite != null)
							{
								//ISpriteAtlasData atlasData = atlas.RenderDataMap_C687078895[sprite.RenderDataKey_C213];
								ISpriteAtlasData atlasData = atlas.RenderDataMap_C687078895[sprite.RenderDataKey_C213];
								if (atlasData.Texture.IsAsset(atlas.SerializedFile, texture))
								{
									m_sprites.Add(sprite, atlas);
									AddAsset(sprite);
								}
							}
						}
					}
				}
			}
		}

		public static IExportCollection CreateExportCollection(IAssetExporter assetExporter, ISprite asset)
		{
			ITexture2D? texture = asset.RD_C213.Texture.FindAsset(asset.SerializedFile);
			if (texture is null)
			{
				return new FailExportCollection(assetExporter, asset);
			}
			return new TextureExportCollection(assetExporter, texture, true);
		}

		protected override IUnityObjectBase CreateImporter(IExportContainer container)
		{
			ITexture2D texture = (ITexture2D)Asset;
			if (m_convert)
			{
				ITextureImporter importer = ImporterFactory.GenerateTextureImporter(container, texture);
				AddSprites(container, importer);
				return importer;
			}
			else
			{
				return ImporterFactory.GenerateIHVImporter(container, texture);
			}
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			return AssetExporter.Export(container, Asset, filePath);
		}

		protected override string GetExportExtension(IUnityObjectBase asset)
		{
			if (m_convert)
			{
				return FileExtension ?? "png";
			}
			return base.GetExportExtension(asset);
		}

		protected override long GenerateExportID(IUnityObjectBase asset)
		{
			long exportID = ExportIdHandler.GetMainExportID(asset, m_nextExportID);
			m_nextExportID += 2;
			return exportID;
		}

		private void AddSprites(IExportContainer container, ITextureImporter importer)
		{
			if (m_sprites.Count == 0)
			{
				importer.SpriteMode_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Single;
				importer.SpriteExtrude_C1006 = 1;
				importer.SpriteMeshType_C1006 = (int)Core.Classes.Sprite.SpriteMeshType.FullRect;//See pull request #306
				importer.Alignment_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteAlignment.Center;
				if (importer.Has_SpritePivot_C1006())
				{
					importer.SpritePivot_C1006.SetValues(0.5f, 0.5f);
				}
				importer.SpritePixelsToUnits_C1006 = 100.0f;
			}
			else if (m_sprites.Count == 1)
			{
				ISprite sprite = m_sprites.Keys.First();
				ITexture2D texture = (ITexture2D)Asset;
				if (sprite.Rect_C213 == sprite.RD_C213.TextureRect && sprite.NameString == texture.NameString)
				{
					importer.SpriteMode_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Single;
				}
				else
				{
					importer.SpriteMode_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Multiple;
					importer.TextureType_C1006 = (int)Core.Classes.Meta.Importers.Texture.TextureImporterType.Sprite;
				}
				importer.SpriteExtrude_C1006 = sprite.Extrude_C213;
				importer.SpriteMeshType_C1006 = (int)sprite.RD_C213.GetMeshType();
				importer.Alignment_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteAlignment.Custom;
				if (importer.Has_SpritePivot_C1006() && sprite.Has_Pivot_C213())
				{
					importer.SpritePivot_C1006.CopyValues(sprite.Pivot_C213);
				}
				if (importer.Has_SpriteBorder_C1006() && sprite.Has_Border_C213())
				{
					importer.SpriteBorder_C1006.CopyValues(sprite.Border_C213);
				}
				importer.SpritePixelsToUnits_C1006 = sprite.PixelsToUnits_C213;
				importer.TextureType_C1006 = (int)Core.Classes.Meta.Importers.Texture.TextureImporterType.Sprite;
				AddSpriteSheet(container, importer);
				AddIDToName(importer);
			}
			else
			{
				ISprite sprite = m_sprites.Keys.First();
				importer.TextureType_C1006 = (int)Core.Classes.Meta.Importers.Texture.TextureImporterType.Sprite;
				importer.SpriteMode_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Multiple;
				importer.SpriteExtrude_C1006 = sprite.Extrude_C213;
				importer.SpriteMeshType_C1006 = (int)sprite.RD_C213.GetMeshType();
				importer.Alignment_C1006 = (int)Core.Classes.Meta.Importers.Texture.SpriteAlignment.Center;
				if (importer.Has_SpritePivot_C1006())
				{
					importer.SpritePivot_C1006.SetValues(0.5f, 0.5f);
				}
				importer.SpritePixelsToUnits_C1006 = sprite.PixelsToUnits_C213;
				importer.TextureType_C1006 = (int)Core.Classes.Meta.Importers.Texture.TextureImporterType.Sprite;
				AddSpriteSheet(container, importer);
				AddIDToName(importer);
			}
		}

		private void AddSpriteSheet(IExportContainer container, ITextureImporter importer)
		{
			if (!importer.Has_SpriteSheet_C1006())
			{
			}
			else if (importer.SpriteMode_C1006 == (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Single)
			{
				KeyValuePair<ISprite, ISpriteAtlas?> kvp = m_sprites.First();
				ISpriteMetaData smeta = kvp.Key.GenerateSpriteMetaData(container, kvp.Value);
				importer.SpriteSheet_C1006.CopyFromSpriteMetaData(smeta);
			}
			else
			{
				List<ISpriteMetaData> metadata = new List<ISpriteMetaData>(m_sprites.Count);
				foreach (KeyValuePair<ISprite, ISpriteAtlas?> kvp in m_sprites)
				{
					ISpriteMetaData smeta = kvp.Key.GenerateSpriteMetaData(container, kvp.Value);
					if (smeta.Has_InternalID())
					{
						smeta.InternalID = ObjectUtils.GenerateInternalID();
					}
					metadata.Add(smeta);
				}
				importer.SpriteSheet_C1006.Sprites.AddRange(metadata);
			}
		}

		private void AddIDToName(ITextureImporter importer)
		{
			if (importer.SpriteMode_C1006 == (int)Core.Classes.Meta.Importers.Texture.SpriteImportMode.Multiple)
			{
				if (importer.Has_InternalIDToNameTable_C1006())
				{
					foreach (ISprite sprite in m_sprites.Keys)
					{
#warning TODO: TEMP:
						long exportID = GetExportID(sprite);
						ISpriteMetaData smeta = importer.SpriteSheet_C1006.GetSpriteMetaData(sprite.NameString);
						smeta.InternalID = exportID;
						NullableKeyValuePair<int, long> key = new NullableKeyValuePair<int, long>((int)ClassIDType.Sprite, exportID);
						importer.InternalIDToNameTable_C1006.Add(new(key, sprite.Name));
					}
				}
				else
				{
					foreach (ISprite sprite in m_sprites.Keys)
					{
						long exportID = GetExportID(sprite);
						if (importer.Has_FileIDToRecycleName_C1006_AssetDictionary_Int32_Utf8String())
						{
							importer.FileIDToRecycleName_C1006_AssetDictionary_Int32_Utf8String.Add((int)exportID, sprite.Name);
						}
						else if (importer.Has_FileIDToRecycleName_C1006_AssetDictionary_Int64_Utf8String())
						{
							importer.FileIDToRecycleName_C1006_AssetDictionary_Int64_Utf8String.Add(exportID, sprite.Name);
						}
					}
				}
			}
		}

		public string? FileExtension { get; set; }

		public readonly Dictionary<ISprite, ISpriteAtlas?> m_sprites = new Dictionary<ISprite, ISpriteAtlas?>();

		private readonly bool m_convert;
		private uint m_nextExportID = 0;
	}
}

```

`AssetRipperLibrary/Exporters/TypeTrees/TypeTreeExporter.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Logging;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;

namespace AssetRipper.Library.Exporters.TypeTrees
{
	public class TypeTreeExporter : IPostExporter
	{
		public void DoPostExport(Ripper ripper)
		{
			string outputDirectory = Path.Combine(ripper.Settings.AuxiliaryFilesPath, "TypeTrees");

			Logger.Info(LogCategory.Export, "Exporting type trees...");
			foreach (Core.Parser.Files.SerializedFiles.SerializedFile? serializedFile in ripper.GameStructure.FileCollection.GameSerializedFiles)
			{
				if (serializedFile.Metadata.EnableTypeTree)
				{
					Logger.Info(LogCategory.Export, serializedFile.Name);
				}

				List<IMonoScript> monoScripts = serializedFile.FetchAssets().Where(asset => asset is IMonoScript).Select(asset => (IMonoScript)asset).ToList();
				StringBuilder sb = new StringBuilder();
				foreach (Core.Parser.Files.SerializedFiles.Parser.SerializedType? type in serializedFile.Metadata.Types)
				{
					//Logger.Info(LogCategory.Export, $"\t\tID: {type.TypeID.ToString()} Node Count: {type.OldType?.Nodes?.Count ?? 0}");
					string? typeTreeText = type.OldType?.Dump;
					if (!string.IsNullOrEmpty(typeTreeText))
					{
						IMonoScript? monoScript = monoScripts.FirstOrDefault(asset => asset.GetPropertiesHash() == type.OldTypeHash);
						string typeName = monoScript is null ? type.TypeID.ToString() : monoScript.GetFullName();
						sb.AppendLine($"// classID{{{(int)type.TypeID}}}: {typeName}");
						sb.AppendLine(typeTreeText);
					}
				}
				string text = sb.ToString();
				if (!string.IsNullOrWhiteSpace(text))
				{
					Directory.CreateDirectory(outputDirectory);
					string filePath = Path.Combine(outputDirectory, serializedFile.Name + ".txt");
					TaskManager.AddTask(File.WriteAllTextAsync(filePath, text));
				}
			}
		}
	}
}

```

`AssetRipperLibrary/Exporters/YamlStreamedAssetExportCollection.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Project;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_89;

namespace AssetRipper.Library.Exporters
{
	public sealed class YamlStreamedAssetExportCollection : AssetExportCollection
	{
		public YamlStreamedAssetExportCollection(IAssetExporter assetExporter, IUnityObjectBase asset) : base(assetExporter, asset)
		{
		}

		protected override bool ExportInner(IProjectAssetContainer container, string filePath, string dirPath)
		{
			//Possible improvement:
			//
			//The code for all these is very similar.
			//An interface could be added to them during source generation in order to avoid this switch expression.

			return Asset switch
			{
				IMesh mesh => ExportMesh(container, filePath, dirPath, mesh),
				ITexture2D texture2D => ExportTexture2D(container, filePath, dirPath, texture2D),
				ITexture3D texture3D => ExportTexture3D(container, filePath, dirPath, texture3D),
				ITexture2DArray texture2DArray => ExportTexture2DArray(container, filePath, dirPath, texture2DArray),
				ICubemapArray cubemapArray => ExportCubemapArray(container, filePath, dirPath, cubemapArray),
				_ => false,
			};
		}

		private bool ExportMesh(IProjectAssetContainer container, string filePath, string dirPath, IMesh mesh)
		{
			bool result;
			if (mesh.Has_StreamData_C43())
			{
				ulong offset = mesh.StreamData_C43.GetOffset();
				byte[] path = mesh.StreamData_C43.Path.Data;
				uint size = mesh.StreamData_C43.Size;
				if (mesh.VertexData_C43 is not null && mesh.VertexData_C43.Data.Length == 0 && mesh.StreamData_C43.IsSet())
				{
					mesh.VertexData_C43.Data = mesh.StreamData_C43.GetContent(mesh.SerializedFile);
					mesh.StreamData_C43.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
					mesh.VertexData_C43.Data = Array.Empty<byte>();
				}
				else
				{
					mesh.StreamData_C43.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
				}
				mesh.StreamData_C43.SetOffset(offset);
				mesh.StreamData_C43.Path.Data = path;
				mesh.StreamData_C43.Size = size;
			}
			else
			{
				result = base.ExportInner(container, filePath, dirPath);
			}

			return result;
		}

		/// <summary>
		/// Also handles <see cref="ICubemap"/> by inheritance
		/// </summary>
		private bool ExportTexture2D(IProjectAssetContainer container, string filePath, string dirPath, ITexture2D texture)
		{
			bool result;
			if (texture.Has_StreamData_C28())
			{
				ulong offset = texture.StreamData_C28.GetOffset();
				byte[] path = texture.StreamData_C28.Path.Data;
				uint size = texture.StreamData_C28.Size;
				if (texture.ImageData_C28.Length == 0 && texture.StreamData_C28.IsSet())
				{
					texture.ImageData_C28 = texture.StreamData_C28.GetContent(texture.SerializedFile);
					texture.StreamData_C28.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
					texture.ImageData_C28 = Array.Empty<byte>();
				}
				else
				{
					texture.StreamData_C28.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
				}
				texture.StreamData_C28.SetOffset(offset);
				texture.StreamData_C28.Path.Data = path;
				texture.StreamData_C28.Size = size;
			}
			else
			{
				result = base.ExportInner(container, filePath, dirPath);
			}

			return result;
		}

		private bool ExportTexture3D(IProjectAssetContainer container, string filePath, string dirPath, ITexture3D texture)
		{
			bool result;
			if (texture.Has_StreamData_C117())
			{
				ulong offset = texture.StreamData_C117.GetOffset();
				byte[] path = texture.StreamData_C117.Path.Data;
				uint size = texture.StreamData_C117.Size;
				if (texture.ImageData_C117.Length == 0 && texture.StreamData_C117.IsSet())
				{
					texture.ImageData_C117 = texture.StreamData_C117.GetContent(texture.SerializedFile);
					texture.StreamData_C117.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
					texture.ImageData_C117 = Array.Empty<byte>();
				}
				else
				{
					texture.StreamData_C117.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
				}
				texture.StreamData_C117.SetOffset(offset);
				texture.StreamData_C117.Path.Data = path;
				texture.StreamData_C117.Size = size;
			}
			else
			{
				result = base.ExportInner(container, filePath, dirPath);
			}

			return result;
		}

		private bool ExportTexture2DArray(IProjectAssetContainer container, string filePath, string dirPath, ITexture2DArray texture)
		{
			bool result;
			if (texture.Has_StreamData_C187())
			{
				ulong offset = texture.StreamData_C187.GetOffset();
				byte[] path = texture.StreamData_C187.Path.Data;
				uint size = texture.StreamData_C187.Size;
				if (texture.ImageData_C187.Length == 0 && texture.StreamData_C187.IsSet())
				{
					texture.ImageData_C187 = texture.StreamData_C187.GetContent(texture.SerializedFile);
					texture.StreamData_C187.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
					texture.ImageData_C187 = Array.Empty<byte>();
				}
				else
				{
					texture.StreamData_C187.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
				}
				texture.StreamData_C187.SetOffset(offset);
				texture.StreamData_C187.Path.Data = path;
				texture.StreamData_C187.Size = size;
			}
			else
			{
				result = base.ExportInner(container, filePath, dirPath);
			}

			return result;
		}

		private bool ExportCubemapArray(IProjectAssetContainer container, string filePath, string dirPath, ICubemapArray texture)
		{
			bool result;
			if (texture.Has_StreamData_C188())
			{
				ulong offset = texture.StreamData_C188.GetOffset();
				byte[] path = texture.StreamData_C188.Path.Data;
				uint size = texture.StreamData_C188.Size;
				if (texture.ImageData_C188.Length == 0 && texture.StreamData_C188.IsSet())
				{
					texture.ImageData_C188 = texture.StreamData_C188.GetContent(texture.SerializedFile);
					texture.StreamData_C188.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
					texture.ImageData_C188 = Array.Empty<byte>();
				}
				else
				{
					texture.StreamData_C188.ClearValues();
					result = base.ExportInner(container, filePath, dirPath);
				}
				texture.StreamData_C188.SetOffset(offset);
				texture.StreamData_C188.Path.Data = path;
				texture.StreamData_C188.Size = size;
			}
			else
			{
				result = base.ExportInner(container, filePath, dirPath);
			}

			return result;
		}
	}
}

```

`AssetRipperLibrary/Exporters/YamlStreamedAssetExporter.cs`:

```cs
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Project.Collections;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;

namespace AssetRipper.Library.Exporters
{
	public sealed class YamlStreamedAssetExporter : YamlExporterBase
	{
		public override bool IsHandle(IUnityObjectBase asset)
		{
			return asset is IMesh or ITexture2D or ITexture3D or ITexture2DArray or ICubemapArray;
			//Note: ICubeMap inherits from ITexture2D
		}

		public override IExportCollection CreateCollection(VirtualSerializedFile virtualFile, IUnityObjectBase asset)
		{
			return new YamlStreamedAssetExportCollection(this, asset);
		}
	}
}

```

`AssetRipperLibrary/GlobalUsings.cs`:

```cs
global using AssetRipper.VersionUtilities;
global using System;

```

`AssetRipperLibrary/PluginBase.cs`:

```cs
using AssetRipper.Core.Logging;

namespace AssetRipper.Library
{
	public abstract class PluginBase
	{
		public Ripper CurrentRipper { get; internal set; }
		public virtual void Initialize() { }
		public abstract string Name { get; }
		public void Info(string message) => Logger.Info(LogCategory.Plugin, $"[{Name}] {message}");
		public void Warning(string message) => Logger.Warning(LogCategory.Plugin, $"[{Name}] {message}");
		public void Error(string message) => Logger.Error(LogCategory.Plugin, $"[{Name}] {message}");
		public void Error(string message, Exception exception) => Logger.Error(LogCategory.Plugin, $"[{Name}] {message}", exception);
		public void Error(Exception exception) => Logger.Error(LogCategory.Plugin, $"[{Name}] Exception thrown", exception);
		public void Verbose(string message) => Logger.Verbose(LogCategory.Plugin, $"[{Name}] {message}");
	}
}

```

`AssetRipperLibrary/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle(AssetRipper.Core.BuildInfo.LibraryName)]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany(AssetRipper.Core.BuildInfo.Author)]
[assembly: AssemblyProduct(AssetRipper.Core.BuildInfo.LibraryName)]
[assembly: AssemblyCopyright(AssetRipper.Core.BuildInfo.CopyRight)]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

[assembly: ComVisible(false)]

[assembly: AssemblyVersion(AssetRipper.Core.BuildInfo.Version)]
[assembly: AssemblyFileVersion(AssetRipper.Core.BuildInfo.Version)]
```

`AssetRipperLibrary/Reference/ModelConverter.cs`:

```cs
/*using AssetRipper.Reading.Classes;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace AssetRipper.Reading.Utils
{
    public class ModelConverter : IImported
    {
        public ImportedFrame RootFrame { get; protected set; }
        public List<ImportedMesh> MeshList { get; protected set; } = new List<ImportedMesh>();
        public List<ImportedMaterial> MaterialList { get; protected set; } = new List<ImportedMaterial>();
        public List<ImportedTexture> TextureList { get; protected set; } = new List<ImportedTexture>();
        public List<ImportedKeyframedAnimation> AnimationList { get; protected set; } = new List<ImportedKeyframedAnimation>();
        public List<ImportedMorph> MorphList { get; protected set; } = new List<ImportedMorph>();

        private ImageFormat imageFormat;
        private Avatar avatar;
        private HashSet<AnimationClip> animationClipHashSet = new HashSet<AnimationClip>();
        private Dictionary<AnimationClip, string> boundAnimationPathDic = new Dictionary<AnimationClip, string>();
        private Dictionary<uint, string> bonePathHash = new Dictionary<uint, string>();
        private Dictionary<Texture2D, string> textureNameDictionary = new Dictionary<Texture2D, string>();
        private Dictionary<Transform, ImportedFrame> transformDictionary = new Dictionary<Transform, ImportedFrame>();
        Dictionary<uint, string> morphChannelNames = new Dictionary<uint, string>();

        public ModelConverter(GameObject m_GameObject, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            if (m_GameObject.m_Animator != null)
            {
                InitWithAnimator(m_GameObject.m_Animator);
                if (animationList == null)
                {
                    CollectAnimationClip(m_GameObject.m_Animator);
                }
            }
            else
            {
                InitWithGameObject(m_GameObject);
            }
            if (animationList != null)
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        public ModelConverter(string rootName, List<GameObject> m_GameObjects, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            RootFrame = CreateFrame(rootName, Vector3.Zero, new Quaternionf(0, 0, 0, 0), Vector3.One);
            foreach (var m_GameObject in m_GameObjects)
            {
                if (m_GameObject.m_Animator != null && animationList == null)
                {
                    CollectAnimationClip(m_GameObject.m_Animator);
                }

                var m_Transform = m_GameObject.m_Transform;
                ConvertTransforms(m_Transform, RootFrame);
                CreateBonePathHash(m_Transform);
            }
            foreach (var m_GameObject in m_GameObjects)
            {
                var m_Transform = m_GameObject.m_Transform;
                ConvertMeshRenderer(m_Transform);
            }
            if (animationList != null)
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        public ModelConverter(Animator m_Animator, ImageFormat imageFormat, AnimationClip[] animationList = null)
        {
            this.imageFormat = imageFormat;
            InitWithAnimator(m_Animator);
            if (animationList == null)
            {
                CollectAnimationClip(m_Animator);
            }
            else
            {
                foreach (var animationClip in animationList)
                {
                    animationClipHashSet.Add(animationClip);
                }
            }
            ConvertAnimations();
        }

        private void InitWithAnimator(Animator m_Animator)
        {
            if (m_Animator.m_Avatar.TryGet(out var m_Avatar))
                avatar = m_Avatar;

            m_Animator.m_GameObject.TryGet(out var m_GameObject);
            InitWithGameObject(m_GameObject, m_Animator.m_HasTransformHierarchy);
        }

        private void InitWithGameObject(GameObject m_GameObject, bool hasTransformHierarchy = true)
        {
            var m_Transform = m_GameObject.m_Transform;
            if (!hasTransformHierarchy)
            {
                ConvertTransforms(m_Transform, null);
                DeoptimizeTransformHierarchy();
            }
            else
            {
                var frameList = new List<ImportedFrame>();
                var tempTransform = m_Transform;
                while (tempTransform.m_Father.TryGet(out var m_Father))
                {
                    frameList.Add(ConvertTransform(m_Father));
                    tempTransform = m_Father;
                }
                if (frameList.Count > 0)
                {
                    RootFrame = frameList[frameList.Count - 1];
                    for (var i = frameList.Count - 2; i >= 0; i--)
                    {
                        var frame = frameList[i];
                        var parent = frameList[i + 1];
                        parent.AddChild(frame);
                    }
                    ConvertTransforms(m_Transform, frameList[0]);
                }
                else
                {
                    ConvertTransforms(m_Transform, null);
                }

                CreateBonePathHash(m_Transform);
            }

            ConvertMeshRenderer(m_Transform);
        }

        private void ConvertMeshRenderer(Transform m_Transform)
        {
            m_Transform.m_GameObject.TryGet(out var m_GameObject);

            if (m_GameObject.m_MeshRenderer != null)
            {
                ConvertMeshRenderer(m_GameObject.m_MeshRenderer);
            }

            if (m_GameObject.m_SkinnedMeshRenderer != null)
            {
                ConvertMeshRenderer(m_GameObject.m_SkinnedMeshRenderer);
            }

            if (m_GameObject.m_Animation != null)
            {
                foreach (var animation in m_GameObject.m_Animation.m_Animations)
                {
                    if (animation.TryGet(out var animationClip))
                    {
                        boundAnimationPathDic.Add(animationClip, GetTransformPath(m_Transform));
                        animationClipHashSet.Add(animationClip);
                    }
                }
            }

            foreach (var pptr in m_Transform.m_Children)
            {
                if (pptr.TryGet(out var child))
                    ConvertMeshRenderer(child);
            }
        }

        private void CollectAnimationClip(Animator m_Animator)
        {
            if (m_Animator.m_Controller.TryGet(out var m_Controller))
            {
                switch (m_Controller)
                {
                    case AnimatorOverrideController m_AnimatorOverrideController:
                        {
                            if (m_AnimatorOverrideController.m_Controller.TryGet<AnimatorController>(out var m_AnimatorController))
                            {
                                foreach (var pptr in m_AnimatorController.m_AnimationClips)
                                {
                                    if (pptr.TryGet(out var m_AnimationClip))
                                    {
                                        animationClipHashSet.Add(m_AnimationClip);
                                    }
                                }
                            }
                            break;
                        }

                    case AnimatorController m_AnimatorController:
                        {
                            foreach (var pptr in m_AnimatorController.m_AnimationClips)
                            {
                                if (pptr.TryGet(out var m_AnimationClip))
                                {
                                    animationClipHashSet.Add(m_AnimationClip);
                                }
                            }
                            break;
                        }
                }
            }
        }

        private ImportedFrame ConvertTransform(Transform trans)
        {
            var frame = new ImportedFrame(trans.m_Children.Length);
            transformDictionary.Add(trans, frame);
            trans.m_GameObject.TryGet(out var m_GameObject);
            frame.Name = m_GameObject.m_Name;
            SetFrame(frame, trans.m_LocalPosition, trans.m_LocalRotation, trans.m_LocalScale);
            return frame;
        }

        private static ImportedFrame CreateFrame(string name, Vector3f t, Quaternionf q, Vector3f s)
        {
            var frame = new ImportedFrame();
            frame.Name = name;
            SetFrame(frame, t, q, s);
            return frame;
        }

        private static void SetFrame(ImportedFrame frame, Vector3f t, Quaternionf q, Vector3f s)
        {
            frame.LocalPosition = new Vector3f(-t.X, t.Y, t.Z);
            frame.LocalRotation = Fbx.QuaternionToEuler(new Quaternionf(q.X, -q.Y, -q.Z, q.W));
            frame.LocalScale = s;
        }

        private void ConvertTransforms(Transform trans, ImportedFrame parent)
        {
            var frame = ConvertTransform(trans);
            if (parent == null)
            {
                RootFrame = frame;
            }
            else
            {
                parent.AddChild(frame);
            }
            foreach (var pptr in trans.m_Children)
            {
                if (pptr.TryGet(out var child))
                    ConvertTransforms(child, frame);
            }
        }

        private void ConvertMeshRenderer(Renderer meshR)
        {
            var mesh = GetMesh(meshR);
            if (mesh == null)
                return;
            var iMesh = new ImportedMesh();
            meshR.m_GameObject.TryGet(out var m_GameObject2);
            iMesh.Path = GetTransformPath(m_GameObject2.m_Transform);
            iMesh.SubmeshList = new List<ImportedSubmesh>();
            var subHashSet = new HashSet<int>();
            var combine = false;
            int firstSubMesh = 0;
            if (meshR.m_StaticBatchInfo?.subMeshCount > 0)
            {
                firstSubMesh = meshR.m_StaticBatchInfo.firstSubMesh;
                var finalSubMesh = meshR.m_StaticBatchInfo.firstSubMesh + meshR.m_StaticBatchInfo.subMeshCount;
                for (int i = meshR.m_StaticBatchInfo.firstSubMesh; i < finalSubMesh; i++)
                {
                    subHashSet.Add(i);
                }
                combine = true;
            }
            else if (meshR.m_SubsetIndices?.Length > 0)
            {
                firstSubMesh = (int)meshR.m_SubsetIndices.Min(x => x);
                foreach (var index in meshR.m_SubsetIndices)
                {
                    subHashSet.Add((int)index);
                }
                combine = true;
            }

            iMesh.hasNormal = mesh.m_Normals?.Length > 0;
            iMesh.hasUV = new bool[8];
            for (int uv = 0; uv < 8; uv++)
            {
                iMesh.hasUV[uv] = mesh.GetUV(uv)?.Length > 0;
            }
            iMesh.hasTangent = mesh.m_Tangents != null && mesh.m_Tangents.Length == mesh.m_VertexCount * 4;
            iMesh.hasColor = mesh.m_Colors?.Length > 0;

            int firstFace = 0;
            for (int i = 0; i < mesh.m_SubMeshes.Length; i++)
            {
                int numFaces = (int)mesh.m_SubMeshes[i].indexCount / 3;
                if (subHashSet.Count > 0 && !subHashSet.Contains(i))
                {
                    firstFace += numFaces;
                    continue;
                }
                var submesh = mesh.m_SubMeshes[i];
                var iSubmesh = new ImportedSubmesh();
                Material mat = null;
                if (i - firstSubMesh < meshR.m_Materials.Length)
                {
                    if (meshR.m_Materials[i - firstSubMesh].TryGet(out var m_Material))
                    {
                        mat = m_Material;
                    }
                }
                ImportedMaterial iMat = ConvertMaterial(mat);
                iSubmesh.Material = iMat.Name;
                iSubmesh.BaseVertex = (int)mesh.m_SubMeshes[i].firstVertex;

                //Face
                iSubmesh.FaceList = new List<ImportedFace>(numFaces);
                var end = firstFace + numFaces;
                for (int f = firstFace; f < end; f++)
                {
                    var face = new ImportedFace();
                    face.VertexIndices = new int[3];
                    face.VertexIndices[0] = (int)(mesh.m_Indices[f * 3 + 2] - submesh.firstVertex);
                    face.VertexIndices[1] = (int)(mesh.m_Indices[f * 3 + 1] - submesh.firstVertex);
                    face.VertexIndices[2] = (int)(mesh.m_Indices[f * 3] - submesh.firstVertex);
                    iSubmesh.FaceList.Add(face);
                }
                firstFace = end;

                iMesh.SubmeshList.Add(iSubmesh);
            }

            // Shared vertex list
            iMesh.VertexList = new List<ImportedVertex>((int)mesh.m_VertexCount);
            for (var j = 0; j < mesh.m_VertexCount; j++)
            {
                var iVertex = new ImportedVertex();
                //Vertices
                int c = 3;
                if (mesh.m_Vertices.Length == mesh.m_VertexCount * 4)
                {
                    c = 4;
                }
                iVertex.Vertex = new Vector3f(-mesh.m_Vertices[j * c], mesh.m_Vertices[j * c + 1], mesh.m_Vertices[j * c + 2]);
                //Normals
                if (iMesh.hasNormal)
                {
                    if (mesh.m_Normals.Length == mesh.m_VertexCount * 3)
                    {
                        c = 3;
                    }
                    else if (mesh.m_Normals.Length == mesh.m_VertexCount * 4)
                    {
                        c = 4;
                    }
                    iVertex.Normal = new Vector3f(-mesh.m_Normals[j * c], mesh.m_Normals[j * c + 1], mesh.m_Normals[j * c + 2]);
                }
                //UV
                iVertex.UV = new float[8][];
                for (int uv = 0; uv < 8; uv++)
                {
                    if (iMesh.hasUV[uv])
                    {
                        var m_UV = mesh.GetUV(uv);
                        if (m_UV.Length == mesh.m_VertexCount * 2)
                        {
                            c = 2;
                        }
                        else if (m_UV.Length == mesh.m_VertexCount * 3)
                        {
                            c = 3;
                        }
                        iVertex.UV[uv] = new[] { m_UV[j * c], m_UV[j * c + 1] };
                    }
                }
                //Tangent
                if (iMesh.hasTangent)
                {
                    iVertex.Tangent = new Vector4f(-mesh.m_Tangents[j * 4], mesh.m_Tangents[j * 4 + 1], mesh.m_Tangents[j * 4 + 2], mesh.m_Tangents[j * 4 + 3]);
                }
                //Colors
                if (iMesh.hasColor)
                {
                    if (mesh.m_Colors.Length == mesh.m_VertexCount * 3)
                    {
                        iVertex.Color = new ColorRGBAf(mesh.m_Colors[j * 3], mesh.m_Colors[j * 3 + 1], mesh.m_Colors[j * 3 + 2], 1.0f);
                    }
                    else
                    {
                        iVertex.Color = new ColorRGBAf(mesh.m_Colors[j * 4], mesh.m_Colors[j * 4 + 1], mesh.m_Colors[j * 4 + 2], mesh.m_Colors[j * 4 + 3]);
                    }
                }
                //BoneInfluence
                if (mesh.m_Skin?.Length > 0)
                {
                    var inf = mesh.m_Skin[j];
                    iVertex.BoneIndices = new int[4];
                    iVertex.Weights = new float[4];
                    for (var k = 0; k < 4; k++)
                    {
                        iVertex.BoneIndices[k] = inf.boneIndex[k];
                        iVertex.Weights[k] = inf.weight[k];
                    }
                }
                iMesh.VertexList.Add(iVertex);
            }

            if (meshR is SkinnedMeshRenderer sMesh)
            {
                //Bone
                //
                // 0 - None
                // 1 - m_Bones
                // 2 - m_BoneNameHashes
                //
                var boneType = 0;
                if (sMesh.m_Bones.Length > 0)
                {
                    if (sMesh.m_Bones.Length == mesh.m_BindPose.Length)
                    {
                        var verifiedBoneCount = sMesh.m_Bones.Count(x => x.TryGet(out _));
                        if (verifiedBoneCount > 0)
                        {
                            boneType = 1;
                        }
                        if (verifiedBoneCount != sMesh.m_Bones.Length)
                        {
                            //尝试使用m_BoneNameHashes 4.3 and up
                            if (mesh.m_BindPose.Length > 0 && (mesh.m_BindPose.Length == mesh.m_BoneNameHashes?.Length))
                            {
                                //有效bone数量是否大于SkinnedMeshRenderer
                                var verifiedBoneCount2 = mesh.m_BoneNameHashes.Count(x => FixBonePath(GetPathFromHash(x)) != null);
                                if (verifiedBoneCount2 > verifiedBoneCount)
                                {
                                    boneType = 2;
                                }
                            }
                        }
                    }
                }
                if (boneType == 0)
                {
                    //尝试使用m_BoneNameHashes 4.3 and up
                    if (mesh.m_BindPose.Length > 0 && (mesh.m_BindPose.Length == mesh.m_BoneNameHashes?.Length))
                    {
                        var verifiedBoneCount = mesh.m_BoneNameHashes.Count(x => FixBonePath(GetPathFromHash(x)) != null);
                        if (verifiedBoneCount > 0)
                        {
                            boneType = 2;
                        }
                    }
                }

                if (boneType == 1)
                {
                    var boneCount = sMesh.m_Bones.Length;
                    iMesh.BoneList = new List<ImportedBone>(boneCount);
                    for (int i = 0; i < boneCount; i++)
                    {
                        var bone = new ImportedBone();
                        if (sMesh.m_Bones[i].TryGet(out var m_Transform))
                        {
                            bone.Path = GetTransformPath(m_Transform);
                        }
                        var convert = Matrix4x4.Scale(new Vector3f(-1, 1, 1));
                        bone.Matrix = convert * mesh.m_BindPose[i] * convert;
                        iMesh.BoneList.Add(bone);
                    }
                }
                else if (boneType == 2)
                {
                    var boneCount = mesh.m_BindPose.Length;
                    iMesh.BoneList = new List<ImportedBone>(boneCount);
                    for (int i = 0; i < boneCount; i++)
                    {
                        var bone = new ImportedBone();
                        var boneHash = mesh.m_BoneNameHashes[i];
                        var path = GetPathFromHash(boneHash);
                        bone.Path = FixBonePath(path);
                        var convert = Matrix4x4.Scale(new Vector3f(-1, 1, 1));
                        bone.Matrix = convert * mesh.m_BindPose[i] * convert;
                        iMesh.BoneList.Add(bone);
                    }
                }

                //Morphs
                if (mesh.m_Shapes?.channels?.Length > 0)
                {
                    var morph = new ImportedMorph();
                    MorphList.Add(morph);
                    morph.Path = iMesh.Path;
                    morph.Channels = new List<ImportedMorphChannel>(mesh.m_Shapes.channels.Length);
                    for (int i = 0; i < mesh.m_Shapes.channels.Length; i++)
                    {
                        var channel = new ImportedMorphChannel();
                        morph.Channels.Add(channel);
                        var shapeChannel = mesh.m_Shapes.channels[i];

                        var blendShapeName = "blendShape." + shapeChannel.name;
                        var crc = new SevenZip.CRC();
                        var bytes = Encoding.UTF8.GetBytes(blendShapeName);
                        crc.Update(bytes, 0, bytes.Length);
                        morphChannelNames[crc.GetDigest()] = blendShapeName;

                        channel.Name = shapeChannel.name.Split('.').Last();
                        channel.KeyframeList = new List<ImportedMorphKeyframe>(shapeChannel.frameCount);
                        var frameEnd = shapeChannel.frameIndex + shapeChannel.frameCount;
                        for (int frameIdx = shapeChannel.frameIndex; frameIdx < frameEnd; frameIdx++)
                        {
                            var keyframe = new ImportedMorphKeyframe();
                            channel.KeyframeList.Add(keyframe);
                            keyframe.Weight = mesh.m_Shapes.fullWeights[frameIdx];
                            var shape = mesh.m_Shapes.shapes[frameIdx];
                            keyframe.hasNormals = shape.hasNormals;
                            keyframe.hasTangents = shape.hasTangents;
                            keyframe.VertexList = new List<ImportedMorphVertex>((int)shape.vertexCount);
                            var vertexEnd = shape.firstVertex + shape.vertexCount;
                            for (uint j = shape.firstVertex; j < vertexEnd; j++)
                            {
                                var destVertex = new ImportedMorphVertex();
                                keyframe.VertexList.Add(destVertex);
                                var morphVertex = mesh.m_Shapes.vertices[j];
                                destVertex.Index = morphVertex.index;
                                var sourceVertex = iMesh.VertexList[(int)morphVertex.index];
                                destVertex.Vertex = new ImportedVertex();
                                var morphPos = morphVertex.vertex;
                                destVertex.Vertex.Vertex = sourceVertex.Vertex + new Vector3f(-morphPos.X, morphPos.Y, morphPos.Z);
                                if (shape.hasNormals)
                                {
                                    var morphNormal = morphVertex.normal;
                                    destVertex.Vertex.Normal = new Vector3f(-morphNormal.X, morphNormal.Y, morphNormal.Z);
                                }
                                if (shape.hasTangents)
                                {
                                    var morphTangent = morphVertex.tangent;
                                    destVertex.Vertex.Tangent = new Vector4f(-morphTangent.X, morphTangent.Y, morphTangent.Z, 0);
                                }
                            }
                        }
                    }
                }
            }

            //TODO combine mesh
            if (combine)
            {
                meshR.m_GameObject.TryGet(out var m_GameObject);
                var frame = RootFrame.FindChild(m_GameObject.m_Name);
                if (frame != null)
                {
                    frame.LocalPosition = RootFrame.LocalPosition;
                    frame.LocalRotation = RootFrame.LocalRotation;
                    while (frame.Parent != null)
                    {
                        frame = frame.Parent;
                        frame.LocalPosition = RootFrame.LocalPosition;
                        frame.LocalRotation = RootFrame.LocalRotation;
                    }
                }
            }

            MeshList.Add(iMesh);
        }

        private static Mesh GetMesh(Renderer meshR)
        {
            if (meshR is SkinnedMeshRenderer sMesh)
            {
                if (sMesh.m_Mesh.TryGet(out var m_Mesh))
                {
                    return m_Mesh;
                }
            }
            else
            {
                meshR.m_GameObject.TryGet(out var m_GameObject);
                if (m_GameObject.m_MeshFilter != null)
                {
                    if (m_GameObject.m_MeshFilter.m_Mesh.TryGet(out var m_Mesh))
                    {
                        return m_Mesh;
                    }
                }
            }

            return null;
        }

        private string GetTransformPath(Transform transform)
        {
            if (transformDictionary.TryGetValue(transform, out var frame))
            {
                return frame.Path;
            }
            return null;
        }

        private string FixBonePath(AnimationClip m_AnimationClip, string path)
        {
            if (boundAnimationPathDic.TryGetValue(m_AnimationClip, out var basePath))
            {
                path = basePath + "/" + path;
            }
            return FixBonePath(path);
        }

        private string FixBonePath(string path)
        {
            var frame = RootFrame.FindFrameByPath(path);
            return frame?.Path;
        }

        private static string GetTransformPathByFather(Transform transform)
        {
            transform.m_GameObject.TryGet(out var m_GameObject);
            if (transform.m_Father.TryGet(out var father))
            {
                return GetTransformPathByFather(father) + "/" + m_GameObject.m_Name;
            }

            return m_GameObject.m_Name;
        }

        private ImportedMaterial ConvertMaterial(Material mat)
        {
            ImportedMaterial iMat;
            if (mat != null)
            {
                iMat = ImportedHelpers.FindMaterial(mat.m_Name, MaterialList);
                if (iMat != null)
                {
                    return iMat;
                }
                iMat = new ImportedMaterial();
                iMat.Name = mat.m_Name;
                //default values
                iMat.Diffuse = new ColorRGBAf(0.8f, 0.8f, 0.8f, 1);
                iMat.Ambient = new ColorRGBAf(0.2f, 0.2f, 0.2f, 1);
                iMat.Emissive = new ColorRGBAf(0, 0, 0, 1);
                iMat.Specular = new ColorRGBAf(0.2f, 0.2f, 0.2f, 1);
                iMat.Reflection = new ColorRGBAf(0, 0, 0, 1);
                iMat.Shininess = 20f;
                iMat.Transparency = 0f;
                foreach (var col in mat.m_SavedProperties.m_Colors)
                {
                    switch (col.Key)
                    {
                        case "_Color":
                            iMat.Diffuse = col.Value;
                            break;
                        case "_SColor":
                            iMat.Ambient = col.Value;
                            break;
                        case "_EmissionColor":
                            iMat.Emissive = col.Value;
                            break;
                        case "_SpecularColor":
                            iMat.Specular = col.Value;
                            break;
                        case "_ReflectColor":
                            iMat.Reflection = col.Value;
                            break;
                    }
                }

                foreach (var flt in mat.m_SavedProperties.m_Floats)
                {
                    switch (flt.Key)
                    {
                        case "_Shininess":
                            iMat.Shininess = flt.Value;
                            break;
                        case "_Transparency":
                            iMat.Transparency = flt.Value;
                            break;
                    }
                }

                //textures
                iMat.Textures = new List<ImportedMaterialTexture>();
                foreach (var texEnv in mat.m_SavedProperties.m_TexEnvs)
                {
                    if (!texEnv.Value.m_Texture.TryGet<Texture2D>(out var m_Texture2D)) //TODO other Texture
                    {
                        continue;
                    }

                    var texture = new ImportedMaterialTexture();
                    iMat.Textures.Add(texture);

                    int dest = -1;
                    if (texEnv.Key == "_MainTex")
                        dest = 0;
                    else if (texEnv.Key == "_BumpMap")
                        dest = 3;
                    else if (texEnv.Key.Contains("Specular"))
                        dest = 2;
                    else if (texEnv.Key.Contains("Normal"))
                        dest = 1;

                    texture.Dest = dest;

                    var ext = $".{imageFormat.ToString().ToLower()}";
                    if (textureNameDictionary.TryGetValue(m_Texture2D, out var textureName))
                    {
                        texture.Name = textureName;
                    }
                    else if (ImportedHelpers.FindTexture(m_Texture2D.m_Name + ext, TextureList) != null) //已有相同名字的图片
                    {
                        for (int i = 1; ; i++)
                        {
                            var name = m_Texture2D.m_Name + $" ({i}){ext}";
                            if (ImportedHelpers.FindTexture(name, TextureList) == null)
                            {
                                texture.Name = name;
                                textureNameDictionary.Add(m_Texture2D, name);
                                break;
                            }
                        }
                    }
                    else
                    {
                        texture.Name = m_Texture2D.m_Name + ext;
                        textureNameDictionary.Add(m_Texture2D, texture.Name);
                    }

                    texture.Offset = texEnv.Value.m_Offset;
                    texture.Scale = texEnv.Value.m_Scale;
                    ConvertTexture2D(m_Texture2D, texture.Name);
                }

                MaterialList.Add(iMat);
            }
            else
            {
                iMat = new ImportedMaterial();
            }
            return iMat;
        }

        private void ConvertTexture2D(Texture2D m_Texture2D, string name)
        {
            var iTex = ImportedHelpers.FindTexture(name, TextureList);
            if (iTex != null)
            {
                return;
            }

            var stream = m_Texture2D.ConvertToStream(imageFormat, true);
            if (stream != null)
            {
                using (stream)
                {
                    iTex = new ImportedTexture(stream, name);
                    TextureList.Add(iTex);
                }
            }
        }

        private void ConvertAnimations()
        {
            foreach (var animationClip in animationClipHashSet)
            {
                var iAnim = new ImportedKeyframedAnimation();
                var name = animationClip.m_Name;
                if (AnimationList.Exists(x => x.Name == name))
                {
                    for (int i = 1; ; i++)
                    {
                        var fixName = name + $"_{i}";
                        if (!AnimationList.Exists(x => x.Name == fixName))
                        {
                            name = fixName;
                            break;
                        }
                    }
                }
                iAnim.Name = name;
                iAnim.SampleRate = animationClip.m_SampleRate;
                iAnim.TrackList = new List<ImportedAnimationKeyframedTrack>();
                AnimationList.Add(iAnim);
                if (animationClip.m_Legacy)
                {
                    foreach (var m_CompressedRotationCurve in animationClip.m_CompressedRotationCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_CompressedRotationCurve.m_Path));

                        var numKeys = m_CompressedRotationCurve.m_Times.m_NumItems;
                        var data = m_CompressedRotationCurve.m_Times.UnpackInts();
                        var times = new float[numKeys];
                        int t = 0;
                        for (int i = 0; i < numKeys; i++)
                        {
                            t += data[i];
                            times[i] = t * 0.01f;
                        }
                        var quats = m_CompressedRotationCurve.m_Values.UnpackQuats();

                        for (int i = 0; i < numKeys; i++)
                        {
                            var quat = quats[i];
                            var value = Fbx.QuaternionToEuler(new Quaternionf(quat.X, -quat.Y, -quat.Z, quat.W));
                            track.Rotations.Add(new ImportedKeyframe<Vector3f>(times[i], value));
                        }
                    }
                    foreach (var m_RotationCurve in animationClip.m_RotationCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_RotationCurve.path));
                        foreach (var m_Curve in m_RotationCurve.curve.m_Curve)
                        {
                            var value = Fbx.QuaternionToEuler(new Quaternionf(m_Curve.value.X, -m_Curve.value.Y, -m_Curve.value.Z, m_Curve.value.W));
                            track.Rotations.Add(new ImportedKeyframe<Vector3f>(m_Curve.time, value));
                        }
                    }
                    foreach (var m_PositionCurve in animationClip.m_PositionCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_PositionCurve.path));
                        foreach (var m_Curve in m_PositionCurve.curve.m_Curve)
                        {
                            track.Translations.Add(new ImportedKeyframe<Vector3f>(m_Curve.time, new Vector3f(-m_Curve.value.X, m_Curve.value.Y, m_Curve.value.Z)));
                        }
                    }
                    foreach (var m_ScaleCurve in animationClip.m_ScaleCurves)
                    {
                        var track = iAnim.FindTrack(FixBonePath(animationClip, m_ScaleCurve.path));
                        foreach (var m_Curve in m_ScaleCurve.curve.m_Curve)
                        {
                            track.Scalings.Add(new ImportedKeyframe<Vector3f>(m_Curve.time, new Vector3f(m_Curve.value.X, m_Curve.value.Y, m_Curve.value.Z)));
                        }
                    }
                    if (animationClip.m_EulerCurves != null)
                    {
                        foreach (var m_EulerCurve in animationClip.m_EulerCurves)
                        {
                            var track = iAnim.FindTrack(FixBonePath(animationClip, m_EulerCurve.path));
                            foreach (var m_Curve in m_EulerCurve.curve.m_Curve)
                            {
                                track.Rotations.Add(new ImportedKeyframe<Vector3f>(m_Curve.time, new Vector3f(m_Curve.value.X, -m_Curve.value.Y, -m_Curve.value.Z)));
                            }
                        }
                    }
                    foreach (var m_FloatCurve in animationClip.m_FloatCurves)
                    {
                        if (m_FloatCurve.classID == ClassIDType.SkinnedMeshRenderer) //BlendShape
                        {
                            var channelName = m_FloatCurve.attribute;
                            int dotPos = channelName.IndexOf('.');
                            if (dotPos >= 0)
                            {
                                channelName = channelName.Substring(dotPos + 1);
                            }

                            var path = FixBonePath(animationClip, m_FloatCurve.path);
                            if (string.IsNullOrEmpty(path))
                            {
                                path = GetPathByChannelName(channelName);
                            }
                            var track = iAnim.FindTrack(path);
                            track.BlendShape = new ImportedBlendShape();
                            track.BlendShape.ChannelName = channelName;
                            foreach (var m_Curve in m_FloatCurve.curve.m_Curve)
                            {
                                track.BlendShape.Keyframes.Add(new ImportedKeyframe<float>(m_Curve.time, m_Curve.value));
                            }
                        }
                    }
                }
                else
                {
                    var m_Clip = animationClip.m_MuscleClip.m_Clip;
                    var streamedFrames = m_Clip.m_StreamedClip.ReadData();
                    var m_ClipBindingConstant = animationClip.m_ClipBindingConstant ?? m_Clip.ConvertValueArrayToGenericBinding();
                    for (int frameIndex = 1; frameIndex < streamedFrames.Count - 1; frameIndex++)
                    {
                        var frame = streamedFrames[frameIndex];
                        var streamedValues = frame.keyList.Select(x => x.value).ToArray();
                        for (int curveIndex = 0; curveIndex < frame.keyList.Length;)
                        {
                            ReadCurveData(iAnim, m_ClipBindingConstant, frame.keyList[curveIndex].index, frame.time, streamedValues, 0, ref curveIndex);
                        }
                    }
                    var m_DenseClip = m_Clip.m_DenseClip;
                    var streamCount = m_Clip.m_StreamedClip.curveCount;
                    for (int frameIndex = 0; frameIndex < m_DenseClip.m_FrameCount; frameIndex++)
                    {
                        var time = m_DenseClip.m_BeginTime + frameIndex / m_DenseClip.m_SampleRate;
                        var frameOffset = frameIndex * m_DenseClip.m_CurveCount;
                        for (int curveIndex = 0; curveIndex < m_DenseClip.m_CurveCount;)
                        {
                            var index = streamCount + curveIndex;
                            ReadCurveData(iAnim, m_ClipBindingConstant, (int)index, time, m_DenseClip.m_SampleArray, (int)frameOffset, ref curveIndex);
                        }
                    }
                    if (m_Clip.m_ConstantClip != null)
                    {
                        var m_ConstantClip = m_Clip.m_ConstantClip;
                        var denseCount = m_Clip.m_DenseClip.m_CurveCount;
                        var time2 = 0.0f;
                        for (int i = 0; i < 2; i++)
                        {
                            for (int curveIndex = 0; curveIndex < m_ConstantClip.data.Length;)
                            {
                                var index = streamCount + denseCount + curveIndex;
                                ReadCurveData(iAnim, m_ClipBindingConstant, (int)index, time2, m_ConstantClip.data, 0, ref curveIndex);
                            }
                            time2 = animationClip.m_MuscleClip.m_StopTime;
                        }
                    }
                }
            }
        }

        private void ReadCurveData(ImportedKeyframedAnimation iAnim, AnimationClipBindingConstant m_ClipBindingConstant, int index, float time, float[] data, int offset, ref int curveIndex)
        {
            var binding = m_ClipBindingConstant.FindBinding(index);
            if (binding.typeID == ClassIDType.SkinnedMeshRenderer) //BlendShape
            {
                var channelName = GetChannelNameFromHash(binding.attribute);
                if (string.IsNullOrEmpty(channelName))
                {
                    curveIndex++;
                    return;
                }
                int dotPos = channelName.IndexOf('.');
                if (dotPos >= 0)
                {
                    channelName = channelName.Substring(dotPos + 1);
                }

                var bPath = FixBonePath(GetPathFromHash(binding.path));
                if (string.IsNullOrEmpty(bPath))
                {
                    bPath = GetPathByChannelName(channelName);
                }
                var bTrack = iAnim.FindTrack(bPath);
                bTrack.BlendShape = new ImportedBlendShape();
                bTrack.BlendShape.ChannelName = channelName;
                bTrack.BlendShape.Keyframes.Add(new ImportedKeyframe<float>(time, data[curveIndex++ + offset]));
            }
            else if (binding.typeID == ClassIDType.Transform)
            {
                var path = FixBonePath(GetPathFromHash(binding.path));
                var track = iAnim.FindTrack(path);

                switch (binding.attribute)
                {
                    case 1:
                        track.Translations.Add(new ImportedKeyframe<Vector3f>(time, new Vector3
                        (
                            -data[curveIndex++ + offset],
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        )));
                        break;
                    case 2:
                        var value = Fbx.QuaternionToEuler(new Quaternion
                        (
                            data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        ));
                        track.Rotations.Add(new ImportedKeyframe<Vector3f>(time, value));
                        break;
                    case 3:
                        track.Scalings.Add(new ImportedKeyframe<Vector3f>(time, new Vector3
                        (
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset],
                            data[curveIndex++ + offset]
                        )));
                        break;
                    case 4:
                        track.Rotations.Add(new ImportedKeyframe<Vector3f>(time, new Vector3
                        (
                            data[curveIndex++ + offset],
                            -data[curveIndex++ + offset],
                            -data[curveIndex++ + offset]
                        )));
                        break;
                    default:
                        curveIndex++;
                        break;
                }
            }
            else
            {
                curveIndex++;
            }
        }

        private string GetPathFromHash(uint hash)
        {
            bonePathHash.TryGetValue(hash, out var boneName);
            if (string.IsNullOrEmpty(boneName))
            {
                boneName = avatar?.FindBonePath(hash);
            }
            if (string.IsNullOrEmpty(boneName))
            {
                boneName = "unknown " + hash;
            }
            return boneName;
        }

        private void CreateBonePathHash(Transform m_Transform)
        {
            var name = GetTransformPathByFather(m_Transform);
            var crc = new SevenZip.CRC();
            var bytes = Encoding.UTF8.GetBytes(name);
            crc.Update(bytes, 0, (uint)bytes.Length);
            bonePathHash[crc.GetDigest()] = name;
            int index;
            while ((index = name.IndexOf("/", StringComparison.Ordinal)) >= 0)
            {
                name = name.Substring(index + 1);
                crc = new SevenZip.CRC();
                bytes = Encoding.UTF8.GetBytes(name);
                crc.Update(bytes, 0, (uint)bytes.Length);
                bonePathHash[crc.GetDigest()] = name;
            }
            foreach (var pptr in m_Transform.m_Children)
            {
                if (pptr.TryGet(out var child))
                    CreateBonePathHash(child);
            }
        }

        private void DeoptimizeTransformHierarchy()
        {
            if (avatar == null)
                throw new Exception("Transform hierarchy has been optimized, but can't find Avatar to deoptimize.");
            // 1. Figure out the skeletonPaths from the unstripped avatar
            var skeletonPaths = new List<string>();
            foreach (var id in avatar.m_Avatar.m_AvatarSkeleton.m_ID)
            {
                var path = avatar.FindBonePath(id);
                skeletonPaths.Add(path);
            }
            // 2. Restore the original transform hierarchy
            // Prerequisite: skeletonPaths follow pre-order traversal
            for (var i = 1; i < skeletonPaths.Count; i++) // start from 1, skip the root transform because it will always be there.
            {
                var path = skeletonPaths[i];
                var strs = path.Split('/');
                string transformName;
                ImportedFrame parentFrame;
                if (strs.Length == 1)
                {
                    transformName = path;
                    parentFrame = RootFrame;
                }
                else
                {
                    transformName = strs.Last();
                    var parentFrameName = strs[strs.Length - 2];
                    parentFrame = RootFrame.FindChild(parentFrameName);
                    //var parentFramePath = path.Substring(0, path.LastIndexOf('/'));
                    //parentFrame = RootFrame.FindFrameByPath(parentFramePath);
                }

                var skeletonPose = avatar.m_Avatar.m_DefaultPose;
                var xform = skeletonPose.m_X[i];

                var frame = RootFrame.FindChild(transformName);
                if (frame != null)
                {
                    SetFrame(frame, xform.t, xform.q, xform.s);
                    parentFrame.AddChild(frame);
                }
                else
                {
                    frame = CreateFrame(transformName, xform.t, xform.q, xform.s);
                    parentFrame.AddChild(frame);
                }
            }
        }

        private string GetPathByChannelName(string channelName)
        {
            foreach (var morph in MorphList)
            {
                foreach (var channel in morph.Channels)
                {
                    if (channel.Name == channelName)
                    {
                        return morph.Path;
                    }
                }
            }
            return null;
        }

        private string GetChannelNameFromHash(uint attribute)
        {
            if (morphChannelNames.TryGetValue(attribute, out var name))
            {
                return name;
            }
            else
            {
                return null;
            }
        }
    }
}
*/
```

`AssetRipperLibrary/Reference/ModelExporter.cs`:

```cs
/*namespace AssetRipper.Reading.Utils
{
    public static class ModelExporter
    {
        public static void ExportFbx(string path, IImported imported, bool eulerFilter, float filterPrecision,
            bool allNodes, bool skins, bool animation, bool blendShape, bool castToBone, float boneSize, bool exportAllUvsAsDiffuseMaps, float scaleFactor, int versionIndex, bool isAscii)
        {
            Fbx.Exporter.Export(path, imported, eulerFilter, filterPrecision, allNodes, skins, animation, blendShape, castToBone, boneSize, exportAllUvsAsDiffuseMaps, scaleFactor, versionIndex, isAscii);
        }
    }
}*/

```

`AssetRipperLibrary/Ripper.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Asset;
using AssetRipper.Core.Project.Exporters;
using AssetRipper.Core.Project.Exporters.Engine;
using AssetRipper.Core.Structure.GameStructure;
using AssetRipper.Core.Utils;
using AssetRipper.Core.VersionHandling;
using AssetRipper.Library.Attributes;
using AssetRipper.Library.Configuration;
using AssetRipper.Library.Exporters;
using AssetRipper.Library.Exporters.AnimationClips;
using AssetRipper.Library.Exporters.AnimatorControllers;
using AssetRipper.Library.Exporters.Audio;
using AssetRipper.Library.Exporters.Meshes;
using AssetRipper.Library.Exporters.Miscellaneous;
using AssetRipper.Library.Exporters.Scripts;
using AssetRipper.Library.Exporters.Shaders;
using AssetRipper.Library.Exporters.Terrains;
using AssetRipper.Library.Exporters.Textures;
using AssetRipper.Library.Exporters.TypeTrees;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_117;
using AssetRipper.SourceGenerated.Classes.ClassID_128;
using AssetRipper.SourceGenerated.Classes.ClassID_152;
using AssetRipper.SourceGenerated.Classes.ClassID_156;
using AssetRipper.SourceGenerated.Classes.ClassID_187;
using AssetRipper.SourceGenerated.Classes.ClassID_188;
using AssetRipper.SourceGenerated.Classes.ClassID_21;
using AssetRipper.SourceGenerated.Classes.ClassID_213;
using AssetRipper.SourceGenerated.Classes.ClassID_28;
using AssetRipper.SourceGenerated.Classes.ClassID_43;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Classes.ClassID_49;
using AssetRipper.SourceGenerated.Classes.ClassID_74;
using AssetRipper.SourceGenerated.Classes.ClassID_83;
using AssetRipper.SourceGenerated.Classes.ClassID_91;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace AssetRipper.Library
{
	public class Ripper
	{
		static Ripper()
		{
			VersionManager.AssetFactory = new AssetFactory();
		}

		public Ripper() : this(new()) { }

		public Ripper(LibraryConfiguration configuration)
		{
			Settings = configuration;
			LoadPlugins();
		}

		public GameStructure GameStructure { get; private set; }
		/// <summary>
		/// Needs to be set before loading assets to ensure predictable behavior
		/// </summary>
		public LibraryConfiguration Settings { get; }
		private bool ExportersInitialized { get; set; }
		private List<IPostExporter> PostExporters { get; } = new();

		public event Action OnStartLoadingGameStructure;
		public event Action OnFinishLoadingGameStructure;
		public event Action OnInitializingExporters;
		public event Action OnStartExporting;
		public event Action OnFinishExporting;

		private void LoadPlugins()
		{
			Logger.Info(LogCategory.Plugin, "Loading plugins...");
			string pluginsDirectory = ExecutingDirectory.Combine("Plugins");
			Directory.CreateDirectory(pluginsDirectory);
			List<Type> pluginTypes = new();
			foreach (string dllFile in Directory.GetFiles(pluginsDirectory, "*.dll"))
			{
				try
				{
					Logger.Info(LogCategory.Plugin, $"Found assembly at {dllFile}");
					Assembly assembly = Assembly.LoadFile(dllFile);
					foreach (RegisterPluginAttribute pluginAttr in assembly.GetCustomAttributes<RegisterPluginAttribute>())
					{
						pluginTypes.Add(pluginAttr.PluginType);
					}
				}
				catch (Exception ex)
				{
					Logger.Error(LogCategory.Plugin, $"Exception thrown while loading plugin assembly: {dllFile}", ex);
				}
			}
			foreach (Type type in pluginTypes)
			{
				try
				{
					PluginBase plugin = (PluginBase)Activator.CreateInstance(type);
					plugin.CurrentRipper = this;
					plugin.Initialize();
					Logger.Info(LogCategory.Plugin, $"Initialized plugin: {plugin.Name}");
				}
				catch (Exception ex)
				{
					Logger.Error(LogCategory.Plugin, $"Exception thrown while initializing plugin: {type?.FullName ?? "<null>"}", ex);
				}
			}
			Logger.Info(LogCategory.Plugin, "Finished loading plugins.");
		}

		public GameStructure Load(IReadOnlyList<string> paths)
		{
			ResetData();
			if (paths.Count == 1)
			{
				Logger.Info(LogCategory.General, $"Attempting to read files from {paths[0]}");
			}
			else
			{
				Logger.Info(LogCategory.General, $"Attempting to read files from {paths.Count} paths...");
			}

			OnStartLoadingGameStructure?.Invoke();
			TaskManager.WaitUntilAllCompleted();

			GameStructure = GameStructure.Load(paths, Settings);
			TaskManager.WaitUntilAllCompleted();
			Logger.Info(LogCategory.General, "Finished reading files");

			OnFinishLoadingGameStructure?.Invoke();
			TaskManager.WaitUntilAllCompleted();
			return GameStructure;
		}

		public IEnumerable<IUnityObjectBase> FetchLoadedAssets()
		{
			if (GameStructure == null)
			{
				throw new NullReferenceException("GameStructure cannot be null");
			}

			if (GameStructure.FileCollection == null)
			{
				throw new NullReferenceException("FileCollection cannot be null");
			}

			return GameStructure.FileCollection.FetchAssets();
		}

		public void ExportProject(string exportPath) => ExportProject(exportPath, Core.Configuration.CoreConfiguration.DefaultFilter);
		public void ExportProject(string exportPath, IUnityObjectBase asset) => ExportProject(exportPath, new IUnityObjectBase[] { asset });
		public void ExportProject(string exportPath, IEnumerable<IUnityObjectBase> assets) => ExportProject(exportPath, GetFilter(assets));
		public void ExportProject<T>(string exportPath) => ExportProject(exportPath, GetFilter<T>());
		public void ExportProject(string exportPath, Type type) => ExportProject(exportPath, GetFilter(type));
		public void ExportProject(string exportPath, IEnumerable<Type> types) => ExportProject(exportPath, GetFilter(types));
		private void ExportProject(string exportPath, Func<IUnityObjectBase, bool> filter)
		{
			Logger.Info(LogCategory.Export, $"Attempting to export assets to {exportPath}...");
			Settings.ExportRootPath = exportPath;
			Settings.Filter = filter;
			InitializeExporters();
			TaskManager.WaitUntilAllCompleted();

			Logger.Info(LogCategory.Export, "Starting pre-export");
			OnStartExporting?.Invoke();
			TaskManager.WaitUntilAllCompleted();

			Logger.Info(LogCategory.Export, "Starting export");
			GameStructure.Export(Settings);
			TaskManager.WaitUntilAllCompleted();

			Logger.Info(LogCategory.Export, "Finished exporting assets");
			OnFinishExporting?.Invoke();
			TaskManager.WaitUntilAllCompleted();

			foreach (IPostExporter postExporter in PostExporters)
			{
				postExporter.DoPostExport(this);
			}
			TaskManager.WaitUntilAllCompleted();
			Logger.Info(LogCategory.Export, "Finished post-export");
		}

		public void ResetData()
		{
			PostExporters.Clear();
			ExportersInitialized = false;
			GameStructure?.Dispose();
			GameStructure = null;
		}

		public void ResetSettings() => Settings.ResetToDefaultValues();

		private static Func<IUnityObjectBase, bool> GetFilter(IEnumerable<IUnityObjectBase> assets)
		{
			if (assets == null || !assets.Any())
			{
				return LibraryConfiguration.DefaultFilter;
			}
			else
			{
				return assets.Contains;
			}
		}
		private static Func<IUnityObjectBase, bool> GetFilter<T>()
		{
			return asset => asset is T;
		}
		private static Func<IUnityObjectBase, bool> GetFilter(Type type)
		{
			return asset => asset.GetType().IsAssignableTo(type);
		}
		private static Func<IUnityObjectBase, bool> GetFilter(IEnumerable<Type> types)
		{
			if (types == null || !types.Any())
			{
				return LibraryConfiguration.DefaultFilter;
			}
			else
			{
				return asset => types.Any(t => asset.GetType().IsAssignableTo(t));
			}
		}

		private void InitializeExporters()
		{
			if (GameStructure == null)
			{
				throw new NullReferenceException("GameStructure cannot be null");
			}

			if (GameStructure.FileCollection == null)
			{
				throw new NullReferenceException("FileCollection cannot be null");
			}

			if (GameStructure.Exporter == null)
			{
				throw new NullReferenceException("Project Exporter cannot be null");
			}

			if (ExportersInitialized)
			{
				return;
			}

			OverrideNormalExporters();
			OnInitializingExporters?.Invoke();
			OverrideEngineExporters();

			ExportersInitialized = true;
		}

		private void OverrideNormalExporters()
		{
			//Yaml Exporters
			YamlStreamedAssetExporter streamedAssetExporter = new();
			OverrideExporter<IMesh>(streamedAssetExporter);
			OverrideExporter<ITexture2D>(streamedAssetExporter);//ICubemap also by inheritance
			OverrideExporter<ITexture3D>(streamedAssetExporter);
			OverrideExporter<ITexture2DArray>(streamedAssetExporter);
			OverrideExporter<ICubemapArray>(streamedAssetExporter);

			//Miscellaneous exporters
			OverrideExporter<ITextAsset>(new TextAssetExporter(Settings));
			OverrideExporter<IFont>(new FontAssetExporter());
			OverrideExporter<IMovieTexture>(new MovieTextureAssetExporter());
			VideoClipExporter videoClipExporter = new();
			OverrideExporter<SourceGenerated.Classes.ClassID_327.IVideoClip>(videoClipExporter);
			OverrideExporter<SourceGenerated.Classes.ClassID_329.IVideoClip>(videoClipExporter);

			//Texture exporters
			TextureAssetExporter textureExporter = new(Settings);
			OverrideExporter<ITexture2D>(textureExporter); //Texture2D and Cubemap
			OverrideExporter<ISprite>(textureExporter);

			//Shader exporters
			ConditionalOverrideExporter<IShader>(new DummyShaderTextExporter(), Settings.ShaderExportMode == ShaderExportMode.Dummy);
			ConditionalOverrideExporter<IShader>(new YamlShaderExporter(), Settings.ShaderExportMode == ShaderExportMode.Yaml);
			ConditionalOverrideExporter<IShader>(new ShaderDisassemblyExporter(), Settings.ShaderExportMode == ShaderExportMode.Disassembly);
			OverrideExporter<IShader>(new SimpleShaderExporter());

			//Audio exporters
			OverrideExporter<IAudioClip>(new YamlAudioExporter());
			ConditionalOverrideExporter<IAudioClip>(new NativeAudioExporter(), Settings.AudioExportFormat == AudioExportFormat.Native);
			ConditionalOverrideExporter<IAudioClip>(new AudioClipExporter(Settings), AudioClipExporter.IsSupportedExportFormat(Settings.AudioExportFormat));

			//Mesh exporters
			OverrideExporter<Core.Classes.Mesh.Mesh>(new GlbMeshExporter(Settings));
			OverrideExporter<Core.Classes.Mesh.Mesh>(new UnifiedMeshExporter(Settings));

			//Terrain exporters
			ConditionalOverrideExporter<ITerrainData>(new TerrainHeatmapExporter(Settings), Settings.TerrainExportMode == TerrainExportMode.Heatmap);
			ConditionalOverrideExporter<ITerrainData>(new TerrainObjExporter(), Settings.TerrainExportMode == TerrainExportMode.Obj);

			//Script exporters
			OverrideExporter<IMonoScript>(new AssemblyDllExporter(GameStructure.FileCollection.AssemblyManager, Settings));
			OverrideExporter<IMonoScript>(new ScriptExporter(GameStructure.FileCollection.AssemblyManager, Settings));
			
			//Animator Controller
			OverrideExporter<IAnimatorController>(new AnimatorControllerExporter());

			//Animation Clip
			OverrideExporter<IAnimationClip>(new AnimationClipExporter());

			AddPostExporter(new ProjectVersionPostExporter());
			AddPostExporter(new TypeTreeExporter());
			AddPostExporter(new DllPostExporter());
		}

		private void OverrideEngineExporters()
		{
			EngineAssetExporter engineExporter = new(Settings);
			OverrideExporter<IMaterial>(engineExporter);
			OverrideExporter<ITexture2D>(engineExporter);
			OverrideExporter<IMesh>(engineExporter);
			OverrideExporter<IShader>(engineExporter);
			OverrideExporter<IFont>(engineExporter);
			OverrideExporter<ISprite>(engineExporter);
			OverrideExporter<IMonoBehaviour>(engineExporter);
		}

		private void ConditionalOverrideExporter<T>(IAssetExporter exporter, bool shouldOverride)
		{
			if (shouldOverride)
			{
				OverrideExporter<T>(exporter);
			}
		}
		public void OverrideExporter<T>(IAssetExporter exporter) => GameStructure.Exporter.OverrideExporter<T>(exporter, true);
		public void AddPostExporter(IPostExporter exporter) => PostExporters.Add(exporter);
	}
}

```

`AssetRipperLibrary/Utils/BmpWriter.cs`:

```cs
using System.IO;

namespace AssetRipper.Library.Utils
{
	/// <summary>
	/// This is really fast, even in comparison to System.Drawing<br/>
	/// It could be even faster if it didn't have to flip the pixels in the y direction
	/// </summary>
	internal static class BmpWriter
	{
		/*
		static byte[] bmpData = // All values are little-endian
		{
			//14 bytes
			0x42, 0x4D,             // Signature 'BM'
			0xaa, 0x00, 0x00, 0x00, // Size: 170 bytes
			0x00, 0x00,             // Unused
			0x00, 0x00,             // Unused
			0x8a, 0x00, 0x00, 0x00, // Offset to image data, ie 138

			//108 bytes
			0x7c, 0x00, 0x00, 0x00, // DIB header size (124 bytes)
			0x04, 0x00, 0x00, 0x00, // Width (4px)
			0x02, 0x00, 0x00, 0x00, // Height (2px)
			0x01, 0x00,             // Planes (1)
			0x20, 0x00,             // Bits per pixel (32)
			0x03, 0x00, 0x00, 0x00, // Format (bitfield = use bitfields | no compression)
			0x20, 0x00, 0x00, 0x00, // Image raw size (32 bytes)
			0x13, 0x0B, 0x00, 0x00, // Horizontal print resolution (2835 = 72dpi * 39.3701)
			0x13, 0x0B, 0x00, 0x00, // Vertical print resolution (2835 = 72dpi * 39.3701)
			0x00, 0x00, 0x00, 0x00, // Colors in palette (none)
			0x00, 0x00, 0x00, 0x00, // Important colors (0 = all)
			0x00, 0x00, 0xFF, 0x00, // R bitmask (00FF0000)
			0x00, 0xFF, 0x00, 0x00, // G bitmask (0000FF00)
			0xFF, 0x00, 0x00, 0x00, // B bitmask (000000FF)
			0x00, 0x00, 0x00, 0xFF, // A bitmask (FF000000)
			0x42, 0x47, 0x52, 0x73, // sRGB color space
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused R entry for color space
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused G entry for color space
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Unused B entry for color space
			0x00, 0x00, 0x00, 0x00, // Unused Gamma X entry for color space
			0x00, 0x00, 0x00, 0x00, // Unused Gamma Y entry for color space
			0x00, 0x00, 0x00, 0x00, // Unused Gamma Z entry for color space

			//16 bytes
			0x00, 0x00, 0x00, 0x00, // Unknown
			0x00, 0x00, 0x00, 0x00, // Unknown
			0x00, 0x00, 0x00, 0x00, // Unknown
			0x00, 0x00, 0x00, 0x00, // Unknown

			// Image data: 32 bytes
			0xFF, 0x00, 0x00, 0x7F, // Bottom left pixel
			0x00, 0xFF, 0x00, 0x7F,
			0x00, 0x00, 0xFF, 0x7F,
			0xFF, 0xFF, 0xFF, 0x7F, // Bottom right pixel
			0xFF, 0x00, 0x00, 0xFF, // Top left pixel
			0x00, 0xFF, 0x00, 0xFF,
			0x00, 0x00, 0xFF, 0xFF,
			0xFF, 0xFF, 0xFF, 0xFF  // Top right pixel
		};
		*/

		public static void WriteBmp(byte[] bgra32Data, int width, int height, Stream stream, bool flip = true)
		{
			if (bgra32Data is null)
			{
				throw new ArgumentNullException(nameof(bgra32Data));
			}

			if (stream is null)
			{
				throw new ArgumentNullException(nameof(stream));
			}

			if (width <= 0)
			{
				throw new ArgumentOutOfRangeException(nameof(width));
			}

			if (height <= 0)
			{
				throw new ArgumentOutOfRangeException(nameof(height));
			}

			if (bgra32Data.Length != GetRawImageSize(width, height))
			{
				throw new ArgumentException("Length must match 4 * width * height", nameof(bgra32Data));
			}

			using BinaryWriter writer = new BinaryWriter(stream);

			//14 bytes
			writer.WriteBytes(0x42, 0x4D); // Signature 'BM'
			writer.Write(GetTotalSize(width, height)); // Size of the file
			writer.WriteZeroBytes(4); // 2 unused shorts
			writer.Write((uint)138); // offset to image data

			//16 bytes
			writer.Write((uint)124); // DIB header size (124 bytes)
			writer.Write(width); // Width
			writer.Write(height); // Height
			writer.Write((ushort)1); // Planes (1)
			writer.Write((ushort)32); // Bits per pixel (32)

			//92 bytes
			writer.WriteBytes(0x03, 0x00, 0x00, 0x00); // Format (bitfield = use bitfields | no compression)
			writer.Write(GetRawImageSize(width, height)); // Image raw size in bytes
			writer.WriteBytes(0x13, 0x0B, 0x00, 0x00); // Horizontal print resolution (2835 = 72dpi * 39.3701)
			writer.WriteBytes(0x13, 0x0B, 0x00, 0x00); // Vertical print resolution (2835 = 72dpi * 39.3701)
			writer.WriteZeroBytes(4); // Colors in palette (none)
			writer.WriteZeroBytes(4); // Important colors (0 = all)
			writer.WriteBytes(0x00, 0x00, 0xFF, 0x00); // R bitmask (00FF0000)
			writer.WriteBytes(0x00, 0xFF, 0x00, 0x00); // G bitmask (0000FF00)
			writer.WriteBytes(0xFF, 0x00, 0x00, 0x00); // B bitmask (000000FF)
			writer.WriteBytes(0x00, 0x00, 0x00, 0xFF); // A bitmask (FF000000)
			writer.WriteBytes(0x42, 0x47, 0x52, 0x73); // sRGB color space
			writer.WriteZeroBytes(12); // Unused R entry for color space
			writer.WriteZeroBytes(12); // Unused G entry for color space
			writer.WriteZeroBytes(12); // Unused B entry for color space
			writer.WriteZeroBytes(4); // Unused Gamma X entry for color space
			writer.WriteZeroBytes(4); // Unused Gamma Y entry for color space
			writer.WriteZeroBytes(4); // Unused Gamma Z entry for color space

			//16 bytes
			writer.WriteZeroBytes(4); // Unknown
			writer.WriteZeroBytes(4); // Unknown
			writer.WriteZeroBytes(4); // Unknown
			writer.WriteZeroBytes(4); // Unknown

			if (flip)
			{
				writer.WriteFlippedY(bgra32Data, width, height);
			}
			else
			{
				writer.Write(bgra32Data.AsSpan());
			}
		}

		private static void WriteFlippedY(this BinaryWriter writer, byte[] data, int width, int height)
		{
			for (int r = height - 1; r >= 0; r--)
			{
				writer.Write(data.AsSpan(r * 4, width * 4));
			}
		}

		private static void WriteBytes(this BinaryWriter writer, byte byte0, byte byte1)
		{
			writer.Write(byte0);
			writer.Write(byte1);
		}

		private static void WriteBytes(this BinaryWriter writer, byte byte0, byte byte1, byte byte2, byte byte3)
		{
			writer.Write(byte0);
			writer.Write(byte1);
			writer.Write(byte2);
			writer.Write(byte3);
		}

		private static void WriteZeroBytes(this BinaryWriter writer, int count)
		{
			for (int i = 0; i < count; i++)
			{
				writer.Write((byte)0);
			}
		}

		private static int GetTotalSize(int width, int height)
		{
			return 14 + 108 + GetRawImageSize(width, height);
		}

		private static int GetRawImageSize(int width, int height)
		{
			return 4 * width * height;
		}
	}
}

```

`AssetRipperLibrary/Utils/DirectBitmap.InternalSaveMethods.cs`:

```cs
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Threading.Tasks;

namespace AssetRipper.Library.Utils
{
	public partial class DirectBitmap
	{
		private bool SaveAsBmp(Stream stream)
		{
			BmpWriter.WriteBmp(Bits, Width, Height, stream);
			return true;
		}

		private async Task SaveAsBmpAsync(Stream stream)
		{
			await Task.Run(() => BmpWriter.WriteBmp(Bits, Width, Height, stream));
		}

		private bool SaveAsGif(Stream stream)
		{
			if (OperatingSystem.IsWindows())
			{
				using Bitmap bitmap = new Bitmap(Width, Height, Stride, PixelFormat.Format32bppArgb, m_bitsHandle.AddrOfPinnedObject());
				bitmap.Save(stream, ImageFormat.Gif);
				return true;
			}
			else
			{
				using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
				image.SaveAsGif(stream);
				return true;
			}
		}

		private async Task SaveAsGifAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsGifAsync(stream);
		}

		private bool SaveAsJpeg(Stream stream)
		{
			if (OperatingSystem.IsWindows())
			{
				using Bitmap bitmap = new Bitmap(Width, Height, Stride, PixelFormat.Format32bppArgb, m_bitsHandle.AddrOfPinnedObject());
				bitmap.Save(stream, ImageFormat.Jpeg);
				return true;
			}
			else
			{
				using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
				image.SaveAsJpeg(stream);
				return true;
			}
		}

		private async Task SaveAsJpegAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsJpegAsync(stream);
		}

		private bool SaveAsPbm(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			image.SaveAsPbm(stream);
			return true;
		}

		private async Task SaveAsPbmAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsPbmAsync(stream);
		}

		private bool SaveAsPng(Stream stream)
		{
			if (OperatingSystem.IsWindows())
			{
				using Bitmap bitmap = new Bitmap(Width, Height, Stride, PixelFormat.Format32bppArgb, m_bitsHandle.AddrOfPinnedObject());
				bitmap.Save(stream, ImageFormat.Png);
				return true;
			}
			else
			{
				using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
				image.SaveAsPng(stream);
				return true;
			}
		}

		private async Task SaveAsPngAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsPngAsync(stream);
		}

		private bool SaveAsTga(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			image.SaveAsTga(stream);
			return true;
		}

		private async Task SaveAsTgaAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsTgaAsync(stream);
		}

		private bool SaveAsTiff(Stream stream)
		{
			if (OperatingSystem.IsWindows())
			{
				using Bitmap bitmap = new Bitmap(Width, Height, Stride, PixelFormat.Format32bppArgb, m_bitsHandle.AddrOfPinnedObject());
				bitmap.Save(stream, ImageFormat.Tiff);
				return true;
			}
			else
			{
				using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
				image.SaveAsTiff(stream);
				return true;
			}
		}

		private async Task SaveAsTiffAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsTiffAsync(stream);
		}

		private bool SaveAsWebp(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			image.SaveAsWebp(stream);
			return true;
		}

		private async Task SaveAsWebpAsync(Stream stream)
		{
			using Image<Bgra32> image = SixLabors.ImageSharp.Image.LoadPixelData<Bgra32>(Bits, Width, Height);
			await image.SaveAsWebpAsync(stream);
		}
	}
}

```

`AssetRipperLibrary/Utils/DirectBitmap.cs`:

```cs
using AssetRipper.Library.Configuration;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading.Tasks;

namespace AssetRipper.Library.Utils
{
	public sealed partial class DirectBitmap : IDisposable
	{
		public int Height { get; }
		public int Width { get; }
		public int Stride => Width * 4;
		public byte[] Bits { get; }
		public IntPtr BitsPtr => m_bitsHandle.AddrOfPinnedObject();

		private readonly GCHandle m_bitsHandle;
		private bool m_disposed;

		/// <summary>
		/// Make a new bitmap
		/// </summary>
		/// <param name="width">The width of the image</param>
		/// <param name="height">The height of the image</param>
		public DirectBitmap(int width, int height) : this(width, height, new byte[width * height * 4]) { }

		/// <summary>
		/// Make a bitmap from existing BGRA32 data
		/// </summary>
		/// <param name="width">The width of the image</param>
		/// <param name="height">The height of the image</param>
		/// <param name="bgra32Data">The image data, 4 bytes per pixel. Will get pinned</param>
		public DirectBitmap(int width, int height, byte[] bgra32Data)
		{
			if(bgra32Data is null)
			{
				throw new ArgumentNullException(nameof(bgra32Data));
			}

			if (bgra32Data.Length != width * height * 4)
			{
				throw new ArgumentException($"Invalid length: expected {width * height * 4} but was actually {bgra32Data.Length}", nameof(bgra32Data));
			}

			Width = width;
			Height = height;
			Bits = bgra32Data;
			m_bitsHandle = GCHandle.Alloc(Bits, GCHandleType.Pinned);
		}

		public unsafe void FlipY()
		{
			uint* top = (uint*)BitsPtr;
			for (int row = 0, irow = Height - 1; row < irow; row++, irow--)
			{
				uint* bottom = (uint*)(BitsPtr + irow * Stride);
				for (int i = 0; i < Width; i++, bottom++, top++)
				{
					uint pixel = *bottom;
					*bottom = *top;
					*top = pixel;
				}
			}
		}

		public bool Save(Stream stream, ImageExportFormat format)
		{
			return format switch
			{
				ImageExportFormat.Bmp => SaveAsBmp(stream),
				ImageExportFormat.Gif => SaveAsGif(stream),
				ImageExportFormat.Jpeg => SaveAsJpeg(stream),
				ImageExportFormat.Pbm => SaveAsPbm(stream),
				ImageExportFormat.Png => SaveAsPng(stream),
				ImageExportFormat.Tga => SaveAsTga(stream),
				ImageExportFormat.Tiff => SaveAsTiff(stream),
				ImageExportFormat.Webp => SaveAsWebp(stream),
				_ => throw new ArgumentOutOfRangeException(nameof(format)),
			};
		}

		public bool Save(string path, ImageExportFormat format)
		{
			using FileStream stream = File.Create(path);
			return Save(stream, format);
		}

		public async Task SaveAsync(Stream stream, ImageExportFormat format)
		{
			switch (format)
			{
				case ImageExportFormat.Bmp:
					await SaveAsBmpAsync(stream);
					break;
				case ImageExportFormat.Gif:
					await SaveAsGifAsync(stream);
					break;
				case ImageExportFormat.Jpeg:
					await SaveAsJpegAsync(stream);
					break;
				case ImageExportFormat.Pbm:
					await SaveAsPbmAsync(stream);
					break;
				case ImageExportFormat.Png:
					await SaveAsPngAsync(stream);
					break;
				case ImageExportFormat.Tga:
					await SaveAsTgaAsync(stream);
					break;
				case ImageExportFormat.Tiff:
					await SaveAsTiffAsync(stream);
					break;
				case ImageExportFormat.Webp:
					await SaveAsWebpAsync(stream);
					break;
				default:
					throw new ArgumentOutOfRangeException(nameof(format));
			}
		}

		public async Task SaveAsync(string path, ImageExportFormat format)
		{
			using FileStream stream = File.Create(path);
			await SaveAsync(stream, format);
		}

		public void Dispose()
		{
			GC.SuppressFinalize(this);
			Dispose(true);
		}

		private void Dispose(bool _)
		{
			if (!m_disposed)
			{
				m_bitsHandle.Free();
				m_disposed = true;
			}
		}

		~DirectBitmap()
		{
			Dispose(false);
		}
	}
}

```

`AssetRipperLibrary/Utils/DumpInfo.cs`:

```cs
using AssetRipper.Core;
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files.ArchiveFiles;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser;
using AssetRipper.Core.Parser.Files.SerializedFiles.Parser.TypeTree;
using AssetRipper.Core.Parser.Files.WebFiles;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_116;
using AssetRipper.SourceGenerated.Classes.ClassID_141;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using ShaderTextRestorer.Extensions;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AssetRipper.Library.Utils
{
	public class DumpInfo
	{
		public static void DumpAllFileInfo(string gameDir, string exportPath)
		{
			Util.PrepareExportDirectory(exportPath);
			foreach (string file in AllFilesInFolder(gameDir))
			{
				string ext = Path.GetExtension(file);
				if (ext != "" && ext != ".assets" && ext != ".unity3d" && ext != ".bundle")
				{
					continue;
				}

				string relPath = Util.GetRelativePath(file, gameDir);
				relPath = Path.GetDirectoryName(relPath);
				if (Directory.Exists(file))
				{

				}
				DumpFile(file, Path.Combine(exportPath, relPath));
			}
		}
		static void DumpFileInfo(SerializedFile container, string exportPath)
		{
			Console.WriteLine($"Dumping container {container.Name }");
			Directory.CreateDirectory(Path.GetDirectoryName(exportPath));
			using StreamWriter sw = new($"{exportPath}.txt");
			WriteFileInfo(container, sw);
			sw.WriteLine("");
			DumpObjectInfo(container, sw);
			if (container.Name == "globalgamemanagers")
			{
				IBuildSettings? buildSettings = (IBuildSettings?)container.FetchAssets().FirstOrDefault(asset => asset is IBuildSettings);
				if (buildSettings != null)
				{
					sw.WriteLine("");
					DumpBuildSettings(buildSettings, sw);
				}
				IMonoManager? monoManager = (IMonoManager?)container.FetchAssets().FirstOrDefault(asset => asset is IMonoManager);
				if (monoManager != null)
				{
					sw.WriteLine("");
					DumpMonoManager(monoManager, sw);
				}
			}
		}
		static void DumpFileListInfo(FileList fileList, string exportPath)
		{
			Console.WriteLine($"Dumping FileList {Path.GetFileName(exportPath)}");
			Directory.CreateDirectory(Path.GetDirectoryName(exportPath));
			using StreamWriter sw = new($"{exportPath}.txt");
			if (fileList is BundleFile bf)
			{
				DumpBundleFileInfo(bf, sw);
			}
			if (fileList is ArchiveFile af)
			{
				//TODO
				sw.WriteLine($"ArchiveFile");
			}
			if (fileList is WebFile wf)
			{
				//TODO
				sw.WriteLine($"WebFile");
			}
			sw.WriteLine($"ResourceFile count {fileList.ResourceFiles.Count}");
			foreach (ResourceFile resourceFile in fileList.ResourceFiles)
			{
				sw.WriteLine($"ResourceFile: Name {resourceFile.Name}");
			}
			sw.WriteLine($"");
			sw.WriteLine($"SerializedFile count {fileList.SerializedFiles.Count}");
			foreach (SerializedFile serializedFile in fileList.SerializedFiles)
			{
				sw.WriteLine("");
				WriteFileInfo(serializedFile, sw);
				sw.WriteLine("");
				DumpObjectInfo(serializedFile, sw);
			}
		}
		static void DumpBundleFileInfo(BundleFile bundleFile, StreamWriter sw)
		{
			sw.WriteLine("BundleFile");
			Core.Parser.Files.BundleFile.Parser.BundleMetadata metadata = bundleFile.Metadata;
			Core.Parser.Files.BundleFile.Header.BundleHeader header = bundleFile.Header;
			sw.WriteLine("  TODO");
		}
		static void DumpObjectInfo(SerializedFile file, StreamWriter sw)
		{
			sw.WriteLine("{0,-40}, {1,30}, {2,-32}, {3}, {4}, {5}, {6}",
				"Name", "ClassID", "GUID", "FileIndex", "PathID", "IsValid", "Extra");
			Dictionary<long, Core.Interfaces.IUnityObjectBase> lookup = file.FetchAssets().ToDictionary(a => a.PathID, a => a);
			foreach (Core.Interfaces.IUnityObjectBase asset in file.FetchAssets())
			{
				string name = Util.GetName(asset);
				PPtr<Core.Interfaces.IUnityObjectBase> pptr = asset.SerializedFile.CreatePPtr(asset);
				string extra = "";
				if (asset is IMonoScript ms)
				{
					string scriptName = $"[{ms.GetAssemblyNameFixed()}]";
					if (!string.IsNullOrEmpty(ms.Namespace_C115.String))
					{
						scriptName += $"{ms.Namespace_C115.String}.";
					}

					scriptName += $"{ms.ClassName_C115.String}:{HashToString(ms.GetPropertiesHash())}";
					extra = scriptName;
				}
				if (asset is IShader shader)
				{
					if (shader.Has_CompressedBlob_C48())
					{
						IEnumerable<Core.Classes.Shader.Enums.GpuProgramType.ShaderGpuProgramType> programTypes = shader.ReadBlobs()
							.SelectMany(b => b.SubPrograms)
							.Select(sp => sp.GetProgramType(file.Version))
							.Distinct();
						extra += string.Format("Platforms: {0} ProgramTypes: {1}",
							string.Join(", ", shader.Platforms_C48 ?? Array.Empty<uint>()),
							string.Join(", ", programTypes));
					}
					else
					{
						extra += "Platforms: Text";
					}

				}
				sw.WriteLine($"{name,-40}, {asset.ClassID,30}, {asset.GUID}, {pptr.FileIndex,9}, {asset.PathID,6}, {extra}");
			}
			sw.WriteLine();
			sw.WriteLine("Cannot parse");
			sw.WriteLine("{0,-6}, {1,-40}, {2,-6}, {3,-15}, {4,-8}, {5,-11}, {6,-9}, {7,-8}",
	"FileID", "ClassID", "TypeID", "ScriptTypeIndex", "Stripped", "IsDestroyed", "ByteStart", "ByteSize");
			foreach (Core.Parser.Files.SerializedFiles.Parser.ObjectInfo info in file.Metadata.Object)
			{
				if (lookup.ContainsKey(info.FileID))
				{
					continue;
				}

				sw.WriteLine($"{info.FileID,-6}, {info.ClassID,-40}, {info.TypeID,-6}, {info.ScriptTypeIndex,-15}, {info.Stripped,-8}, {info.IsDestroyed,-11}, {info.ByteStart,-9}, {info.ByteSize,-8}");
			}
		}
		static void UnknownFileType(object file, string filepath, string exportPath)
		{
			Console.WriteLine($"Unknown file {filepath}({file.GetType().Name })");
			Directory.CreateDirectory(Path.GetDirectoryName(exportPath));
			using StreamWriter sw = new StreamWriter($"{exportPath}.err.txt");
			sw.WriteLine($"Can't dump file {file.GetType().FullName}");
		}
		public static List<string> AllFilesInFolder(string folder)
		{
			List<string> result = new List<string>();

			foreach (string f in Directory.GetFiles(folder))
			{
				result.Add(f);
			}

			foreach (string d in Directory.GetDirectories(folder))
			{
				result.AddRange(AllFilesInFolder(d));
			}
			return result;
		}
		static void WriteFileInfo(SerializedFile container, StreamWriter sw)
		{
			sw.WriteLine($"  File: {container.Name}");
			sw.WriteLine($"	File.Collection: {container.Collection}");
			sw.WriteLine($"	File.Platform: {container.Platform}");
			sw.WriteLine($"	File.Version: {container.Version}");
			foreach (Core.Parser.Files.SerializedFiles.Parser.FileIdentifier dep in container.Dependencies)
			{
				sw.WriteLine($"	File.Dependency: {dep}");
				sw.WriteLine($"	  Dependency.AssetPath: {dep.AssetPath}");
			}
			if (container.Metadata != null)
			{
				//TODO container.Metadata.Hierarchy
				bool SerializeTypeTrees = container.Metadata.EnableTypeTree;
				SerializedType[] Types = container.Metadata.Types;
				UnityVersion Version = container.Metadata.UnityVersion;
				Core.Parser.Files.BuildTarget Platform = container.Metadata.TargetPlatform;
				sw.WriteLine($"	File.Metadata.Hierarchy:");
				sw.WriteLine($"		Hierarchy.Version: {Version}");
				sw.WriteLine($"		Hierarchy.Platform: {Platform}");
				sw.WriteLine($"		Hierarchy.SerializeTypeTrees: {SerializeTypeTrees}");
				sw.WriteLine($"		Hierarchy.Types: {Types.Length}");
				if (Types.Length > 0)
				{
					sw.WriteLine("			{0,-18}, {1}, {2}, {3,-32}, {4,-32}, {5}",
						"ClassId", "IsStrippedType", "ScriptID", "ScriptHash", "TypeHash", "NodeCount");
				}
				foreach (SerializedType type in Types)
				{
					ClassIDType ClassID = type.TypeID;
					bool IsStrippedType = type.IsStrippedType;
					short ScriptID = type.ScriptTypeIndex;
					TypeTree Tree = type.OldType;
					Hash128 ScriptHash = type.ScriptID;
					Hash128 TypeHash = type.OldTypeHash;
					string nodeCount = Tree == null ? "Null" : Tree.Nodes.Count.ToString();
					sw.WriteLine("			{0,-18}, {1,14}, {2,8}, {3}, {4}, {5}",
						ClassID.ToString(), IsStrippedType, ScriptID, HashToString(ScriptHash), HashToString(TypeHash), nodeCount);
				}
			}
			else
			{
				sw.WriteLine($"	File.Metadata.Hierarchy: Null");
			}
			//TODO container.Metadata.Entries
			/*sw.WriteLine($"	File.Metadata.Entries: {container.Metadata.Entries.Length}");

			var factory = new AssetFactory();
			foreach (var entry in container.Metadata.Entries)
			{
				AssetInfo assetInfo = new AssetInfo(container, entry.PathID, entry.ClassID);
				Object asset = factory.CreateAsset(assetInfo);
				if (asset == null)
				{
					sw.WriteLine($"	  Unimplemented Asset: {entry.ClassID}, {entry.ScriptID}, {entry.TypeID}, {entry.PathID}, {entry.IsStripped}");
				}
			}*/
		}
		public static string HashToString(Hash128 hash)
		{
			byte[] data = BitConverter.GetBytes(hash.Data0)
				.Concat(BitConverter.GetBytes(hash.Data1))
				.Concat(BitConverter.GetBytes(hash.Data2))
				.Concat(BitConverter.GetBytes(hash.Data3))
				.ToArray();
			return BitConverter.ToString(data).Replace("-", "");
		}
		public static void DumpBuildSettings(IBuildSettings buildSettings, StreamWriter sw)
		{
			sw.WriteLine("BuildSettings");
			/*sw.WriteLine($"  Version: {buildSettings.Version_C141}");
			sw.WriteLine($"  Scenes {buildSettings.Scenes_C141.Length}");
			for (int i = 0; i < buildSettings.Scenes_C141.Length; i++)
			{
				string scene = buildSettings.Scenes_C141[i].String;
				sw.WriteLine($"	{i}: {scene}");
			}
			sw.WriteLine($"  PreloadedPlugins {buildSettings.PreloadedPlugins_C141}");
			for (int i = 0; i < buildSettings.PreloadedPlugins_C141.Length; i++)
			{
				string? preloadedPlugin = buildSettings.PreloadedPlugins_C141?[i].String;
				sw.WriteLine($"	{i}: {preloadedPlugin}");
			}
			sw.WriteLine($"  BuildTags {buildSettings.BuildTags_C141.Length}");
			for (int i = 0; i < buildSettings.BuildTags_C141.Length; i++)
			{
				string? buildTag = buildSettings.BuildTags_C141?[i].String;
				sw.WriteLine($"	{i}: {buildTag}");
			}
			sw.WriteLine($"  RuntimeClassHashes {buildSettings.RuntimeClassHashes.Count}");
			foreach (KeyValuePair<int, Hash128> kv in buildSettings.RuntimeClassHashes.OrderBy(kv => kv.Key))
			{
				sw.WriteLine($"	{kv.Key}: {HashToString(kv.Value)}");
			}
			sw.WriteLine($"  ScriptHashes {buildSettings.ScriptHashes.Count}");
			foreach (KeyValuePair<Hash128, Hash128> kv in buildSettings.ScriptHashes)
			{
				sw.WriteLine($"	{HashToString(kv.Key)}: {HashToString(kv.Value)}");
			}*/
		}
		public static void DumpMonoManager(IMonoManager monoManager, StreamWriter sw)
		{
			sw.WriteLine("MonoManager");
			/*sw.WriteLine($"  HasCompileErrors {monoManager.HasCompileErrors}");
			sw.WriteLine($"  EngineDllModDate {monoManager.EngineDllModDate}");
			sw.WriteLine($"  CustomDlls {monoManager.CustomDlls?.Length}");
			foreach (string dll in monoManager.CustomDlls ?? Array.Empty<string>())
			{
				sw.WriteLine($"    {dll}");
			}
			sw.WriteLine($"  AssemblyIdentifiers {monoManager.AssemblyIdentifiers?.Length}");
			foreach (string dll in monoManager.AssemblyIdentifiers ?? Array.Empty<string>())
			{
				sw.WriteLine($"    {dll}");
			}
			sw.WriteLine($"  AssemblyNames {monoManager.AssemblyNames?.Length}");
			foreach (string dll in monoManager.AssemblyNames ?? Array.Empty<string>())
			{
				sw.WriteLine($"    {dll}");
			}
			sw.WriteLine($"  AssemblyTypes {monoManager.AssemblyTypes?.Length}");
			foreach (int dll in monoManager.AssemblyTypes ?? Array.Empty<int>())
			{
				sw.WriteLine($"    {dll}");
			}
			sw.WriteLine($"  Scripts {monoManager.Scripts.Length}");
			foreach (PPtr<IMonoScript> dll in monoManager.Scripts ?? Array.Empty<PPtr<IMonoScript>>())
			{
				sw.WriteLine($"    {dll}");
			}*/
		}
		static void DumpFile(string filepath, string exportPath)
		{
			string filename = Path.GetFileName(filepath);
			try
			{
				object file = Util.LoadFile(filepath);
				if (file is SerializedFile serializedFile)
				{
					DumpFileInfo(serializedFile, Path.Combine(exportPath, filename));
				}
				if (file is BundleFile bundleFile)
				{
					DumpFileListInfo(bundleFile, Path.Combine(exportPath, filename));
				}
				if (file is ArchiveFile archiveFile)
				{
					DumpFileListInfo(archiveFile, Path.Combine(exportPath, filename));
				}
				if (file is WebFile webfile)
				{
					DumpFileListInfo(webfile, Path.Combine(exportPath, filename));
				}
				if (file is ResourceFile resourceFile)
				{
					UnknownFileType(resourceFile, filepath, Path.Combine(exportPath, filename));
				}
			}
			catch (Exception ex)
			{
				string errMessage = $"Error dumping file {filepath}\n{ex.ToString()}";
				Logger.Log(LogType.Error, LogCategory.General, errMessage);
				Directory.CreateDirectory(exportPath);
				File.WriteAllText($"{exportPath}/{filename}.err.txt", errMessage);
			}
		}
		public static void DumpTypeTree(string filePath, string exportPath)
		{
			Directory.CreateDirectory(Path.GetDirectoryName(exportPath));
			object file = Util.LoadFile(filePath);
			List<SerializedFile> seralizedFiles = new List<SerializedFile>();
			if (file is SerializedFile sf)
			{
				seralizedFiles.Add(sf);
			}
			else if (file is BundleFile bundleFile)
			{
				seralizedFiles.AddRange(bundleFile.SerializedFiles);
			}
			else
			{
				throw new Exception();
			}
			using StreamWriter sw = new StreamWriter(exportPath);
			foreach (SerializedFile serializedFile in seralizedFiles)
			{
				DumpTypeInfo(serializedFile, sw);
			}
		}

		internal static void DumpTypeInfo(SerializedFile serializedFile, StreamWriter sw)
		{
			foreach (Core.Interfaces.IUnityObjectBase asset in serializedFile.FetchAssets().Where(asset => asset is IMonoScript))
			{
				IMonoScript monoScript = (IMonoScript)asset;
				sw.WriteLine($"\t[{monoScript.GetAssemblyNameFixed()}]{monoScript.Namespace_C115}.{monoScript.ClassName_C115} - {HashToString(monoScript.GetPropertiesHash())}");

			}
			sw.WriteLine($"SerializedFile");
			sw.WriteLine($"Name {serializedFile.Name}");
			sw.WriteLine($"NameOrigin {serializedFile.NameOrigin}");
			sw.WriteLine($"Platform {serializedFile.Platform}");
			sw.WriteLine($"Version {serializedFile.Version}");

			sw.WriteLine($"Preloads:");
			foreach (FileIdentifier ptr in serializedFile.Metadata.Externals)
			{
				sw.WriteLine($"\t{ptr}");
			}
			Core.Parser.Files.SerializedFiles.Parser.SerializedFileMetadata hierarchy = serializedFile.Metadata;
			sw.WriteLine($"TypeTree Version {hierarchy.UnityVersion}");
			sw.WriteLine($"TypeTree Platform {hierarchy.TargetPlatform}");
			bool SerializeTypeTrees = hierarchy.EnableTypeTree;
			sw.WriteLine($"TypeTree SerializeTypeTrees {SerializeTypeTrees}");
			sw.WriteLine($"");
			foreach (SerializedType type in hierarchy.Types)
			{
				ClassIDType ClassID = type.TypeID;
				short ScriptID = type.ScriptTypeIndex;
				bool IsStrippedType = type.IsStrippedType;
				TypeTree Tree = type.OldType;
				Hash128 ScriptHash = type.ScriptID;
				Hash128 TypeHash = type.OldTypeHash;

				IMonoScript? monoScript = serializedFile.FetchAssets().FirstOrDefault(asset => asset is IMonoScript ms && ms.GetPropertiesHash() == TypeHash) as IMonoScript;
				string scriptType = monoScript == null ? "\tNo Script" : $"\tMonoScript is [{monoScript.GetAssemblyNameFixed()}]{monoScript.Namespace_C115}.{monoScript.ClassName_C115}";
				sw.WriteLine(scriptType);
				sw.WriteLine($"\tType: ClassID {ClassID}, ScriptID {ScriptID}, IsStrippedType {IsStrippedType}, ScriptHash {HashToString(ScriptHash)}, TypeHash {HashToString(TypeHash)}");
				string Dump = Tree.Dump;
				sw.WriteLine($"\t{Dump}");
				sw.WriteLine($"");
			}
			sw.WriteLine($"");
		}
	}
}

```

`AssetRipperLibrary/Utils/Util.cs`:

```cs
using AssetRipper.Core.Classes.Misc;
using AssetRipper.Core.Interfaces;
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Logging;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.Parser.Files.ArchiveFiles;
using AssetRipper.Core.Parser.Files.BundleFile;
using AssetRipper.Core.Parser.Files.Entries;
using AssetRipper.Core.Parser.Files.ResourceFiles;
using AssetRipper.Core.Parser.Files.Schemes;
using AssetRipper.Core.Parser.Files.SerializedFiles;
using AssetRipper.Core.Parser.Files.WebFiles;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.Core.Structure;
using AssetRipper.SourceGenerated.Classes.ClassID_114;
using AssetRipper.SourceGenerated.Classes.ClassID_115;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.SourceGenerated.Interfaces;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Security.Cryptography;
using System.Text;
using System.Threading;
using YamlDotNet.RepresentationModel;

namespace AssetRipper.Library.Utils
{
	/// <summary>
	/// Needs removed at some point
	/// </summary>
	internal class Util
	{
		public static BindingFlags AllBindingFlags = BindingFlags.Instance
			| BindingFlags.Static
			| BindingFlags.Public
			| BindingFlags.NonPublic
			| BindingFlags.GetField
			| BindingFlags.SetField
			| BindingFlags.GetProperty
			| BindingFlags.SetProperty;
		public static void PrepareExportDirectory(string path)
		{
			DeleteDirectory(path);
		}
		public static void DeleteDirectory(string path)
		{
			if (!Directory.Exists(path))
			{
				return;
			}

			foreach (string directory in Directory.GetDirectories(path))
			{
				Thread.Sleep(1);
				DeleteDir(directory);
			}
			DeleteDir(path);
		}

		private static void DeleteDir(string dir)
		{
			try
			{
				Thread.Sleep(1);
				Directory.Delete(dir, true);
			}
			catch (IOException)
			{
				DeleteDir(dir);
			}
			catch (UnauthorizedAccessException)
			{
				DeleteDir(dir);
			}
		}
		public static string HashBytes(byte[] inputBytes)
		{
			using MD5 md5 = MD5.Create();
			byte[] hashBytes = md5.ComputeHash(inputBytes);
			StringBuilder sb = new StringBuilder();
			for (int i = 0; i < hashBytes.Length; i++)
			{
				sb.Append(hashBytes[i].ToString("X2"));
			}
			return sb.ToString();
		}
		public static string GetRelativePath(string filePath, string folder)
		{
			Uri pathUri = new Uri(filePath);
			if (!folder.EndsWith(Path.DirectorySeparatorChar.ToString()))
			{
				folder += Path.DirectorySeparatorChar;
			}
			Uri folderUri = new Uri(folder);
			return Uri.UnescapeDataString(folderUri.MakeRelativeUri(pathUri).ToString().Replace('/', Path.DirectorySeparatorChar));
		}
		public static string NormalizePath(string path)
		{
			return Path.GetFullPath(new Uri(path).LocalPath)
						.TrimEnd(Path.DirectorySeparatorChar, Path.AltDirectorySeparatorChar)
						.ToUpperInvariant();
		}
		public static ISerializedFile FindFile(GameCollection fileCollection, string path)
		{
			return fileCollection.GameFiles.Values.First(f => f is SerializedFile sf && NormalizePath(sf.FilePath) == NormalizePath(path));
		}
		public static IEnumerable<SerializedFile> GetSerializedFiles(GameCollection fileCollection)
		{
			return fileCollection.GameFiles.Values;
		}
		public static void ReplaceInFile(string filePath, string source, string replacement)
		{
			if (!File.Exists(filePath))
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Could not perform line replace on {filePath}, file does not exist");
				return;
			}
			string? text = File.ReadAllText(filePath);
			text = text.Replace(source, replacement);
			File.WriteAllText(filePath, text);
		}
		public static void InsertInFile(string filePath, int index, string replacement)
		{
			if (!File.Exists(filePath))
			{
				Logger.Log(LogType.Warning, LogCategory.Export, $"Could not perform line insert on {filePath}, file does not exist");
				return;
			}
			List<string>? lines = File.ReadAllLines(filePath).ToList();
			lines.Insert(index, replacement);
			File.WriteAllLines(filePath, lines);
		}

		public static List<string> GetManifestDependencies(string filePath)
		{
			YamlStream? yaml = new YamlStream();
			YamlMappingNode? mapping = null;
			using (StreamReader? fs = File.OpenText(filePath))
			{
				yaml.Load(fs);
				mapping = (YamlMappingNode)yaml.Documents[0].RootNode;
			}
			YamlSequenceNode? dependencies = (YamlSequenceNode)mapping.Children[new YamlScalarNode("Dependencies")];
			List<string> results = dependencies
				.Select(node => Path.GetFileName(((YamlScalarNode)node).Value ?? ""))
				.ToList();
			return results;
		}

		internal static List<string> GetManifestAssets(string filePath)
		{
			List<string>? lines = File.ReadAllLines(filePath).ToList();
			bool isAtDependencies = false;
			List<string>? results = new List<string>();
			foreach (string? line in lines)
			{
				if (isAtDependencies)
				{
					if (line.StartsWith("- "))
					{
						string? dep = line.Replace("- ", "");
						results.Add(Path.GetFileName(dep));
					}
					else
					{
						break;
					}
				}
				else
				{
					if (line.StartsWith("Assets:"))
					{
						isAtDependencies = true;
					}
				}
			}
			return results;
		}
		public static string FormatTime(TimeSpan obj)
		{
			StringBuilder sb = new StringBuilder();
			if (obj.Hours != 0)
			{
				sb.Append(obj.Hours);
				sb.Append(" ");
				sb.Append("hours");
				sb.Append(" ");
			}
			if (obj.Minutes != 0 || sb.Length != 0)
			{
				sb.Append(obj.Minutes);
				sb.Append(" ");
				sb.Append("minutes");
				sb.Append(" ");
			}
			if (obj.Seconds != 0 || sb.Length != 0)
			{
				sb.Append(obj.Seconds);
				sb.Append(" ");
				sb.Append("seconds");
				sb.Append(" ");
			}
			if (obj.Milliseconds != 0 || sb.Length != 0)
			{
				sb.Append(obj.Milliseconds);
				sb.Append(" ");
				sb.Append("Milliseconds");
				sb.Append(" ");
			}
			if (sb.Length == 0)
			{
				sb.Append(0);
				sb.Append(" ");
				sb.Append("Milliseconds");
			}
			return sb.ToString();
		}

		public static void FixShaderBundle(GameCollection fileCollection)
		{
			SerializedFile? shaderBundle = fileCollection.GameFiles.Values.FirstOrDefault(f => f is SerializedFile sf && Path.GetFileName(sf.FilePath) == "shaders");
			if (shaderBundle != null)
			{
				foreach (IUnityObjectBase? asset in shaderBundle.FetchAssets())
				{
					if (asset is IShader shader)
					{
						using MD5 md5 = MD5.Create();
						byte[] md5Hash = md5.ComputeHash(shader.Name.Data);
						asset.GUID = new UnityGUID(md5Hash);
					}
				}
			}
		}
		public static string GetName(IUnityObjectBase asset)
		{
			if (asset is IHasName no)
			{
				return no.GetNameNotEmpty();
			}
			if (asset is IMonoBehaviour mb && mb.IsScriptableObject())
			{
				return mb.NameString;
			}
			return "Unnamed";
		}
		public static void FixScript(IMonoScript script)
		{
			using MD5 md5 = MD5.Create();
			string fullName = $"{script.GetAssemblyNameFixed()}.{script.Namespace_C115}.{script.ClassName_C115}";
			byte[] data = md5.ComputeHash(Encoding.UTF8.GetBytes(fullName));
			SetGUID(script, data);
		}
		public static void SetGUID(IUnityObjectBase asset, byte[] guid)
		{
			byte[]? swapped = new byte[guid.Length];
			for (int i = 0; i < guid.Length; i++)
			{
				byte x = guid[i];
				swapped[i] = (byte)((x & 0x0F) << 4 | (x & 0xF0) >> 4);
			}
			asset.GUID = new UnityGUID(swapped);
		}
		static T CreateInstance<T>(params object[] parameters)
		{
			object instance = typeof(T)
				.GetConstructors(AllBindingFlags)
				.Single(c => c.GetParameters().Length == parameters.Length)
				.Invoke(parameters);
			return (T)instance;
		}
		public static GameCollection CreateGameCollection()
		{
			LayoutInfo? layoutInfo = new LayoutInfo(new UnityVersion(), BuildTarget.StandaloneWin64Player, TransferInstructionFlags.NoTransferInstructionFlags);
			GameCollection? gameCollection = new GameCollection(layoutInfo);
			return gameCollection;
		}
		public static object LoadFile(string filepath)
		{
			FileScheme? scheme = SchemeReader.LoadScheme(filepath, Path.GetFileName(filepath));
			object file = LoadScheme(scheme);
			scheme.Dispose();
			return file;
		}
		private static void AddScheme(FileList fileList, FileSchemeList list)
		{
			foreach (FileScheme? scheme in list.Schemes)
			{
				AddScheme(fileList, scheme);
			}
		}
		private static void AddScheme(FileList fileList, FileScheme scheme)
		{
			object? file = LoadScheme(scheme);
			switch (scheme.SchemeType)
			{
				case FileEntryType.Serialized:
					fileList.AddSerializedFile((SerializedFile)file);
					break;
				case FileEntryType.Bundle:
				case FileEntryType.Archive:
				case FileEntryType.Web:
					fileList.AddSerializedFile((SerializedFile)file);
					break;
				case FileEntryType.Resource:
					fileList.AddResourceFile((ResourceFile)file);
					break;
			}
		}
		private static object LoadScheme(FileScheme scheme)
		{
			object? file = null;
			if (scheme is SerializedFileScheme serializedFileScheme)
			{
				BuildTarget platform = serializedFileScheme.Metadata != null &&
					serializedFileScheme.Metadata.TargetPlatform != 0 ?
					serializedFileScheme.Metadata.TargetPlatform
					: BuildTarget.StandaloneWin64Player;
				UnityVersion version = serializedFileScheme.Metadata != null ?
					serializedFileScheme.Metadata.UnityVersion
					: new UnityVersion();
				LayoutInfo? layoutInfo = new LayoutInfo(version, platform, serializedFileScheme.Flags);
				GameCollection? collection = new GameCollection(layoutInfo);
				collection.AssemblyManager = new Core.Structure.Assembly.Managers.BaseManager(layoutInfo, new Action<string>(str => str.GetType()));
				file = CreateInstance<SerializedFile>(collection, scheme);
				typeof(SerializedFile).GetMethod("ReadData", AllBindingFlags)?
					.Invoke(file, new object[] { serializedFileScheme.Stream });
			}
			if (scheme is BundleFileScheme bundleFileScheme)
			{
				file = CreateInstance<BundleFile>(scheme);
				AddScheme((BundleFile)file, bundleFileScheme);
			}
			if (scheme is ArchiveFileScheme archiveFileScheme)
			{
				file = CreateInstance<ArchiveFile>(scheme);
				AddScheme((ArchiveFile)file, archiveFileScheme);
			}
			if (scheme is WebFileScheme webFileScheme)
			{
				file = CreateInstance<WebFile>(scheme);
				AddScheme((WebFile)file, webFileScheme);
			}
			if (scheme is ResourceFileScheme resourceFileScheme)
			{
				file = CreateInstance<ResourceFile>(scheme);
			}
			return file ?? throw new Exception();
		}
	}
}

```

`CONTRIBUTING.md`:

```md
# Contributing to AssetRipper

## First Time Contributors

You can find a list of "good first issues" [here](https://github.com/AssetRipper/AssetRipper/contribute). These issues are selected for their relative approachability to first-time contributors.


## Pull Requests
I welcome contributions to AssetRipper and have accepted many patches, but if you want your code to be included, please familiarize yourself with the following guidelines:
* Your submission must be your own work, and able to be released under the GPL license.
* You will need to make sure your code conforms to the layout and naming conventions used elsewhere in AssetRipper.
* Try to write "clean code" - avoid long functions and long classes. Try to add a new feature by creating a new class rather than putting loads of extra code inside an existing one.
* If you are adding a new feature, please consider writing a short tutorial on how to use it.
* Unless your patch is a small bugfix, I will code review it and give you feedback. You will need to be willing to make the recommended changes before it can be integrated into the main code.
* Patches should be provided using the Pull Request feature of GitHub.


## Localizations

AssetRipper has a built-in localization system, so that people can use it in their native language/dialect if localized text has been contributed. 

A web platform has been integrated to make contributing as easy as possible. You can get started [here](http://weblate.samboy.dev/engage/assetripper/).

You'll need to sign up to start translating to a new localization, or you can suggest translations for an existing localization without an account (but someone with an account will have to manually verify your suggestions). This will send an email to the address you entered. Be sure to check your spam folder, as Gmail sometimes redirects the email there.


## Issues

Posting well-written issues is an excellent way to report bugs and share ideas about how AssetRipper can be improved.

Before posting an issue, make sure it hasn't already been addressed in the [previously posted issues](https://github.com/AssetRipper/AssetRipper/issues?q=is%3Aissue).

If posting a bug report, please be sure to include your log file. It is in the same folder as the `exe` file and will be called `AssetRipper.log`.
```

`LICENSE.md`:

```md
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.
```

`Licenses/AsmResolver.md`:

```md
The MIT License (MIT)
=====================

Copyright © `2016-2021 Washi`

Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the “Software”), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
```

`Licenses/AssetStudio.md`:

```md
MIT License

Copyright (c) 2016 Radu
Copyright (c) 2016-2020 Perfare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/Avalonia.md`:

```md
The MIT License (MIT)

Copyright (c) .NET Foundation and Contributors All Rights Reserved

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Licenses/Brotli.md`:

```md
Copyright (c) 2009, 2010, 2013-2016 by the Brotli Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`Licenses/CommandLineParser.md`:

```md
The MIT License (MIT)

Copyright (c) 2005 - 2015 Giacomo Stelluti Scala & Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

`Licenses/Cpp2IL.md`:

```md
MIT License

Copyright (c) 2020 Sam Byass

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/Crunch.md`:

```md
Original crunch/crnlib source code
crunch/crnlib uses the ZLIB license:
http://opensource.org/licenses/Zlib

Copyright (c) 2010-2016 Richard Geldreich, Jr. and Binomial LLC

This software is provided 'as-is', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not
claim that you wrote the original software. If you use this software
in a product, an acknowledgment in the product documentation would be
appreciated but is not required.

2. Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

3. This notice may not be removed or altered from any source distribution.

Further crunch/crnlib modifications
MIT License

Copyright (c) 2019 Perfare

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/Fmod5Sharp.md`:

```md
MIT License

Copyright (c) 2021 Sam Byass

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/ILSpy.md`:

```md
MIT License

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/ImageSharp.md`:

```md
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright (c) Six Labors

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

`Licenses/LibVLCSharp.md`:

```md
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
    USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random
  Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
```

`Licenses/Lz4.md`:

```md
MIT License

Copyright (c) 2017 Milosz Krajewski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/MeshSharp.md`:

```md
MIT License

Copyright (c) 2021 ds5678

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/MessageBoxAvalonia.md`:

```md
  MIT License

Copyright (c) 2019 CreateLab

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/MonoCecil.md`:

```md
Copyright (c) 2008 - 2015 Jb Evain
Copyright (c) 2008 - 2011 Novell, Inc.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`Licenses/NAudio.md`:

```md
Copyright 2020 Mark Heath

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


```

`Licenses/NAudioLame.md`:

```md
The MIT License (MIT)

Copyright (c) 2013-2019 Corey Murtagh

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

`Licenses/NAudioVorbis.md`:

```md
MIT License

Copyright (c) 2021 Andrew Ward

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/NVorbis.md`:

```md
MIT License

Copyright (c) 2020 Andrew Ward

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/SharpCompress.md`:

```md
The MIT License (MIT)

Copyright (c) 2014  Adam Hathcock

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
```

`Licenses/SharpGLTF.md`:

```md
MIT License

Copyright (c) 2019 Vicente Penades

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/SharpZipLib.md`:

```md
Copyright © 2000-2018 SharpZipLib Contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of this
software and associated documentation files (the "Software"), to deal in the Software
without restriction, including without limitation the rights to use, copy, modify, merge,
publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons
to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or
substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE
FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
```

`Licenses/Smolv.md`:

```md
------------------------------------------------------------------------------
This software is available under 2 licenses -- choose whichever you prefer.
------------------------------------------------------------------------------
ALTERNATIVE A - MIT License
Copyright (c) 2016-2018 Aras Pranckevicius
Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
------------------------------------------------------------------------------
ALTERNATIVE B - Public Domain (www.unlicense.org)
This is free and unencumbered software released into the public domain.
Anyone is free to copy, modify, publish, use, compile, sell, or distribute this
software, either in source code form or as a compiled binary, for any purpose,
commercial or non-commercial, and by any means.
In jurisdictions that recognize copyright laws, the author or authors of this
software dedicate any and all copyright interest in the software to the public
domain. We make this dedication for the benefit of the public at large and to
the detriment of our heirs and successors. We intend this dedication to be an
overt act of relinquishment in perpetuity of all present and future rights to
this software under copyright law.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
------------------------------------------------------------------------------
```

`Licenses/SpirV.md`:

```md
BSD 2-Clause License

Copyright (c) 2017, Matthäus G. Chajdas
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.

* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Licenses/Xiph.md`:

```md
Copyright (c) 2002-2020 Xiph.org Foundation

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:

- Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.

- Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

- Neither the name of the Xiph.org Foundation nor the names of its
contributors may be used to endorse or promote products derived from
this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION
OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Licenses/YamlDotNet.md`:

```md
Copyright (c) 2008, 2009, 2010, 2011, 2012, 2013, 2014 Antoine Aubry and contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Licenses/darkfx.md`:

```md
MIT License

Copyright (c) 2021 Steffen Wilke

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/texgenpack.md`:

```md
/*

Copyright (c) 2015 Harm Hanemaaijer <fgenfb@yahoo.com>

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

*/


```

`Licenses/uTinyRipper.md`:

```md
MIT License

Copyright (c) 2020 mafaca

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/uTinyRipperExporter.md`:

```md
MIT License

Copyright (c) 2018 spacehamster

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`Localizations/ar.json`:

```json
{
    "welcome_title": "مرحبا بكم في AssetRipper",
    "config_options": "خيارات إعدادات",
    "ignore_asset_bundle_content_paths": "تجاهل مسارات محتوى حزمة الأصول",
    "skip_streaming_assets": "تخطي مجلد StreamingAssets",
    "mesh_export_title": "تصدير صيغة Mesh",
    "audio_export_title": "تصدير صيغة الصوت",
    "image_export_title": "تصدير صيغة الصور",
    "sprite_export_title": "تصدير صيغة Sprite",
    "terrain_export_title": "تصدير صيغة Terrain",
    "text_asset_export_title": "تصدير صيغة TextAsset",
    "shader_asset_export_title": "تصدير صيغة Shader",
    "script_export_title": "تصدير صيغة Script",
    "script_content_level_title": "تصدير صيغة Script",
    "script_language_version_title": "إصدار اللغة C#",
    "mesh_format_native": "أصلى",
    "mesh_format_native_description": "صيغة قوي لاستخدام meshes في المحرر. يمكن تحويلها إلى صيغة أخرى عن طريق مجموعة متنوعة من حزم الوحدة.",
    "mesh_format_obj": "",
    "mesh_format_obj_description": "",
    "mesh_format_stl_ascii": "",
    "mesh_format_stl_ascii_description": "",
    "mesh_format_stl_binary": "",
    "mesh_format_stl_binary_description": "",
    "mesh_format_ply_ascii": "",
    "mesh_format_ply_ascii_description": "",
    "mesh_format_glb_primitive": "",
    "mesh_format_glb_primitive_description": "",
    "mesh_format_fbx_primitive": "",
    "mesh_format_fbx_primitive_description": "",
    "audio_format_native": "الخام",
    "audio_format_native_description": "الصوت FSB الخام. لا يمكن استيراده إلى Unity، لذا لا تستخدم هذا إلا إذا كنت مستخدما متقدما.",
    "audio_format_default": "افتراضي",
    "audio_format_default_description": "تصدير الأصول كنوع المحتوى المضمن داخل FSB. يتم تصدير معظم أنواع الصوت بصيغة WAV ، ويتم تصدير بعضها بصيغة OGG.",
    "audio_format_force_wav": "",
    "audio_format_force_wav_description": "",
    "audio_format_force_mp3": "قم بالتحويل إلى MP3",
    "audio_format_force_mp3_description": "تحويل جميع الملفات الصوتية إلى ملفات MP3. لا ينصح به لأنه سيعيد ضغط الملفات ، مما يتسبب في فقدان الجودة. ويندوز فقط.",
    "image_format_description": "يؤثر على جميع الصور المصدرة",
    "sprite_format_native": "يونيتي",
    "sprite_format_native_description": "تصدير في صيغة unity sprite. لا يمكن النظر إليها خارج unity.",
    "sprite_format_texture": "",
    "sprite_format_texture_description": "تصدير كصورة لورقة Sprite . يمكن النظر إليها خارج Unity ، ولكن أبطأ في التصدير.",
    "terrain_format_native": "",
    "terrain_format_native_description": "",
    "terrain_format_obj": "",
    "terrain_format_obj_description": "",
    "terrain_format_heatmap": "",
    "terrain_format_heatmap_description": "",
    "text_asset_format_binary": "",
    "text_asset_format_binary_description": "",
    "text_asset_format_text": "",
    "text_asset_format_text_description": "",
    "text_asset_format_parse": "تحليل",
    "text_asset_format_parse_description": "تصدير كملف نصي عادي ، ولكن حاول تخمين امتداد الملف الصحيح (على سبيل المثال ، تحصل ملفات JSON على ملحق .json)",
    "shader_asset_format_dummy": "",
    "shader_asset_format_dummy_description": "",
    "shader_asset_format_yaml": "",
    "shader_asset_format_yaml_description": "",
    "shader_asset_format_disassembly": "",
    "shader_asset_format_disassembly_description": "",
    "script_export_format_decompiled": "",
    "script_export_format_decompiled_description": "",
    "script_export_format_hybrid": "",
    "script_export_format_dll_with_renaming": "تصدير Dll مع إعادة التسمية",
    "script_export_format_dll_without_renaming": "تصدير Dll بدون إعادة تسمية",
    "script_export_format_dll_without_renaming_description": "",
    "script_content_level_0": "المستوى 0",
    "script_content_level_1": "المستوى 1",
    "script_content_level_2": "المستوى 2",
    "script_content_level_3": "المستوى 3",
    "script_content_level_4": "المستوى 4",
    "script_content_level_0_description": "لا يتم تصدير البرامج النصية.",
    "script_content_level_1_description": "",
    "script_content_level_2_description": "",
    "script_content_level_3_description": "",
    "script_content_level_4_description": "",
    "c_sharp_langage_version_config_1": "",
    "c_sharp_langage_version_config_2": "",
    "c_sharp_langage_version_config_3": "",
    "c_sharp_langage_version_config_4": "",
    "c_sharp_langage_version_config_5": "",
    "c_sharp_langage_version_config_6": "",
    "c_sharp_langage_version_config_7": "",
    "c_sharp_langage_version_config_7_1": "",
    "c_sharp_langage_version_config_7_2": "",
    "c_sharp_langage_version_config_7_3": "",
    "c_sharp_langage_version_config_8_0": "",
    "c_sharp_langage_version_config_9_0": "",
    "c_sharp_langage_version_config_10_0": "",
    "c_sharp_langage_version_config_latest": "",
    "c_sharp_langage_version_config_auto_safe": "",
    "c_sharp_langage_version_config_auto_experimental": "",
    "c_sharp_language_version_config_description": "",
    "config_screen_drag_drop_prompt": "",
    "menu_file": "ملف",
    "menu_file_open_file": "فتح ملف",
    "menu_file_open_folder": "فتح مجلد",
    "menu_file_reset": "أعد الضبط",
    "menu_file_exit": "خروج",
    "menu_export": "تصدير",
    "menu_export_all": "تصدير جميع الملفات",
    "menu_export_selected": "تصدير الملف المحدد",
    "menu_export_selected_type": "تصدير جميع الملفات من النوع المحدد",
    "menu_language": "اللغة",
    "loading_game_content_from": "تحميل محتوى اللعبة من {0}\n{1}",
    "loading_step_load_assemblies": "تحميل التجميعات",
    "loading_step_parse_bundle": "حزمة التحليل {0}",
    "loading_step_parse_archive": "تحليل ملف الأرشيف {0}",
    "loading_step_parse_web": "تحليل ملف الويب {0}",
    "loading_step_parse_serialized": "تحليل الملف المتسلسل {0}",
    "loading_step_parse_resource": "تحليل ملف الموارد {0}",
    "loading_step_parse_il2cpp_metadata": "تحليل بيانات تعريف IL2CPP",
    "loading_step_generate_dummy_dll": "إنشاء تجميعات أحادية من IL2CPP",
    "loading_step_locate_key_functions": "مسح IL2CPP الثنائي لوظائف المكتبة",
    "loading_step_restore_attributes": "استعادة الخصائص على التجميعات التي تم إنشاؤها",
    "loading_step_load_assets_from_file": "تحميل الأصول من {0}",
    "loading_step_detect_platform": "جمع الملفات واكتشاف هيكل اللعبة",
    "loading_step_initialize_layout": "جاري تهيئة مخطط الأصل",
    "loading_step_create_file_collection": "إنشاء مجموعة ملفات",
    "loading_step_begin_scheme_processing": "بدء معالجة النظام",
    "loading_step_pre_processing": "",
    "select_asset_to_view_info": "",
    "asset_tab_basic": "",
    "asset_tab_yaml": "",
    "asset_tab_image": "صورة",
    "asset_tab_text": "نص",
    "asset_tab_audio": "صوت",
    "asset_tab_audio_play": "تشغيل",
    "asset_tab_audio_pause": "توقف",
    "asset_tab_audio_duration_unknown": "<مجهول>",
    "error": "خطأ",
    "success": "نجاح!",
    "export_complete": "اكتمل التصدير!",
    "no_game_files_found": "لم يتم العثور على لعبة Unity أو حزمة أصول في الملفات التي تم حذفه.",
    "export_deleting_old_files": "مسح الملفات الموجودة...",
    "export_preparing": "الاستعداد للتصدير...\nقد يستغرق هذا دقيقة واحدة.",
    "export_in_progress_no_file_count_yet": "تصدير ملفات الأصول\n0.0%\n?/?",
    "export_in_progress": "تصدير ملفات الأصول\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "فشل تصدير محتوى اللعبة: {0}",
    "error_importing_with_reason": "فشل تحميل محتوى اللعبة: {0}",
    "check_log_for_more_details": "تحقق من السجل لمزيد من التفاصيل",
    "loose_file_saved_at": "تم فك الملفات المحفوظة في {0}",
    "not_implemented_yet": "لم يتم تنفيذه بعد"
}

```

`Localizations/de.json`:

```json
{
    "welcome_title": "Willkommen zu AssetRipper",
    "config_options": "Konfiguration Optionen",
    "ignore_asset_bundle_content_paths": "Asset Bundle Inhalt Pfad Ignorieren",
    "skip_streaming_assets": "StreamingAssets Ordner Überspringen",
    "mesh_export_title": "Mesh Exportformat",
    "audio_export_title": "Audio Exportformat",
    "image_export_title": "Bild Exportformat",
    "sprite_export_title": "Sprite Exportformat",
    "terrain_export_title": "Terrain Exportformat",
    "text_asset_export_title": "TextAsset Exportformat",
    "script_content_level_title": "Script Inhaltliche Ebene",
    "script_language_version_title": "C# Sprach Version",
    "mesh_format_native": "Nativ",
    "mesh_format_native_description": "Ein robustes Format für die Verwendung von meshes im Editor. Kann durch eine Vielfalt von Unity-Paketen in andere Formate konvertiert werden.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Weit verbreitetes textbasiertes Format, verwendbar in fast allen 3D-Bearbeitungssoftware. Dies bricht jedoch exportierte Verweise zu das Mesh-Asset.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "3D-Objektformat, das häufig für 3D Drucken verwendet wird. Unity kann Assets mit diesen Typ nicht importieren. Textbasierte Variante.",
    "mesh_format_stl_binary": "STL (Binär)",
    "mesh_format_stl_binary_description": "3D-Objektformat, das häufig für den 3D-Druck verwendet wird. Unity kann Assets mit diesen Typ nicht importieren. Binäre Variante.",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Stanford Triangle-Format. Unity kann Assets diesen von diesen Typ nicht importieren. Textbasierte Variante.",
    "mesh_format_glb_primitive": "Simpel GLB",
    "mesh_format_glb_primitive_description": "Eine hochwertige open-source-alternative zu FBX. Binäre Version von GLTF. Enthält nur Mesh-Daten. Kann Fehler verursachen. Unity kann Assets mit diesen Typ nicht importieren.",
    "mesh_format_fbx_primitive": "Simpel FBX",
    "mesh_format_fbx_primitive_description": "Industriestandardformat, das in fast allen 3D-Bearbeitungsprogrammen, einschließlich Unity, verwendet werden kann. Enthält nur Mesh-Daten. Dies macht exportierte Verweise auf das Mesh-Asset Kapput.",
    "audio_format_native": "Raw",
    "audio_format_native_description": "Raw FSB-Audio. Kann nicht in Unity importiert werden, verwenden Sie dies also nur, wenn Sie ein fortgeschrittener Benutzer sind.",
    "audio_format_default": "Standard",
    "audio_format_default_description": "Exportieren Sie Assets als Inhaltstyp, der in den FSB eingebettet ist. Die meisten Audiotypen werden als WAV exportiert, einige als OGG.",
    "audio_format_force_wav": "zu WAV konvertieren",
    "audio_format_force_wav_description": "Konvertieren Sie alle Audiodateien in WAV-Dateien. Wird beim Importieren in Unity nicht empfohlen, da Dateien möglicherweise neu komprimiert werden und zu Qualitätsverlusten führt.",
    "audio_format_force_mp3": "zu MP3 konvertieren",
    "audio_format_force_mp3_description": "Konvertieren Sie alle Audiodateien in MP3-Dateien. Nicht empfohlen, da Dateien neu komprimiert werden, was zu Qualitätsverlusten führt. Nur Windows.",
    "image_format_description": "Betrifft alle exportierten Bilder",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Im Unity Sprite-Format exportieren. Kann nicht außerhalb von Unity angezeigt werden.",
    "sprite_format_texture": "Textur",
    "sprite_format_texture_description": "Exportieren Sie als Bild von das Sprite-Sheet. Kann außerhalb von Unity angezeigt werden, ist jedoch langsamer zu exportieren.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Exportieren Sie im nativen unity terrain-format. Die nützlichste Option, wenn Sie es wieder im Unity importieren möchten.",
    "terrain_format_obj": "3D Model (OBJ)",
    "terrain_format_obj_description": "Exportieren Sie das terrain als ein 3D-Modell im OBJ-Format, das für die Anzeige mit einer Varietät von 3D-Editoren geeignet ist. Experimentell; hat keine korrekte Skalierung.",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Exportieren Sie eine heatmap der Höhe des terrains an jedem Standort. Nur wirklich nützlich, wenn Sie sich nicht um die Details kümmern oder das terrain in 3D haben wollen.",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exportieren Sie die raw bytes des Text-Assets mit eine .Byte-Erweiterung.",
    "text_asset_format_text": "Einfacher Text",
    "text_asset_format_text_description": "Export als eine reine Textdatei (.txt)",
    "text_asset_format_parse": "Parsen",
    "text_asset_format_parse_description": "Export als Nur eine Text-Datei, aber versuchen, die richtige Dateierweiterung zu erraten (zB JSON-Dateien erhalten die .json-Erweiterung)",
    "script_content_level_0": "Level 0",
    "script_content_level_1": "Level 1",
    "script_content_level_2": "Level 2",
    "script_content_level_3": "Level 3",
    "script_content_level_4": "Level 4",
    "script_content_level_0_description": "Scripts werden nicht exportiert.",
    "script_content_level_1_description": "Methoden werden von dekompilierten Export entfernt.",
    "script_content_level_2_description": "Standard. Dies exportiert vollständige Methoden für Mono-Spiele und Dummy-Methoden für IL2Cpp-Spiele.",
    "script_content_level_3_description": "IL2Cpp-Methoden werden sicher wiederhergestellt wo es möglich ist.",
    "script_content_level_4_description": "IL2Cpp-Methoden werden ohne Rücksicht auf die Sicherheit wiederhergestellt.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "C# Aktuell",
    "c_sharp_langage_version_config_preview": "C# Vorschau",
    "c_sharp_language_version_config_description": "Die C# sprach Version die beim Dekompilieren von Skripts verwendet wird.",
    "config_screen_drag_drop_prompt": "Bitte beachten Sie, dass einige Einstellungsänderungen Fehler verursachen oder verhindern können.\nSobald Sie bereit sind, nehmen Sie Ihre Spieldatei bzw. Ihren Ordner per Drag-and-Drop in dieses Fenster oder verwenden Sie das Menü oben links, um etwas manuell zu öffnen.",
    "menu_file": "Datei",
    "menu_file_open_file": "Datei öfnen",
    "menu_file_open_folder": "Ordner öfnen",
    "menu_file_reset": "zurücksetzen",
    "menu_file_exit": "Beenden",
    "menu_export": "Exportieren",
    "menu_export_all": "Alle Dateien exportieren",
    "menu_export_selected": "Ausgewählte Datei exportieren",
    "menu_export_selected_type": "Alle Dateien des ausgewählten Typs exportieren",
    "menu_language": "Sprache",
    "loading_game_content_from": "Spiel Inhalte werden geladen {0}\n{1}",
    "loading_step_load_assemblies": "Assemblies werden geladen",
    "loading_step_parse_bundle": "Parsen Bundle {0}",
    "loading_step_parse_archive": "Parsen der Archivdatei {0}",
    "loading_step_parse_web": "Parsen Webdateien {0}",
    "loading_step_parse_serialized": "Serialisierte Datei analysieren {0}",
    "loading_step_parse_resource": "Parsen der Ressourcendatei {0}",
    "loading_step_parse_il2cpp_metadata": "IL2CPP-Metadata wird analysiert",
    "loading_step_generate_dummy_dll": "Erzeugung von Mono-Assemblys aus IL2CPP",
    "loading_step_locate_key_functions": "IL2CPP-Binärdateien für library funktionen werden gesucht",
    "loading_step_restore_attributes": "Wiederherstellen von Attributen in generierten Assemblys",
    "loading_step_load_assets_from_file": "Laden Assets aus {0}",
    "loading_step_detect_platform": "Dateien werden Gesammelt und die Spielstruktur wird erkannt",
    "loading_step_initialize_layout": "Asset-Layout wird initialisiert",
    "loading_step_create_file_collection": "Dateisammlung wird erstellet",
    "loading_step_begin_scheme_processing": "Schema-Verarbeitung gestartet",
    "loading_step_pre_processing": "Dateien werden vorverarbeitet",
    "select_asset_to_view_info": "Wähle ein Asset aus der linken seite aus um die Informationen darüber anzuzeigen",
    "asset_tab_basic": "Allgemeine Info",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Bild",
    "asset_tab_text": "Text",
    "asset_tab_audio": "Audio",
    "asset_tab_audio_play": "Abspielen",
    "asset_tab_audio_pause": "Pausieren",
    "asset_tab_audio_duration_unknown": "<Unbekannt>",
    "error": "Fehler",
    "success": "Erfolgreich!",
    "export_complete": "Fertig Exportiert!",
    "no_game_files_found": "Kein Unity spiel oder asset bundle wurde gefunden.",
    "export_deleting_old_files": "Vorhandene Dateien werden gelöscht...",
    "export_preparing": "Exportieren wird vorbereitet...\nDas wird vielleicht eine minute dauern.",
    "export_in_progress_no_file_count_yet": "Asset datein werden exportiert\n0.0% \n?/?",
    "export_in_progress": "Asset Datein exportieren\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Exportieren von Spielinhalten fehlgeschlagen: {0}",
    "error_importing_with_reason": "Fehgeschlagen spiel inhalt zu laden: {0}",
    "loose_file_saved_at": "Lose Datei gespeichert unter {0}",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "check_log_for_more_details": "Überprüfen Sie das Protokoll für weitere Details",
    "c_sharp_langage_version_config_auto_safe": "Automatisch - Sicher",
    "c_sharp_langage_version_config_auto_experimental": "Automatisch - Experimentell",
    "not_implemented_yet": "Noch nicht implementiert",
    "shader_asset_export_title": "Shader Export Format",
    "script_export_title": "Skript Export Format",
    "shader_asset_format_dummy": "Dummy-Shader",
    "shader_asset_format_dummy_description": "Den Shader als Dummy-Shader exportieren. Obwohl es Daten wie die Eigenschaften und FallBack behält, verwendet er allgemeinen, opaken Shader-Code.",
    "shader_asset_format_yaml": "Yaml asset",
    "shader_asset_format_yaml_description": "Den Shader als Yaml-Asset exportieren. Experimentell und nur zur Ansicht im Editor verwendbar. Der Editor kann diese Dateien zufällig beschädigen.",
    "shader_asset_format_disassembly": "disassembly",
    "shader_asset_format_disassembly_description": "Exportieren Sie den Shader als disassembly. Experimentell und bruchanfällig. Dies lässt sich im Editor nicht kompilieren.",
    "script_export_format_decompiled": "Dekompiliert",
    "script_export_format_decompiled_description": "Der ILSpy-Decompiler wird zur Erstellung von CS-Skripten verwendet. Dieser ist zuverlässig. Allerdings ist es zeitaufwändig und enthält viele Kompilierfehler.",
    "script_export_format_hybrid": "hybrid",
    "script_export_format_dll_with_renaming": "Dll-Export mit Umbenennung",
    "script_export_format_dll_without_renaming": "Dll-Export ohne Umbenennung",
    "script_export_format_dll_without_renaming_description": "Assemblies werden in ihrer kompilierten Dll-Form exportiert. Experimentell. Funktioniert vielleicht gar nicht.",
    "bundled_assets_export_title": "Gebündelte Assets Exportmodus",
    "bundled_assets_export_group_by_asset_type": "Gruppieren nach Asset-Typ",
    "bundled_assets_export_group_by_asset_type_description": "Gebündelte Assets werden genauso behandelt wie Assets aus anderen Dateien.",
    "bundled_assets_export_group_by_bundle_name": "Gruppieren nach Bündelnamen",
    "bundled_assets_export_group_by_bundle_name_description": "Gebündelte Assets werden nach ihrem Asset-Bundle-Namen gruppiert."
}

```

`Localizations/en_GB.json`:

```json
{
  "welcome_title": "Welcome To AssetRipper",
  "config_options": "Configuration Options",
  "ignore_asset_bundle_content_paths": "Ignore Asset Bundle Content Paths",
  "skip_streaming_assets": "Skip StreamingAssets Folder",
  "mesh_export_title": "Mesh Export Format",
  "audio_export_title": "Audio Export Format",
  "image_export_title": "Image Export Format",
  "sprite_export_title": "Sprite Export Format",
  "terrain_export_title": "Terrain Export Format",
  "text_asset_export_title": "TextAsset Export Format",
  "shader_asset_export_title": "Shader Export Format",
  "script_export_title": "Script Export Format",
  "script_content_level_title": "Script Content Level",
  "script_language_version_title": "C# Language Version",
  "mesh_format_native": "Native",
  "mesh_format_native_description": "A robust format for using meshes in the editor. Can be converted to other formats by a variety of unity packages.",
  "mesh_format_obj": "OBJ",
  "mesh_format_obj_description": "Widely-used text-based format, usable in almost all 3d editing software. However, this breaks exported references to the mesh asset.",
  "mesh_format_stl_ascii": "STL (ASCII)",
  "mesh_format_stl_ascii_description": "3D object format commonly used for 3D printing. Unity cannot import assets of this type. Text-based variant.",
  "mesh_format_stl_binary": "STL (Binary)",
  "mesh_format_stl_binary_description": "3D object format commonly used for 3D printing. Unity cannot import assets of this type. Binary variant.",
  "mesh_format_ply_ascii": "PLY (ASCII)",
  "mesh_format_ply_ascii_description": "Stanford Triangle Format. Unity cannot import assets of this type. Text-based variant.",
  "mesh_format_glb_primitive": "Simple GLB",
  "mesh_format_glb_primitive_description": "A high-quality, open-source alternative to FBX. Binary version of GLTF. Only contains mesh data. Can cause errors. Unity cannot import assets of this type.",
  "mesh_format_fbx_primitive": "Simple FBX",
  "mesh_format_fbx_primitive_description": "Industry standard format usuable in almost all 3d editing software, including Unity. Only contains mesh data. This breaks exported references to the mesh asset.",
  "audio_format_yaml": "Yaml",
  "audio_format_yaml_description": "Export as a yaml asset and resS file. This is a safe option and is the backup when things go wrong.",
  "audio_format_native": "Raw",
  "audio_format_native_description": "Raw FSB Audio. Cannot be imported into Unity, so only use this if you're an advanced user.",
  "audio_format_default": "Default",
  "audio_format_default_description": "Export assets as the content type embedded inside the FSB. Most audio types are exported as WAV, some are exported as OGG.",
  "audio_format_force_wav": "Convert to WAV",
  "audio_format_force_wav_description": "Convert all audio files to WAV files. Not recommended if importing into unity, as it may recompress files, causing a loss of quality.",
  "image_format_description": "Affects all exported images",
  "sprite_format_native": "Unity",
  "sprite_format_native_description": "Export in the unity sprite format. Cannot be viewed outside of unity.",
  "sprite_format_texture": "Texture",
  "sprite_format_texture_description": "Export as an image of the Sprite Sheet. Can be viewed outside of unity, but slower to export.",
  "terrain_format_native": "Unity",
  "terrain_format_native_description": "Export in the native unity terrain format. Most useful option if you plan to re-import back into unity.",
  "terrain_format_obj": "3D Model (OBJ)",
  "terrain_format_obj_description": "Export the terrain as a 3D model in OBJ format, suitable for viewing with a wide range of 3D editors. Experimental; doesn't have correct scaling.",
  "terrain_format_heatmap": "Heightmap",
  "terrain_format_heatmap_description": "Export a heatmap of the height of the terrain at each location. Only really useful if you don't care about the details or having the terrain in 3D.",
  "text_asset_format_binary": "Bytes",
  "text_asset_format_binary_description": "Export the raw bytes of the text asset with a .bytes extension.",
  "text_asset_format_text": "Plain Text",
  "text_asset_format_text_description": "Export as a plain text file (.txt)",
  "text_asset_format_parse": "Parse",
  "text_asset_format_parse_description": "Export as a plain text file, but try to guess the correct file extension (e.g. JSON files get the .json extension)",
  "shader_asset_format_dummy": "Dummy Shader",
  "shader_asset_format_dummy_description": "Export the shader as a dummy shader. Although it preserves data like the Properties and FallBack, it uses general, opaque shader code.",
  "shader_asset_format_yaml": "Yaml Asset",
  "shader_asset_format_yaml_description": "Export the shader as a yaml asset. Experimental and only usable for viewing in the editor. The editor can randomly corrupt these files.",
  "shader_asset_format_disassembly": "Disassembly",
  "shader_asset_format_disassembly_description": "Export the shader as disassembly. Experimental and prone to breakage. This does not compile in the editor.",
  "script_export_format_decompiled": "Decompiled",
  "script_export_format_decompiled_description": "Use the ILSpy decompiler to generate CS scripts. This is reliable. However, it's also time-consuming and contains many compile errors.",
  "script_export_format_hybrid": "Hybrid",
  "script_export_format_dll_with_renaming": "Dll Export With Renaming",
  "script_export_format_dll_without_renaming": "Dll Export Without Renaming",
  "script_export_format_dll_without_renaming_description": "Export assemblies in their compiled Dll form. Experimental. Might not work at all.",
  "script_content_level_0": "Level 0",
  "script_content_level_1": "Level 1",
  "script_content_level_2": "Level 2",
  "script_content_level_3": "Level 3",
  "script_content_level_4": "Level 4",
  "script_content_level_0_description": "Scripts are not exported.",
  "script_content_level_1_description": "Methods are stripped from decompiled export.",
  "script_content_level_2_description": "Default. This exports full methods for Mono games and dummy methods for IL2Cpp games.",
  "script_content_level_3_description": "IL2Cpp methods are safely recovered where possible.",
  "script_content_level_4_description": "IL2Cpp methods are recovered without regard to safety.",
  "c_sharp_langage_version_config_1": "C# 1",
  "c_sharp_langage_version_config_2": "C# 2",
  "c_sharp_langage_version_config_3": "C# 3",
  "c_sharp_langage_version_config_4": "C# 4",
  "c_sharp_langage_version_config_5": "C# 5",
  "c_sharp_langage_version_config_6": "C# 6",
  "c_sharp_langage_version_config_7": "C# 7",
  "c_sharp_langage_version_config_7_1": "C# 7.1",
  "c_sharp_langage_version_config_7_2": "C# 7.2",
  "c_sharp_langage_version_config_7_3": "C# 7.3",
  "c_sharp_langage_version_config_8_0": "C# 8",
  "c_sharp_langage_version_config_9_0": "C# 9",
  "c_sharp_langage_version_config_10_0": "C# 10",
  "c_sharp_langage_version_config_latest": "C# Latest",
  "c_sharp_langage_version_config_auto_safe": "Automatic - Safe",
  "c_sharp_langage_version_config_auto_experimental": "Automatic - Experimental",
  "c_sharp_language_version_config_description": "The C# language version to be used when decompiling scripts.",
  "config_screen_drag_drop_prompt": "Please note that some setting changes may cause or prevent errors.\nOnce you're ready, drag-and-drop your game file/folder onto this window, or use the menu in the upper-left to open something manually.",
  "menu_file": "File",
  "menu_file_open_file": "Open File",
  "menu_file_open_folder": "Open Folder",
  "menu_file_reset": "Reset",
  "menu_file_exit": "Exit",
  "menu_export": "Export",
  "menu_export_all": "Export all Files",
  "menu_export_selected": "Export Selected File",
  "menu_export_selected_type": "Export all Files of Selected Type",
  "menu_language": "Language",
  "loading_game_content_from": "Loading Game Content From {0}\n{1}",
  "loading_step_load_assemblies": "Loading Assemblies",
  "loading_step_parse_bundle": "Parsing Bundle {0}",
  "loading_step_parse_archive": "Parsing Archive File {0}",
  "loading_step_parse_web": "Parsing Web File {0}",
  "loading_step_parse_serialized": "Parsing Serialized File {0}",
  "loading_step_parse_resource": "Parsing Resource File {0}",
  "loading_step_parse_il2cpp_metadata": "Parsing IL2CPP Metadata",
  "loading_step_generate_dummy_dll": "Generating Mono Assemblies from IL2CPP",
  "loading_step_locate_key_functions": "Scanning IL2CPP Binary for Library Functions",
  "loading_step_restore_attributes": "Restoring Attributes on Generated Assemblies",
  "loading_step_load_assets_from_file": "Loading Assets from {0}",
  "loading_step_detect_platform": "Collecting Files and Detecting Game Structure",
  "loading_step_initialize_layout": "Initializing Asset Layout",
  "loading_step_create_file_collection": "Creating File Collection",
  "loading_step_begin_scheme_processing": "Starting Scheme Processing",
  "loading_step_pre_processing": "Pre-Processing Files",
  "select_asset_to_view_info": "Select an Asset on the left to view information about it",
  "asset_tab_basic": "Basic Information",
  "asset_tab_yaml": "Yaml",
  "asset_tab_image": "Image",
  "asset_tab_text": "Text",
  "asset_tab_audio": "Audio",
  "asset_tab_audio_play": "Play",
  "asset_tab_audio_pause": "Pause",
  "asset_tab_audio_duration_unknown": "<Unknown>",
  "error": "Error",
  "success": "Success!",
  "export_complete": "Export Complete!",
  "no_game_files_found": "No Unity game or asset bundle was found in the dropped files.",
  "export_deleting_old_files": "Clearing out existing files...",
  "export_preparing": "Preparing for Export...\nThis might take a minute.",
  "export_in_progress_no_file_count_yet": "Exporting Asset Files\n0.0%\n?/?",
  "export_in_progress": "Exporting Asset Files\n{0}%\n{1}/{2}",
  "error_exporting_with_reason": "Failed to export game content: {0}",
  "error_importing_with_reason": "Failed to load game content: {0}",
  "check_log_for_more_details": "Check log for more details",
  "loose_file_saved_at": "Loose file saved at {0}",
  "not_implemented_yet": "Not Implemented Yet"
}
```

`Localizations/en_US.json`:

```json
{
  "welcome_title": "Welcome To AssetRipper",
  "config_options": "Configuration Options",
  "bundled_assets_export_title": "Bundled Assets Export Mode",
  "skip_streaming_assets": "Skip StreamingAssets Folder",
  "mesh_export_title": "Mesh Export Format",
  "audio_export_title": "Audio Export Format",
  "image_export_title": "Image Export Format",
  "sprite_export_title": "Sprite Export Format",
  "terrain_export_title": "Terrain Export Format",
  "text_asset_export_title": "TextAsset Export Format",
  "shader_asset_export_title": "Shader Export Format",
  "script_export_title": "Script Export Format",
  "script_content_level_title": "Script Content Level",
  "script_language_version_title": "C# Language Version",
  "bundled_assets_export_group_by_asset_type": "Group By Asset Type",
  "bundled_assets_export_group_by_asset_type_description": "Bundled assets are treated the same as assets from other files.",
  "bundled_assets_export_group_by_bundle_name": "Group By Bundle Name",
  "bundled_assets_export_group_by_bundle_name_description": "Bundled assets are grouped by their asset bundle name.",
  "bundled_assets_export_direct_export": "Direct Export",
  "bundled_assets_export_direct_export_description": "Bundled assets are exported without grouping.",
  "mesh_format_native": "Native",
  "mesh_format_native_description": "A robust format for using meshes in the editor. Can be converted to other formats by a variety of unity packages.",
  "mesh_format_obj": "OBJ",
  "mesh_format_obj_description": "Widely-used text-based format, usable in almost all 3d editing software. However, this breaks exported references to the mesh asset.",
  "mesh_format_stl_ascii": "STL (ASCII)",
  "mesh_format_stl_ascii_description": "3D object format commonly used for 3D printing. Unity cannot import assets of this type. Text-based variant.",
  "mesh_format_stl_binary": "STL (Binary)",
  "mesh_format_stl_binary_description": "3D object format commonly used for 3D printing. Unity cannot import assets of this type. Binary variant.",
  "mesh_format_ply_ascii": "PLY (ASCII)",
  "mesh_format_ply_ascii_description": "Stanford Triangle Format. Unity cannot import assets of this type. Text-based variant.",
  "mesh_format_glb_primitive": "Simple GLB",
  "mesh_format_glb_primitive_description": "A high-quality, open-source alternative to FBX. Binary version of GLTF. Only contains mesh data. Can cause errors. Unity cannot import assets of this type.",
  "mesh_format_fbx_primitive": "Simple FBX",
  "mesh_format_fbx_primitive_description": "Industry standard format usuable in almost all 3d editing software, including Unity. Only contains mesh data. This breaks exported references to the mesh asset.",
  "audio_format_yaml": "Yaml",
  "audio_format_yaml_description": "Export as a yaml asset and resS file. This is a safe option and is the backup when things go wrong.",
  "audio_format_native": "Raw",
  "audio_format_native_description": "Raw FSB Audio. Cannot be imported into Unity, so only use this if you're an advanced user.",
  "audio_format_default": "Default",
  "audio_format_default_description": "Export assets as the content type embedded inside the FSB. Most audio types are exported as WAV, some are exported as OGG.",
  "audio_format_force_wav": "Convert to WAV",
  "audio_format_force_wav_description": "Convert all audio files to WAV files. Not recommended if importing into unity, as it may recompress files, causing a loss of quality.",
  "image_format_description": "Affects all exported images",
  "sprite_format_native": "Unity",
  "sprite_format_native_description": "Export in the unity sprite format. Cannot be viewed outside of unity.",
  "sprite_format_texture": "Texture",
  "sprite_format_texture_description": "Export as an image of the Sprite Sheet. Can be viewed outside of unity, but slower to export.",
  "terrain_format_native": "Unity",
  "terrain_format_native_description": "Export in the native unity terrain format. Most useful option if you plan to re-import back into unity.",
  "terrain_format_obj": "3D Model (OBJ)",
  "terrain_format_obj_description": "Export the terrain as a 3D model in OBJ format, suitable for viewing with a wide range of 3D editors. Experimental; doesn't have correct scaling.",
  "terrain_format_heatmap": "Heightmap",
  "terrain_format_heatmap_description": "Export a heatmap of the height of the terrain at each location. Only really useful if you don't care about the details or having the terrain in 3D.",
  "text_asset_format_binary": "Bytes",
  "text_asset_format_binary_description": "Export the raw bytes of the text asset with a .bytes extension.",
  "text_asset_format_text": "Plain Text",
  "text_asset_format_text_description": "Export as a plain text file (.txt)",
  "text_asset_format_parse": "Parse",
  "text_asset_format_parse_description": "Export as a plain text file, but try to guess the correct file extension (e.g. JSON files get the .json extension)",
  "shader_asset_format_dummy": "Dummy Shader",
  "shader_asset_format_dummy_description": "Export the shader as a dummy shader. Although it preserves data like the Properties and FallBack, it uses general, opaque shader code.",
  "shader_asset_format_yaml": "Yaml Asset",
  "shader_asset_format_yaml_description": "Export the shader as a yaml asset. Experimental and only usable for viewing in the editor. The editor can randomly corrupt these files.",
  "shader_asset_format_disassembly": "Disassembly",
  "shader_asset_format_disassembly_description": "Export the shader as disassembly. Experimental and prone to breakage. This does not compile in the editor.",
  "script_export_format_decompiled": "Decompiled",
  "script_export_format_decompiled_description": "The ILSpy decompiler is used to generate CS scripts. This is reliable. However, it's also time-consuming and contains many compile errors.",
  "script_export_format_hybrid": "Hybrid",
  "script_export_format_dll_with_renaming": "Dll Export With Renaming",
  "script_export_format_dll_without_renaming": "Dll Export Without Renaming",
  "script_export_format_dll_without_renaming_description": "Assemblies are exported in their compiled Dll form. Experimental. Might not work at all.",
  "script_content_level_0": "Level 0",
  "script_content_level_1": "Level 1",
  "script_content_level_2": "Level 2",
  "script_content_level_3": "Level 3",
  "script_content_level_4": "Level 4",
  "script_content_level_0_description": "Scripts are not exported.",
  "script_content_level_1_description": "Methods are stripped from decompiled export.",
  "script_content_level_2_description": "Default. This exports full methods for Mono games and dummy methods for IL2Cpp games.",
  "script_content_level_3_description": "IL2Cpp methods are safely recovered where possible.",
  "script_content_level_4_description": "IL2Cpp methods are recovered without regard to safety.",
  "c_sharp_langage_version_config_1": "C# 1",
  "c_sharp_langage_version_config_2": "C# 2",
  "c_sharp_langage_version_config_3": "C# 3",
  "c_sharp_langage_version_config_4": "C# 4",
  "c_sharp_langage_version_config_5": "C# 5",
  "c_sharp_langage_version_config_6": "C# 6",
  "c_sharp_langage_version_config_7": "C# 7",
  "c_sharp_langage_version_config_7_1": "C# 7.1",
  "c_sharp_langage_version_config_7_2": "C# 7.2",
  "c_sharp_langage_version_config_7_3": "C# 7.3",
  "c_sharp_langage_version_config_8_0": "C# 8",
  "c_sharp_langage_version_config_9_0": "C# 9",
  "c_sharp_langage_version_config_10_0": "C# 10",
  "c_sharp_langage_version_config_11_0": "C# 11",
  "c_sharp_langage_version_config_latest": "C# Latest",
  "c_sharp_langage_version_config_auto_safe": "Automatic - Safe",
  "c_sharp_langage_version_config_auto_experimental": "Automatic - Experimental",
  "c_sharp_language_version_config_description": "The C# language version to be used when decompiling scripts.",
  "config_screen_drag_drop_prompt": "Please note that some setting changes may cause or prevent errors.\nOnce you're ready, drag-and-drop your game file/folder onto this window, or use the menu in the upper-left to open something manually.",
  "menu_file": "File",
  "menu_file_open_file": "Open File",
  "menu_file_open_folder": "Open Folder",
  "menu_file_reset": "Reset",
  "menu_file_exit": "Exit",
  "menu_export": "Export",
  "menu_export_all": "Export all Files",
  "menu_export_selected": "Export Selected File",
  "menu_export_selected_type": "Export all Files of Selected Type",
  "menu_language": "Language",
  "loading_game_content_from": "Loading Game Content From {0}\n{1}",
  "loading_step_load_assemblies": "Loading Assemblies",
  "loading_step_parse_bundle": "Parsing Bundle {0}",
  "loading_step_parse_archive": "Parsing Archive File {0}",
  "loading_step_parse_web": "Parsing Web File {0}",
  "loading_step_parse_serialized": "Parsing Serialized File {0}",
  "loading_step_parse_resource": "Parsing Resource File {0}",
  "loading_step_parse_il2cpp_metadata": "Parsing IL2CPP Metadata",
  "loading_step_generate_dummy_dll": "Generating Mono Assemblies from IL2CPP",
  "loading_step_locate_key_functions": "Scanning IL2CPP Binary for Library Functions",
  "loading_step_restore_attributes": "Restoring Attributes on Generated Assemblies",
  "loading_step_load_assets_from_file": "Loading Assets from {0}",
  "loading_step_detect_platform": "Collecting Files and Detecting Game Structure",
  "loading_step_initialize_layout": "Initializing Asset Layout",
  "loading_step_create_file_collection": "Creating File Collection",
  "loading_step_begin_scheme_processing": "Starting Scheme Processing",
  "loading_step_pre_processing": "Pre-Processing Files",
  "select_asset_to_view_info": "Select an Asset on the left to view information about it",
  "asset_tab_basic": "Basic Information",
  "asset_tab_yaml": "Yaml",
  "asset_tab_image": "Image",
  "asset_tab_text": "Text",
  "asset_tab_audio": "Audio",
  "asset_tab_audio_play": "Play",
  "asset_tab_audio_pause": "Pause",
  "asset_tab_audio_duration_unknown": "<Unknown>",
  "error": "Error",
  "success": "Success!",
  "export_complete": "Export Complete!",
  "no_game_files_found": "No Unity game or asset bundle was found in the dropped files.",
  "export_deleting_old_files": "Clearing out existing files...",
  "export_preparing": "Preparing for Export...\nThis might take a minute.",
  "export_in_progress_no_file_count_yet": "Exporting Asset Files\n0.0%\n?/?",
  "export_in_progress": "Exporting Asset Files\n{0}%\n{1}/{2}",
  "error_exporting_with_reason": "Failed to export game content: {0}",
  "error_importing_with_reason": "Failed to load game content: {0}",
  "check_log_for_more_details": "Check log for more details",
  "loose_file_saved_at": "Loose file saved at {0}",
  "not_implemented_yet": "Not Implemented Yet"
}

```

`Localizations/es.json`:

```json
{
    "welcome_title": "Bienvenido a AssetRipper",
    "config_options": "Opciones de configuración",
    "disable_scripts": "Desactivar Procesamiento de Scripts",
    "skip_streaming_assets": "Ignorar el directorio de \"StreamingAssets\"",
    "mesh_export_title": "Formato de exportación del Mesh",
    "audio_export_title": "Formato de exportación del Audio",
    "image_export_title": "Formato de exportación de Imágenes",
    "sprite_export_title": "Formato de exportación de Sprites",
    "terrain_export_title": "Formato de exportación del Terreno",
    "text_asset_export_title": "Formato de exportación de Assets de Texto",
    "mesh_format_native": "Original/Nativo",
    "mesh_format_native_description": "Un formato robusto para utilizar meshes en el editor. Puede ser convertido a otros formatos por una variedad de paquetes de Unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Formato de texto ampliamente utilizado, se puede usar en casi todos los programas de modelaje en 3D. Sin embargo, esto rompe las referencias exportadas al mesh asset.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Formato de objeto 3D usado normalmente para la impresión 3D. Unity no puede importar assets de este tipo. Variante basada en texto.",
    "mesh_format_stl_binary": "STL (Binario)",
    "mesh_format_stl_binary_description": "Formato de objeto 3D usado normalmente para la impresión 3D. Unity no puede importar assets de este tipo. Variante binaria.",
    "mesh_format_glb_primitive": "GLB Simple",
    "mesh_format_glb_primitive_description": "Una alternativa a FBX de alta calidad y open-source. Versión binaria de GLTF. Solo contiene datos del mesh. Puede provocar errores. Unity no puede importar assets de este tipo.",
    "audio_format_native": "Sin Procesar (Raw)",
    "audio_format_native_description": "Audio FSB sin procesar (Raw). No se puede importar a Unity. Usa esta opción solo si eres un usuario avanzado.",
    "audio_format_default": "Default/Predeterminado",
    "audio_format_default_description": "Exportar assets como el tipo de contenido embebido dentro del FSB. La mayoría de los formatos de audio se exportan como WAV, algunos se exportan como OGG.",
    "audio_format_force_wav": "Convertir a WAV",
    "audio_format_force_wav_description": "Convertir todos los archivos de audio a archivos WAV. No recomendado si vas a importarlos en Unity, ya que puede volver a comprimir archivos y provocar una pérdida de calidad.",
    "image_format_description": "Afecta todas las imágenes exportadas",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exportar en el formato nativo de sprites de Unity. No generan imágenes, por lo que no se pueden modificar fuera de Unity.",
    "sprite_format_texture": "Textura",
    "sprite_format_texture_description": "Generar las imágenes de la capa de sprites como texturas. Se pueden manipular y ver fuera de Unity, pero lleva mas tiempo de exportación.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Exportar en el formato de terreno nativo de Unity. La opción más útil si planeas volver a importar en Unity.",
    "terrain_format_obj": "Modelo 3D (OBJ)",
    "terrain_format_obj_description": "Exportar el terreno como un modelo 3D en formato OBJ, adecuado para abrirlo con una amplia gama de editores 3D. Experimental; no tiene la escala correcta.",
    "terrain_format_heatmap": "Mapa de Altura",
    "terrain_format_heatmap_description": "Exportar un mapa de calor de la altura del terreno en cada ubicación. Solo es útil si no te preocupas por los detalles o por tener el terreno en 3D.",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exportar los bytes del asset de texto sin procesar con extensión .bytes.",
    "text_asset_format_text": "Formato de Texto Simple",
    "text_asset_format_text_description": "Exportar como formato de texto simple (.txt)",
    "text_asset_format_parse": "Analizar (Parse)",
    "text_asset_format_parse_description": "Exportar como archivo de texto simple, pero intente adivinar la extensión de archivo correcta (por ejemplo, los archivos JSON obtienen la extensión .json)",
    "config_screen_drag_drop_prompt": "Tenga en cuenta que algunos cambios de configuración pueden provocar o evitar errores.\nUna vez que esté listo, arrastre y suelte el archivo/carpeta del juego en esta ventana, o use el menú en la parte superior izquierda para abrir algo manualmente.",
    "menu_file": "Archivo",
    "menu_file_open_file": "Abrir archivo",
    "menu_file_open_folder": "Abrir carpeta",
    "menu_file_reset": "Reiniciar",
    "menu_file_exit": "Salir",
    "menu_export": "Exportar",
    "menu_export_all": "Exportar todos los archivos",
    "menu_export_selected": "Exportar el archivo seleccionado",
    "loading_game_content_from": "Cargando Contenido del Juego desde {0}\n{1}",
    "loading_step_load_assemblies": "Cargando ensamblajes",
    "loading_step_parse_bundle": "Analizando Bundle {0}",
    "loading_step_parse_archive": "Analizando Archivo {0}",
    "loading_step_parse_web": "Analizando Archivo Web {0}",
    "loading_step_parse_serialized": "Analizando Archivo Serializado {0}",
    "loading_step_parse_resource": "Analizando Archivo de Recursos {0}",
    "loading_step_parse_il2cpp_metadata": "Analizando Metadatos de IL2CPP",
    "loading_step_generate_dummy_dll": "Generando ensamblajes Mono a partir de IL2CPP",
    "loading_step_locate_key_functions": "Buscando funciones de librería en binarios IL2CPP",
    "loading_step_restore_attributes": "Restaurando atributos en los ensamblajes generados",
    "loading_step_load_assets_from_file": "Cargando Assets desde {0}",
    "loading_step_detect_platform": "Recopilando archivos y detectando la estructura del juego",
    "loading_step_initialize_layout": "Inicializando el Esquema de Assets",
    "loading_step_create_file_collection": "Creando colección de archivos",
    "loading_step_begin_scheme_processing": "Iniciando el Procesamiento de Esquemas",
    "loading_step_pre_processing": "Pre-Procesando Archivos",
    "select_asset_to_view_info": "Selecciona un asset de la ventana de la izquierda para ver más información sobre él",
    "asset_tab_basic": "Información Básica",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Imagen",
    "asset_tab_audio": "Audio",
    "asset_tab_audio_play": "Reproducir",
    "asset_tab_audio_pause": "Pausar",
    "asset_tab_audio_duration_unknown": "<Desconocido>",
    "success": "¡Realizado con Éxito!",
    "no_game_files_found": "No se ha encontrado ningún juego de Unity o conjunto de Assets en los archivos seleccionados.",
    "error_importing_with_reason": "No se pudo cargar el contenido del juego: {0}",
    "menu_language": "Idioma",
    "asset_tab_text": "Texto",
    "error": "Error",
    "export_complete": "¡Exportación Completada!",
    "export_deleting_old_files": "Eliminando archivos existentes del directorio de exportación...",
    "export_preparing": "Preparando para exportar...\nEsto podría tardar unos minutos.",
    "export_in_progress_no_file_count_yet": "Exportando Assets\n0.0%\n?/?",
    "export_in_progress": "Exportando Assets\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "No se pudo exportar el contenido del juego: {0}",
    "audio_format_force_mp3": "Convertir a MP3",
    "audio_format_force_mp3_description": "Convertir todos los archivos de audio a archivos MP3. No recomendado porque volverá a comprimir archivos y provocará una pérdida de calidad. Solo funciona en Windows.",
    "loose_file_saved_at": "Archivo suelto guardado en {0}",
    "mesh_format_fbx_primitive_description": "Formato estándar de la industria que se puede utilizar en casi todos los programas de edición 3D, incluido Unity. Solo contiene datos de malla. Esto rompe las referencias de exportación al activo de malla.",
    "mesh_format_fbx_primitive": "Simple FBX (Primitivo)",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Formato de Triángulo de Stanford. Unity no puede importar assets de este tipo. Variante basada en texto.",
    "script_content_level_0": "Nivel 0",
    "script_content_level_1": "Nivel 1",
    "script_content_level_2": "Nivel 2",
    "script_content_level_3": "Nivel 3",
    "script_content_level_4": "Nivel 4",
    "script_content_level_0_description": "Los scripts no serán exportados.",
    "script_content_level_1_description": "Los métodos serán eliminados de los scripts decompilados.",
    "script_content_level_2_description": "Opción establecida por defecto. Se exportarán los métodos completos para juegos Mono y métodos vacíos para juegos IL2Cpp.",
    "script_content_level_3_description": "Los métodos IL2Cpp son recuperados de forma segura, siempre que sea posible.",
    "script_content_level_4_description": "Los métodos IL2Cpp son recuperados sin considerar su seguridad.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "Última versión de C#",
    "c_sharp_langage_version_config_preview": "Versión Adelantada de C#",
    "c_sharp_language_version_config_description": "La versión de lenguaje C# a usar al decompilar scripts.",
    "ignore_asset_bundle_content_paths": "Ignorar directorios de contenido de los Asset Bundle",
    "script_content_level_title": "Nivel de contenido de Scripts",
    "script_language_version_title": "Versión de Lenguaje C#",
    "menu_export_selected_type": "Exportar todos los archivos del tipo seleccionado",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "check_log_for_more_details": "Comprueba el registro para más detalles",
    "script_export_format_dll_without_renaming_description": "Experimental. Los ensambles son exportados en su formato DLL compilado. Puede fallar.",
    "not_implemented_yet": "Aún no implementado",
    "script_export_title": "Formato de exportación de Scripts",
    "c_sharp_langage_version_config_auto_experimental": "Automático - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automático - Seguro",
    "shader_asset_export_title": "Formato de exportación de Shaders",
    "shader_asset_format_dummy": "Shader básico",
    "shader_asset_format_dummy_description": "Exporta los shaders en su formato más simple (pero el más funcional). Aunque contiene los campos de datos como \"Propiedades\" y FallBack, generalmente usa código de shader opaco.",
    "shader_asset_format_yaml": "Yaml Asset",
    "script_export_format_decompiled": "Decompilado",
    "script_export_format_decompiled_description": "El decompilador ILSpy es utilizado para generar scripts CS. Es un método robusto y eficaz. Aunque también aumenta el tiempo de exportación y contiene bastantes errores, pero con la experiencia necesaria, se pueden arreglar manualmente.",
    "script_export_format_hybrid": "Híbrida",
    "script_export_format_dll_with_renaming": "Exportación de DLL renombrados",
    "shader_asset_format_yaml_description": "Experimental. Exporta el shader como Yaml asset. Solamente visible en el editor. Existe la probabilidad de que, de manera aleatoria, el editor corrompa estos archivos."
}

```

`Localizations/fr.json`:

```json
{
    "welcome_title": "Bienvenue dans AssetRipper",
    "config_options": "Options de Configuration",
    "ignore_asset_bundle_content_paths": "",
    "skip_streaming_assets": "Passer le dossier StreamingAssets",
    "mesh_export_title": "Format d'export des modèles",
    "audio_export_title": "Format d'export des fichiers audio",
    "image_export_title": "Format d'export des fichiers image",
    "sprite_export_title": "Format d'export des Sprite",
    "terrain_export_title": "",
    "text_asset_export_title": "",
    "script_content_level_title": "Niveau de contenu des scripts",
    "script_language_version_title": "Version du langage C#",
    "mesh_format_native": "",
    "mesh_format_native_description": "Un format robuste pour utiliser les modèles dans l'éditeur. Peut être converti dans d'autres formats par différents packages unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Format texte communément utilisé, compréhensible par la plupart des logiciels de modélisation 3d. Cependant, cela cassera les références au mesh asset.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Format d'objet 3D habituellement utilisé pour l'impression 3D. Unity ne peut pas importer ce type de fichiers. Variante texte.",
    "mesh_format_stl_binary": "STL (Binaire)",
    "mesh_format_stl_binary_description": "Format d'objet 3D habituellement utilisé pour l'impression 3D. Unity ne peut pas importer ce type de fichiers. Variante binaire.",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "",
    "mesh_format_glb_primitive": "",
    "mesh_format_glb_primitive_description": "",
    "mesh_format_fbx_primitive": "",
    "mesh_format_fbx_primitive_description": "",
    "audio_format_native": "Brut",
    "audio_format_native_description": "Audio FSB brut. Ne peut être importé dans Unity, à utiliser uniquement si vous êtes un utilisateur avancé.",
    "audio_format_default": "Format par défaut",
    "audio_format_default_description": "",
    "audio_format_force_wav": "Convertir vers WAV",
    "audio_format_force_wav_description": "",
    "audio_format_force_mp3": "Convertir vers MP3",
    "audio_format_force_mp3_description": "Convertit tous les fichiers audio en fichier MP3. Non recommandé, car cela recompressera les fichiers, provoquant une perte de qualité. Uniquement pour Windows.",
    "image_format_description": "",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "",
    "sprite_format_texture": "",
    "sprite_format_texture_description": "",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "",
    "terrain_format_obj": "",
    "terrain_format_obj_description": "",
    "terrain_format_heatmap": "",
    "terrain_format_heatmap_description": "",
    "text_asset_format_binary": "Octets",
    "text_asset_format_binary_description": "Exporte les octets brut de l'asset textuel avec une extension en .bytes .",
    "text_asset_format_text": "",
    "text_asset_format_text_description": "",
    "text_asset_format_parse": "",
    "text_asset_format_parse_description": "",
    "script_content_level_0": "Niveau 0",
    "script_content_level_1": "Niveau 1",
    "script_content_level_2": "Niveau 2",
    "script_content_level_3": "Niveau 3",
    "script_content_level_4": "Niveau 4",
    "script_content_level_0_description": "Les scripts ne seront pas exportés.",
    "script_content_level_1_description": "Les méthodes ne sont incluses dans la décompilation.",
    "script_content_level_2_description": "Paramètre par défaut. Ceci exporte toutes les méthodes pour les jeux Mono et des méthodes fictives pour les jeux IL2Cpp.",
    "script_content_level_3_description": "Les méthodes IL2CPP sont récupérées de manière sécurisée lorsque possible.",
    "script_content_level_4_description": "Les méthodes IL2CPP sont récupérées sans considération de sécurité.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_latest": "",
    "c_sharp_language_version_config_description": "La version du langage C# qui sera utilisée lors de la décompilation des scripts.",
    "config_screen_drag_drop_prompt": "",
    "menu_file": "Fichier",
    "menu_file_open_file": "Ouvrir un fichier",
    "menu_file_open_folder": "Ouvrir un dossier",
    "menu_file_reset": "",
    "menu_file_exit": "Quitter",
    "menu_export": "Exporter",
    "menu_export_all": "Exporter tous les fichiers",
    "menu_export_selected": "Exporter le fichier sélectionné",
    "menu_language": "Langue",
    "loading_game_content_from": "Chargement du contenu du jeu depuis {0}\n{1}",
    "loading_step_load_assemblies": "Chargement des assemblies",
    "loading_step_parse_bundle": "Lecture du bundle {0}",
    "loading_step_parse_archive": "Lecture du fichier d'archive {0}",
    "loading_step_parse_web": "Lecture du fichier web {0}",
    "loading_step_parse_serialized": "",
    "loading_step_parse_resource": "",
    "loading_step_parse_il2cpp_metadata": "",
    "loading_step_generate_dummy_dll": "",
    "loading_step_locate_key_functions": "",
    "loading_step_restore_attributes": "",
    "loading_step_load_assets_from_file": "Chargement des assets depuis {0}",
    "loading_step_detect_platform": "",
    "loading_step_initialize_layout": "",
    "loading_step_create_file_collection": "",
    "loading_step_begin_scheme_processing": "",
    "loading_step_pre_processing": "",
    "select_asset_to_view_info": "Sélectionnez un Asset sur le panneau de gauche pour voir ses informations",
    "asset_tab_basic": "Informations de base",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Image",
    "asset_tab_text": "Texte",
    "asset_tab_audio": "",
    "asset_tab_audio_play": "Jouer",
    "asset_tab_audio_pause": "Pause",
    "asset_tab_audio_duration_unknown": "",
    "error": "Erreur",
    "success": "",
    "export_complete": "",
    "no_game_files_found": "Aucun bundle ou asset Unity n'a été trouvé dans les fichiers.",
    "export_deleting_old_files": "",
    "export_preparing": "",
    "export_in_progress_no_file_count_yet": "",
    "export_in_progress": "",
    "error_exporting_with_reason": "Le contenu de jeu suivant n'a pu être exporté : {0}",
    "error_importing_with_reason": "Le contenu de jeu suivant n'a pu être chargé : {0}",
    "loose_file_saved_at": "",
    "c_sharp_langage_version_config_auto_experimental": "Automatique - Expérimental",
    "c_sharp_langage_version_config_auto_safe": "Automatique - Sécurisé"
}

```

`Localizations/id.json`:

```json
{
    "welcome_title": "Selamat Datang di AssetRipper",
    "config_options": "Konfigurasi",
    "disable_scripts": "Nonaktifkan Pemrosesan Script",
    "skip_streaming_assets": "Lewati Folder StreamingAssets",
    "mesh_export_title": "Format Ekspor Mesh",
    "audio_export_title": "Format Ekspor Audio",
    "image_export_title": "Format Ekspor Gambar",
    "sprite_export_title": "Format Ekspor Sprite",
    "terrain_export_title": "Format Ekspor Terrain",
    "text_asset_export_title": "Format Ekspor TextAsset",
    "mesh_format_native": "Bawaan",
    "mesh_format_native_description": "Format yang cocok untuk digunakan pada editor. Dapat dikonversi menjadi format lain di dalam unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Format berbasis teks yang banyak digunakan, dapat digunakan pada hampir semua aplikasi pengedit 3D. Namun, format ini merusak referensi yang diekspor ke aset mesh.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Format objek 3D yang biasa digunakan untuk pencetakan 3D. Unity tidak dapat mengimpor aset jenis ini. Varian berbasis teks.",
    "mesh_format_stl_binary": "STL (Biner)",
    "mesh_format_stl_binary_description": "Format objek 3D yang biasa digunakan untuk 3D printing. Unity tidak dapat mengimpor aset jenis ini. Varian biner.",
    "mesh_format_glb_primitive": "GLB Sederhana",
    "mesh_format_glb_primitive_description": "Alternatif open-source berkualitas tinggi untuk FBX. Versi biner GLTF. Hanya berisi data mesh. Dapat menyebabkan error. Unity tidak dapat mengimpor aset jenis ini.",
    "audio_format_native": "Mentah",
    "audio_format_native_description": "FSB Audio Mentah. Tidak dapat diimpor ke Unity, jadi gunakan ini hanya jika Anda memahaminya.",
    "audio_format_default": "Bawaan",
    "audio_format_default_description": "Ekspor aset sebagai tipe konten yang disematkan di dalam FSB. Sebagian besar jenis audio diekspor sebagai WAV, beberapa diekspor sebagai OGG.",
    "audio_format_force_wav": "Konversikan ke WAV",
    "audio_format_force_wav_description": "Konversikan semua file audio menjadi file WAV. Tidak disarankan jika mengimpor ke unity, karena dapat mengompresi ulang file, yang menyebabkan penurunan kualitas.",
    "image_format_description": "Mempengaruhi semua gambar yang diekspor",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Ekspor dalam format sprite unity. Tidak dapat dilihat di luar unity.",
    "sprite_format_texture": "Tekstur",
    "sprite_format_texture_description": "Ekspor sebagai gambar Sprite Sheet. Dapat dilihat di luar unity, tapi lebih lambat untuk diekspor.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Ekspor dalam format bawaan terrain unity. Pilihan paling berguna jika Anda berencana untuk mengimpor kembali ke unity.",
    "terrain_format_obj": "Model 3D (OBJ)",
    "terrain_format_obj_description": "Ekspor terrain sebagai model 3D dalam format OBJ, cocok untuk dilihat dengan berbagai aplikasi editor 3D. Eksperimental; tidak memiliki skala yang tepat.",
    "terrain_format_heatmap": "Peta ketinggian",
    "terrain_format_heatmap_description": "Ekspor heatmap ketinggian terrain di setiap lokasi. Hanya sangat berguna jika Anda tidak peduli dengan detailnya atau memiliki terrain dalam bentuk 3D.",
    "text_asset_format_binary": "Byte",
    "text_asset_format_binary_description": "Ekspor byte mentah dari aset teks dengan ekstensi .bytes .",
    "text_asset_format_text": "Teks Biasa",
    "text_asset_format_text_description": "Ekspor sebagai file teks biasa (.txt)",
    "text_asset_format_parse": "Mengurai",
    "text_asset_format_parse_description": "Ekspor sebagai file teks biasa, tapi tetap mencoba untuk mencari ekstensi file yang benar (mis. File JSON akan mendapatkan ekstensi .json)",
    "config_screen_drag_drop_prompt": "Harap dicatat bahwa beberapa perubahan pengaturan dapat menyebabkan atau mencegah error.\nSetelah Anda siap,drag-and-drop file/folder game Anda ke jendela ini, atau gunakan menu di kiri atas untuk membuka sesuatu secara manual.",
    "menu_file": "File",
    "menu_file_open_file": "Buka File",
    "menu_file_open_folder": "Buka Folder",
    "menu_file_reset": "Atur Ulang",
    "menu_file_exit": "Keluar",
    "menu_export": "Ekspor",
    "menu_export_all": "Ekspor Semua File",
    "menu_export_selected": "Ekspor File Terpilih",
    "loading_game_content_from": "Memuat Konten Game Dari {0}\n{1}",
    "loading_step_load_assemblies": "Memuat Assemblies",
    "loading_step_parse_bundle": "Menguraikan Berkas {0}",
    "loading_step_parse_archive": "Menguraikan File Arsip {0}",
    "loading_step_parse_web": "Menguraikan File Web {0}",
    "loading_step_parse_serialized": "Menguraikan File Berserial {0}",
    "loading_step_parse_resource": "Menguraikan File Resource {0}",
    "loading_step_parse_il2cpp_metadata": "Menguraikan Metadata IL2CPP",
    "loading_step_generate_dummy_dll": "Menghasilkan Assemblies Mono dari IL2CPP",
    "loading_step_locate_key_functions": "Memindai Biner IL2CPP dalam Mencari Fungsi pada Library",
    "loading_step_restore_attributes": "Memulihkan Atribut pada Assemblies yang Dihasilkan",
    "loading_step_load_assets_from_file": "Memuat Aset dari {0}",
    "loading_step_detect_platform": "Mengumpulkan File dan Mendeteksi Struktur Game",
    "loading_step_initialize_layout": "Menginisialisasi Tata Letak Aset",
    "loading_step_create_file_collection": "Membuat Koleksi File",
    "loading_step_begin_scheme_processing": "Memulai Pemrosesan Skema",
    "loading_step_pre_processing": "Tahap Awal Pemrosesan File",
    "select_asset_to_view_info": "Pilih Aset di sebelah kiri untuk melihat informasi tentangnya",
    "asset_tab_basic": "Informasi Dasar",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Gambar",
    "asset_tab_audio": "Audio",
    "asset_tab_audio_play": "Putar Audio",
    "asset_tab_audio_pause": "Jeda",
    "asset_tab_audio_duration_unknown": "<Tidak Diketahui>",
    "asset_tab_text": "Teks",
    "error": "Error",
    "success": "Berhasil!",
    "export_complete": "Ekspor Selesai!",
    "no_game_files_found": "Tidak ada game Unity atau berkas aset yang ditemukan di dalam file yang dipilih.",
    "export_deleting_old_files": "Menghapus file yang ada...",
    "export_preparing": "Mempersiapkan Ekspor...\nMungkin membutuhkan waktu beberapa menit.",
    "menu_language": "Bahasa",
    "export_in_progress_no_file_count_yet": "Mengekspor File Aset\n0.0%\n?/?",
    "export_in_progress": "Mengekspor File Aset\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Gagal mengekspor konten game: {0}",
    "error_importing_with_reason": "Gagal memuat konten game: {0}",
    "audio_format_force_mp3_description": "Konversikan semua file audio ke file MP3. Tidak disarankan karena akan mengkompres ulang file, menyebabkan penurunan kualitas. Windows saja.",
    "audio_format_force_mp3": "Konversikan ke MP3",
    "mesh_format_fbx_primitive": "FBX Sederhana",
    "mesh_format_fbx_primitive_description": "Format standar industri dapat digunakan di hampir semua software 3d editor, termasuk Unity. Hanya berisi data mesh. Format ini merusak referensi yang diekspor ke aset mesh.",
    "loose_file_saved_at": "File Loose disimpan pada {0}",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Format Segitiga Stanford. Unity tidak dapat mengimpor tipe aset ini. Varian berbasis teks.",
    "script_content_level_1_description": "Method dihasilkan berdasarkan hasil ekspor yang telah didekompilasi.",
    "script_content_level_2_description": "Bawaan. Mengekspor semua method pada game Mono dan method palsu pada game IL2Cpp.",
    "script_content_level_3_description": "Method IL2Cpp dipulihkan dengan aman jika memungkinkan.",
    "script_content_level_4_description": "Method IL2Cpp dipulihkan tanpa memperhatikan keamanan.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "C# Terbaru",
    "c_sharp_langage_version_config_preview": "C# Pratinjau",
    "c_sharp_language_version_config_description": "Versi bahasa C# yang akan digunakan saat dekompilasi script.",
    "ignore_asset_bundle_content_paths": "Abaikan Path Konten Asset Bundle",
    "script_content_level_title": "Tingkat Konten Script",
    "script_language_version_title": "Versi Bahasa C#",
    "script_content_level_0": "Tingkat 0",
    "script_content_level_1": "Tingkat 1",
    "script_content_level_2": "Tingkat 2",
    "script_content_level_3": "Tingkat 3",
    "script_content_level_4": "Tingkat 4",
    "script_content_level_0_description": "Script tidak diekspor.",
    "menu_export_selected_type": "Ekspor semua File Berdasarkan Tipe yang Dipilih",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "check_log_for_more_details": "Cek file Log untuk melihat detil lebih lanjut",
    "c_sharp_langage_version_config_auto_safe": "Otomatis - Aman",
    "c_sharp_langage_version_config_auto_experimental": "Otomatis - Eksperimental",
    "shader_asset_format_dummy": "Shader Tiruan",
    "shader_asset_format_dummy_description": "Ekspor shader sebagai shader tiruan. Data seperti Properties dan FallBack dipertahankan, namun kode shader dihasilkan dalam bentuk umum.",
    "shader_asset_format_disassembly_description": "Ekspor shader sebagai pembongkaran. Eksperimental dan rentan terhadap kerusakan.Editor tidak dapat melakukan kompilasi.",
    "script_export_format_dll_without_renaming_description": "Assemblies diekspor dalam bentuk Dll yang dikompilasi. Eksperimental. Kemungkinan tidak bekerja sama sekali.",
    "shader_asset_export_title": "Format Ekspor Shader",
    "script_export_title": "Format Ekspor Script",
    "shader_asset_format_yaml": "Aset Yaml",
    "shader_asset_format_yaml_description": "Ekspor shader sebagai aset yaml. Eksperimental dan hanya dapat digunakan pada editor. Editor dapat secara acak merusak file-file ini.",
    "shader_asset_format_disassembly": "Bongkar",
    "script_export_format_decompiled": "Dekompilasi",
    "script_export_format_decompiled_description": "ILSpy digunakan untuk menghasilkan script CS. Dapat diandalkan. Namun, akan memakan waktu lama dan terdapat banyak kesalahan kompilasi.",
    "script_export_format_hybrid": "Campuran",
    "script_export_format_dll_with_renaming": "Ekspor Dll Dengan Mengganti Nama",
    "script_export_format_dll_without_renaming": "Ekspor Dll Tanpa Mengganti Nama",
    "not_implemented_yet": "Belum diimplementasikan"
}

```

`Localizations/it.json`:

```json
{
    "welcome_title": "Benvenuto su AssetRipper",
    "config_options": "Opzioni di configurazione",
    "disable_scripts": "Disabilita l'elaborazione degli script",
    "skip_streaming_assets": "Salta l'elaborazione della cartella StreamingAssets",
    "mesh_export_title": "Formato di esportazione delle mesh",
    "audio_export_title": "Formato di esportazione dei file audio",
    "image_export_title": "Formato di esportazione delle immagini",
    "sprite_export_title": "Formato di esportazione degli sprite",
    "terrain_export_title": "Formato di esportazione dei terreni",
    "text_asset_export_title": "Formato di esportazione dei file di testo",
    "mesh_format_native": "Nativo",
    "mesh_format_native_description": "Un formato robusto per utilizzare le mesh nell'editor. Può esser convertito in altri formati da una varietà di unity packages.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Formato basato su file di testo, ampiamente utilizzato ed è utilizzabile in quasi tutti i programmi di modellazione 3D. Questa opzione però rompe i riferimenti delle mesh esportate.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Formato di modelli 3D comunemente usato per la stampa 3D. Unity non può importare questo formato. Questa variante è basata su file di testo.",
    "mesh_format_stl_binary": "STL (Binario)",
    "mesh_format_stl_binary_description": "Formato di modelli 3D comunemente usato per la stampa 3D. Unity non può importare questo formato. Questa variante è basata su file binari.",
    "mesh_format_glb_primitive": "GLB Semplice",
    "mesh_format_glb_primitive_description": "Un'alternativa open source di alta qualità al formato FBX. Questa è la versione binaria del formato GLTF. Contiene solo dati della mesh. Può causare degli errori, inoltre Unity non può importare questo tipo di formato.",
    "audio_format_native": "Nativo",
    "audio_format_native_description": "Formato audio FSB nativo. Non può esser importato su Unity, quindi usalo solo se sei un esperto.",
    "audio_format_default": "Nativo",
    "audio_format_default_description": "Esporta i file come tipo di contenuto incorporato nel formato FSB. La maggior parte dei file audio viene esportata come WAV, alcuni invece vengono esportati come OGG.",
    "audio_format_force_wav": "Converti in WAV",
    "audio_format_force_wav_description": "Converti tutti i file audio in file WAV. Non raccomandato nel caso in cui si volesse importare i file su Unity in quanto alcuni file potrebbero esser ricompressi, causando così perdita di qualità.",
    "image_format_description": "Influisce su tutte le immagini esportate",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Esporta nel formato sprite di Unity. Non può esser visualizzato al di fuori di Unity.",
    "sprite_format_texture": "Texture",
    "sprite_format_texture_description": "Esporta come un immagine dello Sprite Sheet. Può essere visualizzato al di fuori di Unity, ma è più lento da esportare.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Esporta i terreni nel formato nativo di Unity. L'opzione più utile se prevedi di reimportare nuovamente i terreni su Unity.",
    "terrain_format_obj": "Modello 3D (OBJ)",
    "terrain_format_obj_description": "Esporta i terreni come modelli 3D in formato OBJ, adatto per vedere i terreni in un'ampia gamma di editor 3D. Funzione sperimentale, non esporta le dimensioni correttamente.",
    "terrain_format_heatmap": "Heightmap",
    "terrain_format_heatmap_description": "Esporta una heatmap dell'altezza del terreno in ogni posizione. Realmente utile solo se non ti interessano i dettagli o avere il terreno in 3D.",
    "text_asset_format_binary": "Byte",
    "text_asset_format_binary_description": "Esporta i byte non elaborati dei file di testo con estensione .bytes.",
    "text_asset_format_text": "Testo normale",
    "text_asset_format_text_description": "Esporta come file di testo normali (.txt)",
    "text_asset_format_parse": "Analizza",
    "text_asset_format_parse_description": "Esporta come file di testo normali, ma prova ad indovinare l'estensione corretta dei file (ad esempio: i file JSON avranno l'estensione .json)",
    "config_screen_drag_drop_prompt": "Si prega di notare che alcune modifiche alle impostazioni possono causare o prevenire errori.\nQuando sei pronto, trascina e rilascia i file o la cartella del gioco su questa finestra o usa il menu in alto a sinistra per aprire qualcosa manualmente.",
    "menu_file": "File",
    "menu_file_open_file": "Apri un file",
    "menu_file_open_folder": "Apri una cartella",
    "menu_file_reset": "Resetta",
    "menu_file_exit": "Esci",
    "menu_export": "Esporta",
    "menu_export_all": "Esporta tutti i file",
    "menu_export_selected": "Esporta i file selezionati",
    "loading_game_content_from": "Caricamento dei contenuti del gioco da {0}\n{1}",
    "loading_step_load_assemblies": "Caricamento degli Assembly",
    "loading_step_parse_bundle": "Analizzando il bundle {0}",
    "loading_step_parse_archive": "Analizzando l'archivio {0}",
    "loading_step_parse_web": "Analizzando il file web {0}",
    "loading_step_parse_serialized": "Analizzando il file serializzato {0}",
    "loading_step_parse_resource": "Analizzando il file delle risorse {0}",
    "loading_step_parse_il2cpp_metadata": "Analizzando i metadati dell'IL2CPP",
    "loading_step_generate_dummy_dll": "Generazione degli Assembly Mono dall'IL2CPP",
    "loading_step_locate_key_functions": "Scansione del file binario IL2CPP per le funzioni delle librerie",
    "loading_step_restore_attributes": "Ripristino degli attributi sugli Assembly generati",
    "loading_step_load_assets_from_file": "Caricamento dei file da {0}",
    "loading_step_detect_platform": "Raccolta dei file e rilevamento della struttura del gioco",
    "loading_step_initialize_layout": "Inizializzazione del layout dei file",
    "loading_step_create_file_collection": "Creazione della raccolta dei file",
    "loading_step_begin_scheme_processing": "Avvio dell'elaborazione dello schema",
    "loading_step_pre_processing": "Pre-elaborazione dei file",
    "select_asset_to_view_info": "Seleziona un file a sinistra per visualizzare le sue informazioni",
    "asset_tab_basic": "Informazioni di base",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Immagine",
    "asset_tab_audio": "File Audio",
    "asset_tab_audio_play": "Avvia",
    "asset_tab_audio_pause": "Metti in pausa",
    "asset_tab_audio_duration_unknown": "<Sconosciuto>",
    "menu_language": "Lingua",
    "success": "Successo!",
    "asset_tab_text": "Testo",
    "error": "Errore",
    "export_complete": "Esportazione completata!",
    "export_deleting_old_files": "Eliminazione dei file esistenti...",
    "export_preparing": "Preparazione all'esportazione...\nPotrebbero volerci alcuni minuti.",
    "no_game_files_found": "Nessun gioco creato con Unity o asset bundle è stato trovato nei file caricati.",
    "export_in_progress_no_file_count_yet": "Esportazione dei file\n0.0%\n?/?",
    "export_in_progress": "Esportazione dei file\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Impossibile esportare i contenuti del gioco: {0}",
    "error_importing_with_reason": "Impossibile caricare i contenuti del gioco: {0}",
    "audio_format_force_mp3": "Converti in MP3",
    "audio_format_force_mp3_description": "Converti tutti i file audio in file MP3. Non raccomandato perché i file verranno ricompressi, causando così perdita di qualità. Solo Windows.",
    "mesh_format_fbx_primitive_description": "Formato standard del settore utilizzabile in quasi tutti i software di editing 3D, incluso Unity. Contiene solo i dati delle mesh. Ciò rompe i riferimenti alla mesh esportati.",
    "loose_file_saved_at": "File non compresso salvato in {0}",
    "mesh_format_fbx_primitive": "FBX Semplice",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Stanford Triangle Format. Unity non può importare asset di questo tipo. Variante basata su testo.",
    "script_content_level_0": "Livello 0",
    "script_content_level_1": "Livello 1",
    "script_content_level_2": "Livello 2",
    "script_content_level_3": "Livello 3",
    "script_content_level_4": "Livello 4",
    "ignore_asset_bundle_content_paths": "Ignora i percorsi dei contenuti degli Asset Bundle",
    "script_content_level_title": "Livello dei contenuti degli script",
    "script_language_version_title": "Versione del linguaggio C#",
    "script_content_level_0_description": "Gli script non vengono esportati.",
    "script_content_level_1_description": "I metodi vengono rimossi dall'esportazione decompilata.",
    "script_content_level_2_description": "Predefinito. Esporta metodi completi per i giochi Mono e metodi vuoti per i giochi Il2cpp.",
    "script_content_level_3_description": "I metodi Il2cpp vengono recuperati in modo sicuro dove possibile.",
    "script_content_level_4_description": "I metodi Il2cpp vengono recuperati senza tenere conto della sicurezza.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "Ultima versione C#",
    "c_sharp_langage_version_config_preview": "Versione Anteprima C#",
    "c_sharp_language_version_config_description": "La versione del linguaggio C# da utilizzare durante la decompilazione degli script.",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "check_log_for_more_details": "Controlla i log per maggiori dettagli",
    "menu_export_selected_type": "Esporta tutti i file del tipo selezionato",
    "shader_asset_format_disassembly_description": "Esporta le shader come disassemblate. Sperimentale e soggetto a rotture. Queste non vengono compilate nell'editor.",
    "script_export_format_dll_without_renaming_description": "Gli assembly vengono esportati nel formato Dll compilato. Sperimentale. Potrebbe non funzionare affatto.",
    "not_implemented_yet": "Non ancora implementato",
    "c_sharp_langage_version_config_auto_safe": "Automatico - Sicuro",
    "c_sharp_langage_version_config_auto_experimental": "Automatico - Sperimentale",
    "script_export_title": "Formato di esportazione degli script",
    "shader_asset_format_dummy": "Dummy Shader",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_disassembly": "Disassembla",
    "script_export_format_decompiled": "Decompilati",
    "script_export_format_decompiled_description": "Il decompilatore ILSpy viene utilizzato per generare script CS. È affidabile. Tuttavia, richiede anche molto tempo e contiene molti errori di compilazione.",
    "script_export_format_hybrid": "Ibrido",
    "script_export_format_dll_with_renaming": "Esportazione Dll con ridenominazione",
    "script_export_format_dll_without_renaming": "Esportazione Dll senza ridenominazione",
    "shader_asset_export_title": "Formato di esportazione delle Shader",
    "shader_asset_format_dummy_description": "Esporta le shader come dummy shader. Sebbene conservi dati come Proprietà e FallBack, utilizza un comune codice di shader opaca.",
    "shader_asset_format_yaml_description": "Esporta le shader come asset yaml. Sperimentale e utilizzabile solo per la visualizzazione nell'editor. L'editor può casualmente corrompere questi file."
}

```

`Localizations/ja.json`:

```json
{
    "welcome_title": "AssetRipper へようこそ",
    "config_options": "設定オプション",
    "ignore_asset_bundle_content_paths": "アセットバンドルのコンテンツパスを無視",
    "skip_streaming_assets": "StreamingAssets フォルダをスキップ",
    "mesh_export_title": "メッシュの出力形式",
    "audio_export_title": "オーディオの出力形式",
    "image_export_title": "画像の出力形式",
    "sprite_export_title": "スプライトの出力形式",
    "terrain_export_title": "Terrain の出力形式",
    "text_asset_export_title": "TextAsset の出力形式",
    "shader_asset_export_title": "シェーダーの出力形式",
    "script_export_title": "スクリプトの出力形式",
    "script_content_level_title": "スクリプトコンテンツレベル",
    "script_language_version_title": "C# の言語バージョン",
    "mesh_format_native": "ネイティブ",
    "mesh_format_native_description": "エディタでメッシュを使用するための堅牢なフォーマットです。 さまざまなUnityパッケージで別のフォーマットに変換できます。",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "広く使われているテキストベースのフォーマットでほぼすべての3D編集ソフトが対応しています。ただし、メッシュアセットへのエクスポートされた参照が失われます。",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "一般的に3Dプリントに使用される 3D オブジェクト形式です。 Unityはこの種類のアセットをインポートすることはできません。 テキスト形式の種類です。",
    "mesh_format_stl_binary": "STL (バイナリ)",
    "mesh_format_stl_binary_description": "一般的に3Dプリントに使用される 3D オブジェクト形式です。 Unityはこの種類のアセットをインポートすることはできません。 バイナリ形式の種類です。",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Stanford Triangle Format. Unityはこの種類のアセットをインポートすることはできません。 テキスト形式の種類です。",
    "mesh_format_glb_primitive": "Simple GLB",
    "mesh_format_glb_primitive_description": "高品質かつオープンソースなFBXの代替フォーマットです。GLTFのバイナリ版です。メッシュデータのみが含まれます。エラーが発生する恐れがあります。 Unityはこの種類のアセットをインポートすることはできません。",
    "mesh_format_fbx_primitive": "Simple FBX",
    "mesh_format_fbx_primitive_description": "Unityを含むほぼすべての3D編集ソフトで使用できる業界標準のフォーマットです。 メッシュデータのみが含まれます。 これを使うとメッシュアセットへのエクスポートされた参照が失われます。",
    "audio_format_native": "Raw",
    "audio_format_native_description": "Raw FSBオーディオです。Unityにインポートできないため、上級ユーザーの場合にのみ使用してください。",
    "audio_format_default": "デフォルト",
    "audio_format_default_description": "FSB内に埋め込まれたコンテンツタイプとしてアセットをエクスポートします。 ほとんどのオーディオタイプはWAVかOGGとしてエクスポートされます。",
    "audio_format_force_wav": "WAVに変換",
    "audio_format_force_wav_description": "すべてのオーディオファイルをWAVファイルに変換します。 再圧縮され劣化する恐れがあるため、Unityにインポートする用途では推奨しません。",
    "audio_format_force_mp3": "MP3に変換",
    "audio_format_force_mp3_description": "すべてのオーディオファイルをMP3ファイルに変換します。 再圧縮され劣化する恐れがあるため推奨しません。Windowsでのみ使用できます。",
    "image_format_description": "エクスポートしたすべての画像に影響します",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Unityスプライト形式でエクスポートします。Unity以外で開くことはできません。",
    "sprite_format_texture": "テクスチャ",
    "sprite_format_texture_description": "スプライトシートの画像として出力します。 Unity以外でも開くことができますが、出力に時間がかかります。",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "UnityネイティブのTerrainフォーマットで出力します。 Unityに再インポートする場合は最も便利な選択です。",
    "terrain_format_obj": "3Dモデル (OBJ)",
    "terrain_format_obj_description": "TerrainをOBJフォーマットの3Dモデルとして出力します。3D編集ソフトでの表示に適しています。 実験的機能: 正しいスケーリングが適用されません。",
    "terrain_format_heatmap": "ハイトマップ",
    "terrain_format_heatmap_description": "Terrainの各場所の高さのヒートマップを出力します。 詳細や地形を3Dで気にしない場合は非常に便利です。",
    "text_asset_format_binary": "バイト文字列",
    "text_asset_format_binary_description": "テキストアセットを無編集のバイト文字列 (.bytes) として出力します。",
    "text_asset_format_text": "プレーンテキスト",
    "text_asset_format_text_description": "プレーンテキストファイル (.txt) として出力します。",
    "text_asset_format_parse": "",
    "text_asset_format_parse_description": "",
    "shader_asset_format_dummy": "",
    "shader_asset_format_dummy_description": "",
    "shader_asset_format_yaml": "",
    "shader_asset_format_yaml_description": "",
    "shader_asset_format_disassembly": "",
    "shader_asset_format_disassembly_description": "",
    "script_export_format_decompiled": "",
    "script_export_format_decompiled_description": "",
    "script_export_format_hybrid": "",
    "script_export_format_dll_with_renaming": "",
    "script_export_format_dll_without_renaming": "",
    "script_export_format_dll_without_renaming_description": "",
    "script_content_level_0": "",
    "script_content_level_1": "",
    "script_content_level_2": "",
    "script_content_level_3": "",
    "script_content_level_4": "",
    "script_content_level_0_description": "",
    "script_content_level_1_description": "",
    "script_content_level_2_description": "",
    "script_content_level_3_description": "",
    "script_content_level_4_description": "",
    "c_sharp_langage_version_config_1": "",
    "c_sharp_langage_version_config_2": "",
    "c_sharp_langage_version_config_3": "",
    "c_sharp_langage_version_config_4": "",
    "c_sharp_langage_version_config_5": "",
    "c_sharp_langage_version_config_6": "",
    "c_sharp_langage_version_config_7": "",
    "c_sharp_langage_version_config_7_1": "",
    "c_sharp_langage_version_config_7_2": "",
    "c_sharp_langage_version_config_7_3": "",
    "c_sharp_langage_version_config_8_0": "",
    "c_sharp_langage_version_config_9_0": "",
    "c_sharp_langage_version_config_10_0": "",
    "c_sharp_langage_version_config_latest": "",
    "c_sharp_langage_version_config_auto_safe": "",
    "c_sharp_langage_version_config_auto_experimental": "",
    "c_sharp_language_version_config_description": "",
    "config_screen_drag_drop_prompt": "",
    "menu_file": "",
    "menu_file_open_file": "",
    "menu_file_open_folder": "",
    "menu_file_reset": "",
    "menu_file_exit": "",
    "menu_export": "",
    "menu_export_all": "",
    "menu_export_selected": "",
    "menu_export_selected_type": "",
    "menu_language": "",
    "loading_game_content_from": "",
    "loading_step_load_assemblies": "",
    "loading_step_parse_bundle": "",
    "loading_step_parse_archive": "",
    "loading_step_parse_web": "",
    "loading_step_parse_serialized": "",
    "loading_step_parse_resource": "",
    "loading_step_parse_il2cpp_metadata": "",
    "loading_step_generate_dummy_dll": "",
    "loading_step_locate_key_functions": "",
    "loading_step_restore_attributes": "",
    "loading_step_load_assets_from_file": "",
    "loading_step_detect_platform": "",
    "loading_step_initialize_layout": "",
    "loading_step_create_file_collection": "",
    "loading_step_begin_scheme_processing": "",
    "loading_step_pre_processing": "",
    "select_asset_to_view_info": "",
    "asset_tab_basic": "",
    "asset_tab_yaml": "",
    "asset_tab_image": "",
    "asset_tab_text": "",
    "asset_tab_audio": "",
    "asset_tab_audio_play": "",
    "asset_tab_audio_pause": "",
    "asset_tab_audio_duration_unknown": "",
    "error": "",
    "success": "",
    "export_complete": "",
    "no_game_files_found": "",
    "export_deleting_old_files": "",
    "export_preparing": "",
    "export_in_progress_no_file_count_yet": "",
    "export_in_progress": "",
    "error_exporting_with_reason": "",
    "error_importing_with_reason": "",
    "check_log_for_more_details": "",
    "loose_file_saved_at": "",
    "not_implemented_yet": ""
}

```

`Localizations/ko.json`:

```json
{
    "welcome_title": "AssetRipper 오신걸 환영합니다",
    "config_options": "구성 옵션",
    "disable_scripts": "스크립트 처리 비활성화",
    "skip_streaming_assets": "StreamingAssets 폴더 건너뛰기",
    "mesh_export_title": "Mesh 추출 형식",
    "audio_export_title": "오디오 추출 형식",
    "image_export_title": "이미지 추출 형식",
    "sprite_export_title": "Sprite 추출 형식",
    "terrain_export_title": "Terrain 추출 형식",
    "text_asset_export_title": "TextAsset 추출 형식",
    "mesh_format_native": "네이티브",
    "mesh_format_native_description": "편집기에서 Mesh를 사용하기 위한 강력한 형식입니다. 다양한 유니티 패키지로 다른 형식으로 변환할 수 있습니다.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "널리 사용되는 텍스트 기반 형식으로 거의 모든 3D 편집 소프트웨어에서 사용할 수 있습니다. 그러나 이렇게 하면 Mesh 에셋에 대한 내보낸 참조가 중단됩니다.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "3D 프린팅에 일반적으로 사용되는 3D 개체 형식입니다. Unity는 이 유형의 에셋을 가져올 수 없습니다. 텍스트 기반 변형.",
    "mesh_format_stl_binary": "STL (바이너리)",
    "mesh_format_stl_binary_description": "3D 프린팅에 일반적으로 사용되는 3D 개체 형식입니다. Unity는 이 유형의 에셋을 가져올 수 없습니다. 바이너리 변형.",
    "mesh_format_glb_primitive": "단순 GLB",
    "mesh_format_glb_primitive_description": "FBX에 대한 고품질의 오픈 소스 대안입니다. GLTF의 바이너리 버전. 메쉬 데이터만 포함합니다. 오류가 발생할 수 있습니다. Unity는 이 유형의 에셋을 가져올 수 없습니다.",
    "mesh_format_fbx_primitive": "심플 FBX",
    "mesh_format_fbx_primitive_description": "Unity를 포함한 거의 모든 3D 편집 소프트웨어에서 사용할 수 있는 업계 표준 형식입니다. Mesh 데이터만 포함합니다. 그러면 Mesh 에셋에 대한 내보내기 참조가 중단됩니다.",
    "audio_format_native": "RAW",
    "audio_format_native_description": "Raw FSB 오디오. Unity로 가져올 수 없으므로 고급 사용자인 경우에만 사용하십시오.",
    "audio_format_default": "기본",
    "audio_format_default_description": "FSB 내부에 포함된 콘텐츠 유형으로 에셋을 내보냅니다. 대부분의 오디오 파일은 WAV로 내보내지고 일부는 OGG로 내보내집니다.",
    "audio_format_force_wav": "WAV로 변환",
    "audio_format_force_wav_description": "모든 오디오 파일을 WAV 파일로 변환합니다. Unity로 가져오는 경우 파일을 다시 압축하여 품질이 저하될 수 있으므로 권장하지 않습니다.",
    "audio_format_force_mp3": "MP3로 변환",
    "audio_format_force_mp3_description": "모든 오디오 파일을 MP3 파일로 변환합니다. 파일을 다시 압축하여 품질을 저하시키므로 권장하지 않습니다. Windows 전용에서만 사용가능합니다.",
    "image_format_description": "내보낸 모든 이미지에 영향을 줍니다",
    "sprite_format_native": "유니티",
    "sprite_format_native_description": "Unity 스프라이트 형식으로 내보냅니다. Unity 외부에서 볼 수 없습니다.",
    "sprite_format_texture": "텍스쳐",
    "sprite_format_texture_description": "스프라이트 시트의 이미지로 내보냅니다. Unity 외부에서 볼 수 있지만 내보내기 속도가 느립니다.",
    "terrain_format_native": "유니티",
    "terrain_format_native_description": "기본 통합 지형 형식으로 내보냅니다. Unity로 다시 가져오려는 경우 가장 유용한 옵션입니다.",
    "terrain_format_obj": "3D 모델 (OBJ)",
    "terrain_format_obj_description": "다양한 3D 편집기로 보기에 적합한 OBJ 형식의 3D 모델로 지형을 내보냅니다. 해당기능은 실험적이며, 올바른 스케일링이 없습니다.",
    "terrain_format_heatmap": "하이트맵",
    "terrain_format_heatmap_description": "각 위치에서 지형 높이의 히트맵을 내보냅니다. 세부 사항이나 3D 지형에 신경 쓰지 않는 경우에만 정말 유용합니다.",
    "text_asset_format_binary": "바이트",
    "text_asset_format_binary_description": "확장자가 .bytes인 텍스트 자산의 원시 바이트를 내보냅니다.",
    "text_asset_format_text": "일반 텍스트",
    "text_asset_format_text_description": "일반 텍스트 파일(.txt)로 내보내기",
    "text_asset_format_parse": "구문 분석",
    "text_asset_format_parse_description": "일반 텍스트 파일로 내보내되 올바른 파일 확장자를 추측해 보십시오(예시: JSON 파일은 .json 확장자를 가짐)",
    "config_screen_drag_drop_prompt": "일부 설정 변경으로 인해 오류가 발생하거나 방지할 수 있습니다.\n준비가 되면 게임 파일/폴더를 이 창으로 끌어다 놓거나 왼쪽 상단의 메뉴를 사용하여 수동으로 엽니다.",
    "menu_file": "파일",
    "menu_file_open_file": "파일 열기",
    "menu_file_open_folder": "폴더 열기",
    "menu_file_reset": "리셋",
    "menu_file_exit": "종료",
    "menu_export": "내보내기",
    "menu_export_all": "모든파일 내보내기",
    "menu_export_selected": "선택한 파일 내보내기",
    "menu_language": "언어",
    "loading_game_content_from": "{0}에서 게임 콘텐츠 로드\n{1}",
    "loading_step_load_assemblies": "어셈블리 로드",
    "loading_step_parse_bundle": "구문 분석 번들 {0}",
    "loading_step_parse_archive": "보관 파일 {0} 구문 분석",
    "loading_step_parse_web": "웹 파일 {0} 구문 분석",
    "loading_step_parse_serialized": "직렬화된 파일 {0} 구문 분석",
    "loading_step_parse_resource": "리소스 파일 {0} 구문 분석",
    "loading_step_parse_il2cpp_metadata": "IL2CPP 메타데이터 구문 분석",
    "loading_step_generate_dummy_dll": "IL2CPP에서 모노 어셈블리 생성",
    "loading_step_locate_key_functions": "라이브러리 기능을 위한 IL2CPP 바이너리 스캔",
    "loading_step_restore_attributes": "생성된 어셈블리의 속성 복원",
    "loading_step_load_assets_from_file": "{0}에서 에셋 로드 중",
    "loading_step_detect_platform": "파일 수집 및 게임 구조 감지",
    "loading_step_initialize_layout": "에셋 레이아웃 초기화",
    "loading_step_create_file_collection": "파일 컬렉션 생성",
    "loading_step_begin_scheme_processing": "계획 처리 시작",
    "loading_step_pre_processing": "파일 전처리",
    "select_asset_to_view_info": "왼쪽에서 자산을 선택하여 자산에 대한 정보를 봅니다",
    "asset_tab_basic": "기본 정보",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "이미지",
    "asset_tab_text": "텍스트",
    "asset_tab_audio": "오디오",
    "asset_tab_audio_play": "재생",
    "asset_tab_audio_pause": "일시정지",
    "asset_tab_audio_duration_unknown": "<Unknown>",
    "error": "오류",
    "success": "성공!",
    "export_complete": "추출 완료!",
    "no_game_files_found": "삭제된 파일에서 Unity 게임 또는 에셋 번들이 발견되지 않았습니다.",
    "export_deleting_old_files": "기존 파일 지우기...",
    "export_preparing": "수출 준비 중...\n1분 정도 걸릴 수 있습니다.",
    "export_in_progress_no_file_count_yet": "에셋 파일 내보내기\n0.0%\n?/?",
    "export_in_progress": "에셋 파일 내보내기\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "게임 콘텐츠 내보내기 실패: {0}",
    "error_importing_with_reason": "게임 콘텐츠 로드 실패: {0}",
    "loose_file_saved_at": "{0}에 저장된 느슨한 파일",
    "ignore_asset_bundle_content_paths": "에셋 번들 콘텐츠 경로 무시",
    "script_content_level_title": "스크립트 콘텐츠 레벨",
    "script_language_version_title": "C# 언어 버전",
    "c_sharp_langage_version_config_5": "C# 5",
    "mesh_format_ply_ascii_description": "스탠포드 삼각형 형식. Unity는 이 유형의 에셋을 가져올 수 없습니다. 텍스트 기반 변형.",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "script_content_level_0": "레벨 0",
    "script_content_level_1": "레벨 1",
    "script_content_level_2": "레벨 2",
    "script_content_level_3": "레벨 3",
    "script_content_level_4": "레벨 4",
    "script_content_level_0_description": "스크립트는 내보내지지 않습니다.",
    "script_content_level_1_description": "메소드는 디컴파일된 내보내기에서 제거됩니다.",
    "script_content_level_2_description": "기본. Mono 게임의 전체 메서드와 IL2Cpp 게임의 더미 메서드를 내보냅니다.",
    "script_content_level_3_description": "IL2Cpp 방법은 가능한 경우 안전하게 복구됩니다.",
    "script_content_level_4_description": "IL2Cpp 방법은 안전성에 관계없이 복구됩니다.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_language_version_config_description": "스크립트를 디컴파일할 때 사용할 C# 언어 버전입니다.",
    "c_sharp_langage_version_config_latest": "C# 최신",
    "c_sharp_langage_version_config_preview": "C# 프리뷰",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "menu_export_selected_type": "선택한 형식의 모든 파일을 내보냅니다",
    "check_log_for_more_details": "자세한 내용은 로그를 확인하십시오",
    "shader_asset_export_title": "셰이더 내보내기 형식",
    "shader_asset_format_dummy_description": "셰이더를 더미 셰이더로 내보냅니다. 속성 및 FallBack과 같은 데이터를 보존하지만 일반 불투명 셰이더 코드를 사용합니다.",
    "shader_asset_format_disassembly_description": "셰이더를 분해로 내보냅니다. 실험적이며 파손되기 쉽습니다. 이것은 편집기에서 컴파일되지 않습니다.",
    "script_export_format_dll_without_renaming_description": "어셈블리는 컴파일된 DLL 형식으로 내보내집니다. 실험적. 전혀 작동하지 않을 수 있습니다.",
    "not_implemented_yet": "아직 구현되지 않음",
    "c_sharp_langage_version_config_auto_experimental": "자동 - 실험적",
    "c_sharp_langage_version_config_auto_safe": "자동 - 안전",
    "script_export_title": "스크립트 내보내기 형식",
    "shader_asset_format_dummy": "더미 셰이더",
    "shader_asset_format_yaml": "YMAL 에셋",
    "shader_asset_format_yaml_description": "셰이더를 yaml 자산으로 내보냅니다. 실험적이며 편집기에서 볼 때만 사용할 수 있습니다. 편집기는 이러한 파일을 임의로 손상시킬 수 있습니다.",
    "shader_asset_format_disassembly": "분해",
    "script_export_format_decompiled": "디컴파일",
    "script_export_format_decompiled_description": "ILSpy 디컴파일러는 CS 스크립트를 생성하는 데 사용됩니다. 이것은 신뢰할 수 있습니다. 그러나 시간이 많이 걸리고 많은 컴파일 오류가 포함되어 있습니다.",
    "script_export_format_hybrid": "하이브리드",
    "script_export_format_dll_with_renaming": "이름을 변경하여 DLL 내보내기",
    "script_export_format_dll_without_renaming": "이름을 변경하지 않고 DLL 내보내기"
}

```

`Localizations/nl.json`:

```json
{
    "welcome_title": "",
    "config_options": "",
    "ignore_asset_bundle_content_paths": "",
    "skip_streaming_assets": "",
    "mesh_export_title": "",
    "audio_export_title": "",
    "image_export_title": "",
    "sprite_export_title": "",
    "terrain_export_title": "",
    "text_asset_export_title": "",
    "shader_asset_export_title": "",
    "script_export_title": "",
    "script_content_level_title": "",
    "script_language_version_title": "",
    "mesh_format_native": "",
    "mesh_format_native_description": "",
    "mesh_format_obj": "",
    "mesh_format_obj_description": "",
    "mesh_format_stl_ascii": "",
    "mesh_format_stl_ascii_description": "",
    "mesh_format_stl_binary": "",
    "mesh_format_stl_binary_description": "",
    "mesh_format_ply_ascii": "",
    "mesh_format_ply_ascii_description": "",
    "mesh_format_glb_primitive": "",
    "mesh_format_glb_primitive_description": "",
    "mesh_format_fbx_primitive": "",
    "mesh_format_fbx_primitive_description": "",
    "audio_format_native": "",
    "audio_format_native_description": "",
    "audio_format_default": "",
    "audio_format_default_description": "",
    "audio_format_force_wav": "",
    "audio_format_force_wav_description": "",
    "audio_format_force_mp3": "",
    "audio_format_force_mp3_description": "",
    "image_format_description": "",
    "sprite_format_native": "",
    "sprite_format_native_description": "",
    "sprite_format_texture": "",
    "sprite_format_texture_description": "",
    "terrain_format_native": "",
    "terrain_format_native_description": "",
    "terrain_format_obj": "",
    "terrain_format_obj_description": "",
    "terrain_format_heatmap": "",
    "terrain_format_heatmap_description": "",
    "text_asset_format_binary": "",
    "text_asset_format_binary_description": "",
    "text_asset_format_text": "",
    "text_asset_format_text_description": "",
    "text_asset_format_parse": "",
    "text_asset_format_parse_description": "",
    "shader_asset_format_dummy": "",
    "shader_asset_format_dummy_description": "",
    "shader_asset_format_yaml": "",
    "shader_asset_format_yaml_description": "",
    "shader_asset_format_disassembly": "",
    "shader_asset_format_disassembly_description": "",
    "script_export_format_decompiled": "",
    "script_export_format_decompiled_description": "",
    "script_export_format_hybrid": "",
    "script_export_format_dll_with_renaming": "",
    "script_export_format_dll_without_renaming": "",
    "script_export_format_dll_without_renaming_description": "",
    "script_content_level_0": "",
    "script_content_level_1": "",
    "script_content_level_2": "",
    "script_content_level_3": "",
    "script_content_level_4": "",
    "script_content_level_0_description": "",
    "script_content_level_1_description": "",
    "script_content_level_2_description": "",
    "script_content_level_3_description": "",
    "script_content_level_4_description": "",
    "c_sharp_langage_version_config_1": "",
    "c_sharp_langage_version_config_2": "",
    "c_sharp_langage_version_config_3": "",
    "c_sharp_langage_version_config_4": "",
    "c_sharp_langage_version_config_5": "",
    "c_sharp_langage_version_config_6": "",
    "c_sharp_langage_version_config_7": "",
    "c_sharp_langage_version_config_7_1": "",
    "c_sharp_langage_version_config_7_2": "",
    "c_sharp_langage_version_config_7_3": "",
    "c_sharp_langage_version_config_8_0": "",
    "c_sharp_langage_version_config_9_0": "",
    "c_sharp_langage_version_config_10_0": "",
    "c_sharp_langage_version_config_latest": "",
    "c_sharp_langage_version_config_auto_safe": "",
    "c_sharp_langage_version_config_auto_experimental": "",
    "c_sharp_language_version_config_description": "",
    "config_screen_drag_drop_prompt": "",
    "menu_file": "",
    "menu_file_open_file": "",
    "menu_file_open_folder": "",
    "menu_file_reset": "",
    "menu_file_exit": "",
    "menu_export": "",
    "menu_export_all": "",
    "menu_export_selected": "",
    "menu_export_selected_type": "",
    "menu_language": "",
    "loading_game_content_from": "",
    "loading_step_load_assemblies": "",
    "loading_step_parse_bundle": "",
    "loading_step_parse_archive": "",
    "loading_step_parse_web": "",
    "loading_step_parse_serialized": "",
    "loading_step_parse_resource": "",
    "loading_step_parse_il2cpp_metadata": "",
    "loading_step_generate_dummy_dll": "",
    "loading_step_locate_key_functions": "",
    "loading_step_restore_attributes": "",
    "loading_step_load_assets_from_file": "",
    "loading_step_detect_platform": "",
    "loading_step_initialize_layout": "",
    "loading_step_create_file_collection": "",
    "loading_step_begin_scheme_processing": "",
    "loading_step_pre_processing": "",
    "select_asset_to_view_info": "",
    "asset_tab_basic": "",
    "asset_tab_yaml": "",
    "asset_tab_image": "",
    "asset_tab_text": "",
    "asset_tab_audio": "",
    "asset_tab_audio_play": "",
    "asset_tab_audio_pause": "",
    "asset_tab_audio_duration_unknown": "",
    "error": "",
    "success": "",
    "export_complete": "",
    "no_game_files_found": "",
    "export_deleting_old_files": "",
    "export_preparing": "",
    "export_in_progress_no_file_count_yet": "",
    "export_in_progress": "",
    "error_exporting_with_reason": "",
    "error_importing_with_reason": "",
    "check_log_for_more_details": "",
    "loose_file_saved_at": "",
    "not_implemented_yet": ""
}

```

`Localizations/pl.json`:

```json
{
    "welcome_title": "Witaj w AssetRipper",
    "config_options": "Opcje konfiguracji",
    "ignore_asset_bundle_content_paths": "",
    "skip_streaming_assets": "",
    "mesh_export_title": "",
    "audio_export_title": "",
    "image_export_title": "",
    "sprite_export_title": "",
    "terrain_export_title": "",
    "text_asset_export_title": "",
    "script_content_level_title": "",
    "script_language_version_title": "Wersja języka C#",
    "mesh_format_native": "Natywne",
    "mesh_format_native_description": "",
    "mesh_format_obj": "",
    "mesh_format_obj_description": "",
    "mesh_format_stl_ascii": "",
    "mesh_format_stl_ascii_description": "",
    "mesh_format_stl_binary": "",
    "mesh_format_stl_binary_description": "",
    "mesh_format_ply_ascii": "",
    "mesh_format_ply_ascii_description": "",
    "mesh_format_glb_primitive": "",
    "mesh_format_glb_primitive_description": "",
    "mesh_format_fbx_primitive": "Prosty FBX",
    "mesh_format_fbx_primitive_description": "",
    "audio_format_native": "",
    "audio_format_native_description": "",
    "audio_format_default": "Domyślnie",
    "audio_format_default_description": "",
    "audio_format_force_wav": "Przekstałć na WAV",
    "audio_format_force_wav_description": "",
    "audio_format_force_mp3": "Przektałć na MP3",
    "audio_format_force_mp3_description": "",
    "image_format_description": "",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "",
    "sprite_format_texture": "Textura",
    "sprite_format_texture_description": "",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "",
    "terrain_format_obj": "Model 3D (OBJ)",
    "terrain_format_obj_description": "",
    "terrain_format_heatmap": "",
    "terrain_format_heatmap_description": "",
    "text_asset_format_binary": "Bajty",
    "text_asset_format_binary_description": "",
    "text_asset_format_text": "",
    "text_asset_format_text_description": "Exportuj jako plik TXT (textowy)",
    "text_asset_format_parse": "",
    "text_asset_format_parse_description": "",
    "script_content_level_0": "",
    "script_content_level_1": "",
    "script_content_level_2": "",
    "script_content_level_3": "",
    "script_content_level_4": "",
    "script_content_level_0_description": "Skrypty nie są exportowane",
    "script_content_level_1_description": "",
    "script_content_level_2_description": "",
    "script_content_level_3_description": "",
    "script_content_level_4_description": "",
    "c_sharp_langage_version_config_1": "",
    "c_sharp_langage_version_config_2": "",
    "c_sharp_langage_version_config_3": "",
    "c_sharp_langage_version_config_4": "",
    "c_sharp_langage_version_config_5": "",
    "c_sharp_langage_version_config_6": "",
    "c_sharp_langage_version_config_7": "",
    "c_sharp_langage_version_config_7_1": "",
    "c_sharp_langage_version_config_7_2": "",
    "c_sharp_langage_version_config_7_3": "",
    "c_sharp_langage_version_config_8_0": "",
    "c_sharp_langage_version_config_9_0": "",
    "c_sharp_langage_version_config_10_0": "",
    "c_sharp_langage_version_config_latest": "Najnowsze C#",
    "c_sharp_language_version_config_description": "",
    "config_screen_drag_drop_prompt": "",
    "menu_file": "",
    "menu_file_open_file": "",
    "menu_file_open_folder": "",
    "menu_file_reset": "",
    "menu_file_exit": "",
    "menu_export": "Exportuj",
    "menu_export_all": "",
    "menu_export_selected": "",
    "menu_export_selected_type": "",
    "menu_language": "",
    "loading_game_content_from": "",
    "loading_step_load_assemblies": "",
    "loading_step_parse_bundle": "",
    "loading_step_parse_archive": "",
    "loading_step_parse_web": "",
    "loading_step_parse_serialized": "",
    "loading_step_parse_resource": "",
    "loading_step_parse_il2cpp_metadata": "",
    "loading_step_generate_dummy_dll": "Generawanie plikow Mono z IL2CPP",
    "loading_step_locate_key_functions": "",
    "loading_step_restore_attributes": "",
    "loading_step_load_assets_from_file": "",
    "loading_step_detect_platform": "",
    "loading_step_initialize_layout": "",
    "loading_step_create_file_collection": "",
    "loading_step_begin_scheme_processing": "",
    "loading_step_pre_processing": "",
    "select_asset_to_view_info": "",
    "asset_tab_basic": "",
    "asset_tab_yaml": "",
    "asset_tab_image": "",
    "asset_tab_text": "",
    "asset_tab_audio": "",
    "asset_tab_audio_play": "",
    "asset_tab_audio_pause": "",
    "asset_tab_audio_duration_unknown": "",
    "error": "Bład",
    "success": "Sukces!",
    "export_complete": "Exportowanie ukończone!",
    "no_game_files_found": "",
    "export_deleting_old_files": "",
    "export_preparing": "",
    "export_in_progress_no_file_count_yet": "",
    "export_in_progress": "",
    "error_exporting_with_reason": "Błąd exportowania gry: {0}",
    "error_importing_with_reason": "",
    "check_log_for_more_details": "",
    "loose_file_saved_at": "",
    "c_sharp_langage_version_config_auto_safe": "Automatyczne - Bezpieczne",
    "c_sharp_langage_version_config_auto_experimental": "Automatyczne - Experymentalne"
}

```

`Localizations/pt_BR.json`:

```json
{
    "welcome_title": "Bem-vindo ao AssetRipper",
    "config_options": "Opções de Configuração",
    "disable_scripts": "Desabilitar Processamento de Scripts",
    "skip_streaming_assets": "Pular Pasta StreamingAssets",
    "mesh_export_title": "Formato de Exportação de Mesh",
    "audio_export_title": "Formato de Exportação de Áudio",
    "image_export_title": "Formato de Exportação de Imagem",
    "sprite_export_title": "Formato de Exportação de Sprite",
    "terrain_export_title": "Formato de Exportação de Terreno",
    "text_asset_export_title": "Formato de Exportação de TextAsset",
    "mesh_format_native": "Nativo",
    "mesh_format_native_description": "Um formato robusto para o uso de meshes no editor. Pode ser convertido para outros formatos por uma variedade de pacotes unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Formato de texto amplamente utilizado, utilizável em quase todos os softwares de edição 3D. Entretanto, quebra as referências exportadas para o asset da mesh.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Formato de objetos 3D comumente usado para impressão 3D. O Unity não consegue importar assets deste tipo. Variante baseada em texto.",
    "mesh_format_stl_binary": "STL (Binário)",
    "mesh_format_stl_binary_description": "Formato de objetos 3D comumente usado para impressão 3D. O Unity não consegue importar assets deste tipo. Variante binária.",
    "mesh_format_glb_primitive": "GLB Simples",
    "mesh_format_glb_primitive_description": "Uma alternativa de alta qualidade, open-source ao FBX. Versão binária do GLTF. Contém apenas dados mesh. Pode causar erros. O Unity não consegue importes assets deste tipo.",
    "audio_format_native": "Sem compressão (RAW)",
    "audio_format_native_description": "Áudio Raw FSB . Não pode ser importado no Unity, use apenas se você for um usuário avançado.",
    "audio_format_default": "Padrão",
    "audio_format_default_description": "Exporta os assets com o tipo de conteúdo embutido no FSB. A maioria dos tipos de áudio são exportados como WAV, outros como OGG.",
    "audio_format_force_wav": "Converter para WAV",
    "audio_format_force_wav_description": "Converte todos os arquivos de áudio em arquivos WAV. Não recomendo para importar no Unity pois pode recomprimir arquivos, causando perda de qualidade.",
    "audio_format_force_mp3": "Converter para MP3",
    "audio_format_force_mp3_description": "Converte todos os arquivos de áudio para MP3. Não recomendado porque irá recomprimir arquivos, causando perda de qualidade. Apenas Windows.",
    "image_format_description": "Afeta todas as imagens exportadas",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Exporta no formato de sprite do Unity. Não pode ser visualizado fora do Unity.",
    "sprite_format_texture": "Textura",
    "sprite_format_texture_description": "Exporta como uma imagem do Sprite Sheet. Pode ser visualizado fora do Unity, porém exportação mais lenta.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Exporta no formato nativo de terreno. Opção útil se você planeja reimportar de volta no Unity.",
    "terrain_format_obj": "Modelo 3D (OBJ)",
    "terrain_format_obj_description": "Exporta o terreno como um modelo 3D no formato OBJ, apropriado para ser visualizado em uma ampla variedade de editores 3D. Experimental; não redimensiona corretamente.",
    "terrain_format_heatmap": "Mapa de Altura",
    "terrain_format_heatmap_description": "Exporta um mapa de calor da altura do terreno em cada local. Só é realmente útil se você não se importa com os detalhes ou com ter o terreno em 3D.",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "Exporta os bytes raw do asset de texto usando a extensão .bytes.",
    "text_asset_format_text": "Texto Puro",
    "text_asset_format_text_description": "Exporta como um arquivo de texto puro (.txt)",
    "text_asset_format_parse": "Analisar",
    "text_asset_format_parse_description": "Exporta como um arquivo de texto puro, mas tenta adivinhar a extensão correta do arquivo (ex: arquivos JSON recebem a extensão .json)",
    "config_screen_drag_drop_prompt": "Por favor atente que algumas mudanças podem causar ou prevenir erros.\nUma vez pronto, arraste e solte seu arquivo/pasta de jogo nesta janela ou use o menu no canto superior esquerdo para abrir manualmente.",
    "menu_file": "Arquivo",
    "menu_file_open_file": "Abrir Arquivo",
    "menu_file_open_folder": "Abrir Pasta",
    "menu_file_reset": "Reiniciar",
    "menu_file_exit": "Sair",
    "menu_export": "Exportar",
    "menu_export_all": "Exportar todos os Arquivos",
    "menu_export_selected": "Exportar o Arquivo Selecionado",
    "menu_language": "Idioma",
    "loading_game_content_from": "Carregando Conteúdo de Jogo de {0}\n{1}",
    "loading_step_load_assemblies": "Carregando Assemblies",
    "loading_step_parse_bundle": "Analisando Bundle {0}",
    "loading_step_parse_archive": "Analisando Arquivo {0}",
    "loading_step_parse_web": "Analisando Arquivo Web {0}",
    "loading_step_parse_serialized": "Analisando Arquivo Serializado {0}",
    "loading_step_parse_resource": "Analisando Arquivo de Recursos {0}",
    "loading_step_parse_il2cpp_metadata": "Analisando Metadados IL2CPP",
    "loading_step_generate_dummy_dll": "Gerando Mono Assemblies a partir do IL2CPP",
    "loading_step_locate_key_functions": "Escaneando os Binários IL2CPP por Funções de Biblioteca",
    "loading_step_restore_attributes": "Restaurando Atributos nos Assemblies Gerados",
    "loading_step_load_assets_from_file": "Carregando Assets de {0}",
    "loading_step_detect_platform": "Coletando Arquivos e Detectando a Estrutura do Jogo",
    "loading_step_initialize_layout": "Inicializando o Leiaute de Assets",
    "loading_step_create_file_collection": "Criando a Coleção de Arquivos",
    "loading_step_begin_scheme_processing": "Iniciando o Processamento do Esquema",
    "loading_step_pre_processing": "Pré-processando Arquivos",
    "select_asset_to_view_info": "Selecione um Asset na esquerda para ver informações sobre ele",
    "asset_tab_basic": "Informações Básicas",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Imagem",
    "asset_tab_text": "Texto",
    "asset_tab_audio": "Áudio",
    "asset_tab_audio_play": "Tocar",
    "asset_tab_audio_pause": "Pausar",
    "asset_tab_audio_duration_unknown": "<Desconhecido>",
    "error": "Erro",
    "success": "Sucesso!",
    "export_complete": "Exportação Finalizada!",
    "no_game_files_found": "Nenhum jogo Unity ou asset bundle foi encontrado nos arquivos selecionados.",
    "export_deleting_old_files": "Limpando arquivos existentes...",
    "export_preparing": "Preparando para Exportar...\nPode levar um minuto.",
    "export_in_progress_no_file_count_yet": "Exportando Asset Files\n0.0%\n?/?",
    "export_in_progress": "Exportando Asset Files\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Falha ao exportar o conteúdo do jogo: {0}",
    "error_importing_with_reason": "Falha ao carregar o conteúdo do jogo: {0}",
    "c_sharp_langage_version_config_latest": "Última Versão C#",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_language_version_config_description": "A versão da linguagem C# que será utilizada ao decompilar scripts.",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "script_language_version_title": "Versão da Linguagem C#",
    "script_content_level_title": "Nível de Conteúdo de Script",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_auto_experimental": "Automático - Experimental",
    "c_sharp_langage_version_config_auto_safe": "Automático - Seguro",
    "mesh_format_ply_ascii_description": "Formato Stanford Triangle. O Unity não pode importar assets deste tipo. Variante baseada em texto.",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "script_content_level_1_description": "Métodos são removidos da exportação decompilada.",
    "script_content_level_2_description": "Padrão. Isto exporta métodos completos para jogos Mono e métodos substitutos para jogos IL2Cpp.",
    "script_content_level_3_description": "Métodos IL2Cpp são recuperados com segurança quando possível.",
    "script_content_level_4_description": "Métodos IL2Cpp são recuperados sem procedimentos de segurança.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "script_content_level_0_description": "Scripts não serão exportados.",
    "ignore_asset_bundle_content_paths": "Ignorar Caminhos de Conteúdo de Asset Bundles",
    "menu_export_selected_type": "Exportar todos Arquivos do Tipo Selecionado",
    "shader_asset_export_title": "Formato de Exportação de Shader",
    "check_log_for_more_details": "Checar log para mais detalhes",
    "mesh_format_fbx_primitive": "FBX Simples",
    "mesh_format_fbx_primitive_description": "Formato padrão de indústria utilizável em quase todos os softwares de edição 3D, incluindo o Unity. Apenas contém dados de mesh. Quebra as referências exportadas para o asset da mesh.",
    "shader_asset_format_dummy": "Shader Substituto",
    "shader_asset_format_dummy_description": "Exportar o shader como um shader substituto. Apesar de preservar dados como Propriedades e Fallback, utiliza código shader genérico, opaco.",
    "script_export_format_decompiled_description": "O decompilador ILSpy é usado para gerar scripts CS. Isto é confiável, apesar de consumir tempo e conter muitos erros de compilação.",
    "script_export_title": "Formato de Exportação de Script",
    "shader_asset_format_yaml": "Asset Yaml",
    "shader_asset_format_yaml_description": "Exportar o shader como um asset Yaml. Experimental e apenas utilizável para visualização no editor. O editor pode aleatoriamente corromper estes arquivos.",
    "shader_asset_format_disassembly": "Disassembly",
    "shader_asset_format_disassembly_description": "Exportar o shader como disassembly. Experimental e suscetível a falhas. Não compilará no editor.",
    "script_export_format_decompiled": "Decompilado",
    "script_export_format_hybrid": "Híbrido",
    "script_export_format_dll_with_renaming": "Exportação DII Com Renomeação",
    "script_export_format_dll_without_renaming": "Exportação DII Sem Renomeação",
    "script_export_format_dll_without_renaming_description": "Assemblies são exportadas em sua forma compilada DII. Experimental. Pode não funcionar.",
    "script_content_level_0": "Nível 0",
    "script_content_level_1": "Nível 1",
    "script_content_level_2": "Nível 2",
    "script_content_level_3": "Nível 3",
    "script_content_level_4": "Nível 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "loose_file_saved_at": "Arquivo desconexo salvo em {0}",
    "not_implemented_yet": "Ainda Não Implementado",
    "c_sharp_langage_version_config_6": "C# 6"
}

```

`Localizations/ru.json`:

```json
{
    "welcome_title": "Добро пожаловать в AssetRipper",
    "config_options": "Настройки Конфигураций",
    "disable_scripts": "Выключить декомпиляцию скриптов",
    "skip_streaming_assets": "Пропускать папку StreamingAssets",
    "mesh_export_title": "Формат экспорта Mesh",
    "audio_export_title": "Формат экспорта аудио",
    "image_export_title": "Формат экспорта картинок",
    "sprite_export_title": "Формат экспорта спрайтов",
    "terrain_export_title": "Формат экспорта Terrain",
    "text_asset_export_title": "Формат экспорта текста",
    "mesh_format_native": "Нативный",
    "mesh_format_native_description": "Надежный формат для использования сетки в редакторе. Может быть преобразован в другие форматы различными пакетами unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Широко распространенный текстовый формат, используемый почти во всех программах редактирования 3d. Однако это нарушает экспортируемые ссылки на ассеты сетки.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Формат 3D-объектов, обычно используемый для 3D-печати. Unity не может импортировать активы этого типа. Текстовый вариант.",
    "mesh_format_stl_binary": "STL (Бинарный)",
    "mesh_format_stl_binary_description": "Формат 3D-объектов, обычно используемый для 3D-печати. Unity не может импортировать ассеты этого типа. Бинарный вариант.",
    "mesh_format_glb_primitive": "Простой GLB",
    "mesh_format_glb_primitive_description": "Высококачественная альтернатива FBX с открытым исходным кодом. Бинарная версия GLTF. Содержит только данные сетки. Может вызывать ошибки. Unity не может импортировать активы этого типа.",
    "mesh_format_fbx_primitive": "Простой FBX",
    "mesh_format_fbx_primitive_description": "Формат промышленного стандарта, который можно использовать практически во всех программах для редактирования 3d, включая Unity. Содержит только данные сетки. Это нарушает экспортированные ссылки на актив сетки.",
    "audio_format_native": "Сырой",
    "audio_format_native_description": "Необработанное аудио FSB. Не может быть импортирован в Unity, поэтому используйте его только в случае, если вы продвинутый пользователь.",
    "audio_format_default": "По умолчанию",
    "audio_format_default_description": "Экспортируйте ресурсы как тип содержимого, встроенный в FSB. Большинство типов аудио экспортируются в формате WAV, некоторые - в формате OGG.",
    "audio_format_force_wav": "Конвертировать в WAV",
    "audio_format_force_wav_description": "Преобразование всех аудиофайлов в файлы WAV. Не рекомендуется при импорте в Unity, так как это может привести к повторному сжатию файлов, что приведет к потере качества.",
    "audio_format_force_mp3": "Конвертировать в MP3",
    "audio_format_force_mp3_description": "Преобразование всех аудиофайлов в файлы MP3. Не рекомендуется, поскольку при этом происходит повторное сжатие файлов, что приводит к потере качества. Только для Windows.",
    "image_format_description": "Влияет на все экспортированные изображения",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Экспорт в формате Unity sprite. Невозможно просматривать за пределами Unity.",
    "sprite_format_texture": "Текстуры",
    "sprite_format_texture_description": "Экспорт в виде изображения листа спрайтов. Можно просматривать за пределами Unity, но экспортируется медленнее.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Экспорт в родной формат ландшафта Unity. Наиболее полезная опция, если вы планируете повторно импортировать в Unity.",
    "terrain_format_obj": "3D Модель (OBJ)",
    "terrain_format_obj_description": "Экспортируйте terrain как 3D-модель в формате OBJ, пригодную для просмотра в широком спектре 3D-редакторов. Экспериментальный, не имеет правильного масштабирования.",
    "terrain_format_heatmap": "Карта высот",
    "terrain_format_heatmap_description": "Экспортируйте тепловую карту высот местности в каждом месте. Действительно полезно, только если вас не волнуют детали или наличие 3D рельефа.",
    "text_asset_format_binary": "Байты",
    "text_asset_format_binary_description": "Экспортируйте необработанные байты текстового актива с расширением .bytes.",
    "text_asset_format_text": "Обычный текст",
    "text_asset_format_text_description": "Экспорт в обычный текстовый файл (.txt)",
    "text_asset_format_parse": "Анализ",
    "text_asset_format_parse_description": "Экспортируйте как обычный текстовый файл, но попытайтесь угадать правильное расширение файла (например, файлы JSON получают расширение .json)",
    "config_screen_drag_drop_prompt": "Обратите внимание, что некоторые изменения настроек могут вызвать или предотвратить ошибки.\nКак только вы будете готовы, перетащите файл/папку с игрой в это окно или воспользуйтесь меню в левом верхнем углу, чтобы открыть что-то вручную.",
    "menu_file": "Файл",
    "menu_file_open_file": "Открыть файл",
    "menu_file_open_folder": "Открыть папку",
    "menu_file_reset": "Сбросить",
    "menu_file_exit": "Выйти",
    "menu_export": "Экспорт",
    "menu_export_all": "Экспортировать все файлы",
    "menu_export_selected": "Экспортировать выбранные файлы",
    "menu_language": "Язык",
    "loading_game_content_from": "Загрузка игрового содержимого из {0}\n{1}",
    "loading_step_load_assemblies": "Загрузка Assemblies",
    "loading_step_parse_bundle": "Расшифровка пакета {0}",
    "loading_step_parse_archive": "Расшифровка архивного файла {0}",
    "loading_step_parse_web": "Расшифровка веб-файла {0}",
    "loading_step_parse_serialized": "Расшифровка сериализованного файла {0}",
    "loading_step_parse_resource": "Расшифровка файла ресурсов {0}",
    "loading_step_parse_il2cpp_metadata": "Анализ метаданных IL2CPP",
    "loading_step_generate_dummy_dll": "Генерация сборок Mono из IL2CPP",
    "loading_step_locate_key_functions": "Сканирование двоичного файла IL2CPP на наличие библиотечных функций",
    "loading_step_restore_attributes": "Восстановление атрибутов сгенерированных сборок",
    "loading_step_load_assets_from_file": "Загрузка ресурсов из {0}",
    "loading_step_detect_platform": "Сбор файлов и определение структуры игры",
    "loading_step_initialize_layout": "Инициализация макета активов",
    "loading_step_create_file_collection": "Создание коллекции файлов",
    "loading_step_begin_scheme_processing": "Начало обработки схемы",
    "loading_step_pre_processing": "Предварительная обработка файлов",
    "select_asset_to_view_info": "Выберите ресурс слева, чтобы просмотреть информацию о нем",
    "asset_tab_basic": "Основная информация",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Изображение",
    "asset_tab_text": "Текст",
    "asset_tab_audio": "Аудио",
    "asset_tab_audio_play": "Проиграть",
    "asset_tab_audio_pause": "Пауза",
    "asset_tab_audio_duration_unknown": "<Неизвестно>",
    "error": "Ошибка",
    "success": "Успех!",
    "export_complete": "Экспорт завершен!",
    "no_game_files_found": "Не найдено игр Unity или пакетов ресурс загруженный вами.",
    "export_deleting_old_files": "Очистка существующих файлов...",
    "export_preparing": "Подготовка к экспорту...\nЭто может занять минуту.",
    "export_in_progress_no_file_count_yet": "Экспортируем файлы ресурсов\n0.0%\n?/?",
    "export_in_progress": "Экспортируем файлы ресурсов\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Не удалось экспортировать содержимое игры: {0}",
    "error_importing_with_reason": "Не удалось загрузить содержимое игры: {0}",
    "loose_file_saved_at": "Свободный файл сохранен по адресу {0}",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Формат треугольника Стэнфорда. Unity не может импортировать ресурсы этого типа. Текстовый вариант.",
    "script_content_level_4_description": "Методы IL2Cpp восстанавливаются без учета безопасности.",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "Последняя версия C#",
    "c_sharp_langage_version_config_preview": "Бета-версия C#",
    "c_sharp_language_version_config_description": "Версия языка C#, которая будет использоваться при декомпиляции скриптов.",
    "ignore_asset_bundle_content_paths": "Игнорирование путей контента AssetBundle",
    "script_content_level_title": "Уровень контента скрипта",
    "script_language_version_title": "Версия языка C#",
    "script_content_level_0": "Уровень 0",
    "script_content_level_1": "Уровень 1",
    "script_content_level_2": "Уровень 2",
    "script_content_level_3": "Уровень 3",
    "script_content_level_4": "Уровень 4",
    "script_content_level_0_description": "Скрипты не экспортированы.",
    "script_content_level_1_description": "Методы удаляются из декомпилированного экспорта.",
    "script_content_level_2_description": "По умолчанию. Это экспортирует полные методы для игр Mono и пустышки для игр IL2Cpp.",
    "script_content_level_3_description": "Методы IL2Cpp безопасно восстанавливаются там, где это возможно.",
    "c_sharp_langage_version_config_9_0": "С# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "check_log_for_more_details": "Просмотрите журнал для получение подробной информаций",
    "menu_export_selected_type": "Экспортировать все файлы выбранного типа"
}

```

`Localizations/tr.json`:

```json
{
    "welcome_title": "AssetRipper'e Hoşgeldiniz",
    "config_options": "Yapılandırma Seçenekleri",
    "disable_scripts": "Komut Dosyalarını İşlemeyi Bırak",
    "skip_streaming_assets": "StreamingAssets Klasörünü Atla",
    "mesh_export_title": "Mesh Çıkarma Formatı",
    "audio_export_title": "Ses Çıkartma Formatı",
    "image_export_title": "Resim Çıkartma Formatı",
    "sprite_export_title": "Sprite Çıkartma Formatı",
    "terrain_export_title": "Arazi (Terrain) Çıkartma Formatı",
    "text_asset_export_title": "Metin Varlığı Çıkartma Formatı",
    "mesh_format_native": "Yerleşik",
    "mesh_format_native_description": "Yerleşik düzenleyicide ağları kullanmak için sağlam bir biçim. Çeşitli birlik paketleri tarafından diğer biçimlere dönüştürülebilir.",
    "mesh_format_obj": "OBJ Formatı",
    "mesh_format_obj_description": "Yaygın olarak kullanılan metin tabanlı biçimdir, neredeyse tüm 3d düzenleme yazılımlarında kullanılabilir. Ancak bu, ağ varlığına dışa aktarılan referansları bozar.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "3 Boyutlu yazdırma için yaygın olarak kullanılan 3 Boyutlu nesne formatı. Unity bu tür varlıkları içe aktaramaz. Metin tabanlı varyant.",
    "mesh_format_stl_binary": "STL (İkili Sistem)",
    "mesh_format_stl_binary_description": "3 Boyutlu yazdırma için yaygın olarak kullanılan 3 Boyutlu nesne formatı. Unity bu tür varlıkları içe aktaramaz. İkili Sistem değişkeni (Binary).",
    "mesh_format_glb_primitive": "Basit GLB (*GLB bir 3 Boyutlu modellerin ikili dosya formatı temsilidir.)",
    "mesh_format_glb_primitive_description": "FBX'e yüksek kaliteli, açık kaynaklı bir alternatif. GLTF'nin ikili versiyonu. Yalnızca ağ verilerini içerir. Hatalara neden olabilir. Unity bu tür varlıkları içe aktaramaz.",
    "mesh_format_fbx_primitive": "Basit FBX (*Sıkıştırma işlemi yapılamayan basit yapılı FBX Formatı.)",
    "mesh_format_fbx_primitive_description": "Unity dahil neredeyse tüm 3 Boyutlu düzenleme yazılımlarında kullanılabilen endüstri standartı olan format. Yalnızca mesh verilerini içerir. Bu, mesh varlığı dışa aktarma referanslarını bozar.",
    "audio_format_native": "Raw",
    "audio_format_native_description": "Ham FSB Ses. Unity'ye aktarılamaz, bu nedenle bunu yalnızca ileri düzey bir kullanıcıysanız kullanın.",
    "audio_format_default": "Varsayılan",
    "audio_format_default_description": "Varlıkları FSB'ye gömülü içerik türü olarak dışa aktarın. Çoğu ses türü WAV olarak dışa aktarılır, bazıları OGG olarak dışa aktarılır.",
    "audio_format_force_wav": "WAV Dosyasına Çevir",
    "audio_format_force_wav_description": "Tüm ses dosyalarını WAV dosyalarına dönüştürün. Dosyaları yeniden sıkıştırarak kalite kaybına neden olabileceğinden, birliğe içe aktarılıyorsa önerilmez.",
    "audio_format_force_mp3": "MP3 Dosyasına Çevir",
    "audio_format_force_mp3_description": "Tüm ses dosyalarını MP3 dosyalarına dönüştürün. Dosyaları yeniden sıkıştırarak kalite kaybına neden olacağı için önerilmez. Yalnızca Windows.",
    "image_format_description": "Dışa aktarılan tüm görüntüleri etkiler",
    "sprite_format_native": "Birlik",
    "sprite_format_native_description": "Unity hareketli grafik biçiminde dışa aktarın. Birlik (*Unity) dışında görülemez.",
    "sprite_format_texture": "Doku",
    "sprite_format_texture_description": "Model Sayfasının bir görüntüsü olarak dışa aktarın. Birlik (*Unity) dışında görüntülenebilir, ancak dışa aktarma işlemi daha yavaştır.",
    "terrain_format_native": "Birlik",
    "terrain_format_native_description": "Yerel birlik (*Unity) arazi biçiminde dışa aktarın. Birliğe (*Unity'ye) yeniden aktarmayı planlıyorsanız en kullanışlı seçenektir.",
    "terrain_format_obj": "3 Boyutlu Model (OBJ)",
    "terrain_format_obj_description": "Araziyi, çok çeşitli 3 Boyutlu düzenleyicilerle görüntülemeye uygun, OBJ formatında bir 3 Boyutlu model olarak dışa aktarın. Deneysel; doğru ölçeklendirmeye sahip değil.",
    "terrain_format_heatmap": "Yükseklik Haritası (*Heightmap)",
    "terrain_format_heatmap_description": "Her konumdaki arazinin yüksekliğinin bir ısı haritasını dışa aktarın. Yalnızca ayrıntıları önemsemiyorsanız veya arazinin 3 boyutlu olması gerçekten yararlıdır.",
    "text_asset_format_binary": "Bayt (*Bytes)",
    "text_asset_format_binary_description": "Metin varlığının raw baytlarını .bytes uzantısıyla dışa aktarın.",
    "text_asset_format_text": "Düz Metin (*Plain Text)",
    "text_asset_format_text_description": "Düz metin dosyası (.txt) olarak dışa aktarın",
    "text_asset_format_parse": "Ayrıştırma (*Parse)",
    "text_asset_format_parse_description": "Düz metin dosyası olarak dışa aktarın, ancak doğru dosya uzantısını tahmin etmeye çalışın (ör. JSON dosyaları .json uzantısını alır)",
    "config_screen_drag_drop_prompt": "Bazı ayar değişikliklerinin hatalara neden olabileceğini veya hataları önleyebileceğini lütfen unutmayın.\nHazır olduğunuzda, oyun dosyanızı/klasörünüzü bu pencereye sürükleyip bırakın veya bir şeyi manuel olarak açmak için sol üstteki menüyü kullanın.",
    "menu_file": "Dosya",
    "menu_file_open_file": "Dosya Aç",
    "menu_file_open_folder": "Klasör Aç",
    "menu_file_reset": "Sıfırla",
    "menu_file_exit": "Çık",
    "menu_export": "Dışa aktar",
    "menu_export_all": "Tüm dosyaları dışa aktar",
    "menu_export_selected": "Seçili Dosyayı Dışa Aktar",
    "menu_language": "Dil",
    "loading_game_content_from": "{0} Tarafından Oyun İçeriği Yükleniyor\n{1}",
    "loading_step_load_assemblies": "Montajları Yükleme",
    "loading_step_parse_bundle": "Paket Ayrıştırma {0}",
    "loading_step_parse_archive": "{0} Arşiv Dosyası ayrıştırılıyor",
    "loading_step_parse_web": "{0} Web Dosyasını Ayrıştırma",
    "loading_step_parse_serialized": "Serileştirilmiş Dosya {0} Ayrıştırma",
    "loading_step_parse_resource": "Kaynak Dosyasını Ayrıştırma {0}",
    "loading_step_parse_il2cpp_metadata": "IL2CPP Meta Verilerini Ayrıştırma",
    "loading_step_generate_dummy_dll": "IL2CPP'den Mono Montajları Oluşturma",
    "loading_step_locate_key_functions": "Kitaplık İşlevleri için IL2CPP İkili Dosyasını Tarama",
    "loading_step_restore_attributes": "Oluşturulan Derlemelerdeki Nitelikleri Geri Yükleme",
    "loading_step_load_assets_from_file": "{0} öğesinden Öğeler yükleniyor",
    "loading_step_detect_platform": "Dosyaları Toplama ve Oyun Yapısını Tespit Etme",
    "loading_step_initialize_layout": "Varlık Düzenini Başlatma",
    "loading_step_create_file_collection": "Dosya Koleksiyonu Oluşturma",
    "loading_step_begin_scheme_processing": "Şema İşlemeyi Başlatma",
    "loading_step_pre_processing": "Ön İşleme Dosyaları",
    "select_asset_to_view_info": "Hakkında bilgileri görüntülemek için soldan bir Varlık seçin",
    "asset_tab_basic": "Temel Bilgiler",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Resim",
    "asset_tab_text": "Metin",
    "asset_tab_audio": "Ses",
    "asset_tab_audio_play": "Oyna",
    "asset_tab_audio_pause": "Durdur",
    "asset_tab_audio_duration_unknown": "<Bilinmeyen>",
    "error": "Hata",
    "success": "Başarılı!",
    "export_complete": "Dışa aktarma tamamlandı!",
    "no_game_files_found": "Bırakılan dosyalarda Unity oyunu veya varlık paketi bulunamadı.",
    "export_deleting_old_files": "Mevcut dosyalar temizleniyor...",
    "export_preparing": "İhracata Hazırlanıyor...\nBu bir dakika sürebilir.",
    "export_in_progress_no_file_count_yet": "Varlık Dosyalarını Dışa Aktarma\n%0.0\n?/?",
    "export_in_progress": "Varlık Dosyalarını Dışa Aktarma\n%{0}\n{1}/{2}",
    "error_exporting_with_reason": "Oyun içeriği dışa aktarılamadı: {0}",
    "error_importing_with_reason": "Oyun içeriği yüklenemedi: {0}",
    "loose_file_saved_at": "{0} konumunda gevşek dosya kaydedildi",
    "mesh_format_ply_ascii_description": "Stanford Üçgen Biçimi. Unity bu tür varlıkları içe aktaramaz. Metin tabanlı varyant.",
    "c_sharp_langage_version_config_auto_safe": "Otomatik - Güvenli",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_language_version_config_description": "Komut dosyalarının derlenmesi sırasında kullanılacak C# dil sürümü.",
    "ignore_asset_bundle_content_paths": "Varlık Paketi içerik yollarını yoksay",
    "script_content_level_title": "Komut Dosyası İçerik Kalite Düzeyi",
    "script_language_version_title": "C# Dil Sürümü",
    "script_content_level_0": "Seviye 0",
    "script_content_level_1": "Seviye 1",
    "script_content_level_2": "Seviye 2",
    "script_content_level_3": "Seviye 3",
    "script_content_level_4": "Seviye 4",
    "script_content_level_0_description": "Komut dosyaları dışa aktarılmaz.",
    "menu_export_selected_type": "Seçili Türdeki Tüm Dosyaları Dışa Aktar",
    "check_log_for_more_details": "Daha fazla ayrıntı için günlüğü kontrol edin",
    "script_content_level_1_description": "Yöntemler, geri derlenmiş dışa aktarmadan çıkarılır.",
    "script_content_level_2_description": "Varsayılan. Bu, Mono oyunları için tam yöntemleri ve IL2Cpp oyunları için sahte yöntemleri dışa aktarır.",
    "script_content_level_3_description": "IL2Cpp yöntemleri, mümkün olduğunda güvenli bir şekilde kurtarılır.",
    "script_content_level_4_description": "IL2Cpp yöntemleri, güvenlikten bağımsız olarak kurtarılır.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "C# Son Sürüm",
    "c_sharp_langage_version_config_auto_experimental": "Otomatik - Deneysel",
    "script_export_title": "Komut Dosyası Çıkarma Formatı",
    "script_export_format_dll_without_renaming_description": "Assemblies derlenmiş Dll biçiminde dışa aktarılır.Deneysel özellik. Çalışacağı garanti edilmez.",
    "script_export_format_dll_with_renaming": "Dll yeniden isimlendirerek çıkart",
    "script_export_format_dll_without_renaming": "Dll yeniden isimlendirmeden çıkart"
}

```

`Localizations/uk.json`:

```json
{
    "welcome_title": "Ласкаво просимо до AssetRipper",
    "config_options": "Налаштування",
    "bundled_assets_export_title": "Режим експорту Bundled Assets",
    "skip_streaming_assets": "Пропускати папку StreamingAssets",
    "mesh_export_title": "Формат експорту Mesh",
    "audio_export_title": "Формат експорту аудіо",
    "image_export_title": "Формат експорту картинок",
    "sprite_export_title": "Формат експорту спрайтів",
    "terrain_export_title": "Формат експорту Terrain",
    "text_asset_export_title": "Формат експорту тексту",
    "shader_asset_export_title": "Формат експорту шейдерів",
    "script_export_title": "Формат експорту скриптів",
    "script_content_level_title": "Рівень вмісту скрипту",
    "script_language_version_title": "Версія мови C#",
    "bundled_assets_export_group_by_asset_type": "Групувати за типом асета",
    "bundled_assets_export_group_by_asset_type_description": "Bundled assets обробляються так само як і ресурси з інших файлів.",
    "bundled_assets_export_group_by_bundle_name": "Групувати за назвою пакета",
    "bundled_assets_export_group_by_bundle_name_description": "Bundled assets груповано за назвами групи об’єктів.",
    "bundled_assets_export_direct_export": "Прямий експорт",
    "bundled_assets_export_direct_export_description": "Bundled assets експортуються без групування.",
    "mesh_format_native": "Рідний",
    "mesh_format_native_description": "Надійний формат для використання Mesh у редакторі. Може бути перетворений на інші формати розпізнаванні пакетами Unity.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "Широко поширений текстовий формат, який використовується майже у всіх редакторів 3d графіки. Однак це руйнує експортовані посилання на асети Mesh.",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "Формат 3D-об'єктів, який зазвичай використовується для 3D-друку. Unity не може імпортувати активи цього типу. Текстовий варіант.",
    "mesh_format_stl_binary": "STL (Двійковий)",
    "mesh_format_stl_binary_description": "Формат 3D-об'єктів, який зазвичай використовується для 3D-друку. Unity не може імпортувати асет цього типу. Бінарний варіант.",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Формат трикутника Стенфорда. Unity не може імпортувати ресурси цього типу. Текстовий варіант.",
    "mesh_format_glb_primitive": "Простий GLB",
    "mesh_format_glb_primitive_description": "Високоякісна альтернатива FBX з відкритим кодом. Бінарна версія GLTF. Містить лише дані Mesh. Може викликати помилки. Unity не може імпортувати активи цього типу.",
    "mesh_format_fbx_primitive": "Простий FBX",
    "mesh_format_fbx_primitive_description": "Формат промислового стандарту, який можна використовувати майже в усіх програмах для 3D-редагування, включаючи Unity. Містить лише дані Mesh. Це порушує експортовані посилання на асети Mesh.",
    "audio_format_yaml": "Yaml",
    "audio_format_yaml_description": "Експорт як ресурс yaml і файл resS. Це безпечний і резервний варіант, коли щось піде не так.",
    "audio_format_native": "Сирий",
    "audio_format_native_description": "Необроблений FSB Audio. Неможливо імпортувати в Unity, тому використовуйте це, лише якщо ви досвідчений користувач.",
    "audio_format_default": "За замовчуванням",
    "audio_format_default_description": "Експорт ресурсів як типу вмісту, вбудованого в FSB. Більшість типів аудіо експортується як WAV, деякі експортуються як OGG.",
    "audio_format_force_wav": "Конвертувати у WAV",
    "audio_format_force_wav_description": "Конвертувати усі аудіофайли у файли WAV. Не рекомендується, якщо імпортувати в unity, оскільки це може повторно стиснути файли, спричинивши втрату якості.",
    "audio_format_force_mp3": "Конвертувати у MP3",
    "audio_format_force_mp3_description": "Конвертує усі аудіофайли у файли MP3. Не рекомендовано, оскільки це призведе до повторного стискання файлів, спричиняючи втрату якості. Тільки Windows.",
    "image_format_description": "Впливає на всі експортовані зображення",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "Експорт у спрайти які підтримує Unity. Не можна переглядати за межами Unity.",
    "sprite_format_texture": "Текстура",
    "sprite_format_texture_description": "Експортується як зображення аркуша спрайтів. Можна переглядати за межами Unity, але повільніше експортувати.",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "Експорт у рідному форматі Unity Terrain. Найкорисніший варіант, якщо ви плануєте повторно імпортувати в Unity.",
    "terrain_format_obj": "3D Модель (OBJ)",
    "terrain_format_obj_description": "Експорт 3D-моделі Terrain у форматі OBJ, придатний для перегляду за допомогою широкого спектра 3D-редакторів. Експериментальний; не має правильного масштабування.",
    "terrain_format_heatmap": "Карта висот",
    "terrain_format_heatmap_description": "Експорт теплової карти висоти Terrain в кожному місці. Справді корисно, лише якщо вас не цікавлять деталі чи рельєф у 3D.",
    "text_asset_format_binary": "Байти",
    "text_asset_format_binary_description": "Експорт необроблених байтів текстового ресурсу з розширенням .bytes.",
    "text_asset_format_text": "Простий текст",
    "text_asset_format_text_description": "Експорт як звичайний текстовий файл (.txt)",
    "text_asset_format_parse": "Аналіз",
    "text_asset_format_parse_description": "Експорт як звичайний текстовий файл, але пробує вгадати правильне розширення файлу (наприклад, файли JSON отримують розширення .json)",
    "shader_asset_format_dummy": "Фіктивний шейдер",
    "shader_asset_format_dummy_description": "Експорте шейдера як фіктивний шейдер. Попри те, що він зберігає такі дані, як властивості та FallBack, він використовує загальний, непрозорий код шейдера.",
    "shader_asset_format_yaml": "Yaml асет",
    "shader_asset_format_yaml_description": "Експортуй шейдера як асет yaml. Експериментальний і придатний лише для перегляду в редакторі. Редактор може довільно пошкодити ці файли.",
    "shader_asset_format_disassembly": "Disassembly",
    "shader_asset_format_disassembly_description": "Експорт шейдерів як Disassembly. Експериментальний і схильний до поломок. Не компілюється в редакторі.",
    "script_export_format_decompiled": "Декомпільований",
    "script_export_format_decompiled_description": "Декомпілятор ILSpy використовується для створення CS скриптів. Це надійно. Однак це також займає багато часу та містить багато помилок компіляції.",
    "script_export_format_hybrid": "Гібрид",
    "script_export_format_dll_with_renaming": "Експорт Dll з перейменуванням",
    "script_export_format_dll_without_renaming": "Експорт Dll без перейменування",
    "script_export_format_dll_without_renaming_description": "Збірки експортуються у скомпільованій формі DLL. Експериментальний. Може взагалі не працювати.",
    "script_content_level_0": "Рівень 0",
    "script_content_level_1": "Рівень 1",
    "script_content_level_2": "Рівень 2",
    "script_content_level_3": "Рівень 3",
    "script_content_level_4": "Рівень 4",
    "script_content_level_0_description": "Скрипти не експортуються.",
    "script_content_level_1_description": "Методи видаляються з декомпільованого експорту.",
    "script_content_level_2_description": "За замовчуванням. Це експортує повні методи для ігор Mono та фіктивні методи для ігор IL2Cpp.",
    "script_content_level_3_description": "Методи IL2Cpp безпечно відновлюються, де це можливо.",
    "script_content_level_4_description": "Методи IL2Cpp відновлюються не дивлячись на небезпеку.",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_11_0": "C# 11",
    "c_sharp_langage_version_config_latest": "Остання версія C#",
    "c_sharp_langage_version_config_auto_safe": "Автоматично - безпечно",
    "c_sharp_langage_version_config_auto_experimental": "Автоматичний - Експериментальний",
    "c_sharp_language_version_config_description": "Версія мови C# для використання під час декомпіляції сценаріїв.",
    "config_screen_drag_drop_prompt": "Зауважте, що деякі зміни налаштувань можуть спричинити або запобігти помилкам.\nКоли ви будете готові, перетягніть файл/папку вашої гри в це вікно або скористайтеся меню у верхньому лівому куті, щоб відкрити щось вручну.",
    "menu_file": "Файл",
    "menu_file_open_file": "Відкрити файл",
    "menu_file_open_folder": "Відкрити папку",
    "menu_file_reset": "Скинути",
    "menu_file_exit": "Вихід",
    "menu_export": "Експорт",
    "menu_export_all": "Експортувати всі файли",
    "menu_export_selected": "Експортувати вибрані файли",
    "menu_export_selected_type": "Експортувати всі файли вибраного типу",
    "menu_language": "Мова",
    "loading_game_content_from": "Завантаження ігрового вмісту з {0}\n{1}",
    "loading_step_load_assemblies": "Завантаження Assemblies",
    "loading_step_parse_bundle": "Розшифровка пакета {0}",
    "loading_step_parse_archive": "Розшифровка архівного файлу {0}",
    "loading_step_parse_web": "Розшифровка Веб-файлу {0}",
    "loading_step_parse_serialized": "Розшифровка серіалізованого файлу {0}",
    "loading_step_parse_resource": "Розшифровка файлу ресурсів {0}",
    "loading_step_parse_il2cpp_metadata": "Аналіз метаданих IL2CPP",
    "loading_step_generate_dummy_dll": "Генерація збірок Mono з IL2CPP",
    "loading_step_locate_key_functions": "Сканування двійкового файлу IL2CPP на наявність бібліотечних функцій",
    "loading_step_restore_attributes": "Відновлення атрибутів згенерованих збірок",
    "loading_step_load_assets_from_file": "Завантаження Асетів із {0}",
    "loading_step_detect_platform": "Збір файлів і визначення структури гри",
    "loading_step_initialize_layout": "Ініціалізація макета асета",
    "loading_step_create_file_collection": "Створення колекції файлів",
    "loading_step_begin_scheme_processing": "Початок обробки схеми",
    "loading_step_pre_processing": "Попередня обробка файлів",
    "select_asset_to_view_info": "Виберіть асет ліворуч, щоб переглянути інформацію про нього",
    "asset_tab_basic": "Основна інформація",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "Зображення",
    "asset_tab_text": "Текст",
    "asset_tab_audio": "Аудіо",
    "asset_tab_audio_play": "Грати",
    "asset_tab_audio_pause": "Пауза",
    "asset_tab_audio_duration_unknown": "<Невідомо>",
    "error": "Помилка",
    "success": "Успіх!",
    "export_complete": "Експорт завершено!",
    "no_game_files_found": "Не знайдено Unity ігор або асетів, у файлах завантажені вами.",
    "export_deleting_old_files": "Очищення існуючих файлів...",
    "export_preparing": "Підготовка до експорту...\nЦе може зайняти хвилину.",
    "export_in_progress_no_file_count_yet": "Експорт асетів\n0,0%\n?/?",
    "export_in_progress": "Експорт асетів\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "Не вдалося експортувати вміст гри: {0}",
    "error_importing_with_reason": "Не вдалося завантажити вміст гри: {0}",
    "check_log_for_more_details": "Щоб дізнатися більше, перевірте журнал",
    "loose_file_saved_at": "Відсутній файл збережено в {0}",
    "not_implemented_yet": "Ще не реалізовано"
}

```

`Localizations/zh_Hans.json`:

```json
{
    "welcome_title": "欢迎使用 AssetRipper",
    "config_options": "配置选项",
    "disable_scripts": "禁用脚本处理",
    "skip_streaming_assets": "跳过 StreamingAssets 文件夹",
    "mesh_export_title": "网格导出格式",
    "audio_export_title": "音频导出格式",
    "image_export_title": "图像导出格式",
    "sprite_export_title": "Sprite 导出格式",
    "terrain_export_title": "地形导出格式",
    "text_asset_export_title": "TextAsset 导出格式",
    "mesh_format_native": "原生格式",
    "mesh_format_native_description": "在Unity编辑器中使用的网格格式. 可以通过多种unity packages转换成其他格式.",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "广泛使用的基于文本的网格格式，可在几乎所有3D编辑软件中使用。但是，这会断开网格资源的导出引用。",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "3D 打印常用的 3D 对象格式。 Unity 无法导入此类资源或者文本变体。",
    "mesh_format_stl_binary": "STL (二进制文件)",
    "mesh_format_stl_binary_description": "3D 打印常用的 3D 对象格式。 Unity 无法导入这种类型的资源以及 二进制变体。",
    "mesh_format_glb_primitive": "GLB文件",
    "mesh_format_glb_primitive_description": "FBX 的高质量开源替代品。 GLTF 的二进制版本。 仅包含网格数据。 可能会出错。 Unity 无法导入这种资源。",
    "audio_format_native": "Raw原生格式",
    "audio_format_native_description": "原始FSB音频。无法导入到Unity中，仅建议高级用户使用。",
    "audio_format_default": "默认",
    "audio_format_default_description": "将资源导出为嵌入在FSB中的内容类型。大多数音频类型都导出为wav，有些导出为ogg。",
    "audio_format_force_wav": "转换为 WAV",
    "audio_format_force_wav_description": "将所有音频文件转换为 WAV 文件。 不推荐导入unity，因为它可能会重新压缩文件，导致质量损失。",
    "audio_format_force_mp3": "转换为 MP3",
    "audio_format_force_mp3_description": "将所有音频文件转换为 MP3 文件。 不推荐，因为它会重新压缩文件，导致质量下降。 仅限 Windows。",
    "image_format_description": "影响所有导出的图像",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "以Unity Sprite 格式导出。 无法在 Unity 之外查看。",
    "sprite_format_texture": "纹理",
    "sprite_format_texture_description": "导出为 Sprite Sheet 的图像。 可以在 Unity 之外查看，但导出速度较慢。",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "以原生Unity地形格式导出。 如果您打算重新导入到Unity，这是最有用的选项。",
    "terrain_format_obj": "3D模型（OBJ文件）",
    "terrain_format_obj_description": "将地形导出为 OBJ 格式的 3D 模型，适合使用各种 3D 编辑器查看。 实验性功能； 模型没有正确的缩放。",
    "terrain_format_heatmap": "高度图",
    "terrain_format_heatmap_description": "导出每个位置地形高度的热图。 只有在您不关心细节或 3D 地形时才真正有用。",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "使用 .bytes 扩展名导出TextAsset的原始二进制数据。",
    "text_asset_format_text": "纯文本",
    "text_asset_format_text_description": "导出为纯文本文件 (.txt)",
    "text_asset_format_parse": "解析",
    "text_asset_format_parse_description": "导出为纯文本文件，将尝试猜测正确的文件扩展名(例如 JSON 文件将使用 .json 扩展名)",
    "config_screen_drag_drop_prompt": "请注意，某些设置更改可能会产生或导致错误.\n准备好后，将你的游戏文件/文件夹拖放到此窗口中，或使用左上角的菜单手动打开它们。",
    "menu_file": "文件",
    "menu_file_open_file": "打开文件",
    "menu_file_open_folder": "打开目录",
    "menu_file_reset": "重置",
    "menu_file_exit": "关闭",
    "menu_export": "导出",
    "menu_export_all": "导出所有文件",
    "menu_export_selected": "导出选中文件",
    "menu_language": "语言",
    "loading_game_content_from": "从 {0} \n{1}载入游戏内容",
    "loading_step_load_assemblies": "加载程序集",
    "loading_step_parse_bundle": "解析Bundle资源 {0}",
    "loading_step_parse_archive": "解析存档文件 {0}",
    "loading_step_parse_web": "解析网页文件 {0}",
    "loading_step_parse_serialized": "解析序列化文件 {0}",
    "loading_step_parse_resource": "解析资源文件 {0}",
    "loading_step_parse_il2cpp_metadata": "解析 IL2CPP 元数据",
    "loading_step_generate_dummy_dll": "从 IL2CPP 生成 Mono 程序集",
    "loading_step_locate_key_functions": "扫描库函数的 IL2CPP 二进制文件",
    "loading_step_restore_attributes": "恢复生成的程序集的属性",
    "loading_step_load_assets_from_file": "从 {0} 加载资源",
    "loading_step_detect_platform": "检索文件检测游戏结构",
    "loading_step_initialize_layout": "初始化资源布局",
    "loading_step_create_file_collection": "创建文件集合",
    "loading_step_begin_scheme_processing": "开始处理方案",
    "loading_step_pre_processing": "预处理文件",
    "select_asset_to_view_info": "请在左侧选择资源以显示有关它的信息",
    "asset_tab_basic": "基本信息",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "图像",
    "asset_tab_text": "文本",
    "asset_tab_audio": "音频",
    "asset_tab_audio_play": "播放",
    "asset_tab_audio_pause": "暂停",
    "asset_tab_audio_duration_unknown": "<未知>",
    "error": "错误",
    "success": "成功！",
    "export_complete": "导出成功！",
    "no_game_files_found": "在导入的文件中未找到Unity游戏文件或Asset Bundle。",
    "export_deleting_old_files": "清除现有文件中...",
    "export_preparing": "正在准备导出...\n这可能需要几分钟。",
    "export_in_progress_no_file_count_yet": "正在导出资源文件\n0.0%\n?/?",
    "export_in_progress": "正在导出资源文件\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "导出游戏内容失败: {0}",
    "error_importing_with_reason": "加载游s戏内容失败: {0}",
    "loose_file_saved_at": "文件已保存至 {0}",
    "mesh_format_fbx_primitive_description": "适用于几乎所有3D编辑软件的行业标准格式，包括Unity。因为文件只包含网格数据，所以这会破坏对网格资源的导出引用。",
    "mesh_format_fbx_primitive": "FBX文件",
    "script_content_level_2_description": "默认。这会导出 Mono 游戏的完整方法和 IL2Cpp 游戏的虚拟方法。",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_7": "C# 7",
    "script_content_level_title": "脚本解析等级",
    "script_language_version_title": "C#语言版本",
    "script_content_level_0": "0级",
    "script_content_level_2": "2级",
    "script_content_level_3": "3级",
    "script_content_level_4": "4级",
    "script_content_level_0_description": "脚本没有被导出。",
    "script_content_level_1_description": "方法从反编译导出中剥离。",
    "script_content_level_3_description": "尽可能安全地恢复 IL2Cpp 函数。",
    "script_content_level_4_description": "在不考虑安全性的情况下恢复 IL2Cpp 方法。",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "ignore_asset_bundle_content_paths": "忽略AssetBundle包内容路径",
    "script_content_level_1": "1级",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "menu_export_selected_type": "导出所选类型的所有文件",
    "check_log_for_more_details": "查看日志以获取更多详细信息",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "Stanford Triangle Format格式。 Unity 无法导入此类资源。基于文本的变体。",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_language_version_config_description": "反编译脚本时要使用的 C# 语言版本。",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_latest": "C# 最新版",
    "c_sharp_langage_version_config_auto_safe": "自动 - 安全",
    "c_sharp_langage_version_config_auto_experimental": "自动 - 实验性",
    "shader_asset_export_title": "Shader 导出格式",
    "shader_asset_format_dummy_description": "将Shader导出为Dummy Shader。 只保留了 Properties 和 FallBack 之类的数据，它使用了通用的、不透明的Shader代码。",
    "script_export_format_decompiled_description": "ILSpy 反编译器用于反编译生成 C# 源码。 这是一个可靠的方式 ，但同时非常耗时并且可能会包含许多编译错误。",
    "script_export_title": "脚本导出格式",
    "shader_asset_format_dummy": "Dummy Shader(生成模板Shader)",
    "shader_asset_format_yaml": "Yaml 资源",
    "shader_asset_format_yaml_description": "将Shader导出为 yaml 资源。 实验性功能，仅可用于在Unity Editor中查看。 Editor可以随意破坏这些文件。",
    "shader_asset_format_disassembly": "反汇编",
    "shader_asset_format_disassembly_description": "将Shader反编译并导出。 实验性功能，容易损坏Shader。 这不会在Unity Editor中编译。",
    "script_export_format_decompiled": "反编译",
    "script_export_format_dll_with_renaming": "导出重命名后的Dll",
    "script_export_format_dll_without_renaming": "导出未重命名的Dll",
    "script_export_format_dll_without_renaming_description": "程序集以编译的 Dll 形式导出。 实验性功能，可能完全不起作用。",
    "script_export_format_hybrid": "Hybrid",
    "not_implemented_yet": "尚未实现"
}

```

`Localizations/zh_Hant.json`:

```json
{
    "welcome_title": "歡迎使用 AssetRipper",
    "config_options": "設定選項",
    "ignore_asset_bundle_content_paths": "略過 AssetBundle 的內容路徑",
    "skip_streaming_assets": "略過 StreamingAssets 資料夾",
    "mesh_export_title": "Mesh 匯出格式",
    "audio_export_title": "音訊匯出格式",
    "image_export_title": "圖像匯出格式",
    "sprite_export_title": "Sprite 匯出格式",
    "terrain_export_title": "Terrain 匯出格式",
    "text_asset_export_title": "TextAsset 匯出格式",
    "shader_asset_export_title": "Shader 匯出格式",
    "script_export_title": "指令碼匯出格式",
    "script_content_level_title": "指令碼內容層級",
    "script_language_version_title": "C# 語言版本",
    "mesh_format_native": "原生格式",
    "mesh_format_native_description": "在編輯器中使用的強大格式。能夠透過各種 Unity 套件轉換成其他格式。",
    "mesh_format_obj": "OBJ",
    "mesh_format_obj_description": "廣泛運用的文字型格式，可用在幾乎所有的 3D 編輯軟體。但是，這會破壞 Mesh 資源的匯出參考。",
    "mesh_format_stl_ascii": "STL (ASCII)",
    "mesh_format_stl_ascii_description": "3D 物件格式，一般用於 3D 列印。Unity 無法匯入此類型的資源。文字格式。",
    "mesh_format_stl_binary": "STL (二進位)",
    "mesh_format_stl_binary_description": "3D 物件格式，一般用於 3D 列印。Unity 無法匯入此類型的資源。二進位格式。",
    "mesh_format_ply_ascii": "PLY (ASCII)",
    "mesh_format_ply_ascii_description": "史丹佛三角形檔案。Unity 無法匯入此類型的資源。文字格式。",
    "mesh_format_glb_primitive": "簡單 GLB",
    "mesh_format_glb_primitive_description": "FBX 的高品質開放原始碼替代方案。glTF 的二進位格式。只包含 Mesh 資料。可能會造成錯誤。Unity 無法匯入此類型的資源。",
    "mesh_format_fbx_primitive": "簡單 FBX",
    "mesh_format_fbx_primitive_description": "符合業界標準格式，可用在幾乎所有的 3D 編輯軟體（包括 Unity）。只包含 Mesh 資料。這會破壞 Mesh 資產的匯出參考。",
    "audio_format_native": "原始 (Raw)",
    "audio_format_native_description": "未經處理的 FSB 音訊。無法匯入 Unity 中，所以只有進階使用者才可以使用。",
    "audio_format_default": "預設",
    "audio_format_default_description": "將資源匯出為嵌入 FSB 的內容類型。大部分音訊類型匯出為 WAV，部分匯出為 OGG。",
    "audio_format_force_wav": "轉換成 WAV",
    "audio_format_force_wav_description": "將所有音訊檔轉換為 WAV 檔案。不建議在匯入 Unity 時使用，以避免重新壓縮造成品質損失。",
    "audio_format_force_mp3": "轉換成 MP3",
    "audio_format_force_mp3_description": "將所有音訊檔轉換為 MP3 檔案。不建議使用，因為會重新壓縮造成品質損失。僅適用於 Windows。",
    "image_format_description": "影響所有匯出的圖像",
    "sprite_format_native": "Unity",
    "sprite_format_native_description": "匯出為 Unity Sprite 格式。不能在 Unity 外檢視。",
    "sprite_format_texture": "紋理",
    "sprite_format_texture_description": "匯出為 Sprite Sheet 的圖像。可以在 Unity 外檢視，但匯出速度更慢。",
    "terrain_format_native": "Unity",
    "terrain_format_native_description": "匯出為原生的 Unity Terrain。如果您計劃重新匯入 Unity，此選項最適合使用。",
    "terrain_format_obj": "3D 模型 (OBJ)",
    "terrain_format_obj_description": "匯出 Terrain 為 OBJ 格式的 3D 模型，廣泛適用於多種 3D 編輯器。實驗性，縮放比例不正確。",
    "terrain_format_heatmap": "高度圖 (Heightmap)",
    "terrain_format_heatmap_description": "依據每個位置地勢的高度匯出高度圖。只在您有 3D 地勢或不關心細節時，才會非常有用。",
    "text_asset_format_binary": "Bytes",
    "text_asset_format_binary_description": "將文字資源匯出為具有 .bytes 副檔名的原始檔案。",
    "text_asset_format_text": "純文字",
    "text_asset_format_text_description": "匯出純文字檔案 (.txt)",
    "text_asset_format_parse": "剖析 (Parse)",
    "text_asset_format_parse_description": "以純文字格式匯出，同時嘗試推測這個檔案的副檔名。（例如：JSON 檔案取得 .json 副檔名）",
    "shader_asset_format_dummy": "虛擬 Shader",
    "shader_asset_format_dummy_description": "以虛擬 Shader 匯出 Shader。雖然如 Properties 和 FallBack 等資料能夠保留，但它使用了不透明的通用 Shader Code。",
    "shader_asset_format_yaml": "Yaml 資源",
    "shader_asset_format_yaml_description": "將 Shader 匯出為 Yaml 資源。實驗性，只可用在編輯器中檢視，編輯器可能隨機損毀這些檔案。",
    "shader_asset_format_disassembly": "反組譯碼 (Disassembly)",
    "shader_asset_format_disassembly_description": "將 Shader 匯出為反組譯碼資源。實驗性，容易造成 Shader 損毀。不會在編輯器中編譯。",
    "script_export_format_decompiled": "反編譯 (Decompiled)",
    "script_export_format_decompiled_description": "用 ILSpy 反編譯器產生 C# 指令碼。很可靠，但非常耗時，而且會包含很多編譯錯誤。",
    "script_export_format_hybrid": "混合 (Hybrid)",
    "script_export_format_dll_with_renaming": "重新命名的 DLL",
    "script_export_format_dll_without_renaming": "不重新命名的 DLL",
    "script_export_format_dll_without_renaming_description": "匯出組件資訊為編譯的 DLL 形式。實驗性，可能根本無法進行作業。",
    "script_content_level_0": "層級 0",
    "script_content_level_1": "層級 1",
    "script_content_level_2": "層級 2",
    "script_content_level_3": "層級 3",
    "script_content_level_4": "層級 4",
    "script_content_level_0_description": "不會匯出指令碼。",
    "script_content_level_1_description": "從匯出的反編譯碼中移除方法。",
    "script_content_level_2_description": "預設。匯出 Mono 遊戲中的完整方法和 IL2CPP 遊戲中的虛擬方法。",
    "script_content_level_3_description": "盡可能安全的復原 IL2CPP 方法。",
    "script_content_level_4_description": "復原 IL2CPP 方法而不考慮安全性。",
    "c_sharp_langage_version_config_1": "C# 1",
    "c_sharp_langage_version_config_2": "C# 2",
    "c_sharp_langage_version_config_3": "C# 3",
    "c_sharp_langage_version_config_4": "C# 4",
    "c_sharp_langage_version_config_5": "C# 5",
    "c_sharp_langage_version_config_6": "C# 6",
    "c_sharp_langage_version_config_7": "C# 7",
    "c_sharp_langage_version_config_7_1": "C# 7.1",
    "c_sharp_langage_version_config_7_2": "C# 7.2",
    "c_sharp_langage_version_config_7_3": "C# 7.3",
    "c_sharp_langage_version_config_8_0": "C# 8",
    "c_sharp_langage_version_config_9_0": "C# 9",
    "c_sharp_langage_version_config_10_0": "C# 10",
    "c_sharp_langage_version_config_latest": "C# 最新版本",
    "c_sharp_langage_version_config_auto_safe": "自動 - 安全",
    "c_sharp_langage_version_config_auto_experimental": "自動 - 實驗性",
    "c_sharp_language_version_config_description": "反編譯指令碼時要使用的 C# 語言版本。",
    "config_screen_drag_drop_prompt": "請注意，部分設定變更可能引發錯誤，但也可能預防錯誤的發生。\n準備好後，請將遊戲資料或資料夾拖放到此視窗，或使用左上方的功能表手動開啟。",
    "menu_file": "檔案",
    "menu_file_open_file": "開啟檔案",
    "menu_file_open_folder": "開啟資料夾",
    "menu_file_reset": "重設",
    "menu_file_exit": "結束",
    "menu_export": "匯出",
    "menu_export_all": "匯出所有檔案",
    "menu_export_selected": "匯出選取的檔案",
    "menu_export_selected_type": "匯出所選類型的所有檔案",
    "menu_language": "語言",
    "loading_game_content_from": "正在從 {0} 載入內容\n{1}",
    "loading_step_load_assemblies": "正在載入組件資訊",
    "loading_step_parse_bundle": "正在剖析 Bundle {0}",
    "loading_step_parse_archive": "正在剖析封存檔案 {0}",
    "loading_step_parse_web": "正在剖析 Web 檔案 {0}",
    "loading_step_parse_serialized": "正在剖析序列化檔案 {0}",
    "loading_step_parse_resource": "正在剖析資源檔案 {0}",
    "loading_step_parse_il2cpp_metadata": "正在剖析 IL2CPP 中繼資料",
    "loading_step_generate_dummy_dll": "正在從 IL2CPP 中產生 Mono 組件",
    "loading_step_locate_key_functions": "正在掃描 IL2CPP 二進位檔中的程式庫函式",
    "loading_step_restore_attributes": "正在從產生的組件中復原屬性",
    "loading_step_load_assets_from_file": "正在從 {0} 中載入資源",
    "loading_step_detect_platform": "正在收集檔案和偵測遊戲結構",
    "loading_step_initialize_layout": "正在初始化資源配置",
    "loading_step_create_file_collection": "正在建立檔案集合",
    "loading_step_begin_scheme_processing": "正在啟動配置處理",
    "loading_step_pre_processing": "正在前置處理檔案",
    "select_asset_to_view_info": "從左方選取資產以檢視資訊",
    "asset_tab_basic": "基本資訊",
    "asset_tab_yaml": "Yaml",
    "asset_tab_image": "圖像",
    "asset_tab_text": "文字",
    "asset_tab_audio": "音訊",
    "asset_tab_audio_play": "播放",
    "asset_tab_audio_pause": "暫停",
    "asset_tab_audio_duration_unknown": "<未知>",
    "error": "錯誤",
    "success": "成功！",
    "export_complete": "匯出完成！",
    "no_game_files_found": "拖曳的檔案中找不到 Unity 遊戲或 Asset Bundle。",
    "export_deleting_old_files": "正在清除現有檔案…",
    "export_preparing": "正在準備匯出…\n這可能需要一分鐘的時間。",
    "export_in_progress_no_file_count_yet": "正在匯出資源檔案…\n0.0%\n?/?",
    "export_in_progress": "正在匯出資源檔案…\n{0}%\n{1}/{2}",
    "error_exporting_with_reason": "匯出遊戲內容 {0} 失敗",
    "error_importing_with_reason": "載入遊戲內容 {0} 失敗",
    "check_log_for_more_details": "如需詳細資訊，請檢查記錄檔",
    "loose_file_saved_at": "鬆散檔案儲存於 {0}",
    "not_implemented_yet": "尚未實作"
}

```

`README.md`:

```md
# AssetRipper

[![AssetRipper Logo](Media/Images/2D_Logo/AssetRipperLogoBackground.png)](https://github.com/AssetRipper/AssetRipper/raw/master/Media/Images/2D_Logo/AssetRipperLogoBackground.png)

[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/total.svg)](https://github.com/AssetRipper/AssetRipper/releases)
[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/latest/total.svg)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://img.shields.io/github/v/release/AssetRipper/AssetRipper)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://weblate.samboy.dev/widgets/assetripper/-/gui/svg-badge.svg)](http://weblate.samboy.dev/engage/assetripper/)

AssetRipper is a tool for extracting assets from serialized files (*CAB-*\*, *\*.assets*, *\*.sharedAssets*, etc.) and assets bundles (*\*.unity3d*, *\*.bundle*, etc.) and converting them into the native Unity engine format.

# Donations

Thank you for considering to support me. I have normal expenses like food, electric, internet, and rent. Your donations help to ensure that I can continue to afford developing this project. Anyone with a positive lifetime contribution is entitled to the Donator role on the [Discord server](https://discord.gg/XqXa53W2Yh).

[GitHub Sponsors](https://github.com/sponsors/ds5678)

[Patreon](https://www.patreon.com/ds5678)

[Paypal](https://paypal.me/ds5678)

# Supported Versions

Limited support: `3.0.0` to `3.3.0`

Full support: `3.4.0` to `2022.1.X`

# Release Schedule

[Releases](https://github.com/AssetRipper/AssetRipper/releases) are put out once a week, usually on either Sunday or Monday.

# Links

[Website](https://assetripper.github.io/AssetRipper/)

[Downloads](https://assetripper.github.io/AssetRipper/articles/Downloads.html)

[Road Map](https://assetripper.github.io/AssetRipper/articles/RoadMap.html)

# Translations

We have a translation platform for those of you who speak another language to work on translating the GUI into your native language. You can get started at https://weblate.samboy.dev/engage/assetripper/.

You'll need to sign up to start translating to a new language, or you can suggest translations for an existing language without an account (but someone with an account will have to manually verify your suggestions). This will send an email to the address you provide. Be sure check your spam folder, as Gmail can sometimes put the emails there.

# Discord [![](https://img.shields.io/discord/867514400701153281?color=blue&label=AssetRipper)](https://discord.gg/XqXa53W2Yh)

The development of this project has a dedicated [Discord server](https://discord.gg/XqXa53W2Yh). Feel free to come say hi. This is also an alternative location for people to post issues.


# Legal Disclaimers

AssetRipper is licensed under the [GNU General Public License v3.0](License.md).

Please be aware that using or distributing the output from this software may be against copyright legislation in your jurisdiction. You are responsible for ensuring that you're not breaking any laws.

The full list of licensed works can be found on the [Credits](https://assetripper.github.io/AssetRipper/articles/Credits.html) page.

This software is not sponsored by or affiliated with Unity Technologies or its affiliates. "Unity" is a registered trademark of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`ShaderTextRestorer/ConstantBuffers/ConstantBufferChunk.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using System.Collections.Generic;
using AssetRipper.VersionUtilities;
using AssetRipper.IO.Endian;
using ShaderTextRestorer.ShaderBlob;
using ShaderTextRestorer.ShaderBlob.Parameters;

namespace ShaderTextRestorer.ConstantBuffers
{
	internal class ConstantBufferChunk
	{
		public ConstantBufferChunk(UnityVersion version, ref ShaderSubProgram shaderSubprogram, uint contantBufferOffset, Dictionary<string, uint> nameLookup)
		{
			m_shaderSubprogram = shaderSubprogram;
			m_contantBufferOffset = contantBufferOffset;
			m_nameLookup = nameLookup;

			ShaderGpuProgramType programType = shaderSubprogram.GetProgramType(version);
			uint headerSize = Count * 24;
			uint variableOffset = contantBufferOffset + headerSize;
			int constantBufferIndex = 0;
			List<VariableChunk> variables = new List<VariableChunk>();
			for (int i = 0; i < shaderSubprogram.ConstantBuffers.Length; i++)
			{
				ref ConstantBuffer constantBuffer = ref shaderSubprogram.ConstantBuffers[i];
				VariableChunk variableChunk = new VariableChunk(ref constantBuffer, constantBufferIndex++, variableOffset, programType);
				variables.Add(variableChunk);
				variableOffset += variableChunk.Size;
			}
			for (int i = 0; i < shaderSubprogram.BufferParameters.Length; i++)
			{
				ref BufferBinding bufferBindings = ref shaderSubprogram.BufferParameters[i];
				VariableChunk variableChunk = new VariableChunk(ref bufferBindings, constantBufferIndex++, variableOffset, programType);
				variables.Add(variableChunk);
				variableOffset += variableChunk.Size;
			}
			m_variables = variables;
			Size = variableOffset - contantBufferOffset;
		}

		public void Write(EndianWriter writer)
		{
			uint headerSize = Count * 24;
			uint variableOffset = m_contantBufferOffset + headerSize;
			int variableIndex = 0;
			for (int i = 0; i < m_shaderSubprogram.ConstantBuffers.Length; i++, variableIndex++)
			{
				ConstantBuffer constantBuffer = m_shaderSubprogram.ConstantBuffers[i];
				VariableChunk variableChunk = m_variables[variableIndex];
				uint nameOffset = m_nameLookup[constantBuffer.Name];
				writer.Write(nameOffset);
				writer.Write(variableChunk.Count);
				writer.Write(variableOffset);
				writer.Write((uint)constantBuffer.Size);
				//Flags
				writer.Write((uint)ConstantBufferFlags.None);
				//ContantBufferType
				writer.Write((uint)ConstantBufferType.ConstantBuffer);
				variableOffset += variableChunk.Size;
			}
			for (int i = 0; i < m_shaderSubprogram.BufferParameters.Length; i++, variableIndex++)
			{
				BufferBinding bufferParamater = m_shaderSubprogram.BufferParameters[i];
				VariableChunk variableChunk = m_variables[variableIndex];
				uint nameOffset = m_nameLookup[bufferParamater.Name];
				writer.Write(nameOffset);
				writer.Write(variableChunk.Count);
				writer.Write(variableOffset);
				//Size
				writer.Write((uint)4);
				//Flags
				writer.Write((uint)ConstantBufferFlags.None);
				//ContantBufferType
				writer.Write((uint)ConstantBufferType.ResourceBindInformation);
				variableOffset += variableChunk.Size;
			}
			foreach (VariableChunk variableChunk in m_variables)
			{
				variableChunk.Write(writer);
			}
		}

		internal uint Count => (uint)(m_shaderSubprogram.ConstantBuffers.Length + m_shaderSubprogram.BufferParameters.Length);

		internal uint Size { get; }

		private readonly IReadOnlyList<VariableChunk> m_variables;
		private readonly Dictionary<string, uint> m_nameLookup;
		private readonly uint m_contantBufferOffset;

		private ShaderSubProgram m_shaderSubprogram;
	}
}

```

`ShaderTextRestorer/ConstantBuffers/ConstantBufferFlags.cs`:

```cs
namespace ShaderTextRestorer.ConstantBuffers
{
	public enum ConstantBufferFlags
	{
		None = 0,
		UserPacked = 1,
	}
}
```

`ShaderTextRestorer/ConstantBuffers/ConstantBufferType.cs`:

```cs
namespace ShaderTextRestorer.ConstantBuffers
{
	internal enum ConstantBufferType
	{
		ConstantBuffer,
		TextureBuffer,
		InterfacePointers,
		ResourceBindInformation,
	}
}

```

`ShaderTextRestorer/ConstantBuffers/ShaderVariableFlags.cs`:

```cs
using System;

namespace ShaderTextRestorer.ConstantBuffers
{
	[Flags]
	internal enum ShaderVariableFlags
	{
		None = 0,
		UserPacked = 1,
		Used = 2,
		InterfacePointer = 4,
		InterfaceParameter = 8,
	}
}

```

`ShaderTextRestorer/ConstantBuffers/Variable.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using ShaderTextRestorer.ShaderBlob.Parameters;
using System;

namespace ShaderTextRestorer.ConstantBuffers
{
	internal class Variable
	{
		private Variable()
		{
		}

		public Variable(MatrixParameter param, ShaderGpuProgramType programType)
		{
			ShaderType = new Types.ShaderType(param, programType);
			Name = param.Name ?? throw new Exception("Variable name cannot be null");
			NameIndex = param.NameIndex;
			Index = param.Index;
			ArraySize = param.ArraySize;
			Length = (uint)(param.RowCount * param.ColumnCount * 4);
		}

		public Variable(VectorParameter param, ShaderGpuProgramType programType)
		{
			ShaderType = new Types.ShaderType(param, programType);
			Name = param.Name ?? throw new Exception("Variable name cannot be null");
			NameIndex = param.NameIndex;
			Index = param.Index;
			ArraySize = param.ArraySize;
			Length = (uint)(param.Dim * 4);
		}

		public Variable(StructParameter param, ShaderGpuProgramType programType)
		{
			ShaderType = new Types.ShaderType(param, programType);
			Name = param.Name ?? throw new Exception("Variable name cannot be null");
			NameIndex = param.NameIndex;
			Index = param.Index;
			ArraySize = param.ArraySize;
		}

		public static Variable CreateDummyVariable(string name, int index, int sizeToAdd, ShaderGpuProgramType programType)
		{
			if (sizeToAdd % 4 != 0 || sizeToAdd <= 0) throw new Exception($"Invalid dummy variable size {sizeToAdd}");

			//Constant Buffer indices have a stride of 16 bytes
			var alignIndex = index % 16;
			if (alignIndex != 0)
			{
				index += 16 - alignIndex;
				sizeToAdd -= 16 - alignIndex;
			}
			sizeToAdd -= sizeToAdd % 16;

			Variable variable = new Variable();
			var param = new VectorParameter(name, ShaderParamType.Float, index, sizeToAdd / 16, 4);
			variable.ShaderType = new Types.ShaderType(param, programType);
			variable.Name = name ?? throw new Exception("Variable name cannot be null");
			variable.NameIndex = -1;
			variable.Index = index;
			variable.ArraySize = param.ArraySize;
			variable.Type = ShaderParamType.Int;
			variable.Length = (uint)sizeToAdd;
			return variable;
		}

		public static Variable CreateResourceBindVariable(ShaderGpuProgramType programType)
		{
			Variable variable = new Variable();
			variable.Name = "$Element";
			var param = new VectorParameter(variable.Name, ShaderParamType.UInt, 0, 1);
			variable.ShaderType = new Types.ShaderType(param, programType);
			variable.NameIndex = -1;
			variable.Index = 0;
			variable.ArraySize = param.ArraySize;
			variable.Length = 4;
			variable.Type = ShaderParamType.UInt;
			return variable;
		}

		public Types.ShaderType ShaderType { get; private set; }
		public string Name { get; private set; }
		public int NameIndex { get; private set; }
		public int Index { get; private set; }
		public int ArraySize { get; private set; }
		public ShaderParamType Type { get; private set; }
		public uint Length { get; set; }

	}
}

```

`ShaderTextRestorer/ConstantBuffers/VariableChunk.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using System;
using System.Collections.Generic;
using System.Linq;
using ShaderTextRestorer.Extensions;
using ShaderTextRestorer.Types;
using AssetRipper.IO.Endian;
using ShaderTextRestorer.ShaderBlob.Parameters;

namespace ShaderTextRestorer.ConstantBuffers
{
	internal class VariableChunk
	{
		public VariableChunk(ref BufferBinding bufferBinding, int constantBufferIndex, uint variableOffset, ShaderGpuProgramType programType)
		{
			m_constantBufferIndex = constantBufferIndex;
			m_programType = programType;
			majorVersion = programType.GetMajorDXVersion();
			m_variables = new Variable[] { Variable.CreateResourceBindVariable(programType) };
			BuildVariableHeaders(variableOffset);

		}
		public VariableChunk(ref ConstantBuffer constantBuffer, int constantBufferIndex, uint variableOffset, ShaderGpuProgramType programType)
		{
			m_constantBufferIndex = constantBufferIndex;
			m_programType = programType;
			majorVersion = programType.GetMajorDXVersion();
			m_variables = BuildVariables(ref constantBuffer);
			BuildVariableHeaders(variableOffset);
		}
		private void BuildVariableHeaders(uint variableOffset)
		{
			const int memberSize = 12;
			uint variableSize = majorVersion >= 5 ? 40 : (uint)24;
			uint variableCount = (uint)m_variables.Length;
			uint dataOffset = variableOffset + variableCount * variableSize;
			foreach (Variable variable in m_variables)
			{
				m_variableNameLookup[variable.Name] = dataOffset;
				VariableHeader header = new VariableHeader();
				header.NameOffset = dataOffset;
				dataOffset += (uint)variable.Name.Length + 1;
				header.StartOffset = (uint)variable.Index;
				header.Variable = variable;

				m_typeLookup[variable.ShaderType] = dataOffset;
				dataOffset += variable.ShaderType.Size();

				variable.ShaderType.MemberOffset = variable.ShaderType.Members.Length > 0 ? dataOffset : 0;
				dataOffset += (uint)variable.ShaderType.Members.Length * memberSize;

				foreach (ShaderTypeMember member in variable.ShaderType.Members)
				{
					m_variableNameLookup[member.Name] = dataOffset;
					dataOffset += (uint)member.Name.Length + 1;

					m_typeLookup[member.ShaderType] = dataOffset;
					dataOffset += member.ShaderType.Size();
				}

				m_variableHeaders.Add(header);
			}
			Size = dataOffset - variableOffset;
		}
		internal void Write(EndianWriter writer)
		{
			foreach (VariableHeader header in m_variableHeaders)
			{
				WriteVariableHeader(writer, header);
			}
			foreach (Variable variable in m_variables)
			{
				writer.WriteStringZeroTerm(variable.Name);
				WriteShaderType(writer, variable.ShaderType);

				foreach (ShaderTypeMember member in variable.ShaderType.Members)
				{
					uint nameOffset = m_variableNameLookup[member.Name];
					writer.Write(nameOffset);
					uint memberOffset = m_typeLookup[member.ShaderType];
					writer.Write(memberOffset);
					writer.Write(member.Index);
				}
				foreach (ShaderTypeMember member in variable.ShaderType.Members)
				{
					writer.WriteStringZeroTerm(member.Name);
					WriteShaderType(writer, member.ShaderType);
				}
			}
		}

		private Variable[] BuildVariables(ref ConstantBuffer constantBuffer)
		{
			List<Variable> variables = new List<Variable>();
			foreach (MatrixParameter param in constantBuffer.MatrixParams)
			{
				variables.Add(new Variable(param, m_programType));
			}
			foreach (VectorParameter param in constantBuffer.VectorParams)
			{
				variables.Add(new Variable(param, m_programType));
			}
			foreach (StructParameter param in constantBuffer.StructParams)
			{
				variables.Add(new Variable(param, m_programType));
			}
			variables = variables.OrderBy(v => v.Index).ToList();
			//Dummy variables prevents errors in rare edge cases but produces more verbose output
			bool useDummyVariables = true;
			if (useDummyVariables)
			{
				List<Variable> allVariables = new List<Variable>();
				uint currentSize = 0;
				for (int i = 0; i < variables.Count; i++)
				{
					Variable variable = variables[i];
					if (variable.Index - currentSize >= 16)
					{
						long sizeToAdd = variable.Index - currentSize;
						int id1 = m_constantBufferIndex;
						int id2 = allVariables.Count;
						allVariables.Add(Variable.CreateDummyVariable($"unused_{id1}_{id2}",
								(int)currentSize, (int)sizeToAdd, m_programType));
					}
					allVariables.Add(variable);
					currentSize = (uint)variable.Index + variable.Length;
				}
				if (constantBuffer.Size - currentSize >= 16)
				{
					long sizeToAdd = constantBuffer.Size - currentSize;
					int id1 = m_constantBufferIndex;
					int id2 = allVariables.Count;
					allVariables.Add(Variable.CreateDummyVariable($"unused_{id1}_{id2}",
						(int)currentSize, (int)sizeToAdd, m_programType));
				}
				variables = allVariables;
			}
			else
			{
				for (int i = 0; i < variables.Count; i++)
				{
					if (i < variables.Count - 1)
					{
						variables[i].Length = (uint)variables[i + 1].Index - (uint)variables[i].Index;
					}
					else
					{
						variables[i].Length = (uint)constantBuffer.Size - (uint)variables[i].Index;
					}
				}
			}
			return variables.ToArray();
		}

		private void WriteVariableHeader(EndianWriter writer, VariableHeader header)
		{
			//name offset
			writer.Write(header.NameOffset);
			//startOffset
			writer.Write(header.StartOffset);
			//Size
			writer.Write(header.Variable.Length);
			//flags
			writer.Write((uint)ShaderVariableFlags.Used); //Unity only packs used variables as far as I can tell

			uint typeOffset = m_typeLookup[header.Variable.ShaderType];
			//type offset
			writer.Write(typeOffset);
			//default value offset
			writer.Write((uint)0); //Not used
			if (majorVersion >= 5)
			{
				//StartTexture
				writer.Write((uint)0);
				//TextureSize
				writer.Write((uint)0);
				//StartSampler
				writer.Write((uint)0);
				//SamplerSize
				writer.Write((uint)0);
			}
		}

		private void WriteShaderType(EndianWriter writer, ShaderType shaderType)
		{
			writer.Write((ushort)shaderType.ShaderVariableClass);
			writer.Write((ushort)shaderType.ShaderVariableType);
			writer.Write(shaderType.Rows);
			writer.Write(shaderType.Columns);
			writer.Write(shaderType.ElementCount);
			writer.Write(shaderType.MemberCount);
			writer.Write(shaderType.MemberOffset);
			if (majorVersion >= 5)
			{
				if (shaderType.ParentTypeOffset != 0 ||
					shaderType.Unknown2 != 0 ||
					shaderType.Unknown5 != 0 ||
					shaderType.ParentNameOffset != 0)
				{
					throw new Exception("Shader variable type has invalid value");
				}
				writer.Write(shaderType.ParentTypeOffset);
				writer.Write(shaderType.Unknown2);
				writer.Write(shaderType.Unknown4);
				writer.Write(shaderType.Unknown5);
				writer.Write(shaderType.ParentNameOffset);
			}
		}

		internal uint Count => (uint)m_variables.Length;
		internal uint Size { get; private set; }

		private readonly List<VariableHeader> m_variableHeaders = new List<VariableHeader>();
		private readonly Dictionary<string, uint> m_variableNameLookup = new Dictionary<string, uint>();
		private readonly Dictionary<ShaderType, uint> m_typeLookup = new Dictionary<ShaderType, uint>();
		private readonly Variable[] m_variables;

		private readonly int m_constantBufferIndex;
		private readonly ShaderGpuProgramType m_programType;
		private readonly int majorVersion;
	}
}

```

`ShaderTextRestorer/ConstantBuffers/VariableHeader.cs`:

```cs
namespace ShaderTextRestorer.ConstantBuffers
{
	internal class VariableHeader
	{
		public uint NameOffset { get; set; }
		public uint StartOffset { get; set; }
		public uint TypeOffset { get; set; }
		public Variable Variable { get; set; }
	}
}

```

`ShaderTextRestorer/D3DCompiler/D3DCompiler.cs`:

```cs
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// D3DCompiler.cs                                                            //
// Copyright (C) Microsoft Corporation. All rights reserved.                 //
// This file is distributed under the University of Illinois Open Source     //
// License. See LICENSE.TXT for details.                                     //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

namespace ShaderTextRestorer.D3DCompiler
{
	using System;
	using System.Runtime.InteropServices;
	using System.Runtime.Versioning;

	[StructLayout(LayoutKind.Sequential)]
	internal struct D3D_SHADER_MACRO
	{
		[MarshalAs(UnmanagedType.LPStr)] string Name;
		[MarshalAs(UnmanagedType.LPStr)] string Definition;
	}

	[SupportedOSPlatform("windows")]
	internal static class D3DCompiler
	{
		[DllImport("d3dcompiler_47", CallingConvention = CallingConvention.Winapi, SetLastError = false, CharSet = CharSet.Ansi, ExactSpelling = true)]
		internal extern static int D3DDisassemble(
			IntPtr ptr, uint ptrSize, uint flags,
			[MarshalAs(UnmanagedType.LPStr)] string szComments,
			out IDxcBlob disassembly);
	}
}

```

`ShaderTextRestorer/D3DCompiler/IDxcBlob.cs`:

```cs
///////////////////////////////////////////////////////////////////////////////
//                                                                           //
// DotNetDxc.cs                                                              //
// Copyright (C) Microsoft Corporation. All rights reserved.                 //
// This file is distributed under the University of Illinois Open Source     //
// License. See LICENSE.TXT for details.                                     //
//                                                                           //
// Provides P/Invoke declarations for dxcompiler HLSL support.               //
//                                                                           //
///////////////////////////////////////////////////////////////////////////////

using System;
using System.Runtime.InteropServices;

namespace ShaderTextRestorer.D3DCompiler
{
	[ComImport]
	[Guid("8BA5FB08-5195-40e2-AC58-0D989C3A0102")]
	[InterfaceType(ComInterfaceType.InterfaceIsIUnknown)]
	internal interface IDxcBlob
	{
		[PreserveSig]
		IntPtr GetBufferPointer();
		[PreserveSig]
		uint GetBufferSize();
	}
}

```

`ShaderTextRestorer/DXShaderProgramRestorer.cs`:

```cs
using System.Collections.Generic;
using System.IO;
using ShaderTextRestorer.Resources;
using AssetRipper.VersionUtilities;
using AssetRipper.IO.Endian;
using ShaderTextRestorer.ShaderBlob;

namespace ShaderTextRestorer
{
	public static class DXShaderProgramRestorer
	{
		public static byte[] RestoreProgramData(BinaryReader reader, UnityVersion version, ref ShaderSubProgram shaderSubProgram)
		{
			using MemoryStream dest = new MemoryStream();
			using BinaryWriter writer = new BinaryWriter(dest);
			uint baseOffset = (uint)reader.BaseStream.Position;
			byte[] magicBytes = reader.ReadBytes(4);
			byte[] checksum = reader.ReadBytes(16);
			uint unknown0 = reader.ReadUInt32();
			uint totalSize = reader.ReadUInt32();
			uint chunkCount = reader.ReadUInt32();
			List<uint> chunkOffsets = new List<uint>();
			for (int i = 0; i < chunkCount; i++)
			{
				chunkOffsets.Add(reader.ReadUInt32());
			}
			uint bodyOffset = (uint)reader.BaseStream.Position;
			// Check if shader already has resource chunk
			foreach (uint chunkOffset in chunkOffsets)
			{
				reader.BaseStream.Position = chunkOffset + baseOffset;
				uint fourCc = reader.ReadUInt32();
				if (fourCc == RDEFFourCC)
				{
					reader.BaseStream.Position = baseOffset;
					byte[] original = reader.ReadBytes((int)reader.BaseStream.Length);
					return original;
				}
			}
			reader.BaseStream.Position = bodyOffset;
			byte[] resourceChunkData = GetResourceChunk(version, ref shaderSubProgram);
			//Adjust for new chunk
			totalSize += (uint)resourceChunkData.Length;
			for (int i = 0; i < chunkCount; i++)
			{
				chunkOffsets[i] += (uint)resourceChunkData.Length + 4;
			}
			chunkOffsets.Insert(0, bodyOffset - baseOffset + 4);
			chunkCount += 1;
			totalSize += (uint)resourceChunkData.Length;

			writer.Write(magicBytes);
			writer.Write(checksum);
			writer.Write(unknown0);
			writer.Write(totalSize);
			writer.Write(chunkCount);
			foreach (uint chunkOffset in chunkOffsets)
			{
				writer.Write(chunkOffset);
			}
			writer.Write(resourceChunkData);
			byte[] rest = reader.ReadBytes((int)reader.BaseStream.Length - (int)reader.BaseStream.Position);
			writer.Write(rest);
			return dest.ToArray();
		}

		private static byte[] GetResourceChunk(UnityVersion version, ref ShaderSubProgram shaderSubprogram)
		{
			using MemoryStream memoryStream = new MemoryStream();
			using EndianWriter writer = new EndianWriter(memoryStream, EndianType.LittleEndian);
			ResourceChunk resourceChunk = new ResourceChunk(version, ref shaderSubprogram);
			resourceChunk.Write(writer);
			//uint size = resourceChunk.Size;
			//if (memoryStream.Length != resourceChunk.Size) throw new Exception("Expected size does not match actual size");
			return memoryStream.ToArray();
		}

		/// <summary>
		/// 'RDEF' ascii
		/// </summary>
		public const uint RDEFFourCC = 0x46454452;
	}
}

```

`ShaderTextRestorer/Exporters/DirectX/DXDataHeader.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.VersionUtilities;
using System.IO;

namespace ShaderTextRestorer.Exporters.DirectX
{
	public struct DXDataHeader
	{
		/// <summary>
		/// Not D3D9
		/// </summary>
		public static bool HasHeader(GPUPlatform graphicApi) => graphicApi != GPUPlatform.d3d9;
		/// <summary>
		/// 5.4.0 and greater
		/// </summary>
		public static bool HasGSInputPrimitive(UnityVersion version) => version.IsGreaterEqual(5, 4);

		public static int GetDataOffset(UnityVersion version, GPUPlatform graphicApi)
		{
			if (HasHeader(graphicApi))
			{
				return HasGSInputPrimitive(version) ? 6 : 5;
			}
			else
			{
				return 0;
			}
		}

		public void Read(BinaryReader reader, UnityVersion version)
		{
			Unknown1 = reader.ReadByte();
			Textures = reader.ReadByte();
			CBs = reader.ReadByte();
			Samplers = reader.ReadByte();
			UAVs = reader.ReadByte();
			if (HasGSInputPrimitive(version))
			{
				GSInputPrimitive = (DXInputPrimitive)reader.ReadByte();
			}
		}

		public void Write(BinaryWriter writer, UnityVersion version)
		{
			writer.Write(Unknown1);
			writer.Write(Textures);
			writer.Write(CBs);
			writer.Write(Samplers);
			writer.Write(UAVs);
			if (HasGSInputPrimitive(version))
			{
				writer.Write((byte)GSInputPrimitive);
			}
		}

		/// <summary>
		/// Always 1
		/// </summary>
		public byte Unknown1 { get; set; }
		public byte Textures { get; set; }
		public byte CBs { get; set; }
		public byte Samplers { get; set; }
		public byte UAVs { get; set; }
		public DXInputPrimitive GSInputPrimitive { get; set; }
	}
}

```

`ShaderTextRestorer/Exporters/DirectX/DXInputPrimitive.cs`:

```cs
namespace ShaderTextRestorer.Exporters.DirectX
{
	public enum DXInputPrimitive
	{
		None			= 0,
		Points			= 1,
		Lines			= 2,
		Triangles		= 3,
		LineAdj		= 6,
		TriangleAdj = 7,
	}
}

```

`ShaderTextRestorer/Exporters/DirectX/DXShaderTextExtractor.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.VersionUtilities;
using ShaderTextRestorer.Handlers;
using System;

namespace ShaderTextRestorer.Exporters.DirectX
{
	public static class DXShaderTextExtractor
	{
		public static bool TryGetShaderText(byte[] data, UnityVersion version, GPUPlatform gpuPlatform, out string disassemblyText)
		{
			int dataOffset = 0;
			if (DXDataHeader.HasHeader(gpuPlatform))
			{
				dataOffset = DXDataHeader.GetDataOffset(version, gpuPlatform);
			}

			if (DXDecompilerlyHandler.TryDisassemble(data, dataOffset, out disassemblyText))
			{
				return true;
			}
			else if (D3DHandler.IsD3DAvailable())
			{
				uint fourCC = BitConverter.ToUInt32(data, dataOffset);
				if (!D3DHandler.IsCompatible(fourCC))
				{
					throw new Exception($"Magic number {fourCC} doesn't match");
				}
				return D3DHandler.TryGetShaderText(data, dataOffset, out disassemblyText);
			}
			else
			{
				return false;
			}
		}

		public static bool TryDecompileText(byte[] data, UnityVersion version, GPUPlatform gpuPlatform, out string decompiledText)
		{
			int dataOffset = 0;
			if (DXDataHeader.HasHeader(gpuPlatform))
			{
				dataOffset = DXDataHeader.GetDataOffset(version, gpuPlatform);
			}

			return DXDecompilerlyHandler.TryDecompile(data, dataOffset, out decompiledText);
		}
	}
}

```

`ShaderTextRestorer/Exporters/DirectX/ShaderDXExporter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using ShaderTextRestorer.IO;
using ShaderTextRestorer.ShaderBlob;

namespace ShaderTextRestorer.Exporters.DirectX
{
	public class ShaderDXExporter : ShaderTextExporter
	{
		public override string Name => "ShaderDXExporter";

		public ShaderDXExporter(GPUPlatform graphicApi)
		{
			m_graphicApi = graphicApi;
		}

		public override void Export(ShaderWriter writer, ref ShaderSubProgram subProgram)
		{
			byte[] exportData = subProgram.ProgramData;

			if (DXShaderTextExtractor.TryDecompileText(exportData, writer.Version, m_graphicApi, out string decompiledText))
			{
				ExportListing(writer, "//ShaderDXExporter_Decompiler\n" + (decompiledText ?? ""));
			}
			else if (DXShaderTextExtractor.TryGetShaderText(exportData, writer.Version, m_graphicApi, out string disassemblyText))
			{
				ExportListing(writer, "//ShaderDXExporter_Disassembler\n" + (disassemblyText ?? ""));
			}
		}

		protected readonly GPUPlatform m_graphicApi;
	}
}

```

`ShaderTextRestorer/Exporters/ShaderGLESExporter.cs`:

```cs
namespace ShaderTextRestorer.Exporters
{
	public class ShaderGLESExporter : ShaderTextExporter
	{
		public override string Name => "ShaderGLESExporter";
	}
}

```

`ShaderTextRestorer/Exporters/ShaderMetalExporter.cs`:

```cs
using AssetRipper.IO.Endian;
using AssetRipper.VersionUtilities;
using ShaderTextRestorer.IO;
using ShaderTextRestorer.ShaderBlob;
using System.IO;

namespace ShaderTextRestorer.Exporters
{
	public class ShaderMetalExporter : ShaderTextExporter
	{
		/// <summary>
		/// 5.3.0 and greater
		/// </summary>
		public static bool HasBlob(UnityVersion version) => version.IsGreaterEqual(5, 3);
		
		public override string Name => "ShaderMetalExporter";

		public override void Export(ShaderWriter writer, ref ShaderSubProgram subProgram)
		{
			using MemoryStream memStream = new MemoryStream(subProgram.ProgramData);
			using BinaryReader reader = new BinaryReader(memStream);
			if (HasBlob(writer.Version))
			{
				long position = reader.BaseStream.Position;
				uint fourCC = reader.ReadUInt32();
				if (fourCC == MetalFourCC)
				{
					int offset = reader.ReadInt32();
					reader.BaseStream.Position = position + offset;
				}
				using EndianReader endReader = new EndianReader(reader.BaseStream, EndianType.LittleEndian);
				EntryName = endReader.ReadStringZeroTerm();
			}

			ExportText(writer, reader);
		}

		public string EntryName { get; private set; }

		private const uint MetalFourCC = 0xf00dcafe;
	}
}

```

`ShaderTextRestorer/Exporters/ShaderTextExporter.cs`:

```cs
using AssetRipper.Core.Extensions;
using ShaderTextRestorer.IO;
using ShaderTextRestorer.ShaderBlob;
using System.Collections.Generic;
using System.IO;

namespace ShaderTextRestorer.Exporters
{
	public class ShaderTextExporter
	{
		public virtual string Name => "ShaderTextExporter";

		public virtual void Export(ShaderWriter writer, ref ShaderSubProgram subProgram)
		{
			byte[] exportData = subProgram.ProgramData;
			using MemoryStream memStream = new MemoryStream(exportData);
			using BinaryReader reader = new BinaryReader(memStream);
			ExportText(writer, reader, Name);
		}

		protected static void ExportText(TextWriter writer, BinaryReader reader) => ExportText(writer, reader, null);
		protected static void ExportText(TextWriter writer, BinaryReader reader, string name)
		{
			List<char> characters = new List<char>();
			if (!string.IsNullOrEmpty(name))
			{
				characters.Add('/');
				characters.Add('/');
				foreach (char c in name.ToCharArray())
				{
					characters.Add(c);
				}
				characters.Add('\n');
			}
			while (reader.BaseStream.Position != reader.BaseStream.Length)
			{
				characters.Add(reader.ReadChar());
			}
			ExportText(writer, characters.ToArray());
		}
		protected static void ExportText(TextWriter writer, char[] array)
		{
			for (int i = 0; i < array.Length; i++)
			{
				char c = array[i];
				if (c == '\n')
				{
					if (i == array.Length - 1)
					{
						break;
					}
					writer.Write(c);
					writer.WriteIndent(ExpectedIndent);
				}
				else
				{
					writer.Write(c);
				}
			}
		}

		protected static void ExportListing(TextWriter writer, string listing)
		{
			writer.Write('\n');
			writer.WriteIndent(ExpectedIndent);

			for (int i = 0; i < listing.Length;)
			{
				char c = listing[i++];
				bool newLine = false;
				if (c == '\r')
				{
					if (i == listing.Length)
					{
						newLine = true;
					}
					else
					{
						char nc = listing[i];
						if (nc != '\n')
						{
							newLine = true;
						}
					}
				}
				else if (c == '\n')
				{
					newLine = true;
				}

				if (newLine)
				{
					if (i == listing.Length)
					{
						break;
					}
					writer.Write(c);
					writer.WriteIndent(ExpectedIndent);
				}
				else
				{
					writer.Write(c);
				}
			}
		}

		protected const int ExpectedIndent = 5;
	}
}

```

`ShaderTextRestorer/Exporters/ShaderUnknownExporter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using ShaderTextRestorer.IO;
using ShaderTextRestorer.ShaderBlob;

namespace ShaderTextRestorer.Exporters
{
	public class ShaderUnknownExporter : ShaderTextExporter
	{
		public override string Name => "ShaderUnknownExporter";

		public ShaderUnknownExporter(GPUPlatform graphicApi)
		{
			m_graphicApi = graphicApi;
		}

		public override void Export(ShaderWriter writer, ref ShaderSubProgram subProgram)
		{
			writer.Write("/*ShaderUnknownExporter : Can't export program data {0} as a text*/", m_graphicApi);
		}

		private readonly GPUPlatform m_graphicApi;
	}
}

```

`ShaderTextRestorer/Exporters/ShaderVulkanExporter.cs`:

```cs
using AssetRipper.Core.IO;
using Smolv;
using SpirV;
using System;
using System.IO;
using ShaderTextRestorer.IO;
using AssetRipper.VersionUtilities;
using ShaderTextRestorer.ShaderBlob;

namespace ShaderTextRestorer.Exporters
{
	public class ShaderVulkanExporter : ShaderTextExporter
	{
		/// <summary>
		/// 2019.3 and greater
		/// </summary>
		public static bool HasProgRayTracing(UnityVersion version) => version.IsGreaterEqual(2019, 3);
		
		public override string Name => "ShaderVulkanExporter";

		public override void Export(ShaderWriter writer, ref ShaderSubProgram subProgram)
		{
			using MemoryStream ms = new MemoryStream(subProgram.ProgramData);
			using BinaryReader reader = new BinaryReader(ms);
			int requirements = reader.ReadInt32();
			int snippetCount = HasProgRayTracing(writer.Version) ? 6 : 5;
			for (int i = 0; i < snippetCount; i++)
			{
				int offset = reader.ReadInt32();
				int size = reader.ReadInt32();
				if (size > 0)
				{
					ExportSnippet(writer, ms, offset, size);
				}
			}
		}

		private void ExportSnippet(TextWriter writer, Stream stream, int offset, int size)
		{
			using PartialStream snippetStream = new PartialStream(stream, offset, size);
			int decodedSize = SmolvDecoder.GetDecodedBufferSize(snippetStream);
			if (decodedSize == 0)
			{
				throw new Exception("Invalid SMOL-V shader header");
			}
			using MemoryStream decodedStream = new MemoryStream(new byte[decodedSize]);
			if (SmolvDecoder.Decode(stream, size, decodedStream))
			{
				decodedStream.Position = 0;
				Module module = Module.ReadFrom(decodedStream);
				string listing = m_disassembler.Disassemble(module, DisassemblyOptions.Default);
				ExportListing(writer, "//ShaderVulkanExporter\n" + listing);
			}
			else
			{
				throw new Exception("Unable to decode SMOL-V shader");
			}
		}

		private readonly Disassembler m_disassembler = new Disassembler();
	}
}

```

`ShaderTextRestorer/Extensions/ShaderExtensions.cs`:

```cs
using AssetRipper.Core.Layout;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using ShaderTextRestorer.ShaderBlob;
using System;

namespace ShaderTextRestorer.Extensions
{
	public static class ShaderExtensions
	{
		public static ShaderSubProgramBlob[] ReadBlobs(this IShader shader)
		{
			LayoutInfo layout = shader.SerializedFile.Layout;
			if (shader.Has_CompressedBlob_C48())
			{
				if (shader.Has_CompressedLengths_C48_UInt32_Array())
				{
					return UnpackSubProgramBlobs(
						layout,
						shader.Offsets_C48_UInt32_Array!,
						shader.CompressedLengths_C48_UInt32_Array,
						shader.DecompressedLengths_C48_UInt32_Array!,
						shader.CompressedBlob_C48);
				}
				else if (shader.Has_CompressedLengths_C48_UInt32_Array_Array())
				{
					return UnpackSubProgramBlobs(
						layout, 
						shader.Offsets_C48_UInt32_Array_Array!, 
						shader.CompressedLengths_C48_UInt32_Array_Array, 
						shader.DecompressedLengths_C48_UInt32_Array_Array!, 
						shader.CompressedBlob_C48);
				}
			}
			else if (shader.Has_SubProgramBlob_C48())//todo: rename to CompressedBlob
			{
				return UnpackSubProgramBlobs(
					layout,
					0,
					(uint)shader.SubProgramBlob_C48.Length,
					shader.DecompressedSize_C48,
					shader.SubProgramBlob_C48);
			}
			return Array.Empty<ShaderSubProgramBlob>();
		}

		private static ShaderSubProgramBlob[] UnpackSubProgramBlobs(LayoutInfo layout, uint offset, uint compressedLength, uint decompressedLength, byte[] compressedBlob)
		{
			if (compressedBlob.Length == 0)
			{
				return Array.Empty<ShaderSubProgramBlob>();
			}
			else
			{
				ShaderSubProgramBlob[] blobs = new ShaderSubProgramBlob[1] { new() };
				uint[] offsets = new uint[] { offset };
				uint[] compressedLengths = new uint[] { compressedLength };
				uint[] decompressedLengths = new uint[] { decompressedLength };
				blobs[0].Read(layout, compressedBlob, offsets, compressedLengths, decompressedLengths);
				return blobs;
			}
		}

		private static ShaderSubProgramBlob[] UnpackSubProgramBlobs(LayoutInfo layout, uint[] offsets, uint[] compressedLengths, uint[] decompressedLengths, byte[] compressedBlob)
		{
			ShaderSubProgramBlob[] blobs = new ShaderSubProgramBlob[offsets.Length];
			for (int i = 0; i < blobs.Length; i++)
			{
				blobs[i] = new();
				uint[] blobOffsets = new uint[] { offsets[i] };
				uint[] blobCompressedLengths = new uint[] { compressedLengths[i] };
				uint[] blobDecompressedLengths = new uint[] { decompressedLengths[i] };
				blobs[i].Read(layout, compressedBlob, blobOffsets, blobCompressedLengths, blobDecompressedLengths);
			}
			return blobs;
		}

		private static ShaderSubProgramBlob[] UnpackSubProgramBlobs(LayoutInfo layout, uint[][] offsets, uint[][] compressedLengths, uint[][] decompressedLengths, byte[] compressedBlob)
		{
			ShaderSubProgramBlob[] blobs = new ShaderSubProgramBlob[offsets.Length];
			for (int i = 0; i < blobs.Length; i++)
			{
				blobs[i] = new();
				uint[] blobOffsets = offsets[i];
				uint[] blobCompressedLengths = compressedLengths[i];
				uint[] blobDecompressedLengths = decompressedLengths[i];
				blobs[i].Read(layout, compressedBlob, blobOffsets, blobCompressedLengths, blobDecompressedLengths);
			}
			return blobs;
		}
	}
}

```

`ShaderTextRestorer/Extensions/ShaderGpuProgramTypeExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using ShaderTextRestorer.Resources;
using System;

namespace ShaderTextRestorer.Extensions
{
	public static class ShaderGpuProgramTypeExtensions
	{
		public static DXProgramType ToDXProgramType(this ShaderGpuProgramType _this)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.DX10Level9Pixel:
				case ShaderGpuProgramType.DX11PixelSM40:
				case ShaderGpuProgramType.DX11PixelSM50:
					return DXProgramType.PixelShader;

				case ShaderGpuProgramType.DX10Level9Vertex:
				case ShaderGpuProgramType.DX11VertexSM40:
				case ShaderGpuProgramType.DX11VertexSM50:
					return DXProgramType.VertexShader;

				case ShaderGpuProgramType.DX11GeometrySM40:
				case ShaderGpuProgramType.DX11GeometrySM50:
					return DXProgramType.GeometryShader;

				case ShaderGpuProgramType.DX11HullSM50:
					return DXProgramType.HullShader;

				case ShaderGpuProgramType.DX11DomainSM50:
					return DXProgramType.DomainShader;

				default:
					throw new Exception($"Unexpected program type {_this}");
			}
		}

		public static int GetMajorDXVersion(this ShaderGpuProgramType _this)
		{
			switch (_this)
			{
				case ShaderGpuProgramType.DX10Level9Vertex:
				case ShaderGpuProgramType.DX10Level9Pixel:
				case ShaderGpuProgramType.DX11PixelSM40:
				case ShaderGpuProgramType.DX11VertexSM40:
				case ShaderGpuProgramType.DX11GeometrySM40:
					return 4;

				case ShaderGpuProgramType.DX11PixelSM50:
				case ShaderGpuProgramType.DX11VertexSM50:
				case ShaderGpuProgramType.DX11GeometrySM50:
				case ShaderGpuProgramType.DX11HullSM50:
				case ShaderGpuProgramType.DX11DomainSM50:
					return 5;

				case ShaderGpuProgramType.RayTracing:
					return 6;

				default:
					throw new Exception($"Unexpected program type {_this}");
			}
		}
	}
}

```

`ShaderTextRestorer/Handlers/D3DHandler.cs`:

```cs
using ShaderTextRestorer.D3DCompiler;
using System;
using System.Runtime.InteropServices;

namespace ShaderTextRestorer.Handlers
{
	public static class D3DHandler
	{
		public static bool IsD3DAvailable() => OperatingSystem.IsWindows();

		public static bool IsCompatible(uint magicNumber) => magicNumber == DXBCFourCC;

		public static bool TryGetShaderText(byte[] data, int dataOffset, out string shaderText)
		{
			if (!OperatingSystem.IsWindows())
			{
				shaderText = null;
				return false;
			}

			int dataLength = data.Length - dataOffset;
			IntPtr unmanagedPointer = Marshal.AllocHGlobal(dataLength);
			Marshal.Copy(data, dataOffset, unmanagedPointer, dataLength);

			D3DCompiler.D3DCompiler.D3DDisassemble(unmanagedPointer, (uint)dataLength, 0, null, out IDxcBlob disassembly);
			shaderText = GetStringFromBlob(disassembly);

			Marshal.FreeHGlobal(unmanagedPointer);

			return !string.IsNullOrEmpty(shaderText);
		}

		private static string GetStringFromBlob(IDxcBlob blob)
		{
			return Marshal.PtrToStringAnsi(blob.GetBufferPointer());
		}

		/// <summary>
		/// 'DXBC' ascii
		/// </summary>
		const uint DXBCFourCC = 0x43425844;
	}
}

```

`ShaderTextRestorer/Handlers/DXDecompilerlyHandler.cs`:

```cs
using AssetRipper.Core.Logging;
using DXDecompiler;
using DXDecompiler.Decompiler;
using DXDecompiler.Util;
using System;


namespace ShaderTextRestorer.Handlers
{
	public static class DXDecompilerlyHandler
	{
		public static bool TryDisassemble(byte[] data, int offset, out string disassemblyText) => TryDisassemble(GetRelevantData(data, offset), out disassemblyText);
		public static bool TryDisassemble(byte[] data, out string disassemblyText)
		{
			if (data == null)
				throw new ArgumentNullException(nameof(data));
			if (data.Length == 0)
				throw new ArgumentException("inputData cannot have zero length");

			try
			{
				var programType = GetProgramType(data);
				switch (programType)
				{
					case DXProgramType.DXBC:
						var container = new BytecodeContainer(data);
						disassemblyText = container.ToString();
						return !string.IsNullOrEmpty(disassemblyText);
					case DXProgramType.DX9:
						disassemblyText = DXDecompiler.DX9Shader.AsmWriter.Disassemble(data);
						return !string.IsNullOrEmpty(disassemblyText);
				}
			}
			catch(Exception ex)
			{
				Logger.Error(LogCategory.Export, $"DXDecompilerly threw an exception while attempting to disassemble a shader");
				Logger.Verbose(LogCategory.Export, ex.ToString());
			}

			disassemblyText = null;
			return false;
		}

		public static bool TryDecompile(byte[] data, int offset, out string decompiledText) => TryDecompile(GetRelevantData(data, offset), out decompiledText);
		public static bool TryDecompile(byte[] data, out string decompiledText)
		{
			if (data == null)
				throw new ArgumentNullException(nameof(data));
			if (data.Length == 0)
				throw new ArgumentException("inputData cannot have zero length");

			try
			{
				var programType = GetProgramType(data);
				switch (programType)
				{
					case DXProgramType.DXBC:
						decompiledText = HLSLDecompiler.Decompile(data);
						Logger.Info(LogCategory.Export, $"DXDecompilerly successfully decompiled a DXBC shader");
						return !string.IsNullOrEmpty(decompiledText);
					case DXProgramType.DX9:
						decompiledText = DXDecompiler.DX9Shader.HlslWriter.Decompile(data);
						Logger.Info(LogCategory.Export, $"DXDecompilerly successfully decompiled a DX9 shader");
						return !string.IsNullOrEmpty(decompiledText);
				}
			}
			catch (Exception ex)
			{
				Logger.Verbose(LogCategory.Export, $"DXDecompilerly threw an exception while attempting to decompile a shader");
				Logger.Verbose(LogCategory.Export, ex.ToString());
			}

			decompiledText = null;
			return false;
		}

		private static DXProgramType GetProgramType(byte[] data)
		{
			if (data.Length < 4)
			{
				return DXProgramType.Unknown;
			}
			uint dxbcHeader = BitConverter.ToUInt32(data, 0);
			if (dxbcHeader == "DXBC".ToFourCc())
			{
				return DXProgramType.DXBC;
			}
			if (dxbcHeader == 0xFEFF2001)
			{
				return DXProgramType.DXBC;
			}
			var dx9ShaderType = (DXDecompiler.DX9Shader.ShaderType)BitConverter.ToUInt16(data, 2);
			if (dx9ShaderType == DXDecompiler.DX9Shader.ShaderType.Vertex ||
				dx9ShaderType == DXDecompiler.DX9Shader.ShaderType.Pixel ||
				dx9ShaderType == DXDecompiler.DX9Shader.ShaderType.Effect)
			{
				return DXProgramType.DX9;
			}
			return DXProgramType.Unknown;
		}

		private static byte[] GetRelevantData(byte[] bytes, int offset)
		{
			if (bytes == null)
				throw new ArgumentNullException(nameof(bytes));
			if (offset < 0 || offset > bytes.Length)
				throw new ArgumentOutOfRangeException(nameof(offset));
			int size = bytes.Length - offset;
			byte[] result = new byte[size];
			for (int i = 0; i < size; i++)
			{
				result[i] = bytes[i + offset];
			}
			return result;
		}

		private enum DXProgramType
		{
			Unknown,
			DX9,
			DXBC
		}
	}
}

```

`ShaderTextRestorer/IO/SerializedExtensions.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using AssetRipper.Core.Classes.Shader.SerializedShader.Enum;
using AssetRipper.Core.Extensions;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Subclasses.SerializedPass;
using AssetRipper.SourceGenerated.Subclasses.SerializedProgram;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperties;
using AssetRipper.SourceGenerated.Subclasses.SerializedProperty;
using AssetRipper.SourceGenerated.Subclasses.SerializedShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderRTBlendState;
using AssetRipper.SourceGenerated.Subclasses.SerializedShaderState;
using AssetRipper.SourceGenerated.Subclasses.SerializedStencilOp;
using AssetRipper.SourceGenerated.Subclasses.SerializedSubProgram;
using AssetRipper.SourceGenerated.Subclasses.SerializedSubShader;
using AssetRipper.SourceGenerated.Subclasses.SerializedTagMap;
using AssetRipper.SourceGenerated.Subclasses.Utf8String;
using ShaderTextRestorer.ShaderBlob;
using System;
using System.Globalization;
using System.IO;

namespace ShaderTextRestorer.IO
{
	public static class SerializedExtensions
	{
		public static void Export(this ISerializedPass _this, ShaderWriter writer)
		{
			writer.WriteIndent(2);
			writer.Write("{0} ", _this.Type.ToString());

			if (_this.Type == (int)SerializedPassType.UsePass)
			{
				writer.Write("\"{0}\"\n", _this.UseName);
			}
			else
			{
				writer.Write("{\n");

				if (_this.Type == (int)SerializedPassType.GrabPass)
				{
					if (_this.TextureName.Data.Length > 0)
					{
						writer.WriteIndent(3);
						writer.Write("\"{0}\"\n", _this.TextureName);
					}
				}
				else if (_this.Type == (int)SerializedPassType.Pass)
				{
					_this.State.Export(writer);

					if ((_this.ProgramMask & ShaderType.Vertex.ToProgramMask()) != 0)
					{
						_this.ProgVertex.Export(writer, ShaderType.Vertex);
					}
					if ((_this.ProgramMask & ShaderType.Fragment.ToProgramMask()) != 0)
					{
						_this.ProgFragment.Export(writer, ShaderType.Fragment);
					}
					if ((_this.ProgramMask & ShaderType.Geometry.ToProgramMask()) != 0)
					{
						_this.ProgGeometry.Export(writer, ShaderType.Geometry);
					}
					if ((_this.ProgramMask & ShaderType.Hull.ToProgramMask()) != 0)
					{
						_this.ProgHull.Export(writer, ShaderType.Hull);
					}
					if ((_this.ProgramMask & ShaderType.Domain.ToProgramMask()) != 0)
					{
						_this.ProgDomain.Export(writer, ShaderType.Domain);
					}
					if ((_this.ProgramMask & ShaderType.RayTracing.ToProgramMask()) != 0)
					{
						_this.ProgDomain.Export(writer, ShaderType.RayTracing);
					}

#warning HasInstancingVariant?
				}
				else
				{
					throw new NotSupportedException($"Unsupported pass type {_this.Type}");
				}

				writer.WriteIndent(2);
				writer.Write("}\n");
			}
		}

		public static void Export(this ISerializedProgram _this, ShaderWriter writer, ShaderType type)
		{
			if (_this.SubPrograms.Count == 0)
			{
				return;
			}

			writer.WriteIndent(3);
			writer.Write("Program \"{0}\" {{\n", type.ToProgramTypeString());
			int tierCount = _this.GetTierCount();
			for (int i = 0; i < _this.SubPrograms.Count; i++)
			{
				_this.SubPrograms[i].Export(writer, type, tierCount > 1);
			}
			writer.WriteIndent(3);
			writer.Write("}\n");
		}

		public static void Export(this ISerializedProperties _this, TextWriter writer)
		{
			writer.WriteIndent(1);
			writer.Write("Properties {\n");
			foreach (ISerializedProperty prop in _this.Props)
			{
				prop.Export(writer);
			}
			writer.WriteIndent(1);
			writer.Write("}\n");
		}

		public static void Export(this ISerializedProperty _this, TextWriter writer)
		{
			writer.WriteIndent(2);
			foreach (Utf8String attribute in _this.Attributes)
			{
				writer.Write("[{0}] ", attribute);
			}
			SerializedPropertyFlag flags = (SerializedPropertyFlag)_this.Flags;
			if (flags.IsHideInInspector())
			{
				writer.Write("[HideInInspector] ");
			}
			if (flags.IsPerRendererData())
			{
				writer.Write("[PerRendererData] ");
			}
			if (flags.IsNoScaleOffset())
			{
				writer.Write("[NoScaleOffset] ");
			}
			if (flags.IsNormal())
			{
				writer.Write("[Normal] ");
			}
			if (flags.IsHDR())
			{
				writer.Write("[HDR] ");
			}
			if (flags.IsGamma())
			{
				writer.Write("[Gamma] ");
			}

			writer.Write("{0} (\"{1}\", ", _this.NameString, _this.Description);
			
			switch ((SerializedPropertyType)_this.Type)
			{
				case SerializedPropertyType.Color:
				case SerializedPropertyType.Vector:
					writer.Write(nameof(SerializedPropertyType.Vector));
					break;

				case SerializedPropertyType.Int:
					//case SerializedPropertyType.Float:
					writer.Write(nameof(SerializedPropertyType.Float));
					break;

				case SerializedPropertyType.Range:
					writer.Write("{0}({1}, {2})",
						nameof(SerializedPropertyType.Range),
						_this.DefValue_1_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_2_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType._2D:
					//case SerializedPropertyType._3D:
					//case SerializedPropertyType.Cube:
					switch (_this.DefTexture.TexDim)
					{
						case 1:
							writer.Write("any");
							break;
						case 2:
							writer.Write("2D");
							break;
						case 3:
							writer.Write("3D");
							break;
						case 4:
							writer.Write(nameof(SerializedPropertyType.Cube));
							break;
						case 5:
							writer.Write("2DArray");
							break;
						case 6:
							writer.Write(nameof(SerializedPropertyType.CubeArray));
							break;
						default:
							throw new NotSupportedException("Texture dimension isn't supported");

					}
					break;

				default:
					throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
			}
			writer.Write(") = ");

			switch ((SerializedPropertyType)_this.Type)
			{
				case SerializedPropertyType.Color:
				case SerializedPropertyType.Vector:
					writer.Write("({0},{1},{2},{3})",
						_this.DefValue_0_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_1_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_2_.ToString(CultureInfo.InvariantCulture),
						_this.DefValue_3_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType.Int:
				//case SerializedPropertyType.Float:
				case SerializedPropertyType.Range:
					writer.Write(_this.DefValue_0_.ToString(CultureInfo.InvariantCulture));
					break;

				case SerializedPropertyType._2D:
					//case SerializedPropertyType._3D:
					//case SerializedPropertyType.Cube:
					writer.Write("\"{0}\" {{}}", _this.DefTexture.DefaultName);
					break;

				default:
					throw new NotSupportedException($"Serialized property type {_this.Type} isn't supported");
			}
			writer.Write('\n');
		}

		public static void Export(this ISerializedShader _this, ShaderWriter writer)
		{
			writer.Write("Shader \"{0}\" {{\n", _this.NameString);

			_this.PropInfo.Export(writer);

			for (int i = 0; i < _this.SubShaders.Count; i++)
			{
				_this.SubShaders[i].Export(writer);
			}

			if (_this.FallbackName.Data.Length != 0)
			{
				writer.WriteIndent(1);
				writer.Write("Fallback \"{0}\"\n", _this.FallbackName);
			}

			if (_this.CustomEditorName.Data.Length != 0)
			{
				writer.WriteIndent(1);
				writer.Write("CustomEditor \"{0}\"\n", _this.CustomEditorName);
			}

			writer.Write('}');
		}

		public static void Export(this ISerializedShaderRTBlendState _this, TextWriter writer, int index)
		{
			if (!_this.SrcBlendValue().IsOne() || !_this.DestBlendValue().IsZero() || !_this.SrcBlendAlphaValue().IsOne() || !_this.DestBlendAlphaValue().IsZero())
			{
				writer.WriteIndent(3);
				writer.Write("Blend ");
				if (index != -1)
				{
					writer.Write("{0} ", index);
				}
				writer.Write("{0} {1}", _this.SrcBlend, _this.DestBlendValue());
				if (!_this.SrcBlendValue().IsOne() || !_this.DestBlendAlphaValue().IsZero())
				{
					writer.Write(", {0} {1}", _this.SrcBlendAlphaValue(), _this.DestBlendAlphaValue());
				}
				writer.Write('\n');
			}

			if (!_this.BlendOpValue().IsAdd() || !_this.BlendOpAlphaValue().IsAdd())
			{
				writer.WriteIndent(3);
				writer.Write("BlendOp ");
				if (index != -1)
				{
					writer.Write("{0} ", index);
				}
				writer.Write(_this.BlendOpValue().ToString());
				if (!_this.BlendOpAlphaValue().IsAdd())
				{
					writer.Write(", {0}", _this.BlendOpAlphaValue());
				}
				writer.Write('\n');
			}

			if (!_this.ColMaskValue().IsRBGA())
			{
				writer.WriteIndent(3);
				writer.Write("ColorMask ");
				if (_this.ColMaskValue().IsNone())
				{
					writer.Write(0);
				}
				else
				{
					if (_this.ColMaskValue().IsRed())
					{
						writer.Write('R');
					}
					if (_this.ColMaskValue().IsGreen())
					{
						writer.Write('G');
					}
					if (_this.ColMaskValue().IsBlue())
					{
						writer.Write('B');
					}
					if (_this.ColMaskValue().IsAlpha())
					{
						writer.Write('A');
					}
				}
				writer.Write(" {0}\n", index);
			}
		}

		public static void Export(this ISerializedShaderState _this, TextWriter writer)
		{
			if (_this.Name != string.Empty)
			{
				writer.WriteIndent(3);
				writer.Write("Name \"{0}\"\n", _this.Name);
			}
			if (_this.LOD != 0)
			{
				writer.WriteIndent(3);
				writer.Write("LOD {0}\n", _this.LOD);
			}
			_this.Tags.Export(writer, 3);

			_this.RtBlend0.Export(writer, _this.RtSeparateBlend ? 0 : -1);
			_this.RtBlend1.Export(writer, 1);
			_this.RtBlend2.Export(writer, 2);
			_this.RtBlend3.Export(writer, 3);
			_this.RtBlend4.Export(writer, 4);
			_this.RtBlend5.Export(writer, 5);
			_this.RtBlend6.Export(writer, 6);
			_this.RtBlend7.Export(writer, 7);

			if (_this.AlphaToMaskValue())
			{
				writer.WriteIndent(3);
				writer.Write("AlphaToMask On\n");
			}

			if (!_this.ZClipValue().IsOn())
			{
				writer.WriteIndent(3);
				writer.Write("ZClip {0}\n", _this.ZClipValue());
			}
			if (!_this.ZTestValue().IsLEqual() && !_this.ZTestValue().IsNone())
			{
				writer.WriteIndent(3);
				writer.Write("ZTest {0}\n", _this.ZTestValue());
			}
			if (!_this.ZWriteValue().IsOn())
			{
				writer.WriteIndent(3);
				writer.Write("ZWrite {0}\n", _this.ZWriteValue());
			}
			if (!_this.CullingValue().IsBack())
			{
				writer.WriteIndent(3);
				writer.Write("Cull {0}\n", _this.CullingValue());
			}
			if (!_this.OffsetFactor.IsZero() || !_this.OffsetUnits.IsZero())
			{
				writer.WriteIndent(3);
				writer.Write("Offset {0}, {1}\n", _this.OffsetFactor.Val, _this.OffsetUnits.Val);
			}

			if (!_this.StencilRef.IsZero() || !_this.StencilReadMask.IsMax() || !_this.StencilWriteMask.IsMax() || !_this.StencilOp.IsDefault() || !_this.StencilOpFront.IsDefault() || !_this.StencilOpBack.IsDefault())
			{
				writer.WriteIndent(3);
				writer.Write("Stencil {\n");
				if (!_this.StencilRef.IsZero())
				{
					writer.WriteIndent(4);
					writer.Write("Ref {0}\n", _this.StencilRef.Val);
				}
				if (!_this.StencilReadMask.IsMax())
				{
					writer.WriteIndent(4);
					writer.Write("ReadMask {0}\n", _this.StencilReadMask.Val);
				}
				if (!_this.StencilWriteMask.IsMax())
				{
					writer.WriteIndent(4);
					writer.Write("WriteMask {0}\n", _this.StencilWriteMask.Val);
				}
				if (!_this.StencilOp.IsDefault())
				{
					_this.StencilOp.Export(writer, StencilType.Base);
				}
				if (!_this.StencilOpFront.IsDefault())
				{
					_this.StencilOpFront.Export(writer, StencilType.Front);
				}
				if (!_this.StencilOpBack.IsDefault())
				{
					_this.StencilOpBack.Export(writer, StencilType.Back);
				}
				writer.WriteIndent(3);
				writer.Write("}\n");
			}

			if (!_this.FogModeValue().IsUnknown() || !_this.FogColor.IsZero() || !_this.FogDensity.IsZero() || !_this.FogStart.IsZero() || !_this.FogEnd.IsZero())
			{
				writer.WriteIndent(3);
				writer.Write("Fog {\n");
				if (!_this.FogModeValue().IsUnknown())
				{
					writer.WriteIndent(4);
					writer.Write("Mode {0}\n", _this.FogMode);
				}
				if (!_this.FogColor.IsZero())
				{
					writer.WriteIndent(4);
					writer.Write("Color ({0},{1},{2},{3})\n",
						_this.FogColor.X.Val.ToString(CultureInfo.InvariantCulture),
						_this.FogColor.Y.Val.ToString(CultureInfo.InvariantCulture),
						_this.FogColor.Z.Val.ToString(CultureInfo.InvariantCulture),
						_this.FogColor.W.Val.ToString(CultureInfo.InvariantCulture));
				}
				if (!_this.FogDensity.IsZero())
				{
					writer.WriteIndent(4);
					writer.Write("Density {0}\n", _this.FogDensity.Val.ToString(CultureInfo.InvariantCulture));
				}
				if (!_this.FogStart.IsZero() || !_this.FogEnd.IsZero())
				{
					writer.WriteIndent(4);
					writer.Write("Range {0}, {1}\n",
						_this.FogStart.Val.ToString(CultureInfo.InvariantCulture),
						_this.FogEnd.Val.ToString(CultureInfo.InvariantCulture));
				}
				writer.WriteIndent(3);
				writer.Write("}\n");
			}

			if (_this.Lighting)
			{
				writer.WriteIndent(3);
				writer.Write("Lighting {0}\n", _this.LightingValue());
			}
			writer.WriteIndent(3);
			writer.Write("GpuProgramID {0}\n", _this.GpuProgramID);
		}

		public static void Export(this ISerializedStencilOp _this, TextWriter writer, StencilType type)
		{
			writer.WriteIndent(4);
			writer.Write("Comp{0} {1}\n", type.ToSuffixString(), _this.CompValue());
			writer.WriteIndent(4);
			writer.Write("Pass{0} {1}\n", type.ToSuffixString(), _this.PassValue());
			writer.WriteIndent(4);
			writer.Write("Fail{0} {1}\n", type.ToSuffixString(), _this.FailValue());
			writer.WriteIndent(4);
			writer.Write("ZFail{0} {1}\n", type.ToSuffixString(), _this.ZFailValue());
		}

		public static void Export(this ISerializedSubProgram _this, ShaderWriter writer, ShaderType type, bool isTier)
		{
			writer.WriteIndent(4);
#warning TODO: convertion (DX to HLSL)
			ShaderGpuProgramType programType = _this.GetProgramType(writer.Version);
			GPUPlatform graphicApi = programType.ToGPUPlatform(writer.Platform);
			writer.Write("SubProgram \"{0} ", graphicApi);
			if (isTier)
			{
				writer.Write("hw_tier{0} ", _this.ShaderHardwareTier.ToString("00"));
			}
			writer.Write("\" {\n");
			writer.WriteIndent(5);

			int platformIndex = writer.Shader.Platforms_C48.IndexOf((uint)graphicApi);
			writer.Blobs[platformIndex].SubPrograms[_this.BlobIndex].Export(writer, type);

			writer.Write('\n');
			writer.WriteIndent(4);
			writer.Write("}\n");
		}

		public static void Export(this ISerializedSubShader _this, ShaderWriter writer)
		{
			writer.WriteIndent(1);
			writer.Write("SubShader {\n");
			if (_this.LOD != 0)
			{
				writer.WriteIndent(2);
				writer.Write("LOD {0}\n", _this.LOD);
			}
			_this.Tags.Export(writer, 2);
			for (int i = 0; i < _this.Passes.Count; i++)
			{
				_this.Passes[i].Export(writer);
			}
			writer.WriteIndent(1);
			writer.Write("}\n");
		}

		public static void Export(this SerializedTagMap _this, TextWriter writer, int indent)
		{
			if (_this.Tags.Count != 0)
			{
				writer.WriteIndent(indent);
				writer.Write("Tags { ");
				foreach (var kvp in _this.Tags)
				{
					writer.Write("\"{0}\" = \"{1}\" ", kvp.Key, kvp.Value);
				}
				writer.Write("}\n");
			}
		}

		public static void Export(this ShaderSubProgram _this, ShaderWriter writer, ShaderType type)
		{
			if (_this.GlobalKeywords.Length > 0)
			{
				writer.Write("Keywords { ");
				foreach (string keyword in _this.GlobalKeywords)
				{
					writer.Write("\"{0}\" ", keyword);
				}
				if (ShaderSubProgram.HasLocalKeywords(writer.Version))
				{
					foreach (string keyword in _this.LocalKeywords)
					{
						writer.Write("\"{0}\" ", keyword);
					}
				}
				writer.Write("}\n");
				writer.WriteIndent(5);
			}

#warning TODO: convertion (DX to HLSL)
			ShaderGpuProgramType programType = _this.GetProgramType(writer.Version);
			writer.Write("\"{0}", programType.ToProgramDataKeyword(writer.Platform, type));
			if (_this.ProgramData.Length > 0)
			{
				writer.Write("\n");
				writer.WriteIndent(5);

				writer.WriteShaderData(ref _this);
			}
			writer.Write('"');
		}

		public static void Export(this ShaderSubProgramBlob _this, ShaderWriter writer, string header)
		{
			int j = 0;
			while (true)
			{
				int index = header.IndexOf(ShaderSubProgramBlob.GpuProgramIndexName, j);
				if (index == -1)
				{
					break;
				}

				int length = index - j;
				writer.WriteString(header, j, length);
				j += length + ShaderSubProgramBlob.GpuProgramIndexName.Length + 1;

				int subIndex = -1;
				for (int startIndex = j; j < header.Length; j++)
				{
					if (!char.IsDigit(header[j]))
					{
						string numberStr = header.Substring(startIndex, j - startIndex);
						subIndex = int.Parse(numberStr);
						break;
					}
				}

				// we don't know shader type so pass vertex
				_this.SubPrograms[subIndex].Export(writer, ShaderType.Vertex);
			}
			writer.WriteString(header, j, header.Length - j);
		}
	}
}

```

`ShaderTextRestorer/IO/ShaderWriter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using AssetRipper.Core.IO;
using AssetRipper.Core.Parser.Files;
using AssetRipper.Core.SourceGenExtensions;
using AssetRipper.SourceGenerated.Classes.ClassID_48;
using AssetRipper.VersionUtilities;
using ShaderTextRestorer.Exporters;
using ShaderTextRestorer.Extensions;
using ShaderTextRestorer.ShaderBlob;
using System;
using System.IO;
using System.Text;


namespace ShaderTextRestorer.IO
{
	public class ShaderWriter : InvariantStreamWriter
	{
		public ShaderWriter(Stream stream, IShader shader, Func<UnityVersion, GPUPlatform, ShaderTextExporter> exporterInstantiator) : base(stream, new UTF8Encoding(false), 4096, true)
		{
			if (shader == null)
			{
				throw new ArgumentNullException(nameof(shader));
			}
			if (exporterInstantiator == null)
			{
				throw new ArgumentNullException(nameof(exporterInstantiator));
			}

			Shader = shader;
			Blobs = shader.ReadBlobs();
			m_exporterInstantiator = exporterInstantiator;
		}

		public void WriteShaderData(ref ShaderSubProgram subProgram)
		{
			ShaderGpuProgramType programType = subProgram.GetProgramType(Version);
			GPUPlatform graphicApi = programType.ToGPUPlatform(Platform);
			ShaderTextExporter exporter = m_exporterInstantiator.Invoke(Shader.SerializedFile.Version, graphicApi);
			exporter.Export(this, ref subProgram);
		}

		public IShader Shader { get; }
		public ShaderSubProgramBlob[] Blobs { get; }
		public UnityVersion Version => Shader.SerializedFile.Version;
		public BuildTarget Platform => Shader.SerializedFile.Platform;

		private readonly Func<UnityVersion, GPUPlatform, ShaderTextExporter> m_exporterInstantiator;
	}
}

```

`ShaderTextRestorer/README.md`:

```md
# Shader Text Restorer

This project handles all the efforts to restore shaders to something resembling the original shader.

Basic blob export is currently possible for most shaders.
```

`ShaderTextRestorer/Resources/DXProgramType.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	public enum DXProgramType
	{
		PixelShader = 0xFFFF,
		VertexShader = 0xFFFE,
		GeometryShader = 0x4753,
		HullShader = 0x4853,
		DomainShader = 0x4453,
		ComputeShader = 0x4353,
	}
}
```

`ShaderTextRestorer/Resources/ResourceBindingChunk.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using AssetRipper.IO.Endian;
using ShaderTextRestorer.ShaderBlob;
using ShaderTextRestorer.ShaderBlob.Parameters;

namespace ShaderTextRestorer.Resources
{
	internal class ResourceBindingChunk
	{
		public ResourceBindingChunk(ref ShaderSubProgram shaderSubprogram, uint resourceBindingOffset, Dictionary<string, uint> nameLookup)
		{
			m_shaderSubprogram = shaderSubprogram;
			m_nameLookup = nameLookup;
			m_Samplers = CreateSamplers(ref shaderSubprogram);
			const uint bindingHeaderSize = 32;
			uint nameOffset = resourceBindingOffset + bindingHeaderSize * Count;
			foreach (BufferBinding bufferParam in shaderSubprogram.BufferParameters)
			{
				nameLookup[bufferParam.Name] = nameOffset;
				nameOffset += (uint)bufferParam.Name.Length + 1;
			}
			foreach (TextureParameter textureParam in shaderSubprogram.TextureParameters)
			{
				nameLookup[textureParam.Name] = nameOffset;
				nameOffset += (uint)textureParam.Name.Length + 1;
			}
			foreach (Sampler sampler in m_Samplers)
			{
				nameLookup[sampler.Name] = nameOffset;
				nameOffset += (uint)sampler.Name.Length + 1;
			}
			foreach (BufferBinding constantBuffer in shaderSubprogram.ConstantBufferBindings)
			{
				nameLookup[constantBuffer.Name] = nameOffset;
				nameOffset += (uint)constantBuffer.Name.Length + 1;
			}
			Size = nameOffset - resourceBindingOffset;
		}

		internal uint Count => (uint)m_shaderSubprogram.ConstantBuffers.Length +
			(uint)m_shaderSubprogram.TextureParameters.Length +
			(uint)m_Samplers.Count +
			(uint)m_shaderSubprogram.BufferParameters.Length;

		internal uint Size { get; }

		private static List<Sampler> CreateSamplers(ref ShaderSubProgram shaderSubprogram)
		{
#warning Needs work
			/*
			 * Unity supports three types of samplers
			 * Coupled textures and sampler:
			 *		sampler2D _MainTex;
			 *		TODO: Investigate how they work
			 * Separate textures and samplers:
			 *		Texture2D _MainTex;
			 *		SamplerState sampler_MainTex; // "sampler" + “_MainTex”
			 *		These samplers do not contain an entry in SamplerParameters
			 * Inline sampler states: 
			 *		Texture2D _MainTex;
			 *		SamplerState my_point_clamp_sampler;
			 *		These samplers do contain an entry in SamplerParameters
			 * See https://docs.unity3d.com/Manual/SL-SamplerStates.html
			 */
			List<Sampler> samplers = new List<Sampler>();
			foreach (TextureParameter textureParam in shaderSubprogram.TextureParameters)
			{
				if (textureParam.SamplerIndex < 0 || textureParam.SamplerIndex == 0xFFFF) continue;
				string samplerName = "sampler" + textureParam.Name;
				samplers.Add(new Sampler(samplerName, (uint)textureParam.SamplerIndex, false));
			}
			foreach (SamplerParameter samplerParam in shaderSubprogram.SamplerParameters ?? Array.Empty<SamplerParameter>())
			{
				SamplerFilterMode filterMode = (SamplerFilterMode)(samplerParam.Sampler & 0x3);
				SamplerWrapMode wrapU = (SamplerWrapMode)(samplerParam.Sampler >> 2 & 0x3);
				SamplerWrapMode wrapV = (SamplerWrapMode)(samplerParam.Sampler >> 4 & 0x3);
				SamplerWrapMode wrapW = (SamplerWrapMode)(samplerParam.Sampler >> 6 & 0x3);
				bool isComparisonSampler = (samplerParam.Sampler & 0x100) != 0;
				string samplerName;
				if (wrapU == wrapV && wrapU == wrapW)
				{
					samplerName = $"{filterMode}_{wrapU}";
				}
				else
				{
					samplerName = $"{filterMode}_{wrapU}U_{wrapV}V_{wrapW}W";
				}
				if (isComparisonSampler)
				{
					samplerName += $"_Comparison";
				}
				samplerName += $"_Sampler{samplerParam.BindPoint}";
				samplers.Add(new Sampler(samplerName, (uint)samplerParam.BindPoint, isComparisonSampler));
			}
			samplers = samplers.OrderBy(s => s.BindPoint).ToList();
			System.Diagnostics.Debug.Assert(samplers.Select(s => s.BindPoint).Distinct().Count()
				== samplers.Select(s => s.BindPoint).Count(), "Duplicate sampler bindpoint");
			System.Diagnostics.Debug.Assert(samplers.Select(s => s.BindPoint).Distinct().Count()
				== samplers.Select(s => s.BindPoint).Count(), "Duplicate sampler name");
			return samplers;
		}
		internal void Write(EndianWriter writer)
		{
			foreach (BufferBinding bufferParam in m_shaderSubprogram.BufferParameters)
			{
				//Resource bindings
				//nameOffset
				writer.Write(m_nameLookup[bufferParam.Name]);
				//shader input type
				writer.Write((uint)ShaderInputType.Structured);
				//Resource return type
				writer.Write((uint)ResourceReturnType.Mixed);
				//Resource view dimension
				writer.Write((uint)ShaderResourceViewDimension.Buffer);

#warning TODO: Check this
				//Number of samples
				writer.Write((uint)56);

				//Bind point
				writer.Write((uint)bufferParam.Index);
				//Bind count
				writer.Write((uint)1);
				//Shader input flags
				writer.Write((uint)ShaderInputFlags.None);
			}
			foreach (Sampler sampler in m_Samplers)
			{
				//Resource bindings
				//nameOffset
				writer.Write(m_nameLookup[sampler.Name]);
				//shader input type
				writer.Write((uint)ShaderInputType.Sampler);
				//Resource return type
				writer.Write((uint)ResourceReturnType.NotApplicable);
				//Resource view dimension
				writer.Write((uint)ShaderResourceViewDimension.Unknown);
				//Number of samples
				writer.Write((uint)0);
				//Bind point
				writer.Write(sampler.BindPoint);
				//Bind count
				writer.Write((uint)1);
				//Shader input flags
				ShaderInputFlags samplerFlags = sampler.IsComparisonSampler ?
					ShaderInputFlags.ComparisonSampler : ShaderInputFlags.None;
				writer.Write((uint)samplerFlags);
			}
			foreach (TextureParameter textureParam in m_shaderSubprogram.TextureParameters)
			{
				//Resource bindings
				//nameOffset
				writer.Write(m_nameLookup[textureParam.Name]);
				//shader input type
				writer.Write((uint)ShaderInputType.Texture);
				//Resource return type
				writer.Write((uint)ResourceReturnType.Float);
				//Resource view dimension
				writer.Write((uint)GetTextureDimension(textureParam));
				//Number of samples
				writer.Write(uint.MaxValue);
				//Bind point
				writer.Write((uint)textureParam.Index);
				//Bind count
				writer.Write((uint)1);
				//Shader input flags
				writer.Write((uint)ShaderInputFlags.TextureComponents);
			}
			foreach (BufferBinding constantBuffer in m_shaderSubprogram.ConstantBufferBindings)
			{
				//Resource bindings
				//nameOffset
				writer.Write(m_nameLookup[constantBuffer.Name]);
				//shader input type
				writer.Write((uint)ShaderInputType.CBuffer);
				//Resource return type
				writer.Write((uint)ResourceReturnType.NotApplicable);
				//Resource view dimension
				writer.Write((uint)ShaderResourceViewDimension.Unknown);
				//Number of samples
				writer.Write((uint)0);
				//Bind point
				writer.Write((uint)constantBuffer.Index);
				//Bind count
				writer.Write((uint)1);
				//Shader input flags
				writer.Write((uint)ShaderInputFlags.None);
			}

			foreach (BufferBinding bufferParam in m_shaderSubprogram.BufferParameters)
			{
				writer.WriteStringZeroTerm(bufferParam.Name);
			}
			foreach (TextureParameter textureParam in m_shaderSubprogram.TextureParameters)
			{
				writer.WriteStringZeroTerm(textureParam.Name);
			}
			foreach (Sampler sampler in m_Samplers)
			{
				writer.WriteStringZeroTerm(sampler.Name);
			}
			foreach (BufferBinding constantBuffer in m_shaderSubprogram.ConstantBufferBindings)
			{
				writer.WriteStringZeroTerm(constantBuffer.Name);
			}
		}

		ShaderResourceViewDimension GetTextureDimension(TextureParameter param)
		{
			switch (param.Dim)
			{
				case 2:
					return ShaderResourceViewDimension.Texture2D;
				case 3:
					return ShaderResourceViewDimension.Texture3D;
				case 4:
					return ShaderResourceViewDimension.TextureCube;
				case 5:
					return ShaderResourceViewDimension.Texture2DArray;
				case 6:
					return ShaderResourceViewDimension.TextureCubeArray;
				default:
					return ShaderResourceViewDimension.Texture2D;
			}
		}

		private readonly Dictionary<string, uint> m_nameLookup;
		private readonly List<Sampler> m_Samplers;

		private ShaderSubProgram m_shaderSubprogram;
	}
}

```

`ShaderTextRestorer/Resources/ResourceChunk.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using System.Collections.Generic;
using System.Text;
using ShaderTextRestorer.ConstantBuffers;
using ShaderTextRestorer.Extensions;
using AssetRipper.VersionUtilities;
using AssetRipper.IO.Endian;
using ShaderTextRestorer.ShaderBlob;

namespace ShaderTextRestorer.Resources
{
	internal class ResourceChunk
	{
		public ResourceChunk(UnityVersion version, ref ShaderSubProgram shaderSubprogram)
		{
			ShaderGpuProgramType programType = shaderSubprogram.GetProgramType(version);
			m_majorVersion = (byte)programType.GetMajorDXVersion();
			m_resourceBindingOffset = m_majorVersion >= 5 ? 60 : (uint)28;
			m_resourceBindings = new ResourceBindingChunk(ref shaderSubprogram, m_resourceBindingOffset, m_nameLookup);
			m_constantBufferOffset = m_resourceBindingOffset + m_resourceBindings.Size;
			m_constantBuffers = new ConstantBufferChunk(version, ref shaderSubprogram, m_constantBufferOffset, m_nameLookup);
			m_creatorStringOffset = m_constantBufferOffset + m_constantBuffers.Size;
			m_creatorString = "AssetRipper";
			m_chunkSize = m_creatorStringOffset + (uint)m_creatorString.Length + 1;
			m_programType = programType.ToDXProgramType();
		}

		public void Write(EndianWriter writer)
		{
			writer.Write(Encoding.ASCII.GetBytes("RDEF"));
			writer.Write(m_chunkSize);
			writer.Write(m_constantBuffers.Count);
			writer.Write(m_constantBufferOffset);
			writer.Write(m_resourceBindings.Count);
			writer.Write(m_resourceBindingOffset);
			byte minorVersion = 0;
			writer.Write(minorVersion);
			writer.Write(m_majorVersion);
			writer.Write((ushort)m_programType);
			var flags = ShaderFlags.NoPreshader;
			writer.Write((uint)flags);
			writer.Write(m_creatorStringOffset);
			if (m_majorVersion >= 5)
			{
				//rd11
				writer.Write(Encoding.ASCII.GetBytes("RD11"));
				//unknown1
				writer.Write((uint)60);
				//unknown2
				writer.Write((uint)24);
				//unknown3
				writer.Write((uint)32);
				//unknown4
				writer.Write((uint)40);
				//unknown5
				writer.Write((uint)36);
				//unknown6
				writer.Write((uint)12);
				//InterfaceSlotCount
				writer.Write((uint)0);
			}
			m_resourceBindings.Write(writer);
			m_constantBuffers.Write(writer);
			writer.WriteStringZeroTerm(m_creatorString);
		}

		public uint Size => m_chunkSize + 8;

		private readonly Dictionary<string, uint> m_nameLookup = new Dictionary<string, uint>();

		//Length of Resource starting from constantBufferCount
		private readonly uint m_chunkSize;
		private readonly uint m_constantBufferOffset;
		private readonly uint m_resourceBindingOffset;
		private readonly DXProgramType m_programType;
		private readonly uint m_creatorStringOffset;
		private readonly ConstantBufferChunk m_constantBuffers;
		private readonly ResourceBindingChunk m_resourceBindings;
		private readonly string m_creatorString;
		private readonly byte m_majorVersion;
	}
}

```

`ShaderTextRestorer/Resources/ResourceReturnType.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum ResourceReturnType
	{
		NotApplicable = 0,
		UNorm = 1,
		SNorm = 2,
		SInt = 3,
		UInt = 4,
		Float = 5,
		Mixed = 6,
		Double = 7,
		Continued = 8
	}
}
```

`ShaderTextRestorer/Resources/Sampler.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal class Sampler
	{
		public string Name;
		public uint BindPoint;
		public bool IsComparisonSampler;
		public Sampler(string name, uint bindPoint, bool isComparisonSampler)
		{
			Name = name;
			BindPoint = bindPoint;
			IsComparisonSampler = isComparisonSampler;
		}
	}
}

```

`ShaderTextRestorer/Resources/SamplerFilterMode.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum SamplerFilterMode
	{
		Point,
		Linear,
		Trilinear,
	}
}

```

`ShaderTextRestorer/Resources/SamplerWrapMode.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum SamplerWrapMode
	{
		Repeat,
		Clamp,
		Mirror,
		MirrorOnce,
	}
}

```

`ShaderTextRestorer/Resources/ShaderFlags.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum ShaderFlags
	{
		None = 0,
		Debug = 1,
		SkipValidation = 2,
		SkipOptimization = 4,
		PackMatrixRowMajor = 8,
		PackMatrixColumnMajor = 16,
		PartialPrecision = 32,
		ForceVsSoftwareNoOpt = 64,
		ForcePsSoftwareNoOpt = 128,
		NoPreshader = 256,
		AvoidFlowControl = 512,
		PreferFlowControl = 1024,
		EnableStrictness = 2048,
		EnableBackwardsCompatibility = 4096,
		IeeeStrictness = 8192,
		OptimizationLevel0 = 16384,
		OptimizationLevel1 = 0,
		OptimizationLevel2 = 49152,
		OptimizationLevel3 = 32768,
		Reserved16 = 65536,
		Reserved17 = 131072,
		WarningsAreErrors = 262144
	}
}
```

`ShaderTextRestorer/Resources/ShaderInputFlags.cs`:

```cs
using System;

namespace ShaderTextRestorer.Resources
{
	[Flags]
	internal enum ShaderInputFlags
	{
		None = 0x0,
		UserPacked = 0x1,
		ComparisonSampler = 0x2,
		TextureComponent0 = 0x4,
		TextureComponent1 = 0x8,
		TextureComponents = TextureComponent0 | TextureComponent1,
		Unused = 0x10,
	}
}
```

`ShaderTextRestorer/Resources/ShaderInputType.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum ShaderInputType
	{
		CBuffer = 0,
		TBuffer = 1,
		Texture = 2,
		Sampler = 3,
		UavRwTyped = 4,
		Structured = 5,
		UavRwStructured = 6,
		ByteAddress = 7,
		UavRwByteAddress = 8,
		UavAppendStructured = 9,
		UavConsumeStructured = 10,
		UavRwStructuredWithCounter = 11
	}
}
```

`ShaderTextRestorer/Resources/ShaderResourceViewDimension.cs`:

```cs
namespace ShaderTextRestorer.Resources
{
	internal enum ShaderResourceViewDimension
	{
		Unknown = 0,
		Buffer = 1,
		Texture1D = 2,
		Texture1DArray = 3,
		Texture2D = 4,
		Texture2DArray = 5,
		Texture2DMultiSampled = 6,
		Texture2DMultiSampledArray = 7,
		Texture3D = 8,
		TextureCube = 9,
		TextureCubeArray = 10,
		ExtendedBuffer = 11,
	}
}
```

`ShaderTextRestorer/ShaderBlob/Parameters/BufferBinding.cs`:

```cs
namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class BufferBinding
	{
		public BufferBinding() { }

		public BufferBinding(string name, int index)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			ArraySize = 0;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int ArraySize { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/ConstantBuffer.cs`:

```cs
using System;

namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class ConstantBuffer
	{
		public ConstantBuffer() { }

		public ConstantBuffer(string name, MatrixParameter[] matrices, VectorParameter[] vectors, StructParameter[] structs, int usedSize)
		{
			Name = name;
			NameIndex = -1;
			MatrixParams = matrices;
			VectorParams = vectors;
			StructParams = structs;
			Size = usedSize;
			IsPartialCB = false;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public MatrixParameter[] MatrixParams { get; set; } = Array.Empty<MatrixParameter>();
		public VectorParameter[] VectorParams { get; set; } = Array.Empty<VectorParameter>();
		public StructParameter[] StructParams { get; set; } = Array.Empty<StructParameter>();
		public int Size { get; set; }
		public bool IsPartialCB { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/MatrixParameter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;

namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class MatrixParameter
	{
		public MatrixParameter() { }

		public MatrixParameter(string name, ShaderParamType type, int index, int rowCount, int columnCount)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			ArraySize = 0;
			Type = type;
			RowCount = (byte)rowCount;
			ColumnCount = (byte)columnCount;
		}

		public MatrixParameter(string name, ShaderParamType type, int index, int arraySize, int rowCount, int columnCount) : this(name, type, index, rowCount, columnCount)
		{
			ArraySize = arraySize;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int ArraySize { get; set; }
		public ShaderParamType Type { get; set; }
		public byte RowCount { get; set; }
		public byte ColumnCount { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/SamplerParameter.cs`:

```cs
namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class SamplerParameter
	{
		public SamplerParameter() { }

		public SamplerParameter(uint sampler, int bindPoint)
		{
			Sampler = sampler;
			BindPoint = bindPoint;
		}

		public uint Sampler { get; set; }
		public int BindPoint { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/StructParameter.cs`:

```cs
using System;

namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class StructParameter
	{
		public StructParameter() { }

		public StructParameter(string name, int index, int arraySize, int structSize, VectorParameter[] vectors, MatrixParameter[] matrices)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			ArraySize = arraySize;
			StructSize = structSize;
			VectorMembers = vectors;
			MatrixMembers = matrices;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int ArraySize { get; set; }
		public int StructSize { get; set; }
		public VectorParameter[] VectorMembers { get; set; } = Array.Empty<VectorParameter>();
		public MatrixParameter[] MatrixMembers { get; set; } = Array.Empty<MatrixParameter>();
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/TextureParameter.cs`:

```cs
namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class TextureParameter
	{
		public TextureParameter() { }

		public TextureParameter(string name, int index, byte dimension, int sampler)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			Dim = dimension;
			SamplerIndex = sampler;
			MultiSampled = false;
		}

		public TextureParameter(string name, int index, byte dimension, int sampler, bool multiSampled) : this(name, index, dimension, sampler)
		{
			MultiSampled = multiSampled;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int SamplerIndex { get; set; }
		public bool MultiSampled { get; set; }
		public byte Dim { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/UAVParameter.cs`:

```cs
namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class UAVParameter
	{
		public UAVParameter() { }

		public UAVParameter(string name, int index, int originalIndex)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			OriginalIndex = originalIndex;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int OriginalIndex { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/Parameters/VectorParameter.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;

namespace ShaderTextRestorer.ShaderBlob.Parameters
{
	public sealed class VectorParameter
	{
		public VectorParameter() { }

		public VectorParameter(string name, ShaderParamType type, int index, int columns)
		{
			Name = name;
			NameIndex = -1;
			Index = index;
			ArraySize = 0;
			Type = type;
			Dim = (byte)columns;
		}

		public VectorParameter(string name, ShaderParamType type, int index, int arraySize, int columns) : this(name, type, index, columns)
		{
			ArraySize = arraySize;
		}

		public string Name { get; set; } = string.Empty;
		public int NameIndex { get; set; }
		public int Index { get; set; }
		public int ArraySize { get; set; }
		public ShaderParamType Type { get; set; }
		public byte Dim { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/ParserBindChannels.cs`:

```cs
namespace ShaderTextRestorer.ShaderBlob
{
	public sealed class ParserBindChannels
	{
		public ParserBindChannels() { }

		public ParserBindChannels(ShaderBindChannel[] channels, int sourceMap)
		{
			Channels = channels;
			SourceMap = sourceMap;
		}

		public ShaderBindChannel[] Channels { get; set; } = System.Array.Empty<ShaderBindChannel>();
		public int SourceMap { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/ShaderBindChannel.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;

namespace ShaderTextRestorer.ShaderBlob
{
	public sealed class ShaderBindChannel
	{
		public ShaderBindChannel() { }

		public ShaderBindChannel(uint source, VertexComponent target)
		{
			Source = source;
			Target = target;
		}

		/// <summary>
		/// ShaderChannel enum
		/// </summary>
		public uint Source { get; set; }
		public VertexComponent Target { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderBlob/ShaderSubProgram.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using AssetRipper.Core.IO.Asset;
using AssetRipper.VersionUtilities;
using ShaderTextRestorer.ShaderBlob.Parameters;
using System;
using System.Collections.Generic;


namespace ShaderTextRestorer.ShaderBlob
{
	public sealed class ShaderSubProgram : IAssetReadable, IAssetWritable
	{
		/// <summary>
		/// 2019.1 and greater
		/// </summary>
		public static bool HasLocalKeywords(UnityVersion version) => version.IsGreaterEqual(2019);
		/// <summary>
		/// 5.5.0 and greater
		/// </summary>
		public static bool HasUAVParameters(UnityVersion version) => version.IsGreaterEqual(5, 5);
		/// <summary>
		/// 2017.2 and greater
		/// </summary>
		public static bool HasSamplerParameters(UnityVersion version) => version.IsGreaterEqual(2017, 1);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		public static bool HasMultiSampled(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 5.5.0 and greater
		/// </summary>
		private static bool HasStatsTempRegister(UnityVersion version) => version.IsGreaterEqual(5, 5);
		/// <summary>
		/// 5.5.0 and greater
		/// </summary>
		private static bool IsAllParamArgs(UnityVersion version) => version.IsGreaterEqual(5, 5);
		/// <summary>
		/// 2017.3 and greater
		/// </summary>
		private static bool HasStructParameters(UnityVersion version) => version.IsGreaterEqual(2017, 3);
		/// <summary>
		/// 2018.2 and greater
		/// </summary>
		private static bool HasNewTextureParams(UnityVersion version) => version.IsGreaterEqual(2018, 2);
		/// <summary>
		/// 2021.2 and greater
		/// </summary>
		public static bool HasMergedKeywords(UnityVersion version) => version.IsGreaterEqual(2021, 2);
		private static int GetExpectedProgramVersion(UnityVersion version)
		{
			if (version.IsEqual(5, 3))
			{
				return 201509030;
			}
			else if (version.IsEqual(5, 4))
			{
				return 201510240;
			}
			else if (version.IsEqual(5, 5))
			{
				return 201608170;
			}
			else if (version.IsLess(2017, 3))
			{
				return 201609010;
			}
			else if (version.IsLess(2018, 2))
			{
				return 201708220;
			}
			else if (version.IsLess(2019))
			{
				return 201802150;
			}
			else if (version.IsLess(2021, 2))
			{
				return 201806140;
			}
			else
			{
				return 202012090;
			}
		}

		public void Read(AssetReader reader)
		{
			int version = reader.ReadInt32();
			if (version != GetExpectedProgramVersion(reader.Version))
			{
				throw new Exception($"Shader program version {version} doesn't match");
			}

			ProgramType = reader.ReadInt32();
			StatsALU = reader.ReadInt32();
			StatsTEX = reader.ReadInt32();
			StatsFlow = reader.ReadInt32();
			if (HasStatsTempRegister(reader.Version))
			{
				StatsTempRegister = reader.ReadInt32();
			}

			if (HasMergedKeywords(reader.Version))
			{
				reader.ReadStringArray();
			}
			else
			{
				GlobalKeywords = reader.ReadStringArray();
				if (HasLocalKeywords(reader.Version))
				{
					LocalKeywords = reader.ReadStringArray();
				}
			}

			ProgramData = reader.ReadByteArray();
			reader.AlignStream();

			int sourceMap = reader.ReadInt32();
			int bindCount = reader.ReadInt32();
			ShaderBindChannel[] channels = new ShaderBindChannel[bindCount];
			for (int i = 0; i < bindCount; i++)
			{
				uint source = reader.ReadUInt32();
				VertexComponent target = (VertexComponent)reader.ReadUInt32();
				ShaderBindChannel channel = new ShaderBindChannel(source, target);
				channels[i] = channel;
				sourceMap |= 1 << (int)source;
			}
			BindChannels = new ParserBindChannels(channels, sourceMap);

			List<VectorParameter> vectors = new List<VectorParameter>();
			List<MatrixParameter> matrices = new List<MatrixParameter>();
			List<TextureParameter> textures = new List<TextureParameter>();
			List<VectorParameter> structVectors = new List<VectorParameter>();
			List<MatrixParameter> structMatrices = new List<MatrixParameter>();
			List<BufferBinding> buffers = new List<BufferBinding>();
			List<UAVParameter>? uavs = HasUAVParameters(reader.Version) ? new List<UAVParameter>() : null;
			List<SamplerParameter>? samplers = HasSamplerParameters(reader.Version) ? new List<SamplerParameter>() : null;
			List<BufferBinding> constBindings = new List<BufferBinding>();
			List<StructParameter> structs = new List<StructParameter>();

			int paramGroupCount = reader.ReadInt32();
			ConstantBuffers = new ConstantBuffer[paramGroupCount - 1];
			for (int i = 0; i < paramGroupCount; i++)
			{
				vectors.Clear();
				matrices.Clear();
				structs.Clear();

				string name = reader.ReadString();
				int usedSize = reader.ReadInt32();
				int paramCount = reader.ReadInt32();
				for (int j = 0; j < paramCount; j++)
				{
					string paramName = reader.ReadString();
					ShaderParamType paramType = (ShaderParamType)reader.ReadInt32();
					int rows = reader.ReadInt32();
					int columns = reader.ReadInt32();
					bool isMatrix = reader.ReadInt32() > 0;
					int arraySize = reader.ReadInt32();
					int index = reader.ReadInt32();

					if (isMatrix)
					{
						MatrixParameter matrix = IsAllParamArgs(reader.Version)
							? new MatrixParameter(paramName, paramType, index, arraySize, rows, columns)
							: new MatrixParameter(paramName, paramType, index, rows, columns);
						matrices.Add(matrix);
					}
					else
					{
						VectorParameter vector = IsAllParamArgs(reader.Version)
							? new VectorParameter(paramName, paramType, index, arraySize, columns)
							: new VectorParameter(paramName, paramType, index, columns);
						vectors.Add(vector);
					}
				}

				if (HasStructParameters(reader.Version))
				{
					int structCount = reader.ReadInt32();
					for (int j = 0; j < structCount; j++)
					{
						structVectors.Clear();
						structMatrices.Clear();

						string structName = reader.ReadString();
						int index = reader.ReadInt32();
						int arraySize = reader.ReadInt32();
						int structSize = reader.ReadInt32();

						int strucParamCount = reader.ReadInt32();
						for (int k = 0; k < strucParamCount; k++)
						{
							string paramName = reader.ReadString();
							paramName = $"{structName}.{paramName}";
							ShaderParamType paramType = (ShaderParamType)reader.ReadInt32();
							int rows = reader.ReadInt32();
							int columns = reader.ReadInt32();
							bool isMatrix = reader.ReadInt32() > 0;
							int vectorArraySize = reader.ReadInt32();
							int paramIndex = reader.ReadInt32();

							if (isMatrix)
							{
								MatrixParameter matrix = IsAllParamArgs(reader.Version)
									? new MatrixParameter(paramName, paramType, paramIndex, vectorArraySize, rows, columns)
									: new MatrixParameter(paramName, paramType, paramIndex, rows, columns);
								structMatrices.Add(matrix);
							}
							else
							{
								VectorParameter vector = IsAllParamArgs(reader.Version)
									? new VectorParameter(paramName, paramType, paramIndex, vectorArraySize, columns)
									: new VectorParameter(paramName, paramType, paramIndex, columns);
								structVectors.Add(vector);
							}
						}

						StructParameter @struct = new StructParameter(structName, index, arraySize, structSize, structVectors.ToArray(), structMatrices.ToArray());
						structs.Add(@struct);
					}
				}
				if (i == 0)
				{
					VectorParameters = vectors.ToArray();
					MatrixParameters = matrices.ToArray();
					StructParameters = structs.ToArray();
				}
				else
				{
					ConstantBuffer constBuffer = new ConstantBuffer(name, matrices.ToArray(), vectors.ToArray(), structs.ToArray(), usedSize);
					ConstantBuffers[i - 1] = constBuffer;
				}
			}

			int paramGroup2Count = reader.ReadInt32();
			for (int i = 0; i < paramGroup2Count; i++)
			{
				string name = reader.ReadString();
				int type = reader.ReadInt32();
				int index = reader.ReadInt32();
				int extraValue = reader.ReadInt32();

				if (type == 0)
				{
					TextureParameter texture;
					if (HasNewTextureParams(reader.Version))
					{
						uint textureExtraValue = reader.ReadUInt32();
						bool isMultiSampled = (textureExtraValue & 1) == 1;
						byte dimension = (byte)(textureExtraValue >> 1);
						int samplerIndex = extraValue;
						texture = new TextureParameter(name, index, dimension, samplerIndex, isMultiSampled);
					}
					else if (HasMultiSampled(reader.Version))
					{
						uint textureExtraValue = reader.ReadUInt32();
						bool isMultiSampled = textureExtraValue == 1;
						byte dimension = unchecked((byte)extraValue);
						int samplerIndex = extraValue >> 8;
						if (samplerIndex == 0xFFFFFF)
						{
							samplerIndex = -1;
						}

						texture = new TextureParameter(name, index, dimension, samplerIndex, isMultiSampled);
					}
					else
					{
						byte dimension = unchecked((byte)extraValue);
						int samplerIndex = extraValue >> 8;
						if (samplerIndex == 0xFFFFFF)
						{
							samplerIndex = -1;
						}

						texture = new TextureParameter(name, index, dimension, samplerIndex);
					}
					textures.Add(texture);
				}
				else if (type == 1)
				{
					BufferBinding binding = new BufferBinding(name, index);
					constBindings.Add(binding);
				}
				else if (type == 2)
				{
					BufferBinding buffer = new BufferBinding(name, index);
					buffers.Add(buffer);
				}
				else if (type == 3 && HasUAVParameters(reader.Version))
				{
					UAVParameter uav = new UAVParameter(name, index, extraValue);
					uavs.Add(uav);
				}
				else if (type == 4 && HasSamplerParameters(reader.Version))
				{
					SamplerParameter sampler = new SamplerParameter((uint)extraValue, index);
					samplers.Add(sampler);
				}
				else
				{
					throw new Exception($"Unupported parameter type {type}");
				}
			}
			TextureParameters = textures.ToArray();
			BufferParameters = buffers.ToArray();
			if (HasUAVParameters(reader.Version))
			{
				UAVParameters = uavs.ToArray();
			}

			if (HasSamplerParameters(reader.Version))
			{
				SamplerParameters = samplers.ToArray();
			}

			ConstantBufferBindings = constBindings.ToArray();
			if (HasStructParameters(reader.Version))
			{
				StructParameters = structs.ToArray();
			}
		}

		public void Write(AssetWriter writer)
		{
#warning TODO:
			throw new NotImplementedException();
		}

		public ShaderGpuProgramType GetProgramType(UnityVersion version)
		{
			if (ShaderGpuProgramTypeExtensions.GpuProgramType55Relevant(version))
			{
				return ((ShaderGpuProgramType55)ProgramType).ToGpuProgramType();
			}
			else
			{
				return ((ShaderGpuProgramType53)ProgramType).ToGpuProgramType();
			}
		}

		public int ProgramType { get; set; }
		public int StatsALU { get; set; }
		public int StatsTEX { get; set; }
		public int StatsFlow { get; set; }
		public int StatsTempRegister { get; set; }
		public string[] GlobalKeywords { get; set; }
		public string[] LocalKeywords { get; set; }
		public byte[] ProgramData { get; set; }
		public VectorParameter[] VectorParameters { get; set; }
		public MatrixParameter[] MatrixParameters { get; set; }
		public TextureParameter[] TextureParameters { get; set; }
		public BufferBinding[] BufferParameters { get; set; }
		public UAVParameter[] UAVParameters { get; set; }
		public SamplerParameter[] SamplerParameters { get; set; }
		public ConstantBuffer[] ConstantBuffers { get; set; }
		public BufferBinding[] ConstantBufferBindings { get; set; }
		public StructParameter[] StructParameters { get; set; }

		public ParserBindChannels BindChannels = new();
	}
}

```

`ShaderTextRestorer/ShaderBlob/ShaderSubProgramBlob.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.Core.Layout;
using AssetRipper.Core.Utils;
using AssetRipper.IO.Endian;
using K4os.Compression.LZ4;
using System;
using System.IO;
using System.Linq;

namespace ShaderTextRestorer.ShaderBlob
{
	public sealed class ShaderSubProgramBlob
	{
		public void Read(LayoutInfo layout, byte[] compressedBlob, uint[] offsets, uint[] compressedLengths, uint[] decompressedLengths)
		{
			for (int i = 0; i < offsets.Length; i++)
			{
				uint offset = offsets[i];
				uint compressedLength = compressedLengths[i];
				uint decompressedLength = decompressedLengths[i];

				ReadBlob(layout, compressedBlob, offset, compressedLength, decompressedLength, i);
			}
		}

		private void ReadBlob(LayoutInfo layout, byte[] compressedBlob, uint offset, uint compressedLength, uint decompressedLength, int segment)
		{
			byte[] decompressedBuffer = new byte[decompressedLength];
			LZ4Codec.Decode(compressedBlob, (int)offset, (int)compressedLength, decompressedBuffer, 0, (int)decompressedLength);

			using MemoryStream blobMem = new MemoryStream(decompressedBuffer);
			using AssetReader blobReader = new AssetReader(blobMem, EndianType.LittleEndian, layout);
			if (segment == 0)
			{
				Entries = blobReader.ReadAssetArray<ShaderSubProgramEntry>();
				SubPrograms = ArrayUtils.CreateAndInitializeArray<ShaderSubProgram>(Entries.Length);
			}
			ReadSegment(blobReader, segment);
		}

		private void ReadSegment(AssetReader reader, int segment)
		{
			for (int i = 0; i < Entries.Length; i++)
			{
				ShaderSubProgramEntry entry = Entries[i];
				if (entry.Segment == segment)
				{
					reader.BaseStream.Position = entry.Offset;
					SubPrograms[i].Read(reader);
					if (reader.BaseStream.Position != entry.Offset + entry.Length)
					{
						throw new Exception($"Read {reader.BaseStream.Position - entry.Offset} less than expected {entry.Length}");
					}
				}
			}
		}

		public void Write(LayoutInfo layout, MemoryStream memStream, out uint[] offsets, out uint[] compressedLengths, out uint[] decompressedLengths)
		{
			int segmentCount = Entries.Length == 0 ? 0 : Entries.Max(t => t.Segment) + 1;
			offsets = new uint[segmentCount];
			compressedLengths = new uint[segmentCount];
			decompressedLengths = new uint[segmentCount];
			for (int i = 0; i < segmentCount; i++)
			{
				uint offset = (uint)memStream.Position;
				WriteBlob(layout, memStream, out uint compressedLength, out uint decompressedLength, i);

				offsets[i] = offset;
				compressedLengths[i] = compressedLength;
				decompressedLengths[i] = decompressedLength;
			}
		}

		private void WriteBlob(LayoutInfo layout, MemoryStream memStream, out uint compressedLength, out uint decompressedLength, int segment)
		{
			using MemoryStream blobMem = new MemoryStream();
			using (AssetWriter blobWriter = new AssetWriter(blobMem, EndianType.LittleEndian, layout))
			{
				if (segment == 0)
				{
					blobWriter.WriteAssetArray(Entries);
				}

				WriteSegment(blobWriter, segment);
			}
			decompressedLength = (uint)blobMem.Length;

			byte[] source = blobMem.ToArray();

			byte[] target = new byte[LZ4Codec.MaximumOutputSize(source.Length)];
			int encodedLength = LZ4Codec.Encode(source, 0, source.Length, target, 0, target.Length);

			if (encodedLength < 0)
			{
				throw new Exception("Unable to compress sub program blob");
			}
			else
			{
				compressedLength = (uint)encodedLength;
				memStream.Write(target, 0, encodedLength);
			}
		}

		private void WriteSegment(AssetWriter writer, int segment)
		{
			for (int i = 0; i < Entries.Length; i++)
			{
				ShaderSubProgramEntry entry = Entries[i];
				if (entry.Segment == segment)
				{
					writer.BaseStream.Position = entry.Offset;
					SubPrograms[i].Write(writer);
				}
			}
		}

		public ShaderSubProgramEntry[] Entries { get; set; } = Array.Empty<ShaderSubProgramEntry>();
		public ShaderSubProgram[] SubPrograms { get; set; } = Array.Empty<ShaderSubProgram>();

		public const string GpuProgramIndexName = "GpuProgramIndex";
	}
}

```

`ShaderTextRestorer/ShaderBlob/ShaderSubProgramEntry.cs`:

```cs
using AssetRipper.Core.IO.Asset;
using AssetRipper.VersionUtilities;

namespace ShaderTextRestorer.ShaderBlob
{
	public sealed class ShaderSubProgramEntry : IAssetReadable, IAssetWritable
	{
		/// <summary>
		/// 2019.3 and greater
		/// </summary>
		public static bool HasSegment(UnityVersion version) => version.IsGreaterEqual(2019, 3);

		public void Read(AssetReader reader)
		{
			Offset = reader.ReadInt32();
			Length = reader.ReadInt32();
			if (HasSegment(reader.Version))
			{
				Segment = reader.ReadInt32();
			}
		}

		public void Write(AssetWriter writer)
		{
			writer.Write(Offset);
			writer.Write(Length);
			if (HasSegment(writer.Version))
			{
				writer.Write(Segment);
			}
		}

		public int Offset { get; set; }
		public int Length { get; set; }
		public int Segment { get; set; }
	}
}

```

`ShaderTextRestorer/ShaderTextRestorer.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>ShaderTextRestorer</AssemblyName>
		<RootNamespace>ShaderTextRestorer</RootNamespace>
		<CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
		<OutputPath>..\Bins\ShaderTextRestorer\$(Configuration)\</OutputPath>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<IsTrimmable>true</IsTrimmable>
		<Nullable>enable</Nullable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
		<DefineConstants>DEBUG;TRACE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
		<DefineConstants>TRACE</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<ProjectReference Include="..\AssetRipperCore\AssetRipperCore.csproj" />
		<ProjectReference Include="..\Smolv\Smolv.csproj" />
		<ProjectReference Include="..\SpirV\SpirV.csproj" />
	</ItemGroup>

	<ItemGroup>
		<Reference Include="AssetRipper.SourceGenerated">
			<SpecificVersion>False</SpecificVersion>
			<HintPath>../Libraries/AssetRipper.SourceGenerated.dll</HintPath>
		</Reference>
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

	<ItemGroup>
		<PackageReference Include="DXDecompiler-ly" Version="0.0.1" />
	</ItemGroup>

</Project>

```

`ShaderTextRestorer/Types/ShaderType.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums;
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using ShaderTextRestorer.Extensions;
using ShaderTextRestorer.ShaderBlob.Parameters;
using System;
using System.Collections.Generic;
using System.Linq;

namespace ShaderTextRestorer.Types
{
	internal class ShaderType
	{
		public ShaderType(StructParameter structParameter, ShaderGpuProgramType programType)
		{
			List<ShaderTypeMember> members = new List<ShaderTypeMember>();
			members.AddRange(structParameter.VectorMembers.Select(p => new ShaderTypeMember(p, programType)));
			members.AddRange(structParameter.MatrixMembers.Select(p => new ShaderTypeMember(p, programType)));
			Members = members.OrderBy(v => v.Index).ToArray();
			ShaderVariableClass = ShaderVariableClass.Struct; //TODO: matrix colums or rows?
			ShaderVariableType = ShaderVariableType.Void;
			Rows = 0;
			Columns = 0;
			ElementCount = 0;
			MemberCount = (ushort)Members.Count();
			MemberOffset = 0;
			m_programType = programType;
		}

		public ShaderType(MatrixParameter matrixParam, ShaderGpuProgramType programType)
		{
			Members = Array.Empty<ShaderTypeMember>();
			ShaderVariableClass = ShaderVariableClass.MatrixColumns;
			ShaderVariableType = GetVariableType(matrixParam.Type);
			Rows = matrixParam.RowCount;
			Columns = matrixParam.ColumnCount;
			ElementCount = (ushort)matrixParam.ArraySize;
			MemberCount = 0;
			MemberOffset = 0;
			m_programType = programType;
		}

		public ShaderType(VectorParameter vectorParam, ShaderGpuProgramType programType)
		{
			Members = Array.Empty<ShaderTypeMember>();
			ShaderVariableClass = vectorParam.Dim > 1 ? ShaderVariableClass.Vector : ShaderVariableClass.Scalar;
			ShaderVariableType = GetVariableType(vectorParam.Type);
			Rows = 1;
			Columns = vectorParam.Dim;
			ElementCount = (ushort)vectorParam.ArraySize;
			MemberCount = 0;
			MemberOffset = 0;
			m_programType = programType;
		}

		private static ShaderVariableType GetVariableType(ShaderParamType paramType)
		{
			switch (paramType)
			{
				case ShaderParamType.Bool:
					return ShaderVariableType.Bool;
				case ShaderParamType.Float:
					return ShaderVariableType.Float;
				case ShaderParamType.Half:
					return ShaderVariableType.Float;
				case ShaderParamType.Int:
					return ShaderVariableType.Int;
				case ShaderParamType.Short:
					return ShaderVariableType.Int;
				case ShaderParamType.TypeCount:
					return ShaderVariableType.Int; //TODO
				case ShaderParamType.UInt:
					return ShaderVariableType.UInt; //TODO
				default:
					throw new Exception($"Unexpected param type {paramType}");
			}
		}

		/*public override bool Equals(object obj)
		{
			var shaderType = obj as ShaderType;
			if (shaderType == null) return false;
			return (ShaderVariableClass == shaderType.ShaderVariableClass &&
					ShaderVariableType == shaderType.ShaderVariableType &&
					Rows == shaderType.Rows &&
					Columns == shaderType.Columns &&
					ElementCount == shaderType.ElementCount &&
					MemberCount == shaderType.MemberCount &&
					MemberOffset == shaderType.MemberOffset);
		}

		public override int GetHashCode()
		{
			unchecked
			{
				var hashCode = -1667745916;
				hashCode = hashCode * -1521134295 + ShaderVariableClass.GetHashCode();
				hashCode = hashCode * -1521134295 + ShaderVariableType.GetHashCode();
				hashCode = hashCode * -1521134295 + Rows.GetHashCode();
				hashCode = hashCode * -1521134295 + Columns.GetHashCode();
				hashCode = hashCode * -1521134295 + ElementCount.GetHashCode();
				hashCode = hashCode * -1521134295 + MemberCount.GetHashCode();
				hashCode = hashCode * -1521134295 + MemberOffset.GetHashCode();
				return hashCode;
			}
		}*/

		public uint Length()
		{
			uint variableSize = 4; //TODO: does this vary with ShaderVariableType? 
			return variableSize * Rows * Columns * ElementCount;
		}

		public uint Size()
		{
			int majorVersion = m_programType.GetMajorDXVersion();
			return majorVersion >= 5 ? 36 : (uint)16;
		}

		public ShaderVariableClass ShaderVariableClass { get; }
		public ShaderVariableType ShaderVariableType { get; }
		public ushort Rows { get; }
		public ushort Columns { get; }
		public ushort ElementCount { get; }
		public ushort MemberCount { get; }
		public uint MemberOffset { get; set; }
		//SM 5.0 Variables
		public uint ParentTypeOffset { get; }
		public uint Unknown2 { get; }
		public uint Unknown4 { get; }
		public uint Unknown5 { get; }
		public uint ParentNameOffset { get; }
		public ShaderTypeMember[] Members { get; }

		private readonly ShaderGpuProgramType m_programType;
	}
}

```

`ShaderTextRestorer/Types/ShaderTypeMember.cs`:

```cs
using AssetRipper.Core.Classes.Shader.Enums.GpuProgramType;
using ShaderTextRestorer.ShaderBlob.Parameters;

namespace ShaderTextRestorer.Types
{
	class ShaderTypeMember
	{
		public ShaderTypeMember(MatrixParameter param, ShaderGpuProgramType programType)
		{
			ProgramType = programType;
			Name = param.Name;
			ShaderType = new ShaderType(param, programType);
			Index = (uint)param.Index;
		}

		public ShaderTypeMember(VectorParameter param, ShaderGpuProgramType programType)
		{
			ProgramType = programType;
			Name = param.Name;
			ShaderType = new ShaderType(param, programType);
			Index = (uint)param.Index;
		}

		public string Name { get; }
		public ShaderType ShaderType { get; }
		public ShaderGpuProgramType ProgramType { get; }
		public uint Index { get; }
	}
}

```

`ShaderTextRestorer/Types/ShaderVariableClass.cs`:

```cs
namespace ShaderTextRestorer.Types
{
	internal enum ShaderVariableClass
	{
		Scalar,
		Vector,
		MatrixRows,
		MatrixColumns,
		Object,
		Struct,
		InterfaceClass,
		InterfacePointer,
	}
}

```

`ShaderTextRestorer/Types/ShaderVariableType.cs`:

```cs
namespace ShaderTextRestorer.Types
{
	internal enum ShaderVariableType
	{
		Void = 0,
		Bool = 1,
		Int = 2,
		Float = 3,
		String = 4,
		Texture = 5,
		Texture1D = 6,
		Texture2D = 7,
		Texture3D = 8,
		TextureCube = 9,
		Sampler = 10,
		PixelShader = 15,
		VertexShader = 16,
		UInt = 19,
		UInt8 = 20,
		GeometryShader = 21,
		Rasterizer = 22,
		DepthStencil = 23,
		Blend = 24,
		Buffer = 25,
		CBuffer = 26,
		TBuffer = 27,
		Texture1DArray = 28,
		Texture2DArray = 29,
		RenderTargetView = 30,
		DepthStencilView = 31,
		Texture2DMultiSampled = 32,
		Texture2DMultiSampledArray = 33,
		TextureCubeArray = 34,
		// The following are new in D3D11.
		HullShader = 35,
		DomainShader = 36,
		InterfacePointer = 37,
		ComputeShader = 38,
		Double = 39,
		ReadWriteTexture1D,
		ReadWriteTexture1DArray,
		ReadWriteTexture2D,
		ReadWriteTexture2DArray,
		ReadWriteTexture3D,
		ReadWriteBuffer,
		ByteAddressBuffer,
		ReadWriteByteAddressBuffer,
		StructuredBuffer,
		ReadWriteStructuredBuffer,
		AppendStructuredBuffer,
		ConsumeStructuredBuffer
	}
}

```

`Smolv/OpData.cs`:

```cs
namespace Smolv
{
	public struct OpData
	{
		public OpData(byte hasResult, byte hasType, sbyte deltaFromResult, byte varrest)
		{
			this.hasResult = hasResult;
			this.hasType = hasType;
			this.deltaFromResult = deltaFromResult;
			this.varrest = varrest;
		}

		/// <summary>
		/// Does it have result ID?
		/// </summary>
		public byte hasResult;
		/// <summary>
		/// Does it have type ID?
		/// </summary>
		public byte hasType;
		/// <summary>
		/// How many words after (optional) type+result to write out as deltas from result?
		/// </summary>
		public sbyte deltaFromResult;
		/// <summary>
		/// Should the rest of words be written in varint encoding?
		/// </summary>
		public byte varrest;

		public static readonly OpData[] SpirvOpData =
		{
			new OpData(0, 0, 0, 0), // Nop
			new OpData(1, 1, 0, 0), // Undef
			new OpData(0, 0, 0, 0), // SourceContinued
			new OpData(0, 0, 0, 1), // Source
			new OpData(0, 0, 0, 0), // SourceExtension
			new OpData(0, 0, 0, 0), // Name
			new OpData(0, 0, 0, 0), // MemberName
			new OpData(0, 0, 0, 0), // String
			new OpData(0, 0, 0, 1), // Line
			new OpData(1, 1, 0, 0), // #9
			new OpData(0, 0, 0, 0), // Extension
			new OpData(1, 0, 0, 0), // ExtInstImport
			new OpData(1, 1, 0, 1), // ExtInst
			new OpData(1, 1, 2, 1), // VectorShuffleCompact - new in SMOLV
			new OpData(0, 0, 0, 1), // MemoryModel
			new OpData(0, 0, 0, 1), // EntryPoint
			new OpData(0, 0, 0, 1), // ExecutionMode
			new OpData(0, 0, 0, 1), // Capability
			new OpData(1, 1, 0, 0), // #18
			new OpData(1, 0, 0, 1), // TypeVoid
			new OpData(1, 0, 0, 1), // TypeBool
			new OpData(1, 0, 0, 1), // TypeInt
			new OpData(1, 0, 0, 1), // TypeFloat
			new OpData(1, 0, 0, 1), // TypeVector
			new OpData(1, 0, 0, 1), // TypeMatrix
			new OpData(1, 0, 0, 1), // TypeImage
			new OpData(1, 0, 0, 1), // TypeSampler
			new OpData(1, 0, 0, 1), // TypeSampledImage
			new OpData(1, 0, 0, 1), // TypeArray
			new OpData(1, 0, 0, 1), // TypeRuntimeArray
			new OpData(1, 0, 0, 1), // TypeStruct
			new OpData(1, 0, 0, 1), // TypeOpaque
			new OpData(1, 0, 0, 1), // TypePointer
			new OpData(1, 0, 0, 1), // TypeFunction
			new OpData(1, 0, 0, 1), // TypeEvent
			new OpData(1, 0, 0, 1), // TypeDeviceEvent
			new OpData(1, 0, 0, 1), // TypeReserveId
			new OpData(1, 0, 0, 1), // TypeQueue
			new OpData(1, 0, 0, 1), // TypePipe
			new OpData(0, 0, 0, 1), // TypeForwardPointer
			new OpData(1, 1, 0, 0), // #40
			new OpData(1, 1, 0, 0), // ConstantTrue
			new OpData(1, 1, 0, 0), // ConstantFalse
			new OpData(1, 1, 0, 0), // Constant
			new OpData(1, 1, 9, 0), // ConstantComposite
			new OpData(1, 1, 0, 1), // ConstantSampler
			new OpData(1, 1, 0, 0), // ConstantNull
			new OpData(1, 1, 0, 0), // #47
			new OpData(1, 1, 0, 0), // SpecConstantTrue
			new OpData(1, 1, 0, 0), // SpecConstantFalse
			new OpData(1, 1, 0, 0), // SpecConstant
			new OpData(1, 1, 9, 0), // SpecConstantComposite
			new OpData(1, 1, 0, 0), // SpecConstantOp
			new OpData(1, 1, 0, 0), // #53
			new OpData(1, 1, 0, 1), // Function
			new OpData(1, 1, 0, 0), // FunctionParameter
			new OpData(0, 0, 0, 0), // FunctionEnd
			new OpData(1, 1, 9, 0), // FunctionCall
			new OpData(1, 1, 0, 0), // #58
			new OpData(1, 1, 0, 1), // Variable
			new OpData(1, 1, 0, 0), // ImageTexelPointer
			new OpData(1, 1, 1, 1), // Load
			new OpData(0, 0, 2, 1), // Store
			new OpData(0, 0, 0, 0), // CopyMemory
			new OpData(0, 0, 0, 0), // CopyMemorySized
			new OpData(1, 1, 0, 1), // AccessChain
			new OpData(1, 1, 0, 0), // InBoundsAccessChain
			new OpData(1, 1, 0, 0), // PtrAccessChain
			new OpData(1, 1, 0, 0), // ArrayLength
			new OpData(1, 1, 0, 0), // GenericPtrMemSemantics
			new OpData(1, 1, 0, 0), // InBoundsPtrAccessChain
			new OpData(0, 0, 0, 1), // Decorate
			new OpData(0, 0, 0, 1), // MemberDecorate
			new OpData(1, 0, 0, 0), // DecorationGroup
			new OpData(0, 0, 0, 0), // GroupDecorate
			new OpData(0, 0, 0, 0), // GroupMemberDecorate
			new OpData(1, 1, 0, 0), // #76
			new OpData(1, 1, 1, 1), // VectorExtractDynamic
			new OpData(1, 1, 2, 1), // VectorInsertDynamic
			new OpData(1, 1, 2, 1), // VectorShuffle
			new OpData(1, 1, 9, 0), // CompositeConstruct
			new OpData(1, 1, 1, 1), // CompositeExtract
			new OpData(1, 1, 2, 1), // CompositeInsert
			new OpData(1, 1, 1, 0), // CopyObject
			new OpData(1, 1, 0, 0), // Transpose
			new OpData(1, 1, 0, 0), // #85
			new OpData(1, 1, 0, 0), // SampledImage
			new OpData(1, 1, 2, 1), // ImageSampleImplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleExplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleProjImplicitLod
			new OpData(1, 1, 2, 1), // ImageSampleProjExplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleProjDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSampleProjDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageFetch
			new OpData(1, 1, 3, 1), // ImageGather
			new OpData(1, 1, 3, 1), // ImageDrefGather
			new OpData(1, 1, 2, 1), // ImageRead
			new OpData(0, 0, 3, 1), // ImageWrite
			new OpData(1, 1, 1, 0), // Image
			new OpData(1, 1, 1, 0), // ImageQueryFormat
			new OpData(1, 1, 1, 0), // ImageQueryOrder
			new OpData(1, 1, 2, 0), // ImageQuerySizeLod
			new OpData(1, 1, 1, 0), // ImageQuerySize
			new OpData(1, 1, 2, 0), // ImageQueryLod
			new OpData(1, 1, 1, 0), // ImageQueryLevels
			new OpData(1, 1, 1, 0), // ImageQuerySamples
			new OpData(1, 1, 0, 0), // #108
			new OpData(1, 1, 1, 0), // ConvertFToU
			new OpData(1, 1, 1, 0), // ConvertFToS
			new OpData(1, 1, 1, 0), // ConvertSToF
			new OpData(1, 1, 1, 0), // ConvertUToF
			new OpData(1, 1, 1, 0), // UConvert
			new OpData(1, 1, 1, 0), // SConvert
			new OpData(1, 1, 1, 0), // FConvert
			new OpData(1, 1, 1, 0), // QuantizeToF16
			new OpData(1, 1, 1, 0), // ConvertPtrToU
			new OpData(1, 1, 1, 0), // SatConvertSToU
			new OpData(1, 1, 1, 0), // SatConvertUToS
			new OpData(1, 1, 1, 0), // ConvertUToPtr
			new OpData(1, 1, 1, 0), // PtrCastToGeneric
			new OpData(1, 1, 1, 0), // GenericCastToPtr
			new OpData(1, 1, 1, 1), // GenericCastToPtrExplicit
			new OpData(1, 1, 1, 0), // Bitcast
			new OpData(1, 1, 0, 0), // #125
			new OpData(1, 1, 1, 0), // SNegate
			new OpData(1, 1, 1, 0), // FNegate
			new OpData(1, 1, 2, 0), // IAdd
			new OpData(1, 1, 2, 0), // FAdd
			new OpData(1, 1, 2, 0), // ISub
			new OpData(1, 1, 2, 0), // FSub
			new OpData(1, 1, 2, 0), // IMul
			new OpData(1, 1, 2, 0), // FMul
			new OpData(1, 1, 2, 0), // UDiv
			new OpData(1, 1, 2, 0), // SDiv
			new OpData(1, 1, 2, 0), // FDiv
			new OpData(1, 1, 2, 0), // UMod
			new OpData(1, 1, 2, 0), // SRem
			new OpData(1, 1, 2, 0), // SMod
			new OpData(1, 1, 2, 0), // FRem
			new OpData(1, 1, 2, 0), // FMod
			new OpData(1, 1, 2, 0), // VectorTimesScalar
			new OpData(1, 1, 2, 0), // MatrixTimesScalar
			new OpData(1, 1, 2, 0), // VectorTimesMatrix
			new OpData(1, 1, 2, 0), // MatrixTimesVector
			new OpData(1, 1, 2, 0), // MatrixTimesMatrix
			new OpData(1, 1, 2, 0), // OuterProduct
			new OpData(1, 1, 2, 0), // Dot
			new OpData(1, 1, 2, 0), // IAddCarry
			new OpData(1, 1, 2, 0), // ISubBorrow
			new OpData(1, 1, 2, 0), // UMulExtended
			new OpData(1, 1, 2, 0), // SMulExtended
			new OpData(1, 1, 0, 0), // #153
			new OpData(1, 1, 1, 0), // Any
			new OpData(1, 1, 1, 0), // All
			new OpData(1, 1, 1, 0), // IsNan
			new OpData(1, 1, 1, 0), // IsInf
			new OpData(1, 1, 1, 0), // IsFinite
			new OpData(1, 1, 1, 0), // IsNormal
			new OpData(1, 1, 1, 0), // SignBitSet
			new OpData(1, 1, 2, 0), // LessOrGreater
			new OpData(1, 1, 2, 0), // Ordered
			new OpData(1, 1, 2, 0), // Unordered
			new OpData(1, 1, 2, 0), // LogicalEqual
			new OpData(1, 1, 2, 0), // LogicalNotEqual
			new OpData(1, 1, 2, 0), // LogicalOr
			new OpData(1, 1, 2, 0), // LogicalAnd
			new OpData(1, 1, 1, 0), // LogicalNot
			new OpData(1, 1, 3, 0), // Select
			new OpData(1, 1, 2, 0), // IEqual
			new OpData(1, 1, 2, 0), // INotEqual
			new OpData(1, 1, 2, 0), // UGreaterThan
			new OpData(1, 1, 2, 0), // SGreaterThan
			new OpData(1, 1, 2, 0), // UGreaterThanEqual
			new OpData(1, 1, 2, 0), // SGreaterThanEqual
			new OpData(1, 1, 2, 0), // ULessThan
			new OpData(1, 1, 2, 0), // SLessThan
			new OpData(1, 1, 2, 0), // ULessThanEqual
			new OpData(1, 1, 2, 0), // SLessThanEqual
			new OpData(1, 1, 2, 0), // FOrdEqual
			new OpData(1, 1, 2, 0), // FUnordEqual
			new OpData(1, 1, 2, 0), // FOrdNotEqual
			new OpData(1, 1, 2, 0), // FUnordNotEqual
			new OpData(1, 1, 2, 0), // FOrdLessThan
			new OpData(1, 1, 2, 0), // FUnordLessThan
			new OpData(1, 1, 2, 0), // FOrdGreaterThan
			new OpData(1, 1, 2, 0), // FUnordGreaterThan
			new OpData(1, 1, 2, 0), // FOrdLessThanEqual
			new OpData(1, 1, 2, 0), // FUnordLessThanEqual
			new OpData(1, 1, 2, 0), // FOrdGreaterThanEqual
			new OpData(1, 1, 2, 0), // FUnordGreaterThanEqual
			new OpData(1, 1, 0, 0), // #192
			new OpData(1, 1, 0, 0), // #193
			new OpData(1, 1, 2, 0), // ShiftRightLogical
			new OpData(1, 1, 2, 0), // ShiftRightArithmetic
			new OpData(1, 1, 2, 0), // ShiftLeftLogical
			new OpData(1, 1, 2, 0), // BitwiseOr
			new OpData(1, 1, 2, 0), // BitwiseXor
			new OpData(1, 1, 2, 0), // BitwiseAnd
			new OpData(1, 1, 1, 0), // Not
			new OpData(1, 1, 4, 0), // BitFieldInsert
			new OpData(1, 1, 3, 0), // BitFieldSExtract
			new OpData(1, 1, 3, 0), // BitFieldUExtract
			new OpData(1, 1, 1, 0), // BitReverse
			new OpData(1, 1, 1, 0), // BitCount
			new OpData(1, 1, 0, 0), // #206
			new OpData(1, 1, 0, 0), // DPdx
			new OpData(1, 1, 0, 0), // DPdy
			new OpData(1, 1, 0, 0), // Fwidth
			new OpData(1, 1, 0, 0), // DPdxFine
			new OpData(1, 1, 0, 0), // DPdyFine
			new OpData(1, 1, 0, 0), // FwidthFine
			new OpData(1, 1, 0, 0), // DPdxCoarse
			new OpData(1, 1, 0, 0), // DPdyCoarse
			new OpData(1, 1, 0, 0), // FwidthCoarse
			new OpData(1, 1, 0, 0), // #216
			new OpData(1, 1, 0, 0), // #217
			new OpData(0, 0, 0, 0), // EmitVertex
			new OpData(0, 0, 0, 0), // EndPrimitive
			new OpData(0, 0, 0, 0), // EmitStreamVertex
			new OpData(0, 0, 0, 0), // EndStreamPrimitive
			new OpData(1, 1, 0, 0), // #222
			new OpData(1, 1, 0, 0), // #223
			new OpData(0, 0, -3, 0), // ControlBarrier
			new OpData(0, 0, -2, 0), // MemoryBarrier
			new OpData(1, 1, 0, 0), // #226
			new OpData(1, 1, 0, 0), // AtomicLoad
			new OpData(0, 0, 0, 0), // AtomicStore
			new OpData(1, 1, 0, 0), // AtomicExchange
			new OpData(1, 1, 0, 0), // AtomicCompareExchange
			new OpData(1, 1, 0, 0), // AtomicCompareExchangeWeak
			new OpData(1, 1, 0, 0), // AtomicIIncrement
			new OpData(1, 1, 0, 0), // AtomicIDecrement
			new OpData(1, 1, 0, 0), // AtomicIAdd
			new OpData(1, 1, 0, 0), // AtomicISub
			new OpData(1, 1, 0, 0), // AtomicSMin
			new OpData(1, 1, 0, 0), // AtomicUMin
			new OpData(1, 1, 0, 0), // AtomicSMax
			new OpData(1, 1, 0, 0), // AtomicUMax
			new OpData(1, 1, 0, 0), // AtomicAnd
			new OpData(1, 1, 0, 0), // AtomicOr
			new OpData(1, 1, 0, 0), // AtomicXor
			new OpData(1, 1, 0, 0), // #243
			new OpData(1, 1, 0, 0), // #244
			new OpData(1, 1, 0, 0), // Phi
			new OpData(0, 0, -2, 1), // LoopMerge
			new OpData(0, 0, -1, 1), // SelectionMerge
			new OpData(1, 0, 0, 0), // Label
			new OpData(0, 0, -1, 0), // Branch
			new OpData(0, 0, -3, 1), // BranchConditional
			new OpData(0, 0, 0, 0), // Switch
			new OpData(0, 0, 0, 0), // Kill
			new OpData(0, 0, 0, 0), // Return
			new OpData(0, 0, 0, 0), // ReturnValue
			new OpData(0, 0, 0, 0), // Unreachable
			new OpData(0, 0, 0, 0), // LifetimeStart
			new OpData(0, 0, 0, 0), // LifetimeStop
			new OpData(1, 1, 0, 0), // #258
			new OpData(1, 1, 0, 0), // GroupAsyncCopy
			new OpData(0, 0, 0, 0), // GroupWaitEvents
			new OpData(1, 1, 0, 0), // GroupAll
			new OpData(1, 1, 0, 0), // GroupAny
			new OpData(1, 1, 0, 0), // GroupBroadcast
			new OpData(1, 1, 0, 0), // GroupIAdd
			new OpData(1, 1, 0, 0), // GroupFAdd
			new OpData(1, 1, 0, 0), // GroupFMin
			new OpData(1, 1, 0, 0), // GroupUMin
			new OpData(1, 1, 0, 0), // GroupSMin
			new OpData(1, 1, 0, 0), // GroupFMax
			new OpData(1, 1, 0, 0), // GroupUMax
			new OpData(1, 1, 0, 0), // GroupSMax
			new OpData(1, 1, 0, 0), // #272
			new OpData(1, 1, 0, 0), // #273
			new OpData(1, 1, 0, 0), // ReadPipe
			new OpData(1, 1, 0, 0), // WritePipe
			new OpData(1, 1, 0, 0), // ReservedReadPipe
			new OpData(1, 1, 0, 0), // ReservedWritePipe
			new OpData(1, 1, 0, 0), // ReserveReadPipePackets
			new OpData(1, 1, 0, 0), // ReserveWritePipePackets
			new OpData(0, 0, 0, 0), // CommitReadPipe
			new OpData(0, 0, 0, 0), // CommitWritePipe
			new OpData(1, 1, 0, 0), // IsValidReserveId
			new OpData(1, 1, 0, 0), // GetNumPipePackets
			new OpData(1, 1, 0, 0), // GetMaxPipePackets
			new OpData(1, 1, 0, 0), // GroupReserveReadPipePackets
			new OpData(1, 1, 0, 0), // GroupReserveWritePipePackets
			new OpData(0, 0, 0, 0), // GroupCommitReadPipe
			new OpData(0, 0, 0, 0), // GroupCommitWritePipe
			new OpData(1, 1, 0, 0), // #289
			new OpData(1, 1, 0, 0), // #290
			new OpData(1, 1, 0, 0), // EnqueueMarker
			new OpData(1, 1, 0, 0), // EnqueueKernel
			new OpData(1, 1, 0, 0), // GetKernelNDrangeSubGroupCount
			new OpData(1, 1, 0, 0), // GetKernelNDrangeMaxSubGroupSize
			new OpData(1, 1, 0, 0), // GetKernelWorkGroupSize
			new OpData(1, 1, 0, 0), // GetKernelPreferredWorkGroupSizeMultiple
			new OpData(0, 0, 0, 0), // RetainEvent
			new OpData(0, 0, 0, 0), // ReleaseEvent
			new OpData(1, 1, 0, 0), // CreateUserEvent
			new OpData(1, 1, 0, 0), // IsValidEvent
			new OpData(0, 0, 0, 0), // SetUserEventStatus
			new OpData(0, 0, 0, 0), // CaptureEventProfilingInfo
			new OpData(1, 1, 0, 0), // GetDefaultQueue
			new OpData(1, 1, 0, 0), // BuildNDRange
			new OpData(1, 1, 2, 1), // ImageSparseSampleImplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleExplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleProjImplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseSampleProjExplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefImplicitLod
			new OpData(1, 1, 3, 1), // ImageSparseSampleProjDrefExplicitLod
			new OpData(1, 1, 2, 1), // ImageSparseFetch
			new OpData(1, 1, 3, 1), // ImageSparseGather
			new OpData(1, 1, 3, 1), // ImageSparseDrefGather
			new OpData(1, 1, 1, 0), // ImageSparseTexelsResident
			new OpData(0, 0, 0, 0), // NoLine
			new OpData(1, 1, 0, 0), // AtomicFlagTestAndSet
			new OpData(0, 0, 0, 0), // AtomicFlagClear
			new OpData(1, 1, 0, 0), // ImageSparseRead
			new OpData(1, 1, 0, 0), // SizeOf
			new OpData(1, 1, 0, 0), // TypePipeStorage
			new OpData(1, 1, 0, 0), // ConstantPipeStorage
			new OpData(1, 1, 0, 0), // CreatePipeFromPipeStorage
			new OpData(1, 1, 0, 0), // GetKernelLocalSizeForSubgroupCount
			new OpData(1, 1, 0, 0), // GetKernelMaxNumSubgroups
			new OpData(1, 1, 0, 0), // TypeNamedBarrier
			new OpData(1, 1, 0, 1), // NamedBarrierInitialize
			new OpData(0, 0, -2, 1), // MemoryNamedBarrier
			new OpData(1, 1, 0, 0), // ModuleProcessed
			new OpData(0, 0, 0, 1), // ExecutionModeId
			new OpData(0, 0, 0, 1), // DecorateId
			new OpData(1, 1, 1, 1), // GroupNonUniformElect
			new OpData(1, 1, 1, 1), // GroupNonUniformAll
			new OpData(1, 1, 1, 1), // GroupNonUniformAny
			new OpData(1, 1, 1, 1), // GroupNonUniformAllEqual
			new OpData(1, 1, 1, 1), // GroupNonUniformBroadcast
			new OpData(1, 1, 1, 1), // GroupNonUniformBroadcastFirst
			new OpData(1, 1, 1, 1), // GroupNonUniformBallot
			new OpData(1, 1, 1, 1), // GroupNonUniformInverseBallot
			new OpData(1, 1, 1, 1), // GroupNonUniformBallotBitExtract
			new OpData(1, 1, 1, 1), // GroupNonUniformBallotBitCount
			new OpData(1, 1, 1, 1), // GroupNonUniformBallotFindLSB
			new OpData(1, 1, 1, 1), // GroupNonUniformBallotFindMSB
			new OpData(1, 1, 1, 1), // GroupNonUniformShuffle
			new OpData(1, 1, 1, 1), // GroupNonUniformShuffleXor
			new OpData(1, 1, 1, 1), // GroupNonUniformShuffleUp
			new OpData(1, 1, 1, 1), // GroupNonUniformShuffleDown
			new OpData(1, 1, 1, 1), // GroupNonUniformIAdd
			new OpData(1, 1, 1, 1), // GroupNonUniformFAdd
			new OpData(1, 1, 1, 1), // GroupNonUniformIMul
			new OpData(1, 1, 1, 1), // GroupNonUniformFMul
			new OpData(1, 1, 1, 1), // GroupNonUniformSMin
			new OpData(1, 1, 1, 1), // GroupNonUniformUMin
			new OpData(1, 1, 1, 1), // GroupNonUniformFMin
			new OpData(1, 1, 1, 1), // GroupNonUniformSMax
			new OpData(1, 1, 1, 1), // GroupNonUniformUMax
			new OpData(1, 1, 1, 1), // GroupNonUniformFMax
			new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseAnd
			new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseOr
			new OpData(1, 1, 1, 1), // GroupNonUniformBitwiseXor
			new OpData(1, 1, 1, 1), // GroupNonUniformLogicalAnd
			new OpData(1, 1, 1, 1), // GroupNonUniformLogicalOr
			new OpData(1, 1, 1, 1), // GroupNonUniformLogicalXor
			new OpData(1, 1, 1, 1), // GroupNonUniformQuadBroadcast
			new OpData(1, 1, 1, 1), // GroupNonUniformQuadSwap
		};
	};
}

```

`Smolv/Original-Cpp-Notes.md`:

```md
smol-v - public domain - https://github.com/aras-p/smol-v
authored 2016-2020 by Aras Pranckevicius
no warranty implied; use at your own risk
See end of file for license information.


### OVERVIEW:

SMOL-V encodes Vulkan/Khronos SPIR-V format programs into a form that is smaller, and is more
compressible. Normally no changes to the programs are done; they decode
into exactly same program as what was encoded. Optionally, debug information
can be removed too.

SPIR-V is a very verbose format, several times larger than same programs expressed in other
shader formats (e.g. DX11 bytecode, GLSL, DX9 bytecode etc.). The SSA-form with ever increasing
IDs is not very appreciated by regular data compressors either. SMOL-V does several things
to improve this:
- Many words, especially ones that most often have small values, are encoded using
  "varint" scheme (1-5 bytes per word, with just one byte for values in 0..127 range).
  See https://developers.google.com/protocol-buffers/docs/encoding
- Some IDs used in the program are delta-encoded, relative to previously seen IDs (e.g. Result
  IDs). Often instructions reference things that were computed just before, so this results in
  small deltas. These values are also encoded using "varint" scheme.
- Reordering instruction opcodes so that the most common ones are the smallest values, for smaller
 varint encoding.
- Encoding several instructions in a more compact form, e.g. the "typical <=4 component swizzle"
 shape of a VectorShuffle instruction, or sequences of MemberDecorate instructions.

A somewhat similar utility is spirv-remap from glslang, see
https://github.com/KhronosGroup/glslang/blob/master/README-spirv-remap.txt


### USAGE:

Add source/smolv.h and source/smolv.cpp to your C++ project build.
Currently it might require C++11 or somesuch; I only tested with Visual Studio 2017/2019, Mac Xcode 11 and Gcc 5.4.

smolv::Encode and smolv::Decode is the basic functionality.

Other functions are for development/statistics purposes, to figure out frequencies and
distributions of the instructions.

There's a test + compression benchmarking suite in testing/testmain.cpp; using that needs adding
other files under testing/external to the build too (3rd party code: glslang remapper, Zstd, LZ4).


### LIMITATIONS / TODO:

- SPIR-V where the words got stored in big-endian layout is not supported yet.
- The whole thing might not work on Big-Endian CPUs. It might, but I'm not 100% sure.
- Not much prevention is done against malformed/corrupted inputs, TODO.
- Out of memory cases are not handled. The code will either throw exception
  or crash, depending on your compilation flags.
```

`Smolv/README.md`:

```md
# Smolv

## License

[Smolv](https://github.com/aras-p/smol-v) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Smolv.md).
```

`Smolv/Smolv.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>Smolv</AssemblyName>
		<RootNamespace>Smolv</RootNamespace>
		<OutputPath>..\Bins\Smolv\$(Configuration)\</OutputPath>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
		<DefineConstants>DEBUG;TRACE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
		<DefineConstants>TRACE</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

</Project>

```

`Smolv/SmolvDecoder.cs`:

```cs
using System;
using System.IO;
using System.Text;

namespace Smolv
{
	public static class SmolvDecoder
	{
		public static int GetDecodedBufferSize(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			if (!CheckSmolHeader(data))
			{
				return 0;
			}

			int size = BitConverter.ToInt32(data, 5 * sizeof(uint));
			return size;
		}

		public static int GetDecodedBufferSize(Stream stream)
		{
			if (stream == null)
			{
				throw new ArgumentNullException(nameof(stream));
			}
			if (!stream.CanSeek)
			{
				throw new ArgumentException(nameof(stream));
			}
			if (stream.Position + HeaderSize > stream.Length)
			{
				return 0;
			}

			long initPosition = stream.Position;
			stream.Position += HeaderSize - sizeof(uint);
			int size = stream.ReadByte() | stream.ReadByte() << 8 | stream.ReadByte() << 16 | stream.ReadByte() << 24;
			stream.Position = initPosition;
			return size;
		}

		public static byte[] Decode(byte[] data)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}

			int bufferSize = GetDecodedBufferSize(data);
			if (bufferSize == 0)
			{
				// invalid SMOL-V
				return null;
			}

			byte[] output = new byte[bufferSize];
			if (Decode(data, output))
			{
				return output;
			}

			return null;
		}

		public static bool Decode(byte[] data, byte[] output)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}
			if (output == null)
			{
				throw new ArgumentNullException(nameof(output));
			}

			int bufferSize = GetDecodedBufferSize(data);
			if (bufferSize > output.Length)
			{
				return false;
			}

			using MemoryStream outputStream = new MemoryStream(output);
			return Decode(data, outputStream);
		}

		public static bool Decode(byte[] data, Stream outputStream)
		{
			if (data == null)
			{
				throw new ArgumentNullException(nameof(data));
			}
			using MemoryStream inputStream = new MemoryStream(data);
			return Decode(inputStream, data.Length, outputStream);
		}

		public static bool Decode(Stream inputStream, int inputSize, Stream outputStream)
		{
			if (inputStream == null)
			{
				throw new ArgumentNullException(nameof(inputStream));
			}
			if (outputStream == null)
			{
				throw new ArgumentNullException(nameof(outputStream));
			}
			if (inputStream.Length < HeaderSize)
			{
				return false;
			}

			using BinaryReader input = new BinaryReader(inputStream, Encoding.UTF8, true);
			using BinaryWriter output = new BinaryWriter(outputStream, Encoding.UTF8, true);
			long inputEndPosition = input.BaseStream.Position + inputSize;
			long outputStartPosition = output.BaseStream.Position;

			// Header
			output.Write(SpirVHeaderMagic);
			input.BaseStream.Position += sizeof(uint);
			uint version = input.ReadUInt32();
			output.Write(version & 0x00FFFFFF);
			uint generator = input.ReadUInt32();
			output.Write(generator);
			int bound = input.ReadInt32();
			output.Write(bound);
			uint schema = input.ReadUInt32();
			output.Write(schema);
			int decodedSize = input.ReadInt32();

			// Body
			int prevResult = 0;
			int prevDecorate = 0;
			while (input.BaseStream.Position < inputEndPosition)
			{
				// read length + opcode
				if (!ReadLengthOp(input, out uint instrLen, out SpvOp op))
				{
					return false;
				}

				bool wasSwizzle = op == SpvOp.VectorShuffleCompact;
				if (wasSwizzle)
				{
					op = SpvOp.VectorShuffle;
				}
				output.Write((instrLen << 16) | (uint)op);

				uint ioffs = 1;
				// read type as varint, if we have it
				if (op.OpHasType())
				{
					if (!ReadVarint(input, out uint value))
					{
						return false;
					}

					output.Write(value);
					ioffs++;
				}

				// read result as delta+varint, if we have it
				if (op.OpHasResult())
				{
					if (!ReadVarint(input, out uint value))
					{
						return false;
					}

					int zds = prevResult + ZigDecode(value);
					output.Write(zds);
					prevResult = zds;
					ioffs++;
				}

				// Decorate: IDs relative to previous decorate
				if (op == SpvOp.Decorate || op == SpvOp.MemberDecorate)
				{
					if (!ReadVarint(input, out uint value))
					{
						return false;
					}

					int zds = prevDecorate + unchecked((int)value);
					output.Write(zds);
					prevDecorate = zds;
					ioffs++;
				}

				bool isNewSmolV = false;
				if (op == SpvOp.MemberDecorate && isNewSmolV)
				{
					if (input.BaseStream.Position >= inputEndPosition)
						return false; //Broken input

					long count = input.BaseStream.Position + 1;
					uint prevIndex = 0;
					uint prevOffset = 0;
					for (int m = 0; m < count; m++)
					{
						//read member index
						if (!ReadVarint(input, out uint memberIndex))
							return false;

						memberIndex += prevIndex;
						prevIndex = memberIndex;

						//decoration (and length if not common/known)
						if (!ReadVarint(input, out uint memberDec))
							return false;

						int knownExtraOps = DecorationExtraOps((int)memberDec);
						uint memberLen;
						if (knownExtraOps == -1)
						{
							if (!ReadVarint(input, out memberLen))
								return false;

							memberLen += 4;
						}
						else
						{
							memberLen = (uint)(4 + knownExtraOps);
						}

						// write SPIR-V op+length (unless it's first member decoration, in which case it was written before)
						if (m != 0)
						{
							output.Write((memberLen << 16) | (uint)op);
							output.Write(prevDecorate);
						}
						output.Write(memberIndex);
						output.Write(memberDec);

						if (memberDec == 35) // Offset
						{
							if (memberLen != 5)
								return false;
							if (!ReadVarint(input, out uint val))
								return false;
							val += prevOffset;
							output.Write(val);
							prevOffset = val;
						}
						else
						{
							for (uint i = 4; i < memberLen; ++i)
							{
								if (!ReadVarint(input, out uint val))
									return false;
								output.Write(val);
							}
						}
					}
					continue;
				}

				// Read this many IDs, that are relative to result ID
				int relativeCount = op.OpDeltaFromResult();
				bool inverted = false;
				if (relativeCount < 0)
				{
					inverted = true;
					relativeCount = -relativeCount;
				}
				for (int i = 0; i < relativeCount && ioffs < instrLen; ++i, ++ioffs)
				{
					if (!ReadVarint(input, out uint value))
					{
						return false;
					}

					int zd = inverted ? ZigDecode(value) : unchecked((int)value);
					output.Write(prevResult - zd);
				}

				if (wasSwizzle && instrLen <= 9)
				{
					uint swizzle = input.ReadByte();
					if (instrLen > 5) output.Write(swizzle >> 6);
					if (instrLen > 6) output.Write((swizzle >> 4) & 3);
					if (instrLen > 7) output.Write((swizzle >> 2) & 3);
					if (instrLen > 8) output.Write(swizzle & 3);
				}
				else if (op.OpVarRest())
				{
					// read rest of words with variable encoding
					for (; ioffs < instrLen; ++ioffs)
					{
						if (!ReadVarint(input, out uint value))
						{
							return false;
						}
						output.Write(value);
					}
				}
				else
				{
					// read rest of words without any encoding
					for (; ioffs < instrLen; ++ioffs)
					{
						if (input.BaseStream.Position + 4 > input.BaseStream.Length)
						{
							return false;
						}
						uint val = input.ReadUInt32();
						output.Write(val);
					}
				}
			}

			if (output.BaseStream.Position != outputStartPosition + decodedSize)
			{
				// something went wrong during decoding? we should have decoded to exact output size
				return false;
			}

			return true;
		}

		private static bool CheckSmolHeader(byte[] data)
		{
			if (!CheckGenericHeader(data, SmolHeaderMagic))
			{
				return false;
			}

			return true;
		}

		private static bool CheckGenericHeader(byte[] data, uint expectedMagic)
		{
			if (data == null)
			{
				return false;
			}
			if (data.Length < HeaderSize)
			{
				return false;
			}

			uint headerMagic = BitConverter.ToUInt32(data, 0 * sizeof(uint));
			if (headerMagic != expectedMagic)
			{
				return false;
			}

			uint headerVersion = BitConverter.ToUInt32(data, 1 * sizeof(uint));
			if (headerVersion < 0x00010000 || headerVersion > 0x00010300)
			{
				// only support 1.0 through 1.3
				return false;
			}

			return true;
		}

		private static bool ReadVarint(BinaryReader input, out uint value)
		{
			uint v = 0;
			int shift = 0;
			while (input.BaseStream.Position < input.BaseStream.Length)
			{
				byte b = input.ReadByte();
				v |= unchecked((uint)(b & 127) << shift);
				shift += 7;
				if ((b & 128) == 0)
				{
					break;
				}
			}

			value = v;
			// @TODO: report failures
			return true;
		}

		private static bool ReadLengthOp(BinaryReader input, out uint len, out SpvOp op)
		{
			len = default;
			op = default;
			if (!ReadVarint(input, out uint value))
			{
				return false;
			}
			len = ((value >> 20) << 4) | ((value >> 4) & 0xF);
			op = (SpvOp)(((value >> 4) & 0xFFF0) | (value & 0xF));

			op = RemapOp(op);
			len = DecodeLen(op, len);
			return true;
		}

		/// <summary>
		/// Remap most common Op codes (Load, Store, Decorate, VectorShuffle etc.) to be in &lt; 16 range, for 
		/// more compact varint encoding. This basically swaps rarely used op values that are &lt; 16 with the
		/// ones that are common.
		/// </summary>
		private static SpvOp RemapOp(SpvOp op)
		{
			switch (op)
			{
				// 0: 24%
				case SpvOp.Decorate:
					return SpvOp.Nop;
				case SpvOp.Nop:
					return SpvOp.Decorate;

				// 1: 17%
				case SpvOp.Load:
					return SpvOp.Undef;
				case SpvOp.Undef:
					return SpvOp.Load;

				// 2: 9%
				case SpvOp.Store:
					return SpvOp.SourceContinued;
				case SpvOp.SourceContinued:
					return SpvOp.Store;

				// 3: 7.2%
				case SpvOp.AccessChain:
					return SpvOp.Source;
				case SpvOp.Source:
					return SpvOp.AccessChain;

				// 4: 5.0%
				// Name - already small enum value - 5: 4.4%
				// MemberName - already small enum value - 6: 2.9% 
				case SpvOp.VectorShuffle:
					return SpvOp.SourceExtension;
				case SpvOp.SourceExtension:
					return SpvOp.VectorShuffle;

				// 7: 4.0%
				case SpvOp.MemberDecorate:
					return SpvOp.String;
				case SpvOp.String:
					return SpvOp.MemberDecorate;

				// 8: 0.9%
				case SpvOp.Label:
					return SpvOp.Line;
				case SpvOp.Line:
					return SpvOp.Label;

				// 9: 3.9%
				case SpvOp.Variable:
					return (SpvOp)9;
				case (SpvOp)9:
					return SpvOp.Variable;

				// 10: 3.9%
				case SpvOp.FMul:
					return SpvOp.Extension;
				case SpvOp.Extension:
					return SpvOp.FMul;

				// 11: 2.5%
				// ExtInst - already small enum value - 12: 1.2%
				// VectorShuffleCompact - already small enum value - used for compact shuffle encoding
				case SpvOp.FAdd:
					return SpvOp.ExtInstImport;
				case SpvOp.ExtInstImport:
					return SpvOp.FAdd;

				// 14: 2.2%
				case SpvOp.TypePointer:
					return SpvOp.MemoryModel;
				case SpvOp.MemoryModel:
					return SpvOp.TypePointer;

				// 15: 1.1%
				case SpvOp.FNegate:
					return SpvOp.EntryPoint;
				case SpvOp.EntryPoint:
					return SpvOp.FNegate;
			}
			return op;
		}

		private static uint DecodeLen(SpvOp op, uint len)
		{
			len++;
			switch (op)
			{
				case SpvOp.VectorShuffle:
					len += 4;
					break;
				case SpvOp.VectorShuffleCompact:
					len += 4;
					break;
				case SpvOp.Decorate:
					len += 2;
					break;
				case SpvOp.Load:
					len += 3;
					break;
				case SpvOp.AccessChain:
					len += 3;
					break;
			}
			return len;
		}

		private static int DecorationExtraOps(int dec)
		{
			// RelaxedPrecision, Block..ColMajor
			if (dec == 0 || (dec >= 2 && dec <= 5))
			{
				return 0;
			}
			// Stream..XfbStride
			if (dec >= 29 && dec <= 37)
			{
				return 1;
			}

			// unknown, encode length
			return -1;
		}

		private static int ZigDecode(uint u)
		{
			return (u & 1) != 0 ? unchecked((int)(~(u >> 1))) : unchecked((int)(u >> 1));
		}

		public const uint SpirVHeaderMagic = 0x07230203;
		/// <summary>
		/// 'SMOL' ascii
		/// </summary>
		public const uint SmolHeaderMagic = 0x534D4F4C;

		private const int HeaderSize = 6 * sizeof(uint);
	}
}

```

`Smolv/SpvOp.cs`:

```cs
namespace Smolv
{
	public enum SpvOp
	{
		Nop = 0,
		Undef = 1,
		SourceContinued = 2,
		Source = 3,
		SourceExtension = 4,
		Name = 5,
		MemberName = 6,
		String = 7,
		Line = 8,
		Extension = 10,
		ExtInstImport = 11,
		ExtInst = 12,
		/// <summary>
		/// Not in SPIR-V, added for SMOL-V!
		/// </summary>
		VectorShuffleCompact = 13,
		MemoryModel = 14,
		EntryPoint = 15,
		ExecutionMode = 16,
		Capability = 17,
		TypeVoid = 19,
		TypeBool = 20,
		TypeInt = 21,
		TypeFloat = 22,
		TypeVector = 23,
		TypeMatrix = 24,
		TypeImage = 25,
		TypeSampler = 26,
		TypeSampledImage = 27,
		TypeArray = 28,
		TypeRuntimeArray = 29,
		TypeStruct = 30,
		TypeOpaque = 31,
		TypePointer = 32,
		TypeFunction = 33,
		TypeEvent = 34,
		TypeDeviceEvent = 35,
		TypeReserveId = 36,
		TypeQueue = 37,
		TypePipe = 38,
		TypeForwardPointer = 39,
		ConstantTrue = 41,
		ConstantFalse = 42,
		Constant = 43,
		ConstantComposite = 44,
		ConstantSampler = 45,
		ConstantNull = 46,
		SpecConstantTrue = 48,
		SpecConstantFalse = 49,
		SpecConstant = 50,
		SpecConstantComposite = 51,
		SpecConstantOp = 52,
		Function = 54,
		FunctionParameter = 55,
		FunctionEnd = 56,
		FunctionCall = 57,
		Variable = 59,
		ImageTexelPointer = 60,
		Load = 61,
		Store = 62,
		CopyMemory = 63,
		CopyMemorySized = 64,
		AccessChain = 65,
		InBoundsAccessChain = 66,
		PtrAccessChain = 67,
		ArrayLength = 68,
		GenericPtrMemSemantics = 69,
		InBoundsPtrAccessChain = 70,
		Decorate = 71,
		MemberDecorate = 72,
		DecorationGroup = 73,
		GroupDecorate = 74,
		GroupMemberDecorate = 75,
		VectorExtractDynamic = 77,
		VectorInsertDynamic = 78,
		VectorShuffle = 79,
		CompositeConstruct = 80,
		CompositeExtract = 81,
		CompositeInsert = 82,
		CopyObject = 83,
		Transpose = 84,
		SampledImage = 86,
		ImageSampleImplicitLod = 87,
		ImageSampleExplicitLod = 88,
		ImageSampleDrefImplicitLod = 89,
		ImageSampleDrefExplicitLod = 90,
		ImageSampleProjImplicitLod = 91,
		ImageSampleProjExplicitLod = 92,
		ImageSampleProjDrefImplicitLod = 93,
		ImageSampleProjDrefExplicitLod = 94,
		ImageFetch = 95,
		ImageGather = 96,
		ImageDrefGather = 97,
		ImageRead = 98,
		ImageWrite = 99,
		Image = 100,
		ImageQueryFormat = 101,
		ImageQueryOrder = 102,
		ImageQuerySizeLod = 103,
		ImageQuerySize = 104,
		ImageQueryLod = 105,
		ImageQueryLevels = 106,
		ImageQuerySamples = 107,
		ConvertFToU = 109,
		ConvertFToS = 110,
		ConvertSToF = 111,
		ConvertUToF = 112,
		UConvert = 113,
		SConvert = 114,
		FConvert = 115,
		QuantizeToF16 = 116,
		ConvertPtrToU = 117,
		SatConvertSToU = 118,
		SatConvertUToS = 119,
		ConvertUToPtr = 120,
		PtrCastToGeneric = 121,
		GenericCastToPtr = 122,
		GenericCastToPtrExplicit = 123,
		Bitcast = 124,
		SNegate = 126,
		FNegate = 127,
		IAdd = 128,
		FAdd = 129,
		ISub = 130,
		FSub = 131,
		IMul = 132,
		FMul = 133,
		UDiv = 134,
		SDiv = 135,
		FDiv = 136,
		UMod = 137,
		SRem = 138,
		SMod = 139,
		FRem = 140,
		FMod = 141,
		VectorTimesScalar = 142,
		MatrixTimesScalar = 143,
		VectorTimesMatrix = 144,
		MatrixTimesVector = 145,
		MatrixTimesMatrix = 146,
		OuterProduct = 147,
		Dot = 148,
		IAddCarry = 149,
		ISubBorrow = 150,
		UMulExtended = 151,
		SMulExtended = 152,
		Any = 154,
		All = 155,
		IsNan = 156,
		IsInf = 157,
		IsFinite = 158,
		IsNormal = 159,
		SignBitSet = 160,
		LessOrGreater = 161,
		Ordered = 162,
		Unordered = 163,
		LogicalEqual = 164,
		LogicalNotEqual = 165,
		LogicalOr = 166,
		LogicalAnd = 167,
		LogicalNot = 168,
		Select = 169,
		IEqual = 170,
		INotEqual = 171,
		UGreaterThan = 172,
		SGreaterThan = 173,
		UGreaterThanEqual = 174,
		SGreaterThanEqual = 175,
		ULessThan = 176,
		SLessThan = 177,
		ULessThanEqual = 178,
		SLessThanEqual = 179,
		FOrdEqual = 180,
		FUnordEqual = 181,
		FOrdNotEqual = 182,
		FUnordNotEqual = 183,
		FOrdLessThan = 184,
		FUnordLessThan = 185,
		FOrdGreaterThan = 186,
		FUnordGreaterThan = 187,
		FOrdLessThanEqual = 188,
		FUnordLessThanEqual = 189,
		FOrdGreaterThanEqual = 190,
		FUnordGreaterThanEqual = 191,
		ShiftRightLogical = 194,
		ShiftRightArithmetic = 195,
		ShiftLeftLogical = 196,
		BitwiseOr = 197,
		BitwiseXor = 198,
		BitwiseAnd = 199,
		Not = 200,
		BitFieldInsert = 201,
		BitFieldSExtract = 202,
		BitFieldUExtract = 203,
		BitReverse = 204,
		BitCount = 205,
		DPdx = 207,
		DPdy = 208,
		Fwidth = 209,
		DPdxFine = 210,
		DPdyFine = 211,
		FwidthFine = 212,
		DPdxCoarse = 213,
		DPdyCoarse = 214,
		FwidthCoarse = 215,
		EmitVertex = 218,
		EndPrimitive = 219,
		EmitStreamVertex = 220,
		EndStreamPrimitive = 221,
		ControlBarrier = 224,
		MemoryBarrier = 225,
		AtomicLoad = 227,
		AtomicStore = 228,
		AtomicExchange = 229,
		AtomicCompareExchange = 230,
		AtomicCompareExchangeWeak = 231,
		AtomicIIncrement = 232,
		AtomicIDecrement = 233,
		AtomicIAdd = 234,
		AtomicISub = 235,
		AtomicSMin = 236,
		AtomicUMin = 237,
		AtomicSMax = 238,
		AtomicUMax = 239,
		AtomicAnd = 240,
		AtomicOr = 241,
		AtomicXor = 242,
		Phi = 245,
		LoopMerge = 246,
		SelectionMerge = 247,
		Label = 248,
		Branch = 249,
		BranchConditional = 250,
		Switch = 251,
		Kill = 252,
		Return = 253,
		ReturnValue = 254,
		Unreachable = 255,
		LifetimeStart = 256,
		LifetimeStop = 257,
		GroupAsyncCopy = 259,
		GroupWaitEvents = 260,
		GroupAll = 261,
		GroupAny = 262,
		GroupBroadcast = 263,
		GroupIAdd = 264,
		GroupFAdd = 265,
		GroupFMin = 266,
		GroupUMin = 267,
		GroupSMin = 268,
		GroupFMax = 269,
		GroupUMax = 270,
		GroupSMax = 271,
		ReadPipe = 274,
		WritePipe = 275,
		ReservedReadPipe = 276,
		ReservedWritePipe = 277,
		ReserveReadPipePackets = 278,
		ReserveWritePipePackets = 279,
		CommitReadPipe = 280,
		CommitWritePipe = 281,
		IsValidReserveId = 282,
		GetNumPipePackets = 283,
		GetMaxPipePackets = 284,
		GroupReserveReadPipePackets = 285,
		GroupReserveWritePipePackets = 286,
		GroupCommitReadPipe = 287,
		GroupCommitWritePipe = 288,
		EnqueueMarker = 291,
		EnqueueKernel = 292,
		GetKernelNDrangeSubGroupCount = 293,
		GetKernelNDrangeMaxSubGroupSize = 294,
		GetKernelWorkGroupSize = 295,
		GetKernelPreferredWorkGroupSizeMultiple = 296,
		RetainEvent = 297,
		ReleaseEvent = 298,
		CreateUserEvent = 299,
		IsValidEvent = 300,
		SetUserEventStatus = 301,
		CaptureEventProfilingInfo = 302,
		GetDefaultQueue = 303,
		BuildNDRange = 304,
		ImageSparseSampleImplicitLod = 305,
		ImageSparseSampleExplicitLod = 306,
		ImageSparseSampleDrefImplicitLod = 307,
		ImageSparseSampleDrefExplicitLod = 308,
		ImageSparseSampleProjImplicitLod = 309,
		ImageSparseSampleProjExplicitLod = 310,
		ImageSparseSampleProjDrefImplicitLod = 311,
		ImageSparseSampleProjDrefExplicitLod = 312,
		ImageSparseFetch = 313,
		ImageSparseGather = 314,
		ImageSparseDrefGather = 315,
		ImageSparseTexelsResident = 316,
		NoLine = 317,
		AtomicFlagTestAndSet = 318,
		AtomicFlagClear = 319,
		ImageSparseRead = 320,
		SizeOf = 321,
		TypePipeStorage = 322,
		ConstantPipeStorage = 323,
		CreatePipeFromPipeStorage = 324,
		GetKernelLocalSizeForSubgroupCount = 325,
		GetKernelMaxNumSubgroups = 326,
		TypeNamedBarrier = 327,
		NamedBarrierInitialize = 328,
		MemoryNamedBarrier = 329,
		ModuleProcessed = 330,
		ExecutionModeId = 331,
		DecorateId = 332,
		GroupNonUniformElect = 333,
		GroupNonUniformAll = 334,
		GroupNonUniformAny = 335,
		GroupNonUniformAllEqual = 336,
		GroupNonUniformBroadcast = 337,
		GroupNonUniformBroadcastFirst = 338,
		GroupNonUniformBallot = 339,
		GroupNonUniformInverseBallot = 340,
		GroupNonUniformBallotBitExtract = 341,
		GroupNonUniformBallotBitCount = 342,
		GroupNonUniformBallotFindLSB = 343,
		GroupNonUniformBallotFindMSB = 344,
		GroupNonUniformShuffle = 345,
		GroupNonUniformShuffleXor = 346,
		GroupNonUniformShuffleUp = 347,
		GroupNonUniformShuffleDown = 348,
		GroupNonUniformIAdd = 349,
		GroupNonUniformFAdd = 350,
		GroupNonUniformIMul = 351,
		GroupNonUniformFMul = 352,
		GroupNonUniformSMin = 353,
		GroupNonUniformUMin = 354,
		GroupNonUniformFMin = 355,
		GroupNonUniformSMax = 356,
		GroupNonUniformUMax = 357,
		GroupNonUniformFMax = 358,
		GroupNonUniformBitwiseAnd = 359,
		GroupNonUniformBitwiseOr = 360,
		GroupNonUniformBitwiseXor = 361,
		GroupNonUniformLogicalAnd = 362,
		GroupNonUniformLogicalOr = 363,
		GroupNonUniformLogicalXor = 364,
		GroupNonUniformQuadBroadcast = 365,
		GroupNonUniformQuadSwap = 366,
	}

	public static class SpvOpExtensions
	{
		/// <summary>
		/// Instruction encoding depends on the table that describes the various SPIR-V opcodes.<br/>
		/// Whenever we change or expand the table, we need to bump up the SMOL-V version,<br/>
		/// and make sure that we can still decode files encoded by an older version.
		/// </summary>
		static int GetKnownOpsCount(int version)
		{
			if (version == 0)
				return (int)(SpvOp.ModuleProcessed + 1);
			if (version == 1) // 2020 February, version 1 added ExecutionModeId..GroupNonUniformQuadSwap
				return (int)(SpvOp.GroupNonUniformQuadSwap + 1);
			return 0;
		}

		public static bool OpHasResult(this SpvOp _this) => OpHasResult(_this, GetKnownOpsCount(0));
		public static bool OpHasResult(this SpvOp _this, int opsCount)
		{
			if (_this < 0 || (int)_this >= opsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].hasResult != 0;
		}

		public static bool OpHasType(this SpvOp _this) => OpHasType(_this, GetKnownOpsCount(0));
		public static bool OpHasType(this SpvOp _this, int opsCount)
		{
			if (_this < 0 || (int)_this >= opsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].hasType != 0;
		}

		public static int OpDeltaFromResult(this SpvOp _this) => OpDeltaFromResult(_this, GetKnownOpsCount(0));
		public static int OpDeltaFromResult(this SpvOp _this, int opsCount)
		{
			if (_this < 0 || (int)_this >= opsCount)
			{
				return 0;
			}
			return OpData.SpirvOpData[(int)_this].deltaFromResult;
		}

		public static bool OpVarRest(this SpvOp _this) => OpVarRest(_this, GetKnownOpsCount(0));
		public static bool OpVarRest(this SpvOp _this, int opsCount)
		{
			if (_this < 0 || (int)_this >= opsCount)
			{
				return false;
			}
			return OpData.SpirvOpData[(int)_this].varrest != 0;
		}

		public static bool OpDebugInfo(this SpvOp _this) => OpDebugInfo(_this, GetKnownOpsCount(0));
		public static bool OpDebugInfo(this SpvOp _this, int opsCount)
		{
			return
				_this == SpvOp.SourceContinued ||
				_this == SpvOp.Source ||
				_this == SpvOp.SourceExtension ||
				_this == SpvOp.Name ||
				_this == SpvOp.MemberName ||
				_this == SpvOp.String ||
				_this == SpvOp.Line ||
				_this == SpvOp.NoLine ||
				_this == SpvOp.ModuleProcessed;
		}
	}
}

```

`SpirV/Disassembler.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public struct ModuleHeader
	{
		public Version Version { get; set; }
		public string GeneratorVendor { get; set; }
		public string GeneratorName { get; set; }
		public int GeneratorVersion { get; set; }
		public uint Bound { get; set; }
		public uint Reserved { get; set; }
	}

	[Flags]
	public enum DisassemblyOptions
	{
		None,
		ShowTypes,
		ShowNames,
		Default = ShowTypes | ShowNames
	}

	public class Disassembler
	{
		public string Disassemble(Module module)
		{
			return Disassemble(module, DisassemblyOptions.Default);
		}

		public string Disassemble(Module module, DisassemblyOptions options)
		{
			m_sb.AppendLine("; SPIR-V");
			m_sb.Append("; Version: ").Append(module.Header.Version).AppendLine();
			if (module.Header.GeneratorName == null)
			{
				m_sb.Append("; Generator: unknown; ").Append(module.Header.GeneratorVersion).AppendLine();
			}
			else
			{
				m_sb.Append("; Generator: ").Append(module.Header.GeneratorVendor).Append(' ').
					Append(module.Header.GeneratorName).Append("; ").Append(module.Header.GeneratorVersion).AppendLine();
			}
			m_sb.Append("; Bound: ").Append(module.Header.Bound).AppendLine();
			m_sb.Append("; Schema: ").Append(module.Header.Reserved).AppendLine();

			string[] lines = new string[module.Instructions.Count + 1];
			lines[0] = m_sb.ToString();
			m_sb.Clear();

			for (int i = 0; i < module.Instructions.Count; i++)
			{
				ParsedInstruction instruction = module.Instructions[i];
				PrintInstruction(m_sb, instruction, options);
				lines[i + 1] = m_sb.ToString();
				m_sb.Clear();
			}

			int longestPrefix = 0;
			for (int i = 0; i < lines.Length; i++)
			{
				string line = lines[i];
				longestPrefix = Math.Max(longestPrefix, line.IndexOf('='));
				if (longestPrefix > 50)
				{
					longestPrefix = 50;
					break;
				}
			}

			m_sb.Append(lines[0]);
			for (int i = 1; i < lines.Length; i++)
			{
				string line = lines[i];
				int index = line.IndexOf('=');
				if (index == -1)
				{
					m_sb.Append(' ', longestPrefix + 4);
					m_sb.Append(line);
				}
				else
				{
					int pad = Math.Max(0, longestPrefix - index);
					m_sb.Append(' ', pad);
					m_sb.Append(line, 0, index);
					m_sb.Append('=');
					m_sb.Append(line, index + 1, line.Length - index - 1);
				}
				m_sb.AppendLine();
			}

			string result = m_sb.ToString();
			m_sb.Clear();
			return result;
		}

		private static void PrintInstruction(StringBuilder sb, ParsedInstruction instruction, DisassemblyOptions options)
		{
			if (instruction.Operands.Count == 0)
			{
				sb.Append(instruction.Instruction.Name);
				return;
			}

			int currentOperand = 0;
			if (instruction.Instruction.Operands[currentOperand].Type is IdResultType)
			{
				if (options.HasFlag(DisassemblyOptions.ShowTypes))
				{
					instruction.ResultType.ToString(sb).Append(' ');
				}
				++currentOperand;
			}

			if (currentOperand < instruction.Operands.Count && instruction.Instruction.Operands[currentOperand].Type is IdResult)
			{
				if (!options.HasFlag(DisassemblyOptions.ShowNames) || string.IsNullOrWhiteSpace(instruction.Name))
				{
					PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
				}
				else
				{
					sb.Append(instruction.Name);
				}
				sb.Append(" = ");

				++currentOperand;
			}

			sb.Append(instruction.Instruction.Name);
			sb.Append(' ');

			for (; currentOperand < instruction.Operands.Count; ++currentOperand)
			{
				PrintOperandValue(sb, instruction.Operands[currentOperand].Value, options);
				sb.Append(' ');
			}
		}

		private static void PrintOperandValue(StringBuilder sb, object value, DisassemblyOptions options)
		{
			switch (value)
			{
				case System.Type t:
					sb.Append(t.Name);
					break;

				case string s:
					{
						sb.Append('"');
						sb.Append(s);
						sb.Append('"');
					}
					break;

				case ObjectReference or:
					{
						if (options.HasFlag(DisassemblyOptions.ShowNames) && or.Reference != null && !string.IsNullOrWhiteSpace(or.Reference.Name))
						{
							sb.Append(or.Reference.Name);
						}
						else
						{
							or.ToString(sb);
						}
					}
					break;

				case IBitEnumOperandValue beov:
					PrintBitEnumValue(sb, beov, options);
					break;

				case IValueEnumOperandValue veov:
					PrintValueEnumValue(sb, veov, options);
					break;

				case VaryingOperandValue varOpVal:
					varOpVal.ToString(sb);
					break;

				default:
					sb.Append(value);
					break;
			}
		}

		private static void PrintBitEnumValue(StringBuilder sb, IBitEnumOperandValue enumOperandValue, DisassemblyOptions options)
		{
			foreach (uint key in enumOperandValue.Values.Keys)
			{
				sb.Append(enumOperandValue.EnumerationType.GetEnumName(key));
				IReadOnlyList<object> value = enumOperandValue.Values[key];
				if (value.Count != 0)
				{
					sb.Append(' ');
					foreach (object v in value)
					{
						PrintOperandValue(sb, v, options);
					}
				}
			}
		}

		private static void PrintValueEnumValue(StringBuilder sb, IValueEnumOperandValue valueOperandValue, DisassemblyOptions options)
		{
			sb.Append(valueOperandValue.Key);
			if (valueOperandValue.Value is IList<object> valueList && valueList.Count > 0)
			{
				sb.Append(' ');
				foreach (object v in valueList)
				{
					PrintOperandValue(sb, v, options);
				}
			}
		}

		private readonly StringBuilder m_sb = new StringBuilder();
	}
}

```

`SpirV/EnumValuesExtensions.cs`:

```cs
#if NETSTANDARD1_0 || NETSTANDARD1_1 || NETSTANDARD1_2 || NETSTANDARD1_3 || NETSTANDARD1_4 || NETSTANDARD1_5 || NETSTANDARD1_6
using System;
using System.Linq;
using System.Reflection;

namespace SpirV
{
	public static class EnumValuesExtensions
	{
		public static Array GetEnumValues(this System.Type _this)
		{
			TypeInfo typeInfo = _this.GetTypeInfo ();
			if (!typeInfo.IsEnum) {
				throw new ArgumentException ("GetEnumValues: Type '" + _this.Name + "' is not an enum");
			}

			return
				(
				  from field in typeInfo.DeclaredFields
				  where field.IsLiteral
				  select field.GetValue (null)
				)
				.ToArray();
		}

		public static string GetEnumName(this System.Type _this, object value)
		{
			TypeInfo typeInfo = _this.GetTypeInfo ();
			if (!typeInfo.IsEnum) {
				throw new ArgumentException ("GetEnumName: Type '" + _this.Name + "' is not an enum");
			}
			return
				(
				  from field in typeInfo.DeclaredFields
				  where field.IsLiteral && (uint)field.GetValue(null) == (uint)value
				  select field.Name
				)
				.First();
		}
	}
}
#endif
```

`SpirV/Instruction.cs`:

```cs
using System.Collections.Generic;

namespace SpirV
{
	public enum OperandQuantifier
	{
		/// <summary>
		/// 1
		/// </summary>
		Default,
		/// <summary>
		/// 0 or 1
		/// </summary>
		Optional,
		/// <summary>
		/// 0+
		/// </summary>
		Varying
	}

	public class Operand
	{
		public Operand(OperandType kind, string name, OperandQuantifier quantifier)
		{
			Name = name;
			Type = kind;
			Quantifier = quantifier;
		}

		public string Name { get; }
		public OperandType Type { get; }
		public OperandQuantifier Quantifier { get; }
	}

	public class Instruction
	{
		public Instruction(string name)
			: this(name, new List<Operand>())
		{
		}

		public Instruction(string name, IReadOnlyList<Operand> operands)
		{
			Operands = operands;
			Name = name;
		}

		public string Name { get; }
		public IReadOnlyList<Operand> Operands { get; }
	}
}

```

`SpirV/Module.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Runtime.InteropServices;

namespace SpirV
{
	public class Module
	{
		[StructLayout(LayoutKind.Explicit)]
		private struct FloatUIntUnion
		{
			[FieldOffset(0)]
			public uint Int;
			[FieldOffset(0)]
			public float Float;
		}

		[StructLayout(LayoutKind.Explicit)]
		private struct DoubleULongUnion
		{
			[FieldOffset(0)]
			public ulong Long;
			[FieldOffset(0)]
			public double Double;
		}

		public Module(ModuleHeader header, IReadOnlyList<ParsedInstruction> instructions)
		{
			Header = header;
			Instructions = instructions;

			Read(Instructions, objects_);
		}

		public static bool IsDebugInstruction(ParsedInstruction instruction)
		{
			return debugInstructions_.Contains(instruction.Instruction.Name);
		}

		private static void Read(IReadOnlyList<ParsedInstruction> instructions, Dictionary<uint, ParsedInstruction> objects)
		{
			// Debug instructions can be only processed after everything
			// else has been parsed, as they may reference types which haven't
			// been seen in the file yet
			List<ParsedInstruction> debugInstructions = new List<ParsedInstruction>();
			// Entry points contain forward references
			// Those need to be resolved afterwards
			List<ParsedInstruction> entryPoints = new List<ParsedInstruction>();

			foreach (var instruction in instructions)
			{
				if (IsDebugInstruction(instruction))
				{
					debugInstructions.Add(instruction);
					continue;
				}
				if (instruction.Instruction is OpEntryPoint)
				{
					entryPoints.Add(instruction);
					continue;
				}

				if (instruction.Instruction.Name.StartsWith("OpType", StringComparison.Ordinal))
				{
					ProcessTypeInstruction(instruction, objects);
				}

				instruction.ResolveResultType(objects);
				if (instruction.HasResult)
				{
					objects[instruction.ResultId] = instruction;
				}

				switch (instruction.Instruction)
				{
					// Constants require that the result type has been resolved
					case OpSpecConstant sc:
					case OpConstant oc:
						{
							Type t = instruction.ResultType;
							Debug.Assert(t != null);
							Debug.Assert(t is ScalarType);

							object constant = ConvertConstant(instruction.ResultType as ScalarType, instruction.Words, 3);
							instruction.Operands[2].Value = constant;
							instruction.Value = constant;
						}
						break;
				}
			}

			foreach (ParsedInstruction instruction in debugInstructions)
			{
				switch (instruction.Instruction)
				{
					case OpMemberName mn:
						{
							StructType t = (StructType)objects[instruction.Words[1]].ResultType;
							t.SetMemberName((uint)instruction.Operands[1].Value, (string)instruction.Operands[2].Value);
						}
						break;

					case OpName n:
						{
							// We skip naming objects we don't know about
							ParsedInstruction t = objects[instruction.Words[1]];
							t.Name = (string)instruction.Operands[1].Value;
						}
						break;
				}
			}

			foreach (ParsedInstruction instruction in instructions)
			{
				instruction.ResolveReferences(objects);
			}
		}

		public static Module ReadFrom(Stream stream)
		{
			BinaryReader br = new BinaryReader(stream);
			Reader reader = new Reader(br);

			uint versionNumber = reader.ReadDWord();
			int majorVersion = (int)(versionNumber >> 16);
			int minorVersion = (int)((versionNumber >> 8) & 0xFF);
			Version version = new Version(majorVersion, minorVersion);

			uint generatorMagicNumber = reader.ReadDWord();
			int generatorToolId = (int)(generatorMagicNumber >> 16);
			string generatorVendor = "unknown";
			string generatorName = null;

			if (Meta.Tools.ContainsKey(generatorToolId))
			{
				Meta.ToolInfo toolInfo = Meta.Tools[generatorToolId];
				generatorVendor = toolInfo.Vendor;
				if (toolInfo.Name != null)
				{
					generatorName = toolInfo.Name;
				}
			}

			// Read header
			ModuleHeader header = new ModuleHeader();
			header.Version = version;
			header.GeneratorName = generatorName;
			header.GeneratorVendor = generatorVendor;
			header.GeneratorVersion = (int)(generatorMagicNumber & 0xFFFF);
			header.Bound = reader.ReadDWord();
			header.Reserved = reader.ReadDWord();

			List<ParsedInstruction> instructions = new List<ParsedInstruction>();
			while (!reader.EndOfStream)
			{
				uint instructionStart = reader.ReadDWord();
				ushort wordCount = (ushort)(instructionStart >> 16);
				int opCode = (int)(instructionStart & 0xFFFF);

				uint[] words = new uint[wordCount];
				words[0] = instructionStart;
				for (ushort i = 1; i < wordCount; ++i)
				{
					words[i] = reader.ReadDWord();
				}

				ParsedInstruction instruction = new ParsedInstruction(opCode, words);
				instructions.Add(instruction);
			}

			return new Module(header, instructions);
		}

		/// <summary>
		/// Collect types from OpType* instructions
		/// </summary>
		private static void ProcessTypeInstruction(ParsedInstruction i, IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			switch (i.Instruction)
			{
				case OpTypeInt t:
					{
						i.ResultType = new IntegerType((int)i.Words[2], i.Words[3] == 1u);
					}
					break;

				case OpTypeFloat t:
					{
						i.ResultType = new FloatingPointType((int)i.Words[2]);
					}
					break;

				case OpTypeVector t:
					{
						i.ResultType = new VectorType((ScalarType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
					}
					break;

				case OpTypeMatrix t:
					{
						i.ResultType = new MatrixType((VectorType)objects[i.Words[2]].ResultType, (int)i.Words[3]);
					}
					break;

				case OpTypeArray t:
					{
						object constant = objects[i.Words[3]].Value;
						int size = 0;

						switch (constant)
						{
							case ushort u16:
								size = u16;
								break;

							case uint u32:
								size = (int)u32;
								break;

							case ulong u64:
								size = (int)u64;
								break;

							case short i16:
								size = i16;
								break;

							case int i32:
								size = i32;
								break;

							case long i64:
								size = (int)i64;
								break;
						}

						i.ResultType = new ArrayType(objects[i.Words[2]].ResultType, size);
					}
					break;

				case OpTypeRuntimeArray t:
					{
						i.ResultType = new RuntimeArrayType((Type)objects[i.Words[2]].ResultType);
					}
					break;

				case OpTypeBool t:
					{
						i.ResultType = new BoolType();
					}
					break;

				case OpTypeOpaque t:
					{
						i.ResultType = new OpaqueType();
					}
					break;

				case OpTypeVoid t:
					{
						i.ResultType = new VoidType();
					}
					break;

				case OpTypeImage t:
					{
						Type sampledType = objects[i.Operands[1].GetId()].ResultType;
						Dim dim = i.Operands[2].GetSingleEnumValue<Dim>();
						uint depth = (uint)i.Operands[3].Value;
						bool isArray = (uint)i.Operands[4].Value != 0;
						bool isMultiSampled = (uint)i.Operands[5].Value != 0;
						uint sampled = (uint)i.Operands[6].Value;
						ImageFormat imageFormat = i.Operands[7].GetSingleEnumValue<ImageFormat>();

						i.ResultType = new ImageType(sampledType,
							dim,
							(int)depth, isArray, isMultiSampled,
							(int)sampled, imageFormat,
							i.Operands.Count > 8 ? i.Operands[8].GetSingleEnumValue<AccessQualifier>() : AccessQualifier.ReadOnly);
					}
					break;

				case OpTypeSampler st:
					{
						i.ResultType = new SamplerType();
						break;
					}

				case OpTypeSampledImage t:
					{
						i.ResultType = new SampledImageType((ImageType)objects[i.Words[2]].ResultType);
					}
					break;

				case OpTypeFunction t:
					{
						List<Type> parameterTypes = new List<Type>();
						for (int j = 3; j < i.Words.Count; ++j)
						{
							parameterTypes.Add(objects[i.Words[j]].ResultType);
						}
						i.ResultType = new FunctionType(objects[i.Words[2]].ResultType, parameterTypes);
					}
					break;

				case OpTypeForwardPointer t:
					{
						// We create a normal pointer, but with unspecified type
						// This will get resolved later on
						i.ResultType = new PointerType((StorageClass)i.Words[2]);
					}
					break;

				case OpTypePointer t:
					{
						if (objects.ContainsKey(i.Words[1]))
						{
							// If there is something present, it must have been
							// a forward reference. The storage type must
							// match
							PointerType pt = (PointerType)i.ResultType;
							Debug.Assert(pt != null);
							Debug.Assert(pt.StorageClass == (StorageClass)i.Words[2]);
							pt.ResolveForwardReference(objects[i.Words[3]].ResultType);
						}
						else
						{
							i.ResultType = new PointerType((StorageClass)i.Words[2], objects[i.Words[3]].ResultType);
						}
					}
					break;

				case OpTypeStruct t:
					{
						List<Type> memberTypes = new List<Type>();
						for (int j = 2; j < i.Words.Count; ++j)
						{
							memberTypes.Add(objects[i.Words[j]].ResultType);
						}
						i.ResultType = new StructType(memberTypes);
					}
					break;
			}
		}

		private static object ConvertConstant(ScalarType type, IReadOnlyList<uint> words, int index)
		{
			switch (type)
			{
				case IntegerType i:
					{
						if (i.Signed)
						{
							if (i.Width == 16)
							{
								return unchecked((short)(words[index]));
							}
							else if (i.Width == 32)
							{
								return unchecked((int)(words[index]));
							}
							else if (i.Width == 64)
							{
								return unchecked((long)(words[index] | (ulong)(words[index + 1]) << 32));
							}
						}
						else
						{
							if (i.Width == 16)
							{
								return unchecked((ushort)(words[index]));
							}
							else if (i.Width == 32)
							{
								return words[index];
							}
							else if (i.Width == 64)
							{
								return words[index] | (ulong)(words[index + 1]) << 32;
							}
						}

						throw new Exception("Cannot construct integer literal.");
					}

				case FloatingPointType f:
					{
						if (f.Width == 32)
						{
							return new FloatUIntUnion { Int = words[0] }.Float;
						}
						else if (f.Width == 64)
						{
							return new DoubleULongUnion { Long = (words[index] | (ulong)(words[index + 1]) << 32) }.Double;
						}
						else
						{
							throw new Exception("Cannot construct floating point literal.");
						}
					}
			}

			return null;
		}

		public ModuleHeader Header { get; }
		public IReadOnlyList<ParsedInstruction> Instructions { get; }

		private static HashSet<string> debugInstructions_ = new HashSet<string>
		{
			"OpSourceContinued",
			"OpSource",
			"OpSourceExtension",
			"OpName",
			"OpMemberName",
			"OpString",
			"OpLine",
			"OpNoLine",
			"OpModuleProcessed"
		};

		private readonly Dictionary<uint, ParsedInstruction> objects_ = new Dictionary<uint, ParsedInstruction>();
	}
}

```

`SpirV/OperandType.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;

namespace SpirV
{
	public class OperandType
	{
		public virtual bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			// This returns the dynamic type
			value = GetType();
			wordsUsed = 1;
			return true;
		}
	}

	public class Literal : OperandType
	{
	}

	public class LiteralNumber : Literal
	{
	}

	// The SPIR-V JSON file uses only literal integers
	public class LiteralInteger : LiteralNumber
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class LiteralString : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			// This is just a fail-safe -- the loop below must terminate
			wordsUsed = 1;
			int bytesUsed = 0;
			byte[] bytes = new byte[(words.Count - index) * 4];
			for (int i = index; i < words.Count; ++i)
			{
				uint word = words[i];
				byte b0 = (byte)(word & 0xFF);
				if (b0 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b0;
				}

				byte b1 = (byte)((word >> 8) & 0xFF);
				if (b1 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b1;
				}

				byte b2 = (byte)((word >> 16) & 0xFF);
				if (b2 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b2;
				}

				byte b3 = (byte)(word >> 24);
				if (b3 == 0)
				{
					break;
				}
				else
				{
					bytes[bytesUsed++] = b3;
				}
				wordsUsed++;
			}

			value = Encoding.UTF8.GetString(bytes, 0, bytesUsed);
			return true;
		}
	}

	public class LiteralContextDependentNumber : Literal
	{
		// This is handled during parsing by ConvertConstant
	}

	public class LiteralExtInstInteger : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class LiteralSpecConstantOpInteger : Literal
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			List<ObjectReference> result = new List<ObjectReference>();
			for (int i = index; i < words.Count; i++)
			{
				ObjectReference objRef = new ObjectReference(words[i]);
				result.Add(objRef);
			}

			value = result;
			wordsUsed = words.Count - index;
			return true;
		}
	}

	public class Parameter
	{
		public virtual IReadOnlyList<OperandType> OperandTypes { get; }
	}

	public class ParameterFactory
	{
		public virtual Parameter CreateParameter(object value)
		{
			return null;
		}
	}

	public class EnumType<T> : EnumType<T, ParameterFactory>
		where T : Enum
	{
	};

	public class EnumType<T, U> : OperandType
		where T : Enum
		where U : ParameterFactory, new()
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			int wordsUsedForParameters = 0;
			if (typeof(T).GetTypeInfo().GetCustomAttributes<FlagsAttribute>().Any())
			{
				Dictionary<uint, IReadOnlyList<object>> result = new Dictionary<uint, IReadOnlyList<object>>();
				foreach (object enumValue in EnumerationType.GetEnumValues())
				{
					uint bit = (uint)enumValue;
					// bit == 0 and words[0] == 0 handles the 0x0 = None cases
					if ((words[index] & bit) != 0 || (bit == 0 && words[index] == 0))
					{
						Parameter p = parameterFactory_.CreateParameter(bit);
						if (p == null)
						{
							result.Add(bit, Array.Empty<object>());
						}
						else
						{
							object[] resultItems = new object[p.OperandTypes.Count];
							for (int j = 0; j < p.OperandTypes.Count; ++j)
							{
								p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
								wordsUsedForParameters += pWordsUsed;
								resultItems[j] = pValue;
							}
							result.Add(bit, resultItems);
						}
					}
				}
				value = new BitEnumOperandValue<T>(result);
			}
			else
			{
				object[] resultItems;
				Parameter p = parameterFactory_.CreateParameter(words[index]);
				if (p == null)
				{
					resultItems = Array.Empty<object>();
				}
				else
				{
					resultItems = new object[p.OperandTypes.Count];
					for (int j = 0; j < p.OperandTypes.Count; ++j)
					{
						p.OperandTypes[j].ReadValue(words, 1 + wordsUsedForParameters, out object pValue, out int pWordsUsed);
						wordsUsedForParameters += pWordsUsed;
						resultItems[j] = pValue;
					}
				}
				value = new ValueEnumOperandValue<T>((T)(object)words[index], resultItems);
			}

			wordsUsed = wordsUsedForParameters + 1;
			return true;
		}

		public System.Type EnumerationType => typeof(T);

		private U parameterFactory_ = new U();
	}

	public class IdScope : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = (Scope)words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdMemorySemantics : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = (MemorySemantics)words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdType : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = words[index];
			wordsUsed = 1;
			return true;
		}
	}

	public class IdResult : IdType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = new ObjectReference(words[index]);
			wordsUsed = 1;
			return true;
		}
	}

	public class IdResultType : IdType
	{
	}

	public class IdRef : IdType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			value = new ObjectReference(words[index]);
			wordsUsed = 1;
			return true;
		}
	}

	public class PairIdRefIdRef : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			ObjectReference variable = new ObjectReference(words[index]);
			ObjectReference parent = new ObjectReference(words[index + 1]);
			value = new { Variable = variable, Parent = parent };
			wordsUsed = 2;
			return true;
		}
	}

	public class PairIdRefLiteralInteger : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			ObjectReference type = new ObjectReference(words[index]);
			uint word = words[index + 1];
			value = new { Type = type, Member = word };
			wordsUsed = 2;
			return true;
		}
	}

	public class PairLiteralIntegerIdRef : OperandType
	{
		public override bool ReadValue(IReadOnlyList<uint> words, int index, out object value, out int wordsUsed)
		{
			uint selector = words[index];
			ObjectReference label = new ObjectReference(words[index + 1]);
			value = new { Selector = selector, Label = label };
			wordsUsed = 2;
			return true;
		}
	}
}
```

`SpirV/ParsedInstruction.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public class ParsedOperand
	{
		public ParsedOperand(IReadOnlyList<uint> words, int index, int count, object value, Operand operand)
		{
			uint[] array = new uint[count];
			for (int i = 0; i < count; i++)
			{
				array[i] = words[index + i];
			}

			Words = array;
			Value = value;
			Operand = operand;
		}

		public T GetSingleEnumValue<T>() where T : Enum
		{
			IValueEnumOperandValue v = (IValueEnumOperandValue)Value;
			if (v.Value.Count == 0)
			{
				// If there's no value at all, the enum is probably something like ImageFormat.
				// In which case we just return the enum value
				return (T)v.Key;
			}
			else
			{
				// This means the enum has a value attached to it, so we return the attached value
				return (T)((IValueEnumOperandValue)Value).Value[0];
			}
		}

		public uint GetId()
		{
			return ((ObjectReference)Value).Id;
		}

		public T GetBitEnumValue<T>() where T : Enum
		{
			var v = Value as IBitEnumOperandValue;

			uint result = 0;
			foreach (var k in v.Values.Keys)
			{
				result |= k;
			}

			return (T)(object)result;
		}

		public IReadOnlyList<uint> Words { get; }
		public object Value { get; set; }
		public Operand Operand { get; }
	}

	public class VaryingOperandValue
	{
		public VaryingOperandValue(IReadOnlyList<object> values)
		{
			Values = values;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			for (int i = 0; i < Values.Count; ++i)
			{
				if (Values[i] is ObjectReference objRef)
				{
					objRef.ToString(sb);
				}
				else
				{
					sb.Append(Values[i]);
				}
				if (i < (Values.Count - 1))
				{
					sb.Append(' ');
				}
			}
			return sb;
		}

		public IReadOnlyList<object> Values { get; }
	}

	public interface IEnumOperandValue
	{
		System.Type EnumerationType { get; }
	}

	public interface IBitEnumOperandValue : IEnumOperandValue
	{
		IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
	}

	public interface IValueEnumOperandValue : IEnumOperandValue
	{
		object Key { get; }
		IReadOnlyList<object> Value { get; }
	}

	public class ValueEnumOperandValue<T> : IValueEnumOperandValue
		where T : Enum
	{
		public ValueEnumOperandValue(T key, IReadOnlyList<object> value)
		{
			Key = key;
			Value = value;
		}

		public System.Type EnumerationType => typeof(T);
		public object Key { get; }
		public IReadOnlyList<object> Value { get; }
	}

	public class BitEnumOperandValue<T> : IBitEnumOperandValue
		where T : Enum
	{
		public BitEnumOperandValue(Dictionary<uint, IReadOnlyList<object>> values)
		{
			Values = values;
		}

		public IReadOnlyDictionary<uint, IReadOnlyList<object>> Values { get; }
		public System.Type EnumerationType => typeof(T);
	}

	public class ObjectReference
	{
		public ObjectReference(uint id)
		{
			Id = id;
		}

		public void Resolve(IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			Reference = objects[Id];
		}

		public override string ToString()
		{
			return $"%{Id}";
		}

		public StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append('%').Append(Id);
		}

		public uint Id { get; }
		public ParsedInstruction Reference { get; private set; }
	}

	public class ParsedInstruction
	{
		public ParsedInstruction(int opCode, IReadOnlyList<uint> words)
		{
			Words = words;
			Instruction = Instructions.OpcodeToInstruction[opCode];
			ParseOperands();
		}

		private void ParseOperands()
		{
			if (Instruction.Operands.Count == 0)
			{
				return;
			}

			// Word 0 describes this instruction so we can ignore it
			int currentWord = 1;
			int currentOperand = 0;
			List<object> varyingOperandValues = new List<object>();
			int varyingWordStart = 0;
			Operand varyingOperand = null;

			while (currentWord < Words.Count)
			{
				Operand operand = Instruction.Operands[currentOperand];
				operand.Type.ReadValue(Words, currentWord, out object value, out int wordsUsed);
				if (operand.Quantifier == OperandQuantifier.Varying)
				{
					varyingOperandValues.Add(value);
					varyingWordStart = currentWord;
					varyingOperand = operand;
				}
				else
				{
					int wordCount = Math.Min(Words.Count - currentWord, wordsUsed);
					ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, wordCount, value, operand);
					Operands.Add(parsedOperand);
				}

				currentWord += wordsUsed;
				if (operand.Quantifier != OperandQuantifier.Varying)
				{
					++currentOperand;
				}
			}

			if (varyingOperand != null)
			{
				VaryingOperandValue varOperantValue = new VaryingOperandValue(varyingOperandValues);
				ParsedOperand parsedOperand = new ParsedOperand(Words, currentWord, Words.Count - currentWord, varOperantValue, varyingOperand);
				Operands.Add(parsedOperand);
			}
		}

		public void ResolveResultType(IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			if (Instruction.Operands.Count > 0 && Instruction.Operands[0].Type is IdResultType)
			{
				ResultType = objects[(uint)Operands[0].Value].ResultType;
			}
		}

		public void ResolveReferences(IReadOnlyDictionary<uint, ParsedInstruction> objects)
		{
			foreach (var operand in Operands)
			{
				if (operand.Value is ObjectReference objectReference)
				{
					objectReference.Resolve(objects);
				}
			}
		}

		public Type ResultType { get; set; }
		public uint ResultId
		{
			get
			{
				for (int i = 0; i < Instruction.Operands.Count; ++i)
				{
					if (Instruction.Operands[i].Type is IdResult)
					{
						return Operands[i].GetId();
					}
				}
				return 0;
			}
		}
		public bool HasResult => ResultId != 0;

		public IReadOnlyList<uint> Words { get; }
		public Instruction Instruction { get; }
		public IList<ParsedOperand> Operands { get; } = new List<ParsedOperand>();
		public string Name { get; set; }
		public object Value { get; set; }
	}
}

```

`SpirV/README.md`:

```md
# SpirV

## License

[SpirV](https://github.com/Anteru/csspv) is licensed under the [BSD 2-Clause license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/SpirV.md).
```

`SpirV/Reader.cs`:

```cs
using System;
using System.IO;
using System.Runtime.CompilerServices;

namespace SpirV
{
	internal sealed class Reader
	{
		public Reader(BinaryReader reader)
		{
			reader_ = reader;
			uint magicNumber = reader_.ReadUInt32();
			if (magicNumber == Meta.MagicNumber)
			{
				littleEndian_ = true;
			}
			else if (Reverse(magicNumber) == Meta.MagicNumber)
			{
				littleEndian_ = false;
			}
			else
			{
				throw new Exception("Invalid magic number");
			}
		}

		public uint ReadDWord()
		{
			if (littleEndian_)
			{
				return reader_.ReadUInt32();
			}
			else
			{
				return Reverse(reader_.ReadUInt32());
			}
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		private static uint Reverse(uint u)
		{
			return (u << 24) | (u & 0xFF00U) << 8 | (u >> 8) & 0xFF00U | (u >> 24);
		}

		public bool EndOfStream => reader_.BaseStream.Position == reader_.BaseStream.Length;

		private readonly BinaryReader reader_;
		private readonly bool littleEndian_;
	}
}

```

`SpirV/SpirV.Core.Grammar.cs`:

```cs
using System;
using System.Collections.Generic;

namespace SpirV
{
	[Flags]
	public enum ImageOperands : uint
	{
		None = 0,
		Bias = 1,
		Lod = 2,
		Grad = 4,
		ConstOffset = 8,
		Offset = 16,
		ConstOffsets = 32,
		Sample = 64,
		MinLod = 128,
	}
	public class ImageOperandsParameterFactory : ParameterFactory
	{
		public class BiasParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class LodParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class GradParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), new IdRef(), };
		}

		public class ConstOffsetParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class OffsetParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class ConstOffsetsParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class SampleParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class MinLodParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public override Parameter CreateParameter(object value)
		{
			switch ((ImageOperands)value)
			{
				case ImageOperands.Bias:
					return new BiasParameter();
				case ImageOperands.Lod:
					return new LodParameter();
				case ImageOperands.Grad:
					return new GradParameter();
				case ImageOperands.ConstOffset:
					return new ConstOffsetParameter();
				case ImageOperands.Offset:
					return new OffsetParameter();
				case ImageOperands.ConstOffsets:
					return new ConstOffsetsParameter();
				case ImageOperands.Sample:
					return new SampleParameter();
				case ImageOperands.MinLod:
					return new MinLodParameter();
			}

			return null;
		}
	}
	[Flags]
	public enum FPFastMathMode : uint
	{
		None = 0,
		NotNaN = 1,
		NotInf = 2,
		NSZ = 4,
		AllowRecip = 8,
		Fast = 16,
	}
	public class FPFastMathModeParameterFactory : ParameterFactory
	{
	}
	[Flags]
	public enum SelectionControl : uint
	{
		None = 0,
		Flatten = 1,
		DontFlatten = 2,
	}
	public class SelectionControlParameterFactory : ParameterFactory
	{
	}
	[Flags]
	public enum LoopControl : uint
	{
		None = 0,
		Unroll = 1,
		DontUnroll = 2,
		DependencyInfinite = 4,
		DependencyLength = 8,
	}
	public class LoopControlParameterFactory : ParameterFactory
	{
		public class DependencyLengthParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public override Parameter CreateParameter(object value)
		{
			switch ((LoopControl)value)
			{
				case LoopControl.DependencyLength:
					return new DependencyLengthParameter();
			}

			return null;
		}
	}
	[Flags]
	public enum FunctionControl : uint
	{
		None = 0,
		Inline = 1,
		DontInline = 2,
		Pure = 4,
		Const = 8,
	}
	public class FunctionControlParameterFactory : ParameterFactory
	{
	}
	[Flags]
	public enum MemorySemantics : uint
	{
		Relaxed = 0,
		None = 0,
		Acquire = 2,
		Release = 4,
		AcquireRelease = 8,
		SequentiallyConsistent = 16,
		UniformMemory = 64,
		SubgroupMemory = 128,
		WorkgroupMemory = 256,
		CrossWorkgroupMemory = 512,
		AtomicCounterMemory = 1024,
		ImageMemory = 2048,
	}
	public class MemorySemanticsParameterFactory : ParameterFactory
	{
	}
	[Flags]
	public enum MemoryAccess : uint
	{
		None = 0,
		Volatile = 1,
		Aligned = 2,
		Nontemporal = 4,
	}
	public class MemoryAccessParameterFactory : ParameterFactory
	{
		public class AlignedParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public override Parameter CreateParameter(object value)
		{
			switch ((MemoryAccess)value)
			{
				case MemoryAccess.Aligned:
					return new AlignedParameter();
			}

			return null;
		}
	}
	[Flags]
	public enum KernelProfilingInfo : uint
	{
		None = 0,
		CmdExecTime = 1,
	}
	public class KernelProfilingInfoParameterFactory : ParameterFactory
	{
	}
	public enum SourceLanguage : uint
	{
		Unknown = 0,
		ESSL = 1,
		GLSL = 2,
		OpenCL_C = 3,
		OpenCL_CPP = 4,
		HLSL = 5,
	}
	public class SourceLanguageParameterFactory : ParameterFactory
	{
	}
	public enum ExecutionModel : uint
	{
		Vertex = 0,
		TessellationControl = 1,
		TessellationEvaluation = 2,
		Geometry = 3,
		Fragment = 4,
		GLCompute = 5,
		Kernel = 6,
	}
	public class ExecutionModelParameterFactory : ParameterFactory
	{
	}
	public enum AddressingModel : uint
	{
		Logical = 0,
		Physical32 = 1,
		Physical64 = 2,
	}
	public class AddressingModelParameterFactory : ParameterFactory
	{
	}
	public enum MemoryModel : uint
	{
		Simple = 0,
		GLSL450 = 1,
		OpenCL = 2,
	}
	public class MemoryModelParameterFactory : ParameterFactory
	{
	}
	public enum ExecutionMode : uint
	{
		Invocations = 0,
		SpacingEqual = 1,
		SpacingFractionalEven = 2,
		SpacingFractionalOdd = 3,
		VertexOrderCw = 4,
		VertexOrderCcw = 5,
		PixelCenterInteger = 6,
		OriginUpperLeft = 7,
		OriginLowerLeft = 8,
		EarlyFragmentTests = 9,
		PointMode = 10,
		Xfb = 11,
		DepthReplacing = 12,
		DepthGreater = 14,
		DepthLess = 15,
		DepthUnchanged = 16,
		LocalSize = 17,
		LocalSizeHint = 18,
		InputPoints = 19,
		InputLines = 20,
		InputLinesAdjacency = 21,
		Triangles = 22,
		InputTrianglesAdjacency = 23,
		Quads = 24,
		Isolines = 25,
		OutputVertices = 26,
		OutputPoints = 27,
		OutputLineStrip = 28,
		OutputTriangleStrip = 29,
		VecTypeHint = 30,
		ContractionOff = 31,
		Initializer = 33,
		Finalizer = 34,
		SubgroupSize = 35,
		SubgroupsPerWorkgroup = 36,
		SubgroupsPerWorkgroupId = 37,
		LocalSizeId = 38,
		LocalSizeHintId = 39,
		PostDepthCoverage = 4446,
		StencilRefReplacingEXT = 5027,
	}
	public class ExecutionModeParameterFactory : ParameterFactory
	{
		public class InvocationsParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class LocalSizeParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
		}

		public class LocalSizeHintParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), new LiteralInteger(), new LiteralInteger(), };
		}

		public class OutputVerticesParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class VecTypeHintParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class SubgroupSizeParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class SubgroupsPerWorkgroupParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class SubgroupsPerWorkgroupIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class LocalSizeIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), new IdRef(), new IdRef(), };
		}

		public class LocalSizeHintIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public override Parameter CreateParameter(object value)
		{
			switch ((ExecutionMode)value)
			{
				case ExecutionMode.Invocations:
					return new InvocationsParameter();
				case ExecutionMode.LocalSize:
					return new LocalSizeParameter();
				case ExecutionMode.LocalSizeHint:
					return new LocalSizeHintParameter();
				case ExecutionMode.OutputVertices:
					return new OutputVerticesParameter();
				case ExecutionMode.VecTypeHint:
					return new VecTypeHintParameter();
				case ExecutionMode.SubgroupSize:
					return new SubgroupSizeParameter();
				case ExecutionMode.SubgroupsPerWorkgroup:
					return new SubgroupsPerWorkgroupParameter();
				case ExecutionMode.SubgroupsPerWorkgroupId:
					return new SubgroupsPerWorkgroupIdParameter();
				case ExecutionMode.LocalSizeId:
					return new LocalSizeIdParameter();
				case ExecutionMode.LocalSizeHintId:
					return new LocalSizeHintIdParameter();
			}

			return null;
		}
	}
	public enum StorageClass : uint
	{
		UniformConstant = 0,
		Input = 1,
		Uniform = 2,
		Output = 3,
		Workgroup = 4,
		CrossWorkgroup = 5,
		Private = 6,
		Function = 7,
		Generic = 8,
		PushConstant = 9,
		AtomicCounter = 10,
		Image = 11,
		StorageBuffer = 12,
	}
	public class StorageClassParameterFactory : ParameterFactory
	{
	}
	public enum Dim : uint
	{
		Dim1D = 0,
		Dim2D = 1,
		Dim3D = 2,
		Cube = 3,
		Rect = 4,
		Buffer = 5,
		SubpassData = 6,
	}
	public class DimParameterFactory : ParameterFactory
	{
	}
	public enum SamplerAddressingMode : uint
	{
		None = 0,
		ClampToEdge = 1,
		Clamp = 2,
		Repeat = 3,
		RepeatMirrored = 4,
	}
	public class SamplerAddressingModeParameterFactory : ParameterFactory
	{
	}
	public enum SamplerFilterMode : uint
	{
		Nearest = 0,
		Linear = 1,
	}
	public class SamplerFilterModeParameterFactory : ParameterFactory
	{
	}
	public enum ImageFormat : uint
	{
		Unknown = 0,
		Rgba32f = 1,
		Rgba16f = 2,
		R32f = 3,
		Rgba8 = 4,
		Rgba8Snorm = 5,
		Rg32f = 6,
		Rg16f = 7,
		R11fG11fB10f = 8,
		R16f = 9,
		Rgba16 = 10,
		Rgb10A2 = 11,
		Rg16 = 12,
		Rg8 = 13,
		R16 = 14,
		R8 = 15,
		Rgba16Snorm = 16,
		Rg16Snorm = 17,
		Rg8Snorm = 18,
		R16Snorm = 19,
		R8Snorm = 20,
		Rgba32i = 21,
		Rgba16i = 22,
		Rgba8i = 23,
		R32i = 24,
		Rg32i = 25,
		Rg16i = 26,
		Rg8i = 27,
		R16i = 28,
		R8i = 29,
		Rgba32ui = 30,
		Rgba16ui = 31,
		Rgba8ui = 32,
		R32ui = 33,
		Rgb10a2ui = 34,
		Rg32ui = 35,
		Rg16ui = 36,
		Rg8ui = 37,
		R16ui = 38,
		R8ui = 39,
	}
	public class ImageFormatParameterFactory : ParameterFactory
	{
	}
	public enum ImageChannelOrder : uint
	{
		R = 0,
		A = 1,
		RG = 2,
		RA = 3,
		RGB = 4,
		RGBA = 5,
		BGRA = 6,
		ARGB = 7,
		Intensity = 8,
		Luminance = 9,
		Rx = 10,
		RGx = 11,
		RGBx = 12,
		Depth = 13,
		DepthStencil = 14,
		sRGB = 15,
		sRGBx = 16,
		sRGBA = 17,
		sBGRA = 18,
		ABGR = 19,
	}
	public class ImageChannelOrderParameterFactory : ParameterFactory
	{
	}
	public enum ImageChannelDataType : uint
	{
		SnormInt8 = 0,
		SnormInt16 = 1,
		UnormInt8 = 2,
		UnormInt16 = 3,
		UnormShort565 = 4,
		UnormShort555 = 5,
		UnormInt101010 = 6,
		SignedInt8 = 7,
		SignedInt16 = 8,
		SignedInt32 = 9,
		UnsignedInt8 = 10,
		UnsignedInt16 = 11,
		UnsignedInt32 = 12,
		HalfFloat = 13,
		Float = 14,
		UnormInt24 = 15,
		UnormInt101010_2 = 16,
	}
	public class ImageChannelDataTypeParameterFactory : ParameterFactory
	{
	}
	public enum FPRoundingMode : uint
	{
		RTE = 0,
		RTZ = 1,
		RTP = 2,
		RTN = 3,
	}
	public class FPRoundingModeParameterFactory : ParameterFactory
	{
	}
	public enum LinkageType : uint
	{
		Export = 0,
		Import = 1,
	}
	public class LinkageTypeParameterFactory : ParameterFactory
	{
	}
	public enum AccessQualifier : uint
	{
		ReadOnly = 0,
		WriteOnly = 1,
		ReadWrite = 2,
	}
	public class AccessQualifierParameterFactory : ParameterFactory
	{
	}
	public enum FunctionParameterAttribute : uint
	{
		Zext = 0,
		Sext = 1,
		ByVal = 2,
		Sret = 3,
		NoAlias = 4,
		NoCapture = 5,
		NoWrite = 6,
		NoReadWrite = 7,
	}
	public class FunctionParameterAttributeParameterFactory : ParameterFactory
	{
	}
	public enum Decoration : uint
	{
		RelaxedPrecision = 0,
		SpecId = 1,
		Block = 2,
		BufferBlock = 3,
		RowMajor = 4,
		ColMajor = 5,
		ArrayStride = 6,
		MatrixStride = 7,
		GLSLShared = 8,
		GLSLPacked = 9,
		CPacked = 10,
		BuiltIn = 11,
		NoPerspective = 13,
		Flat = 14,
		Patch = 15,
		Centroid = 16,
		Sample = 17,
		Invariant = 18,
		Restrict = 19,
		Aliased = 20,
		Volatile = 21,
		Constant = 22,
		Coherent = 23,
		NonWritable = 24,
		NonReadable = 25,
		Uniform = 26,
		SaturatedConversion = 28,
		Stream = 29,
		Location = 30,
		Component = 31,
		Index = 32,
		Binding = 33,
		DescriptorSet = 34,
		Offset = 35,
		XfbBuffer = 36,
		XfbStride = 37,
		FuncParamAttr = 38,
		FPRoundingMode = 39,
		FPFastMathMode = 40,
		LinkageAttributes = 41,
		NoContraction = 42,
		InputAttachmentIndex = 43,
		Alignment = 44,
		MaxByteOffset = 45,
		AlignmentId = 46,
		MaxByteOffsetId = 47,
		ExplicitInterpAMD = 4999,
		OverrideCoverageNV = 5248,
		PassthroughNV = 5250,
		ViewportRelativeNV = 5252,
		SecondaryViewportRelativeNV = 5256,
	}
	public class DecorationParameterFactory : ParameterFactory
	{
		public class SpecIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class ArrayStrideParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class MatrixStrideParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class BuiltInParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new EnumType<BuiltIn>(), };
		}

		public class StreamParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class LocationParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class ComponentParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class IndexParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class BindingParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class DescriptorSetParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class OffsetParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class XfbBufferParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class XfbStrideParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class FuncParamAttrParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new EnumType<FunctionParameterAttribute>(), };
		}

		public class FPRoundingModeParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new EnumType<FPRoundingMode>(), };
		}

		public class FPFastMathModeParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new EnumType<FPFastMathMode>(), };
		}

		public class LinkageAttributesParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralString(), new EnumType<LinkageType>(), };
		}

		public class InputAttachmentIndexParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class AlignmentParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class MaxByteOffsetParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public class AlignmentIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class MaxByteOffsetIdParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new IdRef(), };
		}

		public class SecondaryViewportRelativeNVParameter : Parameter
		{
			public override IReadOnlyList<OperandType> OperandTypes
			{
				get => operandTypes_;
			}

			private static readonly List<OperandType> operandTypes_ = new List<OperandType>()
		{new LiteralInteger(), };
		}

		public override Parameter CreateParameter(object value)
		{
			switch ((Decoration)value)
			{
				case Decoration.SpecId:
					return new SpecIdParameter();
				case Decoration.ArrayStride:
					return new ArrayStrideParameter();
				case Decoration.MatrixStride:
					return new MatrixStrideParameter();
				case Decoration.BuiltIn:
					return new BuiltInParameter();
				case Decoration.Stream:
					return new StreamParameter();
				case Decoration.Location:
					return new LocationParameter();
				case Decoration.Component:
					return new ComponentParameter();
				case Decoration.Index:
					return new IndexParameter();
				case Decoration.Binding:
					return new BindingParameter();
				case Decoration.DescriptorSet:
					return new DescriptorSetParameter();
				case Decoration.Offset:
					return new OffsetParameter();
				case Decoration.XfbBuffer:
					return new XfbBufferParameter();
				case Decoration.XfbStride:
					return new XfbStrideParameter();
				case Decoration.FuncParamAttr:
					return new FuncParamAttrParameter();
				case Decoration.FPRoundingMode:
					return new FPRoundingModeParameter();
				case Decoration.FPFastMathMode:
					return new FPFastMathModeParameter();
				case Decoration.LinkageAttributes:
					return new LinkageAttributesParameter();
				case Decoration.InputAttachmentIndex:
					return new InputAttachmentIndexParameter();
				case Decoration.Alignment:
					return new AlignmentParameter();
				case Decoration.MaxByteOffset:
					return new MaxByteOffsetParameter();
				case Decoration.AlignmentId:
					return new AlignmentIdParameter();
				case Decoration.MaxByteOffsetId:
					return new MaxByteOffsetIdParameter();
				case Decoration.SecondaryViewportRelativeNV:
					return new SecondaryViewportRelativeNVParameter();
			}

			return null;
		}
	}
	public enum BuiltIn : uint
	{
		Position = 0,
		PointSize = 1,
		ClipDistance = 3,
		CullDistance = 4,
		VertexId = 5,
		InstanceId = 6,
		PrimitiveId = 7,
		InvocationId = 8,
		Layer = 9,
		ViewportIndex = 10,
		TessLevelOuter = 11,
		TessLevelInner = 12,
		TessCoord = 13,
		PatchVertices = 14,
		FragCoord = 15,
		PointCoord = 16,
		FrontFacing = 17,
		SampleId = 18,
		SamplePosition = 19,
		SampleMask = 20,
		FragDepth = 22,
		HelperInvocation = 23,
		NumWorkgroups = 24,
		WorkgroupSize = 25,
		WorkgroupId = 26,
		LocalInvocationId = 27,
		GlobalInvocationId = 28,
		LocalInvocationIndex = 29,
		WorkDim = 30,
		GlobalSize = 31,
		EnqueuedWorkgroupSize = 32,
		GlobalOffset = 33,
		GlobalLinearId = 34,
		SubgroupSize = 36,
		SubgroupMaxSize = 37,
		NumSubgroups = 38,
		NumEnqueuedSubgroups = 39,
		SubgroupId = 40,
		SubgroupLocalInvocationId = 41,
		VertexIndex = 42,
		InstanceIndex = 43,
		SubgroupEqMaskKHR = 4416,
		SubgroupGeMaskKHR = 4417,
		SubgroupGtMaskKHR = 4418,
		SubgroupLeMaskKHR = 4419,
		SubgroupLtMaskKHR = 4420,
		BaseVertex = 4424,
		BaseInstance = 4425,
		DrawIndex = 4426,
		DeviceIndex = 4438,
		ViewIndex = 4440,
		BaryCoordNoPerspAMD = 4992,
		BaryCoordNoPerspCentroidAMD = 4993,
		BaryCoordNoPerspSampleAMD = 4994,
		BaryCoordSmoothAMD = 4995,
		BaryCoordSmoothCentroidAMD = 4996,
		BaryCoordSmoothSampleAMD = 4997,
		BaryCoordPullModelAMD = 4998,
		FragStencilRefEXT = 5014,
		ViewportMaskNV = 5253,
		SecondaryPositionNV = 5257,
		SecondaryViewportMaskNV = 5258,
		PositionPerViewNV = 5261,
		ViewportMaskPerViewNV = 5262,
	}
	public class BuiltInParameterFactory : ParameterFactory
	{
	}
	public enum Scope : uint
	{
		CrossDevice = 0,
		Device = 1,
		Workgroup = 2,
		Subgroup = 3,
		Invocation = 4,
	}
	public class ScopeParameterFactory : ParameterFactory
	{
	}
	public enum GroupOperation : uint
	{
		Reduce = 0,
		InclusiveScan = 1,
		ExclusiveScan = 2,
	}
	public class GroupOperationParameterFactory : ParameterFactory
	{
	}
	public enum KernelEnqueueFlags : uint
	{
		NoWait = 0,
		WaitKernel = 1,
		WaitWorkGroup = 2,
	}
	public class KernelEnqueueFlagsParameterFactory : ParameterFactory
	{
	}
	public enum Capability : uint
	{
		Matrix = 0,
		Shader = 1,
		Geometry = 2,
		Tessellation = 3,
		Addresses = 4,
		Linkage = 5,
		Kernel = 6,
		Vector16 = 7,
		Float16Buffer = 8,
		Float16 = 9,
		Float64 = 10,
		Int64 = 11,
		Int64Atomics = 12,
		ImageBasic = 13,
		ImageReadWrite = 14,
		ImageMipmap = 15,
		Pipes = 17,
		Groups = 18,
		DeviceEnqueue = 19,
		LiteralSampler = 20,
		AtomicStorage = 21,
		Int16 = 22,
		TessellationPointSize = 23,
		GeometryPointSize = 24,
		ImageGatherExtended = 25,
		StorageImageMultisample = 27,
		UniformBufferArrayDynamicIndexing = 28,
		SampledImageArrayDynamicIndexing = 29,
		StorageBufferArrayDynamicIndexing = 30,
		StorageImageArrayDynamicIndexing = 31,
		ClipDistance = 32,
		CullDistance = 33,
		ImageCubeArray = 34,
		SampleRateShading = 35,
		ImageRect = 36,
		SampledRect = 37,
		GenericPointer = 38,
		Int8 = 39,
		InputAttachment = 40,
		SparseResidency = 41,
		MinLod = 42,
		Sampled1D = 43,
		Image1D = 44,
		SampledCubeArray = 45,
		SampledBuffer = 46,
		ImageBuffer = 47,
		ImageMSArray = 48,
		StorageImageExtendedFormats = 49,
		ImageQuery = 50,
		DerivativeControl = 51,
		InterpolationFunction = 52,
		TransformFeedback = 53,
		GeometryStreams = 54,
		StorageImageReadWithoutFormat = 55,
		StorageImageWriteWithoutFormat = 56,
		MultiViewport = 57,
		SubgroupDispatch = 58,
		NamedBarrier = 59,
		PipeStorage = 60,
		SubgroupBallotKHR = 4423,
		DrawParameters = 4427,
		SubgroupVoteKHR = 4431,
		StorageBuffer16BitAccess = 4433,
		StorageUniformBufferBlock16 = 4433,
		UniformAndStorageBuffer16BitAccess = 4434,
		StorageUniform16 = 4434,
		StoragePushConstant16 = 4435,
		StorageInputOutput16 = 4436,
		DeviceGroup = 4437,
		MultiView = 4439,
		VariablePointersStorageBuffer = 4441,
		VariablePointers = 4442,
		AtomicStorageOps = 4445,
		SampleMaskPostDepthCoverage = 4447,
		ImageGatherBiasLodAMD = 5009,
		FragmentMaskAMD = 5010,
		StencilExportEXT = 5013,
		ImageReadWriteLodAMD = 5015,
		SampleMaskOverrideCoverageNV = 5249,
		GeometryShaderPassthroughNV = 5251,
		ShaderViewportIndexLayerEXT = 5254,
		ShaderViewportIndexLayerNV = 5254,
		ShaderViewportMaskNV = 5255,
		ShaderStereoViewNV = 5259,
		PerViewAttributesNV = 5260,
		SubgroupShuffleINTEL = 5568,
		SubgroupBufferBlockIOINTEL = 5569,
		SubgroupImageBlockIOINTEL = 5570,
	}
	public class CapabilityParameterFactory : ParameterFactory
	{
	}
	public class OpNop : Instruction
	{
		public OpNop() : base("OpNop")
		{
		}
	}
	public class OpUndef : Instruction
	{
		public OpUndef() : base("OpUndef", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSourceContinued : Instruction
	{
		public OpSourceContinued() : base("OpSourceContinued", new List<Operand>()
	{new Operand(new LiteralString(), "Continued Source", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSource : Instruction
	{
		public OpSource() : base("OpSource", new List<Operand>()
	{new Operand(new EnumType<SourceLanguage, SourceLanguageParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Version", OperandQuantifier.Default), new Operand(new IdRef(), "File", OperandQuantifier.Optional), new Operand(new LiteralString(), "Source", OperandQuantifier.Optional), })
		{
		}
	}
	public class OpSourceExtension : Instruction
	{
		public OpSourceExtension() : base("OpSourceExtension", new List<Operand>()
	{new Operand(new LiteralString(), "Extension", OperandQuantifier.Default), })
		{
		}
	}
	public class OpName : Instruction
	{
		public OpName() : base("OpName", new List<Operand>()
	{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMemberName : Instruction
	{
		public OpMemberName() : base("OpMemberName", new List<Operand>()
	{new Operand(new IdRef(), "Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
		{
		}
	}
	public class OpString : Instruction
	{
		public OpString() : base("OpString", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "String", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLine : Instruction
	{
		public OpLine() : base("OpLine", new List<Operand>()
	{new Operand(new IdRef(), "File", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Line", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column", OperandQuantifier.Default), })
		{
		}
	}
	public class OpExtension : Instruction
	{
		public OpExtension() : base("OpExtension", new List<Operand>()
	{new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
		{
		}
	}
	public class OpExtInstImport : Instruction
	{
		public OpExtInstImport() : base("OpExtInstImport", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), })
		{
		}
	}
	public class OpExtInst : Instruction
	{
		public OpExtInst() : base("OpExtInst", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Set", OperandQuantifier.Default), new Operand(new LiteralExtInstInteger(), "Instruction", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1, +Operand 2, +...", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpMemoryModel : Instruction
	{
		public OpMemoryModel() : base("OpMemoryModel", new List<Operand>()
	{new Operand(new EnumType<AddressingModel, AddressingModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<MemoryModel, MemoryModelParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpEntryPoint : Instruction
	{
		public OpEntryPoint() : base("OpEntryPoint", new List<Operand>()
	{new Operand(new EnumType<ExecutionModel, ExecutionModelParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new LiteralString(), "Name", OperandQuantifier.Default), new Operand(new IdRef(), "Interface", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpExecutionMode : Instruction
	{
		public OpExecutionMode() : base("OpExecutionMode", new List<Operand>()
	{new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCapability : Instruction
	{
		public OpCapability() : base("OpCapability", new List<Operand>()
	{new Operand(new EnumType<Capability, CapabilityParameterFactory>(), "Capability", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeVoid : Instruction
	{
		public OpTypeVoid() : base("OpTypeVoid", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeBool : Instruction
	{
		public OpTypeBool() : base("OpTypeBool", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeInt : Instruction
	{
		public OpTypeInt() : base("OpTypeInt", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Signedness", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeFloat : Instruction
	{
		public OpTypeFloat() : base("OpTypeFloat", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Width", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeVector : Instruction
	{
		public OpTypeVector() : base("OpTypeVector", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Component Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Component Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeMatrix : Instruction
	{
		public OpTypeMatrix() : base("OpTypeMatrix", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Column Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Column Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeImage : Instruction
	{
		public OpTypeImage() : base("OpTypeImage", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Type", OperandQuantifier.Default), new Operand(new EnumType<Dim, DimParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Depth", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Arrayed", OperandQuantifier.Default), new Operand(new LiteralInteger(), "MS", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Sampled", OperandQuantifier.Default), new Operand(new EnumType<ImageFormat, ImageFormatParameterFactory>(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpTypeSampler : Instruction
	{
		public OpTypeSampler() : base("OpTypeSampler", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeSampledImage : Instruction
	{
		public OpTypeSampledImage() : base("OpTypeSampledImage", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image Type", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeArray : Instruction
	{
		public OpTypeArray() : base("OpTypeArray", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), new Operand(new IdRef(), "Length", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeRuntimeArray : Instruction
	{
		public OpTypeRuntimeArray() : base("OpTypeRuntimeArray", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Element Type", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeStruct : Instruction
	{
		public OpTypeStruct() : base("OpTypeStruct", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Member 0 type, +member 1 type, +...", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpTypeOpaque : Instruction
	{
		public OpTypeOpaque() : base("OpTypeOpaque", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralString(), "The name of the opaque type.", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypePointer : Instruction
	{
		public OpTypePointer() : base("OpTypePointer", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Type", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeFunction : Instruction
	{
		public OpTypeFunction() : base("OpTypeFunction", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Return Type", OperandQuantifier.Default), new Operand(new IdRef(), "Parameter 0 Type, +Parameter 1 Type, +...", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpTypeEvent : Instruction
	{
		public OpTypeEvent() : base("OpTypeEvent", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeDeviceEvent : Instruction
	{
		public OpTypeDeviceEvent() : base("OpTypeDeviceEvent", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeReserveId : Instruction
	{
		public OpTypeReserveId() : base("OpTypeReserveId", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeQueue : Instruction
	{
		public OpTypeQueue() : base("OpTypeQueue", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypePipe : Instruction
	{
		public OpTypePipe() : base("OpTypePipe", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<AccessQualifier, AccessQualifierParameterFactory>(), "Qualifier", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeForwardPointer : Instruction
	{
		public OpTypeForwardPointer() : base("OpTypeForwardPointer", new List<Operand>()
	{new Operand(new IdRef(), "Pointer Type", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstantTrue : Instruction
	{
		public OpConstantTrue() : base("OpConstantTrue", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstantFalse : Instruction
	{
		public OpConstantFalse() : base("OpConstantFalse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstant : Instruction
	{
		public OpConstant() : base("OpConstant", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstantComposite : Instruction
	{
		public OpConstantComposite() : base("OpConstantComposite", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpConstantSampler : Instruction
	{
		public OpConstantSampler() : base("OpConstantSampler", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<SamplerAddressingMode, SamplerAddressingModeParameterFactory>(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Param", OperandQuantifier.Default), new Operand(new EnumType<SamplerFilterMode, SamplerFilterModeParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstantNull : Instruction
	{
		public OpConstantNull() : base("OpConstantNull", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSpecConstantTrue : Instruction
	{
		public OpSpecConstantTrue() : base("OpSpecConstantTrue", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSpecConstantFalse : Instruction
	{
		public OpSpecConstantFalse() : base("OpSpecConstantFalse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSpecConstant : Instruction
	{
		public OpSpecConstant() : base("OpSpecConstant", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralContextDependentNumber(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSpecConstantComposite : Instruction
	{
		public OpSpecConstantComposite() : base("OpSpecConstantComposite", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpSpecConstantOp : Instruction
	{
		public OpSpecConstantOp() : base("OpSpecConstantOp", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralSpecConstantOpInteger(), "Opcode", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFunction : Instruction
	{
		public OpFunction() : base("OpFunction", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<FunctionControl, FunctionControlParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function Type", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFunctionParameter : Instruction
	{
		public OpFunctionParameter() : base("OpFunctionParameter", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpFunctionEnd : Instruction
	{
		public OpFunctionEnd() : base("OpFunctionEnd")
		{
		}
	}
	public class OpFunctionCall : Instruction
	{
		public OpFunctionCall() : base("OpFunctionCall", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Function", OperandQuantifier.Default), new Operand(new IdRef(), "Argument 0, +Argument 1, +...", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpVariable : Instruction
	{
		public OpVariable() : base("OpVariable", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Initializer", OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageTexelPointer : Instruction
	{
		public OpImageTexelPointer() : base("OpImageTexelPointer", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Sample", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLoad : Instruction
	{
		public OpLoad() : base("OpLoad", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpStore : Instruction
	{
		public OpStore() : base("OpStore", new List<Operand>()
	{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpCopyMemory : Instruction
	{
		public OpCopyMemory() : base("OpCopyMemory", new List<Operand>()
	{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpCopyMemorySized : Instruction
	{
		public OpCopyMemorySized() : base("OpCopyMemorySized", new List<Operand>()
	{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Size", OperandQuantifier.Default), new Operand(new EnumType<MemoryAccess, MemoryAccessParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpAccessChain : Instruction
	{
		public OpAccessChain() : base("OpAccessChain", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpInBoundsAccessChain : Instruction
	{
		public OpInBoundsAccessChain() : base("OpInBoundsAccessChain", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpPtrAccessChain : Instruction
	{
		public OpPtrAccessChain() : base("OpPtrAccessChain", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpArrayLength : Instruction
	{
		public OpArrayLength() : base("OpArrayLength", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Structure", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Array member", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGenericPtrMemSemantics : Instruction
	{
		public OpGenericPtrMemSemantics() : base("OpGenericPtrMemSemantics", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
		{
		}
	}
	public class OpInBoundsPtrAccessChain : Instruction
	{
		public OpInBoundsPtrAccessChain() : base("OpInBoundsPtrAccessChain", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Element", OperandQuantifier.Default), new Operand(new IdRef(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpDecorate : Instruction
	{
		public OpDecorate() : base("OpDecorate", new List<Operand>()
	{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpMemberDecorate : Instruction
	{
		public OpMemberDecorate() : base("OpMemberDecorate", new List<Operand>()
	{new Operand(new IdRef(), "Structure Type", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Member", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpDecorationGroup : Instruction
	{
		public OpDecorationGroup() : base("OpDecorationGroup", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupDecorate : Instruction
	{
		public OpGroupDecorate() : base("OpGroupDecorate", new List<Operand>()
	{new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new IdRef(), "Targets", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpGroupMemberDecorate : Instruction
	{
		public OpGroupMemberDecorate() : base("OpGroupMemberDecorate", new List<Operand>()
	{new Operand(new IdRef(), "Decoration Group", OperandQuantifier.Default), new Operand(new PairIdRefLiteralInteger(), "Targets", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpVectorExtractDynamic : Instruction
	{
		public OpVectorExtractDynamic() : base("OpVectorExtractDynamic", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
		{
		}
	}
	public class OpVectorInsertDynamic : Instruction
	{
		public OpVectorInsertDynamic() : base("OpVectorInsertDynamic", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
		{
		}
	}
	public class OpVectorShuffle : Instruction
	{
		public OpVectorShuffle() : base("OpVectorShuffle", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Components", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpCompositeConstruct : Instruction
	{
		public OpCompositeConstruct() : base("OpCompositeConstruct", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Constituents", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpCompositeExtract : Instruction
	{
		public OpCompositeExtract() : base("OpCompositeExtract", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpCompositeInsert : Instruction
	{
		public OpCompositeInsert() : base("OpCompositeInsert", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Object", OperandQuantifier.Default), new Operand(new IdRef(), "Composite", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Indexes", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpCopyObject : Instruction
	{
		public OpCopyObject() : base("OpCopyObject", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTranspose : Instruction
	{
		public OpTranspose() : base("OpTranspose", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSampledImage : Instruction
	{
		public OpSampledImage() : base("OpSampledImage", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Sampler", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSampleImplicitLod : Instruction
	{
		public OpImageSampleImplicitLod() : base("OpImageSampleImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSampleExplicitLod : Instruction
	{
		public OpImageSampleExplicitLod() : base("OpImageSampleExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSampleDrefImplicitLod : Instruction
	{
		public OpImageSampleDrefImplicitLod() : base("OpImageSampleDrefImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSampleDrefExplicitLod : Instruction
	{
		public OpImageSampleDrefExplicitLod() : base("OpImageSampleDrefExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSampleProjImplicitLod : Instruction
	{
		public OpImageSampleProjImplicitLod() : base("OpImageSampleProjImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSampleProjExplicitLod : Instruction
	{
		public OpImageSampleProjExplicitLod() : base("OpImageSampleProjExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSampleProjDrefImplicitLod : Instruction
	{
		public OpImageSampleProjDrefImplicitLod() : base("OpImageSampleProjDrefImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSampleProjDrefExplicitLod : Instruction
	{
		public OpImageSampleProjDrefExplicitLod() : base("OpImageSampleProjDrefExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageFetch : Instruction
	{
		public OpImageFetch() : base("OpImageFetch", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageGather : Instruction
	{
		public OpImageGather() : base("OpImageGather", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageDrefGather : Instruction
	{
		public OpImageDrefGather() : base("OpImageDrefGather", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageRead : Instruction
	{
		public OpImageRead() : base("OpImageRead", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageWrite : Instruction
	{
		public OpImageWrite() : base("OpImageWrite", new List<Operand>()
	{new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Texel", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImage : Instruction
	{
		public OpImage() : base("OpImage", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQueryFormat : Instruction
	{
		public OpImageQueryFormat() : base("OpImageQueryFormat", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQueryOrder : Instruction
	{
		public OpImageQueryOrder() : base("OpImageQueryOrder", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQuerySizeLod : Instruction
	{
		public OpImageQuerySizeLod() : base("OpImageQuerySizeLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Level of Detail", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQuerySize : Instruction
	{
		public OpImageQuerySize() : base("OpImageQuerySize", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQueryLod : Instruction
	{
		public OpImageQueryLod() : base("OpImageQueryLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQueryLevels : Instruction
	{
		public OpImageQueryLevels() : base("OpImageQueryLevels", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageQuerySamples : Instruction
	{
		public OpImageQuerySamples() : base("OpImageQuerySamples", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertFToU : Instruction
	{
		public OpConvertFToU() : base("OpConvertFToU", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertFToS : Instruction
	{
		public OpConvertFToS() : base("OpConvertFToS", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertSToF : Instruction
	{
		public OpConvertSToF() : base("OpConvertSToF", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertUToF : Instruction
	{
		public OpConvertUToF() : base("OpConvertUToF", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUConvert : Instruction
	{
		public OpUConvert() : base("OpUConvert", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSConvert : Instruction
	{
		public OpSConvert() : base("OpSConvert", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFConvert : Instruction
	{
		public OpFConvert() : base("OpFConvert", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Float Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpQuantizeToF16 : Instruction
	{
		public OpQuantizeToF16() : base("OpQuantizeToF16", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertPtrToU : Instruction
	{
		public OpConvertPtrToU() : base("OpConvertPtrToU", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSatConvertSToU : Instruction
	{
		public OpSatConvertSToU() : base("OpSatConvertSToU", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Signed Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSatConvertUToS : Instruction
	{
		public OpSatConvertUToS() : base("OpSatConvertUToS", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Unsigned Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpConvertUToPtr : Instruction
	{
		public OpConvertUToPtr() : base("OpConvertUToPtr", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Integer Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpPtrCastToGeneric : Instruction
	{
		public OpPtrCastToGeneric() : base("OpPtrCastToGeneric", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGenericCastToPtr : Instruction
	{
		public OpGenericCastToPtr() : base("OpGenericCastToPtr", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGenericCastToPtrExplicit : Instruction
	{
		public OpGenericCastToPtrExplicit() : base("OpGenericCastToPtrExplicit", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new EnumType<StorageClass, StorageClassParameterFactory>(), "Storage", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitcast : Instruction
	{
		public OpBitcast() : base("OpBitcast", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSNegate : Instruction
	{
		public OpSNegate() : base("OpSNegate", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFNegate : Instruction
	{
		public OpFNegate() : base("OpFNegate", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIAdd : Instruction
	{
		public OpIAdd() : base("OpIAdd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFAdd : Instruction
	{
		public OpFAdd() : base("OpFAdd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpISub : Instruction
	{
		public OpISub() : base("OpISub", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFSub : Instruction
	{
		public OpFSub() : base("OpFSub", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIMul : Instruction
	{
		public OpIMul() : base("OpIMul", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFMul : Instruction
	{
		public OpFMul() : base("OpFMul", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUDiv : Instruction
	{
		public OpUDiv() : base("OpUDiv", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSDiv : Instruction
	{
		public OpSDiv() : base("OpSDiv", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFDiv : Instruction
	{
		public OpFDiv() : base("OpFDiv", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUMod : Instruction
	{
		public OpUMod() : base("OpUMod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSRem : Instruction
	{
		public OpSRem() : base("OpSRem", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSMod : Instruction
	{
		public OpSMod() : base("OpSMod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFRem : Instruction
	{
		public OpFRem() : base("OpFRem", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFMod : Instruction
	{
		public OpFMod() : base("OpFMod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpVectorTimesScalar : Instruction
	{
		public OpVectorTimesScalar() : base("OpVectorTimesScalar", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMatrixTimesScalar : Instruction
	{
		public OpMatrixTimesScalar() : base("OpMatrixTimesScalar", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Scalar", OperandQuantifier.Default), })
		{
		}
	}
	public class OpVectorTimesMatrix : Instruction
	{
		public OpVectorTimesMatrix() : base("OpVectorTimesMatrix", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMatrixTimesVector : Instruction
	{
		public OpMatrixTimesVector() : base("OpMatrixTimesVector", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Matrix", OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMatrixTimesMatrix : Instruction
	{
		public OpMatrixTimesMatrix() : base("OpMatrixTimesMatrix", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "LeftMatrix", OperandQuantifier.Default), new Operand(new IdRef(), "RightMatrix", OperandQuantifier.Default), })
		{
		}
	}
	public class OpOuterProduct : Instruction
	{
		public OpOuterProduct() : base("OpOuterProduct", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDot : Instruction
	{
		public OpDot() : base("OpDot", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector 1", OperandQuantifier.Default), new Operand(new IdRef(), "Vector 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIAddCarry : Instruction
	{
		public OpIAddCarry() : base("OpIAddCarry", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpISubBorrow : Instruction
	{
		public OpISubBorrow() : base("OpISubBorrow", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUMulExtended : Instruction
	{
		public OpUMulExtended() : base("OpUMulExtended", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSMulExtended : Instruction
	{
		public OpSMulExtended() : base("OpSMulExtended", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAny : Instruction
	{
		public OpAny() : base("OpAny", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAll : Instruction
	{
		public OpAll() : base("OpAll", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Vector", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsNan : Instruction
	{
		public OpIsNan() : base("OpIsNan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsInf : Instruction
	{
		public OpIsInf() : base("OpIsInf", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsFinite : Instruction
	{
		public OpIsFinite() : base("OpIsFinite", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsNormal : Instruction
	{
		public OpIsNormal() : base("OpIsNormal", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSignBitSet : Instruction
	{
		public OpSignBitSet() : base("OpSignBitSet", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLessOrGreater : Instruction
	{
		public OpLessOrGreater() : base("OpLessOrGreater", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
		{
		}
	}
	public class OpOrdered : Instruction
	{
		public OpOrdered() : base("OpOrdered", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUnordered : Instruction
	{
		public OpUnordered() : base("OpUnordered", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "x", OperandQuantifier.Default), new Operand(new IdRef(), "y", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLogicalEqual : Instruction
	{
		public OpLogicalEqual() : base("OpLogicalEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLogicalNotEqual : Instruction
	{
		public OpLogicalNotEqual() : base("OpLogicalNotEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLogicalOr : Instruction
	{
		public OpLogicalOr() : base("OpLogicalOr", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLogicalAnd : Instruction
	{
		public OpLogicalAnd() : base("OpLogicalAnd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLogicalNot : Instruction
	{
		public OpLogicalNot() : base("OpLogicalNot", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSelect : Instruction
	{
		public OpSelect() : base("OpSelect", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "Object 1", OperandQuantifier.Default), new Operand(new IdRef(), "Object 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIEqual : Instruction
	{
		public OpIEqual() : base("OpIEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpINotEqual : Instruction
	{
		public OpINotEqual() : base("OpINotEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUGreaterThan : Instruction
	{
		public OpUGreaterThan() : base("OpUGreaterThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSGreaterThan : Instruction
	{
		public OpSGreaterThan() : base("OpSGreaterThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUGreaterThanEqual : Instruction
	{
		public OpUGreaterThanEqual() : base("OpUGreaterThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSGreaterThanEqual : Instruction
	{
		public OpSGreaterThanEqual() : base("OpSGreaterThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpULessThan : Instruction
	{
		public OpULessThan() : base("OpULessThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSLessThan : Instruction
	{
		public OpSLessThan() : base("OpSLessThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpULessThanEqual : Instruction
	{
		public OpULessThanEqual() : base("OpULessThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSLessThanEqual : Instruction
	{
		public OpSLessThanEqual() : base("OpSLessThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdEqual : Instruction
	{
		public OpFOrdEqual() : base("OpFOrdEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordEqual : Instruction
	{
		public OpFUnordEqual() : base("OpFUnordEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdNotEqual : Instruction
	{
		public OpFOrdNotEqual() : base("OpFOrdNotEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordNotEqual : Instruction
	{
		public OpFUnordNotEqual() : base("OpFUnordNotEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdLessThan : Instruction
	{
		public OpFOrdLessThan() : base("OpFOrdLessThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordLessThan : Instruction
	{
		public OpFUnordLessThan() : base("OpFUnordLessThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdGreaterThan : Instruction
	{
		public OpFOrdGreaterThan() : base("OpFOrdGreaterThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordGreaterThan : Instruction
	{
		public OpFUnordGreaterThan() : base("OpFUnordGreaterThan", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdLessThanEqual : Instruction
	{
		public OpFOrdLessThanEqual() : base("OpFOrdLessThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordLessThanEqual : Instruction
	{
		public OpFUnordLessThanEqual() : base("OpFUnordLessThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFOrdGreaterThanEqual : Instruction
	{
		public OpFOrdGreaterThanEqual() : base("OpFOrdGreaterThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFUnordGreaterThanEqual : Instruction
	{
		public OpFUnordGreaterThanEqual() : base("OpFUnordGreaterThanEqual", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpShiftRightLogical : Instruction
	{
		public OpShiftRightLogical() : base("OpShiftRightLogical", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
		{
		}
	}
	public class OpShiftRightArithmetic : Instruction
	{
		public OpShiftRightArithmetic() : base("OpShiftRightArithmetic", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
		{
		}
	}
	public class OpShiftLeftLogical : Instruction
	{
		public OpShiftLeftLogical() : base("OpShiftLeftLogical", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Shift", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitwiseOr : Instruction
	{
		public OpBitwiseOr() : base("OpBitwiseOr", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitwiseXor : Instruction
	{
		public OpBitwiseXor() : base("OpBitwiseXor", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitwiseAnd : Instruction
	{
		public OpBitwiseAnd() : base("OpBitwiseAnd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand 1", OperandQuantifier.Default), new Operand(new IdRef(), "Operand 2", OperandQuantifier.Default), })
		{
		}
	}
	public class OpNot : Instruction
	{
		public OpNot() : base("OpNot", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Operand", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitFieldInsert : Instruction
	{
		public OpBitFieldInsert() : base("OpBitFieldInsert", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Insert", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitFieldSExtract : Instruction
	{
		public OpBitFieldSExtract() : base("OpBitFieldSExtract", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitFieldUExtract : Instruction
	{
		public OpBitFieldUExtract() : base("OpBitFieldUExtract", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), new Operand(new IdRef(), "Offset", OperandQuantifier.Default), new Operand(new IdRef(), "Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitReverse : Instruction
	{
		public OpBitReverse() : base("OpBitReverse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBitCount : Instruction
	{
		public OpBitCount() : base("OpBitCount", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Base", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdx : Instruction
	{
		public OpDPdx() : base("OpDPdx", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdy : Instruction
	{
		public OpDPdy() : base("OpDPdy", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFwidth : Instruction
	{
		public OpFwidth() : base("OpFwidth", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdxFine : Instruction
	{
		public OpDPdxFine() : base("OpDPdxFine", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdyFine : Instruction
	{
		public OpDPdyFine() : base("OpDPdyFine", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFwidthFine : Instruction
	{
		public OpFwidthFine() : base("OpFwidthFine", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdxCoarse : Instruction
	{
		public OpDPdxCoarse() : base("OpDPdxCoarse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDPdyCoarse : Instruction
	{
		public OpDPdyCoarse() : base("OpDPdyCoarse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFwidthCoarse : Instruction
	{
		public OpFwidthCoarse() : base("OpFwidthCoarse", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "P", OperandQuantifier.Default), })
		{
		}
	}
	public class OpEmitVertex : Instruction
	{
		public OpEmitVertex() : base("OpEmitVertex")
		{
		}
	}
	public class OpEndPrimitive : Instruction
	{
		public OpEndPrimitive() : base("OpEndPrimitive")
		{
		}
	}
	public class OpEmitStreamVertex : Instruction
	{
		public OpEmitStreamVertex() : base("OpEmitStreamVertex", new List<Operand>()
	{new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
		{
		}
	}
	public class OpEndStreamPrimitive : Instruction
	{
		public OpEndStreamPrimitive() : base("OpEndStreamPrimitive", new List<Operand>()
	{new Operand(new IdRef(), "Stream", OperandQuantifier.Default), })
		{
		}
	}
	public class OpControlBarrier : Instruction
	{
		public OpControlBarrier() : base("OpControlBarrier", new List<Operand>()
	{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMemoryBarrier : Instruction
	{
		public OpMemoryBarrier() : base("OpMemoryBarrier", new List<Operand>()
	{new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicLoad : Instruction
	{
		public OpAtomicLoad() : base("OpAtomicLoad", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicStore : Instruction
	{
		public OpAtomicStore() : base("OpAtomicStore", new List<Operand>()
	{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicExchange : Instruction
	{
		public OpAtomicExchange() : base("OpAtomicExchange", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicCompareExchange : Instruction
	{
		public OpAtomicCompareExchange() : base("OpAtomicCompareExchange", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicCompareExchangeWeak : Instruction
	{
		public OpAtomicCompareExchangeWeak() : base("OpAtomicCompareExchangeWeak", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Equal", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Unequal", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Comparator", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicIIncrement : Instruction
	{
		public OpAtomicIIncrement() : base("OpAtomicIIncrement", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicIDecrement : Instruction
	{
		public OpAtomicIDecrement() : base("OpAtomicIDecrement", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicIAdd : Instruction
	{
		public OpAtomicIAdd() : base("OpAtomicIAdd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicISub : Instruction
	{
		public OpAtomicISub() : base("OpAtomicISub", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicSMin : Instruction
	{
		public OpAtomicSMin() : base("OpAtomicSMin", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicUMin : Instruction
	{
		public OpAtomicUMin() : base("OpAtomicUMin", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicSMax : Instruction
	{
		public OpAtomicSMax() : base("OpAtomicSMax", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicUMax : Instruction
	{
		public OpAtomicUMax() : base("OpAtomicUMax", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicAnd : Instruction
	{
		public OpAtomicAnd() : base("OpAtomicAnd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicOr : Instruction
	{
		public OpAtomicOr() : base("OpAtomicOr", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicXor : Instruction
	{
		public OpAtomicXor() : base("OpAtomicXor", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpPhi : Instruction
	{
		public OpPhi() : base("OpPhi", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new PairIdRefIdRef(), "Variable, Parent, ...", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpLoopMerge : Instruction
	{
		public OpLoopMerge() : base("OpLoopMerge", new List<Operand>()
	{new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new IdRef(), "Continue Target", OperandQuantifier.Default), new Operand(new EnumType<LoopControl, LoopControlParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSelectionMerge : Instruction
	{
		public OpSelectionMerge() : base("OpSelectionMerge", new List<Operand>()
	{new Operand(new IdRef(), "Merge Block", OperandQuantifier.Default), new Operand(new EnumType<SelectionControl, SelectionControlParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpLabel : Instruction
	{
		public OpLabel() : base("OpLabel", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpBranch : Instruction
	{
		public OpBranch() : base("OpBranch", new List<Operand>()
	{new Operand(new IdRef(), "Target Label", OperandQuantifier.Default), })
		{
		}
	}
	public class OpBranchConditional : Instruction
	{
		public OpBranchConditional() : base("OpBranchConditional", new List<Operand>()
	{new Operand(new IdRef(), "Condition", OperandQuantifier.Default), new Operand(new IdRef(), "True Label", OperandQuantifier.Default), new Operand(new IdRef(), "False Label", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Branch weights", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpSwitch : Instruction
	{
		public OpSwitch() : base("OpSwitch", new List<Operand>()
	{new Operand(new IdRef(), "Selector", OperandQuantifier.Default), new Operand(new IdRef(), "Default", OperandQuantifier.Default), new Operand(new PairLiteralIntegerIdRef(), "Target", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpKill : Instruction
	{
		public OpKill() : base("OpKill")
		{
		}
	}
	public class OpReturn : Instruction
	{
		public OpReturn() : base("OpReturn")
		{
		}
	}
	public class OpReturnValue : Instruction
	{
		public OpReturnValue() : base("OpReturnValue", new List<Operand>()
	{new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpUnreachable : Instruction
	{
		public OpUnreachable() : base("OpUnreachable")
		{
		}
	}
	public class OpLifetimeStart : Instruction
	{
		public OpLifetimeStart() : base("OpLifetimeStart", new List<Operand>()
	{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
		{
		}
	}
	public class OpLifetimeStop : Instruction
	{
		public OpLifetimeStop() : base("OpLifetimeStop", new List<Operand>()
	{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Size", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupAsyncCopy : Instruction
	{
		public OpGroupAsyncCopy() : base("OpGroupAsyncCopy", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Destination", OperandQuantifier.Default), new Operand(new IdRef(), "Source", OperandQuantifier.Default), new Operand(new IdRef(), "Num Elements", OperandQuantifier.Default), new Operand(new IdRef(), "Stride", OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupWaitEvents : Instruction
	{
		public OpGroupWaitEvents() : base("OpGroupWaitEvents", new List<Operand>()
	{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Events List", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupAll : Instruction
	{
		public OpGroupAll() : base("OpGroupAll", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupAny : Instruction
	{
		public OpGroupAny() : base("OpGroupAny", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupBroadcast : Instruction
	{
		public OpGroupBroadcast() : base("OpGroupBroadcast", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "LocalId", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupIAdd : Instruction
	{
		public OpGroupIAdd() : base("OpGroupIAdd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFAdd : Instruction
	{
		public OpGroupFAdd() : base("OpGroupFAdd", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFMin : Instruction
	{
		public OpGroupFMin() : base("OpGroupFMin", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupUMin : Instruction
	{
		public OpGroupUMin() : base("OpGroupUMin", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupSMin : Instruction
	{
		public OpGroupSMin() : base("OpGroupSMin", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFMax : Instruction
	{
		public OpGroupFMax() : base("OpGroupFMax", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupUMax : Instruction
	{
		public OpGroupUMax() : base("OpGroupUMax", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupSMax : Instruction
	{
		public OpGroupSMax() : base("OpGroupSMax", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReadPipe : Instruction
	{
		public OpReadPipe() : base("OpReadPipe", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpWritePipe : Instruction
	{
		public OpWritePipe() : base("OpWritePipe", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReservedReadPipe : Instruction
	{
		public OpReservedReadPipe() : base("OpReservedReadPipe", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReservedWritePipe : Instruction
	{
		public OpReservedWritePipe() : base("OpReservedWritePipe", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReserveReadPipePackets : Instruction
	{
		public OpReserveReadPipePackets() : base("OpReserveReadPipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReserveWritePipePackets : Instruction
	{
		public OpReserveWritePipePackets() : base("OpReserveWritePipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCommitReadPipe : Instruction
	{
		public OpCommitReadPipe() : base("OpCommitReadPipe", new List<Operand>()
	{new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCommitWritePipe : Instruction
	{
		public OpCommitWritePipe() : base("OpCommitWritePipe", new List<Operand>()
	{new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsValidReserveId : Instruction
	{
		public OpIsValidReserveId() : base("OpIsValidReserveId", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetNumPipePackets : Instruction
	{
		public OpGetNumPipePackets() : base("OpGetNumPipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetMaxPipePackets : Instruction
	{
		public OpGetMaxPipePackets() : base("OpGetMaxPipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupReserveReadPipePackets : Instruction
	{
		public OpGroupReserveReadPipePackets() : base("OpGroupReserveReadPipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupReserveWritePipePackets : Instruction
	{
		public OpGroupReserveWritePipePackets() : base("OpGroupReserveWritePipePackets", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Num Packets", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupCommitReadPipe : Instruction
	{
		public OpGroupCommitReadPipe() : base("OpGroupCommitReadPipe", new List<Operand>()
	{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupCommitWritePipe : Instruction
	{
		public OpGroupCommitWritePipe() : base("OpGroupCommitWritePipe", new List<Operand>()
	{new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new IdRef(), "Pipe", OperandQuantifier.Default), new Operand(new IdRef(), "Reserve Id", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Size", OperandQuantifier.Default), new Operand(new IdRef(), "Packet Alignment", OperandQuantifier.Default), })
		{
		}
	}
	public class OpEnqueueMarker : Instruction
	{
		public OpEnqueueMarker() : base("OpEnqueueMarker", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), })
		{
		}
	}
	public class OpEnqueueKernel : Instruction
	{
		public OpEnqueueKernel() : base("OpEnqueueKernel", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Queue", OperandQuantifier.Default), new Operand(new IdRef(), "Flags", OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Num Events", OperandQuantifier.Default), new Operand(new IdRef(), "Wait Events", OperandQuantifier.Default), new Operand(new IdRef(), "Ret Event", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), new Operand(new IdRef(), "Local Size", OperandQuantifier.Varying), })
		{
		}
	}
	public class OpGetKernelNDrangeSubGroupCount : Instruction
	{
		public OpGetKernelNDrangeSubGroupCount() : base("OpGetKernelNDrangeSubGroupCount", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetKernelNDrangeMaxSubGroupSize : Instruction
	{
		public OpGetKernelNDrangeMaxSubGroupSize() : base("OpGetKernelNDrangeMaxSubGroupSize", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "ND Range", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetKernelWorkGroupSize : Instruction
	{
		public OpGetKernelWorkGroupSize() : base("OpGetKernelWorkGroupSize", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetKernelPreferredWorkGroupSizeMultiple : Instruction
	{
		public OpGetKernelPreferredWorkGroupSizeMultiple() : base("OpGetKernelPreferredWorkGroupSizeMultiple", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpRetainEvent : Instruction
	{
		public OpRetainEvent() : base("OpRetainEvent", new List<Operand>()
	{new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
		{
		}
	}
	public class OpReleaseEvent : Instruction
	{
		public OpReleaseEvent() : base("OpReleaseEvent", new List<Operand>()
	{new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCreateUserEvent : Instruction
	{
		public OpCreateUserEvent() : base("OpCreateUserEvent", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpIsValidEvent : Instruction
	{
		public OpIsValidEvent() : base("OpIsValidEvent", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Event", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSetUserEventStatus : Instruction
	{
		public OpSetUserEventStatus() : base("OpSetUserEventStatus", new List<Operand>()
	{new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Status", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCaptureEventProfilingInfo : Instruction
	{
		public OpCaptureEventProfilingInfo() : base("OpCaptureEventProfilingInfo", new List<Operand>()
	{new Operand(new IdRef(), "Event", OperandQuantifier.Default), new Operand(new IdRef(), "Profiling Info", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetDefaultQueue : Instruction
	{
		public OpGetDefaultQueue() : base("OpGetDefaultQueue", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpBuildNDRange : Instruction
	{
		public OpBuildNDRange() : base("OpBuildNDRange", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "LocalWorkSize", OperandQuantifier.Default), new Operand(new IdRef(), "GlobalWorkOffset", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseSampleImplicitLod : Instruction
	{
		public OpImageSparseSampleImplicitLod() : base("OpImageSparseSampleImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseSampleExplicitLod : Instruction
	{
		public OpImageSparseSampleExplicitLod() : base("OpImageSparseSampleExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseSampleDrefImplicitLod : Instruction
	{
		public OpImageSparseSampleDrefImplicitLod() : base("OpImageSparseSampleDrefImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseSampleDrefExplicitLod : Instruction
	{
		public OpImageSparseSampleDrefExplicitLod() : base("OpImageSparseSampleDrefExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseSampleProjImplicitLod : Instruction
	{
		public OpImageSparseSampleProjImplicitLod() : base("OpImageSparseSampleProjImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseSampleProjExplicitLod : Instruction
	{
		public OpImageSparseSampleProjExplicitLod() : base("OpImageSparseSampleProjExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseSampleProjDrefImplicitLod : Instruction
	{
		public OpImageSparseSampleProjDrefImplicitLod() : base("OpImageSparseSampleProjDrefImplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseSampleProjDrefExplicitLod : Instruction
	{
		public OpImageSparseSampleProjDrefExplicitLod() : base("OpImageSparseSampleProjDrefExplicitLod", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseFetch : Instruction
	{
		public OpImageSparseFetch() : base("OpImageSparseFetch", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseGather : Instruction
	{
		public OpImageSparseGather() : base("OpImageSparseGather", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Component", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseDrefGather : Instruction
	{
		public OpImageSparseDrefGather() : base("OpImageSparseDrefGather", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Sampled Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "D~ref~", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpImageSparseTexelsResident : Instruction
	{
		public OpImageSparseTexelsResident() : base("OpImageSparseTexelsResident", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Resident Code", OperandQuantifier.Default), })
		{
		}
	}
	public class OpNoLine : Instruction
	{
		public OpNoLine() : base("OpNoLine")
		{
		}
	}
	public class OpAtomicFlagTestAndSet : Instruction
	{
		public OpAtomicFlagTestAndSet() : base("OpAtomicFlagTestAndSet", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpAtomicFlagClear : Instruction
	{
		public OpAtomicFlagClear() : base("OpAtomicFlagClear", new List<Operand>()
	{new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), new Operand(new IdScope(), "Scope", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpImageSparseRead : Instruction
	{
		public OpImageSparseRead() : base("OpImageSparseRead", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new EnumType<ImageOperands, ImageOperandsParameterFactory>(), null, OperandQuantifier.Optional), })
		{
		}
	}
	public class OpSizeOf : Instruction
	{
		public OpSizeOf() : base("OpSizeOf", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pointer", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypePipeStorage : Instruction
	{
		public OpTypePipeStorage() : base("OpTypePipeStorage", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpConstantPipeStorage : Instruction
	{
		public OpConstantPipeStorage() : base("OpConstantPipeStorage", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Size", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Packet Alignment", OperandQuantifier.Default), new Operand(new LiteralInteger(), "Capacity", OperandQuantifier.Default), })
		{
		}
	}
	public class OpCreatePipeFromPipeStorage : Instruction
	{
		public OpCreatePipeFromPipeStorage() : base("OpCreatePipeFromPipeStorage", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Pipe Storage", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetKernelLocalSizeForSubgroupCount : Instruction
	{
		public OpGetKernelLocalSizeForSubgroupCount() : base("OpGetKernelLocalSizeForSubgroupCount", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGetKernelMaxNumSubgroups : Instruction
	{
		public OpGetKernelMaxNumSubgroups() : base("OpGetKernelMaxNumSubgroups", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Invoke", OperandQuantifier.Default), new Operand(new IdRef(), "Param", OperandQuantifier.Default), new Operand(new IdRef(), "Param Size", OperandQuantifier.Default), new Operand(new IdRef(), "Param Align", OperandQuantifier.Default), })
		{
		}
	}
	public class OpTypeNamedBarrier : Instruction
	{
		public OpTypeNamedBarrier() : base("OpTypeNamedBarrier", new List<Operand>()
	{new Operand(new IdResult(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpNamedBarrierInitialize : Instruction
	{
		public OpNamedBarrierInitialize() : base("OpNamedBarrierInitialize", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Subgroup Count", OperandQuantifier.Default), })
		{
		}
	}
	public class OpMemoryNamedBarrier : Instruction
	{
		public OpMemoryNamedBarrier() : base("OpMemoryNamedBarrier", new List<Operand>()
	{new Operand(new IdRef(), "Named Barrier", OperandQuantifier.Default), new Operand(new IdScope(), "Memory", OperandQuantifier.Default), new Operand(new IdMemorySemantics(), "Semantics", OperandQuantifier.Default), })
		{
		}
	}
	public class OpModuleProcessed : Instruction
	{
		public OpModuleProcessed() : base("OpModuleProcessed", new List<Operand>()
	{new Operand(new LiteralString(), "Process", OperandQuantifier.Default), })
		{
		}
	}
	public class OpExecutionModeId : Instruction
	{
		public OpExecutionModeId() : base("OpExecutionModeId", new List<Operand>()
	{new Operand(new IdRef(), "Entry Point", OperandQuantifier.Default), new Operand(new EnumType<ExecutionMode, ExecutionModeParameterFactory>(), "Mode", OperandQuantifier.Default), })
		{
		}
	}
	public class OpDecorateId : Instruction
	{
		public OpDecorateId() : base("OpDecorateId", new List<Operand>()
	{new Operand(new IdRef(), "Target", OperandQuantifier.Default), new Operand(new EnumType<Decoration, DecorationParameterFactory>(), null, OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupBallotKHR : Instruction
	{
		public OpSubgroupBallotKHR() : base("OpSubgroupBallotKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupFirstInvocationKHR : Instruction
	{
		public OpSubgroupFirstInvocationKHR() : base("OpSubgroupFirstInvocationKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupAllKHR : Instruction
	{
		public OpSubgroupAllKHR() : base("OpSubgroupAllKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupAnyKHR : Instruction
	{
		public OpSubgroupAnyKHR() : base("OpSubgroupAnyKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupAllEqualKHR : Instruction
	{
		public OpSubgroupAllEqualKHR() : base("OpSubgroupAllEqualKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Predicate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupReadInvocationKHR : Instruction
	{
		public OpSubgroupReadInvocationKHR() : base("OpSubgroupReadInvocationKHR", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), new Operand(new IdRef(), "Index", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupIAddNonUniformAMD : Instruction
	{
		public OpGroupIAddNonUniformAMD() : base("OpGroupIAddNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFAddNonUniformAMD : Instruction
	{
		public OpGroupFAddNonUniformAMD() : base("OpGroupFAddNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFMinNonUniformAMD : Instruction
	{
		public OpGroupFMinNonUniformAMD() : base("OpGroupFMinNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupUMinNonUniformAMD : Instruction
	{
		public OpGroupUMinNonUniformAMD() : base("OpGroupUMinNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupSMinNonUniformAMD : Instruction
	{
		public OpGroupSMinNonUniformAMD() : base("OpGroupSMinNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupFMaxNonUniformAMD : Instruction
	{
		public OpGroupFMaxNonUniformAMD() : base("OpGroupFMaxNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupUMaxNonUniformAMD : Instruction
	{
		public OpGroupUMaxNonUniformAMD() : base("OpGroupUMaxNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpGroupSMaxNonUniformAMD : Instruction
	{
		public OpGroupSMaxNonUniformAMD() : base("OpGroupSMaxNonUniformAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdScope(), "Execution", OperandQuantifier.Default), new Operand(new EnumType<GroupOperation, GroupOperationParameterFactory>(), "Operation", OperandQuantifier.Default), new Operand(new IdRef(), "X", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFragmentMaskFetchAMD : Instruction
	{
		public OpFragmentMaskFetchAMD() : base("OpFragmentMaskFetchAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpFragmentFetchAMD : Instruction
	{
		public OpFragmentFetchAMD() : base("OpFragmentFetchAMD", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Fragment Index", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupShuffleINTEL : Instruction
	{
		public OpSubgroupShuffleINTEL() : base("OpSubgroupShuffleINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "InvocationId", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupShuffleDownINTEL : Instruction
	{
		public OpSubgroupShuffleDownINTEL() : base("OpSubgroupShuffleDownINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Next", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupShuffleUpINTEL : Instruction
	{
		public OpSubgroupShuffleUpINTEL() : base("OpSubgroupShuffleUpINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Previous", OperandQuantifier.Default), new Operand(new IdRef(), "Current", OperandQuantifier.Default), new Operand(new IdRef(), "Delta", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupShuffleXorINTEL : Instruction
	{
		public OpSubgroupShuffleXorINTEL() : base("OpSubgroupShuffleXorINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), new Operand(new IdRef(), "Value", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupBlockReadINTEL : Instruction
	{
		public OpSubgroupBlockReadINTEL() : base("OpSubgroupBlockReadINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupBlockWriteINTEL : Instruction
	{
		public OpSubgroupBlockWriteINTEL() : base("OpSubgroupBlockWriteINTEL", new List<Operand>()
	{new Operand(new IdRef(), "Ptr", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupImageBlockReadINTEL : Instruction
	{
		public OpSubgroupImageBlockReadINTEL() : base("OpSubgroupImageBlockReadINTEL", new List<Operand>()
	{new Operand(new IdResultType(), null, OperandQuantifier.Default), new Operand(new IdResult(), null, OperandQuantifier.Default), new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), })
		{
		}
	}
	public class OpSubgroupImageBlockWriteINTEL : Instruction
	{
		public OpSubgroupImageBlockWriteINTEL() : base("OpSubgroupImageBlockWriteINTEL", new List<Operand>()
	{new Operand(new IdRef(), "Image", OperandQuantifier.Default), new Operand(new IdRef(), "Coordinate", OperandQuantifier.Default), new Operand(new IdRef(), "Data", OperandQuantifier.Default), })
		{
		}
	}
	public static class Instructions
	{
		private static readonly Dictionary<int, Instruction> instructions_ = new Dictionary<int, Instruction> { { 0, new OpNop() }, { 1, new OpUndef() }, { 2, new OpSourceContinued() }, { 3, new OpSource() }, { 4, new OpSourceExtension() }, { 5, new OpName() }, { 6, new OpMemberName() }, { 7, new OpString() }, { 8, new OpLine() }, { 10, new OpExtension() }, { 11, new OpExtInstImport() }, { 12, new OpExtInst() }, { 14, new OpMemoryModel() }, { 15, new OpEntryPoint() }, { 16, new OpExecutionMode() }, { 17, new OpCapability() }, { 19, new OpTypeVoid() }, { 20, new OpTypeBool() }, { 21, new OpTypeInt() }, { 22, new OpTypeFloat() }, { 23, new OpTypeVector() }, { 24, new OpTypeMatrix() }, { 25, new OpTypeImage() }, { 26, new OpTypeSampler() }, { 27, new OpTypeSampledImage() }, { 28, new OpTypeArray() }, { 29, new OpTypeRuntimeArray() }, { 30, new OpTypeStruct() }, { 31, new OpTypeOpaque() }, { 32, new OpTypePointer() }, { 33, new OpTypeFunction() }, { 34, new OpTypeEvent() }, { 35, new OpTypeDeviceEvent() }, { 36, new OpTypeReserveId() }, { 37, new OpTypeQueue() }, { 38, new OpTypePipe() }, { 39, new OpTypeForwardPointer() }, { 41, new OpConstantTrue() }, { 42, new OpConstantFalse() }, { 43, new OpConstant() }, { 44, new OpConstantComposite() }, { 45, new OpConstantSampler() }, { 46, new OpConstantNull() }, { 48, new OpSpecConstantTrue() }, { 49, new OpSpecConstantFalse() }, { 50, new OpSpecConstant() }, { 51, new OpSpecConstantComposite() }, { 52, new OpSpecConstantOp() }, { 54, new OpFunction() }, { 55, new OpFunctionParameter() }, { 56, new OpFunctionEnd() }, { 57, new OpFunctionCall() }, { 59, new OpVariable() }, { 60, new OpImageTexelPointer() }, { 61, new OpLoad() }, { 62, new OpStore() }, { 63, new OpCopyMemory() }, { 64, new OpCopyMemorySized() }, { 65, new OpAccessChain() }, { 66, new OpInBoundsAccessChain() }, { 67, new OpPtrAccessChain() }, { 68, new OpArrayLength() }, { 69, new OpGenericPtrMemSemantics() }, { 70, new OpInBoundsPtrAccessChain() }, { 71, new OpDecorate() }, { 72, new OpMemberDecorate() }, { 73, new OpDecorationGroup() }, { 74, new OpGroupDecorate() }, { 75, new OpGroupMemberDecorate() }, { 77, new OpVectorExtractDynamic() }, { 78, new OpVectorInsertDynamic() }, { 79, new OpVectorShuffle() }, { 80, new OpCompositeConstruct() }, { 81, new OpCompositeExtract() }, { 82, new OpCompositeInsert() }, { 83, new OpCopyObject() }, { 84, new OpTranspose() }, { 86, new OpSampledImage() }, { 87, new OpImageSampleImplicitLod() }, { 88, new OpImageSampleExplicitLod() }, { 89, new OpImageSampleDrefImplicitLod() }, { 90, new OpImageSampleDrefExplicitLod() }, { 91, new OpImageSampleProjImplicitLod() }, { 92, new OpImageSampleProjExplicitLod() }, { 93, new OpImageSampleProjDrefImplicitLod() }, { 94, new OpImageSampleProjDrefExplicitLod() }, { 95, new OpImageFetch() }, { 96, new OpImageGather() }, { 97, new OpImageDrefGather() }, { 98, new OpImageRead() }, { 99, new OpImageWrite() }, { 100, new OpImage() }, { 101, new OpImageQueryFormat() }, { 102, new OpImageQueryOrder() }, { 103, new OpImageQuerySizeLod() }, { 104, new OpImageQuerySize() }, { 105, new OpImageQueryLod() }, { 106, new OpImageQueryLevels() }, { 107, new OpImageQuerySamples() }, { 109, new OpConvertFToU() }, { 110, new OpConvertFToS() }, { 111, new OpConvertSToF() }, { 112, new OpConvertUToF() }, { 113, new OpUConvert() }, { 114, new OpSConvert() }, { 115, new OpFConvert() }, { 116, new OpQuantizeToF16() }, { 117, new OpConvertPtrToU() }, { 118, new OpSatConvertSToU() }, { 119, new OpSatConvertUToS() }, { 120, new OpConvertUToPtr() }, { 121, new OpPtrCastToGeneric() }, { 122, new OpGenericCastToPtr() }, { 123, new OpGenericCastToPtrExplicit() }, { 124, new OpBitcast() }, { 126, new OpSNegate() }, { 127, new OpFNegate() }, { 128, new OpIAdd() }, { 129, new OpFAdd() }, { 130, new OpISub() }, { 131, new OpFSub() }, { 132, new OpIMul() }, { 133, new OpFMul() }, { 134, new OpUDiv() }, { 135, new OpSDiv() }, { 136, new OpFDiv() }, { 137, new OpUMod() }, { 138, new OpSRem() }, { 139, new OpSMod() }, { 140, new OpFRem() }, { 141, new OpFMod() }, { 142, new OpVectorTimesScalar() }, { 143, new OpMatrixTimesScalar() }, { 144, new OpVectorTimesMatrix() }, { 145, new OpMatrixTimesVector() }, { 146, new OpMatrixTimesMatrix() }, { 147, new OpOuterProduct() }, { 148, new OpDot() }, { 149, new OpIAddCarry() }, { 150, new OpISubBorrow() }, { 151, new OpUMulExtended() }, { 152, new OpSMulExtended() }, { 154, new OpAny() }, { 155, new OpAll() }, { 156, new OpIsNan() }, { 157, new OpIsInf() }, { 158, new OpIsFinite() }, { 159, new OpIsNormal() }, { 160, new OpSignBitSet() }, { 161, new OpLessOrGreater() }, { 162, new OpOrdered() }, { 163, new OpUnordered() }, { 164, new OpLogicalEqual() }, { 165, new OpLogicalNotEqual() }, { 166, new OpLogicalOr() }, { 167, new OpLogicalAnd() }, { 168, new OpLogicalNot() }, { 169, new OpSelect() }, { 170, new OpIEqual() }, { 171, new OpINotEqual() }, { 172, new OpUGreaterThan() }, { 173, new OpSGreaterThan() }, { 174, new OpUGreaterThanEqual() }, { 175, new OpSGreaterThanEqual() }, { 176, new OpULessThan() }, { 177, new OpSLessThan() }, { 178, new OpULessThanEqual() }, { 179, new OpSLessThanEqual() }, { 180, new OpFOrdEqual() }, { 181, new OpFUnordEqual() }, { 182, new OpFOrdNotEqual() }, { 183, new OpFUnordNotEqual() }, { 184, new OpFOrdLessThan() }, { 185, new OpFUnordLessThan() }, { 186, new OpFOrdGreaterThan() }, { 187, new OpFUnordGreaterThan() }, { 188, new OpFOrdLessThanEqual() }, { 189, new OpFUnordLessThanEqual() }, { 190, new OpFOrdGreaterThanEqual() }, { 191, new OpFUnordGreaterThanEqual() }, { 194, new OpShiftRightLogical() }, { 195, new OpShiftRightArithmetic() }, { 196, new OpShiftLeftLogical() }, { 197, new OpBitwiseOr() }, { 198, new OpBitwiseXor() }, { 199, new OpBitwiseAnd() }, { 200, new OpNot() }, { 201, new OpBitFieldInsert() }, { 202, new OpBitFieldSExtract() }, { 203, new OpBitFieldUExtract() }, { 204, new OpBitReverse() }, { 205, new OpBitCount() }, { 207, new OpDPdx() }, { 208, new OpDPdy() }, { 209, new OpFwidth() }, { 210, new OpDPdxFine() }, { 211, new OpDPdyFine() }, { 212, new OpFwidthFine() }, { 213, new OpDPdxCoarse() }, { 214, new OpDPdyCoarse() }, { 215, new OpFwidthCoarse() }, { 218, new OpEmitVertex() }, { 219, new OpEndPrimitive() }, { 220, new OpEmitStreamVertex() }, { 221, new OpEndStreamPrimitive() }, { 224, new OpControlBarrier() }, { 225, new OpMemoryBarrier() }, { 227, new OpAtomicLoad() }, { 228, new OpAtomicStore() }, { 229, new OpAtomicExchange() }, { 230, new OpAtomicCompareExchange() }, { 231, new OpAtomicCompareExchangeWeak() }, { 232, new OpAtomicIIncrement() }, { 233, new OpAtomicIDecrement() }, { 234, new OpAtomicIAdd() }, { 235, new OpAtomicISub() }, { 236, new OpAtomicSMin() }, { 237, new OpAtomicUMin() }, { 238, new OpAtomicSMax() }, { 239, new OpAtomicUMax() }, { 240, new OpAtomicAnd() }, { 241, new OpAtomicOr() }, { 242, new OpAtomicXor() }, { 245, new OpPhi() }, { 246, new OpLoopMerge() }, { 247, new OpSelectionMerge() }, { 248, new OpLabel() }, { 249, new OpBranch() }, { 250, new OpBranchConditional() }, { 251, new OpSwitch() }, { 252, new OpKill() }, { 253, new OpReturn() }, { 254, new OpReturnValue() }, { 255, new OpUnreachable() }, { 256, new OpLifetimeStart() }, { 257, new OpLifetimeStop() }, { 259, new OpGroupAsyncCopy() }, { 260, new OpGroupWaitEvents() }, { 261, new OpGroupAll() }, { 262, new OpGroupAny() }, { 263, new OpGroupBroadcast() }, { 264, new OpGroupIAdd() }, { 265, new OpGroupFAdd() }, { 266, new OpGroupFMin() }, { 267, new OpGroupUMin() }, { 268, new OpGroupSMin() }, { 269, new OpGroupFMax() }, { 270, new OpGroupUMax() }, { 271, new OpGroupSMax() }, { 274, new OpReadPipe() }, { 275, new OpWritePipe() }, { 276, new OpReservedReadPipe() }, { 277, new OpReservedWritePipe() }, { 278, new OpReserveReadPipePackets() }, { 279, new OpReserveWritePipePackets() }, { 280, new OpCommitReadPipe() }, { 281, new OpCommitWritePipe() }, { 282, new OpIsValidReserveId() }, { 283, new OpGetNumPipePackets() }, { 284, new OpGetMaxPipePackets() }, { 285, new OpGroupReserveReadPipePackets() }, { 286, new OpGroupReserveWritePipePackets() }, { 287, new OpGroupCommitReadPipe() }, { 288, new OpGroupCommitWritePipe() }, { 291, new OpEnqueueMarker() }, { 292, new OpEnqueueKernel() }, { 293, new OpGetKernelNDrangeSubGroupCount() }, { 294, new OpGetKernelNDrangeMaxSubGroupSize() }, { 295, new OpGetKernelWorkGroupSize() }, { 296, new OpGetKernelPreferredWorkGroupSizeMultiple() }, { 297, new OpRetainEvent() }, { 298, new OpReleaseEvent() }, { 299, new OpCreateUserEvent() }, { 300, new OpIsValidEvent() }, { 301, new OpSetUserEventStatus() }, { 302, new OpCaptureEventProfilingInfo() }, { 303, new OpGetDefaultQueue() }, { 304, new OpBuildNDRange() }, { 305, new OpImageSparseSampleImplicitLod() }, { 306, new OpImageSparseSampleExplicitLod() }, { 307, new OpImageSparseSampleDrefImplicitLod() }, { 308, new OpImageSparseSampleDrefExplicitLod() }, { 309, new OpImageSparseSampleProjImplicitLod() }, { 310, new OpImageSparseSampleProjExplicitLod() }, { 311, new OpImageSparseSampleProjDrefImplicitLod() }, { 312, new OpImageSparseSampleProjDrefExplicitLod() }, { 313, new OpImageSparseFetch() }, { 314, new OpImageSparseGather() }, { 315, new OpImageSparseDrefGather() }, { 316, new OpImageSparseTexelsResident() }, { 317, new OpNoLine() }, { 318, new OpAtomicFlagTestAndSet() }, { 319, new OpAtomicFlagClear() }, { 320, new OpImageSparseRead() }, { 321, new OpSizeOf() }, { 322, new OpTypePipeStorage() }, { 323, new OpConstantPipeStorage() }, { 324, new OpCreatePipeFromPipeStorage() }, { 325, new OpGetKernelLocalSizeForSubgroupCount() }, { 326, new OpGetKernelMaxNumSubgroups() }, { 327, new OpTypeNamedBarrier() }, { 328, new OpNamedBarrierInitialize() }, { 329, new OpMemoryNamedBarrier() }, { 330, new OpModuleProcessed() }, { 331, new OpExecutionModeId() }, { 332, new OpDecorateId() }, { 4421, new OpSubgroupBallotKHR() }, { 4422, new OpSubgroupFirstInvocationKHR() }, { 4428, new OpSubgroupAllKHR() }, { 4429, new OpSubgroupAnyKHR() }, { 4430, new OpSubgroupAllEqualKHR() }, { 4432, new OpSubgroupReadInvocationKHR() }, { 5000, new OpGroupIAddNonUniformAMD() }, { 5001, new OpGroupFAddNonUniformAMD() }, { 5002, new OpGroupFMinNonUniformAMD() }, { 5003, new OpGroupUMinNonUniformAMD() }, { 5004, new OpGroupSMinNonUniformAMD() }, { 5005, new OpGroupFMaxNonUniformAMD() }, { 5006, new OpGroupUMaxNonUniformAMD() }, { 5007, new OpGroupSMaxNonUniformAMD() }, { 5011, new OpFragmentMaskFetchAMD() }, { 5012, new OpFragmentFetchAMD() }, { 5571, new OpSubgroupShuffleINTEL() }, { 5572, new OpSubgroupShuffleDownINTEL() }, { 5573, new OpSubgroupShuffleUpINTEL() }, { 5574, new OpSubgroupShuffleXorINTEL() }, { 5575, new OpSubgroupBlockReadINTEL() }, { 5576, new OpSubgroupBlockWriteINTEL() }, { 5577, new OpSubgroupImageBlockReadINTEL() }, { 5578, new OpSubgroupImageBlockWriteINTEL() }, };
		public static IReadOnlyDictionary<int, Instruction> OpcodeToInstruction
		{
			get => instructions_;
		}
	}
}
```

`SpirV/SpirV.Meta.cs`:

```cs
using System.Collections.Generic;

namespace SpirV
{
	internal class Meta
	{
		public class ToolInfo
		{
			public ToolInfo(string vendor)
			{
				Vendor = vendor;
			}

			public ToolInfo(string vendor, string name)
			{
				Vendor = vendor;
				Name = name;
			}

			public string Name { get; }
			public string Vendor { get; }
		}

		public static uint MagicNumber => 119734787U;
		public static uint Version => 66048U;
		public static uint Revision => 2U;
		public static uint OpCodeMask => 65535U;
		public static uint WordCountShift => 16U;

		public static IReadOnlyDictionary<int, ToolInfo> Tools => toolInfos_;

		private readonly static Dictionary<int, ToolInfo> toolInfos_ = new Dictionary<int, ToolInfo>
		{
			{ 0, new ToolInfo("Khronos") },
			{ 1, new ToolInfo("LunarG") },
			{ 2, new ToolInfo("Valve") },
			{ 3, new ToolInfo("Codeplay") },
			{ 4, new ToolInfo("NVIDIA") },
			{ 5, new ToolInfo("ARM") },
			{ 6, new ToolInfo("Khronos", "LLVM/SPIR-V Translator") },
			{ 7, new ToolInfo("Khronos", "SPIR-V Tools Assembler") },
			{ 8, new ToolInfo("Khronos", "Glslang Reference Front End") },
			{ 9, new ToolInfo("Qualcomm") },
			{ 10, new ToolInfo("AMD") },
			{ 11, new ToolInfo("Intel") },
			{ 12, new ToolInfo("Imagination") },
			{ 13, new ToolInfo("Google", "Shaderc over Glslang") },
			{ 14, new ToolInfo("Google", "spiregg") },
			{ 15, new ToolInfo("Google", "rspirv") },
			{ 16, new ToolInfo("X-LEGEND", "Mesa-IR/SPIR-V Translator") },
			{ 17, new ToolInfo("Khronos", "SPIR-V Tools Linker") },
		};
	}
}
```

`SpirV/SpirV.csproj`:

```csproj
<Project Sdk="Microsoft.NET.Sdk">

	<PropertyGroup>
		<TargetFramework>net6.0</TargetFramework>
		<DisableImplicitNamespaceImports>true</DisableImplicitNamespaceImports>
		<AppendTargetFrameworkToOutputPath>false</AppendTargetFrameworkToOutputPath>
		<AssemblyName>SpirV</AssemblyName>
		<RootNamespace>SpirV</RootNamespace>
		<OutputPath>..\Bins\SpirV\$(Configuration)\</OutputPath>
		<Configurations>Debug;Release</Configurations>
		<DebugType>embedded</DebugType>
		<DebugSymbols>true</DebugSymbols>
		<IsTrimmable>true</IsTrimmable>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|AnyCPU'">
		<DefineConstants>DEBUG;TRACE</DefineConstants>
	</PropertyGroup>

	<PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|AnyCPU'">
		<DefineConstants>TRACE</DefineConstants>
	</PropertyGroup>

	<ItemGroup>
		<RuntimeHostConfigurationOption Include="System.Globalization.Invariant" Value="true" />
	</ItemGroup>

	<ItemGroup>
		<Compile Remove="obj\**" />
		<EmbeddedResource Remove="obj\**" />
		<None Remove="obj\**" />
	</ItemGroup>

</Project>

```

`SpirV/Types.cs`:

```cs
using System.Collections.Generic;
using System.Text;

namespace SpirV
{
	public class Type
	{
		public virtual StringBuilder ToString(StringBuilder sb)
		{
			return sb;
		}
	}

	public class VoidType : Type
	{
		public override string ToString()
		{
			return "void";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("void");
		}
	}

	public class ScalarType : Type
	{
	}

	public class BoolType : ScalarType
	{
		public override string ToString()
		{
			return "bool";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("bool");
		}
	}

	public class IntegerType : ScalarType
	{
		public IntegerType(int width, bool signed)
		{
			Width = width;
			Signed = signed;
		}

		public override string ToString()
		{
			if (Signed)
			{
				return $"i{Width}";
			}
			else
			{
				return $"u{Width}";
			}
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			if (Signed)
			{
				sb.Append('i').Append(Width);
			}
			else
			{
				sb.Append('u').Append(Width);
			}
			return sb;
		}

		public int Width { get; }
		public bool Signed { get; }
	}

	public class FloatingPointType : ScalarType
	{
		public FloatingPointType(int width)
		{
			Width = width;
		}

		public override string ToString()
		{
			return $"f{Width}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append('f').Append(Width);
		}

		public int Width { get; }
	}

	public class VectorType : Type
	{
		public VectorType(ScalarType scalarType, int componentCount)
		{
			ComponentType = scalarType;
			ComponentCount = componentCount;
		}

		public override string ToString()
		{
			return $"{ComponentType}_{ComponentCount}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ComponentType.ToString(sb).Append('_').Append(ComponentCount);
		}

		public ScalarType ComponentType { get; }
		public int ComponentCount { get; }
	}

	public class MatrixType : Type
	{
		public MatrixType(VectorType vectorType, int columnCount)
		{
			ColumnType = vectorType;
			ColumnCount = columnCount;
		}

		public override string ToString()
		{
			return $"{ColumnType}x{ColumnCount}";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append(ColumnType).Append('x').Append(ColumnCount);
		}

		public VectorType ColumnType { get; }
		public int ColumnCount { get; }
		public int RowCount => ColumnType.ComponentCount;
	}

	public class ImageType : Type
	{
		public ImageType(Type sampledType, Dim dim, int depth, bool isArray, bool isMultisampled, int sampleCount,
			ImageFormat imageFormat, AccessQualifier accessQualifier)
		{
			SampledType = sampledType;
			Dim = dim;
			Depth = depth;
			IsArray = isArray;
			IsMultisampled = isMultisampled;
			SampleCount = sampleCount;
			Format = imageFormat;
			AccessQualifier = accessQualifier;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			switch (AccessQualifier)
			{
				case AccessQualifier.ReadWrite:
					sb.Append("read_write ");
					break;
				case AccessQualifier.WriteOnly:
					sb.Append("write_only ");
					break;
				case AccessQualifier.ReadOnly:
					sb.Append("read_only ");
					break;
			}

			sb.Append("Texture");
			switch (Dim)
			{
				case Dim.Dim1D:
					sb.Append("1D");
					break;
				case Dim.Dim2D:
					sb.Append("2D");
					break;
				case Dim.Dim3D:
					sb.Append("3D");
					break;
				case Dim.Cube:
					sb.Append("Cube");
					break;
			}

			if (IsMultisampled)
			{
				sb.Append("MS");
			}
			if (IsArray)
			{
				sb.Append("Array");
			}
			return sb;
		}

		public Type SampledType { get; }
		public Dim Dim { get; }
		public int Depth { get; }
		public bool IsArray { get; }
		public bool IsMultisampled { get; }
		public int SampleCount { get; }
		public ImageFormat Format { get; }
		public AccessQualifier AccessQualifier { get; }
	}

	public class SamplerType : Type
	{
		public override string ToString()
		{
			return "sampler";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return sb.Append("sampler");
		}
	}

	public class SampledImageType : Type
	{
		public SampledImageType(ImageType imageType)
		{
			ImageType = imageType;
		}

		public override string ToString()
		{
			return $"{ImageType}Sampled";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ImageType.ToString(sb).Append("Sampled");
		}

		public ImageType ImageType { get; }
	}

	public class ArrayType : Type
	{
		public ArrayType(Type elementType, int elementCount)
		{
			ElementType = elementType;
			ElementCount = elementCount;
		}

		public override string ToString()
		{
			return $"{ElementType}[{ElementCount}]";
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			return ElementType.ToString(sb).Append('[').Append(ElementCount).Append(']');
		}

		public int ElementCount { get; }
		public Type ElementType { get; }
	}

	public class RuntimeArrayType : Type
	{
		public RuntimeArrayType(Type elementType)
		{
			ElementType = elementType;
		}

		public Type ElementType { get; }
	}

	public class StructType : Type
	{
		public StructType(IReadOnlyList<Type> memberTypes)
		{
			MemberTypes = memberTypes;
			memberNames_ = new List<string>();

			for (int i = 0; i < memberTypes.Count; ++i)
			{
				memberNames_.Add(string.Empty);
			}
		}

		public void SetMemberName(uint member, string name)
		{
			memberNames_[(int)member] = name;
		}

		public override string ToString()
		{
			StringBuilder sb = new StringBuilder();
			ToString(sb);
			return sb.ToString();
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			sb.Append("struct {");
			for (int i = 0; i < MemberTypes.Count; ++i)
			{
				Type memberType = MemberTypes[i];
				memberType.ToString(sb);
				if (!string.IsNullOrEmpty(memberNames_[i]))
				{
					sb.Append(' ');
					sb.Append(MemberNames[i]);
				}

				sb.Append(';');
				if (i < (MemberTypes.Count - 1))
				{
					sb.Append(' ');
				}
			}
			sb.Append('}');
			return sb;
		}

		public IReadOnlyList<Type> MemberTypes { get; }
		public IReadOnlyList<string> MemberNames => memberNames_;

		private List<string> memberNames_;
	}

	public class OpaqueType : Type
	{
	}

	public class PointerType : Type
	{
		public PointerType(StorageClass storageClass, Type type)
		{
			StorageClass = storageClass;
			Type = type;
		}

		public PointerType(StorageClass storageClass)
		{
			StorageClass = storageClass;
		}

		public void ResolveForwardReference(Type t)
		{
			Type = t;
		}

		public override string ToString()
		{
			if (Type == null)
			{
				return $"{StorageClass} *";
			}
			else
			{
				return $"{StorageClass} {Type}*";
			}
		}

		public override StringBuilder ToString(StringBuilder sb)
		{
			sb.Append(StorageClass.ToString()).Append(' ');
			if (Type != null)
			{
				Type.ToString(sb);
			}
			sb.Append('*');
			return sb;
		}

		public StorageClass StorageClass { get; }
		public Type Type { get; private set; }
	}

	public class FunctionType : Type
	{
		public FunctionType(Type returnType, IReadOnlyList<Type> parameterTypes)
		{
			ReturnType = returnType;
			ParameterTypes = parameterTypes;
		}

		public Type ReturnType { get; }
		public IReadOnlyList<Type> ParameterTypes { get; }
	}

	public class EventType : Type
	{
	}

	public class DeviceEventType : Type
	{
	}

	public class ReserveIdType : Type
	{
	}

	public class QueueType : Type
	{
	}

	public class PipeType : Type
	{
	}

	public class PipeStorage : Type
	{
	}

	public class NamedBarrier : Type
	{
	}
}

```

`docs/api/index.md`:

```md
# API Documentation
This section contains all the generated documentation for the project.

```

`docs/articles/CommonIssues.md`:

```md
# Common Issues

## Why doesn't AssetRipper export Mono Scripts from my bundle?

Except in extremely rare and special cases, there are no mono scripts stored in asset bundles. 

Mono scripts are stored in C# assemblies, ie `.dll` files. The contents of these assemblies can be viewed in [ILSpy](https://github.com/icsharpcode/ILSpy).

> Note: C++ assemblies also use the `.dll` extension. If C# code can't be viewed after opening a `.dll` file in ILSpy, then it's not a C# assembly.

In order to export mono scripts with asset bundle assets, the relevant assemblies must be included in the import. You can do this by: 
1. Place all the assemblies in a folder. 
2. Select that folder and the assetbundle(s) being ripped. 
3. Drag those into AssetRipper at the same time.

If it worked, you'll get this line in the log:
```
Import : Files use the 'Mono' scripting backend.
```
If it didn't work, there will be this line:
```
Import : Files use the 'Unknown' scripting backend.
```

For IL2Cpp games, use [Cpp2IL](https://github.com/SamboyCoding/Cpp2IL) to generate assemblies. [Unhollowed assemblies](https://github.com/knah/Il2CppAssemblyUnhollower) used in modding will not work.

## Duplicate Assemblies

This has a signature error in the log file.
```
Could not add pe assembly to name dictionary!
```
It is almost always caused by having two assemblies with the same name in the Managed folder or any subfolders. Note that the "name" in this case is the assembly name shown in a decompiler not the file name.

## Modified Assemblies

> This can include publicized assemblies and/or unhollowed assemblies.

Modified assemblies almost always cause read errors when used in AssetRipper. Here are some common changes that are known to cause lots of problems:
* Publicizing an assembly changes field deserialization on Monobehaviours.
* Attribute removal can also change field deserialization.
* Modified method bodies can cause decompiler errors.
```

`docs/articles/Credits.md`:

```md
# Credits

## Licensed Works

[AsmResolver](https://github.com/Washi1337/AsmResolver) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/AsmResolver.md).

[Avalonia](https://github.com/AvaloniaUI/Avalonia) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Avalonia.md).

[CommandLineParser](https://github.com/commandlineparser/commandline) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/CommandLineParser.md).

[Cpp2IL](https://github.com/SamboyCoding/Cpp2IL) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Cpp2IL.md).

Crunch is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Crunch.md).

[darkfx](https://github.com/steffen-wilke/darkfx) is licensed under the [MIT License](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/darkfx.md).

[Fmod5Sharp](https://github.com/SamboyCoding/Fmod5Sharp) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Fmod5Sharp.md).

[ICSharpCode.Decompiler](https://github.com/icsharpcode/ILSpy) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/ILSpy.md).

[ImageSharp](https://github.com/SixLabors/ImageSharp) is licensed under the [Apache 2.0 license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/ImageSharp.md).

[K4os.Compression.LZ4](https://github.com/MiloszKrajewski/K4os.Compression.LZ4) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Lz4.md).

LibOgg and LibVorbis are licensed from [Xiph](https://www.xiph.org/) under the [BSD 3-Clause License](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/Xiph.md).

[LibVLCSharp](https://github.com/videolan/libvlcsharp) is licensed under the [LGPL-2.1 License](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/LibVLCSharp.md)

[MeshSharp](https://github.com/AssetRipper/MeshSharp) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/MeshSharp.md).

[MessageBox.Avalonia](https://github.com/AvaloniaCommunity/MessageBox.Avalonia) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/MessageBoxAvalonia.md).

[Mono.Cecil](https://github.com/jbevain/cecil) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/MonoCecil.md).

[NAudio](https://github.com/naudio/NAudio) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/NAudio.md).

[NAudio.Lame](https://github.com/Corey-M/NAudio.Lame) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/NAudioLame.md).

[NAudio.Vorbis](https://github.com/naudio/Vorbis) is licensed under the [MIT License](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/NAudioVorbis.md).

[NVorbis](https://github.com/NVorbis/NVorbis) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/NVorbis.md).

[SharpCompress](https://github.com/adamhathcock/sharpcompress) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/SharpCompress.md).

[SharpGLTF](https://github.com/vpenades/SharpGLTF) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/SharpGLTF.md).

[SharpZipLib](https://github.com/icsharpcode/SharpZipLib) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/SharpZipLib.md).

[texgenpack](https://github.com/hglm/texgenpack) is licensed under a [permissive license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/texgenpack.md).

[YamlDotNet](https://github.com/aaubry/YamlDotNet) is licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/YamlDotNet.md).

## Other

This began as a fork of [mafaca](https://github.com/mafaca)'s [uTinyRipper](https://github.com/mafaca/UtinyRipper) project licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/uTinyRipper.md).

It has borrowed code from [Perfare](https://github.com/Perfare)'s [AssetStudio](https://github.com/Perfare/AssetStudio) project licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/AssetStudio.md).

It has borrowed code from [spacehamster](https://github.com/spacehamster)'s [uTinyRipperExporter](https://github.com/spacehamster/UtinyRipperExporter) project licensed under the [MIT license](https://github.com/AssetRipper/AssetRipper/blob/master/Licenses/uTinyRipperExporter.md).
```

`docs/articles/Downloads.md`:

```md
# Downloads 

## Releases [![](https://img.shields.io/github/v/release/AssetRipper/AssetRipper)](https://github.com/AssetRipper/AssetRipper/releases/latest)

Whenever I feel significant improvements have been made, I post an official release. 

Release notes can be found on the [latest release page](https://github.com/AssetRipper/AssetRipper/releases/latest).

### GUI Version
* [Windows](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperGUI_win64.zip)
* [Mac](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperGUI_mac64.zip)
* [Linux](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperGUI_linux64.zip)

### Console Version
* [Windows](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperConsole_win64.zip)
* [Mac](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperConsole_mac64.zip)
* [Linux](https://github.com/AssetRipper/AssetRipper/releases/latest/download/AssetRipperConsole_linux64.zip)

## Pre-Releases [![](https://img.shields.io/github/v/release/AssetRipper/AssetRipper?include_prereleases&label=pre-release)](https://github.com/AssetRipper/AssetRipper/releases)

Occasionally, I'll do a pre-release when I want to showcase an experimental feature. 

These pre-releases can be found in the list of [releases](https://github.com/AssetRipper/AssetRipper/releases).

## Alpha Builds [![](https://img.shields.io/github/workflow/status/AssetRipper/AssetRipper/Publish/master)](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master)

For advanced users, every commit is automatically built into an alpha build with Github Actions. 

### GUI Version
* [Windows](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperGUI_win64.zip)
* [Mac](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperGUI_mac64.zip)
* [Linux](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperGUI_linux64.zip)

### Console Version
* [Windows](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperConsole_win64.zip)
* [Mac](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperConsole_mac64.zip)
* [Linux](https://nightly.link/AssetRipper/AssetRipper/workflows/publish/master/AssetRipperConsole_linux64.zip)
```

`docs/articles/Requirements.md`:

```md
# Requirements:

If you want to build a solution, you'll need:

* [.NET 6](https://dotnet.microsoft.com/download/dotnet/6.0)
* Compiler with C# 10 syntax support, such as:
  * [Visual Studio 2022](https://visualstudio.microsoft.com/downloads/)
  * [Visual Studio Code](https://code.visualstudio.com/Download)
  * [JetBrains Rider](https://www.jetbrains.com/rider/) (proprietary)

If you want to run binary files, you need to install:

* [Unity 2017.3.0f3 or greater](https://unity3d.com/get-unity/download/archive) (NOTE: your editor version must be no less than the game's version)
 
## Linux Dependencies

If you're running AssetRipper on Linux, there are a few additional dependencies:

* [VLC Media Player](https://www.videolan.org/)
```

`docs/articles/RoadMap.md`:

```md
# Development Roadmap

## 0.2.1.0
This release will be primarily focused on cleaning up and refactoring the project.

* Mesh export - STL, OBJ, FBX, PLY, GLB
  * Convert Unified Exporter to the new system
  * Convert GLB Exporter to the new system
  * Use nuget package?
* Cleanup legacy code
  * Move documentation on legacy code to a suitable home
  * Remove the `Classes` and `Converters` namespaces
  * Remove any additional legacy code
  * Merge the common project back into the core project

## 0.2.X.0
These releases will likely focus on preparing for the next major milestone.

* Remove native dependencies
  * Replace ogg and vorbis with managed code
  * Port essential texture decoding code to C#
* Make all dependencies trimmable
* Nuget feed for source generated code and forked dependencies
* Switch to AsmResolver and the Cpp2IL rewrite
* Segregating the codebase into more distinct layers

## 0.3.0.0 / 1.0.0.0
This release will focus on improving the user experience by overhauling the GUI

* Improved UI performance
* Improved Asset previews
  * Preview decompiled script
  * Add a Mesh preview
  * Add a Material preview
  * Add a TypeTree Viewer
  * Improve the Audio preview
    * Fast-forward and rewind
    * Seek-bar for selecting playback position
* Preferences window
  * Adjustable background color/theme
* Window for licensed works
* NativeAOT compilation for better performance while loading and extracting

## Planned But Unscheduled
* Import
  * Script Import
    * Use type trees for deserialization when available
  * Asset Loading
    * Extract assets and save to disk for lower ram usage
* Export
  * Model Export
    * FBX (full)
    * GLB (full)
    * PMX (maybe)
    * DAE (aka Collada)
    * Split combined meshes back into the original set of static meshes
    * Unified mesh export
  * Script Export
    * Hybrid script export
    * Assembly renaming
    * Improve script decompilation quality with ILSpy's whole project decompilation method
  * Audio Export
    * WWise audio extraction
  * Shader Export
    * Replace all shaders on materials with a built-in shader (for example, the Standard shader)
  * Miscellaneous Export
    * Copy plugins folder into output
  * Selective Export
    * Export Selected object to folder
    * Export Selected object to compressed zip file
* UI
  * Audio preview
    * Visual wave form display
  * Asset preview
    * Add a Hex Viewer
  * Scene preview
  * Font preview
  * Asset editing

## Concept Ideas
> Note: This is just a collection of ideas. These might not be desirable or feasible, so many of them might never be implemented. Do not interpret their inclusion here as any form of commitment.

* GUI quality of life features
  * Font setting
  * Configurable keybindings
* Console
  * Enterable commands
* Find all references
* Search Window
  * Dedicated window
  * Filters for various asset types
  * Filters for files
  * Might be redundant due to tree view search
* Tree View Search
  * Filters for various asset types
  * Name filter
  * Rows limit
  * Result count
  * Option to group resources
* Tabs
  * Inspector Tab
    * Tag
    * Layer
    * ID
    * File name
    * Asset Specific Properties
      * Sortable
      * Selectable with indepth description below
  * Moveable Tabs
  * Error Tab
* Import Settings
  * Ignore scenes option
  * Import bundle as level
  * Assembly de-obfuscation
* Performance Improvements
  * Asynchronous import/export
* Filtered Export
  * Resources (png, wav, avi, obj, ...)
  * Prefabs
  * Scripts
* Asset Bundle Construction
  * Editing and Repacking of games and asset bundles
  * Asset Header Editor
  * Asset Duplication and Creation
  * Asset Editing and Replacement
  * Copy and paste assets
  * Prefab Creation
* Asset Exporting
  * Video Export (avi, mp4, etc)
  * Allow saving any text information to a text file
    * Alternatively, ensure that all text can be selected and copied
  * Export as Prefab
  * Export as Unitypackage
  * Node Dump
* Asset Previews
  * Meshes
    * Colored semi-transparency
    * Triangle count
    * FPS meter
    * Corner cube for orientation
    * XYZ axis for orientation
    * Toggle face cull
    * Wireframe option
  * Textures
    * Background options (for example: checkers, white, black, default)
    * Select the color channels to display
      * For example, disable the alpha channel
      * Or show only the blue channel
  * Font Assets
  * Video Display
  * Animations
  * Scripts
    * view as text
    * notify if script missing
```

`docs/articles/RunningOnMac.md`:

```md
# Running on mac
In order to run Asset Ripper on mac, you'll first need to have everything listed in the [requirements](https://assetripper.github.io/AssetRipper/articles/Requirements.html) tab.

## Running the GUI version
If you're done with the requirements, lets see how to run the GUI version.

First, you'll need to download the GUI release from [here](https://github.com/AssetRipper/AssetRipper/releases).

Make sure you download the `AssetRipperGUI_mac64.zip` file as shown below.

![001](images/RunningOnMac/001.png)

After downloading, right click and open the file to extract as shown below.

![002](images/RunningOnMac/002.png)

After extracting, you should see this folder named `AssetRipperGUI_mac64`.

![003](images/RunningOnMac/003.png)

And inside that folder, there should be many other files:

![004](images/RunningOnMac/004.png)

You should also see this file called `AssetRipper`.

![005](images/RunningOnMac/005.png)

Now go back to the `AssetRipperGUI_mac64` folder and select it. Then go to `Finder`, `Services`, `New Terminal at Folder` as shown.

![006](images/RunningOnMac/006.png)

Now you should see the terminal open:

![007](images/RunningOnMac/007.png)

Now you'll need to type in the following command and press `enter`:

```
./AssetRipper
```

Then you should see an error saying `-bash: ./AssetRipper: Permission denied`.

![008](images/RunningOnMac/008.png)

To fix that, you'll need to type in this command:

```
chmod +x AssetRipper
```
After entering that, you should see an empty line

![009](images/RunningOnMac/009.png)

Now again try the following command and it should work.

```
./AssetRipper
```

Now something like this should pop up:

![010](images/RunningOnMac/010.png)

Click cancel. To verify that, you'll need to open system preferences using `⌘ + space` and search for `System preferences` and press `enter`. Then inside, find for `Security & Privacy` as shown below:

![011](images/RunningOnMac/011.png)

Now go to the `General` tab:

![012](images/RunningOnMac/012.png)

And at the bottom, something like this should popup. Click Allow Anyway:

![013](images/RunningOnMac/013.png)

Now again try this command:

```
./AssetRipper
```

Then it will show something like this, click Open:

![014](images/RunningOnMac/014.png)

Then things like this will popup, click OK and do the same steps shown above to open them:

![015](images/RunningOnMac/015.png)

![016](images/RunningOnMac/016.png)

Like that you should see multiple popups, click OK and allow them.

After a while, you should see Asset Ripper GUI open:

![017](images/RunningOnMac/017.png)

Now lets say you got it opened, but you closed it and want to open it again. But luckily, you won't need to follow all the steps above to open again!

Just go to the `AssetRipperGUI_mac64` folder and double click this file and it should open again!

![018](images/RunningOnMac/018.png)

And there you have it :)

![019](images/RunningOnMac/019.png)

```

`docs/articles/intro.md`:

```md
# Introduction

Welcome to the articles section. Here you can find information about the project and its future.
```

`docs/articles/toc.yml`:

```yml
- name: Introduction
  href: intro.md
- name: Downloads
  href: Downloads.md
- name: Common Issues
  href: CommonIssues.md
- name: Requirements
  href: Requirements.md
- name: Road Map
  href: RoadMap.md
- name: Running on Mac
  href: RunningOnMac.md
- name: Credits
  href: Credits.md

```

`docs/docfx.json`:

```json
{
  "metadata": [
    {
      "src": [
        {
          "src": "../",
          "files": [
            "**.csproj",
            "**.sln"
          ]
        }
      ],
      "dest": "api",
      "disableGitFeatures": false,
      "disableDefaultFilter": false
    }
  ],
  "build": {
    "content": [
      {
        "files": [
          "api/**.yml",
          "api/index.md"
        ]
      },
      {
        "files": [
          "articles/**.md",
          "articles/**/toc.yml",
          "toc.yml",
          "*.md"
        ]
      }
    ],
    "resource": [
      {
        "files": [
          "images/**",
          "articles/images/**"
        ]
      }
    ],
    "overwrite": [
      {
        "files": [
          "apidoc/**.md"
        ],
        "exclude": [
          "obj/**",
          "_site/**"
        ]
      }
    ],
    "dest": "_site",
    "globalMetadataFiles": [],
    "fileMetadataFiles": [],
    "template": [
      "default",
      "templates/darkfx"
    ],
    "postProcessors": [],
    "markdownEngineName": "markdig",
    "noLangKeyword": false,
    "keepFileLink": false,
    "cleanupCacheHistory": false,
    "disableGitFeatures": false
  }
}
```

`docs/index.md`:

```md
# AssetRipper

[![AssetRipper Logo](https://github.com/AssetRipper/AssetRipper/raw/master/Media/Images/2D_Logo/AssetRipperLogoBackground.png)](https://github.com/AssetRipper/AssetRipper/raw/master/Media/Images/2D_Logo/AssetRipperLogoBackground.png)

[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/total.svg)](https://github.com/AssetRipper/AssetRipper/releases)
[![](https://img.shields.io/github/downloads/AssetRipper/AssetRipper/latest/total.svg)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://img.shields.io/github/v/release/AssetRipper/AssetRipper)](https://github.com/AssetRipper/AssetRipper/releases/latest)
[![](https://weblate.samboy.dev/widgets/assetripper/-/gui/svg-badge.svg)](http://weblate.samboy.dev/engage/assetripper/)

AssetRipper is a tool for extracting assets from serialized files (*CAB-*\*, *\*.assets*, *\*.sharedAssets*, etc.) and assets bundles (*\*.unity3d*, *\*.bundle*, etc.) and converting them into the native Unity engine format.

> Important note: This project is currently in an experimental state. Expect bugs and many changes.

Current supported versions: `3.4.0` to `2021.1.x`

# Donations

Thank you for considering to support me. I have normal expenses like food, electric, internet, and rent. Your donations help to ensure that I can continue to afford developing this project. Anyone with a positive lifetime contribution is entitled to the Donator role on the [Discord server](https://discord.gg/XqXa53W2Yh).

[Patreon](https://www.patreon.com/ds5678)

[Paypal](https://paypal.me/ds5678)

# Release Schedule

[Releases](https://github.com/AssetRipper/AssetRipper/releases) are put out once a week, usually on either Sunday or Monday.

# Discord [![](https://img.shields.io/discord/867514400701153281?color=blue&label=AssetRipper)](https://discord.gg/XqXa53W2Yh)

The development of this project has a dedicated [Discord server](https://discord.gg/XqXa53W2Yh). Feel free to come say hi. This is also an alternative location for people to post issues.


# Legal Disclaimers

AssetRipper is licensed under the [GNU General Public License v3.0](https://github.com/AssetRipper/AssetRipper/blob/master/LICENSE.md)

Please be aware that using or distributing the output from this software may be against copyright legislation in your jurisdiction. You are responsible for ensuring that you're not breaking any laws.

The full list of licensed works can be found on the [Credits](articles/Credits.md) page.

This software is not sponsored by or affiliated with Unity Technologies or its affiliates. "Unity" is a registered trademark of Unity Technologies or its affiliates in the U.S. and elsewhere.

```

`docs/templates/darkfx/partials/affix.tmpl.partial`:

```partial
{{!Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<div class="hidden-sm col-md-2" role="complementary">
  <div class="sideaffix">
    {{^_disableContribution}}
    <div class="contribution">
      <ul class="nav">
        {{#docurl}}
        <li>
          <a href="{{docurl}}" class="contribution-link">{{__global.improveThisDoc}}</a>
        </li>
        {{/docurl}}
        {{#sourceurl}}
        <li>
          <a href="{{sourceurl}}" class="contribution-link">{{__global.viewSource}}</a>
        </li>
        {{/sourceurl}}
      </ul>
    </div>
    {{/_disableContribution}}
    <div class="toggle-mode">
      <div class="icon">
        <i aria-hidden="true">☀</i>
      </div>
      <label class="switch">
        <input type="checkbox" id="switch-style">
        <span class="slider round"></span>
      </label>
      <div class="icon">
        <i aria-hidden="true">☾</i>
      </div>
    </div>

    <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
    <h5>{{__global.inThisArticle}}</h5>
    <div></div>
    <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
    </nav>
  </div>
</div>

```

`docs/templates/darkfx/partials/footer.tmpl.partial`:

```partial
{{!Copyright (c) Microsoft. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<footer>
  <div class="grad-bottom"></div>
  <div class="footer">
    <div class="container">
      <span class="pull-right">
        <a href="#top">Back to top</a>
      </span>
      <div class="pull-left">
        {{{_appFooter}}}
        {{^_appFooter}}<span>Generated by <strong>DocFX</strong></span>{{/_appFooter}}
      </div>
      <div class="toggle-mode pull-right visible-sm visible-xs">
        <div class="icon">
          <i aria-hidden="true">☀</i>
        </div>
        <label class="switch">
          <input type="checkbox" id="switch-style-m">
          <span class="slider round"></span>
        </label>
        <div class="icon">
          <i aria-hidden="true">☾</i>
        </div>
      </div>
    </div>
  </div>
  <script type="text/javascript" src="{{_rel}}styles/toggle-theme.js"></script>
</footer>
```

`docs/templates/darkfx/partials/head.tmpl.partial`:

```partial
{{!Copyright (c) Oscar Vasquez. All rights reserved. Licensed under the MIT license. See LICENSE file in the project root for full license information.}}

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>{{#title}}{{title}}{{/title}}{{^title}}{{>partials/title}}{{/title}} {{#_appTitle}}| {{_appTitle}} {{/_appTitle}}</title>
  <meta name="viewport" content="width=device-width">
  <meta name="title" content="{{#title}}{{title}}{{/title}}{{^title}}{{>partials/title}}{{/title}} {{#_appTitle}}| {{_appTitle}} {{/_appTitle}}">
  <meta name="generator" content="docfx {{_docfxVersion}}">
  {{#_description}}<meta name="description" content="{{_description}}">{{/_description}}
  <link rel="shortcut icon" href="{{_rel}}{{{_appFaviconPath}}}{{^_appFaviconPath}}favicon.ico{{/_appFaviconPath}}">
  <link rel="stylesheet" href="{{_rel}}styles/docfx.vendor.css">
  <link rel="stylesheet" href="{{_rel}}styles/docfx.css">
  <link rel="stylesheet" href="{{_rel}}styles/main.css">
  <meta property="docfx:navrel" content="{{_navRel}}">
  <meta property="docfx:tocrel" content="{{_tocRel}}">
  {{#_noindex}}<meta name="searchOption" content="noindex">{{/_noindex}}
  {{#_enableSearch}}<meta property="docfx:rel" content="{{_rel}}">{{/_enableSearch}}
  {{#_enableNewTab}}<meta property="docfx:newtab" content="true">{{/_enableNewTab}}
</head>
```

`docs/templates/darkfx/styles/main.css`:

```css
:root, body.dark-theme {
  --color-foreground: #ccd5dc;
  --color-navbar: #66666d;
  --color-breadcrumb: #999;
  --color-underline: #ddd;
  --color-toc-hover: #fff;
  --color-background: #2d2d30;
  --color-background-subnav: #333337;
  --color-background-dark: #1e1e1e;
  --color-background-table-alt: #212123;
  --color-background-quote: #69696e;
}

body.light-theme {
  --color-foreground: #171717;
  --color-breadcrumb: #4a4a4a;
  --color-toc-hover: #4c4c4c;
  --color-background: #ffffff;
  --color-background-subnav: #f5f5f5;
  --color-background-dark: #ddd;
  --color-background-table-alt: #f9f9f9;
}

body {
  color: var(--color-foreground);
  line-height: 1.5;
  font-size: 14px;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  word-wrap: break-word;
  background-color: var(--color-background);
}

.btn.focus, .btn:focus, .btn:hover {
  color: var(--color-foreground);
}

h1 {
  font-weight: 600;
  font-size: 32px;
}

h2 {
  font-weight: 600;
  font-size: 24px;
  line-height: 1.8;
}

h3 {
  font-weight: 600;
  font-size: 20px;
  line-height: 1.8;
}

h5 {
  font-size: 14px;
  padding: 10px 0px;
}

article h1, article h2, article h3, article h4 {
  margin-top: 35px;
  margin-bottom: 15px;
}

article h4 {
  padding-bottom: 8px;
  border-bottom: 2px solid var(--color-underline);
}

.navbar-brand>img {
  color: var(--color-background);
}

.navbar {
  border: none;
}

.subnav {
  border-top: 1px solid var(--color-underline);
  background-color: var(--color-background-subnav);
}

.sidenav, .fixed_header, .toc {
  background-color: var(--color-background);
}

.navbar-inverse {
  background-color: var(--color-background-dark);
  z-index: 100;
}

.navbar-inverse .navbar-nav>li>a, .navbar-inverse .navbar-text {
  color: var(--color-navbar);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid transparent;
  padding-bottom: 12px;
}

.navbar-inverse .navbar-nav>li>a:focus, .navbar-inverse .navbar-nav>li>a:hover {
  color: var(--color-foreground);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid var(--color-background-subnav);
  transition: all ease 0.25s;
}

.navbar-inverse .navbar-nav>.active>a, .navbar-inverse .navbar-nav>.active>a:focus, .navbar-inverse .navbar-nav>.active>a:hover {
  color: var(--color-foreground);
  background-color: var(--color-background-dark);
  border-bottom: 3px solid var(--color-foreground);
  transition: all ease 0.25s;
}

.navbar-form .form-control {
  border: none;
  border-radius: 0;
}

.light-theme .navbar-brand svg {
  filter: brightness(20%);
}

.toc .level1>li {
  font-weight: 400;
}

.toc .nav>li>a {
  color: var(--color-foreground);
}

.sidefilter {
  background-color: var(--color-background);
  border-left: none;
  border-right: none;
}

.sidefilter {
  background-color: var(--color-background);
  border-left: none;
  border-right: none;
}

.toc-filter {
  padding: 10px;
  margin: 0;
  background-color: var(--color-background);
}

.toc-filter>input {
  border: none;
  border-radius: unset;
  background-color: var(--color-background-subnav);
  padding: 5px 0 5px 20px;
  font-size: 90%
}

.toc-filter>.clear-icon {
  position: absolute;
  top: 17px;
  right: 15px;
}

.toc-filter>input:focus {
  color: var(--color-foreground);
  transition: all ease 0.25s;
}

.toc-filter>.filter-icon {
  display: none;
}

.sidetoc>.toc {
  background-color: var(--color-background);
  overflow-x: hidden;
}

.sidetoc {
  background-color: var(--color-background);
  border: none;
}

.alert {
  background-color: inherit;
  border: none;
  padding: 10px 0;
  border-radius: 0;
}

.alert>p {
  margin-bottom: 0;
  padding: 5px 10px;
  border-bottom: 1px solid;
  background-color: var(--color-background-dark);
}

.alert>h5 {
  padding: 10px 15px;
  margin-top: 0;
  margin-bottom: 0;
  text-transform: uppercase;
  font-weight: bold;
  border-top: 2px solid;
  background-color: var(--color-background-dark);
  border-radius: none;
}

.alert>ul {
  margin-bottom: 0;
  padding: 5px 40px;
}

.alert-info {
  color: #1976d2;
}

.alert-warning {
  color: #f57f17;
}

.alert-danger {
  color: #d32f2f;
}

pre {
  padding: 9.5px;
  margin: 0 0 10px;
  font-size: 13px;
  word-break: break-all;
  word-wrap: break-word;
  background-color: var(--color-background-dark);
  border-radius: 0;
  border: none;
}

code {
  background: var(--color-background-dark) !important;
  border-radius: 2px;
}

.hljs {
  color: var(--color-foreground);
}

.toc .nav>li.active>.expand-stub::before, .toc .nav>li.in>.expand-stub::before, .toc .nav>li.in.active>.expand-stub::before, .toc .nav>li.filtered>.expand-stub::before {
  content: "▾";
}

.toc .nav>li>.expand-stub::before, .toc .nav>li.active>.expand-stub::before {
  content: "▸";
}

.affix ul ul>li>a:before {
  content: "|";
}

.breadcrumb {
  background-color: var(--color-background-subnav);
}

.breadcrumb .label.label-primary {
  background: #444;
  border-radius: 0;
  font-weight: normal;
  font-size: 100%;
}

#breadcrumb .breadcrumb>li a {
  border-radius: 0;
  font-weight: normal;
  font-size: 85%;
  display: inline;
  padding: 0 .6em 0;
  line-height: 1;
  text-align: center;
  white-space: nowrap;
  vertical-align: baseline;
  color: var(--color-breadcrumb);
}

#breadcrumb .breadcrumb>li a:hover {
  color: var(--color-foreground);
  transition: all ease 0.25s;
}

.breadcrumb>li+li:before {
  content: "⯈";
  font-size: 75%;
  color: var(--color-background-dark);
  padding: 0;
}

.light-theme .breadcrumb>li+li:before {
  color: var(--color-foreground)
 }

.toc .level1>li {
  font-weight: 600;
  font-size: 130%;
  padding-left: 5px;
}

.footer {
  border-top: none;
  background-color: var(--color-background-dark);
  padding: 15px 0;
  font-size: 90%;
}

.toc .nav>li>a:hover, .toc .nav>li>a:focus {
  color: var(--color-toc-hover);
  transition: all ease 0.1s;
}

.form-control {
  background-color: var(--color-background-subnav);
  border: none;
  border-radius: 0;
  -webkit-box-shadow: none;
  box-shadow: none;
}

.form-control:focus {
  border-color: #66afe9;
  outline: 0;
  -webkit-box-shadow: none;
  box-shadow: none;
}

input#search-query:focus {
  color: var(--color-foreground);
}

.table-bordered, .table-bordered>tbody>tr>td, .table-bordered>tbody>tr>th, .table-bordered>tfoot>tr>td, .table-bordered>tfoot>tr>th, .table-bordered>thead>tr>td, .table-bordered>thead>tr>th {
  border: 1px solid var(--color-background-dark);
}

.table-striped>tbody>tr:nth-of-type(odd) {
  background-color: var(--color-background-table-alt);
}

blockquote {
  padding: 10px 20px;
  margin: 0 0 10px;
  font-size: 110%;
  border-left: 5px solid var(--color-background-quote);
  color: var(--color-background-quote);
}

.pagination>.disabled>a, .pagination>.disabled>a:focus, .pagination>.disabled>a:hover, .pagination>.disabled>span, .pagination>.disabled>span:focus, .pagination>.disabled>span:hover {
  background-color: var(--color-background-subnav);
  border-color: var(--color-background-subnav);
}

.breadcrumb>li, .pagination {
  display: inline;
}

.tabGroup a[role="tab"] {
  border-bottom: 2px solid var(--color-background-dark);
}

.tabGroup a[role="tab"][aria-selected="true"] {
  color: var(--color-foreground);
}

.tabGroup section[role="tabpanel"] {
  border: 1px solid var(--color-background-dark);
}

.sideaffix > div.contribution > ul > li > a.contribution-link:hover {
  background-color: var(--color-background);
}

.switch {
  position: relative;
  display: inline-block;
  width: 40px;
  height: 20px;
}

.switch input { 
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: #ccc;
  -webkit-transition: .4s;
  transition: .4s;
}

.slider:before {
  position: absolute;
  content: "";
  height: 14px;
  width: 14px;
  left: 4px;
  bottom: 3px;
  background-color: white;
  -webkit-transition: .4s;
  transition: .4s;
}

input:checked + .slider {
  background-color: #337ab7;
}

input:focus + .slider {
  box-shadow: 0 0 1px #337ab7;
}

input:checked + .slider:before {
  -webkit-transform: translateX(19px);
  -ms-transform: translateX(19px);
  transform: translateX(19px);
}

/* Rounded sliders */
.slider.round {
  border-radius: 20px;
}

.slider.round:before {
  border-radius: 50%;
}
.toggle-mode .icon {
  display: inline-block;
}

.toggle-mode .icon i {
  font-style: normal;
  font-size: 17px;
  display: inline-block;
  padding-right: 7px;
  padding-left: 7px;
  vertical-align: middle;
}

@media (min-width: 1600px) {
  .container {
    width: 100%;
  }
  .sidefilter {
    width: 18%;
  }
  .sidetoc {
    width: 18%;
  }
  .article.grid-right {
    margin-left: 19%;
  }
  .sideaffix {
    width: 11.5%;
  }
  .affix ul>li.active>a {
    white-space: initial;
  }
  .affix ul>li>a {
    width: 99%;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
}
```

`docs/templates/darkfx/styles/toggle-theme.js`:

```js
const sw = document.getElementById("switch-style"), sw_mobile = document.getElementById("switch-style-m"), b = document.body;
if (b) {
  function toggleTheme(target, dark) {
    target.classList.toggle("dark-theme", dark)
    target.classList.toggle("light-theme", !dark)
  }

  function switchEventListener() {
    toggleTheme(b, this.checked);
    if (window.localStorage) {
      this.checked ? localStorage.setItem("theme", "dark-theme") : localStorage.setItem("theme", "light-theme")
    }
  }

  var isDarkTheme = !window.localStorage || !window.localStorage.getItem("theme") || window.localStorage && localStorage.getItem("theme") === "dark-theme";

  if(sw && sw_mobile){
    sw.checked = isDarkTheme;
    sw_mobile.checked = isDarkTheme;

    sw.addEventListener("change", switchEventListener);
    sw_mobile.addEventListener("change", switchEventListener);
    
    // sync state between switches
    sw.addEventListener("change", function() {
      sw_mobile.checked = this.checked;
    });

    sw_mobile.addEventListener("change", function() {
      sw.checked = this.checked;
    });
  }

  toggleTheme(b, isDarkTheme);
}
```

`docs/toc.yml`:

```yml
- name: Articles
  href: articles/
- name: Api Documentation
  href: api/
  homepage: api/index.md

```

`generate_all.sh`:

```sh
#!/bin/bash

# exit when any command fails
set -e

path_to_OutputFolder="./Output"
path_to_JsonFolder="./TypeTreeDumps/InfoJson"
path_to_AssemblyDumper="./AssemblyDumper.ConsoleApp/bin/x64/ReleaseLinux/net6.0/AssemblyDumper.ConsoleApp"
path_to_RuntimeLibrary="./Libraries/System.Runtime.dll"
path_to_CollectionsLibrary="./Libraries/System.Collections.dll"

mkdir $path_to_OutputFolder

generate() {
    j=$1
    echo Generating from $j...
    $path_to_AssemblyDumper --output $path_to_OutputFolder --runtime $path_to_RuntimeLibrary --collections $path_to_CollectionsLibrary $path_to_JsonFolder/$j
}

if [ $# = 0 ]
then
    vers=($(./get_names.sh))
else
    vers=($(./get_names.sh $1))
fi

echo Generating assemblies for ${#vers[@]} Unity versions
for ((i=0; i<${#vers[@]}; i++)); 
do
    generate ${vers[i]}
done
```

`get_names.sh`:

```sh
#!/bin/bash

path_to_JsonFolder="./TypeTreeDumps/InfoJson"
path_from_JsonFolder="../.."

if [ $# != 0 ] && [ $# != 1 ]
then
    # Incorrect number of arguments
    exit 2
fi
if [ $# = 1 ] && [ ${#1} = 0 ]
then
    # Argument 1 has zero length
    exit 3
fi

cd $path_to_JsonFolder
vers=($(ls *.json | sort -t. -k1,1n -k2,2n -k3,3n))
cd $path_from_JsonFolder

for ((i=0; i<${#vers[@]}; i++)); 
do
    if [ $# = 0 ]
    then
        echo ${vers[i]}
    elif [ ${1:0:2} != "20" ]
    then
        if [ ${vers[i]:0:2} != "20" ]
        then
            echo ${vers[i]}
        fi
    elif [ ${vers[i]:0:4} = $1 ]
    then
        echo ${vers[i]}
    fi
done
```