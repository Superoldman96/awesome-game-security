Project Path: arc_gmh5225_Unity3D_Obfuscator_phw2m9q4

Source Tree:

```txt
arc_gmh5225_Unity3D_Obfuscator_phw2m9q4
├── Unity3DObfuscator
│   ├── AntiILDasmClass.cs
│   ├── AntiTamperingClass.cs
│   ├── App.config
│   ├── ExcludeStringsForm.Designer.cs
│   ├── ExcludeStringsForm.cs
│   ├── ExcludeStringsForm.resx
│   ├── ExcludeTypesForm.Designer.cs
│   ├── ExcludeTypesForm.cs
│   ├── ExcludeTypesForm.resx
│   ├── Exclusion.cs
│   ├── GlobalStrings.cs
│   ├── HelpForm.Designer.cs
│   ├── HelpForm.cs
│   ├── HelpForm.resx
│   ├── InjectHelper.cs
│   ├── MainClass.cs
│   ├── MainForm.Designer.cs
│   ├── MainForm.cs
│   ├── MainForm.resx
│   ├── ObfuscationSettings.cs
│   ├── ObfuscatorHelp.cs
│   ├── Program.cs
│   ├── Properties
│   │   ├── AssemblyInfo.cs
│   │   ├── Resources.Designer.cs
│   │   ├── Resources.resx
│   │   ├── Settings.Designer.cs
│   │   └── Settings.settings
│   ├── RenamingClass.cs
│   ├── StringDecryptionHelper.cs
│   ├── StringEncoding.cs
│   ├── StringEncryptionClass.cs
│   ├── Unity3DObfuscator.csproj
│   ├── Watermarking.cs
│   ├── bin
│   │   └── Debug
│   │       ├── Unity3DObfuscator.exe
│   │       ├── Unity3DObfuscator.exe.config
│   │       ├── Unity3DObfuscator.pdb
│   │       └── dnlib.dll
│   ├── clsNeoBuxTheme.cs
│   ├── dnlib.dll
│   └── obj
│       └── Debug
│           ├── CoreCompileInputs.cache
│           ├── DesignTimeResolveAssemblyReferences.cache
│           ├── DesignTimeResolveAssemblyReferencesInput.cache
│           ├── TemporaryGeneratedFile_036C0B5B-1481-4323-8D20-8F5ADCB23D92.cs
│           ├── TemporaryGeneratedFile_5937a670-0e60-4077-877b-f7221da3dda1.cs
│           ├── TemporaryGeneratedFile_E7A71F73-0F8D-4B9B-B56E-8E70B10BC5D3.cs
│           ├── Unity3DObfuscator.ExcludeStringsForm.resources
│           ├── Unity3DObfuscator.ExcludeTypesForm.resources
│           ├── Unity3DObfuscator.HelpForm.resources
│           ├── Unity3DObfuscator.MainForm.resources
│           ├── Unity3DObfuscator.Properties.Resources.resources
│           ├── Unity3DObfuscator.csproj.FileListAbsolute.txt
│           ├── Unity3DObfuscator.csproj.GenerateResource.Cache
│           ├── Unity3DObfuscator.csprojResolveAssemblyReference.cache
│           ├── Unity3DObfuscator.exe
│           └── Unity3DObfuscator.pdb
└── Unity3DObfuscator.sln

```

`Unity3DObfuscator.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio 15
VisualStudioVersion = 15.0.26228.9
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "Unity3DObfuscator", "Unity3DObfuscator\Unity3DObfuscator.csproj", "{65485E2B-FA14-4F59-BDE7-F4F3E7909321}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{65485E2B-FA14-4F59-BDE7-F4F3E7909321}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{65485E2B-FA14-4F59-BDE7-F4F3E7909321}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{65485E2B-FA14-4F59-BDE7-F4F3E7909321}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{65485E2B-FA14-4F59-BDE7-F4F3E7909321}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`Unity3DObfuscator/AntiILDasmClass.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    public class AntiILDasmClass
    {
        // AntiILDasm class.
        // Credit: The original function is from the ConfuserEx project.
        public void Execute()
        {
            if(!MainClass.Settings.AntiILDasm)
            {
                return;
            }
            TypeRef tRef = MainClass.MainModule.CorLibTypes.GetTypeRef("System.Runtime.CompilerServices", "SuppressIldasmAttribute");
            MemberRefUser ctor = new MemberRefUser(MainClass.MainModule, ".ctor", MethodSig.CreateInstance(MainClass.MainModule.CorLibTypes.Void), tRef);
            CustomAttribute attribute = new CustomAttribute(ctor);
            if(MainClass.MainModule.CustomAttributes.Contains(attribute))
            {
                return;
            }
            MainClass.MainModule.CustomAttributes.Add(attribute);
        }
    }
}

```

`Unity3DObfuscator/AntiTamperingClass.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    public class AntiTamperingClass
    {
        //Anti tampering class.
        public void ExecuteAntiTampering()
        {
            if(!MainClass.Settings.AntiTampering)
            {
                return;
            }
            string typeName = "╬.☻♥♦♣♠•◘○";
            string value = GlobalStrings.RandomString;
            Watermarking.AddCustomAttributeToAssembly(string.Empty, typeName, value);
            Watermarking.RemoveAttributeType(typeName);
            //The way the anti tampering works is by adding a custom attribute and removing its type directly from the assembly instead of deleting the attribute from the assembly first.
            //WARNING! Anti tampering may not work in some assemblies.
            //I figured this method by accident, lol! 
        }
    }
}

```

`Unity3DObfuscator/App.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>
```

`Unity3DObfuscator/ExcludeStringsForm.Designer.cs`:

```cs
namespace Unity3DObfuscator
{
    partial class ExcludeStringsForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.StringsList = new System.Windows.Forms.ListBox();
            this.MainTheme = new FormSkin.clsNeoBuxTheme();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.SearchExcludedStringsTxt = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.ExcludedStringsList = new System.Windows.Forms.ListBox();
            this.SearchStringsTxt = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.CloseBtn = new FormSkin.clsButtonPurple();
            this.RemoveBtn = new FormSkin.clsButtonOrange();
            this.AddBtn = new FormSkin.clsButtonGreen();
            this.MainTheme.SuspendLayout();
            this.SuspendLayout();
            // 
            // StringsList
            // 
            this.StringsList.FormattingEnabled = true;
            this.StringsList.ItemHeight = 15;
            this.StringsList.Location = new System.Drawing.Point(3, 65);
            this.StringsList.Name = "StringsList";
            this.StringsList.Size = new System.Drawing.Size(370, 334);
            this.StringsList.TabIndex = 5;
            // 
            // MainTheme
            // 
            this.MainTheme.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(239)))), ((int)(((byte)(239)))), ((int)(((byte)(242)))));
            this.MainTheme.BorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.MainTheme.Controls.Add(this.label4);
            this.MainTheme.Controls.Add(this.label3);
            this.MainTheme.Controls.Add(this.SearchExcludedStringsTxt);
            this.MainTheme.Controls.Add(this.label2);
            this.MainTheme.Controls.Add(this.ExcludedStringsList);
            this.MainTheme.Controls.Add(this.SearchStringsTxt);
            this.MainTheme.Controls.Add(this.label1);
            this.MainTheme.Controls.Add(this.StringsList);
            this.MainTheme.Controls.Add(this.CloseBtn);
            this.MainTheme.Controls.Add(this.RemoveBtn);
            this.MainTheme.Controls.Add(this.AddBtn);
            this.MainTheme.Customization = "AAAA/w==";
            this.MainTheme.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MainTheme.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.MainTheme.Image = null;
            this.MainTheme.Location = new System.Drawing.Point(0, 0);
            this.MainTheme.Movable = true;
            this.MainTheme.Name = "MainTheme";
            this.MainTheme.NoRounding = false;
            this.MainTheme.Sizable = false;
            this.MainTheme.Size = new System.Drawing.Size(754, 478);
            this.MainTheme.SmartBounds = true;
            this.MainTheme.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.MainTheme.TabIndex = 1;
            this.MainTheme.Text = "Exclude Strings";
            this.MainTheme.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.Transparent = false;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(379, 49);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(96, 15);
            this.label4.TabIndex = 12;
            this.label4.Text = "Excluded Strings:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(3, 47);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(46, 15);
            this.label3.TabIndex = 11;
            this.label3.Text = "Strings:";
            // 
            // SearchExcludedStringsTxt
            // 
            this.SearchExcludedStringsTxt.Location = new System.Drawing.Point(607, 41);
            this.SearchExcludedStringsTxt.Name = "SearchExcludedStringsTxt";
            this.SearchExcludedStringsTxt.Size = new System.Drawing.Size(144, 23);
            this.SearchExcludedStringsTxt.TabIndex = 10;
            this.SearchExcludedStringsTxt.TextChanged += new System.EventHandler(this.SearchExcludedStringsTxt_TextChanged);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label2.Location = new System.Drawing.Point(545, 42);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(60, 21);
            this.label2.TabIndex = 9;
            this.label2.Text = "Search:";
            // 
            // ExcludedStringsList
            // 
            this.ExcludedStringsList.FormattingEnabled = true;
            this.ExcludedStringsList.ItemHeight = 15;
            this.ExcludedStringsList.Location = new System.Drawing.Point(381, 65);
            this.ExcludedStringsList.Name = "ExcludedStringsList";
            this.ExcludedStringsList.Size = new System.Drawing.Size(370, 334);
            this.ExcludedStringsList.TabIndex = 8;
            // 
            // SearchStringsTxt
            // 
            this.SearchStringsTxt.Location = new System.Drawing.Point(229, 41);
            this.SearchStringsTxt.Name = "SearchStringsTxt";
            this.SearchStringsTxt.Size = new System.Drawing.Size(144, 23);
            this.SearchStringsTxt.TabIndex = 7;
            this.SearchStringsTxt.TextChanged += new System.EventHandler(this.SearchStringsTxt_TextChanged);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label1.Location = new System.Drawing.Point(167, 42);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(60, 21);
            this.label1.TabIndex = 6;
            this.label1.Text = "Search:";
            // 
            // CloseBtn
            // 
            this.CloseBtn.Customization = "9fX1/6mpqf8=";
            this.CloseBtn.Font = new System.Drawing.Font("Verdana", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.CloseBtn.Image = null;
            this.CloseBtn.Location = new System.Drawing.Point(3, 443);
            this.CloseBtn.Name = "CloseBtn";
            this.CloseBtn.NoRounding = false;
            this.CloseBtn.Size = new System.Drawing.Size(747, 31);
            this.CloseBtn.TabIndex = 4;
            this.CloseBtn.Text = "Close";
            this.CloseBtn.Transparent = false;
            this.CloseBtn.Click += new System.EventHandler(this.CloseBtn_Click);
            // 
            // RemoveBtn
            // 
            this.RemoveBtn.Customization = "9fX1/6mpqf8=";
            this.RemoveBtn.Font = new System.Drawing.Font("Verdana", 14.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.RemoveBtn.Image = null;
            this.RemoveBtn.Location = new System.Drawing.Point(381, 405);
            this.RemoveBtn.Name = "RemoveBtn";
            this.RemoveBtn.NoRounding = false;
            this.RemoveBtn.Size = new System.Drawing.Size(369, 32);
            this.RemoveBtn.TabIndex = 2;
            this.RemoveBtn.Text = "Remove";
            this.RemoveBtn.Transparent = false;
            this.RemoveBtn.Click += new System.EventHandler(this.RemoveBtn_Click);
            // 
            // AddBtn
            // 
            this.AddBtn.Customization = "9fX1/6mpqf8=";
            this.AddBtn.Font = new System.Drawing.Font("Verdana", 14.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.AddBtn.Image = null;
            this.AddBtn.Location = new System.Drawing.Point(3, 405);
            this.AddBtn.Name = "AddBtn";
            this.AddBtn.NoRounding = false;
            this.AddBtn.Size = new System.Drawing.Size(370, 32);
            this.AddBtn.TabIndex = 1;
            this.AddBtn.Text = "Add";
            this.AddBtn.Transparent = false;
            this.AddBtn.Click += new System.EventHandler(this.AddBtn_Click);
            // 
            // ExcludeStringsForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(754, 478);
            this.Controls.Add(this.MainTheme);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "ExcludeStringsForm";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Exclude Strings";
            this.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.ResumeLayout(false);
            this.MainTheme.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.ListBox StringsList;
        private FormSkin.clsNeoBuxTheme MainTheme;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label3;
        private System.Windows.Forms.TextBox SearchExcludedStringsTxt;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ListBox ExcludedStringsList;
        private System.Windows.Forms.TextBox SearchStringsTxt;
        private System.Windows.Forms.Label label1;
        private FormSkin.clsButtonPurple CloseBtn;
        private FormSkin.clsButtonOrange RemoveBtn;
        private FormSkin.clsButtonGreen AddBtn;
    }
}
```

`Unity3DObfuscator/ExcludeStringsForm.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Unity3DObfuscator
{
    public partial class ExcludeStringsForm : Form
    {
        public ExcludeStringsForm()
        {
            InitializeComponent();
            StringsList.Items.Clear();
            ExcludedStringsList.Items.Clear();
            try
            {
                UpdateStrings();
                UpdateExludedStrings();
            }
            catch
            {

            }
            StringsList.ScrollAlwaysVisible = true; //Sets the vertical scroll bar to be visible.
            StringsList.HorizontalScrollbar = true; // Sets the horizontal scroll bar to be visible.
            ExcludedStringsList.ScrollAlwaysVisible = true; //...
            ExcludedStringsList.HorizontalScrollbar = true; //...
        }

        void UpdateStrings() //Updates the strings on the current assembly.
        {
            if (MainClass.MainModule == null)
            {
                return;
            }
            if (!MainClass.MainModule.HasTypes)
            {
                return;
            }
            StringsList.Sorted = true;
            foreach (TypeDef type in MainClass.MainModule.GetTypes())
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    for (int i = 0; i < instr.Count; i++)
                    {
                        if (instr[i].OpCode == OpCodes.Ldstr)
                        {
                            var originalStr = instr[i].Operand as string;
                            if (Exclusion.ExcludedStrings.Contains(originalStr) || Exclusion.ExcludedStrings.Contains(originalStr))
                            {
                                StringsList.Items.Remove(originalStr);
                            }
                            if (!Exclusion.ExcludedStrings.Contains(originalStr))
                            {
                                if (!StringsList.Items.Contains(originalStr))
                                {
                                    if (!Exclusion.Strings.Contains(originalStr))
                                    {
                                        Exclusion.Strings.Add(originalStr);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            foreach (string str in Exclusion.Strings)
            {
                if (!StringsList.Items.Contains(str))
                {
                    StringsList.Items.Add(str);
                }
            }
        }
        void ShowSearchedMatchStrings() //Shows only the strings that the user searches for.
        {
            foreach (TypeDef type in MainClass.MainModule.GetTypes())
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    for (int i = 0; i < instr.Count - 3; i++)
                    {
                        if (instr[i].OpCode == OpCodes.Ldstr)
                        {
                            var originalStr = instr[i].Operand as string;
                            if (Exclusion.ExcludedStrings.Contains(originalStr))
                            {
                                StringsList.Items.Remove(originalStr);
                            }
                            if (!StringsList.Items.Contains(originalStr))
                            {
                                if (!Exclusion.ExcludedStrings.Contains(originalStr))
                                {
                                    if (originalStr.ToLower().Contains(SearchStringsTxt.Text.ToLower()) || originalStr.ToLower().Contains(SearchStringsTxt.Text.ToLower()))
                                    {
                                        StringsList.Items.Add(originalStr);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        void UpdateExludedStrings() //Updates the excluded strings that are currently on the exclusion list.
        {
            if (MainClass.MainModule == null)
            {
                return;
            }
            if (Exclusion.ExcludedStrings.Count <= 0)
            {
                return;
            }
            ExcludedStringsList.Sorted = true;
            foreach (string str in Exclusion.ExcludedStrings)
            {
                if (!ExcludedStringsList.Items.Contains(str))
                {
                    if (Exclusion.ExcludedStrings.Contains(str))
                    {
                        ExcludedStringsList.Items.Add(str);
                    }
                    else
                    {
                        ExcludedStringsList.Items.Remove(str);
                    }
                }
            }
        }
        void ShowSearchedMatchExcludedStings() ////Shows only the excluded strings that the user searches for.
        {
            foreach (string type in Exclusion.ExcludedStrings)
            {
                if (!ExcludedStringsList.Items.Contains(type))
                {
                    if (type.ToLower().Contains(SearchExcludedStringsTxt.Text.ToLower()))
                    {
                        ExcludedStringsList.Items.Add(type);
                    }
                }
            }
        }
        private void CloseBtn_Click(object sender, EventArgs e) //Closes the form.
        {
            Close();
        }

        private void AddBtn_Click(object sender, EventArgs e) //Adds the selected type to the exclusion list.
        {
            if (StringsList.SelectedIndex < 0)
            {
                return;
            }
            string item = StringsList.SelectedItem.ToString();
            if (!Exclusion.ExcludedStrings.Contains(item))
            {
                Exclusion.ExcludedStrings.Add(item);

            }
            if (!ExcludedStringsList.Items.Contains(item))
            {
                ExcludedStringsList.Items.Add(item);
            }
            if (ExcludedStringsList.Items.Contains(item))
            {
                Exclusion.Strings.Remove(item);
                UpdateStrings();
                StringsList.Items.Remove(item);
            }
        }

        private void SearchStringsTxt_TextChanged(object sender, EventArgs e) //The function when the 'search string' text box changes text.
        {
            if (SearchStringsTxt.Text == string.Empty)
            {
                StringsList.Items.Clear();
                try
                {
                    UpdateStrings();
                }
                catch
                {
                }
            }
            else
            {
                StringsList.Items.Clear();
                try
                {
                    ShowSearchedMatchStrings();
                }
                catch
                {
                }
            }
        }

        private void RemoveBtn_Click(object sender, EventArgs e) //Removes the selected type from the exclusion list.
        {
            if (ExcludedStringsList.SelectedIndex < 0)
            {
                return;
            }
            string item = ExcludedStringsList.SelectedItem.ToString();
            if (Exclusion.ExcludedStrings.Contains(item))
            {
                Exclusion.ExcludedStrings.Remove(item);
            }
            StringsList.Items.Add(item);
            if (ExcludedStringsList.Items.Contains(item))
            {
                ExcludedStringsList.Items.Remove(item);
            }
            Exclusion.Strings.Add(item);
            StringsList.Items.Clear();
            UpdateStrings();
        }

        private void SearchExcludedStringsTxt_TextChanged(object sender, EventArgs e) //The function when the 'search excluded string' text box changes text.
        {
            if (SearchExcludedStringsTxt.Text == string.Empty)
            {
                ExcludedStringsList.Items.Clear();
                try
                {
                    UpdateExludedStrings();
                }
                catch { }
            }
            else
            {
                ExcludedStringsList.Items.Clear();
                try
                {
                    ShowSearchedMatchExcludedStings();
                }
                catch { }
            }
        }
    }
}

```

`Unity3DObfuscator/ExcludeStringsForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Unity3DObfuscator/ExcludeTypesForm.Designer.cs`:

```cs
namespace Unity3DObfuscator
{
    partial class ExcludeTypesForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.MainTheme = new FormSkin.clsNeoBuxTheme();
            this.label4 = new System.Windows.Forms.Label();
            this.label3 = new System.Windows.Forms.Label();
            this.SearchExcludedTypes = new System.Windows.Forms.TextBox();
            this.label2 = new System.Windows.Forms.Label();
            this.ExcludedTypesList = new System.Windows.Forms.ListBox();
            this.SearchTypesTxt = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.TypesList = new System.Windows.Forms.ListBox();
            this.CloseBtn = new FormSkin.clsButtonPurple();
            this.RemoveBtn = new FormSkin.clsButtonOrange();
            this.AddBtn = new FormSkin.clsButtonGreen();
            this.MainTheme.SuspendLayout();
            this.SuspendLayout();
            // 
            // MainTheme
            // 
            this.MainTheme.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(239)))), ((int)(((byte)(239)))), ((int)(((byte)(242)))));
            this.MainTheme.BorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.MainTheme.Controls.Add(this.label4);
            this.MainTheme.Controls.Add(this.label3);
            this.MainTheme.Controls.Add(this.SearchExcludedTypes);
            this.MainTheme.Controls.Add(this.label2);
            this.MainTheme.Controls.Add(this.ExcludedTypesList);
            this.MainTheme.Controls.Add(this.SearchTypesTxt);
            this.MainTheme.Controls.Add(this.label1);
            this.MainTheme.Controls.Add(this.TypesList);
            this.MainTheme.Controls.Add(this.CloseBtn);
            this.MainTheme.Controls.Add(this.RemoveBtn);
            this.MainTheme.Controls.Add(this.AddBtn);
            this.MainTheme.Customization = "AAAA/w==";
            this.MainTheme.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MainTheme.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.MainTheme.Image = null;
            this.MainTheme.Location = new System.Drawing.Point(0, 0);
            this.MainTheme.Movable = true;
            this.MainTheme.Name = "MainTheme";
            this.MainTheme.NoRounding = false;
            this.MainTheme.Sizable = false;
            this.MainTheme.Size = new System.Drawing.Size(755, 478);
            this.MainTheme.SmartBounds = true;
            this.MainTheme.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.MainTheme.TabIndex = 0;
            this.MainTheme.Text = "Exlude Types";
            this.MainTheme.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.Transparent = false;
            // 
            // label4
            // 
            this.label4.AutoSize = true;
            this.label4.Location = new System.Drawing.Point(379, 49);
            this.label4.Name = "label4";
            this.label4.Size = new System.Drawing.Size(90, 15);
            this.label4.TabIndex = 12;
            this.label4.Text = "Excluded Types:";
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(3, 47);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(40, 15);
            this.label3.TabIndex = 11;
            this.label3.Text = "Types:";
            // 
            // SearchExcludedTypes
            // 
            this.SearchExcludedTypes.Location = new System.Drawing.Point(607, 41);
            this.SearchExcludedTypes.Name = "SearchExcludedTypes";
            this.SearchExcludedTypes.Size = new System.Drawing.Size(144, 23);
            this.SearchExcludedTypes.TabIndex = 10;
            this.SearchExcludedTypes.TextChanged += new System.EventHandler(this.SearchExcludedTypes_TextChanged);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label2.Location = new System.Drawing.Point(545, 42);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(60, 21);
            this.label2.TabIndex = 9;
            this.label2.Text = "Search:";
            // 
            // ExcludedTypesList
            // 
            this.ExcludedTypesList.FormattingEnabled = true;
            this.ExcludedTypesList.ItemHeight = 15;
            this.ExcludedTypesList.Location = new System.Drawing.Point(381, 65);
            this.ExcludedTypesList.Name = "ExcludedTypesList";
            this.ExcludedTypesList.Size = new System.Drawing.Size(370, 334);
            this.ExcludedTypesList.TabIndex = 8;
            // 
            // SearchTypesTxt
            // 
            this.SearchTypesTxt.Location = new System.Drawing.Point(229, 41);
            this.SearchTypesTxt.Name = "SearchTypesTxt";
            this.SearchTypesTxt.Size = new System.Drawing.Size(144, 23);
            this.SearchTypesTxt.TabIndex = 7;
            this.SearchTypesTxt.TextChanged += new System.EventHandler(this.SearchTypesTxt_TextChanged);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.label1.Location = new System.Drawing.Point(167, 42);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(60, 21);
            this.label1.TabIndex = 6;
            this.label1.Text = "Search:";
            // 
            // TypesList
            // 
            this.TypesList.FormattingEnabled = true;
            this.TypesList.ItemHeight = 15;
            this.TypesList.Location = new System.Drawing.Point(3, 65);
            this.TypesList.Name = "TypesList";
            this.TypesList.Size = new System.Drawing.Size(370, 334);
            this.TypesList.TabIndex = 5;
            this.TypesList.SelectedIndexChanged += new System.EventHandler(this.TypesList_SelectedIndexChanged);
            // 
            // CloseBtn
            // 
            this.CloseBtn.Customization = "9fX1/6mpqf8=";
            this.CloseBtn.Font = new System.Drawing.Font("Verdana", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.CloseBtn.Image = null;
            this.CloseBtn.Location = new System.Drawing.Point(3, 443);
            this.CloseBtn.Name = "CloseBtn";
            this.CloseBtn.NoRounding = false;
            this.CloseBtn.Size = new System.Drawing.Size(747, 31);
            this.CloseBtn.TabIndex = 4;
            this.CloseBtn.Text = "Close";
            this.CloseBtn.Transparent = false;
            this.CloseBtn.Click += new System.EventHandler(this.CloseBtn_Click);
            // 
            // RemoveBtn
            // 
            this.RemoveBtn.Customization = "9fX1/6mpqf8=";
            this.RemoveBtn.Font = new System.Drawing.Font("Verdana", 14.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.RemoveBtn.Image = null;
            this.RemoveBtn.Location = new System.Drawing.Point(381, 405);
            this.RemoveBtn.Name = "RemoveBtn";
            this.RemoveBtn.NoRounding = false;
            this.RemoveBtn.Size = new System.Drawing.Size(369, 32);
            this.RemoveBtn.TabIndex = 2;
            this.RemoveBtn.Text = "Remove";
            this.RemoveBtn.Transparent = false;
            this.RemoveBtn.Click += new System.EventHandler(this.RemoveBtn_Click);
            // 
            // AddBtn
            // 
            this.AddBtn.Customization = "9fX1/6mpqf8=";
            this.AddBtn.Font = new System.Drawing.Font("Verdana", 14.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.AddBtn.Image = null;
            this.AddBtn.Location = new System.Drawing.Point(3, 405);
            this.AddBtn.Name = "AddBtn";
            this.AddBtn.NoRounding = false;
            this.AddBtn.Size = new System.Drawing.Size(370, 32);
            this.AddBtn.TabIndex = 1;
            this.AddBtn.Text = "Add";
            this.AddBtn.Transparent = false;
            this.AddBtn.Click += new System.EventHandler(this.AddBtn_Click);
            // 
            // ExcludeTypesForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(755, 478);
            this.Controls.Add(this.MainTheme);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "ExcludeTypesForm";
            this.ShowIcon = false;
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Exclude Types";
            this.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.ResumeLayout(false);
            this.MainTheme.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private FormSkin.clsNeoBuxTheme MainTheme;
        private FormSkin.clsButtonPurple CloseBtn;
        private FormSkin.clsButtonOrange RemoveBtn;
        private FormSkin.clsButtonGreen AddBtn;
        private System.Windows.Forms.ListBox TypesList;
        private System.Windows.Forms.TextBox SearchTypesTxt;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.TextBox SearchExcludedTypes;
        private System.Windows.Forms.Label label2;
        private System.Windows.Forms.ListBox ExcludedTypesList;
        private System.Windows.Forms.Label label4;
        private System.Windows.Forms.Label label3;
    }
}
```

`Unity3DObfuscator/ExcludeTypesForm.cs`:

```cs
using dnlib.DotNet;
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Unity3DObfuscator
{
    public partial class ExcludeTypesForm : Form
    {
        public ExcludeTypesForm()
        {
            InitializeComponent();
            TypesList.Items.Clear();
            ExcludedTypesList.Items.Clear();
            try
            {
                UpdateTypes();
                UpdateExcludedTypes();
            }
            catch
            {

            }
            TypesList.ScrollAlwaysVisible = true; //Sets the vertical scroll bar to be visible.
            ExcludedTypesList.ScrollAlwaysVisible = true; //...
            TypesList.HorizontalScrollbar = true; // Sets the horizontal scroll bar to be visible.
            ExcludedTypesList.HorizontalScrollbar = true; //...
        }
        void UpdateTypes() //Updates the types on the current assembly.
        {
            if (MainClass.MainModule == null)
            {
                return;
            }
            if (!MainClass.MainModule.HasTypes)
            {
                return;
            }
            TypesList.Sorted = true;
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (Exclusion.ExludedTypes.Contains(type.FullName))
                {
                    TypesList.Items.Remove(type.FullName);
                }
                if (!Exclusion.ExludedTypes.Contains(type.FullName))
                {
                    if (!TypesList.Items.Contains(type.FullName))
                    {
                        if (!type.Name.StartsWith("<") && !type.Name.EndsWith(">"))
                        {
                            if (!Exclusion.Types.Contains(type.FullName))
                            {
                                Exclusion.Types.Add(type.FullName);
                            }
                        }
                    }
                }
            }
            foreach (string type in Exclusion.Types)
            {
                if (!TypesList.Items.Contains(type))
                {
                    TypesList.Items.Add(type);
                }
            }
        }
        void ShowSearchedMatchTypes() //Shows only the types that the user searches for.
        {
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (Exclusion.ExludedTypes.Contains(type.FullName))
                {
                    TypesList.Items.Remove(type.FullName);
                }
                if (!TypesList.Items.Contains(type.FullName))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        if (!type.Name.StartsWith("<") && !type.Name.EndsWith(">"))
                        {
                            if (type.Name.ToLower().Contains(SearchTypesTxt.Text.ToLower()) || type.FullName.ToLower().Contains(SearchTypesTxt.Text.ToLower()))
                            {
                                TypesList.Items.Add(type.FullName);
                            }
                        }
                    }
                }
            }
        }
        void UpdateExcludedTypes() //Updates the excluded types that are currently on the exclusion list.
        {
            if (MainClass.MainModule == null)
            {
                return;
            }
            if (Exclusion.ExludedTypes.Count <= 0)
            {
                return;
            }
            ExcludedTypesList.Sorted = true;
            foreach (string type in Exclusion.ExludedTypes)
            {
                if (!ExcludedTypesList.Items.Contains(type))
                {
                    if (Exclusion.ExludedTypes.Contains(type))
                    {
                        ExcludedTypesList.Items.Add(type);
                    }
                    else
                    {
                        ExcludedTypesList.Items.Remove(type);
                    }
                }
            }
        }
        void ShowSearchedMatchExcludedTypes() //Shows only the excluded types that the user searches for.
        {
            foreach (string type in Exclusion.ExludedTypes)
            {
                if (!ExcludedTypesList.Items.Contains(type))
                {
                    if (type.ToLower().Contains(SearchExcludedTypes.Text.ToLower()))
                    {
                        ExcludedTypesList.Items.Add(type);
                    }
                }
            }
        }
        private void SearchTypesTxt_TextChanged(object sender, EventArgs e) //The function when the 'search type' text box changes text.
        {
            if (SearchTypesTxt.Text == string.Empty)
            {
                TypesList.Items.Clear();
                try
                {
                    UpdateTypes();
                }
                catch
                {
                }
            }
            else
            {
                TypesList.Items.Clear();
                try
                {
                    ShowSearchedMatchTypes();
                }
                catch
                {
                }
            }
        }
        private void SearchExcludedTypes_TextChanged(object sender, EventArgs e) //The function when the 'search excluded type' text box changes text.
        {
            if (SearchExcludedTypes.Text == string.Empty)
            {
                ExcludedTypesList.Items.Clear();
                try
                {
                    UpdateExcludedTypes();
                }
                catch
                {
                }
            }
            else
            {
                ExcludedTypesList.Items.Clear();
                try
                {
                    ShowSearchedMatchExcludedTypes();
                }
                catch
                {
                }
            }
        }
        private void TypesList_SelectedIndexChanged(object sender, EventArgs e) //Ignore this.
        {

        }
        private void AddBtn_Click(object sender, EventArgs e) //Adds the selected type to the exclusion list.
        {
            if (TypesList.SelectedIndex < 0)
            {
                return;
            }
            string item = TypesList.SelectedItem.ToString();
            if (!Exclusion.ExludedTypes.Contains(item))
            {
                Exclusion.ExludedTypes.Add(item);

            }
            if (!ExcludedTypesList.Items.Contains(item))
            {
                ExcludedTypesList.Items.Add(item);
            }
            if (ExcludedTypesList.Items.Contains(item))
            {
                Exclusion.Types.Remove(item);
                UpdateTypes();
                TypesList.Items.Remove(item);
            }
        }

        private void RemoveBtn_Click(object sender, EventArgs e) //Removes the selected type from the exclusion list.
        { 
            if (ExcludedTypesList.SelectedIndex < 0)
            {
                return;
            }
            string item = ExcludedTypesList.SelectedItem.ToString();
            if (Exclusion.ExludedTypes.Contains(item))
            {
                Exclusion.ExludedTypes.Remove(item);
            }
            TypesList.Items.Add(item);
            if (ExcludedTypesList.Items.Contains(item))
            {
                ExcludedTypesList.Items.Remove(item);
            }
            Exclusion.Types.Add(item);
            TypesList.Items.Clear();
            UpdateTypes();
        }

        private void CloseBtn_Click(object sender, EventArgs e) //Closes the form.
        {
            Close();
        }
    }
}

```

`Unity3DObfuscator/ExcludeTypesForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Unity3DObfuscator/Exclusion.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    public class Exclusion
    {
        //Execution Order of Event Functions in Unity. Feel free to add functions that you think they are missing.
        private static readonly List<string> unityFunctions = new List<string>(new string[] { "Awake", "OnEnable", "OnDisable", "OnLevelWasLoaded", "OnApplicationPause", "Start", "Update", "FixedUpdate", "LateUpdate", "OnPreCull", "OnBecameVisible", "OnBecameInvisible", "OnWillRenderObject", "OnPreRender", "OnRenderObject", "OnPostRender", "OnRenderImage", "OnGUI", "OnDrawGizmos", "OnDestroy", "OnApplicationQuit", "OnTriggerEnter", "OnTriggerExit", "OnCollisionEnter", "OnCollisionExit", "OnMouseClick", "OnMouseDown", "OnMouseUp" });

        private static readonly List<string> types = new List<string>(new string[0]);

        //Excluded types.
        private static readonly List<string> exludedTypes = new List<string>(new string[0]);

        //Excluded strings.
        private static readonly List<string> excludedStrings = new List<string>(new string[0]);

        //List of strings in the assembly
        private static readonly List<string> strings = new List<string>(new string[0]);

        //The properties are just return functions of every list.
        public static List<string> UnityFunctions => unityFunctions;

        public static List<string> Types => types;

        public static List<string> ExludedTypes => exludedTypes;

        public static List<string> ExcludedStrings => excludedStrings;

        public static List<string> Strings => strings;
    }
}
```

`Unity3DObfuscator/GlobalStrings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    //The strings for the renaming function.
    public struct GlobalStrings
    {
        private static Random random = new Random();

        public static string RenamingString => GetRenamingString();
        public static string RandomString => GetRandomString();
        private static string GetRandomString() //Generates a radmom string.
        {
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            var stringChars = new char[19];
            for (int i = 0; i < stringChars.Length; i++)
            {
                stringChars[i] = chars[random.Next(chars.Length)];
            }
            var finalString = new String(stringChars);
            return string.Concat("=", finalString);
        }
        private static string GetEmpty() //Returns an empty string.
        {
            return string.Empty;
        }
        private static string GetRenamingString() //Gets the renaming type of the 'Renaming Obfuscation'. Radmm name or empty.
        {
            if (MainClass.Settings.RandomName && !MainClass.Settings.EmptyName)
            {
                return GetRandomString();
            }
            if (MainClass.Settings.EmptyName && !MainClass.Settings.RandomName)
            {
                return GetEmpty();
            }
            return "xxx";
        }
    }
}

```

`Unity3DObfuscator/HelpForm.Designer.cs`:

```cs
namespace Unity3DObfuscator
{
    partial class HelpForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.MainTheme = new FormSkin.clsNeoBuxTheme();
            this.HelpTabControl = new System.Windows.Forms.TabControl();
            this.RenamingPage = new System.Windows.Forms.TabPage();
            this.StringEncryptionPage = new System.Windows.Forms.TabPage();
            this.AntiTamperingPage = new System.Windows.Forms.TabPage();
            this.textBox1 = new System.Windows.Forms.TextBox();
            this.StringEncryptionTxt = new System.Windows.Forms.TextBox();
            this.AntiTamperingTxt = new System.Windows.Forms.TextBox();
            this.RenamingTxt = new System.Windows.Forms.TextBox();
            this.CloseBtn = new FormSkin.clsButtonBlue();
            this.MainTheme.SuspendLayout();
            this.HelpTabControl.SuspendLayout();
            this.RenamingPage.SuspendLayout();
            this.StringEncryptionPage.SuspendLayout();
            this.AntiTamperingPage.SuspendLayout();
            this.SuspendLayout();
            // 
            // MainTheme
            // 
            this.MainTheme.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(239)))), ((int)(((byte)(239)))), ((int)(((byte)(242)))));
            this.MainTheme.BorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.MainTheme.Controls.Add(this.CloseBtn);
            this.MainTheme.Controls.Add(this.HelpTabControl);
            this.MainTheme.Customization = "AAAA/w==";
            this.MainTheme.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MainTheme.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.MainTheme.Image = null;
            this.MainTheme.Location = new System.Drawing.Point(0, 0);
            this.MainTheme.Movable = false;
            this.MainTheme.Name = "MainTheme";
            this.MainTheme.NoRounding = false;
            this.MainTheme.Sizable = false;
            this.MainTheme.Size = new System.Drawing.Size(346, 518);
            this.MainTheme.SmartBounds = true;
            this.MainTheme.StartPosition = System.Windows.Forms.FormStartPosition.WindowsDefaultLocation;
            this.MainTheme.TabIndex = 0;
            this.MainTheme.Text = "Help";
            this.MainTheme.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.Transparent = false;
            // 
            // HelpTabControl
            // 
            this.HelpTabControl.Controls.Add(this.RenamingPage);
            this.HelpTabControl.Controls.Add(this.StringEncryptionPage);
            this.HelpTabControl.Controls.Add(this.AntiTamperingPage);
            this.HelpTabControl.Location = new System.Drawing.Point(3, 40);
            this.HelpTabControl.Name = "HelpTabControl";
            this.HelpTabControl.SelectedIndex = 0;
            this.HelpTabControl.Size = new System.Drawing.Size(341, 431);
            this.HelpTabControl.TabIndex = 0;
            // 
            // RenamingPage
            // 
            this.RenamingPage.Controls.Add(this.RenamingTxt);
            this.RenamingPage.ForeColor = System.Drawing.Color.Blue;
            this.RenamingPage.Location = new System.Drawing.Point(4, 30);
            this.RenamingPage.Name = "RenamingPage";
            this.RenamingPage.Padding = new System.Windows.Forms.Padding(3);
            this.RenamingPage.Size = new System.Drawing.Size(333, 397);
            this.RenamingPage.TabIndex = 0;
            this.RenamingPage.Text = "Renaming";
            this.RenamingPage.UseVisualStyleBackColor = true;
            // 
            // StringEncryptionPage
            // 
            this.StringEncryptionPage.Controls.Add(this.StringEncryptionTxt);
            this.StringEncryptionPage.Controls.Add(this.textBox1);
            this.StringEncryptionPage.ForeColor = System.Drawing.Color.Blue;
            this.StringEncryptionPage.Location = new System.Drawing.Point(4, 30);
            this.StringEncryptionPage.Name = "StringEncryptionPage";
            this.StringEncryptionPage.Padding = new System.Windows.Forms.Padding(3);
            this.StringEncryptionPage.Size = new System.Drawing.Size(333, 397);
            this.StringEncryptionPage.TabIndex = 1;
            this.StringEncryptionPage.Text = "String Encryption";
            this.StringEncryptionPage.UseVisualStyleBackColor = true;
            // 
            // AntiTamperingPage
            // 
            this.AntiTamperingPage.Controls.Add(this.AntiTamperingTxt);
            this.AntiTamperingPage.ForeColor = System.Drawing.Color.Blue;
            this.AntiTamperingPage.Location = new System.Drawing.Point(4, 30);
            this.AntiTamperingPage.Name = "AntiTamperingPage";
            this.AntiTamperingPage.Size = new System.Drawing.Size(333, 397);
            this.AntiTamperingPage.TabIndex = 2;
            this.AntiTamperingPage.Text = "Anti Tampering";
            this.AntiTamperingPage.UseVisualStyleBackColor = true;
            // 
            // textBox1
            // 
            this.textBox1.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.textBox1.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.textBox1.ForeColor = System.Drawing.Color.Blue;
            this.textBox1.Location = new System.Drawing.Point(-6, -2);
            this.textBox1.Multiline = true;
            this.textBox1.Name = "textBox1";
            this.textBox1.Size = new System.Drawing.Size(344, 368);
            this.textBox1.TabIndex = 1;
            // 
            // StringEncryptionTxt
            // 
            this.StringEncryptionTxt.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.StringEncryptionTxt.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.StringEncryptionTxt.ForeColor = System.Drawing.Color.Blue;
            this.StringEncryptionTxt.Location = new System.Drawing.Point(-4, 0);
            this.StringEncryptionTxt.Multiline = true;
            this.StringEncryptionTxt.Name = "StringEncryptionTxt";
            this.StringEncryptionTxt.ReadOnly = true;
            this.StringEncryptionTxt.Size = new System.Drawing.Size(344, 401);
            this.StringEncryptionTxt.TabIndex = 2;
            // 
            // AntiTamperingTxt
            // 
            this.AntiTamperingTxt.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.AntiTamperingTxt.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.AntiTamperingTxt.ForeColor = System.Drawing.Color.Blue;
            this.AntiTamperingTxt.Location = new System.Drawing.Point(-6, -2);
            this.AntiTamperingTxt.Multiline = true;
            this.AntiTamperingTxt.Name = "AntiTamperingTxt";
            this.AntiTamperingTxt.ReadOnly = true;
            this.AntiTamperingTxt.Size = new System.Drawing.Size(344, 403);
            this.AntiTamperingTxt.TabIndex = 1;
            // 
            // RenamingTxt
            // 
            this.RenamingTxt.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.RenamingTxt.Font = new System.Drawing.Font("Segoe UI", 15.75F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.RenamingTxt.ForeColor = System.Drawing.Color.Blue;
            this.RenamingTxt.ImeMode = System.Windows.Forms.ImeMode.NoControl;
            this.RenamingTxt.Location = new System.Drawing.Point(-7, 0);
            this.RenamingTxt.Multiline = true;
            this.RenamingTxt.Name = "RenamingTxt";
            this.RenamingTxt.ReadOnly = true;
            this.RenamingTxt.Size = new System.Drawing.Size(344, 401);
            this.RenamingTxt.TabIndex = 0;
            // 
            // CloseBtn
            // 
            this.CloseBtn.Customization = "9fX1/6mpqf8=";
            this.CloseBtn.Font = new System.Drawing.Font("Verdana", 18F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.CloseBtn.Image = null;
            this.CloseBtn.Location = new System.Drawing.Point(4, 473);
            this.CloseBtn.Name = "CloseBtn";
            this.CloseBtn.NoRounding = false;
            this.CloseBtn.Size = new System.Drawing.Size(337, 42);
            this.CloseBtn.TabIndex = 1;
            this.CloseBtn.Text = "Close";
            this.CloseBtn.Transparent = false;
            this.CloseBtn.Click += new System.EventHandler(this.CloseBtn_Click);
            // 
            // HelpForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(346, 518);
            this.Controls.Add(this.MainTheme);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "HelpForm";
            this.ShowInTaskbar = false;
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Help";
            this.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.ResumeLayout(false);
            this.HelpTabControl.ResumeLayout(false);
            this.RenamingPage.ResumeLayout(false);
            this.RenamingPage.PerformLayout();
            this.StringEncryptionPage.ResumeLayout(false);
            this.StringEncryptionPage.PerformLayout();
            this.AntiTamperingPage.ResumeLayout(false);
            this.AntiTamperingPage.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private FormSkin.clsNeoBuxTheme MainTheme;
        private System.Windows.Forms.TabControl HelpTabControl;
        private System.Windows.Forms.TabPage RenamingPage;
        private System.Windows.Forms.TabPage StringEncryptionPage;
        private System.Windows.Forms.TabPage AntiTamperingPage;
        private System.Windows.Forms.TextBox StringEncryptionTxt;
        private System.Windows.Forms.TextBox textBox1;
        private System.Windows.Forms.TextBox AntiTamperingTxt;
        private System.Windows.Forms.TextBox RenamingTxt;
        private FormSkin.clsButtonBlue CloseBtn;
    }
}
```

`Unity3DObfuscator/HelpForm.cs`:

```cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Unity3DObfuscator
{
    public partial class HelpForm : Form
    {
        public HelpForm()
        {
            InitializeComponent();
            RenamingTxt.Text = ObfuscatorHelp.Renaming;
            StringEncryptionTxt.Text = ObfuscatorHelp.StringEncryption;
            AntiTamperingTxt.Text = ObfuscatorHelp.AntiTampering;
        }

        private void CloseBtn_Click(object sender, EventArgs e)
        {
            Close();
        }
    }
}

```

`Unity3DObfuscator/HelpForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Unity3DObfuscator/InjectHelper.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System.Collections.Generic;
using System.Linq;

namespace Unity3DObfuscator
{
    // Credit: The original InjectHelper class is from the ConfuserEx project.

    /// <summary>
    ///     Provides methods to inject a <see cref="TypeDef" /> into another module.
    /// </summary>
    public static class InjectHelper
    {
        /// <summary>
        ///     Clones the specified origin TypeDef.
        /// </summary>
        /// <param name="origin">The origin TypeDef.</param>
        /// <returns>The cloned TypeDef.</returns>
        private static TypeDefUser Clone(TypeDef origin)
        {
            var ret = new TypeDefUser(origin.Namespace, origin.Name) {Attributes = origin.Attributes};

            if (origin.ClassLayout != null)
                ret.ClassLayout = new ClassLayoutUser(origin.ClassLayout.PackingSize, origin.ClassSize);

            foreach (GenericParam genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            return ret;
        }

        /// <summary>
        ///     Clones the specified origin MethodDef.
        /// </summary>
        /// <param name="origin">The origin MethodDef.</param>
        /// <returns>The cloned MethodDef.</returns>
        static MethodDefUser Clone(MethodDef origin)
        {
            var ret = new MethodDefUser(origin.Name, null, origin.ImplAttributes, origin.Attributes);

            foreach (GenericParam genericParam in origin.GenericParameters)
                ret.GenericParameters.Add(new GenericParamUser(genericParam.Number, genericParam.Flags, "-"));

            return ret;
        }

        /// <summary>
        ///     Clones the specified origin FieldDef.
        /// </summary>
        /// <param name="origin">The origin FieldDef.</param>
        /// <returns>The cloned FieldDef.</returns>
        private static FieldDefUser Clone(FieldDef origin)
        {
            var ret = new FieldDefUser(origin.Name, null, origin.Attributes);
            return ret;
        }

        /// <summary>
        ///     Populates the context mappings.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        /// <returns>The new TypeDef.</returns>
        private static TypeDef PopulateContext(TypeDef typeDef, InjectContext ctx)
        {
            TypeDef ret;
            IDnlibDef existing;
            if (!ctx.Map.TryGetValue(typeDef, out existing))
            {
                ret = Clone(typeDef);
                ctx.Map[typeDef] = ret;
            }
            else
                ret = (TypeDef)existing;

            foreach (TypeDef nestedType in typeDef.NestedTypes)
                ret.NestedTypes.Add(PopulateContext(nestedType, ctx));

            foreach (MethodDef method in typeDef.Methods)
                ret.Methods.Add((MethodDef)(ctx.Map[method] = Clone(method)));

            foreach (FieldDef field in typeDef.Fields)
                ret.Fields.Add((FieldDef)(ctx.Map[field] = Clone(field)));

            return ret;
        }

        /// <summary>
        ///     Copies the information from the origin type to injected type.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        private static void CopyTypeDef(TypeDef typeDef, InjectContext ctx)
        {
            var newTypeDef = (TypeDef)ctx.Map[typeDef];

            newTypeDef.BaseType = (ITypeDefOrRef)ctx.Importer.Import(typeDef.BaseType);

            foreach (InterfaceImpl iface in typeDef.Interfaces)
                newTypeDef.Interfaces.Add(new InterfaceImplUser((ITypeDefOrRef)ctx.Importer.Import(iface.Interface)));
        }

        /// <summary>
        ///     Copies the information from the origin method to injected method.
        /// </summary>
        /// <param name="methodDef">The origin MethodDef.</param>
        /// <param name="ctx">The injection context.</param>
        private static void CopyMethodDef(MethodDef methodDef, InjectContext ctx)
        {
            var newMethodDef = (MethodDef)ctx.Map[methodDef];

            newMethodDef.Signature = ctx.Importer.Import(methodDef.Signature);
            newMethodDef.Parameters.UpdateParameterTypes();

            if (methodDef.ImplMap != null)
                newMethodDef.ImplMap = new ImplMapUser(new ModuleRefUser(ctx.TargetModule, methodDef.ImplMap.Module.Name), methodDef.ImplMap.Name, methodDef.ImplMap.Attributes);

            foreach (CustomAttribute ca in methodDef.CustomAttributes)
                newMethodDef.CustomAttributes.Add(new CustomAttribute((ICustomAttributeType)ctx.Importer.Import(ca.Constructor)));

            if (!methodDef.HasBody) return;
            newMethodDef.Body = new CilBody(methodDef.Body.InitLocals, new List<Instruction>(), new List<ExceptionHandler>(), new List<Local>());
            newMethodDef.Body.MaxStack = methodDef.Body.MaxStack;

            var bodyMap = new Dictionary<object, object>();

            foreach (Local local in methodDef.Body.Variables)
            {
                var newLocal = new Local(ctx.Importer.Import(local.Type));
                newMethodDef.Body.Variables.Add(newLocal);
                newLocal.Name = local.Name;
                newLocal.PdbAttributes = local.PdbAttributes;

                bodyMap[local] = newLocal;
            }

            foreach (Instruction instr in methodDef.Body.Instructions)
            {
                var newInstr = new Instruction(instr.OpCode, instr.Operand) {SequencePoint = instr.SequencePoint};

                if (newInstr.Operand is IType)
                    newInstr.Operand = ctx.Importer.Import((IType)newInstr.Operand);

                else if (newInstr.Operand is IMethod)
                    newInstr.Operand = ctx.Importer.Import((IMethod)newInstr.Operand);

                else if (newInstr.Operand is IField)
                    newInstr.Operand = ctx.Importer.Import((IField)newInstr.Operand);

                newMethodDef.Body.Instructions.Add(newInstr);
                bodyMap[instr] = newInstr;
            }

            foreach (Instruction instr in newMethodDef.Body.Instructions)
            {
                if (instr.Operand != null && bodyMap.ContainsKey(instr.Operand))
                    instr.Operand = bodyMap[instr.Operand];

                else if (instr.Operand is Instruction[])
                    instr.Operand = ((Instruction[])instr.Operand).Select(target => (Instruction)bodyMap[target]).ToArray();
            }

            foreach (ExceptionHandler eh in methodDef.Body.ExceptionHandlers)
                newMethodDef.Body.ExceptionHandlers.Add(new ExceptionHandler(eh.HandlerType)
                {
                    CatchType = eh.CatchType == null ? null : (ITypeDefOrRef)ctx.Importer.Import(eh.CatchType),
                    TryStart = (Instruction)bodyMap[eh.TryStart],
                    TryEnd = (Instruction)bodyMap[eh.TryEnd],
                    HandlerStart = (Instruction)bodyMap[eh.HandlerStart],
                    HandlerEnd = (Instruction)bodyMap[eh.HandlerEnd],
                    FilterStart = eh.FilterStart == null ? null : (Instruction)bodyMap[eh.FilterStart]
                });

            newMethodDef.Body.SimplifyMacros(newMethodDef.Parameters);
        }

        /// <summary>
        ///     Copies the information from the origin field to injected field.
        /// </summary>
        /// <param name="fieldDef">The origin FieldDef.</param>
        /// <param name="ctx">The injection context.</param>
        private static void CopyFieldDef(FieldDef fieldDef, InjectContext ctx)
        {
            var newFieldDef = (FieldDef)ctx.Map[fieldDef];

            newFieldDef.Signature = ctx.Importer.Import(fieldDef.Signature);
        }

        /// <summary>
        ///     Copies the information to the injected definitions.
        /// </summary>
        /// <param name="typeDef">The origin TypeDef.</param>
        /// <param name="ctx">The injection context.</param>
        /// <param name="copySelf">if set to <c>true</c>, copy information of <paramref name="typeDef" />.</param>
        private static void Copy(TypeDef typeDef, InjectContext ctx, bool copySelf)
        {
            if (copySelf)
                CopyTypeDef(typeDef, ctx);

            foreach (TypeDef nestedType in typeDef.NestedTypes)
                Copy(nestedType, ctx, true);

            foreach (MethodDef method in typeDef.Methods)
                CopyMethodDef(method, ctx);

            foreach (FieldDef field in typeDef.Fields)
                CopyFieldDef(field, ctx);
        }

        /// <summary>
        ///     Injects the specified TypeDef to another module.
        /// </summary>
        /// <param name="typeDef">The source TypeDef.</param>
        /// <param name="target">The target module.</param>
        /// <returns>The injected TypeDef.</returns>
        public static TypeDef Inject(TypeDef typeDef, ModuleDef target)
        {
            var ctx = new InjectContext(typeDef.Module, target);
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, true);
            return (TypeDef)ctx.Map[typeDef];
        }

        /// <summary>
        ///     Injects the specified MethodDef to another module.
        /// </summary>
        /// <param name="methodDef">The source MethodDef.</param>
        /// <param name="target">The target module.</param>
        /// <returns>The injected MethodDef.</returns>
        public static MethodDef Inject(MethodDef methodDef, ModuleDef target)
        {
            var ctx = new InjectContext(methodDef.Module, target);
            ctx.Map[methodDef] = Clone(methodDef);
            CopyMethodDef(methodDef, ctx);
            return (MethodDef)ctx.Map[methodDef];
        }

        /// <summary>
        ///     Injects the members of specified TypeDef to another module.
        /// </summary>
        /// <param name="typeDef">The source TypeDef.</param>
        /// <param name="newType">The new type.</param>
        /// <param name="target">The target module.</param>
        /// <returns>Injected members.</returns>
        public static IEnumerable<IDnlibDef> Inject(TypeDef typeDef, TypeDef newType, ModuleDef target)
        {
            var ctx = new InjectContext(typeDef.Module, target);
            ctx.Map[typeDef] = newType;
            PopulateContext(typeDef, ctx);
            Copy(typeDef, ctx, false);
            return ctx.Map.Values.Except(new[] { newType });
        }

        /// <summary>
        ///     Context of the injection process.
        /// </summary>
        private class InjectContext : ImportResolver
        {
            /// <summary>
            ///     The mapping of origin definitions to injected definitions.
            /// </summary>
            public readonly Dictionary<IDnlibDef, IDnlibDef> Map = new Dictionary<IDnlibDef, IDnlibDef>();

            /// <summary>
            ///     The module which source type originated from.
            /// </summary>
            public readonly ModuleDef OriginModule;

            /// <summary>
            ///     The module which source type is being injected to.
            /// </summary>
            public readonly ModuleDef TargetModule;

            /// <summary>
            ///     The importer.
            /// </summary>
            readonly Importer importer;

            /// <summary>
            ///     Initializes a new instance of the <see cref="InjectContext" /> class.
            /// </summary>
            /// <param name="module">The origin module.</param>
            /// <param name="target">The target module.</param>
            public InjectContext(ModuleDef module, ModuleDef target)
            {
                OriginModule = module;
                TargetModule = target;
                importer = new Importer(target, ImporterOptions.TryToUseTypeDefs);
                importer.Resolver = this;
            }

            /// <summary>
            ///     Gets the importer.
            /// </summary>
            /// <value>The importer.</value>
            public Importer Importer
            {
                get { return importer; }
            }

            /// <inheritdoc />
            public override TypeDef Resolve(TypeDef typeDef)
            {
                if (Map.ContainsKey(typeDef))
                    return (TypeDef)Map[typeDef];
                return null;
            }

            /// <inheritdoc />
            public override MethodDef Resolve(MethodDef methodDef)
            {
                if (Map.ContainsKey(methodDef))
                    return (MethodDef)Map[methodDef];
                return null;
            }

            /// <inheritdoc />
            public override FieldDef Resolve(FieldDef fieldDef)
            {
                if (Map.ContainsKey(fieldDef))
                    return (FieldDef)Map[fieldDef];
                return null;
            }
        }
    }
}

```

`Unity3DObfuscator/MainClass.cs`:

```cs
using dnlib.DotNet;
using System.Threading;

namespace Unity3DObfuscator
{
    public class MainClass
    {
        // I just made this class for various instances.
        private static readonly ObfuscationSettings settings = new ObfuscationSettings();
        private static readonly RenamingClass renaming = new RenamingClass();
        private static readonly AntiILDasmClass antiILDasm = new AntiILDasmClass();
        private static readonly StringEncryptionClass stringEcnryption = new StringEncryptionClass();
        private static readonly AntiTamperingClass antiTampering = new AntiTamperingClass();
        private static ModuleDefMD mainModule = null;
        private static Thread obfuscationThread = null;

        public static ObfuscationSettings Settings => settings;
        public static AntiILDasmClass AntiILDasm => antiILDasm;
        public static RenamingClass Renaming => renaming;
        public static StringEncryptionClass StringEcnryption => stringEcnryption;
        public static AntiTamperingClass AntiTampering => antiTampering;
        public static ModuleDefMD MainModule { get => mainModule; set => mainModule = value; }
        public static Thread ObfuscationThread { get => obfuscationThread; set => obfuscationThread = value; }
    }
}

```

`Unity3DObfuscator/MainForm.Designer.cs`:

```cs
namespace Unity3DObfuscator
{
    partial class MainForm
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.MainTheme = new FormSkin.clsNeoBuxTheme();
            this.ExitBtn = new FormSkin.clsButtonGrey();
            this.CancelBtn = new System.Windows.Forms.Button();
            this.HelpBtn = new FormSkin.clsButtonOrange();
            this.sLabel = new System.Windows.Forms.Label();
            this.StatusLbl = new System.Windows.Forms.Label();
            this.ResetBtn = new FormSkin.clsButtonPurple();
            this.AboutBtn = new FormSkin.clsButtonBlue();
            this.clsControlMenu1 = new FormSkin.clsControlMenu();
            this.RestartBtn_ = new FormSkin.clsButtonOrange();
            this.ChooseBtn = new FormSkin.clsButtonGrey();
            this.PathTxt = new System.Windows.Forms.TextBox();
            this.label1 = new System.Windows.Forms.Label();
            this.ProtectBtn = new FormSkin.clsButtonGreen();
            this.SettingsBox = new System.Windows.Forms.GroupBox();
            this.ExcludeStringsBtn = new FormSkin.clsButtonGrey();
            this.label2 = new System.Windows.Forms.Label();
            this.StringEncnryptionCB = new System.Windows.Forms.CheckBox();
            this.AntiILDasmCB = new System.Windows.Forms.CheckBox();
            this.RandomNameRB = new System.Windows.Forms.RadioButton();
            this.EmptyNameRB = new System.Windows.Forms.RadioButton();
            this.OpenFolderBtn = new FormSkin.clsButtonGrey();
            this.AntiTamperingCB = new System.Windows.Forms.CheckBox();
            this.ExcludeTypesBtn = new FormSkin.clsButtonGrey();
            this.RenameFieldsCB = new System.Windows.Forms.CheckBox();
            this.RenameTypesCB = new System.Windows.Forms.CheckBox();
            this.RenamePropertiesCB = new System.Windows.Forms.CheckBox();
            this.RenameMethodsCB = new System.Windows.Forms.CheckBox();
            this.RenameNamespacesCB = new System.Windows.Forms.CheckBox();
            this.bottomTxt = new System.Windows.Forms.TextBox();
            this.label3 = new System.Windows.Forms.Label();
            this.StringEncrypyionTypeCB = new System.Windows.Forms.ComboBox();
            this.MainTheme.SuspendLayout();
            this.SettingsBox.SuspendLayout();
            this.SuspendLayout();
            // 
            // MainTheme
            // 
            this.MainTheme.BackColor = System.Drawing.Color.FromArgb(((int)(((byte)(239)))), ((int)(((byte)(239)))), ((int)(((byte)(242)))));
            this.MainTheme.BorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.MainTheme.Controls.Add(this.ExitBtn);
            this.MainTheme.Controls.Add(this.CancelBtn);
            this.MainTheme.Controls.Add(this.HelpBtn);
            this.MainTheme.Controls.Add(this.sLabel);
            this.MainTheme.Controls.Add(this.StatusLbl);
            this.MainTheme.Controls.Add(this.ResetBtn);
            this.MainTheme.Controls.Add(this.AboutBtn);
            this.MainTheme.Controls.Add(this.clsControlMenu1);
            this.MainTheme.Controls.Add(this.RestartBtn_);
            this.MainTheme.Controls.Add(this.ChooseBtn);
            this.MainTheme.Controls.Add(this.PathTxt);
            this.MainTheme.Controls.Add(this.label1);
            this.MainTheme.Controls.Add(this.ProtectBtn);
            this.MainTheme.Controls.Add(this.SettingsBox);
            this.MainTheme.Controls.Add(this.bottomTxt);
            this.MainTheme.Customization = "AAAA/w==";
            this.MainTheme.Dock = System.Windows.Forms.DockStyle.Fill;
            this.MainTheme.Font = new System.Drawing.Font("Segoe UI", 9F);
            this.MainTheme.Image = null;
            this.MainTheme.Location = new System.Drawing.Point(0, 0);
            this.MainTheme.Movable = true;
            this.MainTheme.Name = "MainTheme";
            this.MainTheme.NoRounding = false;
            this.MainTheme.Sizable = false;
            this.MainTheme.Size = new System.Drawing.Size(364, 350);
            this.MainTheme.SmartBounds = true;
            this.MainTheme.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.MainTheme.TabIndex = 0;
            this.MainTheme.Text = "Unity3D Obfuscator";
            this.MainTheme.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.Transparent = false;
            this.MainTheme.Click += new System.EventHandler(this.MainTheme_Click);
            // 
            // ExitBtn
            // 
            this.ExitBtn.Customization = "9fX1/6mpqf8=";
            this.ExitBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ExitBtn.Image = null;
            this.ExitBtn.Location = new System.Drawing.Point(272, 268);
            this.ExitBtn.Name = "ExitBtn";
            this.ExitBtn.NoRounding = false;
            this.ExitBtn.Size = new System.Drawing.Size(87, 28);
            this.ExitBtn.TabIndex = 17;
            this.ExitBtn.Text = "Exit";
            this.ExitBtn.Transparent = false;
            this.ExitBtn.Click += new System.EventHandler(this.ExitBtn_Click);
            // 
            // CancelBtn
            // 
            this.CancelBtn.Font = new System.Drawing.Font("Segoe UI", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.CancelBtn.ForeColor = System.Drawing.Color.Red;
            this.CancelBtn.Location = new System.Drawing.Point(235, 313);
            this.CancelBtn.Name = "CancelBtn";
            this.CancelBtn.Size = new System.Drawing.Size(129, 34);
            this.CancelBtn.TabIndex = 19;
            this.CancelBtn.Text = "Cancel";
            this.CancelBtn.UseVisualStyleBackColor = true;
            this.CancelBtn.Visible = false;
            this.CancelBtn.Click += new System.EventHandler(this.CancelBtn_Click);
            // 
            // HelpBtn
            // 
            this.HelpBtn.Customization = "9fX1/6mpqf8=";
            this.HelpBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.HelpBtn.Image = null;
            this.HelpBtn.Location = new System.Drawing.Point(271, 133);
            this.HelpBtn.Name = "HelpBtn";
            this.HelpBtn.NoRounding = false;
            this.HelpBtn.Size = new System.Drawing.Size(87, 28);
            this.HelpBtn.TabIndex = 18;
            this.HelpBtn.Text = "Help";
            this.HelpBtn.Transparent = false;
            this.HelpBtn.Click += new System.EventHandler(this.HelpBtn_Click);
            // 
            // sLabel
            // 
            this.sLabel.AutoSize = true;
            this.sLabel.BackColor = System.Drawing.Color.Gray;
            this.sLabel.Font = new System.Drawing.Font("Segoe UI Semibold", 13F, ((System.Drawing.FontStyle)((System.Drawing.FontStyle.Bold | System.Drawing.FontStyle.Italic))), System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.sLabel.Location = new System.Drawing.Point(4, 319);
            this.sLabel.Name = "sLabel";
            this.sLabel.Size = new System.Drawing.Size(65, 25);
            this.sLabel.TabIndex = 1;
            this.sLabel.Text = "Status:";
            // 
            // StatusLbl
            // 
            this.StatusLbl.AutoSize = true;
            this.StatusLbl.BackColor = System.Drawing.Color.Gray;
            this.StatusLbl.Font = new System.Drawing.Font("Segoe UI Semibold", 13F, ((System.Drawing.FontStyle)((System.Drawing.FontStyle.Bold | System.Drawing.FontStyle.Italic))), System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.StatusLbl.Location = new System.Drawing.Point(64, 319);
            this.StatusLbl.Name = "StatusLbl";
            this.StatusLbl.Size = new System.Drawing.Size(41, 25);
            this.StatusLbl.TabIndex = 13;
            this.StatusLbl.Text = "Idle";
            // 
            // ResetBtn
            // 
            this.ResetBtn.Customization = "9fX1/6mpqf8=";
            this.ResetBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ResetBtn.Image = null;
            this.ResetBtn.Location = new System.Drawing.Point(271, 201);
            this.ResetBtn.Name = "ResetBtn";
            this.ResetBtn.NoRounding = false;
            this.ResetBtn.Size = new System.Drawing.Size(87, 28);
            this.ResetBtn.TabIndex = 12;
            this.ResetBtn.Text = "Reset";
            this.ResetBtn.Transparent = false;
            this.ResetBtn.Click += new System.EventHandler(this.ResetBtn_Click);
            // 
            // AboutBtn
            // 
            this.AboutBtn.Customization = "9fX1/6mpqf8=";
            this.AboutBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.AboutBtn.Image = null;
            this.AboutBtn.Location = new System.Drawing.Point(271, 104);
            this.AboutBtn.Name = "AboutBtn";
            this.AboutBtn.NoRounding = false;
            this.AboutBtn.Size = new System.Drawing.Size(87, 23);
            this.AboutBtn.TabIndex = 11;
            this.AboutBtn.Text = "About";
            this.AboutBtn.Transparent = false;
            this.AboutBtn.Click += new System.EventHandler(this.AboutBtn_Click);
            // 
            // clsControlMenu1
            // 
            this.clsControlMenu1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)));
            this.clsControlMenu1.Customization = "8u/v/////wD///8A";
            this.clsControlMenu1.Font = new System.Drawing.Font("Verdana", 8F);
            this.clsControlMenu1.Image = null;
            this.clsControlMenu1.Location = new System.Drawing.Point(292, 1);
            this.clsControlMenu1.Name = "clsControlMenu1";
            this.clsControlMenu1.NoRounding = false;
            this.clsControlMenu1.Size = new System.Drawing.Size(71, 19);
            this.clsControlMenu1.TabIndex = 10;
            this.clsControlMenu1.Text = "CtrlMenu";
            this.clsControlMenu1.Transparent = false;
            // 
            // RestartBtn_
            // 
            this.RestartBtn_.Customization = "9fX1/6mpqf8=";
            this.RestartBtn_.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.RestartBtn_.Image = null;
            this.RestartBtn_.Location = new System.Drawing.Point(272, 235);
            this.RestartBtn_.Name = "RestartBtn_";
            this.RestartBtn_.NoRounding = false;
            this.RestartBtn_.Size = new System.Drawing.Size(87, 28);
            this.RestartBtn_.TabIndex = 8;
            this.RestartBtn_.Text = "Restart";
            this.RestartBtn_.Transparent = false;
            this.RestartBtn_.Click += new System.EventHandler(this.RestartBtn);
            // 
            // ChooseBtn
            // 
            this.ChooseBtn.Customization = "9fX1/6mpqf8=";
            this.ChooseBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ChooseBtn.Image = null;
            this.ChooseBtn.Location = new System.Drawing.Point(325, 59);
            this.ChooseBtn.Name = "ChooseBtn";
            this.ChooseBtn.NoRounding = false;
            this.ChooseBtn.Size = new System.Drawing.Size(34, 23);
            this.ChooseBtn.TabIndex = 7;
            this.ChooseBtn.Text = "...";
            this.ChooseBtn.Transparent = false;
            this.ChooseBtn.Click += new System.EventHandler(this.ChooseBtn_Click);
            // 
            // PathTxt
            // 
            this.PathTxt.AllowDrop = true;
            this.PathTxt.Location = new System.Drawing.Point(7, 59);
            this.PathTxt.Name = "PathTxt";
            this.PathTxt.Size = new System.Drawing.Size(312, 23);
            this.PathTxt.TabIndex = 6;
            this.PathTxt.TextChanged += new System.EventHandler(this.PathTxt_TextChanged);
            this.PathTxt.DragDrop += new System.Windows.Forms.DragEventHandler(this.PathTxt_DragDrop);
            this.PathTxt.DragEnter += new System.Windows.Forms.DragEventHandler(this.PathTxt_DragEnter);
            // 
            // label1
            // 
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(3, 41);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(104, 15);
            this.label1.TabIndex = 5;
            this.label1.Text = "Choose Assembly:";
            // 
            // ProtectBtn
            // 
            this.ProtectBtn.Customization = "9fX1/6mpqf8=";
            this.ProtectBtn.Font = new System.Drawing.Font("Verdana", 11.25F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ProtectBtn.Image = null;
            this.ProtectBtn.Location = new System.Drawing.Point(271, 166);
            this.ProtectBtn.Name = "ProtectBtn";
            this.ProtectBtn.NoRounding = false;
            this.ProtectBtn.Size = new System.Drawing.Size(87, 28);
            this.ProtectBtn.TabIndex = 4;
            this.ProtectBtn.Text = "Protect!";
            this.ProtectBtn.Transparent = false;
            this.ProtectBtn.Click += new System.EventHandler(this.ProtectBtn_Click);
            // 
            // SettingsBox
            // 
            this.SettingsBox.Controls.Add(this.StringEncrypyionTypeCB);
            this.SettingsBox.Controls.Add(this.label3);
            this.SettingsBox.Controls.Add(this.ExcludeStringsBtn);
            this.SettingsBox.Controls.Add(this.label2);
            this.SettingsBox.Controls.Add(this.StringEncnryptionCB);
            this.SettingsBox.Controls.Add(this.AntiILDasmCB);
            this.SettingsBox.Controls.Add(this.RandomNameRB);
            this.SettingsBox.Controls.Add(this.EmptyNameRB);
            this.SettingsBox.Controls.Add(this.OpenFolderBtn);
            this.SettingsBox.Controls.Add(this.AntiTamperingCB);
            this.SettingsBox.Controls.Add(this.ExcludeTypesBtn);
            this.SettingsBox.Controls.Add(this.RenameFieldsCB);
            this.SettingsBox.Controls.Add(this.RenameTypesCB);
            this.SettingsBox.Controls.Add(this.RenamePropertiesCB);
            this.SettingsBox.Controls.Add(this.RenameMethodsCB);
            this.SettingsBox.Controls.Add(this.RenameNamespacesCB);
            this.SettingsBox.Location = new System.Drawing.Point(3, 80);
            this.SettingsBox.Name = "SettingsBox";
            this.SettingsBox.Size = new System.Drawing.Size(262, 233);
            this.SettingsBox.TabIndex = 3;
            this.SettingsBox.TabStop = false;
            this.SettingsBox.Text = "Settings";
            // 
            // ExcludeStringsBtn
            // 
            this.ExcludeStringsBtn.Customization = "9fX1/6mpqf8=";
            this.ExcludeStringsBtn.Font = new System.Drawing.Font("Verdana", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ExcludeStringsBtn.Image = null;
            this.ExcludeStringsBtn.Location = new System.Drawing.Point(112, 142);
            this.ExcludeStringsBtn.Name = "ExcludeStringsBtn";
            this.ExcludeStringsBtn.NoRounding = false;
            this.ExcludeStringsBtn.Size = new System.Drawing.Size(148, 24);
            this.ExcludeStringsBtn.TabIndex = 19;
            this.ExcludeStringsBtn.Text = "Exclude Strings";
            this.ExcludeStringsBtn.Transparent = false;
            this.ExcludeStringsBtn.Click += new System.EventHandler(this.ExcludeStringsBtn_Click);
            // 
            // label2
            // 
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(-3, 126);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(92, 15);
            this.label2.TabIndex = 18;
            this.label2.Text = "Renaming Type:";
            // 
            // StringEncnryptionCB
            // 
            this.StringEncnryptionCB.AutoSize = true;
            this.StringEncnryptionCB.Location = new System.Drawing.Point(3, 93);
            this.StringEncnryptionCB.Name = "StringEncnryptionCB";
            this.StringEncnryptionCB.Size = new System.Drawing.Size(117, 19);
            this.StringEncnryptionCB.TabIndex = 11;
            this.StringEncnryptionCB.Text = "String Encryption";
            this.StringEncnryptionCB.UseVisualStyleBackColor = true;
            this.StringEncnryptionCB.CheckedChanged += new System.EventHandler(this.StringEcnryptionCB_CheckedChanged);
            // 
            // AntiILDasmCB
            // 
            this.AntiILDasmCB.AutoSize = true;
            this.AntiILDasmCB.Location = new System.Drawing.Point(3, 17);
            this.AntiILDasmCB.Name = "AntiILDasmCB";
            this.AntiILDasmCB.Size = new System.Drawing.Size(93, 19);
            this.AntiILDasmCB.TabIndex = 10;
            this.AntiILDasmCB.Text = "Anti ILDASM";
            this.AntiILDasmCB.UseVisualStyleBackColor = true;
            this.AntiILDasmCB.CheckedChanged += new System.EventHandler(this.AntiILDasmCB_CheckedChanged);
            // 
            // RandomNameRB
            // 
            this.RandomNameRB.AutoSize = true;
            this.RandomNameRB.BackColor = System.Drawing.Color.Transparent;
            this.RandomNameRB.Checked = true;
            this.RandomNameRB.Location = new System.Drawing.Point(-1, 166);
            this.RandomNameRB.Name = "RandomNameRB";
            this.RandomNameRB.Size = new System.Drawing.Size(105, 19);
            this.RandomNameRB.TabIndex = 9;
            this.RandomNameRB.TabStop = true;
            this.RandomNameRB.Text = "Random Name";
            this.RandomNameRB.UseVisualStyleBackColor = false;
            this.RandomNameRB.CheckedChanged += new System.EventHandler(this.RandomNameRB_CheckedChanged);
            // 
            // EmptyNameRB
            // 
            this.EmptyNameRB.AutoSize = true;
            this.EmptyNameRB.Location = new System.Drawing.Point(-1, 144);
            this.EmptyNameRB.Name = "EmptyNameRB";
            this.EmptyNameRB.Size = new System.Drawing.Size(94, 19);
            this.EmptyNameRB.TabIndex = 8;
            this.EmptyNameRB.Text = "Empty Name";
            this.EmptyNameRB.UseVisualStyleBackColor = true;
            this.EmptyNameRB.CheckedChanged += new System.EventHandler(this.EmptyNameRB_CheckedChanged);
            // 
            // OpenFolderBtn
            // 
            this.OpenFolderBtn.Customization = "9fX1/6mpqf8=";
            this.OpenFolderBtn.Font = new System.Drawing.Font("Verdana", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.OpenFolderBtn.Image = null;
            this.OpenFolderBtn.Location = new System.Drawing.Point(112, 172);
            this.OpenFolderBtn.Name = "OpenFolderBtn";
            this.OpenFolderBtn.NoRounding = false;
            this.OpenFolderBtn.Size = new System.Drawing.Size(148, 24);
            this.OpenFolderBtn.TabIndex = 7;
            this.OpenFolderBtn.Text = "Open Containg Folder";
            this.OpenFolderBtn.Transparent = false;
            this.OpenFolderBtn.Click += new System.EventHandler(this.OpenFolderBtn_Click);
            // 
            // AntiTamperingCB
            // 
            this.AntiTamperingCB.AutoSize = true;
            this.AntiTamperingCB.Location = new System.Drawing.Point(126, 93);
            this.AntiTamperingCB.Name = "AntiTamperingCB";
            this.AntiTamperingCB.Size = new System.Drawing.Size(108, 19);
            this.AntiTamperingCB.TabIndex = 6;
            this.AntiTamperingCB.Text = "Anti Tampering";
            this.AntiTamperingCB.UseVisualStyleBackColor = true;
            this.AntiTamperingCB.CheckedChanged += new System.EventHandler(this.AntiTamperingCB_CheckedChanged);
            // 
            // ExcludeTypesBtn
            // 
            this.ExcludeTypesBtn.Customization = "9fX1/6mpqf8=";
            this.ExcludeTypesBtn.Font = new System.Drawing.Font("Verdana", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(0)));
            this.ExcludeTypesBtn.Image = null;
            this.ExcludeTypesBtn.Location = new System.Drawing.Point(112, 113);
            this.ExcludeTypesBtn.Name = "ExcludeTypesBtn";
            this.ExcludeTypesBtn.NoRounding = false;
            this.ExcludeTypesBtn.Size = new System.Drawing.Size(150, 24);
            this.ExcludeTypesBtn.TabIndex = 5;
            this.ExcludeTypesBtn.Text = "Exclude Types";
            this.ExcludeTypesBtn.Transparent = false;
            this.ExcludeTypesBtn.Click += new System.EventHandler(this.ExcludeTypesBtn_Click);
            // 
            // RenameFieldsCB
            // 
            this.RenameFieldsCB.AutoSize = true;
            this.RenameFieldsCB.Location = new System.Drawing.Point(125, 68);
            this.RenameFieldsCB.Name = "RenameFieldsCB";
            this.RenameFieldsCB.Size = new System.Drawing.Size(102, 19);
            this.RenameFieldsCB.TabIndex = 4;
            this.RenameFieldsCB.Text = "Rename Fields";
            this.RenameFieldsCB.UseVisualStyleBackColor = true;
            this.RenameFieldsCB.CheckedChanged += new System.EventHandler(this.RenameFieldsCB_CheckedChanged);
            // 
            // RenameTypesCB
            // 
            this.RenameTypesCB.AutoSize = true;
            this.RenameTypesCB.Location = new System.Drawing.Point(3, 42);
            this.RenameTypesCB.Name = "RenameTypesCB";
            this.RenameTypesCB.Size = new System.Drawing.Size(102, 19);
            this.RenameTypesCB.TabIndex = 3;
            this.RenameTypesCB.Text = "Rename Types";
            this.RenameTypesCB.UseVisualStyleBackColor = true;
            this.RenameTypesCB.CheckedChanged += new System.EventHandler(this.RenameTypesCB_CheckedChanged);
            // 
            // RenamePropertiesCB
            // 
            this.RenamePropertiesCB.AutoSize = true;
            this.RenamePropertiesCB.Location = new System.Drawing.Point(3, 67);
            this.RenamePropertiesCB.Name = "RenamePropertiesCB";
            this.RenamePropertiesCB.Size = new System.Drawing.Size(125, 19);
            this.RenamePropertiesCB.TabIndex = 2;
            this.RenamePropertiesCB.Text = "Rename Properties";
            this.RenamePropertiesCB.UseVisualStyleBackColor = true;
            this.RenamePropertiesCB.CheckedChanged += new System.EventHandler(this.RenamePropertiesCB_CheckedChanged);
            // 
            // RenameMethodsCB
            // 
            this.RenameMethodsCB.AutoSize = true;
            this.RenameMethodsCB.Location = new System.Drawing.Point(125, 43);
            this.RenameMethodsCB.Name = "RenameMethodsCB";
            this.RenameMethodsCB.Size = new System.Drawing.Size(119, 19);
            this.RenameMethodsCB.TabIndex = 1;
            this.RenameMethodsCB.Text = "Rename Methods";
            this.RenameMethodsCB.UseVisualStyleBackColor = true;
            this.RenameMethodsCB.CheckedChanged += new System.EventHandler(this.RenameMethodsCB_CheckedChanged);
            // 
            // RenameNamespacesCB
            // 
            this.RenameNamespacesCB.AutoSize = true;
            this.RenameNamespacesCB.Location = new System.Drawing.Point(125, 17);
            this.RenameNamespacesCB.Name = "RenameNamespacesCB";
            this.RenameNamespacesCB.Size = new System.Drawing.Size(139, 19);
            this.RenameNamespacesCB.TabIndex = 0;
            this.RenameNamespacesCB.Text = "Rename Namespaces";
            this.RenameNamespacesCB.UseVisualStyleBackColor = true;
            this.RenameNamespacesCB.CheckedChanged += new System.EventHandler(this.RenameNamespacesCB_CheckedChanged);
            // 
            // bottomTxt
            // 
            this.bottomTxt.BackColor = System.Drawing.Color.Gray;
            this.bottomTxt.BorderStyle = System.Windows.Forms.BorderStyle.None;
            this.bottomTxt.Enabled = false;
            this.bottomTxt.Location = new System.Drawing.Point(0, 313);
            this.bottomTxt.Multiline = true;
            this.bottomTxt.Name = "bottomTxt";
            this.bottomTxt.ReadOnly = true;
            this.bottomTxt.Size = new System.Drawing.Size(364, 35);
            this.bottomTxt.TabIndex = 14;
            // 
            // label3
            // 
            this.label3.AutoSize = true;
            this.label3.Location = new System.Drawing.Point(1, 209);
            this.label3.Name = "label3";
            this.label3.Size = new System.Drawing.Size(129, 15);
            this.label3.TabIndex = 20;
            this.label3.Text = "String Encryption Type:";
            // 
            // StringEncrypyionTypeCB
            // 
            this.StringEncrypyionTypeCB.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.StringEncrypyionTypeCB.FormattingEnabled = true;
            this.StringEncrypyionTypeCB.Items.AddRange(new object[] {
            "Weak",
            "Normal",
            "Strong"});
            this.StringEncrypyionTypeCB.Location = new System.Drawing.Point(136, 205);
            this.StringEncrypyionTypeCB.Name = "StringEncrypyionTypeCB";
            this.StringEncrypyionTypeCB.Size = new System.Drawing.Size(120, 23);
            this.StringEncrypyionTypeCB.TabIndex = 20;
            this.StringEncrypyionTypeCB.SelectedIndexChanged += new System.EventHandler(this.StringEncrypyionTypeCB_SelectedIndexChanged);
            // 
            // MainForm
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(6F, 13F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(364, 350);
            this.Controls.Add(this.MainTheme);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.None;
            this.Name = "MainForm";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
            this.Text = "Unity3D Obfuscator";
            this.TransparencyKey = System.Drawing.Color.Fuchsia;
            this.MainTheme.ResumeLayout(false);
            this.MainTheme.PerformLayout();
            this.SettingsBox.ResumeLayout(false);
            this.SettingsBox.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private FormSkin.clsNeoBuxTheme MainTheme;
        private FormSkin.clsButtonGrey ChooseBtn;
        private System.Windows.Forms.TextBox PathTxt;
        private System.Windows.Forms.Label label1;
        private FormSkin.clsButtonGreen ProtectBtn;
        private System.Windows.Forms.GroupBox SettingsBox;
        private FormSkin.clsButtonOrange RestartBtn_;
        private System.Windows.Forms.CheckBox RenameFieldsCB;
        private System.Windows.Forms.CheckBox RenameTypesCB;
        private System.Windows.Forms.CheckBox RenamePropertiesCB;
        private System.Windows.Forms.CheckBox RenameMethodsCB;
        private System.Windows.Forms.CheckBox RenameNamespacesCB;
        private FormSkin.clsControlMenu clsControlMenu1;
        private FormSkin.clsButtonBlue AboutBtn;
        private FormSkin.clsButtonGrey ExcludeTypesBtn;
        private System.Windows.Forms.CheckBox AntiTamperingCB;
        private FormSkin.clsButtonPurple ResetBtn;
        private System.Windows.Forms.Label StatusLbl;
        private System.Windows.Forms.Label sLabel;
        private System.Windows.Forms.TextBox bottomTxt;
        private FormSkin.clsButtonGrey OpenFolderBtn;
        private FormSkin.clsButtonGrey ExitBtn;
        private System.Windows.Forms.RadioButton RandomNameRB;
        private System.Windows.Forms.RadioButton EmptyNameRB;
        private System.Windows.Forms.CheckBox AntiILDasmCB;
        private System.Windows.Forms.CheckBox StringEncnryptionCB;
        private System.Windows.Forms.Label label2;
        private FormSkin.clsButtonGrey ExcludeStringsBtn;
        private FormSkin.clsButtonOrange HelpBtn;
        private System.Windows.Forms.Button CancelBtn;
        private System.Windows.Forms.ComboBox StringEncrypyionTypeCB;
        private System.Windows.Forms.Label label3;
    }
}


```

`Unity3DObfuscator/MainForm.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.MD;
using dnlib.DotNet.Writer;
using System;
using System.IO;
using System.Media;
using System.Drawing;
using System.Threading;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Diagnostics;
using FormSkin;
using System.Collections.Generic;

namespace Unity3DObfuscator
{
    public partial class MainForm : Form
    {
        [DllImport("user32.dll")]
        static extern IntPtr GetForegroundWindow();
        public MainForm()
        {
            InitializeComponent();
            StringEncrypyionTypeCB.SelectedIndex = 1;
        }
        private void Protect() //The 'protect' function.
        {
            Invoke((MethodInvoker)(() => StatusLbl.Text = "Obfuscating..."));
            Invoke((MethodInvoker)(() => StatusLbl.ForeColor = Color.Yellow));
            Invoke((MethodInvoker)(() => SetControls(false)));
            try
            {
                MainClass.MainModule = ModuleDefMD.Load(File.ReadAllBytes(MainClass.Settings.AssemblyPath));
                MainClass.AntiILDasm.Execute();
                MainClass.Renaming.RenameNamespaces();
                MainClass.Renaming.RenameTypes();
                MainClass.Renaming.RenameMethods();
                MainClass.Renaming.RenameFields();
                MainClass.Renaming.RenameProperties();
                MainClass.StringEcnryption.Encrypt();
                //This part is very important. If the anti tampering is enabled then the type of the custom attribute will be with a radnom namespace and type name.
                //Making it harder for a deobfuscator to detect it. Or else it will have its normal namespace and type name.
                if (!MainClass.Settings.AntiTampering)
                {
                    Watermarking.Watermark("UnityObfuscator.Attributes", "ObfuscatedByAttribute", "Unity3D Obfuscator by AkyrosXD");
                }
                else
                {
                    Watermarking.Watermark(string.Concat(GlobalStrings.RandomString, ".", GlobalStrings.RandomString), string.Concat(GlobalStrings.RandomString, "Attribute"), "Obfuscated by [Unity3D Obfuscator by AkyrosXD]");
                }
                MainClass.AntiTampering.ExecuteAntiTampering();
                SaveProtectedAssembly();
                Invoke((MethodInvoker)(() => StatusLbl.Text = "Obfuscation Completed!"));
                Invoke((MethodInvoker)(() => StatusLbl.ForeColor = Color.LimeGreen));
                Invoke((MethodInvoker)(() => SetControls(true)));
                MainClass.ObfuscationThread = null;
            }
            catch (Exception ex)
            {
                if(ex.Message.Equals("Thread was being aborted."))
                {
                    Invoke((MethodInvoker)(() => CancelBtn.Visible = false));
                    MainClass.ObfuscationThread = null;
                    Invoke((MethodInvoker)(() => SetControls(true)));
                    return;
                }
                Invoke((MethodInvoker)(() => StatusLbl.Text = "Obfuscation Failed!"));
                Invoke((MethodInvoker)(() => StatusLbl.ForeColor = Color.Red));
                Invoke((MethodInvoker)(() => SetControls(true)));
                NativeWindow nativeWindow = new NativeWindow();
                nativeWindow.AssignHandle(GetForegroundWindow());
                MessageBox.Show(nativeWindow, "An error occurred!\nException:\n" + ex.Message, string.Empty, MessageBoxButtons.OK, MessageBoxIcon.Error);
                MainClass.ObfuscationThread = null;

            }
        }
        private void SaveProtectedAssembly() //Saves the protected assembly to disk.
        {
            string file = Path.Combine(Path.GetDirectoryName(MainClass.Settings.AssemblyPath), Path.GetFileNameWithoutExtension(MainClass.Settings.AssemblyPath) + "_protected" + ".dll");
            if (File.Exists(file))
            {
                File.Delete(file);
            }
            ModuleWriter w = new ModuleWriter(MainClass.MainModule, new ModuleWriterOptions(MainClass.MainModule, DummyModuleWriterListener.Instance));
            w.Options.ModuleKind = ModuleKind.Dll;
            w.Options.Logger = DummyLogger.NoThrowInstance;
            MainClass.MainModule.Write(file, w.Options);
        }
        private void SetControls(bool enabled) //Set the controls to enabled / disabled or visible while the obfuscation is in progress or not.
        {
            foreach (Control c in MainTheme.Controls)
            {
                if (c != bottomTxt && c != sLabel && c != StatusLbl && c != CancelBtn)
                {
                    c.Enabled = enabled;
                    
                }
            }
            ProtectBtn.Visible = enabled;
            CancelBtn.Visible = !enabled;
        }
        private void ChooseBtn_Click(object sender, EventArgs e) //Show file dialog.
        { 
            OpenFileDialog dialog = new OpenFileDialog
            {
                Multiselect = false,
                Filter = ".DLL|*.dll; *.Dll"
            };
            if (dialog.ShowDialog(this) == DialogResult.OK)
            {
                if((MainClass.Settings.AssemblyPath == string.Empty || MainClass.Settings.ContainingFolder == string.Empty) || MainClass.Settings.AssemblyPath != dialog.FileName)
                {
                    StatusLbl.Text = "Idle";
                    StatusLbl.ForeColor = Color.Black;
                    Exclusion.Types.Clear();
                    Exclusion.ExludedTypes.Clear();
                }
                MainClass.Settings.AssemblyPath = dialog.FileName;
                MainClass.Settings.ContainingFolder = Path.GetDirectoryName(MainClass.Settings.AssemblyPath);               
                PathTxt.Text = dialog.FileName;
                try
                {
                    MainClass.MainModule = ModuleDefMD.Load(File.ReadAllBytes(MainClass.Settings.AssemblyPath));
                }
                catch
                {
                    MainClass.MainModule = null;
                }
            }
        }
        private void PathTxt_DragDrop(object sender, DragEventArgs e) //Ignore this.
        {
            
        }
        private void PathTxt_DragEnter(object sender, DragEventArgs e) //You can also drag your assembly directly to the text box instead of browsing it with the file dialog.
        {
            string[] files = (string[])e.Data.GetData(DataFormats.FileDrop);
            if (files != null && files.Length != 0)
            {
                string file = files[0];
                if (file.EndsWith(".dll"))
                {
                    if ((MainClass.Settings.AssemblyPath == string.Empty || MainClass.Settings.ContainingFolder == string.Empty) || MainClass.Settings.AssemblyPath != file)
                    {
                        StatusLbl.Text = "Idle";
                        StatusLbl.ForeColor = Color.Black;
                        Exclusion.Types.Clear();
                        Exclusion.ExludedTypes.Clear();
                        e.Effect = DragDropEffects.Copy;
                        PathTxt.Text = file;
                        MainClass.Settings.AssemblyPath = file;
                    }
                }
            }
        }
        private void PathTxt_TextChanged(object sender, EventArgs e) //Updates the main module when the path of the assembly changes.
        {
            MainClass.Settings.AssemblyPath = PathTxt.Text;
            try
            {
                MainClass.MainModule = ModuleDefMD.Load(File.ReadAllBytes(MainClass.Settings.AssemblyPath));
            }
            catch
            { 
            }
        }
        /* The rest are just functions of what happens when the checkboxes are checked / unchecked. */
        private void AntiILDasmCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.AntiILDasm = AntiILDasmCB.Checked;
            SystemSounds.Asterisk.Play();
        }
        private void RenameNamespacesCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RenameNamespaces = RenameNamespacesCB.Checked;
            SystemSounds.Asterisk.Play();
        }

        private void RenameTypesCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RenameTypes = RenameTypesCB.Checked;
            SystemSounds.Asterisk.Play();
        }

        private void RenameMethodsCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RenameMethods = RenameMethodsCB.Checked;
            SystemSounds.Asterisk.Play();
        }

        private void RenameFieldsCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RenameFields = RenameFieldsCB.Checked;
            SystemSounds.Asterisk.Play();
        }

        private void RenamePropertiesCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RenameProperties = RenamePropertiesCB.Checked;
            SystemSounds.Asterisk.Play();
        }
        private void AntiTamperingCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.AntiTampering = AntiTamperingCB.Checked;
            SystemSounds.Asterisk.Play();
        }
        private void RandomNameRB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RandomName = true;
            MainClass.Settings.EmptyName = false;
            SystemSounds.Asterisk.Play();
        }
        private void StringEcnryptionCB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.StringEcnryption = StringEncnryptionCB.Checked;
            SystemSounds.Asterisk.Play();
        }
        private void EmptyNameRB_CheckedChanged(object sender, EventArgs e)
        {
            MainClass.Settings.RandomName = false;
            MainClass.Settings.EmptyName = true;
            SystemSounds.Asterisk.Play();
        }

        private void ExcludeTypesBtn_Click(object sender, EventArgs e) //Shows the 'Exclude Types' form.
        {
            try
            {
                MainClass.MainModule = ModuleDefMD.Load(File.ReadAllBytes(MainClass.Settings.AssemblyPath));
            }
            catch
            {
                MainClass.MainModule = null;
            }
            new ExcludeTypesForm().ShowDialog();
        }
        private void OpenFolderBtn_Click(object sender, EventArgs e) //Opens the containing folder.
        {
            if(MainClass.Settings.ContainingFolder == string.Empty || !Directory.Exists(MainClass.Settings.ContainingFolder))
            {
                return;
            }
            Process.Start(MainClass.Settings.ContainingFolder);
        }
        private void ProtectBtn_Click(object sender, EventArgs e) //Protects the assembly.
        {
            if (!MainClass.Settings.AssemblyExists)
            {
                MessageBox.Show("DLL not found!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            else if (!MainClass.Settings.IsAssemblyDotNet)
            {
                MessageBox.Show("The selected assebly is not a .NET module!", "Error", MessageBoxButtons.OK, MessageBoxIcon.Error);
                return;
            }
            else
            {
                if (MainClass.Settings.Check())
                {
                    MainClass.ObfuscationThread = new Thread(Protect);
                    MainClass.ObfuscationThread.Start();

                }
            }
        }

        private void AboutBtn_Click(object sender, EventArgs e) //Just an "About" dialog.
        {
            MessageBox.Show("Coded by AkyrosXD", "About", MessageBoxButtons.OK, MessageBoxIcon.Information);
        }

        private void ResetBtn_Click(object sender, EventArgs e) //Resets all the settings.
        {
            foreach (Control c in SettingsBox.Controls)
            {
                if (c is CheckBox cb)
                {
                    if (cb.Checked)
                    {
                        DialogResult r = MessageBox.Show("All the settings will be reseted!\nAre you sure you want to continue?", "Question", MessageBoxButtons.OKCancel, MessageBoxIcon.Question);
                        if(r == DialogResult.OK)
                        {
                            MainClass.Settings.Reset(SettingsBox.Controls);
                        }
                        else
                        {
                            break;
                        }
                    }
                }
            }
        }
        private void RestartBtn(object sender, EventArgs e) //Restarts the form.
        {
            MainClass.Settings.Restart(this);
        }
        private void ExitBtn_Click(object sender, EventArgs e)
        {
            Close();
        }

        private void ExcludeStringsBtn_Click(object sender, EventArgs e) //Shows the 'Exlude Strings' form.
        {
            try
            {
                MainClass.MainModule = ModuleDefMD.Load(File.ReadAllBytes(MainClass.Settings.AssemblyPath));
            }
            catch
            {
                MainClass.MainModule = null;
            }
            new ExcludeStringsForm().ShowDialog();
        }

        private void HelpBtn_Click(object sender, EventArgs e) //Shows the 'Help' form. For more info if someone needs help.
        {
            new HelpForm().ShowDialog();
        }

        private void CancelBtn_Click(object sender, EventArgs e) //Cancels the obfuscation task if it's still in progress.
        {
            if(MainClass.ObfuscationThread != null)
            {
                MainClass.ObfuscationThread.Abort();
                StatusLbl.Text = "Canceled!";
                StatusLbl.ForeColor = Color.Red;
            }
        }

        private void MainTheme_Click(object sender, EventArgs e) //Ignore this.
        {

        }

        private void StringEncrypyionTypeCB_SelectedIndexChanged(object sender, EventArgs e) //Changes the string encryption level when the index of the combo box changes.
        {
            MainClass.Settings.StringEncryptionLevel = StringEncrypyionTypeCB.SelectedIndex;
        }
    }
}
```

`Unity3DObfuscator/MainForm.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Unity3DObfuscator/ObfuscationSettings.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Unity3DObfuscator
{
    //All the obfuscation settings.
    public class ObfuscationSettings
    {
        private string assemblyPath = string.Empty;
        private string containingFolder = string.Empty;
        private bool antiILDasm = false;
        private bool renameNamespaces = false;
        private bool renameTypes = false;
        private bool renameMethods = false;
        private bool renameFields = false;
        private bool renameProperties = false;
        private bool stringEcnryption = false;
        private bool antiTampering = false;
        private bool randomName = true;
        private bool emptyName = false;
        private int stringEncryptionLevel = 1;
        public bool IsAssemblyDotNet => GetIsAssemblyDotNet();
        public bool AssemblyExists => GetAssemblyExists();
        public string AssemblyPath { get => assemblyPath; set => assemblyPath = value; }
        public string ContainingFolder { get => containingFolder; set => containingFolder = value; }
        public bool AntiILDasm { get => antiILDasm; set => antiILDasm = value; }
        public bool RenameNamespaces { get => renameNamespaces; set => renameNamespaces = value; }
        public bool RenameTypes { get => renameTypes; set => renameTypes = value; }
        public bool RenameMethods { get => renameMethods; set => renameMethods = value; }
        public bool RenameFields { get => renameFields; set => renameFields = value; }
        public bool RenameProperties { get => renameProperties; set => renameProperties = value; }
        public bool StringEcnryption { get => stringEcnryption; set => stringEcnryption = value; }
        public bool AntiTampering { get => antiTampering; set => antiTampering = value; }
        public bool RandomName { get => randomName; set => randomName = value; }
        public bool EmptyName { get => emptyName; set => emptyName = value; }
        public int StringEncryptionLevel { get => stringEncryptionLevel; set => stringEncryptionLevel = value; }

        public void Restart(Form currentForm) //Restats the application.
        {
            Process.Start(Application.ExecutablePath);
            currentForm.Close();
        }
        public void Reset(Control.ControlCollection settingsControls) //Resets all the settings.
        {
            foreach (Control c in settingsControls)
            {
                if (c is CheckBox cb)
                {
                    cb.Checked = false;
                }
            }
        }
        public bool Check() //Checks if one of the checkboxes is checked.
        {
            return (antiILDasm || renameNamespaces || renameTypes || renameMethods || renameFields || renameProperties || antiTampering || stringEcnryption);
        }
        private bool GetIsAssemblyDotNet() //Checks if the selected assembly is a .NET module. Source: https://stackoverflow.com/questions/1366503/best-way-to-check-if-a-dll-file-is-a-clr-assembly-in-c-sharp/1366517#1366517
        {
            Stream fs = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read);
            BinaryReader reader = new BinaryReader(fs);
            fs.Position = 60;
            var peHeader = reader.ReadUInt32();
            fs.Position = peHeader;
            uint[] dataDictionaryRva = new uint[16];
            uint[] dataDictionarySize = new uint[16];
            var peHeaderSignature = reader.ReadUInt32();
            var machine = reader.ReadUInt16();
            var sections = reader.ReadUInt16();
            var timestamp = reader.ReadUInt32();
            var pSymbolTable = reader.ReadUInt32();
            var noOfSymbol = reader.ReadUInt32();
            var optionalHeaderSize = reader.ReadUInt16();
            var characteristics = reader.ReadUInt16();
            var dataDictionaryStart = Convert.ToUInt16(Convert.ToUInt16(fs.Position) + 96);
            fs.Position = dataDictionaryStart;
            for (int i = 0; i < 15; i++)
            {
                dataDictionaryRva[i] = reader.ReadUInt32();
                dataDictionarySize[i] = reader.ReadUInt32();
            }
            if (dataDictionaryRva[14] == 0)
            {
                fs.Close();
                return false;
            }
            fs.Close();
            return true;
        }
        private bool GetAssemblyExists()
        {
            return (File.Exists(assemblyPath));
        }
        public Type GetStringDencryptionType() //Get the string dencryption type.
        {
            switch (stringEncryptionLevel)
            {
                case 1:
                    return typeof(StringDecryptionHelpers.Normal);

                case 2:
                    return typeof(StringDecryptionHelpers.Strong);
            }
            return typeof(StringDecryptionHelpers.Weak);
        }
        public string GetStringDencryptionMethod() //Gets the method that decrypts the string.
        {
            switch (stringEncryptionLevel)
            {
                case 1:
                    return "c";

                case 2:
                    return "d";
            }
            return "b";
        }
    }
}
```

`Unity3DObfuscator/ObfuscatorHelp.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    //The help tabs.
    public struct ObfuscatorHelp
    {
        public static string Renaming => GetRenaming();
        public static string StringEncryption => GetStringEcryption();
        public static string AntiTampering => GetAntiTampering();

        private static string GetRenaming()
        {
            return "Renaming obfuscation protects your assembly by renaming classes, methods, fields and properties with random letters or an empty text. You can also exclude the types that you don't wanna be renamed, that also includes its methods, fields and other.. Classes that have  'MonoBehaviour' as Base Type, will not be renamed. This obfuscation will make it harder for a person to understand what some classes and other things do.";
        }
        private static string GetStringEcryption()
        {
            return "String encryption encrypts all the strings in the assembly. Which means it will be harder for a person to read a string / text by encoding it. This function is very usefull if you want to hide a license key or something similar.";
        }
        private static string GetAntiTampering()
        {
            return "Anti tampering is a protection that prevents your assembly to be modified. If someone tries to modify your assembly, None of the code on the assembly will work when the hacker tries to open the game with the modified version of the assembly.";
        }
    }
}

```

`Unity3DObfuscator/Program.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace Unity3DObfuscator
{
    static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}

```

`Unity3DObfuscator/Properties/AssemblyInfo.cs`:

```cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("Unity3D Obfuscator")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("AkyrosXD")]
[assembly: AssemblyProduct("Unity3D Obfuscator")]
[assembly: AssemblyCopyright("Copyright © Pussy 2018")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(true)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("65485e2b-fa14-4f59-bde7-f4f3e7909321")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]

```

`Unity3DObfuscator/Properties/Resources.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Unity3DObfuscator.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Unity3DObfuscator.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}

```

`Unity3DObfuscator/Properties/Resources.resx`:

```resx
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>
```

`Unity3DObfuscator/Properties/Settings.Designer.cs`:

```cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Unity3DObfuscator.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}

```

`Unity3DObfuscator/Properties/Settings.settings`:

```settings
<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>

```

`Unity3DObfuscator/RenamingClass.cs`:

```cs
using dnlib.DotNet;
using System.Collections.Generic;

namespace Unity3DObfuscator
{
    //The renaming class.
    public class RenamingClass
    {
        public void RenameNamespaces() //Renames the namespaces. It doesn't rename a namespace of a type if the type is excluded.
        {
            if (!MainClass.Settings.RenameNamespaces)
            {
                return;
            }
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (TypeExists(type))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        if (IsMonoType(type))
                        {
                            continue;
                        }
                        else
                        {
                            type.Namespace = GlobalStrings.RandomString;
                        }
                    }
                }
            }
        }
        public void RenameTypes() //Renames the types. It doesn't rename the types that are excluded or have 'MonoBehaviour' as BaseType.
        {
            if (!MainClass.Settings.RenameTypes)
            {
                return;
            }
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (TypeExists(type))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        if(IsMonoType(type))
                        {
                            continue;
                        }
                        else
                        {
                            type.Name = GlobalStrings.RenamingString;
                        }
                        foreach (TypeDef nestedType in type.NestedTypes)
                        {
                            if (TypeExists(nestedType))
                            {
                                nestedType.Name = GlobalStrings.RenamingString;
                            }
                        }
                    }
                }
            }
        }
        public void RenameMethods() //Renames the methods. It doesn't rename the methods that their type is excluded or are execution functions in Unity. Example: Start, Update, OnGUI, etc...
        {
            if (!MainClass.Settings.RenameMethods)
            {
                return;
            }
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (TypeExists(type))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        foreach (MethodDef method in type.Methods)
                        {
                            if (MethodExists(type, method))
                            {
                                if (method.Name != ".ctor" && method.Name != ".cctor")
                                {
                                    if (IsMonoType(type))
                                    {
                                        if (!Exclusion.UnityFunctions.Contains(method.Name))
                                        {
                                            method.Name = GlobalStrings.RenamingString;
                                        }
                                    }
                                    else
                                    {
                                        method.Name = GlobalStrings.RenamingString;
                                    }
                                    if (method.HasParamDefs)
                                    {
                                        foreach (ParamDef pr in method.ParamDefs)
                                        {
                                            if (pr == null)
                                            {
                                                return;
                                            }
                                            pr.Name = GlobalStrings.RandomString;
                                        }
                                    }
                                }
                            }
                            KeepOldMaxStack(method); //Keeps the old MaxStack.
                        }
                    }
                }
            }
        }
        public void RenameFields() //Renames the fields. It doesn't rename the fields that their type is excluded.
        {
            if (!MainClass.Settings.RenameFields)
            {
                return;
            }
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (TypeExists(type))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        foreach (FieldDef field in type.Fields)
                        {
                            if (FieldExists(type, field))
                            {
                                field.Name = GlobalStrings.RenamingString;
                            }
                        }
                        foreach (TypeDef nestedType in type.NestedTypes)
                        {
                            if (TypeExists(nestedType))
                            {
                                foreach (FieldDef field in nestedType.Fields)
                                {
                                    if (FieldExists(nestedType, field))
                                    {
                                        field.Name = GlobalStrings.RenamingString;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        public void RenameProperties() //Renames the properties. It doesn't rename the properties that their type is excluded.
        {
            if (!MainClass.Settings.RenameProperties)
            {
                return;
            }
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (TypeExists(type))
                {
                    if (!Exclusion.ExludedTypes.Contains(type.FullName))
                    {
                        foreach (PropertyDef property in type.Properties)
                        {
                            if (PropertyExists(type, property))
                            {
                                property.Name = GlobalStrings.RenamingString;
                            }
                        }
                        foreach (TypeDef nestedType in type.NestedTypes)
                        {
                            if (TypeExists(nestedType))
                            {
                                foreach (PropertyDef property in nestedType.Properties)
                                {
                                    if (PropertyExists(nestedType, property))
                                    {
                                        property.Name = GlobalStrings.RenamingString;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        private void KeepOldMaxStack(MethodDef method) //Keeps the old MaxStack of every method.
        {
            if (method != null)
            {
                if (method.HasBody)
                {
                    if (!method.Body.KeepOldMaxStack)
                    {
                        method.Body.KeepOldMaxStack = true;
                    }
                }
            }
        }
        private TypeDef FindType(string typeName) //I made this functions that finds the Type by their name.
        {
            foreach (TypeDef type in MainClass.MainModule.Types)
            {
                if (type.Name == typeName)
                {
                    return type;
                }
            }
            return null;
        }
        private bool TypeExists(TypeDef type) //Checks if the type exists.
        {
            return (type != null && MainClass.MainModule.HasTypes && !type.IsGlobalModuleType && (!type.Name.StartsWith("<") && !type.Name.EndsWith(">")));
        }
        private bool MethodExists(TypeDef type, MethodDef method) //Checks if the method exists.
        {
            return (method != null && !type.IsGlobalModuleType && (!type.Name.StartsWith("<") && !type.Name.EndsWith(">")) && type.HasMethods && method != null && method.HasBody && !method.IsVirtual);
        }
        private bool FieldExists(TypeDef type, FieldDef field) //Checks if the field exists.
        {
            return (type != null && !type.IsGlobalModuleType && (!type.Name.StartsWith("<") && !type.Name.EndsWith(">")) && type.HasFields && field != null);
        }
        private bool PropertyExists(TypeDef type, PropertyDef property) //Checks if the property exists.
        {
            return (type != null && !type.IsGlobalModuleType && (!type.Name.StartsWith("<") && !type.Name.EndsWith(">")) && type.HasProperties && property != null);
        }
        private bool IsMonoType(TypeDef type) //Checks if the type is a 'MonoBehaviour' type. which most of the time a 'MonoBehaviour' type is a script of the game and it won't work if the type gets renamed.
        {
            List<TypeDef> monoTypes = new List<TypeDef>(new TypeDef[0]);
            if (type.BaseType != null && type.BaseType.TypeName == "MonoBehaviour")
            {
                if (!monoTypes.Contains(type))
                {
                    monoTypes.Add(type);
                }
            }
            TypeDef bType2 = null;
            TypeDef bType3 = null;
            TypeDef bType4 = null;
            TypeDef bType5 = null;
            if (type.BaseType != null)
            {
                bType2 = FindType(type.BaseType.TypeName);
            }
            if (bType2 != null && bType2.BaseType != null)
            {
                bType3 = FindType(bType2.BaseType.TypeName);
            }
            if (bType3 != null && bType3.BaseType != null)
            {
                bType4 = FindType(bType2.BaseType.TypeName);
            }
            if (bType4 != null && bType4.BaseType != null)
            {
                bType5 = FindType(bType2.BaseType.TypeName);
            }
            return ((type.BaseType != null && type.BaseType.TypeName == "MonoBehaviour") || (monoTypes.Contains(type)) || (FindType(type.BaseType.TypeName) != null && monoTypes.Contains(FindType(type.BaseType.TypeName))) || (type.BaseType != null && type.BaseType.TypeName == "MonoBehaviour") || ((bType2 != null && bType2.BaseType.TypeName == "MonoBehaviour") || (bType3 != null && bType3.BaseType.TypeName == "MonoBehaviour") || (bType4 != null && bType4.BaseType.TypeName == "MonoBehaviour") || (bType5 != null && bType5.BaseType.TypeName == "MonoBehaviour")));
        }
    }
}
```

`Unity3DObfuscator/StringDecryptionHelper.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.IO;

namespace Unity3DObfuscator
{
    //String Decryption Helper class.
    public class StringDecryptionHelpers
    {
        internal class Weak
        {
            internal static string a(string text)
            {
                return Encoding.ASCII.GetString(Convert.FromBase64String(text));
            }
            internal static string b(string text)
            {
                return a(a(a(a(a(text)))));
            }
        }
        internal class Normal
        {
            internal static string a(string text)
            {
                return Encoding.ASCII.GetString(Convert.FromBase64String(text));
            }
            internal static string b(string text)
            {
                return a(a(a(a(a(text)))));
            }
            internal static string c(string text)
            {
                return b(b(text));
            }
        }
        internal class Strong
        {
            internal static string a(string text)
            {
                return Encoding.ASCII.GetString(Convert.FromBase64String(text));
            }
            internal static string b(string text)
            {
                return a(a(a(a(a(text)))));
            }
            internal static string c(string text)
            {
                return b(b(text));
            }
            internal static string d(string text)
            {
                return a(b(text));
            }
        }
    }
}
```

`Unity3DObfuscator/StringEncoding.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Unity3DObfuscator
{
    public struct StringEncoding
    {
        private static string a(string text) //encoding
        {
            return Convert.ToBase64String(Encoding.UTF8.GetBytes(text));
        }
        private static string b(string text) //weak
        {
            return a(a(a(a(a(text)))));
        }
        private static string c(string text) //normal
        {
            return b(b(text));
        }
        private static string d(string text) //strong
        {
            return a(b(text));
        }
        public static string EncryptString(string text)
        {
            switch (MainClass.Settings.StringEncryptionLevel)
            {
                case 1:
                    return c(text);

                case 2:
                    return d(text);
            }
            return b(text);
        }
    }
}

```

`Unity3DObfuscator/StringEncryptionClass.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using dnlib.DotNet;
using System.Security.Cryptography;
using System.IO;
using dnlib.DotNet.Emit;

namespace Unity3DObfuscator
{
    //String Encryption class.
    public class StringEncryptionClass
    {
        public void Encrypt()
        {
            if (!MainClass.Settings.StringEcnryption)
            {
                return;
            }
            Protect(MainClass.MainModule);
        }
        private static MethodDef _injectedMethodDef;

        private void Protect(ModuleDefMD module) //module equals the loaded file
        {
            InjectClass(module);
            ProtectStrings(module);
        }
        private void ProtectStrings(ModuleDefMD module) //Encodes all the strings.
        {
            foreach (TypeDef type in module.GetTypes())
            {
                foreach (MethodDef method in type.Methods)
                {
                    if (!method.HasBody) continue;
                    var instr = method.Body.Instructions;
                    for (int i = 0; i < instr.Count; i++)
                    {
                        if (instr[i].OpCode == OpCodes.Ldstr)
                        {
                            var originalStr = instr[i].Operand as string;
                            if (Exclusion.ExcludedStrings.Contains(originalStr))
                            {
                                continue;
                            }
                            var encodedStr = StringEncoding.EncryptString(originalStr);
                            instr[i].Operand = encodedStr;
                            instr.Insert(i + 1, Instruction.Create(OpCodes.Call, _injectedMethodDef));
                            method.Body.SimplifyBranches();
                            method.Body.OptimizeBranches();
                        }
                    }
                }
            }
        }
        private static void InjectClass(ModuleDef module) //Injects the StringDecryptionHelper functions in to the assembly.
        {
            Type type = MainClass.Settings.GetStringDencryptionType();
            ModuleDefMD typeModule = ModuleDefMD.Load(type.Module);
            TypeDef typeDef = typeModule.ResolveTypeDef(MDToken.ToRID(type.MetadataToken));
            IEnumerable<IDnlibDef> members = InjectHelper.Inject(typeDef, module.GlobalType, module);
            _injectedMethodDef = (MethodDef)members.Single(method => method.Name == MainClass.Settings.GetStringDencryptionMethod());
            foreach (MethodDef md in module.GlobalType.Methods)
            {
                if (md.Name == ".ctor")
                {
                    module.GlobalType.Remove(md);
                    break;
                }
            }
        }
    }
}

```

`Unity3DObfuscator/Unity3DObfuscator.csproj`:

```csproj
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{65485E2B-FA14-4F59-BDE7-F4F3E7909321}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>Unity3DObfuscator</RootNamespace>
    <AssemblyName>Unity3DObfuscator</AssemblyName>
    <TargetFrameworkVersion>v4.5.2</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="dnlib, Version=1.6.0.0, Culture=neutral, PublicKeyToken=50e96378b6e77999, processorArchitecture=MSIL">
      <SpecificVersion>False</SpecificVersion>
      <HintPath>.\dnlib.dll</HintPath>
    </Reference>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="AntiILDasmClass.cs" />
    <Compile Include="AntiTamperingClass.cs" />
    <Compile Include="clsNeoBuxTheme.cs">
      <SubType>Component</SubType>
    </Compile>
    <Compile Include="ExcludeStringsForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="ExcludeStringsForm.Designer.cs">
      <DependentUpon>ExcludeStringsForm.cs</DependentUpon>
    </Compile>
    <Compile Include="ExcludeTypesForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="ExcludeTypesForm.Designer.cs">
      <DependentUpon>ExcludeTypesForm.cs</DependentUpon>
    </Compile>
    <Compile Include="Exclusion.cs" />
    <Compile Include="HelpForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="HelpForm.Designer.cs">
      <DependentUpon>HelpForm.cs</DependentUpon>
    </Compile>
    <Compile Include="InjectHelper.cs" />
    <Compile Include="MainClass.cs" />
    <Compile Include="MainForm.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="MainForm.Designer.cs">
      <DependentUpon>MainForm.cs</DependentUpon>
    </Compile>
    <Compile Include="ObfuscationSettings.cs" />
    <Compile Include="ObfuscatorHelp.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="GlobalStrings.cs" />
    <Compile Include="RenamingClass.cs" />
    <Compile Include="StringDecryptionHelper.cs" />
    <Compile Include="StringEncoding.cs" />
    <Compile Include="StringEncryptionClass.cs" />
    <Compile Include="Watermarking.cs" />
    <EmbeddedResource Include="ExcludeStringsForm.resx">
      <DependentUpon>ExcludeStringsForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="ExcludeTypesForm.resx">
      <DependentUpon>ExcludeTypesForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="HelpForm.resx">
      <DependentUpon>HelpForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="MainForm.resx">
      <DependentUpon>MainForm.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
```

`Unity3DObfuscator/Watermarking.cs`:

```cs
using dnlib.DotNet;
using dnlib.DotNet.Emit;
using System;

namespace Unity3DObfuscator
{
    //Watermarking class.
    //Credit: The original custom attribute functions are from the ConfuserEx project.
    public class Watermarking
    {
        public static void AddCustomAttributeToAssembly(string Namespace, string AttributeName, string Value) //Adds a custom attribute to the assembly.
        {
            TypeRef attrRef = MainClass.MainModule.CorLibTypes.GetTypeRef("System", "Attribute");
            TypeDefUser attrType = new TypeDefUser(Namespace, AttributeName, attrRef);
            MainClass.MainModule.Types.Add(attrType);
            MethodDefUser ctor = new MethodDefUser(".ctor", MethodSig.CreateInstance(MainClass.MainModule.CorLibTypes.Void, MainClass.MainModule.CorLibTypes.String), MethodImplAttributes.IL, MethodAttributes.FamANDAssem | MethodAttributes.Family | MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName)
            {
                Body = new CilBody()
                {
                    MaxStack = 1
                }
            };
            ctor.Body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
            ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(MainClass.MainModule, ".ctor", MethodSig.CreateInstance(MainClass.MainModule.CorLibTypes.Void), attrRef)));
            ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
            attrType.Methods.Add(ctor);
            CustomAttribute attr = new CustomAttribute(ctor);
            attr.ConstructorArguments.Add(new CAArgument(MainClass.MainModule.CorLibTypes.String, Value));
            MainClass.MainModule.Assembly.CustomAttributes.Add(attr);
        }
        private static void AddCustomAttributeToModule(string Namespace, string AttributeName, string Value) //Adds a custom attribute to the module.
        {
            TypeRef attrRef = MainClass.MainModule.CorLibTypes.GetTypeRef("System", "Attribute");
            TypeDefUser attrType = new TypeDefUser(Namespace, AttributeName, attrRef);
            MainClass.MainModule.Types.Add(attrType);
            MethodDefUser ctor = new MethodDefUser(".ctor", MethodSig.CreateInstance(MainClass.MainModule.CorLibTypes.Void, MainClass.MainModule.CorLibTypes.String), MethodImplAttributes.IL, MethodAttributes.FamANDAssem | MethodAttributes.Family | MethodAttributes.Public | MethodAttributes.HideBySig | MethodAttributes.SpecialName | MethodAttributes.RTSpecialName)
            {
                Body = new CilBody()
                {
                    MaxStack = 1
                }
            };
            ctor.Body.Instructions.Add(OpCodes.Ldarg_0.ToInstruction());
            ctor.Body.Instructions.Add(OpCodes.Call.ToInstruction(new MemberRefUser(MainClass.MainModule, ".ctor", MethodSig.CreateInstance(MainClass.MainModule.CorLibTypes.Void), attrRef)));
            ctor.Body.Instructions.Add(OpCodes.Ret.ToInstruction());
            attrType.Methods.Add(ctor);
            CustomAttribute attr = new CustomAttribute(ctor);
            attr.ConstructorArguments.Add(new CAArgument(MainClass.MainModule.CorLibTypes.String, Value));
            MainClass.MainModule.CustomAttributes.Add(attr);
        }
        public static void Watermark(string Namespace, string AttributeName, string Value) //Watermaking function.
        {
            AddCustomAttributeToAssembly(Namespace, AttributeName, Value);
            AddCustomAttributeToModule(Namespace, AttributeName, Value);
        }
        public static void RemoveAttributeType(string typeFullName) //Removes a custom attribute. (A part of the Anti Tampering class)
        {
            try
            {
                TypeDef bType = null;
                MethodDef bMethod = null;
                foreach (TypeDef type in MainClass.MainModule.Types)
                {
                    if (type.FullName == typeFullName)
                    {
                        bType = type;
                        foreach(MethodDef method in type.Methods)
                        {
                            bMethod = method;
                        }
                    }
                }
                if(bMethod != null)
                {
                    bType.Remove(bMethod);
                }
                if(bType != null)
                {
                    MainClass.MainModule.Types.Remove(bType);
                }
            }
            catch
            {

            }
        }
    }
}

```

`Unity3DObfuscator/bin/Debug/Unity3DObfuscator.exe.config`:

```config
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.5.2" />
    </startup>
</configuration>
```

`Unity3DObfuscator/clsNeoBuxTheme.cs`:

```cs
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Windows.Forms;
using System.ComponentModel;
using System.Drawing.Drawing2D;
using System.Runtime.InteropServices;
using System.Drawing.Imaging;
using System.IO;
using System.ComponentModel.Design;


namespace FormSkin
{

    //------------------
    //Creator: aeonhack
    //Site: elitevs.net
    //Created: 08/02/2011
    //Changed: 12/06/2011
    //Version: 1.5.4
    //------------------

    abstract class ThemeContainer154 : ContainerControl
    {

        #region " Initialization "

        protected Graphics G;

        protected Bitmap B;
        public ThemeContainer154()
        {
            SetStyle((ControlStyles)139270, true);

            _ImageSize = Size.Empty;
            Font = new Font("Verdana", 8);

            MeasureBitmap = new Bitmap(1, 1);
            MeasureGraphics = Graphics.FromImage(MeasureBitmap);

            DrawRadialPath = new GraphicsPath();

            InvalidateCustimization();
        }

        protected override sealed void OnHandleCreated(EventArgs e)
        {
            if (DoneCreation)
                InitializeMessages();

            InvalidateCustimization();
            ColorHook();

            if (!(_LockWidth == 0))
                Width = _LockWidth;
            if (!(_LockHeight == 0))
                Height = _LockHeight;
            if (!_ControlMode)
                base.Dock = DockStyle.Fill;

            Transparent = _Transparent;
            if (_Transparent && _BackColor)
                BackColor = Color.Transparent;

            base.OnHandleCreated(e);
        }

        private bool DoneCreation;
        protected override sealed void OnParentChanged(EventArgs e)
        {
            base.OnParentChanged(e);

            if (Parent == null)
                return;
            _IsParentForm = Parent is Form;

            if (!_ControlMode)
            {
                InitializeMessages();

                if (_IsParentForm)
                {
                    ParentForm.FormBorderStyle = _BorderStyle;
                    ParentForm.TransparencyKey = _TransparencyKey;

                    if (!DesignMode)
                    {
                        ParentForm.Shown += FormShown;
                    }
                }

                Parent.BackColor = BackColor;
            }

            OnCreation();
            DoneCreation = true;
            InvalidateTimer();
        }

        #endregion

        private void DoAnimation(bool i)
        {
            OnAnimation();
            if (i)
                Invalidate();
        }

        protected override sealed void OnPaint(PaintEventArgs e)
        {
            if (Width == 0 || Height == 0)
                return;

            if (_Transparent && _ControlMode)
            {
                PaintHook();
                e.Graphics.DrawImage(B, 0, 0);
            }
            else {
                G = e.Graphics;
                PaintHook();
            }
        }

        protected override void OnHandleDestroyed(EventArgs e)
        {
            ThemeShare.RemoveAnimationCallback(DoAnimation);
            base.OnHandleDestroyed(e);
        }

        private bool HasShown;
        private void FormShown(object sender, EventArgs e)
        {
            if (_ControlMode || HasShown)
                return;

            if (_StartPosition == FormStartPosition.CenterParent || _StartPosition == FormStartPosition.CenterScreen)
            {
                Rectangle SB = Screen.PrimaryScreen.Bounds;
                Rectangle CB = ParentForm.Bounds;
                ParentForm.Location = new Point(SB.Width / 2 - CB.Width / 2, SB.Height / 2 - CB.Width / 2);
            }

            HasShown = true;
        }


        #region " Size Handling "

        private Rectangle Frame;
        protected override sealed void OnSizeChanged(EventArgs e)
        {
            if (_Movable && !_ControlMode)
            {
                Frame = new Rectangle(7, 7, Width - 14, _Header - 7);
            }

            InvalidateBitmap();
            Invalidate();

            base.OnSizeChanged(e);
        }

        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
        {
            if (!(_LockWidth == 0))
                width = _LockWidth;
            if (!(_LockHeight == 0))
                height = _LockHeight;
            base.SetBoundsCore(x, y, width, height, specified);
        }

        #endregion

        #region " State Handling "

        protected MouseState State;
        private void SetState(MouseState current)
        {
            State = current;
            Invalidate();
        }

        protected override void OnMouseMove(MouseEventArgs e)
        {
            if (!(_IsParentForm && ParentForm.WindowState == FormWindowState.Maximized))
            {
                if (_Sizable && !_ControlMode)
                    InvalidateMouse();
            }

            base.OnMouseMove(e);
        }

        protected override void OnEnabledChanged(EventArgs e)
        {
            if (Enabled)
                SetState(MouseState.None);
            else
                SetState(MouseState.Block);
            base.OnEnabledChanged(e);
        }

        protected override void OnMouseEnter(EventArgs e)
        {
            SetState(MouseState.Over);
            base.OnMouseEnter(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            SetState(MouseState.Over);
            base.OnMouseUp(e);
        }

        protected override void OnMouseLeave(EventArgs e)
        {
            SetState(MouseState.None);

            if (GetChildAtPoint(PointToClient(MousePosition)) != null)
            {
                if (_Sizable && !_ControlMode)
                {
                    Cursor = Cursors.Default;
                    Previous = 0;
                }
            }

            base.OnMouseLeave(e);
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
                SetState(MouseState.Down);

            if (!(_IsParentForm && ParentForm.WindowState == FormWindowState.Maximized || _ControlMode))
            {
                if (_Movable && Frame.Contains(e.Location))
                {
                    Capture = false;
                    WM_LMBUTTONDOWN = true;
                    DefWndProc(ref Messages[0]);
                }
                else if (_Sizable && !(Previous == 0))
                {
                    Capture = false;
                    WM_LMBUTTONDOWN = true;
                    DefWndProc(ref Messages[Previous]);
                }
            }

            base.OnMouseDown(e);
        }

        private bool WM_LMBUTTONDOWN;
        protected override void WndProc(ref Message m)
        {
            base.WndProc(ref m);

            if (WM_LMBUTTONDOWN && m.Msg == 513)
            {
                WM_LMBUTTONDOWN = false;

                SetState(MouseState.Over);
                if (!_SmartBounds)
                    return;

                if (IsParentMdi)
                {
                    CorrectBounds(new Rectangle(Point.Empty, Parent.Parent.Size));
                }
                else {
                    CorrectBounds(Screen.FromControl(Parent).WorkingArea);
                }
            }
        }

        private Point GetIndexPoint;
        private bool B1;
        private bool B2;
        private bool B3;
        private bool B4;
        private int GetIndex()
        {
            GetIndexPoint = PointToClient(MousePosition);
            B1 = GetIndexPoint.X < 7;
            B2 = GetIndexPoint.X > Width - 7;
            B3 = GetIndexPoint.Y < 7;
            B4 = GetIndexPoint.Y > Height - 7;

            if (B1 && B3)
                return 4;
            if (B1 && B4)
                return 7;
            if (B2 && B3)
                return 5;
            if (B2 && B4)
                return 8;
            if (B1)
                return 1;
            if (B2)
                return 2;
            if (B3)
                return 3;
            if (B4)
                return 6;
            return 0;
        }

        private int Current;
        private int Previous;
        private void InvalidateMouse()
        {
            Current = GetIndex();
            if (Current == Previous)
                return;

            Previous = Current;
            switch (Previous)
            {
                case 0:
                    Cursor = Cursors.Default;
                    break;
                case 1:
                case 2:
                    Cursor = Cursors.SizeWE;
                    break;
                case 3:
                case 6:
                    Cursor = Cursors.SizeNS;
                    break;
                case 4:
                case 8:
                    Cursor = Cursors.SizeNWSE;
                    break;
                case 5:
                case 7:
                    Cursor = Cursors.SizeNESW;
                    break;
            }
        }

        private Message[] Messages = new Message[9];
        private void InitializeMessages()
        {
            Messages[0] = Message.Create(Parent.Handle, 161, new IntPtr(2), IntPtr.Zero);
            for (int I = 1; I <= 8; I++)
            {
                Messages[I] = Message.Create(Parent.Handle, 161, new IntPtr(I + 9), IntPtr.Zero);
            }
        }

        private void CorrectBounds(Rectangle bounds)
        {
            if (Parent.Width > bounds.Width)
                Parent.Width = bounds.Width;
            if (Parent.Height > bounds.Height)
                Parent.Height = bounds.Height;

            int X = Parent.Location.X;
            int Y = Parent.Location.Y;

            if (X < bounds.X)
                X = bounds.X;
            if (Y < bounds.Y)
                Y = bounds.Y;

            int Width = bounds.X + bounds.Width;
            int Height = bounds.Y + bounds.Height;

            if (X + Parent.Width > Width)
                X = Width - Parent.Width;
            if (Y + Parent.Height > Height)
                Y = Height - Parent.Height;

            Parent.Location = new Point(X, Y);
        }

        #endregion


        #region " Base Properties "

        public override DockStyle Dock
        {
            get { return base.Dock; }
            set
            {
                if (!_ControlMode)
                    return;
                base.Dock = value;
            }
        }

        private bool _BackColor;
        [Category("Misc")]
        public override Color BackColor
        {
            get { return base.BackColor; }
            set
            {
                if (value == base.BackColor)
                    return;

                if (!IsHandleCreated && _ControlMode && value == Color.Transparent)
                {
                    _BackColor = true;
                    return;
                }

                base.BackColor = value;
                if (Parent != null)
                {
                    if (!_ControlMode)
                        Parent.BackColor = value;
                    ColorHook();
                }
            }
        }

        public override Size MinimumSize
        {
            get { return base.MinimumSize; }
            set
            {
                base.MinimumSize = value;
                if (Parent != null)
                    Parent.MinimumSize = value;
            }
        }

        public override Size MaximumSize
        {
            get { return base.MaximumSize; }
            set
            {
                base.MaximumSize = value;
                if (Parent != null)
                    Parent.MaximumSize = value;
            }
        }

        public override string Text
        {
            get { return base.Text; }
            set
            {
                base.Text = value;
                Invalidate();
            }
        }

        public override Font Font
        {
            get { return base.Font; }
            set
            {
                base.Font = value;
                Invalidate();
            }
        }

        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override Color ForeColor
        {
            get { return Color.Empty; }
            set { }
        }
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override Image BackgroundImage
        {
            get { return null; }
            set { }
        }
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override ImageLayout BackgroundImageLayout
        {
            get { return ImageLayout.None; }
            set { }
        }

        #endregion

        #region " Public Properties "

        private bool _SmartBounds = true;
        public bool SmartBounds
        {
            get { return _SmartBounds; }
            set { _SmartBounds = value; }
        }

        private bool _Movable = true;
        public bool Movable
        {
            get { return _Movable; }
            set { _Movable = value; }
        }

        private bool _Sizable = true;
        public bool Sizable
        {
            get { return _Sizable; }
            set { _Sizable = value; }
        }

        private Color _TransparencyKey;
        public Color TransparencyKey
        {
            get
            {
                if (_IsParentForm && !_ControlMode)
                    return ParentForm.TransparencyKey;
                else
                    return _TransparencyKey;
            }
            set
            {
                if (value == _TransparencyKey)
                    return;
                _TransparencyKey = value;

                if (_IsParentForm && !_ControlMode)
                {
                    ParentForm.TransparencyKey = value;
                    ColorHook();
                }
            }
        }

        private FormBorderStyle _BorderStyle;
        public FormBorderStyle BorderStyle
        {
            get
            {
                if (_IsParentForm && !_ControlMode)
                    return ParentForm.FormBorderStyle;
                else
                    return _BorderStyle;
            }
            set
            {
                _BorderStyle = value;

                if (_IsParentForm && !_ControlMode)
                {
                    ParentForm.FormBorderStyle = value;

                    if (!(value == FormBorderStyle.None))
                    {
                        Movable = false;
                        Sizable = false;
                    }
                }
            }
        }

        private FormStartPosition _StartPosition;
        public FormStartPosition StartPosition
        {
            get
            {
                if (_IsParentForm && !_ControlMode)
                    return ParentForm.StartPosition;
                else
                    return _StartPosition;
            }
            set
            {
                _StartPosition = value;

                if (_IsParentForm && !_ControlMode)
                {
                    ParentForm.StartPosition = value;
                }
            }
        }

        private bool _NoRounding;
        public bool NoRounding
        {
            get { return _NoRounding; }
            set
            {
                _NoRounding = value;
                Invalidate();
            }
        }

        private Image _Image;
        public Image Image
        {
            get { return _Image; }
            set
            {
                if (value == null)
                    _ImageSize = Size.Empty;
                else
                    _ImageSize = value.Size;

                _Image = value;
                Invalidate();
            }
        }

        private Dictionary<string, Color> Items = new Dictionary<string, Color>();
        public Bloom[] Colors
        {
            get
            {
                List<Bloom> T = new List<Bloom>();
                Dictionary<string, Color>.Enumerator E = Items.GetEnumerator();

                while (E.MoveNext())
                {
                    T.Add(new Bloom(E.Current.Key, E.Current.Value));
                }

                return T.ToArray();
            }
            set
            {
                foreach (Bloom B in value)
                {
                    if (Items.ContainsKey(B.Name))
                        Items[B.Name] = B.Value;
                }

                InvalidateCustimization();
                ColorHook();
                Invalidate();
            }
        }

        private string _Customization;
        public string Customization
        {
            get { return _Customization; }
            set
            {
                if (value == _Customization)
                    return;

                byte[] Data = null;
                Bloom[] Items = Colors;

                try
                {
                    Data = Convert.FromBase64String(value);
                    for (int I = 0; I <= Items.Length - 1; I++)
                    {
                        Items[I].Value = Color.FromArgb(BitConverter.ToInt32(Data, I * 4));
                    }
                }
                catch
                {
                    return;
                }

                _Customization = value;

                Colors = Items;
                ColorHook();
                Invalidate();
            }
        }

        private bool _Transparent;
        public bool Transparent
        {
            get { return _Transparent; }
            set
            {
                _Transparent = value;
                if (!(IsHandleCreated || _ControlMode))
                    return;

                if (!value && !(BackColor.A == 255))
                {
                    throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
                }

                SetStyle(ControlStyles.Opaque, !value);
                SetStyle(ControlStyles.SupportsTransparentBackColor, value);

                InvalidateBitmap();
                Invalidate();
            }
        }

        #endregion

        #region " Private Properties "

        private Size _ImageSize;
        protected Size ImageSize
        {
            get { return _ImageSize; }
        }

        private bool _IsParentForm;
        protected bool IsParentForm
        {
            get { return _IsParentForm; }
        }

        protected bool IsParentMdi
        {
            get
            {
                if (Parent == null)
                    return false;
                return Parent.Parent != null;
            }
        }

        private int _LockWidth;
        protected int LockWidth
        {
            get { return _LockWidth; }
            set
            {
                _LockWidth = value;
                if (!(LockWidth == 0) && IsHandleCreated)
                    Width = LockWidth;
            }
        }

        private int _LockHeight;
        protected int LockHeight
        {
            get { return _LockHeight; }
            set
            {
                _LockHeight = value;
                if (!(LockHeight == 0) && IsHandleCreated)
                    Height = LockHeight;
            }
        }

        private int _Header = 24;
        protected int Header
        {
            get { return _Header; }
            set
            {
                _Header = value;

                if (!_ControlMode)
                {
                    Frame = new Rectangle(7, 7, Width - 14, value - 7);
                    Invalidate();
                }
            }
        }

        private bool _ControlMode;
        protected bool ControlMode
        {
            get { return _ControlMode; }
            set
            {
                _ControlMode = value;

                Transparent = _Transparent;
                if (_Transparent && _BackColor)
                    BackColor = Color.Transparent;

                InvalidateBitmap();
                Invalidate();
            }
        }

        private bool _IsAnimated;
        protected bool IsAnimated
        {
            get { return _IsAnimated; }
            set
            {
                _IsAnimated = value;
                InvalidateTimer();
            }
        }

        #endregion


        #region " Property Helpers "

        protected Pen GetPen(string name)
        {
            return new Pen(Items[name]);
        }
        protected Pen GetPen(string name, float width)
        {
            return new Pen(Items[name], width);
        }

        protected SolidBrush GetBrush(string name)
        {
            return new SolidBrush(Items[name]);
        }

        protected Color GetColor(string name)
        {
            return Items[name];
        }

        protected void SetColor(string name, Color value)
        {
            if (Items.ContainsKey(name))
                Items[name] = value;
            else
                Items.Add(name, value);
        }
        protected void SetColor(string name, byte r, byte g, byte b)
        {
            SetColor(name, Color.FromArgb(r, g, b));
        }
        protected void SetColor(string name, byte a, byte r, byte g, byte b)
        {
            SetColor(name, Color.FromArgb(a, r, g, b));
        }
        protected void SetColor(string name, byte a, Color value)
        {
            SetColor(name, Color.FromArgb(a, value));
        }

        private void InvalidateBitmap()
        {
            if (_Transparent && _ControlMode)
            {
                if (Width == 0 || Height == 0)
                    return;
                B = new Bitmap(Width, Height, PixelFormat.Format32bppPArgb);
                G = Graphics.FromImage(B);
            }
            else {
                G = null;
                B = null;
            }
        }

        private void InvalidateCustimization()
        {
            MemoryStream M = new MemoryStream(Items.Count * 4);

            foreach (Bloom B in Colors)
            {
                M.Write(BitConverter.GetBytes(B.Value.ToArgb()), 0, 4);
            }

            M.Close();
            _Customization = Convert.ToBase64String(M.ToArray());
        }

        private void InvalidateTimer()
        {
            if (DesignMode || !DoneCreation)
                return;

            if (_IsAnimated)
            {
                ThemeShare.AddAnimationCallback(DoAnimation);
            }
            else {
                ThemeShare.RemoveAnimationCallback(DoAnimation);
            }
        }

        #endregion


        #region " User Hooks "

        protected abstract void ColorHook();
        protected abstract void PaintHook();

        protected virtual void OnCreation()
        {
        }

        protected virtual void OnAnimation()
        {
        }

        #endregion


        #region " Offset "

        private Rectangle OffsetReturnRectangle;
        protected Rectangle Offset(Rectangle r, int amount)
        {
            OffsetReturnRectangle = new Rectangle(r.X + amount, r.Y + amount, r.Width - (amount * 2), r.Height - (amount * 2));
            return OffsetReturnRectangle;
        }

        private Size OffsetReturnSize;
        protected Size Offset(Size s, int amount)
        {
            OffsetReturnSize = new Size(s.Width + amount, s.Height + amount);
            return OffsetReturnSize;
        }

        private Point OffsetReturnPoint;
        protected Point Offset(Point p, int amount)
        {
            OffsetReturnPoint = new Point(p.X + amount, p.Y + amount);
            return OffsetReturnPoint;
        }

        #endregion

        #region " Center "


        private Point CenterReturn;
        protected Point Center(Rectangle p, Rectangle c)
        {
            CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X + c.X, (p.Height / 2 - c.Height / 2) + p.Y + c.Y);
            return CenterReturn;
        }
        protected Point Center(Rectangle p, Size c)
        {
            CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X, (p.Height / 2 - c.Height / 2) + p.Y);
            return CenterReturn;
        }

        protected Point Center(Rectangle child)
        {
            return Center(Width, Height, child.Width, child.Height);
        }
        protected Point Center(Size child)
        {
            return Center(Width, Height, child.Width, child.Height);
        }
        protected Point Center(int childWidth, int childHeight)
        {
            return Center(Width, Height, childWidth, childHeight);
        }

        protected Point Center(Size p, Size c)
        {
            return Center(p.Width, p.Height, c.Width, c.Height);
        }

        protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
        {
            CenterReturn = new Point(pWidth / 2 - cWidth / 2, pHeight / 2 - cHeight / 2);
            return CenterReturn;
        }

        #endregion

        #region " Measure "

        private Bitmap MeasureBitmap;

        private Graphics MeasureGraphics;
        protected Size Measure()
        {
            lock (MeasureGraphics)
            {
                return MeasureGraphics.MeasureString(Text, Font, Width).ToSize();
            }
        }
        protected Size Measure(string text)
        {
            lock (MeasureGraphics)
            {
                return MeasureGraphics.MeasureString(text, Font, Width).ToSize();
            }
        }

        #endregion


        #region " DrawPixel "


        private SolidBrush DrawPixelBrush;
        protected void DrawPixel(Color c1, int x, int y)
        {
            if (_Transparent)
            {
                B.SetPixel(x, y, c1);
            }
            else {
                DrawPixelBrush = new SolidBrush(c1);
                G.FillRectangle(DrawPixelBrush, x, y, 1, 1);
            }
        }

        #endregion

        #region " DrawCorners "


        private SolidBrush DrawCornersBrush;
        protected void DrawCorners(Color c1, int offset)
        {
            DrawCorners(c1, 0, 0, Width, Height, offset);
        }
        protected void DrawCorners(Color c1, Rectangle r1, int offset)
        {
            DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);
        }
        protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset)
        {
            DrawCorners(c1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
        }

        protected void DrawCorners(Color c1)
        {
            DrawCorners(c1, 0, 0, Width, Height);
        }
        protected void DrawCorners(Color c1, Rectangle r1)
        {
            DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);
        }
        protected void DrawCorners(Color c1, int x, int y, int width, int height)
        {
            if (_NoRounding)
                return;

            if (_Transparent)
            {
                B.SetPixel(x, y, c1);
                B.SetPixel(x + (width - 1), y, c1);
                B.SetPixel(x, y + (height - 1), c1);
                B.SetPixel(x + (width - 1), y + (height - 1), c1);
            }
            else {
                DrawCornersBrush = new SolidBrush(c1);
                G.FillRectangle(DrawCornersBrush, x, y, 1, 1);
                G.FillRectangle(DrawCornersBrush, x + (width - 1), y, 1, 1);
                G.FillRectangle(DrawCornersBrush, x, y + (height - 1), 1, 1);
                G.FillRectangle(DrawCornersBrush, x + (width - 1), y + (height - 1), 1, 1);
            }
        }

        #endregion

        #region " DrawBorders "

        protected void DrawBorders(Pen p1, int offset)
        {
            DrawBorders(p1, 0, 0, Width, Height, offset);
        }
        protected void DrawBorders(Pen p1, Rectangle r, int offset)
        {
            DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);
        }
        protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset)
        {
            DrawBorders(p1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
        }

        protected void DrawBorders(Pen p1)
        {
            DrawBorders(p1, 0, 0, Width, Height);
        }
        protected void DrawBorders(Pen p1, Rectangle r)
        {
            DrawBorders(p1, r.X, r.Y, r.Width, r.Height);
        }
        protected void DrawBorders(Pen p1, int x, int y, int width, int height)
        {
            G.DrawRectangle(p1, x, y, width - 1, height - 1);
        }

        #endregion

        #region " DrawText "

        private Point DrawTextPoint;

        private Size DrawTextSize;
        protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y)
        {
            DrawText(b1, Text, a, x, y);
        }
        protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
        {
            if (text.Length == 0)
                return;

            DrawTextSize = Measure(text);
            DrawTextPoint = new Point(Width / 2 - DrawTextSize.Width / 2, Header / 2 - DrawTextSize.Height / 2);

            switch (a)
            {
                case HorizontalAlignment.Left:
                    G.DrawString(text, Font, b1, x, DrawTextPoint.Y + y);
                    break;
                case HorizontalAlignment.Center:
                    G.DrawString(text, Font, b1, DrawTextPoint.X + x, DrawTextPoint.Y + y);
                    break;
                case HorizontalAlignment.Right:
                    G.DrawString(text, Font, b1, Width - DrawTextSize.Width - x, DrawTextPoint.Y + y);
                    break;
            }
        }

        protected void DrawText(Brush b1, Point p1)
        {
            if (Text.Length == 0)
                return;
            G.DrawString(Text, Font, b1, p1);
        }
        protected void DrawText(Brush b1, int x, int y)
        {
            if (Text.Length == 0)
                return;
            G.DrawString(Text, Font, b1, x, y);
        }

        #endregion

        #region " DrawImage "


        private Point DrawImagePoint;
        protected void DrawImage(HorizontalAlignment a, int x, int y)
        {
            DrawImage(_Image, a, x, y);
        }
        protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
        {
            if (image == null)
                return;
            DrawImagePoint = new Point(Width / 2 - image.Width / 2, Header / 2 - image.Height / 2);

            switch (a)
            {
                case HorizontalAlignment.Left:
                    G.DrawImage(image, x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
                case HorizontalAlignment.Center:
                    G.DrawImage(image, DrawImagePoint.X + x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
                case HorizontalAlignment.Right:
                    G.DrawImage(image, Width - image.Width - x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
            }
        }

        protected void DrawImage(Point p1)
        {
            DrawImage(_Image, p1.X, p1.Y);
        }
        protected void DrawImage(int x, int y)
        {
            DrawImage(_Image, x, y);
        }

        protected void DrawImage(Image image, Point p1)
        {
            DrawImage(image, p1.X, p1.Y);
        }
        protected void DrawImage(Image image, int x, int y)
        {
            if (image == null)
                return;
            G.DrawImage(image, x, y, image.Width, image.Height);
        }

        #endregion

        #region " DrawGradient "

        private LinearGradientBrush DrawGradientBrush;

        private Rectangle DrawGradientRectangle;
        protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(blend, DrawGradientRectangle);
        }
        protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height, float angle)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(blend, DrawGradientRectangle, angle);
        }

        protected void DrawGradient(ColorBlend blend, Rectangle r)
        {
            DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
            DrawGradientBrush.InterpolationColors = blend;
            G.FillRectangle(DrawGradientBrush, r);
        }
        protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
        {
            DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
            DrawGradientBrush.InterpolationColors = blend;
            G.FillRectangle(DrawGradientBrush, r);
        }


        protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(c1, c2, DrawGradientRectangle);
        }
        protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height, float angle)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(c1, c2, DrawGradientRectangle, angle);
        }

        protected void DrawGradient(Color c1, Color c2, Rectangle r)
        {
            DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
            G.FillRectangle(DrawGradientBrush, r);
        }
        protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
        {
            DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
            G.FillRectangle(DrawGradientBrush, r);
        }

        #endregion

        #region " DrawRadial "

        private GraphicsPath DrawRadialPath;
        private PathGradientBrush DrawRadialBrush1;
        private LinearGradientBrush DrawRadialBrush2;

        private Rectangle DrawRadialRectangle;
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, width / 2, height / 2);
        }
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, center.X, center.Y);
        }
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, int cx, int cy)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, cx, cy);
        }

        public void DrawRadial(ColorBlend blend, Rectangle r)
        {
            DrawRadial(blend, r, r.Width / 2, r.Height / 2);
        }
        public void DrawRadial(ColorBlend blend, Rectangle r, Point center)
        {
            DrawRadial(blend, r, center.X, center.Y);
        }
        public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
        {
            DrawRadialPath.Reset();
            DrawRadialPath.AddEllipse(r.X, r.Y, r.Width - 1, r.Height - 1);

            DrawRadialBrush1 = new PathGradientBrush(DrawRadialPath);
            DrawRadialBrush1.CenterPoint = new Point(r.X + cx, r.Y + cy);
            DrawRadialBrush1.InterpolationColors = blend;

            if (G.SmoothingMode == SmoothingMode.AntiAlias)
            {
                G.FillEllipse(DrawRadialBrush1, r.X + 1, r.Y + 1, r.Width - 3, r.Height - 3);
            }
            else {
                G.FillEllipse(DrawRadialBrush1, r);
            }
        }


        protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(c1, c2, DrawGradientRectangle);
        }
        protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height, float angle)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(c1, c2, DrawGradientRectangle, angle);
        }

        protected void DrawRadial(Color c1, Color c2, Rectangle r)
        {
            DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
            G.FillRectangle(DrawGradientBrush, r);
        }
        protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
        {
            DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
            G.FillEllipse(DrawGradientBrush, r);
        }

        #endregion

        #region " CreateRound "

        private GraphicsPath CreateRoundPath;

        private Rectangle CreateRoundRectangle;
        public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
        {
            CreateRoundRectangle = new Rectangle(x, y, width, height);
            return CreateRound(CreateRoundRectangle, slope);
        }

        public GraphicsPath CreateRound(Rectangle r, int slope)
        {
            CreateRoundPath = new GraphicsPath(FillMode.Winding);
            CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
            CreateRoundPath.AddArc(r.Right - slope, r.Y, slope, slope, 270f, 90f);
            CreateRoundPath.AddArc(r.Right - slope, r.Bottom - slope, slope, slope, 0f, 90f);
            CreateRoundPath.AddArc(r.X, r.Bottom - slope, slope, slope, 90f, 90f);
            CreateRoundPath.CloseFigure();
            return CreateRoundPath;
        }

        #endregion

    }

    abstract class ThemeControl154 : Control
    {


        #region " Initialization "

        protected Graphics G;

        protected Bitmap B;
        public ThemeControl154()
        {
            SetStyle((ControlStyles)139270, true);

            _ImageSize = Size.Empty;
            Font = new Font("Verdana", 8);

            MeasureBitmap = new Bitmap(1, 1);
            MeasureGraphics = Graphics.FromImage(MeasureBitmap);

            DrawRadialPath = new GraphicsPath();

            InvalidateCustimization();
            //Remove?
        }

        protected override sealed void OnHandleCreated(EventArgs e)
        {
            InvalidateCustimization();
            ColorHook();

            if (!(_LockWidth == 0))
                Width = _LockWidth;
            if (!(_LockHeight == 0))
                Height = _LockHeight;

            Transparent = _Transparent;
            if (_Transparent && _BackColor)
                BackColor = Color.Transparent;

            base.OnHandleCreated(e);
        }

        private bool DoneCreation;
        protected override sealed void OnParentChanged(EventArgs e)
        {
            if (Parent != null)
            {
                OnCreation();
                DoneCreation = true;
                InvalidateTimer();
            }

            base.OnParentChanged(e);
        }

        #endregion

        private void DoAnimation(bool i)
        {
            OnAnimation();
            if (i)
                Invalidate();
        }

        protected override sealed void OnPaint(PaintEventArgs e)
        {
            if (Width == 0 || Height == 0)
                return;

            if (_Transparent)
            {
                PaintHook();
                e.Graphics.DrawImage(B, 0, 0);
            }
            else {
                G = e.Graphics;
                PaintHook();
            }
        }

        protected override void OnHandleDestroyed(EventArgs e)
        {
            ThemeShare.RemoveAnimationCallback(DoAnimation);
            base.OnHandleDestroyed(e);
        }

        #region " Size Handling "

        protected override sealed void OnSizeChanged(EventArgs e)
        {
            if (_Transparent)
            {
                InvalidateBitmap();
            }

            Invalidate();
            base.OnSizeChanged(e);
        }

        protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
        {
            if (!(_LockWidth == 0))
                width = _LockWidth;
            if (!(_LockHeight == 0))
                height = _LockHeight;
            base.SetBoundsCore(x, y, width, height, specified);
        }

        #endregion

        #region " State Handling "

        private bool InPosition;
        protected override void OnMouseEnter(EventArgs e)
        {
            InPosition = true;
            SetState(MouseState.Over);
            base.OnMouseEnter(e);
        }

        protected override void OnMouseUp(MouseEventArgs e)
        {
            if (InPosition)
                SetState(MouseState.Over);
            base.OnMouseUp(e);
        }

        protected override void OnMouseDown(MouseEventArgs e)
        {
            if (e.Button == MouseButtons.Left)
                SetState(MouseState.Down);
            base.OnMouseDown(e);
        }

        protected override void OnMouseLeave(EventArgs e)
        {
            InPosition = false;
            SetState(MouseState.None);
            base.OnMouseLeave(e);
        }

        protected override void OnEnabledChanged(EventArgs e)
        {
            if (Enabled)
                SetState(MouseState.None);
            else
                SetState(MouseState.Block);
            //base.OnEnabledChanged(e);
            Invoke((MethodInvoker)(() => base.OnEnabledChanged(e)));
        }

        protected MouseState State;
        private void SetState(MouseState current)
        {
            State = current;
            Invalidate();
        }

        #endregion


        #region " Base Properties "

        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override Color ForeColor
        {
            get { return Color.Empty; }
            set { }
        }
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override Image BackgroundImage
        {
            get { return null; }
            set { }
        }
        [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public override ImageLayout BackgroundImageLayout
        {
            get { return ImageLayout.None; }
            set { }
        }

        public override string Text
        {
            get { return base.Text; }
            set
            {
                base.Text = value;
                Invalidate();
            }
        }
        public override Font Font
        {
            get { return base.Font; }
            set
            {
                base.Font = value;
                Invalidate();
            }
        }

        private bool _BackColor;
        [Category("Misc")]
        public override Color BackColor
        {
            get { return base.BackColor; }
            set
            {
                if (!IsHandleCreated && value == Color.Transparent)
                {
                    _BackColor = true;
                    return;
                }

                base.BackColor = value;
                if (Parent != null)
                    ColorHook();
            }
        }

        #endregion

        #region " Public Properties "

        private bool _NoRounding;
        public bool NoRounding
        {
            get { return _NoRounding; }
            set
            {
                _NoRounding = value;
                Invalidate();
            }
        }

        private Image _Image;
        public Image Image
        {
            get { return _Image; }
            set
            {
                if (value == null)
                {
                    _ImageSize = Size.Empty;
                }
                else {
                    _ImageSize = value.Size;
                }

                _Image = value;
                Invalidate();
            }
        }

        private bool _Transparent;
        public bool Transparent
        {
            get { return _Transparent; }
            set
            {
                _Transparent = value;
                if (!IsHandleCreated)
                    return;

                if (!value && !(BackColor.A == 255))
                {
                    throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
                }

                SetStyle(ControlStyles.Opaque, !value);
                SetStyle(ControlStyles.SupportsTransparentBackColor, value);

                if (value)
                    InvalidateBitmap();
                else
                    B = null;
                Invalidate();
            }
        }

        private Dictionary<string, Color> Items = new Dictionary<string, Color>();
        public Bloom[] Colors
        {
            get
            {
                List<Bloom> T = new List<Bloom>();
                Dictionary<string, Color>.Enumerator E = Items.GetEnumerator();
                
                while (E.MoveNext())
                {
                    T.Add(new Bloom(E.Current.Key, E.Current.Value));
                }

                return T.ToArray();
            }
            set
            {
                foreach (Bloom B in value)
                {
                    if (Items.ContainsKey(B.Name))
                        Items[B.Name] = B.Value;
                }

                InvalidateCustimization();
                ColorHook();
                Invalidate();
            }
        }

        private string _Customization;
        public string Customization
        {
            get { return _Customization; }
            set
            {
                if (value == _Customization)
                    return;

                byte[] Data = null;
                Bloom[] Items = Colors;

                try
                {
                    Data = Convert.FromBase64String(value);
                    for (int I = 0; I <= Items.Length - 1; I++)
                    {
                        Items[I].Value = Color.FromArgb(BitConverter.ToInt32(Data, I * 4));
                    }
                }
                catch
                {
                    return;
                }

                _Customization = value;

                Colors = Items;
                ColorHook();
                Invalidate();
            }
        }

        #endregion

        #region " Private Properties "

        private Size _ImageSize;
        protected Size ImageSize
        {
            get { return _ImageSize; }
        }

        private int _LockWidth;
        protected int LockWidth
        {
            get { return _LockWidth; }
            set
            {
                _LockWidth = value;
                if (!(LockWidth == 0) && IsHandleCreated)
                    Width = LockWidth;
            }
        }

        private int _LockHeight;
        protected int LockHeight
        {
            get { return _LockHeight; }
            set
            {
                _LockHeight = value;
                if (!(LockHeight == 0) && IsHandleCreated)
                    Height = LockHeight;
            }
        }

        private bool _IsAnimated;
        protected bool IsAnimated
        {
            get { return _IsAnimated; }
            set
            {
                _IsAnimated = value;
                InvalidateTimer();
            }
        }

        #endregion


        #region " Property Helpers "

        protected Pen GetPen(string name)
        {
            return new Pen(Items[name]);
        }
        protected Pen GetPen(string name, float width)
        {
            return new Pen(Items[name], width);
        }

        protected SolidBrush GetBrush(string name)
        {
            return new SolidBrush(Items[name]);
        }

        protected Color GetColor(string name)
        {
            return Items[name];
        }

        protected void SetColor(string name, Color value)
        {
            if (Items.ContainsKey(name))
                Items[name] = value;
            else
                Items.Add(name, value);
        }
        protected void SetColor(string name, byte r, byte g, byte b)
        {
            SetColor(name, Color.FromArgb(r, g, b));
        }
        protected void SetColor(string name, byte a, byte r, byte g, byte b)
        {
            SetColor(name, Color.FromArgb(a, r, g, b));
        }
        protected void SetColor(string name, byte a, Color value)
        {
            SetColor(name, Color.FromArgb(a, value));
        }

        private void InvalidateBitmap()
        {
            if (Width == 0 || Height == 0)
                return;
            B = new Bitmap(Width, Height, PixelFormat.Format32bppPArgb);
            G = Graphics.FromImage(B);
        }

        private void InvalidateCustimization()
        {
            MemoryStream M = new MemoryStream(Items.Count * 4);

            foreach (Bloom B in Colors)
            {
                M.Write(BitConverter.GetBytes(B.Value.ToArgb()), 0, 4);
            }

            M.Close();
            _Customization = Convert.ToBase64String(M.ToArray());
        }

        private void InvalidateTimer()
        {
            if (DesignMode || !DoneCreation)
                return;

            if (_IsAnimated)
            {
                ThemeShare.AddAnimationCallback(DoAnimation);
            }
            else {
                ThemeShare.RemoveAnimationCallback(DoAnimation);
            }
        }
        #endregion


        #region " User Hooks "

        protected abstract void ColorHook();
        protected abstract void PaintHook();

        protected virtual void OnCreation()
        {
        }

        protected virtual void OnAnimation()
        {
        }

        #endregion


        #region " Offset "

        private Rectangle OffsetReturnRectangle;
        protected Rectangle Offset(Rectangle r, int amount)
        {
            OffsetReturnRectangle = new Rectangle(r.X + amount, r.Y + amount, r.Width - (amount * 2), r.Height - (amount * 2));
            return OffsetReturnRectangle;
        }

        private Size OffsetReturnSize;
        protected Size Offset(Size s, int amount)
        {
            OffsetReturnSize = new Size(s.Width + amount, s.Height + amount);
            return OffsetReturnSize;
        }

        private Point OffsetReturnPoint;
        protected Point Offset(Point p, int amount)
        {
            OffsetReturnPoint = new Point(p.X + amount, p.Y + amount);
            return OffsetReturnPoint;
        }

        #endregion

        #region " Center "


        private Point CenterReturn;
        protected Point Center(Rectangle p, Rectangle c)
        {
            CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X + c.X, (p.Height / 2 - c.Height / 2) + p.Y + c.Y);
            return CenterReturn;
        }
        protected Point Center(Rectangle p, Size c)
        {
            CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X, (p.Height / 2 - c.Height / 2) + p.Y);
            return CenterReturn;
        }

        protected Point Center(Rectangle child)
        {
            return Center(Width, Height, child.Width, child.Height);
        }
        protected Point Center(Size child)
        {
            return Center(Width, Height, child.Width, child.Height);
        }
        protected Point Center(int childWidth, int childHeight)
        {
            return Center(Width, Height, childWidth, childHeight);
        }

        protected Point Center(Size p, Size c)
        {
            return Center(p.Width, p.Height, c.Width, c.Height);
        }

        protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
        {
            CenterReturn = new Point(pWidth / 2 - cWidth / 2, pHeight / 2 - cHeight / 2);
            return CenterReturn;
        }

        #endregion

        #region " Measure "

        private Bitmap MeasureBitmap;
        //TODO: Potential issues during multi-threading.
        private Graphics MeasureGraphics;

        protected Size Measure()
        {
            return MeasureGraphics.MeasureString(Text, Font, Width).ToSize();
        }
        protected Size Measure(string text)
        {
            return MeasureGraphics.MeasureString(text, Font, Width).ToSize();
        }

        #endregion


        #region " DrawPixel "


        private SolidBrush DrawPixelBrush;
        protected void DrawPixel(Color c1, int x, int y)
        {
            if (_Transparent)
            {
                B.SetPixel(x, y, c1);
            }
            else {
                DrawPixelBrush = new SolidBrush(c1);
                G.FillRectangle(DrawPixelBrush, x, y, 1, 1);
            }
        }

        #endregion

        #region " DrawCorners "


        private SolidBrush DrawCornersBrush;
        protected void DrawCorners(Color c1, int offset)
        {
            DrawCorners(c1, 0, 0, Width, Height, offset);
        }
        protected void DrawCorners(Color c1, Rectangle r1, int offset)
        {
            DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);
        }
        protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset)
        {
            DrawCorners(c1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
        }

        protected void DrawCorners(Color c1)
        {
            DrawCorners(c1, 0, 0, Width, Height);
        }
        protected void DrawCorners(Color c1, Rectangle r1)
        {
            DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);
        }
        protected void DrawCorners(Color c1, int x, int y, int width, int height)
        {
            if (_NoRounding)
                return;

            if (_Transparent)
            {
                B.SetPixel(x, y, c1);
                B.SetPixel(x + (width - 1), y, c1);
                B.SetPixel(x, y + (height - 1), c1);
                B.SetPixel(x + (width - 1), y + (height - 1), c1);
            }
            else {
                DrawCornersBrush = new SolidBrush(c1);
                G.FillRectangle(DrawCornersBrush, x, y, 1, 1);
                G.FillRectangle(DrawCornersBrush, x + (width - 1), y, 1, 1);
                G.FillRectangle(DrawCornersBrush, x, y + (height - 1), 1, 1);
                G.FillRectangle(DrawCornersBrush, x + (width - 1), y + (height - 1), 1, 1);
            }
        }

        #endregion

        #region " DrawBorders "

        protected void DrawBorders(Pen p1, int offset)
        {
            DrawBorders(p1, 0, 0, Width, Height, offset);
        }
        protected void DrawBorders(Pen p1, Rectangle r, int offset)
        {
            DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);
        }
        protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset)
        {
            DrawBorders(p1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
        }

        protected void DrawBorders(Pen p1)
        {
            DrawBorders(p1, 0, 0, Width, Height);
        }
        protected void DrawBorders(Pen p1, Rectangle r)
        {
            DrawBorders(p1, r.X, r.Y, r.Width, r.Height);
        }
        protected void DrawBorders(Pen p1, int x, int y, int width, int height)
        {
            G.DrawRectangle(p1, x, y, width - 1, height - 1);
        }

        #endregion

        #region " DrawText "

        private Point DrawTextPoint;

        private Size DrawTextSize;
        protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y)
        {
            DrawText(b1, Text, a, x, y);
        }
        protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
        {
            if (text.Length == 0)
                return;

            DrawTextSize = Measure(text);
            DrawTextPoint = Center(DrawTextSize);

            switch (a)
            {
                case HorizontalAlignment.Left:
                    G.DrawString(text, Font, b1, x, DrawTextPoint.Y + y);
                    break;
                case HorizontalAlignment.Center:
                    G.DrawString(text, Font, b1, DrawTextPoint.X + x, DrawTextPoint.Y + y);
                    break;
                case HorizontalAlignment.Right:
                    G.DrawString(text, Font, b1, Width - DrawTextSize.Width - x, DrawTextPoint.Y + y);
                    break;
            }
        }

        protected void DrawText(Brush b1, Point p1)
        {
            if (Text.Length == 0)
                return;
            G.DrawString(Text, Font, b1, p1);
        }
        protected void DrawText(Brush b1, int x, int y)
        {
            if (Text.Length == 0)
                return;
            G.DrawString(Text, Font, b1, x, y);
        }

        #endregion

        #region " DrawImage "


        private Point DrawImagePoint;
        protected void DrawImage(HorizontalAlignment a, int x, int y)
        {
            DrawImage(_Image, a, x, y);
        }
        protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
        {
            if (image == null)
                return;
            DrawImagePoint = Center(image.Size);

            switch (a)
            {
                case HorizontalAlignment.Left:
                    G.DrawImage(image, x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
                case HorizontalAlignment.Center:
                    G.DrawImage(image, DrawImagePoint.X + x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
                case HorizontalAlignment.Right:
                    G.DrawImage(image, Width - image.Width - x, DrawImagePoint.Y + y, image.Width, image.Height);
                    break;
            }
        }

        protected void DrawImage(Point p1)
        {
            DrawImage(_Image, p1.X, p1.Y);
        }
        protected void DrawImage(int x, int y)
        {
            DrawImage(_Image, x, y);
        }

        protected void DrawImage(Image image, Point p1)
        {
            DrawImage(image, p1.X, p1.Y);
        }
        protected void DrawImage(Image image, int x, int y)
        {
            if (image == null)
                return;
            G.DrawImage(image, x, y, image.Width, image.Height);
        }

        #endregion

        #region " DrawGradient "

        private LinearGradientBrush DrawGradientBrush;

        private Rectangle DrawGradientRectangle;
        protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(blend, DrawGradientRectangle);
        }
        protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height, float angle)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(blend, DrawGradientRectangle, angle);
        }

        protected void DrawGradient(ColorBlend blend, Rectangle r)
        {
            DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
            DrawGradientBrush.InterpolationColors = blend;
            G.FillRectangle(DrawGradientBrush, r);
        }
        protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
        {
            DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
            DrawGradientBrush.InterpolationColors = blend;
            G.FillRectangle(DrawGradientBrush, r);
        }


        protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(c1, c2, DrawGradientRectangle);
        }
        protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height, float angle)
        {
            DrawGradientRectangle = new Rectangle(x, y, width, height);
            DrawGradient(c1, c2, DrawGradientRectangle, angle);
        }

        protected void DrawGradient(Color c1, Color c2, Rectangle r)
        {
            DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
            G.FillRectangle(DrawGradientBrush, r);
        }
        protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
        {
            DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
            G.FillRectangle(DrawGradientBrush, r);
        }

        #endregion

        #region " DrawRadial "

        private GraphicsPath DrawRadialPath;
        private PathGradientBrush DrawRadialBrush1;
        private LinearGradientBrush DrawRadialBrush2;

        private Rectangle DrawRadialRectangle;
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, width / 2, height / 2);
        }
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, center.X, center.Y);
        }
        public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, int cx, int cy)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(blend, DrawRadialRectangle, cx, cy);
        }

        public void DrawRadial(ColorBlend blend, Rectangle r)
        {
            DrawRadial(blend, r, r.Width / 2, r.Height / 2);
        }
        public void DrawRadial(ColorBlend blend, Rectangle r, Point center)
        {
            DrawRadial(blend, r, center.X, center.Y);
        }
        public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
        {
            DrawRadialPath.Reset();
            DrawRadialPath.AddEllipse(r.X, r.Y, r.Width - 1, r.Height - 1);

            DrawRadialBrush1 = new PathGradientBrush(DrawRadialPath);
            DrawRadialBrush1.CenterPoint = new Point(r.X + cx, r.Y + cy);
            DrawRadialBrush1.InterpolationColors = blend;

            if (G.SmoothingMode == SmoothingMode.AntiAlias)
            {
                G.FillEllipse(DrawRadialBrush1, r.X + 1, r.Y + 1, r.Width - 3, r.Height - 3);
            }
            else {
                G.FillEllipse(DrawRadialBrush1, r);
            }
        }


        protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(c1, c2, DrawRadialRectangle);
        }
        protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height, float angle)
        {
            DrawRadialRectangle = new Rectangle(x, y, width, height);
            DrawRadial(c1, c2, DrawRadialRectangle, angle);
        }

        protected void DrawRadial(Color c1, Color c2, Rectangle r)
        {
            DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
            G.FillEllipse(DrawRadialBrush2, r);
        }
        protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
        {
            DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
            G.FillEllipse(DrawRadialBrush2, r);
        }

        #endregion

        #region " CreateRound "

        private GraphicsPath CreateRoundPath;

        private Rectangle CreateRoundRectangle;
        public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
        {
            CreateRoundRectangle = new Rectangle(x, y, width, height);
            return CreateRound(CreateRoundRectangle, slope);
        }

        public GraphicsPath CreateRound(Rectangle r, int slope)
        {
            CreateRoundPath = new GraphicsPath(FillMode.Winding);
            CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
            CreateRoundPath.AddArc(r.Right - slope, r.Y, slope, slope, 270f, 90f);
            CreateRoundPath.AddArc(r.Right - slope, r.Bottom - slope, slope, slope, 0f, 90f);
            CreateRoundPath.AddArc(r.X, r.Bottom - slope, slope, slope, 90f, 90f);
            CreateRoundPath.CloseFigure();
            return CreateRoundPath;
        }

        #endregion

    }

    static class ThemeShare
    {

        #region " Animation "

        private static int Frames;
        private static bool Invalidate;

        public static PrecisionTimer ThemeTimer = new PrecisionTimer();
        //1000 / 50 = 20 FPS
        private const int FPS = 50;

        private const int Rate = 10;
        public delegate void AnimationDelegate(bool invalidate);


        private static List<AnimationDelegate> Callbacks = new List<AnimationDelegate>();
        private static void HandleCallbacks(IntPtr state, bool reserve)
        {
            Invalidate = (Frames >= FPS);
            if (Invalidate)
                Frames = 0;

            lock (Callbacks)
            {
                for (int I = 0; I <= Callbacks.Count - 1; I++)
                {
                    Callbacks[I].Invoke(Invalidate);
                }
            }

            Frames += Rate;
        }

        private static void InvalidateThemeTimer()
        {
            if (Callbacks.Count == 0)
            {
                ThemeTimer.Delete();
            }
            else {
                ThemeTimer.Create(0, Rate, HandleCallbacks);
            }
        }

        public static void AddAnimationCallback(AnimationDelegate callback)
        {
            lock (Callbacks)
            {
                if (Callbacks.Contains(callback))
                    return;

                Callbacks.Add(callback);
                InvalidateThemeTimer();
            }
        }

        public static void RemoveAnimationCallback(AnimationDelegate callback)
        {
            lock (Callbacks)
            {
                if (!Callbacks.Contains(callback))
                    return;

                Callbacks.Remove(callback);
                InvalidateThemeTimer();
            }
        }

        #endregion

    }

    enum MouseState : byte
    {
        None = 0,
        Over = 1,
        Down = 2,
        Block = 3
    }

    struct Bloom
    {

        public string _Name;
        public string Name
        {
            get { return _Name; }
        }

        private Color _Value;
        public Color Value
        {
            get { return _Value; }
            set { _Value = value; }
        }

        public string ValueHex
        {
            get { return string.Concat("#", _Value.R.ToString("X2", null), _Value.G.ToString("X2", null), _Value.B.ToString("X2", null)); }
            set
            {
                try
                {
                    _Value = ColorTranslator.FromHtml(value);
                }
                catch
                {
                    return;
                }
            }
        }


        public Bloom(string name, Color value)
        {
            _Name = name;
            _Value = value;
        }
    }

    //------------------
    //Creator: aeonhack
    //Site: elitevs.net
    //Created: 11/30/2011
    //Changed: 11/30/2011
    //Version: 1.0.0
    //------------------
    class PrecisionTimer : IDisposable
    {

        private bool _Enabled;
        public bool Enabled
        {
            get { return _Enabled; }
        }

        private IntPtr Handle;

        private TimerDelegate TimerCallback;
        [DllImport("kernel32.dll", EntryPoint = "CreateTimerQueueTimer")]
        private static extern bool CreateTimerQueueTimer(ref IntPtr handle, IntPtr queue, TimerDelegate callback, IntPtr state, uint dueTime, uint period, uint flags);

        [DllImport("kernel32.dll", EntryPoint = "DeleteTimerQueueTimer")]
        private static extern bool DeleteTimerQueueTimer(IntPtr queue, IntPtr handle, IntPtr callback);

        public delegate void TimerDelegate(IntPtr r1, bool r2);

        public void Create(uint dueTime, uint period, TimerDelegate callback)
        {
            if (_Enabled)
                return;

            TimerCallback = callback;
            bool Success = CreateTimerQueueTimer(ref Handle, IntPtr.Zero, TimerCallback, IntPtr.Zero, dueTime, period, 0);

            if (!Success)
                ThrowNewException("CreateTimerQueueTimer");
            _Enabled = Success;
        }

        public void Delete()
        {
            if (!_Enabled)
                return;
            bool Success = DeleteTimerQueueTimer(IntPtr.Zero, Handle, IntPtr.Zero);

            if (!Success && !(Marshal.GetLastWin32Error() == 997))
            {
                ThrowNewException("DeleteTimerQueueTimer");
            }

            _Enabled = !Success;
        }

        private void ThrowNewException(string name)
        {
            throw new Exception(string.Format("{0} failed. Win32Error: {1}", name, Marshal.GetLastWin32Error()));
        }

        public void Dispose()
        {
            Delete();
        }
    }




    //------------------
    //Creator: Himler
    //Created: 16/11/2012
    //Version: 1.0.0
    //------------------
    class clsNeoBuxTheme : ThemeContainer154
    {

        public clsNeoBuxTheme()
        {
            TransparencyKey = Color.Fuchsia;
            BackColor = Color.FromArgb(239, 239, 242);
            Font = new Font("Segoe UI", 9);
            SetColor("Text", Color.Black);

        }


        Brush TextBrush;

        protected override void ColorHook()
        {
            TextBrush = GetBrush("Text");
        }

        protected override void PaintHook()
        {
            G.Clear(Color.Gray);

            //MenuTop
            G.FillRectangle(new SolidBrush(BackColor), new Rectangle(1, 1, Width - 2, Height - 2));

            //Border
            G.FillRectangle(new SolidBrush(Color.LightGray), new Rectangle(1, 35, Width - 2, Height - 38));

            //MainForm
            G.FillRectangle(new SolidBrush(Color.WhiteSmoke), new Rectangle(1, 36, Width - 2, Height - 39));


            //ColorLine
            LinearGradientBrush LGB = new LinearGradientBrush(new Rectangle(1, 36, Width - 2, Height - 255), Color.FromArgb(0, 177, 253), Color.FromArgb(46, 202, 56), 180f);
            G.DrawRectangle(new Pen(Color.LightGray), 1, 35, Width - 3, 4);
            G.FillRectangle(LGB, new Rectangle(1, 35, Width - 2, 4));

            //MenuItems
            G.DrawString(FindForm().Text, Font, TextBrush, new Point(35, 10));
            G.DrawIcon(FindForm().Icon, new Rectangle(10, 10, 16, 16));
            DrawCorners(Color.Fuchsia);

        }
    }

    class clsControlMenu : ThemeControl154
    {
        private int X;
        Color BG;
        Color Edge;
        Pen BEdge;
        protected override void ColorHook()
        {
            BG = GetColor("Background");
            Edge = GetColor("Edge color");
            BEdge = new Pen(GetColor("Button edge color"));
        }

        public clsControlMenu()
        {
            SetColor("Background", Color.FromArgb(239, 239, 242));
            SetColor("Edge color", Color.Transparent);
            SetColor("Button edge color", Color.Transparent);
            this.Size = new Size(71, 19);
            this.Anchor = AnchorStyles.Top | AnchorStyles.Right;
        }

        protected override void OnMouseMove(System.Windows.Forms.MouseEventArgs e)
        {
            base.OnMouseMove(e);
            X = e.X;
            Invalidate();
        }

        protected override void OnClick(System.EventArgs e)
        {
            base.OnClick(e);
            if (X > 22 & X <= 44) //x <= 22
            {
                FindForm().WindowState = FormWindowState.Minimized;
            }
            else if (X > 44)
            {
                FindForm().Close();
            }
        }

        protected override void PaintHook()
        {
            //Draw outer edge
            G.Clear(Color.FromArgb(239, 239, 242));

            //Fill buttons
            //Dim SB As New LinearGradientBrush(New Rectangle(New Point(1, 1), New Size(Width - 2, Height - 2)), BG, Color.FromArgb(30, 30, 30), 90.0F)
            G.FillRectangle(new SolidBrush(Color.FromArgb(239, 239, 242)), new Rectangle(new Point(1, 1), new Size(Width - 2, Height - 2)));

            //Draw icons            
            G.DrawString("0", new Font("Marlett", (float)8.25,FontStyle.Regular), Brushes.Black, new Point(27, 4));
            G.DrawString("r", new Font("Marlett", 10), Brushes.Black, new Point(49, 3));

            //Glassy effect
            //Dim CBlend As New ColorBlend(2)
            //CBlend.Colors = {Color.FromArgb(100, Color.Black), Color.Transparent}
            //CBlend.Positions = {0, 1}
            //DrawGradient(CBlend, New Rectangle(New Point(1, 8), New Size(68, 8)), 90.0F)

            //Draw button outlines
            G.DrawRectangle(BEdge, new Rectangle(new Point(1, 1), new Size(20, 16)));
            G.DrawRectangle(BEdge, new Rectangle(new Point(23, 1), new Size(20, 16)));
            G.DrawRectangle(BEdge, new Rectangle(new Point(45, 1), new Size(24, 16)));

            //Mouse states
            switch (State)
            {
                case MouseState.Over:
                    if (X > 22 & X <= 44)
                    {
                        G.FillRectangle(new SolidBrush(Color.FromArgb(40, Color.White)), new Rectangle(new Point(23, 1), new Size(21, Height - 2)));
                    }
                    else if (X > 44)
                    {
                        G.FillRectangle(new SolidBrush(Color.FromArgb(40, Color.White)), new Rectangle(new Point(45, 1), new Size(25, Height - 2)));
                    }
                    break;
                case MouseState.Down:
                    if (X > 22 & X <= 44)
                    {
                        G.FillRectangle(new SolidBrush(Color.FromArgb(20, Color.Black)), new Rectangle(new Point(23, 1), new Size(21, Height - 2)));
                    }
                    else if (X > 44)
                    {
                        G.FillRectangle(new SolidBrush(Color.FromArgb(20, Color.Black)), new Rectangle(new Point(45, 1), new Size(25, Height - 2)));
                    }
                    break;
            }
        }
    }

    class clsButtonGreen : ThemeControl154
    {

        Brush TextColor;

        Pen Border;
        public clsButtonGreen()
        {
            SetColor("Text", Color.WhiteSmoke);
            SetColor("Border", Color.DarkGray);
        }

        protected override void ColorHook()
        {
            TextColor = GetBrush("Text");
            Border = GetPen("Border");
        }

        protected override void PaintHook()
        {
            DrawCorners(Color.Fuchsia);
            G.Clear(BackColor);
            switch (State)
            {
                case MouseState.None:
                    LinearGradientBrush LGB1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(23, 178, 23), Color.FromArgb(1, 156, 1), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGB1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 124, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;

                case MouseState.Over:
                    LinearGradientBrush LGBO1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(49, 188, 49), Color.FromArgb(26, 180, 26), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBO1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 124, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;
                case MouseState.Down:
                    LinearGradientBrush LGBD1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(49, 188, 49), Color.FromArgb(26, 180, 26), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBD1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 124, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 1);
                    break;
            }
        }
    }

    class clsButtonBlue : ThemeControl154
    {

        Brush TextColor;

        Pen Border;
        public clsButtonBlue()
        {
            SetColor("Text", Color.WhiteSmoke);
            SetColor("Border", Color.DarkGray);
        }

        protected override void ColorHook()
        {
            TextColor = GetBrush("Text");
            Border = GetPen("Border");
        }

        protected override void PaintHook()
        {
            DrawCorners(Color.Fuchsia);
            G.Clear(BackColor);
            switch (State)
            {
                case MouseState.None:
                    LinearGradientBrush LGB1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(23, 167, 237), Color.FromArgb(1, 145, 215), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGB1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 116, 172)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;

                case MouseState.Over:
                    LinearGradientBrush LGBO1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(49, 178, 241), Color.FromArgb(26, 169, 239), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBO1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 116, 172)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;
                case MouseState.Down:
                    LinearGradientBrush LGBD1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(49, 178, 241), Color.FromArgb(26, 169, 239), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBD1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(0, 116, 172)), CreateRound(0, 0, Width - 1, Height - 1, 5));
                    DrawText(TextColor, HorizontalAlignment.Center, 0, 1);
                    break;
            }
        }
    }

    class clsButtonOrange : ThemeControl154
    {

        Brush TextColor;

        Pen Border;
        public clsButtonOrange()
        {
            SetColor("Text", Color.WhiteSmoke);
            SetColor("Border", Color.DarkGray);
        }

        protected override void ColorHook()
        {
            TextColor = GetBrush("Text");
            Border = GetPen("Border");
        }

        protected override void PaintHook()
        {
            DrawCorners(Color.Fuchsia);
            G.Clear(BackColor);
            switch (State)
            {
                case MouseState.None:
                    LinearGradientBrush LGB1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(253, 163, 23), Color.FromArgb(231, 141, 1), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGB1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(184, 112, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;

                case MouseState.Over:
                    LinearGradientBrush LGBO1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(255, 175, 49), Color.FromArgb(255, 166, 26), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBO1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(184, 112, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;
                case MouseState.Down:
                    LinearGradientBrush LGBD1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(255, 175, 49), Color.FromArgb(255, 166, 26), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBD1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(184, 112, 0)), CreateRound(0, 0, Width - 1, Height - 1, 5));


                    DrawText(TextColor, HorizontalAlignment.Center, 0, 1);
                    break;
            }
        }
    }

    class clsButtonPurple : ThemeControl154
    {

        Brush TextColor;

        Pen Border;
        public clsButtonPurple()
        {
            SetColor("Text", Color.WhiteSmoke);
            SetColor("Border", Color.DarkGray);
        }

        protected override void ColorHook()
        {
            TextColor = GetBrush("Text");
            Border = GetPen("Border");
        }

        protected override void PaintHook()
        {
            DrawCorners(Color.Fuchsia);
            G.Clear(BackColor);
            switch (State)
            {
                case MouseState.None:
                    LinearGradientBrush LGB1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(229, 43, 245), Color.FromArgb(207, 21, 223), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGB1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(165, 16, 178)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;

                case MouseState.Over:
                    LinearGradientBrush LGBO1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(234, 67, 248), Color.FromArgb(231, 46, 247), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBO1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(165, 16, 178)), CreateRound(0, 0, Width - 1, Height - 1, 5));


                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;
                case MouseState.Down:
                    LinearGradientBrush LGBD1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(234, 67, 248), Color.FromArgb(231, 46, 247), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBD1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(165, 16, 178)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 1);
                    break;
            }
        }
    }

    class clsButtonGrey : ThemeControl154
    {

        Brush TextColor;

        Pen Border;
        public clsButtonGrey()
        {
            SetColor("Text", Color.WhiteSmoke);
            SetColor("Border", Color.DarkGray);
        }

        protected override void ColorHook()
        {
            TextColor = GetBrush("Text");
            Border = GetPen("Border");
        }

        protected override void PaintHook()
        {
            DrawCorners(Color.Fuchsia);
            G.Clear(BackColor);
            switch (State)
            {
                case MouseState.None:
                    LinearGradientBrush LGB1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(161, 161, 161), Color.FromArgb(139, 139, 139), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGB1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(111, 111, 111)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;

                case MouseState.Over:
                    LinearGradientBrush LGBO1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(172, 172, 172), Color.FromArgb(163, 163, 163), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBO1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(111, 111, 111)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 0);

                    break;
                case MouseState.Down:
                    LinearGradientBrush LGBD1 = new LinearGradientBrush(new Rectangle(0, 0, Width - 1, Height - 1), Color.FromArgb(172, 172, 172), Color.FromArgb(163, 163, 163), 90f);

                    G.SmoothingMode = SmoothingMode.HighQuality;
                    G.FillPath(LGBD1, CreateRound(0, 1, Width - 1, Height - 2, 3));
                    G.DrawPath(new Pen(Color.FromArgb(111, 111, 111)), CreateRound(0, 0, Width - 1, Height - 1, 5));

                    DrawText(TextColor, HorizontalAlignment.Center, 0, 1);
                    break;
            }
        }
    }






    //------------------
    //Creator: aeonhack
    //Site: elitevs.net
    //Created: 08/02/2011
    //Changed: 12/06/2011
    //Version: 1.5.4
    //------------------

    //abstract class ThemeContainer154 : ContainerControl
    //{

    //    #region " Initialization "

    //    protected Graphics G;

    //    protected Bitmap B;
    //    public ThemeContainer154()
    //    {
    //        SetStyle((ControlStyles)139270, true);

    //        _ImageSize = Size.Empty;
    //        Font = new Font("Verdana", 8);

    //        MeasureBitmap = new Bitmap(1, 1);
    //        MeasureGraphics = Graphics.FromImage(MeasureBitmap);

    //        DrawRadialPath = new GraphicsPath();

    //        InvalidateCustimization();
    //    }

    //    protected override sealed void OnHandleCreated(EventArgs e)
    //    {
    //        if (DoneCreation)
    //            InitializeMessages();

    //        InvalidateCustimization();
    //        ColorHook();

    //        if (!(_LockWidth == 0))
    //            Width = _LockWidth;
    //        if (!(_LockHeight == 0))
    //            Height = _LockHeight;
    //        if (!_ControlMode)
    //            base.Dock = DockStyle.Fill;

    //        Transparent = _Transparent;
    //        if (_Transparent && _BackColor)
    //            BackColor = Color.Transparent;

    //        base.OnHandleCreated(e);
    //    }

    //    private bool DoneCreation;
    //    protected override sealed void OnParentChanged(EventArgs e)
    //    {
    //        base.OnParentChanged(e);

    //        if (Parent == null)
    //            return;
    //        _IsParentForm = Parent is Form;

    //        if (!_ControlMode)
    //        {
    //            InitializeMessages();

    //            if (_IsParentForm)
    //            {
    //                ParentForm.FormBorderStyle = _BorderStyle;
    //                ParentForm.TransparencyKey = _TransparencyKey;

    //                if (!DesignMode)
    //                {
    //                    ParentForm.Shown += FormShown;
    //                }
    //            }

    //            Parent.BackColor = BackColor;
    //        }

    //        OnCreation();
    //        DoneCreation = true;
    //        InvalidateTimer();
    //    }

    //    #endregion

    //    private void DoAnimation(bool i)
    //    {
    //        OnAnimation();
    //        if (i)
    //            Invalidate();
    //    }

    //    protected override sealed void OnPaint(PaintEventArgs e)
    //    {
    //        if (Width == 0 || Height == 0)
    //            return;

    //        if (_Transparent && _ControlMode)
    //        {
    //            PaintHook();
    //            e.Graphics.DrawImage(B, 0, 0);
    //        }
    //        else {
    //            G = e.Graphics;
    //            PaintHook();
    //        }
    //    }

    //    protected override void OnHandleDestroyed(EventArgs e)
    //    {
    //        ThemeShare.RemoveAnimationCallback(DoAnimation);
    //        base.OnHandleDestroyed(e);
    //    }

    //    private bool HasShown;
    //    private void FormShown(object sender, EventArgs e)
    //    {
    //        if (_ControlMode || HasShown)
    //            return;

    //        if (_StartPosition == FormStartPosition.CenterParent || _StartPosition == FormStartPosition.CenterScreen)
    //        {
    //            Rectangle SB = Screen.PrimaryScreen.Bounds;
    //            Rectangle CB = ParentForm.Bounds;
    //            ParentForm.Location = new Point(SB.Width / 2 - CB.Width / 2, SB.Height / 2 - CB.Width / 2);
    //        }

    //        HasShown = true;
    //    }


    //    #region " Size Handling "

    //    private Rectangle Frame;
    //    protected override sealed void OnSizeChanged(EventArgs e)
    //    {
    //        if (_Movable && !_ControlMode)
    //        {
    //            Frame = new Rectangle(7, 7, Width - 14, _Header - 7);
    //        }

    //        InvalidateBitmap();
    //        Invalidate();

    //        base.OnSizeChanged(e);
    //    }

    //    protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
    //    {
    //        if (!(_LockWidth == 0))
    //            width = _LockWidth;
    //        if (!(_LockHeight == 0))
    //            height = _LockHeight;
    //        base.SetBoundsCore(x, y, width, height, specified);
    //    }

    //    #endregion

    //    #region " State Handling "

    //    protected MouseState State;
    //    private void SetState(MouseState current)
    //    {
    //        State = current;
    //        Invalidate();
    //    }

    //    protected override void OnMouseMove(MouseEventArgs e)
    //    {
    //        if (!(_IsParentForm && ParentForm.WindowState == FormWindowState.Maximized))
    //        {
    //            if (_Sizable && !_ControlMode)
    //                InvalidateMouse();
    //        }

    //        base.OnMouseMove(e);
    //    }

    //    protected override void OnEnabledChanged(EventArgs e)
    //    {
    //        if (Enabled)
    //            SetState(MouseState.None);
    //        else
    //            SetState(MouseState.Block);
    //        base.OnEnabledChanged(e);
    //    }

    //    protected override void OnMouseEnter(EventArgs e)
    //    {
    //        SetState(MouseState.Over);
    //        base.OnMouseEnter(e);
    //    }

    //    protected override void OnMouseUp(MouseEventArgs e)
    //    {
    //        SetState(MouseState.Over);
    //        base.OnMouseUp(e);
    //    }

    //    protected override void OnMouseLeave(EventArgs e)
    //    {
    //        SetState(MouseState.None);

    //        if (GetChildAtPoint(PointToClient(MousePosition)) != null)
    //        {
    //            if (_Sizable && !_ControlMode)
    //            {
    //                Cursor = Cursors.Default;
    //                Previous = 0;
    //            }
    //        }

    //        base.OnMouseLeave(e);
    //    }

    //    protected override void OnMouseDown(MouseEventArgs e)
    //    {
    //        if (e.Button == MouseButtons.Left)
    //            SetState(MouseState.Down);

    //        if (!(_IsParentForm && ParentForm.WindowState == FormWindowState.Maximized || _ControlMode))
    //        {
    //            if (_Movable && Frame.Contains(e.Location))
    //            {
    //                Capture = false;
    //                WM_LMBUTTONDOWN = true;
    //                DefWndProc(ref Messages[0]);
    //            }
    //            else if (_Sizable && !(Previous == 0))
    //            {
    //                Capture = false;
    //                WM_LMBUTTONDOWN = true;
    //                DefWndProc(ref Messages[Previous]);
    //            }
    //        }

    //        base.OnMouseDown(e);
    //    }

    //    private bool WM_LMBUTTONDOWN;
    //    protected override void WndProc(ref Message m)
    //    {
    //        base.WndProc(ref m);

    //        if (WM_LMBUTTONDOWN && m.Msg == 513)
    //        {
    //            WM_LMBUTTONDOWN = false;

    //            SetState(MouseState.Over);
    //            if (!_SmartBounds)
    //                return;

    //            if (IsParentMdi)
    //            {
    //                CorrectBounds(new Rectangle(Point.Empty, Parent.Parent.Size));
    //            }
    //            else {
    //                CorrectBounds(Screen.FromControl(Parent).WorkingArea);
    //            }
    //        }
    //    }

    //    private Point GetIndexPoint;
    //    private bool B1;
    //    private bool B2;
    //    private bool B3;
    //    private bool B4;
    //    private int GetIndex()
    //    {
    //        GetIndexPoint = PointToClient(MousePosition);
    //        B1 = GetIndexPoint.X < 7;
    //        B2 = GetIndexPoint.X > Width - 7;
    //        B3 = GetIndexPoint.Y < 7;
    //        B4 = GetIndexPoint.Y > Height - 7;

    //        if (B1 && B3)
    //            return 4;
    //        if (B1 && B4)
    //            return 7;
    //        if (B2 && B3)
    //            return 5;
    //        if (B2 && B4)
    //            return 8;
    //        if (B1)
    //            return 1;
    //        if (B2)
    //            return 2;
    //        if (B3)
    //            return 3;
    //        if (B4)
    //            return 6;
    //        return 0;
    //    }

    //    private int Current;
    //    private int Previous;
    //    private void InvalidateMouse()
    //    {
    //        Current = GetIndex();
    //        if (Current == Previous)
    //            return;

    //        Previous = Current;
    //        switch (Previous)
    //        {
    //            case 0:
    //                Cursor = Cursors.Default;
    //                break;
    //            case 1:
    //            case 2:
    //                Cursor = Cursors.SizeWE;
    //                break;
    //            case 3:
    //            case 6:
    //                Cursor = Cursors.SizeNS;
    //                break;
    //            case 4:
    //            case 8:
    //                Cursor = Cursors.SizeNWSE;
    //                break;
    //            case 5:
    //            case 7:
    //                Cursor = Cursors.SizeNESW;
    //                break;
    //        }
    //    }

    //    private Message[] Messages = new Message[9];
    //    private void InitializeMessages()
    //    {
    //        Messages[0] = Message.Create(Parent.Handle, 161, new IntPtr(2), IntPtr.Zero);
    //        for (int I = 1; I <= 8; I++)
    //        {
    //            Messages[I] = Message.Create(Parent.Handle, 161, new IntPtr(I + 9), IntPtr.Zero);
    //        }
    //    }

    //    private void CorrectBounds(Rectangle bounds)
    //    {
    //        if (Parent.Width > bounds.Width)
    //            Parent.Width = bounds.Width;
    //        if (Parent.Height > bounds.Height)
    //            Parent.Height = bounds.Height;

    //        int X = Parent.Location.X;
    //        int Y = Parent.Location.Y;

    //        if (X < bounds.X)
    //            X = bounds.X;
    //        if (Y < bounds.Y)
    //            Y = bounds.Y;

    //        int Width = bounds.X + bounds.Width;
    //        int Height = bounds.Y + bounds.Height;

    //        if (X + Parent.Width > Width)
    //            X = Width - Parent.Width;
    //        if (Y + Parent.Height > Height)
    //            Y = Height - Parent.Height;

    //        Parent.Location = new Point(X, Y);
    //    }

    //    #endregion


    //    #region " Base Properties "

    //    public override DockStyle Dock
    //    {
    //        get { return base.Dock; }
    //        set
    //        {
    //            if (!_ControlMode)
    //                return;
    //            base.Dock = value;
    //        }
    //    }

    //    private bool _BackColor;
    //    [Category("Misc")]
    //    public override Color BackColor
    //    {
    //        get { return base.BackColor; }
    //        set
    //        {
    //            if (value == base.BackColor)
    //                return;

    //            if (!IsHandleCreated && _ControlMode && value == Color.Transparent)
    //            {
    //                _BackColor = true;
    //                return;
    //            }

    //            base.BackColor = value;
    //            if (Parent != null)
    //            {
    //                if (!_ControlMode)
    //                    Parent.BackColor = value;
    //                ColorHook();
    //            }
    //        }
    //    }

    //    public override Size MinimumSize
    //    {
    //        get { return base.MinimumSize; }
    //        set
    //        {
    //            base.MinimumSize = value;
    //            if (Parent != null)
    //                Parent.MinimumSize = value;
    //        }
    //    }

    //    public override Size MaximumSize
    //    {
    //        get { return base.MaximumSize; }
    //        set
    //        {
    //            base.MaximumSize = value;
    //            if (Parent != null)
    //                Parent.MaximumSize = value;
    //        }
    //    }

    //    public override string Text
    //    {
    //        get { return base.Text; }
    //        set
    //        {
    //            base.Text = value;
    //            Invalidate();
    //        }
    //    }

    //    public override Font Font
    //    {
    //        get { return base.Font; }
    //        set
    //        {
    //            base.Font = value;
    //            Invalidate();
    //        }
    //    }

    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override Color ForeColor
    //    {
    //        get { return Color.Empty; }
    //        set { }
    //    }
    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override Image BackgroundImage
    //    {
    //        get { return null; }
    //        set { }
    //    }
    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override ImageLayout BackgroundImageLayout
    //    {
    //        get { return ImageLayout.None; }
    //        set { }
    //    }

    //    #endregion

    //    #region " Public Properties "

    //    private bool _SmartBounds = true;
    //    public bool SmartBounds
    //    {
    //        get { return _SmartBounds; }
    //        set { _SmartBounds = value; }
    //    }

    //    private bool _Movable = true;
    //    public bool Movable
    //    {
    //        get { return _Movable; }
    //        set { _Movable = value; }
    //    }

    //    private bool _Sizable = true;
    //    public bool Sizable
    //    {
    //        get { return _Sizable; }
    //        set { _Sizable = value; }
    //    }

    //    private Color _TransparencyKey;
    //    public Color TransparencyKey
    //    {
    //        get
    //        {
    //            if (_IsParentForm && !_ControlMode)
    //                return ParentForm.TransparencyKey;
    //            else
    //                return _TransparencyKey;
    //        }
    //        set
    //        {
    //            if (value == _TransparencyKey)
    //                return;
    //            _TransparencyKey = value;

    //            if (_IsParentForm && !_ControlMode)
    //            {
    //                ParentForm.TransparencyKey = value;
    //                ColorHook();
    //            }
    //        }
    //    }

    //    private FormBorderStyle _BorderStyle;
    //    public FormBorderStyle BorderStyle
    //    {
    //        get
    //        {
    //            if (_IsParentForm && !_ControlMode)
    //                return ParentForm.FormBorderStyle;
    //            else
    //                return _BorderStyle;
    //        }
    //        set
    //        {
    //            _BorderStyle = value;

    //            if (_IsParentForm && !_ControlMode)
    //            {
    //                ParentForm.FormBorderStyle = value;

    //                if (!(value == FormBorderStyle.None))
    //                {
    //                    Movable = false;
    //                    Sizable = false;
    //                }
    //            }
    //        }
    //    }

    //    private FormStartPosition _StartPosition;
    //    public FormStartPosition StartPosition
    //    {
    //        get
    //        {
    //            if (_IsParentForm && !_ControlMode)
    //                return ParentForm.StartPosition;
    //            else
    //                return _StartPosition;
    //        }
    //        set
    //        {
    //            _StartPosition = value;

    //            if (_IsParentForm && !_ControlMode)
    //            {
    //                ParentForm.StartPosition = value;
    //            }
    //        }
    //    }

    //    private bool _NoRounding;
    //    public bool NoRounding
    //    {
    //        get { return _NoRounding; }
    //        set
    //        {
    //            _NoRounding = value;
    //            Invalidate();
    //        }
    //    }

    //    private Image _Image;
    //    public Image Image
    //    {
    //        get { return _Image; }
    //        set
    //        {
    //            if (value == null)
    //                _ImageSize = Size.Empty;
    //            else
    //                _ImageSize = value.Size;

    //            _Image = value;
    //            Invalidate();
    //        }
    //    }

    //    private Dictionary<string, Color> Items = new Dictionary<string, Color>();
    //    public Bloom[] Colors
    //    {
    //        get
    //        {
    //            List<Bloom> T = new List<Bloom>();
    //            Dictionary<string, Color>.Enumerator E = Items.GetEnumerator()();

    //            while (E.MoveNext())
    //            {
    //                T.Add(new Bloom(E.Current.Key, E.Current.Value));
    //            }

    //            return T.ToArray()()();
    //        }
    //        set
    //        {
    //            foreach (Bloom B in value)
    //            {
    //                if (Items.ContainsKey(B.Name))
    //                    Items[B.Name] = B.Value;
    //            }

    //            InvalidateCustimization();
    //            ColorHook();
    //            Invalidate();
    //        }
    //    }

    //    private string _Customization;
    //    public string Customization
    //    {
    //        get { return _Customization; }
    //        set
    //        {
    //            if (value == _Customization)
    //                return;

    //            byte[] Data = null;
    //            Bloom[] Items = Colors;

    //            try
    //            {
    //                Data = Convert.FromBase64String(value);
    //                for (int I = 0; I <= Items.Length - 1; I++)
    //                {
    //                    Items[I].Value = Color.FromArgb(BitConverter.ToInt32(Data, I * 4));
    //                }
    //            }
    //            catch
    //            {
    //                return;
    //            }

    //            _Customization = value;

    //            Colors = Items;
    //            ColorHook();
    //            Invalidate();
    //        }
    //    }

    //    private bool _Transparent;
    //    public bool Transparent
    //    {
    //        get { return _Transparent; }
    //        set
    //        {
    //            _Transparent = value;
    //            if (!(IsHandleCreated || _ControlMode))
    //                return;

    //            if (!value && !(BackColor.A == 255))
    //            {
    //                throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
    //            }

    //            SetStyle(ControlStyles.Opaque, !value);
    //            SetStyle(ControlStyles.SupportsTransparentBackColor, value);

    //            InvalidateBitmap();
    //            Invalidate();
    //        }
    //    }

    //    #endregion

    //    #region " Private Properties "

    //    private Size _ImageSize;
    //    protected Size ImageSize
    //    {
    //        get { return _ImageSize; }
    //    }

    //    private bool _IsParentForm;
    //    protected bool IsParentForm
    //    {
    //        get { return _IsParentForm; }
    //    }

    //    protected bool IsParentMdi
    //    {
    //        get
    //        {
    //            if (Parent == null)
    //                return false;
    //            return Parent.Parent != null;
    //        }
    //    }

    //    private int _LockWidth;
    //    protected int LockWidth
    //    {
    //        get { return _LockWidth; }
    //        set
    //        {
    //            _LockWidth = value;
    //            if (!(LockWidth == 0) && IsHandleCreated)
    //                Width = LockWidth;
    //        }
    //    }

    //    private int _LockHeight;
    //    protected int LockHeight
    //    {
    //        get { return _LockHeight; }
    //        set
    //        {
    //            _LockHeight = value;
    //            if (!(LockHeight == 0) && IsHandleCreated)
    //                Height = LockHeight;
    //        }
    //    }

    //    private int _Header = 24;
    //    protected int Header
    //    {
    //        get { return _Header; }
    //        set
    //        {
    //            _Header = value;

    //            if (!_ControlMode)
    //            {
    //                Frame = new Rectangle(7, 7, Width - 14, value - 7);
    //                Invalidate();
    //            }
    //        }
    //    }

    //    private bool _ControlMode;
    //    protected bool ControlMode
    //    {
    //        get { return _ControlMode; }
    //        set
    //        {
    //            _ControlMode = value;

    //            Transparent = _Transparent;
    //            if (_Transparent && _BackColor)
    //                BackColor = Color.Transparent;

    //            InvalidateBitmap();
    //            Invalidate();
    //        }
    //    }

    //    private bool _IsAnimated;
    //    protected bool IsAnimated
    //    {
    //        get { return _IsAnimated; }
    //        set
    //        {
    //            _IsAnimated = value;
    //            InvalidateTimer();
    //        }
    //    }

    //    #endregion


    //    #region " Property Helpers "

    //    protected Pen GetPen(string name)
    //    {
    //        return new Pen(Items[name]);
    //    }
    //    protected Pen GetPen(string name, float width)
    //    {
    //        return new Pen(Items[name], width);
    //    }

    //    protected SolidBrush GetBrush(string name)
    //    {
    //        return new SolidBrush(Items[name]);
    //    }

    //    protected Color GetColor(string name)
    //    {
    //        return Items[name];
    //    }

    //    protected void SetColor(string name, Color value)
    //    {
    //        if (Items.ContainsKey(name))
    //            Items[name] = value;
    //        else
    //            Items.Add(name, value);
    //    }
    //    protected void SetColor(string name, byte r, byte g, byte b)
    //    {
    //        SetColor(name, Color.FromArgb(r, g, b));
    //    }
    //    protected void SetColor(string name, byte a, byte r, byte g, byte b)
    //    {
    //        SetColor(name, Color.FromArgb(a, r, g, b));
    //    }
    //    protected void SetColor(string name, byte a, Color value)
    //    {
    //        SetColor(name, Color.FromArgb(a, value));
    //    }

    //    private void InvalidateBitmap()
    //    {
    //        if (_Transparent && _ControlMode)
    //        {
    //            if (Width == 0 || Height == 0)
    //                return;
    //            B = new Bitmap(Width, Height, PixelFormat.Format32bppPArgb);
    //            G = Graphics.FromImage(B);
    //        }
    //        else {
    //            G = null;
    //            B = null;
    //        }
    //    }

    //    private void InvalidateCustimization()
    //    {
    //        MemoryStream M = new MemoryStream(Items.Count * 4);

    //        foreach (Bloom B in Colors)
    //        {
    //            M.Write(BitConverter.GetBytes(B.Value.ToArgb()), 0, 4);
    //        }

    //        M.Close();
    //        _Customization = Convert.ToBase64String(M.ToArray()()());
    //    }

    //    private void InvalidateTimer()
    //    {
    //        if (DesignMode || !DoneCreation)
    //            return;

    //        if (_IsAnimated)
    //        {
    //            ThemeShare.AddAnimationCallback(DoAnimation);
    //        }
    //        else {
    //            ThemeShare.RemoveAnimationCallback(DoAnimation);
    //        }
    //    }

    //    #endregion


    //    #region " User Hooks "

    //    protected abstract void ColorHook();
    //    protected abstract void PaintHook();

    //    protected virtual void OnCreation()
    //    {
    //    }

    //    protected virtual void OnAnimation()
    //    {
    //    }

    //    #endregion


    //    #region " Offset "

    //    private Rectangle OffsetReturnRectangle;
    //    protected Rectangle Offset(Rectangle r, int amount)
    //    {
    //        OffsetReturnRectangle = new Rectangle(r.X + amount, r.Y + amount, r.Width - (amount * 2), r.Height - (amount * 2));
    //        return OffsetReturnRectangle;
    //    }

    //    private Size OffsetReturnSize;
    //    protected Size Offset(Size s, int amount)
    //    {
    //        OffsetReturnSize = new Size(s.Width + amount, s.Height + amount);
    //        return OffsetReturnSize;
    //    }

    //    private Point OffsetReturnPoint;
    //    protected Point Offset(Point p, int amount)
    //    {
    //        OffsetReturnPoint = new Point(p.X + amount, p.Y + amount);
    //        return OffsetReturnPoint;
    //    }

    //    #endregion

    //    #region " Center "


    //    private Point CenterReturn;
    //    protected Point Center(Rectangle p, Rectangle c)
    //    {
    //        CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X + c.X, (p.Height / 2 - c.Height / 2) + p.Y + c.Y);
    //        return CenterReturn;
    //    }
    //    protected Point Center(Rectangle p, Size c)
    //    {
    //        CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X, (p.Height / 2 - c.Height / 2) + p.Y);
    //        return CenterReturn;
    //    }

    //    protected Point Center(Rectangle child)
    //    {
    //        return Center(Width, Height, child.Width, child.Height);
    //    }
    //    protected Point Center(Size child)
    //    {
    //        return Center(Width, Height, child.Width, child.Height);
    //    }
    //    protected Point Center(int childWidth, int childHeight)
    //    {
    //        return Center(Width, Height, childWidth, childHeight);
    //    }

    //    protected Point Center(Size p, Size c)
    //    {
    //        return Center(p.Width, p.Height, c.Width, c.Height);
    //    }

    //    protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
    //    {
    //        CenterReturn = new Point(pWidth / 2 - cWidth / 2, pHeight / 2 - cHeight / 2);
    //        return CenterReturn;
    //    }

    //    #endregion

    //    #region " Measure "

    //    private Bitmap MeasureBitmap;

    //    private Graphics MeasureGraphics;
    //    protected Size Measure()
    //    {
    //        lock (MeasureGraphics)
    //        {
    //            return MeasureGraphics.MeasureString(Text, Font, Width).ToSize()()();
    //        }
    //    }
    //    protected Size Measure(string text)
    //    {
    //        lock (MeasureGraphics)
    //        {
    //            return MeasureGraphics.MeasureString(text, Font, Width).ToSize()()();
    //        }
    //    }

    //    #endregion


    //    #region " DrawPixel "


    //    private SolidBrush DrawPixelBrush;
    //    protected void DrawPixel(Color c1, int x, int y)
    //    {
    //        if (_Transparent)
    //        {
    //            B.SetPixel(x, y, c1);
    //        }
    //        else {
    //            DrawPixelBrush = new SolidBrush(c1);
    //            G.FillRectangle(DrawPixelBrush, x, y, 1, 1);
    //        }
    //    }

    //    #endregion

    //    #region " DrawCorners "


    //    private SolidBrush DrawCornersBrush;
    //    protected void DrawCorners(Color c1, int offset)
    //    {
    //        DrawCorners(c1, 0, 0, Width, Height, offset);
    //    }
    //    protected void DrawCorners(Color c1, Rectangle r1, int offset)
    //    {
    //        DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);
    //    }
    //    protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset)
    //    {
    //        DrawCorners(c1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
    //    }

    //    protected void DrawCorners(Color c1)
    //    {
    //        DrawCorners(c1, 0, 0, Width, Height);
    //    }
    //    protected void DrawCorners(Color c1, Rectangle r1)
    //    {
    //        DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);
    //    }
    //    protected void DrawCorners(Color c1, int x, int y, int width, int height)
    //    {
    //        if (_NoRounding)
    //            return;

    //        if (_Transparent)
    //        {
    //            B.SetPixel(x, y, c1);
    //            B.SetPixel(x + (width - 1), y, c1);
    //            B.SetPixel(x, y + (height - 1), c1);
    //            B.SetPixel(x + (width - 1), y + (height - 1), c1);
    //        }
    //        else {
    //            DrawCornersBrush = new SolidBrush(c1);
    //            G.FillRectangle(DrawCornersBrush, x, y, 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x + (width - 1), y, 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x, y + (height - 1), 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x + (width - 1), y + (height - 1), 1, 1);
    //        }
    //    }

    //    #endregion

    //    #region " DrawBorders "

    //    protected void DrawBorders(Pen p1, int offset)
    //    {
    //        DrawBorders(p1, 0, 0, Width, Height, offset);
    //    }
    //    protected void DrawBorders(Pen p1, Rectangle r, int offset)
    //    {
    //        DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);
    //    }
    //    protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset)
    //    {
    //        DrawBorders(p1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
    //    }

    //    protected void DrawBorders(Pen p1)
    //    {
    //        DrawBorders(p1, 0, 0, Width, Height);
    //    }
    //    protected void DrawBorders(Pen p1, Rectangle r)
    //    {
    //        DrawBorders(p1, r.X, r.Y, r.Width, r.Height);
    //    }
    //    protected void DrawBorders(Pen p1, int x, int y, int width, int height)
    //    {
    //        G.DrawRectangle(p1, x, y, width - 1, height - 1);
    //    }

    //    #endregion

    //    #region " DrawText "

    //    private Point DrawTextPoint;

    //    private Size DrawTextSize;
    //    protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y)
    //    {
    //        DrawText(b1, Text, a, x, y);
    //    }
    //    protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
    //    {
    //        if (text.Length == 0)
    //            return;

    //        DrawTextSize = Measure(text);
    //        DrawTextPoint = new Point(Width / 2 - DrawTextSize.Width / 2, Header / 2 - DrawTextSize.Height / 2);

    //        switch (a)
    //        {
    //            case HorizontalAlignment.Left:
    //                G.DrawString(text, Font, b1, x, DrawTextPoint.Y + y);
    //                break;
    //            case HorizontalAlignment.Center:
    //                G.DrawString(text, Font, b1, DrawTextPoint.X + x, DrawTextPoint.Y + y);
    //                break;
    //            case HorizontalAlignment.Right:
    //                G.DrawString(text, Font, b1, Width - DrawTextSize.Width - x, DrawTextPoint.Y + y);
    //                break;
    //        }
    //    }

    //    protected void DrawText(Brush b1, Point p1)
    //    {
    //        if (Text.Length == 0)
    //            return;
    //        G.DrawString(Text, Font, b1, p1);
    //    }
    //    protected void DrawText(Brush b1, int x, int y)
    //    {
    //        if (Text.Length == 0)
    //            return;
    //        G.DrawString(Text, Font, b1, x, y);
    //    }

    //    #endregion

    //    #region " DrawImage "


    //    private Point DrawImagePoint;
    //    protected void DrawImage(HorizontalAlignment a, int x, int y)
    //    {
    //        DrawImage(_Image, a, x, y);
    //    }
    //    protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
    //    {
    //        if (image == null)
    //            return;
    //        DrawImagePoint = new Point(Width / 2 - image.Width / 2, Header / 2 - image.Height / 2);

    //        switch (a)
    //        {
    //            case HorizontalAlignment.Left:
    //                G.DrawImage(image, x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //            case HorizontalAlignment.Center:
    //                G.DrawImage(image, DrawImagePoint.X + x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //            case HorizontalAlignment.Right:
    //                G.DrawImage(image, Width - image.Width - x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //        }
    //    }

    //    protected void DrawImage(Point p1)
    //    {
    //        DrawImage(_Image, p1.X, p1.Y);
    //    }
    //    protected void DrawImage(int x, int y)
    //    {
    //        DrawImage(_Image, x, y);
    //    }

    //    protected void DrawImage(Image image, Point p1)
    //    {
    //        DrawImage(image, p1.X, p1.Y);
    //    }
    //    protected void DrawImage(Image image, int x, int y)
    //    {
    //        if (image == null)
    //            return;
    //        G.DrawImage(image, x, y, image.Width, image.Height);
    //    }

    //    #endregion

    //    #region " DrawGradient "

    //    private LinearGradientBrush DrawGradientBrush;

    //    private Rectangle DrawGradientRectangle;
    //    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(blend, DrawGradientRectangle);
    //    }
    //    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height, float angle)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(blend, DrawGradientRectangle, angle);
    //    }

    //    protected void DrawGradient(ColorBlend blend, Rectangle r)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
    //        DrawGradientBrush.InterpolationColors = blend;
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }
    //    protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
    //        DrawGradientBrush.InterpolationColors = blend;
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }


    //    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(c1, c2, DrawGradientRectangle);
    //    }
    //    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height, float angle)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(c1, c2, DrawGradientRectangle, angle);
    //    }

    //    protected void DrawGradient(Color c1, Color c2, Rectangle r)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }
    //    protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }

    //    #endregion

    //    #region " DrawRadial "

    //    private GraphicsPath DrawRadialPath;
    //    private PathGradientBrush DrawRadialBrush1;
    //    private LinearGradientBrush DrawRadialBrush2;

    //    private Rectangle DrawRadialRectangle;
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, width / 2, height / 2);
    //    }
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, center.X, center.Y);
    //    }
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, int cx, int cy)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, cx, cy);
    //    }

    //    public void DrawRadial(ColorBlend blend, Rectangle r)
    //    {
    //        DrawRadial(blend, r, r.Width / 2, r.Height / 2);
    //    }
    //    public void DrawRadial(ColorBlend blend, Rectangle r, Point center)
    //    {
    //        DrawRadial(blend, r, center.X, center.Y);
    //    }
    //    public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
    //    {
    //        DrawRadialPath.Reset();
    //        DrawRadialPath.AddEllipse(r.X, r.Y, r.Width - 1, r.Height - 1);

    //        DrawRadialBrush1 = new PathGradientBrush(DrawRadialPath);
    //        DrawRadialBrush1.CenterPoint = new Point(r.X + cx, r.Y + cy);
    //        DrawRadialBrush1.InterpolationColors = blend;

    //        if (G.SmoothingMode == SmoothingMode.AntiAlias)
    //        {
    //            G.FillEllipse(DrawRadialBrush1, r.X + 1, r.Y + 1, r.Width - 3, r.Height - 3);
    //        }
    //        else {
    //            G.FillEllipse(DrawRadialBrush1, r);
    //        }
    //    }


    //    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(c1, c2, DrawGradientRectangle);
    //    }
    //    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height, float angle)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(c1, c2, DrawGradientRectangle, angle);
    //    }

    //    protected void DrawRadial(Color c1, Color c2, Rectangle r)
    //    {
    //        DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }
    //    protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
    //    {
    //        DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
    //        G.FillEllipse(DrawGradientBrush, r);
    //    }

    //    #endregion

    //    #region " CreateRound "

    //    private GraphicsPath CreateRoundPath;

    //    private Rectangle CreateRoundRectangle;
    //    public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
    //    {
    //        CreateRoundRectangle = new Rectangle(x, y, width, height);
    //        return CreateRound(CreateRoundRectangle, slope);
    //    }

    //    public GraphicsPath CreateRound(Rectangle r, int slope)
    //    {
    //        CreateRoundPath = new GraphicsPath(FillMode.Winding);
    //        CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
    //        CreateRoundPath.AddArc(r.Right - slope, r.Y, slope, slope, 270f, 90f);
    //        CreateRoundPath.AddArc(r.Right - slope, r.Bottom - slope, slope, slope, 0f, 90f);
    //        CreateRoundPath.AddArc(r.X, r.Bottom - slope, slope, slope, 90f, 90f);
    //        CreateRoundPath.CloseFigure();
    //        return CreateRoundPath;
    //    }

    //    #endregion

    //}

    //abstract class ThemeControl154 : Control
    //{


    //    #region " Initialization "

    //    protected Graphics G;

    //    protected Bitmap B;
    //    public ThemeControl154()
    //    {
    //        SetStyle((ControlStyles)139270, true);

    //        _ImageSize = Size.Empty;
    //        Font = new Font("Verdana", 8);

    //        MeasureBitmap = new Bitmap(1, 1);
    //        MeasureGraphics = Graphics.FromImage(MeasureBitmap);

    //        DrawRadialPath = new GraphicsPath();

    //        InvalidateCustimization();
    //        //Remove?
    //    }

    //    protected override sealed void OnHandleCreated(EventArgs e)
    //    {
    //        InvalidateCustimization();
    //        ColorHook();

    //        if (!(_LockWidth == 0))
    //            Width = _LockWidth;
    //        if (!(_LockHeight == 0))
    //            Height = _LockHeight;

    //        Transparent = _Transparent;
    //        if (_Transparent && _BackColor)
    //            BackColor = Color.Transparent;

    //        base.OnHandleCreated(e);
    //    }

    //    private bool DoneCreation;
    //    protected override sealed void OnParentChanged(EventArgs e)
    //    {
    //        if (Parent != null)
    //        {
    //            OnCreation();
    //            DoneCreation = true;
    //            InvalidateTimer();
    //        }

    //        base.OnParentChanged(e);
    //    }

    //    #endregion

    //    private void DoAnimation(bool i)
    //    {
    //        OnAnimation();
    //        if (i)
    //            Invalidate();
    //    }

    //    protected override sealed void OnPaint(PaintEventArgs e)
    //    {
    //        if (Width == 0 || Height == 0)
    //            return;

    //        if (_Transparent)
    //        {
    //            PaintHook();
    //            e.Graphics.DrawImage(B, 0, 0);
    //        }
    //        else {
    //            G = e.Graphics;
    //            PaintHook();
    //        }
    //    }

    //    protected override void OnHandleDestroyed(EventArgs e)
    //    {
    //        ThemeShare.RemoveAnimationCallback(DoAnimation);
    //        base.OnHandleDestroyed(e);
    //    }

    //    #region " Size Handling "

    //    protected override sealed void OnSizeChanged(EventArgs e)
    //    {
    //        if (_Transparent)
    //        {
    //            InvalidateBitmap();
    //        }

    //        Invalidate();
    //        base.OnSizeChanged(e);
    //    }

    //    protected override void SetBoundsCore(int x, int y, int width, int height, BoundsSpecified specified)
    //    {
    //        if (!(_LockWidth == 0))
    //            width = _LockWidth;
    //        if (!(_LockHeight == 0))
    //            height = _LockHeight;
    //        base.SetBoundsCore(x, y, width, height, specified);
    //    }

    //    #endregion

    //    #region " State Handling "

    //    private bool InPosition;
    //    protected override void OnMouseEnter(EventArgs e)
    //    {
    //        InPosition = true;
    //        SetState(MouseState.Over);
    //        base.OnMouseEnter(e);
    //    }

    //    protected override void OnMouseUp(MouseEventArgs e)
    //    {
    //        if (InPosition)
    //            SetState(MouseState.Over);
    //        base.OnMouseUp(e);
    //    }

    //    protected override void OnMouseDown(MouseEventArgs e)
    //    {
    //        if (e.Button == MouseButtons.Left)
    //            SetState(MouseState.Down);
    //        base.OnMouseDown(e);
    //    }

    //    protected override void OnMouseLeave(EventArgs e)
    //    {
    //        InPosition = false;
    //        SetState(MouseState.None);
    //        base.OnMouseLeave(e);
    //    }

    //    protected override void OnEnabledChanged(EventArgs e)
    //    {
    //        if (Enabled)
    //            SetState(MouseState.None);
    //        else
    //            SetState(MouseState.Block);
    //        base.OnEnabledChanged(e);
    //    }

    //    protected MouseState State;
    //    private void SetState(MouseState current)
    //    {
    //        State = current;
    //        Invalidate();
    //    }

    //    #endregion


    //    #region " Base Properties "

    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override Color ForeColor
    //    {
    //        get { return Color.Empty; }
    //        set { }
    //    }
    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override Image BackgroundImage
    //    {
    //        get { return null; }
    //        set { }
    //    }
    //    [Browsable(false), EditorBrowsable(EditorBrowsableState.Never), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
    //    public override ImageLayout BackgroundImageLayout
    //    {
    //        get { return ImageLayout.None; }
    //        set { }
    //    }

    //    public override string Text
    //    {
    //        get { return base.Text; }
    //        set
    //        {
    //            base.Text = value;
    //            Invalidate();
    //        }
    //    }
    //    public override Font Font
    //    {
    //        get { return base.Font; }
    //        set
    //        {
    //            base.Font = value;
    //            Invalidate();
    //        }
    //    }

    //    private bool _BackColor;
    //    [Category("Misc")]
    //    public override Color BackColor
    //    {
    //        get { return base.BackColor; }
    //        set
    //        {
    //            if (!IsHandleCreated && value == Color.Transparent)
    //            {
    //                _BackColor = true;
    //                return;
    //            }

    //            base.BackColor = value;
    //            if (Parent != null)
    //                ColorHook();
    //        }
    //    }

    //    #endregion

    //    #region " Public Properties "

    //    private bool _NoRounding;
    //    public bool NoRounding
    //    {
    //        get { return _NoRounding; }
    //        set
    //        {
    //            _NoRounding = value;
    //            Invalidate();
    //        }
    //    }

    //    private Image _Image;
    //    public Image Image
    //    {
    //        get { return _Image; }
    //        set
    //        {
    //            if (value == null)
    //            {
    //                _ImageSize = Size.Empty;
    //            }
    //            else {
    //                _ImageSize = value.Size;
    //            }

    //            _Image = value;
    //            Invalidate();
    //        }
    //    }

    //    private bool _Transparent;
    //    public bool Transparent
    //    {
    //        get { return _Transparent; }
    //        set
    //        {
    //            _Transparent = value;
    //            if (!IsHandleCreated)
    //                return;

    //            if (!value && !(BackColor.A == 255))
    //            {
    //                throw new Exception("Unable to change value to false while a transparent BackColor is in use.");
    //            }

    //            SetStyle(ControlStyles.Opaque, !value);
    //            SetStyle(ControlStyles.SupportsTransparentBackColor, value);

    //            if (value)
    //                InvalidateBitmap();
    //            else
    //                B = null;
    //            Invalidate();
    //        }
    //    }

    //    private Dictionary<string, Color> Items = new Dictionary<string, Color>();
    //    public Bloom[] Colors
    //    {
    //        get
    //        {
    //            List<Bloom> T = new List<Bloom>();
    //            Dictionary<string, Color>.Enumerator E = Items.GetEnumerator()();

    //            while (E.MoveNext())
    //            {
    //                T.Add(new Bloom(E.Current.Key, E.Current.Value));
    //            }

    //            return T.ToArray()()();
    //        }
    //        set
    //        {
    //            foreach (Bloom B in value)
    //            {
    //                if (Items.ContainsKey(B.Name))
    //                    Items[B.Name] = B.Value;
    //            }

    //            InvalidateCustimization();
    //            ColorHook();
    //            Invalidate();
    //        }
    //    }

    //    private string _Customization;
    //    public string Customization
    //    {
    //        get { return _Customization; }
    //        set
    //        {
    //            if (value == _Customization)
    //                return;

    //            byte[] Data = null;
    //            Bloom[] Items = Colors;

    //            try
    //            {
    //                Data = Convert.FromBase64String(value);
    //                for (int I = 0; I <= Items.Length - 1; I++)
    //                {
    //                    Items[I].Value = Color.FromArgb(BitConverter.ToInt32(Data, I * 4));
    //                }
    //            }
    //            catch
    //            {
    //                return;
    //            }

    //            _Customization = value;

    //            Colors = Items;
    //            ColorHook();
    //            Invalidate();
    //        }
    //    }

    //    #endregion

    //    #region " Private Properties "

    //    private Size _ImageSize;
    //    protected Size ImageSize
    //    {
    //        get { return _ImageSize; }
    //    }

    //    private int _LockWidth;
    //    protected int LockWidth
    //    {
    //        get { return _LockWidth; }
    //        set
    //        {
    //            _LockWidth = value;
    //            if (!(LockWidth == 0) && IsHandleCreated)
    //                Width = LockWidth;
    //        }
    //    }

    //    private int _LockHeight;
    //    protected int LockHeight
    //    {
    //        get { return _LockHeight; }
    //        set
    //        {
    //            _LockHeight = value;
    //            if (!(LockHeight == 0) && IsHandleCreated)
    //                Height = LockHeight;
    //        }
    //    }

    //    private bool _IsAnimated;
    //    protected bool IsAnimated
    //    {
    //        get { return _IsAnimated; }
    //        set
    //        {
    //            _IsAnimated = value;
    //            InvalidateTimer();
    //        }
    //    }

    //    #endregion


    //    #region " Property Helpers "

    //    protected Pen GetPen(string name)
    //    {
    //        return new Pen(Items[name]);
    //    }
    //    protected Pen GetPen(string name, float width)
    //    {
    //        return new Pen(Items[name], width);
    //    }

    //    protected SolidBrush GetBrush(string name)
    //    {
    //        return new SolidBrush(Items[name]);
    //    }

    //    protected Color GetColor(string name)
    //    {
    //        return Items[name];
    //    }

    //    protected void SetColor(string name, Color value)
    //    {
    //        if (Items.ContainsKey(name))
    //            Items[name] = value;
    //        else
    //            Items.Add(name, value);
    //    }
    //    protected void SetColor(string name, byte r, byte g, byte b)
    //    {
    //        SetColor(name, Color.FromArgb(r, g, b));
    //    }
    //    protected void SetColor(string name, byte a, byte r, byte g, byte b)
    //    {
    //        SetColor(name, Color.FromArgb(a, r, g, b));
    //    }
    //    protected void SetColor(string name, byte a, Color value)
    //    {
    //        SetColor(name, Color.FromArgb(a, value));
    //    }

    //    private void InvalidateBitmap()
    //    {
    //        if (Width == 0 || Height == 0)
    //            return;
    //        B = new Bitmap(Width, Height, PixelFormat.Format32bppPArgb);
    //        G = Graphics.FromImage(B);
    //    }

    //    private void InvalidateCustimization()
    //    {
    //        MemoryStream M = new MemoryStream(Items.Count * 4);

    //        foreach (Bloom B in Colors)
    //        {
    //            M.Write(BitConverter.GetBytes(B.Value.ToArgb()), 0, 4);
    //        }

    //        M.Close();
    //        _Customization = Convert.ToBase64String(M.ToArray()()());
    //    }

    //    private void InvalidateTimer()
    //    {
    //        if (DesignMode || !DoneCreation)
    //            return;

    //        if (_IsAnimated)
    //        {
    //            ThemeShare.AddAnimationCallback(DoAnimation);
    //        }
    //        else {
    //            ThemeShare.RemoveAnimationCallback(DoAnimation);
    //        }
    //    }
    //    #endregion


    //    #region " User Hooks "

    //    protected abstract void ColorHook();
    //    protected abstract void PaintHook();

    //    protected virtual void OnCreation()
    //    {
    //    }

    //    protected virtual void OnAnimation()
    //    {
    //    }

    //    #endregion


    //    #region " Offset "

    //    private Rectangle OffsetReturnRectangle;
    //    protected Rectangle Offset(Rectangle r, int amount)
    //    {
    //        OffsetReturnRectangle = new Rectangle(r.X + amount, r.Y + amount, r.Width - (amount * 2), r.Height - (amount * 2));
    //        return OffsetReturnRectangle;
    //    }

    //    private Size OffsetReturnSize;
    //    protected Size Offset(Size s, int amount)
    //    {
    //        OffsetReturnSize = new Size(s.Width + amount, s.Height + amount);
    //        return OffsetReturnSize;
    //    }

    //    private Point OffsetReturnPoint;
    //    protected Point Offset(Point p, int amount)
    //    {
    //        OffsetReturnPoint = new Point(p.X + amount, p.Y + amount);
    //        return OffsetReturnPoint;
    //    }

    //    #endregion

    //    #region " Center "


    //    private Point CenterReturn;
    //    protected Point Center(Rectangle p, Rectangle c)
    //    {
    //        CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X + c.X, (p.Height / 2 - c.Height / 2) + p.Y + c.Y);
    //        return CenterReturn;
    //    }
    //    protected Point Center(Rectangle p, Size c)
    //    {
    //        CenterReturn = new Point((p.Width / 2 - c.Width / 2) + p.X, (p.Height / 2 - c.Height / 2) + p.Y);
    //        return CenterReturn;
    //    }

    //    protected Point Center(Rectangle child)
    //    {
    //        return Center(Width, Height, child.Width, child.Height);
    //    }
    //    protected Point Center(Size child)
    //    {
    //        return Center(Width, Height, child.Width, child.Height);
    //    }
    //    protected Point Center(int childWidth, int childHeight)
    //    {
    //        return Center(Width, Height, childWidth, childHeight);
    //    }

    //    protected Point Center(Size p, Size c)
    //    {
    //        return Center(p.Width, p.Height, c.Width, c.Height);
    //    }

    //    protected Point Center(int pWidth, int pHeight, int cWidth, int cHeight)
    //    {
    //        CenterReturn = new Point(pWidth / 2 - cWidth / 2, pHeight / 2 - cHeight / 2);
    //        return CenterReturn;
    //    }

    //    #endregion

    //    #region " Measure "

    //    private Bitmap MeasureBitmap;
    //    //TODO: Potential issues during multi-threading.
    //    private Graphics MeasureGraphics;

    //    protected Size Measure()
    //    {
    //        return MeasureGraphics.MeasureString(Text, Font, Width).ToSize()()();
    //    }
    //    protected Size Measure(string text)
    //    {
    //        return MeasureGraphics.MeasureString(text, Font, Width).ToSize()()();
    //    }

    //    #endregion


    //    #region " DrawPixel "


    //    private SolidBrush DrawPixelBrush;
    //    protected void DrawPixel(Color c1, int x, int y)
    //    {
    //        if (_Transparent)
    //        {
    //            B.SetPixel(x, y, c1);
    //        }
    //        else {
    //            DrawPixelBrush = new SolidBrush(c1);
    //            G.FillRectangle(DrawPixelBrush, x, y, 1, 1);
    //        }
    //    }

    //    #endregion

    //    #region " DrawCorners "


    //    private SolidBrush DrawCornersBrush;
    //    protected void DrawCorners(Color c1, int offset)
    //    {
    //        DrawCorners(c1, 0, 0, Width, Height, offset);
    //    }
    //    protected void DrawCorners(Color c1, Rectangle r1, int offset)
    //    {
    //        DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height, offset);
    //    }
    //    protected void DrawCorners(Color c1, int x, int y, int width, int height, int offset)
    //    {
    //        DrawCorners(c1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
    //    }

    //    protected void DrawCorners(Color c1)
    //    {
    //        DrawCorners(c1, 0, 0, Width, Height);
    //    }
    //    protected void DrawCorners(Color c1, Rectangle r1)
    //    {
    //        DrawCorners(c1, r1.X, r1.Y, r1.Width, r1.Height);
    //    }
    //    protected void DrawCorners(Color c1, int x, int y, int width, int height)
    //    {
    //        if (_NoRounding)
    //            return;

    //        if (_Transparent)
    //        {
    //            B.SetPixel(x, y, c1);
    //            B.SetPixel(x + (width - 1), y, c1);
    //            B.SetPixel(x, y + (height - 1), c1);
    //            B.SetPixel(x + (width - 1), y + (height - 1), c1);
    //        }
    //        else {
    //            DrawCornersBrush = new SolidBrush(c1);
    //            G.FillRectangle(DrawCornersBrush, x, y, 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x + (width - 1), y, 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x, y + (height - 1), 1, 1);
    //            G.FillRectangle(DrawCornersBrush, x + (width - 1), y + (height - 1), 1, 1);
    //        }
    //    }

    //    #endregion

    //    #region " DrawBorders "

    //    protected void DrawBorders(Pen p1, int offset)
    //    {
    //        DrawBorders(p1, 0, 0, Width, Height, offset);
    //    }
    //    protected void DrawBorders(Pen p1, Rectangle r, int offset)
    //    {
    //        DrawBorders(p1, r.X, r.Y, r.Width, r.Height, offset);
    //    }
    //    protected void DrawBorders(Pen p1, int x, int y, int width, int height, int offset)
    //    {
    //        DrawBorders(p1, x + offset, y + offset, width - (offset * 2), height - (offset * 2));
    //    }

    //    protected void DrawBorders(Pen p1)
    //    {
    //        DrawBorders(p1, 0, 0, Width, Height);
    //    }
    //    protected void DrawBorders(Pen p1, Rectangle r)
    //    {
    //        DrawBorders(p1, r.X, r.Y, r.Width, r.Height);
    //    }
    //    protected void DrawBorders(Pen p1, int x, int y, int width, int height)
    //    {
    //        G.DrawRectangle(p1, x, y, width - 1, height - 1);
    //    }

    //    #endregion

    //    #region " DrawText "

    //    private Point DrawTextPoint;

    //    private Size DrawTextSize;
    //    protected void DrawText(Brush b1, HorizontalAlignment a, int x, int y)
    //    {
    //        DrawText(b1, Text, a, x, y);
    //    }
    //    protected void DrawText(Brush b1, string text, HorizontalAlignment a, int x, int y)
    //    {
    //        if (text.Length == 0)
    //            return;

    //        DrawTextSize = Measure(text);
    //        DrawTextPoint = Center(DrawTextSize);

    //        switch (a)
    //        {
    //            case HorizontalAlignment.Left:
    //                G.DrawString(text, Font, b1, x, DrawTextPoint.Y + y);
    //                break;
    //            case HorizontalAlignment.Center:
    //                G.DrawString(text, Font, b1, DrawTextPoint.X + x, DrawTextPoint.Y + y);
    //                break;
    //            case HorizontalAlignment.Right:
    //                G.DrawString(text, Font, b1, Width - DrawTextSize.Width - x, DrawTextPoint.Y + y);
    //                break;
    //        }
    //    }

    //    protected void DrawText(Brush b1, Point p1)
    //    {
    //        if (Text.Length == 0)
    //            return;
    //        G.DrawString(Text, Font, b1, p1);
    //    }
    //    protected void DrawText(Brush b1, int x, int y)
    //    {
    //        if (Text.Length == 0)
    //            return;
    //        G.DrawString(Text, Font, b1, x, y);
    //    }

    //    #endregion

    //    #region " DrawImage "


    //    private Point DrawImagePoint;
    //    protected void DrawImage(HorizontalAlignment a, int x, int y)
    //    {
    //        DrawImage(_Image, a, x, y);
    //    }
    //    protected void DrawImage(Image image, HorizontalAlignment a, int x, int y)
    //    {
    //        if (image == null)
    //            return;
    //        DrawImagePoint = Center(image.Size);

    //        switch (a)
    //        {
    //            case HorizontalAlignment.Left:
    //                G.DrawImage(image, x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //            case HorizontalAlignment.Center:
    //                G.DrawImage(image, DrawImagePoint.X + x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //            case HorizontalAlignment.Right:
    //                G.DrawImage(image, Width - image.Width - x, DrawImagePoint.Y + y, image.Width, image.Height);
    //                break;
    //        }
    //    }

    //    protected void DrawImage(Point p1)
    //    {
    //        DrawImage(_Image, p1.X, p1.Y);
    //    }
    //    protected void DrawImage(int x, int y)
    //    {
    //        DrawImage(_Image, x, y);
    //    }

    //    protected void DrawImage(Image image, Point p1)
    //    {
    //        DrawImage(image, p1.X, p1.Y);
    //    }
    //    protected void DrawImage(Image image, int x, int y)
    //    {
    //        if (image == null)
    //            return;
    //        G.DrawImage(image, x, y, image.Width, image.Height);
    //    }

    //    #endregion

    //    #region " DrawGradient "

    //    private LinearGradientBrush DrawGradientBrush;

    //    private Rectangle DrawGradientRectangle;
    //    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(blend, DrawGradientRectangle);
    //    }
    //    protected void DrawGradient(ColorBlend blend, int x, int y, int width, int height, float angle)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(blend, DrawGradientRectangle, angle);
    //    }

    //    protected void DrawGradient(ColorBlend blend, Rectangle r)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, 90f);
    //        DrawGradientBrush.InterpolationColors = blend;
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }
    //    protected void DrawGradient(ColorBlend blend, Rectangle r, float angle)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, Color.Empty, Color.Empty, angle);
    //        DrawGradientBrush.InterpolationColors = blend;
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }


    //    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(c1, c2, DrawGradientRectangle);
    //    }
    //    protected void DrawGradient(Color c1, Color c2, int x, int y, int width, int height, float angle)
    //    {
    //        DrawGradientRectangle = new Rectangle(x, y, width, height);
    //        DrawGradient(c1, c2, DrawGradientRectangle, angle);
    //    }

    //    protected void DrawGradient(Color c1, Color c2, Rectangle r)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, c1, c2, 90f);
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }
    //    protected void DrawGradient(Color c1, Color c2, Rectangle r, float angle)
    //    {
    //        DrawGradientBrush = new LinearGradientBrush(r, c1, c2, angle);
    //        G.FillRectangle(DrawGradientBrush, r);
    //    }

    //    #endregion

    //    #region " DrawRadial "

    //    private GraphicsPath DrawRadialPath;
    //    private PathGradientBrush DrawRadialBrush1;
    //    private LinearGradientBrush DrawRadialBrush2;

    //    private Rectangle DrawRadialRectangle;
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, width / 2, height / 2);
    //    }
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, Point center)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, center.X, center.Y);
    //    }
    //    public void DrawRadial(ColorBlend blend, int x, int y, int width, int height, int cx, int cy)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(blend, DrawRadialRectangle, cx, cy);
    //    }

    //    public void DrawRadial(ColorBlend blend, Rectangle r)
    //    {
    //        DrawRadial(blend, r, r.Width / 2, r.Height / 2);
    //    }
    //    public void DrawRadial(ColorBlend blend, Rectangle r, Point center)
    //    {
    //        DrawRadial(blend, r, center.X, center.Y);
    //    }
    //    public void DrawRadial(ColorBlend blend, Rectangle r, int cx, int cy)
    //    {
    //        DrawRadialPath.Reset();
    //        DrawRadialPath.AddEllipse(r.X, r.Y, r.Width - 1, r.Height - 1);

    //        DrawRadialBrush1 = new PathGradientBrush(DrawRadialPath);
    //        DrawRadialBrush1.CenterPoint = new Point(r.X + cx, r.Y + cy);
    //        DrawRadialBrush1.InterpolationColors = blend;

    //        if (G.SmoothingMode == SmoothingMode.AntiAlias)
    //        {
    //            G.FillEllipse(DrawRadialBrush1, r.X + 1, r.Y + 1, r.Width - 3, r.Height - 3);
    //        }
    //        else {
    //            G.FillEllipse(DrawRadialBrush1, r);
    //        }
    //    }


    //    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(c1, c2, DrawRadialRectangle);
    //    }
    //    protected void DrawRadial(Color c1, Color c2, int x, int y, int width, int height, float angle)
    //    {
    //        DrawRadialRectangle = new Rectangle(x, y, width, height);
    //        DrawRadial(c1, c2, DrawRadialRectangle, angle);
    //    }

    //    protected void DrawRadial(Color c1, Color c2, Rectangle r)
    //    {
    //        DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, 90f);
    //        G.FillEllipse(DrawRadialBrush2, r);
    //    }
    //    protected void DrawRadial(Color c1, Color c2, Rectangle r, float angle)
    //    {
    //        DrawRadialBrush2 = new LinearGradientBrush(r, c1, c2, angle);
    //        G.FillEllipse(DrawRadialBrush2, r);
    //    }

    //    #endregion

    //    #region " CreateRound "

    //    private GraphicsPath CreateRoundPath;

    //    private Rectangle CreateRoundRectangle;
    //    public GraphicsPath CreateRound(int x, int y, int width, int height, int slope)
    //    {
    //        CreateRoundRectangle = new Rectangle(x, y, width, height);
    //        return CreateRound(CreateRoundRectangle, slope);
    //    }

    //    public GraphicsPath CreateRound(Rectangle r, int slope)
    //    {
    //        CreateRoundPath = new GraphicsPath(FillMode.Winding);
    //        CreateRoundPath.AddArc(r.X, r.Y, slope, slope, 180f, 90f);
    //        CreateRoundPath.AddArc(r.Right - slope, r.Y, slope, slope, 270f, 90f);
    //        CreateRoundPath.AddArc(r.Right - slope, r.Bottom - slope, slope, slope, 0f, 90f);
    //        CreateRoundPath.AddArc(r.X, r.Bottom - slope, slope, slope, 90f, 90f);
    //        CreateRoundPath.CloseFigure();
    //        return CreateRoundPath;
    //    }

    //    #endregion

    //}

    //static class ThemeShare
    //{

    //    #region " Animation "

    //    private static int Frames;
    //    private static bool Invalidate;

    //    public static PrecisionTimer ThemeTimer = new PrecisionTimer();
    //    //1000 / 50 = 20 FPS
    //    private const int FPS = 50;

    //    private const int Rate = 10;
    //    public delegate void AnimationDelegate(bool invalidate);


    //    private static List<AnimationDelegate> Callbacks = new List<AnimationDelegate>();
    //    private static void HandleCallbacks(IntPtr state, bool reserve)
    //    {
    //        Invalidate = (Frames >= FPS);
    //        if (Invalidate)
    //            Frames = 0;

    //        lock (Callbacks)
    //        {
    //            for (int I = 0; I <= Callbacks.Count - 1; I++)
    //            {
    //                Callbacks[I].Invoke(Invalidate);
    //            }
    //        }

    //        Frames += Rate;
    //    }

    //    private static void InvalidateThemeTimer()
    //    {
    //        if (Callbacks.Count == 0)
    //        {
    //            ThemeTimer.Delete();
    //        }
    //        else {
    //            ThemeTimer.Create(0, Rate, HandleCallbacks);
    //        }
    //    }

    //    public static void AddAnimationCallback(AnimationDelegate callback)
    //    {
    //        lock (Callbacks)
    //        {
    //            if (Callbacks.Contains(callback))
    //                return;

    //            Callbacks.Add(callback);
    //            InvalidateThemeTimer();
    //        }
    //    }

    //    public static void RemoveAnimationCallback(AnimationDelegate callback)
    //    {
    //        lock (Callbacks)
    //        {
    //            if (!Callbacks.Contains(callback))
    //                return;

    //            Callbacks.Remove(callback);
    //            InvalidateThemeTimer();
    //        }
    //    }

    //    #endregion

    //}

    //enum MouseState : byte
    //{
    //    None = 0,
    //    Over = 1,
    //    Down = 2,
    //    Block = 3
    //}

    //struct Bloom
    //{

    //    public string _Name;
    //    public string Name
    //    {
    //        get { return _Name; }
    //    }

    //    private Color _Value;
    //    public Color Value
    //    {
    //        get { return _Value; }
    //        set { _Value = value; }
    //    }

    //    public string ValueHex
    //    {
    //        get { return string.Concat("#", _Value.R.ToString("X2", null), _Value.G.ToString("X2", null), _Value.B.ToString("X2", null)); }
    //        set
    //        {
    //            try
    //            {
    //                _Value = ColorTranslator.FromHtml(value);
    //            }
    //            catch
    //            {
    //                return;
    //            }
    //        }
    //    }


    //    public Bloom(string name, Color value)
    //    {
    //        _Name = name;
    //        _Value = value;
    //    }
    //}

    ////------------------
    ////Creator: aeonhack
    ////Site: elitevs.net
    ////Created: 11/30/2011
    ////Changed: 11/30/2011
    ////Version: 1.0.0
    ////------------------
    //class PrecisionTimer : IDisposable
    //{

    //    private bool _Enabled;
    //    public bool Enabled
    //    {
    //        get { return _Enabled; }
    //    }

    //    private IntPtr Handle;

    //    private TimerDelegate TimerCallback;
    //    [DllImport("kernel32.dll", EntryPoint = "CreateTimerQueueTimer")]
    //    private static extern bool CreateTimerQueueTimer(ref IntPtr handle, IntPtr queue, TimerDelegate callback, IntPtr state, uint dueTime, uint period, uint flags);

    //    [DllImport("kernel32.dll", EntryPoint = "DeleteTimerQueueTimer")]
    //    private static extern bool DeleteTimerQueueTimer(IntPtr queue, IntPtr handle, IntPtr callback);

    //    public delegate void TimerDelegate(IntPtr r1, bool r2);

    //    public void Create(uint dueTime, uint period, TimerDelegate callback)
    //    {
    //        if (_Enabled)
    //            return;

    //        TimerCallback = callback;
    //        bool Success = CreateTimerQueueTimer(ref Handle, IntPtr.Zero, TimerCallback, IntPtr.Zero, dueTime, period, 0);

    //        if (!Success)
    //            ThrowNewException("CreateTimerQueueTimer");
    //        _Enabled = Success;
    //    }

    //    public void Delete()
    //    {
    //        if (!_Enabled)
    //            return;
    //        bool Success = DeleteTimerQueueTimer(IntPtr.Zero, Handle, IntPtr.Zero);

    //        if (!Success && !(Marshal.GetLastWin32Error() == 997))
    //        {
    //            ThrowNewException("DeleteTimerQueueTimer");
    //        }

    //        _Enabled = !Success;
    //    }

    //    private void ThrowNewException(string name)
    //    {
    //        throw new Exception(string.Format("{0} failed. Win32Error: {1}", name, Marshal.GetLastWin32Error()));
    //    }

    //    public void Dispose()
    //    {
    //        Delete();
    //    }
    //}

}

```

`Unity3DObfuscator/obj/Debug/CoreCompileInputs.cache`:

```cache
4caec689fda36a48dc066fdc55407e37e3fb8494

```

`Unity3DObfuscator/obj/Debug/Unity3DObfuscator.csproj.FileListAbsolute.txt`:

```txt
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\bin\Debug\Unity3DObfuscator.exe.config
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\bin\Debug\Unity3DObfuscator.exe
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\bin\Debug\Unity3DObfuscator.pdb
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.csprojResolveAssemblyReference.cache
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.Properties.Resources.resources
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.csproj.GenerateResource.Cache
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.exe
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.pdb
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.MainForm.resources
c:\users\vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\bin\Debug\dnlib.dll
C:\Users\Vasilis\Documents\Visual Studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.ExcludeTypesForm.resources
C:\Users\Vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.ExcludeStringsForm.resources
C:\Users\Vasilis\documents\visual studio 2017\Projects\Unity3DObfuscator\Unity3DObfuscator\obj\Debug\Unity3DObfuscator.HelpForm.resources

```