Project Path: arc_gmh5225_fumo_loader_xwz8xmuj

Source Tree:

```txt
arc_gmh5225_fumo_loader_xwz8xmuj
├── CMakeLists.txt
├── CMakePresets.json
├── LICENSE
├── README.md
├── cmake
│   └── CPM.cmake
└── src
    ├── CMakeLists.txt
    ├── driver
    │   ├── CMakeLists.txt
    │   ├── driver.c
    │   ├── driver.h
    │   ├── imports.h
    │   ├── memory.c
    │   ├── memory.h
    │   ├── thread.c
    │   └── thread.h
    ├── driver_interface
    │   ├── CMakeLists.txt
    │   ├── driver_interface.cpp
    │   └── driver_interface.h
    ├── encoder
    │   ├── CMakeLists.txt
    │   └── fumo_encoder.cpp
    ├── fumo_generator
    │   ├── CMakeLists.txt
    │   └── fumo_generator.cpp
    ├── include
    │   ├── bootstrap.h
    │   ├── fomo_common.h
    │   └── util.h
    ├── initial_loader
    │   ├── CMakeLists.txt
    │   ├── extract_lib.bat
    │   └── initial_loader.cpp
    ├── rsource_generator
    │   ├── CMakeLists.txt
    │   └── rsource_generator.cpp
    ├── shellcode_extractor
    │   ├── CMakeLists.txt
    │   └── shellcode_extractor.cpp
    ├── stage1
    │   ├── CMakeLists.txt
    │   ├── fumo_preloader.cpp
    │   ├── fumo_preloader.h
    │   └── stage1.cpp
    └── stage2
        ├── CMakeLists.txt
        ├── fumo_loader.cpp
        ├── fumo_loader.h
        ├── stage2.cpp
        ├── stage2.h
        ├── tray_icon.cpp
        └── tray_icon.h

```

`CMakeLists.txt`:

```txt
cmake_minimum_required(VERSION 3.15 FATAL_ERROR)
project(fumo_loader)

set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)

# multi-processor compilation
if(MSVC)
    include(ProcessorCount)
    ProcessorCount(PROCESSOR_COUNT)
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP${PROCESSOR_COUNT}")
    set(CMAKE_VS_MSBUILD_COMMAND "${CMAKE_VS_MSBUILD_COMMAND} /p:CL_MPCount=${PROCESSOR_COUNT} /m")
endif()

set(CPM_SOURCE_CACHE "${CMAKE_SOURCE_DIR}/.cache/cpm")
include(cmake/CPM.cmake)

add_subdirectory(src)
```

`CMakePresets.json`:

```json
{
  "version": 6,
  "cmakeMinimumRequired": {
    "major": 3,
    "minor": 15,
    "patch": 0
  },
  "configurePresets": [
    {
      "name": "x64-windows",
      "binaryDir": "${sourceDir}/build",
      "generator": "Visual Studio 17 2022",
      "architecture": {
        "value": "x64",
        "strategy": "set"
      }
    }
  ],
  "buildPresets": [
    {
      "name": "Release",
      "configurePreset": "x64-windows",
      "configuration": "Release"
    }
  ]
}
```

`LICENSE`:

```
Copyright (c) 2023 nezu

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
```

`README.md`:

```md
# fumo loader

All-in-one kernel-based DLL injector

## Features

- Manual map a DLL into kernel memory and expose it to user mode via page table manipulation
- Re-generate a unique, encrypted executable each time it is run and delete the old one
- Store the target DLL in an encrypted form on disk (.fumo file)
- Tray icon and notifications that tell you about the status of the loader and allow you to abort the injection process
- Wait for certain modules to be loaded in the target process before injecting
- No running processes during injection (injects itself into a different process, explorer.exe by default)
- No open handles to the target process
- No new threads in the target process (injects using APCs from the kernel)
- Compatible with:
  - Windows 10 20H1 to Windows 11 22H2 (x64) (in theory, only tested on W11 22H2)
  - Secure boot
  - PatchGuard
  - Driver Signature Enforcement
  - Vulnerable driver blocklist

## Limitations

- **NOT** Compatible with:
  - 32-bit Windows and 32-bit processes
  - Hypervisor code integrity (HVCI)
  - KVA Shadowing (aka the Meltdown mitigation). Modern CPUs aren't affected, disable Meltdown protection on older ones.
  - Good anti-cheats (this is designed for defeating user-mode anti-cheats)
  - Probably a bunch of anti-virus software
  - Old versions of Windows (before 20H1)
- Target DLL **MUST NOT** have:
  - Thread-local storage (TLS)
  - Vectored exception handlers (VEH) (adding a global handler manually is fine though)

## Caveats

- (Currently) it does not clean any traces of the vulnerable driver
  - Reboot before loading any "decent" anti-cheat if you don't feel like being insta banned
- The target process needs to have a thread that we can schedule APCs on (this is usually not an issue outside of very simple hello world programs that only have one thread)
- You might get random DEP violations because memory above 0x7FFF'FFFFFFFF is technically not valid user-mode memory (at least as far as Windows APIs are concerned, your CPU doesn't care and will happily execute it, that's the whole idea behind this loader)
  - You will have to register an exception handler in your DLL that will catch the exception and return `EXCEPTION_CONTINUE_EXECUTION` whenever it encounters a DEP violation above 0x7FFF'FFFFFFFF

## Usage

### Prepare the .fumo file

1. Download the latest release or build it yourself
2. Drag and drop a DL onto `fumo_encoder.exe`
  1. Fill out the process name
  2. Fill out what DLL(s) to wait for before injecting

### Inject

1. Drag and drop the generated .fumo file onto `fumo.exe`
2. Wait for the success notification or error message box
3. Open the target process
4. Wait for the target DDL(s) to be loaded
5. ...
6. Profit

## Building

### Requirements

- Visual Studio 2022 build tools (lower might work, but not tested)
- Windows Driver Kit 10 (WDK)
- CMake

### Configure and build

```sh
# configure the x64-windows preset
cmake --preset=x64-windows
# build the project
cmake --build --preset=Release
```

Or use the CMake integration built into your IDE of choice

## TODO (feel free to contribute)

- [ ] Add support for TLS
- [ ] Add support for VEH
- [ ] Add support for KVA Shadowing
- [ ] Do some trace cleaning

## Credits

### Libraries and tools used

- [KDU](https://github.com/hfiref0x/KDU) - the driver vulnerable mapper
- [libKDU](https://github.com/dumbasPL/libKDU) - My wrapper around KDU that turns it into a static library
- [lazy_importer](https://github.com/JustasMasiulis/lazy_importer) - inlined import resolution (used for position-independent code)
- [xorstr](https://github.com/JustasMasiulis/xorstr) - inlined and encrypted strings (also used for position-independent code)
- [FindWDK](https://github.com/SergiusTheBest/FindWDK) - CMake module for building Windows drivers
- [CMake](https://cmake.org/) - amazing build system
- [@slnchyt](https://www.pixiv.net/en/artworks/35678304) - the tray icon

### Inspiration

- [ThePerfectInjector](https://github.com/can1357/ThePerfectInjector) - the original idea for this injection method
- [Blackbone](https://github.com/DarthTon/Blackbone) - well-written kernel code that I used as a reference (and stole some code from)

## License

[MIT](LICENSE)

```

`cmake/CPM.cmake`:

```cmake
set(CPM_DOWNLOAD_VERSION 0.38.2)

if(CPM_SOURCE_CACHE)
    set(CPM_DOWNLOAD_LOCATION "${CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
elseif(DEFINED ENV{CPM_SOURCE_CACHE})
    set(CPM_DOWNLOAD_LOCATION "$ENV{CPM_SOURCE_CACHE}/cpm/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
else()
    set(CPM_DOWNLOAD_LOCATION "${CMAKE_BINARY_DIR}/cmake/CPM_${CPM_DOWNLOAD_VERSION}.cmake")
endif()

# Expand relative path. This is important if the provided path contains a tilde (~)
get_filename_component(CPM_DOWNLOAD_LOCATION ${CPM_DOWNLOAD_LOCATION} ABSOLUTE)

function(download_cpm)
    message(STATUS "Downloading CPM.cmake to ${CPM_DOWNLOAD_LOCATION}")
    file(DOWNLOAD
        https://github.com/cpm-cmake/CPM.cmake/releases/download/v${CPM_DOWNLOAD_VERSION}/CPM.cmake
        ${CPM_DOWNLOAD_LOCATION}
    )
endfunction()

if(NOT (EXISTS ${CPM_DOWNLOAD_LOCATION}))
    download_cpm()
else()
    # resume download if it previously failed
    file(READ ${CPM_DOWNLOAD_LOCATION} check)
    if("${check}" STREQUAL "")
        download_cpm()
    endif()
    unset(check)
endif()

include(${CPM_DOWNLOAD_LOCATION})

```

`src/CMakeLists.txt`:

```txt
CPMAddPackage(
    NAME xorstr
    GITHUB_REPOSITORY JustasMasiulis/xorstr
    GIT_TAG master
    DOWNLOAD_ONLY True
)

if (xorstr_ADDED)
    add_library(xorstr INTERFACE)
    target_include_directories(xorstr INTERFACE ${xorstr_SOURCE_DIR}/include)
endif()

CPMAddPackage(
    NAME lazy_importer
    GITHUB_REPOSITORY JustasMasiulis/lazy_importer
    GIT_TAG master
    DOWNLOAD_ONLY True
)

if (lazy_importer_ADDED)
    add_library(lazy_importer INTERFACE)
    target_include_directories(lazy_importer INTERFACE ${lazy_importer_SOURCE_DIR}/include)
endif()

CPMAddPackage("gh:SergiusTheBest/FindWDK#master")
list(APPEND CMAKE_MODULE_PATH "${FindWDK_SOURCE_DIR}/cmake")
find_package(WDK REQUIRED)

CPMAddPackage("gh:dumbasPL/libKDU#main")

add_subdirectory(driver)
add_subdirectory(driver_interface)
add_subdirectory(rsource_generator)
add_subdirectory(stage1)
add_subdirectory(stage2)
add_subdirectory(initial_loader)
add_subdirectory(shellcode_extractor)
add_subdirectory(fumo_generator)
add_subdirectory(encoder)

add_custom_command(
    COMMENT "building final executable"
    DEPENDS fumo_generator initial_loader stage1
        $<TARGET_PROPERTY:initial_loader,RUNTIME_OUTPUT_DIRECTORY>/initial_loader.bin
        $<TARGET_FILE:stage1>
    COMMAND fumo_generator ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
        $<TARGET_PROPERTY:initial_loader,RUNTIME_OUTPUT_DIRECTORY>/initial_loader.bin
        $<TARGET_FILE:stage1>
    OUTPUT ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
)

add_custom_target(
    fumo ALL
    DEPENDS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/fumo.exe
)
```

`src/driver/CMakeLists.txt`:

```txt
wdk_add_driver(fumo_drv WINVER 0x4A61 driver.c memory.c thread.c)
target_include_directories(fumo_drv PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
set_target_properties(fumo_drv PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

# FIXME: add a cmake option to enable debug mode
target_compile_definitions(fumo_drv PRIVATE -DNO_FUMO_DRIVER_DEBUG)
```

`src/driver/driver.c`:

```c
#include "driver.h"
#include "memory.h"
#include "thread.h"
#include <fomo_common.h>

PVOID gOriginalDispatchFunctionArray[IRP_MJ_MAXIMUM_FUNCTION];

NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath) {
    UNREFERENCED_PARAMETER(RegistryPath);
    UNREFERENCED_PARAMETER(DriverObject);

    RTL_OSVERSIONINFOW version = { 0 };
    RtlGetVersion(&version);
    if (version.dwMajorVersion < MIN_OS_MAJOR_VERSION || version.dwBuildNumber < MIN_OS_BUILD_NUMBER) {
        Log("Unsupported OS version: %d.%d.%d", version.dwMajorVersion, version.dwMinorVersion, version.dwBuildNumber);
        return STATUS_NOT_SUPPORTED;
    }

    SetHook(TRUE);

    Log("loaded version %d running on %d.%d %d", FUMO_DRIVER_VERSION, version.dwMajorVersion, version.dwMinorVersion, version.dwBuildNumber);
    return STATUS_SUCCESS;
}

NTSTATUS SetHook(BOOL setHook) {
    UNICODE_STRING driverName;
    RtlInitUnicodeString(&driverName, FUMO_HOOKED_DRIVER_NAME);

    PDRIVER_OBJECT DriverObject = NULL;
    NTSTATUS status = ObReferenceObjectByName(&driverName, OBJ_CASE_INSENSITIVE, NULL, 0,
        *IoDriverObjectType, KernelMode, NULL, (PVOID*)&DriverObject);

    if (!NT_SUCCESS(status)) {
        Log("Failed to obtain DriverObject (0x%08X)", status);
        return status;
    }

    if (setHook) {
        Log("Hooking %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
        RtlCopyMemory(gOriginalDispatchFunctionArray, DriverObject->MajorFunction, sizeof(gOriginalDispatchFunctionArray));
        DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = Hk_DeviceControl;
        Log("Hooked %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
    } else {
        Log("Unhooking %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
        RtlCopyMemory(DriverObject->MajorFunction, gOriginalDispatchFunctionArray, sizeof(gOriginalDispatchFunctionArray));
        Log("Unhooked %ws major funcs", FUMO_HOOKED_DRIVER_NAME);
    }

    ObDereferenceObject(DriverObject);
    return STATUS_SUCCESS;
}

NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp) {
    PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status = STATUS_SUCCESS;
    ULONG bytes = 0;

    switch (stack->Parameters.DeviceIoControl.IoControlCode)
    {
    case IO_VERSION_REQUEST: {
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_VERSION_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_VERSION_RESPONSE_DATA output = (PIO_VERSION_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_VERSION_REQUEST received");

        output->Version = FUMO_DRIVER_VERSION;
        bytes = sizeof(IO_VERSION_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_UNLOAD_REQUEST: {
        Log("IO_UNLOAD_REQUEST received");
        SetHook(FALSE);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_ALLOC_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_ALLOC_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_ALLOC_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_ALLOC_REQUEST_DATA input = (PIO_ALLOC_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;
        PIO_ALLOC_RESPONSE_DATA output = (PIO_ALLOC_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_ALLOC_REQUEST received with size %d", input->Size);

        PVOID address = ExAllocatePool2(POOL_FLAG_NON_PAGED_EXECUTE, input->Size, POOL_TAG);
        if (address == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        Log("Allocated %d bytes at 0x%p", input->Size, address);

        if (!ExposeKernelMemoryToProcess(PsGetCurrentProcess(), address, input->Size)) {
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        output->Address = address;
        bytes = sizeof(IO_ALLOC_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    case IO_MAP_MEMORY_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_MAP_MEMORY_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_MAP_MEMORY_REQUEST_DATA input = (PIO_MAP_MEMORY_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_MAP_MEMORY_REQUEST received with pid %d, address 0x%p, size %d", input->Pid, input->Address, input->Size);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        if (!ExposeKernelMemoryToProcess(pProcess, input->Address, input->Size)) {
            Log("Failed to expose kernel memory to process");
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pProcess);
            status = STATUS_UNSUCCESSFUL;
            break;
        }

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pProcess);

        bytes = 0;
        status = STATUS_SUCCESS;
        break;
    }
    case IO_EXECUTE_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_EXECUTE_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_EXECUTE_REQUEST_DATA input = (PIO_EXECUTE_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_EXECUTE_REQUEST received with pid %d, address 0x%p, Argument 0x%p", input->Pid, input->Address, input->Argument);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        PETHREAD pThread = NULL;
        status = FindProcessThread(pProcess, &pThread);
        if (!NT_SUCCESS(status)) {
            Log("Failed to find process thread (0x%08X)", status);
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pProcess);
            break;
        }

        status = QueueUserApc(pThread, input->Address, input->Argument);
        if (!NT_SUCCESS(status)) {
            Log("Failed to queue user apc (0x%08X)", status);
            KeUnstackDetachProcess(&apcState);
            ObDereferenceObject(pThread);
            ObDereferenceObject(pProcess);
            break;
        }

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pThread);
        ObDereferenceObject(pProcess);

        bytes = 0;
        status = STATUS_SUCCESS;
        break;
    }
    case IO_FIND_MODULE_REQUEST: {
        if (stack->Parameters.DeviceIoControl.InputBufferLength != sizeof(IO_FIND_MODULE_REQUEST_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        if (stack->Parameters.DeviceIoControl.OutputBufferLength != sizeof(IO_FIND_MODULE_RESPONSE_DATA)) {
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        PIO_FIND_MODULE_REQUEST_DATA input = (PIO_FIND_MODULE_REQUEST_DATA)Irp->AssociatedIrp.SystemBuffer;
        PIO_FIND_MODULE_RESPONSE_DATA output = (PIO_FIND_MODULE_RESPONSE_DATA)Irp->AssociatedIrp.SystemBuffer;

        Log("IO_FIND_MODULE_REQUEST received with pid %d, module name %ws", input->Pid, input->ModuleName);

        PEPROCESS pProcess = NULL;
        status = PsLookupProcessByProcessId((HANDLE)input->Pid, &pProcess);
        if (!NT_SUCCESS(status)) {
            Log("Failed to lookup process by pid (0x%08X)", status);
            break;
        }

        KAPC_STATE apcState;
        KeStackAttachProcess(pProcess, &apcState);

        UNICODE_STRING moduleName;
        RtlInitUnicodeString(&moduleName, input->ModuleName);

        output->Address = FindModule(pProcess, &moduleName);

        KeUnstackDetachProcess(&apcState);
        ObDereferenceObject(pProcess);

        bytes = sizeof(IO_FIND_MODULE_RESPONSE_DATA);
        status = STATUS_SUCCESS;
        break;
    }
    default:
        Log("Unknown IOCTL received: 0x%08X", stack->Parameters.DeviceIoControl.IoControlCode);
        return ((DevCtrlPtr)(gOriginalDispatchFunctionArray[IRP_MJ_DEVICE_CONTROL]))(DeviceObject, Irp);
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = bytes;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


```

`src/driver/driver.h`:

```h
#pragma once
#include "imports.h"

#ifndef NO_FUMO_DRIVER_DEBUG
#define FUMO_DRIVER_DEBUG
#endif

#ifdef FUMO_DRIVER_DEBUG

// FUMO
#define POOL_TAG 'OMUF'
#define Log(format, ...) DbgPrint("[FUMO] " format "\n", ##__VA_ARGS__)

#else

// None
#define POOL_TAG 'enoN'
#define Log(format, ...) 

#endif

DRIVER_INITIALIZE DriverEntry;
NTSTATUS SetHook(BOOL setHook);
NTSTATUS Hk_DeviceControl(PDEVICE_OBJECT DeviceObject, PIRP Irp);
```

`src/driver/imports.h`:

```h
#pragma once
#include <ntifs.h>
#include <windef.h>
#include <wdm.h>

typedef struct _PEB_LDR_DATA {
    ULONG Length;
    UCHAR Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    ULONG Flags;
    USHORT LoadCount;
    USHORT TlsIndex;
    LIST_ENTRY HashLinks;
    ULONG TimeDateStamp;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB {
    UCHAR InheritedAddressSpace;
    UCHAR ReadImageFileExecOptions;
    UCHAR BeingDebugged;
    UCHAR BitField;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PPEB_LDR_DATA Ldr;
    PVOID ProcessParameters;
    PVOID SubSystemData;
    PVOID ProcessHeap;
    PVOID FastPebLock;
    PVOID AtlThunkSListPtr;
    PVOID IFEOKey;
    PVOID CrossProcessFlags;
    PVOID KernelCallbackTable;
    ULONG SystemReserved;
    ULONG AtlThunkSListPtr32;
    PVOID ApiSetMap;
} PEB, *PPEB;

typedef enum _KTHREAD_STATE {
    Initialized,
    Ready,
    Running,
    Standby,
    Terminated,
    Waiting,
    Transition,
    DeferredReady,
    GateWaitObsolete,
    WaitingForProcessInSwap,
    MaximumThreadState
} KTHREAD_STATE, *PKTHREAD_STATE;

typedef struct _SYSTEM_THREAD_INFORMATION {
    LARGE_INTEGER KernelTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER CreateTime;
    ULONG WaitTime;
    PVOID StartAddress;
    CLIENT_ID ClientId;
    KPRIORITY Priority;
    KPRIORITY BasePriority;
    ULONG ContextSwitches;
    KTHREAD_STATE ThreadState;
    KWAIT_REASON WaitReason;
} SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _TEB *PTEB;

// private
typedef struct _SYSTEM_EXTENDED_THREAD_INFORMATION {
    SYSTEM_THREAD_INFORMATION ThreadInfo;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID Win32StartAddress;
    PTEB TebBase; // since VISTA
    ULONG_PTR Reserved2;
    ULONG_PTR Reserved3;
    ULONG_PTR Reserved4;
} SYSTEM_EXTENDED_THREAD_INFORMATION, *PSYSTEM_EXTENDED_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFORMATION {
    ULONG NextEntryOffset;
    ULONG NumberOfThreads;
    LARGE_INTEGER WorkingSetPrivateSize; // since VISTA
    ULONG HardFaultCount; // since WIN7
    ULONG NumberOfThreadsHighWatermark; // since WIN7
    ULONGLONG CycleTime; // since WIN7
    LARGE_INTEGER CreateTime;
    LARGE_INTEGER UserTime;
    LARGE_INTEGER KernelTime;
    UNICODE_STRING ImageName;
    KPRIORITY BasePriority;
    HANDLE UniqueProcessId;
    HANDLE InheritedFromUniqueProcessId;
    ULONG HandleCount;
    ULONG SessionId;
    ULONG_PTR UniqueProcessKey; // since VISTA (requires SystemExtendedProcessInformation)
    SIZE_T PeakVirtualSize;
    SIZE_T VirtualSize;
    ULONG PageFaultCount;
    SIZE_T PeakWorkingSetSize;
    SIZE_T WorkingSetSize;
    SIZE_T QuotaPeakPagedPoolUsage;
    SIZE_T QuotaPagedPoolUsage;
    SIZE_T QuotaPeakNonPagedPoolUsage;
    SIZE_T QuotaNonPagedPoolUsage;
    SIZE_T PagefileUsage;
    SIZE_T PeakPagefileUsage;
    SIZE_T PrivatePageCount;
    LARGE_INTEGER ReadOperationCount;
    LARGE_INTEGER WriteOperationCount;
    LARGE_INTEGER OtherOperationCount;
    LARGE_INTEGER ReadTransferCount;
    LARGE_INTEGER WriteTransferCount;
    LARGE_INTEGER OtherTransferCount;
    SYSTEM_THREAD_INFORMATION Threads[1]; // SystemProcessInformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION Threads[1]; // SystemExtendedProcessinformation
    // SYSTEM_EXTENDED_THREAD_INFORMATION + SYSTEM_PROCESS_INFORMATION_EXTENSION // SystemFullProcessInformation
} SYSTEM_PROCESS_INFORMATION, *PSYSTEM_PROCESS_INFORMATION;

typedef enum _SYSTEM_INFORMATION_CLASS {
    SystemBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemPerformanceInformation, // q: SYSTEM_PERFORMANCE_INFORMATION
    SystemTimeOfDayInformation, // q: SYSTEM_TIMEOFDAY_INFORMATION
    SystemPathInformation, // not implemented
    SystemProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemCallCountInformation, // q: SYSTEM_CALL_COUNT_INFORMATION
    SystemDeviceInformation, // q: SYSTEM_DEVICE_INFORMATION
    SystemProcessorPerformanceInformation, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemFlagsInformation, // q: SYSTEM_FLAGS_INFORMATION
    SystemCallTimeInformation, // not implemented // SYSTEM_CALL_TIME_INFORMATION // 10
    SystemModuleInformation, // q: RTL_PROCESS_MODULES
    SystemLocksInformation, // q: RTL_PROCESS_LOCKS
    SystemStackTraceInformation, // q: RTL_PROCESS_BACKTRACES
    SystemPagedPoolInformation, // not implemented
    SystemNonPagedPoolInformation, // not implemented
    SystemHandleInformation, // q: SYSTEM_HANDLE_INFORMATION
    SystemObjectInformation, // q: SYSTEM_OBJECTTYPE_INFORMATION mixed with SYSTEM_OBJECT_INFORMATION
    SystemPageFileInformation, // q: SYSTEM_PAGEFILE_INFORMATION
    SystemVdmInstemulInformation, // q: SYSTEM_VDM_INSTEMUL_INFO
    SystemVdmBopInformation, // not implemented // 20
    SystemFileCacheInformation, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemCache)
    SystemPoolTagInformation, // q: SYSTEM_POOLTAG_INFORMATION
    SystemInterruptInformation, // q: SYSTEM_INTERRUPT_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemDpcBehaviorInformation, // q: SYSTEM_DPC_BEHAVIOR_INFORMATION; s: SYSTEM_DPC_BEHAVIOR_INFORMATION (requires SeLoadDriverPrivilege)
    SystemFullMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemLoadGdiDriverInformation, // s (kernel-mode only)
    SystemUnloadGdiDriverInformation, // s (kernel-mode only)
    SystemTimeAdjustmentInformation, // q: SYSTEM_QUERY_TIME_ADJUST_INFORMATION; s: SYSTEM_SET_TIME_ADJUST_INFORMATION (requires SeSystemtimePrivilege)
    SystemSummaryMemoryInformation, // not implemented // SYSTEM_MEMORY_USAGE_INFORMATION
    SystemMirrorMemoryInformation, // s (requires license value "Kernel-MemoryMirroringSupported") (requires SeShutdownPrivilege) // 30
    SystemPerformanceTraceInformation, // q; s: (type depends on EVENT_TRACE_INFORMATION_CLASS)
    SystemObsolete0, // not implemented
    SystemExceptionInformation, // q: SYSTEM_EXCEPTION_INFORMATION
    SystemCrashDumpStateInformation, // s: SYSTEM_CRASH_DUMP_STATE_INFORMATION (requires SeDebugPrivilege)
    SystemKernelDebuggerInformation, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION
    SystemContextSwitchInformation, // q: SYSTEM_CONTEXT_SWITCH_INFORMATION
    SystemRegistryQuotaInformation, // q: SYSTEM_REGISTRY_QUOTA_INFORMATION; s (requires SeIncreaseQuotaPrivilege)
    SystemExtendServiceTableInformation, // s (requires SeLoadDriverPrivilege) // loads win32k only
    SystemPrioritySeperation, // s (requires SeTcbPrivilege)
    SystemVerifierAddDriverInformation, // s (requires SeDebugPrivilege) // 40
    SystemVerifierRemoveDriverInformation, // s (requires SeDebugPrivilege)
    SystemProcessorIdleInformation, // q: SYSTEM_PROCESSOR_IDLE_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemLegacyDriverInformation, // q: SYSTEM_LEGACY_DRIVER_INFORMATION
    SystemCurrentTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION
    SystemLookasideInformation, // q: SYSTEM_LOOKASIDE_INFORMATION
    SystemTimeSlipNotification, // s: HANDLE (NtCreateEvent) (requires SeSystemtimePrivilege)
    SystemSessionCreate, // not implemented
    SystemSessionDetach, // not implemented
    SystemSessionInformation, // not implemented (SYSTEM_SESSION_INFORMATION)
    SystemRangeStartInformation, // q: SYSTEM_RANGE_START_INFORMATION // 50
    SystemVerifierInformation, // q: SYSTEM_VERIFIER_INFORMATION; s (requires SeDebugPrivilege)
    SystemVerifierThunkExtend, // s (kernel-mode only)
    SystemSessionProcessInformation, // q: SYSTEM_SESSION_PROCESS_INFORMATION
    SystemLoadGdiDriverInSystemSpace, // s: SYSTEM_GDI_DRIVER_INFORMATION (kernel-mode only) (same as SystemLoadGdiDriverInformation)
    SystemNumaProcessorMap, // q: SYSTEM_NUMA_INFORMATION
    SystemPrefetcherInformation, // q; s: PREFETCHER_INFORMATION // PfSnQueryPrefetcherInformation
    SystemExtendedProcessInformation, // q: SYSTEM_PROCESS_INFORMATION
    SystemRecommendedSharedDataAlignment, // q: ULONG // KeGetRecommendedSharedDataAlignment
    SystemComPlusPackage, // q; s: ULONG
    SystemNumaAvailableMemory, // q: SYSTEM_NUMA_INFORMATION // 60
    SystemProcessorPowerInformation, // q: SYSTEM_PROCESSOR_POWER_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemEmulationBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemEmulationProcessorInformation, // q: SYSTEM_PROCESSOR_INFORMATION
    SystemExtendedHandleInformation, // q: SYSTEM_HANDLE_INFORMATION_EX
    SystemLostDelayedWriteInformation, // q: ULONG
    SystemBigPoolInformation, // q: SYSTEM_BIGPOOL_INFORMATION
    SystemSessionPoolTagInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION
    SystemSessionMappedViewInformation, // q: SYSTEM_SESSION_MAPPED_VIEW_INFORMATION
    SystemHotpatchInformation, // q; s: SYSTEM_HOTPATCH_CODE_INFORMATION
    SystemObjectSecurityMode, // q: ULONG // 70
    SystemWatchdogTimerHandler, // s: SYSTEM_WATCHDOG_HANDLER_INFORMATION // (kernel-mode only)
    SystemWatchdogTimerInformation, // q: SYSTEM_WATCHDOG_TIMER_INFORMATION // (kernel-mode only)
    SystemLogicalProcessorInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION (EX in: USHORT ProcessorGroup)
    SystemWow64SharedInformationObsolete, // not implemented
    SystemRegisterFirmwareTableInformationHandler, // s: SYSTEM_FIRMWARE_TABLE_HANDLER // (kernel-mode only)
    SystemFirmwareTableInformation, // SYSTEM_FIRMWARE_TABLE_INFORMATION
    SystemModuleInformationEx, // q: RTL_PROCESS_MODULE_INFORMATION_EX
    SystemVerifierTriageInformation, // not implemented
    SystemSuperfetchInformation, // q; s: SUPERFETCH_INFORMATION // PfQuerySuperfetchInformation
    SystemMemoryListInformation, // q: SYSTEM_MEMORY_LIST_INFORMATION; s: SYSTEM_MEMORY_LIST_COMMAND (requires SeProfileSingleProcessPrivilege) // 80
    SystemFileCacheInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (same as SystemFileCacheInformation)
    SystemThreadPriorityClientIdInformation, // s: SYSTEM_THREAD_CID_PRIORITY_INFORMATION (requires SeIncreaseBasePriorityPrivilege)
    SystemProcessorIdleCycleTimeInformation, // q: SYSTEM_PROCESSOR_IDLE_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemVerifierCancellationInformation, // SYSTEM_VERIFIER_CANCELLATION_INFORMATION // name:wow64:whNT32QuerySystemVerifierCancellationInformation
    SystemProcessorPowerInformationEx, // not implemented
    SystemRefTraceInformation, // q; s: SYSTEM_REF_TRACE_INFORMATION // ObQueryRefTraceInformation
    SystemSpecialPoolInformation, // q; s: SYSTEM_SPECIAL_POOL_INFORMATION (requires SeDebugPrivilege) // MmSpecialPoolTag, then MmSpecialPoolCatchOverruns != 0
    SystemProcessIdInformation, // q: SYSTEM_PROCESS_ID_INFORMATION
    SystemErrorPortInformation, // s (requires SeTcbPrivilege)
    SystemBootEnvironmentInformation, // q: SYSTEM_BOOT_ENVIRONMENT_INFORMATION // 90
    SystemHypervisorInformation, // q: SYSTEM_HYPERVISOR_QUERY_INFORMATION
    SystemVerifierInformationEx, // q; s: SYSTEM_VERIFIER_INFORMATION_EX
    SystemTimeZoneInformation, // q; s: RTL_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemImageFileExecutionOptionsInformation, // s: SYSTEM_IMAGE_FILE_EXECUTION_OPTIONS_INFORMATION (requires SeTcbPrivilege)
    SystemCoverageInformation, // q: COVERAGE_MODULES s: COVERAGE_MODULE_REQUEST // ExpCovQueryInformation (requires SeDebugPrivilege)
    SystemPrefetchPatchInformation, // SYSTEM_PREFETCH_PATCH_INFORMATION
    SystemVerifierFaultsInformation, // s: SYSTEM_VERIFIER_FAULTS_INFORMATION (requires SeDebugPrivilege)
    SystemSystemPartitionInformation, // q: SYSTEM_SYSTEM_PARTITION_INFORMATION
    SystemSystemDiskInformation, // q: SYSTEM_SYSTEM_DISK_INFORMATION
    SystemProcessorPerformanceDistribution, // q: SYSTEM_PROCESSOR_PERFORMANCE_DISTRIBUTION (EX in: USHORT ProcessorGroup) // 100
    SystemNumaProximityNodeInformation, // q; s: SYSTEM_NUMA_PROXIMITY_MAP
    SystemDynamicTimeZoneInformation, // q; s: RTL_DYNAMIC_TIME_ZONE_INFORMATION (requires SeTimeZonePrivilege)
    SystemCodeIntegrityInformation, // q: SYSTEM_CODEINTEGRITY_INFORMATION // SeCodeIntegrityQueryInformation
    SystemProcessorMicrocodeUpdateInformation, // s: SYSTEM_PROCESSOR_MICROCODE_UPDATE_INFORMATION
    SystemProcessorBrandString, // q: CHAR[] // HaliQuerySystemInformation -> HalpGetProcessorBrandString, info class 23
    SystemVirtualAddressInformation, // q: SYSTEM_VA_LIST_INFORMATION[]; s: SYSTEM_VA_LIST_INFORMATION[] (requires SeIncreaseQuotaPrivilege) // MmQuerySystemVaInformation
    SystemLogicalProcessorAndGroupInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX (EX in: LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType) // since WIN7 // KeQueryLogicalProcessorRelationship
    SystemProcessorCycleTimeInformation, // q: SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION[] (EX in: USHORT ProcessorGroup)
    SystemStoreInformation, // q; s: SYSTEM_STORE_INFORMATION (requires SeProfileSingleProcessPrivilege) // SmQueryStoreInformation
    SystemRegistryAppendString, // s: SYSTEM_REGISTRY_APPEND_STRING_PARAMETERS // 110
    SystemAitSamplingValue, // s: ULONG (requires SeProfileSingleProcessPrivilege)
    SystemVhdBootInformation, // q: SYSTEM_VHD_BOOT_INFORMATION
    SystemCpuQuotaInformation, // q; s: PS_CPU_QUOTA_QUERY_INFORMATION
    SystemNativeBasicInformation, // q: SYSTEM_BASIC_INFORMATION
    SystemErrorPortTimeouts, // SYSTEM_ERROR_PORT_TIMEOUTS
    SystemLowPriorityIoInformation, // q: SYSTEM_LOW_PRIORITY_IO_INFORMATION
    SystemTpmBootEntropyInformation, // q: TPM_BOOT_ENTROPY_NT_RESULT // ExQueryTpmBootEntropyInformation
    SystemVerifierCountersInformation, // q: SYSTEM_VERIFIER_COUNTERS_INFORMATION
    SystemPagedPoolInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypePagedPool)
    SystemSystemPtesInformationEx, // q: SYSTEM_FILECACHE_INFORMATION; s (requires SeIncreaseQuotaPrivilege) (info for WorkingSetTypeSystemPtes) // 120
    SystemNodeDistanceInformation, // q: USHORT[4*NumaNodes] // (EX in: USHORT NodeNumber)
    SystemAcpiAuditInformation, // q: SYSTEM_ACPI_AUDIT_INFORMATION // HaliQuerySystemInformation -> HalpAuditQueryResults, info class 26
    SystemBasicPerformanceInformation, // q: SYSTEM_BASIC_PERFORMANCE_INFORMATION // name:wow64:whNtQuerySystemInformation_SystemBasicPerformanceInformation
    SystemQueryPerformanceCounterInformation, // q: SYSTEM_QUERY_PERFORMANCE_COUNTER_INFORMATION // since WIN7 SP1
    SystemSessionBigPoolInformation, // q: SYSTEM_SESSION_POOLTAG_INFORMATION // since WIN8
    SystemBootGraphicsInformation, // q; s: SYSTEM_BOOT_GRAPHICS_INFORMATION (kernel-mode only)
    SystemScrubPhysicalMemoryInformation, // q; s: MEMORY_SCRUB_INFORMATION
    SystemBadPageInformation,
    SystemProcessorProfileControlArea, // q; s: SYSTEM_PROCESSOR_PROFILE_CONTROL_AREA
    SystemCombinePhysicalMemoryInformation, // s: MEMORY_COMBINE_INFORMATION, MEMORY_COMBINE_INFORMATION_EX, MEMORY_COMBINE_INFORMATION_EX2 // 130
    SystemEntropyInterruptTimingInformation, // q; s: SYSTEM_ENTROPY_TIMING_INFORMATION
    SystemConsoleInformation, // q; s: SYSTEM_CONSOLE_INFORMATION
    SystemPlatformBinaryInformation, // q: SYSTEM_PLATFORM_BINARY_INFORMATION (requires SeTcbPrivilege)
    SystemPolicyInformation, // q: SYSTEM_POLICY_INFORMATION (Warbird/Encrypt/Decrypt/Execute)
    SystemHypervisorProcessorCountInformation, // q: SYSTEM_HYPERVISOR_PROCESSOR_COUNT_INFORMATION
    SystemDeviceDataInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemDeviceDataEnumerationInformation, // q: SYSTEM_DEVICE_DATA_INFORMATION
    SystemMemoryTopologyInformation, // q: SYSTEM_MEMORY_TOPOLOGY_INFORMATION
    SystemMemoryChannelInformation, // q: SYSTEM_MEMORY_CHANNEL_INFORMATION
    SystemBootLogoInformation, // q: SYSTEM_BOOT_LOGO_INFORMATION // 140
    SystemProcessorPerformanceInformationEx, // q: SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION_EX // (EX in: USHORT ProcessorGroup) // since WINBLUE
    SystemCriticalProcessErrorLogInformation,
    SystemSecureBootPolicyInformation, // q: SYSTEM_SECUREBOOT_POLICY_INFORMATION
    SystemPageFileInformationEx, // q: SYSTEM_PAGEFILE_INFORMATION_EX
    SystemSecureBootInformation, // q: SYSTEM_SECUREBOOT_INFORMATION
    SystemEntropyInterruptTimingRawInformation,
    SystemPortableWorkspaceEfiLauncherInformation, // q: SYSTEM_PORTABLE_WORKSPACE_EFI_LAUNCHER_INFORMATION
    SystemFullProcessInformation, // q: SYSTEM_PROCESS_INFORMATION with SYSTEM_PROCESS_INFORMATION_EXTENSION (requires admin)
    SystemKernelDebuggerInformationEx, // q: SYSTEM_KERNEL_DEBUGGER_INFORMATION_EX
    SystemBootMetadataInformation, // 150
    SystemSoftRebootInformation, // q: ULONG
    SystemElamCertificateInformation, // s: SYSTEM_ELAM_CERTIFICATE_INFORMATION
    SystemOfflineDumpConfigInformation, // q: OFFLINE_CRASHDUMP_CONFIGURATION_TABLE_V2
    SystemProcessorFeaturesInformation, // q: SYSTEM_PROCESSOR_FEATURES_INFORMATION
    SystemRegistryReconciliationInformation, // s: NULL (requires admin) (flushes registry hives)
    SystemEdidInformation, // q: SYSTEM_EDID_INFORMATION
    SystemManufacturingInformation, // q: SYSTEM_MANUFACTURING_INFORMATION // since THRESHOLD
    SystemEnergyEstimationConfigInformation, // q: SYSTEM_ENERGY_ESTIMATION_CONFIG_INFORMATION
    SystemHypervisorDetailInformation, // q: SYSTEM_HYPERVISOR_DETAIL_INFORMATION
    SystemProcessorCycleStatsInformation, // q: SYSTEM_PROCESSOR_CYCLE_STATS_INFORMATION (EX in: USHORT ProcessorGroup) // 160
    SystemVmGenerationCountInformation,
    SystemTrustedPlatformModuleInformation, // q: SYSTEM_TPM_INFORMATION
    SystemKernelDebuggerFlags, // SYSTEM_KERNEL_DEBUGGER_FLAGS
    SystemCodeIntegrityPolicyInformation, // q; s: SYSTEM_CODEINTEGRITYPOLICY_INFORMATION
    SystemIsolatedUserModeInformation, // q: SYSTEM_ISOLATED_USER_MODE_INFORMATION
    SystemHardwareSecurityTestInterfaceResultsInformation,
    SystemSingleModuleInformation, // q: SYSTEM_SINGLE_MODULE_INFORMATION
    SystemAllowedCpuSetsInformation, // s: SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION
    SystemVsmProtectionInformation, // q: SYSTEM_VSM_PROTECTION_INFORMATION (previously SystemDmaProtectionInformation)
    SystemInterruptCpuSetsInformation, // q: SYSTEM_INTERRUPT_CPU_SET_INFORMATION // 170
    SystemSecureBootPolicyFullInformation, // q: SYSTEM_SECUREBOOT_POLICY_FULL_INFORMATION
    SystemCodeIntegrityPolicyFullInformation,
    SystemAffinitizedInterruptProcessorInformation, // (requires SeIncreaseBasePriorityPrivilege)
    SystemRootSiloInformation, // q: SYSTEM_ROOT_SILO_INFORMATION
    SystemCpuSetInformation, // q: SYSTEM_CPU_SET_INFORMATION // since THRESHOLD2
    SystemCpuSetTagInformation, // q: SYSTEM_CPU_SET_TAG_INFORMATION
    SystemWin32WerStartCallout,
    SystemSecureKernelProfileInformation, // q: SYSTEM_SECURE_KERNEL_HYPERGUARD_PROFILE_INFORMATION
    SystemCodeIntegrityPlatformManifestInformation, // q: SYSTEM_SECUREBOOT_PLATFORM_MANIFEST_INFORMATION // since REDSTONE
    SystemInterruptSteeringInformation, // q: in: SYSTEM_INTERRUPT_STEERING_INFORMATION_INPUT, out: SYSTEM_INTERRUPT_STEERING_INFORMATION_OUTPUT // NtQuerySystemInformationEx // 180
    SystemSupportedProcessorArchitectures, // p: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx
    SystemMemoryUsageInformation, // q: SYSTEM_MEMORY_USAGE_INFORMATION
    SystemCodeIntegrityCertificateInformation, // q: SYSTEM_CODEINTEGRITY_CERTIFICATE_INFORMATION
    SystemPhysicalMemoryInformation, // q: SYSTEM_PHYSICAL_MEMORY_INFORMATION // since REDSTONE2
    SystemControlFlowTransition, // (Warbird/Encrypt/Decrypt/Execute)
    SystemKernelDebuggingAllowed, // s: ULONG
    SystemActivityModerationExeState, // SYSTEM_ACTIVITY_MODERATION_EXE_STATE
    SystemActivityModerationUserSettings, // SYSTEM_ACTIVITY_MODERATION_USER_SETTINGS
    SystemCodeIntegrityPoliciesFullInformation,
    SystemCodeIntegrityUnlockInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION // 190
    SystemIntegrityQuotaInformation,
    SystemFlushInformation, // q: SYSTEM_FLUSH_INFORMATION
    SystemProcessorIdleMaskInformation, // q: ULONG_PTR[ActiveGroupCount] // since REDSTONE3
    SystemSecureDumpEncryptionInformation,
    SystemWriteConstraintInformation, // SYSTEM_WRITE_CONSTRAINT_INFORMATION
    SystemKernelVaShadowInformation, // SYSTEM_KERNEL_VA_SHADOW_INFORMATION
    SystemHypervisorSharedPageInformation, // SYSTEM_HYPERVISOR_SHARED_PAGE_INFORMATION // since REDSTONE4
    SystemFirmwareBootPerformanceInformation,
    SystemCodeIntegrityVerificationInformation, // SYSTEM_CODEINTEGRITYVERIFICATION_INFORMATION
    SystemFirmwarePartitionInformation, // SYSTEM_FIRMWARE_PARTITION_INFORMATION // 200
    SystemSpeculationControlInformation, // SYSTEM_SPECULATION_CONTROL_INFORMATION // (CVE-2017-5715) REDSTONE3 and above.
    SystemDmaGuardPolicyInformation, // SYSTEM_DMA_GUARD_POLICY_INFORMATION
    SystemEnclaveLaunchControlInformation, // SYSTEM_ENCLAVE_LAUNCH_CONTROL_INFORMATION
    SystemWorkloadAllowedCpuSetsInformation, // SYSTEM_WORKLOAD_ALLOWED_CPU_SET_INFORMATION // since REDSTONE5
    SystemCodeIntegrityUnlockModeInformation, // SYSTEM_CODEINTEGRITY_UNLOCK_INFORMATION
    SystemLeapSecondInformation, // SYSTEM_LEAP_SECOND_INFORMATION
    SystemFlags2Information, // q: SYSTEM_FLAGS_INFORMATION
    SystemSecurityModelInformation, // SYSTEM_SECURITY_MODEL_INFORMATION // since 19H1
    SystemCodeIntegritySyntheticCacheInformation,
    SystemFeatureConfigurationInformation, // SYSTEM_FEATURE_CONFIGURATION_INFORMATION // since 20H1 // 210
    SystemFeatureConfigurationSectionInformation, // SYSTEM_FEATURE_CONFIGURATION_SECTIONS_INFORMATION
    SystemFeatureUsageSubscriptionInformation, // SYSTEM_FEATURE_USAGE_SUBSCRIPTION_DETAILS
    SystemSecureSpeculationControlInformation, // SECURE_SPECULATION_CONTROL_INFORMATION
    SystemSpacesBootInformation, // since 20H2
    SystemFwRamdiskInformation, // SYSTEM_FIRMWARE_RAMDISK_INFORMATION
    SystemWheaIpmiHardwareInformation,
    SystemDifSetRuleClassInformation, // SYSTEM_DIF_VOLATILE_INFORMATION
    SystemDifClearRuleClassInformation,
    SystemDifApplyPluginVerificationOnDriver, // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION
    SystemDifRemovePluginVerificationOnDriver, // SYSTEM_DIF_PLUGIN_DRIVER_INFORMATION // 220
    SystemShadowStackInformation, // SYSTEM_SHADOW_STACK_INFORMATION
    SystemBuildVersionInformation, // q: in: ULONG (LayerNumber), out: SYSTEM_BUILD_VERSION_INFORMATION // NtQuerySystemInformationEx // 222
    SystemPoolLimitInformation, // SYSTEM_POOL_LIMIT_INFORMATION (requires SeIncreaseQuotaPrivilege)
    SystemCodeIntegrityAddDynamicStore,
    SystemCodeIntegrityClearDynamicStores,
    SystemDifPoolTrackingInformation,
    SystemPoolZeroingInformation, // q: SYSTEM_POOL_ZEROING_INFORMATION
    SystemDpcWatchdogInformation, // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION
    SystemDpcWatchdogInformation2, // q; s: SYSTEM_DPC_WATCHDOG_CONFIGURATION_INFORMATION_V2
    SystemSupportedProcessorArchitectures2, // q: in opt: HANDLE, out: SYSTEM_SUPPORTED_PROCESSOR_ARCHITECTURES_INFORMATION[] // NtQuerySystemInformationEx // 230
    SystemSingleProcessorRelationshipInformation, // q: SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX // (EX in: PROCESSOR_NUMBER Processor)
    SystemXfgCheckFailureInformation, // q: SYSTEM_XFG_FAILURE_INFORMATION
    SystemIommuStateInformation, // SYSTEM_IOMMU_STATE_INFORMATION // since 22H1
    SystemHypervisorMinrootInformation, // SYSTEM_HYPERVISOR_MINROOT_INFORMATION
    SystemHypervisorBootPagesInformation, // SYSTEM_HYPERVISOR_BOOT_PAGES_INFORMATION
    SystemPointerAuthInformation, // SYSTEM_POINTER_AUTH_INFORMATION
    SystemSecureKernelDebuggerInformation,
    SystemOriginalImageFeatureInformation, // q: in: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_INPUT, out: SYSTEM_ORIGINAL_IMAGE_FEATURE_INFORMATION_OUTPUT // NtQuerySystemInformationEx
    MaxSystemInfoClass
} SYSTEM_INFORMATION_CLASS;

typedef enum _KAPC_ENVIRONMENT {
    OriginalApcEnvironment,
    AttachedApcEnvironment,
    CurrentApcEnvironment,
    InsertApcEnvironment
} KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;

typedef VOID(NTAPI *PKNORMAL_ROUTINE)(
    PVOID NormalContext,
    PVOID SystemArgument1,
    PVOID SystemArgument2
);

typedef VOID(NTAPI* PKKERNEL_ROUTINE)(
    PRKAPC Apc,
    PKNORMAL_ROUTINE *NormalRoutine,
    PVOID *NormalContext,
    PVOID *SystemArgument1,
    PVOID *SystemArgument2
);

typedef VOID(NTAPI *PKRUNDOWN_ROUTINE)(PRKAPC Apc);

typedef NTSTATUS(*DevCtrlPtr)(PDEVICE_OBJECT, PIRP Irp);

NTSYSCALLAPI NTSTATUS NTAPI ZwQuerySystemInformation(
    _In_ SYSTEM_INFORMATION_CLASS SystemInformationClass,
    _Out_writes_bytes_opt_(SystemInformationLength) PVOID SystemInformation,
    _In_ ULONG SystemInformationLength,
    _Out_opt_ PULONG ReturnLength
);

NTKERNELAPI NTSTATUS ObReferenceObjectByName(
    __in PUNICODE_STRING ObjectName,
    __in ULONG Attributes,
    __in_opt PACCESS_STATE AccessState,
    __in_opt ACCESS_MASK DesiredAccess,
    __in POBJECT_TYPE ObjectType,
    __in KPROCESSOR_MODE AccessMode,
    __inout_opt PVOID ParseContext,
    __out PVOID* Object
);

NTKERNELAPI PUCHAR NTAPI PsGetProcessImageFileName(
    _In_ PEPROCESS Process
);

NTKERNELAPI PVOID MmGetVirtualForPhysical(
    __in PHYSICAL_ADDRESS PhysicalAddress
);

NTKERNELAPI PVOID NTAPI PsGetThreadTeb(
    IN PETHREAD Thread
);

NTKERNELAPI VOID NTAPI KeInitializeApc( 
    IN PKAPC Apc,
    IN PKTHREAD Thread,
    IN KAPC_ENVIRONMENT ApcStateIndex,
    IN PKKERNEL_ROUTINE KernelRoutine,
    IN PKRUNDOWN_ROUTINE RundownRoutine,
    IN PKNORMAL_ROUTINE NormalRoutine,
    IN KPROCESSOR_MODE ApcMode,
    IN PVOID NormalContext
);

NTKERNELAPI BOOLEAN NTAPI KeInsertQueueApc(
    PKAPC Apc,
    PVOID SystemArgument1,
    PVOID SystemArgument2,
    KPRIORITY Increment
);

NTKERNELAPI BOOLEAN NTAPI KeTestAlertThread(
    IN KPROCESSOR_MODE AlertMode
);

NTKERNELAPI VOID NTAPI KeFlushCurrentTbImmediately();

NTKERNELAPI VOID NTAPI KeFlushEntireTb();

NTKERNELAPI PPEB NTAPI PsGetProcessPeb(
    IN PEPROCESS Process
);

__declspec(dllimport) POBJECT_TYPE *IoDriverObjectType;
```

`src/driver/memory.c`:

```c
#include "memory.h"

uint64_t GetProcessDirectoryTableBase(PEPROCESS pProcess) {
	PUCHAR process = (PUCHAR)pProcess;
	uint64_t process_dirbase = *(uint64_t*)(process + 0x28); // DirectoryTableBase
	if (process_dirbase == 0)
		process_dirbase = *(uint64_t*)(process + 0x388); // UserDirectoryTableBase
	return process_dirbase;
}

PVOID GetVirtualForPhysical(uint64_t PhysicalAddress) {
    PHYSICAL_ADDRESS AddrToRead = {0};
    AddrToRead.QuadPart = PhysicalAddress;
    return MmGetVirtualForPhysical(AddrToRead);
}

BOOL ReadPhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size) {
    PVOID VirtualAddress = GetVirtualForPhysical(TargetAddress);
    if (!VirtualAddress)
        return FALSE;
    RtlCopyMemory(lpBuffer, VirtualAddress, Size);
    return TRUE;
}

BOOL WritePhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size) {
    PVOID VirtualAddress = GetVirtualForPhysical(TargetAddress);
    if (!VirtualAddress)
        return FALSE;
    RtlCopyMemory(VirtualAddress, lpBuffer, Size);
    return TRUE;
}

PAGE_TABLE_INFO QueryPageTableInfo(uint64_t DirectoryTableBase, PVOID Va) {
    PAGE_TABLE_INFO Pi = {0,0,0,0};

    VIRT_ADDR Addr = {(uint64_t)Va};
    PTE_CR3 Cr3 = {DirectoryTableBase};
    SIZE_T read_size = 0;

    {
        uint64_t Plm4eAddr = PFN_TO_PAGE(Cr3.pml4_p) + sizeof(PML4E) * Addr.pml4_index;
        PML4E* Plm4e = (PML4E*)GetVirtualForPhysical(Plm4eAddr);
        if (!Plm4e->present)
            return Pi;
        Pi.Pml4e = Plm4e;
    }

    {
        uint64_t PdpteAddr = PFN_TO_PAGE(Pi.Pml4e->pdpt_p) + sizeof(PDPTE) * Addr.pdpt_index;
        PDPTE* Pdpte = (PDPTE*)GetVirtualForPhysical(PdpteAddr);
        if (!Pdpte->present)
            return Pi;
        Pi.Pdpte = Pdpte;
    }

    {
        uint64_t PdeAddr = PFN_TO_PAGE(Pi.Pdpte->pd_p) + sizeof(PDE) * Addr.pd_index;
        PDE* Pde = (PDE*)GetVirtualForPhysical(PdeAddr);
        if (!Pde->present)
            return Pi;
        Pi.Pde = Pde;
        if (Pi.Pde->page_size)
            return Pi;
    }

    {
        uint64_t PteAddr = PFN_TO_PAGE(Pi.Pde->pt_p) + sizeof(PTE) * Addr.pt_index;
        PTE* Pte = (PTE*)GetVirtualForPhysical(PteAddr);
        if (!Pte->present)
            return Pi;
        Pi.Pte = Pte;
    }

    return Pi;
}

uint64_t VirtToPhys(uint64_t DirectoryTableBase, PVOID Va) {
    PAGE_TABLE_INFO Info = QueryPageTableInfo(DirectoryTableBase, Va);
    SIZE_T read_size = 0;
    uint64_t Pa = 0;

    if (!Info.Pde)
        return 0;

    if (Info.Pde->page_size) {
        Pa = PFN_TO_PAGE(Info.Pde->pt_p);
        Pa += (uint64_t)Va & (0x200000 - 1);
            return Pa;
    }

    if (!Info.Pte)
        return 0;

    Pa = PFN_TO_PAGE(Info.Pte->page_frame);
    Pa += (uint64_t)Va & (0x1000 - 1);
    
    return Pa;
}

BOOL ExposeKernelMemoryToProcess(PEPROCESS pProcess, PVOID Address, SIZE_T Size) {
    if (!pProcess || !Address || !Size)
        return FALSE;

    PUCHAR pProcessName = PsGetProcessImageFileName(pProcess);
    if (!pProcessName)
        return FALSE;
  
    Log("Exposing kernel memory to %s (%d) at 0x%p with size 0x%X", pProcessName, PsGetProcessId(pProcess), Address, Size);

    uint64_t DirectoryTableBase = GetProcessDirectoryTableBase(pProcess);

    PUCHAR It = (PUCHAR)Address;
    PUCHAR End = It + Size;
    BOOL success = TRUE;

    while (It < End) {
        SIZE_T Size = (PUCHAR)(((uint64_t)It + 0x1000) & (~0xFFF)) - It;

        if ((It + Size) > End)
            Size = End - It;

        PAGE_TABLE_INFO Pti = QueryPageTableInfo(DirectoryTableBase, It);
        It += Size;

        if (!Pti.Pde || (Pti.Pte && !Pti.Pte->present)) {
            success = FALSE;
            continue;
        }

        Pti.Pml4e->user = TRUE;
        Pti.Pdpte->user = TRUE;
        Pti.Pde->user = TRUE;
        if (Pti.Pte)
            Pti.Pte->user = TRUE;
    }

    KeFlushEntireTb();
    KeInvalidateAllCaches();

    return success;
}

PVOID FindModule(PEPROCESS pProcess, PUNICODE_STRING ModuleName) {
    if (!pProcess || !ModuleName)
        return NULL;
    
    PPEB pPeb = PsGetProcessPeb(pProcess);
    if (!pPeb)
        return NULL;
    
    PPEB_LDR_DATA pLdr = pPeb->Ldr;
    if (!pLdr)
        return NULL;
    
    for (PLIST_ENTRY pListEntry = pLdr->InLoadOrderModuleList.Flink; pListEntry != &pLdr->InLoadOrderModuleList; pListEntry = pListEntry->Flink) {
        PLDR_DATA_TABLE_ENTRY pEntry = CONTAINING_RECORD(pListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
        if (RtlCompareUnicodeString(&pEntry->BaseDllName, ModuleName, TRUE) == 0)
            return pEntry->DllBase;
    }

    return NULL;
}
```

`src/driver/memory.h`:

```h
#pragma once
#include "driver.h"

typedef unsigned long long uint64_t;

#define PFN_TO_PAGE(pfn) ( pfn << 12 )

#pragma pack(push, 1)
typedef union CR3_
{
	uint64_t value;
	struct
	{
		uint64_t ignored_1 : 3;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t ignored_2 : 7;
		uint64_t pml4_p : 40;
		uint64_t reserved : 12;
	};
} PTE_CR3;

typedef union VIRT_ADDR_
{
	uint64_t value;
	void *pointer;
	struct
	{
		uint64_t offset : 12;
		uint64_t pt_index : 9;
		uint64_t pd_index : 9;
		uint64_t pdpt_index : 9;
		uint64_t pml4_index : 9;
		uint64_t reserved : 16;
	};
} VIRT_ADDR;

typedef union PML4E_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t ignored_1 : 1;
		uint64_t reserved_1 : 1;
		uint64_t ignored_2 : 4;
		uint64_t pdpt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PML4E;

typedef union PDPTE_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pd_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDPTE;

typedef union PDE_
{
	uint64_t value;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t page_size : 1;
		uint64_t ignored_2 : 4;
		uint64_t pt_p : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PDE;

typedef union PTE_
{
	uint64_t value;
	VIRT_ADDR vaddr;
	struct
	{
		uint64_t present : 1;
		uint64_t rw : 1;
		uint64_t user : 1;
		uint64_t write_through : 1;
		uint64_t cache_disable : 1;
		uint64_t accessed : 1;
		uint64_t dirty : 1;
		uint64_t pat : 1;
		uint64_t global : 1;
		uint64_t ignored_1 : 3;
		uint64_t page_frame : 40;
		uint64_t ignored_3 : 11;
		uint64_t xd : 1;
	};
} PTE;
#pragma pack(pop)

typedef struct PAGE_TABLE_INFO_ {
    PML4E* Pml4e;
    PDPTE* Pdpte;
    PDE* Pde;
    PTE* Pte;
} PAGE_TABLE_INFO, *PPAGE_TABLE_INFO;

uint64_t GetProcessDirectoryTableBase(PEPROCESS pProcess);
PVOID GetVirtualForPhysical(uint64_t PhysicalAddress);
BOOL ReadPhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size);
BOOL WritePhysicalUnsafe(uint64_t TargetAddress, PVOID lpBuffer, SIZE_T Size);
PAGE_TABLE_INFO QueryPageTableInfo(uint64_t directoryTableBase, PVOID Va);
uint64_t VirtToPhys(uint64_t DirectoryTableBase, PVOID Va);
BOOL ExposeKernelMemoryToProcess(PEPROCESS pProcess, PVOID Address, SIZE_T Size);
PVOID FindModule(PEPROCESS pProcess, PUNICODE_STRING ModuleName);
```

`src/driver/thread.c`:

```c
#include "thread.h"

NTSTATUS EnumProcesses(PVOID *ppProcesses, SYSTEM_INFORMATION_CLASS SystemInformationClass) {
    ULONG bufferSize = 0x1000 * 0x1000;
    PVOID buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, POOL_TAG);
    if (!buffer)
        return STATUS_INSUFFICIENT_RESOURCES;

    NTSTATUS status;
    while (TRUE) {
        status = ZwQuerySystemInformation(SystemInformationClass, buffer, bufferSize, &bufferSize);
        if (status == STATUS_INFO_LENGTH_MISMATCH || status == STATUS_BUFFER_TOO_SMALL) {
            Log("Buffer too small, reallocating to 0x%X", bufferSize);
            ExFreePoolWithTag(buffer, POOL_TAG);
            buffer = ExAllocatePool2(POOL_FLAG_NON_PAGED, bufferSize, POOL_TAG);
            if (!buffer)
                return STATUS_INSUFFICIENT_RESOURCES;
        } else {
            break;
        }
    }

    if (!NT_SUCCESS(status)) {
        ExFreePoolWithTag(buffer, POOL_TAG);
        return status;
    }

    *ppProcesses = buffer;
    return STATUS_SUCCESS;
}

PSYSTEM_PROCESS_INFORMATION FindProcessInformation(PVOID Processes, HANDLE ProcessId) {
    PSYSTEM_PROCESS_INFORMATION process = (PSYSTEM_PROCESS_INFORMATION)Processes;
    for (;;) {
        if (process->UniqueProcessId == ProcessId) {
            return process;
        } else if (process->NextEntryOffset) {
            process = (PSYSTEM_PROCESS_INFORMATION)((PUCHAR)process + process->NextEntryOffset);
        } else {
            break;
        }
    }
    return NULL;
}

NTSTATUS FindProcessThread(PEPROCESS pProcess, PETHREAD* ppThread) {
    PVOID Processes = NULL;
    NTSTATUS status = EnumProcesses(&Processes, SystemProcessInformation);
    if (!NT_SUCCESS(status)) {
        Log("Failed to enumerate processes (0x%08X)", status);
        ExFreePoolWithTag(Processes, POOL_TAG);
        return status;
    }

    PSYSTEM_PROCESS_INFORMATION process = FindProcessInformation(Processes, PsGetProcessId(pProcess));
    if (!process) {
        Log("Failed to find process information");
        ExFreePoolWithTag(Processes, POOL_TAG);
        return STATUS_NOT_FOUND;
    }

    for (ULONG i = 0; i < process->NumberOfThreads; i++) {
        HANDLE threadId = process->Threads[i].ClientId.UniqueThread;

        // Skip current thread.
        if (threadId == PsGetCurrentThreadId()) {
            continue;
        }

        PETHREAD pThread = NULL;
        status = PsLookupThreadByThreadId(threadId, &pThread);
        if (!NT_SUCCESS(status) || !pThread) {
            Log("Failed to lookup thread by thread id (0x%08X)", status);
            ExFreePoolWithTag(Processes, POOL_TAG);
            return status;
        }

        if (!SkipThread(pThread)) {
            Log("Found thread 0x%p", pThread);
            *ppThread = pThread;
            ExFreePoolWithTag(Processes, POOL_TAG);
            return STATUS_SUCCESS;
        }

        ObDereferenceObject(pThread);
    }

    ExFreePoolWithTag(Processes, POOL_TAG);
    return STATUS_NOT_FOUND;
}

BOOL SkipThread(PETHREAD pThread) {
    PUCHAR pTeb64 = PsGetThreadTeb(pThread);

    // Skip GUI treads.
    if (*(PULONG64)(pTeb64 + 0x78) != 0) { // Win32ThreadInfo
        Log("Skipping GUI thread");
        return TRUE;
    }

    // Skip threads with no ActivationContext
    if (*(PULONG64)(pTeb64 + 0x2C8) == 0) { // ActivationContextStackPointer
        Log("Skipping thread with no ActivationContext");
        return TRUE;
    }

    // Skip threads with no TLS pointer
    if (*(PULONG64)(pTeb64 + 0x58) == 0) { // ThreadLocalStoragePointer
        Log("Skipping thread with no TLS pointer");
        return TRUE;
    }

    return FALSE;
}

VOID KernelApcCallback(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine, 
    PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2) {
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Log("KernelApcCallback called with NormalRoutine 0x%p", *NormalRoutine);

    // Skip execution
    if (PsIsThreadTerminating(PsGetCurrentThread()))
        *NormalRoutine = NULL;

    ExFreePoolWithTag(Apc, POOL_TAG);
}

VOID KernelApcPrepareCallback(PKAPC Apc, PKNORMAL_ROUTINE* NormalRoutine,
    PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2) {
    UNREFERENCED_PARAMETER(NormalRoutine);
    UNREFERENCED_PARAMETER(NormalContext);
    UNREFERENCED_PARAMETER(SystemArgument1);
    UNREFERENCED_PARAMETER(SystemArgument2);

    Log("KernelApcPrepareCallback called");

    // Alert current thread
    KeTestAlertThread(UserMode);

    ExFreePoolWithTag(Apc, POOL_TAG);
}

NTSTATUS QueueUserApc(PETHREAD pThread, PVOID pUserFunc, PVOID Argument) {
    PKAPC apc = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(KAPC), POOL_TAG);
    if (!apc)
        return STATUS_INSUFFICIENT_RESOURCES;
    
    KeInitializeApc(apc, pThread, OriginalApcEnvironment, &KernelApcCallback, 
        NULL, (PKNORMAL_ROUTINE)(ULONG_PTR)pUserFunc, UserMode, Argument);

    PKAPC apcPrepare = ExAllocatePool2(POOL_FLAG_NON_PAGED, sizeof(KAPC), POOL_TAG);
    if (!apcPrepare) {
        ExFreePoolWithTag(apc, POOL_TAG);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeInitializeApc(apcPrepare, pThread, OriginalApcEnvironment, 
        &KernelApcPrepareCallback, NULL, NULL, KernelMode, NULL);

    if (!KeInsertQueueApc(apc, NULL, NULL, 0)) {
        Log("Failed to insert APC");
        ExFreePoolWithTag(apc, POOL_TAG);
        ExFreePoolWithTag(apcPrepare, POOL_TAG);
        return STATUS_UNSUCCESSFUL;
    }

    if (!KeInsertQueueApc(apcPrepare, NULL, NULL, 0)) {
        Log("Failed to insert prepare APC");
        ExFreePoolWithTag(apc, POOL_TAG);
        ExFreePoolWithTag(apcPrepare, POOL_TAG);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}
```

`src/driver/thread.h`:

```h
#pragma once
#include "driver.h"

NTSTATUS EnumProcesses(PVOID *ppProcesses, SYSTEM_INFORMATION_CLASS SystemInformationClass);
PSYSTEM_PROCESS_INFORMATION FindProcessInformation(PVOID Processes, HANDLE ProcessId);
NTSTATUS FindProcessThread(PEPROCESS pProcess, PETHREAD* ppThread);
BOOL SkipThread(PETHREAD pThread);
NTSTATUS QueueUserApc(PETHREAD pThread, PVOID pUserFunc, PVOID Argument);
```

`src/driver_interface/CMakeLists.txt`:

```txt
add_library(driver_interface STATIC driver_interface.cpp)
target_include_directories(driver_interface PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_include_directories(driver_interface PUBLIC ${CMAKE_CURRENT_SOURCE_DIR})
target_compile_features(driver_interface PUBLIC c_std_17 cxx_std_20)
```

`src/driver_interface/driver_interface.cpp`:

```cpp
#include "driver_interface.h"

std::optional<std::reference_wrapper<fumo::DriverInterface>> fumo::DriverInterface::Open(LPCWSTR lpFileName) {
    HANDLE hDevice = CreateFileW(lpFileName, GENERIC_WRITE, FILE_SHARE_WRITE, nullptr, OPEN_EXISTING, 0, nullptr);
    if (hDevice == INVALID_HANDLE_VALUE) {
        return std::nullopt;
    }
    return std::optional<std::reference_wrapper<fumo::DriverInterface>>(*new DriverInterface(hDevice));
}

std::optional<ULONG> fumo::DriverInterface::GetVersion() {
    IO_VERSION_RESPONSE_DATA version_response = {0};
    if (!DeviceIoControl(hDevice, IO_VERSION_REQUEST, 
        nullptr, 0, 
        &version_response, sizeof(version_response), 
        nullptr, nullptr)) {
        return std::nullopt;
    }
    return version_response.Version;
}

VOID fumo::DriverInterface::Unload() {
    DeviceIoControl(hDevice, IO_UNLOAD_REQUEST, 
        nullptr, 0, 
        nullptr, 0, 
        nullptr, nullptr);
}

PVOID fumo::DriverInterface::AllocateKernelMemory(ULONG size) {
    IO_ALLOC_REQUEST_DATA alloc_request = {0};
    alloc_request.Size = size;

    IO_ALLOC_RESPONSE_DATA alloc_response = {0};
    if (!DeviceIoControl(hDevice, IO_ALLOC_REQUEST, 
        &alloc_request, sizeof(alloc_request), 
        &alloc_response, sizeof(alloc_response), 
        nullptr, nullptr)) {
        return nullptr;
    }

    return alloc_response.Address;
}

BOOL fumo::DriverInterface::ExposeKernelMemory(ULONG pid, PVOID address, ULONG size) {
    IO_MAP_MEMORY_REQUEST_DATA map_data = {0};
    map_data.Pid = pid;
    map_data.Address = address;
    map_data.Size = size;

    return DeviceIoControl(hDevice, IO_MAP_MEMORY_REQUEST, 
        &map_data, sizeof(map_data), 
        nullptr, 0, 
        nullptr, nullptr);
}

BOOL fumo::DriverInterface::ExecuteCode(ULONG pid, PVOID address, PVOID argument) {
    IO_EXECUTE_REQUEST_DATA execute_request = {0};
    execute_request.Pid = pid;
    execute_request.Address = address;
    execute_request.Argument = argument;

    return DeviceIoControl(hDevice, IO_EXECUTE_REQUEST, 
        &execute_request, sizeof(execute_request), 
        nullptr, 0, 
        nullptr, nullptr);
}

BOOL fumo::DriverInterface::FindModule(ULONG pid, LPCWSTR lpModuleName, PVOID* Address) {
    IO_FIND_MODULE_REQUEST_DATA find_module_request = {0};
    find_module_request.Pid = pid;
    wcscpy_s(find_module_request.ModuleName, lpModuleName);

    IO_FIND_MODULE_RESPONSE_DATA find_module_response = {0};
    if (!DeviceIoControl(hDevice, IO_FIND_MODULE_REQUEST, 
        &find_module_request, sizeof(find_module_request), 
        &find_module_response, sizeof(find_module_response), 
        nullptr, nullptr)) {
        return FALSE;
    }

    *Address = find_module_response.Address;
    return TRUE;
}

fumo::DriverInterface::~DriverInterface() {
    std::cout << "Closing handle" << std::endl;
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
    }
}
```

`src/driver_interface/driver_interface.h`:

```h
#pragma once
#include <Windows.h>
#include <optional>
#include <fomo_common.h>
#include <iostream>

namespace fumo {

class DriverInterface {
private:
    HANDLE hDevice = INVALID_HANDLE_VALUE;
    DriverInterface(HANDLE hDevice) : hDevice(hDevice) {}
    // delete copy constructor and assignment operator
    DriverInterface(const DriverInterface&) = delete;
    DriverInterface& operator=(const DriverInterface&) = delete;
public:
    static std::optional<std::reference_wrapper<DriverInterface>> Open(LPCWSTR lpFileName);
    std::optional<ULONG> GetVersion();
    VOID Unload();
    PVOID AllocateKernelMemory(ULONG size);
    BOOL ExposeKernelMemory(ULONG pid, PVOID address, ULONG size);
    BOOL ExecuteCode(ULONG pid, PVOID address, PVOID argument);
    BOOL FindModule(ULONG pid, LPCWSTR lpModuleName, PVOID* Address);
    ~DriverInterface();
};

} // namespace fumo
```

`src/encoder/CMakeLists.txt`:

```txt
add_executable(fumo_encoder fumo_encoder.cpp)
target_compile_features(fumo_encoder PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(fumo_encoder PRIVATE UNICODE _UNICODE)
target_include_directories(fumo_encoder PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)

```

`src/encoder/fumo_encoder.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>
#include <filesystem>
#include <stdint.h>
#include <ctime>
#include <fomo_common.h>
#include <util.h>

int main(int argc, char** argv) {
    // usage: [input_file] [process_name] [wait_for_module1,[wait_for_module2,...]] [output_file]

    std::string input_file_name = [argc, argv]() {
        if (argc > 1)
            return std::string(argv[1]);
        std::cout << "Input file (DLL): ";
        std::string input_file_name;
        std::getline(std::cin, input_file_name);
        return input_file_name;
    }();
    std::string process_name = [argc, argv]() {
        if (argc > 2)
            return std::string(argv[2]);
        std::cout << "Target process name: ";
        std::string process_name;
        std::getline(std::cin, process_name);
        return process_name;
    }();
    std::string wait_for_modules = [argc, argv]() {
        if (argc > 3)
            return std::string(argv[3]);
        std::cout << "Wait for modules (comma separated): ";
        std::string wait_for_modules;
        std::getline(std::cin, wait_for_modules);
        return wait_for_modules;
    }();
    std::string output_file_name = [argc, argv, input_file_name]() {
        if (argc > 4)
            return std::string(argv[4]);
        return std::filesystem::path(input_file_name).replace_extension(".fumo").string();
    }();

    if (process_name.length() == 0) {
        std::cerr << "No process name specified" << std::endl;
        return 1;
    }

    if (wait_for_modules.length() == 0) {
        std::cerr << "No wait modules specified, using default: kernel32.dll" << std::endl;
        wait_for_modules = "kernel32.dll";
    }
    
    // read input file
    std::ifstream input_file(input_file_name, std::ios::binary);
    if (!input_file.is_open()) {
        std::cerr << "Failed to open input file:" << input_file_name << std::endl;
        return 1;
    }
    std::vector<unsigned char> data;
    data.assign(std::istreambuf_iterator<char>(input_file), std::istreambuf_iterator<char>());

    // generate xor key
    std::srand(std::time(nullptr));
    uint64_t xor_key = 0;
    for (int i = 0; i < 8; i++)
        xor_key |= (std::rand() % 256) << (i * 8);

    // pad to 8 bytes
    int padding = 8 - (data.size() % 8);
    if (padding != 8)
        data.insert(data.end(), padding, 0);

    // encrypt data
    for (int i = 0; i < data.size(); i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&data[i];
        *ptr ^= xor_key;
    }

    // generate loader settings
    std::stringstream loader_settings;
    loader_settings << process_name << ';' << wait_for_modules;
    std::string loader_settings_str = loader_settings.str();
    std::vector<unsigned char> loader_settings_data;
    // write size
    uint32_t loader_settings_size = loader_settings.str().length();
    loader_settings_data.insert(loader_settings_data.end(), (unsigned char*)&loader_settings_size, (unsigned char*)&loader_settings_size + sizeof(loader_settings_size));
    // write data
    loader_settings_data.insert(loader_settings_data.end(), loader_settings_str.begin(), loader_settings_str.end());
    // pad to 8 bytes
    padding = 8 - (loader_settings_data.size() % 8);
    if (padding != 8)
        loader_settings_data.insert(loader_settings_data.end(), padding, 0);
    // encrypt loader settings
    for (int i = 0; i < loader_settings_data.size(); i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&loader_settings_data[i];
        *ptr ^= xor_key;
    }

    // write output file
    std::ofstream output_file(output_file_name, std::ios::binary);
    if (!output_file.is_open()) {
        std::cerr << "Failed to open output file:" << output_file_name << std::endl;
        return 1;
    }

    FUMO_DATA_HEADER header;
    header.Magic = FUMO_MAGIC;
    header.Version = FUMO_DATA_VERSION;
    header.XorKey = xor_key;
    header.SettingsSize = loader_settings_data.size();
    header.DataSize = data.size();
    output_file.write((char*)&header, sizeof(header));
    output_file.write((char*)loader_settings_data.data(), loader_settings_data.size());
    output_file.write((char*)data.data(), data.size());

    output_file.close();

    std::cerr << "Successfully encoded " << input_file_name << " to " << output_file_name << std::endl;
    return 0;
}

```

`src/fumo_generator/CMakeLists.txt`:

```txt
add_executable(fumo_generator fumo_generator.cpp)
target_compile_features(fumo_generator PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(fumo_generator PRIVATE UNICODE _UNICODE)
target_include_directories(fumo_generator PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)

```

`src/fumo_generator/fumo_generator.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip>
#include <optional>
#include "bootstrap.h"

NTSYSAPI ULONG RtlRandomEx(PULONG Seed);
auto fnRtlRandomEx = []() {
    return (decltype(&RtlRandomEx))GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "RtlRandomEx");
}();

std::optional<std::vector<BYTE>> read_file(std::string path);
void randomize_section_name(PIMAGE_SECTION_HEADER section_header, PULONG seed);
DWORD GetAlignedSize(DWORD size, DWORD alignment);
void encrypt_buffer(PBYTE buffer, DWORD size, ULONG_PTR xor_key);
std::vector<BYTE> generate_resource_section(DWORD VirtualAddress);

int main(int argc, char** argv) {
    if (argc < 3) {
        std::cerr << "Usage: " << argv[0] << " <output_file> <initial_loader> [module...]" << std::endl;
        return 1;
    }

    std::string output_file_path = argv[1];
    std::string initial_loader_path = argv[2];
    std::vector<std::string> module_paths;
    for (int i = 3; i < argc; i++)
        module_paths.push_back(argv[i]);

    auto initial_loader_buffer = read_file(initial_loader_path);
    if (!initial_loader_buffer.has_value()) {
        std::cerr << "Failed to read initial_loader file" << std::endl;
        return 1;
    }

    std::vector<std::vector<BYTE>> module_buffers;
    for (auto& module_path : module_paths) {
        auto module_buffer = read_file(module_path);
        if (!module_buffer.has_value()) {
            std::cerr << "Failed to read module file: " << module_path << std::endl;
            return 1;
        }
        module_buffers.push_back(module_buffer.value());
    }

    ULONG seed = (ULONG)GetTickCount64();
    ULONG_PTR xor_key = (ULONG_PTR)fnRtlRandomEx(&seed) | ((ULONG_PTR)fnRtlRandomEx(&seed) << 32);

    DWORD NumberOfSections = 3 + module_buffers.size();

    // DOS header
    IMAGE_DOS_HEADER dos_header;
    memset(&dos_header, 0, sizeof(dos_header));
    dos_header.e_magic = IMAGE_DOS_SIGNATURE;
    dos_header.e_cblp = 0x90;
    dos_header.e_cp = 0x3;
    dos_header.e_cparhdr = 0x4;
    dos_header.e_maxalloc = 0xFFFF;
    dos_header.e_sp = 0xB8;
    dos_header.e_lfarlc = 0x40;
    dos_header.e_lfanew = 0x40;

    // NT headers
    IMAGE_NT_HEADERS64 nt_headers;
    memset(&nt_headers, 0, sizeof(nt_headers));
    nt_headers.Signature = IMAGE_NT_SIGNATURE;
    nt_headers.FileHeader.Machine = IMAGE_FILE_MACHINE_AMD64;
    nt_headers.FileHeader.NumberOfSections = NumberOfSections;
    nt_headers.FileHeader.TimeDateStamp = 0x0; // FIXME: randomize
    nt_headers.FileHeader.SizeOfOptionalHeader = sizeof(nt_headers.OptionalHeader);
    nt_headers.FileHeader.Characteristics = IMAGE_FILE_RELOCS_STRIPPED | IMAGE_FILE_EXECUTABLE_IMAGE | 
        IMAGE_FILE_LINE_NUMS_STRIPPED | IMAGE_FILE_LOCAL_SYMS_STRIPPED | IMAGE_FILE_LARGE_ADDRESS_AWARE;
    nt_headers.OptionalHeader.Magic = IMAGE_NT_OPTIONAL_HDR64_MAGIC;
    nt_headers.OptionalHeader.MajorLinkerVersion = 0x1;
    nt_headers.OptionalHeader.MinorLinkerVersion = 0x0;
    nt_headers.OptionalHeader.SizeOfCode = 0; //* needs to be updated
    nt_headers.OptionalHeader.SizeOfInitializedData = 0; //* needs to be updated
    nt_headers.OptionalHeader.SizeOfUninitializedData = 0x0;
    nt_headers.OptionalHeader.AddressOfEntryPoint = 0; //* needs to be updated
    nt_headers.OptionalHeader.BaseOfCode = 0x1000;
    nt_headers.OptionalHeader.ImageBase = 0x0000000140000000;
    nt_headers.OptionalHeader.SectionAlignment = 0x1000;
    nt_headers.OptionalHeader.FileAlignment = 0x200;
    nt_headers.OptionalHeader.MajorOperatingSystemVersion = 0x6;
    nt_headers.OptionalHeader.MinorOperatingSystemVersion = 0x0;
    nt_headers.OptionalHeader.MajorImageVersion = 0x0;
    nt_headers.OptionalHeader.MinorImageVersion = 0x0;
    nt_headers.OptionalHeader.MajorSubsystemVersion = 0x6;
    nt_headers.OptionalHeader.MinorSubsystemVersion = 0x0;
    nt_headers.OptionalHeader.Win32VersionValue = 0x0;
    nt_headers.OptionalHeader.SizeOfImage = 0; //* needs to be updated
    nt_headers.OptionalHeader.SizeOfHeaders = 0x400; //* needs to be updated
    nt_headers.OptionalHeader.CheckSum = 0x0;
    nt_headers.OptionalHeader.Subsystem = IMAGE_SUBSYSTEM_WINDOWS_GUI;
    nt_headers.OptionalHeader.DllCharacteristics = IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE | 
        IMAGE_DLLCHARACTERISTICS_NX_COMPAT | IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE;
    nt_headers.OptionalHeader.SizeOfStackReserve = 0x100000;
    nt_headers.OptionalHeader.SizeOfStackCommit = 0x1000;
    nt_headers.OptionalHeader.SizeOfHeapReserve = 0x100000;
    nt_headers.OptionalHeader.SizeOfHeapCommit = 0x1000;
    nt_headers.OptionalHeader.LoaderFlags = 0x0;
    nt_headers.OptionalHeader.NumberOfRvaAndSizes = IMAGE_NUMBEROF_DIRECTORY_ENTRIES;

    // section headers
    DWORD SizeOfHeaders = sizeof(dos_header) + sizeof(nt_headers) + NumberOfSections * sizeof(IMAGE_SECTION_HEADER);
    // round up to nearest FileAlignment
    SizeOfHeaders = GetAlignedSize(SizeOfHeaders, nt_headers.OptionalHeader.FileAlignment);
    nt_headers.OptionalHeader.SizeOfHeaders = SizeOfHeaders;

    // round up to nearest SectionAlignment after headers
    DWORD NextVirtualAddress = GetAlignedSize(SizeOfHeaders, nt_headers.OptionalHeader.SectionAlignment);
    DWORD NextPointerToRawData = GetAlignedSize(SizeOfHeaders, nt_headers.OptionalHeader.FileAlignment);

    // loader section
    IMAGE_SECTION_HEADER initial_loader_section_header;
    memset(&initial_loader_section_header, 0, sizeof(initial_loader_section_header));
    initial_loader_section_header.Name[0] = 'l'; // loader
    randomize_section_name(&initial_loader_section_header, &seed);
    initial_loader_section_header.Misc.VirtualSize = initial_loader_buffer->size();
    initial_loader_section_header.VirtualAddress = NextVirtualAddress;
    initial_loader_section_header.SizeOfRawData = initial_loader_buffer->size();
    initial_loader_section_header.PointerToRawData = NextPointerToRawData;
    initial_loader_section_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

    // get next free virtual address and pointer to raw data (round up to nearest SectionAlignment)
    NextVirtualAddress += GetAlignedSize(initial_loader_section_header.Misc.VirtualSize, nt_headers.OptionalHeader.SectionAlignment);
    NextPointerToRawData += GetAlignedSize(initial_loader_section_header.SizeOfRawData, nt_headers.OptionalHeader.FileAlignment);

    // bootstrap section
    auto bootstrap_shellcode = get_bootstrap_shellcode(xor_key, initial_loader_section_header.VirtualAddress, initial_loader_section_header.SizeOfRawData);
    IMAGE_SECTION_HEADER bootstrap_section_header;
    memset(&bootstrap_section_header, 0, sizeof(bootstrap_section_header));
    bootstrap_section_header.Name[0] = 'b'; // bootstrap
    randomize_section_name(&bootstrap_section_header, &seed);
    bootstrap_section_header.Misc.VirtualSize = bootstrap_shellcode.size();
    bootstrap_section_header.VirtualAddress = NextVirtualAddress;
    bootstrap_section_header.SizeOfRawData = bootstrap_shellcode.size();
    bootstrap_section_header.PointerToRawData = NextPointerToRawData;
    bootstrap_section_header.Characteristics = IMAGE_SCN_MEM_EXECUTE | IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

    // get next free virtual address and pointer to raw data (round up to nearest SectionAlignment)
    NextVirtualAddress += GetAlignedSize(bootstrap_section_header.Misc.VirtualSize, nt_headers.OptionalHeader.SectionAlignment);
    NextPointerToRawData += GetAlignedSize(bootstrap_section_header.SizeOfRawData, nt_headers.OptionalHeader.FileAlignment);

    // module sections
    std::vector<IMAGE_SECTION_HEADER> module_section_headers;
    for (auto& module_buffer : module_buffers) {
        // section header
        IMAGE_SECTION_HEADER section_header;
        memset(&section_header, 0, sizeof(section_header));
        section_header.Name[0] = 'e'; // encrypted
        randomize_section_name(&section_header, &seed);
        section_header.Misc.VirtualSize = module_buffer.size();
        section_header.VirtualAddress = NextVirtualAddress;
        section_header.SizeOfRawData = module_buffer.size();
        section_header.PointerToRawData = NextPointerToRawData;
        section_header.Characteristics = IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE;

        // get next free virtual address and pointer to raw data (round up to nearest SectionAlignment)
        NextVirtualAddress += GetAlignedSize(section_header.Misc.VirtualSize, nt_headers.OptionalHeader.SectionAlignment);
        NextPointerToRawData += GetAlignedSize(section_header.SizeOfRawData, nt_headers.OptionalHeader.FileAlignment);

        module_section_headers.push_back(section_header);
    }

    // resource section
    auto resource_section_data = generate_resource_section(NextVirtualAddress);
    IMAGE_SECTION_HEADER resource_section_header;
    memset(&resource_section_header, 0, sizeof(resource_section_header));
    strcpy_s((char*)resource_section_header.Name, sizeof(resource_section_header.Name), ".rsrc");
    resource_section_header.Misc.VirtualSize = resource_section_data.size();
    resource_section_header.VirtualAddress = NextVirtualAddress;
    resource_section_header.SizeOfRawData = resource_section_data.size();
    resource_section_header.PointerToRawData = NextPointerToRawData;
    resource_section_header.Characteristics = IMAGE_SCN_MEM_READ;

    // get next free virtual address and pointer to raw data (round up to nearest SectionAlignment)
    NextVirtualAddress += GetAlignedSize(resource_section_header.Misc.VirtualSize, nt_headers.OptionalHeader.SectionAlignment);
    NextPointerToRawData += GetAlignedSize(resource_section_header.SizeOfRawData, nt_headers.OptionalHeader.FileAlignment);
    
    // update NT headers
    nt_headers.OptionalHeader.SizeOfImage = NextVirtualAddress;
    nt_headers.OptionalHeader.SizeOfCode = initial_loader_section_header.SizeOfRawData + bootstrap_section_header.SizeOfRawData;
    nt_headers.OptionalHeader.SizeOfInitializedData = initial_loader_section_header.SizeOfRawData + bootstrap_section_header.SizeOfRawData;
    nt_headers.OptionalHeader.AddressOfEntryPoint = bootstrap_section_header.VirtualAddress;
    nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].VirtualAddress = resource_section_header.VirtualAddress;
    nt_headers.OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_RESOURCE].Size = resource_section_header.SizeOfRawData;

    // write the PE file
    std::ofstream pe_file(output_file_path, std::ios::binary);
    if (!pe_file.is_open()) {
        std::cerr << "Failed to open output file" << std::endl;
        return 1;
    }

    // write DOS header
    pe_file.write((char*)&dos_header, sizeof(dos_header));

    // write NT headers
    pe_file.write((char*)&nt_headers, sizeof(nt_headers));

    // write section headers
    pe_file.write((char*)&initial_loader_section_header, sizeof(initial_loader_section_header));
    pe_file.write((char*)&bootstrap_section_header, sizeof(bootstrap_section_header));
    for (auto& module_section_header : module_section_headers)
        pe_file.write((char*)&module_section_header, sizeof(module_section_header));
    pe_file.write((char*)&resource_section_header, sizeof(resource_section_header));

    // write loader section data
    encrypt_buffer(initial_loader_buffer->data(), initial_loader_buffer->size(), xor_key);
    pe_file.seekp(initial_loader_section_header.PointerToRawData);
    pe_file.write((char*)initial_loader_buffer->data(), initial_loader_buffer->size());

    // write bootstrap section data
    pe_file.seekp(bootstrap_section_header.PointerToRawData);
    pe_file.write((char*)bootstrap_shellcode.data(), bootstrap_shellcode.size());

    // write module section data
    for (int i = 0; i < module_buffers.size(); i++) {
        encrypt_buffer(module_buffers[i].data(), module_buffers[i].size(), xor_key);
        pe_file.seekp(module_section_headers[i].PointerToRawData);
        pe_file.write((char*)module_buffers[i].data(), module_buffers[i].size());
    }

    // write resource section data
    pe_file.seekp(resource_section_header.PointerToRawData);
    pe_file.write((char*)resource_section_data.data(), resource_section_data.size());

    pe_file.close();
    return 0;
}

std::optional<std::vector<BYTE>> read_file(std::string path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open())
        return std::nullopt;

    std::vector<BYTE> data;
    data.assign(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>());
    return data;
}

void randomize_section_name(PIMAGE_SECTION_HEADER section_header, PULONG seed) {
    // start at 1 to skip our "magic" section type indicator
    for (int j = 1; j < 8; j++)
        section_header->Name[j] = (char)(fnRtlRandomEx(seed) % 26 + 'a');
}

DWORD GetAlignedSize(DWORD size, DWORD alignment) {
    return (size + alignment - 1) & ~(alignment - 1);
}

void encrypt_buffer(PBYTE buffer, DWORD size, ULONG_PTR xor_key) {
    for (int i = 0; i < size; i += sizeof(xor_key)) {
        auto data = (PULONG64)(buffer + i);
        *data ^= xor_key;
    }
}

std::vector<BYTE> generate_resource_section(DWORD VirtualAddress) {
    std::vector<BYTE> data;

    // same thing but with a template and automatic size calculation
    auto allocate = [&]<class T>() -> T* {
        auto offset = data.size();
        data.resize(offset + sizeof(T));
        return reinterpret_cast<T*>(&data[offset]);
    };

    PIMAGE_RESOURCE_DIRECTORY resource_directory = allocate.operator()<IMAGE_RESOURCE_DIRECTORY>();
    resource_directory->Characteristics = 0;
    resource_directory->TimeDateStamp = 0;
    resource_directory->MajorVersion = 0;
    resource_directory->MinorVersion = 0;
    resource_directory->NumberOfNamedEntries = 0;
    resource_directory->NumberOfIdEntries = 1;

    // manifest resource
    PIMAGE_RESOURCE_DIRECTORY_ENTRY resource_directory_entry = allocate.operator()<IMAGE_RESOURCE_DIRECTORY_ENTRY>();
    resource_directory_entry->Id = (WORD)RT_MANIFEST;
    resource_directory_entry->DataIsDirectory = TRUE;
    resource_directory_entry->OffsetToDirectory = data.size();

    PIMAGE_RESOURCE_DIRECTORY resource_directory2 = allocate.operator()<IMAGE_RESOURCE_DIRECTORY>();
    resource_directory2->Characteristics = 0;
    resource_directory2->TimeDateStamp = 0;
    resource_directory2->MajorVersion = 0;
    resource_directory2->MinorVersion = 0;
    resource_directory2->NumberOfNamedEntries = 0;
    resource_directory2->NumberOfIdEntries = 1;

    PIMAGE_RESOURCE_DIRECTORY_ENTRY resource_directory_entry2 = allocate.operator()<IMAGE_RESOURCE_DIRECTORY_ENTRY>();
    resource_directory_entry2->Id = 1;
    resource_directory_entry2->DataIsDirectory = TRUE;
    resource_directory_entry2->OffsetToDirectory = data.size();

    PIMAGE_RESOURCE_DIRECTORY resource_directory3 = allocate.operator()<IMAGE_RESOURCE_DIRECTORY>();
    resource_directory3->Characteristics = 0;
    resource_directory3->TimeDateStamp = 0;
    resource_directory3->MajorVersion = 0;
    resource_directory3->MinorVersion = 0;
    resource_directory3->NumberOfNamedEntries = 0;
    resource_directory3->NumberOfIdEntries = 1;

    PIMAGE_RESOURCE_DIRECTORY_ENTRY resource_directory_entry3 = allocate.operator()<IMAGE_RESOURCE_DIRECTORY_ENTRY>();
    resource_directory_entry3->Id = 0x409; // english
    resource_directory_entry3->DataIsDirectory = FALSE;
    resource_directory_entry3->OffsetToData = data.size();

    std::string manifest = R"(<?xml version='1.0' encoding='UTF-8' standalone='yes'?>
<assembly xmlns='urn:schemas-microsoft-com:asm.v1' manifestVersion='1.0'>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level='requireAdministrator' uiAccess='false' />
      </requestedPrivileges>
    </security>
  </trustInfo>
</assembly>
)";

    PIMAGE_RESOURCE_DATA_ENTRY resource_data_entry = allocate.operator()<IMAGE_RESOURCE_DATA_ENTRY>();
    resource_data_entry->OffsetToData = VirtualAddress + data.size();
    resource_data_entry->Size = manifest.size();
    resource_data_entry->CodePage = 0;
    resource_data_entry->Reserved = 0;

    data.insert(data.end(), manifest.begin(), manifest.end());

    return data;
}
```

`src/include/bootstrap.h`:

```h
#pragma once
#include <Windows.h>
#include <array>

__forceinline auto get_bootstrap_shellcode(ULONG_PTR xor_key, ULONG_PTR section_virtual_offset, ULONG section_size) {
    std::array<BYTE, 67> entrypoint = {
        // constants
        0x48, 0xB9, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rcx, 0h
        0x48, 0xBA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov rdx, 0h
        0x49, 0xB8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // mov r8, 0h

        // add image base address to constants (this removes the need for a relocation table)
        0x65, 0x48, 0x8B, 0x04, 0x25, 0x60, 0x00, 0x00, 0x00,       // mov rax, gs:[60h] ; PEB
        0x48, 0x8B, 0x40, 0x10,                                     // mov rax, [rax+10h] ; PEB.ImageBaseAddress
        0x48, 0x01, 0xC2,                                           // add rdx, rax
        0x49, 0x01, 0xC0,                                           // add r8, rax

        // save section start so we can jump to it later
        0x4C, 0x8B, 0xCA,                                           // mov r9, rdx

        // decrypt section                                          // loop1:
        0x48, 0x31, 0x0A,                                           // xor QWORD PTR [rdx], rcx
        0x48, 0x83, 0xC2, 0x08,                                     // add rdx, 8
        0x49, 0x3B, 0xD0,                                           // cmp rdx, r8
        0x72, 0xF4,                                                 // jb loop1

        // jump to section (rcx still contains the xor key)
        0x41, 0xFF, 0xE1 // jmp r9
    };

    // update constants
    *(ULONG_PTR*)&entrypoint[2] = xor_key;
    *(ULONG_PTR*)&entrypoint[12] = section_virtual_offset;
    *(ULONG_PTR*)&entrypoint[22] = section_virtual_offset + section_size;
    return entrypoint;
}
```

`src/include/fomo_common.h`:

```h
#pragma once

// Windows 10 2004/20H1 (19041) or higher
#define MIN_OS_MAJOR_VERSION 10
#define MIN_OS_BUILD_NUMBER 19041

#define FUMO_MAGIC 'OMUF'
#define FUMO_DATA_VERSION 0x00000001
#define FUMO_DRIVER_VERSION 0x00000002
#define FUMO_HOOKED_DRIVER_NAME L"\\Driver\\Null"
#define FUMO_HOOKED_DRIVER_NAME_USER L"\\\\.\\NUL"
#define FUMO_SECOND_STAGE_PROCESS_NAME L"explorer.exe"
#define FUMO_FILE_FORMAT_VERSION 0x00000001

#define IO_VERSION_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8000, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_UNLOAD_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8001, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_ALLOC_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8011, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_MAP_MEMORY_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8012, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_EXECUTE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8013, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IO_FIND_MODULE_REQUEST CTL_CODE(FILE_DEVICE_UNKNOWN, 0x8014, METHOD_BUFFERED, FILE_ANY_ACCESS)

typedef struct _IO_VERSION_RESPONSE_DATA {
    ULONG Version;
} IO_VERSION_RESPONSE_DATA, *PIO_VERSION_RESPONSE_DATA;

typedef struct _IO_ALLOC_REQUEST_DATA {
    ULONG Size;
} IO_ALLOC_REQUEST_DATA, *PIO_ALLOC_REQUEST_DATA;

typedef struct _IO_ALLOC_RESPONSE_DATA {
    PVOID Address;
} IO_ALLOC_RESPONSE_DATA, *PIO_ALLOC_RESPONSE_DATA;

typedef struct _IO_MAP_MEMORY_REQUEST_DATA {
    ULONG Pid;
    PVOID Address;
    ULONG Size;
} IO_MAP_MEMORY_REQUEST_DATA, *PIO_MAP_MEMORY_REQUEST_DATA;

typedef struct _IO_EXECUTE_REQUEST_DATA {
    ULONG Pid;
    PVOID Address;
    PVOID Argument;
} IO_EXECUTE_REQUEST_DATA, *PIO_EXECUTE_REQUEST_DATA;

typedef struct _IO_FIND_MODULE_REQUEST_DATA {
    ULONG Pid;
    WCHAR ModuleName[256];
} IO_FIND_MODULE_REQUEST_DATA, *PIO_FIND_MODULE_REQUEST_DATA;

typedef struct _IO_FIND_MODULE_RESPONSE_DATA {
    PVOID Address;
} IO_FIND_MODULE_RESPONSE_DATA, *PIO_FIND_MODULE_RESPONSE_DATA;

typedef struct _FUMO_DATA_HEADER {
    DWORD Magic;
    DWORD Version;
    DWORDLONG XorKey;
    DWORD SettingsSize;
    DWORD DataSize;
} FUMO_DATA_HEADER, *PFUMO_DATA_HEADER;

typedef struct _FUMO_EMBEDDED_DATA {
    PVOID Data;
    DWORD Size;
} FUMO_EMBEDDED_DATA, *PFUMO_EMBEDDED_DATA;
```

`src/include/util.h`:

```h
#pragma once
#include <Windows.h>
#include <winternl.h>
#include <TlHelp32.h>
#include <string>
#include <format>
#include <sstream>
#include <vector>
#include <locale>
#include <codecvt>

typedef struct _STAGE2_LOADER_DATA {
    ULONG_PTR stage2_base;
    ULONG_PTR fumo_data_base;
    DWORD loader_pid;
} STAGE2_LOADER_DATA, *PSTAGE2_LOADER_DATA;

extern "C" NTSYSAPI NTSTATUS NTAPI RtlGetVersion(
    _Out_ PRTL_OSVERSIONINFOW lpVersionInformation
);

inline std::vector<std::string> split(std::string text, char delim) {
    std::string line;
    std::vector<std::string> vec;
    std::stringstream ss(text);
    while(std::getline(ss, line, delim))
        vec.push_back(line);
    return vec;
}

inline std::wstring convert_to_wstring(const std::string &str) {
    std::wstring_convert<std::codecvt_utf8_utf16<wchar_t>, wchar_t> conv;
    return conv.from_bytes(str);
}

inline bool isHvciEnabled() {
    SYSTEM_CODEINTEGRITY_INFORMATION sci = { 0 };
    sci.Length = sizeof(sci);
    if (NT_SUCCESS(NtQuerySystemInformation(SystemCodeIntegrityInformation, &sci, sizeof(sci), NULL))) {
        return sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_ENABLED && 
          sci.CodeIntegrityOptions & CODEINTEGRITY_OPTION_HVCI_KMCI_ENABLED;
    }
    return false;
}

inline std::wstring get_proces_name(HANDLE process) {
    std::wstring process_name;
    process_name.resize(MAX_PATH);
    DWORD size = process_name.size();
    QueryFullProcessImageNameW(process, 0, (LPWSTR)process_name.data(), &size);
    process_name.resize(size);
    return process_name;
}

inline DWORD find_process_by_name(LPCWSTR lpProcessName) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE)
        return 0;

    PROCESSENTRY32W pe32;
    pe32.dwSize = sizeof(PROCESSENTRY32W);
    if (!Process32FirstW(hSnapshot, &pe32)) {
        CloseHandle(hSnapshot);
        return 0;
    }

    DWORD pid = 0;
    do {
        if (wcscmp(pe32.szExeFile, lpProcessName) == 0) {
            pid = pe32.th32ProcessID;
            break;
        }
    } while (Process32NextW(hSnapshot, &pe32));

    CloseHandle(hSnapshot);
    return pid;
}

namespace fumo {
    template<class... Args>
    int error(int code, const WCHAR* fmt, Args... args) {
        std::wstring message = std::vformat(fmt, std::make_wformat_args(std::forward<decltype(args)>(args)...));
        message.append(L"\n\nError code: " + std::to_wstring(code));
        message.append(L"\nWin32 error: " + std::to_wstring(GetLastError()));
        MessageBoxW(NULL, message.c_str(), L"FUMO LOADER ERROR", MB_OK | MB_ICONERROR);
        return code;
    }
}
```

`src/initial_loader/CMakeLists.txt`:

```txt
add_library(initial_loader_lib STATIC initial_loader.cpp)
target_link_libraries(initial_loader_lib PRIVATE lazy_importer xorstr)
target_compile_definitions(initial_loader_lib PRIVATE UNICODE _UNICODE)
target_compile_features(initial_loader_lib PUBLIC c_std_17 cxx_std_20)
target_compile_options(initial_loader_lib PRIVATE /O1 /GS- /sdl-)
target_include_directories(initial_loader_lib PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)

add_custom_command(
    COMMENT "Extracting initial_loader_lib"
    DEPENDS initial_loader_lib
    WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}/
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj
    COMMAND ${CMAKE_CURRENT_SOURCE_DIR}/extract_lib.bat $<TARGET_LINKER_FILE:initial_loader_lib>
)

add_custom_command(
    COMMENT "Extracting initial_loader"
    DEPENDS shellcode_extractor
    DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj
    OUTPUT ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
    COMMAND shellcode_extractor ${CMAKE_CURRENT_BINARY_DIR}/initial_loader.obj initial_loader ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
)

add_custom_target(
    initial_loader
    DEPENDS ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR}/initial_loader.bin
    COMMENT "Building initial_loader.bin"
)
set_target_properties(initial_loader PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${CMAKE_CFG_INTDIR})
```

`src/initial_loader/extract_lib.bat`:

```bat
@ECHO OFF
SETLOCAL EnableDelayedExpansion

FOR /F %%O IN ('lib "%~1" /LIST /NOLOGO') DO (
    lib "%~1" /EXTRACT:"%%O" /OUT:"%%~nxO" /NOLOGO
)
```

`src/initial_loader/initial_loader.cpp`:

```cpp
#include <Windows.h>
#include <winternl.h>
#include <lazy_importer.hpp>
#include <xorstr.hpp>
#include <bootstrap.h>
#include <fomo_common.h>

NTSYSAPI ULONG RtlRandomEx(PULONG Seed);

#define DEBUG

#ifdef DEBUG
#define EXIT_WITH_ERROR(error, message) {fnMessageBoxA(nullptr, xorstr_(message), xorstr_("Error"), MB_OK | MB_ICONERROR); fnExitProcess(error);}
#else
#define EXIT_WITH_ERROR(error, message) {fnExitProcess(error);}
#endif

#define ERR_SUCCESS 0
#define ERR_FAILED_TO_ALLOCATE_MEMORY 1
#define ERR_FAILED_TO_FIND_LOADER_SECTION 2
#define ERR_FAILED_TO_FIND_BOOTSTRAP_SECTION 3
#define ERR_FAILED_TO_OPEN_FILE_FOR_NEW_EXECUTABLE 4
#define ERR_FAILED_TO_SET_DELETE_FILE_INFO 5
#define ERR_FAILED_TO_WRITE_NEW_EXECUTABLE_TO_DISK 6
#define ERR_FAILED_TO_WRITE_ENTIRE_NEW_EXECUTABLE_TO_DISK 7
#define ERR_FAILED_TO_MAP_ENCRYPTED_SECTION 8
#define ERR_FAILED_TO_RELOCATE_IMAGE 9
#define ERR_FAILED_TO_FIND_IMPORTED_MODULE 10
#define ERR_FAILED_TO_FIND_IMPORTED_FUNCTION 11
#define ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT 12

// simple memcpy that can be inlined
__forceinline void inline_memcpy(PVOID dest, PVOID src, SIZE_T size) {
    for (SIZE_T i = 0; i < size; i++) {
        ((PBYTE)dest)[i] = ((PBYTE)src)[i];
    }
}

__forceinline int map_encrypted_image(ULONG_PTR base, PFUMO_EMBEDDED_DATA embedded_data) {
    auto fnVirtualAlloc = LI_FN(VirtualAlloc).get();
    auto fnExitProcess = LI_FN(ExitProcess).get();
    auto fnLoadLibraryA = LI_FN(LoadLibraryA).get();
    auto fnGetProcAddress = LI_FN(GetProcAddress).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);

    // allocate memory for section
    auto new_image_base = (ULONG_PTR)fnVirtualAlloc(nullptr, //(LPVOID)nt_headers->OptionalHeader.ImageBase,
        nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!new_image_base)
        EXIT_WITH_ERROR(ERR_FAILED_TO_ALLOCATE_MEMORY, "Failed to allocate memory for new executable");

    // map sections
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0)
            continue;
        auto section_data = (PVOID)(base + section->PointerToRawData);
        inline_memcpy((PVOID)(new_image_base + section->VirtualAddress), section_data, section->SizeOfRawData);
    }

    // process relocations
    auto delta = (ULONG_PTR)new_image_base - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0) {
        auto base_relocation = (PIMAGE_BASE_RELOCATION)(new_image_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (base_relocation->VirtualAddress != 0) {
            auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
            auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            for (auto i = 0; i < number_of_relocations; i++) {
                auto type = relocation[i] >> 12;
                if (type == IMAGE_REL_BASED_DIR64) {
                    auto address = (PULONG_PTR)(new_image_base + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += delta;
                } else if (type != IMAGE_REL_BASED_ABSOLUTE)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_RELOCATE_IMAGE, "Failed to relocate image");
            }
            base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    // resolve imports
    auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(new_image_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    while (import_descriptor->Name != 0) {
        auto module_name = (PCHAR)(new_image_base + import_descriptor->Name);
        auto module_handle = fnLoadLibraryA(module_name);
        if (!module_handle)
            EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_MODULE, "Failed to find imported module");

        auto thunk_data = (PIMAGE_THUNK_DATA)(new_image_base + import_descriptor->FirstThunk);
        while (thunk_data->u1.AddressOfData != 0) {
            if (thunk_data->u1.Ordinal & IMAGE_ORDINAL_FLAG64) {
                auto function_name = (PCHAR)(thunk_data->u1.Ordinal & 0xFFFF);
                auto function_address = fnGetProcAddress(module_handle, function_name);
                if (!function_address)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_FUNCTION, "Failed to find imported function");

                thunk_data->u1.Function = (ULONGLONG)function_address;
            } else {
                auto import_by_name = (PIMAGE_IMPORT_BY_NAME)(new_image_base + thunk_data->u1.AddressOfData);
                auto function_address = fnGetProcAddress(module_handle, import_by_name->Name);
                if (!function_address)
                    EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_IMPORTED_FUNCTION, "Failed to find imported function");

                thunk_data->u1.Function = (ULONGLONG)function_address;
            }
            thunk_data++;
        }
        import_descriptor++;
    }

    // execute dll entry point
    using DllMain = BOOL(WINAPI*)(HINSTANCE, DWORD, PFUMO_EMBEDDED_DATA);
    auto dll_entry_point = (DllMain)(new_image_base + nt_headers->OptionalHeader.AddressOfEntryPoint);
    auto success = dll_entry_point((HINSTANCE)new_image_base, DLL_PROCESS_ATTACH, embedded_data);
    if (!success)
        return ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT;
    
    return ERR_SUCCESS;
}

__forceinline int map_encrypted_sections(ULONG_PTR base) {
    auto fnExitProcess = LI_FN(ExitProcess).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    // parse the headers
    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    FUMO_EMBEDDED_DATA embedded_data;
    embedded_data.Data = nullptr;
    embedded_data.Size = 0;

    // map encrypted sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        // only map sections that start with 'e' (encrypted)
        if (section->Name[0] != 'e')
            continue;
        if (section->Misc.VirtualSize < 4)
            EXIT_WITH_ERROR(ERR_FAILED_TO_MAP_ENCRYPTED_SECTION, "Failed to map encrypted section (to small)")
        
        ULONG_PTR section_base = base + section->VirtualAddress;

        // check if this is a data section
        if (*(DWORD*)section_base == FUMO_MAGIC) {
            embedded_data.Data = (PVOID)section_base;
            embedded_data.Size = section->Misc.VirtualSize;
            continue;
        }
        
        auto error = map_encrypted_image(section_base, &embedded_data);
        if (error != ERR_SUCCESS) {
            if (error != ERR_FAILED_TO_EXECUTE_DLL_ENTRY_POINT)
                EXIT_WITH_ERROR(ERR_FAILED_TO_MAP_ENCRYPTED_SECTION, "Failed to map encrypted section");
            return error;
        }
    }
    
    return ERR_SUCCESS;
}

extern "C" void initial_loader(ULONG_PTR xorKey) {
    auto fnGetModuleHandleA = LI_FN(GetModuleHandleA).get();
    auto fnVirtualAlloc = LI_FN(VirtualAlloc).get();
    auto fnVirtualFree = LI_FN(VirtualFree).get();
    auto fnGetTickCount64 = LI_FN(GetTickCount64).get();
    auto fnRtlRandomEx = LI_FN(RtlRandomEx).get();
    auto fnCreateFileA = LI_FN(CreateFileA).get();
    auto fnSetFileInformationByHandle = LI_FN(SetFileInformationByHandle).get();
    auto fnWriteFile = LI_FN(WriteFile).get();
    auto fnCloseHandle = LI_FN(CloseHandle).get();
    auto fnExitProcess = LI_FN(ExitProcess).get();
#ifdef DEBUG
    // user32.dll is not loaded by default by windows, so we need to load it manually
    LI_FN(LoadLibraryA)(xorstr_("user32.dll"));
    auto fnMessageBoxA = LI_FN(MessageBoxA).get();
#else
    #define fnMessageBoxA(a, b, c, d)
#endif

    // get module base
    ULONG_PTR base = (ULONG_PTR)fnGetModuleHandleA(nullptr); // to lazy to pull it from the PEB directly

    // parse the headers
    auto nt_headers = (PIMAGE_NT_HEADERS)(base + ((PIMAGE_DOS_HEADER)base)->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    // decrypt all sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        // only decrypt sections that start with 'e' (encrypted)
        if (section->Name[0] == 'e') {
            // decrypt section (8 bytes at a time)
            for (int j = 0; j < section->SizeOfRawData; j += sizeof(xorKey)) {
                auto data = (PULONG64)(base + section->VirtualAddress + j);
                *data ^= xorKey;
            }
        }
    }

    // allocate memory for new executable
    auto new_image_base = (ULONG_PTR)fnVirtualAlloc(nullptr, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (!new_image_base)
        EXIT_WITH_ERROR(ERR_FAILED_TO_ALLOCATE_MEMORY, "Failed to allocate memory for new executable");

    // copy headers
    inline_memcpy((PVOID)new_image_base, (PVOID)base, nt_headers->OptionalHeader.SizeOfHeaders);
    nt_headers = (PIMAGE_NT_HEADERS)(new_image_base + ((PIMAGE_DOS_HEADER)new_image_base)->e_lfanew);
    section_header = IMAGE_FIRST_SECTION(nt_headers);

    // update image base in new executable to the current base the executable is loaded at
    nt_headers->OptionalHeader.ImageBase = base;

    // unmap sections
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0) {
            continue;
        }
        inline_memcpy((PVOID)(new_image_base + section->PointerToRawData), (PVOID)(base + section->VirtualAddress), section->SizeOfRawData);
    }

    // generate a new random xor key
    ULONG seed = (ULONG)fnGetTickCount64();
    ULONG_PTR new_xor_key = (ULONG_PTR)fnRtlRandomEx(&seed) | ((ULONG_PTR)fnRtlRandomEx(&seed) << 32);

    // re-encrypt all sections in new executable
    section_header = IMAGE_FIRST_SECTION(nt_headers);
    PIMAGE_SECTION_HEADER loader_section = nullptr;
    PIMAGE_SECTION_HEADER bootstrap_section = nullptr;
    DWORD FileSize = 0;
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        switch (section->Name[0]) {
        case 'b': // bootstrap
            bootstrap_section = section;
            break;
        case 'l': // loader
            loader_section = section;
            // fallthrough (encrypt loader section too)
        case 'e': // encrypted
            // encrypt section
            for (int j = 0; j < section->SizeOfRawData; j += sizeof(new_xor_key)) {
                auto data = (PULONG64)(new_image_base + section->PointerToRawData + j);
                *data ^= new_xor_key;
            }
            break;
        default:
            // ignore other sections
            break;
        }

        // calculate file size
        FileSize = max(FileSize, section->PointerToRawData + section->SizeOfRawData);
    }

    if (!loader_section)
        EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_LOADER_SECTION, "Failed to find loader section");
    if (!bootstrap_section)
        EXIT_WITH_ERROR(ERR_FAILED_TO_FIND_BOOTSTRAP_SECTION, "Failed to find bootstrap section");

    // fill bootstrap section with random data
    for (int i = 0; i < bootstrap_section->SizeOfRawData; i += sizeof(ULONG)) {
        auto data = (PULONG)(new_image_base + bootstrap_section->PointerToRawData + i);
        *data = fnRtlRandomEx(&seed);
    }

    auto bootstrap_shellcode = get_bootstrap_shellcode(new_xor_key, loader_section->VirtualAddress, loader_section->SizeOfRawData);

    // pick a random offset in the bootstrap section to store the bootstrap shellcode
    ULONG_PTR max_offset = bootstrap_section->SizeOfRawData - bootstrap_shellcode.size();
    ULONG_PTR bootstrap_shellcode_offset = max_offset == 0 ? 0 : (fnRtlRandomEx(&seed) % max_offset);

    // copy bootstrap shellcode to new executable
    inline_memcpy((PVOID)(new_image_base + bootstrap_section->PointerToRawData + bootstrap_shellcode_offset), bootstrap_shellcode.data(), bootstrap_shellcode.size());

    // update entry point to point to bootstrap shellcode
    nt_headers->OptionalHeader.AddressOfEntryPoint = bootstrap_section->VirtualAddress + bootstrap_shellcode_offset;

    // randomize section names
    for (int i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];

        // ignore sections with well known names
        if (section->Name[0] == '.')
            continue;

        // start at 1 to skip our "magic" section type indicator
        for (int j = 1; j < 8; j++) {
            section->Name[j] = (char)(fnRtlRandomEx(&seed) % 26 + 'a');
        }
    }

    // generate a new random file name
    char file_name[MAX_PATH];
    for (int i = 0; i < 16; i++) {
        file_name[i] = (char)(fnRtlRandomEx(&seed) % 26 + 'a');
    }
    file_name[16] = '.';
    file_name[17] = 'e';
    file_name[18] = 'x';
    file_name[19] = 'e';
    file_name[20] = '\0';

    auto file_handle = fnCreateFileA(file_name, GENERIC_WRITE | DELETE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (file_handle == INVALID_HANDLE_VALUE)
        EXIT_WITH_ERROR(ERR_FAILED_TO_OPEN_FILE_FOR_NEW_EXECUTABLE, "Failed to open file for new executable");
    
    FILE_DISPOSITION_INFO disposition_info;
    disposition_info.DeleteFile = TRUE;
    if (!fnSetFileInformationByHandle(file_handle, FileDispositionInfo, &disposition_info, sizeof(disposition_info))) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_SET_DELETE_FILE_INFO, "Failed to set delete file info (1)");
    }

    DWORD bytes_written = 0;
    if (!fnWriteFile(file_handle, (PVOID)new_image_base, FileSize, &bytes_written, nullptr)) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_WRITE_NEW_EXECUTABLE_TO_DISK, "Failed to write new executable to disk");
    }

    if (bytes_written != FileSize) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_WRITE_ENTIRE_NEW_EXECUTABLE_TO_DISK, "Failed to write entire new executable to disk");
    }

    fnVirtualFree((PVOID)new_image_base, 0, MEM_RELEASE);

    auto error = map_encrypted_sections(base);
    if (error != ERR_SUCCESS) {
        fnCloseHandle(file_handle);
        fnExitProcess(error);
        return;
    }

    disposition_info.DeleteFileW = FALSE;
    if (!fnSetFileInformationByHandle(file_handle, FileDispositionInfo, &disposition_info, sizeof(disposition_info))) {
        fnCloseHandle(file_handle);
        EXIT_WITH_ERROR(ERR_FAILED_TO_SET_DELETE_FILE_INFO, "Failed to set delete file info (2)");
    }

    fnCloseHandle(file_handle);
    fnExitProcess(0);
}
```

`src/rsource_generator/CMakeLists.txt`:

```txt
add_executable(resource_generator rsource_generator.cpp)
target_compile_features(resource_generator PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(resource_generator PRIVATE UNICODE _UNICODE)
set_target_properties(resource_generator PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})

```

`src/rsource_generator/rsource_generator.cpp`:

```cpp
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <array>
#include <iomanip>
#include <filesystem>

int main(int argc, char** argv) {
    if (argc != 4) {
        std::cerr << "Usage: " << argv[0] << " <input_file> <symbol_name> <output_path> " << std::endl;
        return 1;
    }

    std::string input_file_name = argv[1];
    std::string target_symbol_name = argv[2];
    std::filesystem::path output_path = argv[3];

    std::ifstream input_file(input_file_name, std::ios::binary);
    if (!input_file.is_open()) {
        std::cerr << "Failed to open file" << std::endl;
        return 1;
    }

    std::vector<unsigned char> input_data;
    input_data.assign(std::istreambuf_iterator<char>(input_file), std::istreambuf_iterator<char>());

    std::filesystem::path output_source_path = output_path / (target_symbol_name + ".cpp");
    std::ofstream output_file(output_source_path, std::ios::binary);
    if (!output_file.is_open()) {
        std::cerr << "Failed to open source file: " << output_source_path << std::endl;
        return 1;
    }

    output_file << "#include \"" << target_symbol_name << ".h\"\n\n";
    output_file << "std::array<unsigned char, " << input_data.size() << "> res::" << target_symbol_name << " = {\n\t";
    for (int i = 0; i < input_data.size(); i++) {
        if (i % 16 == 0 && i != 0) {
            output_file << "\n\t";
        }
        output_file << "0x" << std::setfill('0') << std::setw(2) << std::hex << (int)input_data[i] << ", ";
    }
    output_file << "\n};\n";
    output_file.close();

    std::filesystem::path output_header_path = output_path / (target_symbol_name + ".h");
    std::ofstream output_header(output_header_path, std::ios::binary);
    if (!output_header.is_open()) {
        std::cerr << "Failed to open header file: " << output_header_path << std::endl;
        return 1;
    }

    output_header << "#pragma once\n\n";
    output_header << "#include <array>\n\n";
    output_header << "namespace res {\n";
    output_header << "extern std::array<unsigned char, " << input_data.size() << "> " << target_symbol_name << ";\n";
    output_header << "}\n";
    output_header.close();

    return 0;
}
```

`src/shellcode_extractor/CMakeLists.txt`:

```txt
add_executable(shellcode_extractor shellcode_extractor.cpp)
target_compile_features(shellcode_extractor PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(shellcode_extractor PRIVATE UNICODE _UNICODE)
set_target_properties(shellcode_extractor PROPERTIES RUNTIME_OUTPUT_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR})
```

`src/shellcode_extractor/shellcode_extractor.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>
#include <vector>
#include <iomanip>

// purpose: extract shellcode from object file given symbol name and emit C++ code
// usage: shellcode_extractor.exe <object_file> <symbol_name> [output_file]
// reason for existence: Why manually copy it every time when you shellcode_extractorcan 
//                       overengineer an automatic extractor/encoder?
// references: https://learn.microsoft.com/en-us/windows/win32/debug/pe-format

std::string getSymbolName(PIMAGE_SYMBOL symbol, PBYTE string_table);

int main(int argc, char** argv) {
	if (argc != 4) {
		std::cerr << "Usage: " << argv[0] << " <object_file> <symbol_name> <output_file>" << std::endl;
		return 1;
	}

	std::string object_file_name = argv[1];
	std::string target_symbol_name = argv[2];
	std::string output_file_name = argv[3];

	std::ifstream object_file(argv[1], std::ios::binary);
	if (!object_file.is_open()) {
		std::cerr << "Failed to open file" << std::endl;
		return 1;
	}

	std::vector<unsigned char> object_data;
	object_data.assign(std::istreambuf_iterator<char>(object_file), std::istreambuf_iterator<char>());

	PBYTE object_base = (PBYTE)object_data.data();
	PIMAGE_FILE_HEADER file_header = (PIMAGE_FILE_HEADER)object_base;
	if (file_header->Machine != IMAGE_FILE_MACHINE_AMD64) {
		std::cerr << "Not a 64-bit object file" << std::endl;
		return 1;
	}

	// parse symbol table
	PIMAGE_SYMBOL symbol_table = (PIMAGE_SYMBOL)(object_base + file_header->PointerToSymbolTable);
	PBYTE string_table = (PBYTE)(symbol_table + file_header->NumberOfSymbols);

	SHORT SectionNumber = IMAGE_SYM_UNDEFINED;
	DWORD SectionOffset = 0;
	for (int i = 0; i < file_header->NumberOfSymbols; i++) {
		std::string symbol_name = getSymbolName(&symbol_table[i], string_table);
		if (symbol_name != target_symbol_name) {
			i += symbol_table[i].NumberOfAuxSymbols;
			continue;
		}

		if ((symbol_table[i].Type >> 4) != IMAGE_SYM_DTYPE_FUNCTION || (symbol_table[i].Type & 0x0F) != IMAGE_SYM_TYPE_NULL) {
			std::cerr << "Specified symbol is not a function" << std::endl;
			return 1;
		}

		if (symbol_table[i].StorageClass != IMAGE_SYM_CLASS_EXTERNAL) {
			std::cerr << "Specified symbol is not external" << std::endl;
			return 1;
		}

		if (symbol_table[i].SectionNumber <= IMAGE_SYM_UNDEFINED) {
			std::cerr << "Specified symbol is not defined in any section" << std::endl;
			return 1;
		}

		SectionNumber = symbol_table[i].SectionNumber;
		SectionOffset = symbol_table[i].Value;
		break;
	}

	if (SectionNumber == IMAGE_SYM_UNDEFINED) {
		std::cerr << "Specified symbol not found" << std::endl;
		return 1;
	}

	// find section
	PIMAGE_SECTION_HEADER section_header = (PIMAGE_SECTION_HEADER)(object_base + sizeof(IMAGE_FILE_HEADER) + file_header->SizeOfOptionalHeader);
	PIMAGE_SECTION_HEADER target_section = &section_header[SectionNumber - 1]; // section numbers are 1-based

	// extract function data
	PBYTE section_data = object_base + target_section->PointerToRawData + SectionOffset;
	DWORD section_size = target_section->SizeOfRawData - SectionOffset;

	// write to file
	std::ofstream output_file(output_file_name, std::ios::binary);
	if (!output_file.is_open()) {
		std::cerr << "Failed to open output file" << std::endl;
		return 1;
	}

	output_file.write((char*)section_data, section_size);
	output_file.close();
	return 0;
}

std::string getSymbolName(PIMAGE_SYMBOL symbol, PBYTE string_table) {
	if (symbol->N.Name.Short == 0)
		return std::string((char*)(string_table + symbol->N.Name.Long));

	char short_name[9] = { 0 };
	memcpy(short_name, symbol->N.ShortName, 8);
	return std::string(short_name);
}
```

`src/stage1/CMakeLists.txt`:

```txt
add_custom_command(
    DEPENDS resource_generator fumo_drv
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.cpp ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.h
    COMMAND resource_generator $<TARGET_FILE:fumo_drv> fumo_drv_data ${CMAKE_CURRENT_BINARY_DIR}/Resources
)

add_custom_command(
    DEPENDS resource_generator stage2
    OUTPUT ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.cpp ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.h
    COMMAND resource_generator $<TARGET_FILE:stage2> stage2_data ${CMAKE_CURRENT_BINARY_DIR}/Resources
)

set(STAGE1_RESOURCES
    ${CMAKE_CURRENT_BINARY_DIR}/Resources/fumo_drv_data.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/Resources/stage2_data.cpp
)

add_library(stage1 MODULE stage1.cpp fumo_preloader.cpp ${STAGE1_RESOURCES})
target_include_directories(stage1 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include ${CMAKE_CURRENT_BINARY_DIR}/Resources)
target_compile_features(stage1 PUBLIC c_std_17 cxx_std_20)
target_compile_definitions(stage1 PRIVATE UNICODE _UNICODE)
target_compile_options(stage1 PRIVATE /O1 /GS- /sdl- /guard:cf- /Zc:threadSafeInit-)
target_link_libraries(stage1 PUBLIC ntdll libKDU driver_interface lazy_importer)
set_target_properties(stage1 PROPERTIES LIBRARY_OUTPUT_DIRECTORY ${CMAKE_RUNTIME_OUTPUT_DIRECTORY})
```

`src/stage1/fumo_preloader.cpp`:

```cpp
#include "fumo_preloader.h"
#include <libKDU.h>
#include <lazy_importer.hpp>
#include <driver_interface.h>
#include <fumo_drv_data.h>
#include <stage2_data.h>

int load_stage2(HANDLE process, std::vector<BYTE>& fumo_data) {
    // save process name in case it dies mid way through
    auto process_name = get_proces_name(process);

    // parse stage2 header
    LPVOID local_stage2_data = res::stage2_data.data();
    auto dos_header = (PIMAGE_DOS_HEADER)local_stage2_data;
    auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)local_stage2_data + dos_header->e_lfanew);

    // allocate memory for stage2 in the target process
    ULONG_PTR stage2_base = (ULONG_PTR)VirtualAllocEx(process, NULL, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (stage2_base == NULL)
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory in {}", process_name);
    
    // allocate local memory for stage2
    ULONG_PTR stage2_local_base = (ULONG_PTR)VirtualAlloc(NULL, nt_headers->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (stage2_local_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for module in {}", process_name);
    }
    
    // copy headers
    memcpy((PVOID)stage2_local_base, local_stage2_data, nt_headers->OptionalHeader.SizeOfHeaders);
    dos_header = (PIMAGE_DOS_HEADER)stage2_local_base;
    nt_headers = (PIMAGE_NT_HEADERS)(stage2_local_base + dos_header->e_lfanew);

    // map sections
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);
    for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
        auto section = &section_header[i];
        if (section->SizeOfRawData == 0)
            continue;
        auto section_data = (PVOID)((ULONG_PTR)local_stage2_data + section->PointerToRawData);
        memcpy((PVOID)(stage2_local_base + section->VirtualAddress), section_data, section->SizeOfRawData);
    }

    // relocate the image
    auto delta = (ULONG_PTR)stage2_base - nt_headers->OptionalHeader.ImageBase;
    if (delta != 0) {
        auto base_relocation = (PIMAGE_BASE_RELOCATION)(stage2_local_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
        while (base_relocation->VirtualAddress != 0) {
            auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
            auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
            for (auto i = 0; i < number_of_relocations; i++) {
                auto type = relocation[i] >> 12;
                if (type == IMAGE_REL_BASED_DIR64) {
                    auto address = (PULONG_PTR)(stage2_local_base + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += delta;
                } else if (type != IMAGE_REL_BASED_ABSOLUTE)
                    return fumo::error(ERR_STAGE1_FAILED_TO_RELOCATE_MODULE, L"Failed to relocate module");
            }
            base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
        }
    }

    // write stage2 to target process
    if (!WriteProcessMemory(process, (LPVOID)stage2_base, (LPCVOID)stage2_local_base, nt_headers->OptionalHeader.SizeOfImage, NULL)) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);   
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write stage2 to {}", process_name);
    }
    
    // free local memory
    VirtualFree((LPVOID)stage2_local_base, 0, MEM_RELEASE);

    // allocate memory for stage2 loader in the target process
    ULONG_PTR fumo_data_base = (ULONG_PTR)VirtualAllocEx(process, NULL, fumo_data.size(), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (fumo_data_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for data in {}", process_name);
    }

    // write fumo data to target process
    if (!WriteProcessMemory(process, (LPVOID)fumo_data_base, fumo_data.data(), fumo_data.size(), NULL)) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write fumo data to {}", process_name);
    }

    STAGE2_LOADER_DATA loader_data = { 0 };
    loader_data.stage2_base = (ULONG_PTR)stage2_base;
    loader_data.fumo_data_base = (ULONG_PTR)fumo_data_base;
    loader_data.loader_pid = GetCurrentProcessId();

    SIZE_T shellcode_size = (SIZE_T)stage2_loader_shellcode_end - (SIZE_T)stage2_loader_shellcode;
    SIZE_T shellcode_data_size = sizeof(STAGE2_LOADER_DATA);

    // allocate memory for shellcode in the target process
    ULONG_PTR shellcode_base = (ULONG_PTR)VirtualAllocEx(process, NULL, shellcode_size + shellcode_data_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    if (shellcode_base == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate memory for shellcode in {}", process_name);
    }

    // write shellcode to target process
    ULONG_PTR shellcode_data_base = shellcode_base + shellcode_size;
    if (
        !WriteProcessMemory(process, (LPVOID)shellcode_base, (LPCVOID)stage2_loader_shellcode, shellcode_size, NULL) ||
        !WriteProcessMemory(process, (LPVOID)shellcode_data_base, (LPCVOID)&loader_data, sizeof(STAGE2_LOADER_DATA), NULL)
    ) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_WRITE_MEMORY, L"Failed to write shellcode to {}", process_name);
    }

    // execute shellcode
    HANDLE thread = CreateRemoteThread(process, NULL, 0, (LPTHREAD_START_ROUTINE)shellcode_base, (LPVOID)shellcode_data_base, 0, NULL);
    if (thread == NULL) {
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}", process_name);
    }

    DWORD wait_result = WaitForSingleObject(thread, INFINITE);
    if (wait_result != WAIT_OBJECT_0) {
        CloseHandle(thread);
        VirtualFreeEx(process, (LPVOID)stage2_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)fumo_data_base, 0, MEM_RELEASE);
        VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}", process_name);
    }

    // get shellcode exit code
    DWORD exit_code = 0;
    GetExitCodeThread(thread, &exit_code);
    CloseHandle(thread);

    // free shellcode memory
    VirtualFreeEx(process, (LPVOID)shellcode_base, 0, MEM_RELEASE);

    // check return code
    if (exit_code != 0) {
        return fumo::error(ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE, L"Failed to execute shellcode in {}, error code: {}", process_name, exit_code);
    }

    return ERR_STAGE1_SUCCESS;
}

DWORD stage2_loader_shellcode(PSTAGE2_LOADER_DATA loader_data) {
    auto fnLoadLibraryA = LI_FN(LoadLibraryA).get();
    auto fnGetProcAddress = LI_FN(GetProcAddress).get();

    // parse stage2 header
    auto dos_header = (PIMAGE_DOS_HEADER)loader_data->stage2_base;
    auto nt_headers = (PIMAGE_NT_HEADERS)(loader_data->stage2_base + dos_header->e_lfanew);
    auto section_header = IMAGE_FIRST_SECTION(nt_headers);

    // resolve imports
    auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)(loader_data->stage2_base + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);
    while (import_descriptor->Name != 0) {
        auto module_name = (LPCSTR)(loader_data->stage2_base + import_descriptor->Name);
        auto module_base = fnLoadLibraryA(module_name);
        if (module_base == NULL)
            return 1;
        auto thunk_data = (PIMAGE_THUNK_DATA)(loader_data->stage2_base + import_descriptor->FirstThunk);
        auto import_address = (PULONG_PTR)(loader_data->stage2_base + import_descriptor->FirstThunk);
        while (thunk_data->u1.AddressOfData != 0) {
            if (thunk_data->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
                *import_address = (ULONG_PTR)fnGetProcAddress(module_base, (LPCSTR)(thunk_data->u1.Ordinal & 0xFFFF));
            }
            else {
                auto import_by_name = (PIMAGE_IMPORT_BY_NAME)(loader_data->stage2_base + thunk_data->u1.AddressOfData);
                *import_address = (ULONG_PTR)fnGetProcAddress(module_base, (LPCSTR)import_by_name->Name);
            }
            if (*import_address == NULL)
                return 2;
            thunk_data++;
            import_address++;
        }
        import_descriptor++;
    }


    // call entry point
    using fnDllMain = BOOL(WINAPI*)(HMODULE, DWORD, LPVOID);
    auto entry_point = (fnDllMain)(loader_data->stage2_base + nt_headers->OptionalHeader.AddressOfEntryPoint);
    BOOL success = entry_point((HMODULE)loader_data->stage2_base, DLL_PROCESS_ATTACH, loader_data);
    return success ? 0 : 1;
}

void stage2_loader_shellcode_end() {}

int init_driver(DWORD osBuildNumber) {
    auto driver = fumo::DriverInterface::Open(FUMO_HOOKED_DRIVER_NAME_USER);
    if (!driver.has_value())
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_DRIVER, L"Failed to open driver");

    auto& driver_ref = driver.value().get();

    auto version = driver_ref.GetVersion();
    if (!version.has_value()) {
        auto error = load_driver(osBuildNumber);
        if (error != ERR_STAGE1_SUCCESS)
            return error;

        version = driver_ref.GetVersion();
        if (!version.has_value())
            return fumo::error(ERR_STAGE1_FAILED_TO_GET_DRIVER_VERSION, L"Failed to get driver version");
    }

    if (version.value() != FUMO_DRIVER_VERSION) {
        // unload the old driver and try again
        driver_ref.Unload();
        return init_driver(osBuildNumber);
    }

    return ERR_STAGE1_SUCCESS;
}

int load_driver(DWORD osBuildNumber) {
    // FIXME: make the provider configurable
    if (!libKDUMapDriver(0, osBuildNumber, 34, 1, res::fumo_drv_data.data(), NULL, NULL))
        return fumo::error(ERR_STAGE1_FAILED_TO_MAP_DRIVER, L"Failed to map driver");

    return ERR_STAGE1_SUCCESS;
}

```

`src/stage1/fumo_preloader.h`:

```h
#pragma once
#include <util.h>
#include <fomo_common.h>
#include <vector>

#define ERR_STAGE1_SUCCESS 0
#define ERR_STAGE1_INVALID_ARGS 1
#define ERR_STAGE1_FAILED_TO_OPEN_FILE 2
#define ERR_STAGE1_FAILED_TO_GET_DEBUG_PRIVILEGES 3
#define ERR_STAGE1_UNSUPPORTED_OS 50
#define ERR_STAGE1_HVCI_ENABLED 51
#define ERR_STAGE1_FAILED_TO_MAP_DRIVER 100
#define ERR_STAGE1_FAILED_TO_OPEN_DRIVER 101
#define ERR_STAGE1_FAILED_TO_GET_DRIVER_VERSION 102
#define ERR_STAGE1_FAILED_TO_FIND_PROCESS 150
#define ERR_STAGE1_FAILED_TO_OPEN_PROCESS 151
#define ERR_STAGE1_FAILED_TO_ALLOCATE_MEMORY 200
#define ERR_STAGE1_FAILED_TO_RELOCATE_MODULE 201
#define ERR_STAGE1_FAILED_TO_WRITE_MEMORY 202
#define ERR_STAGE1_FAILED_TO_EXECUTE_SHELLCODE 203

int init_driver(DWORD osBuildNumber);
int load_driver(DWORD osBuildNumber);
std::wstring get_proces_name(HANDLE process);
DWORD find_process_by_name(LPCWSTR lpProcessName);
int load_stage2(HANDLE process, std::vector<BYTE>& fumo_data);
DWORD stage2_loader_shellcode(PSTAGE2_LOADER_DATA loader_data);
void stage2_loader_shellcode_end();
```

`src/stage1/stage1.cpp`:

```cpp
#include "fumo_preloader.h"
#include <filesystem>
#include <fstream>

bool get_debug_privileges() {
    HANDLE token;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &token))
        return false;

    LUID luid;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) {
        CloseHandle(token);
        return false;
    }

    TOKEN_PRIVILEGES privileges;
    privileges.PrivilegeCount = 1;
    privileges.Privileges[0].Luid = luid;
    privileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges(token, FALSE, &privileges, sizeof(privileges), NULL, NULL)) {
        CloseHandle(token);
        return false;
    }

    CloseHandle(token);
    return true;
}

int main(PFUMO_EMBEDDED_DATA embedded_data) {
    std::vector<BYTE> fumo_data;
    std::wstring fumo_file_path;

    int argc = 0;
    LPWSTR* argv = CommandLineToArgvW(GetCommandLineW(), &argc);

    // use embedded data if present unless a file is specified
    if (argc != 2 && embedded_data && embedded_data->Data && embedded_data->Size > 0) {
        fumo_file_path = L"embedded_data";
        fumo_data.assign((PBYTE)embedded_data->Data, (PBYTE)embedded_data->Data + embedded_data->Size);
    }
    else {
        if (argc != 2) {
            auto exe_name = std::filesystem::path(argv[0]).filename().wstring();
            return fumo::error(ERR_STAGE1_INVALID_ARGS, 
                L"Invalid arguments.\nUsage: {} <fumo_file>\nTip: you can drag the .fumo file on the loader executable",
                exe_name);
        }

        std::filesystem::path fumo_file = argv[1];
        fumo_file_path = fumo_file.wstring();
        std::ifstream fumo_stream(fumo_file, std::ios::binary);
        if (!fumo_stream.is_open())
            return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE, L"Failed to open file: {}", fumo_file_path);
        
        fumo_data.assign(std::istreambuf_iterator<char>(fumo_stream), std::istreambuf_iterator<char>());
        if (fumo_data.size() < sizeof(FUMO_DATA_HEADER) + 0x1000) // header + one page
            return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE, L"File to small: {}", fumo_file_path);
    }

    PFUMO_DATA_HEADER header = (PFUMO_DATA_HEADER)fumo_data.data();

    // check magic
    if (header->Magic != FUMO_MAGIC)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE,
            L"Invalid file format: {}\nTip: use fumo_encoder to generate a .fumo file", fumo_file_path);
    
    // check version
    if (header->Version != FUMO_DATA_VERSION)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_FILE,
            L"Invalid file version (expected: {}, found: {}): {}\nTip: use fumo_encoder to generate a .fumo file",
            fumo_file_path, FUMO_DATA_VERSION, header->Version);

    OSVERSIONINFO osv;
    osv.dwOSVersionInfoSize = sizeof(osv);
    RtlGetVersion((PRTL_OSVERSIONINFOW)&osv);

    if (osv.dwMajorVersion < MIN_OS_MAJOR_VERSION || osv.dwBuildNumber < MIN_OS_BUILD_NUMBER)
        return fumo::error(ERR_STAGE1_UNSUPPORTED_OS, L"Unsupported OS version: {}.{}.{}", osv.dwMajorVersion, osv.dwMinorVersion, osv.dwBuildNumber);

    if (isHvciEnabled())
        return fumo::error(ERR_STAGE1_HVCI_ENABLED, L"HyperVisor Code Integrity (HVCI) is enabled, please disable it and try again");
    
    if(!get_debug_privileges())
        return fumo::error(ERR_STAGE1_FAILED_TO_GET_DEBUG_PRIVILEGES, L"Failed to get debug privileges");

    auto error = init_driver(osv.dwBuildNumber);
    if (error != ERR_STAGE1_SUCCESS)
        return error;
    
    auto pid = find_process_by_name(FUMO_SECOND_STAGE_PROCESS_NAME);
    if (pid == 0)
        return fumo::error(ERR_STAGE1_FAILED_TO_FIND_PROCESS, L"Failed to find {}", FUMO_SECOND_STAGE_PROCESS_NAME);
    
    auto process = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (process == NULL)
        return fumo::error(ERR_STAGE1_FAILED_TO_OPEN_PROCESS, L"Failed to open {}", FUMO_SECOND_STAGE_PROCESS_NAME);
    
    error = load_stage2(process, fumo_data);
    CloseHandle(process);

    return error;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason != DLL_PROCESS_ATTACH)
        return 0;

    return main((PFUMO_EMBEDDED_DATA)lpvReserved) == ERR_STAGE1_SUCCESS;
}
```

`src/stage2/CMakeLists.txt`:

```txt
add_library(stage2 MODULE stage2.cpp fumo_loader.cpp tray_icon.cpp)
target_include_directories(stage2 PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/../include)
target_compile_features(stage2 PUBLIC c_std_17 cxx_std_20)
target_compile_options(stage2 PRIVATE /O1 /GS- /sdl- /guard:cf- /Zc:threadSafeInit-)
target_compile_definitions(stage2 PRIVATE UNICODE _UNICODE)
target_link_libraries(stage2 PRIVATE driver_interface)
```

`src/stage2/fumo_loader.cpp`:

```cpp
#include "fumo_loader.h"
#include "stage2.h"
#include <driver_interface.h>

using fnLdrLoadDll = NTSTATUS(NTAPI*)(PWCHAR PathToFile, ULONG Flags, PUNICODE_STRING ModuleFileName, HMODULE* ModuleHandle);
using fnLdrGetProcedureAddress = NTSTATUS(NTAPI*)(HMODULE ModuleHandle, PANSI_STRING FunctionName, WORD Ordinal, PVOID* FunctionAddress);
using fnRtlAnsiStringToUnicodeString = decltype(&RtlAnsiStringToUnicodeString);
using fnDllMain = BOOL(WINAPI*)(HMODULE hModule, DWORD dwReason, LPVOID lpReserved);

typedef struct _MANUAL_MAPPING_DATA {
	PVOID ImageBase;
	fnLdrLoadDll LdrLoadDll;
	fnLdrGetProcedureAddress LdrGetProcedureAddress;
	fnRtlAnsiStringToUnicodeString RtlAnsiStringToUnicodeString;
} MANUAL_MAPPING_DATA, *PMANUAL_MAPPING_DATA;

MANUAL_MAPPING_DATA GetManualMappingData(PVOID pImageBase) {
	HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");

	MANUAL_MAPPING_DATA data = {0};
	data.ImageBase = pImageBase;
	data.LdrLoadDll = (fnLdrLoadDll)GetProcAddress(hNtdll, "LdrLoadDll");
	data.LdrGetProcedureAddress = (fnLdrGetProcedureAddress)GetProcAddress(hNtdll, "LdrGetProcedureAddress");
	data.RtlAnsiStringToUnicodeString = (fnRtlAnsiStringToUnicodeString)GetProcAddress(hNtdll, "RtlAnsiStringToUnicodeString");
	return data;
}

DWORD Shellcode(PMANUAL_MAPPING_DATA pMmData) {
	// resolve imports
	auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)pMmData->ImageBase + ((PIMAGE_DOS_HEADER)pMmData->ImageBase)->e_lfanew);
	auto import_descriptor = (PIMAGE_IMPORT_DESCRIPTOR)((ULONG_PTR)pMmData->ImageBase + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress);

	while (import_descriptor->Name != 0) {
		auto module_name = (PCHAR)((ULONG_PTR)pMmData->ImageBase + import_descriptor->Name);

		USHORT module_name_length = 0;
		while (module_name[module_name_length] != 0)
			module_name_length++;

		ANSI_STRING ansi_module_name = {0};
		ansi_module_name.Buffer = module_name;
		ansi_module_name.Length = module_name_length;
		ansi_module_name.MaximumLength = module_name_length + 1;

		UNICODE_STRING unicode_module_name = {0};
		pMmData->RtlAnsiStringToUnicodeString(&unicode_module_name, &ansi_module_name, TRUE);

		HMODULE module_handle = nullptr;
		pMmData->LdrLoadDll(nullptr, 0, &unicode_module_name, &module_handle);

		auto original_first_thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)pMmData->ImageBase + import_descriptor->OriginalFirstThunk);
		auto first_thunk = (PIMAGE_THUNK_DATA)((ULONG_PTR)pMmData->ImageBase + import_descriptor->FirstThunk);

		while (original_first_thunk->u1.AddressOfData != 0) {
			auto import_by_name = (PIMAGE_IMPORT_BY_NAME)((ULONG_PTR)pMmData->ImageBase + original_first_thunk->u1.AddressOfData);
			auto function_name = (PCHAR)import_by_name->Name;

			USHORT function_name_length = 0;
			while (function_name[function_name_length] != 0)
				function_name_length++;

			ANSI_STRING ansi_function_name = {0};
			ansi_function_name.Buffer = function_name;
			ansi_function_name.Length = function_name_length;
			ansi_function_name.MaximumLength = function_name_length + 1;

			PVOID function_address = nullptr;
			pMmData->LdrGetProcedureAddress(module_handle, &ansi_function_name, 0, &function_address);

			first_thunk->u1.Function = (ULONG_PTR)function_address;

			original_first_thunk++;
			first_thunk++;
		}

		import_descriptor++;
	}

	// call entry point
	auto entry_point = (fnDllMain)((ULONG_PTR)pMmData->ImageBase + nt_headers->OptionalHeader.AddressOfEntryPoint);
	entry_point((HMODULE)pMmData->ImageBase, DLL_PROCESS_ATTACH, nullptr);

	return 0;
}

VOID Shellcode_End() {}

int MapImage(fumo::DriverInterface* pDriver, ULONG pid, PVOID pImage) {
	// parse the PE header
	auto dos_header = (PIMAGE_DOS_HEADER)pImage;
	if (dos_header->e_magic != IMAGE_DOS_SIGNATURE)
		return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

	// parse the NT header
	auto nt_headers = (PIMAGE_NT_HEADERS)((ULONG_PTR)pImage + dos_header->e_lfanew);
	if (nt_headers->Signature != IMAGE_NT_SIGNATURE)
		return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

	// make sure the image is 64-bit
	if (nt_headers->FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64)
		return fumo::error(ERR_STAGE2_INVALID_PE_HEADER, L"Invalid PE header");

	ULONG size_of_shellcode = (ULONG)((SIZE_T)Shellcode_End - (SIZE_T)Shellcode);
	ULONG size_of_shellcode_data = sizeof(MANUAL_MAPPING_DATA);
	auto size_of_image = nt_headers->OptionalHeader.SizeOfImage;
	auto size_of_mapping = size_of_image + size_of_shellcode + size_of_shellcode_data;

	auto kernel_image = pDriver->AllocateKernelMemory(size_of_mapping);
    if (!kernel_image)
        return fumo::error(ERR_STAGE2_FAILED_TO_ALLOCATE_MEMORY, L"Failed to allocate kernel memory");

	// copy headers
	memcpy(kernel_image, pImage, nt_headers->OptionalHeader.SizeOfHeaders);

	// map sections
	auto section_header = IMAGE_FIRST_SECTION(nt_headers);
	for (auto i = 0; i < nt_headers->FileHeader.NumberOfSections; i++) {
		auto section = &section_header[i];
		if (section->SizeOfRawData == 0)
			continue;
		auto section_data = (PVOID)((ULONG_PTR)pImage + section->PointerToRawData);
		memcpy((PVOID)((ULONG_PTR)kernel_image + section->VirtualAddress), section_data, section->SizeOfRawData);
	}

	// relocate the image
	auto delta = (ULONG_PTR)kernel_image - nt_headers->OptionalHeader.ImageBase;
	if (delta != 0) {
		auto base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)kernel_image + nt_headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress);
		while (base_relocation->VirtualAddress != 0) {
			auto relocation = (PWORD)((ULONG_PTR)base_relocation + sizeof(IMAGE_BASE_RELOCATION));
			auto number_of_relocations = (base_relocation->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
			for (auto i = 0; i < number_of_relocations; i++) {
				if (relocation[i] >> 12 == IMAGE_REL_BASED_DIR64) {
					auto address = (PULONG_PTR)((ULONG_PTR)kernel_image + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
					*address += delta;
				} 
                else if (relocation[i] >> 12 == IMAGE_REL_BASED_HIGHLOW) {
                    auto address = (PULONG)((ULONG_PTR)kernel_image + base_relocation->VirtualAddress + (relocation[i] & 0xFFF));
                    *address += (ULONG)delta;
                }
                else if (relocation[i] >> 12 != IMAGE_REL_BASED_ABSOLUTE)
                    return fumo::error(ERR_STAGE2_FAILED_TO_MAP_FILE, L"Failed to map file (unsupported relocation type)");
			}
			base_relocation = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)base_relocation + base_relocation->SizeOfBlock);
		}
	}

	// write the shellcode
	auto shellcode_addr = (PVOID)((ULONG_PTR)kernel_image + size_of_image);
	memcpy(shellcode_addr, Shellcode, size_of_shellcode);

	// write the manual mapping data
	auto ManualMappingData = GetManualMappingData(kernel_image);
	auto manual_mapping_data_addr = (PMANUAL_MAPPING_DATA)((ULONG_PTR)shellcode_addr + size_of_shellcode);
	memcpy(manual_mapping_data_addr, &ManualMappingData, size_of_shellcode_data);

	if (!pDriver->ExposeKernelMemory(pid, kernel_image, size_of_mapping))
		return fumo::error(ERR_STAGE2_FAILED_TO_EXPOSE_MEMORY, L"Failed to expose kernel memory");

	if (!pDriver->ExecuteCode(pid, shellcode_addr, manual_mapping_data_addr))
		return fumo::error(ERR_STAGE2_FAILED_TO_EXECUTE, L"Failed to execute code");

	return ERR_STAGE2_SUCCESS;
}

```

`src/stage2/fumo_loader.h`:

```h
#include <util.h>
#include <driver_interface.h>

int MapImage(fumo::DriverInterface* pDriver, ULONG pid, PVOID pImage);
```

`src/stage2/stage2.cpp`:

```cpp
#include "stage2.h"
#include "fumo_loader.h"
#include "tray_icon.h"
#include <fomo_common.h>
#include <driver_interface.h>
#include <util.h>
#include <sstream>

std::wstring loader_process_name = L"";
STAGE2_LOADER_DATA loader_data;
TrayIcon* tray_icon = NULL;

int main(HANDLE loader_process) {
    // wait for the loader process to exit
    DWORD wait_result = tray_icon->wait_for_object(loader_process, INFINITE, L"Waiting for loader process to exit");
    if (wait_result != WAIT_OBJECT_0)
        return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS, L"Failed to wait for loader process({}): {}", loader_process_name, wait_result);
    CloseHandle(loader_process);
    
    // delete the loader executable
    if (!DeleteFileW(loader_process_name.c_str()))
        return fumo::error(ERR_STAGE2_FAILED_TO_DELETE_LOADER, L"Failed to delete loader executable: {}", loader_process_name);
    
    auto driver = fumo::DriverInterface::Open(FUMO_HOOKED_DRIVER_NAME_USER);
    if (!driver.has_value())
        return fumo::error(ERR_STAGE2_FAILED_TO_OPEN_DRIVER, L"Failed to open driver");

    auto& driver_ref = driver.value().get();

    auto driver_version = driver_ref.GetVersion();
    if (!driver_version.has_value())
        return fumo::error(ERR_STAGE2_FAILED_TO_OPEN_DRIVER, L"Failed to get driver version");

    if (driver_version.value() != FUMO_DRIVER_VERSION)
        return fumo::error(ERR_STAGE2_INVALID_DRIVER_VERSION, L"Invalid driver version (expected: {}, found: {})", FUMO_DRIVER_VERSION, driver_version.value());
    
    PFUMO_DATA_HEADER header = (PFUMO_DATA_HEADER)loader_data.fumo_data_base;

    // check magic
    if (header->Magic != FUMO_MAGIC)
        return fumo::error(ERR_STAGE2_INVALID_MAGIC, L"Invalid data format", loader_process_name);
    
    // check version
    if (header->Version != FUMO_DATA_VERSION)
        return fumo::error(ERR_STAGE2_INVALID_VERSION, L"Invalid data version", loader_process_name);
    
    // decrypt the settings
    PBYTE settings_data = (PBYTE)header + sizeof(FUMO_DATA_HEADER);
    uint64_t xor_key = header->XorKey;
    for (int i = 0; i < header->SettingsSize; i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&settings_data[i];
        *ptr ^= xor_key;
    }

    // parse the settings
    DWORD settings_size = *(DWORD*)settings_data;
    settings_data += sizeof(DWORD);
    std::string settings((char*)settings_data, settings_size);
    std::stringstream settings_stream(settings);
    
    std::string process_name;
    std::string wait_for_modules_string;
    std::getline(settings_stream, process_name, ';');
    std::getline(settings_stream, wait_for_modules_string, ';');
    
    std::vector<std::string> wait_for_modules = split(wait_for_modules_string, ',');

    tray_icon->send_notification(L"Ready");

    std::wstring process_name_w = convert_to_wstring(process_name);
    WAIT_FOR_PROCESS_DATA wait_for_process_data;
    wait_for_process_data.process_id = 0;
    wait_for_process_data.process_name = process_name_w.c_str();
    wait_for_process_data.cancel_event = CreateEventW(NULL, TRUE, FALSE, NULL);

    HANDLE hThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
        WAIT_FOR_PROCESS_DATA* data = (WAIT_FOR_PROCESS_DATA*)lpParam;
        while (true) {
            data->process_id = find_process_by_name(data->process_name);
            if (data->process_id > 0)
                return 0;
            if (WaitForSingleObject(data->cancel_event, 100) == WAIT_TIMEOUT)
                continue;
            return 1;
        };
    }, &wait_for_process_data, 0, NULL);
    if (hThread == NULL)
        return fumo::error(ERR_STAGE2_FAILED_TO_CREATE_THREAD, L"Failed to create thread");

    // wait for the process to start
    std::wstring message = std::wstring(L"Waiting for ") + process_name_w;
    wait_result = tray_icon->wait_for_object(hThread, INFINITE, message.c_str());
    if (wait_result != WAIT_OBJECT_0) {
        SetEvent(wait_for_process_data.cancel_event); // cancel the wait
        WaitForSingleObject(hThread, INFINITE); // wait for the thread to exit
        CloseHandle(hThread);
        CloseHandle(wait_for_process_data.cancel_event);
        return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS, L"Failed to wait for process({}): {}", process_name_w, wait_result);
    }
    CloseHandle(hThread);
    CloseHandle(wait_for_process_data.cancel_event);

    auto process_id = wait_for_process_data.process_id;

    // wait for all modules to be loaded
    for (auto& module : wait_for_modules) {
        std::wstring module_name = convert_to_wstring(module);
        WAIT_FOR_MODULE_DATA wait_for_module_data;
        wait_for_module_data.driver_interface = &driver_ref;
        wait_for_module_data.process_id = process_id;
        wait_for_module_data.module_base = 0;
        wait_for_module_data.module_name = module_name.c_str();
        wait_for_module_data.cancel_event = CreateEventW(NULL, TRUE, FALSE, NULL);

        HANDLE hThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
            WAIT_FOR_MODULE_DATA* data = (WAIT_FOR_MODULE_DATA*)lpParam;
            while (true) {
                if (!data->driver_interface->FindModule(data->process_id, data->module_name, &data->module_base))
                    return 2;
                if (data->module_base)
                    return 0;
                if (WaitForSingleObject(data->cancel_event, 100) == WAIT_TIMEOUT)
                    continue;
                return 1;
            };
        }, &wait_for_module_data, 0, NULL);

        if (hThread == NULL)
            return fumo::error(ERR_STAGE2_FAILED_TO_CREATE_THREAD, L"Failed to create thread");
        
        // wait for the module to be loaded
        std::wstring message = std::wstring(L"Waiting for ") + module_name;
        wait_result = tray_icon->wait_for_object(hThread, INFINITE, message.c_str());
        if (wait_result != WAIT_OBJECT_0) {
            SetEvent(wait_for_module_data.cancel_event); // cancel the wait
            WaitForSingleObject(hThread, INFINITE); // wait for the thread to exit
            CloseHandle(hThread);
            CloseHandle(wait_for_module_data.cancel_event);
            return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE, L"Failed to wait for module({}): {}", module_name, wait_result);
        }
        DWORD exit_code = 3;
        GetExitCodeThread(hThread, &exit_code);
        CloseHandle(hThread);
        CloseHandle(wait_for_module_data.cancel_event);

        if (exit_code != 0)
            return fumo::error(ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE, L"Failed to wait for module error ({}): {}", module_name, exit_code);
    }

    // decrypt the data
    PBYTE data = (PBYTE)header + sizeof(FUMO_DATA_HEADER) + header->SettingsSize;
    for (int i = 0; i < header->DataSize; i += sizeof(xor_key)) {
        uint64_t* ptr = (uint64_t*)&data[i];
        *ptr ^= xor_key;
    }

    // let the magic happen
    auto error = MapImage(&driver_ref, process_id, data);
    if (error != ERROR_SUCCESS)
        return error;
    
    tray_icon->clear_notification();
    tray_icon->send_notification(L"Injected");

    return ERR_STAGE2_SUCCESS;
}

DWORD stage2(LPVOID lpThreadParameter) {
    tray_icon = new TrayIcon(L"Fumo Loader");
    auto res = main((HANDLE)lpThreadParameter);
    VirtualFree((LPVOID)loader_data.fumo_data_base, 0, MEM_RELEASE);
    delete tray_icon;
    return res;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason != DLL_PROCESS_ATTACH || lpvReserved == NULL)
        return FALSE;
    
    // copy the loader data since the one we get will be freed by the stage1 loader
    memcpy(&loader_data, lpvReserved, sizeof(STAGE2_LOADER_DATA));

    // open the loader process
    HANDLE loader_process = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION | SYNCHRONIZE, FALSE, loader_data.loader_pid);
    if (loader_process == NULL) {
        fumo::error(ERR_STAGE2_FAILED_TO_OPEN_PROCESS, L"Failed to open loader process: {}", loader_data.loader_pid);
        return FALSE;
    }
    
    // get the loader process name here since it will not be available after the loader process exits
    loader_process_name = get_proces_name(loader_process);

    // main loader thread
    HANDLE hThread = CreateThread(NULL, 0, stage2, (LPVOID)loader_process, 0, NULL);
    if (hThread == NULL)
        return FALSE;
    
    CloseHandle(hThread);
    return TRUE;
}
```

`src/stage2/stage2.h`:

```h
#pragma once
#include <Windows.h>
#include <stdint.h>
#include <driver_interface.h>

#define ERR_STAGE2_SUCCESS 0
#define ERR_STAGE2_FAILED_TO_OPEN_PROCESS 50
#define ERR_STAGE2_FAILED_TO_WAIT_FOR_PROCESS 51
#define ERR_STAGE2_FAILED_TO_DELETE_LOADER 52
#define ERR_STAGE2_FAILED_TO_OPEN_DRIVER 53
#define ERR_STAGE2_INVALID_DRIVER_VERSION 54
#define ERR_STAGE2_INVALID_MAGIC 100
#define ERR_STAGE2_INVALID_VERSION 101
#define ERR_STAGE2_FAILED_TO_CREATE_THREAD 102
#define ERR_STAGE2_FAILED_TO_WAIT_FOR_MODULE 103
#define ERR_STAGE2_INVALID_PE_HEADER 200
#define ERR_STAGE2_FAILED_TO_ALLOCATE_MEMORY 201
#define ERR_STAGE2_FAILED_TO_MAP_FILE 202
#define ERR_STAGE2_FAILED_TO_EXPOSE_MEMORY 203
#define ERR_STAGE2_FAILED_TO_EXECUTE 204

typedef struct _WAIT_FOR_PROCESS_DATA {
    LPCWSTR process_name;
    DWORD process_id;
    HANDLE cancel_event;
} WAIT_FOR_PROCESS_DATA, *PWAIT_FOR_PROCESS_DATA;

typedef struct _WAIT_FOR_MODULE_DATA {
    fumo::DriverInterface* driver_interface;
    LPCWSTR module_name;
    DWORD process_id;
    PVOID module_base;
    HANDLE cancel_event;
} WAIT_FOR_MODULE_DATA, *PWAIT_FOR_MODULE_DATA;
```

`src/stage2/tray_icon.cpp`:

```cpp
#include "tray_icon.h"
#include <array>

// forward declaration for the icon data
extern std::array<BYTE, 588> icon_data;

LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam) {
    switch (msg) {
    case WM_CREATE: {
        // save the tray icon pointer in the window data
        CREATESTRUCTW* create_struct = (CREATESTRUCTW*)lParam;
        SetWindowLongPtrW(hwnd, GWLP_USERDATA, (LONG_PTR)create_struct->lpCreateParams);

        TrayIcon* tray_icon = (TrayIcon*)create_struct->lpCreateParams;
        tray_icon->create_icon(hwnd);
        break;
    }
    case WM_USER + 1: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        if (lParam == WM_LBUTTONDOWN)
            tray_icon->cancel_wait();
        break;
    }
    case WM_USER + 2: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        tray_icon->set_icon_message((LPCWSTR)lParam);
        break;
    }
    case WM_DESTROY: {
        TrayIcon* tray_icon = (TrayIcon*)GetWindowLongPtrW(hwnd, GWLP_USERDATA);
        tray_icon->destroy_icon();
        PostQuitMessage(0);
        break;
    }
    default:
        return DefWindowProcW(hwnd, msg, wParam, lParam);
    }
    return 0;
}

TrayIcon::TrayIcon(std::wstring name) : name(name) {
    hInstance = GetModuleHandle(NULL);
    // create the cancel event
    hCancelEvent = CreateEventW(NULL, TRUE, FALSE, NULL);

    // randomize the window class name
    srand(GetTickCount64());
    for (int i = 0; i < 16; i++)
        window_class_name += (wchar_t)(L'A' + rand() % 26);
    
    // start the tray icon message loop in a new thread
    HANDLE hThread = CreateThread(NULL, 0, [](LPVOID lpParam) -> DWORD {
        TrayIcon* tray_icon = (TrayIcon*)lpParam;

        // Register the window class
        WNDCLASSEXW wc = {};
        wc.cbSize = sizeof(WNDCLASSEXW);
        wc.lpfnWndProc = WindowProc;
        wc.hInstance = tray_icon->hInstance;
        wc.lpszClassName = tray_icon->window_class_name.c_str();
        RegisterClassExW(&wc);

        // Create the window (it won't be visible)
        tray_icon->hwnd = CreateWindowExW(0, wc.lpszClassName, L"", 0, 0, 0, 0, 0, NULL, NULL, tray_icon->hInstance, lpParam);
        if (tray_icon->hwnd == NULL)
            return 1;

        // signal that the window has been created
        SetEvent(tray_icon->hCancelEvent);

        // Message loop
        MSG msg = {};
        while (GetMessageW(&msg, NULL, 0, 0)) {
            TranslateMessage(&msg);
            DispatchMessageW(&msg);
        }

        // unregister the window class
        UnregisterClassW(tray_icon->window_class_name.c_str(), tray_icon->hInstance);

        return (DWORD)msg.wParam;
    }, this, 0, NULL);

    // wait for the window to be created or for the thread to exit
    HANDLE handles[2] = { hCancelEvent, hThread };
    DWORD wait_result = WaitForMultipleObjects(2, handles, FALSE, INFINITE);
    CloseHandle(hThread);
    ResetEvent(hCancelEvent);

    if (wait_result != WAIT_OBJECT_0) {
        // the thread exited, so we failed to create the window
        hwnd = NULL;
    }
}

TrayIcon::~TrayIcon() {
    destroy();
}

void TrayIcon::destroy() {
    CloseHandle(hCancelEvent);
    if (hwnd != NULL)
        PostMessageW(hwnd, WM_CLOSE, 0, 0);
}

void TrayIcon::create_icon(HWND hwnd) {
    HICON hIcon = CreateIconFromResourceEx(icon_data.data(), icon_data.size(), TRUE, 0x00030000, 0, 0, LR_DEFAULTCOLOR);
    if (hIcon == NULL)
        return;

    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_ICON | NIF_TIP | NIF_MESSAGE;
    nid.uCallbackMessage = WM_USER + 1;
    nid.hIcon = hIcon;
    wcscpy_s(nid.szTip, name.c_str());
    Shell_NotifyIconW(NIM_ADD, &nid);
}

void TrayIcon::destroy_icon() {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    Shell_NotifyIconW(NIM_DELETE, &nid);
}

void TrayIcon::set_icon_message(LPCWSTR lpMessage) {
    std::wstring tooltip = name;
    if (lpMessage != NULL)
        tooltip += L"\n" + std::wstring(lpMessage);

    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_TIP;
    wcscpy_s(nid.szTip, tooltip.c_str());
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::clear_notification() {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_INFO;
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::send_notification(LPCWSTR lpMessage) {
    NOTIFYICONDATAW nid = {};
    nid.cbSize = sizeof(NOTIFYICONDATAW);
    nid.hWnd = hwnd;
    nid.uID = uID;
    nid.uFlags = NIF_INFO;
    wcscpy_s(nid.szInfo, lpMessage);
    wcscpy_s(nid.szInfoTitle, name.c_str());
    Shell_NotifyIconW(NIM_MODIFY, &nid);
}

void TrayIcon::cancel_wait() {
    // signal the cancel event
    SetEvent(hCancelEvent);
}

// this function waits for an object to be signaled or for the user to click on the tray icon that will cancel the wait using WaitForMultipleObjects
DWORD TrayIcon::wait_for_object(HANDLE hHandle, DWORD dwMilliseconds, LPCWSTR lpMessage) {
    // reset the cancel event
    ResetEvent(hCancelEvent);

    // set tray icon tooltip
    std::wstring message = std::wstring(lpMessage) + L"\nClick to cancel";
    PostMessageW(hwnd, WM_USER + 2, 0, (LPARAM)message.c_str());

    // wait for the object to be signaled or for the cancel event to be signaled
    HANDLE handles[2] = { hHandle, hCancelEvent };
    DWORD wait_result = WaitForMultipleObjects(2, handles, FALSE, dwMilliseconds);

    // reset the tray icon tooltip
    PostMessageW(hwnd, WM_USER + 2, 0, (LPARAM)NULL);

    return wait_result;
}

// credit: https://www.pixiv.net/en/artworks/35678304
std::array<BYTE, 588> icon_data = {
	0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D,
	0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x10,
	0x08, 0x06, 0x00, 0x00, 0x00, 0x1F, 0xF3, 0xFF, 0x61, 0x00, 0x00, 0x02,
	0x13, 0x49, 0x44, 0x41, 0x54, 0x38, 0x8D, 0x75, 0x93, 0x4F, 0x48, 0x93,
	0x61, 0x1C, 0xC7, 0x3F, 0x6F, 0x86, 0x90, 0x50, 0xD0, 0x14, 0x1B, 0xEF,
	0xD8, 0x96, 0x10, 0x8B, 0xE1, 0xE5, 0x15, 0xB6, 0xAC, 0x76, 0x58, 0x12,
	0x0C, 0x07, 0x03, 0xC3, 0x18, 0xCE, 0x53, 0x78, 0xC9, 0x6E, 0x21, 0x78,
	0x90, 0xBA, 0xBC, 0x05, 0x75, 0x69, 0x20, 0x81, 0x87, 0xD5, 0xC1, 0xB0,
	0x93, 0x30, 0xC3, 0xA2, 0xE1, 0x20, 0x26, 0xEC, 0x64, 0x5B, 0x1B, 0xEC,
	0x39, 0x28, 0x4E, 0x3B, 0xC4, 0x16, 0x0E, 0x32, 0x6C, 0x0E, 0xC1, 0xC3,
	0x7B, 0x79, 0x3A, 0xD8, 0x5E, 0x7D, 0x5F, 0xF3, 0x0B, 0x0F, 0x3C, 0x7F,
	0x7E, 0xDF, 0xDF, 0xF3, 0x7C, 0xBF, 0xBF, 0xDF, 0xA3, 0x68, 0xC0, 0x9B,
	0xE2, 0x4F, 0xE9, 0x78, 0xF9, 0x98, 0x93, 0xC8, 0x94, 0xCB, 0x2C, 0xEC,
	0xD4, 0x95, 0x07, 0x2E, 0x8F, 0x8C, 0x05, 0x02, 0x96, 0xB3, 0x3F, 0x4F,
	0x5E, 0x33, 0x39, 0xE8, 0x56, 0x00, 0x14, 0x0D, 0xF8, 0x66, 0x18, 0xB2,
	0x16, 0x4F, 0x90, 0x29, 0x97, 0x01, 0xB8, 0x1C, 0xB9, 0x85, 0x1D, 0xCD,
	0x2F, 0x5F, 0x01, 0x88, 0x05, 0x02, 0x78, 0xD3, 0x8B, 0xDC, 0xE8, 0xEC,
	0x54, 0x00, 0x3A, 0x9C, 0xC0, 0xEF, 0x0E, 0xB7, 0x5E, 0xCF, 0x2C, 0x52,
	0xEB, 0xBD, 0x40, 0x5F, 0x28, 0x88, 0x10, 0x02, 0xA7, 0xD3, 0x69, 0x92,
	0x85, 0x10, 0xF4, 0x85, 0x82, 0x6C, 0x1D, 0xEC, 0xB1, 0xFB, 0xBD, 0x4E,
	0xEE, 0xF0, 0x12, 0xD5, 0xFC, 0xE7, 0x67, 0xE6, 0x0B, 0xF8, 0x27, 0x63,
	0x33, 0x35, 0x8D, 0x10, 0x02, 0x4D, 0xD3, 0xB0, 0xA3, 0xBD, 0xEF, 0x7F,
	0x94, 0x34, 0x9F, 0x0F, 0x70, 0xAE, 0x3D, 0x99, 0x1C, 0x74, 0x2B, 0xED,
	0xA0, 0xB0, 0xB7, 0x89, 0x10, 0xC2, 0x24, 0x86, 0xBD, 0x4D, 0x34, 0x4D,
	0x43, 0x08, 0x61, 0x21, 0x5B, 0x12, 0x00, 0x72, 0x3C, 0x95, 0x23, 0xEC,
	0x6D, 0x32, 0xB6, 0xB2, 0xCF, 0xCC, 0xD4, 0x10, 0x42, 0x08, 0x66, 0xA6,
	0x86, 0x18, 0x5B, 0xD9, 0x27, 0xEC, 0x6D, 0x32, 0x9E, 0xCA, 0x01, 0xC8,
	0xB3, 0x12, 0xB0, 0x36, 0x1A, 0xC2, 0x31, 0x9C, 0x00, 0xA0, 0x7B, 0x64,
	0x82, 0x57, 0xF9, 0xF7, 0x74, 0x8F, 0x4C, 0x00, 0xE0, 0x18, 0x4E, 0xB0,
	0x36, 0x1A, 0x3A, 0x25, 0xCD, 0x92, 0x20, 0x16, 0x08, 0xD0, 0xE5, 0xEF,
	0x3F, 0x15, 0x04, 0xD0, 0xE5, 0xEF, 0xC7, 0x5E, 0x4E, 0x38, 0x61, 0x22,
	0x1C, 0x97, 0xF3, 0xE2, 0xFD, 0x5E, 0xF3, 0x66, 0x80, 0xBD, 0x4F, 0xEF,
	0x38, 0xF8, 0xB0, 0x6B, 0x29, 0x9F, 0x09, 0xCD, 0x3A, 0x64, 0xAB, 0x30,
	0x2F, 0x67, 0x5D, 0x1E, 0x69, 0x18, 0x86, 0xFC, 0xA1, 0x47, 0xA4, 0x61,
	0x18, 0x72, 0xD6, 0xE5, 0x91, 0xAD, 0xC2, 0xBC, 0xD4, 0x40, 0xDA, 0xE2,
	0x8F, 0x25, 0x2C, 0xEB, 0x11, 0x59, 0x6A, 0x15, 0x59, 0x4D, 0xEA, 0x00,
	0xD4, 0xE2, 0x09, 0xAE, 0x3E, 0xF4, 0x50, 0x8B, 0x1F, 0x79, 0xB2, 0x9A,
	0xD4, 0x29, 0xB5, 0x8A, 0x2C, 0xEB, 0x11, 0x8B, 0x89, 0xE7, 0xDB, 0x93,
	0xCA, 0x7A, 0x15, 0xC7, 0xE6, 0x06, 0xCF, 0x97, 0xEA, 0x00, 0xF8, 0x54,
	0x95, 0x6B, 0x38, 0xD8, 0x6E, 0x34, 0x58, 0xD8, 0xA9, 0xC3, 0x12, 0xDC,
	0x9D, 0xDE, 0xA0, 0xB2, 0x5E, 0x3D, 0xD3, 0x03, 0xF9, 0x22, 0x78, 0x93,
	0xED, 0x46, 0xE3, 0xBF, 0x66, 0x65, 0xCA, 0x65, 0x7C, 0xAA, 0xCA, 0xD3,
	0x52, 0x01, 0xE0, 0x74, 0x23, 0x01, 0x4A, 0xCF, 0x5C, 0x1A, 0x9F, 0xAA,
	0x9A, 0x7F, 0xC2, 0x4E, 0xEE, 0x99, 0x4B, 0x5B, 0xC8, 0x16, 0x09, 0x70,
	0xD4, 0x8D, 0xF7, 0xF4, 0xB7, 0x32, 0x1A, 0x8D, 0xE2, 0x1D, 0xB8, 0x62,
	0xEE, 0xDF, 0xAE, 0xFC, 0x22, 0x9B, 0xCD, 0xF2, 0xD1, 0xD6, 0x85, 0x76,
	0x09, 0xA6, 0x94, 0x3B, 0x03, 0xD7, 0xC9, 0x57, 0xB6, 0xDA, 0xB7, 0xD9,
	0xD7, 0x16, 0xFC, 0x05, 0xF8, 0xB0, 0xD2, 0x53, 0xA7, 0x42, 0x1B, 0x26,
	0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82
};

```

`src/stage2/tray_icon.h`:

```h
#pragma once
#include <Windows.h>
#include <string>

class TrayIcon {
private:
    std::wstring name = L"";
    HINSTANCE hInstance = NULL;
    std::wstring window_class_name = L"";
    HWND hwnd = NULL;
    UINT uID = 1;
    HANDLE hCancelEvent = NULL;
public:
    TrayIcon(std::wstring name);
    ~TrayIcon();
    void create_icon(HWND hwnd);
    void destroy_icon();
    void set_icon_message(LPCWSTR lpMessage);
    void clear_notification();
    void send_notification(LPCWSTR lpMessage);
    void cancel_wait();
    void destroy();
    
    DWORD wait_for_object(HANDLE hHandle, DWORD dwMilliseconds, LPCWSTR lpMessage);
};

```