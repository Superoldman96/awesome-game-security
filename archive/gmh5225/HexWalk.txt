Project Path: arc_gmh5225_HexWalk_lf6xkky7

Source Tree:

```txt
arc_gmh5225_HexWalk_lf6xkky7
├── LICENSE
├── README.md
├── binwalk_windows
│   ├── binw.py
│   └── binwalk-2.1.1
│       ├── API.md
│       ├── INSTALL.md
│       ├── LICENSE
│       ├── README.md
│       ├── deps.sh
│       ├── images
│       │   ├── README.md
│       │   ├── binwalk_ida_plugin_output.png
│       │   └── binwalk_ida_plugin_usage.png
│       ├── setup.py
│       └── src
│           ├── binwalk
│           │   ├── __init__.py
│           │   ├── config
│           │   │   └── extract.conf
│           │   ├── core
│           │   │   ├── C.py
│           │   │   ├── __init__.py
│           │   │   ├── common.py
│           │   │   ├── compat.py
│           │   │   ├── display.py
│           │   │   ├── idb.py
│           │   │   ├── magic.py
│           │   │   ├── module.py
│           │   │   ├── plugin.py
│           │   │   ├── settings.py
│           │   │   └── statuserver.py
│           │   ├── magic
│           │   │   ├── archives
│           │   │   ├── binarch
│           │   │   ├── bincast
│           │   │   ├── binwalk
│           │   │   ├── bootloaders
│           │   │   ├── code
│           │   │   ├── compressed
│           │   │   ├── console
│           │   │   ├── crypto
│           │   │   ├── ecos
│           │   │   ├── encoding
│           │   │   ├── executables
│           │   │   ├── filesystems
│           │   │   ├── firmware
│           │   │   ├── hashing
│           │   │   ├── images
│           │   │   ├── linux
│           │   │   ├── lzma
│           │   │   ├── misc
│           │   │   ├── network
│           │   │   ├── sql
│           │   │   └── vxworks
│           │   ├── modules
│           │   │   ├── __init__.py
│           │   │   ├── binvis.py
│           │   │   ├── compression.py
│           │   │   ├── disasm.py
│           │   │   ├── entropy.py
│           │   │   ├── extractor.py
│           │   │   ├── general.py
│           │   │   ├── hashmatch.py
│           │   │   ├── heuristics.py
│           │   │   ├── hexdiff.py
│           │   │   └── signature.py
│           │   └── plugins
│           │       ├── arcadyan.py
│           │       ├── compressd.py
│           │       ├── cpio.py
│           │       ├── gzipextract.py
│           │       ├── gzipvalid.py
│           │       ├── jffs2valid.py
│           │       ├── lzmaextract.py
│           │       ├── lzmamod.py
│           │       ├── lzmavalid.py
│           │       ├── tar.py
│           │       ├── ubivalid.py
│           │       ├── unjffs2.py
│           │       ├── ziphelper.py
│           │       ├── zlibextract.py
│           │       └── zlibvalid.py
│           ├── binwalk.egg-info
│           │   ├── PKG-INFO
│           │   ├── SOURCES.txt
│           │   ├── dependency_links.txt
│           │   └── top_level.txt
│           └── scripts
│               ├── binida.py
│               ├── binwalk
│               └── examples
│                   ├── binwalk_simple.py
│                   ├── extract_data.py
│                   └── signature_scan.py
├── hexwalk
│   ├── advancedsearchdialog.cpp
│   ├── advancedsearchdialog.h
│   ├── advancedsearchdialog.ui
│   ├── binanalysisdialog.cpp
│   ├── binanalysisdialog.h
│   ├── binanalysisdialog.ui
│   ├── converterdialog.cpp
│   ├── converterdialog.h
│   ├── converterdialog.ui
│   ├── entropychart.cpp
│   ├── entropychart.h
│   ├── entropydialog.cpp
│   ├── entropydialog.h
│   ├── entropydialog.ui
│   ├── fonts
│   │   ├── Courier.ttf
│   │   └── Helvetica.ttf
│   ├── hashdialog.cpp
│   ├── hashdialog.h
│   ├── hashdialog.ui
│   ├── hexwalk.pro
│   ├── hexwalk.qrc
│   ├── hexwalkmain.cpp
│   ├── hexwalkmain.h
│   ├── hexwalkmain.ui
│   ├── images
│   │   ├── binary.png
│   │   ├── entropy.png
│   │   ├── find.png
│   │   ├── hexwalk.ico
│   │   ├── hexwalk16.png
│   │   ├── hexwalk256.png
│   │   ├── hexwalk32.png
│   │   ├── hexwalk64.png
│   │   ├── open.png
│   │   ├── redo.png
│   │   ├── save.png
│   │   └── undo.png
│   ├── main.cpp
│   ├── optionsdialog.cpp
│   ├── optionsdialog.h
│   ├── optionsdialog.ui
│   ├── resultType.h
│   ├── searchdialog.cpp
│   ├── searchdialog.h
│   ├── searchdialog.ui
│   ├── translations
│   │   ├── hexwalk_cs.qm
│   │   ├── hexwalk_cs.ts
│   │   ├── hexwalk_de.qm
│   │   ├── hexwalk_de.ts
│   │   ├── hexwalk_ru.qm
│   │   └── hexwalk_ru.ts
│   ├── worditemdelegate.cpp
│   └── worditemdelegate.h
├── hexwalk.png
├── screenshots
│   ├── hexwalk_gui1.png
│   ├── hexwalk_gui2.png
│   ├── hexwalk_gui3.png
│   ├── hexwalk_gui4.png
│   └── hexwalk_gui5.png
└── src
    ├── QHexEditPlugin.cpp
    ├── QHexEditPlugin.h
    ├── chunks.cpp
    ├── chunks.h
    ├── commands.cpp
    ├── commands.h
    ├── license.txt
    ├── qhexedit.cpp
    ├── qhexedit.h
    ├── qhexedit.pro
    ├── qhexedit.sip
    └── qhexeditplugin.pro

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
![hexwalk](hexwalk/images/hexwalk64.png)
# HexWalk - Hex Editor/Viewer/Analyzer
 
HexWalk is an Hex editor, viewer, analyzer.

Based on opensource projects like qhexedit2,binwalk and QT.

It is cross platform and has plenty of features:

* Advanced Find (can find patterns in binary files based on HEX,UTF8,UTF16 and regex)
* Binwalk integration
* Entropy Analysis
* Hash Calculator
* Bin/Dec/Hex Converter
* Hex file editing


## Screenshots

* Main page
![hexwalk gui](screenshots/hexwalk_gui1.png)

* Advanced Search
![hexwalk gui](screenshots/hexwalk_gui5.png)

* Entropy Calculator
![hexwalk gui](screenshots/hexwalk_gui2.png)

* Binary Analyzer
![hexwalk gui](screenshots/hexwalk_gui3.png)

* Hash Calculator
![hexwalk gui](screenshots/hexwalk_gui4.png)

## Dependencies

HexWalk release executables are statically linked, so are self-contained, you can use as-is.
Binwalk functionalities need Binwalk to be installed on the OS. For Linux OS simply install binwalk with your
package manager (eg. sudo apt install binwalk)

For Windows, Binwalk support is experimental, it is done using a python helper file that launches the commands and must be on the same path of hexwalk.exe.
in order for binwalk support to work on Windows it is necessary to install Python and to install binwalk, at the moment of writing on windows it is supported up to binwalk 2.1.1,
sources of binwalk_2.1.1 are supplied inside the binwalk_windows folder. To install it on Windows just run "python setup.py install"

## Acknowledgments

Thanks to these projects:

* Binwalk - https://github.com/ReFirmLabs/binwalk

* QHexEdit2 - https://github.com/Simsys/qhexedit2

* QT5
```

`binwalk_windows/binw.py`:

```py
import binwalk
import sys
if len(sys.argv) == 2:
    binwalk.scan('--signature', sys.argv[1])
elif len(sys.argv) == 3 and sys.argv[1] == '-e':
    binwalk.scan('--signature','--extract', sys.argv[2])

```

`binwalk_windows/binwalk-2.1.1/API.md`:

```md
Description
===========

The binwalk python module can be used by any python script to programmatically perform binwalk scans and obtain the results of those scans. 

The classes, methods and objects in the binwalk modules are documented via pydoc, including examples, so those interested in using the binwalk module are encouraged to look there. However, several common usage examples are provided here to help jump-start development efforts.


Binwalk Scripting
=================

Each of binwalk's features (signature scans, entropy analysis, etc) are implemented as separate modules. These modules can be invoked via `binwalk.scan`.

In fact, the binwalk command line utility can be duplicated nearly entirely with just two lines of code:

```python
import binwalk
binwalk.scan()
```

The `scan` function accepts both args and kwargs, which correspond to the normal command line options accepted by the binwalk command line utility, providing a large amount of freedom in how you choose to specify binwalk options (if none are specified, `sys.argv` is used by default).

For example, to execute a signature scan, you at the very least have to specify the `--signature` option, as well as a list of files to scan. This can be done in a number of ways:

```python
binwalk.scan('--signature', 'firmware1.bin', 'firmware2.bin')

binwalk.scan('firmware1.bin', 'firmware2.bin', signature=True)

binwalk.scan('firmware1.bin', 'firmware2.bin', **{'signature' : True})
        
binwalk.scan(*['firmware1.bin', 'firmware2.bin'], signature=True)
        
binwalk.scan(*['--signature', 'firmware1.bin', 'firmware2.bin',])
```

All args and kwargs keys/values correspond to binwalk's command line options. Either args or kwargs, or a combination of the two may be used, with the following caveats:

* All command line switches passed via args must be preceded by hyphens
* All file names must be passed via args, not kwargs

There is one available API argument which is not exposed via the command line: the `string` argument. When `string` is set to True, data to be scanned can be passed directly to the binwalk module, rather than a file name:

```python
data = "This is some data to scan for signatures"
binwalk.scan(data, signature=True, string=True)
```

Accessing Scan Results
======================

`binwalk.scan` returns a list of objects. Each object corresponds to a module that was run. For example, if you specified `--signature` and `--entropy`, then both the `Signature` and `Entropy` modules would be executed and you would be returned a list of two objects.

The two attributes of greatest interest for each object are the `results` and `errors` objects. Each is a list of `binwalk.core.module.Result` and `binwalk.core.module.Error` instances, respectively. Each `Result` or `Error` instance may contain custom attributes set by each module, but are guaranteed to have at least the following attributes (though modules are not required to populate all attributes):

|  Attribute  | Description |
|-------------|-------------|
| offset      | The file offset of the result/error (usually unused for errors) |
| description | The result/error description, as displayed to the user |
| module      | Name of the module that generated the result/error |
| file        | The file object of the scanned file |
| valid       | Set to True if the result is valid, False if invalid (usually unused for errors) |
| display     | Set to True to display the result to the user, False to hide it (usually unused for errors) |
| extract     | Set to True to flag this result for extraction (not used for errors) |
| plot        | Set to False to exclude this result from entropy plots (not used for errors) |

binwalk.core.module.Error has the additional guaranteed attribute:

|  Attribute  | Description |
|-------------|-------------|
| exception   | Contains the Python exception object if the encountered error was an exception |

Thus, scan results and errors can be programatically accessed rather easily:

```python
for module in binwalk.scan('firmware1.bin', 'firmware2.bin', signature=True, quiet=True):
    print ("%s Results:" % module.name)
    for result in module.results:
        print ("\t%s    0x%.8X    %s" % (result.file.path, result.offset, result.description))
```

Note the above use of the `--quiet` option which prevents the binwalk module from printing its normal output to screen.

Each module object will also have an additional `extractor` attribute, which is an instance of the `binwalk.modules.extractor.Extractor` class. Of particular use is `binwalk.modules.extractor.Extrctor.output`, a dictionary containing information about carved/extracted data:

```python
for module in binwalk.scan('firmware1.bin', 'firmware2.bin', signature=True, quiet=True, extract=True):
    for result in module.results:
        if module.extractor.output.has_key(result.file.path):
            # These are files that binwalk carved out of the original firmware image, a la dd
            if module.extractor.output[result.file.path].carved.has_key(result.offset):
                print "Carved data from offset 0x%X to %s" % (module.extractor.output[result.file.path].carved[result.offset])
            # These are files/directories created by extraction utilities (gunzip, tar, unsquashfs, etc)
            if module.extractor.output[result.file.path].extracted.has_key(result.offset):
                print "Extracted data from offset 0x%X to %s" % (module.extractor.output[result.file.path].extracted[result.offset][0])
```

Module Exceptions
=================

The only expected exception that should be raised is that of binwalk.ModuleException. This exception is thrown only if a required module encountered a fatal error (e.g., one of the specified target files could not be opened):

```python
try:
    binwalk.scan()
except binwalk.ModuleException as e:
    print ("Critical failure:", e)
```

```

`binwalk_windows/binwalk-2.1.1/INSTALL.md`:

```md
Before You Start
================

Binwalk supports Python 2.7 - 3.x. Although most systems have Python2.7 set as their default Python interpreter, binwalk does run faster in Python3. Installation procedures for both are provided below.

Installation
============

Installation follows the typical Python installation procedure:

```bash
# Python2.7
$ sudo python setup.py install
```

```bash
# Python3.x
$ sudo python3 setup.py install
```

**NOTE**: Older versions of binwalk (e.g., v1.0) are not compatible with the latest version of binwalk. It is strongly recommended that you uninstall any existing binwalk installations before installing the latest version in order to avoid API conflicts.

Dependencies
============

Besides a Python interpreter, there are no installation dependencies for binwalk. All dependencies are optional run-time dependencies, and unless otherwise specified, are available from most Linux package managers.

Although all binwalk run-time dependencies are optional, the `python-lzma` module is highly recommended for improving the reliability of signature scans. This module is included by default in Python3, but must be installed separately for Python2.7:

```bash
$ sudo apt-get install python-lzma
```

Binwalk uses [pyqtgraph](http://www.pyqtgraph.org) to generate graphs and visualizations, which requires the following: 

```bash
# Python2.7
$ sudo apt-get install libqt4-opengl python-opengl python-qt4 python-qt4-gl python-numpy python-scipy python-pip
$ sudo pip install pyqtgraph
```

```bash
# Python3.x
$ sudo apt-get install libqt4-opengl python3-opengl python3-pyqt4 python3-pyqt4.qtopengl python3-numpy python3-scipy python3-pip
$ sudo pip3 install pyqtgraph
```

Binwalk's `--disasm` option requires the [Capstone](http://www.capstone-engine.org/) disassembly framework and its corresponding Python bindings:

```bash
# Python2.7
$ sudo apt-get install python-pip
$ sudo pip install capstone
```

```bash
# Python3.x
$ sudo apt-get install python3-pip
$ sudo pip3 install capstone
```

Binwalk relies on multiple external utilties in order to automatically extract/decompress files and data:

```bash
# Install standard extraction utilities
$ sudo apt-get install mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsprogs cramfsswap squashfs-tools
```

```bash
# Install sasquatch to extract non-standard SquashFS images
$ sudo apt-get install zlib1g-dev liblzma-dev liblzo2-dev
$ git clone https://github.com/devttys0/sasquatch
$ (cd sasquatch && make && sudo make install)
```

```bash
# Install jefferson to extract JFFS2 file systems
$ sudo pip install cstruct
$ git clone https://github.com/sviehb/jefferson
$ (cd jefferson && sudo python setup.py install)
```

```bash
# Install ubi_reader to extract UBIFS file systems
$ sudo apt-get install liblzo2-dev python-lzo
$ git clone https://github.com/jrspruitt/ubi_reader
$ (cd ubi_reader && sudo python setup.py install)
```

```bash
# Install unstuff (closed source) to extract StuffIt archive files
$ wget -O - http://my.smithmicro.com/downloads/files/stuffit520.611linux-i386.tar.gz | tar -zxv
$ sudo cp bin/unstuff /usr/local/bin/
```

Note that for Debian/Ubuntu users, all of the above dependencies can be installed automatically using the included `deps.sh` script:

```bash
$ sudo ./deps.sh
```

Installing the IDA Plugin
=========================

If IDA is installed on your system, you may optionally install the binwalk IDA plugin:

```bash
$ python setup.py idainstall --idadir=/home/user/ida
```

Likewise, the binwalk IDA plugin can be uninstalled:

```bash
$ python setup.py idauninstall --idadir=/home/user/ida
```


Uninstalling Binwalk
====================

If binwalk has been installed to a standard system location (e.g., via `setup.py install`), it can be removed by running:

```bash
# Python2.7
$ sudo python setup.py uninstall
```

```bash
# Python3
$ sudo python3 setup.py uninstall
```

Note that this does _not_ remove any of the manually installed dependencies.


```

`binwalk_windows/binwalk-2.1.1/LICENSE`:

```
The MIT License (MIT)

Copyright (c) 2010-2015 Craig Heffner

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

```

`binwalk_windows/binwalk-2.1.1/README.md`:

```md
Description
===========

Binwalk is a fast, easy to use tool for analyzing, reverse engineering, and extracting firmware images.

Installation
============

Binwalk follows the standard Python installation procedure:

```bash
$ sudo python setup.py install
```

If you're running Python 2.x, you'll also want to install the Python lzma module:

```bash
$ sudo apt-get install python-lzma
```

For instructions on installing optional dependencies, see [INSTALL.md](https://github.com/devttys0/binwalk/blob/master/INSTALL.md).


Usage
=====

Basic usage is simple:

```bash
$ binwalk firmware.bin

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
0             0x0             TRX firmware header, little endian, header size: 28 bytes, image size: 14766080 bytes, CRC32: 0x6980E553 flags: 0x0, version: 1
28            0x1C            LZMA compressed data, properties: 0x5D, dictionary size: 65536 bytes, uncompressed size: 5494368 bytes
2319004       0x23629C        Squashfs filesystem, little endian, version 4.0, compression: xz, size: 12442471 bytes, 3158 inodes, blocksize: 131072 bytes, blocksize: 131072 bytes, created: 2014-05-21 22:38:47
```

For additional examples and descriptions of advanced options, see the [wiki](https://github.com/devttys0/binwalk/wiki).

```

`binwalk_windows/binwalk-2.1.1/deps.sh`:

```sh
#!/bin/bash

REQUIRED_UTILS="wget tar python"
APTCMD="apt-get"
YUMCMD="yum"
APT_CANDIDATES="git build-essential libqt4-opengl mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsprogs cramfsswap squashfs-tools zlib1g-dev liblzma-dev liblzo2-dev sleuthkit"
PYTHON2_APT_CANDIDATES="python-lzo python-lzma python-pip python-opengl python-qt4 python-qt4-gl python-numpy python-scipy"
PYTHON3_APT_CANDIDATES="python3-pip python3-opengl python3-pyqt4 python3-pyqt4.qtopengl python3-numpy python3-scipy"
PYTHON3_YUM_CANDIDATES=""
YUM_CANDIDATES="git gcc gcc-c++ make openssl-devel qtwebkit-devel qt-devel gzip bzip2 tar arj p7zip p7zip-plugins cabextract squashfs-tools zlib zlib-devel lzo lzo-devel xz xz-compat-libs xz-libs xz-devel xz-lzma-compat python-backports-lzma lzip pyliblzma perl-Compress-Raw-Lzma"
PYTHON2_YUM_CANDIDATES="python-pip python-opengl python-qt4 numpy python-numdisplay numpy-2f python-Bottleneck scipy"
APT_CANDIDATES="$APT_CANDIDATES $PYTHON2_APT_CANDIDATES"
YUM_CANDIDATES="$YUM_CANDIDATES $PYTHON2_YUM_CANDIDATES"
PIP_COMMANDS="pip"

# Check for root privileges
if [ $UID -eq 0 ]
then
    SUDO=""
else
    SUDO="sudo"
    REQUIRED_UTILS="sudo $REQUIRED_UTILS"
fi

function install_sasquatch
{
    git clone https://github.com/devttys0/sasquatch
    (cd sasquatch && make && $SUDO make install)
    $SUDO rm -rf sasquatch
}

function install_jefferson
{
    $SUDO pip install cstruct
    git clone https://github.com/sviehb/jefferson
    (cd jefferson && $SUDO python2 setup.py install)
    $SUDO rm -rf jefferson
}

function install_unstuff
{
    mkdir -p /tmp/unstuff
    cd /tmp/unstuff
    wget -O - http://my.smithmicro.com/downloads/files/stuffit520.611linux-i386.tar.gz | tar -zxv
    $SUDO cp bin/unstuff /usr/local/bin/
    cd -
    rm -rf /tmp/unstuff
}

function install_ubireader
{
    git clone https://github.com/jrspruitt/ubi_reader
    (cd ubi_reader && $SUDO python setup.py install)
    rm -rf ubi_reader
}

function install_pip_package
{
    PACKAGE="$1"

    for PIP_COMMAND in $PIP_COMMANDS
    do
        $SUDO $PIP_COMMAND install $PACKAGE
    done
}

function find_path
{
    FILE_NAME="$1"

    echo -ne "checking for $FILE_NAME..."
    which $FILE_NAME > /dev/null
    if [ $? -eq 0 ]
    then
        echo "yes"
        return 0
    else
        echo "no"
        return 1
    fi
}

# Make sure the user really wants to do this
echo ""
echo "WARNING: This script will download and install all required and optional dependencies for binwalk."
echo "         This script has only been tested on, and is only intended for, Debian based systems."
echo "         Some dependencies are downloaded via unsecure (HTTP) protocols."
echo "         This script requires internet access."
echo "         This script requires root privileges."
echo ""
echo -n "Continue [y/N]? "
read YN
if [ "$(echo "$YN" | grep -i -e 'y' -e 'yes')" == "" ]
then
    echo "Quitting..."
    exit 1
fi

# Check to make sure we have all the required utilities installed
NEEDED_UTILS=""
for UTIL in $REQUIRED_UTILS
do
    find_path $UTIL
    if [ $? -eq 1 ]
    then
        NEEDED_UTILS="$NEEDED_UTILS $UTIL"
    fi
done

# Check for supported package managers and set the PKG_* envars appropriately
find_path $APTCMD
if [ $? -eq 1 ]
then
    find_path $YUMCMD
    if [ $? -eq 1 ]
    then
        NEEDED_UTILS="$NEEDED_UTILS $APTCMD/$YUMCMD"
    else
        PKGCMD="$YUMCMD"
        PKGCMD_OPTS="-y install"
        PKG_CANDIDATES="$YUM_CANDIDATES"
        PKG_PYTHON3_CANDIDATES="$PYTHON3_YUM_CANDIDATES"
    fi
else
    PKGCMD="$APTCMD"
    PKGCMD_OPTS="install -y"
    PKG_CANDIDATES="$APT_CANDIDATES"
    PKG_PYTHON3_CANDIDATES="$PYTHON3_APT_CANDIDATES"
fi

if [ "$NEEDED_UTILS" != "" ]
then
    echo "Please install the following required utilities: $NEEDED_UTILS"
    exit 1
fi

# Check to see if we should install modules for python3 as well
find_path python3
if [ $? -eq 0 ]
then
     PKG_CANDIDATES="$PKG_CANDIDATES $PKG_PYTHON3_CANDIDATES"
     PIP_COMMANDS="pip3 $PIP_COMMANDS"
fi

# Do the install(s)
cd /tmp
sudo $PKGCMD $PKGCMD_OPTS $PKG_CANDIDTES
install_pip_package pyqtgraph
install_pip_package capstone
install_sasquatch
install_jefferson
install_unstuff
install_ubireader


```

`binwalk_windows/binwalk-2.1.1/images/README.md`:

```md
This is just a directory to store screenshots used in the github Wiki / documentation.

```

`binwalk_windows/binwalk-2.1.1/setup.py`:

```py
#!/usr/bin/env python
import os
import sys
import shutil
import tempfile
import subprocess
from distutils.core import setup, Command
from distutils.dir_util import remove_tree

MODULE_NAME = "binwalk"
SCRIPT_NAME = MODULE_NAME

# Python2/3 compliance
try:
    raw_input
except NameError:
    raw_input = input

# cd into the src directory, no matter where setup.py was invoked from
os.chdir(os.path.join(os.path.dirname(os.path.realpath(__file__)), "src"))

def which(command):
    # /usr/local/bin is usually the default install path, though it may not be in $PATH
    usr_local_bin = os.path.sep.join([os.path.sep, 'usr', 'local', 'bin', command])

    try:
        location = subprocess.Popen(["which", command], shell=False, stdout=subprocess.PIPE).communicate()[0].strip()
    except KeyboardInterrupt as e:
        raise e
    except Exception as e:
        pass

    if not location and os.path.exists(usr_local_bin):
        location = usr_local_bin

    return location

def find_binwalk_module_paths():
    paths = []

    try:
        import binwalk
        paths = binwalk.__path__
    except KeyboardInterrupt as e:
        raise e
    except Exception:
        pass

    return paths

def remove_binwalk_module(pydir=None, pybin=None):
    if pydir:
        module_paths = [pydir]
    else:
        module_paths = find_binwalk_module_paths()

    for path in module_paths:
        try:
            remove_tree(path)
        except OSError as e:
            pass

    if not pybin:
        pybin = which(MODULE_NAME)

    if pybin:
        try:
            sys.stdout.write("removing '%s'\n" % pybin)
            os.remove(pybin)
        except KeyboardInterrupt as e:
            pass
        except Exception as e:
            pass

class IDAUnInstallCommand(Command):
    description = "Uninstalls the binwalk IDA plugin module"
    user_options = [
                    ('idadir=', None, 'Specify the path to your IDA install directory.'),
    ]

    def initialize_options(self):
        self.idadir = None
        self.mydir = os.path.dirname(os.path.realpath(__file__))

    def finalize_options(self):
        pass

    def run(self):
        if self.idadir is None:
            sys.stderr.write("Please specify the path to your IDA install directory with the '--idadir' option!\n")
            return

        binida_dst_path = os.path.join(self.idadir, 'plugins', 'binida.py')
        binwalk_dst_path = os.path.join(self.idadir, 'python', 'binwalk')

        if os.path.exists(binida_dst_path):
            sys.stdout.write("removing %s\n" % binida_dst_path)
            os.remove(binida_dst_path)
        if os.path.exists(binwalk_dst_path):
            sys.stdout.write("removing %s\n" % binwalk_dst_path)
            shutil.rmtree(binwalk_dst_path)

class IDAInstallCommand(Command):
    description = "Installs the binwalk IDA plugin module"
    user_options = [
                    ('idadir=', None, 'Specify the path to your IDA install directory.'),
    ]

    def initialize_options(self):
        self.idadir = None
        self.mydir = os.path.dirname(os.path.realpath(__file__))

    def finalize_options(self):
        pass

    def run(self):
        if self.idadir is None:
            sys.stderr.write("Please specify the path to your IDA install directory with the '--idadir' option!\n")
            return

        binida_src_path = os.path.join(self.mydir, 'scripts', 'binida.py')
        binida_dst_path = os.path.join(self.idadir, 'plugins')

        if not os.path.exists(binida_src_path):
            sys.stderr.write("ERROR: could not locate IDA plugin file '%s'!\n" % binida_src_path)
            return
        if not os.path.exists(binida_dst_path):
            sys.stderr.write("ERROR: could not locate the IDA plugins directory '%s'! Check your --idadir option.\n" % binida_dst_path)
            return

        binwalk_src_path = os.path.join(self.mydir, 'binwalk')
        binwalk_dst_path = os.path.join(self.idadir, 'python')

        if not os.path.exists(binwalk_src_path):
            sys.stderr.write("ERROR: could not locate binwalk source directory '%s'!\n" % binwalk_src_path)
            return
        if not os.path.exists(binwalk_dst_path):
            sys.stderr.write("ERROR: could not locate the IDA python directory '%s'! Check your --idadir option.\n" % binwalk_dst_path)
            return

        binida_dst_path = os.path.join(binida_dst_path, 'binida.py')
        binwalk_dst_path = os.path.join(binwalk_dst_path, 'binwalk')

        if os.path.exists(binida_dst_path):
            os.remove(binida_dst_path)
        if os.path.exists(binwalk_dst_path):
            shutil.rmtree(binwalk_dst_path)

        sys.stdout.write("copying %s -> %s\n" % (binida_src_path, binida_dst_path))
        shutil.copyfile(binida_src_path, binida_dst_path)

        sys.stdout.write("copying %s -> %s\n" % (binwalk_src_path, binwalk_dst_path))
        shutil.copytree(binwalk_src_path, binwalk_dst_path)

class UninstallCommand(Command):
    description = "Uninstalls the Python module"
    user_options = [
                    ('pydir=', None, 'Specify the path to the binwalk python module to be removed.'),
                    ('pybin=', None, 'Specify the path to the binwalk executable to be removed.'),
    ]

    def initialize_options(self):
        self.pydir = None
        self.pybin = None

    def finalize_options(self):
        pass

    def run(self):
        remove_binwalk_module(self.pydir, self.pybin)

class CleanCommand(Command):
    description = "Clean Python build directories"
    user_options = []

    def initialize_options(self):
        pass

    def finalize_options(self):
        pass

    def run(self):
        try:
            remove_tree("build")
        except KeyboardInterrupt as e:
            raise e
        except Exception:
            pass

        try:
            remove_tree("dist")
        except KeyboardInterrupt as e:
            raise e
        except Exception:
            pass

# The data files to install along with the module
install_data_files = []
for data_dir in ["magic", "config", "plugins", "modules", "core"]:
        install_data_files.append("%s%s*" % (data_dir, os.path.sep))

# Install the module, script, and support files
setup(name = MODULE_NAME,
      version = "2.1.1",
      description = "Firmware analysis tool",
      author = "Craig Heffner",
      url = "https://github.com/devttys0/%s" % MODULE_NAME,

      requires = [],
      packages = [MODULE_NAME],
      package_data = {MODULE_NAME : install_data_files},
      scripts = [os.path.join("scripts", SCRIPT_NAME)],

      cmdclass = {'clean' : CleanCommand, 'uninstall' : UninstallCommand, 'idainstall' : IDAInstallCommand, 'idauninstall' : IDAUnInstallCommand}
)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk.egg-info/PKG-INFO`:

```
Metadata-Version: 2.1
Name: binwalk
Version: 2.1.1
Summary: Firmware analysis tool
Home-page: https://github.com/devttys0/binwalk
Author: Craig Heffner

```

`binwalk_windows/binwalk-2.1.1/src/binwalk.egg-info/SOURCES.txt`:

```txt
binwalk/__init__.py
binwalk.egg-info/PKG-INFO
binwalk.egg-info/SOURCES.txt
binwalk.egg-info/dependency_links.txt
binwalk.egg-info/top_level.txt
binwalk/config/extract.conf
binwalk/core/C.py
binwalk/core/__init__.py
binwalk/core/common.py
binwalk/core/compat.py
binwalk/core/display.py
binwalk/core/idb.py
binwalk/core/magic.py
binwalk/core/module.py
binwalk/core/plugin.py
binwalk/core/settings.py
binwalk/core/statuserver.py
binwalk/magic/archives
binwalk/magic/binarch
binwalk/magic/bincast
binwalk/magic/binwalk
binwalk/magic/bootloaders
binwalk/magic/code
binwalk/magic/compressed
binwalk/magic/console
binwalk/magic/crypto
binwalk/magic/ecos
binwalk/magic/encoding
binwalk/magic/executables
binwalk/magic/filesystems
binwalk/magic/firmware
binwalk/magic/hashing
binwalk/magic/images
binwalk/magic/linux
binwalk/magic/lzma
binwalk/magic/misc
binwalk/magic/network
binwalk/magic/sql
binwalk/magic/vxworks
binwalk/modules/__init__.py
binwalk/modules/binvis.py
binwalk/modules/compression.py
binwalk/modules/disasm.py
binwalk/modules/entropy.py
binwalk/modules/extractor.py
binwalk/modules/general.py
binwalk/modules/hashmatch.py
binwalk/modules/heuristics.py
binwalk/modules/hexdiff.py
binwalk/modules/signature.py
binwalk/plugins/arcadyan.py
binwalk/plugins/compressd.py
binwalk/plugins/cpio.py
binwalk/plugins/gzipextract.py
binwalk/plugins/gzipvalid.py
binwalk/plugins/jffs2valid.py
binwalk/plugins/lzmaextract.py
binwalk/plugins/lzmamod.py
binwalk/plugins/lzmavalid.py
binwalk/plugins/tar.py
binwalk/plugins/ubivalid.py
binwalk/plugins/unjffs2.py
binwalk/plugins/ziphelper.py
binwalk/plugins/zlibextract.py
binwalk/plugins/zlibvalid.py
scripts/binwalk
```

`binwalk_windows/binwalk-2.1.1/src/binwalk.egg-info/top_level.txt`:

```txt
binwalk

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/__init__.py`:

```py
__all__ = ['scan', 'execute', 'ModuleException']

from binwalk.core.module import Modules, ModuleException

# Convenience functions
def scan(*args, **kwargs):
    with Modules(*args, **kwargs) as m:
        objs = m.execute()
    return objs
def execute(*args, **kwargs):
    return scan(*args, **kwargs)

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/config/extract.conf`:

```conf
#######################################################################################################################################
# Default extraction rules, loaded when --extract is specified.
#
# <lower-case unique string from binwalk output text>:<desired file extension>:<command to execute>:<successful command return codes>:<False to not scan extracted files/directories>
#
# Note that %e is a place holder for the extracted file name.
#
# The %% place holder is used when a unique file path is required.
# For example '%%squashfs-root%%' will be replaced with 'squashfs-root-0'
# if 'squashfs-root' already exists.
#
# The following file types are handled internally by extractor plugins:
#
#   o zlib
#   o cpio
#   o Raw LZMA/deflate streams
#
# There are also alternative extractors for the following file formats, implemented as plugins:
#
#   o gzip
#   o lzma
#   o xz
#
#######################################################################################################################################

# Assumes these utilities are installed in $PATH.
^gzip compressed data:gz:gzip -d -f '%e':0,2
^lzma compressed data:7z:7z e -y '%e':0,1
^xz compressed data:xz:7z e -y '%e':0,1
^bzip2 compressed data:bz2:bzip2 -d '%e'
^compress'd data:Z:gzip -d '%e'
^zip archive data:zip:7z x -y '%e' -p '':0,1
^posix tar archive:tar:tar xvf '%e'
^rar archive data:rar:unrar e '%e'
^rar archive data:rar:unrar -x '%e' # This is for the 'free' version
^arj archive data.*comment header:arj:arj -y e '%e'
^lha:lha:lha ei '%e'
^iso 9660:iso:7z x '%e' -oiso-root
^microsoft cabinet archive:cab:cabextract '%e'
^stuffit:sit:unstuff '%e'

# Try unsquashfs first, or if not installed, sasquatch
^squashfs filesystem:squashfs:unsquashfs -d '%%squashfs-root%%' '%e':0:False
^squashfs filesystem:squashfs:sasquatch -p 1 -le -d '%%squashfs-root%%' '%e':0:False
^squashfs filesystem:squashfs:sasquatch -p 1 -be -d '%%squashfs-root%%' '%e':0:False

# Try cramfsck first; if that fails, swap the file system and try again
^cramfs filesystem:cramfs:cramfsck -x '%%cramfs-root%%' '%e':0:False
^cramfs filesystem:cramfs:cramfsswap '%e' '%e.swap' && cramfsck -x '%%cramfs-root%%' '%e.swap':0:False

# Extract EXT filesystems using sleuth kit
^linux ext:ext:tsk_recover -i raw -f ext -a -v '%e' '%%ext-root%%':0:False

# Try mounting the file system (this requires root privileges)
^squashfs filesystem:squashfs:mkdir squashfs-root && mount -t squashfs '%e' squashfs-root:0:False
^cramfs filesystem:cramfs:mkdir cramfs-root && mount -t cramfs '%e' cramfs-root:0:False
^ext2 filesystem:ext2:mkdir ext2-root && mount -t ext2 '%e' ext2-root:0:False
^romfs filesystem:romfs:mkdir romfs-root && mount -t romfs '%e' romfs-root:0:False

# Use sviehb's jefferson.py tool for JFFS2 extraction
^jffs2 filesystem:jffs2:jefferson -d '%%jffs2-root%%' '%e':0:False

# Use ubi_reader tool for UBIFS extraction
^ubifs filesystem superblock node:ubi:ubireader_extract_files -o '%%ubifs-root%%' '%e':0:False
^ubi erase count header:ubi:ubireader_extract_files -o '%%ubifs-root%%' '%e':0:False

# These were extractors used from FMK that still need suitable replacements.
#^bff volume entry:bff:/opt/firmware-mod-kit/src/bff/bffxtractor.py '%e'
#^wdk file system:wdk:/opt/firmware-mod-kit/src/firmware-tools/unwdk.py '%e'

# Extract, but don't run anything
^elf,:elf
private key:key
certificate:crt
html document header
xml document:xml


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/C.py`:

```py
import os
import sys
import glob
import ctypes
import ctypes.util
import binwalk.core.common
from binwalk.core.compat import *

class Function(object):
    '''
    Container class for defining library functions.
    '''
    def __init__(self, **kwargs):
        self.name = None
        self.type = int

        for (k, v) in iterator(kwargs):
            setattr(self, k, v)

class FunctionHandler(object):
    '''
    Class for abstracting function calls via ctypes and handling Python 2/3 compatibility issues.
    '''
    PY2CTYPES = {
            bytes   : ctypes.c_char_p,
            str     : ctypes.c_char_p,
            int     : ctypes.c_int,
            float   : ctypes.c_float,
            bool    : ctypes.c_int,
            None    : ctypes.c_int,
    }

    RETVAL_CONVERTERS = {
            None    : int,
            int     : int,
            float   : float,
            bool    : bool,
            str     : bytes2str,
            bytes   : str2bytes,
    }
        
    def __init__(self, library, function):
        '''
        Class constructor.

        @library - Library handle as returned by ctypes.cdll.LoadLibrary.
        @function - An instance of the binwalk.core.C.Function class.

        Returns None.
        '''
        self.name = function.name
        self.retype = function.type
        self.function = getattr(library, self.name)

        if has_key(self.PY2CTYPES, self.retype):
            self.function.restype = self.PY2CTYPES[self.retype]
            self.retval_converter = self.RETVAL_CONVERTERS[self.retype]
        else:
            self.function.restype = self.retype
            self.retval_converter = None
            #raise Exception("Unknown return type: '%s'" % self.retype)

    def run(self, *args):
        '''
        Executes the library function, handling Python 2/3 compatibility and properly converting the return type.

        @*args - Library function arguments.

        Returns the return value from the libraray function.
        '''
        args = list(args)

        # Python3 expects a bytes object for char *'s, not a str. 
        # This allows us to pass either, regardless of the Python version.
        for i in range(0, len(args)):
            if isinstance(args[i], str):
                args[i] = str2bytes(args[i])

        retval = self.function(*args)
        if self.retval_converter is not None:
            retval = self.retval_converter(retval)

        return retval
        
class Library(object):
    '''
    Class for loading the specified library via ctypes.
    '''

    def __init__(self, library, functions):
        '''
        Class constructor.

        @library   - Library name (e.g., 'magic' for libmagic), or a list of names.
        @functions - A dictionary of function names and their return types (e.g., {'magic_buffer' : str})

        Returns None.
        '''
        self.settings = binwalk.core.settings.Settings()
        self.library = ctypes.cdll.LoadLibrary(self.find_library(library))
        if not self.library:
            raise Exception("Failed to load library '%s'" % library)

        for function in functions:    
            f = FunctionHandler(self.library, function)
            setattr(self, function.name, f.run)

    def find_library(self, libraries):
        '''
        Locates the specified library.

        @libraries - Library name (e.g., 'magic' for libmagic), or a list of names.
 
        Returns a string to be passed to ctypes.cdll.LoadLibrary.
        '''
        lib_path = None

        prefix = binwalk.core.common.get_libs_path()
        
        if isinstance(libraries, str):
            libraries = [libraries]

        for library in libraries:
            system_paths = {
                'linux'   : [os.path.join(prefix, 'lib%s.so' % library), '/usr/local/lib/lib%s.so' % library],
                'cygwin'  : [os.path.join(prefix, 'lib%s.so' % library), '/usr/local/lib/lib%s.so' % library],
                'win32'   : [os.path.join(prefix, 'lib%s.dll' % library), '%s.dll' % library],
                'darwin'  : [os.path.join(prefix, 'lib%s.dylib' % library),
                             '/opt/local/lib/lib%s.dylib' % library,
                             '/usr/local/lib/lib%s.dylib' % library,
                            ] + glob.glob('/usr/local/Cellar/*%s*/*/lib/lib%s.dylib' % (library, library)),
            }

            for i in range(2, 4):
                system_paths['linux%d' % i] = system_paths['linux']

            # Search the common install directories first; these are usually not in the library search path
            # Search these *first*, since a) they are the most likely locations and b) there may be a
            # discrepency between where ctypes.util.find_library and ctypes.cdll.LoadLibrary search for libs.
            for path in system_paths[sys.platform]:
                binwalk.core.common.debug("Searching for '%s'" % path)
                if os.path.exists(path):
                    lib_path = path
                    break

            # If we failed to find the library, check the standard library search paths
            if not lib_path:
                lib_path = ctypes.util.find_library(library)

            # Use the first library that we can find
            if lib_path:
                binwalk.core.common.debug("Found library '%s' at: %s" % (library, lib_path))
                break
            else:
                binwalk.core.common.debug("Could not find library '%s'" % library)

        # If we still couldn't find the library, error out
        if not lib_path:
            raise Exception("Failed to locate libraries '%s'" % str(libraries))

        return lib_path


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/common.py`:

```py
# Common functions used throughout various parts of binwalk code.

import io
import os
import re
import sys
import ast
import hashlib
import platform
import operator as op
from binwalk.core.compat import *

# The __debug__ value is a bit backwards; by default it is set to True, but
# then set to False if the Python interpreter is run with the -O option.
if not __debug__:
    DEBUG = True
else:
    DEBUG = False

def MSWindows():
    # Returns True if running in a Microsoft Windows OS
    return (platform.system() == 'Windows')

def debug(msg):
    '''
    Displays debug messages to stderr only if the Python interpreter was invoked with the -O flag.
    '''
    if DEBUG:
        sys.stderr.write("DEBUG: " + msg + "\n")
        sys.stderr.flush()

def warning(msg):
    '''
    Prints warning messages to stderr
    '''
    sys.stderr.write("\nWARNING: " + msg + "\n")

def error(msg):
    '''
    Prints error messages to stderr
    '''
    sys.stderr.write("\nERROR: " + msg + "\n")

def get_module_path():
    root = __file__
    if os.path.islink(root):
        root = os.path.realpath(root)
    return os.path.dirname(os.path.dirname(os.path.abspath(root)))

def get_libs_path():
    return os.path.join(get_module_path(), "libs")

def file_md5(file_name):
    '''
    Generate an MD5 hash of the specified file.

    @file_name - The file to hash.

    Returns an MD5 hex digest string.
    '''
    md5 = hashlib.md5()

    with open(file_name, 'rb') as f:
        for chunk in iter(lambda: f.read(128*md5.block_size), b''):
            md5.update(chunk)

    return md5.hexdigest()

def file_size(filename):
    '''
    Obtains the size of a given file.

    @filename - Path to the file.

    Returns the size of the file.
    '''
    # Using open/lseek works on both regular files and block devices
    fd = os.open(filename, os.O_RDONLY)
    try:
        return os.lseek(fd, 0, os.SEEK_END)
    except KeyboardInterrupt as e:
        raise e
    except Exception as e:
        raise Exception("file_size failed to obtain the size of '%s': %s" % (filename, str(e)))
    finally:
        os.close(fd)

def strip_quoted_strings(string):
    '''
    Strips out data in between double quotes.

    @string - String to strip.

    Returns a sanitized string.
    '''
    # This regex removes all quoted data from string.
    # Note that this removes everything in between the first and last double quote.
    # This is intentional, as printed (and quoted) strings from a target file may contain
    # double quotes, and this function should ignore those. However, it also means that any
    # data between two quoted strings (ex: '"quote 1" you won't see me "quote 2"') will also be stripped.
    return re.sub(r'\"(.*)\"', "", string)

def get_quoted_strings(string):
    '''
    Returns a string comprised of all data in between double quotes.

    @string - String to get quoted data from.

    Returns a string of quoted data on success.
    Returns a blank string if no quoted data is present.
    '''
    try:
        # This regex grabs all quoted data from string.
        # Note that this gets everything in between the first and last double quote.
        # This is intentional, as printed (and quoted) strings from a target file may contain
        # double quotes, and this function should ignore those. However, it also means that any
        # data between two quoted strings (ex: '"quote 1" non-quoted data "quote 2"') will also be included.
        return re.findall(r'\"(.*)\"', string)[0]
    except KeyboardInterrupt as e:
        raise e
    except Exception:
        return ''

def unique_file_name(base_name, extension=''):
    '''
    Creates a unique file name based on the specified base name.

    @base_name - The base name to use for the unique file name.
    @extension - The file extension to use for the unique file name.

    Returns a unique file string.
    '''
    idcount = 0

    if extension and not extension.startswith('.'):
        extension = '.%s' % extension

    fname = base_name + extension

    while os.path.exists(fname):
        fname = "%s-%d%s" % (base_name, idcount, extension)
        idcount += 1

    return fname

def strings(filename, minimum=4):
    '''
    A strings generator, similar to the Unix strings utility.

    @filename - The file to search for strings in.
    @minimum  - The minimum string length to search for.

    Yeilds printable ASCII strings from filename.
    '''
    result = ""

    with BlockFile(filename) as f:
        while True:
            (data, dlen) = f.read_block()
            if not data:
                break

            for c in data:
                if c in string.printable:
                    result += c
                    continue
                elif len(result) >= minimum:
                    yield result
                    result = ""
                else:
                    result = ""

class GenericContainer(object):

    def __init__(self, **kwargs):
        for (k,v) in iterator(kwargs):
            setattr(self, k, v)

class MathExpression(object):
    '''
    Class for safely evaluating mathematical expressions from a string.
    Stolen from: http://stackoverflow.com/questions/2371436/evaluating-a-mathematical-expression-in-a-string
    '''

    OPERATORS = {
        ast.Add:    op.add,
        ast.UAdd:   op.add,
        ast.USub:   op.sub,
        ast.Sub:    op.sub,
        ast.Mult:   op.mul,
        ast.Div:    op.truediv,
        ast.Pow:    op.pow,
        ast.BitXor: op.xor
    }

    def __init__(self, expression):
        self.expression = expression
        self.value = None

        if expression:
            try:
                self.value = self.evaluate(self.expression)
            except KeyboardInterrupt as e:
                raise e
            except Exception as e:
                pass

    def evaluate(self, expr):
        return self._eval(ast.parse(expr).body[0].value)

    def _eval(self, node):
        if isinstance(node, ast.Num): # <number>
            return node.n
        elif isinstance(node, ast.operator): # <operator>
            return self.OPERATORS[type(node.op)]
        elif isinstance(node, ast.UnaryOp):
            return self.OPERATORS[type(node.op)](0, self._eval(node.operand))
        elif isinstance(node, ast.BinOp): # <left> <operator> <right>
            return self.OPERATORS[type(node.op)](self._eval(node.left), self._eval(node.right))
        else:
            raise TypeError(node)

class StringFile(object):
    '''
    A class to allow access to strings as if they were read from a file.
    Used internally as a conditional superclass to InternalBlockFile.
    '''
    def __init__(self, fname, mode='r'):
        self.string = fname
        self.name = "String"
        self.args.size = len(self.string)

    def read(self, n=-1):
        if n == -1:
            data = self.string[self.total_read:]
        else:
            data = self.string[self.total_read:self.total_read+n]
        return data

    def tell(self):
        return self.total_read

    def write(self, *args, **kwargs):
        pass

    def seek(self, *args, **kwargs):
        pass

    def close(self):
        pass

def BlockFile(fname, mode='r', subclass=io.FileIO, **kwargs):

    # Defining a class inside a function allows it to be dynamically subclassed
    class InternalBlockFile(subclass):
        '''
        Abstraction class for accessing binary files.

        This class overrides io.FilIO's read and write methods. This guaruntees two things:

            1. All requested data will be read/written via the read and write methods.
            2. All reads return a str object and all writes can accept either a str or a
               bytes object, regardless of the Python interpreter version.

        However, the downside is that other io.FileIO methods won't work properly in Python 3,
        namely things that are wrappers around self.read (e.g., readline, readlines, etc).

        This class also provides a read_block method, which is used by binwalk to read in a
        block of data, plus some additional data (DEFAULT_BLOCK_PEEK_SIZE), but on the next block read
        pick up at the end of the previous data block (not the end of the additional data). This
        is necessary for scans where a signature may span a block boundary.

        The descision to force read to return a str object instead of a bytes object is questionable
        for Python 3, but it seemed the best way to abstract differences in Python 2/3 from the rest
        of the code (especially for people writing plugins) and to add Python 3 support with
        minimal code change.
        '''

        # The DEFAULT_BLOCK_PEEK_SIZE limits the amount of data available to a signature.
        # While most headers/signatures are far less than this value, some may reference
        # pointers in the header structure which may point well beyond the header itself.
        # Passing the entire remaining buffer to libmagic is resource intensive and will
        # significantly slow the scan; this value represents a reasonable buffer size to
        # pass to libmagic which will not drastically affect scan time.
        DEFAULT_BLOCK_PEEK_SIZE = 8 * 1024

        # Max number of bytes to process at one time. This needs to be large enough to
        # limit disk I/O, but small enough to limit the size of processed data blocks.
        DEFAULT_BLOCK_READ_SIZE = 1 * 1024 * 1024

        def __init__(self, fname, mode='r', length=0, offset=0, block=DEFAULT_BLOCK_READ_SIZE, peek=DEFAULT_BLOCK_PEEK_SIZE, swap=0):
            '''
            Class constructor.

            @fname  - Path to the file to be opened.
            @mode   - Mode to open the file in (default: 'r').
            @length - Maximum number of bytes to read from the file via self.block_read().
            @offset - Offset at which to start reading from the file.
            @block  - Size of data block to read (excluding any trailing size),
            @peek   - Size of trailing data to append to the end of each block.
            @swap   - Swap every n bytes of data.

            Returns None.
            '''
            self.total_read = 0
            self.block_read_size = self.DEFAULT_BLOCK_READ_SIZE
            self.block_peek_size = self.DEFAULT_BLOCK_PEEK_SIZE

            # This is so that custom parent classes can access/modify arguments as necessary
            self.args = GenericContainer(fname=fname,
                                         mode=mode,
                                         length=length,
                                         offset=offset,
                                         block=block,
                                         peek=peek,
                                         swap=swap,
                                         size=0)

            # Python 2.6 doesn't like modes like 'rb' or 'wb'
            mode = self.args.mode.replace('b', '')

            super(self.__class__, self).__init__(fname, mode)

            self.swap_size = self.args.swap

            if self.args.size:
                self.size = self.args.size
            else:
                try:
                    self.size = file_size(self.args.fname)
                except KeyboardInterrupt as e:
                    raise e
                except Exception:
                    self.size = 0

            if self.args.offset < 0:
                self.offset = self.size + self.args.offset
            else:
                self.offset = self.args.offset

            if self.offset < 0:
                self.offset = 0
            elif self.offset > self.size:
                self.offset = self.size

            if self.args.offset < 0:
                self.length = self.args.offset * -1
            elif self.args.length:
                self.length = self.args.length
            else:
                self.length = self.size - self.args.offset

            if self.length < 0:
                self.length = 0
            elif self.length > self.size:
                self.length = self.size

            if self.args.block is not None:
                self.block_read_size = self.args.block
            self.base_block_size = self.block_read_size

            if self.args.peek is not None:
                self.block_peek_size = self.args.peek
            self.base_peek_size = self.block_peek_size

            # Work around for python 2.6 where FileIO._name is not defined
            try:
                self.name
            except AttributeError:
                self._name = fname

            self.path = os.path.abspath(self.name)
            self.seek(self.offset)

        def _swap_data_block(self, block):
            '''
            Reverses every self.swap_size bytes inside the specified data block.
            Size of data block must be a multiple of self.swap_size.

            @block - The data block to swap.

            Returns a swapped string.
            '''
            i = 0
            data = ""

            if self.swap_size > 0:
                while i < len(block):
                    data += block[i:i+self.swap_size][::-1]
                    i += self.swap_size
            else:
                data = block

            return data

        def reset(self):
            self.set_block_size(block=self.base_block_size, peek=self.base_peek_size)
            self.seek(self.offset)

        def set_block_size(self, block=None, peek=None):
            if block is not None:
                self.block_read_size = block
            if peek is not None:
                self.block_peek_size = peek

        def write(self, data):
            '''
            Writes data to the opened file.

            io.FileIO.write does not guaruntee that all data will be written;
            this method overrides io.FileIO.write and does guaruntee that all data will be written.

            Returns the number of bytes written.
            '''
            n = 0
            l = len(data)
            data = str2bytes(data)

            while n < l:
                n += super(self.__class__, self).write(data[n:])

            return n

        def read(self, n=-1):
            ''''
            Reads up to n bytes of data (or to EOF if n is not specified).
            Will not read more than self.length bytes.

            io.FileIO.read does not guaruntee that all requested data will be read;
            this method overrides io.FileIO.read and does guaruntee that all data will be read.

            Returns a str object containing the read data.
            '''
            l = 0
            data = b''

            if self.total_read < self.length:
                # Don't read more than self.length bytes from the file
                if (self.total_read + n) > self.length:
                    n = self.length - self.total_read

                while n < 0 or l < n:
                    tmp = super(self.__class__, self).read(n-l)
                    if tmp:
                        data += tmp
                        l += len(tmp)
                    else:
                        break

                self.total_read += len(data)

            return self._swap_data_block(bytes2str(data))

        def peek(self, n=-1):
            '''
            Peeks at data in file.
            '''
            pos = self.tell()
            data = self.read(n)
            self.seek(pos)
            return data

        def seek(self, n, whence=os.SEEK_SET):
            if whence == os.SEEK_SET:
                self.total_read = n - self.offset
            elif whence == os.SEEK_CUR:
                self.total_read += n
            elif whence == os.SEEK_END:
                self.total_read = self.size + n

            super(self.__class__, self).seek(n, whence)

        def read_block(self):
            '''
            Reads in a block of data from the target file.

            Returns a tuple of (str(file block data), block data length).
            '''
            data = self.read(self.block_read_size)
            dlen = len(data)
            data += self.peek(self.block_peek_size)

            return (data, dlen)

    return InternalBlockFile(fname, mode=mode, **kwargs)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/compat.py`:

```py
# All Python 2/3 compatibility stuffs go here.

from __future__ import print_function
import sys
import string

PY_MAJOR_VERSION = sys.version_info[0]

if PY_MAJOR_VERSION > 2:
    string.letters = string.ascii_letters

def iterator(dictionary):
    '''
    For cross compatibility between Python 2 and Python 3 dictionaries.
    '''
    if PY_MAJOR_VERSION > 2:
        return dictionary.items()
    else:
        return dictionary.iteritems()

def has_key(dictionary, key):
    '''
    For cross compatibility between Python 2 and Python 3 dictionaries.
    '''
    if PY_MAJOR_VERSION > 2:
        return key in dictionary
    else:
        return dictionary.has_key(key)

def get_keys(dictionary):
    '''
    For cross compatibility between Python 2 and Python 3 dictionaries.
    '''
    if PY_MAJOR_VERSION > 2:
        return list(dictionary.keys())
    else:
        return dictionary.keys()

def str2bytes(string):
    '''
    For cross compatibility between Python 2 and Python 3 strings.
    '''
    if isinstance(string, type('')) and PY_MAJOR_VERSION > 2:
        return bytes(string, 'latin1')
    else:
        return string

def bytes2str(bs):
    '''
    For cross compatibility between Python 2 and Python 3 strings.
    '''
    if isinstance(bs, type(b'')) and PY_MAJOR_VERSION > 2:
        return bs.decode('latin1')
    else:
        return bs

def string_decode(string):
    '''
    For cross compatibility between Python 2 and Python 3 strings.
    '''
    if PY_MAJOR_VERSION > 2:
        return bytes(string, 'utf-8').decode('unicode_escape')
    else:
        return string.decode('string_escape')

def user_input(prompt=''):
    '''
    For getting raw user input in Python 2 and 3.
    '''
    if PY_MAJOR_VERSION > 2:
        return input(prompt)
    else:
        return raw_input(prompt)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/display.py`:

```py
# Code to handle displaying and logging of results.
# Anything in binwalk that prints results to screen should use this class.

import sys
import csv as pycsv
import datetime
import binwalk.core.common
from binwalk.core.compat import *

class Display(object):
    '''
    Class to handle display of output and writing to log files.
    This class is instantiated for all modules implicitly and should not need to be invoked directly by most modules.
    '''
    SCREEN_WIDTH = 0
    HEADER_WIDTH = 80
    DEFAULT_FORMAT = "%s\n"

    def __init__(self, quiet=False, verbose=False, log=None, csv=False, fit_to_screen=False):
        self.quiet = quiet
        self.verbose = verbose
        self.fit_to_screen = fit_to_screen
        self.fp = None
        self.csv = None
        self.num_columns = 0
        self.custom_verbose_format = ""
        self.custom_verbose_args = []

        self._configure_formatting()

        if log:
            self.fp = open(log, "a")
            if csv:
                self.csv = pycsv.writer(self.fp)

    def _fix_unicode(self, line):
        '''
        This is a hack, there must be a better way to handle it.
        In Python3, if the environment variable LANG=C is set, indicating
        that the terminal is ASCII only, but unicode characters need to be
        printed to the screen or to a file (e.g., file path, magic result
        format string), then an UnicodeEncodError exception will be raised.

        This converts the given line to ASCII, ignoring conversion errors,
        and returns a str.
        '''
        return bytes2str(line.encode('ascii', 'ignore'))

    def _fix_unicode_list(self, columns):
        '''
        Convenience wrapper for self.log which is passed a list of format arguments.
        '''
        if type(columns) in [list, tuple]:
            for i in range(0, len(columns)):
                try:
                    columns[i] = self._fix_unicode(columns[i])
                except AttributeError:
                    pass
        return columns

    def format_strings(self, header, result):
        self.result_format = result
        self.header_format = header

        if self.num_columns == 0:
            self.num_columns = len(header.split())

    def log(self, fmt, columns):
        if self.fp:
            if self.csv:
                try:
                    self.csv.writerow(columns)
                except UnicodeEncodeError:
                    self.csv.writerow(self._fix_unicode_list(columns))
            else:
                try:
                    self.fp.write(fmt % tuple(columns))
                except UnicodeEncodeError:
                    self.fp.write(fmt % tuple(self._fix_unicode_list(columns)))

            self.fp.flush()

    def add_custom_header(self, fmt, args):
        self.custom_verbose_format = fmt
        self.custom_verbose_args = args

    def header(self, *args, **kwargs):
        file_name = None
        self.num_columns = len(args)

        if has_key(kwargs, 'file_name'):
            file_name = kwargs['file_name']

        if self.verbose and file_name:
            md5sum = binwalk.core.common.file_md5(file_name)
            timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")

            if self.csv:
                self.log("", ["FILE", "MD5SUM", "TIMESTAMP"])
                self.log("", [file_name, md5sum, timestamp])

            self._fprint("%s", "\n", csv=False)
            self._fprint("Scan Time:     %s\n", [timestamp], csv=False, filter=False)
            self._fprint("Target File:   %s\n", [file_name], csv=False, filter=False)
            self._fprint("MD5 Checksum:  %s\n", [md5sum], csv=False, filter=False)
            if self.custom_verbose_format and self.custom_verbose_args:
                self._fprint(self.custom_verbose_format, self.custom_verbose_args, csv=False, filter=False)

        self._fprint("%s", "\n", csv=False, filter=False)
        self._fprint(self.header_format, args, filter=False)
        self._fprint("%s", ["-" * self.HEADER_WIDTH + "\n"], csv=False, filter=False)

    def result(self, *args):
        # Convert to list for item assignment
        args = list(args)

        # Replace multiple spaces with single spaces. This is to prevent accidentally putting
        # four spaces in the description string, which would break auto-formatting.
        for i in range(len(args)):
            if isinstance(args[i], str):
                while "    " in args[i]:
                    args[i] = args[i].replace("  " , " ")

        self._fprint(self.result_format, tuple(args))

    def footer(self):
        self._fprint("%s", "\n", csv=False, filter=False)

    def _fprint(self, fmt, columns, csv=True, stdout=True, filter=True):
        line = fmt % tuple(columns)

        if not self.quiet and stdout:
            try:
                try:
                    sys.stdout.write(self._format_line(line.strip()) + "\n")
                except UnicodeEncodeError:
                    line = self._fix_unicode(line)
                    sys.stdout.write(self._format_line(line.strip()) + "\n")
                sys.stdout.flush()
            except IOError as e:
                pass

        if self.fp and not (self.csv and not csv):
            self.log(fmt, columns)

    def _append_to_data_parts(self, data, start, end):
        '''
        Intelligently appends data to self.string_parts.
        For use by self._format.
        '''
        try:
            while data[start] == ' ':
                start += 1

            if start == end:
                end = len(data[start:])

            self.string_parts.append(data[start:end])
        except KeyboardInterrupt as e:
            raise e
        except Exception:
            try:
                self.string_parts.append(data[start:])
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass

        return start

    def _format_line(self, line):
        '''
        Formats a line of text to fit in the terminal window.
        For Tim.
        '''
        delim = '\n'
        offset = 0
        self.string_parts = []

        # Split the line into an array of columns, e.g., ['0', '0x00000000', 'Some description here']
        line_columns = line.split(None, self.num_columns-1)
        if line_columns:
            # Find where the start of the last column (description) starts in the line of text.
            # All line wraps need to be aligned to this offset.
            offset = line.rfind(line_columns[-1])
            # The delimiter will be a newline followed by spaces padding out the line wrap to the alignment offset.
            delim += ' ' * offset

        if line_columns and self.fit_to_screen and len(line) > self.SCREEN_WIDTH:
            # Calculate the maximum length that each wrapped line can be
            max_line_wrap_length = self.SCREEN_WIDTH - offset
            # Append all but the last column to formatted_line
            formatted_line = line[:offset]

            # Loop to split up line into multiple max_line_wrap_length pieces
            while len(line[offset:]) > max_line_wrap_length:
                # Find the nearest space to wrap the line at (so we don't split a word across two lines)
                split_offset = line[offset:offset+max_line_wrap_length].rfind(' ')
                # If there were no good places to split the line, just truncate it at max_line_wrap_length
                if split_offset < 1:
                    split_offset = max_line_wrap_length

                self._append_to_data_parts(line, offset, offset+split_offset)
                offset += split_offset

            # Add any remaining data (guarunteed to be max_line_wrap_length long or shorter) to self.string_parts
            self._append_to_data_parts(line, offset, offset+len(line[offset:]))

            # Append self.string_parts to formatted_line; each part seperated by delim
            formatted_line += delim.join(self.string_parts)
        else:
            formatted_line = line

        return formatted_line

    def _configure_formatting(self):
        '''
        Configures output formatting, and fitting output to the current terminal width.

        Returns None.
        '''
        self.format_strings(self.DEFAULT_FORMAT, self.DEFAULT_FORMAT)

        if self.fit_to_screen:
            try:
                import fcntl
                import struct
                import termios

                # Get the terminal window width
                hw = struct.unpack('hh', fcntl.ioctl(1, termios.TIOCGWINSZ, '1234'))
                self.SCREEN_WIDTH = self.HEADER_WIDTH = hw[1]
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/idb.py`:

```py
# Special overrides/workarounds for running as an IDA plugin

import io
import os
import logging

class ShutUpHashlib(logging.Filter):
    '''
    This is used to suppress hashlib exception messages
    if using the Python interpreter bundled with IDA.
    '''
    def filter(self, record):
        return not record.getMessage().startswith("code for hash")

try:
    import idc
    import idaapi
    LOADED_IN_IDA = True
    logger = logging.getLogger() 
    logger.addFilter(ShutUpHashlib())
except ImportError:
    LOADED_IN_IDA = False

def start_address():
    return idaapi.get_first_seg().startEA

def end_address():
    last_ea = idc.BADADDR
    seg = idaapi.get_first_seg()

    while seg:
        last_ea = seg.endEA
        seg = idaapi.get_next_seg(last_ea)

    return last_ea

class IDBFileIO(io.FileIO):
    '''
    A custom class to override binwalk.core.common.Blockfile in order to
    read data directly out of the IDB, rather than reading from the original
    file on disk, which may or may not still exist.

    Requests to read from files that are not the current IDB are just forwarded
    up to io.FileIO.
    '''

    def __init__(self, fname, mode):
        if idc.GetIdbPath() != fname:
            self.__idb__ = False
            super(IDBFileIO, self).__init__(fname, mode)
        else:
            self.__idb__ = True
            self.name = fname

            self.idb_start = 0
            self.idb_pos = 0
            self.idb_end = end_address()

            if self.args.size == 0:
                self.args.size = end_address()
            
            if self.args.offset == 0:
                self.args.offset = start_address()
            elif self.args.offset < 0:
                self.args.length = self.args.offset * -1
                self.args.offset = end_address() + self.args.offset

            if self.args.length == 0 or self.args.length > (end_address() - start_address()):
                self.args.length = end_address() - start_address()

    def read(self, n=-1):
        if not self.__idb__:
            return super(IDBFileIO, self).read(n)
        else:
            data = ''
            read_count = 0
            filler_count = 0

            # Loop to read n bytes of data across IDB segments, filling
            # segment gaps with NULL bytes.
            while n and self.idb_pos <= self.idb_end:
                segment = idaapi.getseg(self.idb_pos)

                if not segment:
                    filler_count += 1
                    self.idb_pos += 1
                    n -= 1
                else:
                    if filler_count:
                        data += "\x00" * filler_count
                        filler_count = 0
                    
                    if (self.idb_pos + n) > segment.endEA:
                        read_count = segment.endEA - self.idb_pos
                    else:
                        read_count = n

                    try:
                        data += idc.GetManyBytes(self.idb_pos, read_count)
                    except TypeError as e:
                        # This happens when trying to read from uninitialized segments (e.g., .bss)
                        data += "\x00" * read_count

                    n -= read_count
                    self.idb_pos += read_count

            if filler_count:
                data += "\x00" * filler_count
                filler_count = 0

            return data

    def write(self, data):
        if not self.__idb__:
            return super(IDBFileIO, self).write(data)
        else:
            # Don't actually write anything to the IDB, as, IMHO,
            # a binwalk plugin should never do this. But return the
            # number of bytes we were requested to write so that 
            # any callers are happy.
            return len(data)

    def seek(self, n, whence=os.SEEK_SET):
        if not self.__idb__:
            return super(IDBFileIO, self).seek(n, whence)
        else:
            if whence == os.SEEK_SET:
                self.idb_pos = self.idb_start + n
            elif whence == os.SEEK_CUR:
                self.idb_pos += n
            elif whence == os.SEEK_END:
                self.idb_pos = self.idb_end + n

    def tell(self):
        if not self.__idb__:
            return super(IDBFileIO, self).tell()
        else:
            return self.idb_pos


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/magic.py`:

```py
# A pure Python replacement for libmagic. Supports most libmagic features, plus
# several additional features not provided by libmagic. Tailored specifically
# for quickly searching blocks of data for multiple embedded signatures.

__all__ = ['Magic']

import re
import struct
import datetime
import binwalk.core.common
import binwalk.core.compat

class ParserException(Exception):
    '''
    Exception thrown specifically for signature file parsing errors.
    '''
    pass

class SignatureResult(binwalk.core.module.Result):
    '''
    Container class for signature results.
    '''
    def __init__(self, **kwargs):
        # These are set by signature keyword tags.
        # Keyword tags can also set any other object attributes,
        # including those in binwalk.core.module.Result.
        self.jump = 0
        self.many = False
        self.adjust = 0
        self.strlen = 0
        self.string = False
        self.invalid = False
        self.once = False
        self.overlap = False

        # These are set by code internally
        self.id = 0

        # Kwargs overrides the defaults set above
        super(self.__class__, self).__init__(**kwargs)

        self.valid = (not self.invalid)

class SignatureLine(object):
    '''
    Responsible for parsing signature lines from magic signature files.
    '''

    # Printed strings are truncated to this size
    MAX_STRING_SIZE = 128

    def __init__(self, line):
        '''
        Class constructor. Responsible for parsing a line from a signature file.

        @line - A line of text from the signature file.

        Returns None.
        '''
        self.tags = {}
        self.text = line
        self.regex = False

        # Split the line on any white space; for this to work, backslash-escaped
        # spaces ('\ ') are replaced with their escaped hex value ('\x20').
        #
        # [offset] [data type] [comparison value] [format string]
        # 0        belong      0x12345678         Foo file type,
        # >4       string      x                  file name: %s,
        parts = line.replace('\\ ', '\\x20').split(None, 3)

        # Sanity check on the split line
        if len(parts) not in [3, 4]:
            raise ParserException("Invalid signature line: '%s'" % line)

        # The indentation level is determined by the number of '>' characters at
        # the beginning of the signature line.
        self.level = parts[0].count('>')

        # Get rid of the indentation characters and try to convert the remaining
        # characters to an integer offset. This will fail if the offset is a complex
        # value (e.g., '(4.l+16)').
        self.offset = parts[0].replace('>', '')
        try:
            self.offset = int(self.offset, 0)
        except ValueError as e:
            pass

        # self.type is the specified data type ('belong', 'string', etc)
        self.type = parts[1]
        self.opvalue = None
        self.operator = None

        # Each data type can specify an additional operation to be performed on the
        # data being scanned before performing a comparison (e.g., 'belong&0xFF' will
        # AND the data with 0xFF before the comparison is performed).
        #
        # We support the following operators:
        for operator in ['&', '|', '*', '+', '-', '/', '~', '^']:
            # Look for each operator in self.type
            if operator in self.type:
                # If found, split self.type into the type and operator value
                (self.type, self.opvalue) = self.type.split(operator, 1)

                # Keep a record of the specified operator
                self.operator = operator

                # Try to convert the operator value into an integer. This works for
                # simple operator values, but not for complex types (e.g., '(4.l+12)').
                try:
                    self.opvalue = int(self.opvalue, 0)
                except ValueError as e:
                    pass

                # Only one operator type is supported, so break as soon as one is found
                break

        # If the specified type starts with 'u' (e.g., 'ubelong'), then it is unsigned; else, it is signed
        if self.type[0] == 'u':
            self.signed = False
            self.type = self.type[1:]
        else:
            self.signed = True

        # Big endian values start with 'be' ('belong'), little endian values start with 'le' ('lelong').
        # The struct module uses '>' to denote big endian and '<' to denote little endian.
        if self.type.startswith('be'):
            self.type = self.type[2:]
            self.endianess = '>'
        elif self.type.startswith('le'):
            self.endianess = '<'
            self.type = self.type[2:]
        # Assume big endian if no endianess was explicitly specified
        else:
            self.endianess = '>'

        # Check the comparison value for the type of comparison to be performed (e.g.,
        # '=0x1234', '>0x1234', etc). If no operator is specified, '=' is implied.
        if parts[2][0] in ['=', '!', '>', '<', '&', '|', '^', '~']:
            self.condition = parts[2][0]
            self.value = parts[2][1:]
        else:
            self.condition = '='
            self.value = parts[2]

        # If this is a wildcard value, explicitly set self.value to None
        if self.value == 'x':
            self.value = None
        # String values need to be decoded, as they may contain escape characters (e.g., '\x20')
        elif self.type == 'string':
            # String types support multiplication to easily match large repeating byte sequences
            if '*' in self.value:
                try:
                    p = self.value.split('*')
                    self.value = p[0]
                    for n in p[1:]:
                        self.value *= int(n, 0)
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    raise ParserException("Failed to expand string '%s' with integer '%s' in line '%s'" % (self.value, n, line))
            try:
                self.value = binwalk.core.compat.string_decode(self.value)
            except ValueError as e:
                raise ParserException("Failed to decode string value '%s' in line '%s'" % (self.value, line))
        # If a regex was specified, compile it
        elif self.type == 'regex':
            self.regex = True

            try:
                self.value = re.compile(self.value)
            except KeyboardInterrupt as e:
                raise e
            except Exception as e:
                raise ParserException("Invalid regular expression '%s': %s" % (self.value, str(e)))
        # Non-string types are integer values
        else:
            try:
                self.value = int(self.value, 0)
            except ValueError as e:
                raise ParserException("Failed to convert value '%s' to an integer on line '%s'" % (self.value, line))

        # Sanity check to make sure the first line of a signature has an explicit value
        if self.level == 0 and self.value is None:
            raise ParserException("First element of a signature must specify a non-wildcard value: '%s'" % (line))

        # Set the size and struct format value for the specified data type.
        # This must be done, obviously, after the value has been parsed out above.
        if self.type == 'string':
            # Strings don't have a struct format value, since they don't have to be unpacked
            self.fmt = None

            # If a string type has a specific value, set the comparison size to the length of that string
            if self.value:
                self.size = len(self.value)
            # Else, truncate the string to self.MAX_STRING_SIZE
            else:
                self.size = self.MAX_STRING_SIZE
        elif self.type == 'regex':
            # Regular expressions don't have a struct format value, since they don't have to be unpacked
            self.fmt = None
            # The size of a matching regex is unknown until it is applied to some data
            self.size = self.MAX_STRING_SIZE
        elif self.type == 'byte':
            self.fmt = 'b'
            self.size = 1
        elif self.type == 'short':
            self.fmt = 'h'
            self.size = 2
        elif self.type == 'quad':
            self.fmt = 'q'
            self.size = 8
        # Assume 4 byte length for all other data types
        else:
            self.fmt = 'i'
            self.size = 4

        # The struct module uses the same characters for specifying signed and unsigned data types,
        # except that signed data types are upper case. The above if-else code sets self.fmt to the
        # lower case (unsigned) values.
        if not self.signed:
            self.fmt = self.fmt.upper()

        # If a struct format was identified, create a format string to be passed to struct.unpack
        # which specifies the endianess and data type format.
        if self.fmt:
            self.pkfmt = '%c%c' % (self.endianess, self.fmt)
        else:
            self.pkfmt = None

        # Check if a format string was specified (this is optional)
        if len(parts) == 4:
            # %lld formats are only supported if Python was built with HAVE_LONG_LONG
            self.format = parts[3].replace('%ll', '%l')

            # Regex to parse out tags, which are contained within curly braces
            retag = re.compile(r'\{.*?\}')

            # Parse out tag keywords from the format string
            for match in retag.finditer(self.format):
                # Get rid of the curly braces.
                tag = match.group().replace('{', '').replace('}', '')

                # If the tag specifies a value, it will be colon delimited (e.g., '{name:%s}')
                if ':' in tag:
                    (n, v) = tag.split(':', 1)
                else:
                    n = tag
                    v = True

                # Create a new SignatureTag instance and append it to self.tags
                self.tags[n] = v

            # Remove all tags from the printable format string
            self.format = retag.sub('', self.format).strip()
        else:
            self.format = ""

class Signature(object):
    '''
    Class to hold signature data and generate signature regular expressions.
    '''

    def __init__(self, id, first_line):
        '''
        Class constructor.

        @id         - A ID value to uniquely identify this signature.
        @first_line - The first SignatureLine of the signature (subsequent
                      SignatureLines should be added via self.append).

        Returns None.
        '''
        self.id = id
        self.lines = [first_line]
        self.title = first_line.format
        self.offset = first_line.offset
        self.regex = self._generate_regex(first_line)
        try:
            self.confidence = first_line.tags['confidence']
        except KeyError:
            self.confidence = first_line.size

    def _generate_regex(self, line):
        '''
        Generates a regular expression from the magic bytes of a signature.
        The regex is used by Magic._analyze.

        @line - The first SignatureLine object of the signature.

        Returns a compile regular expression.
        '''
        restr = ""

        # Strings and single byte signatures are taken at face value;
        # multi-byte integer values are turned into regex strings based
        # on their data type size and endianess.
        if line.type == 'regex':
            # Regex types are already compiled expressions.
            # Note that since re.finditer is used, unless the specified
            # regex accounts for it, overlapping signatures will be ignored.
            return line.value
        if line.type == 'string':
            restr = line.value
        elif line.size == 1:
            restr = chr(line.value)
        elif line.size == 2:
            if line.endianess == '<':
                restr = chr(line.value & 0xFF) + chr(line.value >> 8)
            elif line.endianess == '>':
                restr = chr(line.value >> 8) + chr(line.value & 0xFF)
        elif line.size == 4:
            if line.endianess == '<':
                restr =          (chr(line.value & 0xFF) +
                                  chr((line.value >> 8) & 0xFF) +
                                  chr((line.value >> 16) & 0xFF) +
                                  chr(line.value >> 24))
            elif line.endianess == '>':
                restr =          (chr(line.value >> 24) +
                                  chr((line.value >> 16) & 0xFF) +
                                  chr((line.value >> 8) & 0xFF) +
                                  chr(line.value & 0xFF))
        elif line.size == 8:
            if line.endianess == '<':
                restr =          (chr(line.value & 0xFF) +
                                  chr((line.value >> 8) & 0xFF) +
                                  chr((line.value >> 16) & 0xFF) +
                                  chr((line.value >> 24) & 0xFF) +
                                  chr((line.value >> 32) & 0xFF) +
                                  chr((line.value >> 40) & 0xFF) +
                                  chr((line.value >> 48) & 0xFF) +
                                  chr(line.value >> 56))
            elif line.endianess == '>':
                restr =          (chr(line.value >> 56) +
                                  chr((line.value >> 48) & 0xFF) +
                                  chr((line.value >> 40) & 0xFF) +
                                  chr((line.value >> 32) & 0xFF) +
                                  chr((line.value >> 24) & 0xFF) +
                                  chr((line.value >> 16) & 0xFF) +
                                  chr((line.value >> 8) & 0xFF) +
                                  chr(line.value & 0xFF))

        # Since re.finditer is used on a per-signature basis, signatures should be crafted carefully
        # to ensure that they aren't potentially self-overlapping (e.g., a signature of "ABCDAB" could
        # be confused by the byte sequence "ABCDABCDAB"). The longer the signature, the less likely an
        # unintentional overlap is, although files could still be maliciously crafted to cause false
        # negative results.
        #
        # Thus, unless a signature has been explicitly marked as knowingly overlapping ('{overlap}'),
        # spit out a warning about any self-overlapping signatures.
        if not binwalk.core.compat.has_key(line.tags, 'overlap'):
            for i in range(1, line.size):
                if restr[i:] == restr[0:(line.size-i)]:
                    binwalk.core.common.warning("Signature '%s' is a self-overlapping signature!" % line.text)
                    break

        return re.compile(re.escape(restr))

    def append(self, line):
        '''
        Add a new SignatureLine object to the signature.

        @line - A new SignatureLine instance.

        Returns None.
        '''
        # This method is kind of useless, but may be a nice wrapper for future code.
        self.lines.append(line)

class Magic(object):
    '''
    Primary class for loading signature files and scanning
    blocks of arbitrary data for matching signatures.
    '''

    def __init__(self, exclude=[], include=[], invalid=False):
        '''
        Class constructor.

        @include - A list of regex strings describing which signatures should be included in the scan results.
        @exclude - A list of regex strings describing which signatures should not be included in the scan results.
        @invalid - If set to True, invalid results will not be ignored.

        Returns None.
        '''
        # Used to save the block of data passed to self.scan (see additional comments in self.scan)
        self.data = ""
        # A list of Signature class objects, populated by self.parse (see also: self.load)
        self.signatures = []
        # A set of signatures with the 'once' keyword that have already been displayed once
        self.display_once = set()
        self.dirty = True

        self.show_invalid = invalid
        self.includes = [re.compile(x) for x in include]
        self.excludes = [re.compile(x) for x in exclude]

        # Regex rule to replace backspace characters (an the preceeding character)
        # in formatted signature strings (see self._analyze).
        self.bspace = re.compile(".\\\\b")
        # Regex rule to match printable ASCII characters in formatted signature
        # strings (see self._analyze).
        self.printable = re.compile("[ -~]*")
        # Regex rule to find format strings
        self.fmtstr = re.compile("%[^%]")
        # Regex rule to find periods (see self._do_math)
        self.period = re.compile("\.")

    def _filtered(self, text):
        '''
        Tests if a string should be filtered out or not.

        @text - The string to check against filter rules.

        Returns True if the string should be filtered out, i.e., not displayed.
        Returns False if the string should be displayed.
        '''
        filtered = None
        # Text is converted to lower case first, partially for historical
        # purposes, but also because it simplifies writing filter rules
        # (e.g., don't have to worry about case sensitivity).
        text = text.lower()

        for include in self.includes:
            if include.search(text):
                filtered = False
                break

        # If exclusive include filters have been specified and did
        # not match the text, then the text should be filtered out.
        if self.includes and filtered == None:
            return True

        for exclude in self.excludes:
            if exclude.search(text):
                filtered = True
                break

        # If no explicit exclude filters were matched, then the
        # text should *not* be filtered.
        if filtered == None:
            filtered = False

        return filtered

    def _do_math(self, offset, expression):
        '''
        Parses and evaluates complex expressions, e.g., "(4.l+12)", "(6*32)", etc.

        @offset      - The offset inside self.data that the current signature starts at.
        @expressions - The expression to evaluate.

        Returns an integer value that is the result of the evaluated expression.
        '''
        # Does the expression contain an offset (e.g., "(4.l+12)")?
        if '.' in expression and '(' in expression:
            replacements = {}

            for period in [match.start() for match in self.period.finditer(expression)]:
                # Separate the offset field into the integer offset and type values (o and t respsectively)
                s = expression[:period].rfind('(') + 1
                # The offset address may be an evaluatable expression, such as '(4+0.L)', typically the result
                # of the original offset being something like '(&0.L)'.
                o = binwalk.core.common.MathExpression(expression[s:period]).value
                t = expression[period+1]

                # Re-build just the parsed offset portion of the expression
                text = "%s.%c" % (expression[s:period], t)

                # Have we already evaluated this offset expression? If so, skip it.
                if binwalk.core.common.has_key(replacements, text):
                    continue

                # The offset specified in the expression is relative to the starting offset inside self.data
                o += offset

                # Read the value from self.data at the specified offset
                try:
                    # Big and little endian byte format
                    if t in ['b', 'B']:
                        v = struct.unpack('b', binwalk.core.compat.str2bytes(self.data[o:o+1]))[0]
                    # Little endian short format
                    elif t == 's':
                        v = struct.unpack('<h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
                    # Little endian long format
                    elif t == 'l':
                        v = struct.unpack('<i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
                    # Big endian short format
                    elif t == 'S':
                        v = struct.unpack('>h', binwalk.core.compat.str2bytes(self.data[o:o+2]))[0]
                    # Bit endian long format
                    elif t == 'L':
                        v = struct.unpack('>i', binwalk.core.compat.str2bytes(self.data[o:o+4]))[0]
                # struct.error is thrown if there is not enough bytes in self.data for the specified format type
                except struct.error as e:
                    v = 0

                # Keep track of all the recovered values from self.data
                replacements[text] = v

            # Finally, replace all offset expressions with their corresponding text value
            v = expression
            for (text, value) in binwalk.core.common.iterator(replacements):
                v = v.replace(text, "%d" % value)

        # If no offset, then it's just an evaluatable math expression (e.g., "(32+0x20)")
        else:
            v = expression

        # Evaluate the final expression
        value = binwalk.core.common.MathExpression(v).value

        return value

    def _analyze(self, signature, offset):
        '''
        Analyzes self.data for the specified signature data at the specified offset .

        @signature - The signature to apply to the data.
        @offset    - The offset in self.data to apply the signature to.

        Returns a dictionary of tags parsed from the data.
        '''
        description = []
        tag_strlen = None
        max_line_level = 0
        previous_line_end = 0
        tags = {'id' : signature.id, 'offset' : offset, 'invalid' : False, 'once' : False}

        # Apply each line of the signature to self.data, starting at the specified offset
        for n in range(0, len(signature.lines)):
            line = signature.lines[n]

            # Ignore indentation levels above the current max indent level
            if line.level <= max_line_level:
                # If the relative offset of this signature line is just an integer value, use it
                if isinstance(line.offset, int):
                    line_offset = line.offset
                # Else, evaluate the complex expression
                else:
                    # Format the previous_line_end value into a string. Add the '+' sign to explicitly
                    # state that this value is to be added to any subsequent values in the expression
                    # (e.g., '&0' becomes '4+0').
                    ple = '%d+' % previous_line_end
                    # Allow users to use either the '&0' (libmagic) or '&+0' (explcit addition) sytaxes;
                    # replace both with the ple text.
                    line_offset_text = line.offset.replace('&+', ple).replace('&', ple)
                    # Evaluate the expression
                    line_offset = self._do_math(offset, line_offset_text)

                # Sanity check
                if not isinstance(line_offset, int):
                    raise ParserException("Failed to convert offset '%s' to a number: '%s'" % (line.offset, line.text))

                # The start of the data needed by this line is at offset + line_offset.
                # The end of the data will be line.size bytes later.
                start = offset + line_offset
                end = start + line.size

                # If the line has a packed format string, unpack it
                if line.pkfmt:
                    try:
                        dvalue = struct.unpack(line.pkfmt, binwalk.core.compat.str2bytes(self.data[start:end]))[0]
                    # Not enough bytes left in self.data for the specified format size
                    except struct.error as e:
                        dvalue = 0
                # Else, this is a string
                else:
                    # Wildcard strings have line.value == None
                    if line.value is None:
                        # Check to see if this is a string whose size is known and has been specified on a previous
                        # signature line.
                        if binwalk.core.compat.has_key(tags, 'strlen') and binwalk.core.compat.has_key(line.tags, 'string'):
                            dvalue = self.data[start:(start+tags['strlen'])]
                        # Else, just terminate the string at the first newline, carriage return, or NULL byte
                        else:
                            dvalue = self.data[start:end].split('\x00')[0].split('\r')[0].split('\n')[0]
                    # Non-wildcard strings have a known length, specified in the signature line
                    else:
                        dvalue = self.data[start:end]

                # Some integer values have special operations that need to be performed on them
                # before comparison (e.g., "belong&0x0000FFFF"). Complex math expressions are
                # supported here as well.
                #if isinstance(dvalue, int) and line.operator:
                if line.operator:
                    try:
                        # If the operator value of this signature line is just an integer value, use it
                        if isinstance(line.opvalue, int) or isinstance(line.opvalue, long):
                            opval = line.opvalue
                        # Else, evaluate the complex expression
                        else:
                            opval = self._do_math(offset, line.opvalue)

                        # Perform the specified operation
                        if line.operator == '&':
                            dvalue &= opval
                        elif line.operator == '|':
                            dvalue |= opval
                        elif line.operator == '*':
                            dvalue *= opval
                        elif line.operator == '+':
                            dvalue += opval
                        elif line.operator == '-':
                            dvalue -= opval
                        elif line.operator == '/':
                            dvalue /= opval
                        elif line.operator == '~':
                            dvalue = ~opval
                        elif line.operator == '^':
                            dvalue ^= opval
                    except KeyboardInterrupt as e:
                        raise e
                    except Exception as e:
                        raise ParserException("Operation '" + str(dvalue) + " " + str(line.operator) + "= " + str(line.opvalue) + "' failed: " + str(e))

                # Does the data (dvalue) match the specified comparison?
                if ((line.value is None) or
                    (line.regex and line.value.match(dvalue)) or
                    (line.condition == '=' and dvalue == line.value) or
                    (line.condition == '>' and dvalue > line.value) or
                    (line.condition == '<' and dvalue < line.value) or
                    (line.condition == '!' and dvalue != line.value) or
                    (line.condition == '~' and (dvalue == ~line.value)) or
                    (line.condition == '^' and (dvalue ^ line.value)) or
                    (line.condition == '&' and (dvalue & line.value)) or
                    (line.condition == '|' and (dvalue | line.value))):

                    # Up until this point, date fields are treated as integer values,
                    # but we want to display them as nicely formatted strings.
                    if line.type == 'date':
                        ts = datetime.datetime.utcfromtimestamp(dvalue)
                        dvalue = ts.strftime("%Y-%m-%d %H:%M:%S")

                    # Generate the tuple for the format string
                    dvalue_tuple = ()
                    for x in self.fmtstr.finditer(line.format):
                        dvalue_tuple += (dvalue,)

                    # Format the description string
                    desc = line.format % dvalue_tuple

                    # If there was any description string, append it to the list of description string parts
                    if desc:
                        description.append(desc)

                    # Process tag keywords specified in the signature line. These have already been parsed out of the
                    # original format string so that they can be processed separately from the printed description string.
                    for (tag_name, tag_value) in binwalk.core.compat.iterator(line.tags):
                        # If the tag value is a string, try to format it
                        if isinstance(tag_value, str):
                            # Generate the tuple for the format string
                            dvalue_tuple = ()
                            for x in self.fmtstr.finditer(tag_value):
                                dvalue_tuple += (dvalue,)

                            # Format the tag string
                            tags[tag_name] = tag_value % dvalue_tuple
                        # Else, just use the raw tag value
                        else:
                            tags[tag_name] = tag_value

                        # Some tag values are intended to be integer values, so try to convert them as such
                        try:
                            tags[tag_name] = int(tags[tag_name], 0)
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            pass

                    # Abort processing soon as this signature is marked invalid, unless invalid results
                    # were explicitly requested. This means that the sooner invalid checks are made in a
                    # given signature, the faster the scan can filter out false positives.
                    if not self.show_invalid and tags['invalid']:
                        break

                    # Look ahead to the next line in the signature; if its indent level is greater than
                    # that of the current line, then track the end of data for the current line. This is
                    # so that subsequent lines can use the '>>&0' offset syntax to specify relative offsets
                    # from previous lines.
                    try:
                        next_line = signature.lines[n+1]
                        if next_line.level > line.level:
                            if line.type == 'string':
                                previous_line_end = line_offset + len(dvalue)
                            else:
                                previous_line_end = line_offset + line.size
                    except IndexError as e:
                        pass

                    # If this line satisfied its comparison, +1 the max indentation level
                    max_line_level = line.level + 1
                else:
                    # No match on the first line, abort
                    if line.level == 0:
                        break
                    else:
                        # If this line did not satisfy its comparison, then higher
                        # indentation levels will not be accepted.
                        max_line_level = line.level

        # Join the formatted description strings and remove backspace characters (plus the preceeding character as well)
        tags['description'] = self.bspace.sub('', " ".join(description))

        # This should never happen
        if not tags['description']:
            tags['display'] = False
            tags['invalid'] = True

        # If the formatted string contains non-printable characters, consider it invalid
        if self.printable.match(tags['description']).group() != tags['description']:
            tags['invalid'] = True

        return tags

    def match(self, data):
        '''
        Match the beginning of a data buffer to a signature.

        @data - The data buffer to match against the loaded signature list.

        Returns a list of SignatureResult objects.
        '''
        return self.scan(data, 1)

    def scan(self, data, dlen=None):
        '''
        Scan a data block for matching signatures.

        @data - A string of data to scan.
        @dlen - If specified, signatures at offsets larger than dlen will be ignored.

        Returns a list of SignatureResult objects.
        '''
        results = []
        matched_offsets = set()

        # Since data can potentially be quite a large string, make it available to other
        # methods via a class attribute so that it doesn't need to be passed around to
        # different methods over and over again.
        self.data = data

        # If dlen wasn't specified, search all of self.data
        if dlen is None:
            dlen = len(data)

        for signature in self.signatures:
            # Use regex to search the data block for potential signature matches (fast)
            for match in signature.regex.finditer(data):
                # Take the offset of the start of the signature into account
                offset = match.start() - signature.offset

                # Signatures are ordered based on the length of their magic bytes (largest first).
                # If this offset has already been matched to a previous signature, ignore it unless
                # self.show_invalid has been specified. Also ignore obviously invalid offsets (<1)
                # as well as those outside the specified self.data range (dlen).
                if (offset not in matched_offsets or self.show_invalid) and offset >= 0 and offset < dlen:
                #if offset >= 0 and offset < dlen:
                    # Analyze the data at this offset using the current signature rule
                    tags = self._analyze(signature, offset)

                    # Generate a SignatureResult object and append it to the results list if the
                    # signature is valid, or if invalid results were requested.
                    if (not tags['invalid'] or self.show_invalid) and not self._filtered(tags['description']):
                        # Only display results with the 'once' tag once.
                        if tags['once']:
                            if signature.title in self.display_once:
                                continue
                            else:
                                self.display_once.add(signature.title)

                        # Append the result to the results list
                        results.append(SignatureResult(**tags))

                        # Add this offset to the matched_offsets set, so that it can be ignored by
                        # subsequent loops.
                        matched_offsets.add(offset)

        # Sort results by offset
        results.sort(key=lambda x: x.offset, reverse=False)

        return results

    def load(self, fname):
        '''
        Load signatures from a file.

        @fname - Path to signature file.

        Returns None.
        '''
        # Magic files must be ASCII, else encoding issues can arise.
        fp = open(fname, "r")
        lines = fp.readlines()
        self.parse(lines)
        fp.close()

    def parse(self, lines):
        '''
        Parse signature file lines.

        @lines - A list of lines from a signature file.

        Returns None.
        '''
        signature = None

        for line in lines:
            # Split at the first comment delimiter (if any) and strip the result
            line = line.split('#')[0].strip()
            # Ignore blank lines and lines that are nothing but comments.
            # We also don't support the '!mime' style line entries.
            if line and line[0] != '!':
                # Parse this signature line
                sigline = SignatureLine(line)
                # Level 0 means the first line of a signature entry
                if sigline.level == 0:
                    # If there is an existing signature, append it to the signature list,
                    # unless the text in its title field has been filtered by user-defined
                    # filter rules.
                    if signature and not self._filtered(signature.title):
                        self.signatures.append(signature)

                    # Create a new signature object; use the size of self.signatures to
                    # assign each signature a unique ID.
                    signature = Signature(len(self.signatures), sigline)
                # Else, just append this line to the existing signature
                elif signature:
                    #signature.append(sigline)
                    signature.lines.append(sigline)
                # If this is not the first line of a signature entry and there is no other
                # existing signature entry, something is very wrong with the signature file.
                else:
                    raise ParserException("Invalid signature line: '%s'" % line)

        # Add the final signature to the signature list
        if signature:
            if not self._filtered(signature.lines[0].format):
                self.signatures.append(signature)

        # Sort signatures by confidence (aka, length of their magic bytes), largest first
        self.signatures.sort(key=lambda x: x.confidence, reverse=True)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/module.py`:

```py
# Core code relating to binwalk modules and supporting classes.
# In particular, the Module class (base class for all binwalk modules)
# and the Modules class (main class for managing and executing binwalk modules)
# are most critical.

import io
import os
import sys
import time
import inspect
import argparse
import traceback
import binwalk.core.statuserver
import binwalk.core.common
import binwalk.core.settings
import binwalk.core.plugin
from threading import Thread
from binwalk.core.compat import *

class Option(object):
    '''
    A container class that allows modules to declare command line options.
    '''

    def __init__(self, kwargs={}, priority=0, description="", short="", long="", type=None, dtype=None, hidden=False):
        '''
        Class constructor.

        @kwargs      - A dictionary of kwarg key-value pairs affected by this command line option.
        @priority    - A value from 0 to 100. Higher priorities will override kwarg values set by lower priority options.
        @description - A description to be displayed in the help output.
        @short       - The short option to use (optional).
        @long        - The long option to use (if None, this option will not be displayed in help output).
        @type        - The accepted data type (one of: io.FileIO/argparse.FileType/binwalk.core.common.BlockFile, list, str, int, float).
        @dtype       - The displayed accepted type string, to be shown in help output.
        @hidden      - If set to True, this option will not be displayed in the help output.

        Returns None.
        '''
        self.kwargs = kwargs
        self.priority = priority
        self.description = description
        self.short = short
        self.long = long
        self.type = type
        self.dtype = dtype
        self.hidden = hidden

        if not self.dtype and self.type:
            if self.type in [io.FileIO, argparse.FileType, binwalk.core.common.BlockFile]:
                self.dtype = 'file'
            elif self.type in [int, float, str]:
                self.dtype = self.type.__name__
            else:
                self.type = str
                self.dtype = str.__name__

    def convert(self, value, default_value):
        if self.type and (self.type.__name__ == self.dtype):
            # Be sure to specify a base of 0 for int() so that the base is auto-detected
            if self.type == int:
                t = self.type(value, 0)
            else:
                t = self.type(value)
        elif default_value or default_value is False:
            t = default_value
        else:
            t = value

        return t

class Kwarg(object):
    '''
    A container class allowing modules to specify their expected __init__ kwarg(s).
    '''

    def __init__(self, name="", default=None, description=""):
        '''
        Class constructor.

        @name        - Kwarg name.
        @default     - Default kwarg value.
        @description - Description string.

        Return None.
        '''
        self.name = name
        self.default = default
        self.description = description

class Dependency(object):
    '''
    A container class for declaring module dependencies.
    '''

    def __init__(self, attribute="", name="", kwargs={}):
        self.attribute = attribute
        self.name = name
        self.kwargs = kwargs
        self.module = None

class Result(object):
    '''
    Generic class for storing and accessing scan results.
    '''

    def __init__(self, **kwargs):
        '''
        Class constructor.

        @offset      - The file offset of the result.
        @size        - Size of the result, if known.
        @description - The result description, as displayed to the user.
        @module      - Name of the module that generated the result.
        @file        - The file object of the scanned file.
        @valid       - Set to True if the result if value, False if invalid.
        @display     - Set to True to display the result to the user, False to hide it.
        @extract     - Set to True to flag this result for extraction.
        @plot        - Set to Flase to exclude this result from entropy plots.
        @name        - Name of the result found (None if not applicable or unknown).

        Provide additional kwargs as necessary.
        Returns None.
        '''
        self.offset = 0
        self.size = 0
        self.description = ''
        self.module = ''
        self.file = None
        self.valid = True
        self.display = True
        self.extract = True
        self.plot = True
        self.name = None

        for (k, v) in iterator(kwargs):
            setattr(self, k, v)

class Error(Result):
    '''
    A subclass of binwalk.core.module.Result.
    '''

    def __init__(self, **kwargs):
        '''
        Accepts all the same kwargs as binwalk.core.module.Result, but the following are also added:

        @exception - In case of an exception, this is the exception object.

        Returns None.
        '''
        self.exception = None
        Result.__init__(self, **kwargs)

class Module(object):
    '''
    All module classes must be subclassed from this.
    '''
    # The module title, as displayed in help output
    TITLE = ""

    # A list of binwalk.core.module.Option command line options
    CLI = []

    # A list of binwalk.core.module.Kwargs accepted by __init__
    KWARGS = []

    # A list of default dependencies for all modules; do not override this unless you
    # understand the consequences of doing so.
    DEFAULT_DEPENDS = [
            Dependency(name='General',
                       attribute='config'),
            Dependency(name='Extractor',
                       attribute='extractor'),
    ]

    # A list of binwalk.core.module.Dependency instances that can be filled in as needed by each individual module.
    DEPENDS = []

    # Format string for printing the header during a scan.
    # Must be set prior to calling self.header.
    HEADER_FORMAT = "%-12s  %-12s    %s\n"

    # Format string for printing each result during a scan.
    # Must be set prior to calling self.result.
    RESULT_FORMAT = "%-12d  0x%-12X  %s\n"

    # Format string for printing custom information in the verbose header output.
    # Must be set prior to calling self.header.
    VERBOSE_FORMAT = ""

    # The header to print during a scan.
    # Set to None to not print a header.
    # Note that this will be formatted per the HEADER_FORMAT format string.
    # Must be set prior to calling self.header.
    HEADER = ["DECIMAL", "HEXADECIMAL", "DESCRIPTION"]

    # The Result attribute names to print during a scan, as provided to the self.results method.
    # Set to None to not print any results.
    # Note that these will be formatted per the RESULT_FORMAT format string.
    # Must be set prior to calling self.result.
    RESULT = ["offset", "offset", "description"]

    # The custom data to print in the verbose header output.
    # Note that these will be formatted per the VERBOSE_FORMAT format string.
    # Must be set prior to calling self.header.
    VERBOSE = []

    # If set to True, the progress status will be automatically updated for each result
    # containing valid file and offset attributes.
    AUTO_UPDATE_STATUS = True

    # Modules with higher priorities are executed first
    PRIORITY = 5

    # Modules with a higher order are displayed first in help output
    ORDER = 5

    # Set to False if this is not a primary module (e.g., General, Extractor modules)
    PRIMARY = True

    def __init__(self, parent, **kwargs):
        self.errors = []
        self.results = []

        self.parent = parent
        self.target_file_list = []
        self.status = None
        self.enabled = False
        self.previous_next_file_fp = None
        self.current_target_file_name = None
        self.name = self.__class__.__name__
        self.plugins = binwalk.core.plugin.Plugins(self)
        self.dependencies = self.DEFAULT_DEPENDS + self.DEPENDS

        process_kwargs(self, kwargs)

        self.plugins.load_plugins()

        try:
            self.load()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            self.error(exception=e)

        try:
            self.target_file_list = list(self.config.target_files)
        except AttributeError as e:
            pass

    def __enter__(self):
        return self

    def __exit__(self, x, z, y):
        return None

    def load(self):
        '''
        Invoked at module load time.
        May be overridden by the module sub-class.
        '''
        return None

    def unload(self):
        '''
        Invoked at module load time.
        May be overridden by the module sub-class.
        '''
        return None

    def reset(self):
        '''
        Invoked only for dependency modules immediately prior to starting a new primary module.
        '''
        return None

    def init(self):
        '''
        Invoked prior to self.run.
        May be overridden by the module sub-class.

        Returns None.
        '''
        return None

    def run(self):
        '''
        Executes the main module routine.
        Must be overridden by the module sub-class.

        Returns True on success, False on failure.
        '''
        return False

    def callback(self, r):
        '''
        Processes the result from all modules. Called for all dependency modules when a valid result is found.

        @r - The result, an instance of binwalk.core.module.Result.

        Returns None.
        '''
        return None

    def validate(self, r):
        '''
        Validates the result.
        May be overridden by the module sub-class.

        @r - The result, an instance of binwalk.core.module.Result.

        Returns None.
        '''
        r.valid = True
        return None

    def _plugins_pre_scan(self):
        self.plugins.pre_scan_callbacks(self)

    def _plugins_new_file(self, fp):
        self.plugins.new_file_callbacks(fp)

    def _plugins_post_scan(self):
        self.plugins.post_scan_callbacks(self)

    def _plugins_result(self, r):
        self.plugins.scan_callbacks(r)

    def _build_display_args(self, r):
        args = []

        if self.RESULT:
            if type(self.RESULT) != type([]):
                result = [self.RESULT]
            else:
                result = self.RESULT

            for name in result:
                value = getattr(r, name)

                # Displayed offsets should be offset by the base address
                if name == 'offset':
                    value += self.config.base

                args.append(value)

        return args

    def _unload_dependencies(self):
        # Calls the unload method for all dependency modules.
        # These modules cannot be unloaded immediately after being run, as
        # they must persist until the module that depends on them is finished.
        # As such, this must be done separately from the Modules.run 'unload' call.
        for dependency in self.dependencies:
            try:
                getattr(self, dependency.attribute).unload()
            except AttributeError:
                continue

    def next_file(self, close_previous=True):
        '''
        Gets the next file to be scanned (including pending extracted files, if applicable).
        Also re/initializes self.status.
        All modules should access the target file list through this method.
        '''
        fp = None

        # Ensure files are close to prevent IOError (too many open files)
        if close_previous:
            try:
                self.previous_next_file_fp.close()
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass

        # Add any pending extracted files to the target_files list and reset the extractor's pending file list
        self.target_file_list += self.extractor.pending

        # Reset all dependencies prior to continuing with another file.
        # This is particularly important for the extractor module, which must be reset
        # in order to reset its base output directory path for each file, and the
        # list of pending files.
        self.reset_dependencies()

        while self.target_file_list:
            next_target_file = self.target_file_list.pop(0)

            # Values in self.target_file_list are either already open files (BlockFile instances), or paths
            # to files that need to be opened for scanning.
            if isinstance(next_target_file, str):
                fp = self.config.open_file(next_target_file)
            else:
                fp = next_target_file

            if not fp:
                break
            else:
                if self.config.file_name_filter(fp) == False:
                    fp.close()
                    fp = None
                    continue
                else:
                    self.status.clear()
                    self.status.total = fp.length
                    break

        if fp is not None:
            self.current_target_file_name = fp.path
            self.status.fp = fp
        else:
            self.current_target_file_name = None
            self.status.fp = None

        self.previous_next_file_fp = fp

        self._plugins_new_file(fp)

        return fp

    def clear(self, results=True, errors=True):
        '''
        Clears results and errors lists.
        '''
        if results:
            self.results = []
        if errors:
            self.errors = []

    def result(self, r=None, **kwargs):
        '''
        Validates a result, stores it in self.results and prints it.
        Accepts the same kwargs as the binwalk.core.module.Result class.

        @r - An existing instance of binwalk.core.module.Result.

        Returns an instance of binwalk.core.module.Result.
        '''
        if r is None:
            r = Result(**kwargs)

        # Add the name of the current module to the result
        r.module = self.__class__.__name__

        # Any module that is reporting results, valid or not, should be marked as enabled
        if not self.enabled:
            self.enabled = True

        self.validate(r)
        self._plugins_result(r)

        # Update the progress status automatically if it is not being done manually by the module
        if r.offset and r.file and self.AUTO_UPDATE_STATUS:
            self.status.total = r.file.length
            self.status.completed = r.offset
            self.status.fp = r.file

        for dependency in self.dependencies:
            try:
                getattr(self, dependency.attribute).callback(r)
            except AttributeError:
                continue

        if r.valid:
            self.results.append(r)

            if r.display:
                display_args = self._build_display_args(r)
                if display_args:
                    self.config.display.format_strings(self.HEADER_FORMAT, self.RESULT_FORMAT)
                    self.config.display.result(*display_args)

        return r

    def error(self, **kwargs):
        '''
        Stores the specified error in self.errors.

        Accepts the same kwargs as the binwalk.core.module.Error class.

        Returns None.
        '''
        exception_header_width = 100

        e = Error(**kwargs)
        e.module = self.__class__.__name__

        self.errors.append(e)

        if e.exception:
            sys.stderr.write("\n" + e.module + " Exception: " + str(e.exception) + "\n")
            sys.stderr.write("-" * exception_header_width + "\n")
            traceback.print_exc(file=sys.stderr)
            sys.stderr.write("-" * exception_header_width + "\n\n")
        elif e.description:
            sys.stderr.write("\n" + e.module + " Error: " + e.description + "\n\n")

    def header(self):
        '''
        Displays the scan header, as defined by self.HEADER and self.HEADER_FORMAT.

        Returns None.
        '''
        self.config.display.format_strings(self.HEADER_FORMAT, self.RESULT_FORMAT)
        self.config.display.add_custom_header(self.VERBOSE_FORMAT, self.VERBOSE)

        if type(self.HEADER) == type([]):
            self.config.display.header(*self.HEADER, file_name=self.current_target_file_name)
        elif self.HEADER:
            self.config.display.header(self.HEADER, file_name=self.current_target_file_name)

    def footer(self):
        '''
        Displays the scan footer.

        Returns None.
        '''
        self.config.display.footer()

    def reset_dependencies(self):
        # Reset all dependency modules
        for dependency in self.dependencies:
            if hasattr(self, dependency.attribute):
                getattr(self, dependency.attribute).reset()

    def main(self):
        '''
        Responsible for calling self.init, initializing self.config.display, and calling self.run.

        Returns the value returned from self.run.
        '''
        self.status = self.parent.status
        self.modules = self.parent.executed_modules

        # A special exception for the extractor module, which should be allowed to
        # override the verbose setting, e.g., if --matryoshka has been specified
        if hasattr(self, "extractor") and self.extractor.config.verbose:
            self.config.verbose = self.config.display.verbose = True

        if not self.config.files:
            binwalk.core.common.debug("No target files specified, module %s terminated" % self.name)
            return False

        self.reset_dependencies()

        try:
            self.init()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            self.error(exception=e)
            return False

        try:
            self.config.display.format_strings(self.HEADER_FORMAT, self.RESULT_FORMAT)
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            self.error(exception=e)
            return False

        self._plugins_pre_scan()

        try:
            retval = self.run()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            self.error(exception=e)
            return False

        self._plugins_post_scan()

        return retval

class Status(object):
    '''
    Class used for tracking module status (e.g., % complete).
    '''

    def __init__(self, **kwargs):
        self.kwargs = kwargs
        self.clear()

    def clear(self):
        for (k,v) in iterator(self.kwargs):
            setattr(self, k, v)

class ModuleException(Exception):
    '''
    Module exception class.
    Nothing special here except the name.
    '''
    pass

class Modules(object):
    '''
    Main class used for running and managing modules.
    '''

    def __init__(self, *argv, **kargv):
        '''
        Class constructor.

        @argv  - List of command line options. Must not include the program name (e.g., sys.argv[1:]).
        @kargv - Keyword dictionary of command line options.

        Returns None.
        '''
        self.arguments = []
        self.executed_modules = {}
        self.default_dependency_modules = {}
        self.status = Status(completed=0, total=0, fp=None, running=False, shutdown=False, finished=False)
        self.status_server_started = False
        self.status_service = None

        self._set_arguments(list(argv), kargv)

    def cleanup(self):
        if self.status_service:
            self.status_service.server.socket.shutdown(1)
            self.status_service.server.socket.close()

    def __enter__(self):
        return self

    def __exit__(self, t, v, b):
        self.cleanup()

    def _set_arguments(self, argv=[], kargv={}):
        for (k,v) in iterator(kargv):
            k = self._parse_api_opt(k)
            if v not in [True, False, None]:
                if not isinstance(v, list):
                    v = [v]
                for value in v:
                    if not isinstance(value, str):
                        value = str(bytes2str(value))
                    argv.append(k)
                    argv.append(value)
            else:
                argv.append(k)

        if not argv and not self.arguments:
            self.arguments = sys.argv[1:]
        elif argv:
            self.arguments = argv

    def _parse_api_opt(self, opt):
        # If the argument already starts with a hyphen, don't add hyphens in front of it
        if opt.startswith('-'):
            return opt
        # Short options are only 1 character
        elif len(opt) == 1:
            return '-' + opt
        else:
            return '--' + opt

    def list(self, attribute="run"):
        '''
        Finds all modules with the specified attribute.

        @attribute - The desired module attribute.

        Returns a list of modules that contain the specified attribute, in the order they should be executed.
        '''
        import binwalk.modules
        modules = {}

        for (name, module) in inspect.getmembers(binwalk.modules):
            if inspect.isclass(module) and hasattr(module, attribute):
                modules[module] = module.PRIORITY

        return sorted(modules, key=modules.get, reverse=True)

    def help(self):
        '''
        Generates formatted help output.

        Returns the help string.
        '''
        modules = {}
        help_string = "\nBinwalk v%s\nCraig Heffner, http://www.binwalk.org\n" % binwalk.core.settings.Settings.VERSION
        help_string += "\nUsage: binwalk [OPTIONS] [FILE1] [FILE2] [FILE3] ...\n"

        # Build a dictionary of modules and their ORDER attributes.
        # This makes it easy to sort modules by their ORDER attribute for display.
        for module in self.list(attribute="CLI"):
            if module.CLI:
                modules[module] = module.ORDER

        for module in sorted(modules, key=modules.get, reverse=True):
            help_string += "\n%s Options:\n" % module.TITLE

            for module_option in module.CLI:
                if module_option.long and not module_option.hidden:
                    long_opt = '--' + module_option.long

                    if module_option.dtype:
                        optargs = "=<%s>" % module_option.dtype
                    else:
                        optargs = ""

                    if module_option.short:
                        short_opt = "-" + module_option.short + ","
                    else:
                        short_opt = "   "

                    fmt = "    %%s %%s%%-%ds%%s\n" % (25-len(long_opt))
                    help_string += fmt % (short_opt, long_opt, optargs, module_option.description)

        return help_string + "\n"

    def execute(self, *args, **kwargs):
        '''
        Executes all appropriate modules according to the options specified in args/kwargs.

        Returns a list of executed module objects.
        '''
        run_modules = []
        orig_arguments = self.arguments

        if args or kwargs:
            self._set_arguments(list(args), kwargs)

        # Run all modules
        for module in self.list():
            obj = self.run(module)

        # Add all loaded modules that marked themselves as enabled to the run_modules list
        for (module, obj) in iterator(self.executed_modules):
            # Report the results if the module is enabled and if it is a primary module or if it reported any results/errors
            if obj.enabled and (obj.PRIMARY or obj.results or obj.errors):
                run_modules.append(obj)

        self.arguments = orig_arguments

        return run_modules

    def run(self, module, dependency=False, kwargs={}):
        '''
        Runs a specific module.
        '''
        try:
            obj = self.load(module, kwargs)

            if isinstance(obj, binwalk.core.module.Module) and obj.enabled:
                obj.main()
                self.status.clear()

            # If the module is not being loaded as a dependency, add it to the executed modules dictionary.
            # This is used later in self.execute to determine which objects should be returned.
            if not dependency:
                self.executed_modules[module] = obj

                # The unload method tells the module that we're done with it, and gives it a chance to do
                # any cleanup operations that may be necessary. We still retain the object instance in self.executed_modules.
                obj._unload_dependencies()
                obj.unload()
        except KeyboardInterrupt as e:
            # Tell the status server to shut down, and give it time to clean up.
            if self.status.running:
                self.status.shutdown = True
                while not self.status.finished:
                    time.sleep(0.1)
            raise e

        return obj

    def load(self, module, kwargs={}):
        argv = self.argv(module, argv=self.arguments)
        argv.update(kwargs)
        argv.update(self.dependencies(module, argv['enabled']))
        return module(self, **argv)

    def dependencies(self, module, module_enabled):
        import binwalk.modules
        attributes = {}

        for dependency in module.DEFAULT_DEPENDS+module.DEPENDS:

            # The dependency module must be imported by binwalk.modules.__init__.py
            if hasattr(binwalk.modules, dependency.name):
                dependency.module = getattr(binwalk.modules, dependency.name)
            else:
                raise ModuleException("%s depends on %s which was not found in binwalk.modules.__init__.py\n" % (str(module), dependency.name))

            # No recursive dependencies, thanks
            if dependency.module == module:
                continue

            # Only load dependencies with custom kwargs from modules that are enabled, else madness ensues.
            # Example: Heursitic module depends on entropy module, and sets entropy kwargs to contain 'enabled' : True.
            #          Without this check, an entropy scan would always be run, even if -H or -E weren't specified!
            #
            # Modules that are not enabled (e.g., extraction module) can load any dependency as long as they don't
            # set any custom kwargs for those dependencies.
            if module_enabled or not dependency.kwargs:
                depobj = self.run(dependency.module, dependency=True, kwargs=dependency.kwargs)

            # If a dependency failed, consider this a non-recoverable error and raise an exception
            if depobj.errors:
                raise ModuleException("Failed to load " + dependency.name + " module")
            else:
                attributes[dependency.attribute] = depobj

        return attributes

    def argv(self, module, argv=sys.argv[1:]):
        '''
        Processes argv for any options specific to the specified module.

        @module - The module to process argv for.
        @argv   - A list of command line arguments (excluding argv[0]).

        Returns a dictionary of kwargs for the specified module.
        '''
        kwargs = {'enabled' : False}
        last_priority = {}
        longs = []
        shorts = ""
        parser = argparse.ArgumentParser(add_help=False)
        # Hack: This allows the ListActionParser class to correllate short options to long options.
        #       There is probably a built-in way to do this in the argparse.ArgumentParser class?
        parser.short_to_long = {}

        # Must build arguments from all modules so that:
        #
        #    1) Any conflicting arguments will raise an exception
        #    2) The only unknown arguments will be the target files, making them easy to identify
        for m in self.list(attribute="CLI"):

            for module_option in m.CLI:

                parser_args = []
                parser_kwargs = {}

                if not module_option.long:
                    continue

                if module_option.short:
                    parser_args.append('-' + module_option.short)
                parser_args.append('--' + module_option.long)
                parser_kwargs['dest'] = module_option.long

                if module_option.type is None:
                    parser_kwargs['action'] = 'store_true'
                elif module_option.type is list:
                    parser_kwargs['action'] = 'append'
                    parser.short_to_long[module_option.short] = module_option.long

                parser.add_argument(*parser_args, **parser_kwargs)

        args, unknown = parser.parse_known_args(argv)
        args = args.__dict__

        # Only add parsed options pertinent to the requested module
        for module_option in module.CLI:

            if module_option.type == binwalk.core.common.BlockFile:

                for k in get_keys(module_option.kwargs):
                    kwargs[k] = []
                    for unk in unknown:
                        kwargs[k].append(unk)

            elif has_key(args, module_option.long) and args[module_option.long] not in [None, False]:

                # Loop through all the kwargs for this command line option
                for (name, default_value) in iterator(module_option.kwargs):

                    # If this kwarg has not been previously processed, or if its priority is equal to or
                    # greater than the previously processed kwarg's priority, then let's process it.
                    if not has_key(last_priority, name) or last_priority[name] <= module_option.priority:

                        # Track the priority for future iterations that may process the same kwarg name
                        last_priority[name] = module_option.priority

                        try:
                            kwargs[name] = module_option.convert(args[module_option.long], default_value)
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            raise ModuleException("Invalid usage: %s" % str(e))

        binwalk.core.common.debug("%s :: %s => %s" % (module.TITLE, str(argv), str(kwargs)))
        return kwargs

    def kwargs(self, obj, kwargs):
        '''
        Processes a module's kwargs. All modules should use this for kwarg processing.

        @obj    - An instance of the module (e.g., self)
        @kwargs - The kwargs passed to the module

        Returns None.
        '''
        if hasattr(obj, "KWARGS"):
            for module_argument in obj.KWARGS:
                if has_key(kwargs, module_argument.name):
                    arg_value = kwargs[module_argument.name]
                else:
                    arg_value = module_argument.default

                setattr(obj, module_argument.name, arg_value)

            for (k, v) in iterator(kwargs):
                if not hasattr(obj, k):
                    setattr(obj, k, v)
        else:
            raise Exception("binwalk.core.module.Modules.process_kwargs: %s has no attribute 'KWARGS'" % str(obj))

    def status_server(self, port):
        '''
        Starts the progress bar TCP service on the specified port.
        This service will only be started once per instance, regardless of the
        number of times this method is invoked.

        Failure to start the status service is considered non-critical; that is,
        a warning will be displayed to the user, but normal operation will proceed.
        '''
        if self.status_server_started == False:
            self.status_server_started = True
            try:
                self.status_service = binwalk.core.statuserver.StatusServer(port, self)
            except Exception as e:
                binwalk.core.common.warning("Failed to start status server on port %d: %s" % (port, str(e)))

def process_kwargs(obj, kwargs):
    '''
    Convenience wrapper around binwalk.core.module.Modules.kwargs.

    @obj    - The class object (an instance of a sub-class of binwalk.core.module.Module).
    @kwargs - The kwargs provided to the object's __init__ method.

    Returns None.
    '''
    with Modules() as m:
        kwargs = m.kwargs(obj, kwargs)
    return kwargs

def show_help(fd=sys.stdout):
    '''
    Convenience wrapper around binwalk.core.module.Modules.help.

    @fd - An object with a write method (e.g., sys.stdout, sys.stderr, etc).

    Returns None.
    '''
    with Modules() as m:
        fd.write(m.help())



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/plugin.py`:

```py
# Core code for supporting and managing plugins.

import os
import sys
import imp
import inspect
import binwalk.core.common
import binwalk.core.settings
from binwalk.core.compat import *

class Plugin(object):
    '''
    Class from which all plugin classes are based.
    '''
    # A list of case-sensitive module names for which this plugin should be loaded.
    # If no module names are specified, the plugin will be loaded for all modules.
    MODULES = []

    def __init__(self, module):
        '''
        Class constructor.

        @module - A handle to the current module that this plugin is loaded for.

        Returns None.
        '''
        self.module = module

        if not self.MODULES or self.module.name in self.MODULES:
            self._enabled = True
            self.init()
        else:
            self._enabled = False

    def init(self):
        '''
        Child class should override this if needed.
        Invoked during plugin initialization.
        '''
        pass

    def pre_scan(self):
        '''
        Child class should override this if needed.
        '''
        pass

    def new_file(self, fp):
        '''
        Child class should override this if needed.
        '''
        pass

    def scan(self, module):
        '''
        Child class should override this if needed.
        '''
        pass

    def post_scan(self):
        '''
        Child class should override this if needed.
        '''
        pass

class Plugins(object):
    '''
    Class to load and call plugin callback functions, handled automatically by Binwalk.scan / Binwalk.single_scan.
    An instance of this class is available during a scan via the Binwalk.plugins object.

    Each plugin must be placed in the user or system plugins directories, and must define a class named 'Plugin'.
    The Plugin class constructor (__init__) is passed one argument, which is the current instance of the Binwalk class.
    The Plugin class constructor is called once prior to scanning a file or set of files.
    The Plugin class destructor (__del__) is called once after scanning all files.

    By default, all plugins are loaded during binwalk signature scans. Plugins that wish to be disabled by
    default may create a class variable named 'ENABLED' and set it to False. If ENABLED is set to False, the
    plugin will only be loaded if it is explicitly named in the plugins whitelist.
    '''

    SCAN = 'scan'
    NEWFILE = 'new_file'
    PRESCAN = 'pre_scan'
    POSTSCAN = 'post_scan'
    MODULE_EXTENSION = '.py'

    def __init__(self, parent=None):
        self.scan = []
        self.pre_scan = []
        self.new_file = []
        self.post_scan = []
        self.parent = parent
        self.settings = binwalk.core.settings.Settings()

    def __enter__(self):
        return self

    def __exit__(self, t, v, traceback):
        pass

    def _call_plugins(self, callback_list, obj=None):
        for callback in callback_list:
            try:
                try:
                    callback()
                except TypeError:
                    if obj is not None:
                        callback(obj)
            except KeyboardInterrupt as e:
                raise e
            except Exception as e:
                binwalk.core.common.warning("%s.%s failed: %s" % (callback.__module__, callback.__name__, e))

    def _find_plugin_class(self, plugin):
        for (name, klass) in inspect.getmembers(plugin, inspect.isclass):
            if issubclass(klass, Plugin) and klass != Plugin:
                return klass
        raise Exception("Failed to locate Plugin class in " + plugin)

    def list_plugins(self):
        '''
        Obtain a list of all user and system plugin modules.

        Returns a dictionary of:

            {
                'user'      : {
                            'modules'       : [list, of, module, names],
                            'descriptions'  : {'module_name' : 'module pydoc string'},
                            'enabled'       : {'module_name' : True},
                            'path'          : "path/to/module/plugin/directory"
                },
                'system'    : {
                            'modules'       : [list, of, module, names],
                            'descriptions'  : {'module_name' : 'module pydoc string'},
                            'enabled'       : {'module_name' : True},
                            'path'          : "path/to/module/plugin/directory"
                }
            }
        '''

        plugins = {
            'user'   : {
                    'modules'       : [],
                    'descriptions'  : {},
                    'enabled'       : {},
                    'path'          : None,
            },
            'system' : {
                    'modules'       : [],
                    'descriptions'  : {},
                    'enabled'       : {},
                    'path'          : None,
            }
        }

        for key in plugins.keys():
            if key == 'user':
                plugins[key]['path'] = self.settings.user.plugins
            else:
                plugins[key]['path'] = self.settings.system.plugins

            if plugins[key]['path']:
                for file_name in os.listdir(plugins[key]['path']):
                    if file_name.endswith(self.MODULE_EXTENSION):
                        module = file_name[:-len(self.MODULE_EXTENSION)]

                        try:
                            plugin = imp.load_source(module, os.path.join(plugins[key]['path'], file_name))
                            plugin_class = self._find_plugin_class(plugin)

                            plugins[key]['enabled'][module] = True
                            plugins[key]['modules'].append(module)
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            binwalk.core.common.warning("Error loading plugin '%s': %s" % (file_name, str(e)))
                            plugins[key]['enabled'][module] = False

                        try:
                            plugins[key]['descriptions'][module] = plugin_class.__doc__.strip().split('\n')[0]
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            plugins[key]['descriptions'][module] = 'No description'
        return plugins

    def load_plugins(self):
        plugins = self.list_plugins()
        self._load_plugin_modules(plugins['user'])
        self._load_plugin_modules(plugins['system'])

    def _load_plugin_modules(self, plugins):
        for module in plugins['modules']:
            try:
                file_path = os.path.join(plugins['path'], module + self.MODULE_EXTENSION)
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                continue

            try:
                plugin = imp.load_source(module, file_path)
                plugin_class = self._find_plugin_class(plugin)

                class_instance = plugin_class(self.parent)
                if not class_instance._enabled:
                    continue

                try:
                    self.scan.append(getattr(class_instance, self.SCAN))
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    pass

                try:
                    self.pre_scan.append(getattr(class_instance, self.PRESCAN))
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    pass

                try:
                    self.post_scan.append(getattr(class_instance, self.POSTSCAN))
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    pass

                try:
                    self.new_file.append(getattr(class_instance, self.NEWFILE))
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    pass

            except KeyboardInterrupt as e:
                raise e
            except Exception as e:
                binwalk.core.common.warning("Failed to load plugin module '%s': %s" % (module, str(e)))

    def pre_scan_callbacks(self, obj):
        return self._call_plugins(self.pre_scan)

    def new_file_callbacks(self, fp):
        return self._call_plugins(self.new_file, fp)

    def post_scan_callbacks(self, obj):
        return self._call_plugins(self.post_scan)

    def scan_callbacks(self, obj):
        return self._call_plugins(self.scan, obj)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/settings.py`:

```py
# Code for loading and accessing binwalk settings (extraction rules, signature files, etc).

import os
import binwalk.core.common as common
from binwalk.core.compat import *

class Settings:
    '''
    Binwalk settings class, used for accessing user and system file paths and general configuration settings.

    After instatiating the class, file paths can be accessed via the self.paths dictionary.
    System file paths are listed under the 'system' key, user file paths under the 'user' key.

    Valid file names under both the 'user' and 'system' keys are as follows:

        o BINWALK_MAGIC_FILE  - Path to the default binwalk magic file.
        o PLUGINS             - Path to the plugins directory.
    '''
    # Release version
    VERSION = "2.1.1"

    # Sub directories
    BINWALK_USER_DIR = ".binwalk"
    BINWALK_MAGIC_DIR = "magic"
    BINWALK_CONFIG_DIR = "config"
    BINWALK_PLUGINS_DIR = "plugins"

    # File names
    PLUGINS = "plugins"
    EXTRACT_FILE = "extract.conf"
    BINARCH_MAGIC_FILE = "binarch"

    def __init__(self):
        '''
        Class constructor. Enumerates file paths and populates self.paths.
        '''
        # Path to the user binwalk directory
        self.user_dir = self._get_user_dir()
        # Path to the system wide binwalk directory
        self.system_dir = common.get_module_path()

        # Build the paths to all user-specific files
        self.user = common.GenericContainer(binarch=self._user_path(self.BINWALK_MAGIC_DIR, self.BINARCH_MAGIC_FILE),
                                            magic=self._magic_signature_files(user_only=True),
                                            extract=self._user_path(self.BINWALK_CONFIG_DIR, self.EXTRACT_FILE),
                                            plugins=self._user_path(self.BINWALK_PLUGINS_DIR))


        # Build the paths to all system-wide files
        self.system = common.GenericContainer(binarch=self._system_path(self.BINWALK_MAGIC_DIR, self.BINARCH_MAGIC_FILE),
                                              magic=self._magic_signature_files(system_only=True),
                                              extract=self._system_path(self.BINWALK_CONFIG_DIR, self.EXTRACT_FILE),
                                              plugins=self._system_path(self.BINWALK_PLUGINS_DIR))

    def _magic_signature_files(self, system_only=False, user_only=False):
        '''
        Find all user/system magic signature files.

        @system_only - If True, only the system magic file directory will be searched.
        @user_only   - If True, only the user magic file directory will be searched.

        Returns a list of user/system magic signature files.
        '''
        files = []
        user_binarch = self._user_path(self.BINWALK_MAGIC_DIR, self.BINARCH_MAGIC_FILE)
        system_binarch = self._system_path(self.BINWALK_MAGIC_DIR, self.BINARCH_MAGIC_FILE)

        if not system_only:
            user_dir = os.path.join(self.user_dir, self.BINWALK_USER_DIR, self.BINWALK_MAGIC_DIR)
            files += [os.path.join(user_dir, x) for x in os.listdir(user_dir)]
        if not user_only:
            system_dir = os.path.join(self.system_dir, self.BINWALK_MAGIC_DIR)
            files += [os.path.join(system_dir, x) for x in os.listdir(system_dir)]

        # Don't include binarch signatures in the default list of signature files.
        # It is specifically loaded when -A is specified on the command line.
        if user_binarch in files:
            files.remove(user_binarch)
        if system_binarch in files:
            files.remove(system_binarch)

        return files

    def find_magic_file(self, fname, system_only=False, user_only=False):
        '''
        Finds the specified magic file name in the system / user magic file directories.

        @fname       - The name of the magic file.
        @system_only - If True, only the system magic file directory will be searched.
        @user_only   - If True, only the user magic file directory will be searched.

        If system_only and user_only are not set, the user directory is always searched first.

        Returns the path to the file on success; returns None on failure.
        '''
        loc = None

        if not system_only:
            fpath = self._user_path(self.BINWALK_MAGIC_DIR, fname)
            if os.path.exists(fpath) and common.file_size(fpath) > 0:
                loc = fpath

        if loc is None and not user_only:
            fpath = self._system_path(self.BINWALK_MAGIC_DIR, fname)
            if os.path.exists(fpath) and common.file_size(fpath) > 0:
                loc = fpath

        return fpath

    def _get_user_dir(self):
        '''
        Get the user's home directory.
        '''
        try:
            # This should work in both Windows and Unix environments
            return os.getenv('USERPROFILE') or os.getenv('HOME')
        except KeyboardInterrupt as e:
            raise e
        except Exception:
            return ''

    def _file_path(self, dirname, filename):
        '''
        Builds an absolute path and creates the directory and file if they don't already exist.

        @dirname  - Directory path.
        @filename - File name.

        Returns a full path of 'dirname/filename'.
        '''
        if not os.path.exists(dirname):
            try:
                os.makedirs(dirname)
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass

        fpath = os.path.join(dirname, filename)

        if not os.path.exists(fpath):
            try:
                open(fpath, "w").close()
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass

        return fpath

    def _user_path(self, subdir, basename=''):
        '''
        Gets the full path to the 'subdir/basename' file in the user binwalk directory.

        @subdir   - Subdirectory inside the user binwalk directory.
        @basename - File name inside the subdirectory.

        Returns the full path to the 'subdir/basename' file.
        '''
        try:
            return self._file_path(os.path.join(self.user_dir, self.BINWALK_USER_DIR, subdir), basename)
        except KeyboardInterrupt as e :
            raise e
        except Exception:
            return None

    def _system_path(self, subdir, basename=''):
        '''
        Gets the full path to the 'subdir/basename' file in the system binwalk directory.

        @subdir   - Subdirectory inside the system binwalk directory.
        @basename - File name inside the subdirectory.

        Returns the full path to the 'subdir/basename' file.
        '''
        try:
            return self._file_path(os.path.join(self.system_dir, subdir), basename)
        except KeyboardInterrupt as e :
            raise e
        except Exception:
            return None


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/core/statuserver.py`:

```py
# Provides scan status information via a TCP socket service.
# Currently only works for signature scans.

import sys
import time
import errno
import threading
import binwalk.core.compat

# Python 2/3 compatibility
try:
    import SocketServer
except ImportError:
    import socketserver as SocketServer

class StatusRequestHandler(SocketServer.BaseRequestHandler):

    def handle(self):
        message_format = "%s     %3d%%     [ %d / %d ]"
        last_status_message_len = 0
        status_message = ''
        message_sent = False

        self.server.binwalk.status.running = True

        while True:
            time.sleep(0.1)

            try:
                self.request.send(binwalk.core.compat.str2bytes('\b' * last_status_message_len))
                self.request.send(binwalk.core.compat.str2bytes(' ' * last_status_message_len))
                self.request.send(binwalk.core.compat.str2bytes('\b' * last_status_message_len))

                if self.server.binwalk.status.shutdown:
                    self.server.binwalk.status.finished = True
                    break

                if self.server.binwalk.status.total != 0:
                    percentage = ((float(self.server.binwalk.status.completed) / float(self.server.binwalk.status.total)) * 100)
                    status_message = message_format % (self.server.binwalk.status.fp.path,
                                                       percentage,
                                                       self.server.binwalk.status.completed,
                                                       self.server.binwalk.status.total)
                elif not message_sent:
                    status_message = "No status information available at this time!"
                else:
                    continue

                last_status_message_len = len(status_message)
                self.request.send(binwalk.core.compat.str2bytes(status_message))
                message_sent = True
            except IOError as e:
                if e.errno == errno.EPIPE:
                    break
            except Exception as e:
                binwalk.core.common.debug('StatusRequestHandler exception: ' + str(e) + '\n')
            except KeyboardInterrupt as e:
                raise e

        self.server.binwalk.status.running = False
        return

class ThreadedStatusServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):
    daemon_threads = True
    allow_reuse_address = True

class StatusServer(object):

    def __init__(self, port, binwalk):
        self.server = ThreadedStatusServer(('127.0.0.1', port), StatusRequestHandler)
        self.server.binwalk = binwalk

        t = threading.Thread(target=self.server.serve_forever)
        t.setDaemon(True)
        t.start()

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/archives`:

```
# ----------------------------Archive Formats--------------------------------------

# POSIX tar archives
257     string      ustar\000   POSIX tar archive
>8      byte        !0
>>8     string      x           \b, owner user name: "%.32s"
>40     byte        !0
>>40    string      x           \b, owner group name: "%.32s"

257     string      ustar\040\040\000    POSIX tar archive (GNU)
>8      byte        !0
>>8     string      x                    \b, owner user name: "%.32s"
>40     byte        !0
>>40    string      x                    \b, owner group name: "%.32s"

# Incremental snapshot gnu-tar format from:
# http://www.gnu.org/software/tar/manual/html_node/Snapshot-Files.html
0       string      GNU\x20tar-     GNU tar incremental snapshot data,
>0      string      x               version: "%s"

# JAR archiver (.j), this is the successor to ARJ, not Java's JAR (which is essentially ZIP)
14      string  \x1aJar\x1b     JAR (ARJ Software, Inc.) archive data
0       string  JARCS           JAR (ARJ Software, Inc.) archive data

# PKZIP multi-volume archive
0       string          PK\x07\x08PK\x03\x04    Zip multi-volume archive data, at least PKZIP v2.50 to extract

# ZIP compression (Greg Roelofs, c/o zip-bugs@wkuvx1.wku.edu)
0       string      PK\003\004      Zip archive data,
>6      leshort     &0x01           encrypted
>4      byte        0x00            v0.0
>4      byte        0x09            at least v0.9 to extract,
>4      byte        0x0a            at least v1.0 to extract,
>4      byte        0x0b            at least v1.1 to extract,
>0x161  string      WINZIP          WinZIP self-extracting,
>4      byte        0x14
>>30    ubelong     !0x6d696d65     at least v2.0 to extract,
>18     lelong      !0
>>18    lelong      <0              {invalid}
>>18    lelong      x               compressed size: %d,
>>18    lelong      x               {jump:%d}
>22     lelong      !0
>>22    lelong      <0              {invalid}
>>22    lelong      x               uncompressed size: %d,
>30     byte        <0x2D           {invalid}
>30     byte        >0x7A           {invalid}
>26     leshort     x               {strlen:%d}
>30     string      x               name: {string}%s

# ZIP footer
0       string      PK\x05\x06      End of Zip archive
>20     leshort     >0
>>20    leshort     x               \b, comment:
>>20    leshort     x               {strlen:%d}
>>22    string      x               {string}"%s"

# ARJ archiver (jason@jarthur.Claremont.EDU)
0       uleshort    0xea60      ARJ archive data,
>2      leshort     x           header size: %d,
>5      byte        <1          {invalid}
>5      byte        >16         {invalid}
>5      byte        x           version %d,
>6      byte        <1          {invalid}
>6      byte        >16         {invalid}
>6      byte        x           minimum version to extract: %d,
>8      byte        <0          {invalid} flags,
>8      byte        &0x04       multi-volume,
>8      byte        &0x10       slash-switched,
>8      byte        &0x20       backup,
>9      byte        <0          {invalid},
>9      byte        >4          {invalid},
>9      byte        0           compression method: stored,
>9      byte        1           compression method: compressed most,
>9      byte        2           compression method: compressed,
>9      byte        3           compression method: compressed faster,
>9      byte        4           compression method: compressed fastest,
>10     byte        <0          {invalid}
>10     byte        >4          {invalid}
>10     byte        0           file type: binary,
>10     byte        1           file type: 7-bit text,
>10     byte        2           file type: comment header,
>10     byte        3           file type: directory,
>10     byte        4           file type: volume label,
>34     byte        !0
>>34    string      x           {name:%s}
>>34    string      x           original name: "%s",
>0xC    ledate      x           original file date: %s,
>0x10   lelong      <0          {invalid}
>0x10   lelong      x           compressed file size: %d,
>0x14   lelong      <0          {invalid}
>0x14   lelong      x           uncompressed file size: %d,
>7      byte        0           os: MS-DOS 
>7      byte        1           os: PRIMOS
>7      byte        2           os: Unix
>7      byte        3           os: Amiga
>7      byte        4           os: Macintosh
>7      byte        5           os: OS/2
>7      byte        6           os: Apple ][ GS
>7      byte        7           os: Atari ST
>7      byte        8           os: NeXT
>7      byte        9           os: VAX/VMS
>7      byte        >9          {invalid}
>7      byte        <0          {invalid}

# RAR archiver (http://kthoom.googlecode.com/hg/docs/unrar.html)
0   string      \x52\x61\x72\x21\x1A\x07\x00        RAR archive data, first volume type:
>9  ubyte       <0x72                               {invalid}
>9  ubyte       >0x7B                               {invalid}
>9  ubyte       0x72                                MARK_HEAD
>9  ubyte       0x73                                MAIN_HEAD
>9  ubyte       0x74                                FILE_HEAD
>9  ubyte       0x75                                COMM_HEAD
>9  ubyte       0x76                                AV_HEAD
>9  ubyte       0x77                                SUB_HEAD
>9  ubyte       0x78                                PROTECT_HEAD
>9  ubyte       0x79                                SIGN_HEAD
>9  ubyte       0x7A                                NEWSUB_HEAD
>9  ubyte       0x7B                                ENDARC_HEAD

# HPACK archiver (Peter Gutmann, pgut1@cs.aukuni.ac.nz)
0    string        HPAK        HPACK archive data

# JAM Archive volume format, by Dmitry.Kohmanyuk@UA.net
0    string        \351,\001JAM    JAM archive

# LHARC/LHA archiver (Greg Roelofs, newt@uchicago.edu)
2    string        -lzs         LHa 2.x? archive data [lzs] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh\40       LHa 2.x? archive data [lh ] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lhd         LHa 2.x? archive data [lhd] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh2         LHa 2.x? archive data [lh2] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh3         LHa 2.x? archive data [lh3] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh4         LHa (2.x) archive data [lh4] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh5         LHa (2.x) archive data [lh5] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh6         LHa (2.x) archive data [lh6] [NSRL|LHA2]
>6   string        !-           {invalid}
2    string        -lh7         LHa (2.x) archive data [lh7] [NSRL|LHA2]
>6   string        !-           {invalid}


# cpio archives
#
# The SVR4 "cpio(4)" hints that there are additional formats, but they
# are defined as "short"s; I think all the new formats are
# character-header formats and thus are strings, not numbers.
#0       string          070707          ASCII cpio archive (pre-SVR4 or odc)

0       string      070701  ASCII cpio archive (SVR4 with no CRC),
>110    byte        0       {invalid}
>94     byte        <0x30   {invalid}
>94     byte        >0x66   {invalid}
>54     byte        <0x30   {invalid}
>54     byte        >0x66   {invalid}
>110    string      x       file name: "%s",
>94     string      x       file name length: "0x%.8s",
>54     string      x       file size: "0x%.8s"

0       string      070702  ASCII cpio archive (SVR4 with CRC)
>110    byte        0       {invalid}
>94     byte        <0x30   {invalid}
>94     byte        >0x66   {invalid}
>54     byte        <0x30   {invalid}
>54     byte        >0x66   {invalid}
>110    string      x       file name: "%s",
>94     string      x       file name length: "0x%.8s",
>54     string      x       file size: "0x%.8s"

# HP Printer Job Language
# The header found on Win95 HP plot files is the "Silliest Thing possible" 
# (TM)
# Every driver puts the language at some random position, with random case
# (LANGUAGE and Language)
# For example the LaserJet 5L driver puts the "PJL ENTER LANGUAGE" in line 10
# From: Uwe Bonnes <bon@elektron.ikp.physik.th-darmstadt.de>
# 
0       string          \033%-12345X@PJL    HP Printer Job Language data,
>0      string          x                   "%s"

#------------------------------------------------------------------------------
#
# RPM: file(1) magic for Red Hat Packages   Erik Troan (ewt@redhat.com)
#
0     ubelong       0xedabeedb   RPM
>4    byte          <1           {invalid}
>4    byte          >99          {invalid}
>4    byte          x            v%d
>6    beshort       0            bin
>6    beshort       1            src
>8    beshort       1            i386
>8    beshort       2            Alpha
>8    beshort       3            Sparc
>8    beshort       4            MIPS
>8    beshort       5            PowerPC
>8    beshort       6            68000
>8    beshort       7            SGI
>8    beshort       8            RS6000
>8    beshort       9            IA64
>8    beshort       10           Sparc64
>8    beshort       11           MIPSel
>8    beshort       12           ARM
>10   string        x            "%s"

# IBM AIX Backup File Format header and entry signatures
0     ulelong    0xea6b0009   BFF volume header,
>4    uleshort   x            checksum: 0x%.4X,
>6    leshort    <0           {invalid}
>6    leshort    0            {invalid}
>6    leshort    x            volume number: %d,
>8    ledate     x            current date: %s,
>12   ledate     x            starting date: %s,
>20   string     x            disk name: "%s",
>36   string     x            file system name: "%s",
>52   string     x            user name: "%s"

2     uleshort  0xea6b      BFF volume entry,
>22   lelong    <0          {invalid}
>22   lelong    0           directory,
>22   lelong    >0
>>22  lelong    x           file size: %d,
>>54  lelong    <0          {invalid}
>>54  lelong    0           {invalid}
>>54  lelong    x           compressed size: %d,
>58   lelong    !0          {invalid}
>62   byte      0           {invalid}
>62   byte      !0x2e
>>62  byte      !0x2f       {invalid}
>62   string    x           file name: "%s"

2       uleshort    0xea6c  BFF volume entry, compressed,
>22     lelong      <0      {invalid}
>22     lelong      0       directory,
>22     lelong      >0
>>22    lelong      x       file size: %d,
>>54    lelong      <0      {invalid}
>>54    lelong      0       {invalid}
>>54    lelong      x       compressed size: %d,
>58     lelong      !0      {invalid}
>62     byte        0       {invalid}
>62     byte        !0x2e
>>62    byte        !0x2f   {invalid}
>62     string      x       file name: "%s"

0       uleshort    0xea6d  BFF volume entry, AIXv3,
>22     lelong      <0      {invalid}
>22     lelong      0       directory,
>22     lelong      >0
>>22    lelong      x       file size: %d,
>>54    lelong      <0      {invalid}
>>54    lelong      0       {invalid}
>>54    lelong      x       compressed size: %d,
>58     lelong      !0      {invalid}
>62     byte        0       {invalid}
>62     byte        !0x2e
>>62    byte        !0x2f   {invalid}
>62     string      x       file name: "%s"

#------------------------------------------------------------------------------
# From Stuart Caie <kyzer@4u.net> (developer of cabextract)
# Microsoft Cabinet files
0       string      MSCF\0\0\0\0    Microsoft Cabinet archive data
# According to libmagic comments, CAB version number is always 1.3
>25     byte        !1              {invalid}
>24     byte        !3              {invalid}
>8      lelong      x               \b, %u bytes
>28     leshort     0               {invalid}
>28     leshort     1               \b, 1 file
>28     leshort     >1              \b, %u files

# InstallShield Cabinet files
0               string          ISc(            InstallShield Cabinet archive data
# TODO: Version number checks should be made more specific for false positive filtering
>5              byte&0xf0       =0x60           version 6,
>5              byte&0xf0       <0x60           version 4/5,
>5              byte&0xf0       >0x60           {invalid} version,
>12             lelong          <0              {invalid} offset,
>12             lelong          >100000         {invalid} offset,
>(12.l+40)      lelong          x               %u files

# Windows CE package files
0       string          MSCE\0\0\0\0    Microsoft WinCE install header
>20     lelong          0               \b, architecture-independent
>20     lelong          103             \b, Hitachi SH3
>20     lelong          104             \b, Hitachi SH4
>20     lelong          0xA11           \b, StrongARM
>20     lelong          4000            \b, MIPS R4000
>20     lelong          10003           \b, Hitachi SH3
>20     lelong          10004           \b, Hitachi SH3E
>20     lelong          10005           \b, Hitachi SH4
>20     lelong          70001           \b, ARM 7TDMI
>52     leshort         1               \b, 1 file
>52     leshort         >1              \b, %u files
>56     leshort         1               \b, 1 registry entry
>56     leshort         >1              \b, %u registry entries

0       string  \x00\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20        LBR archive data
>12     string  !\x00x00                                                {invalid}

# Parity archive reconstruction file, the 'par' file format now used on Usenet.
0       string          PAR\0   PARity archive data
>48     leshort         =0      - Index file
>48     leshort         >0      - file number %d

# Felix von Leitner <felix-file@fefe.de>
0       string  d8:announce     BitTorrent file

# BSA archives, based on http://forum.step-project.com/topic/5033-ramifications-of-bsa-extraction-in-mod-organizer/page-16
0       string          BSA\x00\x67             BSA archive, version: 103,
>8      byte            !0x24                   {invalid}
>8      byte            0x24                    folder records offset: %d
0       string          BSA\x00\x68             BSA archive, version: 104,
>8      byte            !0x24                   {invalid}
>8      byte            0x24                    folder records offset: %d


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/binarch`:

```
# MIPS prologue
# addiu $sp, -XX
# sw XX, XX($sp)
# 27 BD FF XX
# AF BX XX XX
1	string		\xFF\xBD\x27	MIPSEL instructions, function prologue
>6	byte		!0xAF			{invalid}
>5	byte&0xE0	!0xA0			{invalid}

0	string		\x27\xBD\xFF	MIPS instructions, function prologue
>4	byte		!0xAF			{invalid}
>5	byte&0xE0	!0xA0			{invalid}

# MIPS epilogue
# jr $ra
# addiu $sp, XX
#
# addiu $sp, XX
# jr $ra
0	ubelong	0x03e00008	MIPS instructions, function epilogue
>4	ubeshort	!0x27BD		{invalid}
0	ubeshort	0x27BD		MIPS instructions, function epilogue
>2	ubelong	!0x03e00008	{invalid}

0	ulelong	0x03e00008	MIPSEL instructions, function epilogue
>6	uleshort	!0x27BD		{invalid}
0	uleshort	0x27BD		MIPS instructions, function epilogue
>2	ulelong	!0x03e00008	{invalid}

# MIPS16e
# nop (x4)
# TODO: Produces false positives when scanning ARM Thumb code
#0	string	\x65\x00\x65\x00\x65\x00\x65\x00	MIPS16e instructions, nops{jump-to-offset:8}
#0	string	\x00\x65\x00\x65\x00\x65\x00\x65	MIPSEL16e instructions, nops{jump-to-offset:8}

# save a0-a1, XX
# addiu XX, XX
0	string	\xf0\x08\x64	MIPS16e instructions, function prologue
>4	byte	!0x01			{invalid}

# move $sp, $s1
# restore XX, XX, XX
# jrc $ra
0	ubeshort	0x65B9			MIPS16e instructions, function epilogue
>3	byte	    !0x64			{invalid}
>4	ubeshort	!0xE8A0			{invalid}
0	uleshort	0x65B9			MIPSEL16e instructions, function epilogue
>3	byte	    !0x64			{invalid}
>4	uleshort	!0xE8A0			{invalid}

# jrc $ra
# nop
0	ubelong	0xe8a06500		MIPS16e instructions, function epilogue
0	ulelong	0xe8a06500		MIPSEL16e instructions, function epilogue

# PowerPC prologue
# mflr r0
0	ubelong 0x7C0802A6	PowerPC big endian instructions, function prologue
0	ulelong 0x7C0802A6	PowerPC little endian instructions, function prologue

# PowerPC epilogue
# blr
0	ubelong 0x4E800020	PowerPC big endian instructions, function epilogue
0	ulelong 0x4E800020	PowerPC little endian instructions, function epilogue

# TODO: Add ARM Thumb dectection
# ARM prologue
# STMFD SP!, {XX}
# <any instruction whose opcode begins with 0xE>
0	ubeshort	0xE92D	ARMEB instructions, function prologue
>4	byte&0xF0	!0xE0	{invalid}
>8	byte&0xF0	!0xE0	{invalid}
0	uleshort	0xE92D	ARM instructions, function prologue{adjust:-2}
>5	byte&0xF0	!0xE0	{invalid}
>9	byte&0xF0	!0xE0	{invalid}

# ARM epilogue
# MOV R0, XX
# LDMFD SP!, {XX}
0	ubeshort	0xE1A0	ARMEB instructions, function epilogue
>4	beshort		!0xE8BD	{invalid}
0	uleshort	0xE1A0	ARM instructions, function epilogue{adjust:-2}
>4	leshort		!0xE8BD	{invalid}


# Ubicom32 prologue
# move.4 -4($sp)++, $ra
0	ubelong	    0x02FF6125	Ubicom32 instructions, function prologue

# Ubicom32 epilogues
# calli $ra, 0($ra)
# ret ($sp)4++
0	ubelong	    0xF0A000A0	Ubicom32 instructions, function epilogue
0	ubelong	    0x000022E1	Ubicom32 instructions, function epilogue

# AVR8 prologue
# push r28
# push r29
0	ubelong	    0x93CF93DF	AVR8 instructions, function prologue
0	ubelong	    0x93DF93CF	AVR8 instructions, function prologue

# AVR32 prologue
# pushm   r7,lr
# mov r7,sp
0	string	\xEB\xCD\x40\x80\x1A\x97	AVR32 instructions, function prologue

# SPARC epilogue
# ret
# restore XX
0	string	\x81\xC7\xE0\x08\x81\xE8	SPARC instructions, function epilogue

# x86 epilogue
# push ebp
# move ebp, esp
# sub esp, XX
#
# push ebp
# move ebp, esp
# push edi
# push esi
0	string	\x55\x89\xE5\x83\xEC				Intel x86 instructions, function prologue
0	string	\x55\x89\xE5\x57\x56				Intel x86 instructions, function prologue
0	string	\x90\x90\x90\x90\x90\x90\x90\x90	Intel x86 instructions, nops{jump:8}{overlap}

# unlk a6
# rts
# link a6, XX
0   string  N^NuNV      Motorola Coldfire instructions, function prologue/epilogue

# mov.l   @r15+, r9
# rts
# mov.l   @r15
0   string  \xF6\x69\x0B\x00\xF6\x68            SuperH instructions, little endian, function epilogue (gcc)
0   string  \x69\xF6\x00\x0B\x68\xF6            SuperH instructions, big endian, function epilogue (gcc)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/bincast`:

```
# This file is depreciated and intentionally left blank.
# It is included solely to ensure that previously installed
# versions of this file are overwritten during an upgrade.

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/binwalk`:

```
# This file is depreciated and intentionally left blank.
# It is included solely to ensure that previously installed
# versions of this file are overwritten during an upgrade.

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/bootloaders`:

```

#---------------------------Bootloaders--------------------------------

# CFE bootloader
0	string	CFE1	    CFE boot loader
>4  string  !CFE1       {invalid}
>40	string	CFE1CFE1	{invalid}

# U-Boot boot loader
0	string	U-Boot\x20  U-Boot version string,
>7  byte    <48         {invalid}
>7  byte    >57         {invalid}
>8  byte    !0x2E       {invalid}
>0  string  x           "%s"

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/code`:

```
# This file is depreciated and intentionally left blank.
# It is included solely to ensure that previously installed
# versions of this file are overwritten during an upgrade.

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/compressed`:

```

#------------------Compression Formats-----------------------------
# Stuffit archives are the de facto standard of compression for Macintosh
# files obtained from most archives. (franklsm@tuns.ca)
# Found in some firmware updates.
0   string      SIT!            StuffIt Archive (data)
>2  string      x               \b: %s
0   string      SITD            StuffIt Deluxe (data)
>2  string      x               \b: %s
0   string      Sef             StuffIt Deluxe Segment (data)
>2  string      x               \b: %s

# Newer StuffIt archives (grant@netbsd.org)
0   string      StuffIt         StuffIt Archive

# AFX compressed files (Wolfram Kleff)
2    string        -afx         AFX compressed file data
>6   string        !-           {invalid}

# bzip2
0    string BZh91AY&SY    bzip2 compressed data, block size = 900k
0    string BZh81AY&SY    bzip2 compressed data, block size = 800k
0    string BZh71AY&SY    bzip2 compressed data, block size = 700k
0    string BZh61AY&SY    bzip2 compressed data, block size = 600k
0    string BZh51AY&SY    bzip2 compressed data, block size = 500k
0    string BZh41AY&SY    bzip2 compressed data, block size = 400k
0    string BZh31AY&SY    bzip2 compressed data, block size = 300k
0    string BZh21AY&SY    bzip2 compressed data, block size = 200k
0    string BZh11AY&SY    bzip2 compressed data, block size = 100k

# lzop from <markus.oberhumer@jk.uni-linz.ac.at>
0       string          \x89\x4c\x5a\x4f\x00\x0d\x0a\x1a\x0a    lzop compressed data,
>9      beshort         >0x093F                                 {invalid}
>9      beshort         <0x0940
>>9     byte&0xf0       =0x00                                   - version 0.
>>9     beshort&0x0fff  x                                       \b%03x,
>>9     beshort&0x0fff  <1                                      {invalid}
>>13    byte            1                                       LZO1X-1,
>>13    byte            2                                       LZO1X-1(15),
>>13    byte            3                                       LZO1X-999,
>>14    byte            =0x00                                   os: MS-DOS
>>14    byte            =0x01                                   os: Amiga
>>14    byte            =0x02                                   os: VMS
>>14    byte            =0x03                                   os: Unix
>>14    byte            =0x05                                   os: Atari
>>14    byte            =0x06                                   os: OS/2
>>14    byte            =0x07                                   os: MacOS
>>14    byte            =0x0A                                   os: Tops/20
>>14    byte            =0x0B                                   os: WinNT
>>14    byte            =0x0E                                   os: Win32
>9      beshort         >0x0939
>>9     byte&0xf0       =0x00                                   - version 0.
>>9     byte&0xf0       =0x10                                   - version 1.
>>9     byte&0xf0       =0x20                                   - version 2.
>>9     beshort&0x0fff  x                                       \b%03x,
>>15    byte            1                                       LZO1X-1,
>>15    byte            2                                       LZO1X-1(15),
>>15    byte            3                                       LZO1X-999,
>>17    byte            =0x00                                   os: MS-DOS
>>17    byte            =0x01                                   os: Amiga
>>17    byte            =0x02                                   os: VMS
>>17    byte            =0x03                                   os: Unix
>>17    byte            =0x05                                   os: Atari
>>17    byte            =0x06                                   os: OS/2
>>17    byte            =0x07                                   os: MacOS
>>17    byte            =0x0A                                   os: Tops/20
>>17    byte            =0x0B                                   os: WinNT
>>17    byte            =0x0E                                   os: Win32

# lzip
0       string          LZIP            lzip compressed data,
>4      ubyte           0               {invalid}
# Current version is still 1.x
>4      ubyte           >4              {invalid}
>4      byte            x               version: %d

# lrzip
0       string          LRZI            lrzip compressed data

# LZO
0    string        \211LZO\000\015\012\032\012    LZO compressed data

# 7-zip archiver, from Thomas Klausner (wiz@danbala.tuwien.ac.at)
# http://www.7-zip.org or DOC/7zFormat.txt
#
0     string    7z\274\257\047\034      7-zip archive data,
>6    byte      <0                      {invalid}
>6    byte      0
>>7   byte      0                       {invalid}
>6    byte      >20                     {invalid}
>6    byte      x                       version %d
>7    byte      x                       \b.%d

# standard unix compress
# Disabled until a python alternative can be foudn for the compress binwalk plugin.
#0       string        \x1f\x9d\x90          compress'd data, 16 bits

# http://tukaani.org/xz/xz-file-format.txt
0    string        \xFD\x37\x7a\x58\x5a\x00    xz compressed data

# gzip (GNU zip, not to be confused with Info-ZIP or PKWARE zip archiver)
#   Edited by Chris Chittleborough <cchittleborough@yahoo.com.au>, March 2002
#       * Original filename is only at offset 10 if "extra field" absent
#       * Produce shorter output - notably, only report compression methods
#         other than 8 ("deflate", the only method defined in RFC 1952).
#0       string          \037\213\x08    gzip compressed data
0       string          \x1f\x8b\x08    gzip compressed data
>3      byte            &0x01           \b, ASCII
>3      byte&0xE0       !0x00           \b, {invalid}invalid reserved flag bits
>8      byte            2               \b, maximum compression
>8      byte            4               \b, fastest compression
>8      byte            1               \b, {invalid}invalid extra flags
>8      byte            3               \b, {invalid}invalid extra flags
>8      byte            >4              \b, {invalid}invalid extra flags
>3      byte            &0x02           \b, has header CRC
>3      byte&0x04       0x04
>>10    leshort         x               \b, has %d bytes of extra data
>3      byte&0xC        =0x08           \b, has original file name
>>10    string          x               \b: "%s"{name:%s}
>3      byte            &0x10           \b, has comment
>>3     byte&0xC        0
>>>10   string          x               \b: "%s"
>9      byte            =0x00           \b, from FAT filesystem (MS-DOS, OS/2, NT)
>9      byte            =0x01           \b, from Amiga
>9      byte            =0x02           \b, from VMS
>9      byte            =0x03           \b, from Unix
>9      byte            =0x04           \b, from VM/CMS
>9      byte            =0x05           \b, from Atari
>9      byte            =0x06           \b, from HPFS filesystem (OS/2, NT)
>9      byte            =0x07           \b, from MacOS
>9      byte            =0x08           \b, from Z-System
>9      byte            =0x09           \b, from CP/M
>9      byte            =0x0A           \b, from TOPS/20
>9      byte            =0x0B           \b, from NTFS filesystem (NT)
>9      byte            =0x0C           \b, from QDOS
>9      byte            =0x0D           \b, from Acorn RISCOS
>3      byte            &0x20           \b, encrypted{invalid}
# Dates before 1992 are {invalid}, unless of course you're DD-WRT in which
# case you don't know how to set a date in your gzip files. Brilliant.
>4      lelong          =0              \b, NULL date (1970-01-01 00:00:00)
>4      lelong          <0              {invalid}
>4      lelong          >0
>>4     lelong          <694224000      {invalid}
>>4     lelong          =694224000      {invalid}
>>4     lelong          >694224000      \b, last modified:
>>>4    ledate          x               %s
>>>4    lelong          x               {epoch:%d}

# Supplementary magic data for the file(1) command to support
# rzip(1).  The format is described in magic(5).
#
# Copyright (C) 2003 by Andrew Tridgell.  You may do whatever you want with
# this file.
#
0       string          RZIP            rzip compressed data
>4      byte            x               - version %d
>5      byte            x               \b.%d
>6      belong          x               (%d bytes)

# JAR
0       belong          0xcafed00d      JAR compressed with pack200,
>5      byte            x               version %d.
>4      byte            x               \b%d

# New LZMA format signature
# See lzma file for LZMA signatures
0     string        \xFFLZMA\x00    LZMA compressed data (new),
>6    byte&0x10     0               single-block stream
>6    byte&0x10     0x10            multi-block stream

0    string    \xff\x06\x00\x00\x73\x4e\x61\x50\x70\x59    Snappy compression, stream identifier

#0    beshort        0x7801        Zlib header, no compression
0    beshort        0x789c        Zlib compressed data, default compression
0    beshort        0x78da        Zlib compressed data, best compression
0    beshort        0x785e        Zlib compressed data, compressed


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/console`:

```
# From Gurkan Sengun <gurkan@linuks.mine.nu>, www.linuks.mine.nu
12  string      GameBoy\x20Music\x20Module  Nintendo Gameboy Music Module

#------------------------------------------------------------------------------
# gameboy:  file(1) magic for the Nintendo (Color) Gameboy raw ROM format
#
0x104   ubelong     0xCEED6666      Gameboy ROM,
>0x134  byte        !0
>>0x134 string      x               name: "%.16s"
>0x146  byte        0x03            \b,[SGB]
>0x147  byte        0x00            \b, [ROM ONLY]
>0x147  byte        0x01            \b, [ROM+MBC1]
>0x147  byte        0x02            \b, [ROM+MBC1+RAM]
>0x147  byte        0x03            \b, [ROM+MBC1+RAM+BATT]
>0x147  byte        0x05            \b, [ROM+MBC2]
>0x147  byte        0x06            \b, [ROM+MBC2+BATTERY]
>0x147  byte        0x08            \b, [ROM+RAM]
>0x147  byte        0x09            \b, [ROM+RAM+BATTERY]
>0x147  byte        0x0B            \b, [ROM+MMM01]
>0x147  byte        0x0C            \b, [ROM+MMM01+SRAM]
>0x147  byte        0x0D            \b, [ROM+MMM01+SRAM+BATT]
>0x147  byte        0x0F            \b, [ROM+MBC3+TIMER+BATT]
>0x147  byte        0x10            \b, [ROM+MBC3+TIMER+RAM+BATT]
>0x147  byte        0x11            \b, [ROM+MBC3]
>0x147  byte        0x12            \b, [ROM+MBC3+RAM]
>0x147  byte        0x13            \b, [ROM+MBC3+RAM+BATT]
>0x147  byte        0x19            \b, [ROM+MBC5]
>0x147  byte        0x1A            \b, [ROM+MBC5+RAM]
>0x147  byte        0x1B            \b, [ROM+MBC5+RAM+BATT]
>0x147  byte        0x1C            \b, [ROM+MBC5+RUMBLE]
>0x147  byte        0x1D            \b, [ROM+MBC5+RUMBLE+SRAM]
>0x147  byte        0x1E            \b, [ROM+MBC5+RUMBLE+SRAM+BATT]
>0x147  byte        0x1F            \b, [Pocket Camera]
>0x147  byte        0xFD            \b, [Bandai TAMA5]
>0x147  byte        0xFE            \b, [Hudson HuC-3]
>0x147  byte        0xFF            \b, [Hudson HuC-1]

>0x148  byte        0               \b, ROM: 256Kbit
>0x148  byte        1               \b, ROM: 512Kbit
>0x148  byte        2               \b, ROM: 1Mbit
>0x148  byte        3               \b, ROM: 2Mbit
>0x148  byte        4               \b, ROM: 4Mbit
>0x148  byte        5               \b, ROM: 8Mbit
>0x148  byte        6               \b, ROM: 16Mbit
>0x148  byte        0x52            \b, ROM: 9Mbit
>0x148  byte        0x53            \b, ROM: 10Mbit
>0x148  byte        0x54            \b, ROM: 12Mbit

>0x149  byte        1               \b, RAM: 16Kbit
>0x149  byte        2               \b, RAM: 64Kbit
>0x149  byte        3               \b, RAM: 128Kbit
>0x149  byte        4               \b, RAM: 1Mbit

#>0x14e  long        x               \b, CRC: %x

#------------------------------------------------------------------------------
# genesis:  file(1) magic for the Sega MegaDrive/Genesis raw ROM format
#
0x100   string  SEGA    Sega MegaDrive/Genesis raw ROM dump,
>0x120  string  x       Name: "%.16s",
>0x110  byte    !0
>>0x110 string  x       "%.16s",
>0x1B0  string  RA      with SRAM

# From: "Nelson A. de Oliveira" <naoliv@gmail.com>
# Nintendo .nds
192 string  \044\377\256Qi\232          Nintendo DS Game ROM Image
# Nintendo .gba
0   string  \056\000\000\352$\377\256Qi Nintendo Game Boy Advance ROM Image

#------------------------------------------------------------------------------
# Sony Playstation executables (Adam Sjoegren <asjo@diku.dk>) :
0       string  PS-X\x20EXE     Sony Playstation executable
#  Area:
>113    string  x               (%s)

#------------------------------------------------------------------------------
## Microsoft Xbox executables .xbe (Esa Hyyti <ehyytia@cc.hut.fi>)
0                       string              XBEH            Microsoft Xbox executable (XBE),
## probabilistic checks whether signed or not
>0x0004                 ulelong             =0
>>10                    ulelong             =0
>>>16                   ulelong             =0              \b, not signed
>0x0004                 ulelong             >0
>>10                    ulelong             >0              \b, signed
>>>16                   ulelong             >0              \b, signed
## expect base address of 0x10000
>0x0104                 ulelong             !0x10000        {invalid}
>0x0104                 ulelong             =0x10000
>>(0x0118-0x0FF60)      ulelong&0x80000007  0x80000007      \b, all regions
>>(0x0118-0x0FF60)      ulelong&0x80000007  !0x80000007
>>>(0x0118-0x0FF60)     ulelong             >0              (regions:
>>>>(0x0118-0x0FF60)    ulelong             &0x00000001     NA
>>>>(0x0118-0x0FF60)    ulelong             &0x00000002     Japan
>>>>(0x0118-0x0FF60)    ulelong             &0x00000004     Rest_of_World
>>>>(0x0118-0x0FF60)    ulelong             &0x80000000     Manufacturer
>>>(0x0118-0x0FF60)     ulelong             >0              \b)

# --------------------------------
# # Microsoft Xbox data file formats
# # http://home.comcast.net/~admiral_powerslave/filestructure.html
0       string          XIP0                        XIP, Microsoft Xbox data,
>12     lelong          x                           total size: %d
>16     lelong          !0                          {invalid}
>24     lelong          !0                          {invalid}

0       string          XTF0\x00\x00\x00            XTF, Microsoft Xbox data



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/crypto`:

```
# Type: OpenSSL certificates/key files
# From: Nicolas Collignon <tsointsoin@gmail.com>

0       string  -----BEGIN\x20CERTIFICATE           PEM certificate
>22     string  !-----                              {invalid}
0       string  -----BEGIN\x20CERTIFICATE\x20REQ    PEM certificate request
0       string  -----BEGIN\x20RSA\x20PRIVATE        PEM RSA private key
0       string  -----BEGIN\x20DSA\x20PRIVATE        PEM DSA private key
0       string  -----BEGIN\x20EC\x20PRIVATE         PEM EC private key

# Type: OpenSSH key files
# From: Nicolas Collignon <tsointsoin@gmail.com>

0       string  SSH\x20PRIVATE\x20KEY    OpenSSH RSA1 private key,
>28     byte    !0
>>28    string  x                        version "%s"
>28     byte    0                        {invalid}

0       string  ssh-dss\x20             OpenSSH DSA public key
0       string  ssh-rsa\x20             OpenSSH RSA public key
0       string  ecdsa-sha2-nistp256\x20 OpenSSH ECDSA (Curve P-256) public key
0       string  ecdsa-sha2-nistp384\x20 OpenSSH ECDSA (Curve P-384) public key
0       string  ecdsa-sha2-nistp521\x20 OpenSSH ECDSA (Curve P-521) public key

# Type: Certificates/key files in DER format
# From: Gert Hulselmans <hulselmansgert@gmail.com>
0       string          \x30\x82        Private key in DER format (PKCS#8),
>4      string          !\x02\x01\x00   {invalid}
>2      beshort         <0              {invalid}
>2      beshort         x               header length: 4, sequence length: %d

0       string          \x30\x82        Certificate in DER format (x509 v3),
>4      string          !\x30\x82       {invalid}
>2      beshort         <0              {invalid}
>2      beshort         x               header length: 4, sequence length: %d

# GnuPG
# The format is very similar to pgp
0       string          \001gpg                 GPG key trust database
>4      byte            x                       version %d

# Not a very useful signature
#0       beshort         0x9901                  GPG key public ring

# This magic is not particularly good, as the keyrings don't have true
# magic. Nevertheless, it covers many keyrings.

#------------------------------------------------------------------------------
# Mavroyanopoulos Nikos <nmav@hellug.gr>
# mcrypt:   file(1) magic for mcrypt 2.2.x;
0       string      \0m\3       mcrypt 2.5 encrypted data,
>4      byte        0           {invalid}
>4      string      x           algorithm: "%s",
>>&1    leshort     <1          {invalid}
>>&1    leshort     >0          keysize: %d bytes,
>>>&0   byte        0           {invalid}
>>>&0   string      >\0         mode: "%s",

0       string      \0m\2       mcrypt 2.2 encrypted data,
>3      byte        0           algorithm: blowfish-448,
>3      byte        1           algorithm: DES,
>3      byte        2           algorithm: 3DES,
>3      byte        3           algorithm: 3-WAY,
>3      byte        4           algorithm: GOST,
>3      byte        6           algorithm: SAFER-SK64,
>3      byte        7           algorithm: SAFER-SK128,
>3      byte        8           algorithm: CAST-128,
>3      byte        9           algorithm: xTEA,
>3      byte        10          algorithm: TWOFISH-128,
>3      byte        11          algorithm: RC2,
>3      byte        12          algorithm: TWOFISH-192,
>3      byte        13          algorithm: TWOFISH-256,
>3      byte        14          algorithm: blowfish-128,
>3      byte        15          algorithm: blowfish-192,
>3      byte        16          algorithm: blowfish-256,
>3      byte        100         algorithm: RC6,
>3      byte        101         algorithm: IDEA,
>3      byte        <0          {invalid}
>3      byte        >101        {invalid}
>3      byte        >16
>>3     byte        <100        {invalid}
>4      byte        0           mode: CBC,
>4      byte        1           mode: ECB,
>4      byte        2           mode: CFB,
>4      byte        3           mode: OFB,
>4      byte        4           mode: nOFB,
>4      byte        <0          {invalid}
>4      byte        >4          {invalid}
>5      byte        0           keymode: 8bit
>5      byte        1           keymode: 4bit
>5      byte        2           keymode: SHA-1 hash
>5      byte        3           keymode: MD5 hash
>5      byte        <0          {invalid}
>5      byte        >3          {invalid}

#------------------------------------------------------------------------------
# pgp:  file(1) magic for Pretty Good Privacy
#
#0       beshort         0x9900                  PGP key public ring
#0       beshort         0x9501                  PGP key security ring
#0       beshort         0x9500                  PGP key security ring
#0    beshort        0xa600            PGP encrypted data
0       string          -----BEGIN\040PGP       PGP armored data,
>15     string          PUBLIC\040KEY\040BLOCK- public key block
>15     string          MESSAGE-                message
>15     string          SIGNED\040MESSAGE-      signed message
>15     string          PGP\040SIGNATURE-       signature

0       string        Salted__      OpenSSL encryption, salted,
>8      belong        x             salt: 0x%X
>12     belong        x             \b%X


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/ecos`:

```
# eCos kernel exception handlers
#
# mfc0    $k0, Cause       # Cause of last exception
# nop                      # Some versions of eCos omit the nop
# andi    $k0, 0x7F
# li      $k1, 0xXXXXXXXX
# add     $k1, $k0
# lw      $k1, 0($k1)
# jr      $k1
# nop
0       string      \x00\x68\x1A\x40\x00\x00\x00\x00\x7F\x00\x5A\x33    eCos kernel exception handler, architecture: MIPSEL,
>14     leshort     !0x3C1B                                             {invalid}
>18     leshort     !0x277B                                             {invalid}
>12     uleshort    x                                                   exception vector table base address: 0x%.4X
>16     uleshort    x                                                   \b%.4X

0       string      \x00\x68\x1A\x40\x7F\x00\x5A\x33                    eCos kernel exception handler, architecture: MIPSEL,
>10     leshort     !0x3C1B                                             {invalid}
>14     leshort     !0x277B                                             {invalid}
>8      uleshort    x                                                   exception vector table base address: 0x%.4X
>12     uleshort    x                                                   \b%.4X

0       string      \x40\x1A\x68\x00\x00\x00\x00\x00\x33\x5A\x00\x7F    eCos kernel exception handler, architecture: MIPS,
>12     beshort     !0x3C1B                                             {invalid}
>16     beshort     !0x277B                                             {invalid}
>14     ubeshort    x                                                   exception vector table base address: 0x%.4X
>18     ubeshort    x                                                   \b%.4X

0       string      \x40\x1A\x68\x00\x33\x5A\x00\x7F                    eCos kernel exception handler, architecture: MIPS,
>8      beshort     !0x3C1B                                             {invalid}
>12     beshort     !0x277B                                             {invalid}
>10     ubeshort    x                                                   exception vector table base address: 0x%.4X
>14     ubeshort    x                                                   \b%.4X

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/encoding`:

```
# Base64 index tables
0   string  ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/    Base64 standard index table
0   string  ACEGIKMOQSUWYBDFHJLNPRTVXZacegikmoqsuwybdfhjlnprtvxz0246813579=+/   Base64 SerComm index table

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/executables`:

```

#------------------Standard file formats------------------------------------

#------------------------------------------------------------------------------
# elf:  file(1) magic for ELF executables
#
# We have to check the byte order flag to see what byte order all the
# other stuff in the header is in.
#
# What're the correct byte orders for the nCUBE and the Fujitsu VPP500?
#
# updated by Daniel Quinlan (quinlan@yggdrasil.com)
0           string                  \177ELF         ELF,
>4          byte                    0               {invalid}
>4          byte                    1               32-bit
# only for MIPS - in the future, the ABI field of e_flags should be used.
>>18        leshort                 8
>>>36       lelong                  &0x20           N32
>>18        leshort                 10
>>>36       lelong                  &0x20           N32
>>18        beshort                 8
>>>36       belong                  &0x20           N32
>>18        beshort                 10
>>>36       belong                  &0x20           N32
>4          byte                    2               64-bit
>4          byte                    >2
>>4         byte                    x               unknown ELF class: 0x%X
>5          byte                    !1
>>5         byte                    !2              {invalid}
>5          byte                    1               LSB
# The official e_machine number for MIPS is now #8, regardless of endianness.
# The second number (#10) will be deprecated later. For now, we still
# say something if #10 is encountered, but only gory details for #8.
>>18        leshort                 8
# only for 32-bit
>>>4        byte                    1
>>>>36      lelong&0xf0000000       0x00000000      MIPS-I
>>>>36      lelong&0xf0000000       0x10000000      MIPS-II
>>>>36      lelong&0xf0000000       0x20000000      MIPS-III
>>>>36      lelong&0xf0000000       0x30000000      MIPS-IV
>>>>36      lelong&0xf0000000       0x40000000      MIPS-V
>>>>36      lelong&0xf0000000       0x60000000      MIPS32
>>>>36      lelong&0xf0000000       0x70000000      MIPS64
>>>>36      ulelong&0xf0000000      0x80000000      MIPS32 rel2
>>>>36      ulelong&0xf0000000      0x90000000      MIPS64 rel2
# only for 64-bit
>>>4        byte                    2
>>>>48      lelong&0xf0000000       0x00000000      MIPS-I
>>>>48      lelong&0xf0000000       0x10000000      MIPS-II
>>>>48      lelong&0xf0000000       0x20000000      MIPS-III
>>>>48      lelong&0xf0000000       0x30000000      MIPS-IV
>>>>48      lelong&0xf0000000       0x40000000      MIPS-V
>>>>48      lelong&0xf0000000       0x60000000      MIPS32
>>>>48      lelong&0xf0000000       0x70000000      MIPS64 
>>>>48      ulelong&0xf0000000      0x80000000      MIPS32 rel2
>>>>48      ulelong&0xf0000000      0x90000000      MIPS64 rel2
>>16        leshort                 0               no file type,
>>16        leshort                 1               relocatable,
>>16        leshort                 2               executable,
>>16        leshort                 3               shared object,
# Core handling from Peter Tobias <tobias@server.et-inf.fho-emden.de>
# corrections by Christian 'Dr. Disk' Hechelmann <drdisk@ds9.au.s.shuttle.de>
>>16        leshort                 4               core file
>>16        uleshort                &0xff00         processor-specific,
>>18        leshort                 0               no machine,
>>18        leshort                 1               AT&T WE32100 - wrong byte order,{invalid}
>>18        leshort                 2               SPARC - wrongbyte order,{invalid}
>>18        leshort                 3               Intel 80386,
>>18        leshort                 4               Motorola
>>>36       lelong                  &0x01000000     68000 - wrong byte order,{invalid}
>>>36       lelong                  &0x00810000     CPU32 - wrong byte order,{invalid}
>>>36       lelong                  0               68020 - wrong byte order,{invalid}
>>18        leshort                 5               Motorola 88000 - wrong byte order,{invalid}
>>18        leshort                 6               Intel 80486,
>>18        leshort                 7               Intel 80860,
>>18        leshort                 8               MIPS,
>>18        leshort                 9               Amdahl - wrong byte order,{invalid}
>>18        leshort                 10              MIPS (deprecated),
>>18        leshort                 11              RS6000 - wrong byte order,{invalid}
>>18        leshort                 15              PA-RISC - wrong byte order,{invalid}
>>>50       leshort                 0x0214          2.0
>>>48       leshort                 &0x0008         (LP64),
>>18        leshort                 16              nCUBE,
>>18        leshort                 17              Fujitsu VPP500,
>>18        leshort                 18              SPARC32PLUS,
>>18        leshort                 20              PowerPC,
>>18        leshort                 22              IBM S/390,
>>18        leshort                 36              NEC V800,
>>18        leshort                 37              Fujitsu FR20,
>>18        leshort                 38              TRW RH-32,
>>18        leshort                 39              Motorola RCE,
>>18        leshort                 40              ARM,
>>18        leshort                 41              Alpha,
>>18        uleshort                0xa390          IBM S/390 (obsolete),
>>18        leshort                 42              Hitachi SH,
>>18        leshort                 43              SPARC V9 - wrong byte order,{invalid}
>>18        leshort                 44              Siemens Tricore Embedded Processor,
>>18        leshort                 45              Argonaut RISC Core, Argonaut Technologies Inc.,
>>18        leshort                 46              Hitachi H8/300,
>>18        leshort                 47              Hitachi H8/300H,
>>18        leshort                 48              Hitachi H8S,
>>18        leshort                 49              Hitachi H8/500,
>>18        leshort                 50              IA-64 (Intel 64 bit architecture)
>>18        leshort                 51              Stanford MIPS-X,
>>18        leshort                 52              Motorola Coldfire,
>>18        leshort                 53              Motorola M68HC12,
>>18        leshort                 62              AMD x86-64,
>>18        leshort                 75              Digital VAX,
>>18        leshort                 97              NatSemi 32k,
>>18        uleshort                0x9026          Alpha (unofficial),
>>20        lelong                  0               {invalid} invalid version
>>20        lelong                  1               version 1
>>36        lelong                  1               MathCoPro/FPU/MAU Required
>5          byte                    2               MSB
# only for MIPS - see comment in little-endian section above.
>>18        beshort                 8
# only for 32-bit
>>>4        byte                    1
>>>>36      belong&0xf0000000       0x00000000      MIPS-I
>>>>36      belong&0xf0000000       0x10000000      MIPS-II
>>>>36      belong&0xf0000000       0x20000000      MIPS-III
>>>>36      belong&0xf0000000       0x30000000      MIPS-IV
>>>>36      belong&0xf0000000       0x40000000      MIPS-V
>>>>36      belong&0xf0000000       0x60000000      MIPS32
>>>>36      belong&0xf0000000       0x70000000      MIPS64
>>>>36      ubelong&0xf0000000      0x80000000      MIPS32 rel2
>>>>36      ubelong&0xf0000000      0x90000000      MIPS64 rel2
# only for 64-bit
>>>4        byte                    2
>>>>48      belong&0xf0000000       0x00000000      MIPS-I
>>>>48      belong&0xf0000000       0x10000000      MIPS-II
>>>>48      belong&0xf0000000       0x20000000      MIPS-III
>>>>48      belong&0xf0000000       0x30000000      MIPS-IV
>>>>48      belong&0xf0000000       0x40000000      MIPS-V
>>>>48      belong&0xf0000000       0x60000000      MIPS32
>>>>48      belong&0xf0000000       0x70000000      MIPS64 
>>>>48      ubelong&0xf0000000      0x80000000      MIPS32 rel2
>>>>48      ubelong&0xf0000000      0x90000000      MIPS64 rel2
>>16        beshort                 0               no file type,
>>16        beshort                 1               relocatable,
>>16        beshort                 2               executable,
>>16        beshort                 3               shared object,
>>16        beshort                 4               core file,
#>>>(0x38+0xcc) string    >\0        of '%s'
#>>>(0x38+0x10) belong    >0        (signal %d),
>>16        ubeshort                &0xff00         processor-specific,
>>18        beshort                 0               no machine,
>>18        beshort                 1               AT&T WE32100,
>>18        beshort                 2               SPARC,
>>18        beshort                 3               Intel 80386 - wrong byte order,{invalid}
>>18        beshort                 4               Motorola
>>>36       belong                  &0x01000000     68000,
>>>36       belong                  &0x00810000     CPU32,
>>>36       belong                  0               68020,
>>18        beshort                 5               Motorola 88000,
>>18        beshort                 6               Intel 80486 - wrong byte order,{invalid}
>>18        beshort                 7               Intel 80860 - wrong byte order,{invalid}
>>18        beshort                 8               MIPS,
>>18        beshort                 9               Amdahl,
>>18        beshort                 10              MIPS (deprecated),
>>18        beshort                 11              RS6000,
>>18        beshort                 15              PA-RISC
>>>50       beshort                 0x0214          2.0
>>>48       beshort                 &0x0008         (LP64)
>>18        beshort                 16              nCUBE,
>>18        beshort                 17              Fujitsu VPP500,
>>18        beshort                 18              SPARC32PLUS,
>>>36       belong&0xffff00         &0x000100       V8+ Required,
>>>36       belong&0xffff00         &0x000200       Sun UltraSPARC1 Extensions Required,
>>>36       belong&0xffff00         &0x000400       HaL R1 Extensions Required,
>>>36       belong&0xffff00         &0x000800       Sun UltraSPARC3 Extensions Required,
>>18        beshort                 20              PowerPC or cisco 4500,
>>18        beshort                 21              cisco 7500,
>>18        beshort                 22              IBM S/390,
>>18        beshort                 24              cisco SVIP,
>>18        beshort                 25              cisco 7200,
>>18        beshort                 36              NEC V800 or cisco 12000,
>>18        beshort                 37              Fujitsu FR20,
>>18        beshort                 38              TRW RH-32,
>>18        beshort                 39              Motorola RCE,
>>18        beshort                 40              ARM,
>>18        beshort                 41              Alpha,
>>18        beshort                 42              Hitachi SH,
>>18        beshort                 43              SPARC V9,
>>18        beshort                 44              Siemens Tricore Embedded Processor,
>>18        beshort                 45              Argonaut RISC Core, Argonaut Technologies Inc.,
>>18        beshort                 46              Hitachi H8/300,
>>18        beshort                 47              Hitachi H8/300H,
>>18        beshort                 48              Hitachi H8S,
>>18        beshort                 49              Hitachi H8/500,
>>18        beshort                 50              Intel Merced Processor,
>>18        beshort                 51              Stanford MIPS-X,
>>18        beshort                 52              Motorola Coldfire,
>>18        beshort                 53              Motorola M68HC12,
>>18        beshort                 73              Cray NV1,
>>18        beshort                 75              Digital VAX,
>>18        beshort                 97              NatSemi 32k,
>>18        ubeshort                0x9026          Alpha (unofficial),
>>18        ubeshort                0xa390          IBM S/390 (obsolete),
>>18        ubeshort                0xde3d          Ubicom32,
>>20        belong                  0               {invalid}invalid version
>>20        belong                  1               version 1
>>36        belong                  1               MathCoPro/FPU/MAU Required
# Up to now only 0, 1 and 2 are defined; I've seen a file with 0x83, it seemed
# like proper ELF, but extracting the string had bad results.
>4          byte                    <0x80
>>8         byte                    !0
>>>8        string                  x               ("%s")
>8          byte                    0
>>7         byte                    0               (SYSV)
>>7         byte                    1               (HP-UX)
>>7         byte                    2               (NetBSD)
>>7         byte                    3               (GNU/Linux)
>>7         byte                    4               (GNU/Hurd)
>>7         byte                    5               (86Open)
>>7         byte                    6               (Solaris)
>>7         byte                    7               (Monterey)
>>7         byte                    8               (IRIX)
>>7         byte                    9               (FreeBSD)
>>7         byte                    10              (Tru64)
>>7         byte                    11              (Novell Modesto)
>>7         byte                    12              (OpenBSD)
>>7         byte                    97              (ARM)
>>7         ubyte                   255             (embedded)

# Some simple Microsoft executable signatures
0           string      MZ\0\0\0\0\0\0      Microsoft executable,
>0x3c       lelong      <4                  {invalid}
>(0x3c.l)   string      !PE\0\0             MS-DOS
>(0x3c.l)   string      PE\0\0              portable (PE)

0           string      MZ                  Microsoft executable,
>0x3c       lelong      <4                  {invalid}
>(0x3c.l)   string      !PE\0\0             {invalid}
>(0x3c.l)   string      PE\0\0              portable (PE)


#------------------------------------------------------------------------------
# bFLT: file(1) magic for BFLT uclinux binary files
#
# From Philippe De Muyter <phdm@macqel.be>
# 
# Additional fields added by Craig Heffner
#
0       string      bFLT    BFLT executable
>4      belong      <1      {invalid}
>4      belong      >4      {invalid}
>4      belong      x       version %d, 
>8      ubelong     x       code offset: 0x%.8X, 
>12     ubelong     x       data segment starts at: 0x%.8X, 
>16     ubelong     x       bss segment starts at: 0x%.8X, 
>20     ubelong     x       bss segment ends at: 0x%.8X, 
>24     ubelong     x       stack size: %d bytes, 
>28     ubelong     x       relocation records start at: 0x%.8X, 
>32     ubelong     x       number of reolcation records: %d, 
>>36    belong&0x1  0x1     ram
>>36    belong&0x2  0x2     gotpic
>>36    belong&0x4  0x4     gzip
>>36    belong&0x8  0x8     gzdata


# Windows CE package files
0       string          MSCE\0\0\0\0    Microsoft WinCE installer
>20     lelong          0               \b, architecture-independent
>20     lelong          103             \b, Hitachi SH3
>20     lelong          104             \b, Hitachi SH4
>20     lelong          0xA11           \b, StrongARM
>20     lelong          4000            \b, MIPS R4000
>20     lelong          10003           \b, Hitachi SH3
>20     lelong          10004           \b, Hitachi SH3E
>20     lelong          10005           \b, Hitachi SH4
>20     lelong          70001           \b, ARM 7TDMI
>52     leshort         1               \b, 1 file
>52     uleshort        >1              \b, %u files
>56     leshort         1               \b, 1 registry entry
>56     uleshort        >1              \b, %u registry entries

#------------------------------------------------------------------------------
# motorola:  file(1) magic for Motorola 68K and 88K binaries
#
# 68K
#
# These signatures are useless without further sanity checking. Disable them until 
# that can be implemented.
#0       beshort         0x0208          mc68k COFF
#>18     beshort         ^00000020       object
#>18     beshort         &00000020       executable
#>12     belong          >0              not stripped
#>168    string          .lowmem         Apple toolbox
#>20     beshort         0407            (impure)
#>20     beshort         0410            (pure)
#>20     beshort         0413            (demand paged)
#>20     beshort         0421            (standalone)
#0       beshort         0x0209          mc68k executable (shared)
#>12     belong          >0              not stripped
#0       beshort         0x020A          mc68k executable (shared demand paged)
#>12     belong          >0              not stripped


#------------------------------------------------------------------------------
# Sony Playstation executables (Adam Sjoegren <asjo@diku.dk>) :
0       string  PS-X\x20EXE     Sony Playstation executable,
#  Area:
>113    string  x               "%s"

#------------------------------------------------------------------------------
# cisco:  file(1) magic for cisco Systems routers
#
# Most cisco file-formats are covered by the generic elf code
0   string      \x85\x01\x14    Cisco IOS microcode,
>7  byte        0               {invalid}
>7  string      x               for "%s"

0   string      \x85\x01\xcb    Cisco IOS experimental microcode,
>7  byte        0               {invalid}
>7  string      x               for "%s"

# EST flat binary format (which isn't, but anyway)
# From: Mark Brown <broonie@sirena.org.uk>
0    string    ESTFBINR    EST flat binary

# These are not the binaries themselves, but string references to them
# are a strong indication that they exist elsewhere...
#0    string    /bin/busybox    Busybox string reference: "%s"{one-of-many}
#0    string /bin/sh        Shell string reference: "%s"{one-of-many}

# Mach-O's
0    string \xca\xfe\xba\xbe\x00\x00\x00\x01    Mach-O universal binary with 1 architecture
0    string \xca\xfe\xba\xbe\x00\x00\x00\x02    Mach-O universal binary with 2 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x03    Mach-O universal binary with 3 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x04    Mach-O universal binary with 4 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x05    Mach-O universal binary with 5 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x06    Mach-O universal binary with 6 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x07    Mach-O universal binary with 7 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x08    Mach-O universal binary with 8 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0a    Mach-O universal binary with 9 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0b    Mach-O universal binary with 10 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0c    Mach-O universal binary with 11 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0d    Mach-O universal binary with 12 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0e    Mach-O universal binary with 13 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x0f    Mach-O universal binary with 14 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x10    Mach-O universal binary with 15 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x11    Mach-O universal binary with 16 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x12    Mach-O universal binary with 17 architectures
0    string \xca\xfe\xba\xbe\x00\x00\x00\x13    Mach-O universal binary with 18 architectures

# The magic bytes for Java .class files is 0xcafebabe, but AFAIK all major version numbers are less than 255
# and all minor version numbers are 0. This gives us three more bytes we can signature on.
0       string          \xca\xfe\xba\xbe\x00\x00\x00    Compiled Java class data,
>6      beshort         x                               version %d.
>4      beshort         x                               \b%d
# Which is which?
>4      belong          0x032d                          (Java 1.0/1.1)
#>4     belong          0x032d                          (Java 1.1)
>4      belong          0x002e                          (Java 1.2)
>4      belong          0x002f                          (Java 1.3)
>4      belong          0x0030                          (Java 1.4)
>4      belong          0x0031                          (Java 1.5)
>4      belong          0x0032                          (Java 1.6)
>4      belong          >0x0050                         {invalid}

# Summary: HP-38/39 calculator
0       string          HP38Bin         HP 38 binary
>7      string          A               (Directory List)
>7      string          B               (Zaplet)
>7      string          C               (Note)
>7      string          D               (Program)
>7      string          E               (Variable)
>7      string          F               (List)
>7      string          G               (Matrix)
>7      string          H               (Library)
>7      string          I               (Target List)
>7      string          J               (ASCII Vector specification)
>7      string          K               (wildcard)
>7      byte            <0x41           {invalid}
>7      byte            >0x4B           {invalid}

0       string          HP39Bin         HP 39 binary
>7      string          A               (Directory List)
>7      string          B               (Zaplet)
>7      string          C               (Note)
>7      string          D               (Program)
>7      string          E               (Variable)
>7      string          F               (List)
>7      string          G               (Matrix)
>7      string          H               (Library)
>7      string          I               (Target List)
>7      string          J               (ASCII Vector specification)
>7      string          K               (wildcard)
>7      byte            <0x41           {invalid}
>7      byte            >0x4B           {invalid}

0       string          HP38Asc         HP 38 ASCII
>7      string          A               (Directory List)
>7      string          B               (Zaplet)
>7      string          C               (Note)
>7      string          D               (Program)
>7      string          E               (Variable)
>7      string          F               (List)
>7      string          G               (Matrix)
>7      string          H               (Library)
>7      string          I               (Target List)
>7      string          J               (ASCII Vector specification)
>7      string          K               (wildcard)
>7      byte            <0x41           {invalid}
>7      byte            >0x4B           {invalid}

0       string          HP39Asc         HP 39 ASCII
>7      string          A               (Directory List)
>7      string          B               (Zaplet)
>7      string          C               (Note)
>7      string          D               (Program)
>7      string          E               (Variable)
>7      string          F               (List)
>7      string          G               (Matrix)
>7      string          H               (Library)
>7      string          I               (Target List)
>7      string          J               (ASCII Vector specification)
>7      string          K               (wildcard)
>7      byte            <0x41           {invalid}
>7      byte            >0x4B           {invalid}

# Summary: HP-48/49 calculator
0       string          HPHP48          HP 48 binary
>8      leshort         0x2911          (ADR)
>8      leshort         0x2933          (REAL)
>8      leshort         0x2955          (LREAL)
>8      leshort         0x2977          (COMPLX)
>8      leshort         0x299d          (LCOMPLX)
>8      leshort         0x29bf          (CHAR)
>8      leshort         0x29e8          (ARRAY)
>8      leshort         0x2a0a          (LNKARRAY)
>8      leshort         0x2a2c          (STRING)
>8      leshort         0x2a4e          (HXS)
>8      leshort         0x2a74          (LIST)
>8      leshort         0x2a96          (DIR)
>8      leshort         0x2ab8          (ALG)
>8      leshort         0x2ada          (UNIT)
>8      leshort         0x2afc          (TAGGED)
>8      leshort         0x2b1e          (GROB)
>8      leshort         0x2b40          (LIB)
>8      leshort         0x2b62          (BACKUP)
>8      leshort         0x2b88          (LIBDATA)
>8      leshort         0x2d9d          (PROG)
>8      leshort         0x2dcc          (CODE)
>8      leshort         0x2e48          (GNAME)
>8      leshort         0x2e6d          (LNAME)
>8      leshort         0x2e92          (XLIB)
>8      leshort        <0x2911          {invalid}
>8      leshort        >0x2e92          {invalid}

0       string          HPHP49          HP 49 binary
>8      leshort         0x2911          (ADR)
>8      leshort         0x2933          (REAL)
>8      leshort         0x2955          (LREAL)
>8      leshort         0x2977          (COMPLX)
>8      leshort         0x299d          (LCOMPLX)
>8      leshort         0x29bf          (CHAR)
>8      leshort         0x29e8          (ARRAY)
>8      leshort         0x2a0a          (LNKARRAY)
>8      leshort         0x2a2c          (STRING)
>8      leshort         0x2a4e          (HXS)
>8      leshort         0x2a74          (LIST)
>8      leshort         0x2a96          (DIR)
>8      leshort         0x2ab8          (ALG)
>8      leshort         0x2ada          (UNIT)
>8      leshort         0x2afc          (TAGGED)
>8      leshort         0x2b1e          (GROB)
>8      leshort         0x2b40          (LIB)
>8      leshort         0x2b62          (BACKUP)
>8      leshort         0x2b88          (LIBDATA)
>8      leshort         0x2d9d          (PROG)
>8      leshort         0x2dcc          (CODE)
>8      leshort         0x2e48          (GNAME)
>8      leshort         0x2e6d          (LNAME)
>8      leshort         0x2e92          (XLIB)
>8      leshort         <0x2911         {invalid}
>8      leshort         >0x2e92         {invalid}

0       string          \x23\x21/       Executable script,
>6      byte            !0x2F
>>7     byte            !0x2F           {invalid}
>2      string          x               shebang: "%s"

0       string          \x23\x21\x20/   Executable script,
>7      byte            !0x2F
>>8     byte            !0x2F           {invalid}
>3      string          x               shebang: "%s"


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/filesystems`:

```
#--------------------File Systems---------------------

# Minix filesystems
0x410   string      \x7f\x13\x00\x00\x00\x00    Minix filesystem, V1, little endian,
>0x402  beshort     x                           %d zones
>0x1e   string      minix                       \b, bootable
>0x1e   string      !minix
>>0x1e  string      !\x00\x00\x00\x00\x00       {invalid}

0x410   string      \x13\x7f\x00\x00\x00\x00    Minix filesystem, V1, big endian,
>0x402  beshort     x                           %d zones
>0x1e   string      minix                       \b, bootable
>0x1e   string      !minix
>>0x1e  string      !\x00\x00\x00\x00\x00       {invalid}

0x410   string      \x8f\x13\x00\x00\x00\x00    Minix filesystem, V1, little endian, 30 char names,
>0x402  beshort     x                           %d zones
>0x1e   string      minix                       \b, bootable
>0x1e   string      !minix
>>0x1e  string      !\x00\x00\x00\x00\x00       {invalid}

0x410   string      \x13\x8f\x00\x00\x00\x00    Minix filesystem, V1, big endian, 30 char names,
>0x402  beshort     x                           %d zones
>0x1e   string      minix                       \b, bootable
>0x1e   string      !minix
>>0x1e  string      !\x00\x00\x00\x00\x00       {invalid}

#0x410   leshort     0x2468      Minix filesystem, V2, little endian,
#>0x402  beshort     x           %d zones
#>0x1e   string      minix       \b, bootable

#0x410   beshort     0x2468      Minix filesystem, V2, big endian,
#>0x402  beshort     x           %d zones
#>0x1e   string      minix       \b, bootable

# YAFFS
0    string    \x03\x00\x00\x00\x01\x00\x00\x00\xFF\xFF    YAFFS filesystem

# EFS2 file system - jojo@utulsa.edu
0      lelong       0x53000000       EFS2 Qualcomm filesystem super block, little endian,
>8     string       !EFSSuper        {invalid},
>4     leshort&0x01 1                NAND
>4     leshort&0x01 0                NOR
>4     leshort      x                version 0x%x,
>24    lelong       x                %d blocks,
>16    lelong       x                0x%x pages per block,
>20    lelong       x                0x%x bytes per page

0      belong       0x53000000       EFS2 Qualcomm filesystem super block, big endian,
>8     string       !SSFErepu        {invalid},
>4     beshort&0x01 1                NAND
>4     beshort&0x01 0                NOR
>4     beshort      x                version 0x%x,
>24    belong       x                %d blocks,
>16    belong       x                0x%x pages per block,
>20    belong       x                0x%x bytes per page

# TROC file system
0       string      TROC    TROC filesystem,
>4      lelong      x       %d file entries
>4      lelong      <1      {invalid}

# PFS file system
0       string    PFS/      PFS filesystem,
>5      byte      !0x2E     {invalid}
>4      string    x         version %s,
>14     leshort   x         %d files

# MPFS file system
0       string      MPFS     MPFS filesystem, Microchop,
>4      byte        <0       {invalid}
>5      byte        <0       {invalid}
>4      byte        x        version %d.
>5      byte        x        \b%d,
>6      leshort     <0       {invalid}
>6      leshort     x        %d file entries

# cramfs filesystem - russell@coker.com.au
0       lelong      0x28cd3d45      CramFS filesystem, little endian,
>4      lelong      <0              {invalid}
>4      lelong      >1073741824     {invalid}
>4      ulelong     x               size: %u
>8      lelong      &1              version 2
>8      lelong      &2              sorted_dirs
>8      lelong      &4              hole_support
>32     ulelong     x               CRC 0x%.8X,
>36     ulelong     x               edition %u,
>40     lelong      <0              {invalid}
>40     ulelong     x               %u blocks,
>44     lelong      <0              {invalid}
>44     ulelong     x               %u files
>4      ulelong     x               {jump:%u}
>4      ulelong     x               {size:%u}

0       belong      0x28cd3d45      CramFS filesystem, big endian
>4      belong      <0              {invalid}
>4      belong      >1073741824     {invalid}
>4      belong      x               size %u
>8      belong      &1              version 2
>8      belong      &2              sorted_dirs
>8      belong      &4              hole_support
>32     ubelong     x               CRC 0x%.8X,
>36     belong      x               edition %u,
>40     belong      <0              {invalid}
>40     ubelong     x               %u blocks,
>44     belong      <0              {invalid}
>44     ubelong     x               %u files
>4      ubelong     x               {jump:%u}
>4      ubelong     x               {size:%u}

# http://www.dubeiko.com/development/FileSystems/UBI/ubidesign.pdf
0       string      UBI!            UBI volume ID header,
>4      ubyte       x               version: %d,
>5      ubyte       x               type: %d,
>8      ubelong     x               volume id: %d,
>8      ubelong     >256            {invalid}
>12     ubelong     x               size: %d
>12     ubelong     !0              {invalid}
>28     string      !\x00*12        {invalid}

# http://lxr.free-electrons.com/source/fs/ubifs/ubifs-media.h
0       string      UBI\x23         UBI erase count header,
>4      ubyte       x               version: %d,
>5      string      !\x00*3         {invalid}
>8      ubequad     x               EC: 0x%lX,
>16     ubelong     x               VID header offset: 0x%X,
>20     ubelong     x               data offset: 0x%X
# dummy jump - actual jump value is determined in UBIValidPlugin
>20       ubyte       x               {jump:0}

# http://lxr.free-electrons.com/source/fs/ubifs/ubifs-media.h
0        lelong      0x06101831     UBIFS filesystem
>20      ubyte       <6             {invalid}
>20      ubyte       >7             {invalid} # Only look for superblock and master nodes
>22      leshort     !0             {invalid} # 2 bytes of padding should be filled with NULLs
>20      ubyte       6              superblock node,
>20      ubyte       7              master node,
>4       ulelong     x              CRC: 0x%X,
# Master node
>20      ubyte       7
>>24     lequad      x              highest inode: %d,
>>32     lequad      x              commit number: %d
# Superblock node
>20      ubyte       6
>>24     leshort     !0             {invalid}
>>28     ulelong      x             flags: 0x%X,
>>32     lelong      x              min I/O unit size: %d,
>>36     lelong      x              erase block size: %d,
>>40     lelong      x              erase block count: %d,
>>44     lelong      x              max erase blocks: %d,
>>80     lelong      x              format version: %d,
>>84     uleshort    >2             {invalid}
>>84     uleshort    x              compression type:
>>84     uleshort    0              none
>>84     uleshort    1              lzo
>>84     uleshort    2              zlib
>>86     leshort     !0             invalid padding,{invalid}
>>128    string      !\x00*3968     invalid padding{invalid}

# JFFS2 file system
# If used with binwalk's smart signature feature (on by default, -S to disable)
# this signature can potentially lead to missing some JFFS2 file systems if there
# are multiple JFFS2 file systems in a target file and there are no other identified
# files in between the JFFS2 file systems. This is an unlikely scenario however, and
# the below signatures are much improved in terms of readability and accuracy in the
# vast majority of real world scenarios.
0                   uleshort    0x1985      JFFS2 filesystem, little endian
>2                  uleshort    !0xE001
>>2                 uleshort    !0xE002
>>>2                uleshort    !0x2003
>>>>2               uleshort    !0x2004
>>>>>2              uleshort    !0x2006
>>>>>>2             uleshort    !0xE008
>>>>>>>2            uleshort    !0xE009     {invalid}
>4                  lelong      0           {invalid}
>4                  lelong      <0          {invalid}
>4                  lelong      x           {many}{jump:%d}

0                   ubeshort    0x1985      JFFS2 filesystem, big endian
>2                  ubeshort    !0xE001
>>2                 ubeshort    !0xE002
>>>2                ubeshort    !0x2003
>>>>2               ubeshort    !0x2004
>>>>>2              ubeshort    !0x2006
>>>>>>2             ubeshort    !0xE008
>>>>>>>2            ubeshort    !0xE009     {invalid}
>4                  belong      0           {invalid}
>4                  belong      <0          {invalid}
>4                  belong      x           {many}{jump:%d}


# Squashfs, big endian
0       string  sqsh    Squashfs filesystem, big endian,
>28     beshort >10     {invalid}
>28     beshort <1      {invalid}
>30     beshort >10     {invalid}
>28     beshort x       version %d.
>30     beshort x       \b%d,
>28     beshort >3      compression:
>>20    beshort 1       \bgzip,
>>20    beshort 2       \blzma,
>>20    beshort 3       \bgzip (non-standard type definition),
>>20    beshort 4       \bxz,
>>20    beshort 0       \b{invalid},
>>20    beshort >4      \b{invalid},
>28     beshort <3
>>8     belong  x       size: %d bytes,
>>8     belong  x       \b{jump:%d}
>>8     belong  x       \b{size:%d}
>28     beshort 3
>>63    bequad  x       size: %ld bytes,
>>63    bequad  x       \b{jump:%ld}
>>63    bequad  x       \b{size:%ld}
>28     beshort >3
>>40    bequad  x       size: %ld bytes,
>>40    bequad  x       \b{jump:%ld}
>>40    bequad  x       \b{size:%ld}
>4      belong  x       %d inodes,
>28     beshort >3
>>12    belong  x       blocksize: %d bytes,
>28     beshort <2
>>32    beshort x       blocksize: %d bytes,
>28     beshort 2
>>51    belong  x       blocksize: %d bytes,
>28     beshort 3
>>51    belong  x       blocksize: %d bytes,
>28     beshort <4
>>39    bedate  x       created: %s
>28     beshort >3
>>8     bedate  x       created: %s

# Squashfs, little endian
0       string  hsqs    Squashfs filesystem, little endian,
>28     leshort >10     {invalid}
>28     leshort <1      {invalid}
>30     leshort >10     {invalid}
>28     leshort x       version %d.
>30     leshort x       \b%d,
>28     leshort >3      compression:
>>20    leshort 1       \bgzip,
>>20    leshort 2       \blzma,
>>20    leshort 3       \bgzip (non-standard type definition),
>>20    leshort 4       \bxz,
>>20    leshort 0       \b{invalid},
>>20    leshort >4      \b{invalid},
>28     leshort <3
>>8     lelong  x       size: %d bytes,
>>8     lelong  x       {size:%d}
>28     leshort 3
>>63    lequad  x       size: %ld bytes,
>>63    lequad  x       {size:%ld}
>28     leshort >3    
>>40    lequad  x       size: %ld bytes,
>>40    lequad  x       {size:%ld}
>4      lelong  x       %d inodes,
>28     leshort >3
>>12    lelong  x       blocksize: %d bytes,
>28     leshort <2
>>32    leshort x       blocksize: %d bytes,
>28     leshort 2
>>51    lelong  x       blocksize: %d bytes,
>28     leshort 3
>>51    lelong  x       blocksize: %d bytes,
>28     leshort <4
>>39    ledate  x       created: %s
>28     leshort >3
>>8     ledate  x       created: %s
>28     leshort <3
>>8     lelong  x       {jump:%d}
>28     leshort 3
>>63    lequad  x       {jump:%ld}
>28     leshort >3
>>40    lequad  x       {jump:%ld}

# Squashfs with LZMA compression
0       string  sqlz    Squashfs filesystem, big endian, lzma compression, 
>28     beshort >10     {invalid}
>28     beshort <1      {invalid}
>30     beshort >10     {invalid}
>28     beshort x       version %d.
>30     beshort x       \b%d,
>28     beshort >3      compression:
>>20    beshort 1       \bgzip,
>>20    beshort 2       \blzma,
>>20    beshort 3       \bgzip (non-standard type definition),
>>20    beshort 4       \blzma (non-standard type definition),
>>20    beshort 0       \b{invalid},
>>20    beshort >4      \b{invalid},
>28     beshort <3
>>8     belong  x       size: %d bytes,
>>8     belong  x       {size:%d}
>28     beshort 3
>>63    bequad  x       size: %ld bytes,
>>63    bequad  x       {size:%ld}
>28     beshort >3
>>40    bequad  x       size: %ld bytes,
>>40    bequad  x       {size:%ld}
>4      belong  x       %d inodes,
>28     beshort >3
>>12    belong  x       blocksize: %d bytes,
>28     beshort <2
>>32    beshort x       blocksize: %d bytes,
>28     beshort 2
>>51    belong  x       blocksize: %d bytes,
>28     beshort 3
>>51    belong  x       blocksize: %d bytes,
>28     beshort <4
>>39    bedate  x       created: %s
>28     beshort >3
>>8     bedate  x       created: %s
>28     beshort <3
>>8     belong  x       {jump:%d}
>28     beshort 3
>>63    bequad  x       {jump:%ld}
>28     beshort >3
>>40    bequad  x       {jump:%ld}

# Squashfs 3.3 LZMA signature
0       string  qshs    Squashfs filesystem, big endian, lzma signature,
>28     beshort >10     {invalid}
>28     beshort <1      {invalid}
>30     beshort >10     {invalid}
>28     beshort x       version %d.
>30     beshort x       \b%d,
>28     beshort >3      compression:
>>20    beshort 1       \bgzip,
>>20    beshort 2       \blzma,
>>20    beshort 3       \bgzip (non-standard type definition),
>>20    beshort 4       \bxz,
>>20    beshort 0       \b{invalid},
>>20    beshort >4      \b{invalid},
>28     beshort <3
>>8     belong  x       size: %d bytes,
>>8     belong  x       {size:%d}
>28     beshort 3
>>63    bequad  x       size: %ld bytes,
>>63    bequad  x       {size:%ld}
>28     beshort >3
>>40    bequad  x       size: %ld bytes,
>>40    bequad  x       {size:%ld}
>4      belong  x       %d inodes,
>28     beshort >3
>>12    belong  x       blocksize: %d bytes,
>28     beshort <2
>>32    beshort x       blocksize: %d bytes,
>28     beshort 2
>>51    belong  x       blocksize: %d bytes,
>28     beshort 3
>>51    belong  x       blocksize: %d bytes,
>28     beshort <4
>>39    bedate  x       created: %s
>28     beshort >3
>>8     bedate  x       created: %s
>28     beshort <3
>>8     belong  x       {jump:%d}
>28     beshort 3
>>63    bequad  x       {jump:%ld}
>28     beshort >3
>>40    bequad  x       {jump:%ld}

# Squashfs for DD-WRT
0       string  tqsh    Squashfs filesystem, big endian, DD-WRT signature,
>28     beshort >10     {invalid}
>28     beshort <1      {invalid}
>30     beshort >10     {invalid}
>28     beshort x       version %d.
>30     beshort x       \b%d,
>28     beshort >3      compression:
>>20    beshort 1       \bgzip,
>>20    beshort 2       \blzma,
>>20    beshort 3       \bgzip (non-standard type definition),
>>20    beshort 4       \bxz,
>>20    beshort 0       \b{invalid},
>>20    beshort >4      \b{invalid},
>28     beshort <3
>>8     belong  x       size: %d bytes,
>>8     belong  x       {size:%d}
>28     beshort 3
>>63    bequad  x       size: %ld bytes,
>>63    bequad  x       {size:%ld}
>28     beshort >3
>>40    bequad  x       size: %ld bytes,
>>40    bequad  x       {size:%ld}
>4      belong  x       %d inodes,
>28     beshort >3
>>12    belong  x       blocksize: %d bytes,
>28     beshort <2
>>32    beshort x       blocksize: %d bytes,
>28     beshort 2
>>51    belong  x       blocksize: %d bytes,
>28     beshort 3
>>51    belong  x       blocksize: %d bytes,
>28     beshort <4
>>39    bedate  x       created: %s
>28     beshort >3
>>8     bedate  x       created: %s
>28     beshort <3
>>8     belong  x       {jump:%d}
>28     beshort 3
>>63    bequad  x       {jump:%ld}
>28     beshort >3
>>40    bequad  x       {jump:%ld}

# Squashfs for DD-WRT
0       string  hsqt    Squashfs filesystem, little endian, DD-WRT signature,
>28     leshort >10     {invalid}
>28     leshort <1      {invalid}
>30     leshort >10     {invalid}
>28     leshort x       version %d.
>30     leshort x       \b%d,
>28     leshort >3      compression:
>>20    leshort 1       \bgzip,
>>20    leshort 2       \blzma,
>>20    leshort 3       \bgzip (non-standard type definition),
>>20    leshort 4       \bxz,
>>20    leshort 0       \b{invalid},
>>20    leshort >4      \b{invalid},
>28     leshort <3
>>8     lelong  x       size: %d bytes,
>>8     lelong  x       {size:%d}
>28     leshort 3
>>63    lequad  x       size: %ld bytes,
>>63    lequad  x       {size:%ld}
>28     leshort >3
>>40    lequad  x       size: %ld bytes,
>>40    lequad  x       {size:%ld}
>4      lelong  x       %d inodes,
>28     leshort >3
>>12    lelong  x       blocksize: %d bytes,
>28     leshort <2
>>32    leshort x       blocksize: %d bytes,
>28     leshort 2
>>51    lelong  x       blocksize: %d bytes,
>28     leshort 3
>>51    lelong  x       blocksize: %d bytes,
>28     leshort <4
>>39    ledate  x       created: %s
>28     leshort >3
>>8     ledate  x       created: %s
>28     leshort <3
>>8     lelong  x       {jump:%d}
>28     leshort 3
>>63    lequad  x       {jump:%ld}
>28     leshort >3
>>40    lequad  x       {jump:%ld}

# Non-standard Squashfs signature found on some D-Link routers
0       string  shsq    Squashfs filesystem, little endian, non-standard signature, 
>28     leshort >10     {invalid}
>28     leshort <1      {invalid}
>30     leshort >10     {invalid}
>28     leshort x       version %d.
>30     leshort x       \b%d,
>28     leshort >3      compression:
>>20    leshort 1       \bgzip,
>>20    leshort 2       \blzma,
>>20    leshort 3       \bgzip (non-standard type definition),
>>20    leshort 4       \bxz,
>>20    leshort 0       \b{invalid},
>>20    leshort >4      \b{invalid},
>28     leshort <3
>>8     lelong  x       size: %d bytes,
>>8     lelong  x       {size:%d}
>28     leshort 3
>>63    lequad  x       size: %ld bytes,
>>63    lequad  x       {size:%ld}
>28     leshort >3
>>40    lequad  x       size: %ld bytes,
>>40    lequad  x       {size:%ld}
>4      lelong  x       %d inodes,
>28     leshort >3
>>12    lelong  x       blocksize: %d bytes,
>28     leshort <2
>>32    leshort x       blocksize: %d bytes,
>28     leshort 2
>>51    lelong  x       blocksize: %d bytes,
>28     leshort 3
>>51    lelong  x       blocksize: %d bytes,
>28     leshort <4
>>39    ledate  x       created: %s
>28     leshort >3
>>8     ledate  x       created: %s
>28     leshort <3
>>8     lelong  x       {jump:%d}
>28     leshort 3
>>63    lequad  x       {jump:%ld}
>28     leshort >3
>>40    lequad  x       {jump:%ld}

# ext2/ext3 filesystems - Andreas Dilger <adilger@dilger.ca>
# ext4 filesystem - Eric Sandeen <sandeen@sandeen.net>
# volume label and UUID Russell Coker
# http://etbe.coker.com.au/2008/07/08/label-vs-uuid-vs-device/
0x438       uleshort        0xEF53          Linux EXT filesystem,
>0x43A      leshort         >4              {invalid}invalid state
>0x43A      leshort         3               {invalid}invalid state
>0x43A      leshort         <0              {invalid}invalid state
>0x43C      leshort         >3              {invalid}invalid error behavior
>0x43C      leshort         <0              {invalid}invalid error behavior
>0x43C      lelong          >1              {invalid}invalid major revision
>0x43C      lelong          <0              {invalid}invalid major revision
>0x43C      lelong          x               rev %d
>0x43E      leshort         x               \b.%d,
# No journal?  ext2
>0x438+36   lelong&0x04     0               ext2 filesystem data
>>0x43A     leshort&0x01    0               (mounted or unclean)
# Has a journal?  ext3 or ext4
>0x438+36   lelong          &0x0000004
#  and small INCOMPAT?
>>0x438+40  lelong          <0x0000040
#   and small RO_COMPAT?
>>>0x438+44 lelong          <0x0000008      ext3 filesystem data
#   else large RO_COMPAT?
>>>0x438+44 lelong          >0x0000007      ext4 filesystem data
#  else large INCOMPAT?
>>0x438+40  lelong          >0x000003f      ext4 filesystem data
>0x438+48   ubelong         x               \b, UUID=%08x
>0x438+52   ubeshort        x               \b-%04x
>0x438+54   ubeshort        x               \b-%04x
>0x438+56   ubeshort        x               \b-%04x
>0x438+58   ubelong         x               \b-%08x
>0x438+60   ubeshort        x               \b%04x
>0x438+64   byte            !0
>>0x438+64  string          x               \b, volume name "%s"


#romfs filesystems - Juan Cespedes <cespedes@debian.org>
0       string      -rom1fs-\0      romfs filesystem, version 1
>8      belong      >10000000       {invalid}
>8      belong      <1              {invalid}
>8      belong      x               size: %d bytes,
>16     string      x               {name:%s}
>16     string      x               named "%s"
>8      belong      x               {size:%d}
>8      belong      x               {jump:%d}

# Wind River MemFS file system, found in some VxWorks devices
0       string    owowowowowowowowowowowowowowow    Wind River management filesystem,{overlap}
>30     string    !ow                               {invalid},
>32     belong    1                                 compressed,
>32     belong    2                                 plain text,
>32     belong    <1                                {invalid}
>32     belong    >2                                {invalid}
>36     belong    x                                 %d files

# Wind River MemFS file system, found in some VxWorks devices
0       string    OWOWOWOWOWOWOWOWOWOWOWOWOWOWOW    Wind River management filesystem,{overlap}
>30     string    !OW                               {invalid},
>32     lelong    1                                 compressed,
>32     lelong    2                                 plain text,
>32     lelong    <1                                {invalid}
>32     lelong    >2                                {invalid}
>36     lelong    x                                 %d files

# netboot image - Juan Cespedes <cespedes@debian.org>
0       lelong              0x1b031336      Netboot image,
>4      lelong&0xFFFFFF00   0
>>4     lelong&0x100        0x000           mode 2
>>4     lelong&0x100        0x100           mode 3
>4      lelong&0xFFFFFF00   !0              unknown mode {invalid}

18    string            WDK\x202.0\x00    WDK file system, version 2.0

32769   string        CD001                                         ISO
>6144   string        !NSR0                                         9660 CD-ROM filesystem data,
>6144   string        NSR0                                          UDF filesystem data,
>6148   string        1                                             version 1.0,
>6148   string        2                                             version 2.0,
>6148   string        3                                             version 3.0
>6148   byte          >0x33                                         {invalid} version,
>6148   byte          <0x31                                         {invalid} version,
>38     byte          !0
>>38    string        x                                             volume name: "%s",
>2047   string        \000CD001\001EL\x20TORITO\x20SPECIFICATION    bootable

# updated by Joerg Jenderek at Nov 2012
# DOS Emulator image is 128 byte, null right padded header + harddisc image
0               string      DOSEMU\0        DOS Emulator image
>0x27E          leshort     !0xAA55         {invalid}
>0x27E          leshort     0xAA55
#offset is 128
>>19            byte        128
>>>(19.b-1)     byte        0x0
>>>>7           lelong      >0              \b, %d heads
>>>>11          lelong      >0              \b, %d sectors/track
>>>>15          lelong      >0              \b, %d cylinders

# From: Alex Beregszaszi <alex@fsn.hu>
0       string  COWD\x03        VMWare3 disk image,
>32     lelong  x               (%d/
>36     lelong  x               \b%d/
>40     lelong  x               \b%d)

0       string  COWD\x02    VMWare3 undoable disk image,
>32     byte    !0
>32     string  x           "%s"

# TODO: Add header validation
0       string        VMDK             VMware4 disk image
0       string        KDMV             VMware4 disk image

#--------------------------------------------------------------------
# Qemu Emulator Image
# Lines written by Friedrich Schwittay (f.schwittay@yousable.de)
# Updated by Adam Buchbinder (adam.buchbinder@gmail.com)
# Made by reading sources, reading documentation, and doing trial and error
# on existing QCOW files
0       string        QFI\xFB       QEMU QCOW Image

# BSD 2.x file system image; used in RetroBSD for PIC32.
0        string        FS\x3C\x3C       BSD 2.x filesystem,
>1020    string        !\x3E\x3EFS      {invalid}(missing FSMAGIC2),
>8       lelong*1024   x                size: %d bytes,
>8       lelong*1024   x                {size:%d}
>8       lelong*1024   x                {jump:%d}
>8       lelong        x                total blocks: %d,
>972     lelong        x                free blocks: %d,
>968     ledate        x                last modified: %s
>980     byte          !0
>>980    string        x                \b, last mounted on: "%s"

# Simple file system found in Foscam camera firmware
0       beshort  0xbd9a  Foscam WebUI filesystem,
>2      uleshort x       checksum: 0x%X,
>16     lelong   <3      {invalid}invalid first file name length,
>16     lelong   >127    {invalid}invalid first file name length,
>20     byte     0       {invalid}invalid first file name,
>20     byte     !0x2E
>>20    byte     !0x2F
>>>20   byte     <65     {invalid}invalid first file name,
>>>20   byte     >122    {invalid}invalid first file name,
>16     lelong   x       {strlen:%d}
>20     string   x       first file name: "{string}"


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/firmware`:

```

#--------------------------Firmware Formats---------------------------

# uImage file     
# From: Craig Heffner, U-Boot image.h header definitions file
0      belong    0x27051956     uImage header, header size: 64 bytes,
>4     ubelong   x              header CRC: 0x%X,
>8     bedate    x              created: %s,
>12    belong    <1             {invalid}
>12    ubelong   x              image size: %d bytes,
>16    ubelong   x              Data Address: 0x%X,
>20    ubelong   x              Entry Point: 0x%X,
>24    ubelong   x              data CRC: 0x%X,
>28    byte      0              OS: {invalid}invalid OS,
>28    byte      1              OS: OpenBSD,
>28    byte      2              OS: NetBSD,
>28    byte      3              OS: FreeBSD,
>28    byte      4              OS: 4.4BSD,
>28    byte      5              OS: Linux,
>28    byte      6              OS: SVR4,
>28    byte      7              OS: Esix,
>28    byte      8              OS: Solaris,
>28    byte      9              OS: Irix,
>28    byte      10             OS: SCO,
>28    byte      11             OS: Dell,
>28    byte      12             OS: NCR,
>28    byte      13             OS: LynxOS,
>28    byte      14             OS: VxWorks,
>28    byte      15             OS: pSOS,
>28    byte      16             OS: QNX,
>28    byte      17             OS: Firmware,
>28    byte      18             OS: RTEMS,
>28    byte      19             OS: ARTOS,
>28    byte      20             OS: Unity OS,
>29    byte      0              CPU: {invalid}invalid CPU,
>29    byte      1              CPU: Alpha,
>29    byte      2              CPU: ARM,
>29    byte      3              CPU: Intel x86,
>29    byte      4              CPU: IA64,
>29    byte      5              CPU: MIPS,
>29    byte      6              CPU: MIPS 64 bit,
>29    byte      7              CPU: PowerPC,
>29    byte      8              CPU: IBM S390,
>29    byte      9              CPU: SuperH,
>29    byte      10             CPU: Sparc,
>29    byte      11             CPU: Sparc 64 bit,
>29    byte      12             CPU: M68K,
>29    byte      13             CPU: Nios-32,
>29    byte      14             CPU: MicroBlaze,
>29    byte      15             CPU: Nios-II,
>29    byte      16             CPU: Blackfin,
>29    byte      17             CPU: AVR,
>29    byte      18             CPU: STMicroelectronics ST200,
#>30    byte    x        image type: %d,
>30    byte      0              image type: {invalid} Image,
>30    byte      1              image type: Standalone Program,
>30    byte      2              image type: OS Kernel Image,
>30    byte      3              image type: RAMDisk Image,
>30    byte      4              image type: Multi-File Image,
>30    byte      5              image type: Firmware Image,
>30    byte      6              image type: Script file,
>30    byte      7              image type: Filesystem Image,
>30    byte      8              image type: Binary Flat Device Tree Blob
>31    byte      0              compression type: none,
>31    byte      1              compression type: gzip,
>31    byte      2              compression type: bzip2,
>31    byte      3              compression type: lzma,
>32    string    x              image name: "%s"

#IMG0 header, found in VxWorks-based Mercury router firmware
0       string        IMG0    IMG0 (VxWorks) header,
>4      belong        <1      {invalid}
>4      belong        x       size: %d

#Mediatek bootloader signature
#From xp-dev.com
0    string        BOOTLOADER!    Mediatek bootloader

#CSYS header formats
0    string        CSYS\x00    CSYS header, little endian, 
>8   lelong        x           size: %d

0    string        CSYS\x80    CSYS header, big endian,
>8   belong        x           size: %d

# wrgg firmware image
0       string        wrgg02    WRGG firmware header,
>6      string        x         name: "%s",
>48     string        x         root device: "%s"

# trx image file
0       string        HDR0    TRX firmware header, little endian,
>4      lelong        <1      {invalid}
>4      ulelong       x       image size: %d bytes,
>8      ulelong       x       CRC32: 0x%X,
>12     uleshort      x       flags: 0x%X,
>14     uleshort      !1
>>14    uleshort      !2      {invalid}
>14     uleshort      2       version: %d, header size: 32 bytes,
>>16    ulelong       x       loader offset: 0x%X,
>>20    ulelong       x       linux kernel offset: 0x%X,
>>24    ulelong       x       rootfs offset: 0x%X,
>>28    ulelong       x       bin-header offset: 0x%X
>14     uleshort      1       version: %d, header size: 28 bytes,
>>16    ulelong       x       loader offset: 0x%X,
>>20    ulelong       x       linux kernel offset: 0x%X,
>>24    ulelong       x       rootfs offset: 0x%X

14      string        U2ND      BIN-Header,
>4      ulelong       !0        {invalid}
>22     string        !\x00*10  {invalid}
>0      string        x         board ID: %.4s,
>18     ubyte         0         hardware version: 4702,
>18     ubyte         1         hardware version: 4712,
>18     ubyte         2         hardware version: 4712L,
>18     ubyte         3         hardware version: 4704,
>18     ubyte         >3        hardware version: unknown (code: 0x%.2X),
>11     ubyte         x         firmware version: %d.
>12     ubyte         x         \b%d.
>12     ubyte         x         \b%d,
>8      ubyte         <80
>>8     ubyte         x         build date: 20%.2d-
>8      ubyte         >79
>>8     ubyte         x         build date: 19%.2d-
>9      ubyte         x         \b%.2d-
>10     ubyte         x         \b%.2d

# Ubicom firmware image
0       belong    0xFA320080    Ubicom firmware header,
>12     ubelong   x             checksum: 0x%X,
>24     belong    <0            {invalid}
>24     belong    x             image size: %d

# The ROME bootloader is used by several RealTek-based products.
# Unfortunately, the magic bytes are specific to each product, so
# separate signatures must be created for each one.

# Netgear KWGR614 ROME image
0     string         G614          Realtek firmware header, ROME bootloader,
>4    beshort        0xd92f        image type: KFS,
>4    beshort        0xb162        image type: RDIR,
>4    beshort        0xea43        image type: BOOT,
>4    beshort        0x8dc9        image type: RUN,
>4    beshort        0x2a05        image type: CCFG,
>4    beshort        0x6ce8        image type: DCFG,
>4    beshort        0xc371        image type: LOG,
>6    byte           x             header version: %d,
>10   ubyte          >12           {invalid} month
>12   ubyte          >31           {invalid} day
>8    ubyte          >3000         {invalid} year
#month
>10   byte           x             created: %d/
#day    
>12   byte           x             \b%d/
#year
>8    beshort        x             \b%d,
>16   belong         x             image size: %d bytes,
>22   ubyte          x             body checksum: 0x%X,
>23   ubyte          x             header checksum: 0x%X

# Linksys WRT54GX ROME image
0       belong          0x59a0e842      Realtek firmware header, ROME bootloader,
>4      ubeshort        0xd92f          image type: KFS,
>4      ubeshort        0xb162          image type: RDIR,
>4      ubeshort        0xea43          image type: BOOT,
>4      ubeshort        0x8dc9          image type: RUN,
>4      ubeshort        0x2a05          image type: CCFG,
>4      ubeshort        0x6ce8          image type: DCFG,
>4      ubeshort        0xc371          image type: LOG,
>6      byte            x               header version: %d,
>10     ubyte           >12             {invalid}invalid month
>12     ubyte           >31             {invalid}invalid day
>8      ubyte           >3000           {invalid}invalid year
#month
>10     byte            x               created: %d/
#day    
>12     byte            x               \b%d/
#year
>8      beshort         x               \b%d,
>16     belong          x               image size: %d bytes,
>22     ubyte           x               body checksum: 0x%X,
>23     ubyte           x               header checksum: 0x%X

# PackImg tag, somtimes used as a delimiter between the kernel and rootfs in firmware images.
0       string        --PaCkImGs      PackImg section delimiter tag,
>10     string        !--             {invalid}
# If the size in both big and little endian is greater than 512MB, consider this a false positive
>16     ulelong       >0x20000000
>>16    ubelong       >0x20000000    {invalid}
>16     lelong        <0
>>16    belong        <0             {invalid}
>16     lelong        >0
>>16    lelong        x              little endian size: %d bytes;
>16     belong        >0        
>>16    belong        x              big endian size: %d bytes


#------------------------------------------------------------------------------
# Broadcom header format
#
0       string          BCRM            Broadcom header,
>4      lelong          <0              {invalid}
>4      lelong          x               number of sections: %d,
>>8     lelong          18              first section type: flash
>>8     lelong          19              first section type: disk
>>8     lelong          21              first section type: tag


# Berkeley Lab Checkpoint Restart (BLCR) checkpoint context files
# http://ftg.lbl.gov/checkpoint
0       string  Ck0\0\0R\0\0\0  BLCR
>16     lelong  0               {invalid}
>16     ulelong >7              {invalid}
>16     lelong  1               x86
>16     lelong  3               alpha
>16     lelong  5               x86-64
>16     lelong  7               ARM
>8      lelong  x               context data (little endian, version %d)

0       string  \0\0\0C\0\0\0R  BLCR
>16     lelong  <2              {invalid}
>16     ulelong >8              {invalid}
>16     belong  2               SPARC
>16     belong  4               ppc
>16     belong  6               ppc64
>16     belong  7               ARMEB
>16     belong  8               SPARC64
>8      belong  x               context data (big endian, version %d)

# Aculab VoIP firmware
# From: Mark Brown <broonie@sirena.org.uk>
0       string  VoIP\x20Startup\x20and      Aculab VoIP firmware
>35     string  x                           format "%s"

#------------------------------------------------------------------------------
# HP LaserJet 1000 series downloadable firmware file
0       string  \xbe\xefABCDEFGH        HP LaserJet 1000 series downloadable firmware

# From Albert Cahalan <acahalan@gmail.com>
# really le32 operation,destination,payloadsize (but quite predictable)
# 01 00 00 00 00 00 00 c0 00 02 00 00
0       string          \1\0\0\0\0\0\0\300\0\2\0\0      Marvell Libertas firmware

#---------------------------------------------------------------------------
# The following entries have been tested by Duncan Laurie <duncan@sun.com> (a
# lead Sun/Cobalt developer) who agrees that they are good and worthy of
# inclusion.

# Boot ROM images for Sun/Cobalt Linux server appliances
0       string  Cobalt\x20Networks\x20Inc.\nFirmware\x20v     Paged COBALT boot rom
>38     string  x                                             V%.4s

# New format for Sun/Cobalt boot ROMs is annoying, it stores the version code
# at the very end where file(1) can't get it.
0       string CRfs     COBALT boot rom data (Flat boot rom or file system)

#
# Motorola S-Records, from Gerd Truschinski <gt@freebsd.first.gmd.de>
# Useless until forther improvements can be made to the signature.
#0   string      S0          Motorola S-Record; binary data in text format

#Windows CE Binary Image Data Format aka B000FF
#More information on the format:
#http://msdn.microsoft.com/en-us/library/ms924510.aspx
#http://forum.xda-developers.com/showthread.php?t=801167
0    string    B000FF    Windows CE image header,
>7   ulelong   x         image start: 0x%X,
>11  ulelong   x         image length: %d


#Windows CE RomImage
63    string    \x00ECEC     Windows CE memory segment header,
>4    ulelong   x            TOC address: 0x%X


# --------------------------------
# ZynOS ROM header format
# From openwrt zynos.h.
6      string      SIG          ZynOS header, header size: 48 bytes,
>3     byte        <0x7F        rom image type:
>>3    byte        <1           {invalid},
>>3    byte        >7           {invalid},
>>3    byte        1            ROMIMG,
>>3    byte        2            ROMBOOT,
>>3    byte        3            BOOTEXT,
>>3    byte        4            ROMBIN,
>>3    byte        5            ROMDIR,
>>3    byte        6            6,
>>3    byte        7            ROMMAP,
>3     byte        >0x7F        ram image type:
>>3    byte        >0x82        {invalid},
>>3    byte        0x80         RAM,
>>3    byte        0x81         RAMCODE,
>>3    byte        0x82         RAMBOOT,
>4     ubelong     >0x40000000  {invalid}
>4     belong      <0           {invalid}
>4     belong      0            {invalid}
>4     belong      x            uncompressed size: %d,
>8     belong      >0x40000000  {invalid}
>8     belong      <0           {invalid}
>8     belong      0            {invalid}
>8     belong      x            compressed size: %d,
>14    ubeshort    x            uncompressed checksum: 0x%X,
>16    ubeshort    x            compressed checksum: 0x%X,
>12    ubyte       x            flags: 0x%X,
>12    byte        &0x40        uncompressed checksum is valid,
>12    ubyte       &0x80        the binary is compressed,
>>12   byte        &0x20        compressed checksum is valid,
>35    ubelong     x            memory map table address: 0x%X

# Firmware header used by some VxWorks-based Cisco products
0      string        CI032.00       Cisco VxWorks firmware header,
>8     lelong        >1024          {invalid}
>8     lelong        <0             {invalid}
>8     lelong        x              header size: %d bytes,
>32    lelong        >1024          {invalid}
>32    lelong        <0             {invalid}
>32    lelong        x              number of files: %d,
>48    lelong        <0             {invalid}
>48    lelong        x              image size: %d,
>64    string        x              firmware version: "%s"

# Simple VxWorks reference strings
#0    string        VxWorks        VxWorks string referece:
#>0    string        x            "%s"
#0    string        vxworks        VxWorks string referece:
#>0    string        x            "%s"
#0    string        VXWORKS        VxWorks string referece:
#>0    string        x            "%s"

# Firmware header used by some TV's
0      string        FNIB     ZBOOT firmware header, header size: 32 bytes,
>8     ulelong       x        load address: 0x%.8X,
>12    ulelong       x        start address: 0x%.8X,
>16    ulelong       x        checksum: 0x%.8X,
>20    ulelong       x        version: 0x%.8X,
>24    lelong        <1       {invalid}
>24    ulelong       x        image size: %d bytes

# Firmware header used by several D-Link routers (and probably others)
0               string  \x5e\xa3\xa4\x17        DLOB firmware header,{jump:108}
>(7.b+12)       string  !\x5e\xa3\xa4\x17       {invalid},
#>>12           string  x                       %s,
>(7.b+40)       string  x                       boot partition: "%s"

# TP-Link firmware header structure; thanks to Jonathan McGowan for reversing and documenting this format
4          string          TP-LINK\x20Technologies TP-Link firmware header,
#>-4    lelong          x                       header version: %d,
>0x94      beshort         x                       firmware version: %d.
>0x96      beshort         x                       \b%d.
>0x98      beshort         x                       \b%d,
>0x18      string          x                       image version: "%s",
#>0x74  belong          x                       image size: %d bytes,
>0x3C      belong          x                       product ID: 0x%X,
>0x40      belong          x                       product version: %d,
>0x70      ubelong         x                       kernel load address: 0x%X,
>0x74      ubelong         x                       kernel entry point: 0x%X,
>0x7C      ubelong         x                       kernel offset: %d,
>0x80      ubelong         x                       kernel length: %d,
>0x84      ubelong         x                       rootfs offset: %d,
>0x88      ubelong         x                       rootfs length: %d,
>0x8C      ubelong         x                       bootloader offset: %d,
>0x90      ubelong         x                       bootloader length: %d

# Header format from: http://skaya.enix.org/wiki/FirmwareFormat
0       string        \x36\x00\x00\x00          Broadcom 96345 firmware header, header size: 256,
>4      string        !Broadcom
>>4     string        !\x20\x20\x20\x20         {invalid}
>41     beshort       !0x2020
>>41    beshort       !0x0000
>>>41   string        x                         firmware version: "%.4s",
>45     beshort       !0x0202
>>45    beshort       !0x0000
>>>45   string        x                         board id: "%s",
>236    ubelong       x                         ~CRC32 header checksum: 0x%X,
>216    ubelong       x                         ~CRC32 data checksum: 0x%X

# Xerox MFP DLM signatures
0       string        %%XRXbegin                Xerox DLM firmware start of header
0       string        %%OID_ATT_DLM_NAME        Xerox DLM firmware name:
>19     string        x                         "%s"
0       string        %%OID_ATT_DLM_VERSION     Xerox DLM firmware version:
>22     string        x                         "%s"
0       string        %%XRXend                  Xerox DLM firmware end of header

# Generic copyright signature
0       string      Copyright        Copyright string:
>9      byte        0                {invalid}
>0      string      x                "%s"

0       string      copyright        Copyright string:
>9      byte        0                {invalid}
>0      string      x                "%s"

# Sercomm firmware header
0       string         sErCoMm          Sercomm firmware signature,
>7      leshort        x                version control: %d,
>9      leshort        x                download control: %d,
>11     string         x                hardware ID: "%s",
>44     uleshort       x                hardware version: 0x%X,
>58     uleshort       x                firmware version: 0x%X,
>60     uleshort       x                starting code segment: 0x%X,
>62     uleshort       x                code size: 0x%X

# NPK firmware header, used by Mikrotik
0           belong        0x1EF1D0BA   NPK firmware header,
>4          lelong        <0           {invalid}
>4          lelong        x            image size: %d,
>14         string        x            image name: "%s",
>(48.l+58)  string        x            description: "%s"

# Ubiquiti firmware signatures
0       string      UBNT        Ubiquiti firmware header, header size: 264 bytes,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"

0       string      GEOS        Ubiquiti firmware header, header size: 264 bytes,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"

0       string      OPEN        Ubiquiti firmware header, third party,
>0x108  belong      !0          {invalid},
>0x104  ubelong     x           ~CRC32: 0x%X,
>4      byte        0           {invalid},
>4      string      x           version: "%s"

4   string      \x00\x00\x00\x00PART    Ubiquiti partition header,
>0  byte        x                       header size: 56 bytes,
>8  byte        0                       {invalid}
>8  string      x                       name: "%s",
>44 ubelong     x                       base address: 0x%.8X,
>52 belong      x                       data size: %d bytes{size:%d}

4   string      \x00\x00\x00\x00END\x2e Ubiquiti end header, header size: 12 bytes,
>12 belong      !0                      {invalid},
>8  ubelong     x                       cumulative ~CRC32: 0x%.8X


# Found in DIR-100 firmware
0       string      AIH0N       AIH0N firmware header, header size: 48,
>12     belong      x           size: %d,
>8      belong      !0          executable code,
>>8     belong      x           load address: 0x%X,
>32     string      x           version: "%s"

0       belong      0x5EA3A417      SEAMA firmware header, big endian,
>4      beshort     !0              {invalid}
>6      beshort     x               meta size: %d,
>8      belong      <1              {invalid}
>8      belong      x               image size: %d

0       lelong      0x5EA3A417      SEAMA firmware header, little endian,
>4      leshort     !0              {invalid}
>6      leshort     x               meta size: %d,
>8      lelong      <1              {invalid}
>8      lelong      x               image size: %d

0       belong      0x4D544443      NSP firmware header, big endian,
>16     belong      <1              {invalid}
>16     belong      x               header size: %d,
>20     belong      <1              {invalid}
>20     belong      x               image size: %d,
>20     belong      x               {size:%d}
>4      belong      <1              {invalid}
>4      ubelong     x               kernel offset: %d,
>12     belong      <1              {invalid}
>12     belong      x               header version: %d,

0       lelong      0x4D544443      NSP firmware header, little endian,
>16     lelong      <1              {invalid}
>16     lelong      x               header size: %d,
>20     lelong      <1              {invalid}
>20     lelong      x               image size: %d,
>20     lelong      x               {size:%d}
>4      lelong      <1              {invalid}
>4      ulelong     x               kernel offset: %d,
>12     lelong      <1              {invalid}
>12     lelong      x               header version: %d,

# http://www.openwiz.org/wiki/Firmware_Layout#Beyonwiz_.wrp_header_structure
0       string        WizFwPkgl    Beyonwiz firmware header,
>20     string        x            version: "%s"

0       string      BLI223WJ0   Thompson/Alcatel encoded firmware,
>32     byte        x           version: %d.
>33     byte        x           \b%d.
>34     byte        x           \b%d.
>35     byte        x           \b%d,
>44     belong      x           size: %d,
>48     ubelong     x           crc: 0x%.8X,
>35     byte        x           try decryption tool from:
>35     byte        x           http://download.modem-help.co.uk/mfcs-A/Alcatel/Modems/Misc/

16    string        \xd9\x54\x93\x7a\x68\x04\x4a\x44\x81\xce\x0b\xf6\x17\xd8\x90\xdf    UEFI PI firmware volume

# http://android.stackexchange.com/questions/23357/\
# is-there-a-way-to-look-inside-and-modify-an-adb-backup-created-file/\
# 23608#23608
0       string  ANDROID\040BACKUP\n     Android Backup
>15     string  1\n                     \b, version 1
>17     string  0\n                     \b, uncompressed
>17     string  1\n                     \b, compressed
>19     string  none\n                  \b, unencrypted
>19     string  AES-256\n               \b, encrypted AES-256

# http://forum.xda-developers.com/showthread.php?p=47818657
8    string    imgARMcC         Roku aimage SB

# Boot ROM images for Sun/Cobalt Linux server appliances
0       string    Cobalt\ Networks\ Inc.\nFirmware\ v    Paged Sun/COBALT boot rom,
>38     string    x                        version: "%.4s"

# Simple eCos string signatures
0        string    ecos                    eCos RTOS string reference:
>0       string    x                       "%s"
0        string    eCos                    eCos RTOS string reference:
>0       string    x                       "%s"
0        string    ECOS                    eCos RTOS string reference:
>0       string    x                       "%s"

# ZyXEL config signatures
6           string      dbgarea                  ZyXEL rom-0 configuration block, name: "%s",
>16         ubeshort    x                        compressed size: %d,
>14         ubeshort    x                        uncompressed size: %d,
>18         ubeshort+16 x                        data offset from start of block: %d

6           string      spt.dat                  ZyXEL rom-0 configuration block, name: "%s",
>16         ubeshort    x                        compressed size: %d,
>14         ubeshort    x                        uncompressed size: %d,
>18         ubeshort+16 x                        data offset from start of block: %d

6           string      autoexec.net             ZyXEL rom-0 configuration block, name: "%s",
>16         ubeshort    x                        compressed size: %d,
>14         ubeshort    x                        uncompressed size: %d,
>18         ubeshort+16 x                        data offset from start of block: %d

# Obfuscated Arcadyan firmware
0x68    string  \x00\xD5\x08                    Obfuscated Arcadyan firmware,
>0x6B   byte    !0                              {invalid} signature trailing byte [0x%X],{invalid}
# None of the known Arcadyan signatures bytes have a NULL byte
>0      byte    0                               {invalid}
>1      byte    0                               {invalid}
>2      byte    0                               {invalid}
>3      byte    0                               {invalid}
>0      ubelong x                               signature bytes: 0x%X,
>0x70   string  !\x00\x00\x00\x00\x00\x00       {invalid} padding bytes{invalid}

# Digi firmware images
0xC0            string  Digi            Digi International firmware,
>0xC8           beshort !0x4253
>>0xC8          beshort !0x4950
>>>0xC8         beshort !0x4944
>>>>0xC8        beshort !0x444f
>>>>>0xC8       beshort !0x4443
>>>>>>0xC8      beshort !0x4f53
>>>>>>>0xC8     beshort !0x4f43
>>>>>>>>0xC8    beshort !0x4646
>>>>>>>>>0xC8   beshort !0x5350         {invalid}invalid header,
>0xD4           ubelong x               load address: 0x%.8X,
>0xDC           ubelong x               entry point: 0x%.8X,

# Lancom firmware signatures, courtesy of christophvw
0    string            ELSF              LANCOM firmware header,
>22  string            x                 model: "%s",
>18  string            x                 firmware version: "%.4s",
>12  ubyte             255               Rel,
>12  ubyte             253               alpha,
>12  ubyte             220               PR,
>12  ubyte             >0
>>12 ubyte             <220              RC%d,
>12  ubyte             >220
>>12 ubyte-220         <237              RU%d,
>12  ubyte             0                 dev
>17  ubyte             >0
>>17 ubyte             x                 build %d
#get build date
>7   ubyte             !63
#date is stored as string
>>7  string            x                 ("%.8s")

0    string            ELSO              LANCOM OEM file

0    string            ELSB              LANCOM firmware loader,
>22  string            x                 model: "%s",
>18  string            x                 loader version: "%.4s",


0    string            ELSC              LANCOM WWAN firmware
>4   ubyte             3
>>5  beshort           0
>>7  string            x                 \b, "%s"

0               string      ELSP                    LANCOM file entry
>(198.L+202)    belong      !2
>>(198.L+202)   belong      !3                      {invalid}
>202            string      @(RECENT_FIRMWARE)/     \b, file name:
>>221           string      x                       "%s"
>>221           string      x                       \b{name:%s}
>(198.L+202)    belong      2
>>(198.L+206)   belong      <1                      {invalid}
>>(198.L+206)   belong      x                       \b, file size: %d bytes
>>(198.L+206)   belong      x                       \b{size:%d}
>(198.L+202)    belong      3
>>&4            string      @(RECENT_FIRMWARE)/     \b, alias:
>>&23           string      x                       "%s"
>>(&0.L+4)      belong      x                       \b, file size: %d bytes

# Another Broadcom firmware header...
# The header seems to be always 0x100 bytes length and there is more information than the one displayed (not sure about the meaning).
# Used for example in the EchoLife HG556a router
0x0	string 	\x38\x00\x00\x00	Broadcom firmware header
>0x4	string	!Broadcom Corporatio	{invalid}
>0x18	string	x			%s.
>0x8E	string	x			Model: %s.
>0xA2	string	x			Firmware version: %s.

# QNAP encrypted firmware
0       string       icpnas                  QNAP encrypted firmware footer
>10     string       x                       , model: %s
>26     string       x                       , version: %s
>42     uleshort     !0
>>42    string       x                       , date: %s

# Mediatek
0   string  SF_BOOT\x00\x00\x00\x00\x00  Mediatek Serial Flash Image
>12 lelong <1 {invalid}
>12 lelong >1 {invalid}
>12 lelong x  Version %d
0   string  EMMC_BOOT\x00\x00\x00    Mediatek EMMC Flash Image
>12 lelong <1 {invalid}
>12 lelong >1 {invalid}
>12 lelong x  Version %d
0   string  NOR_BOOT\x00\x00\x00\x00 Mediatek NOR Flash Image
>12 lelong <1 {invalid}
>12 lelong >1 {invalid}
>12 lelong x  Version %d

0  string BRLYT\x00\x00\x00 Mediatek Boot Header
>8 lelong <1 {invalid}
>8 lelong >1 {invalid}
>8 lelong x Version %d

0 string BBBB Boot section{overlap}
>8 lelong x Start 0x%X
>12 lelong x End 0x%X
>16 lelong &0x1 Load-by-Bootrom
>16 lelong &0x80000000 Internal-RAM
>16 lelong &0x7ffffff0 {invalid}

0 string FILE_INFO\x00\x00\x00 Mediatek File Info
>12 lelong <1 {invalid}
>12 lelong >1 {invalid}
>16 leshort 0 File Type: NONE
>16 leshort 1 File Type: ARM-Bootloader 
>16 leshort 2 File Type: ARM-External-Bootloader
>16 leshort 10 File Type: Root-Certificate
>16 leshort 256 File Type: Primary-MAUI
>16 leshort 264 File Type: VIVA
>16 leshort 769 File Type: SECURE_RO_ME
>18 byte 0 Flash Type: NONE
>18 byte 1 Flash Type: NOR Flash
>18 byte 2 Flash Type: NAND Sequential Flash
>18 byte 3 Flash Type: NAND_TTBL
>18 byte 4 Flash Type: NAND_FDM50
>18 byte 5 EMMC-Boot-Region
>18 byte 6 EMMC-Data-Region
>18 byte 7 Flash Type: Serial Flash
>18 byte 255 Flash Type: Device-End
>18 byte >20 {invalid}
>19 byte 0 No Signature
>19 byte 1 Signature Type: PHASH
>19 byte 2 Signature Type: SINGLE
>19 byte 3 Signature Type: SINGLE and PHASH
>19 byte 4 Signature Type: MULTI
>19 byte 5 Signature Type: TYPE_NUM
>19 byte 255 Signature Type: TYE_END
>19 byte >20 {invalid}
>20 lelong x Load Address: 0x%X
>24 lelong x File Length: %d
>28 lelong x Maximum Size: %d
>32 lelong x Content Offset: 0x%X
>36 lelong x Signature Lenght: %d
>40 lelong x Jump Offset: %d
>44 lelong &0x1 POST_BUILD_DONE
>44 lelong &0x2 XIP (Execute In Place)
>44 lelong &0x4 SLT
>44 lelong &0xffffff00 {invalid}

# Android bootimg
# https://android.googlesource.com/platform/system/core.git/+/master/mkbootimg/bootimg.h
0     string     ANDROID!      Android bootimg
>8    ulelong    x             \b, kernel size: %d bytes
>12   ulelong    x             \b, kernel addr: 0x%X
>16   ulelong    x             \b, ramdisk size: %d bytes
>20   ulelong    x             \b, ramdisk addr: 0x%X
>48   string     x             \b, product name: "%s"



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/hashing`:

```
# CRC32 polynomial table
0   string  \x00\x00\x00\x00\x77\x07\x30\x96\xEE\x0E\x61\x2C\x99\x09\x51\xBA    CRC32 polynomial table, big endian
0   string  \x00\x00\x00\x00\x96\x30\x07\x77\x2C\x61\x0E\xEE\xBA\x51\x09\x99    CRC32 polynomial table, little endian

# SHA256 constant k
0   string  \x42\x8a\x2f\x98\x71\x37\x44\x91\xb5\xc0\xfb\xcf\xe9\xb5\xdb\xa5    SHA256 hash constants, big endian
0   string  \x98\x2f\x8a\x42\x91\x44\x37\x71\xcf\xfb\xc0\xb5\xa5\xdb\xb5\xe9    SHA256 hash constants, little endian



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/images`:

```
# Tag Image File Format, from Daniel Quinlan (quinlan@yggdrasil.com)
# The second word of TIFF files is the TIFF version number, 42, which has
# never changed.  The TIFF specification recommends testing for it.
0       string          MM\x00\x2a      TIFF image data, big-endian,
>4      belong          0               {invalid}
>4      belong          <0              {invalid}
# First image directory must begin on an even byte boundary
>4      belong          &1              {invalid}
>4      belong          >10000000       {invalid}
>4      belong          x               offset of first image directory: %d

0       string          II\x2a\x00      TIFF image data, little-endian
>4      lelong          0               {invalid}
>4      lelong          <0              {invalid}
>4      lelong          &1              {invalid}
>4      lelong          >10000000       {invalid}
>4      lelong          x               offset of first image directory: %d

# PNG [Portable Network Graphics, or "PNG's Not GIF"] images
# (Greg Roelofs, newt@uchicago.edu)
# (Albert Cahalan, acahalan@cs.uml.edu)
#
# 137 P N G \r \n ^Z \n [4-byte length] H E A D [HEAD data] [HEAD crc] ...
#
0       string          \x89PNG\x0d\x0a\x1a\x0a         PNG image
>16     belong          <1                              {invalid}
>16     belong          >10000                          {invalid}
>20     belong          <1                              {invalid}
>20     belong          >10000                          {invalid}
>16     belong          x                               \b, %d x
>20     belong          x                               %d,
>24     byte            x                               %d-bit
>25     byte            0                               grayscale,
>25     byte            2                               \b/color RGB,
>25     byte            3                               colormap,
>25     byte            4                               gray+alpha,
>25     byte            6                               \b/color RGBA,
>28     byte            0                               non-interlaced
>28     byte            1                               interlaced

# GIF
0       string          GIF8            GIF image data
>4      string          7a              \b, version "8%s",
>4      string          9a              \b, version "8%s",
>6      leshort         >0              %d x
>8      leshort         >0              %d
#>10    byte            &0x80           color mapped,
#>10    byte&0x07       =0x00           2 colors
#>10    byte&0x07       =0x01           4 colors
#>10    byte&0x07       =0x02           8 colors
#>10    byte&0x07       =0x03           16 colors
#>10    byte&0x07       =0x04           32 colors
#>10    byte&0x07       =0x05           64 colors
#>10    byte&0x07       =0x06           128 colors
#>10    byte&0x07       =0x07           256 colors

# PC bitmaps (OS/2, Windows BMP files)  (Greg Roelofs, newt@uchicago.edu)
0       string          BM          PC bitmap,
>14     leshort         !12
>>14    leshort         !64
>>>14   leshort         !40
>>>>14  leshort         !128        {invalid}
>14     leshort         12          OS/2 1.x format,
>>18    lelong          <1          {invalid}
>>18    lelong          >1000000    {invalid}
>>18    leshort         x           \b, %d x
>>20    lelong          <1          {invalid}
>>20    lelong          >1000000    {invalid}
>>20    leshort         x           %d
>14     leshort         64          OS/2 2.x format,
>>18    lelong          <1          {invalid}
>>18    lelong          >1000000    {invalid}
>>18    leshort         x           \b, %d x
>>20    lelong          <1          {invalid}
>>20    lelong          >1000000    {invalid}
>>20    leshort         x           %d
>14     leshort         40          Windows 3.x format,
>>18    lelong          <1          {invalid}
>>18    lelong          >1000000    {invalid}
>>18    lelong          x           \b, %d x
>>22    lelong          <1          {invalid}
>>22    lelong          >1000000    {invalid}
>>22    lelong          x           %d x
>>28    lelong           <1         {invalid}
>>28    lelong          >1000000    {invalid}
>>28    leshort         x           %d
>14     leshort         128         Windows NT/2000 format,
>>18    lelong          >1000000    {invalid}
>>18    lelong          <1          {invalid}
>>18    lelong          x           \b, %d x
>>22    lelong          <1          {invalid}
>>22    lelong          >1000000    {invalid}
>>22    lelong          x           %d x
>>28    lelong          <1          {invalid}
>>28    lelong          >1000000    {invalid}
>>28    leshort         x           %d

#------------------------------------------------------------------------------
# JPEG images
# SunOS 5.5.1 had
#
#       0       string          \377\330\377\340        JPEG file
#       0       string          \377\330\377\356        JPG file
#
# both of which turn into "JPEG image data" here.
#
0       ubelong         0xffd8ffe0    JPEG image data, JFIF standard 
>6      string          !JFIF         {invalid}
# The following added by Erik Rossen <rossen@freesurf.ch> 1999-09-06
# in a vain attempt to add image size reporting for JFIF.  Note that these
# tests are not fool-proof since some perfectly valid JPEGs are currently
# impossible to specify in magic(4) format.
# First, a little JFIF version info:
>11    byte             x            \b %d.
>12    byte             x            \b%02d
# Next, the resolution or aspect ratio of the image:
#>>13   byte            0               \b, aspect ratio
#>>13   byte            1               \b, resolution (DPI)
#>>13   byte            2               \b, resolution (DPCM)
#>>4    beshort         x               \b, segment length %d
# Next, show thumbnail info, if it exists:
>18    byte             !0           \b, thumbnail %dx
>>19   byte             x            \b%d


0               ubelong         0xffd8ffe1      JPEG image data, EXIF standard
# EXIF moved down here to avoid reporting a bogus version number,
# and EXIF version number printing added.
#   - Patrik R=E5dman <patrik+file-magic@iki.fi>
>6              string          !Exif           {invalid}
# Look for EXIF IFD offset in IFD 0, and then look for EXIF version tag in EXIF IFD.
# All possible combinations of entries have to be enumerated, since no looping
# is possible. And both endians are possible...
# The combinations included below are from real-world JPEGs.
# Little-endian
>12             string          II
# IFD 0 Entry #5:
>>70            leshort         0x8769
# EXIF IFD Entry #1:
>>>(78.l+14)    leshort         0x9000
>>>>(78.l+23)   byte            x               %c
>>>>(78.l+24)   byte            x               \b.%c
>>>>(78.l+25)   byte            !0x30           \b%c
# IFD 0 Entry #9:
>>118           leshort         0x8769
# EXIF IFD Entry #3:
>>>(126.l+38)   leshort         0x9000
>>>>(126.l+47)  byte            x               %c
>>>>(126.l+48)  byte            x               \b.%c
>>>>(126.l+49)  byte            !0x30           \b%c
# IFD 0 Entry #10
>>130           leshort         0x8769
# EXIF IFD Entry #3:
>>>(138.l+38)   leshort         0x9000
>>>>(138.l+47)  byte            x               %c
>>>>(138.l+48)  byte            x               \b.%c
>>>>(138.l+49)  byte            !0x30           \b%c
# EXIF IFD Entry #4:
>>>(138.l+50)   leshort         0x9000
>>>>(138.l+59)  byte            x               %c
>>>>(138.l+60)  byte            x               \b.%c
>>>>(138.l+61)  byte            !0x30           \b%c
# EXIF IFD Entry #5:
>>>(138.l+62)   leshort         0x9000
>>>>(138.l+71)  byte            x               %c
>>>>(138.l+72)  byte            x               \b.%c
>>>>(138.l+73)  byte            !0x30           \b%c
# IFD 0 Entry #11
>>142           leshort         0x8769
# EXIF IFD Entry #3:
>>>(150.l+38)   leshort         0x9000
>>>>(150.l+47)  byte            x               %c
>>>>(150.l+48)  byte            x               \b.%c
>>>>(150.l+49)  byte            !0x30           \b%c
# EXIF IFD Entry #4:
>>>(150.l+50)   leshort         0x9000
>>>>(150.l+59)  byte            x               %c
>>>>(150.l+60)  byte            x               \b.%c
>>>>(150.l+61)  byte            !0x30           \b%c
# EXIF IFD Entry #5:
>>>(150.l+62)   leshort         0x9000
>>>>(150.l+71)  byte            x               %c
>>>>(150.l+72)  byte            x               \b.%c
>>>>(150.l+73)  byte            !0x30           \b%c
# Big-endian
>12             string          MM
# IFD 0 Entry #9:
>>118           beshort         0x8769
# EXIF IFD Entry #1:
>>>(126.L+14)   beshort         0x9000
>>>>(126.L+23)  byte            x               %c
>>>>(126.L+24)  byte            x               \b.%c
>>>>(126.L+25)  byte            !0x30           \b%c
# EXIF IFD Entry #3:
>>>(126.L+38)   beshort         0x9000
>>>>(126.L+47)  byte            x               %c
>>>>(126.L+48)  byte            x               \b.%c
>>>>(126.L+49)  byte            !0x30           \b%c
# IFD 0 Entry #10
>>130           beshort         0x8769
# EXIF IFD Entry #3:
>>>(138.L+38)   beshort         0x9000
>>>>(138.L+47)  byte            x               %c
>>>>(138.L+48)  byte            x               \b.%c
>>>>(138.L+49)  byte            !0x30           \b%c
# EXIF IFD Entry #5:
>>>(138.L+62)   beshort         0x9000
>>>>(138.L+71)  byte            x               %c
>>>>(138.L+72)  byte            x               \b.%c
>>>>(138.L+73)  byte            !0x30           \b%c
# IFD 0 Entry #11
>>142           beshort         0x8769
# EXIF IFD Entry #4:
>>>(150.L+50)   beshort         0x9000
>>>>(150.L+59)  byte            x               %c
>>>>(150.L+60)  byte            x               \b.%c
>>>>(150.L+61)  byte            !0x30           \b%c
# Here things get sticky.  We can do ONE MORE marker segment with
# indirect addressing, and that's all.  It would be great if we could
# do pointer arithemetic like in an assembler language.  Christos?
# And if there was some sort of looping construct to do searches, plus a few
# named accumulators, it would be even more effective...
# At least we can show a comment if no other segments got inserted before:
>(4.S+5)        byte            0xFE
>>(4.S+8)       string          >\0             \b, comment: "%s"
# FIXME: When we can do non-byte counted strings, we can use that to get
# the string's count, and fix Debian bug #283760
#>(4.S+5)       byte            0xFE            \b, comment
#>>(4.S+6)      beshort         x               \b length=%d
#>>(4.S+8)      string          >\0             \b, "%s"
# Or, we can show the encoding type (I've included only the three most common)
# and image dimensions if we are lucky and the SOFn (image segment) is here:
>(4.S+5)        byte            0xC0            \b, baseline
>>(4.S+6)       byte            x               \b, precision %d
>>(4.S+7)       beshort         x               \b, %dx
>>(4.S+9)       beshort         x               \b%d
>(4.S+5)        byte            0xC1            \b, extended sequential
>>(4.S+6)       byte            x               \b, precision %d
>>(4.S+7)       beshort         x               \b, %dx
>>(4.S+9)       beshort         x               \b%d
>(4.S+5)        byte            0xC2            \b, progressive
>>(4.S+6)       byte            x               \b, precision %d
>>(4.S+7)       beshort         x               \b, %dx
>>(4.S+9)       beshort         x               \b%d


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/linux`:

```

#-------------------------Kernels-------------------------------------

# Linux kernel boot images, from Albert Cahalan <acahalan@cs.uml.edu>
# and others such as Axel Kohlmeyer <akohlmey@rincewind.chemie.uni-ulm.de>
# and Nicolas Lichtmaier <nick@debian.org>
# All known start with: b8 c0 07 8e d8 b8 00 90 8e c0 b9 00 01 29 f6 29
0       string      \xb8\xc0\x07\x8e\xd8\xb8\x00\x90\x8e\xc0\xb9\x00\x01\x29\xf6\x29    Linux kernel boot image
>514    string      !HdrS                                                               {invalid}

# Finds and prints Linux kernel strings in raw Linux kernels (output like uname -a).
# Commonly found in decompressed embedded kernel binaries.
0       string      Linux\x20version\x20    Linux kernel version
>14     byte        0                       {invalid}
>14     byte        !0
>>14    string      x                       "%s"

# Linux ARM compressed kernel image
# See arch/arm/boot/compressed/head.S and arch/arm/boot/compressed/vmlinux.lds.S
0	ulelong	0x016f2818	Linux kernel ARM boot executable zImage (little-endian),
>4	ulelong x		    load address: "0x%.8X",
>8	ulelong	x		    end address: "0x%.8X"
>12 ulelong !0x04030201 {invalid}

0	ubelong	0x016f2818	Linux kernel ARM boot executable zImage (big-endian),
>4	ubelong x		    load address: "0x%.8X",
>8	ubelong	x		    end address: "0x%.8X"
>12 ubelong !0x04030201 {invalid}


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/lzma`:

```
#
## ------------------------------------------------------------------
## Signature for LZMA compressed data with valid properties byte 0x40
## ------------------------------------------------------------------
#0        string    \x40\x00\x00    LZMA compressed data, properties: 0x40,
#
## These are all the valid dictionary sizes supported by LZMA utils.
#>1        lelong    !65536    
#>>1        lelong    !131072    
#>>>1        lelong    !262144    
#>>>>1        lelong    !524288    
#>>>>>1        lelong    !1048576    
#>>>>>>1        lelong    !2097152    
#>>>>>>>1    lelong    !4194304    
#>>>>>>>>1    lelong    !8388608    
#>>>>>>>>>1    lelong    !16777216    
#>>>>>>>>>>1    lelong    !33554432    {invalid}
#>1        lelong    x        dictionary size: %d bytes,
#
## Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
## This could technically be valid, but is unlikely.
#>5        lequad    !-1
#>>5        lequad    <32        {invalid}
#>>5        lequad    >0x40000000    {invalid}
#
## These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
## Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
## marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
#>1        lelong    65536
#>>5        lequad    65536        {invalid}
#>1        lelong    131072
#>>5        lequad    131072        {invalid}
#>1        lelong    262144
#>>5        lequad    262144        {invalid}
#>1        lelong    524288
#>>5        lequad    524288        {invalid}
#>1        lelong    1048576
#>>5        lequad    1048576        {invalid}
#>1        lelong    2097152
#>>5        lequad    2097152        {invalid}
#>1        lelong    4194304
#>>5        lequad    4194304        {invalid}
#>1        lelong    8388608
#>>5        lequad    8388608        {invalid}
#>1        lelong    16777216
#>>5        lequad    16777216    {invalid}
#>1        lelong    33554432
#>>5        lequad    33554432    {invalid}
#>5        lequad    x        uncompressed size: %lld bytes
#
#
## ------------------------------------------------------------------
## Signature for LZMA compressed data with valid properties byte 0x41
## ------------------------------------------------------------------
#0        string    \x41\x00\x00    LZMA compressed data, properties: 0x41,
#
## These are all the valid dictionary sizes supported by LZMA utils.
#>1        lelong    !65536    
#>>1        lelong    !131072    
#>>>1        lelong    !262144    
#>>>>1        lelong    !524288    
#>>>>>1        lelong    !1048576    
#>>>>>>1        lelong    !2097152    
#>>>>>>>1    lelong    !4194304    
#>>>>>>>>1    lelong    !8388608    
#>>>>>>>>>1    lelong    !16777216    
#>>>>>>>>>>1    lelong    !33554432    {invalid}
#>1        lelong    x        dictionary size: %d bytes,
#
## Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
## This could technically be valid, but is unlikely.
#>5        lequad    !-1
#>>5        lequad    <32        {invalid}
#>>5        lequad    >0x40000000    {invalid}
#
## These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
## Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
## marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
#>1        lelong    65536
#>>5        lequad    65536        {invalid}
#>1        lelong    131072
#>>5        lequad    131072        {invalid}
#>1        lelong    262144
#>>5        lequad    262144        {invalid}
#>1        lelong    524288
#>>5        lequad    524288        {invalid}
#>1        lelong    1048576
#>>5        lequad    1048576        {invalid}
#>1        lelong    2097152
#>>5        lequad    2097152        {invalid}
#>1        lelong    4194304
#>>5        lequad    4194304        {invalid}
#>1        lelong    8388608
#>>5        lequad    8388608        {invalid}
#>1        lelong    16777216
#>>5        lequad    16777216    {invalid}
#>1        lelong    33554432
#>>5        lequad    33554432    {invalid}
#>5        lequad    x        uncompressed size: %lld bytes
#
#
## ------------------------------------------------------------------
## Signature for LZMA compressed data with valid properties byte 0x48
## ------------------------------------------------------------------
#0        string    \x48\x00\x00    LZMA compressed data, properties: 0x48,
#
## These are all the valid dictionary sizes supported by LZMA utils.
#>1        lelong    !65536    
#>>1        lelong    !131072    
#>>>1        lelong    !262144    
#>>>>1        lelong    !524288    
#>>>>>1        lelong    !1048576    
#>>>>>>1        lelong    !2097152    
#>>>>>>>1    lelong    !4194304    
#>>>>>>>>1    lelong    !8388608    
#>>>>>>>>>1    lelong    !16777216    
#>>>>>>>>>>1    lelong    !33554432    {invalid}
#>1        lelong    x        dictionary size: %d bytes,
#
## Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
## This could technically be valid, but is unlikely.
#>5        lequad    !-1
#>>5        lequad    <32        {invalid}
#>>5        lequad    >0x40000000    {invalid}
#
## These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
## Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
## marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
#>1        lelong    65536
#>>5        lequad    65536        {invalid}
#>1        lelong    131072
#>>5        lequad    131072        {invalid}
#>1        lelong    262144
#>>5        lequad    262144        {invalid}
#>1        lelong    524288
#>>5        lequad    524288        {invalid}
#>1        lelong    1048576
#>>5        lequad    1048576        {invalid}
#>1        lelong    2097152
#>>5        lequad    2097152        {invalid}
#>1        lelong    4194304
#>>5        lequad    4194304        {invalid}
#>1        lelong    8388608
#>>5        lequad    8388608        {invalid}
#>1        lelong    16777216
#>>5        lequad    16777216    {invalid}
#>1        lelong    33554432
#>>5        lequad    33554432    {invalid}
#>5        lequad    x        uncompressed size: %lld bytes
#
#
## ------------------------------------------------------------------
## Signature for LZMA compressed data with valid properties byte 0x49
## ------------------------------------------------------------------
#0        string    \x49\x00\x00    LZMA compressed data, properties: 0x49,
#
## These are all the valid dictionary sizes supported by LZMA utils.
#>1        lelong    !65536    
#>>1        lelong    !131072    
#>>>1        lelong    !262144    
#>>>>1        lelong    !524288    
#>>>>>1        lelong    !1048576    
#>>>>>>1        lelong    !2097152    
#>>>>>>>1    lelong    !4194304    
#>>>>>>>>1    lelong    !8388608    
#>>>>>>>>>1    lelong    !16777216    
#>>>>>>>>>>1    lelong    !33554432    {invalid}
#>1        lelong    x        dictionary size: %d bytes,
#
## Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
## This could technically be valid, but is unlikely.
#>5        lequad    !-1
#>>5        lequad    <32        {invalid}
#>>5        lequad    >0x40000000    {invalid}
#
## These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
## Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
## marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
#>1        lelong    65536
#>>5        lequad    65536        {invalid}
#>1        lelong    131072
#>>5        lequad    131072        {invalid}
#>1        lelong    262144
#>>5        lequad    262144        {invalid}
#>1        lelong    524288
#>>5        lequad    524288        {invalid}
#>1        lelong    1048576
#>>5        lequad    1048576        {invalid}
#>1        lelong    2097152
#>>5        lequad    2097152        {invalid}
#>1        lelong    4194304
#>>5        lequad    4194304        {invalid}
#>1        lelong    8388608
#>>5        lequad    8388608        {invalid}
#>1        lelong    16777216
#>>5        lequad    16777216    {invalid}
#>1        lelong    33554432
#>>5        lequad    33554432    {invalid}
#>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x51
# ------------------------------------------------------------------
0        string    \x51\x00\x00    LZMA compressed data, properties: 0x51,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5A
# ------------------------------------------------------------------
0        string    \x5A\x00\x00    LZMA compressed data, properties: 0x5A,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5B
# ------------------------------------------------------------------
0        string    \x5B\x00\x00    LZMA compressed data, properties: 0x5B,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5C
# ------------------------------------------------------------------
0        string    \x5C\x00\x00    LZMA compressed data, properties: 0x5C,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5D
# ------------------------------------------------------------------
0        string    \x5D\x00\x00    LZMA compressed data, properties: 0x5D,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x5E
# ------------------------------------------------------------------
0        string    \x5E\x00\x00    LZMA compressed data, properties: 0x5E,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x63
# ------------------------------------------------------------------
0        string    \x63\x00\x00    LZMA compressed data, properties: 0x63,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x64
# ------------------------------------------------------------------
0        string    \x64\x00\x00    LZMA compressed data, properties: 0x64,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x65
# ------------------------------------------------------------------
0        string    \x65\x00\x00    LZMA compressed data, properties: 0x65,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x66
# ------------------------------------------------------------------
0        string    \x66\x00\x00    LZMA compressed data, properties: 0x66,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6C
# ------------------------------------------------------------------
0        string    \x6C\x00\x00    LZMA compressed data, properties: 0x6C,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6D
# ------------------------------------------------------------------
0        string    \x6D\x00\x00    LZMA compressed data, properties: 0x6D,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x6E
# ------------------------------------------------------------------
0        string    \x6E\x00\x00    LZMA compressed data, properties: 0x6E,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x75
# ------------------------------------------------------------------
0        string    \x75\x00\x00    LZMA compressed data, properties: 0x75,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x76
# ------------------------------------------------------------------
0        string    \x76\x00\x00    LZMA compressed data, properties: 0x76,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x7E
# ------------------------------------------------------------------
0        string    \x7E\x00\x00    LZMA compressed data, properties: 0x7E,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x87
# ------------------------------------------------------------------
0        string    \x87\x00\x00    LZMA compressed data, properties: 0x87,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x88
# ------------------------------------------------------------------
0        string    \x88\x00\x00    LZMA compressed data, properties: 0x88,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x89
# ------------------------------------------------------------------
0        string    \x89\x00\x00    LZMA compressed data, properties: 0x89,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x8A
# ------------------------------------------------------------------
0        string    \x8A\x00\x00    LZMA compressed data, properties: 0x8A,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x8B
# ------------------------------------------------------------------
0        string    \x8B\x00\x00    LZMA compressed data, properties: 0x8B,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x90
# ------------------------------------------------------------------
0        string    \x90\x00\x00    LZMA compressed data, properties: 0x90,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x91
# ------------------------------------------------------------------
0        string    \x91\x00\x00    LZMA compressed data, properties: 0x91,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x92
# ------------------------------------------------------------------
0        string    \x92\x00\x00    LZMA compressed data, properties: 0x92,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x93
# ------------------------------------------------------------------
0        string    \x93\x00\x00    LZMA compressed data, properties: 0x93,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x99
# ------------------------------------------------------------------
0        string    \x99\x00\x00    LZMA compressed data, properties: 0x99,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x9A
# ------------------------------------------------------------------
0        string    \x9A\x00\x00    LZMA compressed data, properties: 0x9A,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0x9B
# ------------------------------------------------------------------
0        string    \x9B\x00\x00    LZMA compressed data, properties: 0x9B,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xA2
# ------------------------------------------------------------------
0        string    \xA2\x00\x00    LZMA compressed data, properties: 0xA2,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xA3
# ------------------------------------------------------------------
0        string    \xA3\x00\x00    LZMA compressed data, properties: 0xA3,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xAB
# ------------------------------------------------------------------
0        string    \xAB\x00\x00    LZMA compressed data, properties: 0xAB,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB4
# ------------------------------------------------------------------
0        string    \xB4\x00\x00    LZMA compressed data, properties: 0xB4,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB5
# ------------------------------------------------------------------
0        string    \xB5\x00\x00    LZMA compressed data, properties: 0xB5,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB6
# ------------------------------------------------------------------
0        string    \xB6\x00\x00    LZMA compressed data, properties: 0xB6,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB7
# ------------------------------------------------------------------
0        string    \xB7\x00\x00    LZMA compressed data, properties: 0xB7,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xB8
# ------------------------------------------------------------------
0        string    \xB8\x00\x00    LZMA compressed data, properties: 0xB8,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBD
# ------------------------------------------------------------------
0        string    \xBD\x00\x00    LZMA compressed data, properties: 0xBD,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBE
# ------------------------------------------------------------------
0        string    \xBE\x00\x00    LZMA compressed data, properties: 0xBE,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xBF
# ------------------------------------------------------------------
0        string    \xBF\x00\x00    LZMA compressed data, properties: 0xBF,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC0
# ------------------------------------------------------------------
0        string    \xC0\x00\x00    LZMA compressed data, properties: 0xC0,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC6
# ------------------------------------------------------------------
0        string    \xC6\x00\x00    LZMA compressed data, properties: 0xC6,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC7
# ------------------------------------------------------------------
0        string    \xC7\x00\x00    LZMA compressed data, properties: 0xC7,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xC8
# ------------------------------------------------------------------
0        string    \xC8\x00\x00    LZMA compressed data, properties: 0xC8,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xCF
# ------------------------------------------------------------------
0        string    \xCF\x00\x00    LZMA compressed data, properties: 0xCF,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xD0
# ------------------------------------------------------------------
0        string    \xD0\x00\x00    LZMA compressed data, properties: 0xD0,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


# ------------------------------------------------------------------
# Signature for LZMA compressed data with valid properties byte 0xD8
# ------------------------------------------------------------------
0        string    \xD8\x00\x00    LZMA compressed data, properties: 0xD8,

# These are all the valid dictionary sizes supported by LZMA utils.
>1        lelong    !65536    
>>1        lelong    !131072    
>>>1        lelong    !262144    
>>>>1        lelong    !524288    
>>>>>1        lelong    !1048576    
>>>>>>1        lelong    !2097152    
>>>>>>>1    lelong    !4194304    
>>>>>>>>1    lelong    !8388608    
>>>>>>>>>1    lelong    !16777216    
>>>>>>>>>>1    lelong    !33554432    {invalid}
>1        lelong    x        dictionary size: %d bytes,

# Assume that a valid size will be greater than 32 bytes and less than 1GB (a value of -1 IS valid).
# This could technically be valid, but is unlikely.
>5        lequad    !-1
>>5        lequad    <32        {invalid}
>>5        lequad    >0x40000000    {invalid}

# These are not 100%. The uncompressed size could be exactly the same as the dicionary size, but it is unlikely.
# Since most false positives are the result of repeating sequences of bytes (such as executable instructions),
# marking matches with the same uncompressed and dictionary sizes as {invalid} eliminates much of these false positives.
>1        lelong    65536
>>5        lequad    65536        {invalid}
>1        lelong    131072
>>5        lequad    131072        {invalid}
>1        lelong    262144
>>5        lequad    262144        {invalid}
>1        lelong    524288
>>5        lequad    524288        {invalid}
>1        lelong    1048576
>>5        lequad    1048576        {invalid}
>1        lelong    2097152
>>5        lequad    2097152        {invalid}
>1        lelong    4194304
>>5        lequad    4194304        {invalid}
>1        lelong    8388608
>>5        lequad    8388608        {invalid}
>1        lelong    16777216
>>5        lequad    16777216    {invalid}
>1        lelong    33554432
>>5        lequad    33554432    {invalid}
>5        lequad    x        uncompressed size: %lld bytes


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/misc`:

```
#------------------------------------------------------------------------------
# $File: pdf,v 1.6 2009/09/19 16:28:11 christos Exp $
# pdf:  file(1) magic for Portable Document Format
#
0       string  %PDF-       PDF document,
>6      byte    !0x2e       {invalid}
>5      string  x           version: "%3s"

#------------------------------------------------------------------------------
# $File: zyxel,v 1.6 2009/09/19 16:28:13 christos Exp $
# zyxel:  file(1) magic for ZyXEL modems
#
# From <rob@pe1chl.ampr.org>
# These are the /etc/magic entries to decode datafiles as used for the
# ZyXEL U-1496E DATA/FAX/VOICE modems.  (This header conforms to a
# ZyXEL-defined standard)

0       string          ZyXEL\002       ZyXEL voice data
>10     byte            0               \b, CELP encoding
>10     byte&0x0B       1               \b, ADPCM2 encoding
>10     byte&0x0B       2               \b, ADPCM3 encoding
>10     byte&0x0B       3               \b, ADPCM4 encoding
>10     byte&0x0B       8               \b, New ADPCM3 encoding
>10     byte&0x04       4               \b,with resync

0       string          LinuxGuestRecord        Xen saved domain file

0       string      \x3chtml        HTML document header
>5      byte        !0x20
>>5     byte        !0x3e           {invalid}
0       string      \x3cHTML        HTML document header
>5      byte        !0x20
>>5     byte        !0x3e           {invalid}

0    string        \x3c/html\x3e        HTML document footer
0    string        \x3c/HTML\x3e        HTML document footer

0    string        \x3c?xml\x20version      XML document,
>15  string        x                        version: "%.3s"

# CodeGate 2011 http://nopsrus.blogspot.com/2013/05/codegate-ctf-2011-binary-100-points.html
0    string    \x23\x40\x7e\x5e    Windows Script Encoded Data (screnc.exe)

0   regex   /[a-zA-Z0-9\.\-_]{1,25}/[a-zA-Z0-9\.\-_]{1,25}/[a-zA-Z0-9\.\-_]{1,25}/[a-zA-Z0-9\.\-_/].*       Unix path:
>0  string  x                                                                                               %s

0   string      neighbor           Neighborly text,
>0  string      x                  "%s
>63 string      x                  \b%s"

0   string      Neighbor           Neighborly text,
>0  string      x                  "%s
>63 string      x                  \b%s"

0   string      neighborly         Neighborly text, best guess: Goodspeed, 
>0  string      x                  "%s
>63 string      x                  \b%s"

0   string      begin\x20           uuencoded data,
>9  byte        !0x20               {invalid}invalid format,
>6  byte        <0x30               {invalid}invalid permissions,
>6  byte        >0x39               {invalid}invalid permissions,
>7  byte        <0x30               {invalid}invalid permissions,
>7  byte        >0x39               {invalid}invalid permissions,
>8  byte        <0x30               {invalid}invalid permissions,
>8  byte        >0x39               {invalid}invalid permissions,
>10 string      x                   file name: "%s",
>6  string      x                   file permissions: "%.3s"


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/network`:

```
#
# "pcap-ng" capture files.
# http://www.winpcap.org/ntar/draft/PCAP-DumpFileFormat.html
# Pcap-ng files can contain multiple sections. Printing the endianness,
# snaplen, or other information from the first SHB may be misleading.
#
0       string          \x0a\x0d\x0d\x0a\x1a\x2b\x3c\x4d    Pcap-ng capture file, big-endian,
>12     beshort         x                                   version %d
>14     beshort         x                                   \b.%d

0       string          \x0a\x0d\x0d\x0a\x4d\x3c\x2b\x1a    Pcap-ng capture file, little-endian,
>12     leshort         x                                   version %d
>14     leshort         x                                   \b.%d

#
# "libpcap" capture files.
#
0       string          \xa1\xb2\xc3\xd4\x00        Libpcap capture file, big-endian,
>4      beshort         >2                          {invalid}
>4      beshort         x                           version %d
>6      beshort         x                           \b.%d,
>20     belong          0                           (No link-layer encapsulation
>20     belong          1                           (Ethernet
>20     belong          2                           (3Mb Ethernet
>20     belong          3                           (AX.25
>20     belong          4                           (ProNET
>20     belong          5                           (CHAOS
>20     belong          6                           (Token Ring
>20     belong          7                           (BSD ARCNET
>20     belong          8                           (SLIP
>20     belong          9                           (PPP
>20     belong          10                          (FDDI
>20     belong          11                          (RFC 1483 ATM
>20     belong          12                          (raw IP
>20     belong          13                          (BSD/OS SLIP
>20     belong          14                          (BSD/OS PPP
>20     belong          19                          (Linux ATM Classical IP
>20     belong          50                          (PPP or Cisco HDLC
>20     belong          51                          (PPP-over-Ethernet
>20     belong          99                          (Symantec Enterprise Firewall
>20     belong          100                         (RFC 1483 ATM
>20     belong          101                         (raw IP
>20     belong          102                         (BSD/OS SLIP
>20     belong          103                         (BSD/OS PPP
>20     belong          104                         (BSD/OS Cisco HDLC
>20     belong          105                         (802.11
>20     belong          106                         (Linux Classical IP over ATM
>20     belong          107                         (Frame Relay
>20     belong          108                         (OpenBSD loopback
>20     belong          109                         (OpenBSD IPsec encrypted
>20     belong          112                         (Cisco HDLC
>20     belong          113                         (Linux "cooked"
>20     belong          114                         (LocalTalk
>20     belong          117                         (OpenBSD PFLOG
>20     belong          119                         (802.11 with Prism header
>20     belong          122                         (RFC 2625 IP over Fibre Channel
>20     belong          123                         (SunATM
>20     belong          127                         (802.11 with radiotap header
>20     belong          129                         (Linux ARCNET
>20     belong          138                         (Apple IP over IEEE 1394
>20     belong          140                         (MTP2
>20     belong          141                         (MTP3
>20     belong          143                         (DOCSIS
>20     belong          144                         (IrDA
>20     belong          147                         (Private use 0
>20     belong          148                         (Private use 1
>20     belong          149                         (Private use 2
>20     belong          150                         (Private use 3
>20     belong          151                         (Private use 4
>20     belong          152                         (Private use 5
>20     belong          153                         (Private use 6
>20     belong          154                         (Private use 7
>20     belong          155                         (Private use 8
>20     belong          156                         (Private use 9
>20     belong          157                         (Private use 10
>20     belong          158                         (Private use 11
>20     belong          159                         (Private use 12
>20     belong          160                         (Private use 13
>20     belong          161                         (Private use 14
>20     belong          162                         (Private use 15
>20     belong          163                         (802.11 with AVS header
>20     belong          >163                        {invalid}(invalid link layer
>20     belong          <0                          {invalid}(invalid link layer
>16     belong          x                           \b, snaplen: %d)

0       lelong          0xa1b2c3d4      Libpcap capture file, little-endian,
>4      leshort         >2              {invalid}
>4      leshort         <0              {invalid}
>4      leshort         x               version %d
>6      leshort         x               \b.%d,
>20     lelong          0               (No link-layer encapsulation
>20     lelong          1               (Ethernet
>20     lelong          2               (3Mb Ethernet
>20     lelong          3               (AX.25
>20     lelong          4               (ProNET
>20     lelong          5               (CHAOS
>20     lelong          6               (Token Ring
>20     lelong          7               (ARCNET
>20     lelong          8               (SLIP
>20     lelong          9               (PPP
>20     lelong          10              (FDDI
>20     lelong          11              (RFC 1483 ATM
>20     lelong          12              (raw IP
>20     lelong          13              (BSD/OS SLIP
>20     lelong          14              (BSD/OS PPP
>20     lelong          19              (Linux ATM Classical IP
>20     lelong          50              (PPP or Cisco HDLC
>20     lelong          51              (PPP-over-Ethernet
>20     lelong          99              (Symantec Enterprise Firewall
>20     lelong          100             (RFC 1483 ATM
>20     lelong          101             (raw IP
>20     lelong          102             (BSD/OS SLIP
>20     lelong          103             (BSD/OS PPP
>20     lelong          104             (BSD/OS Cisco HDLC
>20     lelong          105             (802.11
>20     lelong          106             (Linux Classical IP over ATM
>20     lelong          107             (Frame Relay
>20     lelong          108             (OpenBSD loopback
>20     lelong          109             (OpenBSD IPsec encrypted
>20     lelong          112             (Cisco HDLC
>20     lelong          113             (Linux "cooked"
>20     lelong          114             (LocalTalk
>20     lelong          117             (OpenBSD PFLOG
>20     lelong          119             (802.11 with Prism header
>20     lelong          122             (RFC 2625 IP over Fibre Channel
>20     lelong          123             (SunATM
>20     lelong          127             (802.11 with radiotap header
>20     lelong          129             (Linux ARCNET
>20     lelong          138             (Apple IP over IEEE 1394
>20     lelong          140             (MTP2
>20     lelong          141             (MTP3
>20     lelong          143             (DOCSIS
>20     lelong          144             (IrDA
>20     lelong          147             (Private use 0
>20     lelong          148             (Private use 1
>20     lelong          149             (Private use 2
>20     lelong          150             (Private use 3
>20     lelong          151             (Private use 4
>20     lelong          152             (Private use 5
>20     lelong          153             (Private use 6
>20     lelong          154             (Private use 7
>20     lelong          155             (Private use 8
>20     lelong          156             (Private use 9
>20     lelong          157             (Private use 10
>20     lelong          158             (Private use 11
>20     lelong          159             (Private use 12
>20     lelong          160             (Private use 13
>20     lelong          161             (Private use 14
>20     lelong          162             (Private use 15
>20     lelong          163             (802.11 with AVS header
>20     lelong          >163            {invalid}(invalid link layer
>20     lelong          <0              {invalid}(invalid link layer
>16     lelong          x               \b, snaplen: %d)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/sql`:

```
#------------------------------------------------------------------------------
# $File: sql,v 1.6 2009/09/19 16:28:12 christos Exp $
# sql:  file(1) magic for SQL files
#
# From: "Marty Leisner" <mleisner@eng.mc.xerox.com>
# Recognize some MySQL files.
#
0       beshort     0xfe01          MySQL table definition file
>2      ubyte       <1              {invalid}
>2      ubyte       >11             {invalid}
>2      byte        x               Version %d
0       string      \xfe\xfe\x03    MySQL MISAM index file
>3      ubyte       <1              {invalid}
>3      ubyte       >11             {invalid}
>3      byte        x               Version %d
0       string      \xfe\xfe\x07    MySQL MISAM compressed data file
>3      ubyte       <1              {invalid}
>3      ubyte       >11             {invalid}
>3      byte        x               Version %d
0       string      \xfe\xfe\x05    MySQL ISAM index file
>3      ubyte       <1              {invalid}
>3      ubyte       >11             {invalid}
>3      byte        x               Version %d
0       string      \xfe\xfe\x06    MySQL ISAM compressed data file
>3      ubyte       <1              {invalid}
>3      ubyte       >11             {invalid}
>3      byte        x               Version %d
#0       string                  \376bin         MySQL replication log

#------------------------------------------------------------------------------
# iRiver H Series database file 
# From Ken Guest <ken@linux.ie>
# As observed from iRivNavi.iDB and unencoded firmware
#
0       string  iRivDB  iRiver Database file
>11     byte    !0
>>11    string  x       Version "%s"
#>39  string             iHP-100 [H Series]

#------------------------------------------------------------------------------
# SQLite database files
# Ken Guest <ken@linux.ie>, Ty Sarna, Zack Weinberg
#
# Version 1 used GDBM internally; its files cannot be distinguished
# from other GDBM files.
#
# Version 2 used this format:
0       string  \x2A\x2A\x20This\x20file\x20contains\x20an\x20SQLite  SQLite 2.x database

# Version 3 of SQLite allows applications to embed their own "user version"
# number in the database.  Detect this and distinguish those files.

0   string      SQLite\x20format\x203   SQLite 3.x database,
>60 string      _MTN                    monotone source repository
>60 ubelong     !0                      \b, user version %u


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/magic/vxworks`:

```

# Signatures to identify the start of a VxWorks symbol table
# The jump is necessary to ensure that we don't accidentally
# report a big endian symbol table followed immediately by a
# little endian symbol table. We only want to show the beginning
# of the symbol table, so use the once keyword too.
8       string      \x00\x00\x05                        VxWorks symbol table, big endian,{overlap}{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00               {invalid}
>4      belong      0                                   {invalid} 
>4      ubelong     x                                   first entry: [type: function, code address: 0x%X,
>0      belong      0                                   {invalid}
>0      ubelong     x                                   symbol address: 0x%X]
>24     belong      !0x500
>>24    belong      !0x700
>>>24   belong      !0x900                              \b, {invalid}
>40     belong      !0x500
>>40    belong      !0x700
>>>40   belong      !0x900                              \b, {invalid}
>56     belong      !0x500
>>56    belong      !0x700
>>>56   belong      !0x900                              \b, {invalid}
>72     belong      !0x500
>>72    belong      !0x700
>>>72   belong      !0x900                              \b, {invalid}
>88     belong      !0x500
>>88    belong      !0x700
>>>88   belong      !0x900                              \b, {invalid}
>104    belong      !0x500
>>104   belong      !0x700
>>>104  belong      !0x900                              \b, {invalid}
>120    belong      !0x500
>>120   belong      !0x700
>>>120  belong      !0x900                              \b, {invalid}
>136    belong      !0x500
>>136   belong      !0x700
>>>136  belong      !0x900                              \b, {invalid}
>152    belong      !0x500
>>152   belong      !0x700
>>>152  belong      !0x900                              \b, {invalid}

8       string      \x00\x00\x07                        VxWorks symbol table, big endian,{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00               {invalid}
>4      belong      0                                   {invalid}
>4      ubelong     x                                   first entry: [type: initialized data, code address: 0x%X,
>0      belong      0                                   {invalid}
>0      ubelong     x                                   symbol address: 0x%X]
>24     belong      !0x500
>>24    belong      !0x700
>>>24   belong      !0x900                              \b, {invalid}
>40     belong      !0x500
>>40    belong      !0x700
>>>40   belong      !0x900                              \b, {invalid}
>56     belong      !0x500
>>56    belong      !0x700
>>>56   belong      !0x900                              \b, {invalid}
>72     belong      !0x500
>>72    belong      !0x700
>>>72   belong      !0x900                              \b, {invalid}
>88     belong      !0x500
>>88    belong      !0x700
>>>88   belong      !0x900                              \b, {invalid}
>104    belong      !0x500
>>104   belong      !0x700
>>>104  belong      !0x900                              \b, {invalid}
>120    belong      !0x500
>>120   belong      !0x700
>>>120  belong      !0x900                              \b, {invalid}
>136    belong      !0x500
>>136   belong      !0x700
>>>136  belong      !0x900                              \b, {invalid}
>152    belong      !0x500
>>152   belong      !0x700
>>>152  belong      !0x900                              \b, {invalid}

8       string      \x00\x00\x09                        VxWorks symbol table, big endian,{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00               {invalid}
>4      belong      0                                   {invalid}
>4      ubelong     x                                   first entry: [type: uninitialized data, code address: 0x%X,
>0      belong      0                                   {invalid}
>0      ubelong     x                                   symbol address: 0x%X]
>24     belong      !0x500
>>24    belong      !0x700
>>>24   belong      !0x900                              \b, {invalid}
>40     belong      !0x500
>>40    belong      !0x700
>>>40   belong      !0x900                              \b, {invalid}
>56     belong      !0x500
>>56    belong      !0x700
>>>56   belong      !0x900                              \b, {invalid}
>72     belong      !0x500
>>72    belong      !0x700
>>>72   belong      !0x900                              \b, {invalid}
>88     belong      !0x500
>>88    belong      !0x700
>>>88   belong      !0x900                              \b, {invalid}
>104    belong      !0x500
>>104   belong      !0x700
>>>104  belong      !0x900                              \b, {invalid}
>120    belong      !0x500
>>120   belong      !0x700
>>>120  belong      !0x900                              \b, {invalid}
>136    belong      !0x500
>>136   belong      !0x700
>>>136  belong      !0x900                              \b, {invalid}
>152    belong      !0x500
>>152   belong      !0x700
>>>152  belong      !0x900                              \b, {invalid}

8       string      \x00\x05                            VxWorks symbol table, little endian,{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00\x00           {invalid}
>4      lelong      0                                   {invalid}
>4      ulelong     x                                   first entry: [type: function, code address: 0x%X,
>0      lelong      0                                   {invalid}
>0      ulelong     x                                   symbol address: 0x%X]
>24     lelong      !0x500
>>24    lelong      !0x700
>>>24   lelong      !0x900                              \b, {invalid}
>40     lelong      !0x500
>>40    lelong      !0x700
>>>40   lelong      !0x900                              \b, {invalid}
>56     lelong      !0x500
>>56    lelong      !0x700
>>>56   lelong      !0x900                              \b, {invalid}
>72     lelong      !0x500
>>72    lelong      !0x700
>>>72   lelong      !0x900                              \b, {invalid}
>88     lelong      !0x500
>>88    lelong      !0x700
>>>88   lelong      !0x900                              \b, {invalid}
>104    lelong      !0x500
>>104   lelong      !0x700
>>>104  lelong      !0x900                              \b, {invalid}
>120    lelong      !0x500
>>120   lelong      !0x700
>>>120  lelong      !0x900                              \b, {invalid}
>136    lelong      !0x500
>>136   lelong      !0x700
>>>136  lelong      !0x900                              \b, {invalid}
>152    lelong      !0x500
>>152   lelong      !0x700
>>>152  lelong      !0x900                              \b, {invalid}

8       string      \x00\x07                            VxWorks symbol table, little endian,{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00\x00           {invalid}
>4      lelong      0                                   {invalid}
>4      ulelong     x                                   first entry: [type: initialized data, code address: 0x%X,
>0      lelong      0                                   {invalid}
>0      ulelong     x                                   symbol address: 0x%X]
>24     lelong      !0x500
>>24    lelong      !0x700
>>>24   lelong      !0x900                              \b, {invalid}
>40     lelong      !0x500
>>40    lelong      !0x700
>>>40   lelong      !0x900                              \b, {invalid}
>56     lelong      !0x500
>>56    lelong      !0x700
>>>56   lelong      !0x900                              \b, {invalid}
>72     lelong      !0x500
>>72    lelong      !0x700
>>>72   lelong      !0x900                              \b, {invalid}
>88     lelong      !0x500
>>88    lelong      !0x700
>>>88   lelong      !0x900                              \b, {invalid}
>104    lelong      !0x500
>>104   lelong      !0x700
>>>104  lelong      !0x900                              \b, {invalid}
>120    lelong      !0x500
>>120   lelong      !0x700
>>>120  lelong      !0x900                              \b, {invalid}
>136    lelong      !0x500
>>136   lelong      !0x700
>>>136  lelong      !0x900                              \b, {invalid}
>152    lelong      !0x500
>>152   lelong      !0x700
>>>152  lelong      !0x900                              \b, {invalid}

8       string      \x00\x09                            VxWorks symbol table, little endian,{once}{jump:156}
>11     string      !\x00\x00\x00\x00\x00\x00           {invalid}
>4      lelong      0                                   {invalid}
>4      ulelong     x                                   first entry: [type: uninitialized data, code address: 0x%X,
>0      lelong      0                                   {invalid}
>0      ulelong     x                                   symbol address: 0x%X]
>24     lelong      !0x500
>>24    lelong      !0x700
>>>24   lelong      !0x900                              \b, {invalid}
>40     lelong      !0x500
>>40    lelong      !0x700
>>>40   lelong      !0x900                              \b, {invalid}
>56     lelong      !0x500
>>56    lelong      !0x700
>>>56   lelong      !0x900                              \b, {invalid}
>72     lelong      !0x500
>>72    lelong      !0x700
>>>72   lelong      !0x900                              \b, {invalid}
>88     lelong      !0x500
>>88    lelong      !0x700
>>>88   lelong      !0x900                              \b, {invalid}
>104    lelong      !0x500
>>104   lelong      !0x700
>>>104  lelong      !0x900                              \b, {invalid}
>120    lelong      !0x500
>>120   lelong      !0x700
>>>120  lelong      !0x900                              \b, {invalid}
>136    lelong      !0x500
>>136   lelong      !0x700
>>>136  lelong      !0x900                              \b, {invalid}
>152    lelong      !0x500
>>152   lelong      !0x700
>>>152  lelong      !0x900                              \b, {invalid}

0       string      WIND\x20version\x20     VxWorks WIND kernel version
>13     byte        0                       {invalid}
>13     byte        !0
>>13    string      x                       "%s"

0       string      VxWorks\00              VxWorks operating system version
>8      byte        0                       {invalid}
>8      byte        !0
>>8     string      x                       "%s"
>16     string      !VxWorks                {invalid}
>32     byte        !0
>>32    string      x                       , compiled: "%s"

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/__init__.py`:

```py
# Don't load the disasm module if the capstone module can't be found
try:
    from binwalk.modules.disasm import Disasm
except ImportError:
    pass

# Don't load the compression module if the lzma module can't be found
try:
    from binwalk.modules.compression import RawCompression
except ImportError:
    pass

from binwalk.modules.signature import Signature
from binwalk.modules.hexdiff import HexDiff
from binwalk.modules.general import General
from binwalk.modules.extractor import Extractor
from binwalk.modules.entropy import Entropy

# These are depreciated.
#from binwalk.modules.binvis import Plotter
#from binwalk.modules.hashmatch import HashMatch
#from binwalk.modules.heuristics import HeuristicCompressionAnalyzer

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/binvis.py`:

```py
# Generates 3D visualizations of input files.

import os
from binwalk.core.compat import *
from binwalk.core.common import BlockFile
from binwalk.core.module import Module, Option, Kwarg

class Plotter(Module):
    '''
    Base class for visualizing binaries in Qt.
    Other plotter classes are derived from this.
    '''
    VIEW_DISTANCE = 1024
    MAX_2D_PLOT_POINTS = 12500
    MAX_3D_PLOT_POINTS = 25000

    TITLE = "Binary Visualization"

    CLI = [
            Option(short='3',
                   long='3D',
                   kwargs={'axis' : 3, 'enabled' : True},
                   description='Generate a 3D binary visualization'),
            Option(short='2',
                   long='2D',
                   kwargs={'axis' : 2, 'enabled' : True},
                   description='Project data points onto 3D cube walls only'),
            Option(short='Z',
                   long='points',
                   type=int,
                   kwargs={'max_points' : 0},
                   description='Set the maximum number of plotted data points'),
#            Option(short='V',
#                   long='grids',
#                   kwargs={'show_grids' : True},
#                   description='Display the x-y-z grids in the resulting plot'),
    ]

    KWARGS = [
            Kwarg(name='axis', default=3),
            Kwarg(name='max_points', default=0),
            Kwarg(name='show_grids', default=False),
            Kwarg(name='enabled', default=False),
    ]

    # There isn't really any useful data to print to console. Disable header and result output.
    HEADER = None
    RESULT = None

    def init(self):
        import pyqtgraph.opengl as gl
        from pyqtgraph.Qt import QtGui

        self.verbose = self.config.verbose
        self.offset = self.config.offset
        self.length = self.config.length
        self.plane_count = -1
        self.plot_points = None

        if self.axis == 2:
            self.MAX_PLOT_POINTS = self.MAX_2D_PLOT_POINTS
            self._generate_data_point = self._generate_2d_data_point
        elif self.axis == 3:
            self.MAX_PLOT_POINTS = self.MAX_3D_PLOT_POINTS
            self._generate_data_point = self._generate_3d_data_point
        else:
            raise Exception("Invalid Plotter axis specified: %d. Must be one of: [2,3]" % self.axis)

        if not self.max_points:
            self.max_points = self.MAX_PLOT_POINTS

        self.app = QtGui.QApplication([])
        self.window = gl.GLViewWidget()
        self.window.opts['distance'] = self.VIEW_DISTANCE

        if len(self.config.target_files) == 1:
            self.window.setWindowTitle(self.config.target_files[0])

    def _print(self, message):
        '''
        Print console messages. For internal use only.
        '''
        if self.verbose:
            print(message)

    def _generate_plot_points(self, data_points):
        '''
        Generates plot points from a list of data points.

        @data_points - A dictionary containing each unique point and its frequency of occurance.

        Returns a set of plot points.
        '''
        total = 0
        min_weight = 0
        weightings = {}
        plot_points = {}

        # If the number of data points exceeds the maximum number of allowed data points, use a
        # weighting system to eliminate data points that occur less freqently.
        if sum(data_points.values()) > self.max_points:

            # First, generate a set of weight values 1 - 10
            for i in range(1, 11):
                weightings[i] = 0

            # Go through every data point and how many times that point occurs
            for (point, count) in iterator(data_points):
                # For each data point, compare it to each remaining weight value
                for w in get_keys(weightings):

                    # If the number of times this data point occurred is >= the weight value,
                    # then increment the weight value. Since weight values are ordered lowest
                    # to highest, this means that more frequent data points also increment lower
                    # weight values. Thus, the more high-frequency data points there are, the
                    # more lower-frequency data points are eliminated.
                    if count >= w:
                        weightings[w] += 1
                    else:
                        break

                    # Throw out weight values that exceed the maximum number of data points
                    if weightings[w] > self.max_points:
                        del weightings[w]

                # If there's only one weight value left, no sense in continuing the loop...
                if len(weightings) == 1:
                    break

            # The least weighted value is our minimum weight
            min_weight = min(weightings)

            # Get rid of all data points that occur less frequently than our minimum weight
            for point in get_keys(data_points):
                if data_points[point] < min_weight:
                    del data_points[point]

        for point in sorted(data_points, key=data_points.get, reverse=True):
            plot_points[point] = data_points[point]
            # Register this as a result in case future modules need access to the raw point information,
            # but mark plot as False to prevent the entropy module from attempting to overlay this data on its graph.
            self.result(point=point, plot=False)
            total += 1
            if total >= self.max_points:
                break

        return plot_points

    def _generate_data_point(self, data):
        '''
        Subclasses must override this to return the appropriate data point.

        @data - A string of data self.axis in length.

        Returns a data point tuple.
        '''
        return (0,0,0)

    def _generate_data_points(self, fp):
        '''
        Generates a dictionary of data points and their frequency of occurrance.

        @fp - The BlockFile object to generate data points from.

        Returns a dictionary.
        '''
        i = 0
        data_points = {}

        self._print("Generating data points for %s" % fp.name)

        # We don't need any extra data from BlockFile
        fp.set_block_size(peek=0)

        while True:
            (data, dlen) = fp.read_block()
            if not data or not dlen:
                break

            i = 0
            while (i+(self.axis-1)) < dlen:
                point = self._generate_data_point(data[i:i+self.axis])
                if has_key(data_points, point):
                    data_points[point] += 1
                else:
                    data_points[point] = 1
                i += 3

        return data_points

    def _generate_plot(self, plot_points):
        import numpy as np
        import pyqtgraph.opengl as gl

        nitems = float(len(plot_points))

        pos = np.empty((nitems, 3))
        size = np.empty((nitems))
        color = np.empty((nitems, 4))

        i = 0
        for (point, weight) in iterator(plot_points):
            r = 0.0
            g = 0.0
            b = 0.0

            pos[i] = point
            frequency_percentage = (weight / nitems)

            # Give points that occur more frequently a brighter color and larger point size.
            # Frequency is determined as a percentage of total unique data points.
            if frequency_percentage > .010:
                size[i] = .20
                r = 1.0
            elif frequency_percentage > .005:
                size[i] = .15
                b = 1.0
            elif frequency_percentage > .002:
                size[i] = .10
                g = 1.0
                r = 1.0
            else:
                size[i] = .05
                g = 1.0

            color[i] = (r, g, b, 1.0)

            i += 1

        scatter_plot = gl.GLScatterPlotItem(pos=pos, size=size, color=color, pxMode=False)
        scatter_plot.translate(-127.5, -127.5, -127.5)

        return scatter_plot

    def plot(self, wait=True):
        import pyqtgraph.opengl as gl

        self.window.show()

        if self.show_grids:
            xgrid = gl.GLGridItem()
            ygrid = gl.GLGridItem()
            zgrid = gl.GLGridItem()

            self.window.addItem(xgrid)
            self.window.addItem(ygrid)
            self.window.addItem(zgrid)

            # Rotate x and y grids to face the correct direction
            xgrid.rotate(90, 0, 1, 0)
            ygrid.rotate(90, 1, 0, 0)

            # Scale grids to the appropriate dimensions
            xgrid.scale(12.8, 12.8, 12.8)
            ygrid.scale(12.8, 12.8, 12.8)
            zgrid.scale(12.8, 12.8, 12.8)

        for fd in iter(self.next_file, None):
            data_points = self._generate_data_points(fd)

            self._print("Generating plot points from %d data points" % len(data_points))

            self.plot_points = self._generate_plot_points(data_points)
            del data_points

            self._print("Generating graph from %d plot points" % len(self.plot_points))

            self.window.addItem(self._generate_plot(self.plot_points))

        if wait:
            self.wait()

    def wait(self):
        from pyqtgraph.Qt import QtCore, QtGui

        t = QtCore.QTimer()
        t.start(50)
        QtGui.QApplication.instance().exec_()

    def _generate_3d_data_point(self, data):
        '''
        Plot data points within a 3D cube.
        '''
        return (ord(data[0]), ord(data[1]), ord(data[2]))

    def _generate_2d_data_point(self, data):
        '''
        Plot data points projected on each cube face.
        '''
        self.plane_count += 1
        if self.plane_count > 5:
            self.plane_count = 0

        if self.plane_count == 0:
            return (0, ord(data[0]), ord(data[1]))
        elif self.plane_count == 1:
            return (ord(data[0]), 0, ord(data[1]))
        elif self.plane_count == 2:
            return (ord(data[0]), ord(data[1]), 0)
        elif self.plane_count == 3:
            return (255, ord(data[0]), ord(data[1]))
        elif self.plane_count == 4:
            return (ord(data[0]), 255, ord(data[1]))
        elif self.plane_count == 5:
            return (ord(data[0]), ord(data[1]), 255)

    def run(self):
        self.plot()
        return True


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/compression.py`:

```py
# Performs raw decompression of various compression algorithms (currently, only deflate).

import os
import zlib
import lzma
import struct
import binwalk.core.compat
import binwalk.core.common
from binwalk.core.module import Option, Kwarg, Module

class LZMAHeader(object):
    def __init__(self, **kwargs):
        for (k,v) in binwalk.core.compat.iterator(kwargs):
            setattr(self, k, v)

class LZMA(object):

    DESCRIPTION = "Raw LZMA compression stream"
    COMMON_PROPERTIES = [0x5D, 0x6E]
    MAX_PROP = ((4 * 5 + 4) * 9 + 8)
    BLOCK_SIZE = 32*1024

    def __init__(self, module):
        self.module = module
        self.properties = None

        self.build_properties()
        self.build_dictionaries()
        self.build_headers()

        # Add an extraction rule
        if self.module.extractor.enabled:
            self.module.extractor.add_rule(regex='^%s' % self.DESCRIPTION.lower(), extension="7z", cmd=self.extractor)

    def extractor(self, file_name):
        # Open and read the file containing the raw compressed data.
        # This is not terribly efficient, especially for large files...
        compressed_data = binwalk.core.common.BlockFile(file_name).read()

        # Re-run self.decompress to detect the properties for this compressed data (stored in self.properties)
        if self.decompress(compressed_data[:self.BLOCK_SIZE]):
            # Build an LZMA header on top of the raw compressed data and write it back to disk.
            # Header consists of the detected properties values, the largest possible dictionary size,
            # and a fake output file size field.
            header = chr(self.properties) + self.dictionaries[-1] + ("\xFF" * 8)
            binwalk.core.common.BlockFile(file_name, "wb").write(header + compressed_data)

            # Try to extract it with all the normal lzma extractors until one works
            for exrule in self.module.extractor.match("lzma compressed data"):
                if self.module.extractor.execute(exrule['cmd'], file_name) == True:
                    break

    def build_property(self, pb, lp, lc):
        prop = (((pb * 5) + lp) * 9) + lc
        if prop > self.MAX_PROP:
            return None
        return int(prop)

    def parse_property(self, prop):
        prop = int(ord(prop))

        if prop > self.MAX_PROP:
            return None

        pb = prop / (9 * 5);
        prop -= pb * 9 * 5;
        lp = prop / 9;
        lc = prop - lp * 9;

        return (pb, lp, lc)

    def parse_header(self, header):
        (pb, lp, lc) = self.parse_property(header[0])
        dictionary = struct.unpack("<I", binwalk.core.compat.str2bytes(header[1:5]))[0]
        return LZMAHeader(pb=pb, lp=lp, lc=lc, dictionary=dictionary)

    def build_properties(self):
        self.properties = set()

        if self.module.partial_scan == True:
            # For partial scans, only check the most common properties values
            for prop in self.COMMON_PROPERTIES:
                self.properties.add(chr(prop))
        else:
            for pb in range(0, 9):
                for lp in range(0, 5):
                    for lc in range(0, 5):
                        prop = self.build_property(pb, lp, lc)
                        if prop is not None:
                            self.properties.add(chr(prop))

    def build_dictionaries(self):
        self.dictionaries = []

        if self.module.partial_scan == True:
            # For partial scans, only use the largest dictionary value
            self.dictionaries.append(binwalk.core.compat.bytes2str(struct.pack("<I", 2**25)))
        else:
            for n in range(16, 26):
                self.dictionaries.append(binwalk.core.compat.bytes2str(struct.pack("<I", 2**n)))

    def build_headers(self):
        self.headers = set()

        for prop in self.properties:
            for dictionary in self.dictionaries:
                self.headers.add(prop + dictionary + ("\xFF" * 8))

    def decompress(self, data):
        result = None
        description = None
        i = 0

        for header in self.headers:
            i += 1
            # The only acceptable exceptions are those indicating that the input data was truncated.
            try:
                final_data = binwalk.core.compat.str2bytes(header + data)
                lzma.decompress(final_data)
                result = self.parse_header(header)
                break
            except IOError as e:
                # The Python2 module gives this error on truncated input data.
                if str(e) == "unknown BUF error":
                    result = self.parse_header(header)
                    break
            except Exception as e:
                # The Python3 module gives this error on truncated input data.
                # The inconsistency between modules is a bit worrisome.
                if str(e) == "Compressed data ended before the end-of-stream marker was reached":
                    result = self.parse_header(header)
                    break

        if result is not None:
            self.properties = self.build_property(result.pb, result.lp, result.lc)
            description = "%s, properties: 0x%.2X [pb: %d, lp: %d, lc: %d], dictionary size: %d" % (self.DESCRIPTION,
                                                                                                   self.properties,
                                                                                                   result.pb,
                                                                                                   result.lp,
                                                                                                   result.lc,
                                                                                                   result.dictionary)

        return description

class Deflate(object):
    '''
    Finds and extracts raw deflate compression streams.
    '''

    ENABLED = False
    BLOCK_SIZE = 33*1024
    DESCRIPTION = "Raw deflate compression stream"

    def __init__(self, module):
        self.module = module

        # Add an extraction rule
        if self.module.extractor.enabled:
            self.module.extractor.add_rule(regex='^%s' % self.DESCRIPTION.lower(), extension="deflate", cmd=self.extractor)

    def extractor(self, file_name):
        in_data = ""
        out_data = ""
        retval = False
        out_file = os.path.splitext(file_name)[0]

        with binwalk.core.common.BlockFile(file_name, 'r') as fp_in:
            while True:
                (data, dlen) = fp_in.read_block()
                if not data or dlen == 0:
                    break
                else:
                    in_data += data

                try:
                    out_data = zlib.decompress(binwalk.core.compat.str2bytes(in_data), -15)
                    with binwalk.core.common.BlockFile(out_file, 'w') as fp_out:
                        fp_out.write(out_data)
                    retval = True
                    break
                except zlib.error as e:
                    pass

        return retval

    def decompress(self, data):
        valid = True
        description = None

        # Looking for either a valid decompression, or an error indicating truncated input data
        try:
            # Negative window size (e.g., -15) indicates that raw decompression should be performed
            zlib.decompress(binwalk.core.compat.str2bytes(data), -15)
        except zlib.error as e:
            if not str(e).startswith("Error -5"):
                # Bad data.
                return None

        return self.DESCRIPTION

class RawCompression(Module):

    TITLE = 'Raw Compression'

    CLI = [
            Option(short='X',
                   long='deflate',
                   kwargs={'enabled' : True, 'scan_for_deflate' : True},
                   description='Scan for raw deflate compression streams'),
            Option(short='Z',
                   long='lzma',
                   kwargs={'enabled' : True, 'scan_for_lzma' : True},
                   description='Scan for raw LZMA compression streams'),
            Option(short='P',
                   long='partial',
                   kwargs={'partial_scan' : True},
                   description='Perform a superficial, but faster, scan'),
            Option(short='S',
                   long='stop',
                   kwargs={'stop_on_first_hit' : True},
                   description='Stop after the first result'),
    ]

    KWARGS = [
            Kwarg(name='enabled', default=False),
            Kwarg(name='partial_scan', default=False),
            Kwarg(name='stop_on_first_hit', default=False),
            Kwarg(name='scan_for_deflate', default=False),
            Kwarg(name='scan_for_lzma', default=False),
    ]

    def init(self):
        self.decompressors = []

        if self.scan_for_deflate:
            self.decompressors.append(Deflate(self))
        if self.scan_for_lzma:
            self.decompressors.append(LZMA(self))

    def run(self):
        for fp in iter(self.next_file, None):

            file_done = False

            self.header()

            while not file_done:
                (data, dlen) = fp.read_block()
                if not data:
                    break

                for i in range(0, dlen):
                    for decompressor in self.decompressors:
                        description = decompressor.decompress(data[i:i+decompressor.BLOCK_SIZE])
                        if description:
                            self.result(description=description, file=fp, offset=fp.tell()-dlen+i)
                            if self.stop_on_first_hit:
                                file_done = True
                                break

                    if file_done:
                        break

                    self.status.completed += 1

                self.status.completed = fp.tell() - fp.offset

            self.footer()


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/disasm.py`:

```py
import capstone
import binwalk.core.common
import binwalk.core.compat
from binwalk.core.module import Module, Option, Kwarg

class ArchResult(object):
    def __init__(self, **kwargs):
        for (k,v) in binwalk.core.compat.iterator(kwargs):
            setattr(self, k, v)

class Architecture(object):
    def __init__(self, **kwargs):
        for (k, v) in binwalk.core.compat.iterator(kwargs):
            setattr(self, k, v)

class Disasm(Module):

    THRESHOLD = 10
    DEFAULT_MIN_INSN_COUNT = 500

    TITLE = "Disassembly Scan"
    ORDER = 10

    CLI = [
            Option(short='Y',
                   long='disasm',
                   kwargs={'enabled' : True},
                   description='Identify the CPU architecture of a file using the capstone disassembler'),
            Option(short='T',
                   long='minsn',
                   type=int,
                   kwargs={'min_insn_count' : 0},
                   description='Minimum number of consecutive instructions to be considered valid (default: %d)' % DEFAULT_MIN_INSN_COUNT),
            Option(long='continue',
                   short='k',
                   kwargs={'keep_going' : True},
                   description="Don't stop at the first match"),
          ]

    KWARGS = [
                Kwarg(name='enabled', default=False),
                Kwarg(name='keep_going', default=False),
                Kwarg(name='min_insn_count', default=DEFAULT_MIN_INSN_COUNT),
             ]

    ARCHITECTURES = [
                    Architecture(type=capstone.CS_ARCH_ARM,
                                 mode=capstone.CS_MODE_ARM,
                                 endianess=capstone.CS_MODE_BIG_ENDIAN,
                                 description="ARM executable code, 32-bit, big endian"),
                    Architecture(type=capstone.CS_ARCH_ARM,
                                 mode=capstone.CS_MODE_ARM,
                                 endianess=capstone.CS_MODE_LITTLE_ENDIAN,
                                 description="ARM executable code, 32-bit, little endian"),
                    Architecture(type=capstone.CS_ARCH_ARM64,
                                 mode=capstone.CS_MODE_ARM,
                                 endianess=capstone.CS_MODE_BIG_ENDIAN,
                                 description="ARM executable code, 64-bit, big endian"),
                    Architecture(type=capstone.CS_ARCH_ARM64,
                                 mode=capstone.CS_MODE_ARM,
                                 endianess=capstone.CS_MODE_LITTLE_ENDIAN,
                                 description="ARM executable code, 64-bit, little endian"),

                    Architecture(type=capstone.CS_ARCH_PPC,
                                 mode=capstone.CS_MODE_BIG_ENDIAN,
                                 endianess=capstone.CS_MODE_BIG_ENDIAN,
                                 description="PPC executable code, 32/64-bit, big endian"),

                    Architecture(type=capstone.CS_ARCH_MIPS,
                                 mode=capstone.CS_MODE_64,
                                 endianess=capstone.CS_MODE_BIG_ENDIAN,
                                 description="MIPS executable code, 32/64-bit, big endian"),
                    Architecture(type=capstone.CS_ARCH_MIPS,
                                 mode=capstone.CS_MODE_64,
                                 endianess=capstone.CS_MODE_LITTLE_ENDIAN,
                                 description="MIPS executable code, 32/64-bit, little endian"),

                    Architecture(type=capstone.CS_ARCH_ARM,
                                 mode=capstone.CS_MODE_THUMB,
                                 endianess=capstone.CS_MODE_LITTLE_ENDIAN,
                                 description="ARM executable code, 16-bit (Thumb), little endian"),
                    Architecture(type=capstone.CS_ARCH_ARM,
                                 mode=capstone.CS_MODE_THUMB,
                                 endianess=capstone.CS_MODE_BIG_ENDIAN,
                                 description="ARM executable code, 16-bit (Thumb), big endian"),
                    ]

    def init(self):
        self.disassemblers = []

        if not self.min_insn_count:
            self.min_insn_count = self.DEFAULT_MIN_INSN_COUNT

        self.disasm_data_size = self.min_insn_count * 10

        for arch in self.ARCHITECTURES:
            self.disassemblers.append((capstone.Cs(arch.type, (arch.mode + arch.endianess)), arch.description))

    def scan_file(self, fp):
        total_read = 0

        while True:
            result = None

            (data, dlen) = fp.read_block()
            if not data:
                break

            # If this data block doesn't contain at least two different bytes, skip it
            # to prevent false positives (e.g., "\x00\x00\x00\x00" is a nop in MIPS).
            if len(set(data)) >= 2:
                block_offset = 0

                # Loop through the entire block, or until we're pretty sure we've found some valid code in this block
                while (block_offset < dlen) and (result is None or result.count < self.THRESHOLD):
                    # Don't pass the entire data block into disasm_lite, it's horribly inefficient
                    # to pass large strings around in Python. Break it up into smaller code blocks instead.
                    code_block = binwalk.core.compat.str2bytes(data[block_offset:block_offset+self.disasm_data_size])

                    # If this code block doesn't contain at least two different bytes, skip it
                    # to prevent false positives (e.g., "\x00\x00\x00\x00" is a nop in MIPS).
                    if len(set(code_block)) >= 2:
                        for (md, description) in self.disassemblers:
                            insns = [insn for insn in md.disasm_lite(code_block, (total_read+block_offset))]
                            binwalk.core.common.debug("0x%.8X   %s, at least %d valid instructions" % ((total_read+block_offset),
                                                                                                        description,
                                                                                                        len(insns)))

                            # Did we disassemble at least self.min_insn_count instructions?
                            if len(insns) >= self.min_insn_count:
                                # If we've already found the same type of code in this block, simply update the result counter
                                if result and result.description == description:
                                    result.count += 1
                                    if result.count >= self.THRESHOLD:
                                        break
                                else:
                                    result = ArchResult(offset=total_read+block_offset+fp.offset,
                                                        description=description,
                                                        insns=insns,
                                                        count=1)

                    block_offset += 1
                    self.status.completed += 1

                if result is not None:
                    r = self.result(offset=result.offset,
                                    file=fp,
                                    description=(result.description + ", at least %d valid instructions" % len(result.insns)))

                    if r.valid and r.display:
                        if self.config.verbose:
                            for (position, size, mnem, opnds) in result.insns:
                                self.result(offset=position, file=fp, description="%s %s" % (mnem, opnds))
                        if not self.keep_going:
                            return

            total_read += dlen
            self.status.completed = total_read

    def run(self):
        for fp in iter(self.next_file, None):
            self.header()
            self.scan_file(fp)
            self.footer()


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/entropy.py`:

```py
# Calculates and optionally plots the entropy of input files.

import os
import math
import zlib
import binwalk.core.common
from binwalk.core.compat import *
from binwalk.core.module import Module, Option, Kwarg

class Entropy(Module):

    XLABEL = 'Offset'
    YLABEL = 'Entropy'

    XUNITS = 'B'
    YUNITS = 'E'

    FILE_WIDTH = 1024
    FILE_FORMAT = 'png'

    COLORS = ['r', 'g', 'c', 'b', 'm']

    DEFAULT_BLOCK_SIZE = 1024
    DEFAULT_DATA_POINTS = 2048

    DEFAULT_TRIGGER_HIGH = .95
    DEFAULT_TRIGGER_LOW = .85

    TITLE = "Entropy Analysis"
    ORDER = 8

    # TODO: Add --dpoints option to set the number of data points?
    CLI = [
            Option(short='E',
                   long='entropy',
                   kwargs={'enabled' : True},
                   description='Calculate file entropy'),
            Option(short='F',
                   long='fast',
                   kwargs={'use_zlib' : True},
                   description='Use faster, but less detailed, entropy analysis'),
            Option(short='J',
                   long='save',
                   kwargs={'save_plot' : True},
                   description='Save plot as a PNG'),
            Option(short='Q',
                   long='nlegend',
                   kwargs={'show_legend' : False},
                   description='Omit the legend from the entropy plot graph'),
            Option(short='N',
                   long='nplot',
                   kwargs={'do_plot' : False},
                   description='Do not generate an entropy plot graph'),
            Option(short='H',
                   long='high',
                   type=float,
                   kwargs={'trigger_high' : DEFAULT_TRIGGER_HIGH},
                   description='Set the rising edge entropy trigger threshold (default: %.2f)' % DEFAULT_TRIGGER_HIGH),
            Option(short='L',
                   long='low',
                   type=float,
                   kwargs={'trigger_low' : DEFAULT_TRIGGER_LOW},
                   description='Set the falling edge entropy trigger threshold (default: %.2f)' % DEFAULT_TRIGGER_LOW),
    ]

    KWARGS = [
            Kwarg(name='enabled', default=False),
            Kwarg(name='save_plot', default=False),
            Kwarg(name='trigger_high', default=DEFAULT_TRIGGER_HIGH),
            Kwarg(name='trigger_low', default=DEFAULT_TRIGGER_LOW),
            Kwarg(name='use_zlib', default=False),
            Kwarg(name='display_results', default=True),
            Kwarg(name='do_plot', default=True),
            Kwarg(name='show_legend', default=True),
            Kwarg(name='block_size', default=0),
    ]

    # Run this module last so that it can process all other module's results and overlay them on the entropy graph
    PRIORITY = 0

    def init(self):
        self.HEADER[-1] = "ENTROPY"
        self.max_description_length = 0
        self.file_markers = {}

        if self.use_zlib:
            self.algorithm = self.gzip
        else:
            self.algorithm = self.shannon

        # Get a list of all other module's results to mark on the entropy graph
        for (module, obj) in iterator(self.modules):
            for result in obj.results:
                if result.plot and result.file and result.description:
                    description = result.description.split(',')[0]

                    if not has_key(self.file_markers, result.file.name):
                        self.file_markers[result.file.name] = []

                    if len(description) > self.max_description_length:
                        self.max_description_length = len(description)

                    self.file_markers[result.file.name].append((result.offset, description))

        # If other modules have been run and they produced results, don't spam the terminal with entropy results
        if self.file_markers:
            self.display_results = False

        if not self.block_size:
            if self.config.block:
                self.block_size = self.config.block
            else:
                self.block_size = None

    def _entropy_sigterm_handler(self, *args):
        print ("FUck it all.")

    def run(self):
        # If generating a graphical plot, this function will never return, as it invokes
        # pg.exit. Calling pg.exit is pretty much required, but pg.exit calls os._exit in
        # order to work around QT cleanup issues.
        self._run()

    def _run(self):
        # Sanity check and warning if pyqtgraph isn't found
        if self.do_plot:
            try:
                import pyqtgraph as pg
            except ImportError as e:
                binwalk.core.common.warning("Failed to import pyqtgraph module, visual entropy graphing will be disabled")
                self.do_plot = False

        for fp in iter(self.next_file, None):

            if self.display_results:
                self.header()

            self.calculate_file_entropy(fp)

            if self.display_results:
                self.footer()

        if self.do_plot:
            if not self.save_plot:
                from pyqtgraph.Qt import QtGui
                QtGui.QApplication.instance().exec_()
            pg.exit()

    def calculate_file_entropy(self, fp):
        # Tracks the last displayed rising/falling edge (0 for falling, 1 for rising, None if nothing has been printed yet)
        last_edge = None
        # Auto-reset the trigger; if True, an entropy above/below self.trigger_high/self.trigger_low will be printed
        trigger_reset = True

        # Clear results from any previously analyzed files
        self.clear(results=True)

        # If -K was not specified, calculate the block size to create DEFAULT_DATA_POINTS data points
        if self.block_size is None:
            block_size = fp.size / self.DEFAULT_DATA_POINTS
            # Round up to the nearest DEFAULT_BLOCK_SIZE (1024)
            block_size = int(block_size + ((self.DEFAULT_BLOCK_SIZE - block_size) % self.DEFAULT_BLOCK_SIZE))
        else:
            block_size = self.block_size

        # Make sure block size is greater than 0
        if block_size <= 0:
            block_size = self.DEFAULT_BLOCK_SIZE

        binwalk.core.common.debug("Entropy block size (%d data points): %d" % (self.DEFAULT_DATA_POINTS, block_size))

        while True:
            file_offset = fp.tell()

            (data, dlen) = fp.read_block()
            if not data:
                break

            i = 0
            while i < dlen:
                entropy = self.algorithm(data[i:i+block_size])
                display = self.display_results
                description = "%f" % entropy

                if not self.config.verbose:
                    if last_edge in [None, 0] and entropy > self.trigger_low:
                        trigger_reset = True
                    elif last_edge in [None, 1] and entropy < self.trigger_high:
                        trigger_reset = True

                    if trigger_reset and entropy >= self.trigger_high:
                        description = "Rising entropy edge (%f)" % entropy
                        display = self.display_results
                        last_edge = 1
                        trigger_reset = False
                    elif trigger_reset and entropy <= self.trigger_low:
                        description = "Falling entropy edge (%f)" % entropy
                        display = self.display_results
                        last_edge = 0
                        trigger_reset = False
                    else:
                        display = False
                        description = "%f" % entropy

                r = self.result(offset=(file_offset + i),
                                file=fp,
                                entropy=entropy,
                                description=description,
                                display=display)

                i += block_size

        if self.do_plot:
            self.plot_entropy(fp.name)

    def shannon(self, data):
        '''
        Performs a Shannon entropy analysis on a given block of data.
        '''
        entropy = 0

        if data:
            length = len(data)

            seen = dict(((chr(x), 0) for x in range(0, 256)))
            for byte in data:
                seen[byte] += 1

            for x in range(0, 256):
                p_x = float(seen[chr(x)]) / length
                if p_x > 0:
                    entropy -= p_x * math.log(p_x, 2)

        return (entropy / 8)

    def gzip(self, data, truncate=True):
        '''
        Performs an entropy analysis based on zlib compression ratio.
        This is faster than the shannon entropy analysis, but not as accurate.
        '''
        # Entropy is a simple ratio of: <zlib compressed size> / <original size>
        e = float(float(len(zlib.compress(str2bytes(data), 9))) / float(len(data)))

        if truncate and e > 1.0:
            e = 1.0

        return e

    def plot_entropy(self, fname):
        try:
            import numpy as np
            import pyqtgraph as pg
            import pyqtgraph.exporters as exporters
        except ImportError as e:
            return

        i = 0
        x = []
        y = []
        plotted_colors = {}

        for r in self.results:
            x.append(r.offset)
            y.append(r.entropy)

        plt = pg.plot(title=fname, clear=True)

        # Disable auto-ranging of the Y (entropy) axis, as it
        # can cause some very un-intuitive graphs, particularly
        #for files with only high-entropy data.
        plt.setYRange(0, 1)

        if self.show_legend and has_key(self.file_markers, fname):
            plt.addLegend(size=(self.max_description_length*10, 0))

            for (offset, description) in self.file_markers[fname]:
                # If this description has already been plotted at a different offset, we need to
                # use the same color for the marker, but set the description to None to prevent
                # duplicate entries in the graph legend.
                #
                # Else, get the next color and use it to mark descriptions of this type.
                if has_key(plotted_colors, description):
                    color = plotted_colors[description]
                    description = None
                else:
                    color = self.COLORS[i]
                    plotted_colors[description] = color

                    i += 1
                    if i >= len(self.COLORS):
                        i = 0

                plt.plot(x=[offset,offset], y=[0,1.1], name=description, pen=pg.mkPen(color, width=2.5))

        # Plot data points
        plt.plot(x, y, pen='y')

        # TODO: legend is not displayed properly when saving plots to disk
        if self.save_plot:
            # Save graph to CWD
            out_file = os.path.join(os.getcwd(), os.path.basename(fname))

            # exporters.ImageExporter is different in different versions of pyqtgraph
            try:
                exporter = exporters.ImageExporter(plt.plotItem)
            except TypeError:
                exporter = exporters.ImageExporter.ImageExporter(plt.plotItem)
            exporter.parameters()['width'] = self.FILE_WIDTH
            exporter.export(binwalk.core.common.unique_file_name(out_file, self.FILE_FORMAT))
        else:
            plt.setLabel('left', self.YLABEL, units=self.YUNITS)
            plt.setLabel('bottom', self.XLABEL, units=self.XUNITS)


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/extractor.py`:

```py
# Performs extraction of data that matches extraction rules.
# This is automatically invoked by core.module code if extraction has been
# enabled by the user; other modules need not reference this module directly.

import os
import re
import sys
import stat
import shlex
import tempfile
import subprocess
import binwalk.core.common
from binwalk.core.compat import *
from binwalk.core.module import Module, Option, Kwarg
from binwalk.core.common import file_size, file_md5, unique_file_name, BlockFile

class ExtractInfo(object):
    def __init__(self):
        self.carved = {}
        self.extracted = {}
        self.directory = None

class Extractor(Module):
    '''
    Extractor class, responsible for extracting files from the target file and executing external applications, if requested.
    '''
    # Extract rules are delimited with a colon.
    # <case insensitive matching string>:<file extension>[:<command to run>]
    RULE_DELIM = ':'

    # Comments in the extract.conf files start with a pound
    COMMENT_DELIM ='#'

    # Place holder for the extracted file name in the command
    FILE_NAME_PLACEHOLDER = '%e'

    # Unique path delimiter, used for generating unique output file/directory names.
    # Useful when, for example, extracting two squashfs images (squashfs-root, squashfs-root-0).
    UNIQUE_PATH_DELIMITER = '%%'

    TITLE = 'Extraction'
    ORDER = 9
    PRIMARY = False

    CLI = [
            Option(short='e',
                   long='extract',
                   kwargs={'load_default_rules' : True, 'enabled' : True},
                   description='Automatically extract known file types'),
            Option(short='D',
                   long='dd',
                   type=list,
                   dtype='type:ext:cmd',
                   kwargs={'manual_rules' : [], 'enabled' : True},
                   description='Extract <type> signatures, give the files an extension of <ext>, and execute <cmd>'),
            Option(short='M',
                   long='matryoshka',
                   kwargs={'matryoshka' : 8},
                   description='Recursively scan extracted files'),
            Option(short='d',
                   long='depth',
                   type=int,
                   kwargs={'matryoshka' : 0},
                   description='Limit matryoshka recursion depth (default: 8 levels deep)'),
            Option(short='C',
                   long='directory',
                   type=str,
                   kwargs={'base_directory' : 0},
                   description='Extract files/folders to a custom directory (default: current working directory)'),
            Option(short='j',
                   long='size',
                   type=int,
                   kwargs={'max_size' : 0},
                   description='Limit the size of each extracted file'),
            Option(short='n',
                   long='count',
                   type=int,
                   kwargs={'max_count' : 0},
                   description='Limit the number of extracted files'),
            Option(short='r',
                   long='rm',
                   kwargs={'remove_after_execute' : True},
                   description='Delete carved files after extraction'),
            Option(short='z',
                   long='carve',
                   kwargs={'run_extractors' : False},
                   description="Carve data from files, but don't execute extraction utilities"),
    ]

    KWARGS = [
            Kwarg(name='max_size', default=None),
            Kwarg(name='max_count', default=None),
            Kwarg(name='base_directory', default=None),
            Kwarg(name='remove_after_execute', default=False),
            Kwarg(name='load_default_rules', default=False),
            Kwarg(name='run_extractors', default=True),
            Kwarg(name='manual_rules', default=[]),
            Kwarg(name='matryoshka', default=0),
            Kwarg(name='enabled', default=False),
    ]

    def load(self):
        # Holds a list of extraction rules loaded either from a file or when manually specified.
        self.extract_rules = []
        # The input file specific output directory path (to be determined at runtime)
        self.directory = None
        # Key value pairs of input file path and output extraction path
        self.output = {}
        # Number of extracted files
        self.extraction_count = 0

        if self.load_default_rules:
            self.load_defaults()

        for manual_rule in self.manual_rules:
            self.add_rule(manual_rule)

        if self.matryoshka:
            self.config.verbose = True

    def add_pending(self, f):
        # Ignore symlinks
        if os.path.islink(f):
            return

        # Get the file mode to check and see if it's a block/char device
        try:
            file_mode = os.stat(f).st_mode
        except OSError as e:
            return

        # Only add this to the pending list of files to scan
        # if the file is a regular file or a block/character device.
        if (stat.S_ISREG(file_mode) or
            stat.S_ISBLK(file_mode) or
            stat.S_ISCHR(file_mode)):
            self.pending.append(f)

    def reset(self):
        # Holds a list of pending files that should be scanned; only populated if self.matryoshka == True
        self.pending = []
        # Holds a dictionary of extraction directories created for each scanned file.
        self.extraction_directories = {}
        # Holds a dictionary of the last directory listing for a given directory; used for identifying
        # newly created/extracted files that need to be appended to self.pending.
        self.last_directory_listing = {}

    def callback(self, r):
        # Make sure the file attribute is set to a compatible instance of binwalk.core.common.BlockFile
        try:
            r.file.size
        except KeyboardInterrupt as e:
            pass
        except Exception as e:
            return

        if not r.size:
            size = r.file.size - r.offset
        else:
            size = r.size

        # Only extract valid results that have been marked for extraction and displayed to the user.
        # Note that r.display is still True even if --quiet has been specified; it is False if the result has been
        # explicitly excluded via the -y/-x options.
        if r.valid and r.extract and r.display and (not self.max_count or self.extraction_count < self.max_count):
            # Create some extract output for this file, it it doesn't already exist
            if not binwalk.core.common.has_key(self.output, r.file.path):
                self.output[r.file.path] = ExtractInfo()

            # Attempt extraction
            binwalk.core.common.debug("Extractor callback for %s @%d [%s]" % (r.file.name, r.offset, r.description))
            (extraction_directory, dd_file, scan_extracted_files) = self.extract(r.offset, r.description, r.file.path, size, r.name)

            # If the extraction was successful, self.extract will have returned the output directory and name of the dd'd file
            if extraction_directory and dd_file:
                # Track the number of extracted files
                self.extraction_count += 1

                # Get the full path to the dd'd file and save it in the output info for this file
                dd_file_path = os.path.join(extraction_directory, dd_file)
                self.output[r.file.path].carved[r.offset] = dd_file_path
                self.output[r.file.path].extracted[r.offset] = []

                # Do a directory listing of the output directory
                directory_listing = set(os.listdir(extraction_directory))

                # If this is a newly created output directory, self.last_directory_listing won't have a record of it.
                # If we've extracted other files to this directory before, it will.
                if not has_key(self.last_directory_listing, extraction_directory):
                    self.last_directory_listing[extraction_directory] = set()

                # Loop through a list of newly created files (i.e., files that weren't listed in the last directory listing)
                for f in directory_listing.difference(self.last_directory_listing[extraction_directory]):
                    # Build the full file path and add it to the extractor results
                    file_path = os.path.join(extraction_directory, f)
                    real_file_path = os.path.realpath(file_path)
                    self.result(description=file_path, display=False)

                    # Also keep a list of files created by the extraction utility
                    if real_file_path != dd_file_path:
                        self.output[r.file.path].extracted[r.offset].append(real_file_path)

                    # If recursion was specified, and the file is not the same one we just dd'd
                    if (self.matryoshka and
                        file_path != dd_file_path and
                        scan_extracted_files and
                        self.directory in real_file_path):
                        # If the recursion level of this file is less than or equal to our desired recursion level
                        if len(real_file_path.split(self.directory)[1].split(os.path.sep)) <= self.matryoshka:
                            # If this is a directory and we are supposed to process directories for this extractor,
                            # then add all files under that directory to the list of pending files.
                            if os.path.isdir(file_path):
                                for root, dirs, files in os.walk(file_path):
                                    for f in files:
                                        full_path = os.path.join(root, f)
                                        self.add_pending(full_path)
                            # If it's just a file, it to the list of pending files
                            else:
                                self.add_pending(file_path)

                # Update the last directory listing for the next time we extract a file to this same output directory
                self.last_directory_listing[extraction_directory] = directory_listing

    def append_rule(self, r):
        self.extract_rules.append(r.copy())

    def add_rule(self, txtrule=None, regex=None, extension=None, cmd=None, codes=[0, None], recurse=True):
        '''
        Adds a set of rules to the extraction rule list.

        @txtrule   - Rule string, or list of rule strings, in the format <regular expression>:<file extension>[:<command to run>]
        @regex     - If rule string is not specified, this is the regular expression string to use.
        @extension - If rule string is not specified, this is the file extension to use.
        @cmd       - If rule string is not specified, this is the command to run.
                     Alternatively a callable object may be specified, which will be passed one argument: the path to the file to extract.
        @codes     - A list of valid return codes for the extractor.
        @recurse   - If False, extracted directories will not be recursed into when the matryoshka option is enabled.

        Returns None.
        '''
        rules = []
        match = False
        r = {
            'extension'     : '',
            'cmd'           : '',
            'regex'         : None,
            'codes'         : codes,
            'recurse'       : recurse,
        }

        # Process single explicitly specified rule
        if not txtrule and regex and extension:
            r['extension'] = extension
            r['regex'] = re.compile(regex)
            if cmd:
                r['cmd'] = cmd

            self.append_rule(r)
            return

        # Process rule string, or list of rule strings
        if not isinstance(txtrule, type([])):
            rules = [txtrule]
        else:
            rules = txtrule

        for rule in rules:
            r['cmd'] = ''
            r['extension'] = ''

            try:
                values = self._parse_rule(rule)
                match = values[0]
                r['regex'] = re.compile(values[0])
                r['extension'] = values[1]
                r['cmd'] = values[2]
                r['codes'] = values[3]
                r['recurse'] = values[4]
            except KeyboardInterrupt as e:
                raise e
            except Exception:
                pass

            # Verify that the match string was retrieved.
            if match:
                self.append_rule(r)

    def remove_rule(self, text):
        '''
        Remove all rules that match a specified text.

        @text - The text to match against.

        Returns the number of rules removed.
        '''
        rm = []

        for i in range(0, len(self.extract_rules)):
            if self.extract_rules[i]['regex'].match(text):
                rm.append(i)

        for i in rm:
            self.extract_rules.pop(i)

        return len(rm)

    def clear_rules(self):
        '''
        Deletes all extraction rules.

        Returns None.
        '''
        self.extract_rules = []

    def get_rules(self):
        '''
        Returns a list of all extraction rules.
        '''
        return self.extract_rules

    def load_from_file(self, fname):
        '''
        Loads extraction rules from the specified file.

        @fname - Path to the extraction rule file.

        Returns None.
        '''
        try:
            # Process each line from the extract file, ignoring comments
            with open(fname, 'r') as f:
                for rule in f.readlines():
                    self.add_rule(rule.split(self.COMMENT_DELIM, 1)[0])
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            raise Exception("Extractor.load_from_file failed to load file '%s': %s" % (fname, str(e)))

    def load_defaults(self):
        '''
        Loads default extraction rules from the user and system extract.conf files.

        Returns None.
        '''
        # Load the user extract file first to ensure its rules take precedence.
        extract_files = [
            self.config.settings.user.extract,
            self.config.settings.system.extract,
        ]

        for extract_file in extract_files:
            if extract_file:
                try:
                    self.load_from_file(extract_file)
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    if binwalk.core.common.DEBUG:
                        raise Exception("Extractor.load_defaults failed to load file '%s': %s" % (extract_file, str(e)))

    def build_output_directory(self, path):
        '''
        Set the output directory for extracted files.

        @path - The path to the file that data will be extracted from.

        Returns None.
        '''
        # If we have not already created an output directory for this target file, create one now
        if not has_key(self.extraction_directories, path):
            basedir = os.path.dirname(path)
            basename = os.path.basename(path)

            # Make sure we put the initial extracted file in the CWD
            if self.directory is None:
                if self.base_directory is None:
                    basedir = os.getcwd()
                else:
                    basedir = self.base_directory
                    if not os.path.exists(basedir):
                        os.mkdir(basedir)

            outdir = os.path.join(basedir, '_' + basename)
            output_directory = unique_file_name(outdir, extension='extracted')

            if not os.path.exists(output_directory):
                os.mkdir(output_directory)

            self.extraction_directories[path] = output_directory
        # Else, just use the already created directory
        else:
            output_directory = self.extraction_directories[path]

        # Set the initial base extraction directory for later determining the level of recusion
        if self.directory is None:
            self.directory = os.path.realpath(output_directory) + os.path.sep
            self.output[path].directory = self.directory

        return output_directory

    def cleanup_extracted_files(self, tf=None):
        '''
        Set the action to take after a file is extracted.

        @tf - If set to True, extracted files will be cleaned up after running a command against them.
              If set to False, extracted files will not be cleaned up after running a command against them.
              If set to None or not specified, the current setting will not be changed.

        Returns the current cleanup status (True/False).
        '''
        if tf is not None:
            self.remove_after_execute = tf

        return self.remove_after_execute

    def extract(self, offset, description, file_name, size, name=None):
        '''
        Extract an embedded file from the target file, if it matches an extract rule.
        Called automatically by Binwalk.scan().

        @offset      - Offset inside the target file to begin the extraction.
        @description - Description of the embedded file to extract, as returned by libmagic.
        @file_name   - Path to the target file.
        @size        - Number of bytes to extract.
        @name        - Name to save the file as.

        Returns the name of the extracted file (blank string if nothing was extracted).
        '''
        fname = ''
        original_dir = os.getcwd()
        rules = self.match(description)
        file_path = os.path.realpath(file_name)

        # No extraction rules for this file
        if not rules:
            return (None, None, False)
        else:
            binwalk.core.common.debug("Found %d matching extraction rules" % len(rules))

        output_directory = self.build_output_directory(file_name)

        # Extract to end of file if no size was specified
        if not size:
            size = file_size(file_path) - offset

        if os.path.isfile(file_path):
            os.chdir(output_directory)

            # Loop through each extraction rule until one succeeds
            for i in range(0, len(rules)):
                rule = rules[i]

                # Make sure we don't recurse into any extracted directories if instructed not to
                if rule['recurse'] in [True, False]:
                    recurse = rule['recurse']
                else:
                    recurse = True

                # Copy out the data to disk, if we haven't already
                fname = self._dd(file_path, offset, size, rule['extension'], output_file_name=name)

                # If there was a command specified for this rule, try to execute it.
                # If execution fails, the next rule will be attempted.
                if rule['cmd']:

                    # Note the hash of the original file; if --rm is specified and the
                    # extraction utility modifies the original file rather than creating
                    # a new one (AFAIK none currently do, but could happen in the future),
                    # we don't want to remove this file.
                    if self.remove_after_execute:
                        fname_md5 = file_md5(fname)

                    # Execute the specified command against the extracted file
                    if self.run_extractors:
                        extract_ok = self.execute(rule['cmd'], fname, rule['codes'])
                    else:
                        extract_ok = True

                    # Only clean up files if remove_after_execute was specified
                    if extract_ok == True and self.remove_after_execute:

                        # Remove the original file that we extracted,
                        # if it has not been modified by the extractor.
                        try:
                            if file_md5(fname) == fname_md5:
                                os.unlink(fname)
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            pass

                    # If the command executed OK, don't try any more rules
                    if extract_ok == True:
                        break
                    # Else, remove the extracted file if this isn't the last rule in the list.
                    # If it is the last rule, leave the file on disk for the user to examine.
                    elif i != (len(rules)-1):
                        try:
                            os.unlink(fname)
                        except KeyboardInterrupt as e:
                            raise e
                        except Exception as e:
                            pass

                # If there was no command to execute, just use the first rule
                else:
                    break

            os.chdir(original_dir)

        return (output_directory, fname, recurse)

    def _entry_offset(self, index, entries, description):
        '''
        Gets the offset of the first entry that matches the description.

        @index       - Index into the entries list to begin searching.
        @entries     - Dictionary of result entries.
        @description - Case insensitive description.

        Returns the offset, if a matching description is found.
        Returns -1 if a matching description is not found.
        '''
        description = description.lower()

        for (offset, infos) in entries[index:]:
            for info in infos:
                if info['description'].lower().startswith(description):
                    return offset
        return -1

    def match(self, description):
        '''
        Check to see if the provided description string matches an extract rule.
        Called internally by self.extract().

        @description - Description string to check.

        Returns the associated rule dictionary if a match is found.
        Returns None if no match is found.
        '''
        rules = []
        description = description.lower()

        for rule in self.extract_rules:
            if rule['regex'].search(description):
                rules.append(rule)
        return rules

    def _parse_rule(self, rule):
        '''
        Parses an extraction rule.

        @rule - Rule string.

        Returns an array of ['<case insensitive matching string>', '<file extension>', '<command to run>', '<comma separated return codes>', <recurse into extracted directories: True|False>].
        '''
        values = rule.strip().split(self.RULE_DELIM, 4)

        if len(values) >= 4:
            codes = values[3].split(',')
            for i in range(0, len(codes)):
                try:
                    codes[i] = int(codes[i], 0)
                except ValueError as e:
                    binwalk.core.common.warning("The specified return code '%s' for extractor '%s' is not a valid number!" % (codes[i], values[0]))
            values[3] = codes

        if len(values) >= 5:
            values[4] = (values[4].lower() == 'true')

        return values

    def _dd(self, file_name, offset, size, extension, output_file_name=None):
        '''
        Extracts a file embedded inside the target file.

        @file_name        - Path to the target file.
        @offset           - Offset inside the target file where the embedded file begins.
        @size             - Number of bytes to extract.
        @extension        - The file exension to assign to the extracted file on disk.
        @output_file_name - The requested name of the output file.

        Returns the extracted file name.
        '''
        total_size = 0
        # Default extracted file name is <displayed hex offset>.<extension>
        default_bname = "%X" % (offset + self.config.base)

        if self.max_size and size > self.max_size:
            size = self.max_size

        if not output_file_name or output_file_name is None:
            bname = default_bname
        else:
            # Strip the output file name of invalid/dangerous characters (like file paths)
            bname = os.path.basename(output_file_name)

        fname = unique_file_name(bname, extension)

        try:
            # If byte swapping is enabled, we need to start reading at a swap-size
            # aligned offset, then index in to the read data appropriately.
            if self.config.swap_size:
                adjust = offset % self.config.swap_size
            else:
                adjust = 0

            offset -= adjust

            # Open the target file and seek to the offset
            fdin = self.config.open_file(file_name)
            fdin.seek(offset)

            # Open the output file
            try:
                fdout = BlockFile(fname, 'w')
            except KeyboardInterrupt as e:
                raise e
            except Exception as e:
                # Fall back to the default name if the requested name fails
                fname = unique_file_name(default_bname, extension)
                fdout = BlockFile(fname, 'w')

            while total_size < size:
                (data, dlen) = fdin.read_block()
                if not data:
                    break
                else:
                    fdout.write(str2bytes(data[adjust:dlen]))
                    total_size += (dlen-adjust)
                    adjust = 0

            # Cleanup
            fdout.close()
            fdin.close()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            raise Exception("Extractor.dd failed to extract data from '%s' to '%s': %s" % (file_name, fname, str(e)))

        binwalk.core.common.debug("Carved data block 0x%X - 0x%X from '%s' to '%s'" % (offset, offset+size, file_name, fname))
        return fname

    def execute(self, cmd, fname, codes=[0, None]):
        '''
        Execute a command against the specified file.

        @cmd   - Command to execute.
        @fname - File to run command against.
        @codes - List of return codes indicating cmd success.

        Returns True on success, False on failure, or None if the external extraction utility could not be found.
        '''
        tmp = None
        rval = 0
        retval = True

        binwalk.core.common.debug("Running extractor '%s'" % str(cmd))

        try:
            if callable(cmd):
                try:
                    retval = cmd(fname)
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    binwalk.core.common.warning("Internal extractor '%s' failed with exception: '%s'" % (str(cmd), str(e)))
            elif cmd:
                # If not in debug mode, create a temporary file to redirect stdout and stderr to
                if not binwalk.core.common.DEBUG:
                    tmp = tempfile.TemporaryFile()

                # Execute.
                for command in cmd.split("&&"):

                    # Generate unique file paths for all paths in the current command that are surrounded by UNIQUE_PATH_DELIMITER
                    while self.UNIQUE_PATH_DELIMITER in command:
                        need_unique_path = command.split(self.UNIQUE_PATH_DELIMITER)[1].split(self.UNIQUE_PATH_DELIMITER)[0]
                        unique_path = binwalk.core.common.unique_file_name(need_unique_path)
                        command = command.replace(self.UNIQUE_PATH_DELIMITER + need_unique_path + self.UNIQUE_PATH_DELIMITER, unique_path)

                    # Replace all instances of FILE_NAME_PLACEHOLDER in the command with fname
                    command = command.strip().replace(self.FILE_NAME_PLACEHOLDER, fname)

                    binwalk.core.common.debug("subprocess.call(%s, stdout=%s, stderr=%s)" % (command, str(tmp), str(tmp)))
                    rval = subprocess.call(shlex.split(command), stdout=tmp, stderr=tmp)

                    if rval in codes:
                        retval = True
                    else:
                        retval = False

                    binwalk.core.common.debug('External extractor command "%s" completed with return code %d (success: %s)' % (cmd, rval, str(retval)))

                    # TODO: Should errors from all commands in a command string be checked? Currently we only support
                    #       specifying one set of error codes, so at the moment, this is not done; it is up to the
                    #       final command to return success or failure (which presumably it will if previous necessary
                    #       commands were not successful, but this is an assumption).
                    #if retval == False:
                    #    break

        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            binwalk.core.common.warning("Extractor.execute failed to run external extractor '%s': %s" % (str(cmd), str(e)))
            retval = None

        if tmp is not None:
            tmp.close()

        return retval



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/general.py`:

```py
# Module to process general user input options (scan length, starting offset, etc).

import io
import os
import re
import sys
import argparse
import binwalk.core.idb
import binwalk.core.common
import binwalk.core.display
import binwalk.core.settings
from binwalk.core.compat import *
from binwalk.core.module import Module, Option, Kwarg, show_help

class General(Module):

    TITLE = "General"
    ORDER = 0

    DEFAULT_DEPENDS = []

    CLI = [
        Option(long='length',
               short='l',
               type=int,
               kwargs={'length' : 0},
               description='Number of bytes to scan'),
        Option(long='offset',
               short='o',
               type=int,
               kwargs={'offset' : 0},
               description='Start scan at this file offset'),
        Option(long='base',
               short='O',
               type=int,
               kwargs={'base' : 0},
               description='Add a base address to all printed offsets'),
        Option(long='block',
               short='K',
               type=int,
               kwargs={'block' : 0},
               description='Set file block size'),
        Option(long='swap',
               short='g',
               type=int,
               kwargs={'swap_size' : 0},
               description='Reverse every n bytes before scanning'),
        Option(long='log',
               short='f',
               type=argparse.FileType,
               kwargs={'log_file' : None},
               description='Log results to file'),
        Option(long='csv',
               short='c',
               kwargs={'csv' : True},
               description='Log results to file in CSV format'),
        Option(long='term',
               short='t',
               kwargs={'format_to_terminal' : True},
               description='Format output to fit the terminal window'),
        Option(long='quiet',
               short='q',
               kwargs={'quiet' : True},
               description='Suppress output to stdout'),
        Option(long='verbose',
               short='v',
               kwargs={'verbose' : True},
               description='Enable verbose output'),
        Option(short='h',
               long='help',
               kwargs={'show_help' : True},
               description='Show help output'),
        Option(short='a',
               long='finclude',
               type=str,
               kwargs={'file_name_include_regex' : ""},
               description='Only scan files whose names match this regex'),
        Option(short='p',
               long='fexclude',
               type=str,
               kwargs={'file_name_exclude_regex' : ""},
               description='Do not scan files whose names match this regex'),
        Option(short='s',
               long='status',
               type=int,
               kwargs={'status_server_port' : 0},
               description='Enable the status server on the specified port'),
        Option(long=None,
               short=None,
               type=binwalk.core.common.BlockFile,
               kwargs={'files' : []}),

        # Hidden, API-only arguments
        Option(long="string",
               hidden=True,
               kwargs={'subclass' : binwalk.core.common.StringFile}),
    ]

    KWARGS = [
        Kwarg(name='length', default=0),
        Kwarg(name='offset', default=0),
        Kwarg(name='base', default=0),
        Kwarg(name='block', default=0),
        Kwarg(name='status_server_port', default=0),
        Kwarg(name='swap_size', default=0),
        Kwarg(name='log_file', default=None),
        Kwarg(name='csv', default=False),
        Kwarg(name='format_to_terminal', default=False),
        Kwarg(name='quiet', default=False),
        Kwarg(name='verbose', default=False),
        Kwarg(name='files', default=[]),
        Kwarg(name='show_help', default=False),
        Kwarg(name='keep_going', default=False),
        Kwarg(name='subclass', default=io.FileIO),
        Kwarg(name='file_name_include_regex', default=None),
        Kwarg(name='file_name_exclude_regex', default=None),
    ]

    PRIMARY = False

    def load(self):
        self.threads_active = False
        self.target_files = []

        # A special case for when we're loaded into IDA
        if self.subclass == io.FileIO and binwalk.core.idb.LOADED_IN_IDA:
            self.subclass = binwalk.core.idb.IDBFileIO

        # Order is important with these two methods
        self._open_target_files()
        self._set_verbosity()

        # Build file name filter regex rules
        if self.file_name_include_regex:
            self.file_name_include_regex = re.compile(self.file_name_include_regex)
        if self.file_name_exclude_regex:
            self.file_name_exclude_regex = re.compile(self.file_name_exclude_regex)

        self.settings = binwalk.core.settings.Settings()
        self.display = binwalk.core.display.Display(log=self.log_file,
                                                    csv=self.csv,
                                                    quiet=self.quiet,
                                                    verbose=self.verbose,
                                                    fit_to_screen=self.format_to_terminal)

        if self.show_help:
            show_help()
            if not binwalk.core.idb.LOADED_IN_IDA:
                sys.exit(0)

        if self.status_server_port > 0:
            self.parent.status_server(self.status_server_port)

    def reset(self):
        pass

    def _set_verbosity(self):
        '''
        Sets the appropriate verbosity.
        Must be called after self._test_target_files so that self.target_files is properly set.
        '''
        # If more than one target file was specified, enable verbose mode; else, there is
        # nothing in some outputs to indicate which scan corresponds to which file.
        if len(self.target_files) > 1 and not self.verbose:
            self.verbose = True

    def file_name_filter(self, fp):
        '''
        Checks to see if a file should be scanned based on file name include/exclude filters.
        Most useful for matryoshka scans where only certian files are desired.

        @fp - An instances of binwalk.common.BlockFile

        Returns True if the file should be scanned, False if not.
        '''
        if self.file_name_include_regex and not self.file_name_include_regex.search(fp.name):
            return False
        if self.file_name_exclude_regex and self.file_name_exclude_regex.search(fp.name):
            return False

        return True

    def open_file(self, fname, length=None, offset=None, swap=None, block=None, peek=None):
        '''
        Opens the specified file with all pertinent configuration settings.
        '''
        if length is None:
            length = self.length
        if offset is None:
            offset = self.offset
        if swap is None:
            swap = self.swap_size

        return binwalk.core.common.BlockFile(fname,
                                             subclass=self.subclass,
                                             length=length,
                                             offset=offset,
                                             swap=swap,
                                             block=block,
                                             peek=peek)

    def _open_target_files(self):
        '''
        Checks if the target files can be opened.
        Any files that cannot be opened are removed from the self.target_files list.
        '''
        # Validate the target files listed in target_files
        for tfile in self.files:
            # Ignore directories.
            if not self.subclass == io.FileIO or not os.path.isdir(tfile):
                # Make sure we can open the target files
                try:
                    fp = self.open_file(tfile)
                    fp.close()
                    self.target_files.append(tfile)
                except KeyboardInterrupt as e:
                    raise e
                except Exception as e:
                    self.error(description="Cannot open file : %s" % str(e))


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/hashmatch.py`:

```py
# Performs fuzzy hashing against files/directories.
# Unlike other scans, this doesn't produce any file offsets, so its results are not applicable to 
# some other scans, such as the entropy scan.
# Additionally, this module currently doesn't support certian general options (length, offset, swap, etc),
# as the libfuzzy C library is responsible for opening and scanning the specified files.

import os
import re
import ctypes
import fnmatch
import binwalk.core.C
import binwalk.core.common
from binwalk.core.compat import *
from binwalk.core.module import Module, Option, Kwarg

class HashResult(object):
    '''
    Class for storing libfuzzy hash results.
    For internal use only.
    '''

    def __init__(self, name, hash=None, strings=None):
        self.name = name
        self.hash = hash
        self.strings = strings

class HashMatch(Module):
    '''
    Class for fuzzy hash matching of files and directories.
    '''
    DEFAULT_CUTOFF = 0
    CONSERVATIVE_CUTOFF = 90

    TITLE = "Fuzzy Hash"

    CLI = [
        Option(short='F',
               long='fuzzy',
               kwargs={'enabled' : True},
               description='Perform fuzzy hash matching on files/directories'),
        Option(short='u',
               long='cutoff',
               priority=100,
               type=int,
               kwargs={'cutoff' : DEFAULT_CUTOFF},
               description='Set the cutoff percentage'),
        Option(short='S',
               long='strings',
               kwargs={'strings' : True},
               description='Diff strings inside files instead of the entire file'),
        Option(short='s',
               long='same',
               kwargs={'same' : True, 'cutoff' : CONSERVATIVE_CUTOFF},
               description='Only show files that are the same'),
        Option(short='p',
               long='diff',
               kwargs={'same' : False, 'cutoff' : CONSERVATIVE_CUTOFF},
               description='Only show files that are different'),
        Option(short='n',
               long='name',
               kwargs={'filter_by_name' : True},
               description='Only compare files whose base names are the same'),
        Option(short='L',
               long='symlinks',
               kwargs={'symlinks' : True},
               description="Don't ignore symlinks"),
    ]

    KWARGS = [
        Kwarg(name='cutoff', default=DEFAULT_CUTOFF),
        Kwarg(name='strings', default=False),
        Kwarg(name='same', default=True),
        Kwarg(name='symlinks', default=False),
        Kwarg(name='max_results', default=None),
        Kwarg(name='abspath', default=False),
        Kwarg(name='filter_by_name', default=False),
        Kwarg(name='symlinks', default=False),
        Kwarg(name='enabled', default=False),
    ]

    LIBRARY_NAME = "fuzzy"
    LIBRARY_FUNCTIONS = [
            binwalk.core.C.Function(name="fuzzy_hash_buf", type=int),
            binwalk.core.C.Function(name="fuzzy_hash_filename", type=int),
            binwalk.core.C.Function(name="fuzzy_compare", type=int),
    ]

    # Max result is 148 (http://ssdeep.sourceforge.net/api/html/fuzzy_8h.html)
    FUZZY_MAX_RESULT = 150
    # Files smaller than this won't produce meaningful fuzzy results (from ssdeep.h)
    FUZZY_MIN_FILE_SIZE = 4096

    HEADER_FORMAT = "\n%s" + " " * 11 + "%s\n" 
    RESULT_FORMAT = "%d%%" + " " * 17 + "%s\n"
    HEADER = ["SIMILARITY", "FILE NAME"]
    RESULT = ["percentage", "description"]

    def init(self):
        self.total = 0
        self.last_file1 = HashResult(None)
        self.last_file2 = HashResult(None)

        self.lib = binwalk.core.C.Library(self.LIBRARY_NAME, self.LIBRARY_FUNCTIONS)

    def _get_strings(self, fname):
        return ''.join(list(binwalk.core.common.strings(fname, minimum=10)))

    def _show_result(self, match, fname):
        if self.abspath:
            fname = os.path.abspath(fname)

        # Add description string padding for alignment
        if match < 100:
            fname = ' ' + fname
        if match < 10:
            fname = ' ' + fname

        self.result(percentage=match, description=fname, plot=False)

    def _compare_files(self, file1, file2):
        '''
        Fuzzy diff two files.
            
        @file1 - The first file to diff.
        @file2 - The second file to diff.
    
        Returns the match percentage.    
        Returns None on error.
        '''
        status = 0
        file1_dup = False
        file2_dup = False

        if not self.filter_by_name or os.path.basename(file1) == os.path.basename(file2):
            if os.path.exists(file1) and os.path.exists(file2):

                hash1 = ctypes.create_string_buffer(self.FUZZY_MAX_RESULT)
                hash2 = ctypes.create_string_buffer(self.FUZZY_MAX_RESULT)

                # Check if the last file1 or file2 matches this file1 or file2; no need to re-hash if they match.
                if file1 == self.last_file1.name and self.last_file1.hash:
                    file1_dup = True
                else:
                    self.last_file1.name = file1

                if file2 == self.last_file2.name and self.last_file2.hash:
                    file2_dup = True
                else:
                    self.last_file2.name = file2

                try:
                    if self.strings:
                        if file1_dup:
                            file1_strings = self.last_file1.strings
                        else:
                            self.last_file1.strings = file1_strings = self._get_strings(file1)
                            
                        if file2_dup:
                            file2_strings = self.last_file2.strings
                        else:
                            self.last_file2.strings = file2_strings = self._get_strings(file2)

                        if file1_strings == file2_strings:
                            return 100
                        else:
                            if file1_dup:
                                hash1 = self.last_file1.hash
                            else:
                                status |= self.lib.fuzzy_hash_buf(file1_strings, len(file1_strings), hash1)

                            if file2_dup:
                                hash2 = self.last_file2.hash
                            else:
                                status |= self.lib.fuzzy_hash_buf(file2_strings, len(file2_strings), hash2)
                        
                    else:
                        if file1_dup:
                            hash1 = self.last_file1.hash
                        else:
                            status |= self.lib.fuzzy_hash_filename(file1, hash1)
                            
                        if file2_dup:
                            hash2 = self.last_file2.hash
                        else:
                            status |= self.lib.fuzzy_hash_filename(file2, hash2)
                
                    if status == 0:
                        if not file1_dup:
                            self.last_file1.hash = hash1
                        if not file2_dup:
                            self.last_file2.hash = hash2

                        if hash1.raw == hash2.raw:
                            return 100
                        else:
                            return self.lib.fuzzy_compare(hash1, hash2)
                except Exception as e:
                    binwalk.core.common.warning("Exception while doing fuzzy hash: %s" % str(e))

        return None

    def is_match(self, match):
        '''
        Returns True if this is a good match.
        Returns False if his is not a good match.
        '''
        return (match is not None and ((match >= self.cutoff and self.same) or (match < self.cutoff and not self.same)))

    def _get_file_list(self, directory):
        '''
        Generates a directory tree.

        @directory - The root directory to start from.

        Returns a set of file paths, excluding the root directory.
        '''
        file_list = []

        # Normalize directory path so that we can exclude it from each individual file path
        directory = os.path.abspath(directory) + os.path.sep

        for (root, dirs, files) in os.walk(directory):
            # Don't include the root directory in the file paths
            root = ''.join(root.split(directory, 1)[1:])

            # Get a list of files, with or without symlinks as specified during __init__
            files = [os.path.join(root, f) for f in files if self.symlinks or not os.path.islink(f)]

            file_list += files
            
        return set(file_list)

    def hash_files(self, needle, haystack):
        '''
        Compare one file against a list of other files.
        
        Returns a list of tuple results.
        '''
        self.total = 0

        for f in haystack:
            m = self._compare_files(needle, f)
            if m is not None and self.is_match(m):
                self._show_result(m, f)
                    
                self.total += 1
                if self.max_results and self.total >= self.max_results:
                    break

    def hash_file(self, needle, haystack):
        '''
        Search for one file inside one or more directories.

        Returns a list of tuple results.
        '''
        matching_files = []
        self.total = 0
        done = False

        for directory in haystack:
            for f in self._get_file_list(directory):
                f = os.path.join(directory, f)
                m = self._compare_files(needle, f)
                if m is not None and self.is_match(m):
                    self._show_result(m, f)
                    matching_files.append((m, f))
                    
                    self.total += 1
                    if self.max_results and self.total >= self.max_results:
                        done = True
                        break
            if done:
                break
                    
        return matching_files

    def hash_directories(self, needle, haystack):
        '''
        Compare the contents of one directory with the contents of other directories.

        Returns a list of tuple results.
        '''
        done = False
        self.total = 0

        source_files = self._get_file_list(needle)

        for directory in haystack:
            dir_files = self._get_file_list(directory)

            for source_file in source_files:
                for dir_file in dir_files:
                    file1 = os.path.join(needle, source_file)
                    file2 = os.path.join(directory, dir_file)

                    m = self._compare_files(file1, file2)
                    if m is not None and self.is_match(m):
                        self._show_result(m, "%s => %s" % (file1, file2))

                        self.total += 1
                        if self.max_results and self.total >= self.max_results:
                            done = True
                            break
            if done:
                break

    def run(self):
        '''
        Main module method.
        '''
        # Access the raw self.config.files list directly here, since we accept both
        # files and directories and self.next_file only works for files.
        needle = self.config.files[0]
        haystack = self.config.files[1:]

        self.header()
                
        if os.path.isfile(needle):
            if os.path.isfile(haystack[0]):
                self.hash_files(needle, haystack)
            else:
                self.hash_file(needle, haystack)
        else:
            self.hash_directories(needle, haystack)

        self.footer()

        return True

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/heuristics.py`:

```py
# Routines to perform Chi Squared tests. 
# Used for fingerprinting unknown areas of high entropy (e.g., is this block of high entropy data compressed or encrypted?).
# Inspired by people who actually know what they're doing: http://www.fourmilab.ch/random/

import math
from binwalk.core.compat import *
from binwalk.core.module import Module, Kwarg, Option, Dependency

class ChiSquare(object):
    '''
    Performs a Chi Squared test against the provided data.
    '''

    IDEAL = 256.0

    def __init__(self):
        '''
        Class constructor.

        Returns None.
        '''
        self.bytes = {}
        self.freedom = self.IDEAL - 1 
        
        # Initialize the self.bytes dictionary with keys for all possible byte values (0 - 255)
        for i in range(0, int(self.IDEAL)):
            self.bytes[chr(i)] = 0
        
        self.reset()

    def reset(self):
        self.xc2 = 0.0
        self.byte_count = 0

        for key in self.bytes.keys():
            self.bytes[key] = 0        

    def update(self, data):
        '''
        Updates the current byte counts with new data.

        @data - String of bytes to update.

        Returns None.
        '''
        # Count the number of occurances of each byte value
        for i in data:
            self.bytes[i] += 1

        self.byte_count += len(data)

    def chisq(self):
        '''
        Calculate the Chi Square critical value.

        Returns the critical value.
        '''
        expected = self.byte_count / self.IDEAL

        if expected:
            for byte in self.bytes.values():
                self.xc2 += ((byte - expected) ** 2 ) / expected

        return self.xc2

class EntropyBlock(object):

    def __init__(self, **kwargs):
        self.start = None
        self.end = None
        self.length = None
        for (k,v) in iterator(kwargs):
            setattr(self, k, v)

class HeuristicCompressionAnalyzer(Module):
    '''
    Performs analysis and attempts to interpret the results.
    '''

    BLOCK_SIZE = 32
    CHI_CUTOFF = 512
    ENTROPY_TRIGGER = .90
    MIN_BLOCK_SIZE = 4096
    BLOCK_OFFSET = 1024
    ENTROPY_BLOCK_SIZE = 1024

    TITLE = "Heuristic Compression"

    DEPENDS = [
            Dependency(name='Entropy',
                       attribute='entropy',
                       kwargs={'enabled' : True, 'do_plot' : False, 'display_results' : False, 'block_size' : ENTROPY_BLOCK_SIZE}),
    ]
    
    CLI = [
            Option(short='H',
                   long='heuristic',
                   kwargs={'enabled' : True},
                   description='Heuristically classify high entropy data'),
            Option(short='a',
                   long='trigger',
                   kwargs={'trigger_level' : 0},
                   type=float,
                   description='Set the entropy trigger level (0.0 - 1.0, default: %.2f)' % ENTROPY_TRIGGER),
    ]

    KWARGS = [
            Kwarg(name='enabled', default=False),
            Kwarg(name='trigger_level', default=ENTROPY_TRIGGER),
    ]

    def init(self):
        self.blocks = {}

        self.HEADER[-1] = "HEURISTIC ENTROPY ANALYSIS"

        # Trigger level sanity check
        if self.trigger_level > 1.0:
            self.trigger_level = 1.0
        elif self.trigger_level < 0.0:
            self.trigger_level = 0.0

        if self.config.block:
            self.block_size = self.config.block
        else:
            self.block_size = self.BLOCK_SIZE

        for result in self.entropy.results:
            if not has_key(self.blocks, result.file.name):
                self.blocks[result.file.name] = []

            if result.entropy >= self.trigger_level and (not self.blocks[result.file.name] or self.blocks[result.file.name][-1].end is not None):
                self.blocks[result.file.name].append(EntropyBlock(start=result.offset + self.BLOCK_OFFSET))
            elif result.entropy < self.trigger_level and self.blocks[result.file.name] and self.blocks[result.file.name][-1].end is None:
                self.blocks[result.file.name][-1].end = result.offset - self.BLOCK_OFFSET

    def run(self):
        for fp in iter(self.next_file, None):
            
            if has_key(self.blocks, fp.name):

                self.header()
                
                for block in self.blocks[fp.name]:

                    if block.end is None:
                        block.length = fp.offset + fp.length - block.start
                    else:
                        block.length = block.end - block.start

                    if block.length >= self.MIN_BLOCK_SIZE:
                        self.analyze(fp, block)

                self.footer()

    def analyze(self, fp, block):
        '''
        Perform analysis and interpretation.
        '''
        i = 0
        num_error = 0
        analyzer_results = []

        chi = ChiSquare()
        fp.seek(block.start)

        while i < block.length:
            j = 0
            (d, dlen) = fp.read_block()
            if not d:
                break

            while j < dlen:
                chi.reset()

                data = d[j:j+self.block_size]
                if len(data) < self.block_size:
                    break

                chi.update(data)

                if chi.chisq() >= self.CHI_CUTOFF:
                    num_error += 1
                
                j += self.block_size

                if (j + i) > block.length:
                    break

            i += dlen

        if num_error > 0:
            verdict = 'Moderate entropy data, best guess: compressed'
        else:
            verdict = 'High entropy data, best guess: encrypted'

        desc = '%s, size: %d, %d low entropy blocks' % (verdict, block.length, num_error)
        self.result(offset=block.start, description=desc, file=fp)

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/hexdiff.py`:

```py
import os
import sys
import string
import binwalk.core.common as common
from binwalk.core.compat import *
from binwalk.core.module import Module, Option, Kwarg

class HexDiff(Module):


    COLORS = {
        'red'   : '31',
        'green' : '32',
        'blue'  : '34',
    }

    SEPERATORS = ['\\', '/']
    DEFAULT_BLOCK_SIZE = 16

    SKIPPED_LINE = "*"
    CUSTOM_DISPLAY_FORMAT = "0x%.8X    %s"

    TITLE = "Binary Diffing"

    CLI = [
            Option(short='W',
                   long='hexdump',
                   kwargs={'enabled' : True},
                   description='Perform a hexdump / diff of a file or files'),
            Option(short='G',
                   long='green',
                   kwargs={'show_green' : True},
                   description='Only show lines containing bytes that are the same among all files'),
            Option(short='i',
                   long='red',
                   kwargs={'show_red' : True},
                   description='Only show lines containing bytes that are different among all files'),
            Option(short='U',
                   long='blue',
                   kwargs={'show_blue' : True},
                   description='Only show lines containing bytes that are different among some files'),
            Option(short='w',
                   long='terse',
                   kwargs={'terse' : True},
                   description='Diff all files, but only display a hex dump of the first file'),
    ]

    KWARGS = [
            Kwarg(name='show_red', default=False),
            Kwarg(name='show_blue', default=False),
            Kwarg(name='show_green', default=False),
            Kwarg(name='terse', default=False),
            Kwarg(name='enabled', default=False),
    ]

    RESULT_FORMAT = "%s\n"
    RESULT = ['display']

    def _no_colorize(self, c, color="red", bold=True):
        return c

    def _colorize(self, c, color="red", bold=True):
        attr = []

        attr.append(self.COLORS[color])
        if bold:
            attr.append('1')

        return "\x1b[%sm%s\x1b[0m" % (';'.join(attr), c)

    def _color_filter(self, data):
        red = '\x1b[' + self.COLORS['red'] + ';'
        green = '\x1b[' + self.COLORS['green'] + ';'
        blue = '\x1b[' + self.COLORS['blue'] + ';'

        if self.show_blue and blue in data:
            return True
        elif self.show_green and green in data:
            return True
        elif self.show_red and red in data:
            return True

        return False

    def hexascii(self, target_data, byte, offset):
        color = "green"

        for (fp_i, data_i) in iterator(target_data):
            diff_count = 0

            for (fp_j, data_j) in iterator(target_data):
                if fp_i == fp_j:
                    continue

                try:
                    if data_i[offset] != data_j[offset]:
                        diff_count += 1
                except IndexError as e:
                    diff_count += 1

            if diff_count == len(target_data)-1:
                color = "red"
            elif diff_count > 0:
                color = "blue"
                break

        hexbyte = self.colorize("%.2X" % ord(byte), color)

        if byte not in string.printable or byte in string.whitespace:
            byte = "."

        asciibyte = self.colorize(byte, color)

        return (hexbyte, asciibyte)

    def diff_files(self, target_files):
        last_line = None
        loop_count = 0
        sep_count = 0

        # Figure out the maximum diff size (largest file size)
        self.status.total = 0
        for i in range(0, len(target_files)):
            if target_files[i].size > self.status.total:
                self.status.total = target_files[i].size
                self.status.fp = target_files[i]

        while True:
            line = ""
            done_files = 0
            block_data = {}
            seperator = self.SEPERATORS[sep_count % 2]

            for fp in target_files:
                block_data[fp] = fp.read(self.block)
                if not block_data[fp]:
                    done_files += 1

            # No more data from any of the target files? Done.
            if done_files == len(target_files):
                break

            for fp in target_files:
                hexline = ""
                asciiline = ""

                for i in range(0, self.block):
                    if i >= len(block_data[fp]):
                        hexbyte = "XX"
                        asciibyte = "."
                    else:
                        (hexbyte, asciibyte) = self.hexascii(block_data, block_data[fp][i], i)

                    hexline += "%s " % hexbyte
                    asciiline += "%s" % asciibyte

                line += "%s |%s|" % (hexline, asciiline)

                if self.terse:
                    break

                if fp != target_files[-1]:
                    line += " %s " % seperator

            offset = fp.offset + (self.block * loop_count)

            if not self._color_filter(line):
                display = line = self.SKIPPED_LINE
            else:
                display = self.CUSTOM_DISPLAY_FORMAT % (offset, line)
                sep_count += 1

            if line != self.SKIPPED_LINE or last_line != line:
                self.result(offset=offset, description=line, display=display)

            last_line = line
            loop_count += 1
            self.status.completed += self.block

    def init(self):
        # To mimic expected behavior, if all options are False, we show everything
        if not any([self.show_red, self.show_green, self.show_blue]):
            self.show_red = self.show_green = self.show_blue = True

        # Always disable terminal formatting, as it won't work properly with colorized output
        self.config.display.fit_to_screen = False

        # Set the block size (aka, hexdump line size)
        self.block = self.config.block
        if not self.block:
            self.block = self.DEFAULT_BLOCK_SIZE

        # Build a list of files to hexdiff
        self.hex_target_files = []
        while True:
            f = self.next_file(close_previous=False)
            if not f:
                break
            else:
                self.hex_target_files.append(f)

        # Build the header format string
        header_width = (self.block * 4) + 2
        if self.terse:
            file_count = 1
        else:
            file_count = len(self.hex_target_files)
        self.HEADER_FORMAT = "OFFSET      " + (("%%-%ds   " % header_width) * file_count) + "\n"

        # Build the header argument list
        self.HEADER = [fp.name for fp in self.hex_target_files]
        if self.terse and len(self.HEADER) > 1:
            self.HEADER = self.HEADER[0]

        # Set up the tty for colorization, if it is supported
        if hasattr(sys.stderr, 'isatty') and sys.stderr.isatty() and not common.MSWindows():
            import curses
            curses.setupterm()
            self.colorize = self._colorize
        else:
            self.colorize = self._no_colorize

    def run(self):
        if self.hex_target_files:
            self.header()
            self.diff_files(self.hex_target_files)
            self.footer()


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/modules/signature.py`:

```py
# Basic signature scan module. This is the default (and primary) feature of binwalk.
import binwalk.core.magic
from binwalk.core.module import Module, Option, Kwarg

class Signature(Module):

    TITLE = "Signature Scan"
    ORDER = 10

    CLI = [
            Option(short='B',
                   long='signature',
                   kwargs={'enabled' : True, 'explicit_signature_scan' : True},
                   description='Scan target file(s) for common file signatures'),
            Option(short='R',
                   long='raw',
                   kwargs={'enabled' : True, 'raw_bytes' : []},
                   type=list,
                   dtype=str.__name__,
                   description='Scan target file(s) for the specified sequence of bytes'),
            Option(short='A',
                   long='opcodes',
                   kwargs={'enabled' : True, 'search_for_opcodes' : True},
                   description='Scan target file(s) for common executable opcode signatures'),
            Option(short='m',
                   long='magic',
                   kwargs={'enabled' : True, 'magic_files' : []},
                   type=list,
                   dtype='file',
                   description='Specify a custom magic file to use'),
            Option(short='b',
                   long='dumb',
                   kwargs={'dumb_scan' : True},
                   description='Disable smart signature keywords'),
            Option(short='I',
                   long='invalid',
                   kwargs={'show_invalid' : True},
                   description='Show results marked as invalid'),
            Option(short='x',
                   long='exclude',
                   kwargs={'exclude_filters' : []},
                   type=list,
                   dtype=str.__name__,
                   description='Exclude results that match <str>'),
            Option(short='y',
                   long='include',
                   kwargs={'include_filters' : []},
                   type=list,
                   dtype=str.__name__,
                   description='Only show results that match <str>'),
    ]

    KWARGS = [
            Kwarg(name='enabled', default=False),
            Kwarg(name='show_invalid', default=False),
            Kwarg(name='include_filters', default=[]),
            Kwarg(name='exclude_filters', default=[]),
            Kwarg(name='raw_bytes', default=[]),
            Kwarg(name='search_for_opcodes', default=False),
            Kwarg(name='explicit_signature_scan', default=False),
            Kwarg(name='dumb_scan', default=False),
            Kwarg(name='magic_files', default=[]),
    ]

    VERBOSE_FORMAT = "%s    %d"

    def init(self):
        self.one_of_many = None

        # Append the user's magic file first so that those signatures take precedence
        if self.search_for_opcodes:
            self.magic_files = [
                    self.config.settings.user.binarch,
                    self.config.settings.system.binarch,
            ]

        # Use the system default magic file if no other was specified, or if -B was explicitly specified
        if (not self.magic_files and not self.raw_bytes) or self.explicit_signature_scan:
            self.magic_files += self.config.settings.user.magic + self.config.settings.system.magic

        # Initialize libmagic
        self.magic = binwalk.core.magic.Magic(include=self.include_filters,
                                              exclude=self.exclude_filters,
                                              invalid=self.show_invalid)

        # Create a signature from the raw bytes, if any
        if self.raw_bytes:
            raw_signatures = []
            for raw_bytes in self.raw_bytes:
                raw_signatures.append("0    string    %s    %s" % (raw_bytes, raw_bytes))
            binwalk.core.common.debug("Parsing raw signatures: %s" % str(raw_signatures))
            self.magic.parse(raw_signatures)

        # Parse the magic file(s)
        if self.magic_files:
            binwalk.core.common.debug("Loading magic files: %s" % str(self.magic_files))
            for f in self.magic_files:
                self.magic.load(f)

        self.VERBOSE = ["Signatures:", len(self.magic.signatures)]

    def validate(self, r):
        '''
        Called automatically by self.result.
        '''
        if self.show_invalid:
            r.valid = True
        elif r.valid:
            if not r.description:
                r.valid = False

            if r.size and (r.size + r.offset) > r.file.size:
                r.valid = False

            if r.jump and (r.jump + r.offset) > r.file.size:
                r.valid = False

        if r.valid:
            # Don't keep displaying signatures that repeat a bunch of times (e.g., JFFS2 nodes)
            if r.id == self.one_of_many:
                r.display = False
            elif r.many:
                self.one_of_many = r.id
            else:
                self.one_of_many = None

    def scan_file(self, fp):
        current_file_offset = 0

        while True:
            (data, dlen) = fp.read_block()
            if not data:
                break

            current_block_offset = 0
            block_start = fp.tell() - dlen
            self.status.completed = block_start - fp.offset

            # Scan this data block for magic signatures
            for r in self.magic.scan(data, dlen):
                # current_block_offset is set when a jump-to-offset keyword is encountered while
                # processing signatures. This points to an offset inside the current data block
                # that scanning should jump to, so ignore any subsequent candidate signatures that
                # occur before this offset inside the current data block.
                if r.offset < current_block_offset:
                    continue

                # Keep a record of the relative offset of this signature inside the current data block
                # (used later for setting current_block_offset).
                relative_offset = r.offset + r.adjust

                # Set the absolute offset inside the target file
                r.offset = block_start + relative_offset

                # Provide an instance of the current file object
                r.file = fp

                # Register the result for futher processing/display
                # self.result automatically calls self.validate for result validation
                self.result(r=r)

                # Is this a valid result and did it specify a jump-to-offset keyword, and are we doing a "smart" scan?
                if r.valid and r.jump > 0 and not self.dumb_scan:
                    absolute_jump_offset = r.offset + r.jump
                    current_block_offset = relative_offset + r.jump
                    #print ("Jumping to: 0x%X (0x%X)..." % (absolute_jump_offset, current_block_offset))

                    # If the jump-to-offset is beyond the confines of the current block, seek the file to
                    # that offset and quit processing this block of data.
                    if absolute_jump_offset >= fp.tell():
                        fp.seek(r.offset + r.jump)
                        break

    def run(self):
        for fp in iter(self.next_file, None):
            self.header()
            self.scan_file(fp)
            self.footer()


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/arcadyan.py`:

```py
import os
import binwalk.core.common
import binwalk.core.plugin

class ArcadyanDeobfuscator(binwalk.core.plugin.Plugin):
    '''
    Deobfuscator for known Arcadyan firmware obfuscation(s).
    '''
    MODULES = ['Signature']

    OBFUSCATION_MAGIC_SIZE  = 4
    MAX_IMAGE_SIZE          = 0x1B0000
    BLOCK_SIZE              = 32
    BLOCK1_OFFSET           = 4
    BLOCK2_OFFSET           = 0x68
    MIN_FILE_SIZE           = (OBFUSCATION_MAGIC_SIZE + BLOCK2_OFFSET + BLOCK_SIZE)

    BLOCK1_START            = BLOCK1_OFFSET
    BLOCK1_END              = BLOCK1_START + BLOCK_SIZE

    BLOCK2_START            = BLOCK2_OFFSET
    BLOCK2_END              = BLOCK2_OFFSET + BLOCK_SIZE

    P1_START                = 0
    P1_END                  = BLOCK1_OFFSET

    P2_START                = BLOCK1_END
    P2_END                  = BLOCK2_START

    P3_START                = BLOCK2_END

    def init(self):
        if self.module.extractor.enabled:
            self.module.extractor.add_rule(regex="^obfuscated arcadyan firmware",
                                           extension="obfuscated",
                                           cmd=self.extractor)

    def extractor(self, fname):
        deobfuscated = None
        fname = os.path.abspath(fname)

        infile = binwalk.core.common.BlockFile(fname, "rb")
        obfuscated = infile.read()
        infile.close()

        if len(obfuscated) >= self.MIN_FILE_SIZE:
            # Swap blocks 1 and 2
            p1 = obfuscated[self.P1_START:self.P1_END]
            b1 = obfuscated[self.BLOCK1_START:self.BLOCK1_END]
            p2 = obfuscated[self.P2_START:self.P2_END]
            b2 = obfuscated[self.BLOCK2_START:self.BLOCK2_END]
            p3 = obfuscated[self.P3_START:]
            deobfuscated = p1 + b2 + p2 + b1 + p3

            # Nibble-swap each byte in block 1
            nswap = ''
            for i in range(self.BLOCK1_START, self.BLOCK1_END):
                nswap += chr(((ord(deobfuscated[i]) & 0x0F) << 4) + ((ord(deobfuscated[i]) & 0xF0) >> 4));
            deobfuscated = deobfuscated[self.P1_START:self.P1_END] + nswap + deobfuscated[self.BLOCK1_END:]

            # Byte-swap each byte pair in block 1
            bswap = ''
            i = self.BLOCK1_START
            while i < self.BLOCK1_END:
                bswap += deobfuscated[i+1] + deobfuscated[i]
                i += 2
            deobfuscated = deobfuscated[self.P1_START:self.P1_END] + bswap + deobfuscated[self.BLOCK1_END:]

        if deobfuscated:
            out = binwalk.core.common.BlockFile((os.path.splitext(fname)[0] + '.deobfuscated'), "wb")
            out.write(deobfuscated)
            out.close()
            return True
        else:
            return False


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/compressd.py`:

```py
#import binwalk.core.C
import binwalk.core.plugin
#from binwalk.core.common import *

class CompressdPlugin(binwalk.core.plugin.Plugin):
#    '''
#    Searches for and validates compress'd data.
#    '''

    MODULES = ['Signature']

    #READ_SIZE = 64

    #COMPRESS42 = "compress42"
    #COMPRESS42_FUNCTIONS = [
    #    binwalk.core.C.Function(name="is_compressed", type=bool),
    #]

    #comp = None

    #def init(self):
        #self.comp = binwalk.core.C.Library(self.COMPRESS42, self.COMPRESS42_FUNCTIONS)
        # This plugin is currently disabled due to the need to move away from supporting C
        # libraries and into a pure Python project, for cross-platform support and ease of
        # installation / package maintenance. A Python implementation will likely need to
        # be custom developed in the future, but for now, since this compression format is
        # not very common, especially in firmware, simply disable it.
        #self.comp = None

    #def scan(self, result):
    #    if self.comp and result.file and result.description.lower().startswith("compress'd data"):
    #        fd = self.module.config.open_file(result.file.name, offset=result.offset, length=self.READ_SIZE)
    #        compressed_data = fd.read(self.READ_SIZE)
    #        fd.close()

    #        if not self.comp.is_compressed(compressed_data, len(compressed_data)):
    #            result.valid = False



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/cpio.py`:

```py
import os
import subprocess
import binwalk.core.plugin

class CPIOPlugin(binwalk.core.plugin.Plugin):
    '''
    Ensures that ASCII CPIO archive entries only get extracted once.
    Also provides an internal CPIO extraction wrapper around the Unix
    cpio utility since no output directory can be provided to it directly.
    '''
    CPIO_OUT_DIR = "cpio-root"

    MODULES = ['Signature']

    def init(self):
        self.consecutive_hits = 0

        if self.module.extractor.enabled:
            self.module.extractor.add_rule(regex="^ascii cpio archive",
                                           extension="cpio",
                                           cmd=self.extractor,
                                           recurse=False)       # Most CPIO archives are file systems, so don't recurse into the extracted contents

    def extractor(self, fname):
        result = None
        fname = os.path.abspath(fname)
        out_dir = os.path.join(os.path.dirname(fname), self.CPIO_OUT_DIR)

        try:
            fpin = open(fname, "rb")
            fperr = open(os.devnull, "rb")
            os.mkdir(out_dir)
        except OSError:
            return

        try:
            curdir = os.getcwd()
            os.chdir(out_dir)
        except OSError:
            return

        try:
            result = subprocess.call(['cpio', '-d', '-i', '--no-absolute-filenames'],
                                     stdin=fpin,
                                     stderr=fperr,
                                     stdout=fperr)
        except OSError:
            result = -1

        os.chdir(curdir)
        fpin.close()
        fperr.close()

        if result in [0, 2]:
            return True
        else:
            return False

    def pre_scan(self):
        # Be sure to re-set this at the beginning of every scan
        self.found_archive = False
        self.found_archive_in_file = None

    def scan(self, result):
        if result.valid:
            # ASCII CPIO archives consist of multiple entries, ending with an entry named 'TRAILER!!!'.
            # Displaying each entry is useful, as it shows what files are contained in the archive,
            # but we only want to extract the archive when the first entry is found.
            if result.description.startswith('ASCII cpio archive'):
                self.consecutive_hits += 1

                if not self.found_archive or self.found_archive_in_file != result.file.name:
                    # This is the first entry. Set found_archive and allow the scan to continue normally.
                    self.found_archive_in_file = result.file.name
                    self.found_archive = True
                    result.extract = True
                elif 'TRAILER!!!' in result.description:
                    # This is the last entry, un-set found_archive.
                    self.found_archive = False
                    result.extract = False
                    self.consecutive_hits = 0
                else:
                    # The first entry has already been found and this is not the last entry, or the last entry
                    # has not yet been found. Don't extract.
                    result.extract = False
            elif self.consecutive_hits < 4:
                # If this was a valid non-CPIO archive result, reset these values; else, a previous
                # false positive CPIO result could leave these set, causing a subsequent valid CPIO
                # result to not be extracted.
                self.found_archive = False
                self.found_archive_in_file = None
                self.consecutive_hits = 0
            elif self.consecutive_hits >= 4:
                # Ignore other stuff until the end of CPIO is found
                # TODO: It would be better to jump to the end of this CPIO entry rather than make this assumption...
                result.valid = False

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/gzipextract.py`:

```py
import os
import gzip
import binwalk.core.plugin

class GzipExtractPlugin(binwalk.core.plugin.Plugin):
    '''
    Gzip extractor plugin.
    '''
    MODULES = ['Signature']
    BLOCK_SIZE = 10 * 1024

    def init(self):
        # If the extractor is enabled for the module we're currently loaded
        # into, and if a rule that matches gzip signature results already exists
        # (e.g., the default rules were loaded or a gzip rule was specified manually),
        # then register self.extractor as a gzip extraction rule.
        if self.module.extractor.enabled and self.module.extractor.match("gzip compressed data"):
            self.module.extractor.add_rule(txtrule=None,
                                           regex="^gzip compressed data",
                                           extension="gz",
                                           cmd=self.extractor)

    def extractor(self, fname):
        fname = os.path.abspath(fname)
        outfile = os.path.splitext(fname)[0]

        try:
            fpout = open(outfile, "wb")
            gz = gzip.GzipFile(fname, "rb")

            while True:
                data = gz.read(self.BLOCK_SIZE)
                if data:
                    fpout.write(data)
                else:
                    break

            gz.close()
            fpout.close()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            return False

        return True

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/gzipvalid.py`:

```py
import zlib
import binwalk.core.compat
import binwalk.core.plugin
from binwalk.core.common import BlockFile

class GzipValidPlugin(binwalk.core.plugin.Plugin):
    '''
    Validates gzip compressed data. Almost identical to zlibvalid.py.
    '''
    MODULES = ['Signature']

    MAX_DATA_SIZE = 33 * 1024

    def scan(self, result):
        # If this result is a gzip signature match, try to decompress the data
        if result.file and result.description.lower().startswith('gzip'):
            # Seek to and read the suspected gzip data
            fd = self.module.config.open_file(result.file.name, offset=result.offset, length=self.MAX_DATA_SIZE)
            data = fd.read(self.MAX_DATA_SIZE)
            fd.close()

            # Grab the flags and initialize the default offset of the start of
            # compressed data.
            flags = int(ord(data[3]))
            offset = 10

            # If there is a comment or the original file name, find the end of that
            # string and start decompression from there.
            if (flags & 0x0C) or (flags & 0x10):
                while data[offset] != "\x00":
                    offset += 1
                offset += 1

            # Append basic zlib header to the beginning of the compressed data
            data = "\x78\x9C" + data[offset:]

            # Check if this is valid deflate data (no zlib header)
            try:
                zlib.decompress(binwalk.core.compat.str2bytes(data))
            except zlib.error as e:
                error = str(e)
                # Truncated input data results in error -5.
                # gzip uses different checksums than zlib, which results in error -3.
                if not error.startswith("Error -5") and not error.startswith("Error -3"):
                    result.valid = False



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/jffs2valid.py`:

```py
import struct
import binascii
import binwalk.core.plugin

class JFFS2ValidPlugin(binwalk.core.plugin.Plugin):
    '''
    Helps validate JFFS2 signature results.

    The JFFS2 signature rules catch obvious cases, but inadvertently
    mark some valid JFFS2 nodes as invalid due to  padding (0xFF's or
    0x00's) in between nodes.
    '''
    MODULES = ['Signature']

    def _check_crc(self, node_header):
        # struct and binascii want a bytes object in Python3
        node_header = binwalk.core.compat.str2bytes(node_header)

        # Get the header's reported CRC value
        if node_header[0:2] == b"\x19\x85":
            header_crc = struct.unpack(">I", node_header[8:12])[0]
        else:
            header_crc = struct.unpack("<I", node_header[8:12])[0]

        # Calculate the actual CRC
        calculated_header_crc = (binascii.crc32(node_header[0:8], -1) ^ -1) & 0xffffffff

        # Make sure they match
        return (header_crc == calculated_header_crc)

    def scan(self, result):
        if result.file and result.description.lower().startswith('jffs2 filesystem'):

            # Seek to and read the suspected JFFS2 node header
            fd = self.module.config.open_file(result.file.name, offset=result.offset)
            # JFFS2 headers are only 12 bytes in size, but reading larger amounts of
            # data from disk speeds up repeated disk access and decreases performance
            # hits (disk caching?).
            #
            # TODO: Should this plugin validate the *entire* JFFS2 file system, rather
            #       than letting the signature module find every single JFFS2 node?
            node_header = fd.read(1024)
            fd.close()

            result.valid = self._check_crc(node_header[0:12])



```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/lzmaextract.py`:

```py
import os
import binwalk.core.plugin

class LZMAExtractPlugin(binwalk.core.plugin.Plugin):
    '''
    LZMA extractor plugin.
    '''
    MODULES = ['Signature']

    def init(self):
        try:
            # lzma package in Python 2.0 decompress() does not handle multiple
            # compressed streams, only first stream is extracted.
            # backports.lzma package could be used to keep consistent behaviour.
            import lzma
            self.decompressor = lzma.decompress

            # If the extractor is enabled for the module we're currently loaded
            # into, then register self.extractor as a zlib extraction rule.
            if self.module.extractor.enabled:
                self.module.extractor.add_rule(txtrule=None,
                                               regex="^lzma compressed data",
                                               extension="7z",
                                               cmd=self.extractor)
                self.module.extractor.add_rule(txtrule=None,
                                               regex="^xz compressed data",
                                               extension="xz",
                                               cmd=self.extractor)
        except ImportError as e:
            pass

    def extractor(self, fname):
        fname = os.path.abspath(fname)
        outfile = os.path.splitext(fname)[0]

        try:
            fpin = open(fname, "rb")
            compressed = fpin.read()
            fpin.close()

            decompressed = self.decompressor(compressed)

            fpout = open(outfile, "wb")
            fpout.write(decompressed)
            fpout.close()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            return False

        return True

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/lzmamod.py`:

```py
import os
import shutil
import binwalk.core.plugin
from binwalk.core.compat import *
from binwalk.core.common import BlockFile

class LZMAModPlugin(binwalk.core.plugin.Plugin):
    '''
    Finds and extracts modified LZMA files commonly found in cable modems.
    Based on Bernardo Rodrigues' work: http://w00tsec.blogspot.com/2013/11/unpacking-firmware-images-from-cable.html
    '''
    MODULES = ['Signature']

    FAKE_LZMA_SIZE = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"
    SIGNATURE = "lzma compressed data"

    def init(self):
        self.original_cmd = ''

        # Replace the first existing LZMA extraction command with our own
        for rule in self.module.extractor.match(self.SIGNATURE):
            self.original_cmd = rule['cmd']
            rule['cmd'] = self.lzma_cable_extractor
            break

    def lzma_cable_extractor(self, fname):
        # Try extracting the LZMA file without modification first
        result = self.module.extractor.execute(self.original_cmd, fname)

        # If the external extractor was successul (True) or didn't exist (None), don't do anything.
        if result not in [True, None]:
            out_name = os.path.splitext(fname)[0] + '-patched' + os.path.splitext(fname)[1]
            fp_out = BlockFile(out_name, 'w')
            # Use self.module.config.open_file here to ensure that other config settings (such as byte-swapping) are honored
            fp_in = self.module.config.open_file(fname, offset=0, length=0)
            fp_in.set_block_size(peek=0)
            i = 0

            while i < fp_in.length:
                (data, dlen) = fp_in.read_block()

                if i == 0:
                    out_data = data[0:5] + self.FAKE_LZMA_SIZE + data[5:]
                else:
                    out_data = data

                fp_out.write(out_data)

                i += dlen

            fp_in.close()
            fp_out.close()

            # Overwrite the original file so that it can be cleaned up if -r was specified
            shutil.move(out_name, fname)
            result = self.module.extractor.execute(self.original_cmd, fname)

        return result

    def scan(self, result):
        # The modified cable modem LZMA headers all have valid dictionary sizes and a properties byte of 0x5D.
        if result.description.lower().startswith(self.SIGNATURE) and "invalid uncompressed size" in result.description:
            if "properties: 0x5D" in result.description and "invalid dictionary size" not in result.description:
                result.valid = True
                result.description = result.description.split("invalid uncompressed size")[0] + "missing uncompressed size"


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/lzmavalid.py`:

```py
import binwalk.core.plugin
import binwalk.core.compat
from binwalk.core.common import BlockFile

class LZMAPlugin(binwalk.core.plugin.Plugin):
    '''
    Validates lzma signature results.
    '''
    MODULES = ['Signature']

    # Some lzma files exclude the file size, so we have to put it back in.
    # See also the lzmamod.py plugin.
    FAKE_LZMA_SIZE = "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF"

    # Check up to the first 64KB
    MAX_DATA_SIZE = 64 * 1024

    def init(self):
        try:
            import lzma
            self.decompressor = lzma.decompress
        except ImportError as e:
            self.decompressor = None

    def is_valid_lzma(self, data):
        valid = True

        if self.decompressor is not None:
            # The only acceptable exceptions are those indicating that the input data was truncated.
            try:
                self.decompressor(binwalk.core.compat.str2bytes(data))
            except IOError as e:
                # The Python2 module gives this error on truncated input data.
                if str(e) != "unknown BUF error":
                    valid = False
            except Exception as e:
                # The Python3 module gives this error on truncated input data.
                # The inconsistency between modules is a bit worrisome.
                if str(e) != "Compressed data ended before the end-of-stream marker was reached":
                    valid = False

        return valid

    def scan(self, result):
        # If this result is an lzma signature match, try to decompress the data
        if result.valid and result.file and result.description.lower().startswith('lzma compressed data'):

            # Seek to and read the suspected lzma data
            fd = self.module.config.open_file(result.file.name, offset=result.offset, length=self.MAX_DATA_SIZE)
            data = fd.read(self.MAX_DATA_SIZE)
            fd.close()

            # Validate the original data; if that fails, maybe it is missing the size field,
            # so try again with a dummy size field in place.
            if not self.is_valid_lzma(data):
                data = data[:5] + self.FAKE_LZMA_SIZE + data[5:]
                if not self.is_valid_lzma(data):
                    result.valid = False


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/tar.py`:

```py
import time
import math
import binwalk.core.plugin

class TarPlugin(binwalk.core.plugin.Plugin):

    MODULES = ['Signature']

    # "borrowed from pythons tarfile module"
    TAR_BLOCKSIZE = 512

    def nts(self, s):
        """
        Convert a null-terminated string field to a python string.
        """
        # Use the string up to the first null char.
        p = s.find("\0")
        if p == -1:
            return s
        return s[:p]

    def nti(self, s):
        """
        Convert a number field to a python number.
        """
        # There are two possible encodings for a number field, see
        # itn() below.
        if s[0] != chr(0x80):
            try:
                n = int(self.nts(s) or "0", 8)
            except ValueError:
                raise ValueError("invalid tar header")
        else:
            n = 0
            for i in xrange(len(s) - 1):
                n <<= 8
                n += ord(s[i + 1])
        return n

    def scan(self, result):
        if result.description.lower().startswith('posix tar archive'):
            is_tar = True
            file_offset = result.offset
            fd = self.module.config.open_file(result.file.name, offset=result.offset)

            while is_tar:
                # read in the tar header struct
                buf = fd.read(self.TAR_BLOCKSIZE)
                
                # check to see if we are still in a tarball
                if buf[257:262] == 'ustar':
                    # get size of tarred file convert to blocks (plus 1 to include header)
                    try:
                        size = self.nti(buf[124:136])
                        blocks = math.ceil(size/float(self.TAR_BLOCKSIZE)) + 1
                    except ValueError as e:
                        is_tar = False
                        break

                    # update file offset for next file in tarball
                    file_offset += int(self.TAR_BLOCKSIZE*blocks)

                    if file_offset >= result.file.size:
                        # we hit the end of the file
                        is_tar = False
                    else:
                        fd.seek(file_offset)
                else:
                    is_tar = False            

            result.jump = file_offset

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/ubivalid.py`:

```py
import struct
import binascii
import binwalk.core.plugin
import binwalk.core.compat

class UBIValidPlugin(binwalk.core.plugin.Plugin):
    '''
    Helps validate UBI erase count signature results.

    Checks header CRC and calculates jump value
    '''
    MODULES = ['Signature']
    current_file=None
    last_ec_hdr_offset = None
    peb_size = None

    def _check_crc(self, ec_header):
        # Get the header's reported CRC value
        header_crc = struct.unpack(">I", ec_header[60:64])[0]

        # Calculate the actual CRC
        calculated_header_crc = ~binascii.crc32(ec_header[0:60]) & 0xffffffff

        # Make sure they match
        return header_crc == calculated_header_crc

    def _process_result(self, result):
        if self.current_file == result.file.name:
            result.display=False
        else:
            # Reset everything in case new file is encountered
            self.peb_size=None
            self.last_ec_hdr_offset=None
            self.peb_size=None

            # Display result and trigger extraction
            result.display=True

        self.current_file = result.file.name

        if not self.peb_size and self.last_ec_hdr_offset:
            # Calculate PEB size by subtracting last EC block offset
            self.peb_size = result.offset - self.last_ec_hdr_offset
        else:
            # First time plugin is called on file, save EC block offset
            self.last_ec_hdr_offset = result.offset

        if self.peb_size:
            # If PEB size has been determined jump PEB size
            result.jump = self.peb_size
        else:
            result.jump = 0

    def scan(self, result):
        if result.file and result.description.lower().startswith('ubi erase count header'):
            # Seek to and read the suspected UBI erase count header
            fd = self.module.config.open_file(result.file.name, offset=result.offset)

            ec_header = binwalk.core.compat.str2bytes(fd.read(1024))
            fd.close()

            result.valid = self._check_crc(ec_header[0:64])
            if result.valid:
                self._process_result(result)

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/unjffs2.py`:

```py
# This file has been depreciated and is no longer in use.
# This is merely a placeholder to ensure future installations
# don't leave the old, depreciated file in tact.

import binwalk.core.plugin

class Unjffs2DepreciatedPlugin(binwalk.core.plugin.Plugin):
    pass

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/ziphelper.py`:

```py
import binwalk.core.plugin

class ZipHelperPlugin(binwalk.core.plugin.Plugin):
    '''
    A helper plugin for Zip files to ensure that the Zip archive
    extraction rule is only executed once when the first Zip archive
    entry is encountered. This resets once and end of zip archive is
    found.
    '''
    MODULES = ['Signature']

    extraction_active = False

    def scan(self, result):
        if result.valid and result.display:
            if result.description.lower().startswith('zip archive data'):
                if self.extraction_active:
                    result.extract = False
                else:
                    self.extraction_active = True
            elif result.description.lower().startswith('end of zip archive'):
                self.extraction_active = False

```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/zlibextract.py`:

```py
import os
import zlib
import binwalk.core.compat
import binwalk.core.common
import binwalk.core.plugin

class ZLIBExtractPlugin(binwalk.core.plugin.Plugin):
    '''
    Zlib extractor plugin.
    '''
    MODULES = ['Signature']

    def init(self):
        # If the extractor is enabled for the module we're currently loaded
        # into, then register self.extractor as a zlib extraction rule.
        if self.module.extractor.enabled:
            self.module.extractor.add_rule(txtrule=None,
                                           regex="^zlib compressed data",
                                           extension="zlib",
                                           cmd=self.extractor)

    def extractor(self, fname):
        outfile = os.path.splitext(fname)[0]

        try:
            fpin = binwalk.core.common.BlockFile(fname)
            fpout = binwalk.core.common.BlockFile(outfile, 'w')

            plaintext = zlib.decompress(binwalk.core.compat.str2bytes(fpin.read()))
            fpout.write(plaintext)

            fpin.close()
            fpout.close()
        except KeyboardInterrupt as e:
            raise e
        except Exception as e:
            return False

        return True


```

`binwalk_windows/binwalk-2.1.1/src/binwalk/plugins/zlibvalid.py`:

```py
import zlib
import binwalk.core.compat
import binwalk.core.plugin
from binwalk.core.common import BlockFile

class ZlibValidPlugin(binwalk.core.plugin.Plugin):
    '''
    Validates zlib compressed data.
    '''
    MODULES = ['Signature']

    MAX_DATA_SIZE = 33 * 1024

    def scan(self, result):
        # If this result is a zlib signature match, try to decompress the data
        if result.file and result.description.lower().startswith('zlib'):

            # If byte swapping is enabled, we need to start reading at a swap-size
            # aligned offset, then index in to the read data appropriately.
            if self.module.config.swap_size:
                adjust = result.offset % self.module.config.swap_size
            else:
                adjust = 0

            offset = result.offset - adjust

            # Seek to and read the suspected zlib data
            fd = self.module.config.open_file(result.file.name)
            fd.seek(offset)
            data = fd.read(self.MAX_DATA_SIZE)[adjust:]
            fd.close()

            # Check if this is valid zlib data. It is valid if:
            #
            #   1. It decompresses without error
            #   2. Decompression fails only because of truncated input
            try:
                zlib.decompress(binwalk.core.compat.str2bytes(data))
            except zlib.error as e:
                # Error -5, incomplete or truncated data input
                if not str(e).startswith("Error -5"):
                    result.valid = False


```

`binwalk_windows/binwalk-2.1.1/src/scripts/binida.py`:

```py
import idc
import idaapi
import binwalk

class binwalk_t(idaapi.plugin_t):
    flags = 0
    comment = "Scan the current IDB for file signatures"
    help = ""
    wanted_name = "Binwalk IDA Plugin"
    wanted_hotkey = ""

    def init(self):
        self.menu_context_1 = idaapi.add_menu_item("Search/", "binwalk opcodes", "", 0, self.opcode_scan, (None,))
        self.menu_context_2 = idaapi.add_menu_item("Search/", "binwalk signatures", "", 0, self.signature_scan, (None,))
        return idaapi.PLUGIN_KEEP

    def term(self):
        idaapi.del_menu_item(self.menu_context_1)
        idaapi.del_menu_item(self.menu_context_2)
        return None

    def run(self, arg):
        return None

    def signature_scan(self, arg):
        binwalk.scan(idc.GetIdbPath(), signature=True)

    def opcode_scan(self, arg):
        binwalk.scan(idc.GetIdbPath(), opcode=True)

def PLUGIN_ENTRY():
    return binwalk_t()


```

`binwalk_windows/binwalk-2.1.1/src/scripts/binwalk`:

```
#!/usr/bin/env python

import os
import sys

# If installed to a custom prefix directory, binwalk may not be in
# the default module search path(s). Try to resolve the prefix module
# path and make it the first entry in sys.path.
# Ensure that 'src/binwalk' becomes '.' instead of an empty string
_parent_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
for _module_path in [
    # from repo: src/scripts/ -> src/
    _parent_dir,
    # from build dir: build/scripts-3.4/ -> build/lib/
    os.path.join(_parent_dir, "lib"),
    # installed in non-default path: bin/ -> lib/python3.4/site-packages/
    os.path.join(_parent_dir,
                 "lib",
                 "python%d.%d" % (sys.version_info[0], sys.version_info[1]),
                 "site-packages")
]:
    if os.path.exists(_module_path) and _module_path not in sys.path:
        sys.path = [_module_path] + sys.path

import binwalk
import binwalk.modules

def main():
    with binwalk.Modules() as modules:
        try:
            if len(sys.argv) == 1:
                sys.stderr.write(modules.help())
                sys.exit(1)
            # If no explicit module was enabled in the command line arguments,
            # run again with the default signature scan explicitly enabled.
            elif not modules.execute():
                # Make sure the Signature module is loaded before attempting 
                # an implicit signature scan; else, the error message received
                # by the end user is not very helpful.
                if hasattr(binwalk.modules, "Signature"):
                    modules.execute(*sys.argv[1:], signature=True)
                else:
                    sys.stderr.write("Error: Signature scans not supported; ")
                    sys.stderr.write("make sure you have python-lzma installed and try again.\n")
                    sys.exit(2)
        except binwalk.ModuleException as e:
            sys.exit(3)

if __name__ == '__main__':
    try:
        # Special options for profiling the code. For debug use only.
        if '--profile' in sys.argv:
            import cProfile
            sys.argv.pop(sys.argv.index('--profile'))
            cProfile.run('main()')
        else:
            main()
    except IOError:
        pass
    except KeyboardInterrupt:
        sys.stdout.write("\n")


```

`binwalk_windows/binwalk-2.1.1/src/scripts/examples/binwalk_simple.py`:

```py
#!/usr/bin/env python

import binwalk

# Since no options are specified, they are by default taken from sys.argv.
# Effecitvely, this duplicates the functionality of the normal binwalk script.
binwalk.scan()

```

`binwalk_windows/binwalk-2.1.1/src/scripts/examples/extract_data.py`:

```py
#!/usr/bin/env python

import sys
import binwalk

# Extracts and logs
for module in binwalk.scan(*sys.argv[1:], signature=True, quiet=True, extract=True):
    print ("%s Results:" % module.name)
    for result in module.results:
        if module.extractor.output.has_key(result.file.path):
            if module.extractor.output[result.file.path].extracted.has_key(result.offset):
                print ("Extracted '%s' at offset 0x%X from '%s' to '%s'" % (result.description.split(',')[0],
                                                                            result.offset,
                                                                            result.file.path,
                                                                            str(module.extractor.output[result.file.path].extracted[result.offset])))

```

`binwalk_windows/binwalk-2.1.1/src/scripts/examples/signature_scan.py`:

```py
#!/usr/bin/env python

import sys
import binwalk

try:
    # Perform a signature scan against the files specified on the command line and suppress the usual binwalk output.
    for module in binwalk.scan(*sys.argv[1:], signature=True, quiet=True):
        print ("%s Results:" % module.name)
        for result in module.results:
            print ("\t%s    0x%.8X    %s [%s]" % (result.file.name, result.offset, result.description, str(result.valid)))
except binwalk.ModuleException as e:
    pass

```

`hexwalk/advancedsearchdialog.cpp`:

```cpp
#include "advancedsearchdialog.h"
#include "ui_advancedsearchdialog.h"
#include <QDebug>
#include <QMessageBox>
#include "resultType.h"
#include "worditemdelegate.h"
#include <QProgressDialog>
#include <QMessageBox>

AdvancedSearchDialog::AdvancedSearchDialog(QHexEdit *hexEdit, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::AdvancedSearchDialog)
{
  ui->setupUi(this);
  _hexEdit = hexEdit;
  //model = new TableModel(this);


}

AdvancedSearchDialog::~AdvancedSearchDialog()
{
  delete ui;
}

qint64 AdvancedSearchDialog::findNext()
{
    qint64 from = _hexEdit->cursorPosition() / 2;
    _findBa = getContent(ui->cbFindFormat->currentIndex(), ui->cbFind->currentText());
    qint64 idx = -1;

    if (_findBa.length() > 0)
    {
        if (ui->cbBackwards->isChecked())
            idx = _hexEdit->lastIndexOf(_findBa, from);
        else
            idx = _hexEdit->indexOf(_findBa, from,ui->cbRegex->isChecked(),ui->cbCase->isChecked());
    }
    return idx;
}

void AdvancedSearchDialog::on_pbFind_clicked()
{
    if(ui->cbBegin->isChecked() == true)
    {
        _hexEdit->setCursorPosition(0);
        ui->cbBegin->setChecked(false);
    }
    findNext();

}

QByteArray AdvancedSearchDialog::getContent(int comboIndex, const QString &input)
{
    QByteArray findBa;
    switch (comboIndex)
    {
        case 2:     // hex
            findBa = QByteArray::fromHex(input.toLatin1());
            break;
        case 0:     // text
            findBa = input.toUtf8();
            break;
        case 1:

            findBa = QByteArray::fromRawData((char*)(input.utf16()),input.length());
    }
    return findBa;
}
QString AdvancedSearchDialog::binToStr(QByteArray bin)
{
    QString outString;
    for(int i=0;i<bin.length();i++)
    {
            if(bin.at(i)<32 || uchar(bin.at(i))>127)
            {
                outString += QString(".");
            }
            else if(bin.at(i) == '<')
            {
                outString += QString("&lt;");
            }
            else if(bin.at(i) == '>')
            {
                outString += QString("&gt;");
            }
            else if(bin.at(i) == '&')
            {
                outString += QString("&amp;");
            }
            else
            {
                outString += QString(bin.at(i));
            }
    }
    return outString;
}
void AdvancedSearchDialog::findAll()
{
    progrDialog = new QProgressDialog("Task in progress...","Cancel",0,100,this);
    progrDialog->setValue(0);
    progrDialog->setModal(true);
    progrDialog->show();



    resultslist.clear();
    int ret = 1;
    Result_S result;
    int count=0;

    while(ret > 0)
    {
        ret = findNext();

        if(progrDialog->wasCanceled() == true)
        {
                break;
        }
        progrDialog->setValue(int(100.0*double(_hexEdit->cursorPosition()/2)/double(_hexEdit->getSize())));
        QCoreApplication::processEvents();

        if(ret > -1)
        {
                QByteArray preData;
                QByteArray postData;

                result.cursor=ret;
                QByteArray inData = _hexEdit->selectedDataBa();
                if(_hexEdit->cursorPosition()/2 > 8)
                {
                    preData = _hexEdit->dataAt(ret-8,8);
                }
                else
                {
                    preData = _hexEdit->dataAt(ret-(_hexEdit->cursorPosition()/2),_hexEdit->cursorPosition()/2);
                }
                qint64 remainingBytes = _hexEdit->getSize() - _hexEdit->cursorPosition()/2;
                if(remainingBytes > 8)
                {
                    postData = _hexEdit->dataAt(ret+inData.length(),8);
                }
                else {
                   postData = _hexEdit->dataAt(ret+inData.length(),remainingBytes);
                }
                if(resultslist.length() > 0)
                {
                    if(resultslist.last().cursor == result.cursor)
                    {
                       break;
                    }
                }

                result.datastr = binToStr(preData) + QString("<b>")+ binToStr(inData) + QString("</b>")+ binToStr(postData);
                result.hexdatastr = preData.toHex()+ QString("<b>") + inData.toHex() + QString("</b>")+ postData.toHex();
                resultslist.append(result);
                count++;
        }

        if(count > 512)
        {

                QMessageBox::warning(this, tr("HexWalk"),tr("Too much occurrencies found, stopping search."));
                break;
        }
    }
    setData();
    ui->resultsTableView->resizeColumnsToContents();
    ui->resultsTableView->verticalHeader()->show();
    ui->resultsTableView->setSelectionBehavior(QAbstractItemView::SelectRows);
    QCoreApplication::processEvents();

}
void AdvancedSearchDialog::on_pbFindAll_clicked()
{
    if(ui->cbBegin->isChecked() == true)
    {
        _hexEdit->setCursorPosition(0);
    }
    findAll();
}

TableModel::TableModel(QObject *parent) : QAbstractTableModel(parent)
{
}


void TableModel::populateData(const QList<Result_S> &resultlist)
{
    tm_cursor.clear();
    tm_content.clear();
    tm_contenthex.clear();

    for(int i=0;i<resultlist.count();i++)
    {
        QString cursor;
        cursor = QString("%1").arg(resultlist.at(i).cursor,4,16);
        tm_cursor.append(cursor);
        tm_content.append(resultlist.at(i).datastr);
        tm_contenthex.append(resultlist.at(i).hexdatastr);
    }




    return;
}


int TableModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return tm_cursor.length();
}

int TableModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return 3;
}

QVariant TableModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || role != Qt::DisplayRole) {
        return QVariant();
    }
    if (index.column() == 0) {
        return tm_cursor[index.row()];
    } else if (index.column() == 1) {
        return tm_content[index.row()];
    }else if (index.column() == 2) {
        return tm_contenthex[index.row()];
    }

    return QVariant();
}

QVariant TableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
        if (section == 0) {
            return QString("Cursor");
        } else if (section == 2) {
            return QString("Content(Hex)");
        }else if (section == 1) {
            return QString("Content");
        }
    }
    return QVariant();
}

void AdvancedSearchDialog::setData()
{
    progrDialog->cancel();

    try{
        if(model)
        {
            delete model;
        }
        model = new TableModel(this);

        model->populateData(resultslist);
        ui->resultsTableView->clearSpans();
        ui->resultsTableView->setModel(model);
        auto wordItemDelegate = new WordItemDelegate(this);
        ui->resultsTableView->setItemDelegate(wordItemDelegate);
    }
    catch(QException)
    {
        qInfo() <<"Exception!!\n";
    }
}

void AdvancedSearchDialog::on_resultsTableView_clicked(const QModelIndex &index)
{
    _hexEdit->indexOf("",resultslist.at(index.row()).cursor,ui->cbRegex->isChecked(),ui->cbCase->isChecked());
    _hexEdit->setCursorPosition(resultslist.at(index.row()).cursor);
    _hexEdit->indexOf(_findBa, resultslist.at(index.row()).cursor - 1,ui->cbRegex->isChecked(),ui->cbCase->isChecked());
    _hexEdit->update();

}
void TableModel::clearData()
{
    tm_cursor.clear();
    tm_content.clear();
    tm_contenthex.clear();
}
void AdvancedSearchDialog::on_pbCancel_clicked()
{

    resultslist.clear();


}


void AdvancedSearchDialog::on_cbCase_clicked()
{
    if(ui->cbCase->isChecked())
    {
        ui->cbRegex->setChecked(true);
        ui->cbBackwards->setChecked(false);
    }

}


void AdvancedSearchDialog::on_cbFindFormat_currentIndexChanged(int index)
{
    if(!ui->cbFindFormat->currentText().compare("Hex"))
    {
        ui->cbRegex->setChecked(false);
        ui->cbCase->setChecked(false);
        ui->cbRegex->setEnabled(false);
        ui->cbCase->setEnabled(false);
    }
    else
    {
        ui->cbRegex->setEnabled(true);
        ui->cbCase->setEnabled(true);
    }
}


void AdvancedSearchDialog::on_cbBackwards_clicked()
{
    if(ui->cbBackwards->isChecked())
    {
        ui->cbRegex->setChecked(false);
        ui->cbCase->setChecked(false);
        ui->cbBegin->setChecked(false);
    }

}


void AdvancedSearchDialog::on_cbBegin_clicked()
{
    if(ui->cbBegin->isChecked())
    {
        ui->cbBackwards->setChecked(false);
    }

}


void AdvancedSearchDialog::on_cbRegex_clicked()
{
    if(ui->cbRegex->isChecked())
    {
        ui->cbBackwards->setChecked(false);
    }
    else
    {
        ui->cbCase->setChecked(false);
    }
}


```

`hexwalk/advancedsearchdialog.h`:

```h
#ifndef ADVANCEDSEARCHDIALOG_H
#define ADVANCEDSEARCHDIALOG_H

#include <QDialog>
#include <QtCore>
#include <QTimer>
#include <QProgressDialog>
#include <QAbstractTableModel>
#include "../src/qhexedit.h"
#include "resultType.h"

namespace Ui {
    class AdvancedSearchDialog;
}

class FindAllWorker;

class TableModel : public QAbstractTableModel
{
    Q_OBJECT

public:
    TableModel(QObject *parent = 0);

    void populateData(const QList<Result_S> &resultsData);
    void clearData();

    int rowCount(const QModelIndex &parent = QModelIndex()) const Q_DECL_OVERRIDE;
    int columnCount(const QModelIndex &parent = QModelIndex()) const Q_DECL_OVERRIDE;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;

private:
    QList<QString> tm_cursor;
    QList<QString> tm_contenthex;
    QList<QString> tm_content;

};

class AdvancedSearchDialog : public QDialog
{
    Q_OBJECT
public:
    explicit AdvancedSearchDialog(QHexEdit *hexEdit, QWidget *parent = 0);
    ~AdvancedSearchDialog();
    qint64 findNext();
    void findAll();

    Ui::AdvancedSearchDialog *ui;


    QHexEdit *_hexEdit;
    QProgressDialog * progrDialog;

private slots:
    void on_pbFind_clicked();



    void on_resultsTableView_clicked(const QModelIndex &index);

void on_pbFindAll_clicked();
    void on_pbCancel_clicked();

void on_cbCase_clicked();

    void on_cbFindFormat_currentIndexChanged(int index);

void on_cbBackwards_clicked();

    void on_cbBegin_clicked();

void on_cbRegex_clicked();

private:
    void setData();
    QByteArray getContent(int comboIndex, const QString &input);
    qint64 replaceOccurrence(qint64 idx, const QByteArray &replaceBa);
    QByteArray _findBa;
    QList<Result_S> resultslist;
    TableModel *model = NULL;
    QString binToStr(QByteArray bin);

};



#endif // ADVANCEDSEARCHDIALOG_H

```

`hexwalk/advancedsearchdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>AdvancedSearchDialog</class>
 <widget class="QDialog" name="AdvancedSearchDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>775</width>
    <height>550</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Advanced Find</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout_3" stretch="0,0">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout_2" stretch="1,0,5">
     <item>
      <widget class="QGroupBox" name="gbFind">
       <property name="title">
        <string>Find</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout">
        <item>
         <widget class="QComboBox" name="cbFindFormat">
          <item>
           <property name="text">
            <string>UTF-8</string>
           </property>
          </item>
          <item>
           <property name="text">
            <string>UTF-16</string>
           </property>
          </item>
          <item>
           <property name="text">
            <string>Hex</string>
           </property>
          </item>
         </widget>
        </item>
        <item>
         <widget class="QComboBox" name="cbFind">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="editable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="gbOptions">
       <property name="title">
        <string>Options</string>
       </property>
       <layout class="QGridLayout" name="gridLayout" rowstretch="0,0,0,1" columnstretch="0,0" rowminimumheight="0,0,0,1" columnminimumwidth="0,0">
        <item row="3" column="0">
         <widget class="QCheckBox" name="cbBackwards">
          <property name="text">
           <string>&amp;Backwards</string>
          </property>
         </widget>
        </item>
        <item row="1" column="0">
         <widget class="QCheckBox" name="cbBegin">
          <property name="text">
           <string>Start from beginning</string>
          </property>
          <property name="checked">
           <bool>true</bool>
          </property>
         </widget>
        </item>
        <item row="2" column="0">
         <widget class="QCheckBox" name="cbRegex">
          <property name="text">
           <string>Regex</string>
          </property>
         </widget>
        </item>
        <item row="1" column="1">
         <widget class="QCheckBox" name="cbCase">
          <property name="text">
           <string>Case Insensitive</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="gbResults">
       <property name="title">
        <string>Results</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <item>
         <widget class="QTableView" name="resultsTableView">
          <property name="wordWrap">
           <bool>false</bool>
          </property>
          <attribute name="horizontalHeaderCascadingSectionResizes">
           <bool>true</bool>
          </attribute>
          <attribute name="horizontalHeaderStretchLastSection">
           <bool>true</bool>
          </attribute>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QPushButton" name="pbFind">
       <property name="text">
        <string>&amp;Find</string>
       </property>
       <property name="shortcut">
        <string>F3</string>
       </property>
       <property name="default">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pbFindAll">
       <property name="text">
        <string>Find All</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pbCancel">
       <property name="text">
        <string>&amp;Close</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="verticalSpacer">
       <property name="orientation">
        <enum>Qt::Vertical</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>20</width>
         <height>40</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>cbFind</tabstop>
  <tabstop>cbFindFormat</tabstop>
  <tabstop>cbBackwards</tabstop>
  <tabstop>pbFind</tabstop>
  <tabstop>pbCancel</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>pbCancel</sender>
   <signal>clicked()</signal>
   <receiver>AdvancedSearchDialog</receiver>
   <slot>hide()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>360</x>
     <y>134</y>
    </hint>
    <hint type="destinationlabel">
     <x>364</x>
     <y>162</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`hexwalk/binanalysisdialog.cpp`:

```cpp
#include "binanalysisdialog.h"
#include "ui_binanalysisdialog.h"
#include <QFile>
#include <QTextStream>
#include <QDebug>
#include <QProcess>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonArray>
#include <QProgressDialog>
#include <QMessageBox>


BinTableModel::BinTableModel(QObject *parent) : QAbstractTableModel(parent)
{
}


void BinTableModel::populateData(const QList<BinwalkResult_S> &resultlist)
{

    tm_cursor.clear();
    tm_content.clear();


    for(int i=0;i<resultlist.count();i++)
    {
        QString cursor;
        cursor = QString("%1").arg(resultlist.at(i).cursor,4,16);
        tm_cursor.append(cursor);
        tm_content.append(resultlist.at(i).datastr);

    }




    return;
}


int BinTableModel::rowCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return tm_cursor.length();
}

int BinTableModel::columnCount(const QModelIndex &parent) const
{
    Q_UNUSED(parent);
    return 2;
}

QVariant BinTableModel::data(const QModelIndex &index, int role) const
{
    if (!index.isValid() || role != Qt::DisplayRole) {
        return QVariant();
    }
    if (index.column() == 0) {
        return tm_cursor[index.row()];
    } else if (index.column() == 1) {
        return tm_content[index.row()];
    }

    return QVariant();
}

QVariant BinTableModel::headerData(int section, Qt::Orientation orientation, int role) const
{
    if (role == Qt::DisplayRole && orientation == Qt::Horizontal) {
        if (section == 0) {
            return QString("Cursor");
        }else if (section == 1) {
            return QString("Content");
        }
    }
    return QVariant();
}


void BinTableModel::clearData()
{
    tm_cursor.clear();
    tm_content.clear();
}

binanalysisdialog::binanalysisdialog(QHexEdit *hexEdit,QWidget *parent) :
    QDialog(parent),
    ui(new Ui::binanalysisdialog)
{
    ui->setupUi(this);
    _hexEdit = hexEdit;
}

binanalysisdialog::~binanalysisdialog()
{
    delete ui;
}


void binanalysisdialog::analyze(QString filename)
{
    QCoreApplication::processEvents();
    curFile = filename;
    BinwalkResult_S binwalkResult;
    resultslist.clear();
    QThread::msleep(200);
    QCoreApplication::processEvents();
    QProgressDialog progrDialog("Wait while binwalk is processing...","Cancel",0,0,this);
    progrDialog.setModal(true);
    progrDialog.setRange(0,0);
    progrDialog.show();

    progrDialog.setValue(0);
    QCoreApplication::processEvents();
    QProcess p;
    QStringList params;


#ifdef Q_OS_WIN
    params << "binw.py" << filename;
    p.start("python",params);
#else
    params << filename;
    p.start("binwalk",params);
#endif

    p.waitForFinished(-1);

    QString p_stdout = p.readAll();
    progrDialog.cancel();
    QStringList lines = p_stdout.split("\n");
    if(lines.length() < 3)
    {
        return;
    }
    lines.removeFirst();
    lines.removeFirst();
    lines.removeFirst();
    QString line;
    foreach(line,lines)
    {
        if(line.length()>0){
            binwalkResult.cursor = line.section(' ',1,1,QString::SectionSkipEmpty).toLong(NULL,16);
            binwalkResult.datastr = line.section(' ',2,-1,QString::SectionSkipEmpty);

            resultslist.append(binwalkResult);
        }


    }



    if(model)
    {
        delete model;
    }
    model = new BinTableModel(this);

    model->populateData(resultslist);

    ui->binwalkTableView->setModel(model);
    ui->binwalkTableView->setColumnWidth(1,750);
ui->binwalkTableView->resizeRowsToContents();
    ui->binwalkTableView->setSelectionBehavior(QAbstractItemView::SelectRows);

}

void binanalysisdialog::on_binwalkTableView_clicked(const QModelIndex &index)
{
    _hexEdit->indexOf("",resultslist.at(index.row()).cursor,false,false);
    _hexEdit->setCursorPosition(resultslist.at(index.row()).cursor*2);
    _hexEdit->update();
}


void binanalysisdialog::on_closeBtn_clicked()
{
    this->close();
}


void binanalysisdialog::on_extractAllBtn_clicked()
{

    QProgressDialog progrDialog("Wait while binwalk is extracting data...","Cancel",0,0,this);
    progrDialog.setModal(true);
    progrDialog.setRange(0,0);
    progrDialog.show();
    QApplication::processEvents();
    QProcess p;
    QStringList params;

#ifdef Q_OS_WIN
    params << "binw.py"<<"-e" << curFile;
    p.start("python",params);
#else
    params << "-e" << curFile;
    p.start("binwalk",params);
#endif

    p.waitForFinished(-1);
    QString p_stdout = p.readAll();
    progrDialog.cancel();
}


```

`hexwalk/binanalysisdialog.h`:

```h
#ifndef BINANALYSISDIALOG_H
#define BINANALYSISDIALOG_H

#include <QDialog>
#include <QAbstractTableModel>
#include "resultType.h"
#include "../src/qhexedit.h"

namespace Ui {
class binanalysisdialog;
}

class BinTableModel : public QAbstractTableModel
{
    Q_OBJECT

public:
    BinTableModel(QObject *parent = 0);

    void populateData(const QList<BinwalkResult_S> &resultsData);
    void clearData();

    int rowCount(const QModelIndex &parent = QModelIndex()) const Q_DECL_OVERRIDE;
    int columnCount(const QModelIndex &parent = QModelIndex()) const Q_DECL_OVERRIDE;

    QVariant data(const QModelIndex &index, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;
    QVariant headerData(int section, Qt::Orientation orientation, int role = Qt::DisplayRole) const Q_DECL_OVERRIDE;

private:
    QList<QString> tm_cursor;
    QList<QString> tm_content;

};


class binanalysisdialog : public QDialog
{
    Q_OBJECT

public:
    explicit binanalysisdialog(QHexEdit *hexEdit,QWidget *parent = nullptr);
    ~binanalysisdialog();
    void analyze(QString filename);
     QHexEdit *_hexEdit;

private slots:
    void on_binwalkTableView_clicked(const QModelIndex &index);

    void on_closeBtn_clicked();

    void on_extractAllBtn_clicked();

private:
    Ui::binanalysisdialog *ui;
    QList<BinwalkResult_S> resultslist;
    BinTableModel *model = NULL;
    QString curFile;
};

#endif // BINANALYSISDIALOG_H

```

`hexwalk/binanalysisdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>binanalysisdialog</class>
 <widget class="QDialog" name="binanalysisdialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1024</width>
    <height>378</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>1024</width>
    <height>0</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>1024</width>
    <height>16777215</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Binary Analysis</string>
  </property>
  <widget class="QTableView" name="binwalkTableView">
   <property name="geometry">
    <rect>
     <x>0</x>
     <y>10</y>
     <width>881</width>
     <height>361</height>
    </rect>
   </property>
  </widget>
  <widget class="QPushButton" name="extractAllBtn">
   <property name="geometry">
    <rect>
     <x>910</x>
     <y>10</y>
     <width>93</width>
     <height>29</height>
    </rect>
   </property>
   <property name="text">
    <string>Extract All</string>
   </property>
  </widget>
  <widget class="QPushButton" name="closeBtn">
   <property name="geometry">
    <rect>
     <x>910</x>
     <y>50</y>
     <width>93</width>
     <height>29</height>
    </rect>
   </property>
   <property name="text">
    <string>Close</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`hexwalk/converterdialog.cpp`:

```cpp
#include "converterdialog.h"
#include "ui_converterdialog.h"

ConverterDialog::ConverterDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::ConverterDialog)
{
    ui->setupUi(this);
    binValue = QString("0");
    hexValue = QString("0");
    decValue = QString("0");
    ui->hexTextEdit->setText(hexValue);
    ui->decTextEdit->setText(decValue);
    ui->binTextEdit->setText(binValue);
}

ConverterDialog::~ConverterDialog()
{
    delete ui;
}

void ConverterDialog::on_decTextEdit_textChanged()
{
    if(decValue != ui->decTextEdit->toPlainText())
    {
        QString check = ui->decTextEdit->toPlainText().replace(" ","");
        int i;
        bool good = true;
        if(check.length())
        {
            for(i=0;i<check.length();i++)
            {
                if(check.at(i) < 0x30 || check.at(i) >0x39)
                {
                    good = false;
                    break;
                }
            }

            if(ui->decTextEdit->toPlainText().length() <= 16 && good == true)
            {
                decValue = ui->decTextEdit->toPlainText();
                hexValue = QString("%1").arg(decValue.toLongLong(),1,16);
                binValue = QString("%1").arg(decValue.toLongLong(),1,2);
                blockSignals(true);
                ui->hexTextEdit->setText(hexValue);
                ui->binTextEdit->setText(binValue);
                blockSignals(false);
            }
            else
        {
            blockSignals(true);
            ui->decTextEdit->setText(decValue);
            blockSignals(false);
        }
        }
    }


}


void ConverterDialog::on_hexTextEdit_textChanged()
{

   if(hexValue != ui->hexTextEdit->toPlainText())
    {
        QString check = ui->hexTextEdit->toPlainText();
        int i;
        bool good = true;
        if(check.length()){
            for(i=0;i<check.length();i++)
            {
            if(check.at(i) < 0x30 || (check.at(i) >0x39 && check.at(i) < 0x41) || (check.at(i)>0x46 && check.at(i) < 0x61) ||(check.at(i)> 0x66))
                {
                    good = false;
                    break;
                }
            }

            if(ui->hexTextEdit->toPlainText().length() <= 16 && good == true)
            {
                hexValue = ui->hexTextEdit->toPlainText();
                decValue = QString("%1").arg(hexValue.toLongLong(NULL,16),1,10);
                binValue = QString("%1").arg(hexValue.toLongLong(NULL,16),1,2);
                blockSignals(true);
                ui->decTextEdit->setText(decValue);
                ui->binTextEdit->setText(binValue);
                blockSignals(false);
            }
            else
    {
                blockSignals(true);
        ui->hexTextEdit->setText(hexValue);
                blockSignals(false);
    }
        }
    }

}


void ConverterDialog::on_binTextEdit_textChanged()
{
    if(binValue != ui->binTextEdit->toPlainText())
    {
        QString check = ui->binTextEdit->toPlainText();
        int i;
        bool good = true;
        if(check.length()){
    for(i=0;i<check.length();i++)
    {
                if(check.at(i) != 0x30 && check.at(i) != 0x31)
                {
                    good = false;
                    break;
                }
    }

    if(ui->binTextEdit->toPlainText().length() < 64 && good == true)
    {
                binValue = ui->binTextEdit->toPlainText();
                decValue = QString("%1").arg(binValue.toLongLong(NULL,2),1,10);
                hexValue = QString("%1").arg(binValue.toLongLong(NULL,2),1,16);
                blockSignals(true);
                ui->decTextEdit->setText(decValue);
                ui->hexTextEdit->setText(hexValue);
                blockSignals(false);
    }
    else
    {
                blockSignals(true);
                ui->binTextEdit->setText(binValue);
                blockSignals(false);
    }
        }
    }
}


```

`hexwalk/converterdialog.h`:

```h
#ifndef CONVERTERDIALOG_H
#define CONVERTERDIALOG_H

#include <QDialog>

namespace Ui {
class ConverterDialog;
}

class ConverterDialog : public QDialog
{
    Q_OBJECT

public:
    explicit ConverterDialog(QWidget *parent = nullptr);
    ~ConverterDialog();

private slots:
    void on_decTextEdit_textChanged();

    void on_hexTextEdit_textChanged();

    void on_binTextEdit_textChanged();

private:
    Ui::ConverterDialog *ui;
    QString binValue;
    QString decValue;
    QString hexValue;
};

#endif // CONVERTERDIALOG_H

```

`hexwalk/converterdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>ConverterDialog</class>
 <widget class="QDialog" name="ConverterDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>624</width>
    <height>215</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Converter</string>
  </property>
  <widget class="QDialogButtonBox" name="buttonBox">
   <property name="geometry">
    <rect>
     <x>30</x>
     <y>180</y>
     <width>341</width>
     <height>32</height>
    </rect>
   </property>
   <property name="orientation">
    <enum>Qt::Horizontal</enum>
   </property>
   <property name="standardButtons">
    <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
   </property>
  </widget>
  <widget class="QTextEdit" name="decTextEdit">
   <property name="geometry">
    <rect>
     <x>130</x>
     <y>50</y>
     <width>471</width>
     <height>31</height>
    </rect>
   </property>
   <property name="acceptRichText">
    <bool>false</bool>
   </property>
  </widget>
  <widget class="QLabel" name="label">
   <property name="geometry">
    <rect>
     <x>50</x>
     <y>60</y>
     <width>63</width>
     <height>20</height>
    </rect>
   </property>
   <property name="text">
    <string>Decimal:</string>
   </property>
  </widget>
  <widget class="QTextEdit" name="hexTextEdit">
   <property name="geometry">
    <rect>
     <x>130</x>
     <y>90</y>
     <width>471</width>
     <height>31</height>
    </rect>
   </property>
  </widget>
  <widget class="QLabel" name="label_2">
   <property name="geometry">
    <rect>
     <x>20</x>
     <y>100</y>
     <width>101</width>
     <height>20</height>
    </rect>
   </property>
   <property name="text">
    <string>Hexadecimal:</string>
   </property>
  </widget>
  <widget class="QTextEdit" name="binTextEdit">
   <property name="geometry">
    <rect>
     <x>130</x>
     <y>130</y>
     <width>471</width>
     <height>31</height>
    </rect>
   </property>
  </widget>
  <widget class="QLabel" name="label_4">
   <property name="geometry">
    <rect>
     <x>60</x>
     <y>140</y>
     <width>51</width>
     <height>20</height>
    </rect>
   </property>
   <property name="text">
    <string>Binary:</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>ConverterDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>ConverterDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`hexwalk/entropychart.cpp`:

```cpp
#include "entropychart.h"

EntropyChart::EntropyChart(QChart * chart,QWidget *parent):
    QChartView(chart,parent)
{

}

void EntropyChart::mousePressEvent(QMouseEvent * event){
    auto curPoint = QCursor::pos();
    curPoint = this->mapFromGlobal(curPoint);
    auto pickVal = this->mapToScene(curPoint);
    pickVal = this->chart()->mapFromScene(curPoint);
    pickVal = this->chart()->mapToValue(curPoint,this->chart()->series().at(0));

    emit mousePressed(qint64(pickVal.x()));
    QChartView::mousePressEvent(event);
}

```

`hexwalk/entropychart.h`:

```h
#ifndef ENTROPYCHART_H
#define ENTROPYCHART_H
#include <QtCharts>
#include <QChartView>
#include <QRubberBand>
QT_CHARTS_USE_NAMESPACE
class EntropyChart : public QChartView
{
Q_OBJECT
public:
    explicit EntropyChart(QChart *chart,QWidget *parent = nullptr);

signals:
    void mousePressed(qint64 value);
protected:
    void mousePressEvent(QMouseEvent *event);



};

#endif // ENTROPYCHART_H

```

`hexwalk/entropydialog.cpp`:

```cpp
#include "entropydialog.h"
#include "ui_entropydialog.h"
#include <QLineSeries>
#include <QChart>

EntropyDialog::EntropyDialog(QHexEdit * hexedit,QWidget *parent) :
    QDialog(parent),
    ui(new Ui::EntropyDialog)
{
    _hexed = hexedit;
    ui->setupUi(this);

}
double EntropyDialog::blockEntropy(QByteArray * data)
{
    int seen[256]={0};
    double p_x;
    double entropy = 0;
    for(int i=0;i<data->length();i++){
        seen[uchar(data->at(i))]++;
    }

    for(int i=0;i<256;i++){
        p_x = double(seen[i])/data->length();
        if(seen[i] > 0)
       {
           entropy -= p_x*log2(p_x);
       }
    }

    return entropy/8;

}
void EntropyDialog::calculate()
{
    qint64 cursor = 0;
    qint64 dataSize = 1024;
    QLineSeries *series = new QLineSeries();
    progrDialog = new QProgressDialog("Entropy calculation in progress...","Cancel",0,100,this);
    progrDialog->setValue(0);
    progrDialog->show();

    while(cursor < _hexed->getSize())
    {
       dataSize = 1024;
       if(dataSize > (_hexed->getSize()-cursor))
       {
           dataSize = (_hexed->getSize()-cursor);
       }
       QByteArray data = _hexed->dataAt(cursor,dataSize);
       series->append(double(cursor),blockEntropy(&data));
       cursor+=dataSize;
       progrDialog->setValue(int(100.0*(double(cursor)/double(_hexed->getSize()))));
       QCoreApplication::processEvents();
       if(progrDialog->wasCanceled())
           break;
    }

    progrDialog->cancel();
    series->setColor(Qt::green);

    QChart *chart = new QChart();
    chart->legend()->hide();
    chart->addSeries(series);
    chart->createDefaultAxes();
    chart->axes(Qt::Vertical).back()->setRange(0.0,1.1);
    chart->axes(Qt::Vertical).back()->setLabelsBrush(QBrush(QColor("lightgray")));
    chart->axes(Qt::Horizontal).back()->setLabelsBrush(QBrush(QColor("lightgray")));
    chart->setTitle("Entropy chart");

    chart->setBackgroundBrush(QBrush(QColor("black")));
    chart->setTitleBrush(QBrush(QColor("lightgray")));
    entropyView = new EntropyChart(chart,this);
    entropyView->setRenderHint(QPainter::Antialiasing);

    QLayoutItem *item;

    while((item=ui->verticalLayout->takeAt(0)) != NULL)
    {
       delete item;
    }
    ui->verticalLayout->addWidget(entropyView);
    connect(entropyView,SIGNAL(mousePressed(qint64)),this,SLOT(mousePressed(qint64)));

}

void EntropyDialog::mousePressed(qint64 value)
{
    _hexed->setCursorPosition(2*value);
    _hexed->ensureVisible();
}
EntropyDialog::~EntropyDialog()
{

    delete ui;
}



void EntropyDialog::on_buttonBox_clicked(QAbstractButton *button)
{

}


```

`hexwalk/entropydialog.h`:

```h
#ifndef ENTROPYDIALOG_H
#define ENTROPYDIALOG_H

#include <QDialog>
#include <QtCharts>
#include <QProgressDialog>
#include "../src/qhexedit.h"
#include "entropychart.h"

namespace Ui {
class EntropyDialog;
}

class EntropyDialog : public QDialog
{
    Q_OBJECT

public:
    explicit EntropyDialog(QHexEdit * hexedit,QWidget *parent = nullptr);
    ~EntropyDialog();
    void calculate();
public slots:
    void mousePressed(qint64 value);
private slots:
    void on_buttonBox_clicked(QAbstractButton *button);

private:
    Ui::EntropyDialog *ui;
    QHexEdit * _hexed;
    double blockEntropy(QByteArray * data);
    EntropyChart *entropyView;
    QProgressDialog *progrDialog;
};

#endif // ENTROPYDIALOG_H

```

`hexwalk/entropydialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>EntropyDialog</class>
 <widget class="QDialog" name="EntropyDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>752</width>
    <height>564</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Entropy Analysis</string>
  </property>
  <widget class="QDialogButtonBox" name="buttonBox">
   <property name="geometry">
    <rect>
     <x>390</x>
     <y>520</y>
     <width>341</width>
     <height>32</height>
    </rect>
   </property>
   <property name="orientation">
    <enum>Qt::Horizontal</enum>
   </property>
   <property name="standardButtons">
    <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
   </property>
  </widget>
  <widget class="QWidget" name="verticalLayoutWidget">
   <property name="geometry">
    <rect>
     <x>19</x>
     <y>29</y>
     <width>691</width>
     <height>471</height>
    </rect>
   </property>
   <layout class="QVBoxLayout" name="verticalLayout"/>
  </widget>
 </widget>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>EntropyDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>248</x>
     <y>254</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>EntropyDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>316</x>
     <y>260</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>274</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`hexwalk/hashdialog.cpp`:

```cpp
#include "hashdialog.h"
#include "ui_hashdialog.h"
#include <QFile>
#include <QCryptographicHash>
#include <QDebug>
HashDialog::HashDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::HashDialog)
{
    ui->setupUi(this);
}

HashDialog::~HashDialog()
{
    delete ui;
}

void HashDialog::calculate(QString filepath)
{
    QFile in(filepath);
    haltCalc = false;
    ui->md5Lbl->setText("");
    ui->sha1Lbl->setText("");
    ui->sha256Lbl->setText("");
    if (in.open(QIODevice::ReadOnly)) {
        qint64 fileSize = in.size();
        ui->progressBar->setMinimum(0);
        ui->progressBar->setMaximum(100);
        ui->progressBar->setValue(0);
        ui->progressBar->show();
        QCryptographicHash hashmd5(QCryptographicHash::Md5);
        QCryptographicHash hashsha1(QCryptographicHash::Sha1);
        QCryptographicHash hashsha256(QCryptographicHash::Sha256);
        hashmd5.reset();
        hashsha1.reset();
        hashsha256.reset();
        char buf[4096];
        qint64 bytesRead;
        qint64 totalBytes = 0;
        while ((bytesRead = in.read(buf, 4096)) > 0) {
            if(haltCalc == true)
            {
                break;
            }
            totalBytes+=bytesRead;
            ui->progressBar->setValue(100.0*totalBytes/fileSize);
            hashmd5.addData(buf, bytesRead);
            hashsha1.addData(buf, bytesRead);
            hashsha256.addData(buf, bytesRead);
            QCoreApplication::processEvents();

        }
        ui->progressBar->hide();
        if(haltCalc == false)
        {
        ui->md5Lbl->setText(hashmd5.result().toHex());
        ui->sha1Lbl->setText(hashsha1.result().toHex());
        ui->sha256Lbl->setText(hashsha256.result().toHex());
        }
        else
        {
        haltCalc = false;
        }

        in.close();
    }
}

void HashDialog::on_pushButton_clicked()
{
    haltCalc = true;
}


void HashDialog::on_pushButton_2_clicked()
{
    haltCalc = true;
    this->hide();
}


```

`hexwalk/hashdialog.h`:

```h
#ifndef HASHDIALOG_H
#define HASHDIALOG_H

#include <QDialog>

namespace Ui {
class HashDialog;
}

class HashDialog : public QDialog
{
    Q_OBJECT

public:
    explicit HashDialog(QWidget *parent = nullptr);
    ~HashDialog();
    void calculate(QString curFile);

private slots:
    void on_pushButton_clicked();

    void on_pushButton_2_clicked();

private:
    Ui::HashDialog *ui;
    bool haltCalc;
};

#endif // HASHDIALOG_H

```

`hexwalk/hashdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>HashDialog</class>
 <widget class="QDialog" name="HashDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>800</width>
    <height>230</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>800</width>
    <height>230</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>800</width>
    <height>230</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Hash Calculator</string>
  </property>
  <widget class="QLabel" name="label">
   <property name="geometry">
    <rect>
     <x>40</x>
     <y>30</y>
     <width>41</width>
     <height>18</height>
    </rect>
   </property>
   <property name="text">
    <string>MD5:</string>
   </property>
  </widget>
  <widget class="QLabel" name="label_2">
   <property name="geometry">
    <rect>
     <x>40</x>
     <y>70</y>
     <width>41</width>
     <height>18</height>
    </rect>
   </property>
   <property name="text">
    <string>SHA1:</string>
   </property>
  </widget>
  <widget class="QLabel" name="label_3">
   <property name="geometry">
    <rect>
     <x>40</x>
     <y>110</y>
     <width>67</width>
     <height>18</height>
    </rect>
   </property>
   <property name="text">
    <string>SHA256:</string>
   </property>
  </widget>
  <widget class="QLabel" name="md5Lbl">
   <property name="geometry">
    <rect>
     <x>110</x>
     <y>27</y>
     <width>681</width>
     <height>21</height>
    </rect>
   </property>
   <property name="palette">
    <palette>
     <active>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </active>
     <inactive>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </inactive>
     <disabled>
      <colorrole role="Base">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </disabled>
    </palette>
   </property>
   <property name="autoFillBackground">
    <bool>false</bool>
   </property>
   <property name="frameShape">
    <enum>QFrame::Box</enum>
   </property>
   <property name="frameShadow">
    <enum>QFrame::Sunken</enum>
   </property>
   <property name="lineWidth">
    <number>1</number>
   </property>
   <property name="text">
    <string/>
   </property>
   <property name="textInteractionFlags">
    <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
   </property>
  </widget>
  <widget class="QLabel" name="sha1Lbl">
   <property name="geometry">
    <rect>
     <x>110</x>
     <y>67</y>
     <width>681</width>
     <height>21</height>
    </rect>
   </property>
   <property name="palette">
    <palette>
     <active>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </active>
     <inactive>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </inactive>
     <disabled>
      <colorrole role="Base">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </disabled>
    </palette>
   </property>
   <property name="autoFillBackground">
    <bool>false</bool>
   </property>
   <property name="frameShape">
    <enum>QFrame::Box</enum>
   </property>
   <property name="frameShadow">
    <enum>QFrame::Sunken</enum>
   </property>
   <property name="text">
    <string/>
   </property>
   <property name="textInteractionFlags">
    <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
   </property>
  </widget>
  <widget class="QLabel" name="sha256Lbl">
   <property name="geometry">
    <rect>
     <x>110</x>
     <y>107</y>
     <width>681</width>
     <height>21</height>
    </rect>
   </property>
   <property name="palette">
    <palette>
     <active>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </active>
     <inactive>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </inactive>
     <disabled>
      <colorrole role="Base">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
      <colorrole role="Window">
       <brush brushstyle="SolidPattern">
        <color alpha="255">
         <red>255</red>
         <green>255</green>
         <blue>255</blue>
        </color>
       </brush>
      </colorrole>
     </disabled>
    </palette>
   </property>
   <property name="autoFillBackground">
    <bool>false</bool>
   </property>
   <property name="frameShape">
    <enum>QFrame::Box</enum>
   </property>
   <property name="frameShadow">
    <enum>QFrame::Sunken</enum>
   </property>
   <property name="text">
    <string/>
   </property>
   <property name="textInteractionFlags">
    <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByMouse</set>
   </property>
  </widget>
  <widget class="QProgressBar" name="progressBar">
   <property name="geometry">
    <rect>
     <x>110</x>
     <y>140</y>
     <width>681</width>
     <height>23</height>
    </rect>
   </property>
   <property name="value">
    <number>24</number>
   </property>
  </widget>
  <widget class="QPushButton" name="pushButton">
   <property name="geometry">
    <rect>
     <x>20</x>
     <y>180</y>
     <width>88</width>
     <height>26</height>
    </rect>
   </property>
   <property name="text">
    <string>Stop</string>
   </property>
  </widget>
  <widget class="QPushButton" name="pushButton_2">
   <property name="geometry">
    <rect>
     <x>700</x>
     <y>180</y>
     <width>88</width>
     <height>26</height>
    </rect>
   </property>
   <property name="text">
    <string>Close</string>
   </property>
  </widget>
 </widget>
 <resources/>
 <connections/>
</ui>

```

`hexwalk/hexwalk.pro`:

```pro
QT += widgets charts
CONFIG += static
RC_ICONS = images/hexwalk.ico
QMAKE_LFLAGS += -no-pie
HEADERS = \
    advancedsearchdialog.h \
    binanalysisdialog.h \
    converterdialog.h \
    entropychart.h \
    entropydialog.h \
    hashdialog.h \
    hexwalkmain.h \
    optionsdialog.h \
    ../src/qhexedit.h \
    ../src/chunks.h \
    ../src/commands.h \
    resultType.h \
    searchdialog.h \
    worditemdelegate.h


SOURCES = \
    advancedsearchdialog.cpp \
    binanalysisdialog.cpp \
    converterdialog.cpp \
    entropychart.cpp \
    entropydialog.cpp \
    hashdialog.cpp \
    hexwalkmain.cpp \
    main.cpp \
    optionsdialog.cpp \
    ../src/qhexedit.cpp \
    ../src/chunks.cpp \
    ../src/commands.cpp \
    searchdialog.cpp \
    worditemdelegate.cpp

RESOURCES = \
    hexwalk.qrc

FORMS += \
    advancedsearchdialog.ui \
    binanalysisdialog.ui \
    converterdialog.ui \
    entropydialog.ui \
    hashdialog.ui \
    hexwalkmain.ui \
    optionsdialog.ui \
    searchdialog.ui

TRANSLATIONS += \
    translations/hexwalk_cs.ts \
    translations/hexwalk_de.ts

DEFINES += QHEXEDIT_EXPORTS

```

`hexwalk/hexwalk.qrc`:

```qrc
<RCC>
    <qresource prefix="/">
        <file>images/save.png</file>
        <file>images/undo.png</file>
        <file>images/redo.png</file>
        <file>images/find.png</file>
        <file>images/hexwalk.ico</file>
        <file>images/binary.png</file>
        <file>images/entropy.png</file>
        <file>images/open.png</file>
        <file>fonts/Helvetica.ttf</file>
        <file>fonts/Courier.ttf</file>
    </qresource>
</RCC>

```

`hexwalk/hexwalkmain.cpp`:

```cpp
#include <QFileDialog>
#include <QMessageBox>
#include <QApplication>
#include <QStatusBar>
#include <QLabel>
#include <QAction>
#include <QMenuBar>
#include <QToolBar>
#include <QColorDialog>
#include <QFontDialog>
#include <QDragEnterEvent>
#include <QDropEvent>

#include "hexwalkmain.h"
#include "ui_hexwalkmain.h"

HexWalkMain::HexWalkMain(QWidget *parent) :
    QMainWindow(parent),
    ui(new Ui::HexWalkMain)
{
    ui->setupUi(this);
    setAcceptDrops( true );
    init();
    setCurrentFile("");
}

void HexWalkMain::init()
{
    setAttribute(Qt::WA_DeleteOnClose);

    isUntitled = true;

    hexEdit = ui->widget;
    connect(hexEdit, SIGNAL(overwriteModeChanged(bool)), this, SLOT(setOverwriteMode(bool)));
    connect(hexEdit, SIGNAL(dataChanged()), this, SLOT(dataChanged()));
    searchDialog = new SearchDialog(hexEdit, this);
    advancedSearchDialog = new AdvancedSearchDialog(hexEdit,this);
    entropyDialog = new EntropyDialog(hexEdit,this);
    analysisDialog = new binanalysisdialog(hexEdit,this);
    converterDialog = new ConverterDialog(this);
    hashDialog = new HashDialog(this);

    createActions();
    createMenus();
    createToolBars();
    createStatusBar();

    readSettings();


    setUnifiedTitleAndToolBarOnMac(true);
}
HexWalkMain::~HexWalkMain()
{
    delete ui;
}

void HexWalkMain::createMenus()
{
    fileMenu = menuBar()->addMenu(tr("&File"));
    fileMenu->addAction(openAct);
    fileMenu->addAction(saveAct);
    fileMenu->addAction(saveAsAct);
    fileMenu->addAction(saveReadable);

    recentFilesMenu = fileMenu->addMenu(tr("Open Recent"));
    for(auto i = 0; i < 5; ++i)
        recentFilesMenu->addAction(recentFileActionList.at(i));

    updateRecentActionList();
    fileMenu->addMenu(recentFilesMenu);

    fileMenu->addSeparator();
    fileMenu->addAction(exitAct);

    editMenu = menuBar()->addMenu(tr("&Edit"));
    editMenu->addAction(undoAct);
    editMenu->addAction(redoAct);
    editMenu->addAction(saveSelectionReadable);
    editMenu->addSeparator();
    editMenu->addAction(advancedFindAct);
    editMenu->addAction(findAct);
    editMenu->addAction(overwriteAct);




    analysisMenu = menuBar()->addMenu(tr("&Analysis"));
    analysisMenu->addAction(entropyAct);
    analysisMenu->addAction(binaryAct);

    toolsMenu = menuBar()->addMenu(tr("&Tools"));
    toolsMenu->addAction(converterAct);
    toolsMenu->addAction(hashAct);

    helpMenu = menuBar()->addMenu(tr("&Help"));
    helpMenu->addAction(aboutAct);
}

void HexWalkMain::createStatusBar()
{
    // Address Label
    lbAddressName = new QLabel();
    lbAddressName->setText(tr("Address:"));
    statusBar()->addPermanentWidget(lbAddressName);
    lbAddress = new QLabel();
    lbAddress->setFrameShape(QFrame::Panel);
    lbAddress->setFrameShadow(QFrame::Sunken);
    lbAddress->setMinimumWidth(100);
    statusBar()->addPermanentWidget(lbAddress);
    connect(hexEdit, SIGNAL(currentAddressChanged(qint64)), this, SLOT(setAddress(qint64)));

    // Size Label
    lbSizeName = new QLabel();
    lbSizeName->setText(tr("Size:"));
    statusBar()->addPermanentWidget(lbSizeName);
    lbSize = new QLabel();
    lbSize->setFrameShape(QFrame::Panel);
    lbSize->setFrameShadow(QFrame::Sunken);
    lbSize->setMinimumWidth(70);
    statusBar()->addPermanentWidget(lbSize);
    connect(hexEdit, SIGNAL(currentSizeChanged(qint64)), this, SLOT(setSize(qint64)));

    // Overwrite Mode Label
    lbOverwriteModeName = new QLabel();
    lbOverwriteModeName->setText(tr("Mode:"));
    statusBar()->addPermanentWidget(lbOverwriteModeName);
    lbOverwriteMode = new QLabel();
    lbOverwriteMode->setFrameShape(QFrame::Panel);
    lbOverwriteMode->setFrameShadow(QFrame::Sunken);
    lbOverwriteMode->setMinimumWidth(70);
    statusBar()->addPermanentWidget(lbOverwriteMode);
    setOverwriteMode(hexEdit->overwriteMode());

    statusBar()->showMessage(tr("Ready"), 2000);
}

void HexWalkMain::createActions()
{
    openAct = new QAction(QIcon(":/images/open.png"), tr("&Open..."), this);
    openAct->setShortcuts(QKeySequence::Open);
    openAct->setStatusTip(tr("Open an existing file"));
    connect(openAct, SIGNAL(triggered()), this, SLOT(open()));

    saveAct = new QAction(QIcon(":/images/save.png"), tr("&Save"), this);
    saveAct->setShortcuts(QKeySequence::Save);
    saveAct->setStatusTip(tr("Save the document to disk"));
    connect(saveAct, SIGNAL(triggered()), this, SLOT(save()));

    saveAsAct = new QAction(tr("Save &As..."), this);
    saveAsAct->setShortcuts(QKeySequence::SaveAs);
    saveAsAct->setStatusTip(tr("Save the document under a new name"));
    connect(saveAsAct, SIGNAL(triggered()), this, SLOT(saveAs()));

    saveReadable = new QAction(tr("Save &Readable..."), this);
    saveReadable->setStatusTip(tr("Save document in readable form"));
    connect(saveReadable, SIGNAL(triggered()), this, SLOT(saveToReadableFile()));

    exitAct = new QAction(tr("E&xit"), this);
    exitAct->setShortcuts(QKeySequence::Quit);
    exitAct->setStatusTip(tr("Exit the application"));
    connect(exitAct, SIGNAL(triggered()), qApp, SLOT(closeAllWindows()));

    undoAct = new QAction(QIcon(":/images/undo.png"), tr("&Undo"), this);
    undoAct->setShortcuts(QKeySequence::Undo);
    connect(undoAct, SIGNAL(triggered()), hexEdit, SLOT(undo()));

    redoAct = new QAction(QIcon(":/images/redo.png"), tr("&Redo"), this);
    redoAct->setShortcuts(QKeySequence::Redo);
    connect(redoAct, SIGNAL(triggered()), hexEdit, SLOT(redo()));

    saveSelectionReadable = new QAction(tr("&Save Selection Readable..."), this);
    saveSelectionReadable->setStatusTip(tr("Save selection in readable form"));
    connect(saveSelectionReadable, SIGNAL(triggered()), this, SLOT(saveSelectionToReadableFile()));

    aboutAct = new QAction(tr("&About"), this);
    aboutAct->setStatusTip(tr("Show the application's About box"));
    connect(aboutAct, SIGNAL(triggered()), this, SLOT(about()));

    findAct = new QAction(tr("&Find/Replace"), this);
    findAct->setShortcuts(QKeySequence::FindPrevious);
    findAct->setStatusTip(tr("Show the Dialog for finding and replacing"));
    connect(findAct, SIGNAL(triggered()), this, SLOT(showSearchDialog()));

    overwriteAct = new QAction(tr("&Overwrite/Insert mode"), this);
    overwriteAct->setShortcut(QKeySequence(Qt::Key_O));
    overwriteAct->setStatusTip(tr("Toggle overwrite/insert mode"));
    connect(overwriteAct, SIGNAL(triggered()), this, SLOT(toggleOverwriteMode()));

    findNextAct = new QAction(tr("Find &next"), this);
    findNextAct->setShortcuts(QKeySequence::FindNext);
    findNextAct->setStatusTip(tr("Find next occurrence of the searched pattern"));
    connect(findNextAct, SIGNAL(triggered()), this, SLOT(findNext()));

    advancedFindAct = new QAction(QIcon(":/images/find.png"),tr("Advanced Find"), this);
    advancedFindAct->setShortcuts(QKeySequence::Find);
    advancedFindAct->setStatusTip(tr("Advanced find tool"));
    connect(advancedFindAct, SIGNAL(triggered()), this, SLOT(showAdvancedSearchDialog()));

    entropyAct = new QAction(QIcon(":/images/entropy.png"),tr("Entropy"), this);
    entropyAct->setShortcuts(QKeySequence::Find);
    entropyAct->setStatusTip(tr("Calculate entropy of file"));
    connect(entropyAct, SIGNAL(triggered()), this, SLOT(showEntropyDialog()));

    binaryAct = new QAction(QIcon(":/images/binary.png"),tr("Binary Analysis"), this);
    binaryAct->setStatusTip(tr("make binary analysis with Binwalk"));
    connect(binaryAct, SIGNAL(triggered()), this, SLOT(showBinaryDialog()));

    converterAct = new QAction(tr("Number Converter"), this);
    converterAct->setStatusTip(tr("Useful number converter"));
    connect(converterAct, SIGNAL(triggered()), this, SLOT(showConverterDialog()));

    hashAct = new QAction(tr("Hash Calculator"), this);
    hashAct->setStatusTip(tr("Hash Calculator"));
    connect(hashAct, SIGNAL(triggered()), this, SLOT(showHashDialog()));

    QAction* recentFileAction = 0;
    for(auto i = 0; i < 5; ++i){
        recentFileAction = new QAction(this);
        recentFileAction->setVisible(false);
        connect(recentFileAction, SIGNAL(triggered()),this, SLOT(openRecent()));
        recentFileActionList.append(recentFileAction);
    }
}
void HexWalkMain::toggleOverwriteMode(){
    if(hexEdit->overwriteMode() == true)
    {
        hexEdit->setOverwriteMode(false);
    }
    else
    {
        hexEdit->setOverwriteMode(true);
    }
}
void HexWalkMain::openRecent(){
    QAction *action = qobject_cast<QAction *>(sender());
    if (action)
        loadFile(action->data().toString());
}
void HexWalkMain::createToolBars()
{
    fileToolBar = addToolBar(tr("File"));
    fileToolBar->addAction(openAct);
    fileToolBar->addAction(saveAct);
    editToolBar = addToolBar(tr("Edit"));
    editToolBar->addAction(undoAct);
    editToolBar->addAction(redoAct);
    editToolBar->addAction(advancedFindAct);
    analysisToolBar = addToolBar(tr("Analysis"));
    analysisToolBar->addAction(entropyAct);
    analysisToolBar->addAction(binaryAct);
    //infoToolBar = addToolBar(tr("Info"));

}

void HexWalkMain::setCurrentFile(const QString &fileName)
{
    curFile = QFileInfo(fileName).canonicalFilePath();
    isUntitled = fileName.isEmpty();
    setWindowModified(false);
    if (fileName.isEmpty())
        setWindowFilePath("HexWalk");
    else
        setWindowFilePath(curFile + " - HexWalk");
}

void HexWalkMain::loadFile(const QString &fileName)
{
    file.setFileName(fileName);
    if (!hexEdit->setData(file)) {
        QMessageBox::warning(this, tr("HexWalk"),
                             tr("Cannot read file %1:\n%2.")
                                 .arg(fileName)
                                 .arg(file.errorString()));
        return;
    }
    setCurrentFile(fileName);
    statusBar()->showMessage(tr("File loaded"), 2000);
}

/*****************************************************************************/
/* Private Slots */
/*****************************************************************************/
void HexWalkMain::about()
{
    QMessageBox::about(this, tr("About HexWalk"),
                       tr("HexWalk v1.0.0a is an HEX editor/viewer/analyzer.\r\n"
                          "It is open source and it is based on QT, qhexedit2, binwalk\r\n"
                          "Sources at https://github.com/gcarmix/HexWalk\r\n"));
}

void HexWalkMain::dataChanged()
{
    setWindowModified(hexEdit->isModified());
}

void HexWalkMain::adjustForCurrentFile(const QString &filePath){
    currentFilePath = filePath;
    setWindowFilePath(currentFilePath);

    QSettings settings;
    QStringList recentFilePaths =
        settings.value("recentFiles").toStringList();
    recentFilePaths.removeAll(filePath);
    recentFilePaths.prepend(filePath);
    while (recentFilePaths.size() > 5)
        recentFilePaths.removeLast();
    settings.setValue("recentFiles", recentFilePaths);

    // see note
    updateRecentActionList();
}
void HexWalkMain::updateRecentActionList(){
    QSettings settings;
    QStringList recentFilePaths =
        settings.value("recentFiles").toStringList();

    auto itEnd = 0u;
    if(recentFilePaths.size() <= 5)
        itEnd = recentFilePaths.size();
    else
        itEnd = 5;

    for (auto i = 0u; i < itEnd; ++i) {
        QString strippedName = QFileInfo(recentFilePaths.at(i)).fileName();
        recentFileActionList.at(i)->setText(strippedName);
        recentFileActionList.at(i)->setData(recentFilePaths.at(i));
        recentFileActionList.at(i)->setVisible(true);
    }

    for (auto i = itEnd; i < 5; ++i)
        recentFileActionList.at(i)->setVisible(false);
}
void HexWalkMain::open()
{
    QSettings settings;
    QString fileName = QFileDialog::getOpenFileName(this);
    if (!fileName.isEmpty()) {
        adjustForCurrentFile(fileName);
        loadFile(fileName);
    }
}

void HexWalkMain::writeSettings()
{
    QSettings settings;
    settings.setValue("pos", pos());
    settings.setValue("size", size());
}

void HexWalkMain::findNext()
{
    searchDialog->findNext();
}

bool HexWalkMain::saveFile(const QString &fileName)
{
    QString tmpFileName = fileName + ".~tmp";

    QApplication::setOverrideCursor(Qt::WaitCursor);
    QFile file(tmpFileName);
    bool ok = hexEdit->write(file);
    if (QFile::exists(fileName))
        ok = QFile::remove(fileName);
    if (ok)
    {
        file.setFileName(tmpFileName);
        ok = file.copy(fileName);
        if (ok)
            ok = QFile::remove(tmpFileName);
    }
    QApplication::restoreOverrideCursor();

    if (!ok) {
        QMessageBox::warning(this, tr("HexWalk"),
                             tr("Cannot write file %1.")
                                 .arg(fileName));
        return false;
    }

    setCurrentFile(fileName);
    statusBar()->showMessage(tr("File saved"), 2000);
    return true;
}
QString HexWalkMain::strippedName(const QString &fullFileName)
{
    return QFileInfo(fullFileName).fileName();
}

bool HexWalkMain::save()
{

    if (isUntitled) {
        return saveAs();
    } else {

        QMessageBox msgBox;
        msgBox.setText("Do you want to save your changes?");
        msgBox.setStandardButtons(QMessageBox::Save | QMessageBox::Cancel);
        msgBox.setDefaultButton(QMessageBox::Save);
        int ret = msgBox.exec();

        switch (ret) {
        case QMessageBox::Save:
            // Save was clicked
            return saveFile(curFile);
            break;
        case QMessageBox::Cancel:
            // Cancel was clicked
            break;
        default:
            // should never be reached
            break;
        }



    }
    return 0;
}

bool HexWalkMain::saveAs()
{
    QString fileName = QFileDialog::getSaveFileName(this, tr("Save As"),
                                                    curFile);
    if (fileName.isEmpty())
        return false;

    return saveFile(fileName);
    return 0;
}

void HexWalkMain::saveSelectionToReadableFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, tr("Save To Readable File"));
    if (!fileName.isEmpty())
    {
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text)) {
            QMessageBox::warning(this, tr("HexWalk"),
                                 tr("Cannot write file %1:\n%2.")
                                     .arg(fileName)
                                     .arg(file.errorString()));
            return;
        }

        QApplication::setOverrideCursor(Qt::WaitCursor);
        file.write(hexEdit->selectionToReadableString().toLatin1());
        QApplication::restoreOverrideCursor();

        statusBar()->showMessage(tr("File saved"), 2000);
    }
}

void HexWalkMain::saveToReadableFile()
{
    QString fileName = QFileDialog::getSaveFileName(this, tr("Save To Readable File"));
    if (!fileName.isEmpty())
    {
        QFile file(fileName);
        if (!file.open(QFile::WriteOnly | QFile::Text)) {
            QMessageBox::warning(this, tr("HexWalk"),
                                 tr("Cannot write file %1:\n%2.")
                                     .arg(fileName)
                                     .arg(file.errorString()));
            return;
        }

        QApplication::setOverrideCursor(Qt::WaitCursor);
        file.write(hexEdit->toReadableString().toLatin1());
        QApplication::restoreOverrideCursor();

        statusBar()->showMessage(tr("File saved"), 2000);
    }
}

void HexWalkMain::setAddress(qint64 address)
{
    lbAddress->setText(QString("%1(%2)").arg(address, 1, 16).arg(address,1,10));
    if(hexEdit->getSize() > 0)
    {
        if(address < hexEdit->getSize())
        {
        ui->hexTextedit->setText(QString("%1").arg(uchar(hexEdit->dataAt(address,1).at(0)),2,16,QLatin1Char('0')));
        ui->decTextedit->setText(QString("%1").arg(uchar(hexEdit->dataAt(address,1).at(0)),3,10));
        ui->octTextedit->setText(QString("%1").arg(uchar(hexEdit->dataAt(address,1).at(0)),3,8,QLatin1Char('0')));
        ui->binTextedit->setText(QString("%1").arg(uchar(hexEdit->dataAt(address,1).at(0)),8,2,QLatin1Char('0')));
        }
    }

}

void HexWalkMain::setOverwriteMode(bool mode)
{
    QSettings settings;
    settings.setValue("OverwriteMode", mode);
    if (mode)
        lbOverwriteMode->setText(tr("Overwrite"));
    else
        lbOverwriteMode->setText(tr("Insert"));
}

void HexWalkMain::setSize(qint64 size)
{
    lbSize->setText(QString("%1").arg(size));
}

void HexWalkMain::showSearchDialog()
{
    searchDialog->show();
}

void HexWalkMain::showAdvancedSearchDialog()
{
    advancedSearchDialog->show();
}

void HexWalkMain::showEntropyDialog()
{
    if(curFile.length() == 0)
    {
        QMessageBox::warning(this, tr("HexWalk"),
                             tr("You must select a file first.")
                             );
    }
    else
    {
        entropyDialog->show();
        entropyDialog->calculate();
    }

}

void HexWalkMain::showBinaryDialog()
{
    if(curFile.length() == 0)
    {
        QMessageBox::warning(this, tr("HexWalk"),
                             tr("You must select a file first.")
                                );
    }
    else
    {
        analysisDialog->show();
        analysisDialog->analyze(curFile);
    }

}

void HexWalkMain::showConverterDialog()
{
    converterDialog->show();
}
void HexWalkMain::showHashDialog()
{
    if(curFile.length() == 0)
    {
        QMessageBox::warning(this, tr("HexWalk"),
                             tr("You must select a file first.")
                             );
    }
    else
    {
        hashDialog->show();
        hashDialog->calculate(curFile);
    }

}

void HexWalkMain::readSettings()
{
    QSettings settings;
    hexEdit->setAddressWidth(8);
    hexEdit->setBytesPerLine(16);
    hexEdit->setHexCaps(true);
    hexEdit->setAddressAreaColor(QColor("#545454"));
    hexEdit->setAddressFontColor(QColor("#f0f0f0"));
    hexEdit->setAsciiFontColor(QColor("#00ff5e"));
    hexEdit->setHexFontColor(QColor("#00ff5e"));
    hexEdit->setHighlightingColor(QColor("#540c00"));
    hexEdit->setFont(QFont("Courier",12));
    hexEdit->setHighlighting(true);
    hexEdit->setOverwriteMode(true);
    /*
    QPoint pos = settings.value("pos", QPoint(200, 200)).toPoint();
    QSize size = settings.value("size", QSize(610, 460)).toSize();
    move(pos);
    resize(size);

    hexEdit->setAddressArea(settings.value("AddressArea").toBool());
    hexEdit->setAsciiArea(settings.value("AsciiArea").toBool());
    hexEdit->setHighlighting(settings.value("Highlighting").toBool());
    hexEdit->setOverwriteMode(settings.value("OverwriteMode").toBool());
    hexEdit->setReadOnly(settings.value("ReadOnly").toBool());

    hexEdit->setHighlightingColor(settings.value("HighlightingColor").value<QColor>());
    hexEdit->setAddressAreaColor(settings.value("AddressAreaColor").value<QColor>());
    hexEdit->setSelectionColor(settings.value("SelectionColor").value<QColor>());
    hexEdit->setFont(settings.value("WidgetFont").value<QFont>());
    hexEdit->setAddressFontColor(settings.value("AddressFontColor").value<QColor>());
    hexEdit->setAsciiAreaColor(settings.value("AsciiAreaColor").value<QColor>());
    hexEdit->setAsciiFontColor(settings.value("AsciiFontColor").value<QColor>());
    hexEdit->setHexFontColor(settings.value("HexFontColor").value<QColor>());

    hexEdit->setAddressWidth(settings.value("AddressAreaWidth").toInt());
    hexEdit->setBytesPerLine(settings.value("BytesPerLine").toInt());
    hexEdit->setHexCaps(settings.value("HexCaps", true).toBool());
*/
}


/*****************************************************************************/
/* Protected methods */
/*****************************************************************************/
void HexWalkMain::closeEvent(QCloseEvent *)
{
    writeSettings();
}


void HexWalkMain::dragEnterEvent(QDragEnterEvent *event)
{
    if (event->mimeData()->hasUrls())
        event->accept();
}


void HexWalkMain::dropEvent(QDropEvent *event)
{
    if (event->mimeData()->hasUrls())
    {
        QList<QUrl> urls = event->mimeData()->urls();
        QString filePath = urls.at(0).toLocalFile();
        loadFile(filePath);
        event->accept();
    }
}

```

`hexwalk/hexwalkmain.h`:

```h
#ifndef HEXWALKMAIN_H
#define HEXWALKMAIN_H

#include <QMainWindow>
#include "../src/qhexedit.h"


#include "searchdialog.h"
#include "advancedsearchdialog.h"
#include "entropydialog.h"
#include "binanalysisdialog.h"
#include "converterdialog.h"
#include "hashdialog.h"
QT_BEGIN_NAMESPACE
class QAction;
class QMenu;
class QUndoStack;
class QLabel;
class QDragEnterEvent;
class QDropEvent;
QT_END_NAMESPACE

namespace Ui {
class HexWalkMain;
}

class HexWalkMain : public QMainWindow
{
    Q_OBJECT

public:
    explicit HexWalkMain(QWidget *parent = nullptr);
    ~HexWalkMain();
    void loadFile(const QString &fileName);


protected:
    void closeEvent(QCloseEvent *event);
    void dragEnterEvent(QDragEnterEvent *event);
    void dropEvent(QDropEvent *event);
private slots:
    void about();
    void dataChanged();
    void open();
    void openRecent();
    void findNext();
    bool save();
    bool saveAs();
    void saveSelectionToReadableFile();
    void saveToReadableFile();
    void setAddress(qint64 address);
    void setOverwriteMode(bool mode);
    void setSize(qint64 size);
    void showSearchDialog();
    void showAdvancedSearchDialog();
    void showEntropyDialog();
    void showBinaryDialog();
    void showConverterDialog();
    void showHashDialog();
    void toggleOverwriteMode();

private:
    void init();
    void adjustForCurrentFile(const QString& filePath);
    void updateRecentActionList();
    QList<QAction*> recentFileActionList;
    QString curFile;
    QFile file;
    bool isUntitled;
    QMenu *fileMenu;
    QMenu *editMenu;
    QMenu *helpMenu;
    QMenu *analysisMenu;
    QMenu *toolsMenu;
    QMenu *recentFilesMenu;
    QString currentFilePath;
    QToolBar *infoToolBar;
    QToolBar *fileToolBar;
    QToolBar *editToolBar;
    QToolBar *analysisToolBar;

    QAction *openAct;
    QAction *saveAct;
    QAction *saveAsAct;
    QAction *saveReadable;
    QAction *closeAct;
    QAction *exitAct;
    QAction *binaryAct;
    QAction *overwriteAct;
    QAction *hashAct;

    QAction *undoAct;
    QAction *redoAct;
    QAction *saveSelectionReadable;

    QAction *aboutAct;
    QAction *aboutQtAct;
    QAction *findAct;
    QAction *findNextAct;
    QAction *advancedFindAct;
    QAction *entropyAct;
    QAction *converterAct;
    void createActions();
    void createMenus();
    void createStatusBar();
    void createToolBars();
    void setCurrentFile(const QString &fileName);
    void readSettings();
    void writeSettings();
    bool saveFile(const QString &fileName);
    QString strippedName(const QString &fullFileName);
    Ui::HexWalkMain *ui;
    QHexEdit *hexEdit;

    EntropyDialog *entropyDialog;
    ConverterDialog *converterDialog;
    HashDialog * hashDialog;
    SearchDialog *searchDialog;
    binanalysisdialog * analysisDialog;
    AdvancedSearchDialog *advancedSearchDialog;
    QLabel *lbAddress, *lbAddressName;
    QLabel *lbOverwriteMode, *lbOverwriteModeName;
    QLabel *lbSize, *lbSizeName;
};

#endif // HEXWALKMAIN_H

```

`hexwalk/hexwalkmain.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>HexWalkMain</class>
 <widget class="QMainWindow" name="HexWalkMain">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>950</width>
    <height>800</height>
   </rect>
  </property>
  <property name="minimumSize">
   <size>
    <width>950</width>
    <height>800</height>
   </size>
  </property>
  <property name="maximumSize">
   <size>
    <width>950</width>
    <height>800</height>
   </size>
  </property>
  <property name="windowTitle">
   <string>HexWalk</string>
  </property>
  <widget class="QWidget" name="centralwidget">
   <property name="acceptDrops">
    <bool>true</bool>
   </property>
   <widget class="QGroupBox" name="groupBox">
    <property name="geometry">
     <rect>
      <x>10</x>
      <y>620</y>
      <width>931</width>
      <height>91</height>
     </rect>
    </property>
    <property name="autoFillBackground">
     <bool>false</bool>
    </property>
    <property name="title">
     <string>Info</string>
    </property>
    <widget class="QLabel" name="hexlbl">
     <property name="geometry">
      <rect>
       <x>10</x>
       <y>40</y>
       <width>101</width>
       <height>31</height>
      </rect>
     </property>
     <property name="text">
      <string>Hex:</string>
     </property>
    </widget>
    <widget class="QLabel" name="declbl">
     <property name="geometry">
      <rect>
       <x>120</x>
       <y>40</y>
       <width>41</width>
       <height>31</height>
      </rect>
     </property>
     <property name="text">
      <string>Dec:</string>
     </property>
    </widget>
    <widget class="QLabel" name="octlbl">
     <property name="geometry">
      <rect>
       <x>230</x>
       <y>40</y>
       <width>41</width>
       <height>31</height>
      </rect>
     </property>
     <property name="text">
      <string>Oct:</string>
     </property>
    </widget>
    <widget class="QLabel" name="binlbl">
     <property name="geometry">
      <rect>
       <x>350</x>
       <y>40</y>
       <width>41</width>
       <height>31</height>
      </rect>
     </property>
     <property name="text">
      <string>Bin:</string>
     </property>
    </widget>
    <widget class="QLabel" name="hexTextedit">
     <property name="geometry">
      <rect>
       <x>50</x>
       <y>37</y>
       <width>61</width>
       <height>31</height>
      </rect>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Sunken</enum>
     </property>
     <property name="text">
      <string/>
     </property>
    </widget>
    <widget class="QLabel" name="decTextedit">
     <property name="geometry">
      <rect>
       <x>160</x>
       <y>40</y>
       <width>61</width>
       <height>31</height>
      </rect>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Sunken</enum>
     </property>
     <property name="text">
      <string/>
     </property>
    </widget>
    <widget class="QLabel" name="octTextedit">
     <property name="geometry">
      <rect>
       <x>270</x>
       <y>40</y>
       <width>61</width>
       <height>31</height>
      </rect>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Sunken</enum>
     </property>
     <property name="text">
      <string/>
     </property>
    </widget>
    <widget class="QLabel" name="binTextedit">
     <property name="geometry">
      <rect>
       <x>390</x>
       <y>40</y>
       <width>161</width>
       <height>31</height>
      </rect>
     </property>
     <property name="frameShape">
      <enum>QFrame::Box</enum>
     </property>
     <property name="frameShadow">
      <enum>QFrame::Sunken</enum>
     </property>
     <property name="text">
      <string/>
     </property>
    </widget>
   </widget>
   <widget class="QHexEdit" name="widget" native="true">
    <property name="geometry">
     <rect>
      <x>10</x>
      <y>10</y>
      <width>931</width>
      <height>611</height>
     </rect>
    </property>
    <property name="acceptDrops">
     <bool>true</bool>
    </property>
   </widget>
  </widget>
  <widget class="QStatusBar" name="statusbar"/>
  <widget class="QToolBar" name="toolBar">
   <property name="windowTitle">
    <string>toolBar</string>
   </property>
   <attribute name="toolBarArea">
    <enum>TopToolBarArea</enum>
   </attribute>
   <attribute name="toolBarBreak">
    <bool>false</bool>
   </attribute>
  </widget>
  <action name="actionExit">
   <property name="text">
    <string>Exit</string>
   </property>
  </action>
 </widget>
 <customwidgets>
  <customwidget>
   <class>QHexEdit</class>
   <extends>QWidget</extends>
   <header>../src/qhexedit.h</header>
   <container>1</container>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>

```

`hexwalk/main.cpp`:

```cpp
#include <QApplication>
#include <QIcon>
#include <QStyleFactory>

#include "hexwalkmain.h"
int main(int argc, char *argv[])
{
    Q_INIT_RESOURCE(hexwalk);
    QApplication app(argc, argv);
    app.setApplicationName("HexWalk");
    app.setOrganizationName("HexWalk");
    app.setWindowIcon(QIcon(":images/hexwalk.ico"));
    // set style
    app.setStyle(QStyleFactory::create("Fusion"));
    // increase font size for better reading
    QString fontPath1=":/fonts/Helvetica.ttf";
    QString fontPath2=":/fonts/Courier.ttf";
    int fontId = QFontDatabase::addApplicationFont(fontPath1);
    QFontDatabase::addApplicationFont(fontPath2);
    if (fontId != -1)
    {
        QFont font("Helvetica");
        font.setPointSize(font.pointSize()-1);
        app.setFont(font);
    }
    /*QFont defaultFont = QApplication::font();
    defaultFont.setPointSize(defaultFont.pointSize()+2);
    app.setFont(defaultFont);*/
    // modify palette to dark
    QPalette darkPalette;
    darkPalette.setColor(QPalette::Window,QColor(53,53,53));
    darkPalette.setColor(QPalette::WindowText,Qt::white);
    darkPalette.setColor(QPalette::Disabled,QPalette::WindowText,QColor(127,127,127));
    darkPalette.setColor(QPalette::Base,QColor(42,42,42));
    darkPalette.setColor(QPalette::AlternateBase,QColor(66,66,66));
    darkPalette.setColor(QPalette::ToolTipBase,Qt::white);
    darkPalette.setColor(QPalette::ToolTipText,Qt::white);
    darkPalette.setColor(QPalette::Text,Qt::white);
    darkPalette.setColor(QPalette::Disabled,QPalette::Text,QColor(127,127,127));
    darkPalette.setColor(QPalette::Dark,QColor(35,35,35));
    darkPalette.setColor(QPalette::Shadow,QColor(20,20,20));
    darkPalette.setColor(QPalette::Button,QColor(53,53,53));
    darkPalette.setColor(QPalette::ButtonText,Qt::white);
    darkPalette.setColor(QPalette::Disabled,QPalette::ButtonText,QColor(127,127,127));
    darkPalette.setColor(QPalette::BrightText,Qt::red);
    darkPalette.setColor(QPalette::Link,QColor(42,130,218));
    darkPalette.setColor(QPalette::Highlight,QColor(42,130,218));
    darkPalette.setColor(QPalette::Disabled,QPalette::Highlight,QColor(80,80,80));
    darkPalette.setColor(QPalette::HighlightedText,Qt::white);
    darkPalette.setColor(QPalette::Disabled,QPalette::HighlightedText,QColor(127,127,127));

    app.setPalette(darkPalette);


    // Identify locale and load translation if available
    QString locale = QLocale::system().name();
    QTranslator translator;
    translator.load(QString("hexwalk_") + locale);
    app.installTranslator(&translator);

    QCommandLineParser parser;
    parser.addPositionalArgument("file", "File to open");
    parser.addHelpOption();
    parser.process(app);

    /*MainWindow *mainWin = new MainWindow;
    if(!parser.positionalArguments().isEmpty())
        mainWin->loadFile(parser.positionalArguments().at(0));
    mainWin->show();*/
    HexWalkMain *hexwalkWin = new HexWalkMain;
    if(!parser.positionalArguments().isEmpty())
        hexwalkWin->loadFile(parser.positionalArguments().at(0));
    hexwalkWin->show();

    return app.exec();
}

```

`hexwalk/optionsdialog.cpp`:

```cpp

#include <QColorDialog>
#include <QFontDialog>

#include "optionsdialog.h"
#include "ui_optionsdialog.h"

OptionsDialog::OptionsDialog(QWidget *parent) :
    QDialog(parent),
    ui(new Ui::OptionsDialog)
{
    ui->setupUi(this);
    //readSettings();
    //writeSettings();
}

OptionsDialog::~OptionsDialog()
{
    delete ui;
}

void OptionsDialog::show()
{
    readSettings();
    QWidget::show();
}

void OptionsDialog::accept()
{
    writeSettings();
    emit accepted();
    QDialog::hide();
}

void OptionsDialog::readSettings()
{
    QSettings settings;

    ui->cbAddressArea->setChecked(settings.value("AddressArea", true).toBool());
    ui->cbAsciiArea->setChecked(settings.value("AsciiArea", true).toBool());
    ui->cbHighlighting->setChecked(settings.value("Highlighting", true).toBool());
    ui->cbOverwriteMode->setChecked(settings.value("OverwriteMode", true).toBool());
    ui->cbReadOnly->setChecked(settings.value("ReadOnly").toBool());

    setColor(ui->lbHighlightingColor, settings.value("HighlightingColor", QColor(0xff, 0xff, 0x99, 0xff)).value<QColor>());
    setColor(ui->lbAddressAreaColor, settings.value("AddressAreaColor", this->palette().alternateBase().color()).value<QColor>());
    setColor(ui->lbSelectionColor, settings.value("SelectionColor", this->palette().highlight().color()).value<QColor>());
    setColor(ui->lbAddressFontColor, settings.value("AddressFontColor", QPalette::WindowText).value<QColor>());
    setColor(ui->lbAsciiAreaColor, settings.value("AsciiAreaColor", this->palette().alternateBase().color()).value<QColor>());
    setColor(ui->lbAsciiFontColor, settings.value("AsciiFontColor", QPalette::WindowText).value<QColor>());
    setColor(ui->lbHexFontColor, settings.value("HexFontColor", QPalette::WindowText).value<QColor>());
#ifdef Q_OS_WIN32
    ui->leWidgetFont->setFont(settings.value("WidgetFont", QFont("Courier", 10)).value<QFont>());
#else
    ui->leWidgetFont->setFont(settings.value("WidgetFont", QFont("Monospace", 10)).value<QFont>());
#endif

    ui->sbAddressAreaWidth->setValue(settings.value("AddressAreaWidth", 4).toInt());
    ui->sbBytesPerLine->setValue(settings.value("BytesPerLine", 16).toInt());
}

void OptionsDialog::writeSettings()
{
    QSettings settings;
    settings.setValue("AddressArea", ui->cbAddressArea->isChecked());
    settings.setValue("AsciiArea", ui->cbAsciiArea->isChecked());
    settings.setValue("Highlighting", ui->cbHighlighting->isChecked());
    settings.setValue("OverwriteMode", ui->cbOverwriteMode->isChecked());
    settings.setValue("ReadOnly", ui->cbReadOnly->isChecked());

    settings.setValue("HighlightingColor", ui->lbHighlightingColor->palette().color(QPalette::Background));
    settings.setValue("AddressAreaColor", ui->lbAddressAreaColor->palette().color(QPalette::Background));
    settings.setValue("SelectionColor", ui->lbSelectionColor->palette().color(QPalette::Background));
    settings.setValue("AddressFontColor", ui->lbAddressFontColor->palette().color(QPalette::Background));
    settings.setValue("AsciiAreaColor", ui->lbAsciiAreaColor->palette().color(QPalette::Background));
    settings.setValue("AsciiFontColor", ui->lbAsciiFontColor->palette().color(QPalette::Background));
    settings.setValue("HexFontColor", ui->lbHexFontColor->palette().color(QPalette::Background));
    settings.setValue("WidgetFont",ui->leWidgetFont->font());

    settings.setValue("AddressAreaWidth", ui->sbAddressAreaWidth->value());
    settings.setValue("BytesPerLine", ui->sbBytesPerLine->value());
}

void OptionsDialog::setColor(QWidget *widget, QColor color)
{
    QPalette palette = widget->palette();
    palette.setColor(QPalette::Background, color);
    widget->setPalette(palette);
    widget->setAutoFillBackground(true);
}

void OptionsDialog::on_pbHighlightingColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbHighlightingColor->palette().color(QPalette::Background), this);
    if (color.isValid())
        setColor(ui->lbHighlightingColor, color);
}

void OptionsDialog::on_pbAddressAreaColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbAddressAreaColor->palette().color(QPalette::Background), this);
    if (color.isValid())
        setColor(ui->lbAddressAreaColor, color);
}

void OptionsDialog::on_pbAddressFontColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbAddressFontColor->palette().color(QPalette::WindowText), this);
    if (color.isValid())
        setColor(ui->lbAddressFontColor, color);
}

void OptionsDialog::on_pbAsciiAreaColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbAsciiAreaColor->palette().color(QPalette::Background), this);
    if (color.isValid())
        setColor(ui->lbAsciiAreaColor, color);
}

void OptionsDialog::on_pbAsciiFontColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbAsciiFontColor->palette().color(QPalette::WindowText), this);
    if (color.isValid())
        setColor(ui->lbAsciiFontColor, color);
}

void OptionsDialog::on_pbHexFontColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbHexFontColor->palette().color(QPalette::WindowText), this);
    if (color.isValid())
        setColor(ui->lbHexFontColor, color);
}

void OptionsDialog::on_pbSelectionColor_clicked()
{
    QColor color = QColorDialog::getColor(ui->lbSelectionColor->palette().color(QPalette::Background), this);
    if (color.isValid())
        setColor(ui->lbSelectionColor, color);
}

void OptionsDialog::on_pbWidgetFont_clicked()
{
    bool ok;
    QFont font = QFontDialog::getFont(&ok, ui->leWidgetFont->font(), this);
    if (ok)
        ui->leWidgetFont->setFont(font);
}

```

`hexwalk/optionsdialog.h`:

```h
#ifndef OPTIONSDIALOG_H
#define OPTIONSDIALOG_H

#include <QtCore>
#include <QDialog>

namespace Ui {
    class OptionsDialog;
}

class OptionsDialog : public QDialog
{
    Q_OBJECT

public:
    explicit OptionsDialog(QWidget *parent = 0);
    ~OptionsDialog();
    Ui::OptionsDialog *ui;
    void show();

public slots:
    virtual void accept();

private slots:
    void on_pbHighlightingColor_clicked();
    void on_pbAddressAreaColor_clicked();
    void on_pbAddressFontColor_clicked();
    void on_pbAsciiAreaColor_clicked();
    void on_pbAsciiFontColor_clicked();
    void on_pbHexFontColor_clicked();
    void on_pbSelectionColor_clicked();
    void on_pbWidgetFont_clicked();

private:
    void readSettings();
    void writeSettings();
    void setColor(QWidget *widget, QColor color);
};

#endif // OPTIONSDIALOG_H

```

`hexwalk/optionsdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>OptionsDialog</class>
 <widget class="QDialog" name="OptionsDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>374</width>
    <height>754</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Options</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <widget class="QGroupBox" name="gbFlags">
     <property name="title">
      <string>Flags</string>
     </property>
     <layout class="QGridLayout" name="gridLayout_2">
      <item row="1" column="1">
       <widget class="QCheckBox" name="cbAddressArea">
        <property name="text">
         <string>Address Area</string>
        </property>
       </widget>
      </item>
      <item row="1" column="0">
       <widget class="QCheckBox" name="cbOverwriteMode">
        <property name="text">
         <string>Overwrite Mode</string>
        </property>
       </widget>
      </item>
      <item row="2" column="0">
       <widget class="QCheckBox" name="cbHighlighting">
        <property name="text">
         <string>Higlighting</string>
        </property>
       </widget>
      </item>
      <item row="2" column="1">
       <widget class="QCheckBox" name="cbAsciiArea">
        <property name="text">
         <string>Ascii Area</string>
        </property>
       </widget>
      </item>
      <item row="3" column="0">
       <widget class="QCheckBox" name="cbReadOnly">
        <property name="text">
         <string>ReadOnly</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="gbColors">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="title">
      <string>Colors and Fonts</string>
     </property>
     <layout class="QGridLayout" name="gridLayout">
      <item row="0" column="0">
       <widget class="QPushButton" name="pbHighlightingColor">
        <property name="text">
         <string>Highlighting Color</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QLabel" name="lbHighlightingColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="1" column="0">
       <widget class="QPushButton" name="pbSelectionColor">
        <property name="text">
         <string>Selection Color</string>
        </property>
       </widget>
      </item>
      <item row="1" column="1">
       <widget class="QLabel" name="lbSelectionColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="2" column="0">
       <widget class="QPushButton" name="pbAddressAreaColor">
        <property name="text">
         <string>Address Area Color</string>
        </property>
       </widget>
      </item>
      <item row="2" column="1">
       <widget class="QLabel" name="lbAddressAreaColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="3" column="0">
       <widget class="QPushButton" name="pbAddressFontColor">
        <property name="text">
         <string>Address Font Color</string>
        </property>
       </widget>
      </item>
      <item row="3" column="1">
       <widget class="QLabel" name="lbAddressFontColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="4" column="0">
       <widget class="QPushButton" name="pbAsciiAreaColor">
        <property name="text">
         <string>ASCII Area Color</string>
        </property>
       </widget>
      </item>
      <item row="4" column="1">
       <widget class="QLabel" name="lbAsciiAreaColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="5" column="0">
       <widget class="QPushButton" name="pbAsciiFontColor">
        <property name="text">
         <string>ASCII Font Color</string>
        </property>
       </widget>
      </item>
      <item row="5" column="1">
       <widget class="QLabel" name="lbAsciiFontColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="6" column="0">
       <widget class="QPushButton" name="pbHexFontColor">
        <property name="text">
         <string>Hex Font Color</string>
        </property>
       </widget>
      </item>
      <item row="6" column="1">
       <widget class="QLabel" name="lbHexFontColor">
        <property name="minimumSize">
         <size>
          <width>100</width>
          <height>0</height>
         </size>
        </property>
        <property name="maximumSize">
         <size>
          <width>16777215</width>
          <height>16777215</height>
         </size>
        </property>
        <property name="frameShape">
         <enum>QFrame::Panel</enum>
        </property>
        <property name="frameShadow">
         <enum>QFrame::Sunken</enum>
        </property>
        <property name="text">
         <string/>
        </property>
       </widget>
      </item>
      <item row="7" column="0">
       <widget class="QPushButton" name="pbWidgetFont">
        <property name="text">
         <string>Widget Font</string>
        </property>
       </widget>
      </item>
      <item row="7" column="1">
       <widget class="QLineEdit" name="leWidgetFont">
        <property name="sizePolicy">
         <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
          <horstretch>0</horstretch>
          <verstretch>0</verstretch>
         </sizepolicy>
        </property>
        <property name="font">
         <font>
          <family>Courier New</family>
          <pointsize>10</pointsize>
         </font>
        </property>
        <property name="text">
         <string>01 23 45 67 89 ab cd ef</string>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="gbAddressAreaWidth">
     <property name="title">
      <string>Address Area</string>
     </property>
     <layout class="QGridLayout" name="gridLayout_3">
      <item row="0" column="0">
       <widget class="QLabel" name="lbAddressAreaWidth">
        <property name="text">
         <string>Address Area Width</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QSpinBox" name="sbAddressAreaWidth">
        <property name="minimum">
         <number>1</number>
        </property>
        <property name="maximum">
         <number>6</number>
        </property>
        <property name="value">
         <number>4</number>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <widget class="QGroupBox" name="gbHexArea">
     <property name="title">
      <string>Hex Area</string>
     </property>
     <layout class="QGridLayout" name="gridLayout_4">
      <item row="0" column="0">
       <widget class="QLabel" name="lbBytesPerLine">
        <property name="text">
         <string>Bytes per Line</string>
        </property>
       </widget>
      </item>
      <item row="0" column="1">
       <widget class="QSpinBox" name="sbBytesPerLine">
        <property name="minimum">
         <number>1</number>
        </property>
        <property name="maximum">
         <number>32</number>
        </property>
        <property name="value">
         <number>16</number>
        </property>
       </widget>
      </item>
     </layout>
    </widget>
   </item>
   <item>
    <spacer name="verticalSpacer">
     <property name="orientation">
      <enum>Qt::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::Cancel|QDialogButtonBox::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>pbHighlightingColor</tabstop>
  <tabstop>pbAddressAreaColor</tabstop>
  <tabstop>buttonBox</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>buttonBox</sender>
   <signal>accepted()</signal>
   <receiver>OptionsDialog</receiver>
   <slot>accept()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>222</x>
     <y>154</y>
    </hint>
    <hint type="destinationlabel">
     <x>157</x>
     <y>168</y>
    </hint>
   </hints>
  </connection>
  <connection>
   <sender>buttonBox</sender>
   <signal>rejected()</signal>
   <receiver>OptionsDialog</receiver>
   <slot>reject()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>290</x>
     <y>160</y>
    </hint>
    <hint type="destinationlabel">
     <x>286</x>
     <y>168</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`hexwalk/resultType.h`:

```h
#ifndef RESULTTYPE_H
#define RESULTTYPE_H
#include <QString>
#include <qglobal.h>

typedef struct Result_S{
    qint64 cursor;
    QString hexdatastr;
    QString datastr;

}Result_S;

typedef struct BinwalkResult_S{
    qint64 cursor;
    QString datastr;

}BinwalkResult_S;

#endif // RESULTTYPE_H

```

`hexwalk/searchdialog.cpp`:

```cpp
#include "searchdialog.h"
#include "ui_searchdialog.h"

#include <QMessageBox>

SearchDialog::SearchDialog(QHexEdit *hexEdit, QWidget *parent) :
    QDialog(parent),
    ui(new Ui::SearchDialog)
{
  ui->setupUi(this);
  _hexEdit = hexEdit;
}

SearchDialog::~SearchDialog()
{
  delete ui;
}

qint64 SearchDialog::findNext()
{
    qint64 from = _hexEdit->cursorPosition() / 2;
    _findBa = getContent(ui->cbFindFormat->currentIndex(), ui->cbFind->currentText());
    qint64 idx = -1;

    if (_findBa.length() > 0)
    {
        if (ui->cbBackwards->isChecked())
            idx = _hexEdit->lastIndexOf(_findBa, from);
        else
            idx = _hexEdit->indexOf(_findBa, from,false,false);
    }
    return idx;
}

void SearchDialog::on_pbFind_clicked()
{
    findNext();
}

void SearchDialog::on_pbReplace_clicked()
{
    int idx = findNext();
    if (idx >= 0)
    {
        QByteArray replaceBa = getContent(ui->cbReplaceFormat->currentIndex(), ui->cbReplace->currentText());
        replaceOccurrence(idx, replaceBa);
    }
}

void SearchDialog::on_pbReplaceAll_clicked()
{
    int replaceCounter = 0;
    int idx = 0;
    int goOn = QMessageBox::Yes;

    while ((idx >= 0) && (goOn == QMessageBox::Yes))
    {
        idx = findNext();
        if (idx >= 0)
        {
            QByteArray replaceBa = getContent(ui->cbReplaceFormat->currentIndex(), ui->cbReplace->currentText());
            int result = replaceOccurrence(idx, replaceBa);

            if (result == QMessageBox::Yes)
                replaceCounter += 1;

            if (result == QMessageBox::Cancel)
                goOn = result;
        }
    }

    if (replaceCounter > 0)
        QMessageBox::information(this, tr("QHexEdit"), QString(tr("%1 occurrences replaced.")).arg(replaceCounter));
}


QByteArray SearchDialog::getContent(int comboIndex, const QString &input)
{
    QByteArray findBa;
    switch (comboIndex)
    {
        case 0:     // hex
            findBa = QByteArray::fromHex(input.toLatin1());
            break;
        case 1:     // text
            findBa = input.toUtf8();
            break;
    }
    return findBa;
}

qint64 SearchDialog::replaceOccurrence(qint64 idx, const QByteArray &replaceBa)
{
    int result = QMessageBox::Yes;
    if (replaceBa.length() >= 0)
    {
        if (ui->cbPrompt->isChecked())
        {
            result = QMessageBox::question(this, tr("QHexEdit"),
                     tr("Replace occurrence?"),
                     QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel);

            if (result == QMessageBox::Yes)
            {
                _hexEdit->replace(idx, replaceBa.length(), replaceBa);
                _hexEdit->update();
            }
        }
        else
        {
            _hexEdit->replace(idx, _findBa.length(), replaceBa);
        }
    }
    return result;
}

```

`hexwalk/searchdialog.h`:

```h
#ifndef SEARCHDIALOG_H
#define SEARCHDIALOG_H

#include <QDialog>
#include <QtCore>
#include "../src/qhexedit.h"

namespace Ui {
    class SearchDialog;
}

class SearchDialog : public QDialog
{
    Q_OBJECT
public:
    explicit SearchDialog(QHexEdit *hexEdit, QWidget *parent = 0);
    ~SearchDialog();
    qint64 findNext();
    Ui::SearchDialog *ui;

private slots:
    void on_pbFind_clicked();
    void on_pbReplace_clicked();
    void on_pbReplaceAll_clicked();

private:
    QByteArray getContent(int comboIndex, const QString &input);
    qint64 replaceOccurrence(qint64 idx, const QByteArray &replaceBa);

    QHexEdit *_hexEdit;
    QByteArray _findBa;
};

#endif // SEARCHDIALOG_H

```

`hexwalk/searchdialog.ui`:

```ui
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SearchDialog</class>
 <widget class="QDialog" name="SearchDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>436</width>
    <height>275</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>HexWalk - Find/Replace</string>
  </property>
  <layout class="QHBoxLayout" name="horizontalLayout_3">
   <item>
    <layout class="QVBoxLayout" name="verticalLayout_2">
     <item>
      <widget class="QGroupBox" name="gbFind">
       <property name="title">
        <string>Find</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout">
        <item>
         <widget class="QComboBox" name="cbFindFormat">
          <item>
           <property name="text">
            <string>Hex</string>
           </property>
          </item>
          <item>
           <property name="text">
            <string>UTF-8</string>
           </property>
          </item>
         </widget>
        </item>
        <item>
         <widget class="QComboBox" name="cbFind">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="editable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="gbReplace">
       <property name="title">
        <string>Replace</string>
       </property>
       <layout class="QHBoxLayout" name="horizontalLayout_2">
        <item>
         <widget class="QComboBox" name="cbReplaceFormat">
          <item>
           <property name="text">
            <string>Hex</string>
           </property>
          </item>
          <item>
           <property name="text">
            <string>UTF-8</string>
           </property>
          </item>
         </widget>
        </item>
        <item>
         <widget class="QComboBox" name="cbReplace">
          <property name="sizePolicy">
           <sizepolicy hsizetype="Expanding" vsizetype="Fixed">
            <horstretch>0</horstretch>
            <verstretch>0</verstretch>
           </sizepolicy>
          </property>
          <property name="editable">
           <bool>true</bool>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
     <item>
      <widget class="QGroupBox" name="gbOptions">
       <property name="title">
        <string>Options</string>
       </property>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <item>
         <widget class="QCheckBox" name="cbBackwards">
          <property name="text">
           <string>&amp;Backwards</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QCheckBox" name="cbPrompt">
          <property name="text">
           <string>&amp;Prompt on replace</string>
          </property>
         </widget>
        </item>
       </layout>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <layout class="QVBoxLayout" name="verticalLayout">
     <item>
      <widget class="QPushButton" name="pbFind">
       <property name="text">
        <string>&amp;Find</string>
       </property>
       <property name="shortcut">
        <string>F3</string>
       </property>
       <property name="default">
        <bool>true</bool>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pbReplace">
       <property name="text">
        <string>&amp;Replace</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pbReplaceAll">
       <property name="text">
        <string>Replace &amp;All</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="pbCancel">
       <property name="text">
        <string>&amp;Close</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="verticalSpacer">
       <property name="orientation">
        <enum>Qt::Vertical</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>20</width>
         <height>40</height>
        </size>
       </property>
      </spacer>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <tabstops>
  <tabstop>cbFind</tabstop>
  <tabstop>cbReplace</tabstop>
  <tabstop>cbFindFormat</tabstop>
  <tabstop>cbReplaceFormat</tabstop>
  <tabstop>cbBackwards</tabstop>
  <tabstop>cbPrompt</tabstop>
  <tabstop>pbFind</tabstop>
  <tabstop>pbReplace</tabstop>
  <tabstop>pbReplaceAll</tabstop>
  <tabstop>pbCancel</tabstop>
 </tabstops>
 <resources/>
 <connections>
  <connection>
   <sender>pbCancel</sender>
   <signal>clicked()</signal>
   <receiver>SearchDialog</receiver>
   <slot>hide()</slot>
   <hints>
    <hint type="sourcelabel">
     <x>360</x>
     <y>134</y>
    </hint>
    <hint type="destinationlabel">
     <x>364</x>
     <y>162</y>
    </hint>
   </hints>
  </connection>
 </connections>
</ui>

```

`hexwalk/translations/hexwalk_cs.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="cs_CZ">
<context>
    <name>MainWindow</name>
    <message>
        <source>About HexEdit</source>
        <translation type="obsolete">O HexEdit</translation>
    </message>
    <message>
        <source>The HexEdit example is a short Demo of the QHexEdit Widget.</source>
        <translation type="obsolete">Příklad HexEdit je krátká ukázka doplňku QHexEdit.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="100"/>
        <source>Save As</source>
        <translation>Uložit jako</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="110"/>
        <location filename="../mainwindow.cpp" line="132"/>
        <source>Save To Readable File</source>
        <translation>Uložit do čitelného souboru</translation>
    </message>
    <message>
        <source>HexEdit</source>
        <translation type="obsolete">HexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="61"/>
        <source>About QHexEdit</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="62"/>
        <source>The QHexEdit example is a short Demo of the QHexEdit Widget.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="115"/>
        <location filename="../mainwindow.cpp" line="137"/>
        <location filename="../mainwindow.cpp" line="347"/>
        <location filename="../mainwindow.cpp" line="399"/>
        <source>QHexEdit</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="116"/>
        <location filename="../mainwindow.cpp" line="138"/>
        <source>Cannot write file %1:
%2.</source>
        <translation>Nelze zapsat soubor %1:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="126"/>
        <location filename="../mainwindow.cpp" line="148"/>
        <location filename="../mainwindow.cpp" line="406"/>
        <source>File saved</source>
        <translation>Soubor uložen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="162"/>
        <source>Overwrite</source>
        <translation>Přepsat</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="164"/>
        <source>Insert</source>
        <translation>Vložit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="210"/>
        <source>&amp;Open...</source>
        <translation>&amp;Otevřít...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="212"/>
        <source>Open an existing file</source>
        <translation>Otevřít stávající soubor</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="215"/>
        <source>&amp;Save</source>
        <translation>&amp;Uložit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="217"/>
        <source>Save the document to disk</source>
        <translation>Uložit dokument na disk</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="220"/>
        <source>Save &amp;As...</source>
        <translation>Uložit &amp;jako...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="222"/>
        <source>Save the document under a new name</source>
        <translation>Uložit dokument pod novým názvem</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="225"/>
        <source>Save &amp;Readable...</source>
        <translation>Uložit Č&amp;itelné...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="226"/>
        <source>Save document in readable form</source>
        <translation>Uložit dokument v čitelné podobě</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="229"/>
        <source>E&amp;xit</source>
        <translation>&amp;Ukončit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="231"/>
        <source>Exit the application</source>
        <translation>Ukončit program</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="234"/>
        <source>&amp;Undo</source>
        <translation>&amp;Zpět</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="238"/>
        <source>&amp;Redo</source>
        <translation>&amp;Znovu</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="242"/>
        <source>&amp;Save Selection Readable...</source>
        <translation>&amp;Uložit výběr čitelný...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="243"/>
        <source>Save selection in readable form</source>
        <translation>Uložit výběr v čitelné podobě</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="246"/>
        <source>&amp;About</source>
        <translation>&amp;O programu</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="247"/>
        <source>Show the application&apos;s About box</source>
        <translation>Ukázat informace o programu</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="250"/>
        <source>About &amp;Qt</source>
        <translation>O &amp;Qt</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="251"/>
        <source>Show the Qt library&apos;s About box</source>
        <translation>Ukázat informace oknihovně Qt</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="261"/>
        <source>Find next occurrence of the searched pattern</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="264"/>
        <source>&amp;Options</source>
        <translation>&amp;Volby</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="265"/>
        <source>Show the Dialog to select applications options</source>
        <translation>Ukázat dialog pro výběr voleb programu</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="337"/>
        <source>Edit</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="400"/>
        <source>Cannot write file %1.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="254"/>
        <source>&amp;Find/Replace</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="41"/>
        <source>Drop File: </source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="256"/>
        <source>Show the Dialog for finding and replacing</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="259"/>
        <source>Find &amp;next</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="271"/>
        <source>&amp;File</source>
        <translation>&amp;Soubor</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="279"/>
        <source>&amp;Edit</source>
        <translation>Ú&amp;pravy</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="289"/>
        <source>&amp;Help</source>
        <translation>&amp;Nápověda</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="298"/>
        <source>Address:</source>
        <translation>Adresa:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="309"/>
        <source>Size:</source>
        <translation>Velikost:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="320"/>
        <source>Mode:</source>
        <translation>Režim:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="329"/>
        <source>Ready</source>
        <translation>Připraven</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="334"/>
        <source>File</source>
        <translation>Soubor</translation>
    </message>
    <message>
        <source>SDI</source>
        <translation type="vanished">SDI</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="348"/>
        <source>Cannot read file %1:
%2.</source>
        <translation>Nelze číst soubor %1:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="354"/>
        <source>File loaded</source>
        <translation>Soubor nahrán</translation>
    </message>
</context>
<context>
    <name>OptionsDialog</name>
    <message>
        <source>Dialog</source>
        <translation type="obsolete">Dialog</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="14"/>
        <source>QHexEdit - Options</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="20"/>
        <source>Flags</source>
        <translation>Příznaky</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="26"/>
        <source>ReadOnly</source>
        <translation>PouzeProČtení</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="33"/>
        <source>Higlighting</source>
        <translation>Zvýraznění</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="40"/>
        <source>Overwrite Mode</source>
        <translation>Režim přepisu</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="47"/>
        <location filename="../optionsdialog.ui" line="195"/>
        <source>Address Area</source>
        <translation>Oblast s adresou</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="54"/>
        <source>Ascii Area</source>
        <translation>Oblast ASCII</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="64"/>
        <source>Colors and Fonts</source>
        <translation>Barvy a písma</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="70"/>
        <source>Highlighting Color</source>
        <translation>Barva pro zvýraznění</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="102"/>
        <source>Address Area Color</source>
        <translation>Barva pro oblast s adresou</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="159"/>
        <source>Selection Color</source>
        <translation>Barva výběru</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="166"/>
        <source>Widget Font</source>
        <translation>Písmo doplňku</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="185"/>
        <source>01 23 45 67 89 ab cd ef</source>
        <translation>01 23 45 67 89 ab cd ef</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="201"/>
        <source>Address Area Width</source>
        <translation>Šířka oblasti s adresou</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="224"/>
        <source>Hex Area</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="230"/>
        <source>Bytes per Line</source>
        <translation type="unfinished"></translation>
    </message>
</context>
<context>
    <name>SearchDialog</name>
    <message>
        <source>Dialog</source>
        <translation type="obsolete">Dialog</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="14"/>
        <source>QHexEdit - Find/Replace</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="22"/>
        <source>Find</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="29"/>
        <location filename="../searchdialog.ui" line="65"/>
        <source>Hex</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="34"/>
        <location filename="../searchdialog.ui" line="70"/>
        <source>UTF-8</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="58"/>
        <source>Replace</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="94"/>
        <source>Options</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="100"/>
        <source>&amp;Backwards</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="107"/>
        <source>&amp;Prompt on replace</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="121"/>
        <source>&amp;Find</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="124"/>
        <source>F3</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="134"/>
        <source>&amp;Replace</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="141"/>
        <source>Replace &amp;All</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="148"/>
        <source>&amp;Close</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <location filename="../searchdialog.cpp" line="99"/>
        <source>QHexEdit</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <source>%1 occurrences replaced.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="100"/>
        <source>Replace occurrence?</source>
        <translation type="unfinished"></translation>
    </message>
</context>
<context>
    <name>UndoStack</name>
    <message>
        <location filename="../../src/commands.cpp" line="112"/>
        <source>Inserting %1 bytes</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="134"/>
        <source>Delete %1 chars</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="159"/>
        <source>Overwrite %1 chars</source>
        <translation type="unfinished"></translation>
    </message>
</context>
</TS>

```

`hexwalk/translations/hexwalk_de.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="de_DE">
<context>
    <name>MainWindow</name>
    <message>
        <source>About HexEdit</source>
        <translation type="obsolete">Über HexEdit</translation>
    </message>
    <message>
        <source>The HexEdit example is a short Demo of the QHexEdit Widget.</source>
        <translation type="obsolete">Das HexEdit Beispiel ist eine einfache Demo Anwendung für das QHexEdit Widget.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="100"/>
        <source>Save As</source>
        <translation>Speichern unter</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="110"/>
        <location filename="../mainwindow.cpp" line="132"/>
        <source>Save To Readable File</source>
        <translation>Als lesbare Datei speichern</translation>
    </message>
    <message>
        <source>HexEdit</source>
        <translation type="obsolete">HexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="61"/>
        <source>About QHexEdit</source>
        <translation>Über QHexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="62"/>
        <source>The QHexEdit example is a short Demo of the QHexEdit Widget.</source>
        <translation>Das QHexEdit Beispiel ist eine einfache Demo Anwendung für das QHexEdit Widget.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="115"/>
        <location filename="../mainwindow.cpp" line="137"/>
        <location filename="../mainwindow.cpp" line="347"/>
        <location filename="../mainwindow.cpp" line="399"/>
        <source>QHexEdit</source>
        <translation>QHexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="116"/>
        <location filename="../mainwindow.cpp" line="138"/>
        <source>Cannot write file %1:
%2.</source>
        <translation>Kann Detei %1 nicht schreiben:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="126"/>
        <location filename="../mainwindow.cpp" line="148"/>
        <location filename="../mainwindow.cpp" line="406"/>
        <source>File saved</source>
        <translation>Datei gespeichert</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="162"/>
        <source>Overwrite</source>
        <translation>Überschreiben</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="164"/>
        <source>Insert</source>
        <translation>Einfügen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="210"/>
        <source>&amp;Open...</source>
        <translation>Öf&amp;fnen...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="212"/>
        <source>Open an existing file</source>
        <translation>Existierende Datei öffnen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="215"/>
        <source>&amp;Save</source>
        <translation>&amp;Speichern</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="217"/>
        <source>Save the document to disk</source>
        <translation>Dokument auf Platte speichern</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="220"/>
        <source>Save &amp;As...</source>
        <translation>Speichern &amp;unter...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="222"/>
        <source>Save the document under a new name</source>
        <translation>Dokument unter neuem Namen speichern</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="225"/>
        <source>Save &amp;Readable...</source>
        <translation>Als &amp;lesbare Datei speichern...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="226"/>
        <source>Save document in readable form</source>
        <translation>Das Dokument in lesbarer From speichern</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="229"/>
        <source>E&amp;xit</source>
        <translation>&amp;Beenden</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="231"/>
        <source>Exit the application</source>
        <translation>Applikation beenden</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="234"/>
        <source>&amp;Undo</source>
        <translation>&amp;Wiederherstellen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="238"/>
        <source>&amp;Redo</source>
        <translation>&amp;Rückgängig</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="242"/>
        <source>&amp;Save Selection Readable...</source>
        <translation>&amp;Auswahl in lesbarer Form speichern...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="243"/>
        <source>Save selection in readable form</source>
        <translation>Speichere die Auswahl in lesbarer Form</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="246"/>
        <source>&amp;About</source>
        <translation>Ü&amp;ber</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="247"/>
        <source>Show the application&apos;s About box</source>
        <translation>Zeige Informationen zur Anwendungj</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="250"/>
        <source>About &amp;Qt</source>
        <translation>Über &amp;Qt</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="251"/>
        <source>Show the Qt library&apos;s About box</source>
        <translation>Zeige Informationen über Qt</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="261"/>
        <source>Find next occurrence of the searched pattern</source>
        <translation>Zeige die nächste Fundstelle mit dem gleichen Suchmuster</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="264"/>
        <source>&amp;Options</source>
        <translation>&amp;Optionen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="265"/>
        <source>Show the Dialog to select applications options</source>
        <translation>Zeige den Dialog, um Optionen der Anwendunge einzustellen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="337"/>
        <source>Edit</source>
        <translation type="unfinished">Bearbeiten</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="400"/>
        <source>Cannot write file %1.</source>
        <translation type="unfinished">Kann Datei %1 nicht schreiben.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="254"/>
        <source>&amp;Find/Replace</source>
        <translation>&amp;Suchen/Ersetzen</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="41"/>
        <source>Drop File: </source>
        <translation type="unfinished">Datei erhalten:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="256"/>
        <source>Show the Dialog for finding and replacing</source>
        <translation>Zeige den Suchen/Ersetzen Dialog</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="259"/>
        <source>Find &amp;next</source>
        <translation>&amp;Weitersuchen</translation>
    </message>
    <message>
        <source>Find next occurance of the sarched pattern</source>
        <translation type="obsolete">Zeige die nächste Fundstelle mit dem gleichen Suchmuster</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="271"/>
        <source>&amp;File</source>
        <translation>&amp;Datei</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="279"/>
        <source>&amp;Edit</source>
        <translation>&amp;Beearbeiten</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="289"/>
        <source>&amp;Help</source>
        <translation>&amp;Hilfe</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="298"/>
        <source>Address:</source>
        <translation>Adresse:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="309"/>
        <source>Size:</source>
        <translation>Größe:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="320"/>
        <source>Mode:</source>
        <translation>Mode:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="329"/>
        <source>Ready</source>
        <translation>Fertig</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="334"/>
        <source>File</source>
        <translation>Datei</translation>
    </message>
    <message>
        <source>SDI</source>
        <translation type="vanished">SDI</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="348"/>
        <source>Cannot read file %1:
%2.</source>
        <translation>Kann Datei %1 nicht lesen:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="354"/>
        <source>File loaded</source>
        <translation>Datei geladen</translation>
    </message>
</context>
<context>
    <name>OptionsDialog</name>
    <message>
        <source>Dialog</source>
        <translation type="obsolete">Optionen</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="14"/>
        <source>QHexEdit - Options</source>
        <translation>QHexEdit - Optionen</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="20"/>
        <source>Flags</source>
        <translation>Eigenschaften</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="26"/>
        <source>ReadOnly</source>
        <translation>Nur lesen</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="33"/>
        <source>Higlighting</source>
        <translation>Hervorheben</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="40"/>
        <source>Overwrite Mode</source>
        <translation>Überschreibe Modus</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="47"/>
        <location filename="../optionsdialog.ui" line="195"/>
        <source>Address Area</source>
        <translation>Adressfeld</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="54"/>
        <source>Ascii Area</source>
        <translation>Ascii-Feld</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="64"/>
        <source>Colors and Fonts</source>
        <translation>Farben und Schriftarten</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="70"/>
        <source>Highlighting Color</source>
        <translation>Farbe Hervorhebung</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="102"/>
        <source>Address Area Color</source>
        <translation>Farbe Adressfeld</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="159"/>
        <source>Selection Color</source>
        <translation>Farbe Markierung</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="166"/>
        <source>Widget Font</source>
        <translation>Font-Auswahl</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="185"/>
        <source>01 23 45 67 89 ab cd ef</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="201"/>
        <source>Address Area Width</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="224"/>
        <source>Hex Area</source>
        <translation type="unfinished">Hexadezimalfeld</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="230"/>
        <source>Bytes per Line</source>
        <translation type="unfinished">Bytes pro Zeile</translation>
    </message>
</context>
<context>
    <name>SearchDialog</name>
    <message>
        <source>Dialog</source>
        <translation type="obsolete">Optionen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="14"/>
        <source>QHexEdit - Find/Replace</source>
        <translation>QHexEdit - Suchen/Ersetzen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="22"/>
        <source>Find</source>
        <translation>Suchen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="29"/>
        <location filename="../searchdialog.ui" line="65"/>
        <source>Hex</source>
        <translation>Hex</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="34"/>
        <location filename="../searchdialog.ui" line="70"/>
        <source>UTF-8</source>
        <translation>UTF-8</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="58"/>
        <source>Replace</source>
        <translation>Ersetzen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="94"/>
        <source>Options</source>
        <translation>Optionen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="100"/>
        <source>&amp;Backwards</source>
        <translation>&amp;Rückwärts</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="107"/>
        <source>&amp;Prompt on replace</source>
        <translation>Vor dem Ersetzen &amp;nachfragen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="121"/>
        <source>&amp;Find</source>
        <translation>&amp;Suchen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="124"/>
        <source>F3</source>
        <translation></translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="134"/>
        <source>&amp;Replace</source>
        <translation>&amp;Ersetzen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="141"/>
        <source>Replace &amp;All</source>
        <translation>&amp;Alle ersetzen</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="148"/>
        <source>&amp;Close</source>
        <translation>&amp;Schließen</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <location filename="../searchdialog.cpp" line="99"/>
        <source>QHexEdit</source>
        <translation>QHexEdit</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <source>%1 occurrences replaced.</source>
        <translation>%1 Vorkommnisse ersetzt.</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="100"/>
        <source>Replace occurrence?</source>
        <translation>Vorkommnis ersetzen?</translation>
    </message>
    <message>
        <source>Replace occurrance?</source>
        <translation type="obsolete">Vorkommnis ersetzen?</translation>
    </message>
</context>
<context>
    <name>UndoStack</name>
    <message>
        <location filename="../../src/commands.cpp" line="112"/>
        <source>Inserting %1 bytes</source>
        <translation type="unfinished">%1 Bytes eingefügt</translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="134"/>
        <source>Delete %1 chars</source>
        <translation type="unfinished">%1 Zeiche(n) gelöscht</translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="159"/>
        <source>Overwrite %1 chars</source>
        <translation type="unfinished">%1 Zeichen überschrieben</translation>
    </message>
</context>
</TS>

```

`hexwalk/translations/hexwalk_ru.ts`:

```ts
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.0" language="ru_RU">
<context>
    <name>MainWindow</name>
    <message>
        <location filename="../mainwindow.cpp" line="58"/>
        <source>About QHexEdit</source>
        <translation>Про QHexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="59"/>
        <source>The QHexEdit example is a short Demo of the QHexEdit Widget.</source>
        <translation>QHexEdit пример это короткая демонстрация работы QHexEdit компоненты.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="97"/>
        <source>Save As</source>
        <translation>Сохранить как</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="107"/>
        <location filename="../mainwindow.cpp" line="129"/>
        <source>Save To Readable File</source>
        <translatorcomment>i hope it is text file with hex dump</translatorcomment>
        <translation>Сохранить как читаемый файл</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="112"/>
        <location filename="../mainwindow.cpp" line="134"/>
        <location filename="../mainwindow.cpp" line="344"/>
        <location filename="../mainwindow.cpp" line="396"/>
        <source>QHexEdit</source>
        <translation>QHexEdit</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="113"/>
        <location filename="../mainwindow.cpp" line="135"/>
        <source>Cannot write file %1:
%2.</source>
        <translation>Не могу записать файл %1:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="123"/>
        <location filename="../mainwindow.cpp" line="145"/>
        <location filename="../mainwindow.cpp" line="403"/>
        <source>File saved</source>
        <translation>Файл сохранен</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="159"/>
        <source>Overwrite</source>
        <translation>Замена</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="161"/>
        <source>Insert</source>
        <translation>Вставка</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="207"/>
        <source>&amp;Open...</source>
        <translation>&amp;Открыть...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="209"/>
        <source>Open an existing file</source>
        <translation>Открыть существующий файл</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="212"/>
        <source>&amp;Save</source>
        <translation>&amp;Сохранить</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="214"/>
        <source>Save the document to disk</source>
        <translation>Сохранить документ на диск</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="217"/>
        <source>Save &amp;As...</source>
        <translation>Сохранить &amp;как...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="219"/>
        <source>Save the document under a new name</source>
        <translation>Сохранить документ под новым именем</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="222"/>
        <source>Save &amp;Readable...</source>
        <translation>Сохранить как &amp;читаемый...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="223"/>
        <source>Save document in readable form</source>
        <translation>Сохранить документ в читабельной форме</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="226"/>
        <source>E&amp;xit</source>
        <translation>В&amp;ыход</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="228"/>
        <source>Exit the application</source>
        <translation>Выход из приложения</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="231"/>
        <source>&amp;Undo</source>
        <translation>&amp;Отмена</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="235"/>
        <source>&amp;Redo</source>
        <translation>&amp;Повторение</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="239"/>
        <source>&amp;Save Selection Readable...</source>
        <translation>&amp;Сохранить выделеное читабельно...</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="240"/>
        <source>Save selection in readable form</source>
        <translation>Сохранить выделеное в читабельной форме</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="243"/>
        <source>&amp;About</source>
        <translation>&amp;О программе</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="244"/>
        <source>Show the application&apos;s About box</source>
        <translation>Показать сообщение рассказывающее о программе</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="247"/>
        <source>About &amp;Qt</source>
        <translation>Про &amp;QT</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="248"/>
        <source>Show the Qt library&apos;s About box</source>
        <translation>Показать сообщение о библиотеке QT</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="251"/>
        <source>&amp;Find/Replace</source>
        <translation>&amp;Поиск/Замена</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="253"/>
        <source>Show the Dialog for finding and replacing</source>
        <translation>Показать диалоговое окно для поиска и замены</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="256"/>
        <source>Find &amp;next</source>
        <translation>Найти &amp;следующий</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="258"/>
        <source>Find next occurrence of the searched pattern</source>
        <translation>Найти следующие вхождение поискового шаблона</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="261"/>
        <source>&amp;Options</source>
        <translation>&amp;Настройки</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="262"/>
        <source>Show the Dialog to select applications options</source>
        <translation>Показать диалоговое окно для установок приложения</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="268"/>
        <source>&amp;File</source>
        <translation>&amp;Файл</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="276"/>
        <source>&amp;Edit</source>
        <translation>&amp;Редактирование</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="286"/>
        <source>&amp;Help</source>
        <translation>&amp;Помощь</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="295"/>
        <source>Address:</source>
        <translation>Адрес:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="306"/>
        <source>Size:</source>
        <translation>Размер:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="317"/>
        <source>Mode:</source>
        <translation>Режим:</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="326"/>
        <source>Ready</source>
        <translation>Готово</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="331"/>
        <source>File</source>
        <translation>Файл</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="334"/>
        <source>Edit</source>
        <translation>Редактирование</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="345"/>
        <source>Cannot read file %1:
%2.</source>
        <translation>Не могу прочитать файл %1:
%2.</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="351"/>
        <source>File loaded</source>
        <translation>Файл загружен</translation>
    </message>
    <message>
        <location filename="../mainwindow.cpp" line="397"/>
        <source>Cannot write file %1.</source>
        <translation>Не могу записать файл %1.</translation>
    </message>
</context>
<context>
    <name>OptionsDialog</name>
    <message>
        <location filename="../optionsdialog.ui" line="14"/>
        <source>QHexEdit - Options</source>
        <translation>QHexEdit - Настройки</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="20"/>
        <source>Flags</source>
        <translation>Флаги</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="26"/>
        <source>ReadOnly</source>
        <translation>Только чтение</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="33"/>
        <source>Higlighting</source>
        <translation>Подсвечивание</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="40"/>
        <source>Overwrite Mode</source>
        <translation>Режим замены</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="47"/>
        <location filename="../optionsdialog.ui" line="195"/>
        <source>Address Area</source>
        <translation>Адресная область</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="54"/>
        <source>Ascii Area</source>
        <translation>Область ASCII</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="64"/>
        <source>Colors and Fonts</source>
        <translation>Цвета и Шрифты</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="70"/>
        <source>Highlighting Color</source>
        <translation>Цвет подсвечивания</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="102"/>
        <source>Address Area Color</source>
        <translation>Цвет адресной области</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="159"/>
        <source>Selection Color</source>
        <translation>Цвет для выбраной области</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="166"/>
        <source>Widget Font</source>
        <translation>Шрифт для компоненты</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="185"/>
        <source>01 23 45 67 89 ab cd ef</source>
        <translation>01 23 45 67 89 ab cd ef</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="201"/>
        <source>Address Area Width</source>
        <translation>Ширина адресной области</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="224"/>
        <source>Hex Area</source>
        <translation>Шестнадцатиричная область</translation>
    </message>
    <message>
        <location filename="../optionsdialog.ui" line="230"/>
        <source>Bytes per Line</source>
        <translation>Байт в строке</translation>
    </message>
</context>
<context>
    <name>SearchDialog</name>
    <message>
        <location filename="../searchdialog.ui" line="14"/>
        <source>QHexEdit - Find/Replace</source>
        <translation>QHExEdit - Поиск/Замена</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="22"/>
        <source>Find</source>
        <translation>Найти</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="29"/>
        <location filename="../searchdialog.ui" line="65"/>
        <source>Hex</source>
        <translation>Hex</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="34"/>
        <location filename="../searchdialog.ui" line="70"/>
        <source>UTF-8</source>
        <translation>UTF-8</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="58"/>
        <source>Replace</source>
        <translation>Замена</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="94"/>
        <source>Options</source>
        <translation>Настройки</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="100"/>
        <source>&amp;Backwards</source>
        <translation>&amp;Обратный поиск</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="107"/>
        <source>&amp;Prompt on replace</source>
        <translation>&amp;Предупреждать перед заменой</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="121"/>
        <source>&amp;Find</source>
        <translation>&amp;Найти</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="124"/>
        <source>F3</source>
        <translation>F3</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="134"/>
        <source>&amp;Replace</source>
        <translation>За&amp;менить</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="141"/>
        <source>Replace &amp;All</source>
        <translation>Заменить &amp;всё</translation>
    </message>
    <message>
        <location filename="../searchdialog.ui" line="148"/>
        <source>&amp;Close</source>
        <translation>&amp;Закрыть</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <location filename="../searchdialog.cpp" line="99"/>
        <source>QHexEdit</source>
        <translation>QHexEdit</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="73"/>
        <source>%1 occurrences replaced.</source>
        <translation>%1 найденых фрагментов заменено.</translation>
    </message>
    <message>
        <location filename="../searchdialog.cpp" line="100"/>
        <source>Replace occurrence?</source>
        <translation>заменить найденое?</translation>
    </message>
</context>
<context>
    <name>UndoStack</name>
    <message>
        <location filename="../../src/commands.cpp" line="112"/>
        <source>Inserting %1 bytes</source>
        <translation>Вставить %1 байт</translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="134"/>
        <source>Delete %1 chars</source>
        <translation>Удалить %1 символов</translation>
    </message>
    <message>
        <location filename="../../src/commands.cpp" line="159"/>
        <source>Overwrite %1 chars</source>
        <translation>Заменить %1 символов</translation>
    </message>
</context>
</TS>

```

`hexwalk/worditemdelegate.cpp`:

```cpp
#include <QTextDocument>
#include <QAbstractTextDocumentLayout>
#include "worditemdelegate.h"
#include <QPainter>

WordItemDelegate::WordItemDelegate(QObject *parent) :
    QStyledItemDelegate(parent)
{}

QString WordItemDelegate::anchorAt(QString html, const QPoint &point) const {
    QTextDocument doc;
    doc.setHtml(html);

    auto textLayout = doc.documentLayout();
    Q_ASSERT(textLayout != 0);
    return textLayout->anchorAt(point);
}

void WordItemDelegate::paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const {
    auto options = option;
    initStyleOption(&options, index);

    painter->save();

    QTextDocument doc;
    doc.setHtml(options.text);

    options.text = "";
    options.widget->style()->drawControl(QStyle::CE_ItemViewItem, &option, painter);

    painter->translate(options.rect.left(), options.rect.top());
    QRect clip(0, 0, options.rect.width(), options.rect.height());
    doc.drawContents(painter, clip);

    painter->restore();
}

QSize WordItemDelegate::sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const {
    QStyleOptionViewItemV4 options = option;
    initStyleOption(&options, index);

    QTextDocument doc;
    doc.setHtml(options.text);
    doc.setTextWidth(options.rect.width());
    return QSize(doc.idealWidth(), doc.size().height());
}

```

`hexwalk/worditemdelegate.h`:

```h
#ifndef WORDITEMDELEGATE_H
#define WORDITEMDELEGATE_H

#include <QStyledItemDelegate>

class WordItemDelegate : public QStyledItemDelegate
{
    Q_OBJECT
public:
    explicit WordItemDelegate(QObject *parent = 0);

    QString anchorAt(QString html, const QPoint &point) const;

protected:
    void paint(QPainter *painter, const QStyleOptionViewItem &option, const QModelIndex &index) const;
    QSize sizeHint(const QStyleOptionViewItem &option, const QModelIndex &index) const;
};

#endif // WORDITEMDELEGATE_H

```

`src/QHexEditPlugin.cpp`:

```cpp
#include "QHexEditPlugin.h"
#include "qhexedit.h"

#include <QtPlugin>

QHexEditPlugin::QHexEditPlugin(QObject * parent) : QObject(parent)
{
    initialized = false;
}


bool QHexEditPlugin::isContainer() const
{
    return false;
}

bool QHexEditPlugin::isInitialized() const
{
    return initialized;
}

QIcon QHexEditPlugin::icon() const
{
    return QIcon();
}

QString QHexEditPlugin::domXml() const
{
    return "<ui language=\"c++\">\n"
        " <widget class=\"QHexEdit\" name=\"hexEdit\">\n"
        "  <property name=\"geometry\">\n"
        "   <rect>\n"
        "    <x>0</x>\n"
        "    <y>0</y>\n"
        "    <width>100</width>\n"
        "    <height>100</height>\n"
        "   </rect>\n"
        "  </property>\n"
        "  <property name=\"toolTip\" >\n"
        "   <string>QHexEditWidget</string>\n"
        "  </property>\n"
        "  <property name=\"whatsThis\" >\n"
        "   <string>QHexEdit widget allow to edit the data in hex view.</string>\n"
        "  </property>\n"
        " </widget>\n"
        "</ui>\n";
}

QString QHexEditPlugin::group() const
{
    return "Input Widgets";
}

QString QHexEditPlugin::includeFile() const
{
    return "qhexedit.h";
}

QString QHexEditPlugin::name() const
{
    return "QHexEdit";
}

QString QHexEditPlugin::toolTip() const
{
    return "";
}

QString QHexEditPlugin::whatsThis() const
{
    return "";
}

QWidget * QHexEditPlugin::createWidget(QWidget *parent)
{
    return new QHexEdit(parent);
}

void QHexEditPlugin::initialize(QDesignerFormEditorInterface * /*core*/)
{
    if (initialized)
        return;

    initialized = true;
}

#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
Q_EXPORT_PLUGIN2(QHexEditPlugin, QHexEditPlugin)
#endif

```

`src/QHexEditPlugin.h`:

```h
#ifndef QHEXEDITPLUGIN_H
#define QHEXEDITPLUGIN_H

#include <QObject>

#if QT_VERSION < QT_VERSION_CHECK(5,0,0)
#include <QtDesigner/QDesignerCustomWidgetInterface>
#else
#include <QDesignerCustomWidgetInterface>
#endif

class QHexEditPlugin : public QObject, public QDesignerCustomWidgetInterface
{
    Q_OBJECT
    Q_INTERFACES(QDesignerCustomWidgetInterface)
#if QT_VERSION >= QT_VERSION_CHECK(5,0,0)
    Q_PLUGIN_METADATA(IID "com.qt-project.Qt.QHexEditPlugin")
#endif

public:
    QHexEditPlugin(QObject * parent = 0);

    bool isContainer() const;
    bool isInitialized() const;
    QIcon icon() const;
    QString domXml() const;
    QString group() const;
    QString includeFile() const;
    QString name() const;
    QString toolTip() const;
    QString whatsThis() const;
    QWidget *createWidget(QWidget *parent);
    void initialize(QDesignerFormEditorInterface *core);

private:
    bool initialized;

};

#endif

```

`src/chunks.cpp`:

```cpp
#include "chunks.h"
#include <limits.h>

#define NORMAL 0
#define HIGHLIGHTED 1

#define BUFFER_SIZE 0x10000
#define CHUNK_SIZE 0x1000
#define READ_CHUNK_MASK Q_INT64_C(0xfffffffffffff000)

// ***************************************** Constructors and file settings

Chunks::Chunks(QObject *parent): QObject(parent)
{
    QBuffer *buf = new QBuffer(this);
    setIODevice(*buf);
}

Chunks::Chunks(QIODevice &ioDevice, QObject *parent): QObject(parent)
{
    setIODevice(ioDevice);
}

bool Chunks::setIODevice(QIODevice &ioDevice)
{
    _ioDevice = &ioDevice;
    bool ok = _ioDevice->open(QIODevice::ReadOnly);
    if (ok)   // Try to open IODevice
    {
        _size = _ioDevice->size();
        _ioDevice->close();
    }
    else                                        // Fallback is an empty buffer
    {
        QBuffer *buf = new QBuffer(this);
        _ioDevice = buf;
        _size = 0;
    }
    _chunks.clear();
    _pos = 0;
    return ok;
}


// ***************************************** Getting data out of Chunks

QByteArray Chunks::data(qint64 pos, qint64 maxSize, QByteArray *highlighted)
{
    qint64 ioDelta = 0;
    int chunkIdx = 0;

    Chunk chunk;
    QByteArray buffer;

    // Do some checks and some arrangements
    if (highlighted)
        highlighted->clear();

    if (pos >= _size)
        return buffer;

    if (maxSize < 0)
        maxSize = _size;
    else
        if ((pos + maxSize) > _size)
            maxSize = _size - pos;

    _ioDevice->open(QIODevice::ReadOnly);

    while (maxSize > 0)
    {
        chunk.absPos = LLONG_MAX;
        bool chunksLoopOngoing = true;
        while ((chunkIdx < _chunks.count()) && chunksLoopOngoing)
        {
            // In this section, we track changes before our required data and
            // we take the editdet data, if availible. ioDelta is a difference
            // counter to justify the read pointer to the original data, if
            // data in between was deleted or inserted.

            chunk = _chunks[chunkIdx];
            if (chunk.absPos > pos)
                chunksLoopOngoing = false;
            else
            {
                chunkIdx += 1;
                qint64 count;
                qint64 chunkOfs = pos - chunk.absPos;
                if (maxSize > ((qint64)chunk.data.size() - chunkOfs))
                {
                    count = (qint64)chunk.data.size() - chunkOfs;
                    ioDelta += CHUNK_SIZE - chunk.data.size();
                }
                else
                    count = maxSize;
                if (count > 0)
                {
                    buffer += chunk.data.mid(chunkOfs, (int)count);
                    maxSize -= count;
                    pos += count;
                    if (highlighted)
                        *highlighted += chunk.dataChanged.mid(chunkOfs, (int)count);
                }
            }
        }

        if ((maxSize > 0) && (pos < chunk.absPos))
        {
            // In this section, we read data from the original source. This only will
            // happen, whe no copied data is available

            qint64 byteCount;
            QByteArray readBuffer;
            if ((chunk.absPos - pos) > maxSize)
                byteCount = maxSize;
            else
                byteCount = chunk.absPos - pos;

            maxSize -= byteCount;
            _ioDevice->seek(pos + ioDelta);
            readBuffer = _ioDevice->read(byteCount);
            buffer += readBuffer;
            if (highlighted)
                *highlighted += QByteArray(readBuffer.size(), NORMAL);
            pos += readBuffer.size();
        }
    }
    _ioDevice->close();
    return buffer;
}

bool Chunks::write(QIODevice &iODevice, qint64 pos, qint64 count)
{
    if (count == -1)
        count = _size;
    bool ok = iODevice.open(QIODevice::WriteOnly);
    if (ok)
    {
        for (qint64 idx=pos; idx < count; idx += BUFFER_SIZE)
        {
            QByteArray ba = data(idx, BUFFER_SIZE);
            iODevice.write(ba);
        }
        iODevice.close();
    }
    return ok;
}


// ***************************************** Set and get highlighting infos

void Chunks::setDataChanged(qint64 pos, bool dataChanged)
{
    if ((pos < 0) || (pos >= _size))
        return;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].dataChanged[(int)posInBa] = char(dataChanged);
}

bool Chunks::dataChanged(qint64 pos)
{
    QByteArray highlighted;
    data(pos, 1, &highlighted);
    return bool(highlighted.at(0));
}


// ***************************************** Search API

qint64 Chunks::indexOf(const QByteArray &ba, qint64 from,bool isRegex,bool isCaseInsensitive)
{
    qint64 result = -1;
    QByteArray buffer;
    matchSize = 0;

    for (qint64 pos=from; (pos < _size) && (result < 0); pos += BUFFER_SIZE)
    {
        buffer = data(pos, BUFFER_SIZE + ba.size() - 1);
        int findPos = -1;

        if (isRegex) {
            try {
                std::string regex = ba.toStdString();
                std::string buf = buffer.toStdString();
                int icase = 0;
                if(isCaseInsensitive)
                {
                    icase = std::regex_constants::icase;
                }

                std::regex re(regex,(std::regex_constants::syntax_option_type)icase);

                std::smatch match;
                if (std::regex_search(buf, match, re)) {
                    findPos = match.position(0);
                    matchSize = match.str(0).size();
                }
            } catch (std::regex_error& e) {
               // std::cerr << "Regex syntax error:" << std::endl << e.what() << std::endl;
            }
        } else {
            findPos = buffer.indexOf(ba);
            matchSize = ba.size();
        }

        if (findPos >= 0)
            result = pos + (qint64)findPos;
    }
    return result;
}

qint64 Chunks::lastIndexOf(const QByteArray &ba, qint64 from)
{
    qint64 result = -1;
    QByteArray buffer;

    for (qint64 pos=from; (pos > 0) && (result < 0); pos -= BUFFER_SIZE)
    {
        qint64 sPos = pos - BUFFER_SIZE - (qint64)ba.size() + 1;
        if (sPos < 0)
            sPos = 0;
        buffer = data(sPos, pos - sPos);
        int findPos = buffer.lastIndexOf(ba);
        if (findPos >= 0)
            result = sPos + (qint64)findPos;
    }
    return result;
}


// ***************************************** Char manipulations

bool Chunks::insert(qint64 pos, char b)
{
    if ((pos < 0) || (pos > _size))
        return false;
    int chunkIdx;
    if (pos == _size)
        chunkIdx = getChunkIndex(pos-1);
    else
        chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data.insert(posInBa, b);
    _chunks[chunkIdx].dataChanged.insert(posInBa, char(1));
    for (int idx=chunkIdx+1; idx < _chunks.size(); idx++)
        _chunks[idx].absPos += 1;
    _size += 1;
    _pos = pos;
    return true;
}

bool Chunks::overwrite(qint64 pos, char b)
{
    if ((pos < 0) || (pos >= _size))
        return false;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data[(int)posInBa] = b;
    _chunks[chunkIdx].dataChanged[(int)posInBa] = char(1);
    _pos = pos;
    return true;
}

bool Chunks::removeAt(qint64 pos)
{
    if ((pos < 0) || (pos >= _size))
        return false;
    int chunkIdx = getChunkIndex(pos);
    qint64 posInBa = pos - _chunks[chunkIdx].absPos;
    _chunks[chunkIdx].data.remove(posInBa, 1);
    _chunks[chunkIdx].dataChanged.remove(posInBa, 1);
    for (int idx=chunkIdx+1; idx < _chunks.size(); idx++)
        _chunks[idx].absPos -= 1;
    _size -= 1;
    _pos = pos;
    return true;
}


// ***************************************** Utility functions

char Chunks::operator[](qint64 pos)
{
    return data(pos, 1).at(0);
}

qint64 Chunks::pos()
{
    return _pos;
}

qint64 Chunks::size()
{
    return _size;
}

int Chunks::getChunkIndex(qint64 absPos)
{
    // This routine checks, if there is already a copied chunk available. If os, it
    // returns a reference to it. If there is no copied chunk available, original
    // data will be copied into a new chunk.

    int foundIdx = -1;
    int insertIdx = 0;
    qint64 ioDelta = 0;


    for (int idx=0; idx < _chunks.size(); idx++)
    {
        Chunk chunk = _chunks[idx];
        if ((absPos >= chunk.absPos) && (absPos < (chunk.absPos + chunk.data.size())))
        {
            foundIdx = idx;
            break;
        }
        if (absPos < chunk.absPos)
        {
            insertIdx = idx;
            break;
        }
        ioDelta += chunk.data.size() - CHUNK_SIZE;
        insertIdx = idx + 1;
    }

    if (foundIdx == -1)
    {
        Chunk newChunk;
        qint64 readAbsPos = absPos - ioDelta;
        qint64 readPos = (readAbsPos & READ_CHUNK_MASK);
        _ioDevice->open(QIODevice::ReadOnly);
        _ioDevice->seek(readPos);
        newChunk.data = _ioDevice->read(CHUNK_SIZE);
        _ioDevice->close();
        newChunk.absPos = absPos - (readAbsPos - readPos);
        newChunk.dataChanged = QByteArray(newChunk.data.size(), char(0));
        _chunks.insert(insertIdx, newChunk);
        foundIdx = insertIdx;
    }
    return foundIdx;
}


#ifdef MODUL_TEST
int Chunks::chunkSize()
{
    return _chunks.size();
}

#endif

```

`src/chunks.h`:

```h
#ifndef CHUNKS_H
#define CHUNKS_H

/** \cond docNever */

/*! The Chunks class is the storage backend for QHexEdit.
 *
 * When QHexEdit loads data, Chunks access them using a QIODevice interface. When the app uses
 * a QByteArray interface, QBuffer is used to provide again a QIODevice like interface. No data
 * will be changed, therefore Chunks opens the QIODevice in QIODevice::ReadOnly mode. After every
 * access Chunks closes the QIODevice, that's why external applications can overwrite files while
 * QHexEdit shows them.
 *
 * When the the user starts to edit the data, Chunks creates a local copy of a chunk of data (4
 * kilobytes) and notes all changes there. Parallel to that chunk, there is a second chunk,
 * which keep track of which bytes are changed and which not.
 *
 */

#include <QtCore>
#include <regex>
struct Chunk
{
    QByteArray data;
    QByteArray dataChanged;
    qint64 absPos;
};

class Chunks: public QObject
{
Q_OBJECT
public:
    // Constructors and file settings
    Chunks(QObject *parent);
    Chunks(QIODevice &ioDevice, QObject *parent);
    bool setIODevice(QIODevice &ioDevice);

    // Getting data out of Chunks
    QByteArray data(qint64 pos=0, qint64 count=-1, QByteArray *highlighted=0);
    bool write(QIODevice &iODevice, qint64 pos=0, qint64 count=-1);

    // Set and get highlighting infos
    void setDataChanged(qint64 pos, bool dataChanged);
    bool dataChanged(qint64 pos);

    // Search API
    qint64 indexOf(const QByteArray &ba, qint64 from,bool isRegex,bool isCaseInsensitive);
    qint64 lastIndexOf(const QByteArray &ba, qint64 from);

    // Char manipulations
    bool insert(qint64 pos, char b);
    bool overwrite(qint64 pos, char b);
    bool removeAt(qint64 pos);

    // Utility functions
    char operator[](qint64 pos);
    qint64 pos();
    qint64 size();
    int matchSize = 0;


private:
    int getChunkIndex(qint64 absPos);

    QIODevice * _ioDevice;
    qint64 _pos;
    qint64 _size;
    QList<Chunk> _chunks;

#ifdef MODUL_TEST
public:
    int chunkSize();
#endif
};

/** \endcond docNever */

#endif // CHUNKS_H

```

`src/commands.cpp`:

```cpp
#include "commands.h"
#include <QUndoCommand>


// Helper class to store single byte commands
class CharCommand : public QUndoCommand
{
public:
    enum CCmd {insert, removeAt, overwrite};

    CharCommand(Chunks * chunks, CCmd cmd, qint64 charPos, char newChar,
                       QUndoCommand *parent=0);

    void undo();
    void redo();
    bool mergeWith(const QUndoCommand *command);
    int id() const { return 1234; }

private:
    Chunks * _chunks;
    qint64 _charPos;
    bool _wasChanged;
    char _newChar;
    char _oldChar;
    CCmd _cmd;
};

CharCommand::CharCommand(Chunks * chunks, CCmd cmd, qint64 charPos, char newChar, QUndoCommand *parent)
    : QUndoCommand(parent)
    , _chunks(chunks)
    , _charPos(charPos)
    , _wasChanged(false)
    , _newChar(newChar)
    , _oldChar('\0')
    , _cmd(cmd)
{
}

bool CharCommand::mergeWith(const QUndoCommand *command)
{
    const CharCommand *nextCommand = static_cast<const CharCommand *>(command);
    bool result = false;

    if (_cmd != CharCommand::removeAt)
    {
        if (nextCommand->_cmd == overwrite)
            if (nextCommand->_charPos == _charPos)
            {
                _newChar = nextCommand->_newChar;
                result = true;
            }
    }
    return result;
}

void CharCommand::undo()
{
    switch (_cmd)
    {
        case insert:
            _chunks->removeAt(_charPos);
            break;
        case overwrite:
            _chunks->overwrite(_charPos, _oldChar);
            _chunks->setDataChanged(_charPos, _wasChanged);
            break;
        case removeAt:
            _chunks->insert(_charPos, _oldChar);
            _chunks->setDataChanged(_charPos, _wasChanged);
            break;
    }
}

void CharCommand::redo()
{
    switch (_cmd)
    {
        case insert:
            _chunks->insert(_charPos, _newChar);
            break;
        case overwrite:
            _oldChar = (*_chunks)[_charPos];
            _wasChanged = _chunks->dataChanged(_charPos);
            _chunks->overwrite(_charPos, _newChar);
            break;
        case removeAt:
            _oldChar = (*_chunks)[_charPos];
            _wasChanged = _chunks->dataChanged(_charPos);
            _chunks->removeAt(_charPos);
            break;
    }
}

UndoStack::UndoStack(Chunks * chunks, QObject * parent)
    : QUndoStack(parent)
{
    _chunks = chunks;
    _parent = parent;
    this->setUndoLimit(1000);
}

void UndoStack::insert(qint64 pos, char c)
{
    if ((pos >= 0) && (pos <= _chunks->size()))
    {
        QUndoCommand *cc = new CharCommand(_chunks, CharCommand::insert, pos, c);
        this->push(cc);
    }
}

void UndoStack::insert(qint64 pos, const QByteArray &ba)
{
    if ((pos >= 0) && (pos <= _chunks->size()))
    {
        QString txt = QString(tr("Inserting %1 bytes")).arg(ba.size());
        beginMacro(txt);
        for (int idx=0; idx < ba.size(); idx++)
        {
            QUndoCommand *cc = new CharCommand(_chunks, CharCommand::insert, pos + idx, ba.at(idx));
            this->push(cc);
        }
        endMacro();
    }
}

void UndoStack::removeAt(qint64 pos, qint64 len)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        if (len==1)
        {
            QUndoCommand *cc = new CharCommand(_chunks, CharCommand::removeAt, pos, char(0));
            this->push(cc);
        }
        else
        {
            QString txt = QString(tr("Delete %1 chars")).arg(len);
            beginMacro(txt);
            for (qint64 cnt=0; cnt<len; cnt++)
            {
                QUndoCommand *cc = new CharCommand(_chunks, CharCommand::removeAt, pos, char(0));
                push(cc);
            }
            endMacro();
        }
    }
}

void UndoStack::overwrite(qint64 pos, char c)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        QUndoCommand *cc = new CharCommand(_chunks, CharCommand::overwrite, pos, c);
        this->push(cc);
    }
}

void UndoStack::overwrite(qint64 pos, int len, const QByteArray &ba)
{
    if ((pos >= 0) && (pos < _chunks->size()))
    {
        QString txt = QString(tr("Overwrite %1 chars")).arg(len);
        beginMacro(txt);
        removeAt(pos, len);
        insert(pos, ba);
        endMacro();
    }
}

```

`src/commands.h`:

```h
#ifndef COMMANDS_H
#define COMMANDS_H

/** \cond docNever */

#include <QUndoStack>

#include "chunks.h"

/*! CharCommand is a class to provid undo/redo functionality in QHexEdit.
A QUndoCommand represents a single editing action on a document. CharCommand
is responsable for manipulations on single chars. It can insert. overwrite and
remove characters. A manipulation stores allways two actions
1. redo (or do) action
2. undo action.

CharCommand also supports command compression via mergeWith(). This enables
the user to perform an undo command e.g. 3 steps in a single command.
If you for example insert a new byt "34" this means for the editor doing 3
steps: insert a "00", overwrite it with "03" and the overwrite it with "34". These
3 steps are combined into a single step, insert a "34".

The byte array oriented commands are just put into a set of single byte commands,
which are pooled together with the macroBegin() and macroEnd() functionality of
Qt's QUndoStack.
*/

class UndoStack : public QUndoStack
{
    Q_OBJECT

public:
    UndoStack(Chunks *chunks, QObject * parent=0);
    void insert(qint64 pos, char c);
    void insert(qint64 pos, const QByteArray &ba);
    void removeAt(qint64 pos, qint64 len=1);
    void overwrite(qint64 pos, char c);
    void overwrite(qint64 pos, int len, const QByteArray &ba);

private:
    Chunks * _chunks;
    QObject * _parent;
};

/** \endcond docNever */

#endif // COMMANDS_H

```

`src/license.txt`:

```txt
                  GNU LESSER GENERAL PUBLIC LICENSE
                       Version 2.1, February 1999

 Copyright (C) 1991, 1999 Free Software Foundation, Inc.
 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
 as the successor of the GNU Library Public License, version 2, hence
 the version number 2.1.]

                            Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software--to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software packages--typically libraries--of the
Free Software Foundation and other authors who decide to use it.  You
can use it too, but we suggest you first think carefully about whether
this license or the ordinary General Public License is the better
strategy to use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of
it in new free programs; and that you are informed that you can do
these things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the "Lesser" General Public License because it
does Less to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
"work based on the library" and a "work that uses the library".  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

                  GNU LESSER GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License Agreement applies to any software library or other
program which contains a notice placed by the copyright holder or
other authorized party saying it may be distributed under the terms of
this Lesser General Public License (also called "this License").
Each licensee is addressed as "you".

  A "library" means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The "Library", below, refers to any such software library or work
which has been distributed under these terms.  A "work based on the
Library" means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term "modification".)

  "Source code" for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

  1. You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

  2. You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) The modified work must itself be a software library.

    b) You must cause the files modified to carry prominent notices
    stating that you changed the files and the date of any change.

    c) You must cause the whole of the work to be licensed at no
    charge to all third parties under the terms of this License.

    d) If a facility in the modified Library refers to a function or a
    table of data to be supplied by an application program that uses
    the facility, other than as an argument passed when the facility
    is invoked, then you must make a good faith effort to ensure that,
    in the event an application does not supply such function or
    table, the facility still operates, and performs whatever part of
    its purpose remains meaningful.

    (For example, a function in a library to compute square roots has
    a purpose that is entirely well-defined independent of the
    application.  Therefore, Subsection 2d requires that any
    application-supplied function or table used by this function must
    be optional: if the application does not supply it, the square
    root function must still compute square roots.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

  4. You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

  5. A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a "work that uses the Library".  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a "work that uses the Library" with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a "work that uses the
library".  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a "work that uses the Library" uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

  6. As an exception to the Sections above, you may also combine or
link a "work that uses the Library" with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

    a) Accompany the work with the complete corresponding
    machine-readable source code for the Library including whatever
    changes were used in the work (which must be distributed under
    Sections 1 and 2 above); and, if the work is an executable linked
    with the Library, with the complete machine-readable "work that
    uses the Library", as object code and/or source code, so that the
    user can modify the Library and then relink to produce a modified
    executable containing the modified Library.  (It is understood
    that the user who changes the contents of definitions files in the
    Library will not necessarily be able to recompile the application
    to use the modified definitions.)

    b) Use a suitable shared library mechanism for linking with the
    Library.  A suitable mechanism is one that (1) uses at run time a
    copy of the library already present on the user's computer system,
    rather than copying library functions into the executable, and (2)
    will operate properly with a modified version of the library, if
    the user installs one, as long as the modified version is
    interface-compatible with the version that the work was made with.

    c) Accompany the work with a written offer, valid for at
    least three years, to give the same user the materials
    specified in Subsection 6a, above, for a charge no more
    than the cost of performing this distribution.

    d) If distribution of the work is made by offering access to copy
    from a designated place, offer equivalent access to copy the above
    specified materials from the same place.

    e) Verify that the user has already received a copy of these
    materials or that you have already sent this user a copy.

  For an executable, the required form of the "work that uses the
Library" must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies
the executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

  7. You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

    a) Accompany the combined library with a copy of the same work
    based on the Library, uncombined with any other library
    facilities.  This must be distributed under the terms of the
    Sections above.

    b) Give prominent notice with the combined library of the fact
    that part of it is a work based on the Library, and explaining
    where to find the accompanying uncombined form of the same work.

  8. You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

  9. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

  10. Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

  11. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  12. If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

  13. The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
"any later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

  14. If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

                            NO WARRANTY

  15. BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY "AS IS" WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.

                     END OF TERMS AND CONDITIONS

           How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
"copyright" line and a pointer to where the full notice is found.

    <one line to give the library's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a "copyright disclaimer" for the library, if
necessary.  Here is a sample; alter the names:

  Yoyodyne, Inc., hereby disclaims all copyright interest in the
  library `Frob' (a library for tweaking knobs) written by James Random Hacker.

  <signature of Ty Coon>, 1 April 1990
  Ty Coon, President of Vice

That's all there is to it!
```

`src/qhexedit.cpp`:

```cpp
#include <QApplication>
#include <QClipboard>
#include <QKeyEvent>
#include <QPainter>
#include <QScrollBar>

#include "qhexedit.h"
#include <algorithm>


// ********************************************************************** Constructor, destructor

QHexEdit::QHexEdit(QWidget *parent) : QAbstractScrollArea(parent)
    , _addressArea(true)
    , _addressWidth(4)
    , _asciiArea(true)
    , _bytesPerLine(16)
    , _hexCharsInLine(47)
    , _highlighting(true)
    , _overwriteMode(true)
    , _readOnly(false)
    , _hexCaps(false)
    , _dynamicBytesPerLine(false)
    , _editAreaIsAscii(false)
    , _chunks(new Chunks(this))
    , _cursorPosition(0)
    , _lastEventSize(0)
    , _undoStack(new UndoStack(_chunks, this))
{
#ifdef Q_OS_WIN32
    setFont(QFont("Courier", 10));
#else
    setFont(QFont("Monospace", 10));
#endif
    setAddressAreaColor(this->palette().alternateBase().color());
    setHighlightingColor(QColor(0xff, 0xff, 0x99, 0xff));
    setSelectionColor(this->palette().highlight().color());
    setAddressFontColor(QPalette::WindowText);
    setAsciiAreaColor(this->palette().alternateBase().color());
    setAsciiFontColor(QPalette::WindowText);

    connect(&_cursorTimer, SIGNAL(timeout()), this, SLOT(updateCursor()));
    connect(verticalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(adjust()));
    connect(horizontalScrollBar(), SIGNAL(valueChanged(int)), this, SLOT(adjust()));
    connect(_undoStack, SIGNAL(indexChanged(int)), this, SLOT(dataChangedPrivate(int)));

    _cursorTimer.setInterval(500);
    _cursorTimer.start();

    setAddressWidth(4);
    setAddressArea(true);
    setAsciiArea(true);
    setOverwriteMode(true);
    setHighlighting(true);
    setReadOnly(false);

    init();

}

QHexEdit::~QHexEdit()
{
}

// ********************************************************************** Properties

void QHexEdit::setAddressArea(bool addressArea)
{
    _addressArea = addressArea;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

bool QHexEdit::addressArea()
{
    return _addressArea;
}

void QHexEdit::setAddressAreaColor(const QColor &color)
{
    _addressAreaColor = color;
    viewport()->update();
}

QColor QHexEdit::addressAreaColor()
{
    return _addressAreaColor;
}

void QHexEdit::setAddressFontColor(const QColor &color)
{
    _addressFontColor = color;
    viewport()->update();
}

QColor QHexEdit::addressFontColor()
{
    return _addressFontColor;
}

void QHexEdit::setAsciiAreaColor(const QColor &color)
{
    _asciiAreaColor = color;
    viewport()->update();
}

QColor QHexEdit::asciiAreaColor()
{
    return _asciiAreaColor;
}

void QHexEdit::setAsciiFontColor(const QColor &color)
{
    _asciiFontColor = color;
    viewport()->update();
}

QColor QHexEdit::asciiFontColor()
{
    return _asciiFontColor;
}

void QHexEdit::setHexFontColor(const QColor &color)
{
    _hexFontColor = color;
    viewport()->update();
}

QColor QHexEdit::hexFontColor()
{
    return _hexFontColor;
}

void QHexEdit::setAddressOffset(qint64 addressOffset)
{
    _addressOffset = addressOffset;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

qint64 QHexEdit::addressOffset()
{
    return _addressOffset;
}

void QHexEdit::setAddressWidth(int addressWidth)
{
    _addressWidth = addressWidth;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

qint64 QHexEdit::getSize()
{
    return _chunks->size();
}
int QHexEdit::addressWidth()
{
    qint64 size = _chunks->size();
    int n = 1;
    if (size > Q_INT64_C(0x100000000)){ n += 8; size /= Q_INT64_C(0x100000000);}
    if (size > 0x10000){ n += 4; size /= 0x10000;}
    if (size > 0x100){ n += 2; size /= 0x100;}
    if (size > 0x10){ n += 1;}

    if (n > _addressWidth)
        return n;
    else
        return _addressWidth;
}

void QHexEdit::setAsciiArea(bool asciiArea)
{
    if (!asciiArea)
        _editAreaIsAscii = false;
    _asciiArea = asciiArea;
    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

bool QHexEdit::asciiArea()
{
    return _asciiArea;
}

void QHexEdit::setBytesPerLine(int count)
{
    _bytesPerLine = count;
    _hexCharsInLine = count * 3 - 1;

    adjust();
    setCursorPosition(_cursorPosition);
    viewport()->update();
}

int QHexEdit::bytesPerLine()
{
    return _bytesPerLine;
}

void QHexEdit::setCursorPosition(qint64 position)
{
    // 1. delete old cursor
    _blink = false;
    viewport()->update(_cursorRect);

    // 2. Check, if cursor in range?
    if (position > (_chunks->size() * 2 - 1))
        position = _chunks->size() * 2  - (_overwriteMode ? 1 : 0);

    if (position < 0)
        position = 0;

    // 3. Calc new position of cursor
    _bPosCurrent = position / 2;
    _pxCursorY = ((position / 2 - _bPosFirst) / _bytesPerLine + 1) * _pxCharHeight;
    int x = (position % (2 * _bytesPerLine));
    if (_editAreaIsAscii)
    {
        _pxCursorX = x / 2 * _pxCharWidth + _pxPosAsciiX;
        _cursorPosition = position & 0xFFFFFFFFFFFFFFFE;
    } else {
        _pxCursorX = (((x / 2) * 3) + (x % 2)) * _pxCharWidth + _pxPosHexX;
        _cursorPosition = position;
    }

    if (_overwriteMode)
        _cursorRect = QRect(_pxCursorX - horizontalScrollBar()->value(), _pxCursorY + _pxCursorWidth, _pxCharWidth, _pxCursorWidth);
    else
        _cursorRect = QRect(_pxCursorX - horizontalScrollBar()->value(), _pxCursorY - _pxCharHeight + 4, _pxCursorWidth, _pxCharHeight);

    // 4. Immediately draw new cursor
    _blink = true;
    viewport()->update(_cursorRect);
    emit currentAddressChanged(_bPosCurrent);
}

qint64 QHexEdit::cursorPosition(QPoint pos)
{
    // Calc cursor position depending on a graphical position
    qint64 result = -1;
    int posX = pos.x() + horizontalScrollBar()->value();
    int posY = pos.y() - 3;
    if ((posX >= _pxPosHexX) && (posX < (_pxPosHexX + (1 + _hexCharsInLine) * _pxCharWidth)))
    {
        _editAreaIsAscii = false;
        int x = (posX - _pxPosHexX) / _pxCharWidth;
        x = (x / 3) * 2 + x % 3;
        int y = (posY / _pxCharHeight) * 2 * _bytesPerLine;
        result = _bPosFirst * 2 + x + y;
    }
    else
        if (_asciiArea && (posX >= _pxPosAsciiX) && (posX < (_pxPosAsciiX + (1 + _bytesPerLine) * _pxCharWidth)))
        {
            _editAreaIsAscii = true;
            int x = 2 * (posX - _pxPosAsciiX) / _pxCharWidth;
            int y = (posY / _pxCharHeight) * 2 * _bytesPerLine;
            result = _bPosFirst * 2 + x + y;
        }
    return result;
}

qint64 QHexEdit::cursorPosition()
{
    return _cursorPosition;
}

void QHexEdit::setData(const QByteArray &ba)
{
    _data = ba;
    _bData.setData(_data);
    setData(_bData);
}

QByteArray QHexEdit::data()
{
    return _chunks->data(0, -1);
}

void QHexEdit::setHighlighting(bool highlighting)
{
    _highlighting = highlighting;
    viewport()->update();
}

bool QHexEdit::highlighting()
{
    return _highlighting;
}

void QHexEdit::setHighlightingColor(const QColor &color)
{
    _brushHighlighted = QBrush(color);
    _penHighlighted = QPen(viewport()->palette().color(QPalette::WindowText));
    viewport()->update();
}

QColor QHexEdit::highlightingColor()
{
    return _brushHighlighted.color();
}

void QHexEdit::setOverwriteMode(bool overwriteMode)
{
    _overwriteMode = overwriteMode;
    emit overwriteModeChanged(overwriteMode);
}

bool QHexEdit::overwriteMode()
{
    return _overwriteMode;
}

void QHexEdit::setSelectionColor(const QColor &color)
{
    _brushSelection = QBrush(color);
    _penSelection = QPen(Qt::white);
    viewport()->update();
}

QColor QHexEdit::selectionColor()
{
    return _brushSelection.color();
}

bool QHexEdit::isReadOnly()
{
    return _readOnly;
}

void QHexEdit::setReadOnly(bool readOnly)
{
    _readOnly = readOnly;
}

void QHexEdit::setHexCaps(const bool isCaps)
{
    if (_hexCaps != isCaps)
    {
        _hexCaps = isCaps;
        viewport()->update();
    }
}

bool QHexEdit::hexCaps()
{
    return _hexCaps;
}

void QHexEdit::setDynamicBytesPerLine(const bool isDynamic)
{
    _dynamicBytesPerLine = isDynamic;
    resizeEvent(NULL);
}

bool QHexEdit::dynamicBytesPerLine()
{
    return _dynamicBytesPerLine;
}

// ********************************************************************** Access to data of qhexedit
bool QHexEdit::setData(QIODevice &iODevice)
{
    bool ok = _chunks->setIODevice(iODevice);
    init();
    dataChangedPrivate();
    return ok;
}

QByteArray QHexEdit::dataAt(qint64 pos, qint64 count)
{
    return _chunks->data(pos, count);
}

bool QHexEdit::write(QIODevice &iODevice, qint64 pos, qint64 count)
{
    return _chunks->write(iODevice, pos, count);
}

// ********************************************************************** Char handling
void QHexEdit::insert(qint64 index, char ch)
{
    _undoStack->insert(index, ch);
    refresh();
}

void QHexEdit::remove(qint64 index, qint64 len)
{
    _undoStack->removeAt(index, len);
    refresh();
}

void QHexEdit::replace(qint64 index, char ch)
{
    _undoStack->overwrite(index, ch);
    refresh();
}

// ********************************************************************** ByteArray handling
void QHexEdit::insert(qint64 pos, const QByteArray &ba)
{
    _undoStack->insert(pos, ba);
    refresh();
}

void QHexEdit::replace(qint64 pos, qint64 len, const QByteArray &ba)
{
    _undoStack->overwrite(pos, len, ba);
    refresh();
}

// ********************************************************************** Utility functions
void QHexEdit::ensureVisible()
{
    if (_cursorPosition < (_bPosFirst * 2))
        verticalScrollBar()->setValue((int)(_cursorPosition / 2 / _bytesPerLine));
    if (_cursorPosition > ((_bPosFirst + (_rowsShown - 1)*_bytesPerLine) * 2))
        verticalScrollBar()->setValue((int)(_cursorPosition / 2 / _bytesPerLine) - _rowsShown + 1);
    if (_pxCursorX < horizontalScrollBar()->value())
        horizontalScrollBar()->setValue(_pxCursorX);
    if ((_pxCursorX + _pxCharWidth) > (horizontalScrollBar()->value() + viewport()->width()))
        horizontalScrollBar()->setValue(_pxCursorX + _pxCharWidth - viewport()->width());
    viewport()->update();
}

qint64 QHexEdit::indexOf(const QByteArray &ba, qint64 from, bool isRegex,bool isCaseInsensitive)
{
    qint64 pos = _chunks->indexOf(ba, from,isRegex,isCaseInsensitive);
    if (pos > -1)
    {
        qint64 curPos = pos*2;
        setCursorPosition(curPos + _chunks->matchSize*2);
        resetSelection(curPos);
        setSelection(curPos + _chunks->matchSize*2);
        ensureVisible();
    }
    return pos;
}

bool QHexEdit::isModified()
{
    return _modified;
}

qint64 QHexEdit::lastIndexOf(const QByteArray &ba, qint64 from)
{
    qint64 pos = _chunks->lastIndexOf(ba, from);
    if (pos > -1)
    {
        qint64 curPos = pos*2;
        setCursorPosition(curPos - 1);
        resetSelection(curPos);
        setSelection(curPos + ba.length()*2);
        ensureVisible();
    }
    return pos;
}

void QHexEdit::redo()
{
    _undoStack->redo();
    setCursorPosition(_chunks->pos()*(_editAreaIsAscii ? 1 : 2));
    refresh();
}

QString QHexEdit::selectionToReadableString()
{
    QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
    return toReadable(ba);
}

QString QHexEdit::selectedData()
{
    QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin()).toHex();
    return ba;
}
QByteArray QHexEdit::selectedDataBa()
{
    QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
    return ba;
}


void QHexEdit::setFont(const QFont &font)
{
    QFont theFont(font);
    theFont.setStyleHint(QFont::Monospace);
    QWidget::setFont(theFont);
    QFontMetrics metrics = fontMetrics();
#if QT_VERSION > QT_VERSION_CHECK(5, 11, 0)
    _pxCharWidth = metrics.horizontalAdvance(QLatin1Char('2'));
#else
    _pxCharWidth = metrics.width(QLatin1Char('2'));
#endif
    _pxCharHeight = metrics.height();
    _pxGapAdr = _pxCharWidth / 2;
    _pxGapAdrHex = _pxCharWidth;
    _pxGapHexAscii = 2 * _pxCharWidth;
    _pxCursorWidth = _pxCharHeight / 7;
    _pxSelectionSub = _pxCharHeight / 5;
    viewport()->update();
}

QString QHexEdit::toReadableString()
{
    QByteArray ba = _chunks->data();
    return toReadable(ba);
}

void QHexEdit::undo()
{
    _undoStack->undo();
    setCursorPosition(_chunks->pos()*(_editAreaIsAscii ? 1 : 2));
    refresh();
}

// ********************************************************************** Handle events
void QHexEdit::keyPressEvent(QKeyEvent *event)
{
    // Cursor movements
    if (event->matches(QKeySequence::MoveToNextChar))
    {
        qint64 pos = _cursorPosition + 1;
        if (_editAreaIsAscii)
            pos += 1;
        setCursorPosition(pos);
        resetSelection(pos);
    }
    if (event->matches(QKeySequence::MoveToPreviousChar))
    {
        qint64 pos = _cursorPosition - 1;
        if (_editAreaIsAscii)
            pos -= 1;
        setCursorPosition(pos);
        resetSelection(pos);
    }
    if (event->matches(QKeySequence::MoveToEndOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine)) + (2 * _bytesPerLine) - 1;
        setCursorPosition(pos);
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToStartOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine));
        setCursorPosition(pos);
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToPreviousLine))
    {
        setCursorPosition(_cursorPosition - (2 * _bytesPerLine));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToNextLine))
    {
        setCursorPosition(_cursorPosition + (2 * _bytesPerLine));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToNextPage))
    {
        setCursorPosition(_cursorPosition + (((_rowsShown - 1) * 2 * _bytesPerLine)));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToPreviousPage))
    {
        setCursorPosition(_cursorPosition - (((_rowsShown - 1) * 2 * _bytesPerLine)));
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToEndOfDocument))
    {
        setCursorPosition(_chunks->size() * 2 );
        resetSelection(_cursorPosition);
    }
    if (event->matches(QKeySequence::MoveToStartOfDocument))
    {
        setCursorPosition(0);
        resetSelection(_cursorPosition);
    }

    // Select commands
    if (event->matches(QKeySequence::SelectAll))
    {
        resetSelection(0);
        setSelection(2 * _chunks->size() + 1);
    }
    if (event->matches(QKeySequence::SelectNextChar))
    {
        qint64 pos = _cursorPosition + 1;
        if (_editAreaIsAscii)
            pos += 1;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousChar))
    {
        qint64 pos = _cursorPosition - 1;
        if (_editAreaIsAscii)
            pos -= 1;
        setSelection(pos);
        setCursorPosition(pos);
    }
    if (event->matches(QKeySequence::SelectEndOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine)) + (2 * _bytesPerLine) - 1;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectStartOfLine))
    {
        qint64 pos = _cursorPosition - (_cursorPosition % (2 * _bytesPerLine));
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousLine))
    {
        qint64 pos = _cursorPosition - (2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectNextLine))
    {
        qint64 pos = _cursorPosition + (2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectNextPage))
    {
        qint64 pos = _cursorPosition + (((viewport()->height() / _pxCharHeight) - 1) * 2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectPreviousPage))
    {
        qint64 pos = _cursorPosition - (((viewport()->height() / _pxCharHeight) - 1) * 2 * _bytesPerLine);
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectEndOfDocument))
    {
        qint64 pos = _chunks->size() * 2;
        setCursorPosition(pos);
        setSelection(pos);
    }
    if (event->matches(QKeySequence::SelectStartOfDocument))
    {
        qint64 pos = 0;
        setCursorPosition(pos);
        setSelection(pos);
    }

    // Edit Commands
    if (!_readOnly)
    {
        /* Cut */
        if (event->matches(QKeySequence::Cut))
        {
            QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin()).toHex();
            for (qint64 idx = 32; idx < ba.size(); idx +=33)
                ba.insert(idx, "\n");
            QClipboard *clipboard = QApplication::clipboard();
            clipboard->setText(ba);
            if (_overwriteMode)
            {
                qint64 len = getSelectionEnd() - getSelectionBegin();
                replace(getSelectionBegin(), (int)len, QByteArray((int)len, char(0)));
            }
            else
            {
                remove(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
            }
            setCursorPosition(2 * getSelectionBegin());
            resetSelection(2 * getSelectionBegin());
        } else

        /* Paste */
        if (event->matches(QKeySequence::Paste))
        {
            QClipboard *clipboard = QApplication::clipboard();
            QByteArray ba = QByteArray().fromHex(clipboard->text().toLatin1());
            if (_overwriteMode)
            {
                ba = ba.left(std::min<qint64>(ba.size(), (_chunks->size() - _bPosCurrent)));
                replace(_bPosCurrent, ba.size(), ba);
            }
            else
                insert(_bPosCurrent, ba);
            setCursorPosition(_cursorPosition + 2 * ba.size());
            resetSelection(getSelectionBegin());
        } else

        /* Delete char */
        if (event->matches(QKeySequence::Delete))
        {
            if (getSelectionBegin() != getSelectionEnd())
            {
                _bPosCurrent = getSelectionBegin();
                if (_overwriteMode)
                {
                    QByteArray ba = QByteArray(getSelectionEnd() - getSelectionBegin(), char(0));
                    replace(_bPosCurrent, ba.size(), ba);
                }
                else
                {
                    remove(_bPosCurrent, getSelectionEnd() - getSelectionBegin());
                }
            }
            else
            {
                if (_overwriteMode)
                    replace(_bPosCurrent, char(0));
                else
                    remove(_bPosCurrent, 1);
            }
            setCursorPosition(2 * _bPosCurrent);
            resetSelection(2 * _bPosCurrent);
        } else

        /* Backspace */
        if ((event->key() == Qt::Key_Backspace) && (event->modifiers() == Qt::NoModifier))
        {
            if (getSelectionBegin() != getSelectionEnd())
            {
                _bPosCurrent = getSelectionBegin();
                setCursorPosition(2 * _bPosCurrent);
                if (_overwriteMode)
                {
                    QByteArray ba = QByteArray(getSelectionEnd() - getSelectionBegin(), char(0));
                    replace(_bPosCurrent, ba.size(), ba);
                }
                else
                {
                    remove(_bPosCurrent, getSelectionEnd() - getSelectionBegin());
                }
                resetSelection(2 * _bPosCurrent);
            }
            else
            {
                bool behindLastByte = false;
                if ((_cursorPosition / 2) == _chunks->size())
                    behindLastByte = true;

                _bPosCurrent -= 1;
                if (_overwriteMode)
                    replace(_bPosCurrent, char(0));
                else
                    remove(_bPosCurrent, 1);

                if (!behindLastByte)
                    _bPosCurrent -= 1;

                setCursorPosition(2 * _bPosCurrent);
                resetSelection(2 * _bPosCurrent);
            }
        } else

        /* undo */
        if (event->matches(QKeySequence::Undo))
        {
            undo();
        } else

        /* redo */
        if (event->matches(QKeySequence::Redo))
        {
            redo();
        } else

        if ((QApplication::keyboardModifiers() == Qt::NoModifier) ||
            (QApplication::keyboardModifiers() == Qt::KeypadModifier) ||
            (QApplication::keyboardModifiers() == Qt::ShiftModifier) ||
            (QApplication::keyboardModifiers() == (Qt::AltModifier | Qt::ControlModifier)) ||
            (QApplication::keyboardModifiers() == Qt::GroupSwitchModifier))
        {
            /* Hex and ascii input */
            int key = 0;
            QString text = event->text();
            if (!text.isEmpty())
            {
                if (_editAreaIsAscii)
                    key = (uchar)text.at(0).toLatin1();
                else
                    key = int(text.at(0).toLower().toLatin1());
            }

            if ((((key >= '0' && key <= '9') || (key >= 'a' && key <= 'f')) && _editAreaIsAscii == false)
                || (key >= ' ' && _editAreaIsAscii))
            {
                if (getSelectionBegin() != getSelectionEnd())
                {
                    if (_overwriteMode)
                    {
                        qint64 len = getSelectionEnd() - getSelectionBegin();
                        replace(getSelectionBegin(), (int)len, QByteArray((int)len, char(0)));
                    } else
                    {
                        remove(getSelectionBegin(), getSelectionEnd() - getSelectionBegin());
                        _bPosCurrent = getSelectionBegin();
                    }
                    setCursorPosition(2 * _bPosCurrent);
                    resetSelection(2 * _bPosCurrent);
                }

                // If insert mode, then insert a byte
                if (_overwriteMode == false)
                    if ((_cursorPosition % 2) == 0)
                        insert(_bPosCurrent, char(0));

                // Change content
                if (_chunks->size() > 0)
                {
                    char ch = key;
                    if (!_editAreaIsAscii){
                        QByteArray hexValue = _chunks->data(_bPosCurrent, 1).toHex();
                        if ((_cursorPosition % 2) == 0)
                            hexValue[0] = key;
                        else
                            hexValue[1] = key;
                        ch = QByteArray().fromHex(hexValue)[0];
                    }
                    replace(_bPosCurrent, ch);
                    if (_editAreaIsAscii)
                        setCursorPosition(_cursorPosition + 2);
                    else
                        setCursorPosition(_cursorPosition + 1);
                    resetSelection(_cursorPosition);
                }
            }
        }


    }

    /* Copy */
    if (event->matches(QKeySequence::Copy))
    {
        QByteArray ba = _chunks->data(getSelectionBegin(), getSelectionEnd() - getSelectionBegin()).toHex();
        for (qint64 idx = 32; idx < ba.size(); idx +=33)
            ba.insert(idx, "\n");
        QClipboard *clipboard = QApplication::clipboard();
        clipboard->setText(ba);
    }

    // Switch between insert/overwrite mode
    if ((event->key() == Qt::Key_Insert) && (event->modifiers() == Qt::NoModifier))
    {
        setOverwriteMode(!overwriteMode());
        setCursorPosition(_cursorPosition);
    }

    // switch from hex to ascii edit
    if (event->key() == Qt::Key_Tab && !_editAreaIsAscii){
        _editAreaIsAscii = true;
        setCursorPosition(_cursorPosition);
    }

    // switch from ascii to hex edit
    if (event->key() == Qt::Key_Backtab  && _editAreaIsAscii){
        _editAreaIsAscii = false;
        setCursorPosition(_cursorPosition);
    }

    refresh();
    QAbstractScrollArea::keyPressEvent(event);
}

void QHexEdit::mouseMoveEvent(QMouseEvent * event)
{
    _blink = false;
    viewport()->update();
    qint64 actPos = cursorPosition(event->pos());
    if (actPos >= 0)
    {
        setCursorPosition(actPos);
        setSelection(actPos);
    }
}

void QHexEdit::mousePressEvent(QMouseEvent * event)
{
    _blink = false;
    viewport()->update();
    qint64 cPos = cursorPosition(event->pos());
    if (cPos >= 0)
    {
        if (event->button() != Qt::RightButton)
            resetSelection(cPos);
        setCursorPosition(cPos);
    }
}

void QHexEdit::paintEvent(QPaintEvent *event)
{
    QPainter painter(viewport());
    int pxOfsX = horizontalScrollBar()->value();

    if (event->rect() != _cursorRect)
    {
        int pxPosStartY = _pxCharHeight;

        // draw some patterns if needed
        painter.fillRect(event->rect(), viewport()->palette().color(QPalette::Base));
        if (_addressArea)
            painter.fillRect(QRect(-pxOfsX, event->rect().top(), _pxPosHexX - _pxGapAdrHex/2, height()), _addressAreaColor);
        if (_asciiArea)
        {
            int linePos = _pxPosAsciiX - (_pxGapHexAscii / 2);
            painter.setPen(Qt::gray);
            painter.drawLine(linePos - pxOfsX, event->rect().top(), linePos - pxOfsX, height());
        }

        painter.setPen(viewport()->palette().color(QPalette::WindowText));

        // paint address area
        if (_addressArea)
        {
            QString address;
            for (int row=0, pxPosY = _pxCharHeight; row <= (_dataShown.size()/_bytesPerLine); row++, pxPosY +=_pxCharHeight)
            {
                address = QString("%1").arg(_bPosFirst + row*_bytesPerLine + _addressOffset, _addrDigits, 16, QChar('0'));
                painter.setPen(QPen(_addressFontColor));
                painter.drawText(_pxPosAdrX - pxOfsX, pxPosY, hexCaps() ? address.toUpper() : address);
            }
        }

        // paint hex and ascii area
        QPen colStandard = QPen(viewport()->palette().color(QPalette::WindowText));

        painter.setBackgroundMode(Qt::TransparentMode);

        for (int row = 0, pxPosY = pxPosStartY; row <= _rowsShown; row++, pxPosY +=_pxCharHeight)
        {
            QByteArray hex;
            int pxPosX = _pxPosHexX  - pxOfsX;
            int pxPosAsciiX2 = _pxPosAsciiX  - pxOfsX;
            qint64 bPosLine = row * _bytesPerLine;
            for (int colIdx = 0; ((bPosLine + colIdx) < _dataShown.size() && (colIdx < _bytesPerLine)); colIdx++)
            {
                QColor c = viewport()->palette().color(QPalette::Base);
                painter.setPen(QPen(_hexFontColor));

                qint64 posBa = _bPosFirst + bPosLine + colIdx;
                if ((getSelectionBegin() <= posBa) && (getSelectionEnd() > posBa))
                {
                    c = _brushSelection.color();
                    painter.setPen(_penSelection);
                }
                else
                {
                    if (_highlighting)
                        if (_markedShown.at((int)(posBa - _bPosFirst)))
                        {
                            c = _brushHighlighted.color();
                            painter.setPen(_penHighlighted);
                        }
                }

                // render hex value
                QRect r;
                if (colIdx == 0)
                    r.setRect(pxPosX, pxPosY - _pxCharHeight + _pxSelectionSub, 2*_pxCharWidth, _pxCharHeight);
                else
                    r.setRect(pxPosX - _pxCharWidth, pxPosY - _pxCharHeight + _pxSelectionSub, 3*_pxCharWidth, _pxCharHeight);
                painter.fillRect(r, c);
                hex = _hexDataShown.mid((bPosLine + colIdx) * 2, 2);
                painter.drawText(pxPosX, pxPosY, hexCaps()?hex.toUpper():hex);
                pxPosX += 3*_pxCharWidth;

                // render ascii value
                if (_asciiArea)
                {
                    if (c == viewport()->palette().color(QPalette::Base))
                        c = _asciiAreaColor;
                    int ch = (uchar)_dataShown.at(bPosLine + colIdx);
                    if ( ch < ' ' || ch > '~' )
                        ch = '.';
                    r.setRect(pxPosAsciiX2, pxPosY - _pxCharHeight + _pxSelectionSub, _pxCharWidth, _pxCharHeight);
                    painter.fillRect(r, c);
                    painter.setPen(QPen(_asciiFontColor));
                    painter.drawText(pxPosAsciiX2, pxPosY, QChar(ch));
                    pxPosAsciiX2 += _pxCharWidth;
                }
            }
        }
        painter.setBackgroundMode(Qt::TransparentMode);
        painter.setPen(viewport()->palette().color(QPalette::WindowText));
    }

    // _cursorPosition counts in 2, _bPosFirst counts in 1
    int hexPositionInShowData = _cursorPosition - 2 * _bPosFirst;

    // due to scrolling the cursor can go out of the currently displayed data
    if ((hexPositionInShowData >= 0) && (hexPositionInShowData < _hexDataShown.size()))
    {
        // paint cursor
        if (_readOnly)
        {
            QColor color = viewport()->palette().dark().color();
            painter.fillRect(QRect(_pxCursorX - pxOfsX, _pxCursorY - _pxCharHeight + _pxSelectionSub, _pxCharWidth, _pxCharHeight), color);
        }
        else
        {
            if (_blink && hasFocus())
                painter.fillRect(_cursorRect, this->palette().color(QPalette::WindowText));
        }
            if (_editAreaIsAscii)
            {
                // every 2 hex there is 1 ascii
                int asciiPositionInShowData = hexPositionInShowData / 2;
                int ch = (uchar)_dataShown.at(asciiPositionInShowData);
                if (ch < ' ' || ch > '~')
                    ch = '.';

                painter.drawText(_pxCursorX - pxOfsX, _pxCursorY, QChar(ch));
            }
            else
            {
                painter.drawText(_pxCursorX - pxOfsX, _pxCursorY, hexCaps() ? _hexDataShown.mid(hexPositionInShowData, 1).toUpper() : _hexDataShown.mid(hexPositionInShowData, 1));
            }
    }

    // emit event, if size has changed
    if (_lastEventSize != _chunks->size())
    {
        _lastEventSize = _chunks->size();
        emit currentSizeChanged(_lastEventSize);
    }
}

void QHexEdit::resizeEvent(QResizeEvent *)
{
    if (_dynamicBytesPerLine)
    {
        int pxFixGaps = 0;
        if (_addressArea)
            pxFixGaps = addressWidth() * _pxCharWidth + _pxGapAdr;
        pxFixGaps += _pxGapAdrHex;
        if (_asciiArea)
            pxFixGaps += _pxGapHexAscii;

        // +1 because the last hex value do not have space. so it is effective one char more
        int charWidth = (viewport()->width() - pxFixGaps ) / _pxCharWidth + 1;

        // 2 hex alfa-digits 1 space 1 ascii per byte = 4; if ascii is disabled then 3
        // to prevent devision by zero use the min value 1
        setBytesPerLine(std::max(charWidth / (_asciiArea ? 4 : 3),1));
    }
    adjust();
}

bool QHexEdit::focusNextPrevChild(bool next)
{
    if (_addressArea)
    {
        if ( (next && _editAreaIsAscii) || (!next && !_editAreaIsAscii ))
            return QWidget::focusNextPrevChild(next);
        else
            return false;
    }
    else
    {
        return QWidget::focusNextPrevChild(next);
    }
}

// ********************************************************************** Handle selections
void QHexEdit::resetSelection()
{
    _bSelectionBegin = _bSelectionInit;
    _bSelectionEnd = _bSelectionInit;
}

void QHexEdit::resetSelection(qint64 pos)
{
    pos = pos / 2 ;
    if (pos < 0)
        pos = 0;
    if (pos > _chunks->size())
        pos = _chunks->size();

    _bSelectionInit = pos;
    _bSelectionBegin = pos;
    _bSelectionEnd = pos;
}

void QHexEdit::setSelection(qint64 pos)
{
    pos = pos / 2;
    if (pos < 0)
        pos = 0;
    if (pos > _chunks->size())
        pos = _chunks->size();

    if (pos >= _bSelectionInit)
    {
        _bSelectionEnd = pos;
        _bSelectionBegin = _bSelectionInit;
    }
    else
    {
        _bSelectionBegin = pos;
        _bSelectionEnd = _bSelectionInit;
    }
}

qint64 QHexEdit::getSelectionBegin()
{
    return _bSelectionBegin;
}

qint64 QHexEdit::getSelectionEnd()
{
    return _bSelectionEnd;
}

// ********************************************************************** Private utility functions
void QHexEdit::init()
{
    _undoStack->clear();
    setAddressOffset(0);
    resetSelection(0);
    setCursorPosition(0);
    verticalScrollBar()->setValue(0);
    _modified = false;
}

void QHexEdit::adjust()
{
    // recalc Graphics
    if (_addressArea)
    {
        _addrDigits = addressWidth();
        _pxPosHexX = _pxGapAdr + _addrDigits*_pxCharWidth + _pxGapAdrHex;
    }
    else
        _pxPosHexX = _pxGapAdrHex;
    _pxPosAdrX = _pxGapAdr;
    _pxPosAsciiX = _pxPosHexX + _hexCharsInLine * _pxCharWidth + _pxGapHexAscii;

    // set horizontalScrollBar()
    int pxWidth = _pxPosAsciiX;
    if (_asciiArea)
        pxWidth += _bytesPerLine*_pxCharWidth;
    horizontalScrollBar()->setRange(0, pxWidth - viewport()->width());
    horizontalScrollBar()->setPageStep(viewport()->width());

    // set verticalScrollbar()
    _rowsShown = ((viewport()->height()-4)/_pxCharHeight);
    int lineCount = (int)(_chunks->size() / (qint64)_bytesPerLine) + 1;
    verticalScrollBar()->setRange(0, lineCount - _rowsShown);
    verticalScrollBar()->setPageStep(_rowsShown);

    int value = verticalScrollBar()->value();
    _bPosFirst = (qint64)value * _bytesPerLine;
    _bPosLast = _bPosFirst + (qint64)(_rowsShown * _bytesPerLine) - 1;
    if (_bPosLast >= _chunks->size())
        _bPosLast = _chunks->size() - 1;
    readBuffers();
    setCursorPosition(_cursorPosition);
}

void QHexEdit::dataChangedPrivate(int)
{
    _modified = _undoStack->index() != 0;
    adjust();
    emit dataChanged();
}

void QHexEdit::refresh()
{
    ensureVisible();
    readBuffers();
}

void QHexEdit::readBuffers()
{
    _dataShown = _chunks->data(_bPosFirst, _bPosLast - _bPosFirst + _bytesPerLine + 1, &_markedShown);
    _hexDataShown = QByteArray(_dataShown.toHex());
}

QString QHexEdit::toReadable(const QByteArray &ba)
{
    QString result;

    for (int i=0; i < ba.size(); i += 16)
    {
        QString addrStr = QString("%1").arg(_addressOffset + i, addressWidth(), 16, QChar('0'));
        QString hexStr;
        QString ascStr;
        for (int j=0; j<16; j++)
        {
            if ((i + j) < ba.size())
            {
                hexStr.append(" ").append(ba.mid(i+j, 1).toHex());
                char ch = ba[i + j];
                if ((ch < 0x20) || (ch > 0x7e))
                        ch = '.';
                ascStr.append(QChar(ch));
            }
        }
        result += addrStr + " " + QString("%1").arg(hexStr, -48) + "  " + QString("%1").arg(ascStr, -17) + "\n";
    }
    return result;
}

void QHexEdit::updateCursor()
{
    if (_blink)
        _blink = false;
    else
        _blink = true;
    viewport()->update(_cursorRect);
}

```

`src/qhexedit.h`:

```h
#ifndef QHEXEDIT_H
#define QHEXEDIT_H

#include <QAbstractScrollArea>
#include <QPen>
#include <QBrush>

#include "chunks.h"
#include "commands.h"

#ifdef QHEXEDIT_EXPORTS
#define QHEXEDIT_API Q_DECL_EXPORT
#elif QHEXEDIT_IMPORTS
#define QHEXEDIT_API Q_DECL_IMPORT
#else
#define QHEXEDIT_API
#endif

/** \mainpage
QHexEdit is a binary editor widget for Qt.

\version Version 0.8.9
\image html qhexedit.png
*/


/** QHexEdit is a hex editor widget written in C++ for the Qt (Qt4, Qt5) framework.
It is a simple editor for binary data, just like QPlainTextEdit is for text
data. There are sip configuration files included, so it is easy to create
bindings for PyQt and you can use this widget also in python 2 and 3.

QHexEdit takes the data of a QByteArray (setData()) and shows it. You can use
the mouse or the keyboard to navigate inside the widget. If you hit the keys
(0..9, a..f) you will change the data. Changed data is highlighted and can be
accessed via data().

Normally QHexEdit works in the overwrite mode. You can set overwrite mode(false)
and insert data. In this case the size of data() increases. It is also possible
to delete bytes (del or backspace), here the size of data decreases.

You can select data with keyboard hits or mouse movements. The copy-key will
copy the selected data into the clipboard. The cut-key copies also but deletes
it afterwards. In overwrite mode, the paste function overwrites the content of
the (does not change the length) data. In insert mode, clipboard data will be
inserted. The clipboard content is expected in ASCII Hex notation. Unknown
characters will be ignored.

QHexEdit comes with undo/redo functionality. All changes can be undone, by
pressing the undo-key (usually ctr-z). They can also be redone afterwards.
The undo/redo framework is cleared, when setData() sets up a new
content for the editor. You can search data inside the content with indexOf()
and lastIndexOf(). The replace() function is to change located subdata. This
'replaced' data can also be undone by the undo/redo framework.

QHexEdit is based on QIODevice, that's why QHexEdit can handle big amounts of
data. The size of edited data can be more then two gigabytes without any
restrictions.
*/
class QHEXEDIT_API QHexEdit : public QAbstractScrollArea
{
    Q_OBJECT

    /*! Property address area switch the address area on or off. Set addressArea true
    (show it), false (hide it).
    */
    Q_PROPERTY(bool addressArea READ addressArea WRITE setAddressArea)

    /*! Property address area color sets (setAddressAreaColor()) the background
    color of address areas. You can also read the color (addressAreaColor()).
    */
    Q_PROPERTY(QColor addressAreaColor READ addressAreaColor WRITE setAddressAreaColor)

    /*! Property address font color sets (setAddressFontColor()) the text
    color of address areas. You can also read the color (addressFontColor()).
    */
    Q_PROPERTY(QColor addressFontColor READ addressFontColor WRITE setAddressFontColor)

    /*! Property ascii area color sets (setAsciiAreaColor()) the backgorund
    color of ascii areas. You can also read the color (asciiAreaColor()).
    */
    Q_PROPERTY(QColor asciiAreaColor READ asciiAreaColor WRITE setAsciiAreaColor)

    /*! Property ascii font color sets (setAsciiFontColor()) the text
    color of ascii areas. You can also read the color (asciiFontColor()).
    */
    Q_PROPERTY(QColor asciiFontColor READ asciiFontColor WRITE setAsciiFontColor)

    /*! Property hex font color sets (setHexFontColor()) the text
    color of hex areas. You can also read the color (hexFontColor()).
    */
    Q_PROPERTY(QColor hexFontColor READ hexFontColor WRITE setHexFontColor)

    /*! Property addressOffset is added to the Numbers of the Address Area.
    A offset in the address area (left side) is sometimes useful, whe you show
    only a segment of a complete memory picture. With setAddressOffset() you set
    this property - with addressOffset() you get the current value.
    */
    Q_PROPERTY(qint64 addressOffset READ addressOffset WRITE setAddressOffset)

    /*! Set and get the minimum width of the address area, width in characters.
    */
    Q_PROPERTY(int addressWidth READ addressWidth WRITE setAddressWidth)

    /*! Switch the ascii area on (true, show it) or off (false, hide it).
    */
    Q_PROPERTY(bool asciiArea READ asciiArea WRITE setAsciiArea)

    /*! Set and get bytes number per line.*/
    Q_PROPERTY(int bytesPerLine READ bytesPerLine WRITE setBytesPerLine)

    /*! Property cursorPosition sets or gets the position of the editor cursor
    in QHexEdit. Every byte in data has two cursor positions: the lower and upper
    Nibble. Maximum cursor position is factor two of data.size().
    */
    Q_PROPERTY(qint64 cursorPosition READ cursorPosition WRITE setCursorPosition)

    /*! Property data holds the content of QHexEdit. Call setData() to set the
    content of QHexEdit, data() returns the actual content. When calling setData()
    with a QByteArray as argument, QHexEdit creates a internal copy of the data
    If you want to edit big files please use setData(), based on QIODevice.
    */
    Q_PROPERTY(QByteArray data READ data WRITE setData NOTIFY dataChanged)

    /*! That property defines if the hex values looks as a-f if the value is false(default)
    or A-F if value is true.
    */
    Q_PROPERTY(bool hexCaps READ hexCaps WRITE setHexCaps)

    /*! Property defines the dynamic calculation of bytesPerLine parameter depends of width of widget.
    set this property true to avoid horizontal scrollbars and show the maximal possible data. defalut value is false*/
    Q_PROPERTY(bool dynamicBytesPerLine READ dynamicBytesPerLine WRITE setDynamicBytesPerLine)

    /*! Switch the highlighting feature on or of: true (show it), false (hide it).
    */
    Q_PROPERTY(bool highlighting READ highlighting WRITE setHighlighting)

    /*! Property highlighting color sets (setHighlightingColor()) the background
    color of highlighted text areas. You can also read the color
    (highlightingColor()).
    */
    Q_PROPERTY(QColor highlightingColor READ highlightingColor WRITE setHighlightingColor)

    /*! Property overwrite mode sets (setOverwriteMode()) or gets (overwriteMode()) the mode
    in which the editor works. In overwrite mode the user will overwrite existing data. The
    size of data will be constant. In insert mode the size will grow, when inserting
    new data.
    */
    Q_PROPERTY(bool overwriteMode READ overwriteMode WRITE setOverwriteMode)

    /*! Property selection color sets (setSelectionColor()) the background
    color of selected text areas. You can also read the color
    (selectionColor()).
    */
    Q_PROPERTY(QColor selectionColor READ selectionColor WRITE setSelectionColor)

    /*! Property readOnly sets (setReadOnly()) or gets (isReadOnly) the mode
    in which the editor works. In readonly mode the the user can only navigate
    through the data and select data; modifying is not possible. This
    property's default is false.
    */
    Q_PROPERTY(bool readOnly READ isReadOnly WRITE setReadOnly)

    /*! Set the font of the widget. Please use fixed width fonts like Mono or Courier.*/
    Q_PROPERTY(QFont font READ font WRITE setFont)

public:
    /*! Creates an instance of QHexEdit.
    \param parent Parent widget of QHexEdit.
    */
    QHexEdit(QWidget *parent=0);

    // Access to data of qhexedit

    /*! Sets the data of QHexEdit. The QIODevice will be opened just before reading
    and closed immediately afterwards. This is to allow other programs to rewrite
    the file while editing it.
    */
    bool setData(QIODevice &iODevice);

    /*! Gives back the data as a QByteArray starting at position \param pos and
    delivering \param count bytes.
    */
    QByteArray dataAt(qint64 pos, qint64 count=-1);

    /*! Gives back the data into a \param iODevice starting at position \param pos
    and delivering \param count bytes.
    */
    bool write(QIODevice &iODevice, qint64 pos=0, qint64 count=-1);


    // Char handling

    /*! Inserts a char.
    \param pos Index position, where to insert
    \param ch Char, which is to insert
    The char will be inserted and size of data grows.
    */
    void insert(qint64 pos, char ch);

    /*! Removes len bytes from the content.
    \param pos Index position, where to remove
    \param len Amount of bytes to remove
    */
    void remove(qint64 pos, qint64 len=1);

    /*! Replaces a char.
    \param pos Index position, where to overwrite
    \param ch Char, which is to insert
    The char will be overwritten and size remains constant.
    */
    void replace(qint64 pos, char ch);


    // ByteArray handling

    /*! Inserts a byte array.
    \param pos Index position, where to insert
    \param ba QByteArray, which is to insert
    The QByteArray will be inserted and size of data grows.
    */
    void insert(qint64 pos, const QByteArray &ba);

    /*! Replaces \param len bytes with a byte array \param ba
    \param pos Index position, where to overwrite
    \param ba QByteArray, which is inserted
    \param len count of bytes to overwrite
    The data is overwritten and size of data may change.
    */
    void replace(qint64 pos, qint64 len, const QByteArray &ba);


    // Utility functions
    /*! Calc cursor position from graphics position
     * \param point from where the cursor position should be calculated
     * \return Cursor position
     */
    qint64 cursorPosition(QPoint point);

    /*! Ensure the cursor to be visbile
     */
    void ensureVisible();
    /*! Get current file size
     */
    qint64 getSize();
    /*! Find first occurrence of ba in QHexEdit data
     * \param ba Data to find
     * \param from Point where the search starts
     * \param isRegex regex on off switch
     * \return pos if fond, else -1
     */
    qint64 indexOf(const QByteArray &ba, qint64 from, bool isRegex, bool isCaseSensitive);

    /*! Returns if any changes where done on document
     * \return true when document is modified else false
     */
    bool isModified();

    /*! Find last occurrence of ba in QHexEdit data
     * \param ba Data to find
     * \param from Point where the search starts
     * \return pos if fond, else -1
     */
    qint64 lastIndexOf(const QByteArray &ba, qint64 from);

    /*! Gives back a formatted image of the selected content of QHexEdit
    */
    QString selectionToReadableString();

    /*! Return the selected content of QHexEdit as QString HEX
    */
    QString selectedData();
    /*! Return the selected content of QHexEdit as QByteArray
    */
    QByteArray selectedDataBa();
    /*! Set Font of QHexEdit
     * \param font
     */
    void setFont(const QFont &font);

    /*! Gives back a formatted image of the content of QHexEdit
    */
    QString toReadableString();


public slots:
    /*! Redoes the last operation. If there is no operation to redo, i.e.
      there is no redo step in the undo/redo history, nothing happens.
      */
    void redo();

    /*! Undoes the last operation. If there is no operation to undo, i.e.
      there is no undo step in the undo/redo history, nothing happens.
      */
    void undo();

signals:

    /*! Contains the address, where the cursor is located. */
    void currentAddressChanged(qint64 address);

    /*! Contains the size of the data to edit. */
    void currentSizeChanged(qint64 size);

    /*! The signal is emitted every time, the data is changed. */
    void dataChanged();

    /*! The signal is emitted every time, the overwrite mode is changed. */
    void overwriteModeChanged(bool state);


/*! \cond docNever */
public:
    ~QHexEdit();

    // Properties
    bool addressArea();
    void setAddressArea(bool addressArea);

    QColor addressAreaColor();
    void setAddressAreaColor(const QColor &color);

    QColor addressFontColor();
    void setAddressFontColor(const QColor &color);

    QColor asciiAreaColor();
    void setAsciiAreaColor(const QColor &color);

    QColor asciiFontColor();
    void setAsciiFontColor(const QColor &color);

    QColor hexFontColor();
    void setHexFontColor(const QColor &color);

    qint64 addressOffset();
    void setAddressOffset(qint64 addressArea);

    int addressWidth();
    void setAddressWidth(int addressWidth);

    bool asciiArea();
    void setAsciiArea(bool asciiArea);

    int bytesPerLine();
    void setBytesPerLine(int count);

    qint64 cursorPosition();
    void setCursorPosition(qint64 position);

    QByteArray data();
    void setData(const QByteArray &ba);

    void setHexCaps(const bool isCaps);
    bool hexCaps();

    void setDynamicBytesPerLine(const bool isDynamic);
    bool dynamicBytesPerLine();

    bool highlighting();
    void setHighlighting(bool mode);

    QColor highlightingColor();
    void setHighlightingColor(const QColor &color);

    bool overwriteMode();
    void setOverwriteMode(bool overwriteMode);

    bool isReadOnly();
    void setReadOnly(bool readOnly);

    QColor selectionColor();
    void setSelectionColor(const QColor &color);

protected:
    // Handle events
    void keyPressEvent(QKeyEvent *event);
    void mouseMoveEvent(QMouseEvent * event);
    void mousePressEvent(QMouseEvent * event);
    void paintEvent(QPaintEvent *event);
    void resizeEvent(QResizeEvent *);
    virtual bool focusNextPrevChild(bool next);
private:
    // Handle selections
    void resetSelection(qint64 pos);            // set selectionStart and selectionEnd to pos
    void resetSelection();                      // set selectionEnd to selectionStart
    void setSelection(qint64 pos);              // set min (if below init) or max (if greater init)
    qint64 getSelectionBegin();
    qint64 getSelectionEnd();

    // Private utility functions
    void init();
    void readBuffers();
    QString toReadable(const QByteArray &ba);

private slots:
    void adjust();                              // recalc pixel positions
    void dataChangedPrivate(int idx=0);         // emit dataChanged() signal
    void refresh();                             // ensureVisible() and readBuffers()
    void updateCursor();                        // update blinking cursor

private:
    // Name convention: pixel positions start with _px
    int _pxCharWidth, _pxCharHeight;            // char dimensions (dependend on font)
    int _pxPosHexX;                             // X-Pos of HeaxArea
    int _pxPosAdrX;                             // X-Pos of Address Area
    int _pxPosAsciiX;                           // X-Pos of Ascii Area
    int _pxGapAdr;                              // gap left from AddressArea
    int _pxGapAdrHex;                           // gap between AddressArea and HexAerea
    int _pxGapHexAscii;                         // gap between HexArea and AsciiArea
    int _pxCursorWidth;                         // cursor width
    int _pxSelectionSub;                        // offset selection rect
    int _pxCursorX;                             // current cursor pos
    int _pxCursorY;                             // current cursor pos

    // Name convention: absolute byte positions in chunks start with _b
    qint64 _bSelectionBegin;                    // first position of Selection
    qint64 _bSelectionEnd;                      // end of Selection
    qint64 _bSelectionInit;                     // memory position of Selection
    qint64 _bPosFirst;                          // position of first byte shown
    qint64 _bPosLast;                           // position of last byte shown
    qint64 _bPosCurrent;                        // current position

    // variables to store the property values
    bool _addressArea;                          // left area of QHexEdit
    QColor _addressAreaColor;
    QColor _asciiAreaColor;
    QColor _addressFontColor;
    QColor _asciiFontColor;
    QColor _hexFontColor;
    int _addressWidth;
    bool _asciiArea;
    qint64 _addressOffset;
    int _bytesPerLine;
    int _hexCharsInLine;
    bool _highlighting;
    bool _overwriteMode;
    QBrush _brushSelection;
    QPen _penSelection;
    QBrush _brushHighlighted;
    QPen _penHighlighted;
    bool _readOnly;
    bool _hexCaps;
    bool _dynamicBytesPerLine;

    // other variables
    bool _editAreaIsAscii;                      // flag about the ascii mode edited
    int _addrDigits;                            // real no of addressdigits, may be > addressWidth
    bool _blink;                                // help get cursor blinking
    QBuffer _bData;                             // buffer, when setup with QByteArray
    Chunks *_chunks;                            // IODevice based access to data
    QTimer _cursorTimer;                        // for blinking cursor
    qint64 _cursorPosition;                     // absolute position of cursor, 1 Byte == 2 tics
    QRect _cursorRect;                          // physical dimensions of cursor
    QByteArray _data;                           // QHexEdit's data, when setup with QByteArray
    QByteArray _dataShown;                      // data in the current View
    QByteArray _hexDataShown;                   // data in view, transformed to hex
    qint64 _lastEventSize;                      // size, which was emitted last time
    QByteArray _markedShown;                    // marked data in view
    bool _modified;                             // Is any data in editor modified?
    int _rowsShown;                             // lines of text shown
    UndoStack * _undoStack;                     // Stack to store edit actions for undo/redo
    /*! \endcond docNever */
};

#endif // QHEXEDIT_H

```

`src/qhexedit.pro`:

```pro

greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

QT += core gui
TEMPLATE = lib

VERSION = 4.2.0

DEFINES += QHEXEDIT_EXPORTS

HEADERS = \
    qhexedit.h \
    chunks.h \
    commands.h


SOURCES = \
    qhexedit.cpp \
    chunks.cpp \
    commands.cpp

Release:TARGET = qhexedit
Debug:TARGET = qhexeditd


unix:DESTDIR = /usr/lib
win32:DESTDIR = ../lib

```

`src/qhexedit.sip`:

```sip
%Module(name=qhexedit)

%Import QtCore/QtCoremod.sip
%Import QtGui/QtGuimod.sip

%If (Qt_5_0_0 -)
%Import QtWidgets/QtWidgetsmod.sip
%End

class QHexEdit : QAbstractScrollArea
{
%TypeHeaderCode
#include "../src/qhexedit.h"
%End

public:
    explicit QHexEdit(QWidget *parent /TransferThis/ = 0);
    virtual ~QHexEdit();

    bool setData(QIODevice &);
    QByteArray dataAt(qint64, qint64=-1);
    bool write(QIODevice &iODevice, qint64=0, qint64=-1);

    void insert(qint64, char);
    void remove(qint64, qint64);
    void replace(qint64, char);

    void insert(qint64, QByteArray &);
    void replace(qint64, qint64, QByteArray &);

    bool addressArea();
    bool addressWidth();
    bool asciiArea();
    qint64 cursorPosition(QPoint);
    void ensureVisible();
    qint64 indexOf(QByteArray &, qint64);
    bool isModified();
    bool highlighting();
    qint64 lastIndexOf(QByteArray &, qint64);
    QString selectionToReadableString();
    QString selectedData();
    void setFont(const QFont &);
    QString toReadableString();

    QColor addressAreaColor();
    void setAddressAreaColor(const QColor &);

    QColor addressFontColor();
    void setAddressFontColor(const QColor &);

    QColor asciiAreaColor();
    void setAsciiAreaColor(const QColor &);

    QColor asciiFontColor();
    void setAsciiFontColor(const QColor &);

    QColor hexFontColor();
    void setHexFontColor(const QColor &);

    qint64 addressOffset();
    void setAddressOffset(qint64);

    qint64 cursorPosition();
    void setCursorPosition(qint64);

    QByteArray data();
    void setData(const QByteArray &);

    QColor highlightingColor();
    void setHighlightingColor(const QColor &);

    bool overwriteMode();
    void setOverwriteMode(bool);

    bool isReadOnly();
    void setReadOnly(bool);

    QColor selectionColor();
    void setSelectionColor(const QColor &);

public slots:
    void redo();
    void setAddressArea(bool);
    void setAddressWidth(int);
    void setAsciiArea(bool);
    void setHighlighting(bool);
    void undo();

signals:
    void currentAddressChanged(qint64);
    void currentSizeChanged(qint64);
    void dataChanged();
    void overwriteModeChanged(bool);
};

```

`src/qhexeditplugin.pro`:

```pro
#! [0] #! [1]
greaterThan(QT_MAJOR_VERSION, 4) {
    QT      += widgets uiplugin
}

lessThan(QT_MAJOR_VERSION, 5) {
    CONFIG  += designer
}

CONFIG      += plugin
#! [0]
TARGET      = $$qtLibraryTarget($$TARGET)
#! [2]
TEMPLATE    = lib
#! [1] #! [2]
QTDIR_build:DESTDIR     = $$QT_BUILD_TREE/plugins/designer

#! [3]
HEADERS = \
    qhexedit.h \
    chunks.h \
    commands.h \
    QHexEditPlugin.h


SOURCES = \
    qhexedit.cpp \
    chunks.cpp \
    commands.cpp \
    QHexEditPlugin.cpp

#! [3]

# install
target.path = $$[QT_INSTALL_PLUGINS]/designer
sources.files = $$SOURCES $$HEADERS *.pro
sources.path = $$[QT_INSTALL_EXAMPLES]/designer/QHexEditPlugin
INSTALLS += target

symbian: include($$QT_SOURCE_TREE/examples/symbianpkgrules.pri)

```