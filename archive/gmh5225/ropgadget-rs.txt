Project Path: arc_gmh5225_ropgadget-rs_2nucdwv5

Source Tree:

```txt
arc_gmh5225_ropgadget-rs_2nucdwv5
├── Cargo.toml
├── LICENSE
├── README.md
├── src
│   ├── common.rs
│   ├── cpu
│   │   ├── arm.rs
│   │   ├── mod.rs
│   │   └── x86.rs
│   ├── engine.rs
│   ├── error.rs
│   ├── format
│   │   ├── elf.rs
│   │   ├── mach.rs
│   │   ├── mod.rs
│   │   └── pe.rs
│   ├── gadget.rs
│   ├── main.rs
│   ├── section.rs
│   └── session.rs
└── tests
    └── bin
        ├── big-arm32.elf
        ├── big-arm32.pe
        ├── big-arm64.elf
        ├── big-arm64.pe
        ├── big-x64.elf
        ├── big-x64.pe
        ├── big-x86.elf
        ├── big-x86.pe
        ├── small-arm32.elf
        ├── small-arm32.pe
        ├── small-arm64.elf
        ├── small-arm64.pe
        ├── small-x64.elf
        ├── small-x64.macho
        ├── small-x64.pe
        ├── small-x86.elf
        ├── small-x86.macho
        └── small-x86.pe

```

`Cargo.toml`:

```toml
[package]
name = "ropgadget-rs"
version = "0.3.0"
authors = ["hugsy <hugsy@blah.cat>"]
edition = "2018"
description = "Another (bad) ROP gadget finder"
homepage = "https://github.com/hugsy/ropgadget-rs/"
repository = "https://github.com/hugsy/ropgadget-rs/"
readme = "README.md"
license = "MIT"
keywords = ["pwn", "ctf", "x64", "x86", "arm", "arm64"]

[dependencies]
goblin = "0.6.0"
capstone = "0.11.0"
clap = { version = "4.0.29", features = ["derive"] }
colored = "2"
bitflags = "1.2.1"
log = {version = "0.4.11", features = ["std",]}

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 crazy rabbidz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
# ropgadget-rs

[![CI Build](https://github.com/hugsy/ropgadget-rs/actions/workflows/build.yml/badge.svg?branch=main)](https://github.com/hugsy/ropgadget-rs/actions/workflows/build.yml)

## Why another ROP gadget finder?

RopGadget-rs is an attempt to learn Rust as a weekend project, to try and get a really fast & easily portable ropgadget finder even (especially!) for large binaries (ntoskrnl, chrome, etc.). As a result it is barely functional, and the code is probably ugly and inefficient.

You've been warned, don't blame me...

Currently supports:

|      | ELF | PE | Mach  |
|:-----:|:---:|:--:|:----:|
| x86   | ✅ | ✅ | ❌   |
| x64   | ✅ | ✅ | ✅   |
| arm   | ✅ | ✅ | ❌   |
| arm64 | ✅ | ✅ | ❌   |


## ropgadget-rs

```text
❯ .\ropgadget-rs.exe --help
Another (bad) ROP gadget finder

Usage: rp-rs.exe [OPTIONS] <FILE>

Arguments:
  <FILE>
          The file to parse

Options:
  -t, --number-of-threads <THREAD_NUM>
          The number of threads to use

          [default: 2]

  -o, --output-file <OUTPUT>
          Write gadget to file (optional)

  -v, --verbose...
          The verbosity level

  -u, --unique
          Unique gadgets

      --architecture <ARCHITECTURE>
          Force the architecture to given value

          [possible values: x86, x64, arm, arm64]

      --format <FORMAT>
          Force the OS to given value

          [possible values: pe, elf, mach]

  -i, --image-base <IMAGE_BASE>
          Specify an image base

          [default: 0]

      --no-color
          Unique gadgets

      --max-insn-per-gadget <MAX_INSN_PER_GADGET>
          The maximum number of instructions in a gadget

          [default: 6]

      --max-size <MAX_SIZE>
          The maximum size of the gadget

          [default: 32]

      --rop-types <ROP_TYPES>
          The type of gadgets to focus on (default - return only)

          [possible values: jump, call, ret, int, iret, privileged]

      --profile-type <PROFILE_TYPE>
          The profile type (default - fast)

          [default: fast]

          Possible values:
          - fast:     Strategy Fast
          - complete: Strategy Complete

  -h, --help
          Print help information (use `-h` for a summary)

  -V, --version
          Print version information
```


## Build

If you don't have `cargo`:

 - On Linux/MacOS
```bash
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

 - On Windows
```bash
Invoke-WebRequest https://win.rustup.rs/x86_64 -UseBasicParsing -OutFile "rustup-init.exe"
iex rustup-init.exe
```

Then build:

```bash
git clone https://github.com/hugsy/ropgadget-rs
cd ropgadget-rs
cargo build
```

And run:

```bash
cargo run -- --help
```


## Install

Via `cargo`:

```bash
$ cargo install --bins --git https://github.com/hugsy/ropgadget-rs.git
```

## Perfs

Well yeah, it's pretty fast (thanks Rust) but I'll try to improve here and there as I learn to write better Rust.

For a lame benchmark: here on an old i5-4300M (build in `--release` mode) with 2 threads (default)

 * `ntoskrnl.exe` (Windows 10 RS6 - 10.0.19041.329) - 10,921,280 bytes

```bash
PS C:\Users\hugsy>  .\ropgadget-rs.exe -o rop.txt -vv .\ntoskrnl-rs6.exe
[INFO] - Checking file '.\ntoskrnl-rs6.exe'
[INFO] - Creating new Session(file=.\ntoskrnl-rs6.exe, Info(Arch=x86-64, OS=PE))
[INFO] - Looking for gadgets in 15 sections (with 2 threads)...'
[INFO] - Dumping 336787 gadgets to 'rop.txt'...
[INFO] - Done!
[INFO] - Execution: 336787 gadgets found in 13.5224138s
```

 * `msedge.dll` (Chromium Edge - 83.0.478.64) - 145,665,416 bytes

```bash
PS C:\Users\hugsy> .\ropgadget-rs.exe -o rop.txt -vv .\msedge.dll
[INFO] - Checking file '.\msedge.dll'
[INFO] - Creating new Session(file=.\msedge.dll, Info(Arch=x86-64, OS=PE))
[INFO] - Looking for gadgets in 1 sections (with 2 threads)...'
[INFO] - Dumping 5713703 gadgets to 'rop.txt'...
[INFO] - Done!
[INFO] - Execution: 5713703 gadgets found in 132.2237842s
```

YMMV but most small files (like Unix binaries) will execute in way under 1 second.

```text
$ ./ropgadget-rs -vv -o /dev/null /bin/ls
[INFO] - Checking file '/bin/ls'
[INFO] - Creating new Session(file=/bin/ls, Info(Arch=x86-64, OS=ELF))
[INFO] - Looking for gadgets in 5 sections (with 2 threads)...'
[INFO] - Dumping 3544 gadgets to '/dev/null'...
[INFO] - Done!
[INFO] - Execution: 3544 gadgets found in 151.5587ms
```


## Better projects

Unless you're ok with experiencing my bugs, you should probably check out one of those projects:
 - [rp++](https://github.com/0vercl0k/rp)
 - [ropper](https://github.com/sashs/ropper)
 - [RopGadget](https://github.com/JonathanSalwan/ROPgadget)


```

`src/common.rs`:

```rs
use crate::error::Error;

pub type GenericResult<T> = Result<T, Error>;

```

`src/cpu/arm.rs`:

```rs
use crate::cpu;

pub struct Arm;

impl cpu::Cpu for Arm {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::ARM
    }

    fn ptrsize(&self) -> usize {
        4
        // TODO: thumb
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![(
            vec![0xd6, 0x5f, 0x03, 0xc0].into_iter().rev().collect(),
            vec![0xff, 0xff, 0xff, 0xff].into_iter().rev().collect(),
        )]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0b1101_0001, 0b0010_1111, 0b1111_1111, 0b0001_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_1111, 0b1111_0000]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // 4.3 Branch and Exchange (BX)
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![]
    }

    fn insn_step(&self) -> usize {
        4
    }
}

impl std::fmt::Debug for Arm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Arm").finish()
    }
}

pub struct Arm64;

impl cpu::Cpu for Arm64 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::ARM64
    }

    fn ptrsize(&self) -> usize {
        8
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0xd6, 0x5f, 0x03, 0xc0].into_iter().rev().collect(),
                vec![0xff, 0xff, 0xff, 0xff].into_iter().rev().collect(),
            ), // RET
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (vec![0x14], vec![0xff]),             // B LABEL
            // (vec![0x01, 0x14], vec![0xff, 0xff]), // BL LABEL
            // (vec![0xd4], vec![0xff]),             // B.cond
            // (vec![0xb4], vec![0xff]),             // CBZ // CBNZ
            (
                vec![0b1101_0110, 0b0011_1111, 0b0000_0000, 0b0000_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_0000, 0b0001_1111]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // C6.2.35 BLR
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (
                vec![0b1101_0110, 0b0001_1111, 0b0000_0000, 0b0000_0000]
                    .into_iter()
                    .rev()
                    .collect(),
                vec![0b1111_1111, 0b1111_1111, 0b1111_0000, 0b0001_1111]
                    .into_iter()
                    .rev()
                    .collect(),
            ), // C6.2.37 BR
        ]
    }

    fn insn_step(&self) -> usize {
        4
    }
}

impl std::fmt::Debug for Arm64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Arm64").finish()
    }
}

```

`src/cpu/mod.rs`:

```rs
pub mod arm;
pub mod x86;

use clap::ValueEnum;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum CpuType {
    X86,
    X64,
    ARM,
    ARM64,
}

pub trait Cpu: Send + Sync + std::fmt::Debug {
    fn cpu_type(&self) -> CpuType;
    fn ptrsize(&self) -> usize;
    fn insn_step(&self) -> usize;

    //
    // for each instruction type, the format is Vector<opcode, mask>
    //

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;
    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;
    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)>;

    fn name(&self) -> String {
        self.cpu_type().to_string()
    }
}

impl std::fmt::Display for CpuType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let val = match self {
            CpuType::X86 => "x86-32",
            CpuType::X64 => "x86-64",
            CpuType::ARM => "ARM",
            CpuType::ARM64 => "ARM64",
        };

        write!(f, "Arch={}", val)
    }
}

```

`src/cpu/x86.rs`:

```rs
use std::vec;

use crate::cpu;

pub struct X86;

impl cpu::Cpu for X86 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::X86
    }

    fn ptrsize(&self) -> usize {
        4
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xc3], vec![0xff]),                         // ret
            (vec![0xcb], vec![0xff]),                         // retf
            (vec![0xc2, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // ret imm16
            (vec![0xcf, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // retf imm16
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (
            //     vec![0xe8, 0x00, 0x00, 0x00, 0x00],
            //     vec![0xff, 0x00, 0x00, 0x00, 0x00],
            // ), // CALL rel32
            (vec![0xff, 0xd0], vec![0xff, 0xf0]), // CALL REG32
            (vec![0xff, 0b0001_0000], vec![0xff, 0b1111_0000]), // CALL [REG32]
            (vec![0xff, 0b0101_0001, 0], vec![0xff, 0b1111_0000, 0]), // CALL [REG32+DISP8]
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (vec![0xe9, 0, 0, 0, 0], vec![0xff, 0, 0, 0, 0]), // JMP imm32
            (vec![0xFF, 0xe7], vec![0xff, 0xf8]), // JMP REG32
        ]
    }

    fn insn_step(&self) -> usize {
        1
    }
}

impl std::fmt::Debug for X86 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("X86").finish()
    }
}

pub struct X64;

impl cpu::Cpu for X64 {
    fn cpu_type(&self) -> cpu::CpuType {
        cpu::CpuType::X64
    }

    fn ptrsize(&self) -> usize {
        8
    }

    fn ret_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xc3], vec![0xff]),                         // RET
            (vec![0xcb], vec![0xff]),                         // RETF
            (vec![0xc2, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // RET imm16
            (vec![0xcf, 0x00, 0x00], vec![0xff, 0x00, 0x00]), // RETF imm16
        ]
    }

    fn call_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            // (
            //     vec![0xe8, 0x00, 0x00, 0x00, 0x00],
            //     vec![0xff, 0x00, 0x00, 0x00, 0x00],
            // ), // CALL rel32
            (vec![0xff, 0xd0], vec![0xff, 0xf0]), // CALL REG64
            (vec![0x41, 0xff, 0xd0], vec![0xff, 0xff, 0xf0]), // CALL REX.W REG64
            (vec![0xff, 0b0001_0000], vec![0xff, 0b1111_0000]), // CALL [REG64]
            (vec![0x41, 0xff, 0b0001_0000], vec![0x41, 0xff, 0b1111_0000]), // CALL [REX.W REG64]
            (vec![0xff, 0b0101_0001, 0], vec![0xff, 0b1111_0000, 0]), // CALL [REG64+DISP8]
            (
                vec![0x41, 0xff, 0b0101_0001, 0],
                vec![0xff, 0xff, 0b1111_0000, 0],
            ), // CALL [REX.W REG64+DISP8]
        ]
    }

    fn jmp_insns(&self) -> Vec<(Vec<u8>, Vec<u8>)> {
        vec![
            (vec![0xff, 0xe0], vec![0xff, 0xf8]), // JMP REG64
            (vec![0x41, 0xff, 0xe0], vec![0xff, 0xff, 0xf8]), // JMP REX.W REG64
                                                  // (vec![0xeb, 0x00], vec![0xff, 0x00]),             // JMP imm8
                                                  // (vec![0xe9, 0, 0, 0, 0], vec![0xff, 0, 0, 0, 0]), // JMP imm32
        ]
    }

    fn insn_step(&self) -> usize {
        1
    }
}

impl std::fmt::Debug for X64 {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("X64").finish()
    }
}

```

`src/engine.rs`:

```rs
use capstone::prelude::*;

use crate::cpu::{Cpu, CpuType};
use crate::gadget::{Instruction, InstructionGroup};

/**
 *
 * for now we just use capstone, but can be easily updated to other engines
 * in this case, change engine.rs -> engine/mod.rs and put the engines there
 *
 */

pub enum DisassemblyEngineType {
    Capstone,
}

//
// All disassembler must implement this trait
//
pub trait Disassembler {
    fn disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>>;
    fn name(&self) -> String;
    fn id(&self) -> DisassemblyEngineType;
}

pub struct DisassemblyEngine {
    pub disassembler: Box<dyn Disassembler>,
}

impl DisassemblyEngine {
    ///
    ///
    ///
    pub fn new(engine_type: &DisassemblyEngineType, cpu: &dyn Cpu) -> Self {
        match engine_type {
            DisassemblyEngineType::Capstone => Self {
                disassembler: Box::new(CapstoneDisassembler::new(cpu)),
            },
        }
    }
}

impl std::fmt::Display for DisassemblyEngine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Engine({})", self.disassembler.name())
    }
}

///
/// Capstone disassembler implementation
///

// https://github.com/aquynh/capstone/blob/1b5014515d0d671048e2b43ce483d38d85a2bc83/bindings/python/capstone/__init__.py#L216
const INSN_GRP_JUMP: u8 = 0x01;
const INSN_GRP_CALL: u8 = 0x02;
const INSN_GRP_RET: u8 = 0x03;
const INSN_GRP_INT: u8 = 0x04;
const INSN_GRP_IRET: u8 = 0x05;
const INSN_GRP_PRIV: u8 = 0x06;

pub struct CapstoneDisassembler {
    cs: Capstone,
}

impl Disassembler for CapstoneDisassembler {
    fn disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>> {
        self.cs_disassemble(code, address)
    }

    fn name(&self) -> String {
        // todo: add version strings
        let (major, minor) = Capstone::lib_version();
        format!("Capstone-Engine({}.{})", major, minor)
    }

    fn id(&self) -> DisassemblyEngineType {
        DisassemblyEngineType::Capstone
    }
}

impl std::fmt::Display for CapstoneDisassembler {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Disassembler({})", self.name())
    }
}

impl CapstoneDisassembler {
    fn new(cpu: &dyn Cpu) -> Self {
        let cs = match cpu.cpu_type() {
            CpuType::X86 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode32)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::X64 => Capstone::new()
                .x86()
                .mode(arch::x86::ArchMode::Mode64)
                .syntax(arch::x86::ArchSyntax::Intel)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::ARM => Capstone::new()
                .arm()
                .mode(arch::arm::ArchMode::Arm)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),

            CpuType::ARM64 => Capstone::new()
                .arm64()
                .mode(arch::arm64::ArchMode::Arm)
                .detail(true)
                .build()
                .expect("Failed to create Capstone object"),
        };

        Self { cs }
    }

    fn cs_disassemble(&self, code: &Vec<u8>, address: u64) -> Option<Vec<Instruction>> {
        let cs_insns = self
            .cs
            .disasm_all(&code, address)
            .expect("Failed to disassemble");

        //
        // Any instruction?
        //
        if cs_insns.len() == 0 {
            return None;
        }

        //
        // Otherwise we're good to proceed
        //
        let mut insns: Vec<Instruction> = Vec::new();
        let mut candidates: Vec<Instruction> = Vec::new();

        for cs_insn in cs_insns.iter() {
            let detail: InsnDetail = self.cs.insn_detail(&cs_insn).unwrap();

            let mut insn_group = InstructionGroup::Undefined;

            for cs_insn_group in detail.groups() {
                insn_group = match cs_insn_group.0 {
                    INSN_GRP_JUMP => InstructionGroup::Jump,
                    INSN_GRP_CALL => InstructionGroup::Call,
                    INSN_GRP_RET => InstructionGroup::Ret,
                    INSN_GRP_PRIV => InstructionGroup::Privileged,
                    INSN_GRP_INT => InstructionGroup::Int,
                    INSN_GRP_IRET => InstructionGroup::Iret,
                    _ => {
                        continue;
                    }
                };
            }

            let mnemonic = cs_insn.mnemonic().unwrap().to_string();

            let operands: Option<String> = match cs_insn.op_str() {
                // todo: do better parsing on args
                Some(op) => Some(op.to_string()),
                None => None,
            };

            let insn = Instruction {
                raw: cs_insn.bytes().to_vec(),
                size: cs_insn.bytes().len(),
                mnemonic: mnemonic,
                operands: operands,
                address: cs_insn.address(),
                group: insn_group,
            };

            candidates.push(insn);
        }

        //
        // at this point `candidates` holds a valid set of Instruction
        // must filter out the sequence that can't qualify for a rop sequence
        //
        for insn in candidates.into_iter().rev() {
            match insn.group {
                InstructionGroup::Jump => {
                    if insns.len() > 0 {
                        break;
                    }
                }
                InstructionGroup::Call => {
                    if insns.len() > 0 {
                        break;
                    }
                }
                InstructionGroup::Ret => {
                    if insns.len() > 0 {
                        break;
                    }
                }
                _ => {}
            };

            insns.insert(0, insn);
        }

        Some(insns)
    }
}

```

`src/error.rs`:

```rs
#[derive(Debug)]
pub enum Error {
    IoError(std::io::Error),
    ParsingError(goblin::error::Error),
    ThreadRuntimeError(std::boxed::Box<dyn std::any::Any + std::marker::Send>),
    InvalidFileError,
}

#[derive(Debug)]
pub struct GenericError {
    msg: String,
}

impl std::fmt::Display for GenericError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}'", self.msg)
    }
}

#[derive(Debug)]
pub struct GadgetBuildError {}

impl From<std::io::Error> for Error {
    fn from(error: std::io::Error) -> Self {
        Error::IoError(error)
    }
}

impl From<goblin::error::Error> for Error {
    fn from(error: goblin::error::Error) -> Self {
        Error::ParsingError(error)
    }
}

impl From<std::boxed::Box<dyn std::any::Any + std::marker::Send>> for Error {
    fn from(error: std::boxed::Box<dyn std::any::Any + std::marker::Send>) -> Self {
        Error::ThreadRuntimeError(error)
    }
}

#[derive(Debug)]
pub struct InvalidFormatError {
    format: String,
}

impl std::fmt::Display for InvalidFormatError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "Unknown/unsupported format: {}'", self.format)
    }
}

```

`src/format/elf.rs`:

```rs
use colored::Colorize;
use goblin;
use log::{debug, trace};
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use crate::cpu;
use crate::{format::Format, section::Section};

use super::ExecutableFormat;

#[derive(Debug)]
pub struct Elf {
    path: PathBuf,
    sections: Vec<Section>,
    cpu: Box<dyn cpu::Cpu>,
    entry_point: u64,
}

impl Elf {
    pub fn new(path: PathBuf, obj: goblin::elf::Elf) -> Self {
        let filepath = path.to_str().unwrap();

        let mut executable_sections: Vec<Section> = Vec::new();
        debug!("looking for executables s in ELF: '{}'", filepath.bold());

        let file = File::open(&path).unwrap();
        let mut reader = BufReader::new(file);

        for s in &obj.section_headers {
            trace!("Testing section {:?}", s);

            //
            // disregard non executable section
            //
            if !s.is_executable() {
                continue;
            }

            debug!("Importing section {:?}", s);

            let mut section = Section::from(s);
            section.name = String::from(&obj.shdr_strtab[s.sh_name]);

            if reader.seek(SeekFrom::Start(s.sh_addr as u64)).is_err() {
                panic!(
                    "Invalid offset {} for section '{}', corrupted ELF?",
                    s.sh_addr, section.name
                )
            }

            match reader.read_exact(&mut section.data) {
                Ok(_) => {
                    executable_sections.push(section);
                }
                Err(e) => panic!("Failed to read '{}' section: {:?}", section.name, e),
            };
        }

        let cpu: Box<dyn cpu::Cpu> = match obj.header.e_machine {
            goblin::elf::header::EM_386 => Box::new(cpu::x86::X86 {}),
            goblin::elf::header::EM_X86_64 => Box::new(cpu::x86::X64 {}),
            goblin::elf::header::EM_ARM => Box::new(cpu::arm::Arm {}),
            goblin::elf::header::EM_AARCH64 => Box::new(cpu::arm::Arm {}),
            _ => {
                panic!("ELF machine format is unsupported")
            }
        };

        Self {
            path: path.clone(),
            sections: executable_sections,
            cpu: cpu,
            entry_point: obj.entry,
        }
    }
}

impl ExecutableFormat for Elf {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> Format {
        Format::Elf
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    fn cpu(&self) -> &dyn cpu::Cpu {
        self.cpu.as_ref()
    }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }
}

```

`src/format/mach.rs`:

```rs
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use colored::Colorize;
use goblin;
use goblin::mach::constants;
use log::debug;

use crate::cpu;
use crate::{format::Format, section::Permission, section::Section};

use super::ExecutableFormat;

pub struct Mach {
    path: PathBuf,
    sections: Vec<Section>,
    cpu: Box<dyn cpu::Cpu>,
    entry_point: u64,
}
impl Mach {
    pub fn new(path: PathBuf, obj: goblin::mach::Mach) -> Self {
        let bin = match obj {
            goblin::mach::Mach::Fat(_) => {
                todo!()
            }
            goblin::mach::Mach::Binary(macho) => macho,
        };

        let filepath = path.to_str().unwrap();

        let mut sections: Vec<Section> = Vec::new();

        debug!(
            "looking for executables sections in MachO: '{}'",
            filepath.bold()
        );

        let file = File::open(&path).unwrap();
        let mut reader = BufReader::new(file);

        for s in &bin.segments {
            if s.flags & constants::S_ATTR_PURE_INSTRUCTIONS == 0
                || s.flags & constants::S_ATTR_SOME_INSTRUCTIONS == 0
            {
                continue;
            }

            let section_name = match std::str::from_utf8(&s.segname) {
                Ok(v) => String::from(v).replace("\0", ""),
                Err(_) => "".to_string(),
            };

            let mut section = Section::new(s.vmaddr as u64, (s.vmaddr + s.vmsize - 1) as u64);

            section.name = section_name;

            let perm = Permission::EXECUTABLE | Permission::READABLE; // todo: fix later
            section.permission = perm;

            reader.seek(SeekFrom::Start(s.fileoff as u64)).unwrap();
            reader.read_exact(&mut section.data).unwrap();

            debug!("Adding {}", section);

            sections.push(section);
        }

        let cpu: Box<dyn cpu::Cpu> = match bin.header.cputype {
            constants::cputype::CPU_TYPE_X86 => Box::new(cpu::x86::X86 {}),
            constants::cputype::CPU_TYPE_X86_64 => Box::new(cpu::x86::X64 {}),
            constants::cputype::CPU_TYPE_ARM64 => Box::new(cpu::arm::Arm64 {}),
            constants::cputype::CPU_TYPE_ARM => Box::new(cpu::arm::Arm {}),
            _ => {
                panic!("MachO is corrupted")
            }
        };

        Self {
            path: path.clone(),
            sections: sections,
            cpu: cpu,
            entry_point: bin.entry,
        }
    }
}

impl ExecutableFormat for Mach {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> Format {
        Format::Mach
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    fn cpu(&self) -> &dyn cpu::Cpu {
        self.cpu.as_ref()
    }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }
}

```

`src/format/mod.rs`:

```rs
pub mod elf;
pub mod mach;
pub mod pe;

use std::{fs, path::PathBuf};

use crate::{common::GenericResult, cpu, error::Error, section::Section};

use clap::ValueEnum;
use goblin::Object;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum Format {
    Pe,
    Elf,
    Mach,
    // todo: Raw,
}

impl std::fmt::Display for Format {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let val = match self {
            Format::Pe => "PE",
            Format::Elf => "ELF",
            Format::Mach => "Mach",
        };

        write!(f, "BinaryFormat={}", val)
    }
}

/// Trait specific to executable files
pub trait ExecutableFormat: Send + Sync {
    fn path(&self) -> &PathBuf;

    fn format(&self) -> Format;

    fn sections(&self) -> &Vec<Section>;

    fn cpu(&self) -> &dyn cpu::Cpu;

    fn entry_point(&self) -> u64;
}

/// Attempt to determine the file
pub fn guess_file_format(file: &PathBuf) -> GenericResult<Box<dyn ExecutableFormat>> {
    if !file.as_path().exists() {
        return Err(Error::InvalidFileError);
    }

    let buffer = match fs::read(file.as_path()) {
        Ok(buf) => buf,
        Err(_) => return Err(Error::InvalidFileError),
    };

    let parsed = match Object::parse(&buffer) {
        Ok(e) => e,
        Err(_) => return Err(Error::InvalidFileError),
    };

    match parsed {
        Object::PE(obj) => Ok(Box::new(pe::Pe::new(file.to_path_buf(), obj))),
        Object::Elf(obj) => Ok(Box::new(elf::Elf::new(file.to_path_buf(), obj))),
        Object::Mach(obj) => Ok(Box::new(mach::Mach::new(file.to_path_buf(), obj))),
        Object::Archive(_) => Err(Error::InvalidFileError),
        Object::Unknown(_) => Err(Error::InvalidFileError),
    }
}

```

`src/format/pe.rs`:

```rs
use std::fs::File;
use std::io::{BufReader, Read, Seek, SeekFrom};
use std::path::PathBuf;

use goblin;
use log::debug;

use crate::cpu;
use crate::{format::Format, section::Permission, section::Section};

use super::ExecutableFormat;

#[derive(Debug)]
pub struct Pe {
    path: PathBuf,
    sections: Vec<Section>,
    cpu: Box<dyn cpu::Cpu>,
    entry_point: u64,
}

impl Pe {
    pub fn new(path: PathBuf, obj: goblin::pe::PE) -> Self {
        let mut executable_sections: Vec<Section> = Vec::new();

        let file = File::open(&path).unwrap();
        let mut reader = BufReader::new(file);

        for s in &obj.sections {
            if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_EXECUTE == 0 {
                continue;
            }

            let section_name = match std::str::from_utf8(&s.name) {
                Ok(v) => String::from(v).replace("\0", ""),
                Err(_) => String::new(),
            };

            let mut section = Section::new(
                s.virtual_address as u64,
                (s.virtual_address + s.virtual_size - 1) as u64,
            );

            section.name = section_name;

            let mut perm = Permission::EXECUTABLE;
            if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_READ != 0 {
                perm |= Permission::READABLE;
            }

            if s.characteristics & goblin::pe::section_table::IMAGE_SCN_MEM_WRITE != 0 {
                perm |= Permission::WRITABLE;
            }

            section.permission = perm;

            reader
                .seek(SeekFrom::Start(s.pointer_to_raw_data as u64))
                .unwrap();
            reader.read_exact(&mut section.data).unwrap();

            debug!("Adding {}", section);
            executable_sections.push(section);
        }

        let cpu: Box<dyn cpu::Cpu> = match obj.header.coff_header.machine {
            goblin::pe::header::COFF_MACHINE_X86 => Box::new(cpu::x86::X86 {}),
            goblin::pe::header::COFF_MACHINE_X86_64 => Box::new(cpu::x86::X64 {}),
            goblin::pe::header::COFF_MACHINE_ARM => Box::new(cpu::arm::Arm {}),
            goblin::pe::header::COFF_MACHINE_ARMNT => Box::new(cpu::arm::Arm {}),
            goblin::pe::header::COFF_MACHINE_ARM64 => Box::new(cpu::arm::Arm64 {}),
            _ => {
                panic!("PE is corrupted")
            }
        };

        Self {
            path: path.clone(),
            sections: executable_sections,
            cpu: cpu,
            entry_point: obj.entry as u64,
        }
    }
}

impl ExecutableFormat for Pe {
    fn path(&self) -> &PathBuf {
        &self.path
    }

    fn format(&self) -> Format {
        Format::Pe
    }

    fn sections(&self) -> &Vec<Section> {
        &self.sections
    }

    fn cpu(&self) -> &dyn cpu::Cpu {
        self.cpu.as_ref()
    }

    fn entry_point(&self) -> u64 {
        self.entry_point
    }
}

```

`src/gadget.rs`:

```rs
extern crate capstone;

use std::cmp::Ordering;
use std::{fmt, thread};
use std::{
    io::{Cursor, Read, Seek, SeekFrom},
    sync::Arc,
};

use colored::*;
use log::{debug, warn};

use crate::common::GenericResult;
use crate::cpu;
use crate::engine::Disassembler;
use crate::section::Section;
use crate::session::{RopProfileStrategy, Session};

use clap::ValueEnum;

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum InstructionGroup {
    Undefined,
    Jump,
    Call,
    Ret,
    Int,
    Iret,
    Privileged,
}

impl std::fmt::Display for InstructionGroup {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(self, f)
    }
}

#[derive(Debug, PartialEq)]
pub struct Instruction {
    pub size: usize,
    pub raw: Vec<u8>,
    pub address: u64,
    pub group: InstructionGroup,

    pub mnemonic: String,
    pub operands: Option<String>,
}

impl Instruction {
    pub fn text(&self, use_color: bool) -> String {
        let mnemo = match use_color {
            true => {
                format!("{}", self.mnemonic.cyan())
            }
            false => {
                format!("{}", self.mnemonic)
            }
        };

        let op = match &self.operands {
            Some(x) => {
                if use_color {
                    format!(" {}", x.bold())
                } else {
                    format!(" {}", x)
                }
            }
            None => "".to_string(),
        };

        format!("{}{}", mnemo, op)
    }
}

impl fmt::Display for Instruction {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Instruction(addr=0x{:x}, size={}, text='{}', raw={:?}, group={:?})",
            self.address,
            self.size,
            self.text(false),
            self.raw,
            self.group
        )
    }
}

#[derive(Debug, PartialEq)]
pub struct Gadget {
    pub address: u64,
    pub insns: Vec<Instruction>,
    pub size: usize,  // sum() of sizeof(each_instruction)
    pub raw: Vec<u8>, // concat() of instruction.raw
}

impl fmt::Display for Gadget {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "Gadget(addr={:#x}, text='{}')",
            self.address,
            self.text(false)
        )
    }
}

impl Gadget {
    pub fn new(insns: Vec<Instruction>) -> Self {
        //
        // by nature, we should never be here if insns.len() is 0 (should at least have the
        // ret insn) so we assert() to be notified
        //
        if insns.len() == 0 {
            std::panic::panic_any("GadgetBuildError");
        }

        let size = insns.iter().map(|x| x.size).sum();

        let raw = insns.iter().map(|x| x.raw.clone()).flatten().collect();

        let address = insns.get(0).unwrap().address;

        Self {
            size,
            raw,
            address,
            insns,
        }
    }

    pub fn text(&self, use_color: bool) -> String {
        self.insns
            .iter()
            .map(|i| i.text(use_color).clone() + " ; ")
            .collect()
    }
}

fn collect_previous_instructions(
    session: &Arc<Session>,
    group: &Vec<(Vec<u8>, Vec<u8>)>,
    memory_chunk: &Vec<u8>,
) -> GenericResult<Vec<(usize, usize)>> {
    let mut res: Vec<(usize, usize)> = Vec::new();

    for (opcodes, mask) in group {
        let sz = opcodes.len();

        let mut v: Vec<(usize, usize)> = memory_chunk
            .windows(sz)
            .enumerate()
            .filter(|(_, y)| {
                y.iter()
                    .enumerate()
                    .map(|(i, z)| z & mask[i])
                    .cmp(opcodes.to_owned())
                    == Ordering::Equal
            })
            .map(|(x, _)| (x, sz))
            .collect();

        res.append(&mut v);

        match session.profile_type {
            RopProfileStrategy::Fast => {
                break;
            }
            _ => {}
        }
    }

    Ok(res)
}

pub fn get_all_valid_positions_and_length(
    session: &Arc<Session>,
    cpu: &Box<dyn cpu::Cpu>,
    section: &Section,
    cursor: usize,
) -> GenericResult<Vec<(usize, usize)>> {
    let data = &section.data[cursor..].to_vec();

    let mut groups = Vec::new();

    for gadget_type in &session.gadget_types {
        match gadget_type {
            InstructionGroup::Ret => {
                debug!("inserting ret positions and length...");
                groups.append(&mut cpu.ret_insns().clone());
            }
            InstructionGroup::Call => {
                debug!("inserting call positions and length...");
                groups.append(&mut cpu.call_insns().clone());
            }
            InstructionGroup::Jump => {
                debug!("inserting jump positions and length...");
                groups.append(&mut cpu.jmp_insns().clone());
            }
            InstructionGroup::Int => todo!(),
            InstructionGroup::Iret => todo!(),
            InstructionGroup::Privileged => todo!(),
            InstructionGroup::Undefined => todo!(),
        }
    }

    collect_previous_instructions(session, &groups, data)
}

///
/// from the section.data[pos], disassemble previous instructions
///
pub fn find_gadgets_from_position(
    session: Arc<Session>,
    engine: &dyn Disassembler,
    section: &Section,
    initial_position: usize,
    initial_len: usize,
    cpu: &Box<dyn cpu::Cpu>,
) -> GenericResult<Vec<Gadget>> {
    let max_invalid_size = match cpu.cpu_type() // todo: use session.max_gadget_length
    {
        cpu::CpuType::X86 => { 16 }
        cpu::CpuType::X64 => { 16 }
        cpu::CpuType::ARM64 => { 16 }
        cpu::CpuType::ARM => { 16 }
    };

    let start_address = section.start_address.clone();
    let s: usize = if initial_position < max_invalid_size {
        0
    } else {
        initial_position - max_invalid_size
    };
    let data = &section.data[s..initial_position + initial_len];
    let mut cur = Cursor::new(data);

    //
    // browse the section for the largest gadget
    //

    let mut sz: usize = initial_len;
    let mut nb_invalid = 0;
    let step = cpu.insn_step();
    let mut gadgets: Vec<Gadget> = Vec::new();

    loop {
        let mut candidate: Vec<u8> = vec![0; sz];

        //
        // ensure we're still within the boundaries of the cursor
        //
        if (sz - step) >= data.len() {
            break;
        }

        //
        // jump to the position in the file
        //
        let current_position = -((sz - step) as i64);

        cur.seek(SeekFrom::End(current_position - step as i64))?;
        if cur.read_exact(&mut candidate).is_err() {
            warn!("{:?} Cursor reached EOF", std::thread::current().id());
            break;
        }

        //
        // disassemble the code from given position
        //
        let addr = start_address + s as u64 + cur.position() - sz as u64;
        let insns = engine.disassemble(&candidate, addr as u64);

        //
        // transform the Vec<Instruction> into a valid gadget
        //
        match insns {
            Some(x) => {
                nb_invalid = 0;
                if x.len() > 0 {
                    let last_insn = x.last().unwrap();
                    if session.gadget_types.contains(&last_insn.group) {
                        let gadget = Gadget::new(x);
                        if gadgets.iter().all(|x| x.address != gadget.address) {
                            debug!(
                                "{:?}: pushing new gadget(address={:x}, sz={})",
                                thread::current().id(),
                                gadget.address,
                                gadget.raw.len()
                            );
                            gadgets.push(gadget);
                        }
                    }
                }
            }

            None => {
                nb_invalid += 1;
                if nb_invalid == max_invalid_size {
                    break;
                }
            }
        }

        sz += step;
    }

    Ok(gadgets)
}

```

`src/main.rs`:

```rs
#[macro_use]
extern crate bitflags;

use std::io::prelude::*;
use std::{fs, path::PathBuf};

use std::sync::Arc;

use colored::*;
use gadget::InstructionGroup;
use log::{debug, error, info, warn, LevelFilter};

mod common;
mod cpu;
mod engine;
mod error;
mod format;
mod gadget;
mod section;
mod session;

use common::GenericResult;
use session::{RopProfileStrategy, Session};

fn collect_all_gadgets(sess: Session) -> GenericResult<()> {
    let start_timestamp = std::time::Instant::now();
    let sections = sess.info.format.sections();
    let total_gadgets_found: usize;
    let use_color = sess.use_color.clone();
    let unique_only = sess.unique_only.clone();
    let outfile = sess.output_file.clone();
    let entrypoint_address = sess.info.format.entry_point().clone();
    let is_64b = sess.info.is_64b();

    //
    // the real meat of the tool
    //
    info!(
        "Looking for gadgets in {} executable section(s) (with {} threads)...'",
        sections.len(),
        sess.nb_thread,
    );

    let arc = Arc::new(sess);
    {
        if !session::find_gadgets(arc.clone()) {
            error!("An error occured in `find_gadgets'");
            return Ok(());
        }
    }

    //
    // sort by address
    //
    let mut gadgets = arc.gadgets.lock().unwrap();
    gadgets.sort_by(|a, b| a.address.cmp(&b.address));

    total_gadgets_found = gadgets.len();

    //
    // if unique, filter out doublons
    //
    if unique_only {
        debug!(
            "Filtering {} gadgets for deplicates ...",
            total_gadgets_found
        );
        gadgets.dedup_by(|a, b| a.text(false).eq_ignore_ascii_case(&b.text(false)));
        info!(
            "{} duplicate gadgets removed",
            total_gadgets_found - gadgets.len()
        );
    }

    if let Some(filename) = outfile {
        info!(
            "Dumping {} gadgets to '{}'...",
            gadgets.len(),
            filename.to_str().unwrap()
        );
        if use_color {
            warn!("Disabling colors when writing to file");
        }

        let mut file = fs::File::create(filename)?;
        for g in &*gadgets {
            let txt = g.text(false);
            let addr = entrypoint_address + g.address;
            file.write((format!("{:#x} | {}\n", addr, txt)).as_bytes())?;
        }
    } else {
        info!("Dumping {} gadgets to stdout...", gadgets.len());

        for g in &*gadgets {
            let addr = match is_64b {
                true => {
                    format!("0x{:016x}", g.address)
                }
                _ => {
                    format!("0x{:08x}", g.address)
                }
            };

            if use_color {
                println!("{} | {}", addr.red(), g.text(use_color));
            } else {
                println!("{} | {}", addr, g.text(use_color));
            }
        }
    }

    info!("Done!");

    if log::log_enabled!(log::Level::Info) {
        let end_timestamp = std::time::Instant::now();
        let elapsed = end_timestamp - start_timestamp;
        let execution_time = start_timestamp.elapsed().as_secs_f64();
        info!("Execution time => {:?}", execution_time);
        info!(
            "Execution: {} gadgets found in {:?}",
            total_gadgets_found, elapsed
        );
    }

    Ok(())
}

fn main() -> GenericResult<()> {
    let sess = Session::new();
    info!("Created session: {}", sess);

    collect_all_gadgets(sess)
}

fn test_one(sz: &str, arch: &str, fmt: &str) -> bool {
    #![allow(dead_code)]
    let input_fname = PathBuf::from(format!("tests/bin/{}-{}.{}", sz, arch, fmt));
    let mut output_fname = std::env::temp_dir();
    output_fname.push(format!("rop-{}-{}.{}", sz, arch, fmt));
    let s = Session {
        filepath: input_fname.clone(),
        nb_thread: 2,
        output_file: Some(output_fname.clone()),
        unique_only: true,
        use_color: false,
        max_gadget_length: 16,
        gadget_types: vec![InstructionGroup::Ret],
        profile_type: RopProfileStrategy::Fast,
        verbosity: LevelFilter::Debug,
        info: session::ExecutableDetail::new(&input_fname, None),
        gadgets: std::sync::Mutex::new(Vec::new()),
        engine_type: engine::DisassemblyEngineType::Capstone,
    };

    let res = collect_all_gadgets(s).is_ok();

    fs::remove_file(output_fname.as_path()).unwrap();

    res
}

#[cfg(test)]
mod tests {

    mod pe {
        use super::super::*;
        const FMT: &str = "pe";

        #[test]
        fn x86() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "x86", FMT));
            }
        }

        #[test]
        fn x64() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "x64", FMT));
            }
        }

        #[test]
        fn arm32() {
            assert!(test_one("small", "arm32", FMT));
            assert!(test_one("big", "arm32", FMT));
        }

        #[test]
        fn arm64() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "arm64", FMT));
            }
        }
    }

    mod elf {
        use super::super::*;
        const FMT: &str = "elf";

        #[test]
        fn x86() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "x86", FMT));
            }
        }

        #[test]
        fn x64() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "x64", FMT));
            }
        }

        #[test]
        fn arm32() {
            for sz in vec!["big"] {
                assert!(test_one(sz, "arm32", FMT));
            }
        }

        #[test]
        fn arm64() {
            for sz in vec!["small", "big"] {
                assert!(test_one(sz, "arm64", FMT));
            }
        }
    }

    mod macho {
        use super::super::*;
        const FMT: &str = "macho";

        #[test]
        fn x86() {
            for sz in vec!["small"] {
                assert!(test_one(sz, "x86", FMT));
            }
        }

        #[test]
        fn x64() {
            for sz in vec!["small"] {
                assert!(test_one(sz, "x64", FMT));
            }
        }
    }
}

```

`src/section.rs`:

```rs
use std::fmt;

bitflags! {
    pub struct Permission: u8
    {
        const NONE = 0;
        const READABLE = 1;
        const WRITABLE = 2;
        const EXECUTABLE = 4;
        const ALL = Self::READABLE.bits | Self::WRITABLE.bits | Self::EXECUTABLE.bits;
    }
}

#[derive(Debug)]
pub struct Section {
    pub start_address: u64,
    pub end_address: u64,
    pub name: String,
    pub size: usize,
    pub permission: Permission,
    pub data: Vec<u8>,
}

impl fmt::Display for Section {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "Section(name='{}', start={:#x}, sz={:#x}, permission={:?})",
            self.name, self.start_address, self.size, self.permission
        )
    }
}

impl Section {
    pub fn new(start_address: u64, end_address: u64) -> Self {
        assert!(start_address < end_address);
        let sz = (end_address - start_address) as usize;
        Self {
            start_address: start_address,
            end_address: end_address,
            size: sz,
            name: String::from(""),
            permission: Permission::NONE,
            data: vec![0; sz],
        }
    }
}

impl From<&goblin::elf::section_header::SectionHeader> for Section {
    fn from(s: &goblin::elf::section_header::SectionHeader) -> Self {
        let permission: Permission;
        match s.is_writable() {
            true => {
                permission = Permission::READABLE | Permission::EXECUTABLE | Permission::WRITABLE
            }
            false => permission = Permission::READABLE | Permission::EXECUTABLE,
        };

        let start_address = s.sh_addr as u64;
        let size = s.sh_size as usize;
        let end_address = s.sh_addr + size as u64;

        Self {
            start_address,
            end_address,
            size,
            name: String::from(""),
            permission,
            data: vec![0; size],
        }
    }
}

```

`src/session.rs`:

```rs
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::thread;

use clap::{ArgAction, Parser, ValueEnum};
use colored::*;
use log::{debug, info, warn, Level, LevelFilter, Metadata, Record};

use crate::cpu;
use crate::engine::{DisassemblyEngine, DisassemblyEngineType};
use crate::format::{self, guess_file_format};
use crate::gadget::{
    find_gadgets_from_position, get_all_valid_positions_and_length, Gadget, InstructionGroup,
};

#[derive(std::fmt::Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]
pub enum RopProfileStrategy {
    /// Strategy Fast
    Fast,
    /// Strategy Complete
    Complete,
}

impl std::fmt::Display for RopProfileStrategy {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        std::fmt::Debug::fmt(self, f)
    }
}

#[derive(Parser, Debug)]
#[command(author, version, about, long_about)] // Read from `Cargo.toml`
pub struct Args {
    /// The file to parse
    #[arg(value_name = "FILE")]
    filepath: PathBuf,

    /// The number of threads to use
    #[arg(short, long = "number-of-threads", default_value_t = 2)]
    thread_num: u8,

    /// Write gadget to file (optional)
    #[arg(short, long = "output-file", value_name = "OUTPUT")]
    output_file: Option<PathBuf>,

    /// The verbosity level
    #[arg(short, long = "verbose", action = clap::ArgAction::Count)]
    verbosity: u8,

    /// Unique gadgets
    #[arg(short, long, action = ArgAction::SetTrue)]
    unique: bool,

    /// Force the architecture to given value
    #[arg(long, value_enum)]
    architecture: Option<cpu::CpuType>,

    /// Force the OS to given value
    #[arg(long, value_enum)]
    format: Option<format::Format>,

    /// Specify an image base
    #[arg(short, long, default_value_t = 0)]
    image_base: u32,

    /// Unique gadgets
    #[arg(long)]
    no_color: bool,

    /// The maximum number of instructions in a gadget
    #[arg(long, default_value_t = 6)]
    max_insn_per_gadget: u8,

    /// The maximum size of the gadget
    #[arg(long, default_value_t = 32)]
    max_size: u8,

    /// The type of gadgets to focus on (default - return only)
    #[arg(long, value_enum)]
    rop_types: Vec<InstructionGroup>,

    /// The profile type (default - fast)
    #[arg(long, value_enum, default_value_t = RopProfileStrategy::Fast)]
    profile_type: RopProfileStrategy,
}

pub struct ExecutableDetail {
    pub format: Box<dyn format::ExecutableFormat>,
    pub cpu: Box<dyn cpu::Cpu>,
}

impl std::fmt::Display for ExecutableDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Info({}, {}, Entry=0x{:x})",
            self.cpu.cpu_type().to_string(),
            self.format.format().to_string(),
            self.format.entry_point()
        )
    }
}

impl ExecutableDetail {
    pub fn new(filepath: &PathBuf, binfmt: Option<format::Format>) -> Self {
        let format = guess_file_format(&filepath).unwrap();
        let cpu_type = format.cpu().cpu_type();
        let cpu: Box<dyn cpu::Cpu> = match cpu_type {
            cpu::CpuType::X86 => Box::new(cpu::x86::X86 {}),
            cpu::CpuType::X64 => Box::new(cpu::x86::X64 {}),
            cpu::CpuType::ARM64 => Box::new(cpu::arm::Arm64 {}),
            cpu::CpuType::ARM => Box::new(cpu::arm::Arm {}),
        };

        let check_format = match binfmt {
            Some(fmt) => fmt == format.format(),
            _ => true,
        };

        if !check_format {
            panic!("A binary format was specify, but doesn't match the given file...")
        }

        ExecutableDetail { cpu, format }
    }

    pub fn is_64b(&self) -> bool {
        self.cpu.ptrsize() == 8
    }
}

struct RpLogger;

impl log::Log for RpLogger {
    fn enabled(&self, metadata: &Metadata) -> bool {
        metadata.level() <= Level::Trace
    }

    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            let level = match record.level().to_string().as_str() {
                "ERROR" => "ERROR".red(),
                "WARN" => "WARN".magenta(),
                "INFO" => "INFO".green(),
                "DEBUG" => "DEBUG".cyan(),
                _ => "TRACE".bold(),
            };

            println!("[{}] - {}", level, record.args());
        }
    }

    fn flush(&self) {}
}

static LOGGER: RpLogger = RpLogger;

pub struct Session {
    //
    // session required information
    //
    pub filepath: PathBuf,
    pub nb_thread: u32,
    pub verbosity: LevelFilter,
    pub output_file: Option<PathBuf>,

    //
    // misc details about the executable file (filled by )
    //
    pub info: ExecutableDetail,

    //
    // the info need to build, store and show the ropgadgets
    //
    pub engine_type: DisassemblyEngineType,
    pub max_gadget_length: usize,
    pub gadgets: Mutex<Vec<Gadget>>,
    pub unique_only: bool,
    pub use_color: bool,
    pub gadget_types: Vec<InstructionGroup>,
    pub profile_type: RopProfileStrategy,
}

impl Session {
    //
    // Build session parameters
    //
    pub fn new() -> Self {
        let args = Args::parse();

        let verbosity = match args.verbosity {
            4 => LevelFilter::Trace, // -vvvv
            3 => LevelFilter::Debug, // -vvv
            2 => LevelFilter::Info,  // -vv
            1 => LevelFilter::Warn,  // -v
            _ => LevelFilter::Error,
        };

        log::set_logger(&LOGGER)
            .map(|()| log::set_max_level(verbosity))
            .unwrap();

        let info = ExecutableDetail::new(&args.filepath, args.format);

        let gadget_types = match args.rop_types.len() {
            0 => vec![InstructionGroup::Ret],
            _ => args.rop_types.clone(),
        };

        Session {
            filepath: args.filepath,
            nb_thread: args.thread_num.into(),
            output_file: args.output_file,
            unique_only: args.unique,
            use_color: !args.no_color,
            max_gadget_length: args.max_insn_per_gadget.into(),
            gadget_types: gadget_types,
            profile_type: args.profile_type,
            verbosity: verbosity,
            info: info,
            gadgets: Mutex::new(Vec::new()),
            engine_type: DisassemblyEngineType::Capstone,
        }
    }
}

impl std::fmt::Debug for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("Session")
            .field("path", &self.filepath)
            .field("format", &self.info.format.format().to_string())
            .field("cpu", &self.info.cpu.cpu_type().to_string())
            .finish()
    }
}

impl std::fmt::Display for Session {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let gadget_types: Vec<String> = self.gadget_types.iter().map(|x| x.to_string()).collect();
        write!(
            f,
            "Session(File='{}', {}, Profile={}, GadgetTypes=[{}])",
            self.filepath.to_str().unwrap(),
            self.info,
            self.profile_type.to_string(),
            gadget_types.join(", "),
        )
    }
}

//
// find all the gadgets in the different sections in parallel
// returns true if no error occured
//
pub fn find_gadgets(session: Arc<Session>) -> bool {
    let number_of_sections = session.info.format.sections().len();
    let nb_thread = session.nb_thread.clone() as usize;

    debug!("Using {nb_thread} threads over {number_of_sections} section(s) of executable code...");

    //
    // multithread parsing of each section
    //
    for section_idx in 0..number_of_sections {
        if session.info.format.sections().get(section_idx).is_none() {
            continue;
        }

        let section = session.info.format.sections().get(section_idx).unwrap();
        let chunk_size = section.data.len() / nb_thread;

        //
        // Fill the thread pool
        //
        let mut threads: Vec<std::thread::JoinHandle<Vec<Gadget>>> = Vec::new();
        let mut pos = 0;
        let mut thread_pool_size = 0;
        let mut force_flush = false;

        loop {
            //
            // Empty the thread pool if necessary
            //
            if thread_pool_size == nb_thread || force_flush {
                for curthread in threads {
                    debug!("Joining {:?}...", curthread.thread().id());
                    let gadgets = curthread.join().unwrap();
                    {
                        let mut data = session.gadgets.lock().unwrap();
                        data.extend(gadgets);
                    }
                }

                threads = Vec::new();
                thread_pool_size = 0;

                if force_flush {
                    break;
                }
            }

            //
            // Is there still some data to parse?
            //
            if pos >= section.data.len() {
                force_flush = true;
                continue;
            }

            //
            // If so, spawn more workers
            //
            let rc_session = Arc::clone(&session);
            let thread = thread::spawn(move || thread_worker(rc_session, section_idx, pos));
            debug!(
                "Spawning {:?} (pos={} section_index={})...",
                thread.thread().id(),
                pos,
                section_idx
            );
            threads.push(thread);
            thread_pool_size += 1;
            pos += chunk_size;
        }
    }

    info!(
        "Total gadgets found => {}",
        session.gadgets.lock().unwrap().len()
    );
    true
}

fn thread_worker(session: Arc<Session>, index: usize, cursor: usize) -> Vec<Gadget> {
    let cpu = session.info.cpu.as_ref();
    let engine = DisassemblyEngine::new(&session.engine_type, cpu);
    debug!(
        "{:?}: Initialized engine {} for {:?}",
        thread::current().id(),
        engine,
        cpu.cpu_type()
    );

    let mut gadgets: Vec<Gadget> = Vec::new();
    let sections = session.info.format.sections();
    if let Some(section) = sections.get(index) {
        debug!(
            "{:?}: Processing section '{}'",
            thread::current().id(),
            section.name
        );

        let cpu = &session.info.cpu;
        let disass = engine.disassembler.as_ref();

        for (pos, len) in
            get_all_valid_positions_and_length(&session, cpu, section, cursor).unwrap()
        {
            debug!(
                "{:?}: Processing Section {}[..{:x}+{:x}] (size={:x})",
                thread::current().id(),
                section.name,
                pos,
                len,
                section.size,
            );

            let res = find_gadgets_from_position(session.clone(), disass, section, pos, len, cpu);
            if res.is_ok() {
                let mut gadget = res.unwrap();
                gadgets.append(&mut gadget);
            }
        }

        debug!(
            "{:?}: Finished processing section '{}'",
            thread::current().id(),
            section.name
        );
    } else {
        warn!(
            "{:?}: No section at index {}, ending...",
            thread::current().id(),
            index,
        );
    }

    gadgets
}

```