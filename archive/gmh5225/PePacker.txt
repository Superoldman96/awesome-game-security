Project Path: arc_gmh5225_PePacker_n5rt6eer

Source Tree:

```txt
arc_gmh5225_PePacker_n5rt6eer
├── PEPacker
│   ├── PEPacker.vcxproj
│   ├── PEPacker.vcxproj.filters
│   └── main.cpp
├── PEPacker.sln
├── PEStub
│   ├── PEStub.ico
│   ├── PEStub.rc
│   ├── PEStub.vcxproj
│   ├── PEStub.vcxproj.filters
│   ├── main.cpp
│   └── resource.h
└── README.md

```

`PEPacker.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32106.194
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PEPacker", "PEPacker\PEPacker.vcxproj", "{4A084988-CFB6-4613-80F9-489E50185F56}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "PEStub", "PEStub\PEStub.vcxproj", "{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{4A084988-CFB6-4613-80F9-489E50185F56}.Debug|x64.ActiveCfg = Debug|x64
		{4A084988-CFB6-4613-80F9-489E50185F56}.Debug|x64.Build.0 = Debug|x64
		{4A084988-CFB6-4613-80F9-489E50185F56}.Debug|x86.ActiveCfg = Debug|Win32
		{4A084988-CFB6-4613-80F9-489E50185F56}.Debug|x86.Build.0 = Debug|Win32
		{4A084988-CFB6-4613-80F9-489E50185F56}.Release|x64.ActiveCfg = Release|x64
		{4A084988-CFB6-4613-80F9-489E50185F56}.Release|x64.Build.0 = Release|x64
		{4A084988-CFB6-4613-80F9-489E50185F56}.Release|x86.ActiveCfg = Release|Win32
		{4A084988-CFB6-4613-80F9-489E50185F56}.Release|x86.Build.0 = Release|Win32
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Debug|x64.ActiveCfg = Debug|x64
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Debug|x64.Build.0 = Debug|x64
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Debug|x86.ActiveCfg = Debug|Win32
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Debug|x86.Build.0 = Debug|Win32
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Release|x64.ActiveCfg = Release|x64
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Release|x64.Build.0 = Release|x64
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Release|x86.ActiveCfg = Release|Win32
		{CA17FAF7-6833-4DB2-9C0F-51ACBA9DC8C8}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {7784F246-BEEE-469C-A7A4-19804BF557B5}
	EndGlobalSection
EndGlobal

```

`PEPacker/PEPacker.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{4a084988-cfb6-4613-80f9-489e50185f56}</ProjectGuid>
    <RootNamespace>PEPacker</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>true</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>true</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreSpecificDefaultLibraries>
      </IgnoreSpecificDefaultLibraries>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PEPacker/PEPacker.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`PEPacker/main.cpp`:

```cpp
#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <cryptopp/filters.h>
#include <cryptopp/aes.h>
#include <cryptopp/modes.h>
#include <cryptopp/gzip.h>
#include <cryptopp/hex.h>
#include <cryptopp/files.h>


#pragma warning(disable: 6011)

#define RESOURCE_ID 1000
#define AES_BLOCK_SIZE 16


BYTE* ReadPeFile(TCHAR* PePath, DWORD* PeSize);
BYTE* EncryptData(BYTE* Data, INT Length, INT* OutputLength);
BOOL UpdatePEResource(TCHAR* StubPath, TCHAR* PackedPath, PBYTE EncrtyptedData, DWORD EncrtyptedSize);


int _tmain(int argc, TCHAR* argv[])
{
	if (argc != 3) {
		_tprintf(_T("[x] Usage: PEPacker.exe [PEStub.exe] [Evil.exe]\n"));
		return 0;
	}

	TCHAR* StubPath = argv[1];
	TCHAR* PePath = argv[2];
	TCHAR* PackedPath = (TCHAR*)_T("PEPacked.exe");

	//
	// 读取需要加壳的PE文件
	//

	DWORD PeSize;
	BYTE* PeAddress = ReadPeFile(PePath, &PeSize);

	if (PeAddress == NULL) {
		return -1;
	}

	_tprintf(_T("[+] Raw File Size: %#x\n"), PeSize);

	//
	// 加密文件
	//

	INT EncryptedSize = 0;
	BYTE* EncryptedData = EncryptData(PeAddress, PeSize, &EncryptedSize);

	free(PeAddress);

	if (EncryptedData == NULL) {
		return -1;
	}

	_tprintf(_T("[+] Encrypted Data Size: %#x\n"), EncryptedSize);

	_tprintf(_T("[+] Compression Ratio: %.2f\n"), (FLOAT)EncryptedSize / PeSize);

	//
	// 开始加壳
	//

	if (UpdatePEResource(StubPath, PackedPath, EncryptedData, EncryptedSize) == FALSE) {
		_tprintf(_T("[x] Failed to Packet PE File.\n"));
		free(EncryptedData);
		return -1;
	}

	_tprintf(_T("[+] Success.\n"));

	free(EncryptedData);

	return 0;
}


BYTE* ReadPeFile(TCHAR* PePath, DWORD* PeSize)
{
	HANDLE hFile = CreateFile(PePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
		_tprintf(_T("[x] CreateFile Failed, Path: %s. Error: %#x\n"), PePath, GetLastError());
		return NULL;
	}

	*PeSize = GetFileSize(hFile, NULL);
	BYTE* PeAddress = (BYTE*)malloc(*PeSize);
	if (PeAddress == NULL) {
		_tprintf(_T("[x] Malloc Failed, Size: %#x. Error: %#x\n"), *PeSize, GetLastError());
		CloseHandle(hFile);
		return NULL;
	}

	DWORD nBytesRead = 0;
	if (ReadFile(hFile, PeAddress, *PeSize, &nBytesRead, NULL) == FALSE) {
		_tprintf(_T("[x] ReadFile Failed, Path: %s. Error: %#x\n"), PePath, GetLastError());
		CloseHandle(hFile);
		return NULL;
	}

	CloseHandle(hFile);

	return PeAddress;
}


BYTE* EncryptData(BYTE* Data, INT Length, INT* OutputLength)
{
	std::string Key;
	std::string IV = "0123456789ABCDEF";

	try {
		CryptoPP::FileSource fs("LICENSE.txt", true,
			new CryptoPP::HexDecoder(
				new CryptoPP::StringSink(Key)));
	}
	catch (CryptoPP::Exception& e) {
		_tprintf(_T("[x] Read Key Error: %hs\n"), e.what());
		return NULL;
	}

	if (Key.length() != 16 && Key.length() != 24 && Key.length() != 32) {
		_tprintf(_T("[x] Wrong Key Length\n"));
		return NULL;
	}

	std::string Input((CHAR*)Data, Length);
	CryptoPP::StringSource Source(Input, false);

	std::string Output;
	CryptoPP::StringSink Sink(Output);

	try {
		CryptoPP::CBC_Mode<CryptoPP::AES>::Encryption Encryption;
		Encryption.SetKeyWithIV((byte*)Key.c_str(), Key.length(), (byte*)IV.c_str());
		CryptoPP::StreamTransformationFilter Encryptor(Encryption);

		CryptoPP::Gzip Gzip(nullptr, CryptoPP::Gzip::MAX_DEFLATE_LEVEL);

		Source.Attach(new CryptoPP::Redirector(Gzip));
		Gzip.Attach(new CryptoPP::Redirector(Encryptor));
		Encryptor.Attach(new CryptoPP::Redirector(Sink));

		Source.PumpAll();
	}
	catch (CryptoPP::Exception& e) {
		_tprintf(_T("[x] CryptoPP Encrypt Error: %hs\n"), e.what());
		return NULL;
	}

	INT OL = (INT)Output.length();
	BYTE* EncryptedData = (BYTE*)malloc(OL);
	if (EncryptedData == NULL) {
		_tprintf(_T("[x] Malloc Failed, Size: %#x. Error: %#x\n"), OL, GetLastError());
		return NULL;
	}
	memcpy(EncryptedData, Output.c_str(), OL);

	*OutputLength = OL;

	return EncryptedData;
}


BOOL UpdatePEResource(TCHAR* StubPath, TCHAR* PackedPath, PBYTE EncryptedData, DWORD EncryptedSize)
{
	if (CopyFile(StubPath, PackedPath, FALSE) == FALSE) {
		_tprintf(_T("[x] CopyFile Failed, StubPath: %s, PackedPath: %s. Error: %#x\n"), 
			StubPath, PackedPath, GetLastError());
		return FALSE;
	}

	HANDLE hUpdateRes = BeginUpdateResource(PackedPath, FALSE);
	if (hUpdateRes == NULL) {
		_tprintf(_T("[x] BeginUpdateResource Failed. Error: %#x\n"), GetLastError());
		return FALSE;
	}

	BOOL Result = UpdateResource(hUpdateRes, TEXT("FILE"), MAKEINTRESOURCE(RESOURCE_ID),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), EncryptedData, EncryptedSize);
	if (Result == FALSE) {
		_tprintf(_T("[x] UpdateResource Failed. Error: %#x\n"), GetLastError());
		return FALSE;
	}

	if (!EndUpdateResource(hUpdateRes, FALSE)) {
		_tprintf(_T("[x] EndUpdateResource Failed. Error: %#x\n"), GetLastError());
		return FALSE;
	}

	return TRUE;
}

```

`PEStub/PEStub.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// 中文(简体，中国) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_CHS)
LANGUAGE LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED
#pragma code_page(936)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 3,10,11150,1013
 PRODUCTVERSION 3,10,11150,1013
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "Python Software Foundation"
            VALUE "FileDescription", "Python"
            VALUE "FileVersion", "3.10.11"
            VALUE "InternalName", "Python Application"
            VALUE "LegalCopyright", "Copyright (c) 2001-2023 Python Software Foundation. Copyright (c) 2000 BeOpen.com. Copyright (c) 1995-2001 CNRI. Copyright (c) 1991-1995 SMC."
            VALUE "OriginalFilename", "pythonw.exe"
            VALUE "ProductName", "Python"
            VALUE "ProductVersion", "3.10.11"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_ICON1               ICON                    "PEStub.ico"

#endif    // 中文(简体，中国) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`PEStub/PEStub.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ca17faf7-6833-4db2-9c0f-51acba9dc8c8}</ProjectGuid>
    <RootNamespace>PEStub</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v142</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>true</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>true</VcpkgUseMD>
  </PropertyGroup>
  <PropertyGroup Label="Vcpkg" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <VcpkgUseStatic>true</VcpkgUseStatic>
    <VcpkgUseMD>false</VcpkgUseMD>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PEStub.rc" />
  </ItemGroup>
  <ItemGroup>
    <Image Include="PEStub.ico" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`PEStub/PEStub.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="源文件">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;cppm;ixx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="头文件">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="资源文件">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="main.cpp">
      <Filter>源文件</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h">
      <Filter>头文件</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="PEStub.rc">
      <Filter>资源文件</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <Image Include="PEStub.ico">
      <Filter>资源文件</Filter>
    </Image>
  </ItemGroup>
</Project>
```

`PEStub/main.cpp`:

```cpp
#include <Windows.h>
#include <tchar.h>
#include <stdio.h>
#include <fstream>
#include <cryptopp/filters.h>
#include <cryptopp/aes.h>
#include <cryptopp/modes.h>
#include <cryptopp/gzip.h>
#include <cryptopp/hex.h>
#include <cryptopp/files.h>


#pragma warning(disable: 6011)

// 根据情况决定是否要隐藏窗口

//#ifdef _UNICODE
//#pragma comment(linker, "/subsystem:windows /entry:wmainCRTStartup")
//#else
//#pragma comment(linker, "/subsystem:windows /entry:mainCRTStartup")
//#endif


#define RESOURCE_ID 1000


typedef struct _PeConfig {

	PVOID					PeAddress;
	SIZE_T					PeSize;

	PIMAGE_DOS_HEADER		DosHeader;
	PIMAGE_NT_HEADERS		NtHeaders;

	PIMAGE_DATA_DIRECTORY	ImportTable;		//IMAGE_DIRECTORY_ENTRY_IMPORT
	PIMAGE_DATA_DIRECTORY	TlsTable;			//IMAGE_DIRECTORY_ENTRY_TLS
	PIMAGE_DATA_DIRECTORY	RelocationTable;	//IMAGE_DIRECTORY_ENTRY_BASERELOC
	PIMAGE_DATA_DIRECTORY	ExceptionTable;		//IMAGE_DIRECTORY_ENTRY_EXCEPTION

	PIMAGE_SECTION_HEADER	SectionHeaders;

} PeConfig, * PPeConfig;


// 提取加密数据
BYTE* ExtractEncryptedData(DWORD* EncryptedSize);

// 解密加密数据
BYTE* DecryptData(BYTE* Data, INT Length, INT* OutputLength);

// 初始化PE数据
BOOL InitPeConfig(PPeConfig Pe, PVOID PeAddress, SIZE_T PeSize);

// 内存展开PE
PVOID UnpackPE(PeConfig Pe, PVOID PeAddress, PVOID Address);


int _tmain(int argc, TCHAR* argv[])
{
	//
	// 寻找资源
	//

	DWORD EncryptedSize = 0;
	BYTE* EncryptedData = ExtractEncryptedData(&EncryptedSize);

	if (EncryptedData == NULL || EncryptedSize == 0) {
#ifdef _DEBUG
		_tprintf(_T("[x] Could Not Find %d Resource !\n"), RESOURCE_ID);
#endif
		return -1;
	}

#ifdef _DEBUG
	_tprintf(_T("[!] EncryptedData: %p, EncryptedSize: %#x\n"), EncryptedData, EncryptedSize);
#endif

	//
	// 解密资源
	//

	INT DecryptedLength = 0;
	BYTE* DecryptedData = DecryptData(EncryptedData, EncryptedSize, &DecryptedLength);

	if (DecryptedData == NULL)
		return -1;

	//
	// 申请内存准备展开PE
	//

	PVOID PeAddress = DecryptedData;
	DWORD PeSize = DecryptedLength;

	PeConfig Pe = { 0 };
	if (!InitPeConfig(&Pe, PeAddress, PeSize)) {
#ifdef _DEBUG
		_tprintf(_T("[x] InitPeConfig Failed\n"));
#endif
		return -1;
	}

	PVOID Address = VirtualAlloc((PVOID)Pe.NtHeaders->OptionalHeader.ImageBase,
		Pe.NtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	if (Address == NULL) {
#ifdef _DEBUG
		_tprintf(_T("[x] First VirtualAlloc Failed. Error: %#x\n"), GetLastError());
		_tprintf(_T("[!] You have second chance. Goodluck.\n"));
#endif
		Address = VirtualAlloc(NULL, Pe.NtHeaders->OptionalHeader.SizeOfImage, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (Address == NULL) {
#ifdef _DEBUG
			_tprintf(_T("[x] Second VirtualAlloc Failed. Error: %#x\n"), GetLastError());
#endif
			return -1;
		}
	}

#ifdef _DEBUG
	_tprintf(_T("[+] Preferable Address: 0x%p \n"), (PVOID)Pe.NtHeaders->OptionalHeader.ImageBase);
	_tprintf(_T("[+] Allocated Address: 0x%p \n"), Address);
	_tprintf(_T("[+] Allocation Size: %#x \n"), Pe.NtHeaders->OptionalHeader.SizeOfImage);
#endif

	//
	// 内存展开PE
	//

	PVOID EP = UnpackPE(Pe, PeAddress, Address);
	if (EP == NULL) {
		return -1;
	}

	// 抹掉PE头
	ZeroMemory(Address, (SIZE_T)Pe.SectionHeaders[0].VirtualAddress);

	// 释放内存
	free(PeAddress);

	//
	// 运行PE
	//

#ifdef _DEBUG
	_tprintf(_T("[+] Running The Packed Pe's Entry Point ... \n\n\n"));
#endif

	// 创建新线程执行PE
	HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)EP, 0, 0, NULL);
	if (hThread == NULL) {
#ifdef _DEBUG
		_tprintf(_T("[x] CreateThread Failed. Error: %#x\n"), GetLastError());
#endif
		return -1;
	}

	WaitForSingleObject(hThread, INFINITE);

	return 0;
}


BYTE* ExtractEncryptedData(DWORD* EncryptedSize)
{
	HRSRC hResource = FindResource(GetModuleHandle(NULL), MAKEINTRESOURCE(1000), TEXT("FILE"));
	if (hResource == NULL) {
#ifdef _DEBUG
		_tprintf(_T("[x] FindResource Failed, Error: %#x\n"), GetLastError());
#endif
		return NULL;
	}

	HGLOBAL hGlobal = LoadResource(NULL, hResource);
	if (hGlobal == NULL) {
#ifdef _DEBUG
		_tprintf(_T("[x] LoadResource Failed, Error: %#x\n"), GetLastError());
#endif
		return NULL;
	}

	*EncryptedSize = SizeofResource(NULL, hResource);

	return (BYTE*)LockResource(hGlobal);
}


BYTE* DecryptData(BYTE* Data, INT Length, INT* OutputLength)
{
	std::string Key;
	std::string IV = "0123456789ABCDEF";

	// 寻找临时目录
	CHAR TempPath[MAX_PATH + 1] = "";
	DWORD Len =  GetTempPathA(MAX_PATH + 1, TempPath);
	if (Len == 0) {
#ifdef _DEBUG
		_tprintf(_T("[!] Can Not Get Temp Path\n"));
#endif
	}

	// 拼接Key路径
	std::string KeyPath[] = {
		std::string(TempPath) + "LICENSE.txt",
		std::string("LICENSE.txt"),
		std::string("C:\\Windows\\Temp\\LICENSE.txt")
	};

	// 尝试打开文件
	std::ifstream ifs;
	for (std::string k : KeyPath) {
		ifs.open(k);
		if (ifs.is_open())
			break;
	}

	if (ifs.is_open() == false) {
#ifdef _DEBUG
		_tprintf(_T("[x] Can Not Find Key File\n"));
#endif
		return NULL;
	}

	// 读取密钥
	try {
		CryptoPP::FileSource fs(ifs, true,
			new CryptoPP::HexDecoder(
				new CryptoPP::StringSink(Key)));
	}
	catch (CryptoPP::Exception& e) {
#ifdef _DEBUG
		_tprintf(_T("[x] Read Key Error: %hs\n"), e.what());
#endif
		ifs.close();
		return NULL;
	}

	ifs.close();

	if (Key.length() != 16 && Key.length() != 24 && Key.length() != 32) {
#ifdef _DEBUG
		_tprintf(_T("[x] Wrong Key Length\n"));
#endif
		return NULL;
	}

	std::string Input((CHAR*)Data, Length);
	CryptoPP::StringSource Source(Input, false);

	std::string Output;
	CryptoPP::StringSink Sink(Output);

	try {
		CryptoPP::CBC_Mode<CryptoPP::AES>::Decryption Decryption;
		Decryption.SetKeyWithIV((byte*)Key.c_str(), Key.length(), (byte*)IV.c_str());
		CryptoPP::StreamTransformationFilter Decryptor(Decryption);

		CryptoPP::Gunzip Gunzip;

		Source.Attach(new CryptoPP::Redirector(Decryptor));
		Decryptor.Attach(new CryptoPP::Redirector(Gunzip));
		Gunzip.Attach(new CryptoPP::Redirector(Sink));

		Source.PumpAll();
	}
	catch (CryptoPP::Exception& e) {
#ifdef _DEBUG
		_tprintf(_T("[x] CryptoPP Decrypt Error: %hs\n"), e.what());
#endif
		return NULL;
	}

	INT OL = (INT)Output.length();
	BYTE* DecryptedData = (BYTE*)malloc(OL);
	if (DecryptedData == NULL) {
#ifdef _DEBUG
		_tprintf(_T("[x] Malloc Failed, Size: %#x. Error: %#x\n"), OL, GetLastError());
#endif
		return NULL;
	}
	memcpy(DecryptedData, Output.c_str(), OL);

	*OutputLength = OL;

	return DecryptedData;
}


BOOL InitPeConfig(PPeConfig Pe, PVOID PeAddress, SIZE_T PeSize)
{
	if (PeAddress == NULL || PeSize == NULL) {
		return FALSE;
	}

	Pe->PeAddress = PeAddress;
	Pe->PeSize = PeSize;

	Pe->DosHeader = (PIMAGE_DOS_HEADER)PeAddress;
	if (Pe->DosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}

	Pe->NtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)PeAddress + Pe->DosHeader->e_lfanew);
	if (Pe->NtHeaders->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	Pe->ImportTable = &Pe->NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
	Pe->TlsTable = &Pe->NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
	Pe->RelocationTable = &Pe->NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
	Pe->ExceptionTable = &Pe->NtHeaders->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
	Pe->SectionHeaders = (PIMAGE_SECTION_HEADER)((SIZE_T)Pe->NtHeaders + sizeof(IMAGE_NT_HEADERS));

	if (Pe->DosHeader == NULL || Pe->NtHeaders == NULL ||
		Pe->ImportTable == NULL || Pe->TlsTable == NULL ||
		Pe->RelocationTable == NULL || Pe->ExceptionTable == NULL ||
		Pe->SectionHeaders == NULL) {
		return FALSE;
	}

	return TRUE;
}


BOOL FixImportAddressTable(PeConfig Pe, PVOID Address)
{
	// 遍历DLL
	for (DWORD i = 0; i < Pe.ImportTable->Size; i += sizeof(IMAGE_IMPORT_DESCRIPTOR)) {

		PIMAGE_IMPORT_DESCRIPTOR ImageImportDescriptor = (IMAGE_IMPORT_DESCRIPTOR*)((ULONG_PTR)Address + Pe.ImportTable->VirtualAddress + i);

		if (ImageImportDescriptor->OriginalFirstThunk == NULL && ImageImportDescriptor->FirstThunk == NULL) {
			break;
		}

		LPSTR		DllName = (LPSTR)((ULONG_PTR)Address + ImageImportDescriptor->Name);
		ULONG_PTR	Head = ImageImportDescriptor->FirstThunk;
		ULONG_PTR	Next = ImageImportDescriptor->OriginalFirstThunk;
		SIZE_T		HeadSize = 0;
		SIZE_T		NextSize = 0;
		HMODULE		hDLL = LoadLibraryA(DllName);

		if (hDLL == NULL) {
			return FALSE;
		}

		if (Next == NULL) {
			Next = ImageImportDescriptor->FirstThunk;
		}

		// 开始导入函数
		while (TRUE) {

			PIMAGE_THUNK_DATA			FirstThunk = (IMAGE_THUNK_DATA*)((ULONG_PTR)Address + HeadSize + Head);
			PIMAGE_THUNK_DATA			OrginFirstThunk = (IMAGE_THUNK_DATA*)((ULONG_PTR)Address + NextSize + Next);
			PIMAGE_IMPORT_BY_NAME		FunctionName = NULL;
			ULONG_PTR					Function = NULL;

			if (FirstThunk->u1.Function == NULL) {
				break;
			}

			// 通过DLL序号导入
			if (OrginFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG) {
				Function = (ULONG_PTR)GetProcAddress(hDLL, (CHAR*)(OrginFirstThunk->u1.Ordinal & 0xFFFF));
			}

			// 通过函数名字导入
			else {
				FunctionName = (PIMAGE_IMPORT_BY_NAME)((SIZE_T)Address + OrginFirstThunk->u1.AddressOfData);
				Function = (ULONG_PTR)GetProcAddress(hDLL, FunctionName->Name);
			}

			if (Function == NULL) {
#ifdef _DEBUG
				_tprintf(_T("[x] Could Not Import !%hs.%hs\n"), DllName, FunctionName->Name);
#endif
				return FALSE;
			}

			FirstThunk->u1.Function = Function;

			// 下一个函数
			HeadSize += sizeof(IMAGE_THUNK_DATA);
			NextSize += sizeof(IMAGE_THUNK_DATA);

		}
	}

	return TRUE;
}


BOOL Relocate(PeConfig Pe, PVOID Address)
{
	typedef struct _BASE_RELOCATION_ENTRY {
		WORD Offset : 12;
		WORD Type : 4;
	} BASE_RELOCATION_ENTRY, * PBASE_RELOCATION_ENTRY;

	PIMAGE_BASE_RELOCATION  RelocationTable = (PIMAGE_BASE_RELOCATION)((ULONG_PTR)Address + Pe.RelocationTable->VirtualAddress);
	ULONG_PTR				Offset = (ULONG_PTR)Address - Pe.NtHeaders->OptionalHeader.ImageBase;

	while (RelocationTable->VirtualAddress != 0) {

		// 重定位表项跟IMAGE_BASE_RELOCATION结构体是连在一起的
		PBASE_RELOCATION_ENTRY Relocation = (PBASE_RELOCATION_ENTRY)((ULONG_PTR)RelocationTable + sizeof(IMAGE_BASE_RELOCATION));

		while ((PBYTE)Relocation != (PBYTE)RelocationTable + RelocationTable->SizeOfBlock) {

			switch (Relocation->Type) {
			case IMAGE_REL_BASED_DIR64:
				*((ULONG_PTR*)((ULONG_PTR)Address + RelocationTable->VirtualAddress + Relocation->Offset)) += Offset;
				break;
			case IMAGE_REL_BASED_HIGHLOW:
				*((DWORD*)((ULONG_PTR)Address + RelocationTable->VirtualAddress + Relocation->Offset)) += (DWORD)Offset;
				break;

			case IMAGE_REL_BASED_HIGH:
				*((WORD*)((ULONG_PTR)Address + RelocationTable->VirtualAddress + Relocation->Offset)) += HIWORD(Offset);
				break;

			case IMAGE_REL_BASED_LOW:
				*((WORD*)((ULONG_PTR)Address + RelocationTable->VirtualAddress + Relocation->Offset)) += LOWORD(Offset);
				break;

			case IMAGE_REL_BASED_ABSOLUTE:
				break;

			default:
#ifdef _DEBUG
				_tprintf(_T("[x] Unknown Relocation Type: %#x\n"), Relocation->Type);
#endif
				return FALSE;
			}

			Relocation++;
		}

		RelocationTable = (PIMAGE_BASE_RELOCATION)Relocation;
	}

	return TRUE;
}


PVOID UnpackPE(PeConfig Pe, PVOID PeAddress, PVOID Address)
{
	// 复制PE头
	memcpy(Address, PeAddress, Pe.NtHeaders->OptionalHeader.SizeOfHeaders);

	// 复制各段
	for (int i = 0; i < Pe.NtHeaders->FileHeader.NumberOfSections; i++) {
#ifdef _DEBUG
		_tprintf(_T("\t[%0.2d] Section: %hs. Copying 0x%p To 0x%p of Size: %d\n"), i,
			Pe.SectionHeaders[i].Name,
			(PVOID)((ULONG_PTR)PeAddress + Pe.SectionHeaders[i].PointerToRawData),
			(PVOID)((ULONG_PTR)Address + Pe.SectionHeaders[i].VirtualAddress),
			Pe.SectionHeaders[i].SizeOfRawData);
#endif

		memcpy(
			(BYTE*)Address + Pe.SectionHeaders[i].VirtualAddress,
			(BYTE*)PeAddress + Pe.SectionHeaders[i].PointerToRawData,
			Pe.SectionHeaders[i].SizeOfRawData);
	}

	// 修复IAT
	if (!FixImportAddressTable(Pe, Address)) {
#ifdef _DEBUG
		_tprintf(_T("[x] Failed To Fix The IAT.\n"));
#endif
		return NULL;
	}

	// 重定位
	if (Address != (PVOID)Pe.NtHeaders->OptionalHeader.ImageBase) {
#ifdef _DEBUG
		_tprintf(_T("[!] The Allocated Mem Is Different Than The Preferable Address, Handling Reallocations ... \n"));
#endif

		if (Pe.RelocationTable->VirtualAddress == NULL) {
#ifdef _DEBUG
			_tprintf(_T("[x] Image base has changed and relocation directory not exist\n"));
#endif
			return NULL;
		}

		if (!Relocate(Pe, Address)) {
#ifdef _DEBUG
			_tprintf(_T("[!] Failed To Fix The Re-Allocation\n"));
#endif
			return NULL;
		}
	}

#ifndef WIN32
	// 注册异常处理
	if (Pe.ExceptionTable->Size) {
#ifdef _DEBUG
		_tprintf(_T("[!] Handling The Packed Pe's Exception Handlers ... \n"));
#endif
		PIMAGE_RUNTIME_FUNCTION_ENTRY RuntimeFunctionEntry = (PIMAGE_RUNTIME_FUNCTION_ENTRY)((ULONG_PTR)Address + Pe.ExceptionTable->VirtualAddress);
		if (!RtlAddFunctionTable(RuntimeFunctionEntry, (Pe.ExceptionTable->Size / sizeof(IMAGE_RUNTIME_FUNCTION_ENTRY)) - 1, (ULONG_PTR)Address)) {
#ifdef _DEBUG
			_tprintf(_T("[!] RtlAddFunctionTable Failed. Error: %#x\n"), GetLastError());
#endif
			return NULL;
		}
	}
#endif

	// 修复段权限，需要在TLS回调处理之前
	for (DWORD i = 0; i < Pe.NtHeaders->FileHeader.NumberOfSections; i++) {

		DWORD Protection = 0;

		if (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_WRITE)
			Protection = PAGE_WRITECOPY;

		if (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_READ)
			Protection = PAGE_READONLY;

		if ((Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_READWRITE;

		if (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_EXECUTE)
			Protection = PAGE_EXECUTE;

		if ((Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_WRITE))
			Protection = PAGE_EXECUTE_WRITECOPY;

		if ((Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READ;

		if ((Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_EXECUTE) && (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_WRITE) && (Pe.SectionHeaders[i].Characteristics & IMAGE_SCN_MEM_READ))
			Protection = PAGE_EXECUTE_READWRITE;

#ifdef _DEBUG
		_tprintf(_T("\t[%0.2d] Setting Mem Permissions To %#04x on 0x%p\n"), i, Protection, (PVOID)((ULONG_PTR)Address + Pe.SectionHeaders[i].VirtualAddress));
#endif

		DWORD OldProtect;
		VirtualProtect((BYTE*)Address + Pe.SectionHeaders[i].VirtualAddress, Pe.SectionHeaders[i].SizeOfRawData, Protection, &OldProtect);
	}

	// TLS回调处理
	if (Pe.TlsTable->Size) {
#ifdef _DEBUG
		_tprintf(_T("[!] Found Tls Callbacks, Setting Up For Execution ... \n"));
#endif

		PIMAGE_TLS_DIRECTORY pImgTlsDir = (PIMAGE_TLS_DIRECTORY)((ULONG_PTR)Address + Pe.TlsTable->VirtualAddress);
		PIMAGE_TLS_CALLBACK* ppCallback = (PIMAGE_TLS_CALLBACK*)(pImgTlsDir->AddressOfCallBacks);
		for (; *ppCallback; ppCallback++) {
			(*ppCallback)((LPVOID)Address, DLL_PROCESS_ATTACH, NULL);
		}
	}

	return (PVOID)((ULONG_PTR)Address + Pe.NtHeaders->OptionalHeader.AddressOfEntryPoint);
}

```

`PEStub/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ 生成的包含文件。
// 供 PEStub.rc 使用
//
#define IDI_ICON1                       101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`README.md`:

```md
# 介绍

PEPacker是一款PE加壳工具。本工具目前仅支持对64位程序加壳。

# 编译

开发环境为Visual Studio 2019，项目依赖 `crypto++` 库，推荐使用 `vcpkg` 安装：

```
.\vcpkg install cryptopp:x64-windows
.\vcpkg install cryptopp:x64-windows-static
.\vcpkg install cryptopp:x64-windows-static-md
```

安装完依赖后直接编译即可。

# 使用方式

**编译程序：** 编译完成会获得 `PEPacker.exe` 和 `PEStub.exe` 两个文件，其中 `PEPacker.exe` 是加壳工具，`PEStub.exe` 是存根文件，确保这两个文件同时放置在同一目录下。由于加壳程序使用了加密技术，加密与解密都需要用到密钥文件。

**准备密钥文件：** 加壳前需要准备密钥文件，PEPacker使用了AES加密算法保护被加壳文件，在同级目录下新建一个 `LICENSE.txt` 文件，其中写入HEX格式的AES密钥，长度支持128/192/256位，为了方便，密钥可以使用MD5或SHA256算法生成，例如：`e10adc3949ba59abbe56e057f20f883e` 。

**使用以下指令加壳：**

```` 
PEPacker.exe [Path to Stub] [Path to PE File]
````

加壳完毕后会生成 `PEPacked.exe` 文件，即为加壳后的程序。

**使用方式：** 由于有密码的保护，加壳程序执行时需要确保 `LICENSE.txt` 文件放在同级目录，后续的使用与原被加壳程序无区别。

# 感谢

https://github.com/NUL0x4C/AtomPePacker

https://github.com/weidai11/cryptopp


```