Project Path: arc_gmh5225_Fatpack_jt8s3azb

Source Tree:

```txt
arc_gmh5225_Fatpack_jt8s3azb
├── Fatpack
│   ├── BinaryFileWriter
│   │   ├── BinaryFileWriter.cpp
│   │   └── BinaryFileWriter.h
│   ├── CommandLine
│   │   ├── CommandLine.cpp
│   │   └── CommandLine.h
│   ├── Compessor
│   │   ├── Compressor.cpp
│   │   ├── Compressor.h
│   │   └── lzma
│   │       ├── common_internal.c
│   │       ├── common_internal.h
│   │       ├── compress.c
│   │       ├── decompress.c
│   │       ├── easylzma
│   │       │   ├── common.h
│   │       │   ├── compress.h
│   │       │   └── decompress.h
│   │       ├── lzip_header.c
│   │       ├── lzip_header.h
│   │       ├── lzma_header.c
│   │       ├── lzma_header.h
│   │       ├── pavlov
│   │       │   ├── 7zBuf.c
│   │       │   ├── 7zBuf.h
│   │       │   ├── 7zBuf2.c
│   │       │   ├── 7zCrc.c
│   │       │   ├── 7zCrc.h
│   │       │   ├── 7zFile.c
│   │       │   ├── 7zFile.h
│   │       │   ├── 7zStream.c
│   │       │   ├── 7zVersion.h
│   │       │   ├── Alloc.c
│   │       │   ├── Alloc.h
│   │       │   ├── Bcj2.c
│   │       │   ├── Bcj2.h
│   │       │   ├── Bra.c
│   │       │   ├── Bra.h
│   │       │   ├── Bra86.c
│   │       │   ├── BraIA64.c
│   │       │   ├── CpuArch.h
│   │       │   ├── LzFind.c
│   │       │   ├── LzFind.h
│   │       │   ├── LzHash.h
│   │       │   ├── LzmaDec.c
│   │       │   ├── LzmaDec.h
│   │       │   ├── LzmaEnc.c
│   │       │   ├── LzmaEnc.h
│   │       │   ├── LzmaLib.c
│   │       │   ├── LzmaLib.h
│   │       │   └── Types.h
│   │       └── wrapper
│   │           ├── easylzmawrapper.cpp
│   │           └── easylzmawrapper.h
│   ├── Console
│   │   ├── Console.cpp
│   │   └── Console.h
│   ├── Fatpack.vcxproj
│   ├── Fatpack.vcxproj.filters
│   ├── IconExtractor
│   │   ├── IconExtractor.cpp
│   │   └── IconExtractor.h
│   ├── ManifestExtractor
│   │   ├── ManifestExtractor.cpp
│   │   └── ManifestExtractor.h
│   ├── PEFile
│   │   ├── PEFile.cpp
│   │   └── PEFile.h
│   ├── PostBuildStep_Debug.bat
│   ├── PostBuildStep_Release.bat
│   └── main.cpp
├── Fatpack.sln
├── Images
│   └── Concept.PNG
├── LICENSE
├── Licenses
│   ├── LICENSE_PeLoader.txt
│   ├── LICENSE_TinyZZZ.txt
│   └── README_Easylzma.txt
├── Loader_Console
│   ├── Loader_Console.vcxproj
│   ├── Loader_Console.vcxproj.filters
│   └── main.cpp
├── Loader_Windows
│   ├── Loader_Windows.vcxproj
│   ├── Loader_Windows.vcxproj.filters
│   └── main.cpp
├── README.md
├── ResourceAdder
│   ├── ResourceAdder.vcxproj
│   ├── ResourceAdder.vcxproj.filters
│   └── main.cpp
└── Shared
    ├── BinaryFileReader
    │   ├── BinaryFileReader.cpp
    │   └── BinaryFileReader.h
    ├── CRT
    │   ├── crt.cpp
    │   ├── crt.h
    │   └── crt_tls.h
    ├── Decompressor
    │   ├── Decompressor.cpp
    │   ├── Decompressor.h
    │   ├── TinyLzmaDecompress.cpp
    │   └── TinyLzmaDecompress.h
    ├── PELoader
    │   ├── PELoader
    │   │   ├── PEFile.cpp
    │   │   ├── PEFile.h
    │   │   ├── PEImage.cpp
    │   │   ├── PEImage.h
    │   │   ├── PELoader.cpp
    │   │   ├── PELoader.h
    │   │   ├── TlsResolver.cpp
    │   │   └── TlsResolver.h
    │   ├── TlsCallbackProxy
    │   │   └── TlsCallbackProxy.h
    │   └── TypeDefs
    │       └── peb.h
    ├── PELoaderStub
    │   ├── PELoaderStub.cpp
    │   └── PELoaderStub.h
    └── ResourceLoader
        ├── ResourceLoader.cpp
        └── ResourceLoader.h

```

`Fatpack.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.13.35818.85
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Fatpack", "Fatpack\Fatpack.vcxproj", "{23B3307D-097A-4F6F-BD3D-AB61BEA6D30C}"
	ProjectSection(ProjectDependencies) = postProject
		{6482B097-A9DE-4D2F-B103-7DF0BC56B231} = {6482B097-A9DE-4D2F-B103-7DF0BC56B231}
		{D6392848-12A3-4B94-BF4C-1CE727F12D0B} = {D6392848-12A3-4B94-BF4C-1CE727F12D0B}
		{E373949F-E084-4DD4-A445-43B2672C42AA} = {E373949F-E084-4DD4-A445-43B2672C42AA}
	EndProjectSection
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Loader_Console", "Loader_Console\Loader_Console.vcxproj", "{E373949F-E084-4DD4-A445-43B2672C42AA}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "ResourceAdder", "ResourceAdder\ResourceAdder.vcxproj", "{D6392848-12A3-4B94-BF4C-1CE727F12D0B}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Loader_Windows", "Loader_Windows\Loader_Windows.vcxproj", "{6482B097-A9DE-4D2F-B103-7DF0BC56B231}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{23B3307D-097A-4F6F-BD3D-AB61BEA6D30C}.Debug|x64.ActiveCfg = Debug|x64
		{23B3307D-097A-4F6F-BD3D-AB61BEA6D30C}.Debug|x64.Build.0 = Debug|x64
		{23B3307D-097A-4F6F-BD3D-AB61BEA6D30C}.Release|x64.ActiveCfg = Release|x64
		{23B3307D-097A-4F6F-BD3D-AB61BEA6D30C}.Release|x64.Build.0 = Release|x64
		{E373949F-E084-4DD4-A445-43B2672C42AA}.Debug|x64.ActiveCfg = Debug|x64
		{E373949F-E084-4DD4-A445-43B2672C42AA}.Debug|x64.Build.0 = Debug|x64
		{E373949F-E084-4DD4-A445-43B2672C42AA}.Release|x64.ActiveCfg = Release|x64
		{E373949F-E084-4DD4-A445-43B2672C42AA}.Release|x64.Build.0 = Release|x64
		{D6392848-12A3-4B94-BF4C-1CE727F12D0B}.Debug|x64.ActiveCfg = Debug|x64
		{D6392848-12A3-4B94-BF4C-1CE727F12D0B}.Debug|x64.Build.0 = Debug|x64
		{D6392848-12A3-4B94-BF4C-1CE727F12D0B}.Release|x64.ActiveCfg = Release|x64
		{D6392848-12A3-4B94-BF4C-1CE727F12D0B}.Release|x64.Build.0 = Release|x64
		{6482B097-A9DE-4D2F-B103-7DF0BC56B231}.Debug|x64.ActiveCfg = Debug|x64
		{6482B097-A9DE-4D2F-B103-7DF0BC56B231}.Debug|x64.Build.0 = Debug|x64
		{6482B097-A9DE-4D2F-B103-7DF0BC56B231}.Release|x64.ActiveCfg = Release|x64
		{6482B097-A9DE-4D2F-B103-7DF0BC56B231}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F47E0CEF-F1B0-4324-BAEC-C9C8D43B0C73}
	EndGlobalSection
EndGlobal

```

`Fatpack/BinaryFileWriter/BinaryFileWriter.cpp`:

```cpp
#include "BinaryFileWriter.h"

namespace BinaryFileWriter
{
  BinaryFileWriter::BinaryFileWriter()
  {
  }

  BinaryFileWriter::~BinaryFileWriter()
  {
  }

  bool BinaryFileWriter::WriteFile(LPCWSTR fileName, BYTE* buffer, DWORD bufferSize)
  {
    if (fileName == nullptr || buffer == nullptr || bufferSize == 0) return false;

    DWORD bytesWritten = 0;
    HANDLE outputFileHandle = ::CreateFileW(fileName, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, nullptr);
    if (outputFileHandle == INVALID_HANDLE_VALUE) return false;

    bool result = ::WriteFile(outputFileHandle, buffer, bufferSize, &bytesWritten, nullptr);
    CloseHandle(outputFileHandle);

    return (result && bytesWritten > 0);
  }
}



```

`Fatpack/BinaryFileWriter/BinaryFileWriter.h`:

```h
#pragma once
#include <Windows.h>

namespace BinaryFileWriter
{
  class BinaryFileWriter
  {
  public:
    BinaryFileWriter();
    ~BinaryFileWriter();

    bool WriteFile(LPCWSTR fileName, BYTE* buffer, DWORD bufferSize);
  };
}



```

`Fatpack/CommandLine/CommandLine.cpp`:

```cpp
#include "CommandLine.h"

namespace CommandLine
{
  CommandLine::CommandLine()
  {
  }

  CommandLine::~CommandLine()
  {
  }

  LPWSTR CommandLine::GetCommandLine()
  {
    return ::GetCommandLineW();
  }

  LPWSTR* CommandLine::CommandLineToArgv(LPWSTR commandLine, int& argc)
  {
    return ::CommandLineToArgvW(commandLine, &argc);
  }
}
```

`Fatpack/CommandLine/CommandLine.h`:

```h
#pragma once
#include <Windows.h>

namespace CommandLine
{
  class CommandLine
  {
  public:
    CommandLine();
    ~CommandLine();

    LPWSTR GetCommandLine();
    LPWSTR* CommandLineToArgv(LPWSTR commandLine, int& argc);
  };
}
```

`Fatpack/Compessor/Compressor.cpp`:

```cpp
#include "Compressor.h"
#include "lzma\wrapper\easylzmawrapper.h"

namespace Compressor
{
  Compressor::Compressor()
  {
  }

  Compressor::~Compressor()
  {
  }

  bool Compressor::Compress(BYTE* source, size_t sourceLength, BYTE** compressed, size_t* compressedSize)
  {
    int result = simpleCompress(ELZMA_lzma, source, sourceLength, compressed, compressedSize);
    return (result == ELZMA_E_OK && *compressed != nullptr && *compressedSize != 0);
  }

  void Compressor::Free(BYTE* compressed)
  {
    if (compressed == nullptr) return;
    free(compressed);
  }
}
```

`Fatpack/Compessor/Compressor.h`:

```h
#pragma once
#include <Windows.h>

namespace Compressor
{
  class Compressor
  {
  public:
    Compressor();
    ~Compressor();

    bool Compress(BYTE* source, size_t sourceLength, BYTE** compressed, size_t* compressedSize);
    void Free(BYTE* compressed);
  };
}
```

`Fatpack/Compessor/lzma/common_internal.c`:

```c
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 */

#include "common_internal.h"

static void *elzmaAlloc(void *p, size_t size) {
    struct elzma_alloc_struct * as = (struct elzma_alloc_struct *) p;
    if (as->clientMallocFunc) {
        return as->clientMallocFunc(as->clientMallocContext, size);
    }
    return malloc(size);
}

static void elzmaFree(void *p, void *address) {
    struct elzma_alloc_struct * as = (struct elzma_alloc_struct *) p;
    if (as->clientFreeFunc) {
        as->clientFreeFunc(as->clientMallocContext, address);
    } else {
        free(address);
    }
}

void
init_alloc_struct(struct elzma_alloc_struct * as,
                  elzma_malloc clientMallocFunc,
                  void * clientMallocContext,
                  elzma_free clientFreeFunc,
                  void * clientFreeContext)
{
    as->Alloc = elzmaAlloc;
    as->Free = elzmaFree;    
    as->clientMallocFunc = clientMallocFunc;
    as->clientMallocContext = clientMallocContext;    
    as->clientFreeFunc = clientFreeFunc;
    as->clientFreeContext = clientFreeContext;    
}

```

`Fatpack/Compessor/lzma/common_internal.h`:

```h
#ifndef __ELZMA_COMMON_INTERNAL_H__
#define __ELZMA_COMMON_INTERNAL_H__

#include "easylzma/common.h"

/** a structure which may be cast and passed into Igor's allocate
 *  routines */
struct elzma_alloc_struct {
    void *(*Alloc)(void *p, size_t size);
    void (*Free)(void *p, void *address); /* address can be 0 */

    elzma_malloc clientMallocFunc;
    void * clientMallocContext;

    elzma_free clientFreeFunc;
    void * clientFreeContext;
};

/* initialize an allocation structure, may be called safely multiple
 * times */
void init_alloc_struct(struct elzma_alloc_struct * allocStruct,
                       elzma_malloc clientMallocFunc,
                       void * clientMallocContext,
                       elzma_free clientFreeFunc,
                       void * clientFreeContext);

/** superset representation of a compressed file header */
struct elzma_file_header {
    unsigned char pb;
    unsigned char lp;    
    unsigned char lc;    
    unsigned char isStreamed;    
    long long unsigned int uncompressedSize;
    unsigned int dictSize;
};

/** superset representation of a compressed file footer */
struct elzma_file_footer {
    unsigned int crc32;
    long long unsigned int uncompressedSize;
};

/** a structure which encapsulates information about the particular
 *  file header and footer in use (lzip vs lzma vs (eventually) xz.
 *  The intention of this structure is to simplify compression and
 *  decompression logic by abstracting the file format details a bit.  */
struct elzma_format_handler
{
    unsigned int header_size;
    void (*init_header)(struct elzma_file_header * hdr);    
    int (*parse_header)(const unsigned char * hdrBuf,
                        struct elzma_file_header * hdr);
    int (*serialize_header)(unsigned char * hdrBuf,
                            const struct elzma_file_header * hdr);

    unsigned int footer_size;
    int (*serialize_footer)(struct elzma_file_footer * ftr,
                            unsigned char * ftrBuf);
    int (*parse_footer)(const unsigned char * ftrBuf,
                        struct elzma_file_footer * ftr);
};

#endif

```

`Fatpack/Compessor/lzma/compress.c`:

```c
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 */

#include "easylzma/compress.h"
#include "lzma_header.h"
#include "lzip_header.h"
#include "common_internal.h"

#include "pavlov/Types.h"
#include "pavlov/LzmaEnc.h"
#include "pavlov/7zCrc.h"

struct _elzma_compress_handle {
    CLzmaEncProps props;
    CLzmaEncHandle encHand;
    unsigned long long uncompressedSize;
    elzma_file_format format;
    struct elzma_alloc_struct allocStruct;
    struct elzma_format_handler formatHandler;
};

elzma_compress_handle
elzma_compress_alloc()
{
    elzma_compress_handle hand = malloc(sizeof(struct _elzma_compress_handle));
    memset((void *) hand, 0, sizeof(struct _elzma_compress_handle));

    /* "reasonable" defaults for props */
    LzmaEncProps_Init(&(hand->props));
    hand->props.lc = 3;
    hand->props.lp = 0;    
    hand->props.pb = 2;    
    hand->props.level = 5;
    hand->props.algo = 1;
    hand->props.fb = 32;
    hand->props.dictSize = 1 << 24;
    hand->props.btMode = 1;
    hand->props.numHashBytes = 4;
    hand->props.mc = 32;
    hand->props.numThreads = 1;
    hand->props.writeEndMark = 1;

    init_alloc_struct(&(hand->allocStruct), NULL, NULL, NULL, NULL);

    /* default format is LZMA-Alone */
    initializeLZMAFormatHandler(&(hand->formatHandler));

    return hand;
}

void
elzma_compress_free(elzma_compress_handle * hand)
{
    if (hand && *hand) {
        if ((*hand)->encHand) {
            LzmaEnc_Destroy((*hand)->encHand,
                            (ISzAlloc *) &((*hand)->allocStruct),
                            (ISzAlloc *) &((*hand)->allocStruct));
        }
        
    }
    *hand = NULL;
}

int
elzma_compress_config(elzma_compress_handle hand,
                      unsigned char lc,
                      unsigned char lp,
                      unsigned char pb,
                      unsigned char level,
                      unsigned int dictionarySize,
                      elzma_file_format format,
                      unsigned long long uncompressedSize)
{
    /* XXX: validate arguments are in valid ranges */

    hand->props.lc = lc;
    hand->props.lp = lp;    
    hand->props.pb = pb;
    hand->props.level = level;
    hand->props.dictSize = dictionarySize;
    hand->uncompressedSize = uncompressedSize;
    hand->format = format;

    /* default of LZMA-Alone is set at alloc time, and there are only
     * two possible formats */
    if (format == ELZMA_lzip) {
        initializeLZIPFormatHandler(&(hand->formatHandler));
    }

    return ELZMA_E_OK;
}

/* use Igor's stream hooks for compression. */
struct elzmaInStream
{
    SRes (*ReadPtr)(void *p, void *buf, size_t *size);
    elzma_read_callback inputStream;
    void * inputContext;
    unsigned int crc32;
    unsigned int crc32a;
    unsigned int crc32b;
    unsigned int crc32c;
    int calculateCRC;
};

static SRes elzmaReadFunc(void *p, void *buf, size_t *size)
{
    int rv;
    struct elzmaInStream * is = (struct elzmaInStream *) p;
    rv = is->inputStream(is->inputContext, buf, size);
    if (rv == 0 && *size > 0 && is->calculateCRC) {
        is->crc32 = CrcUpdate(is->crc32, buf, *size);
    }
    return rv;
}

struct elzmaOutStream {
    size_t (*WritePtr)(void *p, const void *buf, size_t size);
    elzma_write_callback outputStream;
    void * outputContext;
};

static size_t elzmaWriteFunc(void *p, const void *buf, size_t size)
{
    struct elzmaOutStream * os = (struct elzmaOutStream *) p;
    return os->outputStream(os->outputContext, buf, size);
}

/* use Igor's stream hooks for compression. */
struct elzmaProgressStruct
{
    SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
    long long unsigned int uncompressedSize;
    elzma_progress_callback progressCallback;
    void * progressContext;

};

#include <stdio.h>
static SRes elzmaProgress(void *p, UInt64 inSize, UInt64 outSize)
{
    struct elzmaProgressStruct * ps = (struct elzmaProgressStruct *) p;
    if (ps->progressCallback) {
        ps->progressCallback(ps->progressContext, inSize,
                             ps->uncompressedSize);
    }
    return SZ_OK;
}

void elzma_compress_set_allocation_callbacks(
    elzma_compress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext)
{
    if (hand) {
        init_alloc_struct(&(hand->allocStruct),
                          mallocFunc, mallocFuncContext,
                          freeFunc, freeFuncContext);
    }
}

int
elzma_compress_run(elzma_compress_handle hand,
                   elzma_read_callback inputStream, void * inputContext,
                   elzma_write_callback outputStream, void * outputContext,
                   elzma_progress_callback progressCallback,
                   void * progressContext)
{
    struct elzmaInStream inStreamStruct;
    struct elzmaOutStream outStreamStruct;    
    struct elzmaProgressStruct progressStruct;    
	SRes r;

    CrcGenerateTable();

    if (hand == NULL || inputStream == NULL) return ELZMA_E_BAD_PARAMS;

    /* initialize stream structrures */
    inStreamStruct.ReadPtr = elzmaReadFunc;
    inStreamStruct.inputStream = inputStream;    
    inStreamStruct.inputContext = inputContext;    
    inStreamStruct.crc32 = CRC_INIT_VAL;
    inStreamStruct.calculateCRC =
        (hand->formatHandler.serialize_footer != NULL);

    outStreamStruct.WritePtr = elzmaWriteFunc;
    outStreamStruct.outputStream = outputStream;    
    outStreamStruct.outputContext = outputContext;    

    progressStruct.Progress = elzmaProgress;
    progressStruct.uncompressedSize = hand->uncompressedSize;
    progressStruct.progressCallback = progressCallback;
    progressStruct.progressContext = progressContext;

    /* create an encoding object */
    hand->encHand = LzmaEnc_Create((ISzAlloc *) &(hand->allocStruct));

    if (hand->encHand == NULL) {
        return ELZMA_E_COMPRESS_ERROR;
    }

    /* inintialize with compression parameters */
    if (SZ_OK != LzmaEnc_SetProps(hand->encHand, &(hand->props)))
    {
        return ELZMA_E_BAD_PARAMS;
    }

    /* verify format is sane */
    if (ELZMA_lzma != hand->format && ELZMA_lzip != hand->format) {
        return ELZMA_E_UNSUPPORTED_FORMAT;
    }

    /* now write the compression header header */ 
    {
        unsigned char * hdr =
            hand->allocStruct.Alloc(&(hand->allocStruct),
                                    hand->formatHandler.header_size);
        
        struct elzma_file_header h;
        size_t wt;

        hand->formatHandler.init_header(&h);
        h.pb = (unsigned char) hand->props.pb;
        h.lp = (unsigned char) hand->props.lp;
        h.lc = (unsigned char) hand->props.lc;
        h.dictSize = hand->props.dictSize;
        h.isStreamed = (unsigned char) (hand->uncompressedSize == 0);
        h.uncompressedSize = hand->uncompressedSize;

        hand->formatHandler.serialize_header(hdr, &h);

        wt = outputStream(outputContext, (void *) hdr,
                          hand->formatHandler.header_size);

        hand->allocStruct.Free(&(hand->allocStruct), hdr);
        
        if (wt != hand->formatHandler.header_size) {
            return ELZMA_E_OUTPUT_ERROR;
        }
    }
    
    /* begin LZMA encoding */
    /* XXX: expose encoding progress */
    r = LzmaEnc_Encode(hand->encHand,
                       (ISeqOutStream *) &outStreamStruct,
                       (ISeqInStream *) &inStreamStruct,
                       (ICompressProgress *) &progressStruct,
                       (ISzAlloc *) &(hand->allocStruct),
                       (ISzAlloc *) &(hand->allocStruct));

    if (r != SZ_OK) return ELZMA_E_COMPRESS_ERROR;

    /* support a footer! (lzip) */
    if (hand->formatHandler.serialize_footer != NULL &&
        hand->formatHandler.footer_size > 0)
    {
        size_t wt;
        unsigned char * ftrBuf = 
            hand->allocStruct.Alloc(&(hand->allocStruct),
                                    hand->formatHandler.footer_size);
        struct elzma_file_footer ftr;
        ftr.crc32 = inStreamStruct.crc32 ^ 0xFFFFFFFF;
        ftr.uncompressedSize = hand->uncompressedSize;

        hand->formatHandler.serialize_footer(&ftr, ftrBuf);

        wt = outputStream(outputContext, (void *) ftrBuf,
                          hand->formatHandler.footer_size);

        hand->allocStruct.Free(&(hand->allocStruct), ftrBuf);
        
        if (wt != hand->formatHandler.footer_size) {
            return ELZMA_E_OUTPUT_ERROR;
        }
    }
    
    return ELZMA_E_OK;
}

unsigned int
elzma_get_dict_size(unsigned long long size)
{
    int i = 13; /* 16k dict is minimum */

    /* now we'll find the closes power of two with a max at 16< *
     * if the size is greater than 8m, we'll divide by two, all of this
     * is based on a quick set of emperical tests on hopefully
     * representative sample data */
    if ( size > ( 1 << 23 ) ) size >>= 1;

    while (size >> i) i++;

    if (i > 23) return 1 << 23;

    /* now 1 << i is greater than size, let's return either 1<<i or 1<<(i-1),
     * whichever is closer to size */
    return 1 << ((((1 << i) - size) > (size - (1 << (i-1)))) ? i-1 : i);
}

```

`Fatpack/Compessor/lzma/decompress.c`:

```c
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 */

#include "easylzma/decompress.h"
#include "pavlov/LzmaDec.h"
#include "pavlov/7zCrc.h"
#include "common_internal.h"
#include "lzma_header.h"
#include "lzip_header.h"

#define ELZMA_DECOMPRESS_INPUT_BUFSIZE (1024 * 64)
#define ELZMA_DECOMPRESS_OUTPUT_BUFSIZE (1024 * 256)

/** an opaque handle to an lzma decompressor */
struct _elzma_decompress_handle {
    char inbuf[ELZMA_DECOMPRESS_INPUT_BUFSIZE];
    char outbuf[ELZMA_DECOMPRESS_OUTPUT_BUFSIZE];    
    struct elzma_alloc_struct allocStruct;
};

elzma_decompress_handle
elzma_decompress_alloc()
{
    elzma_decompress_handle hand =
        malloc(sizeof(struct _elzma_decompress_handle));
    memset((void *) hand, 0, sizeof(struct _elzma_decompress_handle));
    init_alloc_struct(&(hand->allocStruct), NULL, NULL, NULL, NULL);
    return hand;
}

void elzma_decompress_set_allocation_callbacks(
    elzma_decompress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext)
{
    if (hand) {
        init_alloc_struct(&(hand->allocStruct),
                          mallocFunc, mallocFuncContext,
                          freeFunc, freeFuncContext);
    }
}


void
elzma_decompress_free(elzma_decompress_handle * hand)
{
    if (*hand) free(*hand);
    *hand = NULL;
}

int
elzma_decompress_run(elzma_decompress_handle hand,
                     elzma_read_callback inputStream, void * inputContext,
                     elzma_write_callback outputStream, void * outputContext,
                     elzma_file_format format)
{
    unsigned long long int totalRead = 0; /* total amount read from stream */
    unsigned int crc32 = CRC_INIT_VAL; /* running crc32 (lzip case) */     
    CLzmaDec dec;
    unsigned int errorCode = ELZMA_E_OK;
    struct elzma_format_handler formatHandler;
    struct elzma_file_header h;
    struct elzma_file_footer f;

    /* switch between supported formats */ 
    if (format == ELZMA_lzma) {
        initializeLZMAFormatHandler(&formatHandler);
    } else if (format == ELZMA_lzip) {
        CrcGenerateTable();        
        initializeLZIPFormatHandler(&formatHandler);
    } else {
        return ELZMA_E_BAD_PARAMS;        
    }

    /* initialize footer */
    f.crc32 = 0;
    f.uncompressedSize = 0;
    
    /* initialize decoder memory */
    memset((void *) &dec, 0, sizeof(dec));
    LzmaDec_Init(&dec);

    /* decode the header. */
    {
        unsigned char * hdr = 
            hand->allocStruct.Alloc(&(hand->allocStruct),
                                    formatHandler.header_size);

        size_t sz = formatHandler.header_size;

        formatHandler.init_header(&h);        

        if (inputStream(inputContext, hdr, &sz) != 0 ||
            sz != formatHandler.header_size)
        {
            hand->allocStruct.Free(&(hand->allocStruct), hdr);
            return ELZMA_E_INPUT_ERROR;
        }

        if (0 != formatHandler.parse_header(hdr, &h)) {
            hand->allocStruct.Free(&(hand->allocStruct), hdr);
            return ELZMA_E_CORRUPT_HEADER;
        }

        /* the LzmaDec_Allocate call requires 5 bytes which have
         * compression properties encoded in them.  In the case of
         * lzip, the header format does not already contain what
         * LzmaDec_Allocate expects, so we must craft it, silly */
        {
            unsigned char propsBuf[13];
            const unsigned char * propsPtr = hdr;            

            if (format == ELZMA_lzip) {
                struct elzma_format_handler lzmaHand;
                initializeLZMAFormatHandler(&lzmaHand);
                lzmaHand.serialize_header(propsBuf, &h);
                propsPtr = propsBuf;
            }

            /* now we're ready to allocate the decoder */
            LzmaDec_Allocate(&dec, propsPtr, 5,
                             (ISzAlloc *) &(hand->allocStruct));
        }
        
        hand->allocStruct.Free(&(hand->allocStruct), hdr);
    }

    /* perform the decoding */
    for (;;)
    {
        size_t dstLen = ELZMA_DECOMPRESS_OUTPUT_BUFSIZE;
        size_t srcLen = ELZMA_DECOMPRESS_INPUT_BUFSIZE;
        size_t amt = 0;
        size_t bufOff = 0;
		ELzmaStatus stat;

        if (0 != inputStream(inputContext, hand->inbuf, &srcLen))
        {
            errorCode = ELZMA_E_INPUT_ERROR;
            goto decompressEnd;                    
        }

        /* handle the case where the input prematurely finishes */
        if (srcLen == 0) {
            errorCode = ELZMA_E_INSUFFICIENT_INPUT;
            goto decompressEnd;
        }
        
        amt = srcLen;

        /* handle the case where a single read buffer of compressed bytes
         * will translate into multiple buffers of uncompressed bytes,
         * with this inner loop */
        stat = LZMA_STATUS_NOT_SPECIFIED;

        while (bufOff < srcLen) {
            SRes r = LzmaDec_DecodeToBuf(&dec, (Byte *) hand->outbuf, &dstLen,
                                         ((Byte *) hand->inbuf + bufOff), &amt,
                                         LZMA_FINISH_ANY, &stat);

            /* XXX deal with result code more granularly*/
            if (r != SZ_OK) {
                errorCode = ELZMA_E_DECOMPRESS_ERROR;
                goto decompressEnd;
            }
            
            /* write what we've read */
            {
                size_t wt;
                
                /* if decoding lzip, update our crc32 value */
                if (format == ELZMA_lzip && dstLen > 0) {
                    crc32 = CrcUpdate(crc32, hand->outbuf, dstLen);

                }
                totalRead += dstLen;
                
                wt = outputStream(outputContext, hand->outbuf, dstLen);
                if (wt != dstLen) {
                    errorCode = ELZMA_E_OUTPUT_ERROR;
                    goto decompressEnd;                    
                }
            }
            
            /* do we have more data on the input buffer? */
            bufOff += amt;
            if (bufOff >= srcLen) break;
            amt = srcLen - bufOff;

            /* with lzip, we will have the footer left on the buffer! */
            if (stat == LZMA_STATUS_FINISHED_WITH_MARK) {
                break;
            }
        }

        /* now check status */
        if (stat == LZMA_STATUS_FINISHED_WITH_MARK) {
            /* read a footer if one is expected and
             * present */ 
            if (formatHandler.footer_size > 0 &&
                amt >= formatHandler.footer_size &&
                formatHandler.parse_footer != NULL)
            {
                formatHandler.parse_footer(
                    (unsigned char *) hand->inbuf + bufOff, &f);
            }

            break;
        }
        /* for LZMA utils,  we don't always have a finished mark */
        if (!h.isStreamed && totalRead >= h.uncompressedSize) {
            break;
        }
    }

    /* finish the calculated crc32 */
    crc32 ^= 0xFFFFFFFF;

    /* if we have a footer, check that the calculated crc32 matches
     * the encoded crc32, and that the sizes match */
    if (formatHandler.footer_size)
    {
        if (f.crc32 != crc32) {
            errorCode = ELZMA_E_CRC32_MISMATCH;
        } else if (f.uncompressedSize != totalRead) {
            errorCode = ELZMA_E_SIZE_MISMATCH;            
        }
    }
    else if (!h.isStreamed)
    {
        /* if the format does not support a footer and has an uncompressed
         * size in the header, let's compare that with how much we actually
         * read */
        if (h.uncompressedSize != totalRead) {
            errorCode = ELZMA_E_SIZE_MISMATCH;
        }
    }

  decompressEnd:
    LzmaDec_Free(&dec, (ISzAlloc *) &(hand->allocStruct));

    return errorCode;
}

```

`Fatpack/Compessor/lzma/easylzma/common.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/common.h - definitions common to both compression and
 *                     decompression
 */

#ifndef __EASYLZMACOMMON_H__ 
#define __EASYLZMACOMMON_H__ 

#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/* msft dll export gunk.  To build a DLL on windows, you
 * must define WIN32, EASYLZMA_SHARED, and EASYLZMA_BUILD.  To use a 
 * DLL, you must define EASYLZMA_SHARED and WIN32 */
#if defined(WIN32) && defined(EASYLZMA_SHARED)
#  ifdef EASYLZMA_BUILD
#    define EASYLZMA_API __declspec(dllexport)
#  else
#    define EASYLZMA_API __declspec(dllimport)
#  endif
#else
#  define EASYLZMA_API
#endif 

/** error codes */

/** no error */
#define ELZMA_E_OK                               0
/** bad parameters passed to an ELZMA function */
#define ELZMA_E_BAD_PARAMS                      10
/** could not initialize the encode with configured parameters. */
#define ELZMA_E_ENCODING_PROPERTIES_ERROR       11
/** an error occured during compression (XXX: be more specific) */
#define ELZMA_E_COMPRESS_ERROR                  12
/** currently unsupported lzma file format was specified*/
#define ELZMA_E_UNSUPPORTED_FORMAT              13
/** an error occured when reading input */
#define ELZMA_E_INPUT_ERROR                     14
/** an error occured when writing output */
#define ELZMA_E_OUTPUT_ERROR                    15
/** LZMA header couldn't be parsed */
#define ELZMA_E_CORRUPT_HEADER                  16
/** an error occured during decompression (XXX: be more specific) */
#define ELZMA_E_DECOMPRESS_ERROR                17
/** the input stream returns EOF before the decompression could complete */
#define ELZMA_E_INSUFFICIENT_INPUT              18
/** for formats which have an emebedded crc, this error would indicated that
 *  what came out was not what went in, i.e. data corruption */
#define ELZMA_E_CRC32_MISMATCH                  19
/** for formats which have an emebedded uncompressed content length,
 *  this error indicates that the amount we read was not what we expected */
#define ELZMA_E_SIZE_MISMATCH                   20


/** Supported file formats */
typedef enum {
    ELZMA_lzip, /**< the lzip format which includes a magic number and
                 *   CRC check */
    ELZMA_lzma  /**< the LZMA-Alone format, originally designed by
                 *   Igor Pavlov and in widespread use due to lzmautils,
                 *   lacking both aforementioned features of lzip */
/* XXX: future, potentially   ,
    ELZMA_xz 
*/
} elzma_file_format;

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process has generated [de]compressed output.
 *
 * the size parameter indicates how much data is in buf to be written.
 * it is required that the write callback consume all data, and a return
 * value not equal to input size indicates and error.
 */
typedef size_t (*elzma_write_callback)(void *ctx, const void *buf,
                                       size_t size);

/**
 * A callback invoked during elzma_[de]compress_run when the [de]compression
 * process requires more [un]compressed input.
 *
 * the size parameter is an in/out argument.  on input it indicates
 * the buffer size.  on output it indicates the amount of data read into
 * buf.  when *size is zero on output it indicates EOF.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef int (*elzma_read_callback)(void *ctx, void *buf,
                                   size_t *size);

/**
 * A callback invoked during elzma_[de]compress_run to report progress
 * on the [de]compression.
 *
 * \returns the read callback should return nonzero on failure.
 */
typedef void (*elzma_progress_callback)(void *ctx, size_t complete,
                                        size_t total);


/** pointer to a malloc function, supporting client overriding memory
 *  allocation routines */
typedef void * (*elzma_malloc)(void *ctx, unsigned int sz);

/** pointer to a free function, supporting client overriding memory
 *  allocation routines */
typedef void (*elzma_free)(void *ctx, void * ptr);

#ifdef __cplusplus
};
#endif    

#endif

```

`Fatpack/Compessor/lzma/easylzma/compress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/compress.h - the API for LZMA compression using easylzma
 */

#ifndef __EASYLZMACOMPRESS_H__ 
#define __EASYLZMACOMPRESS_H__ 

#include "common.h"
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif    

/** suggested default values */
#define ELZMA_LC_DEFAULT 3
#define ELZMA_LP_DEFAULT 0
#define ELZMA_PB_DEFAULT 2
#define ELZMA_DICT_SIZE_DEFAULT_MAX (1 << 24)

/** an opaque handle to an lzma compressor */
typedef struct _elzma_compress_handle * elzma_compress_handle;

/**
 * Allocate a handle to an LZMA compressor object.
 */ 
elzma_compress_handle EASYLZMA_API elzma_compress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_compress_set_allocation_callbacks(
    elzma_compress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA compressor object.
 */ 
void EASYLZMA_API elzma_compress_free(elzma_compress_handle * hand);

/**
 * Set configuration paramters for a compression run.  If not called,
 * reasonable defaults will be used.
 */ 
int EASYLZMA_API elzma_compress_config(elzma_compress_handle hand,
                                       unsigned char lc,
                                       unsigned char lp,
                                       unsigned char pb,
                                       unsigned char level,
                                       unsigned int dictionarySize,
                                       elzma_file_format format,
                                       unsigned long long uncompressedSize);

/**
 * Run compression
 */ 
int EASYLZMA_API elzma_compress_run(
    elzma_compress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_progress_callback progressCallback, void * progressContext);


/**
 * a heuristic utility routine to guess a dictionary size that gets near
 * optimal compression while reducing memory usage.
 * accepts a size in bytes, returns a proposed dictionary size
 */
unsigned int EASYLZMA_API elzma_get_dict_size(unsigned long long size);

#ifdef __cplusplus
};
#endif    

#endif

```

`Fatpack/Compessor/lzma/easylzma/decompress.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * easylzma/decompress.h - The API for LZMA decompression using easylzma
 */

#ifndef __EASYLZMADECOMPRESS_H__ 
#define __EASYLZMADECOMPRESS_H__ 

#include "common.h"

#ifdef __cplusplus
extern "C" {
#endif    

/** an opaque handle to an lzma decompressor */
typedef struct _elzma_decompress_handle * elzma_decompress_handle;

/**
 * Allocate a handle to an LZMA decompressor object.
 */ 
elzma_decompress_handle EASYLZMA_API elzma_decompress_alloc();

/**
 * set allocation routines (optional, if not called malloc & free will
 * be used) 
 */ 
void EASYLZMA_API elzma_decompress_set_allocation_callbacks(
    elzma_decompress_handle hand,
    elzma_malloc mallocFunc, void * mallocFuncContext,
    elzma_free freeFunc, void * freeFuncContext);

/**
 * Free all data associated with an LZMA decompressor object.
 */ 
void EASYLZMA_API elzma_decompress_free(elzma_decompress_handle * hand);

/**
 * Perform decompression
 *
 * XXX: should the library automatically detect format by reading stream?
 *      currently it's based on data external to stream (such as extension
 *      or convention)
 */ 
int EASYLZMA_API elzma_decompress_run(
    elzma_decompress_handle hand,
    elzma_read_callback inputStream, void * inputContext,
    elzma_write_callback outputStream, void * outputContext,
    elzma_file_format format);


#ifdef __cplusplus
};
#endif    

#endif

```

`Fatpack/Compessor/lzma/lzip_header.c`:

```c
#include <Windows.h>
#include "lzip_header.h"

#define ELZMA_LZIP_HEADER_SIZE 6
#define ELZMA_LZIP_FOOTER_SIZE 12

static
void initLzipHeader(struct elzma_file_header * hdr)
{
    memset((void *) hdr, 0, sizeof(struct elzma_file_header));
}

static
int parseLzipHeader(const unsigned char * hdrBuf,
                    struct elzma_file_header * hdr)
{
    if (0 != strncmp("LZIP", (char *) hdrBuf, 4)) return 1;
    /* XXX: ignore version for now */
    hdr->pb = 2;
    hdr->lp = 0;    
    hdr->lc = 3;        
    /* unknown at this point */
    hdr->isStreamed = 1;
    hdr->uncompressedSize = 0;    
    hdr->dictSize = 1 << (hdrBuf[5] & 0x1F);
    return 0;
}

static int
serializeLzipHeader(unsigned char * hdrBuf,
                    const struct elzma_file_header * hdr)
{
    hdrBuf[0] = 'L';
    hdrBuf[1] = 'Z';
    hdrBuf[2] = 'I';
    hdrBuf[3] = 'P';
    hdrBuf[4] = 0;
    {
        int r = 0;
        while ((hdr->dictSize >> r) != 0) r++;
        hdrBuf[5] = (unsigned char) (r-1) & 0x1F;
    }        
    return 0;
}

static int
serializeLzipFooter(struct elzma_file_footer * ftr,
                    unsigned char * ftrBuf)
{
	unsigned int i = 0;

    /* first crc32 */
    for (i = 0; i < 4; i++) {
        *(ftrBuf++) = (unsigned char) (ftr->crc32 >> (i * 8)); 
    }

    /* next data size */
    for (i = 0; i < 8; i++) {
        *(ftrBuf++) = (unsigned char) (ftr->uncompressedSize >> (i * 8)); 
    }

    /* write version 0 files, omit member length for now*/
    
    return 0;
}

static int
parseLzipFooter(const unsigned char * ftrBuf,
                struct elzma_file_footer * ftr)
{
	unsigned int i = 0;
    ftr->crc32 = 0;
    ftr->uncompressedSize = 0;    

    /* first crc32 */
    for (i = 0; i < 4; i++)
    {
        ftr->crc32 += ((unsigned int) *(ftrBuf++) << (i * 8)); 
    }

    /* next data size */
    for (i = 0; i < 8; i++) {
        ftr->uncompressedSize +=
            (unsigned long long) *(ftrBuf++) << (i * 8); 
    }
    /* read version 0 files, omit member length for now*/
    
    return 0;
}

void
initializeLZIPFormatHandler(struct elzma_format_handler * hand)
{
    hand->header_size = ELZMA_LZIP_HEADER_SIZE;
    hand->init_header = initLzipHeader;
    hand->parse_header = parseLzipHeader;    
    hand->serialize_header = serializeLzipHeader;    
    hand->footer_size = ELZMA_LZIP_FOOTER_SIZE;    
    hand->serialize_footer = serializeLzipFooter;
    hand->parse_footer = parseLzipFooter;
}


```

`Fatpack/Compessor/lzma/lzip_header.h`:

```h
#ifndef __EASYLZMA_LZIP_HEADER__
#define __EASYLZMA_LZIP_HEADER__

#include "common_internal.h"

/* lzip file format documented here:
 * http://download.savannah.gnu.org/releases-noredirect/lzip/manual/ */

void initializeLZIPFormatHandler(struct elzma_format_handler * hand);

#endif

```

`Fatpack/Compessor/lzma/lzma_header.c`:

```c
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 */

/* XXX: clean this up, it's mostly lifted from pavel */

#include "lzma_header.h"

#define ELZMA_LZMA_HEADER_SIZE 13
#define ELZMA_LZMA_PROPSBUF_SIZE 5

/****************
  Header parsing
 ****************/

#ifndef UINT64_MAX
#define UINT64_MAX ((unsigned long long) -1)
#endif

/* Parse the properties byte */
static char
lzmadec_header_properties (
	unsigned char *pb, unsigned char *lp, unsigned char *lc, const unsigned char c)
{
/*	 pb, lp and lc are encoded into a single byte.  */
	if (c > (9 * 5 * 5))
		return -1;
	*pb = c / (9 * 5);        /* 0 <= pb <= 4 */
    *lp = (c % (9 * 5)) / 9;  /* 0 <= lp <= 4 */
    *lc = c % 9;              /* 0 <= lc <= 8 */

	return 0;
}

/* Parse the dictionary size (4 bytes, little endian) */
static char
lzmadec_header_dictionary (unsigned int *size, const unsigned char *buffer)
{
	unsigned int i;
	*size = 0;
	for (i = 0; i < 4; i++)
		*size += (unsigned int)(*buffer++) << (i * 8);
	/* The dictionary size is limited to 256 MiB (checked from
	 * LZMA SDK 4.30) */
	if (*size > (1 << 28))
		return -1;
	return 0;
}

/* Parse the uncompressed size field (8 bytes, little endian) */
static void
lzmadec_header_uncompressed (unsigned long long *size,
                             unsigned char *is_streamed,
                             const unsigned char *buffer)
{
	unsigned int i;

    /* Streamed files have all 64 bits set in the size field.
     * We don't know the uncompressed size beforehand. */
	*is_streamed = 1;  /* Assume streamed. */
	*size = 0;
	for (i = 0; i < 8; i++) {
		*size += (unsigned long long)buffer[i] << (i * 8);
		if (buffer[i] != 255)
			*is_streamed = 0;
	}
}

static void
initLzmaHeader(struct elzma_file_header * hdr)
{
    memset((void *) hdr, 0, sizeof(struct elzma_file_header));
}

static int
parseLzmaHeader(const unsigned char * hdrBuf,
                struct elzma_file_header * hdr)
{
    if (lzmadec_header_properties(&(hdr->pb), &(hdr->lp), &(hdr->lc),
                                  *hdrBuf) ||
        lzmadec_header_dictionary(&(hdr->dictSize), hdrBuf + 1))
    {
        return 1;
    }
    lzmadec_header_uncompressed(&(hdr->uncompressedSize),
                                &(hdr->isStreamed),
                                hdrBuf + 5);
    
    return 0;
}

static int
serializeLzmaHeader(unsigned char * hdrBuf,
                    const struct elzma_file_header * hdr)
{
    unsigned int i;
    
    memset((void *) hdrBuf, 0, ELZMA_LZMA_HEADER_SIZE); 

    /* encode lc, pb, and lp */
    *hdrBuf++ = hdr->lc + (hdr->pb * 45) + (hdr->lp * 45 * 9);

    /* encode dictionary size */
    for (i = 0; i < 4; i++) {
        *(hdrBuf++) = (unsigned char) (hdr->dictSize >> (i * 8)); 
    }

    /* encode uncompressed size */
    for (i = 0; i < 8; i++) {
        if (hdr->isStreamed) {
            *(hdrBuf++) = 0xff; 
        } else {
            *(hdrBuf++) = (unsigned char) (hdr->uncompressedSize >> (i * 8)); 
        }
    }

    return 0;
}

void
initializeLZMAFormatHandler(struct elzma_format_handler * hand)
{
    hand->header_size = ELZMA_LZMA_HEADER_SIZE;
    hand->init_header = initLzmaHeader;
    hand->parse_header = parseLzmaHeader;    
    hand->serialize_header = serializeLzmaHeader;    
    hand->footer_size = 0;    
    hand->serialize_footer = NULL;
}

```

`Fatpack/Compessor/lzma/lzma_header.h`:

```h
#ifndef __EASYLZMA_LZMA_HEADER__
#define __EASYLZMA_LZMA_HEADER__

#include "common_internal.h"

/* LZMA-Alone header format gleaned from reading Igor's code */

void initializeLZMAFormatHandler(struct elzma_format_handler * hand);

#endif

```

`Fatpack/Compessor/lzma/pavlov/7zBuf.c`:

```c
/* 7zBuf.c -- Byte Buffer
2008-03-28
Igor Pavlov
Public domain */

#include "7zBuf.h"

void Buf_Init(CBuf *p)
{
  p->data = 0;
  p->size = 0;
}

int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc)
{
  p->size = 0;
  if (size == 0)
  {
    p->data = 0;
    return 1;
  }
  p->data = (Byte *)alloc->Alloc(alloc, size);
  if (p->data != 0)
  {
    p->size = size;
    return 1;
  }
  return 0;
}

void Buf_Free(CBuf *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->data);
  p->data = 0;
  p->size = 0;
}

```

`Fatpack/Compessor/lzma/pavlov/7zBuf.h`:

```h
/* 7zBuf.h -- Byte Buffer
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __7Z_BUF_H
#define __7Z_BUF_H

#include "Types.h"

typedef struct
{
  Byte *data;
  size_t size;
} CBuf;

void Buf_Init(CBuf *p);
int Buf_Create(CBuf *p, size_t size, ISzAlloc *alloc);
void Buf_Free(CBuf *p, ISzAlloc *alloc);

typedef struct
{
  Byte *data;
  size_t size;
  size_t pos;
} CDynBuf;

void DynBuf_Construct(CDynBuf *p);
void DynBuf_SeekToBeg(CDynBuf *p);
int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc);
void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc);

#endif

```

`Fatpack/Compessor/lzma/pavlov/7zBuf2.c`:

```c
/* 7zBuf2.c -- Byte Buffer
2008-10-04 : Igor Pavlov : Public domain */

#include "7zBuf.h"

void DynBuf_Construct(CDynBuf *p)
{
  p->data = 0;
  p->size = 0;
  p->pos = 0;
}

void DynBuf_SeekToBeg(CDynBuf *p)
{
  p->pos = 0;
}

int DynBuf_Write(CDynBuf *p, const Byte *buf, size_t size, ISzAlloc *alloc)
{
  if (size > p->size - p->pos)
  {
    size_t newSize = p->pos + size;
    Byte *data;
    newSize += newSize / 4;
    data = (Byte *)alloc->Alloc(alloc, newSize);
    if (data == 0)
      return 0;
    p->size = newSize;
    memcpy(data, p->data, p->pos);
    alloc->Free(alloc, p->data);
    p->data = data;
  }
  memcpy(p->data + p->pos, buf, size);
  p->pos += size;
  return 1;
}

void DynBuf_Free(CDynBuf *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->data);
  p->data = 0;
  p->size = 0;
  p->pos = 0;
}

```

`Fatpack/Compessor/lzma/pavlov/7zCrc.c`:

```c
/* 7zCrc.c -- CRC32 calculation
2008-08-05
Igor Pavlov
Public domain */

#include "7zCrc.h"

#define kCrcPoly 0xEDB88320
UInt32 g_CrcTable[256];

void MY_FAST_CALL CrcGenerateTable(void)
{
  UInt32 i;
  for (i = 0; i < 256; i++)
  {
    UInt32 r = i;
    int j;
    for (j = 0; j < 8; j++)
      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
    g_CrcTable[i] = r;
  }
}

UInt32 MY_FAST_CALL CrcUpdate(UInt32 v, const void *data, size_t size)
{
  const Byte *p = (const Byte *)data;
  for (; size > 0 ; size--, p++)
    v = CRC_UPDATE_BYTE(v, *p);
  return v;
}

UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size)
{
  return CrcUpdate(CRC_INIT_VAL, data, size) ^ 0xFFFFFFFF;
}

```

`Fatpack/Compessor/lzma/pavlov/7zCrc.h`:

```h
/* 7zCrc.h -- CRC32 calculation
2008-03-13
Igor Pavlov
Public domain */

#ifndef __7Z_CRC_H
#define __7Z_CRC_H

#include <stddef.h>

#include "Types.h"

extern UInt32 g_CrcTable[];

void MY_FAST_CALL CrcGenerateTable(void);

#define CRC_INIT_VAL 0xFFFFFFFF
#define CRC_GET_DIGEST(crc) ((crc) ^ 0xFFFFFFFF)
#define CRC_UPDATE_BYTE(crc, b) (g_CrcTable[((crc) ^ (b)) & 0xFF] ^ ((crc) >> 8))

UInt32 MY_FAST_CALL CrcUpdate(UInt32 crc, const void *data, size_t size);
UInt32 MY_FAST_CALL CrcCalc(const void *data, size_t size);

#endif

```

`Fatpack/Compessor/lzma/pavlov/7zFile.c`:

```c
/* 7zFile.c -- File IO
2008-11-22 : Igor Pavlov : Public domain */

#include "7zFile.h"

#ifndef USE_WINDOWS_FILE

#include <errno.h>

#endif

#ifdef USE_WINDOWS_FILE

/*
   ReadFile and WriteFile functions in Windows have BUG:
   If you Read or Write 64MB or more (probably min_failure_size = 64MB - 32KB + 1)
   from/to Network file, it returns ERROR_NO_SYSTEM_RESOURCES
   (Insufficient system resources exist to complete the requested service).
   Probably in some version of Windows there are problems with other sizes:
   for 32 MB (maybe also for 16 MB).
   And message can be "Network connection was lost"
*/

#define kChunkSizeMax (1 << 22)

#endif

void File_Construct(CSzFile *p)
{
  #ifdef USE_WINDOWS_FILE
  p->handle = INVALID_HANDLE_VALUE;
  #else
  p->file = NULL;
  #endif
}

static WRes File_Open(CSzFile *p, const char *name, int writeMode)
{
  #ifdef USE_WINDOWS_FILE
  p->handle = CreateFileA(name,
      writeMode ? GENERIC_WRITE : GENERIC_READ,
      FILE_SHARE_READ, NULL,
      writeMode ? CREATE_ALWAYS : OPEN_EXISTING,
      FILE_ATTRIBUTE_NORMAL, NULL);
  return (p->handle != INVALID_HANDLE_VALUE) ? 0 : GetLastError();
  #else
  p->file = fopen(name, writeMode ? "wb+" : "rb");
  return (p->file != 0) ? 0 : errno;
  #endif
}

WRes InFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 0); }
WRes OutFile_Open(CSzFile *p, const char *name) { return File_Open(p, name, 1); }

WRes File_Close(CSzFile *p)
{
  #ifdef USE_WINDOWS_FILE
  if (p->handle != INVALID_HANDLE_VALUE)
  {
    if (!CloseHandle(p->handle))
      return GetLastError();
    p->handle = INVALID_HANDLE_VALUE;
  }
  #else
  if (p->file != NULL)
  {
    int res = fclose(p->file);
    if (res != 0)
      return res;
    p->file = NULL;
  }
  #endif
  return 0;
}

WRes File_Read(CSzFile *p, void *data, size_t *size)
{
  size_t originalSize = *size;
  if (originalSize == 0)
    return 0;

  #ifdef USE_WINDOWS_FILE

  *size = 0;
  do
  {
    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
    DWORD processed = 0;
    BOOL res = ReadFile(p->handle, data, curSize, &processed, NULL);
    data = (void *)((Byte *)data + processed);
    originalSize -= processed;
    *size += processed;
    if (!res)
      return GetLastError();
    if (processed == 0)
      break;
  }
  while (originalSize > 0);
  return 0;

  #else
  
  *size = fread(data, 1, originalSize, p->file);
  if (*size == originalSize)
    return 0;
  return ferror(p->file);
  
  #endif
}

WRes File_Write(CSzFile *p, const void *data, size_t *size)
{
  size_t originalSize = *size;
  if (originalSize == 0)
    return 0;
  
  #ifdef USE_WINDOWS_FILE

  *size = 0;
  do
  {
    DWORD curSize = (originalSize > kChunkSizeMax) ? kChunkSizeMax : (DWORD)originalSize;
    DWORD processed = 0;
    BOOL res = WriteFile(p->handle, data, curSize, &processed, NULL);
    data = (void *)((Byte *)data + processed);
    originalSize -= processed;
    *size += processed;
    if (!res)
      return GetLastError();
    if (processed == 0)
      break;
  }
  while (originalSize > 0);
  return 0;

  #else

  *size = fwrite(data, 1, originalSize, p->file);
  if (*size == originalSize)
    return 0;
  return ferror(p->file);
  
  #endif
}

WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin)
{
  #ifdef USE_WINDOWS_FILE

  LARGE_INTEGER value;
  DWORD moveMethod;
  value.LowPart = (DWORD)*pos;
  value.HighPart = (LONG)((UInt64)*pos >> 16 >> 16); /* for case when UInt64 is 32-bit only */
  switch (origin)
  {
    case SZ_SEEK_SET: moveMethod = FILE_BEGIN; break;
    case SZ_SEEK_CUR: moveMethod = FILE_CURRENT; break;
    case SZ_SEEK_END: moveMethod = FILE_END; break;
    default: return ERROR_INVALID_PARAMETER;
  }
  value.LowPart = SetFilePointer(p->handle, value.LowPart, &value.HighPart, moveMethod);
  if (value.LowPart == 0xFFFFFFFF)
  {
    WRes res = GetLastError();
    if (res != NO_ERROR)
      return res;
  }
  *pos = ((Int64)value.HighPart << 32) | value.LowPart;
  return 0;

  #else
  
  int moveMethod;
  int res;
  switch (origin)
  {
    case SZ_SEEK_SET: moveMethod = SEEK_SET; break;
    case SZ_SEEK_CUR: moveMethod = SEEK_CUR; break;
    case SZ_SEEK_END: moveMethod = SEEK_END; break;
    default: return 1;
  }
  res = fseek(p->file, (long)*pos, moveMethod);
  *pos = ftell(p->file);
  return res;
  
  #endif
}

WRes File_GetLength(CSzFile *p, UInt64 *length)
{
  #ifdef USE_WINDOWS_FILE
  
  DWORD sizeHigh;
  DWORD sizeLow = GetFileSize(p->handle, &sizeHigh);
  if (sizeLow == 0xFFFFFFFF)
  {
    DWORD res = GetLastError();
    if (res != NO_ERROR)
      return res;
  }
  *length = (((UInt64)sizeHigh) << 32) + sizeLow;
  return 0;
  
  #else
  
  long pos = ftell(p->file);
  int res = fseek(p->file, 0, SEEK_END);
  *length = ftell(p->file);
  fseek(p->file, pos, SEEK_SET);
  return res;
  
  #endif
}


/* ---------- FileSeqInStream ---------- */

static SRes FileSeqInStream_Read(void *pp, void *buf, size_t *size)
{
  CFileSeqInStream *p = (CFileSeqInStream *)pp;
  return File_Read(&p->file, buf, size) == 0 ? SZ_OK : SZ_ERROR_READ;
}

void FileSeqInStream_CreateVTable(CFileSeqInStream *p)
{
  p->s.Read = FileSeqInStream_Read;
}


/* ---------- FileInStream ---------- */

static SRes FileInStream_Read(void *pp, void *buf, size_t *size)
{
  CFileInStream *p = (CFileInStream *)pp;
  return (File_Read(&p->file, buf, size) == 0) ? SZ_OK : SZ_ERROR_READ;
}

static SRes FileInStream_Seek(void *pp, Int64 *pos, ESzSeek origin)
{
  CFileInStream *p = (CFileInStream *)pp;
  return File_Seek(&p->file, pos, origin);
}

void FileInStream_CreateVTable(CFileInStream *p)
{
  p->s.Read = FileInStream_Read;
  p->s.Seek = FileInStream_Seek;
}


/* ---------- FileOutStream ---------- */

static size_t FileOutStream_Write(void *pp, const void *data, size_t size)
{
  CFileOutStream *p = (CFileOutStream *)pp;
  File_Write(&p->file, data, &size);
  return size;
}

void FileOutStream_CreateVTable(CFileOutStream *p)
{
  p->s.Write = FileOutStream_Write;
}

```

`Fatpack/Compessor/lzma/pavlov/7zFile.h`:

```h
/* 7zFile.h -- File IO
2008-11-22 : Igor Pavlov : Public domain */

#ifndef __7Z_FILE_H
#define __7Z_FILE_H

#ifdef _WIN32
#define USE_WINDOWS_FILE
#endif

#ifdef USE_WINDOWS_FILE
#include <windows.h>
#else
#include <stdio.h>
#endif

#include "Types.h"


/* ---------- File ---------- */

typedef struct
{
  #ifdef USE_WINDOWS_FILE
  HANDLE handle;
  #else
  FILE *file;
  #endif
} CSzFile;

void File_Construct(CSzFile *p);
WRes InFile_Open(CSzFile *p, const char *name);
WRes OutFile_Open(CSzFile *p, const char *name);
WRes File_Close(CSzFile *p);

/* reads max(*size, remain file's size) bytes */
WRes File_Read(CSzFile *p, void *data, size_t *size);

/* writes *size bytes */
WRes File_Write(CSzFile *p, const void *data, size_t *size);

WRes File_Seek(CSzFile *p, Int64 *pos, ESzSeek origin);
WRes File_GetLength(CSzFile *p, UInt64 *length);


/* ---------- FileInStream ---------- */

typedef struct
{
  ISeqInStream s;
  CSzFile file;
} CFileSeqInStream;

void FileSeqInStream_CreateVTable(CFileSeqInStream *p);


typedef struct
{
  ISeekInStream s;
  CSzFile file;
} CFileInStream;

void FileInStream_CreateVTable(CFileInStream *p);


typedef struct
{
  ISeqOutStream s;
  CSzFile file;
} CFileOutStream;

void FileOutStream_CreateVTable(CFileOutStream *p);

#endif

```

`Fatpack/Compessor/lzma/pavlov/7zStream.c`:

```c
/* 7zStream.c -- 7z Stream functions
2008-11-23 : Igor Pavlov : Public domain */

#include "Types.h"

SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType)
{
  while (size != 0)
  {
    size_t processed = size;
    RINOK(stream->Read(stream, buf, &processed));
    if (processed == 0)
      return errorType;
    buf = (void *)((Byte *)buf + processed);
    size -= processed;
  }
  return SZ_OK;
}

SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size)
{
  return SeqInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
}

SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf)
{
  size_t processed = 1;
  RINOK(stream->Read(stream, buf, &processed));
  return (processed == 1) ? SZ_OK : SZ_ERROR_INPUT_EOF;
}

SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset)
{
  Int64 t = offset;
  return stream->Seek(stream, &t, SZ_SEEK_SET);
}

SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size)
{
  void *lookBuf;
  if (*size == 0)
    return SZ_OK;
  RINOK(stream->Look(stream, &lookBuf, size));
  memcpy(buf, lookBuf, *size);
  return stream->Skip(stream, *size);
}

SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType)
{
  while (size != 0)
  {
    size_t processed = size;
    RINOK(stream->Read(stream, buf, &processed));
    if (processed == 0)
      return errorType;
    buf = (void *)((Byte *)buf + processed);
    size -= processed;
  }
  return SZ_OK;
}

SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size)
{
  return LookInStream_Read2(stream, buf, size, SZ_ERROR_INPUT_EOF);
}

static SRes LookToRead_Look_Lookahead(void *pp, void **buf, size_t *size)
{
  SRes res = SZ_OK;
  CLookToRead *p = (CLookToRead *)pp;
  size_t size2 = p->size - p->pos;
  if (size2 == 0 && *size > 0)
  {
    p->pos = 0;
    size2 = LookToRead_BUF_SIZE;
    res = p->realStream->Read(p->realStream, p->buf, &size2);
    p->size = size2;
  }
  if (size2 < *size)
    *size = size2;
  *buf = p->buf + p->pos;
  return res;
}

static SRes LookToRead_Look_Exact(void *pp, void **buf, size_t *size)
{
  SRes res = SZ_OK;
  CLookToRead *p = (CLookToRead *)pp;
  size_t size2 = p->size - p->pos;
  if (size2 == 0 && *size > 0)
  {
    p->pos = 0;
    if (*size > LookToRead_BUF_SIZE)
      *size = LookToRead_BUF_SIZE;
    res = p->realStream->Read(p->realStream, p->buf, size);
    size2 = p->size = *size;
  }
  if (size2 < *size)
    *size = size2;
  *buf = p->buf + p->pos;
  return res;
}

static SRes LookToRead_Skip(void *pp, size_t offset)
{
  CLookToRead *p = (CLookToRead *)pp;
  p->pos += offset;
  return SZ_OK;
}

static SRes LookToRead_Read(void *pp, void *buf, size_t *size)
{
  CLookToRead *p = (CLookToRead *)pp;
  size_t rem = p->size - p->pos;
  if (rem == 0)
    return p->realStream->Read(p->realStream, buf, size);
  if (rem > *size)
    rem = *size;
  memcpy(buf, p->buf + p->pos, rem);
  p->pos += rem;
  *size = rem;
  return SZ_OK;
}

static SRes LookToRead_Seek(void *pp, Int64 *pos, ESzSeek origin)
{
  CLookToRead *p = (CLookToRead *)pp;
  p->pos = p->size = 0;
  return p->realStream->Seek(p->realStream, pos, origin);
}

void LookToRead_CreateVTable(CLookToRead *p, int lookahead)
{
  p->s.Look = lookahead ?
      LookToRead_Look_Lookahead :
      LookToRead_Look_Exact;
  p->s.Skip = LookToRead_Skip;
  p->s.Read = LookToRead_Read;
  p->s.Seek = LookToRead_Seek;
}

void LookToRead_Init(CLookToRead *p)
{
  p->pos = p->size = 0;
}

static SRes SecToLook_Read(void *pp, void *buf, size_t *size)
{
  CSecToLook *p = (CSecToLook *)pp;
  return LookInStream_LookRead(p->realStream, buf, size);
}

void SecToLook_CreateVTable(CSecToLook *p)
{
  p->s.Read = SecToLook_Read;
}

static SRes SecToRead_Read(void *pp, void *buf, size_t *size)
{
  CSecToRead *p = (CSecToRead *)pp;
  return p->realStream->Read(p->realStream, buf, size);
}

void SecToRead_CreateVTable(CSecToRead *p)
{
  p->s.Read = SecToRead_Read;
}

```

`Fatpack/Compessor/lzma/pavlov/7zVersion.h`:

```h
#define MY_VER_MAJOR 4
#define MY_VER_MINOR 63
#define MY_VER_BUILD 0
#define MY_VERSION "4.63"
#define MY_DATE "2008-12-31"
#define MY_COPYRIGHT ": Igor Pavlov : Public domain"
#define MY_VERSION_COPYRIGHT_DATE MY_VERSION " " MY_COPYRIGHT " : " MY_DATE

```

`Fatpack/Compessor/lzma/pavlov/Alloc.c`:

```c
/* Alloc.c -- Memory allocation functions
2008-09-24
Igor Pavlov
Public domain */

#ifdef _WIN32
#include <windows.h>
#endif
#include <stdlib.h>

#include "Alloc.h"

/* #define _SZ_ALLOC_DEBUG */

/* use _SZ_ALLOC_DEBUG to debug alloc/free operations */
#ifdef _SZ_ALLOC_DEBUG
#include <stdio.h>
int g_allocCount = 0;
int g_allocCountMid = 0;
int g_allocCountBig = 0;
#endif

void *MyAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  {
    void *p = malloc(size);
    fprintf(stderr, "\nAlloc %10d bytes, count = %10d,  addr = %8X", size, g_allocCount++, (unsigned)p);
    return p;
  }
  #else
  return malloc(size);
  #endif
}

void MyFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree; count = %10d,  addr = %8X", --g_allocCount, (unsigned)address);
  #endif
  free(address);
}

#ifdef _WIN32

void *MidAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  fprintf(stderr, "\nAlloc_Mid %10d bytes;  count = %10d", size, g_allocCountMid++);
  #endif
  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
}

void MidFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree_Mid; count = %10d", --g_allocCountMid);
  #endif
  if (address == 0)
    return;
  VirtualFree(address, 0, MEM_RELEASE);
}

#ifndef MEM_LARGE_PAGES
#undef _7ZIP_LARGE_PAGES
#endif

#ifdef _7ZIP_LARGE_PAGES
SIZE_T g_LargePageSize = 0;
typedef SIZE_T (WINAPI *GetLargePageMinimumP)();
#endif

void SetLargePageSize()
{
  #ifdef _7ZIP_LARGE_PAGES
  SIZE_T size = 0;
  GetLargePageMinimumP largePageMinimum = (GetLargePageMinimumP)
        GetProcAddress(GetModuleHandle(TEXT("kernel32.dll")), "GetLargePageMinimum");
  if (largePageMinimum == 0)
    return;
  size = largePageMinimum();
  if (size == 0 || (size & (size - 1)) != 0)
    return;
  g_LargePageSize = size;
  #endif
}


void *BigAlloc(size_t size)
{
  if (size == 0)
    return 0;
  #ifdef _SZ_ALLOC_DEBUG
  fprintf(stderr, "\nAlloc_Big %10d bytes;  count = %10d", size, g_allocCountBig++);
  #endif
  
  #ifdef _7ZIP_LARGE_PAGES
  if (g_LargePageSize != 0 && g_LargePageSize <= (1 << 30) && size >= (1 << 18))
  {
    void *res = VirtualAlloc(0, (size + g_LargePageSize - 1) & (~(g_LargePageSize - 1)),
        MEM_COMMIT | MEM_LARGE_PAGES, PAGE_READWRITE);
    if (res != 0)
      return res;
  }
  #endif
  return VirtualAlloc(0, size, MEM_COMMIT, PAGE_READWRITE);
}

void BigFree(void *address)
{
  #ifdef _SZ_ALLOC_DEBUG
  if (address != 0)
    fprintf(stderr, "\nFree_Big; count = %10d", --g_allocCountBig);
  #endif
  
  if (address == 0)
    return;
  VirtualFree(address, 0, MEM_RELEASE);
}

#endif

```

`Fatpack/Compessor/lzma/pavlov/Alloc.h`:

```h
/* Alloc.h -- Memory allocation functions
2008-03-13
Igor Pavlov
Public domain */

#ifndef __COMMON_ALLOC_H
#define __COMMON_ALLOC_H

#include <stddef.h>

void *MyAlloc(size_t size);
void MyFree(void *address);

#ifdef _WIN32

void SetLargePageSize();

void *MidAlloc(size_t size);
void MidFree(void *address);
void *BigAlloc(size_t size);
void BigFree(void *address);

#else

#define MidAlloc(size) MyAlloc(size)
#define MidFree(address) MyFree(address)
#define BigAlloc(size) MyAlloc(size)
#define BigFree(address) MyFree(address)

#endif

#endif

```

`Fatpack/Compessor/lzma/pavlov/Bcj2.c`:

```c
/* Bcj2.c -- Converter for x86 code (BCJ2)
2008-10-04 : Igor Pavlov : Public domain */

#include "Bcj2.h"

#ifdef _LZMA_PROB32
#define CProb UInt32
#else
#define CProb UInt16
#endif

#define IsJcc(b0, b1) ((b0) == 0x0F && ((b1) & 0xF0) == 0x80)
#define IsJ(b0, b1) ((b1 & 0xFE) == 0xE8 || IsJcc(b0, b1))

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_READ_BYTE (*buffer++)
#define RC_TEST { if (buffer == bufferLim) return SZ_ERROR_DATA; }
#define RC_INIT2 code = 0; range = 0xFFFFFFFF; \
  { int i; for (i = 0; i < 5; i++) { RC_TEST; code = (code << 8) | RC_READ_BYTE; }}

#define NORMALIZE if (range < kTopValue) { RC_TEST; range <<= 8; code = (code << 8) | RC_READ_BYTE; }

#define IF_BIT_0(p) ttt = *(p); bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0(p) range = bound; *(p) = (CProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits)); NORMALIZE;
#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CProb)(ttt - (ttt >> kNumMoveBits)); NORMALIZE;

int Bcj2_Decode(
    const Byte *buf0, SizeT size0,
    const Byte *buf1, SizeT size1,
    const Byte *buf2, SizeT size2,
    const Byte *buf3, SizeT size3,
    Byte *outBuf, SizeT outSize)
{
  CProb p[256 + 2];
  SizeT inPos = 0, outPos = 0;

  const Byte *buffer, *bufferLim;
  UInt32 range, code;
  Byte prevByte = 0;

  unsigned int i;
  for (i = 0; i < sizeof(p) / sizeof(p[0]); i++)
    p[i] = kBitModelTotal >> 1;

  buffer = buf3;
  bufferLim = buffer + size3;
  RC_INIT2

  if (outSize == 0)
    return SZ_OK;

  for (;;)
  {
    Byte b;
    CProb *prob;
    UInt32 bound;
    UInt32 ttt;

    SizeT limit = size0 - inPos;
    if (outSize - outPos < limit)
      limit = outSize - outPos;
    while (limit != 0)
    {
      Byte b = buf0[inPos];
      outBuf[outPos++] = b;
      if (IsJ(prevByte, b))
        break;
      inPos++;
      prevByte = b;
      limit--;
    }

    if (limit == 0 || outPos == outSize)
      break;

    b = buf0[inPos++];

    if (b == 0xE8)
      prob = p + prevByte;
    else if (b == 0xE9)
      prob = p + 256;
    else
      prob = p + 257;

    IF_BIT_0(prob)
    {
      UPDATE_0(prob)
      prevByte = b;
    }
    else
    {
      UInt32 dest;
      const Byte *v;
      UPDATE_1(prob)
      if (b == 0xE8)
      {
        v = buf1;
        if (size1 < 4)
          return SZ_ERROR_DATA;
        buf1 += 4;
        size1 -= 4;
      }
      else
      {
        v = buf2;
        if (size2 < 4)
          return SZ_ERROR_DATA;
        buf2 += 4;
        size2 -= 4;
      }
      dest = (((UInt32)v[0] << 24) | ((UInt32)v[1] << 16) |
          ((UInt32)v[2] << 8) | ((UInt32)v[3])) - ((UInt32)outPos + 4);
      outBuf[outPos++] = (Byte)dest;
      if (outPos == outSize)
        break;
      outBuf[outPos++] = (Byte)(dest >> 8);
      if (outPos == outSize)
        break;
      outBuf[outPos++] = (Byte)(dest >> 16);
      if (outPos == outSize)
        break;
      outBuf[outPos++] = prevByte = (Byte)(dest >> 24);
    }
  }
  return (outPos == outSize) ? SZ_OK : SZ_ERROR_DATA;
}

```

`Fatpack/Compessor/lzma/pavlov/Bcj2.h`:

```h
/* Bcj2.h -- Converter for x86 code (BCJ2)
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __BCJ2_H
#define __BCJ2_H

#include "Types.h"

/*
Conditions:
  outSize <= FullOutputSize,
  where FullOutputSize is full size of output stream of x86_2 filter.

If buf0 overlaps outBuf, there are two required conditions:
  1) (buf0 >= outBuf)
  2) (buf0 + size0 >= outBuf + FullOutputSize).

Returns:
  SZ_OK
  SZ_ERROR_DATA - Data error
*/

int Bcj2_Decode(
    const Byte *buf0, SizeT size0,
    const Byte *buf1, SizeT size1,
    const Byte *buf2, SizeT size2,
    const Byte *buf3, SizeT size3,
    Byte *outBuf, SizeT outSize);

#endif

```

`Fatpack/Compessor/lzma/pavlov/Bra.c`:

```c
/* Bra.c -- Converters for RISC code
2008-10-04 : Igor Pavlov : Public domain */

#include "Bra.h"

SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
{
  SizeT i;
  if (size < 4)
    return 0;
  size -= 4;
  ip += 8;
  for (i = 0; i <= size; i += 4)
  {
    if (data[i + 3] == 0xEB)
    {
      UInt32 dest;
      UInt32 src = ((UInt32)data[i + 2] << 16) | ((UInt32)data[i + 1] << 8) | (data[i + 0]);
      src <<= 2;
      if (encoding)
        dest = ip + (UInt32)i + src;
      else
        dest = src - (ip + (UInt32)i);
      dest >>= 2;
      data[i + 2] = (Byte)(dest >> 16);
      data[i + 1] = (Byte)(dest >> 8);
      data[i + 0] = (Byte)dest;
    }
  }
  return i;
}

SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
{
  SizeT i;
  if (size < 4)
    return 0;
  size -= 4;
  ip += 4;
  for (i = 0; i <= size; i += 2)
  {
    if ((data[i + 1] & 0xF8) == 0xF0 &&
        (data[i + 3] & 0xF8) == 0xF8)
    {
      UInt32 dest;
      UInt32 src =
        (((UInt32)data[i + 1] & 0x7) << 19) |
        ((UInt32)data[i + 0] << 11) |
        (((UInt32)data[i + 3] & 0x7) << 8) |
        (data[i + 2]);
      
      src <<= 1;
      if (encoding)
        dest = ip + (UInt32)i + src;
      else
        dest = src - (ip + (UInt32)i);
      dest >>= 1;
      
      data[i + 1] = (Byte)(0xF0 | ((dest >> 19) & 0x7));
      data[i + 0] = (Byte)(dest >> 11);
      data[i + 3] = (Byte)(0xF8 | ((dest >> 8) & 0x7));
      data[i + 2] = (Byte)dest;
      i += 2;
    }
  }
  return i;
}

SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
{
  SizeT i;
  if (size < 4)
    return 0;
  size -= 4;
  for (i = 0; i <= size; i += 4)
  {
    if ((data[i] >> 2) == 0x12 && (data[i + 3] & 3) == 1)
    {
      UInt32 src = ((UInt32)(data[i + 0] & 3) << 24) |
        ((UInt32)data[i + 1] << 16) |
        ((UInt32)data[i + 2] << 8) |
        ((UInt32)data[i + 3] & (~3));
      
      UInt32 dest;
      if (encoding)
        dest = ip + (UInt32)i + src;
      else
        dest = src - (ip + (UInt32)i);
      data[i + 0] = (Byte)(0x48 | ((dest >> 24) &  0x3));
      data[i + 1] = (Byte)(dest >> 16);
      data[i + 2] = (Byte)(dest >> 8);
      data[i + 3] &= 0x3;
      data[i + 3] |= dest;
    }
  }
  return i;
}

SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
{
  UInt32 i;
  if (size < 4)
    return 0;
  size -= 4;
  for (i = 0; i <= size; i += 4)
  {
    if (data[i] == 0x40 && (data[i + 1] & 0xC0) == 0x00 ||
        data[i] == 0x7F && (data[i + 1] & 0xC0) == 0xC0)
    {
      UInt32 src =
        ((UInt32)data[i + 0] << 24) |
        ((UInt32)data[i + 1] << 16) |
        ((UInt32)data[i + 2] << 8) |
        ((UInt32)data[i + 3]);
      UInt32 dest;
      
      src <<= 2;
      if (encoding)
        dest = ip + i + src;
      else
        dest = src - (ip + i);
      dest >>= 2;
      
      dest = (((0 - ((dest >> 22) & 1)) << 22) & 0x3FFFFFFF) | (dest & 0x3FFFFF) | 0x40000000;

      data[i + 0] = (Byte)(dest >> 24);
      data[i + 1] = (Byte)(dest >> 16);
      data[i + 2] = (Byte)(dest >> 8);
      data[i + 3] = (Byte)dest;
    }
  }
  return i;
}

```

`Fatpack/Compessor/lzma/pavlov/Bra.h`:

```h
/* Bra.h -- Branch converters for executables
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __BRA_H
#define __BRA_H

#include "Types.h"

/*
These functions convert relative addresses to absolute addresses
in CALL instructions to increase the compression ratio.
  
  In:
    data     - data buffer
    size     - size of data
    ip       - current virtual Instruction Pinter (IP) value
    state    - state variable for x86 converter
    encoding - 0 (for decoding), 1 (for encoding)
  
  Out:
    state    - state variable for x86 converter

  Returns:
    The number of processed bytes. If you call these functions with multiple calls,
    you must start next call with first byte after block of processed bytes.
  
  Type   Endian  Alignment  LookAhead
  
  x86    little      1          4
  ARMT   little      2          2
  ARM    little      4          0
  PPC     big        4          0
  SPARC   big        4          0
  IA64   little     16          0

  size must be >= Alignment + LookAhead, if it's not last block.
  If (size < Alignment + LookAhead), converter returns 0.

  Example:

    UInt32 ip = 0;
    for ()
    {
      ; size must be >= Alignment + LookAhead, if it's not last block
      SizeT processed = Convert(data, size, ip, 1);
      data += processed;
      size -= processed;
      ip += processed;
    }
*/

#define x86_Convert_Init(state) { state = 0; }
SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding);
SizeT ARM_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT ARMT_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT PPC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT SPARC_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);
SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding);

#endif

```

`Fatpack/Compessor/lzma/pavlov/Bra86.c`:

```c
/* Bra86.c -- Converter for x86 code (BCJ)
2008-10-04 : Igor Pavlov : Public domain */

#include "Bra.h"

#define Test86MSByte(b) ((b) == 0 || (b) == 0xFF)

const Byte kMaskToAllowedStatus[8] = {1, 1, 1, 0, 1, 0, 0, 0};
const Byte kMaskToBitNumber[8] = {0, 1, 2, 2, 3, 3, 3, 3};

SizeT x86_Convert(Byte *data, SizeT size, UInt32 ip, UInt32 *state, int encoding)
{
  SizeT bufferPos = 0, prevPosT;
  UInt32 prevMask = *state & 0x7;
  if (size < 5)
    return 0;
  ip += 5;
  prevPosT = (SizeT)0 - 1;

  for (;;)
  {
    Byte *p = data + bufferPos;
    Byte *limit = data + size - 4;
    for (; p < limit; p++)
      if ((*p & 0xFE) == 0xE8)
        break;
    bufferPos = (SizeT)(p - data);
    if (p >= limit)
      break;
    prevPosT = bufferPos - prevPosT;
    if (prevPosT > 3)
      prevMask = 0;
    else
    {
      prevMask = (prevMask << ((int)prevPosT - 1)) & 0x7;
      if (prevMask != 0)
      {
        Byte b = p[4 - kMaskToBitNumber[prevMask]];
        if (!kMaskToAllowedStatus[prevMask] || Test86MSByte(b))
        {
          prevPosT = bufferPos;
          prevMask = ((prevMask << 1) & 0x7) | 1;
          bufferPos++;
          continue;
        }
      }
    }
    prevPosT = bufferPos;

    if (Test86MSByte(p[4]))
    {
      UInt32 src = ((UInt32)p[4] << 24) | ((UInt32)p[3] << 16) | ((UInt32)p[2] << 8) | ((UInt32)p[1]);
      UInt32 dest;
      for (;;)
      {
        Byte b;
        int index;
        if (encoding)
          dest = (ip + (UInt32)bufferPos) + src;
        else
          dest = src - (ip + (UInt32)bufferPos);
        if (prevMask == 0)
          break;
        index = kMaskToBitNumber[prevMask] * 8;
        b = (Byte)(dest >> (24 - index));
        if (!Test86MSByte(b))
          break;
        src = dest ^ ((1 << (32 - index)) - 1);
      }
      p[4] = (Byte)(~(((dest >> 24) & 1) - 1));
      p[3] = (Byte)(dest >> 16);
      p[2] = (Byte)(dest >> 8);
      p[1] = (Byte)dest;
      bufferPos += 5;
    }
    else
    {
      prevMask = ((prevMask << 1) & 0x7) | 1;
      bufferPos++;
    }
  }
  prevPosT = bufferPos - prevPosT;
  *state = ((prevPosT > 3) ? 0 : ((prevMask << ((int)prevPosT - 1)) & 0x7));
  return bufferPos;
}

```

`Fatpack/Compessor/lzma/pavlov/BraIA64.c`:

```c
/* BraIA64.c -- Converter for IA-64 code
2008-10-04 : Igor Pavlov : Public domain */

#include "Bra.h"

static const Byte kBranchTable[32] =
{
  0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0,
  4, 4, 6, 6, 0, 0, 7, 7,
  4, 4, 0, 0, 4, 4, 0, 0
};

SizeT IA64_Convert(Byte *data, SizeT size, UInt32 ip, int encoding)
{
  SizeT i;
  if (size < 16)
    return 0;
  size -= 16;
  for (i = 0; i <= size; i += 16)
  {
    UInt32 instrTemplate = data[i] & 0x1F;
    UInt32 mask = kBranchTable[instrTemplate];
    UInt32 bitPos = 5;
    int slot;
    for (slot = 0; slot < 3; slot++, bitPos += 41)
    {
      UInt32 bytePos, bitRes;
      UInt64 instruction, instNorm;
      int j;
      if (((mask >> slot) & 1) == 0)
        continue;
      bytePos = (bitPos >> 3);
      bitRes = bitPos & 0x7;
      instruction = 0;
      for (j = 0; j < 6; j++)
        instruction += (UInt64)data[i + j + bytePos] << (8 * j);

      instNorm = instruction >> bitRes;
      if (((instNorm >> 37) & 0xF) == 0x5 && ((instNorm >> 9) & 0x7) == 0)
      {
        UInt32 src = (UInt32)((instNorm >> 13) & 0xFFFFF);
        UInt32 dest;
        src |= ((UInt32)(instNorm >> 36) & 1) << 20;
        
        src <<= 4;
        
        if (encoding)
          dest = ip + (UInt32)i + src;
        else
          dest = src - (ip + (UInt32)i);
        
        dest >>= 4;
        
        instNorm &= ~((UInt64)(0x8FFFFF) << 13);
        instNorm |= ((UInt64)(dest & 0xFFFFF) << 13);
        instNorm |= ((UInt64)(dest & 0x100000) << (36 - 20));
        
        instruction &= (1 << bitRes) - 1;
        instruction |= (instNorm << bitRes);
        for (j = 0; j < 6; j++)
          data[i + j + bytePos] = (Byte)(instruction >> (8 * j));
      }
    }
  }
  return i;
}

```

`Fatpack/Compessor/lzma/pavlov/CpuArch.h`:

```h
/* CpuArch.h
2008-08-05
Igor Pavlov
Public domain */

#ifndef __CPUARCH_H
#define __CPUARCH_H

/*
LITTLE_ENDIAN_UNALIGN means:
  1) CPU is LITTLE_ENDIAN
  2) it's allowed to make unaligned memory accesses
if LITTLE_ENDIAN_UNALIGN is not defined, it means that we don't know
about these properties of platform.
*/

#if defined(_M_IX86) || defined(_M_X64) || defined(_M_AMD64) || defined(__i386__) || defined(__x86_64__)
#define LITTLE_ENDIAN_UNALIGN
#endif

#ifdef LITTLE_ENDIAN_UNALIGN

#define GetUi16(p) (*(const UInt16 *)(p))
#define GetUi32(p) (*(const UInt32 *)(p))
#define GetUi64(p) (*(const UInt64 *)(p))
#define SetUi32(p, d) *(UInt32 *)(p) = (d);

#else

#define GetUi16(p) (((const Byte *)(p))[0] | ((UInt16)((const Byte *)(p))[1] << 8))

#define GetUi32(p) ( \
             ((const Byte *)(p))[0]        | \
    ((UInt32)((const Byte *)(p))[1] <<  8) | \
    ((UInt32)((const Byte *)(p))[2] << 16) | \
    ((UInt32)((const Byte *)(p))[3] << 24))

#define GetUi64(p) (GetUi32(p) | ((UInt64)GetUi32(((const Byte *)(p)) + 4) << 32))

#define SetUi32(p, d) { UInt32 _x_ = (d); \
    ((Byte *)(p))[0] = (Byte)_x_; \
    ((Byte *)(p))[1] = (Byte)(_x_ >> 8); \
    ((Byte *)(p))[2] = (Byte)(_x_ >> 16); \
    ((Byte *)(p))[3] = (Byte)(_x_ >> 24); }

#endif

#if defined(LITTLE_ENDIAN_UNALIGN) && defined(_WIN64) && (_MSC_VER >= 1300)

#pragma intrinsic(_byteswap_ulong)
#pragma intrinsic(_byteswap_uint64)
#define GetBe32(p) _byteswap_ulong(*(const UInt32 *)(const Byte *)(p))
#define GetBe64(p) _byteswap_uint64(*(const UInt64 *)(const Byte *)(p))

#else

#define GetBe32(p) ( \
    ((UInt32)((const Byte *)(p))[0] << 24) | \
    ((UInt32)((const Byte *)(p))[1] << 16) | \
    ((UInt32)((const Byte *)(p))[2] <<  8) | \
             ((const Byte *)(p))[3] )

#define GetBe64(p) (((UInt64)GetBe32(p) << 32) | GetBe32(((const Byte *)(p)) + 4))

#endif

#define GetBe16(p) (((UInt16)((const Byte *)(p))[0] << 8) | ((const Byte *)(p))[1])

#endif

```

`Fatpack/Compessor/lzma/pavlov/LzFind.c`:

```c
/* LzFind.c -- Match finder for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */

#include "LzFind.h"
#include "LzHash.h"

#define kEmptyHashValue 0
#define kMaxValForNormalize ((UInt32)0xFFFFFFFF)
#define kNormalizeStepMin (1 << 10) /* it must be power of 2 */
#define kNormalizeMask (~(kNormalizeStepMin - 1))
#define kMaxHistorySize ((UInt32)3 << 30)

#define kStartMaxLen 3

static void LzInWindow_Free(CMatchFinder *p, ISzAlloc *alloc)
{
  if (!p->directInput)
  {
    alloc->Free(alloc, p->bufferBase);
    p->bufferBase = 0;
  }
}

/* keepSizeBefore + keepSizeAfter + keepSizeReserv must be < 4G) */

static int LzInWindow_Create(CMatchFinder *p, UInt32 keepSizeReserv, ISzAlloc *alloc)
{
  UInt32 blockSize = p->keepSizeBefore + p->keepSizeAfter + keepSizeReserv;
  if (p->directInput)
  {
    p->blockSize = blockSize;
    return 1;
  }
  if (p->bufferBase == 0 || p->blockSize != blockSize)
  {
    LzInWindow_Free(p, alloc);
    p->blockSize = blockSize;
    p->bufferBase = (Byte *)alloc->Alloc(alloc, (size_t)blockSize);
  }
  return (p->bufferBase != 0);
}

Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p) { return p->buffer; }
Byte MatchFinder_GetIndexByte(CMatchFinder *p, Int32 index) { return p->buffer[index]; }

UInt32 MatchFinder_GetNumAvailableBytes(CMatchFinder *p) { return p->streamPos - p->pos; }

void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue)
{
  p->posLimit -= subValue;
  p->pos -= subValue;
  p->streamPos -= subValue;
}

static void MatchFinder_ReadBlock(CMatchFinder *p)
{
  if (p->streamEndWasReached || p->result != SZ_OK)
    return;
  for (;;)
  {
    Byte *dest = p->buffer + (p->streamPos - p->pos);
    size_t size = (p->bufferBase + p->blockSize - dest);
    if (size == 0)
      return;
    p->result = p->stream->Read(p->stream, dest, &size);
    if (p->result != SZ_OK)
      return;
    if (size == 0)
    {
      p->streamEndWasReached = 1;
      return;
    }
    p->streamPos += (UInt32)size;
    if (p->streamPos - p->pos > p->keepSizeAfter)
      return;
  }
}

void MatchFinder_MoveBlock(CMatchFinder *p)
{
  memmove(p->bufferBase,
    p->buffer - p->keepSizeBefore,
    (size_t)(p->streamPos - p->pos + p->keepSizeBefore));
  p->buffer = p->bufferBase + p->keepSizeBefore;
}

int MatchFinder_NeedMove(CMatchFinder *p)
{
  /* if (p->streamEndWasReached) return 0; */
  return ((size_t)(p->bufferBase + p->blockSize - p->buffer) <= p->keepSizeAfter);
}

void MatchFinder_ReadIfRequired(CMatchFinder *p)
{
  if (p->streamEndWasReached)
    return;
  if (p->keepSizeAfter >= p->streamPos - p->pos)
    MatchFinder_ReadBlock(p);
}

static void MatchFinder_CheckAndMoveAndRead(CMatchFinder *p)
{
  if (MatchFinder_NeedMove(p))
    MatchFinder_MoveBlock(p);
  MatchFinder_ReadBlock(p);
}

static void MatchFinder_SetDefaultSettings(CMatchFinder *p)
{
  p->cutValue = 32;
  p->btMode = 1;
  p->numHashBytes = 4;
  /* p->skipModeBits = 0; */
  p->directInput = 0;
  p->bigHash = 0;
}

#define kCrcPoly 0xEDB88320

void MatchFinder_Construct(CMatchFinder *p)
{
  UInt32 i;
  p->bufferBase = 0;
  p->directInput = 0;
  p->hash = 0;
  MatchFinder_SetDefaultSettings(p);

  for (i = 0; i < 256; i++)
  {
    UInt32 r = i;
    int j;
    for (j = 0; j < 8; j++)
      r = (r >> 1) ^ (kCrcPoly & ~((r & 1) - 1));
    p->crc[i] = r;
  }
}

static void MatchFinder_FreeThisClassMemory(CMatchFinder *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->hash);
  p->hash = 0;
}

void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc)
{
  MatchFinder_FreeThisClassMemory(p, alloc);
  LzInWindow_Free(p, alloc);
}

static CLzRef* AllocRefs(UInt32 num, ISzAlloc *alloc)
{
  size_t sizeInBytes = (size_t)num * sizeof(CLzRef);
  if (sizeInBytes / sizeof(CLzRef) != num)
    return 0;
  return (CLzRef *)alloc->Alloc(alloc, sizeInBytes);
}

int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc)
{
  UInt32 sizeReserv;
  if (historySize > kMaxHistorySize)
  {
    MatchFinder_Free(p, alloc);
    return 0;
  }
  sizeReserv = historySize >> 1;
  if (historySize > ((UInt32)2 << 30))
    sizeReserv = historySize >> 2;
  sizeReserv += (keepAddBufferBefore + matchMaxLen + keepAddBufferAfter) / 2 + (1 << 19);

  p->keepSizeBefore = historySize + keepAddBufferBefore + 1;
  p->keepSizeAfter = matchMaxLen + keepAddBufferAfter;
  /* we need one additional byte, since we use MoveBlock after pos++ and before dictionary using */
  if (LzInWindow_Create(p, sizeReserv, alloc))
  {
    UInt32 newCyclicBufferSize = (historySize /* >> p->skipModeBits */) + 1;
    UInt32 hs;
    p->matchMaxLen = matchMaxLen;
    {
      p->fixedHashSize = 0;
      if (p->numHashBytes == 2)
        hs = (1 << 16) - 1;
      else
      {
        hs = historySize - 1;
        hs |= (hs >> 1);
        hs |= (hs >> 2);
        hs |= (hs >> 4);
        hs |= (hs >> 8);
        hs >>= 1;
        /* hs >>= p->skipModeBits; */
        hs |= 0xFFFF; /* don't change it! It's required for Deflate */
        if (hs > (1 << 24))
        {
          if (p->numHashBytes == 3)
            hs = (1 << 24) - 1;
          else
            hs >>= 1;
        }
      }
      p->hashMask = hs;
      hs++;
      if (p->numHashBytes > 2) p->fixedHashSize += kHash2Size;
      if (p->numHashBytes > 3) p->fixedHashSize += kHash3Size;
      if (p->numHashBytes > 4) p->fixedHashSize += kHash4Size;
      hs += p->fixedHashSize;
    }

    {
      UInt32 prevSize = p->hashSizeSum + p->numSons;
      UInt32 newSize;
      p->historySize = historySize;
      p->hashSizeSum = hs;
      p->cyclicBufferSize = newCyclicBufferSize;
      p->numSons = (p->btMode ? newCyclicBufferSize * 2 : newCyclicBufferSize);
      newSize = p->hashSizeSum + p->numSons;
      if (p->hash != 0 && prevSize == newSize)
        return 1;
      MatchFinder_FreeThisClassMemory(p, alloc);
      p->hash = AllocRefs(newSize, alloc);
      if (p->hash != 0)
      {
        p->son = p->hash + p->hashSizeSum;
        return 1;
      }
    }
  }
  MatchFinder_Free(p, alloc);
  return 0;
}

static void MatchFinder_SetLimits(CMatchFinder *p)
{
  UInt32 limit = kMaxValForNormalize - p->pos;
  UInt32 limit2 = p->cyclicBufferSize - p->cyclicBufferPos;
  if (limit2 < limit)
    limit = limit2;
  limit2 = p->streamPos - p->pos;
  if (limit2 <= p->keepSizeAfter)
  {
    if (limit2 > 0)
      limit2 = 1;
  }
  else
    limit2 -= p->keepSizeAfter;
  if (limit2 < limit)
    limit = limit2;
  {
    UInt32 lenLimit = p->streamPos - p->pos;
    if (lenLimit > p->matchMaxLen)
      lenLimit = p->matchMaxLen;
    p->lenLimit = lenLimit;
  }
  p->posLimit = p->pos + limit;
}

void MatchFinder_Init(CMatchFinder *p)
{
  UInt32 i;
  for (i = 0; i < p->hashSizeSum; i++)
    p->hash[i] = kEmptyHashValue;
  p->cyclicBufferPos = 0;
  p->buffer = p->bufferBase;
  p->pos = p->streamPos = p->cyclicBufferSize;
  p->result = SZ_OK;
  p->streamEndWasReached = 0;
  MatchFinder_ReadBlock(p);
  MatchFinder_SetLimits(p);
}

static UInt32 MatchFinder_GetSubValue(CMatchFinder *p)
{
  return (p->pos - p->historySize - 1) & kNormalizeMask;
}

void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems)
{
  UInt32 i;
  for (i = 0; i < numItems; i++)
  {
    UInt32 value = items[i];
    if (value <= subValue)
      value = kEmptyHashValue;
    else
      value -= subValue;
    items[i] = value;
  }
}

static void MatchFinder_Normalize(CMatchFinder *p)
{
  UInt32 subValue = MatchFinder_GetSubValue(p);
  MatchFinder_Normalize3(subValue, p->hash, p->hashSizeSum + p->numSons);
  MatchFinder_ReduceOffsets(p, subValue);
}

static void MatchFinder_CheckLimits(CMatchFinder *p)
{
  if (p->pos == kMaxValForNormalize)
    MatchFinder_Normalize(p);
  if (!p->streamEndWasReached && p->keepSizeAfter == p->streamPos - p->pos)
    MatchFinder_CheckAndMoveAndRead(p);
  if (p->cyclicBufferPos == p->cyclicBufferSize)
    p->cyclicBufferPos = 0;
  MatchFinder_SetLimits(p);
}

static UInt32 * Hc_GetMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
  son[_cyclicBufferPos] = curMatch;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
      return distances;
    {
      const Byte *pb = cur - delta;
      curMatch = son[_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)];
      if (pb[maxLen] == cur[maxLen] && *pb == *cur)
      {
        UInt32 len = 0;
        while (++len != lenLimit)
          if (pb[len] != cur[len])
            break;
        if (maxLen < len)
        {
          *distances++ = maxLen = len;
          *distances++ = delta - 1;
          if (len == lenLimit)
            return distances;
        }
      }
    }
  }
}

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue,
    UInt32 *distances, UInt32 maxLen)
{
  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
  UInt32 len0 = 0, len1 = 0;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
    {
      *ptr0 = *ptr1 = kEmptyHashValue;
      return distances;
    }
    {
      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
      const Byte *pb = cur - delta;
      UInt32 len = (len0 < len1 ? len0 : len1);
      if (pb[len] == cur[len])
      {
        if (++len != lenLimit && pb[len] == cur[len])
          while (++len != lenLimit)
            if (pb[len] != cur[len])
              break;
        if (maxLen < len)
        {
          *distances++ = maxLen = len;
          *distances++ = delta - 1;
          if (len == lenLimit)
          {
            *ptr1 = pair[0];
            *ptr0 = pair[1];
            return distances;
          }
        }
      }
      if (pb[len] < cur[len])
      {
        *ptr1 = curMatch;
        ptr1 = pair + 1;
        curMatch = *ptr1;
        len1 = len;
      }
      else
      {
        *ptr0 = curMatch;
        ptr0 = pair;
        curMatch = *ptr0;
        len0 = len;
      }
    }
  }
}

static void SkipMatchesSpec(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *cur, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 cutValue)
{
  CLzRef *ptr0 = son + (_cyclicBufferPos << 1) + 1;
  CLzRef *ptr1 = son + (_cyclicBufferPos << 1);
  UInt32 len0 = 0, len1 = 0;
  for (;;)
  {
    UInt32 delta = pos - curMatch;
    if (cutValue-- == 0 || delta >= _cyclicBufferSize)
    {
      *ptr0 = *ptr1 = kEmptyHashValue;
      return;
    }
    {
      CLzRef *pair = son + ((_cyclicBufferPos - delta + ((delta > _cyclicBufferPos) ? _cyclicBufferSize : 0)) << 1);
      const Byte *pb = cur - delta;
      UInt32 len = (len0 < len1 ? len0 : len1);
      if (pb[len] == cur[len])
      {
        while (++len != lenLimit)
          if (pb[len] != cur[len])
            break;
        {
          if (len == lenLimit)
          {
            *ptr1 = pair[0];
            *ptr0 = pair[1];
            return;
          }
        }
      }
      if (pb[len] < cur[len])
      {
        *ptr1 = curMatch;
        ptr1 = pair + 1;
        curMatch = *ptr1;
        len1 = len;
      }
      else
      {
        *ptr0 = curMatch;
        ptr0 = pair;
        curMatch = *ptr0;
        len0 = len;
      }
    }
  }
}

#define MOVE_POS \
  ++p->cyclicBufferPos; \
  p->buffer++; \
  if (++p->pos == p->posLimit) MatchFinder_CheckLimits(p);

#define MOVE_POS_RET MOVE_POS return offset;

static void MatchFinder_MovePos(CMatchFinder *p) { MOVE_POS; }

#define GET_MATCHES_HEADER2(minLen, ret_op) \
  UInt32 lenLimit; UInt32 hashValue; const Byte *cur; UInt32 curMatch; \
  lenLimit = p->lenLimit; { if (lenLimit < minLen) { MatchFinder_MovePos(p); ret_op; }} \
  cur = p->buffer;

#define GET_MATCHES_HEADER(minLen) GET_MATCHES_HEADER2(minLen, return 0)
#define SKIP_HEADER(minLen)        GET_MATCHES_HEADER2(minLen, continue)

#define MF_PARAMS(p) p->pos, p->buffer, p->son, p->cyclicBufferPos, p->cyclicBufferSize, p->cutValue

#define GET_MATCHES_FOOTER(offset, maxLen) \
  offset = (UInt32)(GetMatchesSpec1(lenLimit, curMatch, MF_PARAMS(p), \
  distances + offset, maxLen) - distances); MOVE_POS_RET;

#define SKIP_FOOTER \
  SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p)); MOVE_POS;

static UInt32 Bt2_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(2)
  HASH2_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = 0;
  GET_MATCHES_FOOTER(offset, 1)
}

UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(3)
  HASH_ZIP_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = 0;
  GET_MATCHES_FOOTER(offset, 2)
}

static UInt32 Bt3_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, delta2, maxLen, offset;
  GET_MATCHES_HEADER(3)

  HASH3_CALC;

  delta2 = p->pos - p->hash[hash2Value];
  curMatch = p->hash[kFix3HashSize + hashValue];
  
  p->hash[hash2Value] =
  p->hash[kFix3HashSize + hashValue] = p->pos;


  maxLen = 2;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[0] = maxLen;
    distances[1] = delta2 - 1;
    offset = 2;
    if (maxLen == lenLimit)
    {
      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
      MOVE_POS_RET;
    }
  }
  GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Bt4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
  GET_MATCHES_HEADER(4)

  HASH4_CALC;

  delta2 = p->pos - p->hash[                hash2Value];
  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
  curMatch = p->hash[kFix4HashSize + hashValue];
  
  p->hash[                hash2Value] =
  p->hash[kFix3HashSize + hash3Value] =
  p->hash[kFix4HashSize + hashValue] = p->pos;

  maxLen = 1;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    distances[0] = maxLen = 2;
    distances[1] = delta2 - 1;
    offset = 2;
  }
  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
  {
    maxLen = 3;
    distances[offset + 1] = delta3 - 1;
    offset += 2;
    delta2 = delta3;
  }
  if (offset != 0)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[offset - 2] = maxLen;
    if (maxLen == lenLimit)
    {
      SkipMatchesSpec(lenLimit, curMatch, MF_PARAMS(p));
      MOVE_POS_RET;
    }
  }
  if (maxLen < 3)
    maxLen = 3;
  GET_MATCHES_FOOTER(offset, maxLen)
}

static UInt32 Hc4_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 hash2Value, hash3Value, delta2, delta3, maxLen, offset;
  GET_MATCHES_HEADER(4)

  HASH4_CALC;

  delta2 = p->pos - p->hash[                hash2Value];
  delta3 = p->pos - p->hash[kFix3HashSize + hash3Value];
  curMatch = p->hash[kFix4HashSize + hashValue];

  p->hash[                hash2Value] =
  p->hash[kFix3HashSize + hash3Value] =
  p->hash[kFix4HashSize + hashValue] = p->pos;

  maxLen = 1;
  offset = 0;
  if (delta2 < p->cyclicBufferSize && *(cur - delta2) == *cur)
  {
    distances[0] = maxLen = 2;
    distances[1] = delta2 - 1;
    offset = 2;
  }
  if (delta2 != delta3 && delta3 < p->cyclicBufferSize && *(cur - delta3) == *cur)
  {
    maxLen = 3;
    distances[offset + 1] = delta3 - 1;
    offset += 2;
    delta2 = delta3;
  }
  if (offset != 0)
  {
    for (; maxLen != lenLimit; maxLen++)
      if (cur[(ptrdiff_t)maxLen - delta2] != cur[maxLen])
        break;
    distances[offset - 2] = maxLen;
    if (maxLen == lenLimit)
    {
      p->son[p->cyclicBufferPos] = curMatch;
      MOVE_POS_RET;
    }
  }
  if (maxLen < 3)
    maxLen = 3;
  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
    distances + offset, maxLen) - (distances));
  MOVE_POS_RET
}

UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances)
{
  UInt32 offset;
  GET_MATCHES_HEADER(3)
  HASH_ZIP_CALC;
  curMatch = p->hash[hashValue];
  p->hash[hashValue] = p->pos;
  offset = (UInt32)(Hc_GetMatchesSpec(lenLimit, curMatch, MF_PARAMS(p),
    distances, 2) - (distances));
  MOVE_POS_RET
}

static void Bt2_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(2)
    HASH2_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(3)
    HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Bt3_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value;
    SKIP_HEADER(3)
    HASH3_CALC;
    curMatch = p->hash[kFix3HashSize + hashValue];
    p->hash[hash2Value] =
    p->hash[kFix3HashSize + hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Bt4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value, hash3Value;
    SKIP_HEADER(4)
    HASH4_CALC;
    curMatch = p->hash[kFix4HashSize + hashValue];
    p->hash[                hash2Value] =
    p->hash[kFix3HashSize + hash3Value] = p->pos;
    p->hash[kFix4HashSize + hashValue] = p->pos;
    SKIP_FOOTER
  }
  while (--num != 0);
}

static void Hc4_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    UInt32 hash2Value, hash3Value;
    SKIP_HEADER(4)
    HASH4_CALC;
    curMatch = p->hash[kFix4HashSize + hashValue];
    p->hash[                hash2Value] =
    p->hash[kFix3HashSize + hash3Value] =
    p->hash[kFix4HashSize + hashValue] = p->pos;
    p->son[p->cyclicBufferPos] = curMatch;
    MOVE_POS
  }
  while (--num != 0);
}

void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num)
{
  do
  {
    SKIP_HEADER(3)
    HASH_ZIP_CALC;
    curMatch = p->hash[hashValue];
    p->hash[hashValue] = p->pos;
    p->son[p->cyclicBufferPos] = curMatch;
    MOVE_POS
  }
  while (--num != 0);
}

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable)
{
  vTable->Init = (Mf_Init_Func)MatchFinder_Init;
  vTable->GetIndexByte = (Mf_GetIndexByte_Func)MatchFinder_GetIndexByte;
  vTable->GetNumAvailableBytes = (Mf_GetNumAvailableBytes_Func)MatchFinder_GetNumAvailableBytes;
  vTable->GetPointerToCurrentPos = (Mf_GetPointerToCurrentPos_Func)MatchFinder_GetPointerToCurrentPos;
  if (!p->btMode)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Hc4_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Hc4_MatchFinder_Skip;
  }
  else if (p->numHashBytes == 2)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt2_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt2_MatchFinder_Skip;
  }
  else if (p->numHashBytes == 3)
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt3_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt3_MatchFinder_Skip;
  }
  else
  {
    vTable->GetMatches = (Mf_GetMatches_Func)Bt4_MatchFinder_GetMatches;
    vTable->Skip = (Mf_Skip_Func)Bt4_MatchFinder_Skip;
  }
}

```

`Fatpack/Compessor/lzma/pavlov/LzFind.h`:

```h
/* LzFind.h -- Match finder for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZFIND_H
#define __LZFIND_H

#include "Types.h"

typedef UInt32 CLzRef;

typedef struct _CMatchFinder
{
  Byte *buffer;
  UInt32 pos;
  UInt32 posLimit;
  UInt32 streamPos;
  UInt32 lenLimit;

  UInt32 cyclicBufferPos;
  UInt32 cyclicBufferSize; /* it must be = (historySize + 1) */

  UInt32 matchMaxLen;
  CLzRef *hash;
  CLzRef *son;
  UInt32 hashMask;
  UInt32 cutValue;

  Byte *bufferBase;
  ISeqInStream *stream;
  int streamEndWasReached;

  UInt32 blockSize;
  UInt32 keepSizeBefore;
  UInt32 keepSizeAfter;

  UInt32 numHashBytes;
  int directInput;
  int btMode;
  /* int skipModeBits; */
  int bigHash;
  UInt32 historySize;
  UInt32 fixedHashSize;
  UInt32 hashSizeSum;
  UInt32 numSons;
  SRes result;
  UInt32 crc[256];
} CMatchFinder;

#define Inline_MatchFinder_GetPointerToCurrentPos(p) ((p)->buffer)
#define Inline_MatchFinder_GetIndexByte(p, index) ((p)->buffer[(Int32)(index)])

#define Inline_MatchFinder_GetNumAvailableBytes(p) ((p)->streamPos - (p)->pos)

int MatchFinder_NeedMove(CMatchFinder *p);
Byte *MatchFinder_GetPointerToCurrentPos(CMatchFinder *p);
void MatchFinder_MoveBlock(CMatchFinder *p);
void MatchFinder_ReadIfRequired(CMatchFinder *p);

void MatchFinder_Construct(CMatchFinder *p);

/* Conditions:
     historySize <= 3 GB
     keepAddBufferBefore + matchMaxLen + keepAddBufferAfter < 511MB
*/
int MatchFinder_Create(CMatchFinder *p, UInt32 historySize,
    UInt32 keepAddBufferBefore, UInt32 matchMaxLen, UInt32 keepAddBufferAfter,
    ISzAlloc *alloc);
void MatchFinder_Free(CMatchFinder *p, ISzAlloc *alloc);
void MatchFinder_Normalize3(UInt32 subValue, CLzRef *items, UInt32 numItems);
void MatchFinder_ReduceOffsets(CMatchFinder *p, UInt32 subValue);

UInt32 * GetMatchesSpec1(UInt32 lenLimit, UInt32 curMatch, UInt32 pos, const Byte *buffer, CLzRef *son,
    UInt32 _cyclicBufferPos, UInt32 _cyclicBufferSize, UInt32 _cutValue,
    UInt32 *distances, UInt32 maxLen);

/*
Conditions:
  Mf_GetNumAvailableBytes_Func must be called before each Mf_GetMatchLen_Func.
  Mf_GetPointerToCurrentPos_Func's result must be used only before any other function
*/

typedef void (*Mf_Init_Func)(void *object);
typedef Byte (*Mf_GetIndexByte_Func)(void *object, Int32 index);
typedef UInt32 (*Mf_GetNumAvailableBytes_Func)(void *object);
typedef const Byte * (*Mf_GetPointerToCurrentPos_Func)(void *object);
typedef UInt32 (*Mf_GetMatches_Func)(void *object, UInt32 *distances);
typedef void (*Mf_Skip_Func)(void *object, UInt32);

typedef struct _IMatchFinder
{
  Mf_Init_Func Init;
  Mf_GetIndexByte_Func GetIndexByte;
  Mf_GetNumAvailableBytes_Func GetNumAvailableBytes;
  Mf_GetPointerToCurrentPos_Func GetPointerToCurrentPos;
  Mf_GetMatches_Func GetMatches;
  Mf_Skip_Func Skip;
} IMatchFinder;

void MatchFinder_CreateVTable(CMatchFinder *p, IMatchFinder *vTable);

void MatchFinder_Init(CMatchFinder *p);
UInt32 Bt3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
UInt32 Hc3Zip_MatchFinder_GetMatches(CMatchFinder *p, UInt32 *distances);
void Bt3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);
void Hc3Zip_MatchFinder_Skip(CMatchFinder *p, UInt32 num);

#endif

```

`Fatpack/Compessor/lzma/pavlov/LzHash.h`:

```h
/* LzHash.h -- HASH functions for LZ algorithms
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZHASH_H
#define __LZHASH_H

#define kHash2Size (1 << 10)
#define kHash3Size (1 << 16)
#define kHash4Size (1 << 20)

#define kFix3HashSize (kHash2Size)
#define kFix4HashSize (kHash2Size + kHash3Size)
#define kFix5HashSize (kHash2Size + kHash3Size + kHash4Size)

#define HASH2_CALC hashValue = cur[0] | ((UInt32)cur[1] << 8);

#define HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8)) & p->hashMask; }

#define HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hashValue = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & p->hashMask; }

#define HASH5_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)); \
  hashValue = (hash4Value ^ (p->crc[cur[4]] << 3)) & p->hashMask; \
  hash4Value &= (kHash4Size - 1); }

/* #define HASH_ZIP_CALC hashValue = ((cur[0] | ((UInt32)cur[1] << 8)) ^ p->crc[cur[2]]) & 0xFFFF; */
#define HASH_ZIP_CALC hashValue = ((cur[2] | ((UInt32)cur[0] << 8)) ^ p->crc[cur[1]]) & 0xFFFF;


#define MT_HASH2_CALC \
  hash2Value = (p->crc[cur[0]] ^ cur[1]) & (kHash2Size - 1);

#define MT_HASH3_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); }

#define MT_HASH4_CALC { \
  UInt32 temp = p->crc[cur[0]] ^ cur[1]; \
  hash2Value = temp & (kHash2Size - 1); \
  hash3Value = (temp ^ ((UInt32)cur[2] << 8)) & (kHash3Size - 1); \
  hash4Value = (temp ^ ((UInt32)cur[2] << 8) ^ (p->crc[cur[3]] << 5)) & (kHash4Size - 1); }

#endif

```

`Fatpack/Compessor/lzma/pavlov/LzmaDec.c`:

```c
/* LzmaDec.c -- LZMA Decoder
2008-11-06 : Igor Pavlov : Public domain */

#include "LzmaDec.h"

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5

#define RC_INIT_SIZE 5

#define NORMALIZE if (range < kTopValue) { range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0(p) ttt = *(p); NORMALIZE; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0(p) range = bound; *(p) = (CLzmaProb)(ttt + ((kBitModelTotal - ttt) >> kNumMoveBits));
#define UPDATE_1(p) range -= bound; code -= bound; *(p) = (CLzmaProb)(ttt - (ttt >> kNumMoveBits));
#define GET_BIT2(p, i, A0, A1) IF_BIT_0(p) \
  { UPDATE_0(p); i = (i + i); A0; } else \
  { UPDATE_1(p); i = (i + i) + 1; A1; }
#define GET_BIT(p, i) GET_BIT2(p, i, ; , ;)

#define TREE_GET_BIT(probs, i) { GET_BIT((probs + i), i); }
#define TREE_DECODE(probs, limit, i) \
  { i = 1; do { TREE_GET_BIT(probs, i); } while (i < limit); i -= limit; }

/* #define _LZMA_SIZE_OPT */

#ifdef _LZMA_SIZE_OPT
#define TREE_6_DECODE(probs, i) TREE_DECODE(probs, (1 << 6), i)
#else
#define TREE_6_DECODE(probs, i) \
  { i = 1; \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  TREE_GET_BIT(probs, i); \
  i -= 0x40; }
#endif

#define NORMALIZE_CHECK if (range < kTopValue) { if (buf >= bufLimit) return DUMMY_ERROR; range <<= 8; code = (code << 8) | (*buf++); }

#define IF_BIT_0_CHECK(p) ttt = *(p); NORMALIZE_CHECK; bound = (range >> kNumBitModelTotalBits) * ttt; if (code < bound)
#define UPDATE_0_CHECK range = bound;
#define UPDATE_1_CHECK range -= bound; code -= bound;
#define GET_BIT2_CHECK(p, i, A0, A1) IF_BIT_0_CHECK(p) \
  { UPDATE_0_CHECK; i = (i + i); A0; } else \
  { UPDATE_1_CHECK; i = (i + i) + 1; A1; }
#define GET_BIT_CHECK(p, i) GET_BIT2_CHECK(p, i, ; , ;)
#define TREE_DECODE_CHECK(probs, limit, i) \
  { i = 1; do { GET_BIT_CHECK(probs + i, i) } while (i < limit); i -= limit; }


#define kNumPosBitsMax 4
#define kNumPosStatesMax (1 << kNumPosBitsMax)

#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define LenChoice 0
#define LenChoice2 (LenChoice + 1)
#define LenLow (LenChoice2 + 1)
#define LenMid (LenLow + (kNumPosStatesMax << kLenNumLowBits))
#define LenHigh (LenMid + (kNumPosStatesMax << kLenNumMidBits))
#define kNumLenProbs (LenHigh + kLenNumHighSymbols)


#define kNumStates 12
#define kNumLitStates 7

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumFullDistances (1 << (kEndPosModelIndex >> 1))

#define kNumPosSlotBits 6
#define kNumLenToPosStates 4

#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)

#define kMatchMinLen 2
#define kMatchSpecLenStart (kMatchMinLen + kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define IsMatch 0
#define IsRep (IsMatch + (kNumStates << kNumPosBitsMax))
#define IsRepG0 (IsRep + kNumStates)
#define IsRepG1 (IsRepG0 + kNumStates)
#define IsRepG2 (IsRepG1 + kNumStates)
#define IsRep0Long (IsRepG2 + kNumStates)
#define PosSlot (IsRep0Long + (kNumStates << kNumPosBitsMax))
#define SpecPos (PosSlot + (kNumLenToPosStates << kNumPosSlotBits))
#define Align (SpecPos + kNumFullDistances - kEndPosModelIndex)
#define LenCoder (Align + kAlignTableSize)
#define RepLenCoder (LenCoder + kNumLenProbs)
#define Literal (RepLenCoder + kNumLenProbs)

#define LZMA_BASE_SIZE 1846
#define LZMA_LIT_SIZE 768

#define LzmaProps_GetNumProbs(p) ((UInt32)LZMA_BASE_SIZE + (LZMA_LIT_SIZE << ((p)->lc + (p)->lp)))

#if Literal != LZMA_BASE_SIZE
StopCompilingDueBUG
#endif

static const Byte kLiteralNextStates[kNumStates * 2] =
{
  0, 0, 0, 0, 1, 2, 3,  4,  5,  6,  4,  5,
  7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10
};

#define LZMA_DIC_MIN (1 << 12)

/* First LZMA-symbol is always decoded.
And it decodes new LZMA-symbols while (buf < bufLimit), but "buf" is without last normalization
Out:
  Result:
    SZ_OK - OK
    SZ_ERROR_DATA - Error
  p->remainLen:
    < kMatchSpecLenStart : normal remain
    = kMatchSpecLenStart : finished
    = kMatchSpecLenStart + 1 : Flush marker
    = kMatchSpecLenStart + 2 : State Init Marker
*/

static int MY_FAST_CALL LzmaDec_DecodeReal(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
  CLzmaProb *probs = p->probs;

  unsigned state = p->state;
  UInt32 rep0 = p->reps[0], rep1 = p->reps[1], rep2 = p->reps[2], rep3 = p->reps[3];
  unsigned pbMask = ((unsigned)1 << (p->prop.pb)) - 1;
  unsigned lpMask = ((unsigned)1 << (p->prop.lp)) - 1;
  unsigned lc = p->prop.lc;

  Byte *dic = p->dic;
  SizeT dicBufSize = p->dicBufSize;
  SizeT dicPos = p->dicPos;
  
  UInt32 processedPos = p->processedPos;
  UInt32 checkDicSize = p->checkDicSize;
  unsigned len = 0;

  const Byte *buf = p->buf;
  UInt32 range = p->range;
  UInt32 code = p->code;

  do
  {
    CLzmaProb *prob;
    UInt32 bound;
    unsigned ttt;
    unsigned posState = processedPos & pbMask;

    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
    IF_BIT_0(prob)
    {
      unsigned symbol;
      UPDATE_0(prob);
      prob = probs + Literal;
      if (checkDicSize != 0 || processedPos != 0)
        prob += (LZMA_LIT_SIZE * (((processedPos & lpMask) << lc) +
        (dic[(dicPos == 0 ? dicBufSize : dicPos) - 1] >> (8 - lc))));

      if (state < kNumLitStates)
      {
        symbol = 1;
        do { GET_BIT(prob + symbol, symbol) } while (symbol < 0x100);
      }
      else
      {
        unsigned matchByte = p->dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
        unsigned offs = 0x100;
        symbol = 1;
        do
        {
          unsigned bit;
          CLzmaProb *probLit;
          matchByte <<= 1;
          bit = (matchByte & offs);
          probLit = prob + offs + bit + symbol;
          GET_BIT2(probLit, symbol, offs &= ~bit, offs &= bit)
        }
        while (symbol < 0x100);
      }
      dic[dicPos++] = (Byte)symbol;
      processedPos++;

      state = kLiteralNextStates[state];
      /* if (state < 4) state = 0; else if (state < 10) state -= 3; else state -= 6; */
      continue;
    }
    else
    {
      UPDATE_1(prob);
      prob = probs + IsRep + state;
      IF_BIT_0(prob)
      {
        UPDATE_0(prob);
        state += kNumStates;
        prob = probs + LenCoder;
      }
      else
      {
        UPDATE_1(prob);
        if (checkDicSize == 0 && processedPos == 0)
          return SZ_ERROR_DATA;
        prob = probs + IsRepG0 + state;
        IF_BIT_0(prob)
        {
          UPDATE_0(prob);
          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
          IF_BIT_0(prob)
          {
            UPDATE_0(prob);
            dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
            dicPos++;
            processedPos++;
            state = state < kNumLitStates ? 9 : 11;
            continue;
          }
          UPDATE_1(prob);
        }
        else
        {
          UInt32 distance;
          UPDATE_1(prob);
          prob = probs + IsRepG1 + state;
          IF_BIT_0(prob)
          {
            UPDATE_0(prob);
            distance = rep1;
          }
          else
          {
            UPDATE_1(prob);
            prob = probs + IsRepG2 + state;
            IF_BIT_0(prob)
            {
              UPDATE_0(prob);
              distance = rep2;
            }
            else
            {
              UPDATE_1(prob);
              distance = rep3;
              rep3 = rep2;
            }
            rep2 = rep1;
          }
          rep1 = rep0;
          rep0 = distance;
        }
        state = state < kNumLitStates ? 8 : 11;
        prob = probs + RepLenCoder;
      }
      {
        unsigned limit, offset;
        CLzmaProb *probLen = prob + LenChoice;
        IF_BIT_0(probLen)
        {
          UPDATE_0(probLen);
          probLen = prob + LenLow + (posState << kLenNumLowBits);
          offset = 0;
          limit = (1 << kLenNumLowBits);
        }
        else
        {
          UPDATE_1(probLen);
          probLen = prob + LenChoice2;
          IF_BIT_0(probLen)
          {
            UPDATE_0(probLen);
            probLen = prob + LenMid + (posState << kLenNumMidBits);
            offset = kLenNumLowSymbols;
            limit = (1 << kLenNumMidBits);
          }
          else
          {
            UPDATE_1(probLen);
            probLen = prob + LenHigh;
            offset = kLenNumLowSymbols + kLenNumMidSymbols;
            limit = (1 << kLenNumHighBits);
          }
        }
        TREE_DECODE(probLen, limit, len);
        len += offset;
      }

      if (state >= kNumStates)
      {
        UInt32 distance;
        prob = probs + PosSlot +
            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) << kNumPosSlotBits);
        TREE_6_DECODE(prob, distance);
        if (distance >= kStartPosModelIndex)
        {
          unsigned posSlot = (unsigned)distance;
          int numDirectBits = (int)(((distance >> 1) - 1));
          distance = (2 | (distance & 1));
          if (posSlot < kEndPosModelIndex)
          {
            distance <<= numDirectBits;
            prob = probs + SpecPos + distance - posSlot - 1;
            {
              UInt32 mask = 1;
              unsigned i = 1;
              do
              {
                GET_BIT2(prob + i, i, ; , distance |= mask);
                mask <<= 1;
              }
              while (--numDirectBits != 0);
            }
          }
          else
          {
            numDirectBits -= kNumAlignBits;
            do
            {
              NORMALIZE
              range >>= 1;
              
              {
                UInt32 t;
                code -= range;
                t = (0 - ((UInt32)code >> 31)); /* (UInt32)((Int32)code >> 31) */
                distance = (distance << 1) + (t + 1);
                code += range & t;
              }
              /*
              distance <<= 1;
              if (code >= range)
              {
                code -= range;
                distance |= 1;
              }
              */
            }
            while (--numDirectBits != 0);
            prob = probs + Align;
            distance <<= kNumAlignBits;
            {
              unsigned i = 1;
              GET_BIT2(prob + i, i, ; , distance |= 1);
              GET_BIT2(prob + i, i, ; , distance |= 2);
              GET_BIT2(prob + i, i, ; , distance |= 4);
              GET_BIT2(prob + i, i, ; , distance |= 8);
            }
            if (distance == (UInt32)0xFFFFFFFF)
            {
              len += kMatchSpecLenStart;
              state -= kNumStates;
              break;
            }
          }
        }
        rep3 = rep2;
        rep2 = rep1;
        rep1 = rep0;
        rep0 = distance + 1;
        if (checkDicSize == 0)
        {
          if (distance >= processedPos)
            return SZ_ERROR_DATA;
        }
        else if (distance >= checkDicSize)
          return SZ_ERROR_DATA;
        state = (state < kNumStates + kNumLitStates) ? kNumLitStates : kNumLitStates + 3;
        /* state = kLiteralNextStates[state]; */
      }

      len += kMatchMinLen;

      if (limit == dicPos)
        return SZ_ERROR_DATA;
      {
        SizeT rem = limit - dicPos;
        unsigned curLen = ((rem < len) ? (unsigned)rem : len);
        SizeT pos = (dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0);

        processedPos += curLen;

        len -= curLen;
        if (pos + curLen <= dicBufSize)
        {
          Byte *dest = dic + dicPos;
          ptrdiff_t src = (ptrdiff_t)pos - (ptrdiff_t)dicPos;
          const Byte *lim = dest + curLen;
          dicPos += curLen;
          do
            *(dest) = (Byte)*(dest + src);
          while (++dest != lim);
        }
        else
        {
          do
          {
            dic[dicPos++] = dic[pos];
            if (++pos == dicBufSize)
              pos = 0;
          }
          while (--curLen != 0);
        }
      }
    }
  }
  while (dicPos < limit && buf < bufLimit);
  NORMALIZE;
  p->buf = buf;
  p->range = range;
  p->code = code;
  p->remainLen = len;
  p->dicPos = dicPos;
  p->processedPos = processedPos;
  p->reps[0] = rep0;
  p->reps[1] = rep1;
  p->reps[2] = rep2;
  p->reps[3] = rep3;
  p->state = state;

  return SZ_OK;
}

static void MY_FAST_CALL LzmaDec_WriteRem(CLzmaDec *p, SizeT limit)
{
  if (p->remainLen != 0 && p->remainLen < kMatchSpecLenStart)
  {
    Byte *dic = p->dic;
    SizeT dicPos = p->dicPos;
    SizeT dicBufSize = p->dicBufSize;
    unsigned len = p->remainLen;
    UInt32 rep0 = p->reps[0];
    if (limit - dicPos < len)
      len = (unsigned)(limit - dicPos);

    if (p->checkDicSize == 0 && p->prop.dicSize - p->processedPos <= len)
      p->checkDicSize = p->prop.dicSize;

    p->processedPos += len;
    p->remainLen -= len;
    while (len-- != 0)
    {
      dic[dicPos] = dic[(dicPos - rep0) + ((dicPos < rep0) ? dicBufSize : 0)];
      dicPos++;
    }
    p->dicPos = dicPos;
  }
}

static int MY_FAST_CALL LzmaDec_DecodeReal2(CLzmaDec *p, SizeT limit, const Byte *bufLimit)
{
  do
  {
    SizeT limit2 = limit;
    if (p->checkDicSize == 0)
    {
      UInt32 rem = p->prop.dicSize - p->processedPos;
      if (limit - p->dicPos > rem)
        limit2 = p->dicPos + rem;
    }
    RINOK(LzmaDec_DecodeReal(p, limit2, bufLimit));
    if (p->processedPos >= p->prop.dicSize)
      p->checkDicSize = p->prop.dicSize;
    LzmaDec_WriteRem(p, limit);
  }
  while (p->dicPos < limit && p->buf < bufLimit && p->remainLen < kMatchSpecLenStart);

  if (p->remainLen > kMatchSpecLenStart)
  {
    p->remainLen = kMatchSpecLenStart;
  }
  return 0;
}

typedef enum
{
  DUMMY_ERROR, /* unexpected end of input stream */
  DUMMY_LIT,
  DUMMY_MATCH,
  DUMMY_REP
} ELzmaDummy;

static ELzmaDummy LzmaDec_TryDummy(const CLzmaDec *p, const Byte *buf, SizeT inSize)
{
  UInt32 range = p->range;
  UInt32 code = p->code;
  const Byte *bufLimit = buf + inSize;
  CLzmaProb *probs = p->probs;
  unsigned state = p->state;
  ELzmaDummy res;

  {
    CLzmaProb *prob;
    UInt32 bound;
    unsigned ttt;
    unsigned posState = (p->processedPos) & ((1 << p->prop.pb) - 1);

    prob = probs + IsMatch + (state << kNumPosBitsMax) + posState;
    IF_BIT_0_CHECK(prob)
    {
      UPDATE_0_CHECK

      /* if (bufLimit - buf >= 7) return DUMMY_LIT; */

      prob = probs + Literal;
      if (p->checkDicSize != 0 || p->processedPos != 0)
        prob += (LZMA_LIT_SIZE *
          ((((p->processedPos) & ((1 << (p->prop.lp)) - 1)) << p->prop.lc) +
          (p->dic[(p->dicPos == 0 ? p->dicBufSize : p->dicPos) - 1] >> (8 - p->prop.lc))));

      if (state < kNumLitStates)
      {
        unsigned symbol = 1;
        do { GET_BIT_CHECK(prob + symbol, symbol) } while (symbol < 0x100);
      }
      else
      {
        unsigned matchByte = p->dic[p->dicPos - p->reps[0] +
            ((p->dicPos < p->reps[0]) ? p->dicBufSize : 0)];
        unsigned offs = 0x100;
        unsigned symbol = 1;
        do
        {
          unsigned bit;
          CLzmaProb *probLit;
          matchByte <<= 1;
          bit = (matchByte & offs);
          probLit = prob + offs + bit + symbol;
          GET_BIT2_CHECK(probLit, symbol, offs &= ~bit, offs &= bit)
        }
        while (symbol < 0x100);
      }
      res = DUMMY_LIT;
    }
    else
    {
      unsigned len;
      UPDATE_1_CHECK;

      prob = probs + IsRep + state;
      IF_BIT_0_CHECK(prob)
      {
        UPDATE_0_CHECK;
        state = 0;
        prob = probs + LenCoder;
        res = DUMMY_MATCH;
      }
      else
      {
        UPDATE_1_CHECK;
        res = DUMMY_REP;
        prob = probs + IsRepG0 + state;
        IF_BIT_0_CHECK(prob)
        {
          UPDATE_0_CHECK;
          prob = probs + IsRep0Long + (state << kNumPosBitsMax) + posState;
          IF_BIT_0_CHECK(prob)
          {
            UPDATE_0_CHECK;
            NORMALIZE_CHECK;
            return DUMMY_REP;
          }
          else
          {
            UPDATE_1_CHECK;
          }
        }
        else
        {
          UPDATE_1_CHECK;
          prob = probs + IsRepG1 + state;
          IF_BIT_0_CHECK(prob)
          {
            UPDATE_0_CHECK;
          }
          else
          {
            UPDATE_1_CHECK;
            prob = probs + IsRepG2 + state;
            IF_BIT_0_CHECK(prob)
            {
              UPDATE_0_CHECK;
            }
            else
            {
              UPDATE_1_CHECK;
            }
          }
        }
        state = kNumStates;
        prob = probs + RepLenCoder;
      }
      {
        unsigned limit, offset;
        CLzmaProb *probLen = prob + LenChoice;
        IF_BIT_0_CHECK(probLen)
        {
          UPDATE_0_CHECK;
          probLen = prob + LenLow + (posState << kLenNumLowBits);
          offset = 0;
          limit = 1 << kLenNumLowBits;
        }
        else
        {
          UPDATE_1_CHECK;
          probLen = prob + LenChoice2;
          IF_BIT_0_CHECK(probLen)
          {
            UPDATE_0_CHECK;
            probLen = prob + LenMid + (posState << kLenNumMidBits);
            offset = kLenNumLowSymbols;
            limit = 1 << kLenNumMidBits;
          }
          else
          {
            UPDATE_1_CHECK;
            probLen = prob + LenHigh;
            offset = kLenNumLowSymbols + kLenNumMidSymbols;
            limit = 1 << kLenNumHighBits;
          }
        }
        TREE_DECODE_CHECK(probLen, limit, len);
        len += offset;
      }

      if (state < 4)
      {
        unsigned posSlot;
        prob = probs + PosSlot +
            ((len < kNumLenToPosStates ? len : kNumLenToPosStates - 1) <<
            kNumPosSlotBits);
        TREE_DECODE_CHECK(prob, 1 << kNumPosSlotBits, posSlot);
        if (posSlot >= kStartPosModelIndex)
        {
          int numDirectBits = ((posSlot >> 1) - 1);

          /* if (bufLimit - buf >= 8) return DUMMY_MATCH; */

          if (posSlot < kEndPosModelIndex)
          {
            prob = probs + SpecPos + ((2 | (posSlot & 1)) << numDirectBits) - posSlot - 1;
          }
          else
          {
            numDirectBits -= kNumAlignBits;
            do
            {
              NORMALIZE_CHECK
              range >>= 1;
              code -= range & (((code - range) >> 31) - 1);
              /* if (code >= range) code -= range; */
            }
            while (--numDirectBits != 0);
            prob = probs + Align;
            numDirectBits = kNumAlignBits;
          }
          {
            unsigned i = 1;
            do
            {
              GET_BIT_CHECK(prob + i, i);
            }
            while (--numDirectBits != 0);
          }
        }
      }
    }
  }
  NORMALIZE_CHECK;
  return res;
}


static void LzmaDec_InitRc(CLzmaDec *p, const Byte *data)
{
  p->code = ((UInt32)data[1] << 24) | ((UInt32)data[2] << 16) | ((UInt32)data[3] << 8) | ((UInt32)data[4]);
  p->range = 0xFFFFFFFF;
  p->needFlush = 0;
}

void LzmaDec_InitDicAndState(CLzmaDec *p, Bool initDic, Bool initState)
{
  p->needFlush = 1;
  p->remainLen = 0;
  p->tempBufSize = 0;

  if (initDic)
  {
    p->processedPos = 0;
    p->checkDicSize = 0;
    p->needInitState = 1;
  }
  if (initState)
    p->needInitState = 1;
}

void LzmaDec_Init(CLzmaDec *p)
{
  p->dicPos = 0;
  LzmaDec_InitDicAndState(p, True, True);
}

static void LzmaDec_InitStateReal(CLzmaDec *p)
{
  UInt32 numProbs = Literal + ((UInt32)LZMA_LIT_SIZE << (p->prop.lc + p->prop.lp));
  UInt32 i;
  CLzmaProb *probs = p->probs;
  for (i = 0; i < numProbs; i++)
    probs[i] = kBitModelTotal >> 1;
  p->reps[0] = p->reps[1] = p->reps[2] = p->reps[3] = 1;
  p->state = 0;
  p->needInitState = 0;
}

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit, const Byte *src, SizeT *srcLen,
    ELzmaFinishMode finishMode, ELzmaStatus *status)
{
  SizeT inSize = *srcLen;
  (*srcLen) = 0;
  LzmaDec_WriteRem(p, dicLimit);
  
  *status = LZMA_STATUS_NOT_SPECIFIED;

  while (p->remainLen != kMatchSpecLenStart)
  {
      int checkEndMarkNow;

      if (p->needFlush != 0)
      {
        for (; inSize > 0 && p->tempBufSize < RC_INIT_SIZE; (*srcLen)++, inSize--)
          p->tempBuf[p->tempBufSize++] = *src++;
        if (p->tempBufSize < RC_INIT_SIZE)
        {
          *status = LZMA_STATUS_NEEDS_MORE_INPUT;
          return SZ_OK;
        }
        if (p->tempBuf[0] != 0)
          return SZ_ERROR_DATA;

        LzmaDec_InitRc(p, p->tempBuf);
        p->tempBufSize = 0;
      }

      checkEndMarkNow = 0;
      if (p->dicPos >= dicLimit)
      {
        if (p->remainLen == 0 && p->code == 0)
        {
          *status = LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK;
          return SZ_OK;
        }
        if (finishMode == LZMA_FINISH_ANY)
        {
          *status = LZMA_STATUS_NOT_FINISHED;
          return SZ_OK;
        }
        if (p->remainLen != 0)
        {
          *status = LZMA_STATUS_NOT_FINISHED;
          return SZ_ERROR_DATA;
        }
        checkEndMarkNow = 1;
      }

      if (p->needInitState)
        LzmaDec_InitStateReal(p);
  
      if (p->tempBufSize == 0)
      {
        SizeT processed;
        const Byte *bufLimit;
        if (inSize < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
        {
          int dummyRes = LzmaDec_TryDummy(p, src, inSize);
          if (dummyRes == DUMMY_ERROR)
          {
            memcpy(p->tempBuf, src, inSize);
            p->tempBufSize = (unsigned)inSize;
            (*srcLen) += inSize;
            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
            return SZ_OK;
          }
          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
          {
            *status = LZMA_STATUS_NOT_FINISHED;
            return SZ_ERROR_DATA;
          }
          bufLimit = src;
        }
        else
          bufLimit = src + inSize - LZMA_REQUIRED_INPUT_MAX;
        p->buf = src;
        if (LzmaDec_DecodeReal2(p, dicLimit, bufLimit) != 0)
          return SZ_ERROR_DATA;
        processed = (SizeT)(p->buf - src);
        (*srcLen) += processed;
        src += processed;
        inSize -= processed;
      }
      else
      {
        unsigned rem = p->tempBufSize, lookAhead = 0;
        while (rem < LZMA_REQUIRED_INPUT_MAX && lookAhead < inSize)
          p->tempBuf[rem++] = src[lookAhead++];
        p->tempBufSize = rem;
        if (rem < LZMA_REQUIRED_INPUT_MAX || checkEndMarkNow)
        {
          int dummyRes = LzmaDec_TryDummy(p, p->tempBuf, rem);
          if (dummyRes == DUMMY_ERROR)
          {
            (*srcLen) += lookAhead;
            *status = LZMA_STATUS_NEEDS_MORE_INPUT;
            return SZ_OK;
          }
          if (checkEndMarkNow && dummyRes != DUMMY_MATCH)
          {
            *status = LZMA_STATUS_NOT_FINISHED;
            return SZ_ERROR_DATA;
          }
        }
        p->buf = p->tempBuf;
        if (LzmaDec_DecodeReal2(p, dicLimit, p->buf) != 0)
          return SZ_ERROR_DATA;
        lookAhead -= (rem - (unsigned)(p->buf - p->tempBuf));
        (*srcLen) += lookAhead;
        src += lookAhead;
        inSize -= lookAhead;
        p->tempBufSize = 0;
      }
  }
  if (p->code == 0)
    *status = LZMA_STATUS_FINISHED_WITH_MARK;
  return (p->code == 0) ? SZ_OK : SZ_ERROR_DATA;
}

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status)
{
  SizeT outSize = *destLen;
  SizeT inSize = *srcLen;
  *srcLen = *destLen = 0;
  for (;;)
  {
    SizeT inSizeCur = inSize, outSizeCur, dicPos;
    ELzmaFinishMode curFinishMode;
    SRes res;
    if (p->dicPos == p->dicBufSize)
      p->dicPos = 0;
    dicPos = p->dicPos;
    if (outSize > p->dicBufSize - dicPos)
    {
      outSizeCur = p->dicBufSize;
      curFinishMode = LZMA_FINISH_ANY;
    }
    else
    {
      outSizeCur = dicPos + outSize;
      curFinishMode = finishMode;
    }

    res = LzmaDec_DecodeToDic(p, outSizeCur, src, &inSizeCur, curFinishMode, status);
    src += inSizeCur;
    inSize -= inSizeCur;
    *srcLen += inSizeCur;
    outSizeCur = p->dicPos - dicPos;
    memcpy(dest, p->dic + dicPos, outSizeCur);
    dest += outSizeCur;
    outSize -= outSizeCur;
    *destLen += outSizeCur;
    if (res != 0)
      return res;
    if (outSizeCur == 0 || outSize == 0)
      return SZ_OK;
  }
}

void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->probs);
  p->probs = 0;
}

static void LzmaDec_FreeDict(CLzmaDec *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->dic);
  p->dic = 0;
}

void LzmaDec_Free(CLzmaDec *p, ISzAlloc *alloc)
{
  LzmaDec_FreeProbs(p, alloc);
  LzmaDec_FreeDict(p, alloc);
}

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size)
{
  UInt32 dicSize;
  Byte d;
  
  if (size < LZMA_PROPS_SIZE)
    return SZ_ERROR_UNSUPPORTED;
  else
    dicSize = data[1] | ((UInt32)data[2] << 8) | ((UInt32)data[3] << 16) | ((UInt32)data[4] << 24);
 
  if (dicSize < LZMA_DIC_MIN)
    dicSize = LZMA_DIC_MIN;
  p->dicSize = dicSize;

  d = data[0];
  if (d >= (9 * 5 * 5))
    return SZ_ERROR_UNSUPPORTED;

  p->lc = d % 9;
  d /= 9;
  p->pb = d / 5;
  p->lp = d % 5;

  return SZ_OK;
}

static SRes LzmaDec_AllocateProbs2(CLzmaDec *p, const CLzmaProps *propNew, ISzAlloc *alloc)
{
  UInt32 numProbs = LzmaProps_GetNumProbs(propNew);
  if (p->probs == 0 || numProbs != p->numProbs)
  {
    LzmaDec_FreeProbs(p, alloc);
    p->probs = (CLzmaProb *)alloc->Alloc(alloc, numProbs * sizeof(CLzmaProb));
    p->numProbs = numProbs;
    if (p->probs == 0)
      return SZ_ERROR_MEM;
  }
  return SZ_OK;
}

SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
  CLzmaProps propNew;
  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
  p->prop = propNew;
  return SZ_OK;
}

SRes LzmaDec_Allocate(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc)
{
  CLzmaProps propNew;
  SizeT dicBufSize;
  RINOK(LzmaProps_Decode(&propNew, props, propsSize));
  RINOK(LzmaDec_AllocateProbs2(p, &propNew, alloc));
  dicBufSize = propNew.dicSize;
  if (p->dic == 0 || dicBufSize != p->dicBufSize)
  {
    LzmaDec_FreeDict(p, alloc);
    p->dic = (Byte *)alloc->Alloc(alloc, dicBufSize);
    if (p->dic == 0)
    {
      LzmaDec_FreeProbs(p, alloc);
      return SZ_ERROR_MEM;
    }
  }
  p->dicBufSize = dicBufSize;
  p->prop = propNew;
  return SZ_OK;
}

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc)
{
  CLzmaDec p;
  SRes res;
  SizeT inSize = *srcLen;
  SizeT outSize = *destLen;
  *srcLen = *destLen = 0;
  if (inSize < RC_INIT_SIZE)
    return SZ_ERROR_INPUT_EOF;

  LzmaDec_Construct(&p);
  res = LzmaDec_AllocateProbs(&p, propData, propSize, alloc);
  if (res != 0)
    return res;
  p.dic = dest;
  p.dicBufSize = outSize;

  LzmaDec_Init(&p);
  
  *srcLen = inSize;
  res = LzmaDec_DecodeToDic(&p, outSize, src, srcLen, finishMode, status);

  if (res == SZ_OK && *status == LZMA_STATUS_NEEDS_MORE_INPUT)
    res = SZ_ERROR_INPUT_EOF;

  (*destLen) = p.dicPos;
  LzmaDec_FreeProbs(&p, alloc);
  return res;
}

```

`Fatpack/Compessor/lzma/pavlov/LzmaDec.h`:

```h
/* LzmaDec.h -- LZMA Decoder
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZMADEC_H
#define __LZMADEC_H

#include "Types.h"

/* #define _LZMA_PROB32 */
/* _LZMA_PROB32 can increase the speed on some CPUs,
   but memory usage for CLzmaDec::probs will be doubled in that case */

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif


/* ---------- LZMA Properties ---------- */

#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaProps
{
  unsigned lc, lp, pb;
  UInt32 dicSize;
} CLzmaProps;

/* LzmaProps_Decode - decodes properties
Returns:
  SZ_OK
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/

SRes LzmaProps_Decode(CLzmaProps *p, const Byte *data, unsigned size);


/* ---------- LZMA Decoder state ---------- */

/* LZMA_REQUIRED_INPUT_MAX = number of required input bytes for worst case.
   Num bits = log2((2^11 / 31) ^ 22) + 26 < 134 + 26 = 160; */

#define LZMA_REQUIRED_INPUT_MAX 20

typedef struct
{
  CLzmaProps prop;
  CLzmaProb *probs;
  Byte *dic;
  const Byte *buf;
  UInt32 range, code;
  SizeT dicPos;
  SizeT dicBufSize;
  UInt32 processedPos;
  UInt32 checkDicSize;
  unsigned state;
  UInt32 reps[4];
  unsigned remainLen;
  int needFlush;
  int needInitState;
  UInt32 numProbs;
  unsigned tempBufSize;
  Byte tempBuf[LZMA_REQUIRED_INPUT_MAX];
} CLzmaDec;

#define LzmaDec_Construct(p) { (p)->dic = 0; (p)->probs = 0; }

void LzmaDec_Init(CLzmaDec *p);

/* There are two types of LZMA streams:
     0) Stream with end mark. That end mark adds about 6 bytes to compressed size.
     1) Stream without end mark. You must know exact uncompressed size to decompress such stream. */

typedef enum
{
  LZMA_FINISH_ANY,   /* finish at any point */
  LZMA_FINISH_END    /* block must be finished at the end */
} ELzmaFinishMode;

/* ELzmaFinishMode has meaning only if the decoding reaches output limit !!!

   You must use LZMA_FINISH_END, when you know that current output buffer
   covers last bytes of block. In other cases you must use LZMA_FINISH_ANY.

   If LZMA decoder sees end marker before reaching output limit, it returns SZ_OK,
   and output value of destLen will be less than output buffer size limit.
   You can check status result also.

   You can use multiple checks to test data integrity after full decompression:
     1) Check Result and "status" variable.
     2) Check that output(destLen) = uncompressedSize, if you know real uncompressedSize.
     3) Check that output(srcLen) = compressedSize, if you know real compressedSize.
        You must use correct finish mode in that case. */

typedef enum
{
  LZMA_STATUS_NOT_SPECIFIED,               /* use main error code instead */
  LZMA_STATUS_FINISHED_WITH_MARK,          /* stream was finished with end mark. */
  LZMA_STATUS_NOT_FINISHED,                /* stream was not finished */
  LZMA_STATUS_NEEDS_MORE_INPUT,            /* you must provide more input bytes */
  LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK  /* there is probability that stream was finished without end mark */
} ELzmaStatus;

/* ELzmaStatus is used only as output value for function call */


/* ---------- Interfaces ---------- */

/* There are 3 levels of interfaces:
     1) Dictionary Interface
     2) Buffer Interface
     3) One Call Interface
   You can select any of these interfaces, but don't mix functions from different
   groups for same object. */


/* There are two variants to allocate state for Dictionary Interface:
     1) LzmaDec_Allocate / LzmaDec_Free
     2) LzmaDec_AllocateProbs / LzmaDec_FreeProbs
   You can use variant 2, if you set dictionary buffer manually.
   For Buffer Interface you must always use variant 1.

LzmaDec_Allocate* can return:
  SZ_OK
  SZ_ERROR_MEM         - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
*/
   
SRes LzmaDec_AllocateProbs(CLzmaDec *p, const Byte *props, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_FreeProbs(CLzmaDec *p, ISzAlloc *alloc);

SRes LzmaDec_Allocate(CLzmaDec *state, const Byte *prop, unsigned propsSize, ISzAlloc *alloc);
void LzmaDec_Free(CLzmaDec *state, ISzAlloc *alloc);

/* ---------- Dictionary Interface ---------- */

/* You can use it, if you want to eliminate the overhead for data copying from
   dictionary to some other external buffer.
   You must work with CLzmaDec variables directly in this interface.

   STEPS:
     LzmaDec_Constr()
     LzmaDec_Allocate()
     for (each new stream)
     {
       LzmaDec_Init()
       while (it needs more decompression)
       {
         LzmaDec_DecodeToDic()
         use data from CLzmaDec::dic and update CLzmaDec::dicPos
       }
     }
     LzmaDec_Free()
*/

/* LzmaDec_DecodeToDic
   
   The decoding to internal dictionary buffer (CLzmaDec::dic).
   You must manually update CLzmaDec::dicPos, if it reaches CLzmaDec::dicBufSize !!!

finishMode:
  It has meaning only if the decoding reaches output limit (dicLimit).
  LZMA_FINISH_ANY - Decode just dicLimit bytes.
  LZMA_FINISH_END - Stream must be finished after dicLimit.

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_NEEDS_MORE_INPUT
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
*/

SRes LzmaDec_DecodeToDic(CLzmaDec *p, SizeT dicLimit,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- Buffer Interface ---------- */

/* It's zlib-like interface.
   See LzmaDec_DecodeToDic description for information about STEPS and return results,
   but you must use LzmaDec_DecodeToBuf instead of LzmaDec_DecodeToDic and you don't need
   to work with CLzmaDec variables manually.

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).
*/

SRes LzmaDec_DecodeToBuf(CLzmaDec *p, Byte *dest, SizeT *destLen,
    const Byte *src, SizeT *srcLen, ELzmaFinishMode finishMode, ELzmaStatus *status);


/* ---------- One Call Interface ---------- */

/* LzmaDecode

finishMode:
  It has meaning only if the decoding reaches output limit (*destLen).
  LZMA_FINISH_ANY - Decode just destLen bytes.
  LZMA_FINISH_END - Stream must be finished after (*destLen).

Returns:
  SZ_OK
    status:
      LZMA_STATUS_FINISHED_WITH_MARK
      LZMA_STATUS_NOT_FINISHED
      LZMA_STATUS_MAYBE_FINISHED_WITHOUT_MARK
  SZ_ERROR_DATA - Data error
  SZ_ERROR_MEM  - Memory allocation error
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF - It needs more bytes in input buffer (src).
*/

SRes LzmaDecode(Byte *dest, SizeT *destLen, const Byte *src, SizeT *srcLen,
    const Byte *propData, unsigned propSize, ELzmaFinishMode finishMode,
    ELzmaStatus *status, ISzAlloc *alloc);

#endif

```

`Fatpack/Compessor/lzma/pavlov/LzmaEnc.c`:

```c
/* LzmaEnc.c -- LZMA Encoder
2008-10-04 : Igor Pavlov : Public domain */

/* #define SHOW_STAT */
/* #define SHOW_STAT2 */

#if defined(SHOW_STAT) || defined(SHOW_STAT2)
#include <stdio.h>
#endif

#include "LzmaEnc.h"

#include "LzFind.h"
#ifdef COMPRESS_MF_MT
#include "LzFindMt.h"
#endif

#ifdef SHOW_STAT
static int ttt = 0;
#endif

#define kBlockSizeMax ((1 << LZMA_NUM_BLOCK_SIZE_BITS) - 1)

#define kBlockSize (9 << 10)
#define kUnpackBlockSize (1 << 18)
#define kMatchArraySize (1 << 21)
#define kMatchRecordMaxSize ((LZMA_MATCH_LEN_MAX * 2 + 3) * LZMA_MATCH_LEN_MAX)

#define kNumMaxDirectBits (31)

#define kNumTopBits 24
#define kTopValue ((UInt32)1 << kNumTopBits)

#define kNumBitModelTotalBits 11
#define kBitModelTotal (1 << kNumBitModelTotalBits)
#define kNumMoveBits 5
#define kProbInitValue (kBitModelTotal >> 1)

#define kNumMoveReducingBits 4
#define kNumBitPriceShiftBits 4
#define kBitPrice (1 << kNumBitPriceShiftBits)

void LzmaEncProps_Init(CLzmaEncProps *p)
{
  p->level = 5;
  p->dictSize = p->mc = 0;
  p->lc = p->lp = p->pb = p->algo = p->fb = p->btMode = p->numHashBytes = p->numThreads = -1;
  p->writeEndMark = 0;
}

void LzmaEncProps_Normalize(CLzmaEncProps *p)
{
  int level = p->level;
  if (level < 0) level = 5;
  p->level = level;
  if (p->dictSize == 0) p->dictSize = (level <= 5 ? (1 << (level * 2 + 14)) : (level == 6 ? (1 << 25) : (1 << 26)));
  if (p->lc < 0) p->lc = 3;
  if (p->lp < 0) p->lp = 0;
  if (p->pb < 0) p->pb = 2;
  if (p->algo < 0) p->algo = (level < 5 ? 0 : 1);
  if (p->fb < 0) p->fb = (level < 7 ? 32 : 64);
  if (p->btMode < 0) p->btMode = (p->algo == 0 ? 0 : 1);
  if (p->numHashBytes < 0) p->numHashBytes = 4;
  if (p->mc == 0)  p->mc = (16 + (p->fb >> 1)) >> (p->btMode ? 0 : 1);
  if (p->numThreads < 0) p->numThreads = ((p->btMode && p->algo) ? 2 : 1);
}

UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2)
{
  CLzmaEncProps props = *props2;
  LzmaEncProps_Normalize(&props);
  return props.dictSize;
}

/* #define LZMA_LOG_BSR */
/* Define it for Intel's CPU */


#ifdef LZMA_LOG_BSR

#define kDicLogSizeMaxCompress 30

#define BSR2_RET(pos, res) { unsigned long i; _BitScanReverse(&i, (pos)); res = (i + i) + ((pos >> (i - 1)) & 1); }

UInt32 GetPosSlot1(UInt32 pos)
{
  UInt32 res;
  BSR2_RET(pos, res);
  return res;
}
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < 2) res = pos; else BSR2_RET(pos, res); }

#else

#define kNumLogBits (9 + (int)sizeof(size_t) / 2)
#define kDicLogSizeMaxCompress ((kNumLogBits - 1) * 2 + 7)

void LzmaEnc_FastPosInit(Byte *g_FastPos)
{
  int c = 2, slotFast;
  g_FastPos[0] = 0;
  g_FastPos[1] = 1;
  
  for (slotFast = 2; slotFast < kNumLogBits * 2; slotFast++)
  {
    UInt32 k = (1 << ((slotFast >> 1) - 1));
    UInt32 j;
    for (j = 0; j < k; j++, c++)
      g_FastPos[c] = (Byte)slotFast;
  }
}

#define BSR2_RET(pos, res) { UInt32 i = 6 + ((kNumLogBits - 1) & \
  (0 - (((((UInt32)1 << (kNumLogBits + 6)) - 1) - pos) >> 31))); \
  res = p->g_FastPos[pos >> i] + (i * 2); }
/*
#define BSR2_RET(pos, res) { res = (pos < (1 << (kNumLogBits + 6))) ? \
  p->g_FastPos[pos >> 6] + 12 : \
  p->g_FastPos[pos >> (6 + kNumLogBits - 1)] + (6 + (kNumLogBits - 1)) * 2; }
*/

#define GetPosSlot1(pos) p->g_FastPos[pos]
#define GetPosSlot2(pos, res) { BSR2_RET(pos, res); }
#define GetPosSlot(pos, res) { if (pos < kNumFullDistances) res = p->g_FastPos[pos]; else BSR2_RET(pos, res); }

#endif


#define LZMA_NUM_REPS 4

typedef unsigned CState;

typedef struct _COptimal
{
  UInt32 price;

  CState state;
  int prev1IsChar;
  int prev2;

  UInt32 posPrev2;
  UInt32 backPrev2;

  UInt32 posPrev;
  UInt32 backPrev;
  UInt32 backs[LZMA_NUM_REPS];
} COptimal;

#define kNumOpts (1 << 12)

#define kNumLenToPosStates 4
#define kNumPosSlotBits 6
#define kDicLogSizeMin 0
#define kDicLogSizeMax 32
#define kDistTableSizeMax (kDicLogSizeMax * 2)


#define kNumAlignBits 4
#define kAlignTableSize (1 << kNumAlignBits)
#define kAlignMask (kAlignTableSize - 1)

#define kStartPosModelIndex 4
#define kEndPosModelIndex 14
#define kNumPosModels (kEndPosModelIndex - kStartPosModelIndex)

#define kNumFullDistances (1 << (kEndPosModelIndex / 2))

#ifdef _LZMA_PROB32
#define CLzmaProb UInt32
#else
#define CLzmaProb UInt16
#endif

#define LZMA_PB_MAX 4
#define LZMA_LC_MAX 8
#define LZMA_LP_MAX 4

#define LZMA_NUM_PB_STATES_MAX (1 << LZMA_PB_MAX)


#define kLenNumLowBits 3
#define kLenNumLowSymbols (1 << kLenNumLowBits)
#define kLenNumMidBits 3
#define kLenNumMidSymbols (1 << kLenNumMidBits)
#define kLenNumHighBits 8
#define kLenNumHighSymbols (1 << kLenNumHighBits)

#define kLenNumSymbolsTotal (kLenNumLowSymbols + kLenNumMidSymbols + kLenNumHighSymbols)

#define LZMA_MATCH_LEN_MIN 2
#define LZMA_MATCH_LEN_MAX (LZMA_MATCH_LEN_MIN + kLenNumSymbolsTotal - 1)

#define kNumStates 12

typedef struct
{
  CLzmaProb choice;
  CLzmaProb choice2;
  CLzmaProb low[LZMA_NUM_PB_STATES_MAX << kLenNumLowBits];
  CLzmaProb mid[LZMA_NUM_PB_STATES_MAX << kLenNumMidBits];
  CLzmaProb high[kLenNumHighSymbols];
} CLenEnc;

typedef struct
{
  CLenEnc p;
  UInt32 prices[LZMA_NUM_PB_STATES_MAX][kLenNumSymbolsTotal];
  UInt32 tableSize;
  UInt32 counters[LZMA_NUM_PB_STATES_MAX];
} CLenPriceEnc;

typedef struct _CRangeEnc
{
  UInt32 range;
  Byte cache;
  UInt64 low;
  UInt64 cacheSize;
  Byte *buf;
  Byte *bufLim;
  Byte *bufBase;
  ISeqOutStream *outStream;
  UInt64 processed;
  SRes res;
} CRangeEnc;

typedef struct _CSeqInStreamBuf
{
  ISeqInStream funcTable;
  const Byte *data;
  SizeT rem;
} CSeqInStreamBuf;

static SRes MyRead(void *pp, void *data, size_t *size)
{
  size_t curSize = *size;
  CSeqInStreamBuf *p = (CSeqInStreamBuf *)pp;
  if (p->rem < curSize)
    curSize = p->rem;
  memcpy(data, p->data, curSize);
  p->rem -= curSize;
  p->data += curSize;
  *size = curSize;
  return SZ_OK;
}

typedef struct
{
  CLzmaProb *litProbs;

  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
  CLzmaProb isRep[kNumStates];
  CLzmaProb isRepG0[kNumStates];
  CLzmaProb isRepG1[kNumStates];
  CLzmaProb isRepG2[kNumStates];
  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
  
  CLenPriceEnc lenEnc;
  CLenPriceEnc repLenEnc;

  UInt32 reps[LZMA_NUM_REPS];
  UInt32 state;
} CSaveState;

typedef struct _CLzmaEnc
{
  IMatchFinder matchFinder;
  void *matchFinderObj;

  #ifdef COMPRESS_MF_MT
  Bool mtMode;
  CMatchFinderMt matchFinderMt;
  #endif

  CMatchFinder matchFinderBase;

  #ifdef COMPRESS_MF_MT
  Byte pad[128];
  #endif
  
  UInt32 optimumEndIndex;
  UInt32 optimumCurrentIndex;

  UInt32 longestMatchLength;
  UInt32 numPairs;
  UInt32 numAvail;
  COptimal opt[kNumOpts];
  
  #ifndef LZMA_LOG_BSR
  Byte g_FastPos[1 << kNumLogBits];
  #endif

  UInt32 ProbPrices[kBitModelTotal >> kNumMoveReducingBits];
  UInt32 matches[LZMA_MATCH_LEN_MAX * 2 + 2 + 1];
  UInt32 numFastBytes;
  UInt32 additionalOffset;
  UInt32 reps[LZMA_NUM_REPS];
  UInt32 state;

  UInt32 posSlotPrices[kNumLenToPosStates][kDistTableSizeMax];
  UInt32 distancesPrices[kNumLenToPosStates][kNumFullDistances];
  UInt32 alignPrices[kAlignTableSize];
  UInt32 alignPriceCount;

  UInt32 distTableSize;

  unsigned lc, lp, pb;
  unsigned lpMask, pbMask;

  CLzmaProb *litProbs;

  CLzmaProb isMatch[kNumStates][LZMA_NUM_PB_STATES_MAX];
  CLzmaProb isRep[kNumStates];
  CLzmaProb isRepG0[kNumStates];
  CLzmaProb isRepG1[kNumStates];
  CLzmaProb isRepG2[kNumStates];
  CLzmaProb isRep0Long[kNumStates][LZMA_NUM_PB_STATES_MAX];

  CLzmaProb posSlotEncoder[kNumLenToPosStates][1 << kNumPosSlotBits];
  CLzmaProb posEncoders[kNumFullDistances - kEndPosModelIndex];
  CLzmaProb posAlignEncoder[1 << kNumAlignBits];
  
  CLenPriceEnc lenEnc;
  CLenPriceEnc repLenEnc;

  unsigned lclp;

  Bool fastMode;
  
  CRangeEnc rc;

  Bool writeEndMark;
  UInt64 nowPos64;
  UInt32 matchPriceCount;
  Bool finished;
  Bool multiThread;

  SRes result;
  UInt32 dictSize;
  UInt32 matchFinderCycles;

  ISeqInStream *inStream;
  CSeqInStreamBuf seqBufInStream;

  CSaveState saveState;
} CLzmaEnc;

void LzmaEnc_SaveState(CLzmaEncHandle pp)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  CSaveState *dest = &p->saveState;
  int i;
  dest->lenEnc = p->lenEnc;
  dest->repLenEnc = p->repLenEnc;
  dest->state = p->state;

  for (i = 0; i < kNumStates; i++)
  {
    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
  }
  for (i = 0; i < kNumLenToPosStates; i++)
    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
  memcpy(dest->reps, p->reps, sizeof(p->reps));
  memcpy(dest->litProbs, p->litProbs, (0x300 << p->lclp) * sizeof(CLzmaProb));
}

void LzmaEnc_RestoreState(CLzmaEncHandle pp)
{
  CLzmaEnc *dest = (CLzmaEnc *)pp;
  const CSaveState *p = &dest->saveState;
  int i;
  dest->lenEnc = p->lenEnc;
  dest->repLenEnc = p->repLenEnc;
  dest->state = p->state;

  for (i = 0; i < kNumStates; i++)
  {
    memcpy(dest->isMatch[i], p->isMatch[i], sizeof(p->isMatch[i]));
    memcpy(dest->isRep0Long[i], p->isRep0Long[i], sizeof(p->isRep0Long[i]));
  }
  for (i = 0; i < kNumLenToPosStates; i++)
    memcpy(dest->posSlotEncoder[i], p->posSlotEncoder[i], sizeof(p->posSlotEncoder[i]));
  memcpy(dest->isRep, p->isRep, sizeof(p->isRep));
  memcpy(dest->isRepG0, p->isRepG0, sizeof(p->isRepG0));
  memcpy(dest->isRepG1, p->isRepG1, sizeof(p->isRepG1));
  memcpy(dest->isRepG2, p->isRepG2, sizeof(p->isRepG2));
  memcpy(dest->posEncoders, p->posEncoders, sizeof(p->posEncoders));
  memcpy(dest->posAlignEncoder, p->posAlignEncoder, sizeof(p->posAlignEncoder));
  memcpy(dest->reps, p->reps, sizeof(p->reps));
  memcpy(dest->litProbs, p->litProbs, (0x300 << dest->lclp) * sizeof(CLzmaProb));
}

SRes LzmaEnc_SetProps(CLzmaEncHandle pp, const CLzmaEncProps *props2)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  CLzmaEncProps props = *props2;
  LzmaEncProps_Normalize(&props);

  if (props.lc > LZMA_LC_MAX || props.lp > LZMA_LP_MAX || props.pb > LZMA_PB_MAX ||
      props.dictSize > (1 << kDicLogSizeMaxCompress) || props.dictSize > (1 << 30))
    return SZ_ERROR_PARAM;
  p->dictSize = props.dictSize;
  p->matchFinderCycles = props.mc;
  {
    unsigned fb = props.fb;
    if (fb < 5)
      fb = 5;
    if (fb > LZMA_MATCH_LEN_MAX)
      fb = LZMA_MATCH_LEN_MAX;
    p->numFastBytes = fb;
  }
  p->lc = props.lc;
  p->lp = props.lp;
  p->pb = props.pb;
  p->fastMode = (props.algo == 0);
  p->matchFinderBase.btMode = props.btMode;
  {
    UInt32 numHashBytes = 4;
    if (props.btMode)
    {
      if (props.numHashBytes < 2)
        numHashBytes = 2;
      else if (props.numHashBytes < 4)
        numHashBytes = props.numHashBytes;
    }
    p->matchFinderBase.numHashBytes = numHashBytes;
  }

  p->matchFinderBase.cutValue = props.mc;

  p->writeEndMark = props.writeEndMark;

  #ifdef COMPRESS_MF_MT
  /*
  if (newMultiThread != _multiThread)
  {
    ReleaseMatchFinder();
    _multiThread = newMultiThread;
  }
  */
  p->multiThread = (props.numThreads > 1);
  #endif

  return SZ_OK;
}

static const int kLiteralNextStates[kNumStates] = {0, 0, 0, 0, 1, 2, 3, 4,  5,  6,   4, 5};
static const int kMatchNextStates[kNumStates]   = {7, 7, 7, 7, 7, 7, 7, 10, 10, 10, 10, 10};
static const int kRepNextStates[kNumStates]     = {8, 8, 8, 8, 8, 8, 8, 11, 11, 11, 11, 11};
static const int kShortRepNextStates[kNumStates]= {9, 9, 9, 9, 9, 9, 9, 11, 11, 11, 11, 11};

#define IsCharState(s) ((s) < 7)

#define GetLenToPosState(len) (((len) < kNumLenToPosStates + 1) ? (len) - 2 : kNumLenToPosStates - 1)

#define kInfinityPrice (1 << 30)

static void RangeEnc_Construct(CRangeEnc *p)
{
  p->outStream = 0;
  p->bufBase = 0;
}

#define RangeEnc_GetProcessed(p) ((p)->processed + ((p)->buf - (p)->bufBase) + (p)->cacheSize)

#define RC_BUF_SIZE (1 << 16)
static int RangeEnc_Alloc(CRangeEnc *p, ISzAlloc *alloc)
{
  if (p->bufBase == 0)
  {
    p->bufBase = (Byte *)alloc->Alloc(alloc, RC_BUF_SIZE);
    if (p->bufBase == 0)
      return 0;
    p->bufLim = p->bufBase + RC_BUF_SIZE;
  }
  return 1;
}

static void RangeEnc_Free(CRangeEnc *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->bufBase);
  p->bufBase = 0;
}

static void RangeEnc_Init(CRangeEnc *p)
{
  /* Stream.Init(); */
  p->low = 0;
  p->range = 0xFFFFFFFF;
  p->cacheSize = 1;
  p->cache = 0;

  p->buf = p->bufBase;

  p->processed = 0;
  p->res = SZ_OK;
}

static void RangeEnc_FlushStream(CRangeEnc *p)
{
  size_t num;
  if (p->res != SZ_OK)
    return;
  num = p->buf - p->bufBase;
  if (num != p->outStream->Write(p->outStream, p->bufBase, num))
    p->res = SZ_ERROR_WRITE;
  p->processed += num;
  p->buf = p->bufBase;
}

static void MY_FAST_CALL RangeEnc_ShiftLow(CRangeEnc *p)
{
  if ((UInt32)p->low < (UInt32)0xFF000000 || (int)(p->low >> 32) != 0)
  {
    Byte temp = p->cache;
    do
    {
      Byte *buf = p->buf;
      *buf++ = (Byte)(temp + (Byte)(p->low >> 32));
      p->buf = buf;
      if (buf == p->bufLim)
        RangeEnc_FlushStream(p);
      temp = 0xFF;
    }
    while (--p->cacheSize != 0);
    p->cache = (Byte)((UInt32)p->low >> 24);
  }
  p->cacheSize++;
  p->low = (UInt32)p->low << 8;
}

static void RangeEnc_FlushData(CRangeEnc *p)
{
  int i;
  for (i = 0; i < 5; i++)
    RangeEnc_ShiftLow(p);
}

static void RangeEnc_EncodeDirectBits(CRangeEnc *p, UInt32 value, int numBits)
{
  do
  {
    p->range >>= 1;
    p->low += p->range & (0 - ((value >> --numBits) & 1));
    if (p->range < kTopValue)
    {
      p->range <<= 8;
      RangeEnc_ShiftLow(p);
    }
  }
  while (numBits != 0);
}

static void RangeEnc_EncodeBit(CRangeEnc *p, CLzmaProb *prob, UInt32 symbol)
{
  UInt32 ttt = *prob;
  UInt32 newBound = (p->range >> kNumBitModelTotalBits) * ttt;
  if (symbol == 0)
  {
    p->range = newBound;
    ttt += (kBitModelTotal - ttt) >> kNumMoveBits;
  }
  else
  {
    p->low += newBound;
    p->range -= newBound;
    ttt -= ttt >> kNumMoveBits;
  }
  *prob = (CLzmaProb)ttt;
  if (p->range < kTopValue)
  {
    p->range <<= 8;
    RangeEnc_ShiftLow(p);
  }
}

static void LitEnc_Encode(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol)
{
  symbol |= 0x100;
  do
  {
    RangeEnc_EncodeBit(p, probs + (symbol >> 8), (symbol >> 7) & 1);
    symbol <<= 1;
  }
  while (symbol < 0x10000);
}

static void LitEnc_EncodeMatched(CRangeEnc *p, CLzmaProb *probs, UInt32 symbol, UInt32 matchByte)
{
  UInt32 offs = 0x100;
  symbol |= 0x100;
  do
  {
    matchByte <<= 1;
    RangeEnc_EncodeBit(p, probs + (offs + (matchByte & offs) + (symbol >> 8)), (symbol >> 7) & 1);
    symbol <<= 1;
    offs &= ~(matchByte ^ symbol);
  }
  while (symbol < 0x10000);
}

void LzmaEnc_InitPriceTables(UInt32 *ProbPrices)
{
  UInt32 i;
  for (i = (1 << kNumMoveReducingBits) / 2; i < kBitModelTotal; i += (1 << kNumMoveReducingBits))
  {
    const int kCyclesBits = kNumBitPriceShiftBits;
    UInt32 w = i;
    UInt32 bitCount = 0;
    int j;
    for (j = 0; j < kCyclesBits; j++)
    {
      w = w * w;
      bitCount <<= 1;
      while (w >= ((UInt32)1 << 16))
      {
        w >>= 1;
        bitCount++;
      }
    }
    ProbPrices[i >> kNumMoveReducingBits] = ((kNumBitModelTotalBits << kCyclesBits) - 15 - bitCount);
  }
}


#define GET_PRICE(prob, symbol) \
  p->ProbPrices[((prob) ^ (((-(int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICEa(prob, symbol) \
  ProbPrices[((prob) ^ ((-((int)(symbol))) & (kBitModelTotal - 1))) >> kNumMoveReducingBits];

#define GET_PRICE_0(prob) p->ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1(prob) p->ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

#define GET_PRICE_0a(prob) ProbPrices[(prob) >> kNumMoveReducingBits]
#define GET_PRICE_1a(prob) ProbPrices[((prob) ^ (kBitModelTotal - 1)) >> kNumMoveReducingBits]

static UInt32 LitEnc_GetPrice(const CLzmaProb *probs, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  symbol |= 0x100;
  do
  {
    price += GET_PRICEa(probs[symbol >> 8], (symbol >> 7) & 1);
    symbol <<= 1;
  }
  while (symbol < 0x10000);
  return price;
}

static UInt32 LitEnc_GetPriceMatched(const CLzmaProb *probs, UInt32 symbol, UInt32 matchByte, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  UInt32 offs = 0x100;
  symbol |= 0x100;
  do
  {
    matchByte <<= 1;
    price += GET_PRICEa(probs[offs + (matchByte & offs) + (symbol >> 8)], (symbol >> 7) & 1);
    symbol <<= 1;
    offs &= ~(matchByte ^ symbol);
  }
  while (symbol < 0x10000);
  return price;
}


static void RcTree_Encode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
  UInt32 m = 1;
  int i;
  for (i = numBitLevels; i != 0;)
  {
    UInt32 bit;
    i--;
    bit = (symbol >> i) & 1;
    RangeEnc_EncodeBit(rc, probs + m, bit);
    m = (m << 1) | bit;
  }
}

static void RcTree_ReverseEncode(CRangeEnc *rc, CLzmaProb *probs, int numBitLevels, UInt32 symbol)
{
  UInt32 m = 1;
  int i;
  for (i = 0; i < numBitLevels; i++)
  {
    UInt32 bit = symbol & 1;
    RangeEnc_EncodeBit(rc, probs + m, bit);
    m = (m << 1) | bit;
    symbol >>= 1;
  }
}

static UInt32 RcTree_GetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  symbol |= (1 << numBitLevels);
  while (symbol != 1)
  {
    price += GET_PRICEa(probs[symbol >> 1], symbol & 1);
    symbol >>= 1;
  }
  return price;
}

static UInt32 RcTree_ReverseGetPrice(const CLzmaProb *probs, int numBitLevels, UInt32 symbol, UInt32 *ProbPrices)
{
  UInt32 price = 0;
  UInt32 m = 1;
  int i;
  for (i = numBitLevels; i != 0; i--)
  {
    UInt32 bit = symbol & 1;
    symbol >>= 1;
    price += GET_PRICEa(probs[m], bit);
    m = (m << 1) | bit;
  }
  return price;
}


static void LenEnc_Init(CLenEnc *p)
{
  unsigned i;
  p->choice = p->choice2 = kProbInitValue;
  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumLowBits); i++)
    p->low[i] = kProbInitValue;
  for (i = 0; i < (LZMA_NUM_PB_STATES_MAX << kLenNumMidBits); i++)
    p->mid[i] = kProbInitValue;
  for (i = 0; i < kLenNumHighSymbols; i++)
    p->high[i] = kProbInitValue;
}

static void LenEnc_Encode(CLenEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState)
{
  if (symbol < kLenNumLowSymbols)
  {
    RangeEnc_EncodeBit(rc, &p->choice, 0);
    RcTree_Encode(rc, p->low + (posState << kLenNumLowBits), kLenNumLowBits, symbol);
  }
  else
  {
    RangeEnc_EncodeBit(rc, &p->choice, 1);
    if (symbol < kLenNumLowSymbols + kLenNumMidSymbols)
    {
      RangeEnc_EncodeBit(rc, &p->choice2, 0);
      RcTree_Encode(rc, p->mid + (posState << kLenNumMidBits), kLenNumMidBits, symbol - kLenNumLowSymbols);
    }
    else
    {
      RangeEnc_EncodeBit(rc, &p->choice2, 1);
      RcTree_Encode(rc, p->high, kLenNumHighBits, symbol - kLenNumLowSymbols - kLenNumMidSymbols);
    }
  }
}

static void LenEnc_SetPrices(CLenEnc *p, UInt32 posState, UInt32 numSymbols, UInt32 *prices, UInt32 *ProbPrices)
{
  UInt32 a0 = GET_PRICE_0a(p->choice);
  UInt32 a1 = GET_PRICE_1a(p->choice);
  UInt32 b0 = a1 + GET_PRICE_0a(p->choice2);
  UInt32 b1 = a1 + GET_PRICE_1a(p->choice2);
  UInt32 i = 0;
  for (i = 0; i < kLenNumLowSymbols; i++)
  {
    if (i >= numSymbols)
      return;
    prices[i] = a0 + RcTree_GetPrice(p->low + (posState << kLenNumLowBits), kLenNumLowBits, i, ProbPrices);
  }
  for (; i < kLenNumLowSymbols + kLenNumMidSymbols; i++)
  {
    if (i >= numSymbols)
      return;
    prices[i] = b0 + RcTree_GetPrice(p->mid + (posState << kLenNumMidBits), kLenNumMidBits, i - kLenNumLowSymbols, ProbPrices);
  }
  for (; i < numSymbols; i++)
    prices[i] = b1 + RcTree_GetPrice(p->high, kLenNumHighBits, i - kLenNumLowSymbols - kLenNumMidSymbols, ProbPrices);
}

static void MY_FAST_CALL LenPriceEnc_UpdateTable(CLenPriceEnc *p, UInt32 posState, UInt32 *ProbPrices)
{
  LenEnc_SetPrices(&p->p, posState, p->tableSize, p->prices[posState], ProbPrices);
  p->counters[posState] = p->tableSize;
}

static void LenPriceEnc_UpdateTables(CLenPriceEnc *p, UInt32 numPosStates, UInt32 *ProbPrices)
{
  UInt32 posState;
  for (posState = 0; posState < numPosStates; posState++)
    LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}

static void LenEnc_Encode2(CLenPriceEnc *p, CRangeEnc *rc, UInt32 symbol, UInt32 posState, Bool updatePrice, UInt32 *ProbPrices)
{
  LenEnc_Encode(&p->p, rc, symbol, posState);
  if (updatePrice)
    if (--p->counters[posState] == 0)
      LenPriceEnc_UpdateTable(p, posState, ProbPrices);
}




static void MovePos(CLzmaEnc *p, UInt32 num)
{
  #ifdef SHOW_STAT
  ttt += num;
  printf("\n MovePos %d", num);
  #endif
  if (num != 0)
  {
    p->additionalOffset += num;
    p->matchFinder.Skip(p->matchFinderObj, num);
  }
}

static UInt32 ReadMatchDistances(CLzmaEnc *p, UInt32 *numDistancePairsRes)
{
  UInt32 lenRes = 0, numPairs;
  p->numAvail = p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
  numPairs = p->matchFinder.GetMatches(p->matchFinderObj, p->matches);
  #ifdef SHOW_STAT
  printf("\n i = %d numPairs = %d    ", ttt, numPairs / 2);
  ttt++;
  {
    UInt32 i;
    for (i = 0; i < numPairs; i += 2)
      printf("%2d %6d   | ", p->matches[i], p->matches[i + 1]);
  }
  #endif
  if (numPairs > 0)
  {
    lenRes = p->matches[numPairs - 2];
    if (lenRes == p->numFastBytes)
    {
      const Byte *pby = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
      UInt32 distance = p->matches[numPairs - 1] + 1;
      UInt32 numAvail = p->numAvail;
      if (numAvail > LZMA_MATCH_LEN_MAX)
        numAvail = LZMA_MATCH_LEN_MAX;
      {
        const Byte *pby2 = pby - distance;
        for (; lenRes < numAvail && pby[lenRes] == pby2[lenRes]; lenRes++);
      }
    }
  }
  p->additionalOffset++;
  *numDistancePairsRes = numPairs;
  return lenRes;
}


#define MakeAsChar(p) (p)->backPrev = (UInt32)(-1); (p)->prev1IsChar = False;
#define MakeAsShortRep(p) (p)->backPrev = 0; (p)->prev1IsChar = False;
#define IsShortRep(p) ((p)->backPrev == 0)

static UInt32 GetRepLen1Price(CLzmaEnc *p, UInt32 state, UInt32 posState)
{
  return
    GET_PRICE_0(p->isRepG0[state]) +
    GET_PRICE_0(p->isRep0Long[state][posState]);
}

static UInt32 GetPureRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 state, UInt32 posState)
{
  UInt32 price;
  if (repIndex == 0)
  {
    price = GET_PRICE_0(p->isRepG0[state]);
    price += GET_PRICE_1(p->isRep0Long[state][posState]);
  }
  else
  {
    price = GET_PRICE_1(p->isRepG0[state]);
    if (repIndex == 1)
      price += GET_PRICE_0(p->isRepG1[state]);
    else
    {
      price += GET_PRICE_1(p->isRepG1[state]);
      price += GET_PRICE(p->isRepG2[state], repIndex - 2);
    }
  }
  return price;
}

static UInt32 GetRepPrice(CLzmaEnc *p, UInt32 repIndex, UInt32 len, UInt32 state, UInt32 posState)
{
  return p->repLenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN] +
    GetPureRepPrice(p, repIndex, state, posState);
}

static UInt32 Backward(CLzmaEnc *p, UInt32 *backRes, UInt32 cur)
{
  UInt32 posMem = p->opt[cur].posPrev;
  UInt32 backMem = p->opt[cur].backPrev;
  p->optimumEndIndex = cur;
  do
  {
    if (p->opt[cur].prev1IsChar)
    {
      MakeAsChar(&p->opt[posMem])
      p->opt[posMem].posPrev = posMem - 1;
      if (p->opt[cur].prev2)
      {
        p->opt[posMem - 1].prev1IsChar = False;
        p->opt[posMem - 1].posPrev = p->opt[cur].posPrev2;
        p->opt[posMem - 1].backPrev = p->opt[cur].backPrev2;
      }
    }
    {
      UInt32 posPrev = posMem;
      UInt32 backCur = backMem;
      
      backMem = p->opt[posPrev].backPrev;
      posMem = p->opt[posPrev].posPrev;
      
      p->opt[posPrev].backPrev = backCur;
      p->opt[posPrev].posPrev = cur;
      cur = posPrev;
    }
  }
  while (cur != 0);
  *backRes = p->opt[0].backPrev;
  p->optimumCurrentIndex  = p->opt[0].posPrev;
  return p->optimumCurrentIndex;
}

#define LIT_PROBS(pos, prevByte) (p->litProbs + ((((pos) & p->lpMask) << p->lc) + ((prevByte) >> (8 - p->lc))) * 0x300)

static UInt32 GetOptimum(CLzmaEnc *p, UInt32 position, UInt32 *backRes)
{
  UInt32 numAvail, mainLen, numPairs, repMaxIndex, i, posState, lenEnd, len, cur;
  UInt32 matchPrice, repMatchPrice, normalMatchPrice;
  UInt32 reps[LZMA_NUM_REPS], repLens[LZMA_NUM_REPS];
  UInt32 *matches;
  const Byte *data;
  Byte curByte, matchByte;
  if (p->optimumEndIndex != p->optimumCurrentIndex)
  {
    const COptimal *opt = &p->opt[p->optimumCurrentIndex];
    UInt32 lenRes = opt->posPrev - p->optimumCurrentIndex;
    *backRes = opt->backPrev;
    p->optimumCurrentIndex = opt->posPrev;
    return lenRes;
  }
  p->optimumCurrentIndex = p->optimumEndIndex = 0;
  
  if (p->additionalOffset == 0)
    mainLen = ReadMatchDistances(p, &numPairs);
  else
  {
    mainLen = p->longestMatchLength;
    numPairs = p->numPairs;
  }

  numAvail = p->numAvail;
  if (numAvail < 2)
  {
    *backRes = (UInt32)(-1);
    return 1;
  }
  if (numAvail > LZMA_MATCH_LEN_MAX)
    numAvail = LZMA_MATCH_LEN_MAX;

  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
  repMaxIndex = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 lenTest;
    const Byte *data2;
    reps[i] = p->reps[i];
    data2 = data - (reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
    {
      repLens[i] = 0;
      continue;
    }
    for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
    repLens[i] = lenTest;
    if (lenTest > repLens[repMaxIndex])
      repMaxIndex = i;
  }
  if (repLens[repMaxIndex] >= p->numFastBytes)
  {
    UInt32 lenRes;
    *backRes = repMaxIndex;
    lenRes = repLens[repMaxIndex];
    MovePos(p, lenRes - 1);
    return lenRes;
  }

  matches = p->matches;
  if (mainLen >= p->numFastBytes)
  {
    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
    MovePos(p, mainLen - 1);
    return mainLen;
  }
  curByte = *data;
  matchByte = *(data - (reps[0] + 1));

  if (mainLen < 2 && curByte != matchByte && repLens[repMaxIndex] < 2)
  {
    *backRes = (UInt32)-1;
    return 1;
  }

  p->opt[0].state = (CState)p->state;

  posState = (position & p->pbMask);

  {
    const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
    p->opt[1].price = GET_PRICE_0(p->isMatch[p->state][posState]) +
        (!IsCharState(p->state) ?
          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
  }

  MakeAsChar(&p->opt[1]);

  matchPrice = GET_PRICE_1(p->isMatch[p->state][posState]);
  repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[p->state]);

  if (matchByte == curByte)
  {
    UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, p->state, posState);
    if (shortRepPrice < p->opt[1].price)
    {
      p->opt[1].price = shortRepPrice;
      MakeAsShortRep(&p->opt[1]);
    }
  }
  lenEnd = ((mainLen >= repLens[repMaxIndex]) ? mainLen : repLens[repMaxIndex]);

  if (lenEnd < 2)
  {
    *backRes = p->opt[1].backPrev;
    return 1;
  }

  p->opt[1].posPrev = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
    p->opt[0].backs[i] = reps[i];

  len = lenEnd;
  do
    p->opt[len--].price = kInfinityPrice;
  while (len >= 2);

  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 repLen = repLens[i];
    UInt32 price;
    if (repLen < 2)
      continue;
    price = repMatchPrice + GetPureRepPrice(p, i, p->state, posState);
    do
    {
      UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][repLen - 2];
      COptimal *opt = &p->opt[repLen];
      if (curAndLenPrice < opt->price)
      {
        opt->price = curAndLenPrice;
        opt->posPrev = 0;
        opt->backPrev = i;
        opt->prev1IsChar = False;
      }
    }
    while (--repLen >= 2);
  }

  normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[p->state]);

  len = ((repLens[0] >= 2) ? repLens[0] + 1 : 2);
  if (len <= mainLen)
  {
    UInt32 offs = 0;
    while (len > matches[offs])
      offs += 2;
    for (; ; len++)
    {
      COptimal *opt;
      UInt32 distance = matches[offs + 1];

      UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][len - LZMA_MATCH_LEN_MIN];
      UInt32 lenToPosState = GetLenToPosState(len);
      if (distance < kNumFullDistances)
        curAndLenPrice += p->distancesPrices[lenToPosState][distance];
      else
      {
        UInt32 slot;
        GetPosSlot2(distance, slot);
        curAndLenPrice += p->alignPrices[distance & kAlignMask] + p->posSlotPrices[lenToPosState][slot];
      }
      opt = &p->opt[len];
      if (curAndLenPrice < opt->price)
      {
        opt->price = curAndLenPrice;
        opt->posPrev = 0;
        opt->backPrev = distance + LZMA_NUM_REPS;
        opt->prev1IsChar = False;
      }
      if (len == matches[offs])
      {
        offs += 2;
        if (offs == numPairs)
          break;
      }
    }
  }

  cur = 0;

    #ifdef SHOW_STAT2
    if (position >= 0)
    {
      unsigned i;
      printf("\n pos = %4X", position);
      for (i = cur; i <= lenEnd; i++)
      printf("\nprice[%4X] = %d", position - cur + i, p->opt[i].price);
    }
    #endif

  for (;;)
  {
    UInt32 numAvailFull, newLen, numPairs, posPrev, state, posState, startLen;
    UInt32 curPrice, curAnd1Price, matchPrice, repMatchPrice;
    Bool nextIsChar;
    Byte curByte, matchByte;
    const Byte *data;
    COptimal *curOpt;
    COptimal *nextOpt;

    cur++;
    if (cur == lenEnd)
      return Backward(p, backRes, cur);

    newLen = ReadMatchDistances(p, &numPairs);
    if (newLen >= p->numFastBytes)
    {
      p->numPairs = numPairs;
      p->longestMatchLength = newLen;
      return Backward(p, backRes, cur);
    }
    position++;
    curOpt = &p->opt[cur];
    posPrev = curOpt->posPrev;
    if (curOpt->prev1IsChar)
    {
      posPrev--;
      if (curOpt->prev2)
      {
        state = p->opt[curOpt->posPrev2].state;
        if (curOpt->backPrev2 < LZMA_NUM_REPS)
          state = kRepNextStates[state];
        else
          state = kMatchNextStates[state];
      }
      else
        state = p->opt[posPrev].state;
      state = kLiteralNextStates[state];
    }
    else
      state = p->opt[posPrev].state;
    if (posPrev == cur - 1)
    {
      if (IsShortRep(curOpt))
        state = kShortRepNextStates[state];
      else
        state = kLiteralNextStates[state];
    }
    else
    {
      UInt32 pos;
      const COptimal *prevOpt;
      if (curOpt->prev1IsChar && curOpt->prev2)
      {
        posPrev = curOpt->posPrev2;
        pos = curOpt->backPrev2;
        state = kRepNextStates[state];
      }
      else
      {
        pos = curOpt->backPrev;
        if (pos < LZMA_NUM_REPS)
          state = kRepNextStates[state];
        else
          state = kMatchNextStates[state];
      }
      prevOpt = &p->opt[posPrev];
      if (pos < LZMA_NUM_REPS)
      {
        UInt32 i;
        reps[0] = prevOpt->backs[pos];
        for (i = 1; i <= pos; i++)
          reps[i] = prevOpt->backs[i - 1];
        for (; i < LZMA_NUM_REPS; i++)
          reps[i] = prevOpt->backs[i];
      }
      else
      {
        UInt32 i;
        reps[0] = (pos - LZMA_NUM_REPS);
        for (i = 1; i < LZMA_NUM_REPS; i++)
          reps[i] = prevOpt->backs[i - 1];
      }
    }
    curOpt->state = (CState)state;

    curOpt->backs[0] = reps[0];
    curOpt->backs[1] = reps[1];
    curOpt->backs[2] = reps[2];
    curOpt->backs[3] = reps[3];

    curPrice = curOpt->price;
    nextIsChar = False;
    data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
    curByte = *data;
    matchByte = *(data - (reps[0] + 1));

    posState = (position & p->pbMask);

    curAnd1Price = curPrice + GET_PRICE_0(p->isMatch[state][posState]);
    {
      const CLzmaProb *probs = LIT_PROBS(position, *(data - 1));
      curAnd1Price +=
        (!IsCharState(state) ?
          LitEnc_GetPriceMatched(probs, curByte, matchByte, p->ProbPrices) :
          LitEnc_GetPrice(probs, curByte, p->ProbPrices));
    }

    nextOpt = &p->opt[cur + 1];

    if (curAnd1Price < nextOpt->price)
    {
      nextOpt->price = curAnd1Price;
      nextOpt->posPrev = cur;
      MakeAsChar(nextOpt);
      nextIsChar = True;
    }

    matchPrice = curPrice + GET_PRICE_1(p->isMatch[state][posState]);
    repMatchPrice = matchPrice + GET_PRICE_1(p->isRep[state]);
    
    if (matchByte == curByte && !(nextOpt->posPrev < cur && nextOpt->backPrev == 0))
    {
      UInt32 shortRepPrice = repMatchPrice + GetRepLen1Price(p, state, posState);
      if (shortRepPrice <= nextOpt->price)
      {
        nextOpt->price = shortRepPrice;
        nextOpt->posPrev = cur;
        MakeAsShortRep(nextOpt);
        nextIsChar = True;
      }
    }
    numAvailFull = p->numAvail;
    {
      UInt32 temp = kNumOpts - 1 - cur;
      if (temp < numAvailFull)
        numAvailFull = temp;
    }

    if (numAvailFull < 2)
      continue;
    numAvail = (numAvailFull <= p->numFastBytes ? numAvailFull : p->numFastBytes);

    if (!nextIsChar && matchByte != curByte) /* speed optimization */
    {
      /* try Literal + rep0 */
      UInt32 temp;
      UInt32 lenTest2;
      const Byte *data2 = data - (reps[0] + 1);
      UInt32 limit = p->numFastBytes + 1;
      if (limit > numAvailFull)
        limit = numAvailFull;

      for (temp = 1; temp < limit && data[temp] == data2[temp]; temp++);
      lenTest2 = temp - 1;
      if (lenTest2 >= 2)
      {
        UInt32 state2 = kLiteralNextStates[state];
        UInt32 posStateNext = (position + 1) & p->pbMask;
        UInt32 nextRepMatchPrice = curAnd1Price +
            GET_PRICE_1(p->isMatch[state2][posStateNext]) +
            GET_PRICE_1(p->isRep[state2]);
        /* for (; lenTest2 >= 2; lenTest2--) */
        {
          UInt32 curAndLenPrice;
          COptimal *opt;
          UInt32 offset = cur + 1 + lenTest2;
          while (lenEnd < offset)
            p->opt[++lenEnd].price = kInfinityPrice;
          curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
          opt = &p->opt[offset];
          if (curAndLenPrice < opt->price)
          {
            opt->price = curAndLenPrice;
            opt->posPrev = cur + 1;
            opt->backPrev = 0;
            opt->prev1IsChar = True;
            opt->prev2 = False;
          }
        }
      }
    }
    
    startLen = 2; /* speed optimization */
    {
    UInt32 repIndex;
    for (repIndex = 0; repIndex < LZMA_NUM_REPS; repIndex++)
    {
      UInt32 lenTest;
      UInt32 lenTestTemp;
      UInt32 price;
      const Byte *data2 = data - (reps[repIndex] + 1);
      if (data[0] != data2[0] || data[1] != data2[1])
        continue;
      for (lenTest = 2; lenTest < numAvail && data[lenTest] == data2[lenTest]; lenTest++);
      while (lenEnd < cur + lenTest)
        p->opt[++lenEnd].price = kInfinityPrice;
      lenTestTemp = lenTest;
      price = repMatchPrice + GetPureRepPrice(p, repIndex, state, posState);
      do
      {
        UInt32 curAndLenPrice = price + p->repLenEnc.prices[posState][lenTest - 2];
        COptimal *opt = &p->opt[cur + lenTest];
        if (curAndLenPrice < opt->price)
        {
          opt->price = curAndLenPrice;
          opt->posPrev = cur;
          opt->backPrev = repIndex;
          opt->prev1IsChar = False;
        }
      }
      while (--lenTest >= 2);
      lenTest = lenTestTemp;
      
      if (repIndex == 0)
        startLen = lenTest + 1;
        
      /* if (_maxMode) */
        {
          UInt32 lenTest2 = lenTest + 1;
          UInt32 limit = lenTest2 + p->numFastBytes;
          UInt32 nextRepMatchPrice;
          if (limit > numAvailFull)
            limit = numAvailFull;
          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
          lenTest2 -= lenTest + 1;
          if (lenTest2 >= 2)
          {
            UInt32 state2 = kRepNextStates[state];
            UInt32 posStateNext = (position + lenTest) & p->pbMask;
            UInt32 curAndLenCharPrice =
                price + p->repLenEnc.prices[posState][lenTest - 2] +
                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                    data[lenTest], data2[lenTest], p->ProbPrices);
            state2 = kLiteralNextStates[state2];
            posStateNext = (position + lenTest + 1) & p->pbMask;
            nextRepMatchPrice = curAndLenCharPrice +
                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                GET_PRICE_1(p->isRep[state2]);
            
            /* for (; lenTest2 >= 2; lenTest2--) */
            {
              UInt32 curAndLenPrice;
              COptimal *opt;
              UInt32 offset = cur + lenTest + 1 + lenTest2;
              while (lenEnd < offset)
                p->opt[++lenEnd].price = kInfinityPrice;
              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
              opt = &p->opt[offset];
              if (curAndLenPrice < opt->price)
              {
                opt->price = curAndLenPrice;
                opt->posPrev = cur + lenTest + 1;
                opt->backPrev = 0;
                opt->prev1IsChar = True;
                opt->prev2 = True;
                opt->posPrev2 = cur;
                opt->backPrev2 = repIndex;
              }
            }
          }
        }
    }
    }
    /* for (UInt32 lenTest = 2; lenTest <= newLen; lenTest++) */
    if (newLen > numAvail)
    {
      newLen = numAvail;
      for (numPairs = 0; newLen > matches[numPairs]; numPairs += 2);
      matches[numPairs] = newLen;
      numPairs += 2;
    }
    if (newLen >= startLen)
    {
      UInt32 normalMatchPrice = matchPrice + GET_PRICE_0(p->isRep[state]);
      UInt32 offs, curBack, posSlot;
      UInt32 lenTest;
      while (lenEnd < cur + newLen)
        p->opt[++lenEnd].price = kInfinityPrice;

      offs = 0;
      while (startLen > matches[offs])
        offs += 2;
      curBack = matches[offs + 1];
      GetPosSlot2(curBack, posSlot);
      for (lenTest = /*2*/ startLen; ; lenTest++)
      {
        UInt32 curAndLenPrice = normalMatchPrice + p->lenEnc.prices[posState][lenTest - LZMA_MATCH_LEN_MIN];
        UInt32 lenToPosState = GetLenToPosState(lenTest);
        COptimal *opt;
        if (curBack < kNumFullDistances)
          curAndLenPrice += p->distancesPrices[lenToPosState][curBack];
        else
          curAndLenPrice += p->posSlotPrices[lenToPosState][posSlot] + p->alignPrices[curBack & kAlignMask];
        
        opt = &p->opt[cur + lenTest];
        if (curAndLenPrice < opt->price)
        {
          opt->price = curAndLenPrice;
          opt->posPrev = cur;
          opt->backPrev = curBack + LZMA_NUM_REPS;
          opt->prev1IsChar = False;
        }

        if (/*_maxMode && */lenTest == matches[offs])
        {
          /* Try Match + Literal + Rep0 */
          const Byte *data2 = data - (curBack + 1);
          UInt32 lenTest2 = lenTest + 1;
          UInt32 limit = lenTest2 + p->numFastBytes;
          UInt32 nextRepMatchPrice;
          if (limit > numAvailFull)
            limit = numAvailFull;
          for (; lenTest2 < limit && data[lenTest2] == data2[lenTest2]; lenTest2++);
          lenTest2 -= lenTest + 1;
          if (lenTest2 >= 2)
          {
            UInt32 state2 = kMatchNextStates[state];
            UInt32 posStateNext = (position + lenTest) & p->pbMask;
            UInt32 curAndLenCharPrice = curAndLenPrice +
                GET_PRICE_0(p->isMatch[state2][posStateNext]) +
                LitEnc_GetPriceMatched(LIT_PROBS(position + lenTest, data[lenTest - 1]),
                    data[lenTest], data2[lenTest], p->ProbPrices);
            state2 = kLiteralNextStates[state2];
            posStateNext = (posStateNext + 1) & p->pbMask;
            nextRepMatchPrice = curAndLenCharPrice +
                GET_PRICE_1(p->isMatch[state2][posStateNext]) +
                GET_PRICE_1(p->isRep[state2]);
            
            /* for (; lenTest2 >= 2; lenTest2--) */
            {
              UInt32 offset = cur + lenTest + 1 + lenTest2;
              UInt32 curAndLenPrice;
              COptimal *opt;
              while (lenEnd < offset)
                p->opt[++lenEnd].price = kInfinityPrice;
              curAndLenPrice = nextRepMatchPrice + GetRepPrice(p, 0, lenTest2, state2, posStateNext);
              opt = &p->opt[offset];
              if (curAndLenPrice < opt->price)
              {
                opt->price = curAndLenPrice;
                opt->posPrev = cur + lenTest + 1;
                opt->backPrev = 0;
                opt->prev1IsChar = True;
                opt->prev2 = True;
                opt->posPrev2 = cur;
                opt->backPrev2 = curBack + LZMA_NUM_REPS;
              }
            }
          }
          offs += 2;
          if (offs == numPairs)
            break;
          curBack = matches[offs + 1];
          if (curBack >= kNumFullDistances)
            GetPosSlot2(curBack, posSlot);
        }
      }
    }
  }
}

#define ChangePair(smallDist, bigDist) (((bigDist) >> 7) > (smallDist))

static UInt32 GetOptimumFast(CLzmaEnc *p, UInt32 *backRes)
{
  UInt32 numAvail, mainLen, mainDist, numPairs, repIndex, repLen, i;
  const Byte *data;
  const UInt32 *matches;

  if (p->additionalOffset == 0)
    mainLen = ReadMatchDistances(p, &numPairs);
  else
  {
    mainLen = p->longestMatchLength;
    numPairs = p->numPairs;
  }

  numAvail = p->numAvail;
  *backRes = (UInt32)-1;
  if (numAvail < 2)
    return 1;
  if (numAvail > LZMA_MATCH_LEN_MAX)
    numAvail = LZMA_MATCH_LEN_MAX;
  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;

  repLen = repIndex = 0;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 len;
    const Byte *data2 = data - (p->reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
      continue;
    for (len = 2; len < numAvail && data[len] == data2[len]; len++);
    if (len >= p->numFastBytes)
    {
      *backRes = i;
      MovePos(p, len - 1);
      return len;
    }
    if (len > repLen)
    {
      repIndex = i;
      repLen = len;
    }
  }

  matches = p->matches;
  if (mainLen >= p->numFastBytes)
  {
    *backRes = matches[numPairs - 1] + LZMA_NUM_REPS;
    MovePos(p, mainLen - 1);
    return mainLen;
  }

  mainDist = 0; /* for GCC */
  if (mainLen >= 2)
  {
    mainDist = matches[numPairs - 1];
    while (numPairs > 2 && mainLen == matches[numPairs - 4] + 1)
    {
      if (!ChangePair(matches[numPairs - 3], mainDist))
        break;
      numPairs -= 2;
      mainLen = matches[numPairs - 2];
      mainDist = matches[numPairs - 1];
    }
    if (mainLen == 2 && mainDist >= 0x80)
      mainLen = 1;
  }

  if (repLen >= 2 && (
        (repLen + 1 >= mainLen) ||
        (repLen + 2 >= mainLen && mainDist >= (1 << 9)) ||
        (repLen + 3 >= mainLen && mainDist >= (1 << 15))))
  {
    *backRes = repIndex;
    MovePos(p, repLen - 1);
    return repLen;
  }
  
  if (mainLen < 2 || numAvail <= 2)
    return 1;

  p->longestMatchLength = ReadMatchDistances(p, &p->numPairs);
  if (p->longestMatchLength >= 2)
  {
    UInt32 newDistance = matches[p->numPairs - 1];
    if ((p->longestMatchLength >= mainLen && newDistance < mainDist) ||
        (p->longestMatchLength == mainLen + 1 && !ChangePair(mainDist, newDistance)) ||
        (p->longestMatchLength > mainLen + 1) ||
        (p->longestMatchLength + 1 >= mainLen && mainLen >= 3 && ChangePair(newDistance, mainDist)))
      return 1;
  }
  
  data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - 1;
  for (i = 0; i < LZMA_NUM_REPS; i++)
  {
    UInt32 len, limit;
    const Byte *data2 = data - (p->reps[i] + 1);
    if (data[0] != data2[0] || data[1] != data2[1])
      continue;
    limit = mainLen - 1;
    for (len = 2; len < limit && data[len] == data2[len]; len++);
    if (len >= limit)
      return 1;
  }
  *backRes = mainDist + LZMA_NUM_REPS;
  MovePos(p, mainLen - 2);
  return mainLen;
}

static void WriteEndMarker(CLzmaEnc *p, UInt32 posState)
{
  UInt32 len;
  RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
  RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
  p->state = kMatchNextStates[p->state];
  len = LZMA_MATCH_LEN_MIN;
  LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
  RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, (1 << kNumPosSlotBits) - 1);
  RangeEnc_EncodeDirectBits(&p->rc, (((UInt32)1 << 30) - 1) >> kNumAlignBits, 30 - kNumAlignBits);
  RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, kAlignMask);
}

static SRes CheckErrors(CLzmaEnc *p)
{
  if (p->result != SZ_OK)
    return p->result;
  if (p->rc.res != SZ_OK)
    p->result = SZ_ERROR_WRITE;
  if (p->matchFinderBase.result != SZ_OK)
    p->result = SZ_ERROR_READ;
  if (p->result != SZ_OK)
    p->finished = True;
  return p->result;
}

static SRes Flush(CLzmaEnc *p, UInt32 nowPos)
{
  /* ReleaseMFStream(); */
  p->finished = True;
  if (p->writeEndMark)
    WriteEndMarker(p, nowPos & p->pbMask);
  RangeEnc_FlushData(&p->rc);
  RangeEnc_FlushStream(&p->rc);
  return CheckErrors(p);
}

static void FillAlignPrices(CLzmaEnc *p)
{
  UInt32 i;
  for (i = 0; i < kAlignTableSize; i++)
    p->alignPrices[i] = RcTree_ReverseGetPrice(p->posAlignEncoder, kNumAlignBits, i, p->ProbPrices);
  p->alignPriceCount = 0;
}

static void FillDistancesPrices(CLzmaEnc *p)
{
  UInt32 tempPrices[kNumFullDistances];
  UInt32 i, lenToPosState;
  for (i = kStartPosModelIndex; i < kNumFullDistances; i++)
  {
    UInt32 posSlot = GetPosSlot1(i);
    UInt32 footerBits = ((posSlot >> 1) - 1);
    UInt32 base = ((2 | (posSlot & 1)) << footerBits);
    tempPrices[i] = RcTree_ReverseGetPrice(p->posEncoders + base - posSlot - 1, footerBits, i - base, p->ProbPrices);
  }

  for (lenToPosState = 0; lenToPosState < kNumLenToPosStates; lenToPosState++)
  {
    UInt32 posSlot;
    const CLzmaProb *encoder = p->posSlotEncoder[lenToPosState];
    UInt32 *posSlotPrices = p->posSlotPrices[lenToPosState];
    for (posSlot = 0; posSlot < p->distTableSize; posSlot++)
      posSlotPrices[posSlot] = RcTree_GetPrice(encoder, kNumPosSlotBits, posSlot, p->ProbPrices);
    for (posSlot = kEndPosModelIndex; posSlot < p->distTableSize; posSlot++)
      posSlotPrices[posSlot] += ((((posSlot >> 1) - 1) - kNumAlignBits) << kNumBitPriceShiftBits);

    {
      UInt32 *distancesPrices = p->distancesPrices[lenToPosState];
      UInt32 i;
      for (i = 0; i < kStartPosModelIndex; i++)
        distancesPrices[i] = posSlotPrices[i];
      for (; i < kNumFullDistances; i++)
        distancesPrices[i] = posSlotPrices[GetPosSlot1(i)] + tempPrices[i];
    }
  }
  p->matchPriceCount = 0;
}

void LzmaEnc_Construct(CLzmaEnc *p)
{
  RangeEnc_Construct(&p->rc);
  MatchFinder_Construct(&p->matchFinderBase);
  #ifdef COMPRESS_MF_MT
  MatchFinderMt_Construct(&p->matchFinderMt);
  p->matchFinderMt.MatchFinder = &p->matchFinderBase;
  #endif

  {
    CLzmaEncProps props;
    LzmaEncProps_Init(&props);
    LzmaEnc_SetProps(p, &props);
  }

  #ifndef LZMA_LOG_BSR
  LzmaEnc_FastPosInit(p->g_FastPos);
  #endif

  LzmaEnc_InitPriceTables(p->ProbPrices);
  p->litProbs = 0;
  p->saveState.litProbs = 0;
}

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc)
{
  void *p;
  p = alloc->Alloc(alloc, sizeof(CLzmaEnc));
  if (p != 0)
    LzmaEnc_Construct((CLzmaEnc *)p);
  return p;
}

void LzmaEnc_FreeLits(CLzmaEnc *p, ISzAlloc *alloc)
{
  alloc->Free(alloc, p->litProbs);
  alloc->Free(alloc, p->saveState.litProbs);
  p->litProbs = 0;
  p->saveState.litProbs = 0;
}

void LzmaEnc_Destruct(CLzmaEnc *p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  #ifdef COMPRESS_MF_MT
  MatchFinderMt_Destruct(&p->matchFinderMt, allocBig);
  #endif
  MatchFinder_Free(&p->matchFinderBase, allocBig);
  LzmaEnc_FreeLits(p, alloc);
  RangeEnc_Free(&p->rc, alloc);
}

void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  LzmaEnc_Destruct((CLzmaEnc *)p, alloc, allocBig);
  alloc->Free(alloc, p);
}

static SRes LzmaEnc_CodeOneBlock(CLzmaEnc *p, Bool useLimits, UInt32 maxPackSize, UInt32 maxUnpackSize)
{
  UInt32 nowPos32, startPos32;
  if (p->inStream != 0)
  {
    p->matchFinderBase.stream = p->inStream;
    p->matchFinder.Init(p->matchFinderObj);
    p->inStream = 0;
  }

  if (p->finished)
    return p->result;
  RINOK(CheckErrors(p));

  nowPos32 = (UInt32)p->nowPos64;
  startPos32 = nowPos32;

  if (p->nowPos64 == 0)
  {
    UInt32 numPairs;
    Byte curByte;
    if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
      return Flush(p, nowPos32);
    ReadMatchDistances(p, &numPairs);
    RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][0], 0);
    p->state = kLiteralNextStates[p->state];
    curByte = p->matchFinder.GetIndexByte(p->matchFinderObj, 0 - p->additionalOffset);
    LitEnc_Encode(&p->rc, p->litProbs, curByte);
    p->additionalOffset--;
    nowPos32++;
  }

  if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) != 0)
  for (;;)
  {
    UInt32 pos, len, posState;

    if (p->fastMode)
      len = GetOptimumFast(p, &pos);
    else
      len = GetOptimum(p, nowPos32, &pos);

    #ifdef SHOW_STAT2
    printf("\n pos = %4X,   len = %d   pos = %d", nowPos32, len, pos);
    #endif

    posState = nowPos32 & p->pbMask;
    if (len == 1 && pos == (UInt32)-1)
    {
      Byte curByte;
      CLzmaProb *probs;
      const Byte *data;

      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 0);
      data = p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
      curByte = *data;
      probs = LIT_PROBS(nowPos32, *(data - 1));
      if (IsCharState(p->state))
        LitEnc_Encode(&p->rc, probs, curByte);
      else
        LitEnc_EncodeMatched(&p->rc, probs, curByte, *(data - p->reps[0] - 1));
      p->state = kLiteralNextStates[p->state];
    }
    else
    {
      RangeEnc_EncodeBit(&p->rc, &p->isMatch[p->state][posState], 1);
      if (pos < LZMA_NUM_REPS)
      {
        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 1);
        if (pos == 0)
        {
          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 0);
          RangeEnc_EncodeBit(&p->rc, &p->isRep0Long[p->state][posState], ((len == 1) ? 0 : 1));
        }
        else
        {
          UInt32 distance = p->reps[pos];
          RangeEnc_EncodeBit(&p->rc, &p->isRepG0[p->state], 1);
          if (pos == 1)
            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 0);
          else
          {
            RangeEnc_EncodeBit(&p->rc, &p->isRepG1[p->state], 1);
            RangeEnc_EncodeBit(&p->rc, &p->isRepG2[p->state], pos - 2);
            if (pos == 3)
              p->reps[3] = p->reps[2];
            p->reps[2] = p->reps[1];
          }
          p->reps[1] = p->reps[0];
          p->reps[0] = distance;
        }
        if (len == 1)
          p->state = kShortRepNextStates[p->state];
        else
        {
          LenEnc_Encode2(&p->repLenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
          p->state = kRepNextStates[p->state];
        }
      }
      else
      {
        UInt32 posSlot;
        RangeEnc_EncodeBit(&p->rc, &p->isRep[p->state], 0);
        p->state = kMatchNextStates[p->state];
        LenEnc_Encode2(&p->lenEnc, &p->rc, len - LZMA_MATCH_LEN_MIN, posState, !p->fastMode, p->ProbPrices);
        pos -= LZMA_NUM_REPS;
        GetPosSlot(pos, posSlot);
        RcTree_Encode(&p->rc, p->posSlotEncoder[GetLenToPosState(len)], kNumPosSlotBits, posSlot);
        
        if (posSlot >= kStartPosModelIndex)
        {
          UInt32 footerBits = ((posSlot >> 1) - 1);
          UInt32 base = ((2 | (posSlot & 1)) << footerBits);
          UInt32 posReduced = pos - base;

          if (posSlot < kEndPosModelIndex)
            RcTree_ReverseEncode(&p->rc, p->posEncoders + base - posSlot - 1, footerBits, posReduced);
          else
          {
            RangeEnc_EncodeDirectBits(&p->rc, posReduced >> kNumAlignBits, footerBits - kNumAlignBits);
            RcTree_ReverseEncode(&p->rc, p->posAlignEncoder, kNumAlignBits, posReduced & kAlignMask);
            p->alignPriceCount++;
          }
        }
        p->reps[3] = p->reps[2];
        p->reps[2] = p->reps[1];
        p->reps[1] = p->reps[0];
        p->reps[0] = pos;
        p->matchPriceCount++;
      }
    }
    p->additionalOffset -= len;
    nowPos32 += len;
    if (p->additionalOffset == 0)
    {
      UInt32 processed;
      if (!p->fastMode)
      {
        if (p->matchPriceCount >= (1 << 7))
          FillDistancesPrices(p);
        if (p->alignPriceCount >= kAlignTableSize)
          FillAlignPrices(p);
      }
      if (p->matchFinder.GetNumAvailableBytes(p->matchFinderObj) == 0)
        break;
      processed = nowPos32 - startPos32;
      if (useLimits)
      {
        if (processed + kNumOpts + 300 >= maxUnpackSize ||
            RangeEnc_GetProcessed(&p->rc) + kNumOpts * 2 >= maxPackSize)
          break;
      }
      else if (processed >= (1 << 15))
      {
        p->nowPos64 += nowPos32 - startPos32;
        return CheckErrors(p);
      }
    }
  }
  p->nowPos64 += nowPos32 - startPos32;
  return Flush(p, nowPos32);
}

#define kBigHashDicLimit ((UInt32)1 << 24)

static SRes LzmaEnc_Alloc(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  UInt32 beforeSize = kNumOpts;
  Bool btMode;
  if (!RangeEnc_Alloc(&p->rc, alloc))
    return SZ_ERROR_MEM;
  btMode = (p->matchFinderBase.btMode != 0);
  #ifdef COMPRESS_MF_MT
  p->mtMode = (p->multiThread && !p->fastMode && btMode);
  #endif

  {
    unsigned lclp = p->lc + p->lp;
    if (p->litProbs == 0 || p->saveState.litProbs == 0 || p->lclp != lclp)
    {
      LzmaEnc_FreeLits(p, alloc);
      p->litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
      p->saveState.litProbs = (CLzmaProb *)alloc->Alloc(alloc, (0x300 << lclp) * sizeof(CLzmaProb));
      if (p->litProbs == 0 || p->saveState.litProbs == 0)
      {
        LzmaEnc_FreeLits(p, alloc);
        return SZ_ERROR_MEM;
      }
      p->lclp = lclp;
    }
  }

  p->matchFinderBase.bigHash = (p->dictSize > kBigHashDicLimit);

  if (beforeSize + p->dictSize < keepWindowSize)
    beforeSize = keepWindowSize - p->dictSize;

  #ifdef COMPRESS_MF_MT
  if (p->mtMode)
  {
    RINOK(MatchFinderMt_Create(&p->matchFinderMt, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig));
    p->matchFinderObj = &p->matchFinderMt;
    MatchFinderMt_CreateVTable(&p->matchFinderMt, &p->matchFinder);
  }
  else
  #endif
  {
    if (!MatchFinder_Create(&p->matchFinderBase, p->dictSize, beforeSize, p->numFastBytes, LZMA_MATCH_LEN_MAX, allocBig))
      return SZ_ERROR_MEM;
    p->matchFinderObj = &p->matchFinderBase;
    MatchFinder_CreateVTable(&p->matchFinderBase, &p->matchFinder);
  }
  return SZ_OK;
}

void LzmaEnc_Init(CLzmaEnc *p)
{
  UInt32 i;
  p->state = 0;
  for (i = 0 ; i < LZMA_NUM_REPS; i++)
    p->reps[i] = 0;

  RangeEnc_Init(&p->rc);


  for (i = 0; i < kNumStates; i++)
  {
    UInt32 j;
    for (j = 0; j < LZMA_NUM_PB_STATES_MAX; j++)
    {
      p->isMatch[i][j] = kProbInitValue;
      p->isRep0Long[i][j] = kProbInitValue;
    }
    p->isRep[i] = kProbInitValue;
    p->isRepG0[i] = kProbInitValue;
    p->isRepG1[i] = kProbInitValue;
    p->isRepG2[i] = kProbInitValue;
  }

  {
    UInt32 num = 0x300 << (p->lp + p->lc);
    for (i = 0; i < num; i++)
      p->litProbs[i] = kProbInitValue;
  }

  {
    for (i = 0; i < kNumLenToPosStates; i++)
    {
      CLzmaProb *probs = p->posSlotEncoder[i];
      UInt32 j;
      for (j = 0; j < (1 << kNumPosSlotBits); j++)
        probs[j] = kProbInitValue;
    }
  }
  {
    for (i = 0; i < kNumFullDistances - kEndPosModelIndex; i++)
      p->posEncoders[i] = kProbInitValue;
  }

  LenEnc_Init(&p->lenEnc.p);
  LenEnc_Init(&p->repLenEnc.p);

  for (i = 0; i < (1 << kNumAlignBits); i++)
    p->posAlignEncoder[i] = kProbInitValue;

  p->optimumEndIndex = 0;
  p->optimumCurrentIndex = 0;
  p->additionalOffset = 0;

  p->pbMask = (1 << p->pb) - 1;
  p->lpMask = (1 << p->lp) - 1;
}

void LzmaEnc_InitPrices(CLzmaEnc *p)
{
  if (!p->fastMode)
  {
    FillDistancesPrices(p);
    FillAlignPrices(p);
  }

  p->lenEnc.tableSize =
  p->repLenEnc.tableSize =
      p->numFastBytes + 1 - LZMA_MATCH_LEN_MIN;
  LenPriceEnc_UpdateTables(&p->lenEnc, 1 << p->pb, p->ProbPrices);
  LenPriceEnc_UpdateTables(&p->repLenEnc, 1 << p->pb, p->ProbPrices);
}

static SRes LzmaEnc_AllocAndInit(CLzmaEnc *p, UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  UInt32 i;
  for (i = 0; i < (UInt32)kDicLogSizeMaxCompress; i++)
    if (p->dictSize <= ((UInt32)1 << i))
      break;
  p->distTableSize = i * 2;

  p->finished = False;
  p->result = SZ_OK;
  RINOK(LzmaEnc_Alloc(p, keepWindowSize, alloc, allocBig));
  LzmaEnc_Init(p);
  LzmaEnc_InitPrices(p);
  p->nowPos64 = 0;
  return SZ_OK;
}

static SRes LzmaEnc_Prepare(CLzmaEncHandle pp, ISeqInStream *inStream, ISeqOutStream *outStream,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  p->inStream = inStream;
  p->rc.outStream = outStream;
  return LzmaEnc_AllocAndInit(p, 0, alloc, allocBig);
}

SRes LzmaEnc_PrepareForLzma2(CLzmaEncHandle pp,
    ISeqInStream *inStream, UInt32 keepWindowSize,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  p->inStream = inStream;
  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

static void LzmaEnc_SetInputBuf(CLzmaEnc *p, const Byte *src, SizeT srcLen)
{
  p->seqBufInStream.funcTable.Read = MyRead;
  p->seqBufInStream.data = src;
  p->seqBufInStream.rem = srcLen;
}

SRes LzmaEnc_MemPrepare(CLzmaEncHandle pp, const Byte *src, SizeT srcLen,
    UInt32 keepWindowSize, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  LzmaEnc_SetInputBuf(p, src, srcLen);
  p->inStream = &p->seqBufInStream.funcTable;
  return LzmaEnc_AllocAndInit(p, keepWindowSize, alloc, allocBig);
}

void LzmaEnc_Finish(CLzmaEncHandle pp)
{
  #ifdef COMPRESS_MF_MT
  CLzmaEnc *p = (CLzmaEnc *)pp;
  if (p->mtMode)
    MatchFinderMt_ReleaseStream(&p->matchFinderMt);
  #else
  pp = pp;
  #endif
}

typedef struct _CSeqOutStreamBuf
{
  ISeqOutStream funcTable;
  Byte *data;
  SizeT rem;
  Bool overflow;
} CSeqOutStreamBuf;

static size_t MyWrite(void *pp, const void *data, size_t size)
{
  CSeqOutStreamBuf *p = (CSeqOutStreamBuf *)pp;
  if (p->rem < size)
  {
    size = p->rem;
    p->overflow = True;
  }
  memcpy(p->data, data, size);
  p->rem -= size;
  p->data += size;
  return size;
}


UInt32 LzmaEnc_GetNumAvailableBytes(CLzmaEncHandle pp)
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  return p->matchFinder.GetNumAvailableBytes(p->matchFinderObj);
}

const Byte *LzmaEnc_GetCurBuf(CLzmaEncHandle pp)
{
  const CLzmaEnc *p = (CLzmaEnc *)pp;
  return p->matchFinder.GetPointerToCurrentPos(p->matchFinderObj) - p->additionalOffset;
}

SRes LzmaEnc_CodeOneMemBlock(CLzmaEncHandle pp, Bool reInit,
    Byte *dest, size_t *destLen, UInt32 desiredPackSize, UInt32 *unpackSize)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  UInt64 nowPos64;
  SRes res;
  CSeqOutStreamBuf outStream;

  outStream.funcTable.Write = MyWrite;
  outStream.data = dest;
  outStream.rem = *destLen;
  outStream.overflow = False;

  p->writeEndMark = False;
  p->finished = False;
  p->result = SZ_OK;

  if (reInit)
    LzmaEnc_Init(p);
  LzmaEnc_InitPrices(p);
  nowPos64 = p->nowPos64;
  RangeEnc_Init(&p->rc);
  p->rc.outStream = &outStream.funcTable;

  res = LzmaEnc_CodeOneBlock(p, True, desiredPackSize, *unpackSize);
  
  *unpackSize = (UInt32)(p->nowPos64 - nowPos64);
  *destLen -= outStream.rem;
  if (outStream.overflow)
    return SZ_ERROR_OUTPUT_EOF;

  return res;
}

SRes LzmaEnc_Encode(CLzmaEncHandle pp, ISeqOutStream *outStream, ISeqInStream *inStream, ICompressProgress *progress,
    ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  SRes res = SZ_OK;

  #ifdef COMPRESS_MF_MT
  Byte allocaDummy[0x300];
  int i = 0;
  for (i = 0; i < 16; i++)
    allocaDummy[i] = (Byte)i;
  #endif

  RINOK(LzmaEnc_Prepare(pp, inStream, outStream, alloc, allocBig));

  for (;;)
  {
    res = LzmaEnc_CodeOneBlock(p, False, 0, 0);
    if (res != SZ_OK || p->finished != 0)
      break;
    if (progress != 0)
    {
      res = progress->Progress(progress, p->nowPos64, RangeEnc_GetProcessed(&p->rc));
      if (res != SZ_OK)
      {
        res = SZ_ERROR_PROGRESS;
        break;
      }
    }
  }
  LzmaEnc_Finish(pp);
  return res;
}

SRes LzmaEnc_WriteProperties(CLzmaEncHandle pp, Byte *props, SizeT *size)
{
  CLzmaEnc *p = (CLzmaEnc *)pp;
  int i;
  UInt32 dictSize = p->dictSize;
  if (*size < LZMA_PROPS_SIZE)
    return SZ_ERROR_PARAM;
  *size = LZMA_PROPS_SIZE;
  props[0] = (Byte)((p->pb * 5 + p->lp) * 9 + p->lc);

  for (i = 11; i <= 30; i++)
  {
    if (dictSize <= ((UInt32)2 << i))
    {
      dictSize = (2 << i);
      break;
    }
    if (dictSize <= ((UInt32)3 << i))
    {
      dictSize = (3 << i);
      break;
    }
  }

  for (i = 0; i < 4; i++)
    props[1 + i] = (Byte)(dictSize >> (8 * i));
  return SZ_OK;
}

SRes LzmaEnc_MemEncode(CLzmaEncHandle pp, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  SRes res;
  CLzmaEnc *p = (CLzmaEnc *)pp;

  CSeqOutStreamBuf outStream;

  LzmaEnc_SetInputBuf(p, src, srcLen);

  outStream.funcTable.Write = MyWrite;
  outStream.data = dest;
  outStream.rem = *destLen;
  outStream.overflow = False;

  p->writeEndMark = writeEndMark;
  res = LzmaEnc_Encode(pp, &outStream.funcTable, &p->seqBufInStream.funcTable,
      progress, alloc, allocBig);

  *destLen -= outStream.rem;
  if (outStream.overflow)
    return SZ_ERROR_OUTPUT_EOF;
  return res;
}

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig)
{
  CLzmaEnc *p = (CLzmaEnc *)LzmaEnc_Create(alloc);
  SRes res;
  if (p == 0)
    return SZ_ERROR_MEM;

  res = LzmaEnc_SetProps(p, props);
  if (res == SZ_OK)
  {
    res = LzmaEnc_WriteProperties(p, propsEncoded, propsSize);
    if (res == SZ_OK)
      res = LzmaEnc_MemEncode(p, dest, destLen, src, srcLen,
          writeEndMark, progress, alloc, allocBig);
  }

  LzmaEnc_Destroy(p, alloc, allocBig);
  return res;
}

```

`Fatpack/Compessor/lzma/pavlov/LzmaEnc.h`:

```h
/*  LzmaEnc.h -- LZMA Encoder
2008-10-04 : Igor Pavlov : Public domain */

#ifndef __LZMAENC_H
#define __LZMAENC_H

#include "Types.h"

#define LZMA_PROPS_SIZE 5

typedef struct _CLzmaEncProps
{
  int level;       /*  0 <= level <= 9 */
  UInt32 dictSize; /* (1 << 12) <= dictSize <= (1 << 27) for 32-bit version
                      (1 << 12) <= dictSize <= (1 << 30) for 64-bit version
                       default = (1 << 24) */
  int lc;          /* 0 <= lc <= 8, default = 3 */
  int lp;          /* 0 <= lp <= 4, default = 0 */
  int pb;          /* 0 <= pb <= 4, default = 2 */
  int algo;        /* 0 - fast, 1 - normal, default = 1 */
  int fb;          /* 5 <= fb <= 273, default = 32 */
  int btMode;      /* 0 - hashChain Mode, 1 - binTree mode - normal, default = 1 */
  int numHashBytes; /* 2, 3 or 4, default = 4 */
  UInt32 mc;        /* 1 <= mc <= (1 << 30), default = 32 */
  unsigned writeEndMark;  /* 0 - do not write EOPM, 1 - write EOPM, default = 0 */
  int numThreads;  /* 1 or 2, default = 2 */
} CLzmaEncProps;

void LzmaEncProps_Init(CLzmaEncProps *p);
void LzmaEncProps_Normalize(CLzmaEncProps *p);
UInt32 LzmaEncProps_GetDictSize(const CLzmaEncProps *props2);


/* ---------- CLzmaEncHandle Interface ---------- */

/* LzmaEnc_* functions can return the following exit codes:
Returns:
  SZ_OK           - OK
  SZ_ERROR_MEM    - Memory allocation error
  SZ_ERROR_PARAM  - Incorrect paramater in props
  SZ_ERROR_WRITE  - Write callback error.
  SZ_ERROR_PROGRESS - some break from progress callback
  SZ_ERROR_THREAD - errors in multithreading functions (only for Mt version)
*/

typedef void * CLzmaEncHandle;

CLzmaEncHandle LzmaEnc_Create(ISzAlloc *alloc);
void LzmaEnc_Destroy(CLzmaEncHandle p, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_SetProps(CLzmaEncHandle p, const CLzmaEncProps *props);
SRes LzmaEnc_WriteProperties(CLzmaEncHandle p, Byte *properties, SizeT *size);
SRes LzmaEnc_Encode(CLzmaEncHandle p, ISeqOutStream *outStream, ISeqInStream *inStream,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);
SRes LzmaEnc_MemEncode(CLzmaEncHandle p, Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    int writeEndMark, ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

/* ---------- One Call Interface ---------- */

/* LzmaEncode
Return code:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
*/

SRes LzmaEncode(Byte *dest, SizeT *destLen, const Byte *src, SizeT srcLen,
    const CLzmaEncProps *props, Byte *propsEncoded, SizeT *propsSize, int writeEndMark,
    ICompressProgress *progress, ISzAlloc *alloc, ISzAlloc *allocBig);

#endif

```

`Fatpack/Compessor/lzma/pavlov/LzmaLib.c`:

```c
/* LzmaLib.c -- LZMA library wrapper
2008-08-05
Igor Pavlov
Public domain */

#include "LzmaEnc.h"
#include "LzmaDec.h"
#include "Alloc.h"
#include "LzmaLib.h"

static void *SzAlloc(void *p, size_t size) { p = p; return MyAlloc(size); }
static void SzFree(void *p, void *address) { p = p; MyFree(address); }
static ISzAlloc g_Alloc = { SzAlloc, SzFree };

MY_STDAPI LzmaCompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  srcLen,
  unsigned char *outProps, size_t *outPropsSize,
  int level, /* 0 <= level <= 9, default = 5 */
  unsigned dictSize, /* use (1 << N) or (3 << N). 4 KB < dictSize <= 128 MB */
  int lc, /* 0 <= lc <= 8, default = 3  */
  int lp, /* 0 <= lp <= 4, default = 0  */
  int pb, /* 0 <= pb <= 4, default = 2  */
  int fb,  /* 5 <= fb <= 273, default = 32 */
  int numThreads /* 1 or 2, default = 2 */
)
{
  CLzmaEncProps props;
  LzmaEncProps_Init(&props);
  props.level = level;
  props.dictSize = dictSize;
  props.lc = lc;
  props.lp = lp;
  props.pb = pb;
  props.fb = fb;
  props.numThreads = numThreads;

  return LzmaEncode(dest, destLen, src, srcLen, &props, outProps, outPropsSize, 0,
      NULL, &g_Alloc, &g_Alloc);
}


MY_STDAPI LzmaUncompress(unsigned char *dest, size_t  *destLen, const unsigned char *src, size_t  *srcLen,
  const unsigned char *props, size_t propsSize)
{
  ELzmaStatus status;
  return LzmaDecode(dest, destLen, src, srcLen, props, (unsigned)propsSize, LZMA_FINISH_ANY, &status, &g_Alloc);
}

```

`Fatpack/Compessor/lzma/pavlov/LzmaLib.h`:

```h
/* LzmaLib.h -- LZMA library interface
2008-08-05
Igor Pavlov
Public domain */

#ifndef __LZMALIB_H
#define __LZMALIB_H

#include "Types.h"

#ifdef __cplusplus
  #define MY_EXTERN_C extern "C"
#else
  #define MY_EXTERN_C extern
#endif

#define MY_STDAPI MY_EXTERN_C int MY_STD_CALL

#define LZMA_PROPS_SIZE 5

/*
RAM requirements for LZMA:
  for compression:   (dictSize * 11.5 + 6 MB) + state_size
  for decompression: dictSize + state_size
    state_size = (4 + (1.5 << (lc + lp))) KB
    by default (lc=3, lp=0), state_size = 16 KB.

LZMA properties (5 bytes) format
    Offset Size  Description
      0     1    lc, lp and pb in encoded form.
      1     4    dictSize (little endian).
*/

/*
LzmaCompress
------------

outPropsSize -
     In:  the pointer to the size of outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.
     Out: the pointer to the size of written properties in outProps buffer; *outPropsSize = LZMA_PROPS_SIZE = 5.

  LZMA Encoder will use defult values for any parameter, if it is
  -1  for any from: level, loc, lp, pb, fb, numThreads
   0  for dictSize
  
level - compression level: 0 <= level <= 9;

  level dictSize algo  fb
    0:    16 KB   0    32
    1:    64 KB   0    32
    2:   256 KB   0    32
    3:     1 MB   0    32
    4:     4 MB   0    32
    5:    16 MB   1    32
    6:    32 MB   1    32
    7+:   64 MB   1    64
 
  The default value for "level" is 5.

  algo = 0 means fast method
  algo = 1 means normal method

dictSize - The dictionary size in bytes. The maximum value is
        128 MB = (1 << 27) bytes for 32-bit version
          1 GB = (1 << 30) bytes for 64-bit version
     The default value is 16 MB = (1 << 24) bytes.
     It's recommended to use the dictionary that is larger than 4 KB and
     that can be calculated as (1 << N) or (3 << N) sizes.

lc - The number of literal context bits (high bits of previous literal).
     It can be in the range from 0 to 8. The default value is 3.
     Sometimes lc=4 gives the gain for big files.

lp - The number of literal pos bits (low bits of current position for literals).
     It can be in the range from 0 to 4. The default value is 0.
     The lp switch is intended for periodical data when the period is equal to 2^lp.
     For example, for 32-bit (4 bytes) periodical data you can use lp=2. Often it's
     better to set lc=0, if you change lp switch.

pb - The number of pos bits (low bits of current position).
     It can be in the range from 0 to 4. The default value is 2.
     The pb switch is intended for periodical data when the period is equal 2^pb.

fb - Word size (the number of fast bytes).
     It can be in the range from 5 to 273. The default value is 32.
     Usually, a big number gives a little bit better compression ratio and
     slower compression process.

numThreads - The number of thereads. 1 or 2. The default value is 2.
     Fast mode (algo = 0) can use only 1 thread.

Out:
  destLen  - processed output size
Returns:
  SZ_OK               - OK
  SZ_ERROR_MEM        - Memory allocation error
  SZ_ERROR_PARAM      - Incorrect paramater
  SZ_ERROR_OUTPUT_EOF - output buffer overflow
  SZ_ERROR_THREAD     - errors in multithreading functions (only for Mt version)
*/

MY_STDAPI LzmaCompress(unsigned char *dest, size_t *destLen, const unsigned char *src, size_t srcLen,
  unsigned char *outProps, size_t *outPropsSize, /* *outPropsSize must be = 5 */
  int level,      /* 0 <= level <= 9, default = 5 */
  unsigned dictSize,  /* default = (1 << 24) */
  int lc,        /* 0 <= lc <= 8, default = 3  */
  int lp,        /* 0 <= lp <= 4, default = 0  */
  int pb,        /* 0 <= pb <= 4, default = 2  */
  int fb,        /* 5 <= fb <= 273, default = 32 */
  int numThreads /* 1 or 2, default = 2 */
  );

/*
LzmaUncompress
--------------
In:
  dest     - output data
  destLen  - output data size
  src      - input data
  srcLen   - input data size
Out:
  destLen  - processed output size
  srcLen   - processed input size
Returns:
  SZ_OK                - OK
  SZ_ERROR_DATA        - Data error
  SZ_ERROR_MEM         - Memory allocation arror
  SZ_ERROR_UNSUPPORTED - Unsupported properties
  SZ_ERROR_INPUT_EOF   - it needs more bytes in input buffer (src)
*/

MY_STDAPI LzmaUncompress(unsigned char *dest, size_t *destLen, const unsigned char *src, SizeT *srcLen,
  const unsigned char *props, size_t propsSize);

#endif

```

`Fatpack/Compessor/lzma/pavlov/Types.h`:

```h
/* Types.h -- Basic types
2008-11-23 : Igor Pavlov : Public domain */

#ifndef __7Z_TYPES_H
#define __7Z_TYPES_H

#include <stddef.h>

#ifdef _WIN32
#include <windows.h>
#endif

#define SZ_OK 0

#define SZ_ERROR_DATA 1
#define SZ_ERROR_MEM 2
#define SZ_ERROR_CRC 3
#define SZ_ERROR_UNSUPPORTED 4
#define SZ_ERROR_PARAM 5
#define SZ_ERROR_INPUT_EOF 6
#define SZ_ERROR_OUTPUT_EOF 7
#define SZ_ERROR_READ 8
#define SZ_ERROR_WRITE 9
#define SZ_ERROR_PROGRESS 10
#define SZ_ERROR_FAIL 11
#define SZ_ERROR_THREAD 12

#define SZ_ERROR_ARCHIVE 16
#define SZ_ERROR_NO_ARCHIVE 17

typedef int SRes;

#ifdef _WIN32
typedef DWORD WRes;
#else
typedef int WRes;
#endif

#ifndef RINOK
#define RINOK(x) { int __result__ = (x); if (__result__ != 0) return __result__; }
#endif

typedef unsigned char Byte;
typedef short Int16;
typedef unsigned short UInt16;

#ifdef _LZMA_UINT32_IS_ULONG
typedef long Int32;
typedef unsigned long UInt32;
#else
typedef int Int32;
typedef unsigned int UInt32;
#endif

#ifdef _SZ_NO_INT_64

/* define _SZ_NO_INT_64, if your compiler doesn't support 64-bit integers.
   NOTES: Some code will work incorrectly in that case! */

typedef long Int64;
typedef unsigned long UInt64;

#else

#if defined(_MSC_VER) || defined(__BORLANDC__)
typedef __int64 Int64;
typedef unsigned __int64 UInt64;
#else
typedef long long int Int64;
typedef unsigned long long int UInt64;
#endif

#endif

#ifdef _LZMA_NO_SYSTEM_SIZE_T
typedef UInt32 SizeT;
#else
typedef size_t SizeT;
#endif

typedef int Bool;
#define True 1
#define False 0


#ifdef _MSC_VER

#if _MSC_VER >= 1300
#define MY_NO_INLINE __declspec(noinline)
#else
#define MY_NO_INLINE
#endif

#define MY_CDECL __cdecl
#define MY_STD_CALL __stdcall
#define MY_FAST_CALL MY_NO_INLINE __fastcall

#else

#define MY_CDECL
#define MY_STD_CALL
#define MY_FAST_CALL

#endif


/* The following interfaces use first parameter as pointer to structure */

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) < input(*size)) is allowed */
} ISeqInStream;

/* it can return SZ_ERROR_INPUT_EOF */
SRes SeqInStream_Read(ISeqInStream *stream, void *buf, size_t size);
SRes SeqInStream_Read2(ISeqInStream *stream, void *buf, size_t size, SRes errorType);
SRes SeqInStream_ReadByte(ISeqInStream *stream, Byte *buf);

typedef struct
{
  size_t (*Write)(void *p, const void *buf, size_t size);
    /* Returns: result - the number of actually written bytes.
       (result < size) means error */
} ISeqOutStream;

typedef enum
{
  SZ_SEEK_SET = 0,
  SZ_SEEK_CUR = 1,
  SZ_SEEK_END = 2
} ESzSeek;

typedef struct
{
  SRes (*Read)(void *p, void *buf, size_t *size);  /* same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ISeekInStream;

typedef struct
{
  SRes (*Look)(void *p, void **buf, size_t *size);
    /* if (input(*size) != 0 && output(*size) == 0) means end_of_stream.
       (output(*size) > input(*size)) is not allowed
       (output(*size) < input(*size)) is allowed */
  SRes (*Skip)(void *p, size_t offset);
    /* offset must be <= output(*size) of Look */

  SRes (*Read)(void *p, void *buf, size_t *size);
    /* reads directly (without buffer). It's same as ISeqInStream::Read */
  SRes (*Seek)(void *p, Int64 *pos, ESzSeek origin);
} ILookInStream;

SRes LookInStream_LookRead(ILookInStream *stream, void *buf, size_t *size);
SRes LookInStream_SeekTo(ILookInStream *stream, UInt64 offset);

/* reads via ILookInStream::Read */
SRes LookInStream_Read2(ILookInStream *stream, void *buf, size_t size, SRes errorType);
SRes LookInStream_Read(ILookInStream *stream, void *buf, size_t size);

#define LookToRead_BUF_SIZE (1 << 14)

typedef struct
{
  ILookInStream s;
  ISeekInStream *realStream;
  size_t pos;
  size_t size;
  Byte buf[LookToRead_BUF_SIZE];
} CLookToRead;

void LookToRead_CreateVTable(CLookToRead *p, int lookahead);
void LookToRead_Init(CLookToRead *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToLook;

void SecToLook_CreateVTable(CSecToLook *p);

typedef struct
{
  ISeqInStream s;
  ILookInStream *realStream;
} CSecToRead;

void SecToRead_CreateVTable(CSecToRead *p);

typedef struct
{
  SRes (*Progress)(void *p, UInt64 inSize, UInt64 outSize);
    /* Returns: result. (result != SZ_OK) means break.
       Value (UInt64)(Int64)-1 for size means unknown value. */
} ICompressProgress;

typedef struct
{
  void *(*Alloc)(void *p, size_t size);
  void (*Free)(void *p, void *address); /* address can be 0 */
} ISzAlloc;

#define IAlloc_Alloc(p, size) (p)->Alloc((p), size)
#define IAlloc_Free(p, a) (p)->Free((p), a)

#endif

```

`Fatpack/Compessor/lzma/wrapper/easylzmawrapper.cpp`:

```cpp
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * simple.c - a wrapper around easylzma to compress/decompress to memory 
 */

#include <Windows.h>
#include "easylzmawrapper.h"

struct dataStream 
{
    const unsigned char * inData;
    size_t inLen;

    unsigned char * outData;
    size_t outLen;
};

static int
inputCallback(void *ctx, void *buf, size_t * size)
{
    size_t rd = 0;
    struct dataStream * ds = (struct dataStream *) ctx;
    
    rd = (ds->inLen < *size) ? ds->inLen : *size;

    if (rd > 0) {
        memcpy(buf, (void *) ds->inData, rd);
        ds->inData += rd;
        ds->inLen -= rd;
    }

    *size = rd;

    return 0;
}

static size_t
outputCallback(void *ctx, const void *buf, size_t size)
{
    struct dataStream * ds = (struct dataStream *) ctx;
    
    if (size > 0) {
        ds->outData = (unsigned char*)realloc(ds->outData, ds->outLen + size);
        memcpy((void *) (ds->outData + ds->outLen), buf, size);
        ds->outLen += size;
    }

    return size;
}

int
simpleCompress(elzma_file_format format, const unsigned char * inData,
               size_t inLen, unsigned char ** outData,
               size_t * outLen)
{
    int rc;
    elzma_compress_handle hand;

    /* allocate compression handle */
    hand = elzma_compress_alloc();

    rc = elzma_compress_config(hand, ELZMA_LC_DEFAULT,
                               ELZMA_LP_DEFAULT, ELZMA_PB_DEFAULT,
                               9, (1 << 20) /* 1mb */,
                               format, inLen);

    if (rc != ELZMA_E_OK) {
        elzma_compress_free(&hand);
        return rc;
    }    

    /* now run the compression */
    {
        struct dataStream ds;
        ds.inData = inData;
        ds.inLen = inLen;
        ds.outData = NULL;
        ds.outLen = 0;

        rc = elzma_compress_run(hand, inputCallback, (void *) &ds,
                                outputCallback, (void *) &ds,
                                NULL, NULL);
        
        if (rc != ELZMA_E_OK) {
            if (ds.outData != NULL) free(ds.outData);
            elzma_compress_free(&hand);
            return rc;
        }

        *outData = ds.outData;
        *outLen = ds.outLen;
    }

    return rc;
}

//int
//simpleDecompress(elzma_file_format format, const unsigned char * inData,
//                 size_t inLen, unsigned char ** outData,
//                 size_t * outLen)
//{
//    int rc;
//    elzma_decompress_handle hand;
//    
//    hand = elzma_decompress_alloc();
//    
//    /* now run the compression */
//    {
//        struct dataStream ds;
//        ds.inData = inData;
//        ds.inLen = inLen;
//        ds.outData = NULL;
//        ds.outLen = 0;
//
//        rc = elzma_decompress_run(hand, inputCallback, (void *) &ds,
//                                  outputCallback, (void *) &ds, format);
//        
//        if (rc != ELZMA_E_OK) {
//            if (ds.outData != NULL) free(ds.outData);
//            elzma_decompress_free(&hand);
//            return rc;
//        }
//        
//        *outData = ds.outData;
//        *outLen = ds.outLen;
//    }
//
//    return rc;
//}

```

`Fatpack/Compessor/lzma/wrapper/easylzmawrapper.h`:

```h
/*
 * Written in 2009 by Lloyd Hilaiel
 *
 * License
 * 
 * All the cruft you find here is public domain.  You don't have to credit
 * anyone to use this code, but my personal request is that you mention
 * Igor Pavlov for his hard, high quality work.
 *
 * simple.h - a wrapper around easylzma to compress/decompress to memory 
 */

#ifndef __SIMPLE_H__
#define __SIMPLE_H__

#include "..\easylzma\compress.h"
//#include "..\easylzma\decompress.h"

/* compress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
int simpleCompress(elzma_file_format format,
                   const unsigned char * inData,
                   size_t inLen,
                   unsigned char ** outData,
                   size_t * outLen);

/* decompress a chunk of memory and return a dynamically allocated buffer
 * if successful.  return value is an easylzma error code */
//int simpleDecompress(elzma_file_format format,
//                     const unsigned char * inData,
//                     size_t inLen,
//                     unsigned char ** outData,
//                     size_t * outLen);

#endif

```

`Fatpack/Console/Console.cpp`:

```cpp
#include "Console.h"

namespace Console
{
  Console::Console()
  {
  }

  Console::~Console()
  {
  }

  void Console::WriteLine(const wchar_t* text)
  {
    HANDLE consoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    if (consoleHandle == INVALID_HANDLE_VALUE) return;

    DWORD written = 0;
    WriteConsoleW(consoleHandle, text, (DWORD)wcslen(text), &written, NULL);
    WriteConsoleW(consoleHandle, L"\n", 1, &written, NULL);
  }
}
```

`Fatpack/Console/Console.h`:

```h
#pragma once
#include <Windows.h>

namespace Console
{
  class Console
  {
  public:
    Console();
    ~Console();

    void WriteLine(const wchar_t* text);
  };
}
```

`Fatpack/Fatpack.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{23b3307d-097a-4f6f-bd3d-ab61bea6d30c}</ProjectGuid>
    <RootNamespace>Fatpack</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Fatpack\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Fatpack\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary />
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:threadSafeInit- /Gs10000000 %(AdditionalOptions)</AdditionalOptions>
      <ExceptionHandling>false</ExceptionHandling>
      <IntrinsicFunctions>true</IntrinsicFunctions>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <EntryPointSymbol>main</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EnableUAC>false</EnableUAC>
    </Link>
    <PostBuildEvent>
      <Command>call PostBuildStep_Debug.bat</Command>
      <Message>Adding loader stubs to fatpack.exe as resource...</Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <RuntimeLibrary />
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <ExceptionHandling>false</ExceptionHandling>
      <WholeProgramOptimization>false</WholeProgramOptimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>/DEBUG:NONE /EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <EntryPointSymbol>main</EntryPointSymbol>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EnableUAC>false</EnableUAC>
    </Link>
    <PostBuildEvent>
      <Message>Adding loader stubs to fatpack.exe as resource...</Message>
      <Command>call PostBuildStep_Release.bat</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\BinaryFileReader\BinaryFileReader.cpp" />
    <ClCompile Include="..\Shared\CRT\crt.cpp" />
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp" />
    <ClCompile Include="BinaryFileWriter\BinaryFileWriter.cpp" />
    <ClCompile Include="CommandLine\CommandLine.cpp" />
    <ClCompile Include="Compessor\Compressor.cpp" />
    <ClCompile Include="Compessor\lzma\common_internal.c" />
    <ClCompile Include="Compessor\lzma\compress.c" />
    <ClCompile Include="Compessor\lzma\decompress.c" />
    <ClCompile Include="Compessor\lzma\lzip_header.c" />
    <ClCompile Include="Compessor\lzma\lzma_header.c" />
    <ClCompile Include="Compessor\lzma\pavlov\7zBuf.c" />
    <ClCompile Include="Compessor\lzma\pavlov\7zBuf2.c" />
    <ClCompile Include="Compessor\lzma\pavlov\7zCrc.c" />
    <ClCompile Include="Compessor\lzma\pavlov\7zFile.c" />
    <ClCompile Include="Compessor\lzma\pavlov\7zStream.c" />
    <ClCompile Include="Compessor\lzma\pavlov\Alloc.c" />
    <ClCompile Include="Compessor\lzma\pavlov\Bcj2.c" />
    <ClCompile Include="Compessor\lzma\pavlov\Bra.c" />
    <ClCompile Include="Compessor\lzma\pavlov\Bra86.c" />
    <ClCompile Include="Compessor\lzma\pavlov\BraIA64.c" />
    <ClCompile Include="Compessor\lzma\pavlov\LzFind.c" />
    <ClCompile Include="Compessor\lzma\pavlov\LzmaDec.c" />
    <ClCompile Include="Compessor\lzma\pavlov\LzmaEnc.c" />
    <ClCompile Include="Compessor\lzma\pavlov\LzmaLib.c" />
    <ClCompile Include="Compessor\lzma\wrapper\easylzmawrapper.cpp" />
    <ClCompile Include="Console\Console.cpp" />
    <ClCompile Include="IconExtractor\IconExtractor.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="ManifestExtractor\ManifestExtractor.cpp" />
    <ClCompile Include="PEFile\PEFile.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\BinaryFileReader\BinaryFileReader.h" />
    <ClInclude Include="..\Shared\CRT\crt.h" />
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h" />
    <ClInclude Include="BinaryFileWriter\BinaryFileWriter.h" />
    <ClInclude Include="CommandLine\CommandLine.h" />
    <ClInclude Include="Compessor\Compressor.h" />
    <ClInclude Include="Compessor\lzma\common_internal.h" />
    <ClInclude Include="Compessor\lzma\easylzma\common.h" />
    <ClInclude Include="Compessor\lzma\easylzma\compress.h" />
    <ClInclude Include="Compessor\lzma\easylzma\decompress.h" />
    <ClInclude Include="Compessor\lzma\lzip_header.h" />
    <ClInclude Include="Compessor\lzma\lzma_header.h" />
    <ClInclude Include="Compessor\lzma\pavlov\7zBuf.h" />
    <ClInclude Include="Compessor\lzma\pavlov\7zCrc.h" />
    <ClInclude Include="Compessor\lzma\pavlov\7zFile.h" />
    <ClInclude Include="Compessor\lzma\pavlov\7zVersion.h" />
    <ClInclude Include="Compessor\lzma\pavlov\Alloc.h" />
    <ClInclude Include="Compessor\lzma\pavlov\Bcj2.h" />
    <ClInclude Include="Compessor\lzma\pavlov\Bra.h" />
    <ClInclude Include="Compessor\lzma\pavlov\CpuArch.h" />
    <ClInclude Include="Compessor\lzma\pavlov\LzFind.h" />
    <ClInclude Include="Compessor\lzma\pavlov\LzHash.h" />
    <ClInclude Include="Compessor\lzma\pavlov\LzmaDec.h" />
    <ClInclude Include="Compessor\lzma\pavlov\LzmaEnc.h" />
    <ClInclude Include="Compessor\lzma\pavlov\LzmaLib.h" />
    <ClInclude Include="Compessor\lzma\pavlov\Types.h" />
    <ClInclude Include="Compessor\lzma\wrapper\easylzmawrapper.h" />
    <ClInclude Include="Console\Console.h" />
    <ClInclude Include="IconExtractor\IconExtractor.h" />
    <ClInclude Include="ManifestExtractor\ManifestExtractor.h" />
    <ClInclude Include="PEFile\PEFile.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Fatpack/Fatpack.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="..\Shared\CRT\crt.cpp">
      <Filter>CRT</Filter>
    </ClCompile>
    <ClCompile Include="Console\Console.cpp">
      <Filter>Console</Filter>
    </ClCompile>
    <ClCompile Include="CommandLine\CommandLine.cpp">
      <Filter>CommandLine</Filter>
    </ClCompile>
    <ClCompile Include="IconExtractor\IconExtractor.cpp">
      <Filter>IconExtractor</Filter>
    </ClCompile>
    <ClCompile Include="ManifestExtractor\ManifestExtractor.cpp">
      <Filter>ManifestExtractor</Filter>
    </ClCompile>
    <ClCompile Include="PEFile\PEFile.cpp">
      <Filter>PEFile</Filter>
    </ClCompile>
    <ClCompile Include="BinaryFileWriter\BinaryFileWriter.cpp">
      <Filter>BinaryFileWriter</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp">
      <Filter>ResourceLoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\BinaryFileReader\BinaryFileReader.cpp">
      <Filter>BinaryFileReader</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\Compressor.cpp">
      <Filter>Compressor</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\7zBuf.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\7zBuf2.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\7zCrc.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\7zFile.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\7zStream.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\Alloc.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\Bcj2.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\Bra.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\Bra86.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\BraIA64.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\LzFind.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\LzmaDec.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\LzmaEnc.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\pavlov\LzmaLib.c">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\wrapper\easylzmawrapper.cpp">
      <Filter>Compressor\lzma\wrapper</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\common_internal.c">
      <Filter>Compressor\lzma</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\compress.c">
      <Filter>Compressor\lzma</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\lzip_header.c">
      <Filter>Compressor\lzma</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\lzma_header.c">
      <Filter>Compressor\lzma</Filter>
    </ClCompile>
    <ClCompile Include="Compessor\lzma\decompress.c">
      <Filter>Compressor\lzma</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="CRT">
      <UniqueIdentifier>{a2999939-ea34-4455-af39-063347463b0c}</UniqueIdentifier>
    </Filter>
    <Filter Include="Console">
      <UniqueIdentifier>{cec1ec72-7f64-4660-84c0-caead896c09f}</UniqueIdentifier>
    </Filter>
    <Filter Include="CommandLine">
      <UniqueIdentifier>{02a59476-092a-44d2-973a-58f233616c20}</UniqueIdentifier>
    </Filter>
    <Filter Include="IconExtractor">
      <UniqueIdentifier>{1e245d88-6658-475d-94fd-a8691fa45eab}</UniqueIdentifier>
    </Filter>
    <Filter Include="ManifestExtractor">
      <UniqueIdentifier>{25cfdf53-d451-4031-be65-e3aed107cfc0}</UniqueIdentifier>
    </Filter>
    <Filter Include="PEFile">
      <UniqueIdentifier>{d840e5ea-083e-4705-a778-47efe5b20309}</UniqueIdentifier>
    </Filter>
    <Filter Include="BinaryFileWriter">
      <UniqueIdentifier>{2474d084-96aa-4e14-8eea-1cba04a3beee}</UniqueIdentifier>
    </Filter>
    <Filter Include="ResourceLoader">
      <UniqueIdentifier>{fa985a2c-d723-4564-98bb-25b40c404b25}</UniqueIdentifier>
    </Filter>
    <Filter Include="BinaryFileReader">
      <UniqueIdentifier>{e850630a-daeb-4e1a-a990-4a3087359d36}</UniqueIdentifier>
    </Filter>
    <Filter Include="Compressor">
      <UniqueIdentifier>{d529fa72-0d8b-4891-9675-1a8c84bfef68}</UniqueIdentifier>
    </Filter>
    <Filter Include="Compressor\lzma">
      <UniqueIdentifier>{dfdda02a-28ed-4ec2-bea3-d3f1d7516f42}</UniqueIdentifier>
    </Filter>
    <Filter Include="Compressor\lzma\easylzma">
      <UniqueIdentifier>{13b8ba1b-c51e-4f62-aafe-21490509db4b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Compressor\lzma\pavlov">
      <UniqueIdentifier>{99a76fb0-8f9a-4379-bbb1-bf592251d90f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Compressor\lzma\wrapper">
      <UniqueIdentifier>{b3a89139-3bfd-4a54-8917-fe3614c8e247}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\CRT\crt.h">
      <Filter>CRT</Filter>
    </ClInclude>
    <ClInclude Include="Console\Console.h">
      <Filter>Console</Filter>
    </ClInclude>
    <ClInclude Include="CommandLine\CommandLine.h">
      <Filter>CommandLine</Filter>
    </ClInclude>
    <ClInclude Include="IconExtractor\IconExtractor.h">
      <Filter>IconExtractor</Filter>
    </ClInclude>
    <ClInclude Include="ManifestExtractor\ManifestExtractor.h">
      <Filter>ManifestExtractor</Filter>
    </ClInclude>
    <ClInclude Include="PEFile\PEFile.h">
      <Filter>PEFile</Filter>
    </ClInclude>
    <ClInclude Include="BinaryFileWriter\BinaryFileWriter.h">
      <Filter>BinaryFileWriter</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h">
      <Filter>ResourceLoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\BinaryFileReader\BinaryFileReader.h">
      <Filter>BinaryFileReader</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\Compressor.h">
      <Filter>Compressor</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\easylzma\common.h">
      <Filter>Compressor\lzma\easylzma</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\easylzma\compress.h">
      <Filter>Compressor\lzma\easylzma</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\7zBuf.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\7zCrc.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\7zFile.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\7zVersion.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\Alloc.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\Bcj2.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\Bra.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\CpuArch.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\LzFind.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\LzHash.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\LzmaDec.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\LzmaEnc.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\LzmaLib.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\pavlov\Types.h">
      <Filter>Compressor\lzma\pavlov</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\wrapper\easylzmawrapper.h">
      <Filter>Compressor\lzma\wrapper</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\common_internal.h">
      <Filter>Compressor\lzma</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\lzip_header.h">
      <Filter>Compressor\lzma</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\lzma_header.h">
      <Filter>Compressor\lzma</Filter>
    </ClInclude>
    <ClInclude Include="Compessor\lzma\easylzma\decompress.h">
      <Filter>Compressor\lzma\easylzma</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Fatpack/IconExtractor/IconExtractor.cpp`:

```cpp
#include "IconExtractor.h"

namespace IconExtractor
{
#pragma pack(push, 1)
  typedef struct
  {
    BYTE  Width, Height, ColorCount, Reserved;
    WORD  Planes, BitCount;
    DWORD BytesInRes;
    WORD  ID;
  } ICONENTRY;

  typedef struct
  {
    WORD Reserved, Type, Count;
    ICONENTRY Entries[1]; // Variable length
  } ICONGROUP;
#pragma pack(pop)

  IconExtractor::IconExtractor()
  {
  }

  IconExtractor::~IconExtractor()
  {
  }

  bool IconExtractor::ExtractAndSetIcon(LPWSTR sourceExe, LPWSTR targetExe)
  {
    HMODULE sourceModuleHandle = LoadLibraryExW(sourceExe, nullptr, LOAD_LIBRARY_AS_DATAFILE);
    if (!sourceModuleHandle)
    {
      return false;
    }

    LPCWSTR groupIconName = nullptr;
    EnumResourceNames(sourceModuleHandle, RT_GROUP_ICON, EnumResNameProc, (LONG_PTR)&groupIconName);

    if (!groupIconName)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    HRSRC groupIconHandle = FindResource(sourceModuleHandle, groupIconName, RT_GROUP_ICON);
    if (!groupIconHandle)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    HGLOBAL groupIconDataHandle = LoadResource(sourceModuleHandle, groupIconHandle);
    if (!groupIconDataHandle)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    LPVOID groupIconData = LockResource(groupIconDataHandle);
    DWORD groupIconSize = SizeofResource(sourceModuleHandle, groupIconHandle);

    HANDLE updateHandle = BeginUpdateResourceW(targetExe, FALSE);
    if (!updateHandle)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    // Update the icon group resource
    if (!UpdateResource(updateHandle, RT_GROUP_ICON, groupIconName, MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), groupIconData, groupIconSize))
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    ICONGROUP* iconGroup = (ICONGROUP*)groupIconData;
    for (int i = 0; i < iconGroup->Count; i++)
    {
      WORD iconId = iconGroup->Entries[i].ID;
      HRSRC iconHandle = FindResource(sourceModuleHandle, MAKEINTRESOURCE(iconId), RT_ICON);
      if (iconHandle)
      {
        HGLOBAL iconDataHandle = LoadResource(sourceModuleHandle, iconHandle);
        if (iconDataHandle)
        {
          LPVOID iconData = LockResource(iconDataHandle);
          DWORD iconSize = SizeofResource(sourceModuleHandle, iconHandle);

          if (!UpdateResource(updateHandle, RT_ICON, MAKEINTRESOURCE(iconId), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), iconData, iconSize))
          {
            return false;
          }
        }
      }
    }

    // Finalize the update
    if (!EndUpdateResource(updateHandle, FALSE))
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    FreeLibrary(sourceModuleHandle);

    return true;
  }

  bool IconExtractor::ExtractAndSetIconWithCustomIds(LPWSTR sourceExe, LPWSTR targetExe)
  {
    HMODULE sourceModuleHandle = LoadLibraryExW(sourceExe, nullptr, LOAD_LIBRARY_AS_DATAFILE);
    if (!sourceModuleHandle)
    {
      return false;
    }

    LPCWSTR groupIconName = nullptr;
    EnumResourceNames(sourceModuleHandle, RT_GROUP_ICON, EnumResNameProc, (LONG_PTR)&groupIconName);

    if (!groupIconName)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    // Find and load the RT_GROUP_ICON resource
    HRSRC groupIconHandle = FindResource(sourceModuleHandle, groupIconName, RT_GROUP_ICON);
    if (!groupIconHandle)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    HGLOBAL groupIconDataHandle = LoadResource(sourceModuleHandle, groupIconHandle);
    if (!groupIconDataHandle)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    ICONGROUP* groupIcon = (ICONGROUP*)LockResource(groupIconDataHandle);
    DWORD groupIconSize = SizeofResource(sourceModuleHandle, groupIconHandle);

    // Create a copy of the RT_GROUP_ICON structure to modify it
    DWORD newGroupIconSize = sizeof(ICONGROUP) + (groupIcon->Count - 1) * sizeof(ICONENTRY);
    ICONGROUP* newGroupIcon = (ICONGROUP*)malloc(newGroupIconSize);
    if (!newGroupIcon)
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    // Copy original RT_GROUP_ICON data
    memcpy(newGroupIcon, groupIcon, newGroupIconSize);

    HANDLE updataHandle = BeginUpdateResourceW(targetExe, FALSE);
    if (!updataHandle)
    {
      FreeLibrary(sourceModuleHandle);
      free(newGroupIcon);
      return false;
    }

    // Update the icon group with a new ID
    if (!UpdateResource(updataHandle, RT_GROUP_ICON, MAKEINTRESOURCE(CUSTOM_ICON_GROUP_ID), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), newGroupIcon, newGroupIconSize))
    {
      FreeLibrary(sourceModuleHandle);
      free(newGroupIcon);
      return false;
    }

    // Extract and update RT_ICON resources with new IDs
    for (int i = 0; i < groupIcon->Count; i++)
    {
      WORD oldIconId = groupIcon->Entries[i].ID;
      WORD newIconId = CUSTOM_ICON_BASE_ID + i;

      HRSRC oldIconHandle = FindResource(sourceModuleHandle, MAKEINTRESOURCE(oldIconId), RT_ICON);
      if (oldIconHandle)
      {
        HGLOBAL oldIconDataHandle = LoadResource(sourceModuleHandle, oldIconHandle);
        if (oldIconDataHandle)
        {
          LPVOID oldIconData = LockResource(oldIconDataHandle);
          DWORD oldIconSize = SizeofResource(sourceModuleHandle, oldIconHandle);

          if (UpdateResource(updataHandle, RT_ICON, MAKEINTRESOURCE(newIconId), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), oldIconData, oldIconSize))
          {
            // Modify the RT_GROUP_ICON to reference new IDs
            newGroupIcon->Entries[i].ID = newIconId;
          }
        }
      }
    }

    // Update RT_GROUP_ICON with corrected icon IDs
    if (!UpdateResource(updataHandle, RT_GROUP_ICON, MAKEINTRESOURCE(CUSTOM_ICON_GROUP_ID), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), newGroupIcon, newGroupIconSize))
    {
      FreeLibrary(sourceModuleHandle);
      free(newGroupIcon);
      return false;
    }

    // Finalize the update
    if (!EndUpdateResource(updataHandle, FALSE))
    {
      FreeLibrary(sourceModuleHandle);
      free(newGroupIcon);
      return false;
    }

    FreeLibrary(sourceModuleHandle);
    free(newGroupIcon);

    return true;
  }

  BOOL CALLBACK IconExtractor::EnumResNameProc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam)
  {
    if (lpType == RT_GROUP_ICON)
    {
      *((LPWSTR*)lParam) = lpName;
      return FALSE; // Stop after finding the first icon
    }
    return TRUE;
  }
}
```

`Fatpack/IconExtractor/IconExtractor.h`:

```h
#pragma once
#include <Windows.h>

#define CUSTOM_ICON_GROUP_ID 100 // Custom ID for RT_GROUP_ICON
#define CUSTOM_ICON_BASE_ID  101 // Custom base ID for RT_ICON entries

namespace IconExtractor
{
  class IconExtractor
  {
  public:
    IconExtractor();
    ~IconExtractor();

    bool ExtractAndSetIcon(LPWSTR sourceExe, LPWSTR targetExe);
    bool ExtractAndSetIconWithCustomIds(LPWSTR sourceExe, LPWSTR targetExe);

    private:
      static BOOL CALLBACK EnumResNameProc(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam);
  };
}
```

`Fatpack/ManifestExtractor/ManifestExtractor.cpp`:

```cpp
#include <windows.h>
#include "ManifestExtractor.h"

namespace ManifestExtractor
{
  ManifestResource* ManifestExtractor::_manifestResources = nullptr;
  DWORD ManifestExtractor::_manifestCount = 0;

  ManifestExtractor::ManifestExtractor()
  {
    _heapHandle = GetProcessHeap();
    _manifestResources = (ManifestResource*)HeapAlloc(_heapHandle, HEAP_ZERO_MEMORY, MAX_MANIFEST_RESOURCES * sizeof(ManifestResource));
    _manifestCount = 0;
  }

  ManifestExtractor::~ManifestExtractor()
  {
    if (_manifestResources)
    {
      HeapFree(_heapHandle, 0, _manifestResources);
      _manifestResources = nullptr;
    }
    _manifestCount = 0;
  }

  bool ManifestExtractor::ExtractManifestResources(LPWSTR fileName)
  {
    _manifestCount = 0;

    HMODULE sourceModuleHandle = LoadLibraryExW(fileName, nullptr, LOAD_LIBRARY_AS_DATAFILE);
    if (!sourceModuleHandle)
    {
      return false;
    }

    if (!EnumResourceNames(sourceModuleHandle, MANIFEST_RESOURCE_TYPE, EnumResNameProc, 0))
    {
      FreeLibrary(sourceModuleHandle);
      return false;
    }

    return (_manifestCount > 0);
  }

  bool ManifestExtractor::AddManifestResourcesToTarget(LPWSTR destinationPath)
  {
    HANDLE updateHandle = BeginUpdateResourceW(destinationPath, FALSE);
    if (!updateHandle)
    {
      return false;
    }

    for (DWORD i = 0; i < _manifestCount; ++i)
    {
      ManifestResource& res = _manifestResources[i];
      if (!UpdateResource(updateHandle, MANIFEST_RESOURCE_TYPE, MAKEINTRESOURCE(res.id), res.lang, res.data, res.size))
      {
        EndUpdateResource(updateHandle, TRUE);
        return false;
      }
    }

    if (!EndUpdateResource(updateHandle, FALSE))
    {
      return false;
    }

    return true;
  }

  BOOL CALLBACK ManifestExtractor::EnumResNameProc(HMODULE moduleHandle, LPCTSTR type, LPTSTR name, LONG_PTR param)
  {
    EnumResourceLanguages(moduleHandle, type, name, EnumResLangProc, param);
    return TRUE;
  }

  BOOL CALLBACK ManifestExtractor::EnumResLangProc(HMODULE moduleHandle, LPCTSTR type, LPCTSTR name, WORD language, LONG_PTR param)
  {
    if (_manifestCount >= MAX_MANIFEST_RESOURCES)
    {
      return FALSE; // Stop enumeration
    }

    HRSRC hRes = FindResourceEx(moduleHandle, type, name, language);
    if (!hRes) return TRUE;

    DWORD resourceSize = SizeofResource(moduleHandle, hRes);
    HGLOBAL resourceDataHandle = LoadResource(moduleHandle, hRes);
    LPVOID resourceData = LockResource(resourceDataHandle);

    if (resourceData && resourceSize > 0)
    {
      ManifestResource& res = _manifestResources[_manifestCount++];
      res.id = (WORD)(IS_INTRESOURCE(name) ? (WORD)(uintptr_t)name : 1);
      res.lang = language;
      res.size = resourceSize;
      res.data = resourceData;
    }

    return TRUE; // Continue enumeration
  }
}
```

`Fatpack/ManifestExtractor/ManifestExtractor.h`:

```h
#pragma once
#include <Windows.h>

namespace ManifestExtractor
{
#define MANIFEST_RESOURCE_TYPE RT_MANIFEST  // RT_MANIFEST = MAKEINTRESOURCE(24)
#define MAX_MANIFEST_RESOURCES 64

  struct ManifestResource
  {
    WORD id;
    WORD lang;
    DWORD size;
    LPVOID data;
  };

  class ManifestExtractor
  {
  public:
    ManifestExtractor();
    ~ManifestExtractor();

    bool ExtractManifestResources(LPWSTR srcPath);
    bool AddManifestResourcesToTarget(LPWSTR destPath);

    private:
      static BOOL CALLBACK EnumResNameProc(HMODULE moduleHandle, LPCTSTR type, LPTSTR name, LONG_PTR param);
      static BOOL CALLBACK EnumResLangProc(HMODULE moduleHandle, LPCTSTR type, LPCTSTR name, WORD language, LONG_PTR param);

  private:
    static ManifestResource* _manifestResources;
    static DWORD _manifestCount;
    HANDLE _heapHandle;
  };
}
```

`Fatpack/PEFile/PEFile.cpp`:

```cpp
#include "PEFile.h"

namespace PEFile
{
  PEFile::PEFile()
  {
    _buffer = nullptr;
    _bufferSize = 0;
    _PIMAGE_DOS_HEADER = nullptr;
    _PIMAGE_NT_HEADERS = nullptr;
    _PIMAGE_SECTION_HEADER = nullptr;
  }

  PEFile::~PEFile()
  {
    DeleteBuffer();
  }

  bool PEFile::LoadFromBuffer(BYTE* fileBuffer, DWORD size)
  {
    if (fileBuffer == nullptr || size == 0) return false;

    DeleteBuffer();
    _bufferSize = size;
    _buffer = new BYTE[_bufferSize];
    memcpy(_buffer, fileBuffer, _bufferSize);

    _PIMAGE_DOS_HEADER = (PIMAGE_DOS_HEADER)_buffer;
    _PIMAGE_NT_HEADERS = (PIMAGE_NT_HEADERS)(_buffer + _PIMAGE_DOS_HEADER->e_lfanew);
    _PIMAGE_SECTION_HEADER = IMAGE_FIRST_SECTION(_PIMAGE_NT_HEADERS);

    return true;
  }

  ULONGLONG PEFile::GetImageBase()
  {
    if (_buffer == nullptr || _bufferSize == 0) return 0;
    return _PIMAGE_NT_HEADERS->OptionalHeader.ImageBase;
  }

  DWORD PEFile::GetSizeOfImage()
  {
    if (_buffer == nullptr || _bufferSize == 0) return 0;
    return _PIMAGE_NT_HEADERS->OptionalHeader.SizeOfImage;
  }

  bool PEFile::IsPEFile()
  {
    if (_buffer == nullptr || _bufferSize == 0) return false;
    return (_PIMAGE_DOS_HEADER->e_magic == IMAGE_DOS_SIGNATURE && _PIMAGE_NT_HEADERS->Signature == IMAGE_NT_SIGNATURE);
  }

  bool PEFile::Isx64()
  {
    if (_buffer == nullptr || _bufferSize == 0) return false;
    return (_PIMAGE_NT_HEADERS->FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64);
  }

  bool PEFile::IsNative()
  {
    if (_buffer == nullptr || _bufferSize == 0) return false;
    if (!Isx64()) return false;
    PIMAGE_DATA_DIRECTORY comDirectory = &_PIMAGE_NT_HEADERS->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR];
    return (comDirectory->VirtualAddress == 0 && comDirectory->Size == 0);
  }

  bool PEFile::IsConsole()
  {
    if (_buffer == nullptr || _bufferSize == 0) return false;
    if (!Isx64()) return false;
    return (_PIMAGE_NT_HEADERS->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI);
  }

  bool PEFile::IntersectsWith(PEFile& other)
  {
    auto imageBase = GetImageBase();
    auto imageEnd = imageBase + GetSizeOfImage();
    auto otherImageBase = other.GetImageBase();
    auto otherImageEnd = otherImageBase + other.GetSizeOfImage();

    if (imageBase == otherImageBase) return true;
    if (otherImageBase >= imageBase && otherImageBase <= imageEnd) return true;
    if (otherImageBase <= imageBase && otherImageEnd >= imageBase) return true;

    return false;
  }

  bool PEFile::HasRelocationTable()
  {
    if (_buffer == nullptr || _bufferSize == 0) return false;

    DWORD size = _PIMAGE_NT_HEADERS->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size;
    DWORD virtualAddress = _PIMAGE_NT_HEADERS->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress;
    return (size != 0 && virtualAddress != 0);
  }

  ULONGLONG PEFile::GetNextImageBase()
  {
    if (_buffer == nullptr || _bufferSize == 0) return 0;

    ULONGLONG result = 0;
    const DWORD imageBaseAlignment = 0x00010000; // ImageBase must be a multiple of 64 K

    ULONGLONG endOfImage = GetImageBase() + GetSizeOfImage();
    if (endOfImage % imageBaseAlignment == 0)
    {
      result = endOfImage;
    }
    else
    {
      result = imageBaseAlignment * ((endOfImage / imageBaseAlignment) + 1);
    }
    return result;
  }

  bool PEFile::Rebase(ULONGLONG newImageBase)
  {
    if (!ApplyRelocations(newImageBase)) return false;
    SetImageBase(newImageBase);
    StripRelocations();
    return true;
  }

  bool PEFile::ApplyRelocations(ULONGLONG imageBase)
  {
    if (_buffer == nullptr || _bufferSize == 0 || !HasRelocationTable() || imageBase == GetImageBase()) return false;

    ULONGLONG baseDelta = (ULONGLONG)(imageBase - GetImageBase());
    if (baseDelta == 0) return false;

    PIMAGE_DATA_DIRECTORY relocDir = &NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if (relocDir->Size == 0) return false;

    PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)(GetRawAddress(Rva2RawOffset(relocDir->VirtualAddress)));
    while (reloc->VirtualAddress && reloc->SizeOfBlock)
    {
      int numEntries = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
      PWORD relocEntries = (PWORD)((BYTE*)reloc + sizeof(IMAGE_BASE_RELOCATION));

      for (int i = 0; i < numEntries; i++)
      {
        WORD type = relocEntries[i] >> 12;
        WORD offset = relocEntries[i] & 0xFFF;

        switch (type)
        {
          case IMAGE_REL_BASED_ABSOLUTE:
            break;

          case IMAGE_REL_BASED_DIR64:
          {
            ULONGLONG* patchAddr = (ULONGLONG*)(GetRawAddress(Rva2RawOffset(reloc->VirtualAddress)) + offset);
            *patchAddr += baseDelta;
            break;
          }
          default:
            break;
        }
      }

      reloc = (PIMAGE_BASE_RELOCATION)((BYTE*)reloc + reloc->SizeOfBlock);
    }

    return true;
  }

  void PEFile::SetImageBase(ULONGLONG imageBase)
  {
    if (_buffer == nullptr || _bufferSize == 0) return;

    NT_HEADERS()->OptionalHeader.ImageBase = imageBase;
  }

  void PEFile::StripRelocations()
  {
    if (_buffer == nullptr || _bufferSize == 0 || !HasRelocationTable()) return;

    DOS_HEADER()->e_crlc = 0;

    NT_HEADERS()->FileHeader.Characteristics |= IMAGE_FILE_RELOCS_STRIPPED;
    NT_HEADERS()->OptionalHeader.DllCharacteristics &= ~IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE;
    NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].Size = 0;
    NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;

    // To do (optional): Remove section from pe file if its the last section to save some extra bytes
  }

  DWORD PEFile::Rva2RawOffset(DWORD rva)
  {
    WORD sectionCount = NT_HEADERS()->FileHeader.NumberOfSections;
    PIMAGE_SECTION_HEADER sectionHeader = SECTION_HEADER();
    for (int i = 0; i < sectionCount; i++, sectionHeader++)
    {
      DWORD startOfSection = sectionHeader->VirtualAddress;
      DWORD endOfSection = sectionHeader->VirtualAddress + sectionHeader->SizeOfRawData;
      if (rva >= startOfSection && rva <= endOfSection)
      {
        DWORD relativeOffset = rva - startOfSection;
        DWORD rawOffset = sectionHeader->PointerToRawData + relativeOffset;
        return rawOffset;
      }
    }
    return -1;
  }

  DWORD64 PEFile::GetRawAddress(DWORD rawOffset)
  {
    return (DWORD64)((BYTE*)DOS_HEADER() + rawOffset);
  }

  void PEFile::DeleteBuffer()
  {
    if (_buffer != nullptr)
    {
      delete[] _buffer;
      _buffer = nullptr;
    }
  }
}
```

`Fatpack/PEFile/PEFile.h`:

```h
#pragma once
#include <windows.h>

namespace PEFile
{
  class PEFile
  {
  public:
    PEFile();
    ~PEFile();

    bool LoadFromBuffer(BYTE* fileBuffer, DWORD size);
    DWORD GetBufferSize() { return _bufferSize; }
    BYTE* GetBuffer() { return _buffer; }

    const PIMAGE_DOS_HEADER DOS_HEADER() { return _PIMAGE_DOS_HEADER; }
    const PIMAGE_NT_HEADERS NT_HEADERS() { return _PIMAGE_NT_HEADERS; }
    const PIMAGE_SECTION_HEADER SECTION_HEADER() { return _PIMAGE_SECTION_HEADER; }

    ULONGLONG GetImageBase();
    DWORD GetSizeOfImage();

    bool IsPEFile();    
    bool Isx64();
    bool IsNative();
    bool IsConsole();

    bool IntersectsWith(PEFile& other);
    bool HasRelocationTable();
    ULONGLONG GetNextImageBase();
    bool Rebase(ULONGLONG newImageBase);

  private:

    bool ApplyRelocations(ULONGLONG imageBase);
    void SetImageBase(ULONGLONG imageBase);
    void StripRelocations();

    DWORD Rva2RawOffset(DWORD rva);
    DWORD64 GetRawAddress(DWORD rawOffset);
    
    void DeleteBuffer();

  private:
    BYTE* _buffer;
    DWORD _bufferSize;

    PIMAGE_DOS_HEADER _PIMAGE_DOS_HEADER;
    PIMAGE_NT_HEADERS _PIMAGE_NT_HEADERS;
    PIMAGE_SECTION_HEADER _PIMAGE_SECTION_HEADER;
  };
}
```

`Fatpack/PostBuildStep_Debug.bat`:

```bat
cd..
cd build
cd x64
cd Debug

START /WAIT ResourceAdder Loader_Console.exe Fatpack.exe 1000
powershell -command "Start-Sleep -Milliseconds 1000"
START /WAIT ResourceAdder Loader_Windows.exe Fatpack.exe 1001
powershell -command "Start-Sleep -Milliseconds 1000"
```

`Fatpack/PostBuildStep_Release.bat`:

```bat
cd..
cd build
cd x64
cd Release

START /WAIT ResourceAdder Loader_Console.exe Fatpack.exe 1000
powershell -command "Start-Sleep -Milliseconds 1000"
START /WAIT ResourceAdder Loader_Windows.exe Fatpack.exe 1001
powershell -command "Start-Sleep -Milliseconds 1000"
```

`Fatpack/main.cpp`:

```cpp
#include "Console\Console.h"
#include "CommandLine\CommandLine.h"
#include "PEFile\PEFile.h"
#include "..\Shared\BinaryFileReader\BinaryFileReader.h"
#include "BinaryFileWriter\BinaryFileWriter.h"
#include "IconExtractor\IconExtractor.h"
#include "ManifestExtractor\ManifestExtractor.h"
#include "..\Shared\ResourceLoader\ResourceLoader.h"
#include "Compessor\Compressor.h"

bool GetCommandLine(LPWSTR& inputFileName, LPWSTR& outputFileName);
bool ReadInputFile(LPWSTR inputFileName, PEFile::PEFile& inputFile);
bool IsInputFileSupported(PEFile::PEFile& inputFile);
bool LoadPELoaderFromResource(PEFile::PEFile& peLoader, bool useConsoleStub);
bool RebasePELoader(PEFile::PEFile& inputFile, PEFile::PEFile& peLoader);
bool SavePELoader(PEFile::PEFile& peLoader, LPWSTR outputFileName);
bool AppendResourcesToPELoader(LPWSTR inputFileName, LPWSTR outputFileName);
bool CompressAndAppendToPELoader(PEFile::PEFile& inputFile, LPWSTR outputFileName);

int main()
{
  LPWSTR inputFileName = nullptr;
  LPWSTR outputFileName = nullptr;
  if (!GetCommandLine(inputFileName, outputFileName)) return 0;

  PEFile::PEFile inputFile;
  if (!ReadInputFile(inputFileName, inputFile)) return 0;
  if (!IsInputFileSupported(inputFile)) return 0;

  PEFile::PEFile peLoader;
  if (!LoadPELoaderFromResource(peLoader, inputFile.IsConsole())) return 0;
  if (!RebasePELoader(inputFile, peLoader)) return 0;
  if (!SavePELoader(peLoader, outputFileName)) return 0;

  if (!AppendResourcesToPELoader(inputFileName, outputFileName)) return 0;
  if (!CompressAndAppendToPELoader(inputFile, outputFileName)) return 0;
  
  Console::Console console;
  console.WriteLine(L"Packing finished.");

  return 0;
}

bool GetCommandLine(LPWSTR& inputFileName, LPWSTR& outputFileName)
{
  Console::Console console;
  CommandLine::CommandLine commandLine;

  auto args = commandLine.GetCommandLine();

  int argc = 0;
  auto argv = commandLine.CommandLineToArgv(args, argc);
  if (argc != 3)
  {
    console.WriteLine(L"\n..::[Fatmike 2025]::..\n");
    console.WriteLine(L"Version: Fatpack v1.4.0");
    console.WriteLine(L"Usage:\t fatpack.exe inputfile.exe outputfile.exe");
    return false;
  }

  inputFileName = argv[1];
  outputFileName = argv[2];

  if (wcscmp(inputFileName, outputFileName) == 0)
  {
    console.WriteLine(L"inputfile may not be the same as outputfile");
    return false;
  }

  return true;
}

bool ReadInputFile(LPWSTR inputFileName, PEFile::PEFile& inputFile)
{
  BinaryFileReader::BinaryFileReader binaryFileReader(inputFileName);
  if (binaryFileReader.GetBufferSize() == 0 || binaryFileReader.GetBuffer() == nullptr)
  {
    Console::Console console;
    console.WriteLine(L"Reading inputfile failed.");
    return false;
  }

  return inputFile.LoadFromBuffer(binaryFileReader.GetBuffer(), binaryFileReader.GetBufferSize());
}

bool IsInputFileSupported(PEFile::PEFile& inputFile)
{
  Console::Console console;
  if (!inputFile.IsPEFile())
  {
    console.WriteLine(L"inputfile is not a valid pe file.");
    return false;
  }
  if (!inputFile.Isx64())
  {
    console.WriteLine(L"inputfile is not a x64 pe file.");
    return false;
  }
  if (!inputFile.IsNative())
  {
    console.WriteLine(L"inputfile is not a native pe file.");
    return false;
  }
  return true;
}

bool LoadPELoaderFromResource(PEFile::PEFile& peLoader, bool useConsoleStub)
{
  Console::Console console;

  DWORD peLoaderSize = 0;
  ResourceLoader::ResourceLoader resourceLoader;
  BYTE* peLoaderBuffer = nullptr;
  if (useConsoleStub)
  {
    console.WriteLine(L"Using console loader stub.");
    peLoaderBuffer = resourceLoader.LoadResource(MAKEINTRESOURCE(1000), RT_RCDATA, peLoaderSize); // 1000 : Loader_Console
  }
  else
  {
    console.WriteLine(L"Using windows loader stub.");
    peLoaderBuffer = resourceLoader.LoadResource(MAKEINTRESOURCE(1001), RT_RCDATA, peLoaderSize); // 1001 : Loader_Windows
  }

  if (peLoaderBuffer == nullptr || peLoaderSize == 0)
  {
    console.WriteLine(L"Loading loader stub failed.");
    return false;
  }

  if (!peLoader.LoadFromBuffer(peLoaderBuffer, peLoaderSize)) return false;
  resourceLoader.Free(peLoaderBuffer);

  return true;
}

bool RebasePELoader(PEFile::PEFile& inputFile, PEFile::PEFile& peLoader)
{
  if (!inputFile.HasRelocationTable() && inputFile.IntersectsWith(peLoader))
  {
    Console::Console console;

    console.WriteLine(L"No relocation table found. Image base conflict detected. Rebasing...");
    ULONGLONG newImageBase = inputFile.GetNextImageBase();
    if (peLoader.Rebase(newImageBase)) // Rebase the pe loader to the next possible image base 'behind' the target
    {
      console.WriteLine(L"Rebasing finished.");
      return true;
    }
    else
    {
      console.WriteLine(L"Rebasing failed.");
      return false;
    }
  }
  return true;
}

bool SavePELoader(PEFile::PEFile& peLoader, LPWSTR outputFileName)
{
  Console::Console console;

  // Write pe loader from resource to disk (Loader is added as resource in postbuild event)
  BinaryFileWriter::BinaryFileWriter binaryFileWriter;
  if (!binaryFileWriter.WriteFile(outputFileName, peLoader.GetBuffer(), peLoader.GetBufferSize()))
  {
    console.WriteLine(L"Saving loader stub to disk failed.");
    return false;
  }
  return true;
}

bool AppendResourcesToPELoader(LPWSTR inputFileName, LPWSTR outputFileName)
{
  Console::Console console;

  // Extract icon from inputFile if available and add it to outputFile (pe loader)
  IconExtractor::IconExtractor iconExtractor;
  if (iconExtractor.ExtractAndSetIconWithCustomIds(inputFileName, outputFileName))
  {
    console.WriteLine(L"Adding icon finished.");
  }

  // Extract manifest from inputFile if available and add it to outputFile (pe loader)
  // This is required because the manifest can contain specific dll versions be loaded
  ManifestExtractor::ManifestExtractor manifestExtractor;
  if (manifestExtractor.ExtractManifestResources(inputFileName))
  {
    console.WriteLine(L"Manifest found. Adding manifest...");
    if (!manifestExtractor.AddManifestResourcesToTarget(outputFileName))
    {
      console.WriteLine(L"Adding manifest failed.");
      return false;
    }
    else
    {
      console.WriteLine(L"Adding manifest finished.");
    }
  }
  return true;
}

bool CompressAndAppendToPELoader(PEFile::PEFile& inputFile, LPWSTR outputFileName)
{
  Console::Console console;

  // Compress inputFile
  BYTE* compressed = nullptr;
  size_t compressedSize = 0;
  Compressor::Compressor compressor;
  if (!compressor.Compress(inputFile.GetBuffer(), inputFile.GetBufferSize(), &compressed, &compressedSize))
  {
    console.WriteLine(L"Compressing failed.");
    return false;
  }

  // Append compressed data as resource to loader (outputFile)
  HANDLE updateHandle = BeginUpdateResourceW(outputFileName, FALSE);
  if (updateHandle == nullptr)
  {
    console.WriteLine(L"Appending compressed data failed.");
    return false;
  }
  if (UpdateResource(updateHandle, RT_RCDATA, L"PACKED", MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), compressed, (DWORD)compressedSize) == FALSE)
  {
    console.WriteLine(L"Appending compressed data failed.");
    return false;
  }
  if (EndUpdateResource(updateHandle, FALSE) == FALSE)
  {
    console.WriteLine(L"Appending compressed data failed.");
    return false;
  }

  compressor.Free(compressed);

  return true;
}

```

`LICENSE`:

```
MIT License

Copyright (c) 2025 Fatmike-GH (https://github.com/Fatmike-GH/Fatpack)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/LICENSE_PeLoader.txt`:

```txt
MIT License

Copyright (c) 2025 Fatmike (https://github.com/Fatmike-GH/PELoader)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/LICENSE_TinyZZZ.txt`:

```txt
MIT License

Copyright (c) 2025 https://github.com/WangXuan95

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Licenses/README_Easylzma.txt`:

```txt
Overview

Easylzma is a C library and command line tools for LZMA compression and 
decompression.  It uses a Igor Pavlov's reference implementation and SDK
written in C.

License

All the cruft you find here is public domain.  You don't have to credit
anyone to use this code, but my personal request is that you mention
Igor Pavlov for his hard, high quality work.

Project Goals

1. A tiny C wrapper and portable build system around a subset of
   Igor Pavlov's public domain LZMA compression and decompression
   implementation.
2. A tiny and straighforward API
3. Support for multiple different prominent LZMA file formats (see section on
   file formats below)
4. easy to build and use everywhere (doze and nix alike)
5. public domain licensing through and through.  (hats off to Igor)

Current State:

THIS IS A WORK IN PROGRESS.  The code here should be considered pre-alpha,
and this should only be used by tinkerers or hackers at this point.  Once
feature completion is attained this message will be updated.  See the
TODO file distributed with the source for remaining work to be done.

Platforms Supported

0.0.2 has been successfully compiled and run basic round trip testing
on the following platforms & compilers:

  * win32 - visual studio 2005
  * osx - 10.4 & 10.5 (intel)
  * netbsd ppc - 4.0.1 with gcc 4.1.2
    (NOTE: memory allocation errors when dict size is default)
  * freebsd 6.1 - amd64 gcc 3.4.4

Features

XXX: write me (and the code)

Usage

XXX: write me (and the code)

The Saga of LZMA File Formats, and a couple cents.

As far as I can tell, there are at least four different ways to put LZMA
compressed data in a stream:

1. The LZMA-Alone format, which consists of a 13 byte header including
   compression properties, dictionary size, and the uncompressed size of
   the file, followed by compressed data.  This format has some support
   in Igor Pavlov's reference implementation and is in widespread use, as
   it's supported by lzmautils: http://tukaani.org/lzma/

   The canonical (afaict) implementation of this format (lzmautis) is
   BSD licensed.

2. The lzip format (http://www.nongnu.org/lzip/lzip.html) - which
   includes a CRC footer and leading "magic number".  The former
   affords data integrity gaurantees, while the latter simplifies
   heuristic determination of file format.  This format looks to have
   reasonably widespread usage, though not quite as significant as
   LZMA-Alone.

   The only implementation of this format I can find (lzip) is GPL licensed.

3. the xz format ( http://tukaani.org/xz/xz-file-format.txt ) which is
   a more complex representation that includes CRC support and a magic
   number.  This format is to be supported by the next iteration of
   XZ Utils which is currently in beta.  The source may be obtained
   here: git://ctrl.tukaani.org/xz.git

   This format will address some criticisms to the LZMA-Alone format and
   was developed collaboratively by Lasse Collin (the current maintainer
   of XZ utils) and Igor Pavlov (the author of 7zip and the refrence
   implementation of LZMA).

   The xz format will employ LZMA2 which consists of extensions on top
   of LZMA, in the xz utils maintainer's words:

   "The primary compression algorithm in .xz is currently LZMA2, which
    is an extension on top of the orignal LZMA to fix a few practical
    issues, like adding support for flushing the encoder (equivalent
    to zlib's Z_SYNC_FLUSH), which isn't possible with the original
    LZMA."

   Again, maintainers words, regarding licensing:

   "XZ Utils currently contains a zlib-like compression library and a 
    gzip-like command line tool. It's currently under LGPLv2.1+ but I will 
    put it into the public domain before the first stable release."

4. The 7zip disk format which can contain multiple files possibly stored in
   LZMA compressed format.

Given the state of things, the goal of this project is to develop something
based on the existing formats, and quickly leverage code generated by the XZ
Utils project, or simply kill this thing if that project produces something
that's easy to embed and has a clean API at a similar level of abstraction
as easylzma.

lloyd - sometime in oh nine.

```

`Loader_Console/Loader_Console.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{e373949f-e084-4dd4-a445-43b2672c42aa}</ProjectGuid>
    <RootNamespace>LoaderConsole</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Loader_Console\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Loader_Console\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary />
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:threadSafeInit- /Gs10000000 %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FunctionLevelLinking>
      </FunctionLevelLinking>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>main</EntryPointSymbol>
      <StackReserveSize>
      </StackReserveSize>
      <StackCommitSize>
      </StackCommitSize>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <ExceptionHandling>false</ExceptionHandling>
      <RuntimeLibrary />
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <Optimization>MinSpace</Optimization>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EnableUAC>false</EnableUAC>
      <EntryPointSymbol>main</EntryPointSymbol>
      <AdditionalOptions>/DEBUG:NONE /EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\CRT\crt.cpp" />
    <ClCompile Include="..\Shared\Decompressor\Decompressor.cpp" />
    <ClCompile Include="..\Shared\Decompressor\TinyLzmaDecompress.cpp" />
    <ClCompile Include="..\Shared\PELoaderStub\PELoaderStub.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PEFile.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PEImage.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PELoader.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\TlsResolver.cpp" />
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\CRT\crt.h" />
    <ClInclude Include="..\Shared\CRT\crt_tls.h" />
    <ClInclude Include="..\Shared\Decompressor\Decompressor.h" />
    <ClInclude Include="..\Shared\Decompressor\TinyLzmaDecompress.h" />
    <ClInclude Include="..\Shared\PELoaderStub\PELoaderStub.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PEFile.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PEImage.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PELoader.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\TlsResolver.h" />
    <ClInclude Include="..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h" />
    <ClInclude Include="..\Shared\PELoader\TypeDefs\peb.h" />
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Loader_Console/Loader_Console.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="..\Shared\CRT\crt.cpp">
      <Filter>CRT</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PEFile.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PEImage.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PELoader.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\TlsResolver.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp">
      <Filter>ResourceLoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Decompressor\Decompressor.cpp">
      <Filter>Decompressor</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Decompressor\TinyLzmaDecompress.cpp">
      <Filter>Decompressor</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoaderStub\PELoaderStub.cpp">
      <Filter>PELoaderStub</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="PELoader">
      <UniqueIdentifier>{8bc8722f-41fb-405d-a2f5-48c040013e7d}</UniqueIdentifier>
    </Filter>
    <Filter Include="TlsCallbackProxy">
      <UniqueIdentifier>{8cd4ed16-89d6-4c5c-b102-26b5626249e3}</UniqueIdentifier>
    </Filter>
    <Filter Include="TypeDefs">
      <UniqueIdentifier>{b5a4e8a5-6067-4597-ac61-8c68e7e2e6c7}</UniqueIdentifier>
    </Filter>
    <Filter Include="CRT">
      <UniqueIdentifier>{f83fac1d-c5cf-4b1f-99d8-19371c40002f}</UniqueIdentifier>
    </Filter>
    <Filter Include="ResourceLoader">
      <UniqueIdentifier>{a247ea49-dee8-4075-8bb7-aaf43fe552d2}</UniqueIdentifier>
    </Filter>
    <Filter Include="Decompressor">
      <UniqueIdentifier>{89b152b3-51c6-4a6c-90ec-7f8f0de1026d}</UniqueIdentifier>
    </Filter>
    <Filter Include="PELoaderStub">
      <UniqueIdentifier>{54e5439f-4789-4650-a902-4c2da15d678f}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\CRT\crt.h">
      <Filter>CRT</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\CRT\crt_tls.h">
      <Filter>CRT</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PEFile.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PEImage.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PELoader.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\TlsResolver.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h">
      <Filter>TlsCallbackProxy</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\TypeDefs\peb.h">
      <Filter>TypeDefs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h">
      <Filter>ResourceLoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Decompressor\Decompressor.h">
      <Filter>Decompressor</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Decompressor\TinyLzmaDecompress.h">
      <Filter>Decompressor</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoaderStub\PELoaderStub.h">
      <Filter>PELoaderStub</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Loader_Console/main.cpp`:

```cpp
#include <Windows.h>
#include "..\Shared\PELoaderStub\PELoaderStub.h"
#include "..\Shared\PELoader\PELoader\PEImage.h"
#include "..\Shared\PELoader\PELoader\TlsResolver.h"
#include "..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h"

PELoader::TlsResolver* _tlsResolver = nullptr;
PELoader::PEImage* _peImage = nullptr;
BOOL _entryPointCalled = FALSE;

void TlsCallbackProxy(PVOID hModule, DWORD dwReason, PVOID pContext)
{
  if (_entryPointCalled == FALSE) return;

  if (dwReason == DLL_THREAD_DETACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
    _tlsResolver->ClearTlsData();
  }
  else if (dwReason == DLL_THREAD_ATTACH)
  {
    _tlsResolver->InitializeTlsData(_peImage);
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
  else if (dwReason == DLL_PROCESS_ATTACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
  else if (dwReason == DLL_PROCESS_DETACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
}

int main()
{
  _tlsResolver = new PELoader::TlsResolver();

  PELoaderStub::PELoaderStub* peLoaderStub = new PELoaderStub::PELoaderStub();
  _peImage = peLoaderStub->Load(_tlsResolver);
  delete peLoaderStub;

  // Call entry point  
  LPVOID entryPoint = _peImage->GetEntryPoint();
  _entryPointCalled = TRUE;
  ((void(*)())(entryPoint))();

  return 0;
}
```

`Loader_Windows/Loader_Windows.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{6482b097-a9de-4d2f-b103-7df0bc56b231}</ProjectGuid>
    <RootNamespace>LoaderWindows</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Loader_Windows\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\Loader_Windows\$(Platform)\$(Configuration)\</IntDir>
    <GenerateManifest>false</GenerateManifest>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalOptions>/Zc:threadSafeInit- /Gs10000000 %(AdditionalOptions)</AdditionalOptions>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <BasicRuntimeChecks>Default</BasicRuntimeChecks>
      <RuntimeLibrary />
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>WinMain</EntryPointSymbol>
      <EnableUAC>false</EnableUAC>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>false</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <AdditionalOptions>/Zc:threadSafeInit- %(AdditionalOptions)</AdditionalOptions>
      <WholeProgramOptimization>false</WholeProgramOptimization>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <ExceptionHandling>false</ExceptionHandling>
      <Optimization>MinSpace</Optimization>
      <RuntimeLibrary />
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <IgnoreAllDefaultLibraries>true</IgnoreAllDefaultLibraries>
      <EntryPointSymbol>WinMain</EntryPointSymbol>
      <AdditionalOptions>/DEBUG:NONE /EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <EnableUAC>false</EnableUAC>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <FixedBaseAddress>false</FixedBaseAddress>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\CRT\crt.cpp" />
    <ClCompile Include="..\Shared\Decompressor\Decompressor.cpp" />
    <ClCompile Include="..\Shared\Decompressor\TinyLzmaDecompress.cpp" />
    <ClCompile Include="..\Shared\PELoaderStub\PELoaderStub.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PEFile.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PEImage.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\PELoader.cpp" />
    <ClCompile Include="..\Shared\PELoader\PELoader\TlsResolver.cpp" />
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\CRT\crt.h" />
    <ClInclude Include="..\Shared\CRT\crt_tls.h" />
    <ClInclude Include="..\Shared\Decompressor\Decompressor.h" />
    <ClInclude Include="..\Shared\Decompressor\TinyLzmaDecompress.h" />
    <ClInclude Include="..\Shared\PELoaderStub\PELoaderStub.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PEFile.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PEImage.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\PELoader.h" />
    <ClInclude Include="..\Shared\PELoader\PELoader\TlsResolver.h" />
    <ClInclude Include="..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h" />
    <ClInclude Include="..\Shared\PELoader\TypeDefs\peb.h" />
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Loader_Windows/Loader_Windows.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="..\Shared\CRT\crt.cpp">
      <Filter>CRT</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PEFile.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PEImage.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\PELoader.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoader\PELoader\TlsResolver.cpp">
      <Filter>PELoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\ResourceLoader\ResourceLoader.cpp">
      <Filter>ResourceLoader</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Decompressor\Decompressor.cpp">
      <Filter>Decompressor</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\Decompressor\TinyLzmaDecompress.cpp">
      <Filter>Decompressor</Filter>
    </ClCompile>
    <ClCompile Include="..\Shared\PELoaderStub\PELoaderStub.cpp">
      <Filter>PELoaderStub</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="CRT">
      <UniqueIdentifier>{26ee8355-4a30-474e-9804-2a5dd66241ef}</UniqueIdentifier>
    </Filter>
    <Filter Include="ResourceLoader">
      <UniqueIdentifier>{f26f6ac7-016a-4050-92a7-fa09dd2d02ba}</UniqueIdentifier>
    </Filter>
    <Filter Include="TypeDefs">
      <UniqueIdentifier>{76cc35a7-9632-4fb7-abdf-ad58935b1ea4}</UniqueIdentifier>
    </Filter>
    <Filter Include="TlsCallbackProxy">
      <UniqueIdentifier>{99f38114-3632-4185-9806-112071789014}</UniqueIdentifier>
    </Filter>
    <Filter Include="PELoader">
      <UniqueIdentifier>{15defd60-dee7-4278-b7d5-caa308c1731f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Decompressor">
      <UniqueIdentifier>{5779bd0d-7384-41a8-85b9-7496dd4e3b8c}</UniqueIdentifier>
    </Filter>
    <Filter Include="PELoaderStub">
      <UniqueIdentifier>{ccd74711-d078-4364-8337-d80c7b100c2d}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\CRT\crt.h">
      <Filter>CRT</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\CRT\crt_tls.h">
      <Filter>CRT</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PEFile.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PEImage.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\PELoader.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\PELoader\TlsResolver.h">
      <Filter>PELoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h">
      <Filter>TlsCallbackProxy</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoader\TypeDefs\peb.h">
      <Filter>TypeDefs</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\ResourceLoader\ResourceLoader.h">
      <Filter>ResourceLoader</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Decompressor\Decompressor.h">
      <Filter>Decompressor</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\Decompressor\TinyLzmaDecompress.h">
      <Filter>Decompressor</Filter>
    </ClInclude>
    <ClInclude Include="..\Shared\PELoaderStub\PELoaderStub.h">
      <Filter>PELoaderStub</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Loader_Windows/main.cpp`:

```cpp
#include <Windows.h>
#include "..\Shared\PELoaderStub\PELoaderStub.h"
#include "..\Shared\PELoader\PELoader\PEImage.h"
#include "..\Shared\PELoader\PELoader\TlsResolver.h"
#include "..\Shared\PELoader\TlsCallbackProxy\TlsCallbackProxy.h"

PELoader::TlsResolver* _tlsResolver = nullptr;
PELoader::PEImage* _peImage = nullptr;
BOOL _entryPointCalled = FALSE;

void TlsCallbackProxy(PVOID hModule, DWORD dwReason, PVOID pContext)
{
  if (_entryPointCalled == FALSE) return;

  if (dwReason == DLL_THREAD_DETACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
    _tlsResolver->ClearTlsData();
  }
  else if (dwReason == DLL_THREAD_ATTACH)
  {
    _tlsResolver->InitializeTlsData(_peImage);
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
  else if (dwReason == DLL_PROCESS_ATTACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
  else if (dwReason == DLL_PROCESS_DETACH)
  {
    _tlsResolver->ExecuteCallbacks(_peImage, dwReason, pContext);
  }
}

int WINAPI WinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPSTR lpCmdLine, _In_ int nCmdShow)
{
  _tlsResolver = new PELoader::TlsResolver();

  PELoaderStub::PELoaderStub* peLoaderStub = new PELoaderStub::PELoaderStub();
  _peImage = peLoaderStub->Load(_tlsResolver);
  delete peLoaderStub;

  // Call entry point  
  LPVOID entryPoint = _peImage->GetEntryPoint();
  _entryPointCalled = TRUE;
  ((void(*)())(entryPoint))();

  return 0;
}
```

`README.md`:

```md
# Fatpack  

A Windows PE packer (x64) with LZMA compression and with full TLS (Thread Local Storage) support.  

Keywords: PE packer, PE loader, manual mapping, manual mapper, portable executable, LZMA, UPX, EXE

## Motivation

A practical application of my PE loader: https://github.com/Fatmike-GH/PELoader  

## Usage

``Fatpack.exe inputfile.exe outputfile.exe``  

## Features

### Functional Features  

- Support for native Console- and Windows executables (x64 only, no .NET support)  
- LZMA compression  
- Full TLS (Thread Local Storage) support  
  - Therefore supports Rust- and Delphi exectuables for example  
- No CRT usage in Fatpack.exe and Stubs (WinAPI only) and therefore no C/C++ redistributables are required  
- Icon extraction
- Manifest extraction (required if specfic module versions of the target executable are specified)

### Technical Features  

- Relocations
- Imports
- Delay Imports
- Exception Handlers
- Proper Memory Section Protection
- Full TLS (Thread Local Storage) support
  - TLS Callbacks
    - DLL_PROCESS_ATTACH  
    - DLL_THREAD_ATTACH  
    - DLL_THREAD_DETACH  
    - DLL_PROCESS_DETACH  
  - TLS Data
- Rebasing if necessary 

## Solution Overview

The solution consists of four projects:  

- ``Fatpack``  
  - The console application ``Fatpack.exe``, which the user employs to pack their target executable.  
  
- Loader stubs  
  - The loader stubs serve as containers for the packed target executable and are responsible for loading and executing it.  
  - ``Loader_Console``  
  - ``Loader_Windows``  
  
- ``ResourceAdder``
  - ``ResourceAdder.exe``, a helper executable that adds the loader stubs to ``Fatpack.exe`` as post-build step, using the scripts ``PostBuildStep_Debug.bat`` and ``PostBuildStep_Release.bat``.

### Loader Stubs  

Both ``Loader_Console`` and ``Loader_Windows`` serve as loader stubs. Upon startup, they retrieve the packed target executable from their embedded resources, unpack it in memory, and execute it.  
The loader logic is available at: https://github.com/Fatmike-GH/PELoader  

- ``Loader_Console``: The loader stub for loading console applications.  
- ``Loader_Windows``: The loader stub for loading windows applications.  

### ResourceAdder  

A simple console application used to embed the loader stubs into ``Fatpack.exe`` as post-build step. This integration is handled via the scripts ``PostBuildStep_Debug.bat`` and ``PostBuildStep_Release.bat``.  

>**Note:** Always use **"Rebuild Solution"** after making changes to ensure that the post-build steps execute correctly.  

### Fatpack

The console application (``Fatpack.exe``) is used by the user to package their target executable. Its main responsibilities include:  

- Determining the appropriate loader stub (Loader_Console or Loader_Windows) based on the type of the target executable, loading it from an embedded resource, and saving it to disk. 
- Rebasing the loader stub if the target does not have a relocation table and there is an image base conflict.  
- Extracting the icon from the target executable and embedding it into the selected loader stub.  
- Extracting and embedding the application manifest from the target executable. This step is essential, as the manifest may specify specific module versions required for correct execution.  
- Compressing the target executable using the LZMA algorithm and appending it to the loader stub.  

![image](Images/Concept.PNG)

## Fatpack vs UPX 5.0.1 

| Target size 	| UPX     	| UPX -9  	| Fatpack 	| Target info                                   	|
|-------------	|---------	|---------	|---------	|-----------------------------------------------	|
| 6744 kb     	| 1735 kb 	| 1669 kb 	| **1608 kb** 	| Embarcadero Delphi(XE3-X4)[Professional]      	|
| 2728 kb     	| 1052 kb 	| **1034 kb** 	| 1035 kb 	| Rust                                          	|
| 611 kb      	| 86 kb   	| 83 kb   	| **80 kb**   	| Microsoft Visual C/C++(19.36.34808)[C++]      	|
| 533 kb      	| 213 kb  	| 210 kb  	| **199 kb**  	| Rust                                          	|
| 448 kb      	| -       	| -       	| **193 kb**  	| Rust                                          	|
| 233 kb      	| 89 kb   	| 89 kb   	| **85 kb**   	| Microsoft Visual C/C++(19.36.34436)[LTCG/C++] 	|
| 32 kb       	| **9 kb**    	| **9 kb**    	| 16 kb   	| Microsoft Visual C/C++(19.29.30139)[LTCG/C]   	|
| 20 kb       	| **11 kb**  	| **11 kb**   	| 18 kb   	| Microsoft Visual C/C++(19.36.34808)[LTCG/C++] 	|
| 15 kb       	| **10 kb**   	| **10 kb**   	| 17 kb   	| Microsoft Visual C/C++(19.36.34808)[LTCG/C++] 	|

Since the loader stubs (``Loader_Console`` and ``Loader_Windows``) are relatively large,approximately 10 KB each, the compression ratio is less favorable when packing very small target executables. However, for larger executables, the results are significantly more efficient, yielding much better overall compression ratios.  

> **Note:** UPX did not support the 448 kb target

## Third Party Software  

### EasyLZMA  

https://github.com/lloyd/easylzma  

### TinyZZZ  

https://github.com/WangXuan95/TinyZZZ  

### Fatmike's PE Loader  

https://github.com/Fatmike-GH/PELoader




```

`ResourceAdder/ResourceAdder.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{d6392848-12a3-4b94-bf4c-1ce727f12d0b}</ProjectGuid>
    <RootNamespace>ResourceAdder</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\ResourceAdder\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <OutDir>$(SolutionDir)\build\$(Platform)\$(Configuration)\</OutDir>
    <IntDir>$(SolutionDir)\build\obj\ResourceAdder\$(Platform)\$(Configuration)\</IntDir>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
    <PostBuildEvent>
      <Command>
      </Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>
      </Message>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="..\Shared\BinaryFileReader\BinaryFileReader.cpp" />
    <ClCompile Include="main.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\BinaryFileReader\BinaryFileReader.h" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`ResourceAdder/ResourceAdder.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <ClCompile Include="main.cpp" />
    <ClCompile Include="..\Shared\BinaryFileReader\BinaryFileReader.cpp">
      <Filter>BinaryFileReader</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <Filter Include="BinaryFileReader">
      <UniqueIdentifier>{3cefc128-4c6a-46e4-b9ea-532d6421101c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\Shared\BinaryFileReader\BinaryFileReader.h">
      <Filter>BinaryFileReader</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`ResourceAdder/main.cpp`:

```cpp
#include <windows.h>
#include <iostream>
#include <stdio.h>
#include <string>
#include "..\Shared\BinaryFileReader\BinaryFileReader.h"

int wmain(int argc, wchar_t* argv[])
{
  if (argc != 4)
  {
    std::cout << "Usage: ResourceAdder resourcefile targetfile.exe resource id" << std::endl;
    return 0;
  }

  std::wstring resourceFile(argv[1]);
  std::wstring targetFile(argv[2]);
  std::wstring resourceId(argv[3]);

  WORD resourceIdValue = static_cast<WORD>(std::stoi(resourceId));

  // Read resourceFile
  BinaryFileReader::BinaryFileReader binaryFileReader(resourceFile.c_str());
  if (binaryFileReader.GetBuffer() == nullptr || binaryFileReader.GetBufferSize() == 0) return 0;

  // Add resourceFile as resource to targetFile
  HANDLE updateHandle = BeginUpdateResourceW(targetFile.c_str(), FALSE);
  UpdateResource(updateHandle, RT_RCDATA, MAKEINTRESOURCE(resourceIdValue), MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL), binaryFileReader.GetBuffer(), binaryFileReader.GetBufferSize());
  EndUpdateResource(updateHandle, FALSE);

  return 0;
}

```

`Shared/BinaryFileReader/BinaryFileReader.cpp`:

```cpp
#include "BinaryFileReader.h"

namespace BinaryFileReader
{
  BinaryFileReader::BinaryFileReader(const wchar_t* fileName)
  {
    _buffer = nullptr;
    _bufferSize = 0;

    HANDLE fileHandle = CreateFileW(fileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (fileHandle == INVALID_HANDLE_VALUE)
    {
      Cleanup();
      return;
    }

    _bufferSize = GetFileSize(fileHandle, NULL);
    if (_bufferSize == INVALID_FILE_SIZE)
    {
      Cleanup();
      CloseHandle(fileHandle);
      return;
    }

    _buffer = new BYTE[_bufferSize];

    DWORD bytesRead = 0;
    BOOL result = ReadFile(fileHandle, _buffer, _bufferSize, &bytesRead, NULL);
    CloseHandle(fileHandle);

    if (result == FALSE)
    {
      Cleanup();
    }

    return;
  }

  BinaryFileReader::~BinaryFileReader()
  {
    Cleanup();
  }

  void BinaryFileReader::Cleanup()
  {
    if (_buffer != nullptr)
    {
      delete[] _buffer;
      _buffer = nullptr;
    }
    _bufferSize = 0;
  }
}



```

`Shared/BinaryFileReader/BinaryFileReader.h`:

```h
#pragma once
#include <Windows.h>

namespace BinaryFileReader
{
  class BinaryFileReader
  {
  public:
    BinaryFileReader(const wchar_t* fileName);
    ~BinaryFileReader();

    BYTE* GetBuffer() { return _buffer; }
    DWORD GetBufferSize() { return _bufferSize; }

  private:
    void Cleanup();

  private:
    BYTE* _buffer;
    DWORD _bufferSize;
  };
}



```

`Shared/CRT/crt.cpp`:

```cpp
#include "crt.h"

#pragma function(memset)
void* memset(void* _Dst, int _Val, size_t _Size)
{
  __stosb(static_cast<unsigned char*>(_Dst),
  static_cast<unsigned char>(_Val), _Size);
  return _Dst;
}

#pragma function(memcpy)
void* __cdecl memcpy(void* _Dst, void const* _Src, size_t _Size)
{
  __movsb(static_cast<unsigned char*>(_Dst),
  static_cast<const unsigned char*>(_Src), _Size);
  return _Dst;
}

#pragma function(memmove)
void* __cdecl memmove(void* dest, const void* src, size_t n)
{
  unsigned char* from = (unsigned char*)src;
  unsigned char* to = (unsigned char*)dest;

  if (from == to || n == 0)
    return dest;
  if (to > from && to - from < (int)n) {
    /* to overlaps with from */
    /*  <from......>         */
    /*         <to........>  */
    /* copy in reverse, to avoid overwriting from */
    size_t i;
    for (i = n - 1; i >= 0; i--)
      to[i] = from[i];
    return dest;
  }
  if (from > to && from - to < (int)n) {
    /* to overlaps with from */
    /*        <from......>   */
    /*  <to........>         */
    /* copy forwards, to avoid overwriting from */
    size_t i;
    for (i = 0; i < n; i++)
      to[i] = from[i];
    return dest;
  }
  memcpy(dest, src, n);
  return dest;
}

_Check_return_
int __cdecl strncmp(
  _In_reads_or_z_(n) char const* s1,
  _In_reads_or_z_(n) char const* s2,
  _In_                       size_t      n
)
{
  register unsigned char u1, u2;

  while (n-- > 0)
  {
    u1 = (unsigned char)*s1++;
    u2 = (unsigned char)*s2++;
    if (u1 != u2)
      return u1 - u2;
    if (u1 == '\0')
      return 0;
  }
  return 0;
}

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(size)
_CRTALLOCATOR _CRT_JIT_INTRINSIC _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl malloc(
  _In_ _CRT_GUARDOVERFLOW size_t size
)
{
  return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size);
}

_CRT_HYBRIDPATCHABLE
void __cdecl free(
  _Pre_maybenull_ _Post_invalid_ void* ptr
)
{
  HeapFree(GetProcessHeap(), 0, ptr);
}

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(size)
_CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl realloc(
  _Pre_maybenull_ _Post_invalid_ void* ptr,
  _In_ _CRT_GUARDOVERFLOW        size_t size
)
{
  if (ptr == NULL)
  {
    return malloc(size);
  }
  if (size == 0)
  {
    free(ptr);
    return NULL;
  }

  return HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, ptr, size);
}

void* operator new(size_t size)
{
  if (size == 0) return nullptr;
  return malloc(size);
}

void* operator new[](size_t size)
{
  if (size == 0) return nullptr;
  return malloc(size);
}

void operator delete(void* ptr)
{
  free(ptr);
}

void operator delete[](void* ptr)
{
  free(ptr);
}

void operator delete(void* ptr, size_t size)
{
  free(ptr);
}

void operator delete[](void* ptr, size_t size)
{
  free(ptr);
}
```

`Shared/CRT/crt.h`:

```h
#pragma once
#include <Windows.h>
#include <intrin.h>

void* __cdecl memset(void* _Dst, int _Val, size_t _Size);
#pragma intrinsic(memset)

void* __cdecl memcpy(void* _Dst, void const* _Src, size_t _Size);
#pragma intrinsic(memcpy)

void* __cdecl memmove(void* dest, const void* src, size_t n);
#pragma intrinsic(memmove)

_Check_return_
int __cdecl strncmp(
  _In_reads_or_z_(_MaxCount) char const* _Str1,
  _In_reads_or_z_(_MaxCount) char const* _Str2,
  _In_                       size_t      _MaxCount
);

_Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_CRTALLOCATOR _CRT_JIT_INTRINSIC _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl malloc(
  _In_ _CRT_GUARDOVERFLOW size_t _Size
);

_CRT_HYBRIDPATCHABLE
void __cdecl free(
  _Pre_maybenull_ _Post_invalid_ void* _Block
);

_Success_(return != 0) _Check_return_ _Ret_maybenull_ _Post_writable_byte_size_(_Size)
_CRTALLOCATOR _CRTRESTRICT _CRT_HYBRIDPATCHABLE
void* __cdecl realloc(
  _Pre_maybenull_ _Post_invalid_ void* _Block,
  _In_ _CRT_GUARDOVERFLOW        size_t _Size
);

void* operator new(size_t size);
void* operator new[](size_t size);
void operator delete(void* ptr);
void operator delete[](void* ptr);
void operator delete(void* ptr, size_t size);
void operator delete[](void* ptr, size_t size);


```

`Shared/CRT/crt_tls.h`:

```h
#pragma once
#include <Windows.h>

#pragma section(".CRT$XCA",    long, read) // First C++ Initializer
#pragma section(".CRT$XCAA",   long, read) // Startup C++ Initializer
#pragma section(".CRT$XCZ",    long, read) // Last C++ Initializer

#pragma section(".CRT$XDA",    long, read) // First Dynamic TLS Initializer
#pragma section(".CRT$XDZ",    long, read) // Last Dynamic TLS Initializer

#pragma section(".CRT$XIA",    long, read) // First C Initializer
#pragma section(".CRT$XIAA",   long, read) // Startup C Initializer
#pragma section(".CRT$XIAB",   long, read) // PGO C Initializer
#pragma section(".CRT$XIAC",   long, read) // Post-PGO C Initializer
#pragma section(".CRT$XIC",    long, read) // CRT C Initializers
#pragma section(".CRT$XIYA",   long, read) // VCCorLib Threading Model Initializer
#pragma section(".CRT$XIYAA",  long, read) // XAML Designer Threading Model Override Initializer
#pragma section(".CRT$XIYB",   long, read) // VCCorLib Main Initializer
#pragma section(".CRT$XIZ",    long, read) // Last C Initializer

#pragma section(".CRT$XLA",    long, read) // First Loader TLS Callback
#pragma section(".CRT$XLC",    long, read) // CRT TLS Constructor
#pragma section(".CRT$XLD",    long, read) // CRT TLS Terminator
#pragma section(".CRT$XLZ",    long, read) // Last Loader TLS Callback

#pragma section(".CRT$XPA",    long, read) // First Pre-Terminator
#pragma section(".CRT$XPB",    long, read) // CRT ConcRT Pre-Terminator
#pragma section(".CRT$XPX",    long, read) // CRT Pre-Terminators
#pragma section(".CRT$XPXA",   long, read) // CRT stdio Pre-Terminator
#pragma section(".CRT$XPZ",    long, read) // Last Pre-Terminator

#pragma section(".CRT$XTA",    long, read) // First Terminator
#pragma section(".CRT$XTZ",    long, read) // Last Terminator

#pragma section(".CRTMA$XCA",  long, read) // First Managed C++ Initializer
#pragma section(".CRTMA$XCZ",  long, read) // Last Managed C++ Initializer

#pragma section(".CRTVT$XCA",  long, read) // First Managed VTable Initializer
#pragma section(".CRTVT$XCZ",  long, read) // Last Managed VTable Initializer

#pragma section(".rdata$T",    long, read)

#pragma section(".rtc$IAA",    long, read) // First RTC Initializer
#pragma section(".rtc$IZZ",    long, read) // Last RTC Initializer

#pragma section(".rtc$TAA",    long, read) // First RTC Terminator
#pragma section(".rtc$TZZ",    long, read) // Last RTC Terminator

#define _CRTALLOC(x) __declspec(allocate(x))

typedef int(__cdecl* _PIFV)(void);
typedef void(__cdecl* _PVFV)(void);

extern "C" _CRTALLOC(".CRT$XIA") _PIFV __xi_a[] = { nullptr }; // C initializers (first)
extern "C" _CRTALLOC(".CRT$XIZ") _PIFV __xi_z[] = { nullptr }; // C initializers (last)
extern "C" _CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { nullptr }; // C++ initializers (first)
extern "C" _CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { nullptr }; // C++ initializers (last)
extern "C" _CRTALLOC(".CRT$XPA") _PVFV __xp_a[] = { nullptr }; // C pre-terminators (first)
extern "C" _CRTALLOC(".CRT$XPZ") _PVFV __xp_z[] = { nullptr }; // C pre-terminators (last)
extern "C" _CRTALLOC(".CRT$XTA") _PVFV __xt_a[] = { nullptr }; // C terminators (first)
extern "C" _CRTALLOC(".CRT$XTZ") _PVFV __xt_z[] = { nullptr }; // C terminators (last)

#pragma comment(linker, "/merge:.CRT=.rdata")

extern "C"
{
  ULONG _tls_index = 0;

#pragma data_seg(".tls")
  _CRTALLOC(".tls")
    char _tls_start = 0;

#pragma data_seg(".tls$ZZZ")
  _CRTALLOC(".tls$ZZZ")
    char _tls_end = 0;

#pragma data_seg()


  //NOTE: Start of TLS callback generated by os loader code
  _CRTALLOC(".CRT$XLA") PIMAGE_TLS_CALLBACK __xl_a = 0;

  //NOTE: Terminator of TLS callback array
  _CRTALLOC(".CRT$XLZ") PIMAGE_TLS_CALLBACK __xl_z = 0;

  //NOTE: TLS array..
  _CRTALLOC(".rdata$T")
    extern const IMAGE_TLS_DIRECTORY64 _tls_used =
  {
      (ULONGLONG)&_tls_start,
      (ULONGLONG)&_tls_end,
      (ULONGLONG)&_tls_index,
      (ULONGLONG)(&__xl_a + 1),
      (ULONG)0,
      (LONG)0
  };
}
```

`Shared/Decompressor/Decompressor.cpp`:

```cpp
#include "Decompressor.h"
#include "TinyLzmaDecompress.h"
#include "..\..\Shared\CRT\crt.h"

namespace Decompressor
{
  Decompressor::Decompressor()
  {
  }

  Decompressor::~Decompressor()
  {
  }

  bool Decompressor::Decompress(BYTE* source, size_t sourceLength, BYTE** decompressed, size_t* uncompressedSize)
  {
    return (tinyLzmaDecompress(source, sourceLength, decompressed, uncompressedSize) == 0);
  }

  void Decompressor::Free(BYTE* decompressed)
  {
    free(decompressed);
  }
}
```

`Shared/Decompressor/Decompressor.h`:

```h
#pragma once
#include <Windows.h>

namespace Decompressor
{
  class Decompressor
  {
  public:
    Decompressor();
    ~Decompressor();

    bool Decompress(BYTE* source, size_t sourceLength, BYTE** decompressed, size_t* compressedSize);
    void Free(BYTE* decompressed);
  };
}
```

`Shared/Decompressor/TinyLzmaDecompress.cpp`:

```cpp
// TinyLZMA
// Source from https://github.com/WangXuan95/TinyLzma

#include <Windows.h>
#include "TinyLzmaDecompress.h"
#include "..\..\Shared\CRT\crt.h"

// the code only use these basic types :
//    int      : as return code
//    uint8_t  : as compressed and uncompressed data, as LZMA state
//    uint16_t : as probabilities of range coder
//    uint32_t : as generic integers
//    size_t   : as data length



#define RET_IF_ERROR(expression)  {     \
    int res = (expression);             \
    if (res != R_OK)                    \
        return res;                     \
}



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// common useful functions
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static uint32_t bitsReverse(uint32_t bits, uint32_t bit_count) {
  uint32_t revbits = 0;
  for (; bit_count > 0; bit_count--) {
    revbits <<= 1;
    revbits |= (bits & 1);
    bits >>= 1;
  }
  return revbits;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Range Decoder
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define   RANGE_CODE_NORMALIZE_THRESHOLD           (1 << 24)
#define   RANGE_CODE_MOVE_BITS                     5
#define   RANGE_CODE_N_BIT_MODEL_TOTAL_BITS        11
#define   RANGE_CODE_BIT_MODEL_TOTAL               (1 << RANGE_CODE_N_BIT_MODEL_TOTAL_BITS)
#define   RANGE_CODE_HALF_PROBABILITY              (RANGE_CODE_BIT_MODEL_TOTAL >> 1)


typedef struct {
  uint32_t       code;
  uint32_t       range;
  const uint8_t* p_src;
  const uint8_t* p_src_limit;
  uint8_t        overflow;
} RangeDecoder_t;


static void rangeDecodeNormalize(RangeDecoder_t* d) {
  if (d->range < RANGE_CODE_NORMALIZE_THRESHOLD) {
    if (d->p_src != d->p_src_limit) {
      d->range <<= 8;
      d->code <<= 8;
      d->code |= (uint32_t)(*(d->p_src));
      d->p_src++;
    }
    else {
      d->overflow = 1;
    }
  }
}


static RangeDecoder_t newRangeDecoder(const uint8_t* p_src, size_t src_len) {
  RangeDecoder_t coder;
  coder.code = 0;
  coder.range = 0;
  coder.p_src = p_src;
  coder.p_src_limit = p_src + src_len;
  coder.overflow = 0;
  rangeDecodeNormalize(&coder);
  rangeDecodeNormalize(&coder);
  rangeDecodeNormalize(&coder);
  rangeDecodeNormalize(&coder);
  rangeDecodeNormalize(&coder);
  coder.range = 0xFFFFFFFF;
  return coder;
}


static uint32_t rangeDecodeIntByFixedProb(RangeDecoder_t* d, uint32_t bit_count) {
  uint32_t val = 0, b;
  for (; bit_count > 0; bit_count--) {
    rangeDecodeNormalize(d);
    d->range >>= 1;
    d->code -= d->range;
    b = !(1 & (d->code >> 31));
    if (!b)
      d->code += d->range;
    val <<= 1;
    val |= b;
  }
  return val;
}


static uint32_t rangeDecodeBit(RangeDecoder_t* d, uint16_t* p_prob) {
  uint32_t prob = *p_prob;
  uint32_t bound;
  rangeDecodeNormalize(d);
  bound = (d->range >> RANGE_CODE_N_BIT_MODEL_TOTAL_BITS) * prob;
  if (d->code < bound) {
    d->range = bound;
    *p_prob = (uint16_t)(prob + ((RANGE_CODE_BIT_MODEL_TOTAL - prob) >> RANGE_CODE_MOVE_BITS));
    return 0;
  }
  else {
    d->range -= bound;
    d->code -= bound;
    *p_prob = (uint16_t)(prob - (prob >> RANGE_CODE_MOVE_BITS));
    return 1;
  }
}


static uint32_t rangeDecodeInt(RangeDecoder_t* d, uint16_t* p_prob, uint32_t bit_count) {
  uint32_t val = 1;
  uint32_t i;
  for (i = 0; i < bit_count; i++) {
    if (!rangeDecodeBit(d, p_prob + val - 1)) {                // get bit 0
      val <<= 1;
    }
    else {                                                  // get bit 1
      val <<= 1;
      val |= 1;
    }
  }
  return val & ((1 << bit_count) - 1);
}


static uint32_t rangeDecodeMB(RangeDecoder_t* d, uint16_t* p_prob, uint32_t match_byte) {
  uint32_t i, val = 1, off0 = 0x100, off1;                       // off0 and off1 can only be 0x000 or 0x100
  for (i = 0; i < 8; i++) {
    match_byte <<= 1;
    off1 = off0;
    off0 &= match_byte;
    if (!rangeDecodeBit(d, (p_prob + (off0 + off1 + val - 1)))) {  // get bit 0
      val <<= 1;
      off0 ^= off1;
    }
    else {                                                  // get bit 1
      val <<= 1;
      val |= 1;
    }
  }
  return val & 0xFF;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LZMA Decoder
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

typedef enum {          // packet_type
  PKT_LIT,
  PKT_MATCH,
  PKT_SHORTREP,
  PKT_REP0,           // LONGREP0
  PKT_REP1,           // LONGREP1
  PKT_REP2,           // LONGREP2
  PKT_REP3            // LONGREP3
} PACKET_t;


static uint8_t stateTransition(uint8_t state, PACKET_t type) {
  switch (state) {
  case  0: return (type == PKT_LIT) ? 0 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  1: return (type == PKT_LIT) ? 0 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  2: return (type == PKT_LIT) ? 0 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  3: return (type == PKT_LIT) ? 0 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  4: return (type == PKT_LIT) ? 1 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  5: return (type == PKT_LIT) ? 2 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  6: return (type == PKT_LIT) ? 3 : (type == PKT_MATCH) ? 7 : (type == PKT_SHORTREP) ? 9 : 8;
  case  7: return (type == PKT_LIT) ? 4 : (type == PKT_MATCH) ? 10 : (type == PKT_SHORTREP) ? 11 : 11;
  case  8: return (type == PKT_LIT) ? 5 : (type == PKT_MATCH) ? 10 : (type == PKT_SHORTREP) ? 11 : 11;
  case  9: return (type == PKT_LIT) ? 6 : (type == PKT_MATCH) ? 10 : (type == PKT_SHORTREP) ? 11 : 11;
  case 10: return (type == PKT_LIT) ? 4 : (type == PKT_MATCH) ? 10 : (type == PKT_SHORTREP) ? 11 : 11;
  case 11: return (type == PKT_LIT) ? 5 : (type == PKT_MATCH) ? 10 : (type == PKT_SHORTREP) ? 11 : 11;
  default: return 0xFF;                                                                              // 0xFF is invalid state which will never appear
  }
}



#define   N_STATES                                  12
#define   N_LIT_STATES                              7

#define   MAX_LC                                    8                    // max value of lc is 8, see LZMA specification
#define   N_PREV_BYTE_LC_MSBS                       (1 << MAX_LC)

#define   MAX_LP                                    4                    // max value of lp is 4, see LZMA specification
#define   N_LIT_POS_STATES                          (1 << MAX_LP)

#define   MAX_PB                                    4                    // max value of pb is 4, see LZMA specification
#define   N_POS_STATES                              (1 << MAX_PB)


#define   INIT_PROBS(probs)                         {                  \
    uint16_t *p = (uint16_t*)(probs);                                  \
    uint16_t *q = p + (sizeof(probs) / sizeof(uint16_t));              \
    for (; p<q; p++)                                                   \
        *p = RANGE_CODE_HALF_PROBABILITY;                              \
}                                                                       // all probabilities are init to 50% (half probability)


#define   INIT_PROBS_LITERAL(probs)                 {                  \
    uint16_t *p = (uint16_t*)(probs);                                  \
    uint16_t *q = p + (N_LIT_POS_STATES*N_PREV_BYTE_LC_MSBS*3*(1<<8)); \
    for (; p<q; p++)                                                   \
        *p = RANGE_CODE_HALF_PROBABILITY;                              \
}                                                                       // all probabilities are init to 50% (half probability)


static int lzmaDecode(const uint8_t* p_src, size_t src_len, uint8_t* p_dst, size_t* p_dst_len, uint8_t lc, uint8_t lp, uint8_t pb) {
  const uint8_t lc_shift = (8 - lc);
  const uint8_t lc_mask = (1 << lc) - 1;
  const uint8_t lp_mask = (1 << lp) - 1;
  const uint8_t pb_mask = (1 << pb) - 1;

  uint8_t  prev_byte = 0;
  uint8_t  state = 0;        // valid value : 0~12
  size_t   pos = 0;        // position of uncompressed data (p_dst)
  uint32_t rep0 = 1;
  uint32_t rep1 = 1;
  uint32_t rep2 = 1;
  uint32_t rep3 = 1;

  RangeDecoder_t coder = newRangeDecoder(p_src, src_len);

  // probability arrays ---------------------------------------
  uint16_t probs_is_match[N_STATES][N_POS_STATES];
  uint16_t probs_is_rep[N_STATES];
  uint16_t probs_is_rep0[N_STATES];
  uint16_t probs_is_rep0_long[N_STATES][N_POS_STATES];
  uint16_t probs_is_rep1[N_STATES];
  uint16_t probs_is_rep2[N_STATES];
  uint16_t probs_dist_slot[4][(1 << 6) - 1];
  uint16_t probs_dist_special[10][(1 << 5) - 1];
  uint16_t probs_dist_align[(1 << 4) - 1];
  uint16_t probs_len_choice[2];
  uint16_t probs_len_choice2[2];
  uint16_t probs_len_low[2][N_POS_STATES][(1 << 3) - 1];
  uint16_t probs_len_mid[2][N_POS_STATES][(1 << 3) - 1];
  uint16_t probs_len_high[2][(1 << 8) - 1];

  // uint16_t probs_literal  [N_LIT_POS_STATES] [N_PREV_BYTE_LC_MSBS] [3*(1<<8)];

  uint16_t(*probs_literal)[N_PREV_BYTE_LC_MSBS][3 * (1 << 8)];

  probs_literal = (uint16_t(*)[N_PREV_BYTE_LC_MSBS][3 * (1 << 8)]) malloc(sizeof(uint16_t) * N_PREV_BYTE_LC_MSBS * N_LIT_POS_STATES * 3 * (1 << 8));    // since this array is quiet large (3145728 items, 6MB), we need to use malloc

  if (probs_literal == 0)
    return R_ERR_MEMORY_RUNOUT;

  INIT_PROBS(probs_is_match);
  INIT_PROBS(probs_is_rep);
  INIT_PROBS(probs_is_rep0);
  INIT_PROBS(probs_is_rep0_long);
  INIT_PROBS(probs_is_rep1);
  INIT_PROBS(probs_is_rep2);
  INIT_PROBS(probs_dist_slot);
  INIT_PROBS(probs_dist_special);
  INIT_PROBS(probs_dist_align);
  INIT_PROBS(probs_len_choice);
  INIT_PROBS(probs_len_choice2);
  INIT_PROBS(probs_len_low);
  INIT_PROBS(probs_len_mid);
  INIT_PROBS(probs_len_high);
  //INIT_PROBS(probs_literal);
  INIT_PROBS_LITERAL(probs_literal);

  while (pos < *p_dst_len) {                                                          // main loop
    const uint8_t prev_byte_lc_msbs = lc_mask & (prev_byte >> lc_shift);
    const uint8_t literal_pos_state = lp_mask & (uint32_t)pos;
    const uint8_t pos_state = pb_mask & (uint32_t)pos;
    uint32_t dist = 0, len = 0;
    PACKET_t type;

    if (coder.overflow)
      return R_ERR_INPUT_OVERFLOW;

    if (!rangeDecodeBit(&coder, &probs_is_match[state][pos_state])) {  // decoded bit sequence = 0     (packet LIT)
      type = PKT_LIT;
    }
    else if (!rangeDecodeBit(&coder, &probs_is_rep[state])) {  // decoded bit sequence = 10    (packet MATCH)
      type = PKT_MATCH;
    }
    else if (!rangeDecodeBit(&coder, &probs_is_rep0[state])) {  // decoded bit sequence = 110   (packet SHORTREP or LONGREP0)
      type = rangeDecodeBit(&coder, &probs_is_rep0_long[state][pos_state]) ? PKT_REP0 : PKT_SHORTREP;
    }
    else if (!rangeDecodeBit(&coder, &probs_is_rep1[state])) {  // decoded bit sequence = 1110  (packet LONGREP1)
      type = PKT_REP1;
    }
    else {
      type = rangeDecodeBit(&coder, &probs_is_rep2[state]) ? PKT_REP3 : PKT_REP2;
    }

    if (type == PKT_LIT) {
      if (state < N_LIT_STATES) {
        prev_byte = rangeDecodeInt(&coder, probs_literal[literal_pos_state][prev_byte_lc_msbs], 8);
      }
      else {
        uint8_t match_byte = 0;
        if (pos >= (size_t)rep0)
          match_byte = p_dst[pos - rep0];
        prev_byte = rangeDecodeMB(&coder, probs_literal[literal_pos_state][prev_byte_lc_msbs], match_byte);
      }
    }

    state = stateTransition(state, type);

    switch (type) {
    case PKT_SHORTREP:
    case PKT_REP0: dist = rep0;  break;
    case PKT_REP1: dist = rep1;  break;
    case PKT_REP2: dist = rep2;  break;
    case PKT_REP3: dist = rep3;  break;
    default:               break;
    }

    switch (type) {
    case PKT_LIT:
    case PKT_SHORTREP: len = 1;     break;
    case PKT_MATCH:
    case PKT_REP3: rep3 = rep2;
    case PKT_REP2: rep2 = rep1;
    case PKT_REP1: rep1 = rep0;  break;
    default:               break;
    }

    if (len == 0) {                                                                    // unknown length, need to decode
      const uint32_t is_rep = (type != PKT_MATCH);
      if (!rangeDecodeBit(&coder, &probs_len_choice[is_rep]))
        len = 2 + rangeDecodeInt(&coder, probs_len_low[is_rep][pos_state], 3);   // len = 2~9
      else if (!rangeDecodeBit(&coder, &probs_len_choice2[is_rep]))
        len = 10 + rangeDecodeInt(&coder, probs_len_mid[is_rep][pos_state], 3);   // len = 10~17
      else
        len = 18 + rangeDecodeInt(&coder, probs_len_high[is_rep], 8);              // len = 18~273
    }

    if (type == PKT_MATCH) {                                                           // unknown distance, need to decode
      const uint32_t len_min5_minus2 = (len > 5) ? 3 : (len - 2);
      uint32_t dist_slot, bcnt;

      dist_slot = rangeDecodeInt(&coder, probs_dist_slot[len_min5_minus2], 6);       // decode distance slot (0~63)
      bcnt = (dist_slot >> 1) - 1;
      dist = (2 | (dist_slot & 1));                                                 // high 2 bits of dist
      dist <<= bcnt;

      if (dist_slot >= 14) {                                                   // dist slot = 14~63
        dist |= rangeDecodeIntByFixedProb(&coder, bcnt - 4) << 4;
        dist |= bitsReverse(rangeDecodeInt(&coder, probs_dist_align, 4), 4);
      }
      else if (dist_slot >= 4) {                                                   // dist slot = 4~13
        dist |= bitsReverse(rangeDecodeInt(&coder, probs_dist_special[dist_slot - 4], bcnt), bcnt);
      }
      else {                                                                       // dist slot = 0~3
        dist = dist_slot;
      }

      if (dist == 0xFFFFFFFF)                                                        // meeting end marker
        break;

      dist++;
    }

    if ((size_t)dist > pos)
      return R_ERR_DATA;

    if ((pos + len) > *p_dst_len)
      return R_ERR_OUTPUT_OVERFLOW;

    if (type == PKT_LIT)
      p_dst[pos] = prev_byte;
    else
      rep0 = dist;

    for (; len > 0; len--) {
      p_dst[pos] = prev_byte = p_dst[pos - dist];
      pos++;
    }
  }

  free(probs_literal);

  *p_dst_len = pos;

  return R_OK;
}




/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// LZMA decompress (include parsing ".lzma" format's header)
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define   LZMA_HEADER_LEN                           13
#define   LZMA_DIC_MIN                              (1 << 12)


static int parseLzmaHeader(const uint8_t* p_src, uint8_t* p_lc, uint8_t* p_lp, uint8_t* p_pb, uint32_t* p_dict_len, size_t* p_uncompressed_len, uint32_t* p_uncompressed_len_known) {
  uint8_t byte0 = p_src[0];

  *p_dict_len = ((uint32_t)p_src[1]) | ((uint32_t)p_src[2] << 8) | ((uint32_t)p_src[3] << 16) | ((uint32_t)p_src[4] << 24);

  if (*p_dict_len < LZMA_DIC_MIN)
    *p_dict_len = LZMA_DIC_MIN;

  if (p_src[5] == 0xFF && p_src[6] == 0xFF && p_src[7] == 0xFF && p_src[8] == 0xFF && p_src[9] == 0xFF && p_src[10] == 0xFF && p_src[11] == 0xFF && p_src[12] == 0xFF) {
    *p_uncompressed_len_known = 0;
  }
  else {
    uint32_t i;
    *p_uncompressed_len_known = 1;
    *p_uncompressed_len = 0;
    for (i = 0; i < 8; i++) {
      if (i < sizeof(size_t)) {
        *p_uncompressed_len |= (((size_t)p_src[5 + i]) << (i << 3));    // get (sizeof(size_t)) bytes from p_src, and put it to (*p_uncompressed_len)
      }
      else if (p_src[5 + i] > 0) {
        return R_ERR_OUTPUT_OVERFLOW;                               // uncompressed length overflow from the machine's memory address limit
      }
    }
  }

  *p_lc = (uint8_t)(byte0 % 9);
  byte0 /= 9;
  *p_lp = (uint8_t)(byte0 % 5);
  *p_pb = (uint8_t)(byte0 / 5);

  if (*p_lc > MAX_LC || *p_lp > MAX_LP || *p_pb > MAX_PB)
    return R_ERR_UNSUPPORTED;

  return R_OK;
}


int tinyLzmaDecompress(const uint8_t* p_src, size_t src_len, uint8_t** p_dst, size_t* uncompressed_len)
{

  uint8_t  lc, lp, pb;                                             // lc=0~8   lp=0~4   pb=0~4
  uint32_t dict_len, uncompressed_len_known;

  if (src_len < LZMA_HEADER_LEN)
    return R_ERR_INPUT_OVERFLOW;

  RET_IF_ERROR(parseLzmaHeader(p_src, &lc, &lp, &pb, &dict_len, uncompressed_len, &uncompressed_len_known))

  if (!uncompressed_len_known)
  {
    return R_ERR_OUTPUT_OVERFLOW;
  }

  *p_dst = (unsigned char*)malloc(*uncompressed_len);

  RET_IF_ERROR(lzmaDecode(p_src + LZMA_HEADER_LEN, src_len - LZMA_HEADER_LEN, *p_dst, uncompressed_len, lc, lp, pb));

  return R_OK;
}


```

`Shared/Decompressor/TinyLzmaDecompress.h`:

```h
// TinyLZMA
// Source from https://github.com/WangXuan95/TinyLzma


#ifndef   __TINY_LZMA_DECOMPRESS_H__
#define   __TINY_LZMA_DECOMPRESS_H__

#include <stdint.h>

int tinyLzmaDecompress (const uint8_t *p_src, size_t src_len, uint8_t** p_dst, size_t *p_dst_len);

// return codes of tinyLzmaDecompressor --------------------
#define   R_OK                           0
#define   R_ERR_MEMORY_RUNOUT            1
#define   R_ERR_UNSUPPORTED              2
#define   R_ERR_OUTPUT_OVERFLOW          3
#define   R_ERR_INPUT_OVERFLOW           4
#define   R_ERR_DATA                     5
#define   R_ERR_OUTPUT_LEN_MISMATCH      6

#endif // __TINY_LZMA_DECOMPRESS_H__

```

`Shared/PELoader/PELoader/PEFile.cpp`:

```cpp
#include "PEFile.h"

namespace PELoader
{
	PEFile::PEFile(LPVOID fileBuffer)
	{
		_buffer = (BYTE*)fileBuffer;
		_PIMAGE_DOS_HEADER = (PIMAGE_DOS_HEADER)_buffer;
		_PIMAGE_NT_HEADERS = (PIMAGE_NT_HEADERS)(_buffer + _PIMAGE_DOS_HEADER->e_lfanew);
		_PIMAGE_SECTION_HEADER = IMAGE_FIRST_SECTION(_PIMAGE_NT_HEADERS);
	}

	PEFile::~PEFile()
	{
	}
}
```

`Shared/PELoader/PELoader/PEFile.h`:

```h
#pragma once
#include <windows.h>

namespace PELoader
{
  class PEFile
  {
  public:
    PEFile(LPVOID fileBuffer);
    ~PEFile();

    const PIMAGE_DOS_HEADER DOS_HEADER() { return _PIMAGE_DOS_HEADER; }
    const PIMAGE_NT_HEADERS NT_HEADERS() { return _PIMAGE_NT_HEADERS; }
    const PIMAGE_SECTION_HEADER SECTION_HEADER() { return _PIMAGE_SECTION_HEADER; }

    BYTE* GetBuffer() { return _buffer; }

  private:
    BYTE* _buffer;

    PIMAGE_DOS_HEADER _PIMAGE_DOS_HEADER;
    PIMAGE_NT_HEADERS _PIMAGE_NT_HEADERS;
    PIMAGE_SECTION_HEADER _PIMAGE_SECTION_HEADER;
  };
}
```

`Shared/PELoader/PELoader/PEImage.cpp`:

```cpp
#include "PEImage.h"

namespace PELoader
{
	PEImage::PEImage(LPVOID imageBase)
	{
		_imageBase = imageBase;
		_PIMAGE_DOS_HEADER = (PIMAGE_DOS_HEADER)_imageBase;
		_PIMAGE_NT_HEADERS = (PIMAGE_NT_HEADERS)((BYTE*)_imageBase + _PIMAGE_DOS_HEADER->e_lfanew);
		_PIMAGE_SECTION_HEADER = IMAGE_FIRST_SECTION(_PIMAGE_NT_HEADERS);
		_entryPoint = (BYTE*)_imageBase + _PIMAGE_NT_HEADERS->OptionalHeader.AddressOfEntryPoint;
	}

	PEImage::~PEImage()
	{
	}
}
```

`Shared/PELoader/PELoader/PEImage.h`:

```h
#pragma once
#include <windows.h>

namespace PELoader
{
  class PEImage
  {
  public:
    PEImage(LPVOID imageBase);
    ~PEImage();

    const PIMAGE_DOS_HEADER DOS_HEADER() { return _PIMAGE_DOS_HEADER; }
    const PIMAGE_NT_HEADERS NT_HEADERS() { return _PIMAGE_NT_HEADERS; }
    const PIMAGE_SECTION_HEADER SECTION_HEADER() { return _PIMAGE_SECTION_HEADER; }
    const LPVOID GetImageBase() { return _imageBase; }
    const LPVOID GetEntryPoint() { return _entryPoint; }

  private:
    PIMAGE_DOS_HEADER _PIMAGE_DOS_HEADER;
    PIMAGE_NT_HEADERS _PIMAGE_NT_HEADERS;
    PIMAGE_SECTION_HEADER _PIMAGE_SECTION_HEADER;
    LPVOID _imageBase;
    LPVOID _entryPoint;
  };
}
```

`Shared/PELoader/PELoader/PELoader.cpp`:

```cpp
#include <Windows.h>
#include "PELoader.h"
#include "PEFile.h"
#include "PEImage.h"
#include "TlsResolver.h"
#include "..\TypeDefs\peb.h"

namespace PELoader
{
  PELoader::PELoader()
  {
  }

  PELoader::~PELoader()
  {
  }

  LPVOID PELoader::LoadPE(TlsResolver* tlsResolver, LPVOID fileBuffer)
  {
    PEFile pefile(fileBuffer);
    LPVOID imageBase = MapSections(&pefile);

    PEImage peImage(imageBase); // Using the mapped pe file at actual imageBase
    ApplyRelocations(&peImage, pefile.NT_HEADERS()->OptionalHeader.ImageBase);
    UpdatePEB(&peImage);
    InitializeTlsIndex(tlsResolver, &peImage);
    InitializeTlsData(tlsResolver, &peImage);
    ResolveImports(&peImage);
    ResolveDelayImports(&peImage);
    SetupExceptionHandling(&peImage);
    ApplySectionMemoryProtection(&peImage);
    ExecuteTlsCallbacks(tlsResolver, &peImage);

    return imageBase;
  }

  LPVOID PELoader::MapSections(PEFile* pefile)
  {
    LPVOID imageBase = VirtualAlloc((LPVOID)pefile->NT_HEADERS()->OptionalHeader.ImageBase, pefile->NT_HEADERS()->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    if (imageBase == nullptr)
    {
      imageBase = VirtualAlloc(nullptr, pefile->NT_HEADERS()->OptionalHeader.SizeOfImage, MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
      if (imageBase == nullptr) return nullptr;
    }

    memcpy(imageBase, pefile->GetBuffer(), pefile->NT_HEADERS()->OptionalHeader.SizeOfHeaders);

    for (int i = 0; i < pefile->NT_HEADERS()->FileHeader.NumberOfSections; i++)
    {
      LPVOID sectionDest = (BYTE*)imageBase + pefile->SECTION_HEADER()[i].VirtualAddress;
      LPVOID sectionSrc = pefile->GetBuffer() + pefile->SECTION_HEADER()[i].PointerToRawData;
      SIZE_T sectionSize = min(pefile->SECTION_HEADER()[i].SizeOfRawData, pefile->SECTION_HEADER()[i].Misc.VirtualSize);

      memcpy(sectionDest, sectionSrc, sectionSize);
    }

    return imageBase;
  }

  void PELoader::ApplyRelocations(PEImage* peImage, ULONGLONG originalImageBase)
  {
    ULONGLONG baseDelta = (ULONGLONG)peImage->GetImageBase() - originalImageBase;
    if (baseDelta == 0) return;

    PIMAGE_DATA_DIRECTORY relocDir = &peImage->NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];
    if (relocDir->Size == 0) return;

    PIMAGE_BASE_RELOCATION reloc = (PIMAGE_BASE_RELOCATION)((BYTE*)peImage->GetImageBase() + relocDir->VirtualAddress);
    while (reloc->VirtualAddress && reloc->SizeOfBlock)
    {
      int numEntries = (reloc->SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / sizeof(WORD);
      PWORD relocEntries = (PWORD)((BYTE*)reloc + sizeof(IMAGE_BASE_RELOCATION));

      for (int i = 0; i < numEntries; i++)
      {
        WORD type = relocEntries[i] >> 12;
        WORD offset = relocEntries[i] & 0xFFF;

        switch (type)
        {
          case IMAGE_REL_BASED_ABSOLUTE:
            break;

          case IMAGE_REL_BASED_DIR64:
          {
            ULONGLONG* patchAddr = (ULONGLONG*)((BYTE*)peImage->GetImageBase() + reloc->VirtualAddress + offset);
            *patchAddr += baseDelta;
            break;
          }

          default:
            break;
        }
      }

      reloc = (PIMAGE_BASE_RELOCATION)((BYTE*)reloc + reloc->SizeOfBlock);
    }
  }

  void PELoader::UpdatePEB(PEImage* peImage)
  {
    PEB* peb = (PEB*)__readgsqword(0x60); // Get PEB in x64

    // Required to get specific APIs like GetModuleFileName work
    PLDR_DATA_TABLE_ENTRY entry = GetOwnLdrEntry(peb);
    entry->DllBase = (PVOID)peImage->GetImageBase();
    entry->SizeOfImage = peImage->NT_HEADERS()->OptionalHeader.SizeOfImage;
    entry->EntryPoint = (PVOID)peImage->GetEntryPoint();
    entry->TlsIndex = (USHORT)TLS_OUT_OF_INDEXES; // Do not use the actual tls index here! entry->TlsIndex is TLS_OUT_OF_INDEXES by default, we leave it as is.

    // Set new image base in peb (After calling GetOwnLdrEntry!)
    peb->ImageBaseAddress = (PVOID)peImage->GetImageBase();
  }

  void PELoader::InitializeTlsIndex(TlsResolver* tlsResolver, PEImage* peImage)
  {
    tlsResolver->InitializeTlsIndex(peImage);
  }

  void PELoader::InitializeTlsData(TlsResolver* tlsResolver, PEImage* peImage)
  {
    tlsResolver->InitializeTlsData(peImage);
  }

  void PELoader::ResolveImports(PEImage* peImage)
  {
    PIMAGE_DATA_DIRECTORY importDir = &peImage->NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    if (importDir->Size == 0) return;

    PIMAGE_IMPORT_DESCRIPTOR importDesc = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)peImage->GetImageBase() + importDir->VirtualAddress);
    while (importDesc->Name)
    {
      LPCSTR moduleName = (LPCSTR)((BYTE*)peImage->GetImageBase() + importDesc->Name);

      HMODULE moduleHandle = LoadLibraryA(moduleName);
      if (!moduleHandle) return; // Error

      PIMAGE_THUNK_DATA origFirstThunk = (PIMAGE_THUNK_DATA)((BYTE*)peImage->GetImageBase() + importDesc->OriginalFirstThunk);
      PIMAGE_THUNK_DATA firstThunk = (PIMAGE_THUNK_DATA)((BYTE*)peImage->GetImageBase() + importDesc->FirstThunk);

      while (origFirstThunk->u1.AddressOfData)
      {
        FARPROC functionAddress = nullptr;
        if (origFirstThunk->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
        {
          // Import by ordinal
          WORD ordinal = (WORD)(origFirstThunk->u1.Ordinal & 0xFFFF);
          functionAddress = GetProcAddress(moduleHandle, (LPCSTR)(ULONG_PTR)ordinal);
        }
        else
        {
          // Import by name
          PIMAGE_IMPORT_BY_NAME importByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)peImage->GetImageBase() + origFirstThunk->u1.AddressOfData);
          functionAddress = GetProcAddress(moduleHandle, importByName->Name);
        }
        if (!functionAddress)
        {
          // Error
          return;
        }

        firstThunk->u1.Function = (ULONGLONG)functionAddress;

        origFirstThunk++;
        firstThunk++;
      }
      importDesc++;
    }
  }

  void PELoader::ResolveDelayImports(PEImage* peImage)
  {
    IMAGE_DATA_DIRECTORY* delayImportDirectory = &peImage->NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];
    if (delayImportDirectory->VirtualAddress == 0) return;

    IMAGE_DELAYLOAD_DESCRIPTOR* delayDesc = (IMAGE_DELAYLOAD_DESCRIPTOR*)((BYTE*)peImage->GetImageBase() + delayImportDirectory->VirtualAddress);
    while (delayDesc->DllNameRVA)
    {
      ResolveDelayImport(peImage, delayDesc);
      ++delayDesc;
    }
  }

  void PELoader::SetupExceptionHandling(PEImage* peImage)
  {
    auto exceptionDir = peImage->NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXCEPTION];
    if (exceptionDir.VirtualAddress == 0 || exceptionDir.Size == 0) return;

    auto exceptionTable = reinterpret_cast<RUNTIME_FUNCTION*>((BYTE*)peImage->GetImageBase() + exceptionDir.VirtualAddress);
    DWORD count = exceptionDir.Size / sizeof(RUNTIME_FUNCTION);

    RtlAddFunctionTable(exceptionTable, count, reinterpret_cast<DWORD64>(peImage->GetImageBase()));
  }

  void PELoader::ApplySectionMemoryProtection(PEImage* peImage)
  {
    for (int i = 0; i < peImage->NT_HEADERS()->FileHeader.NumberOfSections; i++)
    {
      DWORD protection = PAGE_READWRITE; // Default protection

      DWORD characteristics = peImage->SECTION_HEADER()[i].Characteristics;
      if (characteristics & IMAGE_SCN_MEM_EXECUTE)
      {
        if (characteristics & IMAGE_SCN_MEM_WRITE)
        {
          protection = PAGE_EXECUTE_READWRITE;
        }
        else if (characteristics & IMAGE_SCN_MEM_READ)
        {
          protection = PAGE_EXECUTE_READ;
        }
        else
        {
          protection = PAGE_EXECUTE;
        }
      }
      else
      {
        if (characteristics & IMAGE_SCN_MEM_WRITE)
        {
          protection = PAGE_READWRITE;
        }
        else if (characteristics & IMAGE_SCN_MEM_READ)
        {
          protection = PAGE_READONLY;
        }
        else
        {
          protection = PAGE_NOACCESS;
        }
      }

      // Apply memory protection
      LPVOID sectionAddress = (BYTE*)peImage->GetImageBase() + peImage->SECTION_HEADER()[i].VirtualAddress;
      SIZE_T sectionSize = peImage->SECTION_HEADER()[i].Misc.VirtualSize;

      if (sectionSize > 0)
      {
        DWORD oldProtect = 0;
        VirtualProtect(sectionAddress, sectionSize, protection, &oldProtect);
      }
    }
  }

  void PELoader::ExecuteTlsCallbacks(TlsResolver* tlsResolver, PEImage* peImage)
  {
    tlsResolver->ExecuteCallbacks(peImage, DLL_PROCESS_ATTACH, nullptr);
  }

  void PELoader::ResolveDelayImport(PEImage* peImage, const IMAGE_DELAYLOAD_DESCRIPTOR* delayDesc)
  {
    const char* dllName = (const char*)((BYTE*)peImage->GetImageBase() + delayDesc->DllNameRVA);

    HMODULE moduleHandle = LoadLibraryA(dllName);
    if (!moduleHandle) return; // Error

    BYTE* imageBase = (BYTE*)peImage->GetImageBase();

    IMAGE_THUNK_DATA* iat = (IMAGE_THUNK_DATA*)(imageBase + delayDesc->ImportAddressTableRVA);
    IMAGE_THUNK_DATA* intt = (IMAGE_THUNK_DATA*)(imageBase + delayDesc->ImportNameTableRVA);
    IMAGE_THUNK_DATA* boundIat = (IMAGE_THUNK_DATA*)(imageBase + delayDesc->BoundImportAddressTableRVA);
    IMAGE_THUNK_DATA* unloadIat = (IMAGE_THUNK_DATA*)(imageBase + delayDesc->UnloadInformationTableRVA);

    while (intt->u1.AddressOfData)
    {
      FARPROC func = nullptr;

      if (intt->u1.Ordinal & IMAGE_ORDINAL_FLAG64)
      {
        // Import by ordinal
        WORD ordinal = (WORD)(intt->u1.Ordinal & 0xFFFF);
        func = GetProcAddress(moduleHandle, (LPCSTR)(ULONG_PTR)ordinal);
      }
      else
      {
        // Import by name
        const IMAGE_IMPORT_BY_NAME* importByName = (IMAGE_IMPORT_BY_NAME*)((BYTE*)peImage->GetImageBase() + intt->u1.AddressOfData);
        func = GetProcAddress(moduleHandle, (LPCSTR)importByName->Name);
      }

      if (!func)
      {
        // Error
        return;
      }

      // Update IAT and optionally Bound IAT and Unload IAT
      iat->u1.Function = (ULONGLONG)func;
      if (delayDesc->BoundImportAddressTableRVA)
      {
        boundIat->u1.Function = (ULONGLONG)func;
      }
      if (delayDesc->UnloadInformationTableRVA)
      {
        unloadIat->u1.Function = (ULONGLONG)func;
      }

      ++iat;
      ++intt;
      if (boundIat) ++boundIat;
      if (unloadIat) ++unloadIat;
    }
  }

  PLDR_DATA_TABLE_ENTRY PELoader::GetOwnLdrEntry(PPEB peb)
  {
    PPEB_LDR_DATA ldr = peb->Ldr;
    LIST_ENTRY* list = &ldr->InLoadOrderModuleList;

    for (LIST_ENTRY* e = list->Flink; e != list; e = e->Flink)
    {
      PLDR_DATA_TABLE_ENTRY entry = CONTAINING_RECORD(e, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
      if ((PBYTE)entry->DllBase == (PBYTE)GetModuleHandle(nullptr))
      {
        return entry;
      }
    }
    return nullptr;
  }
}

```

`Shared/PELoader/PELoader/PELoader.h`:

```h
#pragma once
#include <Windows.h>
#include "..\TypeDefs\peb.h"

namespace PELoader
{
  class TlsResolver;
  class PEFile;
  class PEImage;
}

namespace PELoader
{
  class PELoader
  {
  public:
    PELoader();
    ~PELoader();

    LPVOID LoadPE(TlsResolver* tlsResolver, LPVOID fileBuffer);

  private:
    LPVOID MapSections(PEFile* pefile);
    void ApplyRelocations(PEImage* peImage, ULONGLONG originalImageBase);
    void UpdatePEB(PEImage* peImage);
    void InitializeTlsIndex(TlsResolver* tlsResolver, PEImage* peImage);
    void InitializeTlsData(TlsResolver* tlsResolver, PEImage* peImage);
    void ResolveImports(PEImage* peImage);
    void ResolveDelayImports(PEImage* peImage);
    void ResolveDelayImport(PEImage* peImage, const IMAGE_DELAYLOAD_DESCRIPTOR* delayDesc);
    void SetupExceptionHandling(PEImage* peImage);
    void ExecuteTlsCallbacks(TlsResolver* tlsResolver, PEImage* peImage);
    void ApplySectionMemoryProtection( PEImage* peImage);
    PLDR_DATA_TABLE_ENTRY GetOwnLdrEntry(PPEB peb);
  };
}
```

`Shared/PELoader/PELoader/TlsResolver.cpp`:

```cpp
#include "TlsResolver.h"
#include "PEFile.h"
#include "PEImage.h"
#include "..\TypeDefs\peb.h"

namespace PELoader
{
  TlsResolver::TlsResolver()
  {
    PEImage peLoaderImage(GetModuleHandle(nullptr));
    _tlsIndex = GetTlsIndex(&peLoaderImage); // Get tls index of pe loader. It has been initialized by windows loader. Since we do not use tls data (only one tls callback (TlsCallbackProxy)) we can use this index.
  }

  TlsResolver::~TlsResolver()
  {
  }

  void TlsResolver::InitializeTlsIndex(PEImage* peImage)
  {
    PIMAGE_TLS_DIRECTORY tlsDirectory = GetTlsDirectory(peImage);
    if (tlsDirectory == nullptr || !HasTlsData(tlsDirectory)) return;
    SetTlsIndex(tlsDirectory, _tlsIndex);
  }

  void TlsResolver::InitializeTlsData(PEImage* peImage)
  {
    PIMAGE_TLS_DIRECTORY tlsDirectory = GetTlsDirectory(peImage);
    if (tlsDirectory == nullptr || !HasTlsData(tlsDirectory)) return;

    LPVOID tlsData = CreateTlsData(tlsDirectory);
    if (tlsData == nullptr) return;

    SetTlsData(_tlsIndex, tlsData);
  }

  void TlsResolver::ClearTlsData()
  {
    if (_tlsIndex == TLS_OUT_OF_INDEXES) return;
    LPVOID tlsData = GetTlsData(_tlsIndex);
    if (tlsData != nullptr)
    {
      VirtualFree(tlsData, 0, MEM_RELEASE);
    }
    SetTlsData(_tlsIndex, nullptr);
  }

  void TlsResolver::ExecuteCallbacks(PEImage* peImage, DWORD reason, PVOID context)
  {
    // AddressOfCallBacks points to an array of function pointers (VAs).
    // These VAs are absolute addresses and can be used after relocation.

    PIMAGE_TLS_DIRECTORY tlsDirectory = GetTlsDirectory(peImage);
    if (tlsDirectory == nullptr || !HasTlsCallbacks(tlsDirectory)) return;

    PIMAGE_TLS_CALLBACK* tlsCallbacks = (PIMAGE_TLS_CALLBACK*)(tlsDirectory->AddressOfCallBacks);
    while (*tlsCallbacks)
    {
      (*tlsCallbacks)(peImage->GetImageBase(), reason, context);
      tlsCallbacks++;
    }
  }

  PIMAGE_TLS_DIRECTORY TlsResolver::GetTlsDirectory(PEImage* peImage)
  {
    PIMAGE_DATA_DIRECTORY tlsDataDir = &peImage->NT_HEADERS()->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_TLS];
    if (tlsDataDir->Size == 0 || tlsDataDir->VirtualAddress == 0) return nullptr;

    PIMAGE_TLS_DIRECTORY tlsDirectory = (PIMAGE_TLS_DIRECTORY)((BYTE*)peImage->GetImageBase() + tlsDataDir->VirtualAddress);
    return tlsDirectory;
  }

  BOOL TlsResolver::HasTlsData(PIMAGE_TLS_DIRECTORY tlsDirectory)
  {
    if (tlsDirectory != nullptr && tlsDirectory->AddressOfIndex != 0 && tlsDirectory->StartAddressOfRawData != 0 && tlsDirectory->EndAddressOfRawData != 0)
    {
      return TRUE;
    }
    return FALSE;
  }

  BOOL TlsResolver::HasTlsCallbacks(PIMAGE_TLS_DIRECTORY tlsDirectory)
  {
    if (tlsDirectory != nullptr && tlsDirectory->AddressOfCallBacks != 0)
    {
      PIMAGE_TLS_CALLBACK* tlsCallbacks = (PIMAGE_TLS_CALLBACK*)(tlsDirectory->AddressOfCallBacks);
      return (*tlsCallbacks != nullptr);
    }
    return FALSE;
  }

  ULONG TlsResolver::GetTlsIndex(PEImage* peImage)
  {
    PIMAGE_TLS_DIRECTORY tlsDirectory = GetTlsDirectory(peImage);
    if (tlsDirectory == nullptr) return 0;
    ULONG* tlsIndexAddress = (ULONG*)(tlsDirectory->AddressOfIndex); // This is an absolute VA after relocations
    if (tlsIndexAddress == nullptr) return 0;

    return *tlsIndexAddress;
  }

  void TlsResolver::SetTlsIndex(PIMAGE_TLS_DIRECTORY tlsDirectory, ULONG tlsIndex)
  {
    ULONG* tlsIndexAddress = (ULONG*)(tlsDirectory->AddressOfIndex); // This is an absolute VA after relocations
    if (tlsIndexAddress == nullptr) return;
    *tlsIndexAddress = tlsIndex;
  }

  LPVOID TlsResolver::CreateTlsData(PIMAGE_TLS_DIRECTORY tlsDirectory)
  {
    size_t rawDataSize = (BYTE*)tlsDirectory->EndAddressOfRawData - (BYTE*)tlsDirectory->StartAddressOfRawData;
    size_t totalDataSize = rawDataSize + tlsDirectory->SizeOfZeroFill;

    // Allocate memory for the TLS data for the current thread
    LPVOID tlsDataBlock = VirtualAlloc(nullptr, totalDataSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!tlsDataBlock) return nullptr;

    // Copy the default TLS data to the thread specific memory
    if (rawDataSize > 0 && tlsDirectory->StartAddressOfRawData != 0)
    {
      // StartAddressOfRawData is a VA, it should be an absolute pointer after relocations.
      memcpy(tlsDataBlock, (void*)tlsDirectory->StartAddressOfRawData, rawDataSize);
    }

    if (tlsDirectory->SizeOfZeroFill > 0)
    {
      memset((BYTE*)tlsDataBlock + rawDataSize, 0, tlsDirectory->SizeOfZeroFill);
    }

    return tlsDataBlock;
  }

  void TlsResolver::SetTlsData(ULONG tlsIndex, LPVOID tlsData)
  {
    // Update the TEB directly, because TlsSetValue will NOT set it in TEB.
    PTEB teb = NtCurrentTeb();
    if (teb)
    {
      if (tlsIndex < 64)
      {
        // DWORD64* ThreadLocalStoragePointer = (DWORD64*)__readgsqword(0x58);
        // Directly set the TEB slot
        ((ULONG_PTR*)teb->ThreadLocalStoragePointer)[tlsIndex] = (ULONG_PTR)tlsData;
      }
      else
      {
        PEB* peb = teb->ProcessEnvironmentBlock;
        PVOID* tlsArray = (PVOID*)peb->TlsExpansionSlots;
        if (!tlsArray)
        {
          peb->TlsExpansionSlots = (PVOID*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(PVOID) * 1024);
        }
        if (peb->TlsExpansionSlots)
        {
          peb->TlsExpansionSlots[tlsIndex - 64] = tlsData;
        }
      }
    }
  }

  LPVOID TlsResolver::GetTlsData(ULONG tlsIndex)
  {
    PTEB teb = NtCurrentTeb();
    if (teb)
    {
      if (tlsIndex < 64)
      {
        return (LPVOID)((ULONG_PTR*)teb->ThreadLocalStoragePointer)[tlsIndex];
      }
      else
      {
        PEB* peb = teb->ProcessEnvironmentBlock;
        if (peb->TlsExpansionSlots)
        {
          return peb->TlsExpansionSlots[tlsIndex - 64];
        }
      }
    }
    return nullptr;
  }
}


```

`Shared/PELoader/PELoader/TlsResolver.h`:

```h
#pragma once
#include <Windows.h>

namespace PELoader
{
  class PEImage;
}

namespace PELoader
{
  class TlsResolver
  {
  public:
    TlsResolver();
    ~TlsResolver();

    void InitializeTlsIndex(PEImage* peImage);
    void InitializeTlsData(PEImage* peImage);
    void ClearTlsData();
    void ExecuteCallbacks(PEImage* peImage, DWORD reason, PVOID context);

  private:
    PIMAGE_TLS_DIRECTORY GetTlsDirectory(PEImage* peImage);

    BOOL HasTlsData(PIMAGE_TLS_DIRECTORY tlsDirectory);
    BOOL HasTlsCallbacks(PIMAGE_TLS_DIRECTORY tlsDirectory);

    ULONG GetTlsIndex(PEImage* peImage);
    void SetTlsIndex(PIMAGE_TLS_DIRECTORY tlsDirectory, ULONG tlsIndex);

    LPVOID CreateTlsData(PIMAGE_TLS_DIRECTORY tlsDirectory);
    void SetTlsData(ULONG tlsIndex, LPVOID tlsData);
    LPVOID GetTlsData(ULONG tlsIndex);

  private:
    ULONG _tlsIndex;
  };
}

```

`Shared/PELoader/TlsCallbackProxy/TlsCallbackProxy.h`:

```h
#pragma once
#include <Windows.h>
#include "..\..\CRT\crt_tls.h"

void TlsCallbackProxy(PVOID hModule, DWORD dwReason, PVOID pContext);

#pragma comment (linker, "/INCLUDE:_tls_used")
#pragma comment (linker, "/INCLUDE:tls_callback_func")

#pragma const_seg(".CRT$XLB")
EXTERN_C const PIMAGE_TLS_CALLBACK tls_callback_func = (PIMAGE_TLS_CALLBACK)TlsCallbackProxy;

#pragma const_seg()
```

`Shared/PELoader/TypeDefs/peb.h`:

```h
#pragma once
#include <Windows.h>

typedef struct _CLIENT_ID
{
  HANDLE UniqueProcess;
  HANDLE UniqueThread;
} CLIENT_ID, * PCLIENT_ID;

typedef struct _UNICODE_STRING {
  USHORT Length;
  USHORT MaximumLength;
  PWSTR  Buffer;
} UNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY
{
  LIST_ENTRY InLoadOrderLinks;
  LIST_ENTRY InMemoryOrderLinks;
  union
  {
    LIST_ENTRY InInitializationOrderLinks;
    LIST_ENTRY InProgressLinks;
  };
  PVOID DllBase;
  PVOID EntryPoint;
  ULONG SizeOfImage;
  UNICODE_STRING FullDllName;
  UNICODE_STRING BaseDllName;
  union
  {
    UCHAR FlagGroup[4];
    ULONG Flags;
    struct
    {
      ULONG PackagedBinary : 1;
      ULONG MarkedForRemoval : 1;
      ULONG ImageDll : 1;
      ULONG LoadNotificationsSent : 1;
      ULONG TelemetryEntryProcessed : 1;
      ULONG ProcessStaticImport : 1;
      ULONG InLegacyLists : 1;
      ULONG InIndexes : 1;
      ULONG ShimDll : 1;
      ULONG InExceptionTable : 1;
      ULONG ReservedFlags1 : 2;
      ULONG LoadInProgress : 1;
      ULONG LoadConfigProcessed : 1;
      ULONG EntryProcessed : 1;
      ULONG ProtectDelayLoad : 1;
      ULONG ReservedFlags3 : 2;
      ULONG DontCallForThreads : 1;
      ULONG ProcessAttachCalled : 1;
      ULONG ProcessAttachFailed : 1;
      ULONG CorDeferredValidate : 1;
      ULONG CorImage : 1;
      ULONG DontRelocate : 1;
      ULONG CorILOnly : 1;
      ULONG ReservedFlags5 : 3;
      ULONG Redirected : 1;
      ULONG ReservedFlags6 : 2;
      ULONG CompatDatabaseProcessed : 1;
    } s;
  } u;
  USHORT ObsoleteLoadCount;
  USHORT TlsIndex;
  // other fields omitted
} LDR_DATA_TABLE_ENTRY, * PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
  ULONG Length;
  BOOLEAN Initialized;
  HANDLE SsHandle;
  LIST_ENTRY InLoadOrderModuleList;
  LIST_ENTRY InMemoryOrderModuleList;
  LIST_ENTRY InInitializationOrderModuleList;
  PVOID EntryInProgress;
  BOOLEAN ShutdownInProgress;
  HANDLE ShutdownThreadId;
} PEB_LDR_DATA, * PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS {
  ULONG MaximumLength;
  ULONG Length;
  ULONG Flags;
  ULONG DebugFlags;
  PVOID ConsoleHandle;
  ULONG ConsoleFlags;
  HANDLE StandardInput;
  HANDLE StandardOutput;
  HANDLE StandardError;
  UNICODE_STRING CurrentDirectoryPath;
  HANDLE CurrentDirectoryHandle;
  UNICODE_STRING DllPath;
  UNICODE_STRING ImagePathName;
  UNICODE_STRING CommandLine;
  PVOID Environment;
  ULONG StartingX;
  ULONG StartingY;
  ULONG CountX;
  ULONG CountY;
  ULONG CountCharsX;
  ULONG CountCharsY;
  ULONG FillAttribute;
  ULONG WindowFlags;
  ULONG ShowWindowFlags;
  UNICODE_STRING WindowTitle;
  UNICODE_STRING DesktopInfo;
  UNICODE_STRING ShellInfo;
  UNICODE_STRING RuntimeData;
  PVOID CurrentDirectories;
  ULONG EnvironmentSize;
  ULONG EnvironmentVersion;
  PVOID PackageDependencyData;
  ULONG ProcessGroupId;
  ULONG LoaderThreads;
} RTL_USER_PROCESS_PARAMETERS, * PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB {
  BOOLEAN InheritedAddressSpace;
  BOOLEAN ReadImageFileExecOptions;
  BOOLEAN BeingDebugged;
  BOOLEAN BitField;
  PVOID Mutant;
  PVOID ImageBaseAddress; // Base address of the loaded image
  PPEB_LDR_DATA Ldr;      // Pointer to the loader data
  PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
  PVOID SubSystemData;
  PVOID ProcessHeap;
  PVOID FastPebLock;
  PVOID AtlThunkSListPtr;
  PVOID IFEOKey;
  ULONG CrossProcessFlags;
  PVOID KernelCallbackTable;
  ULONG SystemReserved;
  ULONG AtlThunkSListPtr32;
  PVOID ApiSetMap;
  ULONG TlsExpansionCounter;
  PVOID TlsBitmap;
  ULONG TlsBitmapBits[2];
  PVOID ReadOnlySharedMemoryBase;
  PVOID HotpatchInformation;
  PVOID* TlsExpansionSlots; // TLS slots for tls index >= 64
} PEB, * PPEB;

typedef struct _TEB {
  NT_TIB NtTib;
  PVOID  EnvironmentPointer;
  CLIENT_ID ClientId;
  PVOID ActiveRpcHandle;
  PVOID ThreadLocalStoragePointer;  // TLS slots for tls index < 64
  PPEB ProcessEnvironmentBlock;
  // other fields omitted
} TEB, * PTEB;
```

`Shared/PELoaderStub/PELoaderStub.cpp`:

```cpp
#include "PELoaderStub.h"
#include "..\ResourceLoader\ResourceLoader.h"
#include "..\Decompressor\Decompressor.h"
#include "..\PELoader\PELoader\PELoader.h"
#include "..\PELoader\PELoader\PEImage.h"
#include "..\PELoader\PELoader\TlsResolver.h"

namespace PELoaderStub
{
  PELoaderStub::PELoaderStub()
  {
  }

  PELoaderStub::~PELoaderStub()
  {
  }

  PELoader::PEImage* PELoaderStub::Load(PELoader::TlsResolver* tlsResolver)
  {
    // Load packed target from resource
    DWORD targetSize = 0;
    ResourceLoader::ResourceLoader resourceLoader;
    BYTE* targetBuffer = resourceLoader.LoadResource(L"PACKED", RT_RCDATA, targetSize);
    if (targetBuffer == nullptr || targetSize == 0) return 0;

    // Decompress target
    size_t decompressedSize = 0;
    BYTE* decompressed = NULL;
    Decompressor::Decompressor decompressor;
    decompressor.Decompress(targetBuffer, targetSize, &decompressed, &decompressedSize);
    resourceLoader.Free(targetBuffer);

    // Load target
    PELoader::PELoader peLoader;
    LPVOID imageBase = peLoader.LoadPE(tlsResolver, (LPVOID)decompressed);
    decompressor.Free(decompressed);

    return new PELoader::PEImage(imageBase);
  }
}
```

`Shared/PELoaderStub/PELoaderStub.h`:

```h
#pragma once
#include <windows.h>

namespace PELoader
{
  class PEImage;
  class TlsResolver;
  
}

namespace PELoaderStub
{
  class PELoaderStub
  {
  public:
    PELoaderStub();
    ~PELoaderStub();

    PELoader::PEImage* Load(PELoader::TlsResolver* tlsResolver);
  };
}
```

`Shared/ResourceLoader/ResourceLoader.cpp`:

```cpp
#include "ResourceLoader.h"

namespace ResourceLoader
{
  ResourceLoader::ResourceLoader()
  {
  }

  ResourceLoader::~ResourceLoader()
  {
  }

  BYTE* ResourceLoader::LoadResource(LPCWSTR resourceName, LPCWSTR resourceType, DWORD& resourceSize)
  {
    resourceSize = 0;

    HMODULE moduleHandle = ::GetModuleHandle(nullptr);
    HRSRC resourceHandle = ::FindResource(moduleHandle, resourceName, resourceType);
    if (resourceHandle == nullptr) return nullptr;

    resourceSize = ::SizeofResource(moduleHandle, resourceHandle);
    if (resourceSize == 0) return nullptr;

    HGLOBAL resourceDataHandle = ::LoadResource(moduleHandle, resourceHandle);
    if (resourceDataHandle == nullptr) return nullptr;

    LPVOID resourceData = ::LockResource(resourceDataHandle);
    if (resourceData == nullptr) return nullptr;

    BYTE* buffer = new BYTE[resourceSize];
    memcpy(buffer, resourceData, resourceSize);
    return buffer;
  }

  void ResourceLoader::Free(BYTE* resourceBuffer)
  {
    if (resourceBuffer == nullptr) return;
    delete[] resourceBuffer;
  }
}

```

`Shared/ResourceLoader/ResourceLoader.h`:

```h
#pragma once
#include <Windows.h>

namespace ResourceLoader
{
  class ResourceLoader
  {
  public:
    ResourceLoader();
    ~ResourceLoader();

    BYTE* LoadResource(LPCWSTR resourceName, LPCWSTR resourceType, DWORD& resourceSize);
    void Free(BYTE* resourceBuffer);
  };
}
```