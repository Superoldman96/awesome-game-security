Project Path: arc_gmh5225_mvisor_ichz7mel

Source Tree:

```txt
arc_gmh5225_mvisor_ichz7mel
├── LICENSE
├── README.md
├── config
│   ├── i440fx.yaml
│   ├── q35.yaml
│   └── sample.yaml
├── core
│   ├── configuration.cc
│   ├── device.cc
│   ├── device_manager.cc
│   ├── dirty_memory.proto
│   ├── image.proto
│   ├── io_thread.cc
│   ├── machine.cc
│   ├── memory_manager.cc
│   ├── meson.build
│   ├── object.cc
│   ├── pci_device.cc
│   ├── pci_device.proto
│   ├── vcpu.cc
│   └── vcpu.proto
├── devices
│   ├── acpi
│   │   ├── ich9_lpc.cc
│   │   ├── ich9_lpc.proto
│   │   ├── ich9_smbus.cc
│   │   ├── meson.build
│   │   ├── piix3.cc
│   │   ├── piix3.proto
│   │   ├── piix4_pm.cc
│   │   ├── piix4_pm.proto
│   │   ├── pmio.cc
│   │   ├── pmio.h
│   │   └── pmio.proto
│   ├── agents
│   │   ├── meson.build
│   │   ├── qemu_guest_agent.cc
│   │   ├── spice_agent.cc
│   │   └── webdav_agent.cc
│   ├── ahci
│   │   ├── ahci_cdrom.cc
│   │   ├── ahci_disk.cc
│   │   ├── ahci_host.cc
│   │   ├── ahci_host.h
│   │   ├── ahci_host.proto
│   │   ├── ahci_internal.h
│   │   ├── ahci_port.cc
│   │   ├── ahci_port.h
│   │   ├── ata_cdrom.cc
│   │   ├── ata_cdrom.h
│   │   ├── ata_cdrom.proto
│   │   ├── ata_disk.cc
│   │   ├── ata_disk.h
│   │   ├── ata_internal.h
│   │   ├── ata_storage.cc
│   │   ├── ata_storage.h
│   │   ├── ich9_ahci.cc
│   │   ├── ide_cdrom.cc
│   │   ├── ide_disk.cc
│   │   ├── ide_host.cc
│   │   ├── ide_host.h
│   │   ├── ide_host.proto
│   │   ├── ide_port.cc
│   │   ├── ide_port.h
│   │   ├── meson.build
│   │   └── piix3_ide.cc
│   ├── audio
│   │   ├── ac97.cc
│   │   ├── ac97.proto
│   │   ├── hda_codec.h
│   │   ├── hda_duplex.cc
│   │   ├── hda_duplex.proto
│   │   ├── hda_internal.h
│   │   ├── ich9_hda.cc
│   │   ├── ich9_hda.h
│   │   ├── ich9_hda.proto
│   │   └── meson.build
│   ├── display
│   │   ├── meson.build
│   │   ├── qxl
│   │   │   ├── canvas
│   │   │   │   ├── canvas_base.c
│   │   │   │   ├── canvas_base.h
│   │   │   │   ├── canvas_utils.c
│   │   │   │   ├── canvas_utils.h
│   │   │   │   ├── config.h
│   │   │   │   ├── draw.h
│   │   │   │   ├── lines.c
│   │   │   │   ├── lines.h
│   │   │   │   ├── log.c
│   │   │   │   ├── log.h
│   │   │   │   ├── lz.c
│   │   │   │   ├── lz.h
│   │   │   │   ├── lz_common.h
│   │   │   │   ├── lz_compress_tmpl.c
│   │   │   │   ├── lz_config.h
│   │   │   │   ├── lz_decompress_tmpl.c
│   │   │   │   ├── macros.h
│   │   │   │   ├── mem.c
│   │   │   │   ├── mem.h
│   │   │   │   ├── meson.build
│   │   │   │   ├── pixman_utils.c
│   │   │   │   ├── pixman_utils.h
│   │   │   │   ├── quic.c
│   │   │   │   ├── quic.h
│   │   │   │   ├── quic_config.h
│   │   │   │   ├── quic_family_tmpl.c
│   │   │   │   ├── quic_tmpl.c
│   │   │   │   ├── rect.h
│   │   │   │   ├── region.c
│   │   │   │   ├── region.h
│   │   │   │   ├── ring.h
│   │   │   │   ├── rop3.c
│   │   │   │   ├── rop3.h
│   │   │   │   ├── sw_canvas.c
│   │   │   │   ├── sw_canvas.h
│   │   │   │   └── verify.h
│   │   │   ├── meson.build
│   │   │   ├── qxl.cc
│   │   │   ├── qxl.h
│   │   │   ├── qxl.proto
│   │   │   ├── qxl_dev.h
│   │   │   ├── qxl_modes.h
│   │   │   ├── qxl_parser.cc
│   │   │   ├── qxl_parser.h
│   │   │   ├── qxl_render.cc
│   │   │   └── qxl_render.h
│   │   ├── vbe.h
│   │   ├── vga.cc
│   │   ├── vga.h
│   │   ├── vga.proto
│   │   └── vga_regs.h
│   ├── kvm
│   │   ├── kvm_clock.cc
│   │   └── meson.build
│   ├── meson.build
│   ├── nvram
│   │   ├── acpi_dsdt
│   │   │   ├── acpi-dsdt-cpu-hotplug.dsl
│   │   │   ├── acpi-dsdt-dbug.dsl
│   │   │   ├── acpi-dsdt-hpet.dsl
│   │   │   ├── acpi-dsdt-isa.dsl
│   │   │   ├── acpi-dsdt-pci-crs.dsl
│   │   │   ├── acpi-dsdt.dsl
│   │   │   ├── acpi_dsdt.hex.h
│   │   │   ├── build_hex.sh
│   │   │   ├── meson.build
│   │   │   ├── q35-acpi-dsdt.dsl
│   │   │   └── q35_acpi_dsdt.hex.h
│   │   ├── firmware_config.cc
│   │   ├── firmware_config.h
│   │   ├── firmware_config.proto
│   │   ├── meson.build
│   │   ├── smbios.cc
│   │   └── smbios.h
│   ├── pci
│   │   ├── i440fx_host.cc
│   │   ├── meson.build
│   │   ├── pci_host.cc
│   │   ├── pci_host.h
│   │   ├── pci_host.proto
│   │   └── q35_host.cc
│   ├── superio
│   │   ├── cmos.cc
│   │   ├── cmos.proto
│   │   ├── debug_console.cc
│   │   ├── dummy.cc
│   │   ├── floppy.cc
│   │   ├── floppy.h
│   │   ├── i82078_fdc.cc
│   │   ├── i82078_fdc.proto
│   │   ├── i8257_dma.cc
│   │   ├── i8257_dma.h
│   │   ├── i8257_dma.proto
│   │   ├── meson.build
│   │   ├── ps2.cc
│   │   ├── ps2.proto
│   │   └── uart.cc
│   ├── usb
│   │   ├── meson.build
│   │   ├── piix3_uhci.cc
│   │   ├── uhci_host.cc
│   │   ├── uhci_host.h
│   │   ├── uhci_host.proto
│   │   ├── uhci_internal.h
│   │   ├── usb.h
│   │   ├── usb_descriptor.h
│   │   ├── usb_device.cc
│   │   ├── usb_device.h
│   │   ├── usb_device.proto
│   │   ├── usb_hid.cc
│   │   ├── usb_hid.h
│   │   ├── usb_midi.cc
│   │   ├── usb_tablet.cc
│   │   ├── usb_wacom.cc
│   │   ├── xhci_host.cc
│   │   ├── xhci_host.h
│   │   ├── xhci_host.proto
│   │   └── xhci_internal.h
│   ├── vfio
│   │   ├── meson.build
│   │   ├── vfio_pci.cc
│   │   └── vfio_pci.h
│   └── virtio
│       ├── fuse
│       │   ├── fuse.cc
│       │   ├── fuse.h
│       │   ├── fuse_common.h
│       │   ├── fuse_kernel.h
│       │   ├── fuse_lowlevel.h
│       │   └── meson.build
│       ├── meson.build
│       ├── virtio_block.cc
│       ├── virtio_console.cc
│       ├── virtio_console.proto
│       ├── virtio_fs.cc
│       ├── virtio_network.cc
│       ├── virtio_pci.cc
│       ├── virtio_pci.h
│       ├── virtio_pci.proto
│       ├── virtio_vgpu.cc
│       ├── virtio_vgpu.h
│       └── virtio_vgpu.proto
├── docs
│   ├── cpuids
│   │   ├── icelake
│   │   ├── icelake-mvisor
│   │   ├── skylake
│   │   └── skylake-qemu
│   ├── multimedia.jpg
│   ├── qemu_migration
│   ├── stdvga_set_mode.txt
│   ├── ubuntu.jpg
│   └── vgpu.jpg
├── gui
│   ├── gtk
│   │   └── meson.build
│   └── sdl
│       ├── keymap.c
│       ├── keymap.h
│       ├── meson.build
│       ├── viewer.cc
│       └── viewer.h
├── images
│   ├── image.cc
│   ├── meson.build
│   ├── qcow2.cc
│   ├── qcow2_create.cc
│   └── raw.cc
├── include
│   ├── configuration.h
│   ├── device.h
│   ├── device_interface.h
│   ├── device_manager.h
│   ├── disk_image.h
│   ├── hyperv
│   │   ├── cpuid.h
│   │   ├── hypercall.h
│   │   └── hyperv.h
│   ├── io_thread.h
│   ├── linuz
│   │   ├── kvm_para.h
│   │   ├── vfio.h
│   │   ├── virgl_protocol.h
│   │   ├── virtio_blk.h
│   │   └── virtio_net.h
│   ├── logger.h
│   ├── lru_cache.h
│   ├── machine.h
│   ├── memory_manager.h
│   ├── migration.h
│   ├── object.h
│   ├── pci_device.h
│   ├── qcow2.h
│   ├── spice
│   │   ├── barrier.h
│   │   ├── end-packed.h
│   │   ├── enums.h
│   │   ├── ipc_ring.h
│   │   ├── macros.h
│   │   ├── start-packed.h
│   │   ├── types.h
│   │   └── vd_agent.h
│   ├── utilities.h
│   └── vcpu.h
├── main.cc
├── meson.build
├── meson_options.txt
├── migration
│   ├── file_reader.cc
│   ├── file_writer.cc
│   ├── meson.build
│   ├── network_reader.cc
│   └── network_writer.cc
├── networks
│   └── uip
│       ├── core.cc
│       ├── dhcp.cc
│       ├── icmp.cc
│       ├── ipv4.cc
│       ├── map_tcp.cc
│       ├── meson.build
│       ├── redirect_icmp.cc
│       ├── redirect_tcp.cc
│       ├── redirect_udp.cc
│       ├── tcp.cc
│       ├── udp.cc
│       └── uip.h
├── scripts
│   ├── create_vfio.sh
│   ├── debug.sh
│   └── debug_load.sh
├── share
│   ├── bios-256k.bin
│   ├── bios-debug.bin
│   ├── empty.qcow2
│   ├── vgabios-qxl.bin
│   └── vgabios-stdvga.bin
├── sweet-server
└── utilities
    ├── classes.cc
    ├── logger.cc
    ├── meson.build
    ├── zero.cc
    └── zstd.cc

```

`LICENSE`:

```
                    GNU GENERAL PUBLIC LICENSE
                       Version 3, 29 June 2007

 Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

                            Preamble

  The GNU General Public License is a free, copyleft license for
software and other kinds of works.

  The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program--to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

  To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

  Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

  For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

  Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users' freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

  Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

  The precise terms and conditions for copying, distribution and
modification follow.

                       TERMS AND CONDITIONS

  0. Definitions.

  "This License" refers to version 3 of the GNU General Public License.

  "Copyright" also means copyright-like laws that apply to other kinds of
works, such as semiconductor masks.

  "The Program" refers to any copyrightable work licensed under this
License.  Each licensee is addressed as "you".  "Licensees" and
"recipients" may be individuals or organizations.

  To "modify" a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of an
exact copy.  The resulting work is called a "modified version" of the
earlier work or a work "based on" the earlier work.

  A "covered work" means either the unmodified Program or a work based
on the Program.

  To "propagate" a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

  To "convey" a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user through
a computer network, with no transfer of a copy, is not conveying.

  An interactive user interface displays "Appropriate Legal Notices"
to the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent item in the list meets this criterion.

  1. Source Code.

  The "source code" for a work means the preferred form of the work
for making modifications to it.  "Object code" means any non-source
form of a work.

  A "Standard Interface" means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

  The "System Libraries" of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
"Major Component", in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

  The "Corresponding Source" for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

  The Corresponding Source need not include anything that users
can regenerate automatically from other parts of the Corresponding
Source.

  The Corresponding Source for a work in source code form is that
same work.

  2. Basic Permissions.

  All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

  You may make, run and propagate covered works that you do not
convey, without conditions so long as your license otherwise remains
in force.  You may convey covered works to others for the sole purpose
of having them make modifications exclusively for you, or provide you
with facilities for running those works, provided that you comply with
the terms of this License in conveying all material for which you do
not control copyright.  Those thus making or running the covered works
for you must do so exclusively on your behalf, under your direction
and control, on terms that prohibit them from making any copies of
your copyrighted material outside their relationship with you.

  Conveying under any other circumstances is permitted solely under
the conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

  3. Protecting Users' Legal Rights From Anti-Circumvention Law.

  No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

  When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such circumvention
is effected by exercising rights under this License with respect to
the covered work, and you disclaim any intention to limit operation or
modification of the work as a means of enforcing, against the work's
users, your or third parties' legal rights to forbid circumvention of
technological measures.

  4. Conveying Verbatim Copies.

  You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

  You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

  You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these conditions:

    a) The work must carry prominent notices stating that you modified
    it, and giving a relevant date.

    b) The work must carry prominent notices stating that it is
    released under this License and any conditions added under section
    7.  This requirement modifies the requirement in section 4 to
    "keep intact all notices".

    c) You must license the entire work, as a whole, under this
    License to anyone who comes into possession of a copy.  This
    License will therefore apply, along with any applicable section 7
    additional terms, to the whole of the work, and all its parts,
    regardless of how they are packaged.  This License gives no
    permission to license the work in any other way, but it does not
    invalidate such permission if you have separately received it.

    d) If the work has interactive user interfaces, each must display
    Appropriate Legal Notices; however, if the Program has interactive
    interfaces that do not display Appropriate Legal Notices, your
    work need not make them do so.

  A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
"aggregate" if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

  6. Conveying Non-Source Forms.

  You may convey a covered work in object code form under the terms
of sections 4 and 5, provided that you also convey the
machine-readable Corresponding Source under the terms of this License,
in one of these ways:

    a) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by the
    Corresponding Source fixed on a durable physical medium
    customarily used for software interchange.

    b) Convey the object code in, or embodied in, a physical product
    (including a physical distribution medium), accompanied by a
    written offer, valid for at least three years and valid for as
    long as you offer spare parts or customer support for that product
    model, to give anyone who possesses the object code either (1) a
    copy of the Corresponding Source for all the software in the
    product that is covered by this License, on a durable physical
    medium customarily used for software interchange, for a price no
    more than your reasonable cost of physically performing this
    conveying of source, or (2) access to copy the
    Corresponding Source from a network server at no charge.

    c) Convey individual copies of the object code with a copy of the
    written offer to provide the Corresponding Source.  This
    alternative is allowed only occasionally and noncommercially, and
    only if you received the object code with such an offer, in accord
    with subsection 6b.

    d) Convey the object code by offering access from a designated
    place (gratis or for a charge), and offer equivalent access to the
    Corresponding Source in the same way through the same place at no
    further charge.  You need not require recipients to copy the
    Corresponding Source along with the object code.  If the place to
    copy the object code is a network server, the Corresponding Source
    may be on a different server (operated by you or a third party)
    that supports equivalent copying facilities, provided you maintain
    clear directions next to the object code saying where to find the
    Corresponding Source.  Regardless of what server hosts the
    Corresponding Source, you remain obligated to ensure that it is
    available for as long as needed to satisfy these requirements.

    e) Convey the object code using peer-to-peer transmission, provided
    you inform other peers where the object code and Corresponding
    Source of the work are being offered to the general public at no
    charge under subsection 6d.

  A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

  A "User Product" is either (1) a "consumer product", which means any
tangible personal property which is normally used for personal, family,
or household purposes, or (2) anything designed or sold for incorporation
into a dwelling.  In determining whether a product is a consumer product,
doubtful cases shall be resolved in favor of coverage.  For a particular
product received by a particular user, "normally used" refers to a
typical or common use of that class of product, regardless of the status
of the particular user or of the way in which the particular user
actually uses, or expects or is expected to use, the product.  A product
is a consumer product regardless of whether the product has substantial
commercial, industrial or non-consumer uses, unless such uses represent
the only significant mode of use of the product.

  "Installation Information" for a User Product means any methods,
procedures, authorization keys, or other information required to install
and execute modified versions of a covered work in that User Product from
a modified version of its Corresponding Source.  The information must
suffice to ensure that the continued functioning of the modified object
code is in no case prevented or interfered with solely because
modification has been made.

  If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

  The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or updates
for a work that has been modified or installed by the recipient, or for
the User Product in which it has been modified or installed.  Access to a
network may be denied when the modification itself materially and
adversely affects the operation of the network or violates the rules and
protocols for communication across the network.

  Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

  7. Additional Terms.

  "Additional permissions" are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

  When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

  Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders of
that material) supplement the terms of this License with terms:

    a) Disclaiming warranty or limiting liability differently from the
    terms of sections 15 and 16 of this License; or

    b) Requiring preservation of specified reasonable legal notices or
    author attributions in that material or in the Appropriate Legal
    Notices displayed by works containing it; or

    c) Prohibiting misrepresentation of the origin of that material, or
    requiring that modified versions of such material be marked in
    reasonable ways as different from the original version; or

    d) Limiting the use for publicity purposes of names of licensors or
    authors of the material; or

    e) Declining to grant rights under trademark law for use of some
    trade names, trademarks, or service marks; or

    f) Requiring indemnification of licensors and authors of that
    material by anyone who conveys the material (or modified versions of
    it) with contractual assumptions of liability to the recipient, for
    any liability that these contractual assumptions directly impose on
    those licensors and authors.

  All other non-permissive additional terms are considered "further
restrictions" within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

  If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

  Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions;
the above requirements apply either way.

  8. Termination.

  You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

  However, if you cease all violation of this License, then your
license from a particular copyright holder is reinstated (a)
provisionally, unless and until the copyright holder explicitly and
finally terminates your license, and (b) permanently, if the copyright
holder fails to notify you of the violation by some reasonable means
prior to 60 days after the cessation.

  Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

  Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

  9. Acceptance Not Required for Having Copies.

  You are not required to accept this License in order to receive or
run a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

  Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

  An "entity transaction" is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

  You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

  11. Patents.

  A "contributor" is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's "contributor version".

  A contributor's "essential patent claims" are all patent claims
owned or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, "control" includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

  Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

  In the following three paragraphs, a "patent license" is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To "grant" such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

  If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  "Knowingly relying" means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

  If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

  A patent license is "discriminatory" if it does not include within
the scope of its coverage, prohibits the exercise of, or is
conditioned on the non-exercise of one or more of the rights that are
specifically granted under this License.  You may not convey a covered
work if you are a party to an arrangement with a third party that is
in the business of distributing software, under which you make payment
to the third party based on the extent of your activity of conveying
the work, and under which the third party grants, to any of the
parties who would receive the covered work from you, a discriminatory
patent license (a) in connection with copies of the covered work
conveyed by you (or copies made from those copies), or (b) primarily
for and in connection with specific products or compilations that
contain the covered work, unless you entered into that arrangement,
or that patent license was granted, prior to 28 March 2007.

  Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

  12. No Surrender of Others' Freedom.

  If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey a
covered work so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you may
not convey it at all.  For example, if you agree to terms that obligate you
to collect a royalty for further conveying from those to whom you convey
the Program, the only way you could satisfy both those terms and this
License would be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

  Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

  14. Revised Versions of this License.

  The Free Software Foundation may publish revised and/or new versions of
the GNU General Public License from time to time.  Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

  Each version is given a distinguishing version number.  If the
Program specifies that a certain numbered version of the GNU General
Public License "or any later version" applies to it, you have the
option of following the terms and conditions either of that numbered
version or of any later version published by the Free Software
Foundation.  If the Program does not specify a version number of the
GNU General Public License, you may choose any version ever published
by the Free Software Foundation.

  If the Program specifies that a proxy can decide which future
versions of the GNU General Public License can be used, that proxy's
public statement of acceptance of a version permanently authorizes you
to choose that version for the Program.

  Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

  15. Disclaimer of Warranty.

  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

  If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

                     END OF TERMS AND CONDITIONS

            How to Apply These Terms to Your New Programs

  If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these terms.

  To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

    <one line to give the program's name and a brief idea of what it does.>
    Copyright (C) <year>  <name of author>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

Also add information on how to contact you by electronic and paper mail.

  If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

    <program>  Copyright (C) <year>  <name of author>
    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
    This is free software, and you are welcome to redistribute it
    under certain conditions; type `show c' for details.

The hypothetical commands `show w' and `show c' should show the appropriate
parts of the General Public License.  Of course, your program's commands
might be different; for a GUI interface, you would use an "about box".

  You should also get your employer (if you work as a programmer) or school,
if any, to sign a "copyright disclaimer" for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
<https://www.gnu.org/licenses/>.

  The GNU General Public License does not permit incorporating your program
into proprietary programs.  If your program is a subroutine library, you
may consider it more useful to permit linking proprietary applications with
the library.  If this is what you want to do, use the GNU Lesser General
Public License instead of this License.  But first, please read
<https://www.gnu.org/licenses/why-not-lgpl.html>.

```

`README.md`:

```md
# MVisor: A mini x86 hypervisor

## Goal

1. A minimal hypervisor based on KVM and x86 (replace QEMU)
2. A limited number of emulated devices (support plugins in later version)
3. Linux and Windows as guest VMs
4. VFIO (especially vGPU) and migration
5. Extremely stable and high performance


## Screenshot

### Ubuntu

<img src="./docs/ubuntu.jpg" width="640">

### vGPU

<img src="./docs/vgpu.jpg" width="640">

### Multimedia

<img src="./docs/multimedia.jpg" width="640">



## Roadmap And Current Status

What's supported now:

### Basic functions

1. 440FX ✅ / Q35 Chipset ✅
2. SeaBIOS ✅
3. Memory Region Management ✅
4. IOPort Management ✅
5. Devices Management ✅
6. RTC (CMOS) ✅
7. PS/2 ✅
8. PCI ISA ICH9-LPC ✅
9. QEMU CFG ✅
10. Legacy DMA ✅
11. IDE ✅ / AHCI ✅
12. Floppy Disk ✅
13. Serial Port ✅
14. VGA / VBE ✅
15. Option Roms ✅ / SMBIOS ✅ / ACPI Table ✅
16. Boot DOS ✅
17. Boot OS (Win98 to Win11 / DOS / Ubuntu) ✅
18. QCOW2 ✅

### Multimedia & Networking

1. Virtio (Console ✅ / Block ✅ / Net ✅ / VirtioFS ✅ / Balloon)
2. SpiceAgent ✅
3. QemuGuestAgent ✅
4. Qxl ✅
5. Audio (ICH9-HDA / AC97) ✅
6. Tap network
7. User network ✅
8. VFIO ✅
9. Samba
10. USB 1.0 UHCI ✅ / USB 3.0 XHCI ✅ / USB Tablet ✅ / USB Midi ✅ / USB Wacom ✅

### Hyper-V & Migration

1. CPU migration ✅
2. VFIO migration ✅
3. Migration to sparse files ✅
4. Hyper-V enlightenments ✅


## Compile & Run

For CentOS 8,

```
yum install -y gcc-c++ SDL2-devel yaml-cpp-devel libuuid-devel protobuf-devel protobuf-compiler libzstd-devel zlib-devel alsa-lib-devel libjpeg-devel opus-devel

meson setup build
meson compile -C build
```

An ISO image file is needed to install OS. Modify config/default.yaml to configure image path.

Virtio is recommended:

<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">Download Virtio Guest Tools</a>

```

`config/i440fx.yaml`:

```yaml
name: i440fx-machine

machine:
  memory: 4G
  vcpu: 4
  bios: ../share/bios-256k.bin

objects:
# Use the old name pci-host instead of i440fx-host for compatibility
  - class: i440fx-host

# PCI devices connected to PCI Host.
# The PIIX3 must be put first because it must use PCI slot 1
  - class: piix3
  - class: piix3-ide
  - class: piix3-uhci
  - class: piix4-pm
  - class: ac97

# I/O devices connected to PIIX3
  - class: cmos
  - class: debug-console
  - class: dummy-device
  - class: firmware-config
  - class: kvm-clock
  - class: ps2
  - class: i8257-dma
  - class: i82078-fdc


```

`config/q35.yaml`:

```yaml
name: q35-machine

machine:
  memory: 4G
  vcpu: 4
  bios: ../share/bios-256k.bin

objects:
# Use the old name pci-host instead of q35-host for compatibility
  - class: q35-host

# PCI devices connected to PCI Host
  - class: ich9-hda
  - class: ich9-lpc
  - class: ich9-ahci

# I/O devices connected to ICH9 LPC
  - class: cmos
  - class: debug-console
  - class: dummy-device
  - class: firmware-config
  - class: kvm-clock
  - class: ps2

# codec device connected to ICH9 HDA
  - class: hda-duplex

```

`config/sample.yaml`:

```yaml
name: Default configuration
base: i440fx.yaml

machine:
  memory: 4G
  vcpu: 4
  # Set vcpu thread priority value [-20, 19]
  # A higher value means a lower priority
  priority: 1
  # Turn on BIOS output and performance measurement
  debug: No
  # Turn on hypervisor to lower CPU usage (Hyper-V is used for Windows)
  hypervisor: Yes

objects:
  - name: cmos
    # gmtime for linux, localtime for windows
    rtc: localtime

  - class: qxl
  - class: spice-agent
  - class: qemu-guest-agent
  - class: usb-tablet

  - class: virtio-network
    backend: uip
    mac: 00:50:00:11:22:33
    map: tcp:0.0.0.0:8022-:22

  - class: ata-cdrom 
    image: /data/ubuntu-21.10-desktop-amd64.iso
  
  - class: ata-cdrom
    image: /data/virtio.iso

  - class: ata-disk
    image: /data/empty.qcow2
    snapshot: No
  
  # - class: floppy
  #   image: /data/images/floppy.img

  # - class: virtio-block
  #   image: /data/empty.qcow2
  #   snapshot: No

  # - class: virtio-fs
  #   path: /tmp/fuse
  #   disk_name: mvisor-fs
  #   disk_size: 2G
  #   inode_count: 200

  # - class: vfio-pci
  #   sysfs: /sys/bus/mdev/devices/c2e088ba-954f-11ec-8584-525400666f2b
  #   debug: Yes

  # - class: virtio-vgpu
  #   memory: 1G
  #   staging: No
  #   blob: No
  #   node: /dev/dri/renderD131

```

`core/configuration.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "configuration.h"

#include <libgen.h>
#include <unistd.h>
#include <cstring>

#include <fstream>

#include "machine.h"
#include "logger.h"


Configuration::Configuration(Machine* machine) : machine_(machine) {
  InitializePaths();
}

/* Apparently this only works under Linux */
void Configuration::InitializePaths() {
  char temp[1024];
  bzero(temp, sizeof(temp));
  getcwd(temp, sizeof(temp) - 1);
  directories_.insert(temp);

  bzero(temp, sizeof(temp));
  if (readlink("/proc/self/exe", temp, sizeof(temp) - 1) > 0) {
    directories_.insert(dirname(temp));
  }
}

/* Try to find file in current path and executable path */
std::string Configuration::FindPath(std::string path) const {
  if (access(path.c_str(), F_OK) == 0) {
    return path;
  }
  if (path[0] != '/') {
    for (auto &dir : directories_) {
      auto new_path = dir + "/" + path;
      if (access(new_path.c_str(), F_OK) == 0) {
        return new_path;
      }
    }
  }
  /* Path not found */
  MV_PANIC("Path not found %s", path.c_str());
  return path;
}

/* Load configuration from file */
bool Configuration::Load(std::string path) {
  if (!machine_->objects_.empty()) {
    MV_PANIC("Machine already loaded");
    return false;
  }
  return LoadFile(path);
}

/* Load configuration file *.yaml */
bool Configuration::LoadFile(std::string path) {
  path_ = FindPath(path);
  YAML::Node config = YAML::LoadFile(path_);
  if (config["base"]) {
    /* Add the current config directory to directories and load base file */
    char temp[1024] = { 0 };
    strcpy(temp, path.c_str());
    directories_.insert(dirname(temp));
    Load(config["base"].as<std::string>());
  }

  if (config["machine"]) {
    LoadMachine(config["machine"]);
  }

  if (config["objects"]) {
    LoadObjects(config["objects"]);
  }
  return true;
}

Object* Configuration::CreateObject(std::string class_name, std::string name) {
  auto &objects = machine_->objects_;
  MV_ASSERT(objects.find(name) == objects.end());

  auto object = Object::Create(class_name.c_str());
  if (object) {
    object->set_name(name.c_str());
    objects[name] = object;
  }
  return object;
}

Object* Configuration::GetOrCreateObject(std::string class_name, std::string name) {
  auto &objects = machine_->objects_;
  auto it = objects.find(name);
  Object* object = nullptr;
  if (it == objects.end()) {
    if (!class_name.empty()) {
      object = CreateObject(class_name, name);
    }
  } else {
    object = it->second;
  }
  return object;
}

std::string Configuration::GenerateObjectName(std::string class_name) {
  auto &objects = machine_->objects_;

  /* try to use class name as name */
  std::string name = get_class_alias(class_name.c_str());
  if(objects.find(name) == objects.end()) {
    return name;
  }

  for (int index = 1; index < 256; index++) {
    char tmp[100];
    sprintf(tmp, "%s-%d", name.c_str(), index);
    if (objects.find(tmp) == objects.end()) {
      return tmp;
    }
  }
  /* never get here */
  MV_PANIC("failed to set object name of %s", class_name.c_str());
  return class_name;
}

/* Make sure all objects are linked. If parent not found, try to create one */
void Configuration::CreateParents(Object* object) {
  auto &objects = machine_->objects_;

  if (object->parent()) {
    return;
  }
  
  /* Try the user specified parent name */
  if (object->parent_name()[0]) {
    auto it = objects.find(object->parent_name());
    if (it == objects.end()) {
      MV_PANIC("object parent not found: %s", object->parent_name());
    }
    it->second->AddChild(object);
    return;
  }

  /* Search objects by default parent classes */
  auto& parent_classes = object->default_parent_classes();
  if (parent_classes.empty()) {
    return; // root object
  }

  for (auto classname : parent_classes) {
    auto it = std::find_if(objects.begin(), objects.end(), [&classname](auto& o) {
      return classname == o.second->classname();
    });
    if (it != objects.end()) {
      it->second->AddChild(object);
      return;
    }
  }

  /* If not found, we try to create a parent object */
  std::string parent_classname = parent_classes.front();
  std::string parnet_name = GenerateObjectName(parent_classname);
  auto parent = CreateObject(parent_classname, parnet_name);
  parent->AddChild(object);
  if (!parent->parent()) {
    CreateParents(parent);
  }
}

void Configuration::SetObjectKeyValue(Object* object, std::string key, const YAML::Node& value) {
  /* try type uint64_t or bool or string */
  try {
    auto uint_value = value.as<uint64_t>();
    (*object)[key] = uint_value;
    return;
  } catch (const YAML::BadConversion& e) { }
  try {
    auto bool_value = value.as<bool>();
    (*object)[key] = bool_value;
    return;
  } catch (const YAML::BadConversion& e) { }
  try {
    auto string_value = value.as<std::string>();
    (*object)[key] = string_value;
    return;
  } catch (const YAML::BadConversion& e) { }
  MV_PANIC("Object %s has invalid key %s", object->name(), key.c_str());
}

/* Extract machine configs */
void Configuration::LoadMachine(const YAML::Node& node) {
  if (node["memory"]) {
    auto memory = node["memory"].as<std::string>();
    long value = atol(memory.substr(0, memory.length() - 1).c_str());
    if (memory.back() == 'G') {
      machine_->ram_size_ = (1UL << 30) * value;
    } else if (memory.back() == 'M') {
      machine_->ram_size_ = (1UL << 20) * value;
    } else {
      MV_PANIC("invalid memory size %s", memory.c_str());
    }
  }
  if (node["vcpu"]) {
    machine_->num_vcpus_ = node["vcpu"].as<uint64_t>();
  }
  if (node["priority"]) {
    machine_->vcpu_priority_ = node["priority"].as<uint64_t>();
  } 
  if (node["bios"]) {
    bios_path_ = FindPath(node["bios"].as<std::string>());
  } else {
    bios_path_ = FindPath("../share/bios-256k.bin");
  }
  if (node["debug"]) {
    machine_->debug_ = node["debug"].as<bool>();
  }
  if (node["hypervisor"]) {
    machine_->hypervisor_ = node["hypervisor"].as<bool>();
  }
}

void Configuration::LoadObjects(const YAML::Node& objects_node) {
  std::vector<Object*> created;

  /* Create objects */
  for (auto it = objects_node.begin(); it != objects_node.end(); it++) {
    auto node = *it;
    std::string name, class_name;
    if (node["class"]) {
      class_name = node["class"].as<std::string>();
    }
    if (node["name"]) {
      name = node["name"].as<std::string>();
    } else {
      name = GenerateObjectName(class_name);
    }
    auto object = GetOrCreateObject(class_name, name);
    if (object == nullptr) {
      MV_WARN("object not found %s %s", class_name.c_str(), name.c_str());
      continue;
    }

    /* Load object properties */
    for (auto it2 = node.begin(); it2 != node.end(); it2++) {
      auto key = it2->first.as<std::string>();
      auto value = it2->second;
      if (key == "name" || key == "class") {
        continue;
      }
      if (key == "debug") {
        object->set_debug(value.as<bool>());
        continue;
      } else if (key == "parent") {
        object->set_parent_name(value.as<std::string>().c_str());
        continue;
      }
      SetObjectKeyValue(object, key, value);
    }

    created.push_back(object);
  }

  for (auto object : created) {
    CreateParents(object);
  }
}

/* Save configuration to file */
bool Configuration::Save(std::string path) {
  std::ofstream ofs(path, std::ios::out);
  if (!ofs.is_open())
    return false;

  auto root = YAML::Node();
  root["version"] = 1;

  /* Build time */
  auto now = time(nullptr);
  char temp[100];
  strftime(temp, 100, "%Y-%m-%d %H:%M:%S", gmtime(&now));
  root["create_time"] = temp;
  
  /* Build machine */
  auto machine_node = root["machine"];
  SaveMachine(machine_node);

  /* Build objects */
  std::vector<Object*> objects;
  for (auto it = machine_->objects_.begin(); it != machine_->objects_.end(); it++) {
    objects.push_back(it->second);
  }
  /* Sort by id */
  std::sort(objects.begin(), objects.end(), [](Object* a, Object* b) {
    return a->id() < b->id();
  });

  auto objects_node = root["objects"];
  for (auto o : objects) {
    auto node = YAML::Node();
    node["name"] = o->name();
    node["class"] = o->classname();
    node["debug"] = o->debug();
    if (o->parent()) {
      node["parent"] = o->parent()->name();
    }
    auto &kv = o->key_values();
    for (auto it = kv.begin(); it != kv.end(); it++) {
      auto& value = it->second;
      switch (value.index())
      {
      case 0:
        node[it->first] = std::get<bool>(it->second);
        break;
      case 1:
        node[it->first] = std::get<uint64_t>(it->second);
        break;
      case 2:
        node[it->first] = std::get<std::string>(it->second);
        break;
      }
    }
    objects_node.push_back(node);
  }

  ofs << root << std::endl;
  return true;
}

/* Save machine configs */
void Configuration::SaveMachine(YAML::Node& node) {
  std::stringstream ss;
  ss << machine_->ram_size_ / (1UL << 30) << "G";
  node["memory"] = ss.str();
  node["vcpu"] = machine_->num_vcpus_;
  node["debug"] = machine_->debug_;
  node["hypervisor"] = machine_->hypervisor_;
  node["bios"] = bios_path_;
}

```

`core/device.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "device.h"
#include <cstring>
#include "logger.h"
#include "utilities.h"
#include "machine.h"
#include "device_manager.h"

Device::Device() {
  strcpy(name_, "unknown");

  /* If the device is not specified a default parent, attach it to the top system-root */
  set_default_parent_class("SystemRoot");
}

Device::~Device() {
  /* Free resources */
  for (auto resource : io_resources_) {
    delete resource;
  }
}

void Device::Reset() {
  /* Don't add anything here */
}

/* Connect() is called when device manager initialize */
void Device::Connect() {
  MV_ASSERT(manager_);

  for (auto child : children_) {
    auto device = dynamic_cast<Device*>(child);
    if (device) {
      device->manager_ = manager_;
      device->Connect();
    }
  }

  connected_ = true;
  manager_->RegisterDevice(this);
  for (auto resource : io_resources_) {
    SetIoResourceEnabled(resource, true);
  }
  if (parent_ && manager_->machine()->debug()) {
    MV_LOG("%s <= %s", parent_->name(), name_);
  }
}

/* Disconnect() is called when device manager is being destroyed */
void Device::Disconnect() {
  if (!connected_) {
    return;
  }
  connected_ = false;
  for (auto child : children_) {
    auto device = dynamic_cast<Device*>(child);
    if (device) {
      device->Disconnect();
    }
  }

  for (auto resource : io_resources_) {
    if (resource->enabled) {
      SetIoResourceEnabled(resource, false);
    }
  }
  manager_->UnregisterDevice(this);
}

void Device::AddIoResource(IoResourceType type, uint64_t base, uint64_t length, const char* name) {
  AddIoResource(type, base, length, name, nullptr, kIoResourceFlagNone);
}

void Device::AddIoResource(IoResourceType type, uint64_t base, uint64_t length, const char* name, void* host_memory, IoResourceFlag flags) {
  auto resource = new IoResource {
    .type = type,
    .base = base,
    .length = length,
    .name = name,
    .enabled = false,
    .host_memory = host_memory,
    .mapped_region = nullptr,
    .flags = flags
  };
  io_resources_.push_back(resource);
  if (connected_) {
    SetIoResourceEnabled(resource, true);
  }
}

void Device::RemoveIoResource(IoResourceType type, const char* name) {
  for (auto it = io_resources_.begin(); it != io_resources_.end(); it++) {
    auto resource = *it;
    if (resource->type == type &&
        (resource->name == name || (name && resource->name && strcmp(resource->name, name) == 0))
      ) {
      if (connected_) {
        SetIoResourceEnabled(resource, false);
      }
      io_resources_.erase(it);
      delete resource;
      return;
    }
  }
}

void Device::RemoveIoResource(IoResourceType type, uint64_t base) {
  for (auto it = io_resources_.begin(); it != io_resources_.end(); it++) {
    auto resource = *it;
    if (resource->type == type && resource->base == base) {
      if (connected_) {
        SetIoResourceEnabled(resource, false);
      }
      MV_ASSERT(!resource->enabled);
      io_resources_.erase(it);
      delete resource;
      return;
    }
  }
  MV_PANIC("not found type=%d base=0x%lx", type, base);
}

void Device::SetIoResourceEnabled(IoResource* resource, bool enabled) {
  if (enabled) {
    MV_ASSERT(!resource->enabled);
    if (resource->type == kIoResourceTypeRam) {
      MV_ASSERT(resource->host_memory);
      auto mm = manager_->machine()->memory_manager();
      resource->mapped_region = mm->Map(resource->base, resource->length, resource->host_memory, kMemoryTypeRam, resource->name);
    } else {
      manager_->RegisterIoHandler(this, resource);
    }
    resource->enabled = true;
  } else {
    MV_ASSERT(resource->enabled);
    if (resource->type == kIoResourceTypeRam) {
      MV_ASSERT(resource->mapped_region);
      auto mm = manager_->machine()->memory_manager();
      mm->Unmap(&resource->mapped_region);
    } else {
      manager_->UnregisterIoHandler(this, resource);
    }
    resource->enabled = false;
  }
}

void Device::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  MV_PANIC("not implemented %s base=0x%lx offset=0x%lx size=%d name=%s",
    name_, resource->base, offset, size, resource->name);
  MV_UNUSED(data);
}

void Device::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  MV_PANIC("not implemented %s base=0x%lx offset=0x%lx size=%d data=0x%lx name=%s",
    name_, resource->base, offset, size, *(uint64_t*)data, resource->name);
}

bool Device::SaveState(MigrationWriter* writer) {
  MV_UNUSED(writer);
  return true;
}

bool Device::LoadState(MigrationReader* reader) {
  MV_UNUSED(reader);
  return true;
}


void Device::Schedule(VoidCallback callback) {
  manager_->io()->Schedule(this, std::move(callback));
}

IoTimer* Device::AddTimer(int64_t interval_ns, bool permanent, VoidCallback callback) {
  return manager_->io()->AddTimer(this, interval_ns, permanent, std::move(callback));
}

void Device::ModifyTimer(IoTimer* timer, int64_t interval_ns) {
  manager_->io()->ModifyTimer(timer, interval_ns);
}

void Device::RemoveTimer(IoTimer* timer) {
  manager_->io()->RemoveTimer(timer);
}

void Device::StartPolling(int fd, uint poll_mask, IoCallback callback) {
  manager_->io()->StartPolling(this, fd, poll_mask, std::move(callback));
}

void Device::StopPolling(int fd) {
  manager_->io()->StopPolling(fd);
}


```

`core/device_manager.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "device_manager.h"

#include <algorithm>

#include <cstring>
#include <unistd.h>
#include <sys/ioctl.h>
#include <sys/eventfd.h>
#include <signal.h>

#include "logger.h"
#include "memory_manager.h"
#include "machine.h"

#define IOEVENTFD_MAX_EVENTS  1000

/* SystemRoot is a motherboard that holds all the funcational devices */
class SystemRoot : public Device {
 public:
  SystemRoot() {
    default_parent_classes_.clear();
  }
 private:
  friend class DeviceManager;
};
DECLARE_DEVICE(SystemRoot);

IoThread* DeviceManager::io() {
  return machine_->io_thread_;
}

DeviceManager::DeviceManager(Machine* machine, Device* root) :
  machine_(machine), root_(root)
{
  root_->manager_ = this;

  /* Initialize IRQ chip */
  SetupIrqChip();
  
  /* Initialize GSI routing table */
  SetupGsiRoutingTable();

  /* Call Connect() on all devices and do the initialization
   * 1. reset device status
   * 2. register IO handlers
   */
  root_->Connect();
}

DeviceManager::~DeviceManager() {
  if (root_) {
    /* Disconnect invoked recursively */
    root_->Disconnect();
  }
  
  safe_close(&vfio_kvm_device_fd_);
  MV_ASSERT(ioevents_.empty());
}

/* Called when system start or reset */
void DeviceManager::ResetDevices() {
  for (auto device : registered_devices_) {
    device->Reset();
  }
}

/* Used for debugging */
void DeviceManager::PrintDevices() {
  for (auto device : registered_devices_) {
    MV_LOG("Device: %s", device->name());
    for (auto resource : device->io_resources()) {
      switch (resource->type)
      {
      case kIoResourceTypePio:
        MV_LOG("\tIO   port    0x%lx-0x%lx %d", resource->base, resource->base + resource->length - 1, resource->enabled);
        break;
      case kIoResourceTypeMmio:
        MV_LOG("\tMMIO address 0x%016lx-0x016%lx %d", resource->base, resource->base + resource->length - 1, resource->enabled);
        break;
      case kIoResourceTypeRam:
        MV_LOG("\tRAM  address 0x%016lx-0x016%lx %d", resource->base, resource->base + resource->length - 1, resource->enabled);
        break;
      }
    }
  }
}

Device* DeviceManager::LookupDeviceByClass(const std::string class_name) {
  for (auto device : registered_devices_) {
    if (device->classname() == class_name) {
      return device;
    }
  }
  return nullptr;
}

PciDevice* DeviceManager::LookupPciDevice(uint16_t bus, uint8_t slot, uint8_t function) {
  for (auto device : registered_devices_) {
    PciDevice* pci_device = dynamic_cast<PciDevice*>(device);
    if (pci_device && pci_device->bus_ == bus && pci_device->slot_ == slot && pci_device->function_ == function) {
      return pci_device;
    }
  }
  return nullptr;
}


void DeviceManager::RegisterDevice(Device* device) {
  // Check devfn conflicts or reassign it
  PciDevice* pci = dynamic_cast<PciDevice*>(device);
  if (pci) {
    /* Auto generate pci address */
    if (pci->slot_ == 0xFF) {
      auto parent = dynamic_cast<const PciDevice*>(pci->parent());
      /* Check if Multi-function */
      if (parent && (parent->pci_header_.header_type & 0x80)) {
        pci->slot_ = parent->slot_;
        for (uint i = 0; i < 8; i++) {
          if (!LookupPciDevice(pci->bus_, pci->slot_, i)) {
            pci->function_ = i;
            break;
          }
        }
      } else {
        for (uint i = 1; i < 0x1F; i++) {
          if (!LookupPciDevice(pci->bus_, i, pci->function_)) {
            pci->slot_ = i;
            break;
          }
        }
      }
    }

    if (LookupPciDevice(pci->bus_, pci->slot_, pci->function_)) {
      MV_PANIC("PCI device %x.%x conflicts", pci->slot_, pci->function_);
      return;
    }
    if (machine_->debug_) {
      MV_LOG("register PCI %s at %x:%x.%x", pci->name_, pci->bus_, pci->slot_, pci->function_);
    }
  }

  registered_devices_.insert(device);
}

void DeviceManager::UnregisterDevice(Device* device) {
  registered_devices_.erase(device);
}


void DeviceManager::RegisterVfioGroup(int group_fd) {
  if (vfio_kvm_device_fd_ == -1) {
    kvm_create_device create = {
      .type = KVM_DEV_TYPE_VFIO,
      .fd = 0,
      .flags = 0
    };
    if (ioctl(machine_->vm_fd_, KVM_CREATE_DEVICE, &create) < 0) {
      MV_PANIC("failed to create KVM VFIO device");
    }
    vfio_kvm_device_fd_ = create.fd;
  }

  kvm_device_attr attr = {
    .flags = 0,
    .group = KVM_DEV_VFIO_GROUP,
    .attr = KVM_DEV_VFIO_GROUP_ADD,
    .addr = (uint64_t)&group_fd
  };
  if (ioctl(vfio_kvm_device_fd_, KVM_SET_DEVICE_ATTR, &attr) < 0) {
    MV_PANIC("failed to add group %d to KVM VFIO device %d", group_fd, vfio_kvm_device_fd_);
  }
}

void DeviceManager::UnregisterVfioGroup(int group_fd) {
  MV_ASSERT(vfio_kvm_device_fd_ != -1);

  kvm_device_attr attr = {
    .flags = 0,
    .group = KVM_DEV_VFIO_GROUP,
    .attr = KVM_DEV_VFIO_GROUP_DEL,
    .addr = (uint64_t)&group_fd
  };
  if (ioctl(vfio_kvm_device_fd_, KVM_SET_DEVICE_ATTR, &attr) < 0) {
    MV_PANIC("failed to delete group %d to KVM VFIO device %d", group_fd, vfio_kvm_device_fd_);
  }
}


void DeviceManager::RegisterIoHandler(Device* device, const IoResource* resource) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);

  /* Check if resources are overlapped */
  if (resource->type == kIoResourceTypePio) {
    auto found = std::find_if(pio_handlers_.begin(), pio_handlers_.end(), [resource](auto& o) {
      return ranges_overlap(o->resource->base, o->resource->length, resource->base, resource->length);
    });
    if (found != pio_handlers_.end()) {
      MV_PANIC("%s port 0x%x(0x%x) overlapped by %s port 0x%x(0x%x)", device->name(), resource->base,
        resource->length, (*found)->device->name(), (*found)->resource->base, (*found)->resource->length);
    }
  } else if (resource->type == kIoResourceTypeMmio) {
    auto found = std::find_if(pio_handlers_.begin(), pio_handlers_.end(), [resource](auto& o) {
      return ranges_overlap(o->resource->base, o->resource->length, resource->base, resource->length);
    });
    if (found != pio_handlers_.end()) {
      MV_PANIC("%s mmio 0x%x(0x%x) overlapped by %s mmio 0x%x(0x%x)", device->name(), resource->base,
        resource->length, (*found)->device->name(), (*found)->resource->base, (*found)->resource->length);
    }
  }

  if (resource->type == kIoResourceTypePio) {
    pio_handlers_.push_back(new IoHandler {
      .resource = resource,
      .device = device,
      .memory_region = nullptr
    });
  } else if (resource->type == kIoResourceTypeMmio) {
    // Map the memory to type Device. Accessing these regions will cause MMIO access fault
    const MemoryRegion* region = machine_->memory_manager()->Map(resource->base, resource->length,
      nullptr, kMemoryTypeDevice, resource->name);

    mmio_handlers_.push_back(new IoHandler {
      .resource = resource,
      .device = device,
      .memory_region = region
    });

    if (resource->flags & kIoResourceFlagCoalescingMmio) {
      kvm_coalesced_mmio_zone zone = {
        .addr = resource->base,
        .size =  (uint32_t)resource->length,
        .pad = 0
      };
      if (ioctl(machine_->vm_fd_, KVM_REGISTER_COALESCED_MMIO, &zone) != 0) {
        MV_PANIC("failed to register coaleascing MMIO");
      }
    }
  }
}

void DeviceManager::UnregisterIoHandler(Device* device, const IoResource* resource) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  if (resource->type == kIoResourceTypePio) {
    for (auto it = pio_handlers_.begin(); it != pio_handlers_.end(); it++) {
      if ((*it)->device == device && (*it)->resource->base == resource->base) {
        delete *it;
        pio_handlers_.erase(it);
        break;
      }
    }
  } else if (resource->type == kIoResourceTypeMmio) {
    for (auto it = mmio_handlers_.begin(); it != mmio_handlers_.end(); it++) {
      if ((*it)->device == device && (*it)->resource->base == resource->base) {
        machine_->memory_manager()->Unmap(&(*it)->memory_region);
        delete *it;
        mmio_handlers_.erase(it);
        break;
      }
    }

    if (resource->flags & kIoResourceFlagCoalescingMmio) {
      kvm_coalesced_mmio_zone zone = {
        .addr = resource->base,
        .size = (uint32_t)resource->length,
        .pad = 0
      };
      if (ioctl(machine_->vm_fd_, KVM_UNREGISTER_COALESCED_MMIO, &zone) != 0) {
        MV_PANIC("failed to unregister coaleascing MMIO");
      }
    }
  }
}

IoEvent* DeviceManager::RegisterIoEvent(Device* device, IoResourceType type, uint64_t address, uint32_t length, uint64_t datamatch) {
  IoEvent* event = new IoEvent {
    .type = kIoEventFd,
    .device = device,
    .address = address,
    .length = length,
    .datamatch = datamatch,
    .flags = length ? KVM_IOEVENTFD_FLAG_DATAMATCH : 0U,
    .fd = eventfd(0, 0)
  };
  if (type == kIoResourceTypePio) {
    event->flags |= KVM_IOEVENTFD_FLAG_PIO;
    event->type = kIoEventPio;
  } else {
    event->type = kIoEventMmio;
  }
  struct kvm_ioeventfd kvm_ioevent = {
    .datamatch = event->datamatch,
    .addr = event->address,
    .len = event->length,
    .fd = event->fd,
    .flags = event->flags,
    .pad = {0}
  };
  int ret = ioctl(machine_->vm_fd_, KVM_IOEVENTFD, &kvm_ioevent);
  if (ret < 0) {
    MV_PANIC("failed to register io event, ret=%d", ret);
  }
  if (machine_->debug_) {
    MV_LOG("%s register IO event address=0x%lx length=%lu fd=%d", device->name(), address, length, event->fd);
  }

  io()->StartPolling(device, event->fd, EPOLLIN, [event, this](int events) {
    if (events & EPOLLIN) {
      uint64_t tmp;
      read(event->fd, &tmp, sizeof(tmp));
      if (event->type == kIoEventMmio) {
        HandleMmio(event->address, (uint8_t*)&event->datamatch, event->length, true, true);
      } else if (event->type == kIoEventPio) {
        HandleIo(event->address, (uint8_t*)&event->datamatch, event->length, true, 1, true);
      }
    }
  });

  std::lock_guard<std::recursive_mutex> lock(mutex_);
  ioevents_.insert(event);
  return event;
}

IoEvent* DeviceManager::RegisterIoEvent(Device* device, IoResourceType type, uint64_t address) {
  return RegisterIoEvent(device, type, address, 0, 0);
}

void DeviceManager::UnregisterIoEvent(IoEvent* event) {
  io()->StopPolling(event->fd);

  std::lock_guard<std::recursive_mutex> lock(mutex_);

  if (event->type == kIoEventMmio || event->type == kIoEventPio) {
    struct kvm_ioeventfd kvm_ioevent = {
      .datamatch = event->datamatch,
      .addr = event->address,
      .len = event->length,
      .fd = event->fd,
      .flags = event->flags | KVM_IOEVENTFD_FLAG_DEASSIGN,
      .pad = {0}
    };
    int ret = ioctl(machine_->vm_fd_, KVM_IOEVENTFD, &kvm_ioevent);
    if (ret < 0) {
      MV_PANIC("failed to unregister io event, ret=%d", ret);
    }
  }

  ioevents_.erase(event);
  safe_close(&event->fd);
  delete event;
}

void DeviceManager::UnregisterIoEvent(Device* device, IoResourceType type, uint64_t address) {
  std::unique_lock<std::recursive_mutex> lock(mutex_);
  auto it = std::find_if(ioevents_.begin(), ioevents_.end(), [=](auto &e) {
    return e->device == device && e->address == address &&
      ((type == kIoResourceTypePio) == !!(e->flags & KVM_IOEVENTFD_FLAG_PIO));
  });
  if (it == ioevents_.end()) {
    return;
  }
  auto event = *it;
  lock.unlock();
  UnregisterIoEvent(event);
}

void DeviceManager::SetupCoalescingMmioRing(kvm_coalesced_mmio_ring* ring) {
  if (coalesced_mmio_ring_ == nullptr) {
    coalesced_mmio_ring_ = ring;
  }
}

void DeviceManager::FlushCoalescingMmioBuffer() {
  if (!coalesced_mmio_ring_) {
    return;
  }
  if (coalesced_mmio_ring_->first == coalesced_mmio_ring_->last) {
    return;
  }

  /* Is mutex necessary? */
  std::unique_lock<std::recursive_mutex> lock(mutex_);

  uint max_entries = ((PAGE_SIZE - sizeof(struct kvm_coalesced_mmio_ring)) / \
    sizeof(struct kvm_coalesced_mmio));
  while (coalesced_mmio_ring_->first != coalesced_mmio_ring_->last) {
    struct kvm_coalesced_mmio *m = &coalesced_mmio_ring_->coalesced_mmio[coalesced_mmio_ring_->first];
    coalesced_mmio_ring_->first = (coalesced_mmio_ring_->first + 1) % max_entries;

    lock.unlock();
    for (size_t i = m->len; i < sizeof(m->data); i++)
      m->data[i] = 0;
    if (m->pio == 1) {
      machine_->device_manager()->HandleIo(m->phys_addr, m->data, m->len, 1, 1);
    } else {
      machine_->device_manager()->HandleMmio(m->phys_addr, m->data, m->len, 1);
    }
    lock.lock();
  }
}

/* IO ports may overlap like MMIO addresses.
 * Use para-virtual drivers instead of IO operations to improve performance.
 * It seems no race condition would happen among vCPUs
 */
void DeviceManager::HandleIo(uint16_t port, uint8_t* data, uint16_t size, int is_write, uint32_t count, bool ioeventfd) {
  int it_count = 0;
  std::deque<IoHandler*>::iterator it;

  std::unique_lock<std::recursive_mutex> lock(mutex_);
  for (it = pio_handlers_.begin(); it != pio_handlers_.end(); it++, it_count++) {
    auto resource = (*it)->resource;
    if (port >= resource->base && port < resource->base + resource->length) {
      Device* device = (*it)->device;
      if (it_count >= 3) {
        // Move to the front for faster access next time
        pio_handlers_.push_front(*it);
        pio_handlers_.erase(it);
        --it;
      }
      lock.unlock();

      auto start_time = std::chrono::steady_clock::now();
      std::lock_guard<std::recursive_mutex> device_lock(device->mutex_);
      auto ptr = data;
      for (uint32_t i = 0; i < count; i++) {
        if (is_write) {
          device->Write(resource, port - resource->base, ptr, size);
        } else {
          device->Read(resource, port - resource->base, ptr, size);
        }
        ptr += size;
      }

      if (machine_->debug() && !ioeventfd) {
        auto cost_us = std::chrono::duration_cast<std::chrono::microseconds>(
          std::chrono::steady_clock::now() - start_time).count();
        if (cost_us >= 10000) {
          MV_LOG("%s SLOW IO %s port=0x%x size=%u data=%lx cost=%.3lfms", device->name(),
            is_write ? "out" : "in", port, size, *(uint64_t*)data, double(cost_us) / 1000.0);
        }
        ++io_accounting_.total_pio;
        if (start_time - io_accounting_.last_print_time > std::chrono::seconds(1)) {
          MV_LOG("pio count=%u  mmio count=%u", io_accounting_.total_pio, io_accounting_.total_mmio);
          io_accounting_.last_print_time = start_time;
          io_accounting_.total_pio = 0;
          io_accounting_.total_mmio = 0;
        }
        // MV_LOG("%s handle io %s port: 0x%x size: %x data: %016lx count: %d", device->name(),
        //   is_write ? "out" : "in", port, size, *(uint64_t*)data, count);
      }
      return;
    }
  }

  /* Accessing invalid port always returns error */
  memset(data, 0xFF, size);
  if (machine_->debug()) {
    /* Not allowed unhandled IO for debugging */
    MV_LOG("unhandled io %s port: 0x%x size: %x data: %016lx count: %d",
      is_write ? "out" : "in", port, size, *(uint64_t*)data, count);
  }
}


/* Use for loop to find MMIO handlers is stupid, unless we are sure addresses not overlapped.
 * But moving the handler to the front works great for now, 99% MMIOs are concentrated on
 * a few devices
 * Race condition could happen among multiple vCPUs, should be handled carefully in Read / Write
 */
void DeviceManager::HandleMmio(uint64_t addr, uint8_t* data, uint16_t size, int is_write, bool ioeventfd) {
  std::deque<IoHandler*>::iterator it;
  int it_count = 0;

  std::unique_lock<std::recursive_mutex> lock(mutex_);
  for (it = mmio_handlers_.begin(); it != mmio_handlers_.end(); it++, it_count++) {
    auto resource = (*it)->resource;
    if (addr >= resource->base && addr < resource->base + resource->length) {
      Device* device = (*it)->device;

      if (it_count >= 3) {
        // Move to the front for faster access next time
        mmio_handlers_.push_front(*it);
        mmio_handlers_.erase(it);
        --it;
      }
      lock.unlock();

      auto start_time = std::chrono::steady_clock::now();
      std::lock_guard<std::recursive_mutex> device_lock(device->mutex_);
      if (is_write) {
        device->Write(resource, addr - resource->base, data, size);
      } else {
        device->Read(resource, addr - resource->base, data, size);
      }

      if (machine_->debug() && !ioeventfd) {
        auto cost_us = std::chrono::duration_cast<std::chrono::microseconds>(
          std::chrono::steady_clock::now() - start_time).count();
        if (cost_us >= 10000) {
          MV_LOG("%s SLOW MMIO %s addr=0x%lx size=%u data=%lx cost=%.3lfms", device->name(),
            is_write ? "out" : "in", addr, size, *(uint64_t*)data, double(cost_us) / 1000.0);
        }
        ++io_accounting_.total_mmio;
        if (start_time - io_accounting_.last_print_time > std::chrono::seconds(1)) {
          MV_LOG("pio count=%u  mmio count=%u", io_accounting_.total_pio, io_accounting_.total_mmio);
          io_accounting_.last_print_time = start_time;
          io_accounting_.total_pio = 0;
          io_accounting_.total_mmio = 0;
        }
        // MV_LOG("%s handled mmio %s addr: 0x%016lx size: %x data: %016lx", device->name(),
        //   is_write ? "write" : "read", addr, size, *(uint64_t*)data);
      }
      return;
    }
  }

  if (machine_->debug()) {
    machine_->memory_manager()->PrintMemoryScope();
    MV_LOG("unhandled mmio %s base: 0x%016lx size: %x data: %016lx",
      is_write ? "write" : "read", addr, size, *(uint64_t*)data);
  }
}

/* 
  Get the host memory address of a guest physical address
  Param 'size' means the length of guest memory you may need to modify, it's important for migration
*/
void* DeviceManager::TranslateGuestMemory(uint64_t gpa) {
  auto memory_manger = machine_->memory_manager();
  return memory_manger->GuestToHostAddress(gpa);
}

void DeviceManager::AddDirtyMemory(uint64_t gpa, size_t size) {
  auto memory_manger = machine_->memory_manager();
  if (size == 0) {
    memory_manger->SetDirtyMemoryRegion(gpa, PAGE_SIZE);
  } else {
    memory_manger->SetDirtyMemoryRegion(gpa, size);
  }
}

/* Sets the level of a GSI input to the interrupt controller model */
void DeviceManager::SetGsiLevel(uint gsi, uint level) {
  struct kvm_irq_level irq_level = {
    .irq = gsi,
    .level = level
  };
  if (ioctl(machine_->vm_fd_, KVM_IRQ_LINE, &irq_level) != 0) {
    MV_PANIC("KVM_IRQ_LINE failed, gsi=%u, level=%u", gsi, level);
  }
}

/* Calculate the GSI of a PCI pin and set its level.
 * GSI can be shared, so we count the level */
void DeviceManager::SetPciIrqLevel(PciDevice* pci, uint level) {
  auto gsi = pci->pci_header_.irq_line;
  if (pci_irq_translator_) {
    gsi = pci_irq_translator_(pci->slot_, pci->function_, pci->pci_header_.irq_pin);
  }

  std::unique_lock<std::recursive_mutex> lock(mutex_);
  if (level) {
    pci_irq_raised_[gsi].insert(pci->id_);
  } else {
    pci_irq_raised_[gsi].erase(pci->id_);
  }
  uint set_level = !pci_irq_raised_[gsi].empty();
  lock.unlock();

  SetGsiLevel(gsi, set_level);
}

/* It seems we can signal MSI without seting up routing table */
void DeviceManager::SignalMsi(uint64_t address, uint32_t data) {
  struct kvm_msi msi = {
    .address_lo = (uint32_t)(address),
    .address_hi = (uint32_t)(address >> 32),
    .data = data,
    .flags = 0
  };
  auto ret = ioctl(machine_->vm_fd_, KVM_SIGNAL_MSI, &msi);
  if (ret < 0) {
    MV_PANIC("KVM_SIGNAL_MSI ret=%d", ret);
  }
}

/* Since we cannot read routing table from KVM, we keep a copy and update to KVM if changed */
void DeviceManager::UpdateGsiRoutingTable() {
  uint8_t buffer[sizeof(kvm_irq_routing) + sizeof(kvm_irq_routing_entry) * gsi_routing_table_.size()];
  auto table = (kvm_irq_routing*)buffer;

  mutex_.lock();
  table->nr = gsi_routing_table_.size();
  table->flags = 0;
  std::copy(gsi_routing_table_.begin(), gsi_routing_table_.end(), table->entries);
  mutex_.unlock();

  auto ret = ioctl(machine_->vm_fd_, KVM_SET_GSI_ROUTING, table);
  if (ret) {
    MV_PANIC("KVM_SET_GSI_ROUTING ret=%d", ret);
  }
}

/* Use KVM Irq Chip */
void DeviceManager::SetupIrqChip() {
  // Use Kvm in-kernel IRQChip
  if (ioctl(machine_->vm_fd_, KVM_CREATE_IRQCHIP) < 0) {
    MV_PANIC("failed to create irqchip");
  }

  // Use Kvm in-kernel PITClock
  struct kvm_pit_config pit_config = { .flags = KVM_PIT_SPEAKER_DUMMY, .pad = {0} };
  if (ioctl(machine_->vm_fd_, KVM_CREATE_PIT2, &pit_config) < 0) {
    MV_PANIC("failed to create pit2");
  }
}

/* Although KVM has initialized GSI routing table, we still need to do it again */
void DeviceManager::SetupGsiRoutingTable() {
  auto add_irq_routing = [this](uint gsi, uint chip, uint pin) {
    kvm_irq_routing_entry entry = {
      .gsi = gsi,
      .type = KVM_IRQ_ROUTING_IRQCHIP,
      .flags = 0,
      .pad = 0,
      .u = { .irqchip = { .irqchip = chip, .pin = pin } }
    };
    gsi_routing_table_.push_back(entry);
  };

  /* 8259A Master */
  for (uint i = 0; i < 8; i++) {
    if (i != 2) {
      add_irq_routing(i, 0, i);
    }
  }

  /* 8259A Slave */
  for (uint i = 0; i < 8; i++) {
    add_irq_routing(8 + i, 1, i);
  }

  /* IOAPIC */
  for (uint i = 0; i < 24; i++) {
    if (i == 0) {
      add_irq_routing(i, 2, 2);
    } else if (i != 2) {
      add_irq_routing(i, 2, i);
    }
  }

  next_gsi_ = 24;
  UpdateGsiRoutingTable();
}

/* This GSI is currently used with IRQ fd */
int DeviceManager::AddMsiRoute(uint64_t address, uint32_t data, int trigger_fd) {
  auto gsi = next_gsi_++;

  kvm_irq_routing_entry entry = {
    .gsi = (uint)gsi,
    .type = KVM_IRQ_ROUTING_MSI,
    .flags = 0,
    .pad = 0,
    .u = { .msi = {
      .address_lo = (uint32_t)address,
      .address_hi = (uint32_t)(address >> 32),
      .data = data,
      .pad = 0
    } }
  };

  mutex_.lock();
  gsi_routing_table_.push_back(entry);
  mutex_.unlock();

  UpdateGsiRoutingTable();
  if (trigger_fd != -1) {
    kvm_irqfd irqfd;
    bzero(&irqfd, sizeof(irqfd));
    irqfd.fd = (uint)trigger_fd;
    irqfd.gsi = (uint)gsi;
    if (ioctl(machine_->vm_fd_, KVM_IRQFD, &irqfd) < 0) {
      MV_PANIC("failed to assign irqfd=%d to gsi=%d", trigger_fd, gsi);
    }
  }
  return gsi;
}

/* Setting the address to 0 to remove a MSI route */
void DeviceManager::UpdateMsiRoute(int gsi, uint64_t address, uint32_t data, int trigger_fd) {
  std::unique_lock<std::recursive_mutex> lock(mutex_);
  auto it = std::find_if(gsi_routing_table_.begin(), gsi_routing_table_.end(), [gsi](auto &entry) {
    return entry.gsi == (uint)gsi;
  });

  kvm_irqfd irqfd;
  bzero(&irqfd, sizeof(irqfd));
  irqfd.fd = (uint)trigger_fd;
  irqfd.gsi = (uint)gsi;

  if (it == gsi_routing_table_.end()) {
    MV_PANIC("not found gsi=%d", gsi);
  } else if (address == 0) {
    /* deassign the irqfd and remove from table */
    if (trigger_fd != -1) {
      irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;
      if (ioctl(machine_->vm_fd_, KVM_IRQFD, &irqfd) < 0) {
        MV_PANIC("failed to assign irqfd=%d to gsi=%d", trigger_fd, gsi);
      }
    }
    gsi_routing_table_.erase(it);
  } else {
    /* update entry and irqfd */
    auto& msi = it->u.msi;
    msi.address_lo = (uint32_t)address;
    msi.address_hi = (uint32_t)(address >> 32);
    msi.data = data;

    if (trigger_fd != -1) {
      if (ioctl(machine_->vm_fd_, KVM_IRQFD, &irqfd) < 0) {
        MV_PANIC("failed to assign irqfd=%d to gsi=%d", trigger_fd, gsi);
      }
    }
  }
  lock.unlock();
  
  UpdateGsiRoutingTable();
}


bool DeviceManager::SaveState(MigrationWriter* writer) {
  writer->SetPrefix("kvm-irqchip");
  /* Save irq chip */
  kvm_irqchip chip;
  chip.chip_id = KVM_IRQCHIP_PIC_MASTER;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_GET_IRQCHIP, &chip) == 0);
  writer->WriteRaw("PIC_MASTER", &chip.chip.pic, sizeof(chip.chip.pic));

  chip.chip_id = KVM_IRQCHIP_PIC_SLAVE;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_GET_IRQCHIP, &chip) == 0);
  writer->WriteRaw("PIC_SLAVE", &chip.chip.pic, sizeof(chip.chip.pic));

  chip.chip_id = KVM_IRQCHIP_IOAPIC;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_GET_IRQCHIP, &chip) == 0);
  writer->WriteRaw("IOAPIC", &chip.chip.ioapic, sizeof(chip.chip.ioapic));

  kvm_pit_state2 pit2;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_GET_PIT2, &pit2) == 0);
  writer->WriteRaw("PIT2", &pit2, sizeof(pit2));
  
  /* Save states of devices */
  for (auto device : registered_devices_) {
    writer->SetPrefix(device->name());
    if (!device->SaveState(writer)) {
      MV_ERROR("failed to save state of device %s", device->name());
      return false;
    }
  }
  return true;
}

bool DeviceManager::LoadState(MigrationReader* reader) {
  reader->SetPrefix("kvm-irqchip");
  /* Load irq chip */
  kvm_irqchip chip;
  chip.chip_id = KVM_IRQCHIP_PIC_MASTER;
  if (!reader->ReadRaw("PIC_MASTER", &chip.chip.pic, sizeof(chip.chip.pic)))
    return false;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_SET_IRQCHIP, &chip) == 0);

  chip.chip_id = KVM_IRQCHIP_PIC_SLAVE;
  if (!reader->ReadRaw("PIC_SLAVE", &chip.chip.pic, sizeof(chip.chip.pic)))
    return false;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_SET_IRQCHIP, &chip) == 0);

  chip.chip_id = KVM_IRQCHIP_IOAPIC;
  if (!reader->ReadRaw("IOAPIC", &chip.chip.ioapic, sizeof(chip.chip.ioapic)))
    return false;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_SET_IRQCHIP, &chip) == 0);

  kvm_pit_state2 pit2;
  if (!reader->ReadRaw("PIT2", &pit2, sizeof(pit2)))
    return false;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_SET_PIT2, &pit2) == 0);

  /* Load device states */
  for (auto device : registered_devices_) {
    reader->SetPrefix(device->name());
    if (!device->LoadState(reader)) {
      MV_PANIC("failed to load state of device %s", device->name());
      return false;
    }
  }
  return true;
}

```

`core/dirty_memory.proto`:

```proto
syntax = "proto3";

message DirtyMemoryDescriptor {
  uint64  gpa   = 1;
  uint64  size  = 2;
}

```

`core/image.proto`:

```proto
syntax = "proto3";

message ImageDescriptor {
  sint64  offset  = 1;
}

```

`core/io_thread.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include "io_thread.h"

#include <cstring>
#include <unistd.h>
#include <arpa/inet.h>
#include <sys/eventfd.h>
#include <sys/mman.h>

#include <filesystem>

#include "logger.h"
#include "machine.h"
#include "qcow2.h"
#include "disk_image.h"


#define MAX_ENTRIES 256

IoThread::IoThread(Machine* machine) : machine_(machine) {
  epoll_fd_ = epoll_create(MAX_ENTRIES);
  event_fd_ = eventfd(0, 0);
}

IoThread::~IoThread() {
  Kick();

  if (thread_.joinable()) {
    thread_.join();
  }

  if (event_fd_ > 0) {
    safe_close(&event_fd_);
  }
  if (epoll_fd_ > 0) {
    safe_close(&epoll_fd_);
  }
  for (auto it = epoll_events_.begin(); it != epoll_events_.end(); it++) {
    delete it->second;
  }
  for (auto timer : timers_) {
    if (!timer->removed) {
      MV_WARN("timer %s is not removed when disconnected", timer->callback.target_type().name());
    }
    delete timer;
  }

  for (auto it = qcow2_image_backing_files_.begin(); it != qcow2_image_backing_files_.end(); it++) {
    auto& files = it->second;
    while (!files.empty()) {
      auto file = files.front();
      files.pop();
      remove(file.c_str());
    }
  }
  qcow2_image_backing_files_.clear();
}

void IoThread::Start() {
  thread_ = std::thread(&IoThread::RunLoop, this);

  StartPolling(nullptr, event_fd_, EPOLLIN, [this](auto ret) {
    MV_UNUSED(ret);
    uint64_t tmp;
    read(event_fd_, &tmp, sizeof(tmp));
  });
}

void IoThread::Stop() {
  /* Just wakeup the thread and found machine is stopped */
  MV_ASSERT(!machine_->IsValid());
  Kick();
}

void IoThread::Kick() {
  if (event_fd_ > 0) {
    uint64_t tmp = 1;
    write(event_fd_, &tmp, sizeof(tmp));
  }
}

bool IoThread::IsCurrentThread() {
  return std::this_thread::get_id() == thread_.get_id();
}

void IoThread::RunLoop() {
  SetThreadName("mvisor-iothread");
  signal(SIGPIPE, SIG_IGN);

  struct epoll_event events[MAX_ENTRIES];

  while (true) {
    /* Execute timer events and calculate the next timeout */
    int64_t next_timeout_ns;
    do {
      next_timeout_ns = CheckTimers();
    } while (next_timeout_ns <= 0);

    /* Check paused state before sleep */
    while(machine_->IsPaused() && CanPauseNow()) {
      machine_->WaitToResume();
    }
    if (!machine_->IsValid()) {
      break;
    }

    /* epoll_wait limits to 1ms at least. epoll_pwait2 is only available after kernel 5.11 */
    int nfds = epoll_wait(epoll_fd_, events, MAX_ENTRIES, std::max(1LL, next_timeout_ns / 1000000LL));
    if (nfds < 0 && errno != EINTR) {
      MV_PANIC("nfds=%d", nfds);
      break;
    }
    
    for (int i = 0; i < nfds; i++) {
      auto event_it = epoll_events_.find(events[i].data.fd);
      if (event_it == epoll_events_.end()) {
        /* Maybe the fd is deleted just now */
        continue;
      }
      auto event = event_it->second;
      auto start_time = std::chrono::steady_clock::now();
      if (event->device) {
        std::lock_guard<std::recursive_mutex> device_lock(event->device->mutex_);
        event->callback(events[i].events);
      } else {
        event->callback(events[i].events);
      }

      if (machine_->debug()) {
        auto cost_us = std::chrono::duration_cast<std::chrono::microseconds>(
          std::chrono::steady_clock::now() - start_time).count();
        if (cost_us >= 50000) {
          MV_LOG("%s SLOW fd=%d events=%d cost=%.3lfms", event->callback.target_type().name(),
            event->fd, events[i].events, double(cost_us) / 1000.0);
        }
      }
    }
  }

  if (machine_->debug()) MV_LOG("mvisor-iothread ended");
}

EpollEvent* IoThread::StartPolling(Device* device, int fd, uint poll_mask, IoCallback callback) {
  EpollEvent* event = new EpollEvent;
  event->fd = fd;
  event->callback = callback;
  event->device = device;
  event->event = epoll_event {
    .events = poll_mask,
    .data = {
      .fd = fd
    }
  };

  int ret = epoll_ctl(epoll_fd_, EPOLL_CTL_ADD, fd, &event->event);
  if (ret < 0) {
    MV_PANIC("failed to add epoll event, ret=%d", ret);
  }

  std::lock_guard<std::recursive_mutex> lock(mutex_);
  if (epoll_events_.find(fd) != epoll_events_.end()) {
    MV_PANIC("repeated polling fd=%d, mask=0x%x, callback=%s",
      fd, poll_mask, callback.target_type().name());
  }
  epoll_events_[fd] = event;
  return event;
}

void IoThread::StopPolling(int fd) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  auto it = epoll_events_.find(fd);
  MV_ASSERT(it != epoll_events_.end());

  auto event = it->second;
  int ret = epoll_ctl(epoll_fd_, EPOLL_CTL_DEL, event->fd, &event->event);
  if (ret < 0) {
    MV_PANIC("failed to delete epoll event, ret=%d", ret);
  }
  epoll_events_.erase(it);
  delete event;
}

IoTimer* IoThread::AddTimer(Device* device, int64_t interval_ns, bool permanent, VoidCallback callback) {
  IoTimer* timer = new IoTimer;
  timer->device = device;
  timer->permanent = permanent;
  timer->interval_ns = interval_ns;
  timer->callback = std::move(callback);
  timer->removed = false;
  timer->next_timepoint = std::chrono::steady_clock::now() + std::chrono::nanoseconds(interval_ns);

  std::lock_guard<std::recursive_mutex> lock(mutex_);
  timers_.push_back(timer);

  /* Wakeup io thread and recalculate the timeout */
  Kick();

  return timer;
}

void IoThread::RemoveTimer(IoTimer* timer) {
  timer->removed = true;
}

void IoThread::ModifyTimer(IoTimer* timer, int64_t interval_ns) {
  timer->interval_ns = interval_ns;
  timer->next_timepoint = std::chrono::steady_clock::now() + std::chrono::nanoseconds(interval_ns);
}

int64_t IoThread::CheckTimers() {
  auto now = std::chrono::steady_clock::now();
  int64_t min_timeout_ns = 100 * NS_PER_SECOND;

  std::vector<IoTimer*> triggered;

  mutex_.lock();
  for (auto it = timers_.begin(); it != timers_.end();) {
    auto timer = *it;
    if (timer->removed) {
      it = timers_.erase(it);
      delete timer;
    } else {
      auto delta_ns = std::chrono::duration_cast<std::chrono::nanoseconds>(timer->next_timepoint - now).count();
      if (delta_ns <= 0) {
        triggered.push_back(timer);
        timer->next_timepoint = now + std::chrono::nanoseconds(timer->interval_ns);
        delta_ns = timer->interval_ns;
      }
      if (delta_ns < min_timeout_ns) {
        min_timeout_ns = delta_ns;
      }
      ++it;
    }
  }
  mutex_.unlock();
  
  for (auto timer : triggered) {
    std::lock_guard<std::recursive_mutex> device_lock(timer->device->mutex_);
    /* better check again, in case of removing a timer in during a timer event or device IO */
    if (timer->removed) {
      continue;
    }
    timer->callback();

    if (!timer->permanent) {
      timer->removed = true;
      continue;
    }
  }
  return min_timeout_ns;
}

void IoThread::Schedule(Device* device, VoidCallback callback) {
  AddTimer(device, 0, false, std::move(callback));
}

void IoThread::RegisterDiskImage(DiskImage* image) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  disk_images_.push_back(image);
}

void IoThread::UnregisterDiskImage(DiskImage* image) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  disk_images_.remove(image);
}

void IoThread::FlushDiskImages() {
  std::lock_guard<std::recursive_mutex> lock(mutex_);

  for (auto image : disk_images_) {
    ImageIoRequest r = {
      .type = kImageIoFlush
    };
    image->QueueIoRequest(r, [](auto ret) {
      MV_UNUSED(ret);
    });
  }
}

bool IoThread::CanPauseNow() {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  if (machine_->pausing_)
    return false;

  /* Drain all disk IO */
  for (auto image : disk_images_) {
    if (image->busy()) {
      return false;
    }
  }

  /* Drain all IO schedule jobs */
  for (auto timer : timers_) {
    if (timer->interval_ns == 0) {
      return false;
    }
  }

  return true;
}

/* Make sure call Flush() before save disk images */
bool IoThread::SaveDiskImage(MigrationWriter* writer) {
  for (auto image : disk_images_) {
    auto& device = *image->deivce();
    if (image->readonly())
      continue;
    if (!image->snapshot())
      continue;

    /* Only copy snapshot image */
    auto network_writer = dynamic_cast<MigrationNetworkWriter*>(writer);
    if (network_writer) {
      if (!dynamic_cast<Qcow2Image*>(image)) {
        return false;
      }
      if (!network_writer->WriteFromFile("IMAGE", image->filepath(), QCOW2_MIGRATE_DATA_OFFSET)) {
        return false;
      }
    } else {
      auto file_writer = dynamic_cast<MigrationFileWriter*>(writer);
      MV_ASSERT(file_writer);

      file_writer->SetPrefix(device.name());
      auto new_path = file_writer->base_path() + "/" + device.name();
      if (!std::filesystem::exists(new_path)) {
        std::filesystem::create_directories(new_path);
      }
      new_path += "/disk.qcow2";
      if (std::filesystem::exists(new_path)) {
        std::filesystem::remove(new_path);
      }
      std::filesystem::copy_file(image->filepath(), new_path);
      device["image"] = new_path;
    }
  }
  return true;
}

// only could be called when vm was paused
bool IoThread::CreateQcow2ImageSnapshot() {
  for (auto image : disk_images_) {
    auto qcow2_image = dynamic_cast<Qcow2Image*>(image);
     if (!qcow2_image) {
      MV_ERROR("snapshot was only supported by qcow2");
      return false;
    }

    auto image_path = qcow2_image->filepath();
    if (!qcow2_image->CreateSnapshot()) {
      MV_ERROR("failed to create snapshot for qcow2 image=%s", image_path);
      return false;
    }
    qcow2_image_backing_files_[qcow2_image].push(image_path);
  }
  return true;
}

bool IoThread::SaveBackingDiskImage(MigrationNetworkWriter* writer) {
  for (auto image : disk_images_) {
    auto qcow2_image = dynamic_cast<Qcow2Image*>(image);
    auto files(qcow2_image_backing_files_[qcow2_image]);

    ImageDescriptor image_descriptor;
    image_descriptor.set_offset(QCOW2_MIGRATE_DATA_OFFSET);
    while (!files.empty()) {
      if (!writer->WriteProtobuf("IMAGE_DESCRIPTOR", image_descriptor)) {
        return false;
      }
      if (!writer->WriteFromFile("BACKING_IMAGE", files.front(), image_descriptor.offset())) {
        return false;
      }
      files.pop();
    }

    // offset=-1 means we transfer backing images data completely for current image
    image_descriptor.set_offset(-1);
    if (!writer->WriteProtobuf("IMAGE_DESCRIPTOR", image_descriptor)) {
      return false;
    }
  }
  return true;
}

bool IoThread::LoadBackingDiskImage(MigrationNetworkReader* reader) {
  for (auto image : disk_images_) { 
    auto qcow2_image = dynamic_cast<Qcow2Image*>(image);
    if (!qcow2_image) {
      MV_ERROR("snapshot was only supported by qcow2");
      return false;
    }

    ImageDescriptor image_descriptor;
    while (true) {
      if (!reader->ReadProtobuf("IMAGE_DESCRIPTOR", image_descriptor)) {
        MV_ERROR("failed to read disk image descriptor");
        return false;
      }

      if (image_descriptor.offset() == -1) {
        break;
      }
      
      reader->ReadToFile("BACKING_IMAGE", qcow2_image->filepath(), image_descriptor.offset());
      qcow2_image_backing_files_[qcow2_image].push(qcow2_image->filepath());
      if (!qcow2_image->CreateSnapshot()) {
        MV_ERROR("failed to create disk image snapshot, image=%s", qcow2_image->filepath().c_str());
        return false;
      }
    }
  }
  return true;
}

bool IoThread::LoadDiskImage(MigrationNetworkReader* reader) {
  for (auto image : disk_images_) {
    if (!dynamic_cast<Qcow2Image*>(image)) {
      MV_ERROR("migration was only supported by qcow2");
      return false;
    }
    reader->ReadToFile("IMAGE", image->filepath(), QCOW2_MIGRATE_DATA_OFFSET);
  }
  return true;
}

```

`core/machine.cc`:

```cc
/* 
 * MVisor - Virtual Machine Controller
 * KVM API reference: https://www.kernel.org/doc/html/latest/virt/kvm/api.html
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include "machine.h"

#include <linux/kvm.h>
#include <sys/ioctl.h>
#include <fcntl.h>
#include <unistd.h>
#include <cstring>

#include <filesystem>

#include "logger.h"
#include "disk_image.h"
#include "device_interface.h"
#include "migration.h"


Machine::Machine(std::string config_path) {
  /* Load the configuration and set values of num_vcpus & ram_size */
  config_ = new Configuration(this);
  if (!config_->Load(config_path)) {
    MV_PANIC("failed to load config file: %s", config_path.c_str());
  }

  InitializeKvm();

  /* Initialize system RAM and BIOS ROM */
  memory_manager_ = new MemoryManager(this);

  /* Currently, an i440fx / q35 chipset motherboard is implemented */
  Device* root = dynamic_cast<Device*>(LookupObjectByClass("SystemRoot"));
  if (!root) {
    MV_PANIC("failed to find system-root device");
  }
  /* Initialize IO thread before devices */
  io_thread_ = new IoThread(this);
  /* Initialize device manager, connect and reset all devices */
  device_manager_ = new DeviceManager(this, root);

  /* Create vcpu objects */
  for (int i = 0; i < num_vcpus_; ++i) {
    vcpus_.push_back(new Vcpu(this, i));
  }

  /* Start threads and wait to resume */
  std::unique_lock<std::mutex> lock(mutex_);
  wait_count_ = num_vcpus_ + 1;
  paused_ = true;

  for (auto vcpu: vcpus_) {
    vcpu->Start();
  }
  io_thread_->Start();
  /* Wait for all threads ready */
  wait_to_pause_condition_.wait(lock, [this]() {
    return wait_count_ == 0;
  });

  /* Reset devices after vCPU created and paused */
  device_manager_->ResetDevices();
}

/* Free VM resources */
Machine::~Machine() {
  valid_ = false;

  // Join all vcpu threads and free resources
  for (auto vcpu: vcpus_) {
    delete vcpu;
  }

  delete device_manager_;
  delete memory_manager_;
  delete io_thread_;

  // delete objects created by configuration
  for (auto it = objects_.begin(); it != objects_.end(); it++) {
    delete it->second;
  }

  safe_close(&vm_fd_);
  safe_close(&kvm_fd_);
  delete config_;
  
  if (network_writer_) {
    delete network_writer_;
  }
}

/* Create KVM instance */
void Machine::InitializeKvm() {
  kvm_fd_ = open("/dev/kvm", O_RDWR);
  MV_ASSERT(kvm_fd_ > 0);

  int api_version = ioctl(kvm_fd_, KVM_GET_API_VERSION, 0);
  if (api_version != KVM_API_VERSION) {
    MV_PANIC("kvm api verison %d, expected: %d", api_version, KVM_API_VERSION);
  }

  // Get the vcpu information block size. Vcpu uses this value
  kvm_vcpu_mmap_size_ = ioctl(kvm_fd_, KVM_GET_VCPU_MMAP_SIZE, 0);
  MV_ASSERT(kvm_vcpu_mmap_size_ > 0);

  // Create vm so that we can map userspace memory
  vm_fd_ = ioctl(kvm_fd_, KVM_CREATE_VM, 0);
  MV_ASSERT(vm_fd_ > 0);
}

/* Maybe there are lots of things to do before quiting a VM */
void Machine::Quit() {
  if (!valid_)
    return;
  
  /* Pause all threads and flush disk cache as well */
  if (!paused_) {
    Pause();
  }
  valid_ = false;

  /* If paused, threads are waiting to resume */
  wait_to_resume_.notify_all();

  for (auto vcpu: vcpus_) {
    vcpu->Kick();
  }
  io_thread_->Stop();
}

/* Recover BIOS data and reset all vCPU */
void Machine::Reset() {
  if (!valid_)
    return;
  memory_manager_->Reset();
  device_manager_->ResetDevices();

  if (debug_) {
    MV_LOG("Resettings vCPUs");
  }

  for (auto vcpu : vcpus_) {
    vcpu->Schedule([vcpu]() {
      vcpu->Reset();
    });
  }
}

/* Find the first object with matching name */
Object* Machine::LookupObjectByName(std::string name) {
  auto it = objects_.find(name);
  if (it == objects_.end()) {
    return nullptr;
  }
  return it->second;
}

/* Find the first object with matching name */
Object* Machine::LookupObjectByClass(std::string name) {
  for (auto it = objects_.begin(); it != objects_.end(); it++) {
    if (name == it->second->classname()) {
      return it->second;
    }
  }
  return nullptr;
}

/* Find all objects that compare function returns true */
std::vector<Object*> Machine::LookupObjects(std::function<bool (Object*)> compare) {
  std::vector<Object*> result;
  for (auto it = objects_.begin(); it != objects_.end(); it++) {
    if (compare(it->second)) {
      result.push_back(it->second);
    }
  }
  return result;
}

/* Power button is pressed */
void Machine::Shutdown() {
  for (auto o : LookupObjects([](auto o) { return dynamic_cast<PowerDownInterface*>(o); })) {
    auto interface = dynamic_cast<PowerDownInterface*>(o);
    interface->PowerDown();
  }
}

/* Resume from paused state */
void Machine::Resume() {
  std::unique_lock<std::mutex> lock(mutex_);
  if (!paused_) {
    MV_LOG("unable to resume a running machine");
    return;
  }
  MV_ASSERT(wait_count_ == 0);
  paused_ = false;

  /* Before running, broadcast messages */
  for (auto listener : state_change_listeners_) {
    listener->callback();
  }
  
  /* Resume threads */
  wait_to_resume_.notify_all();
}

/* Currently this method can only be called from UI threads */
void Machine::Pause() {
  std::unique_lock<std::mutex> lock(mutex_);
  if (!valid_ || paused_)
    return;

  /* Mark paused state and wait for vCPU threads */
  wait_count_ = num_vcpus_;
  pausing_ = true;
  paused_ = true;

  for (auto vcpu : vcpus_) {
    vcpu->Kick();
  }
  wait_to_pause_condition_.wait(lock, [this]() {
    return wait_count_ == 0;
  });

  /* Here all the threads are stopped, broadcast messages */
  for (auto listener : state_change_listeners_) {
    listener->callback();
  }

  /* Wait for IO thread to stop */
  io_thread_->FlushDiskImages();

  wait_count_ = 1;
  pausing_ = false;
  io_thread_->Kick();

  wait_to_pause_condition_.wait(lock, [this]() {
    return wait_count_ == 0;
  });
}

/* vCPU threads and IO threads call this method to sleep */
void Machine::WaitToResume() {
  std::unique_lock<std::mutex> lock(mutex_);  
  MV_ASSERT(wait_count_ > 0);
  wait_count_--;
  wait_to_pause_condition_.notify_all();
  wait_to_resume_.wait(lock, [this]() {
    return !IsPaused();
  });
}

/* Listeners are called after Pause / Resume */
const StateChangeListener* Machine::RegisterStateChangeListener(VoidCallback callback) {
  auto listener = new StateChangeListener {
    .callback = callback
  };
  std::lock_guard<std::mutex> lock(mutex_);
  state_change_listeners_.insert(listener);
  return listener;
}

void Machine::UnregisterStateChangeListener(const StateChangeListener** plistener) {
  std::lock_guard<std::mutex> lock(mutex_);
  if (state_change_listeners_.erase(*plistener)) {
    delete *plistener;
    *plistener = nullptr;
  }
}

bool Machine::PrepareForSaving() {
  bool ret = true;
  bool paused = IsPaused();
  if (!paused) {
    Pause();
  }

  // create snapshot for current disk images
  ret = io_thread_->CreateQcow2ImageSnapshot();
  if (!ret) {
    goto end;
  }

  // start tracking dirty memory before sending memory
  memory_manager_->StartTrackingDirtyMemory();

end:
  if (!paused) {
    Resume();
  }
  return ret;
}

/* Save through network */
bool Machine::Save(const std::string ip, const uint16_t port) {
  if (saving_) {
    MV_ERROR("machine is busy migrating");
    return false;
  }

  MV_LOG("start saving");
  saving_ = true;

  bool ret = false;
  if (network_writer_) {
    MV_LOG("retry save machine, close last connection");
    delete network_writer_;
  }

  /* Make connection to target machine */
  network_writer_ = new MigrationNetworkWriter();
  if (!network_writer_->Connect(ip, port)) {
    MV_ERROR("failed to connect target machine");
    goto end;
  }

  if (!PrepareForSaving()) {
    MV_ERROR("failed to prepare for saving");
    goto end;
  }

  /* Save backing disk images */
  if(!io_thread_->SaveBackingDiskImage(network_writer_)) {
    MV_ERROR("failed to save backing disk images");
    goto end;
  }
  
  if (!network_writer_->WaitForSignal(kMigrateBackingImageComplete)) {
    goto end;
  }

  /* Save system RAM */
  if (!memory_manager_->SaveState(network_writer_)) {
    MV_ERROR("failed to save memory");
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateRamComplete)) {
    goto end;
  }
  ret = true;

end:
  if (!ret) {
    delete network_writer_;
    network_writer_ = nullptr;
    memory_manager_->StopTrackingDirtyMemory();
  }

  saving_ = false;
  MV_LOG("done saving");
  return ret;
}

/* Save through network */
bool Machine::PostSave() {
  if (saving_) {
    MV_ERROR("machine is busy migrating");
    return false;
  }

  if (!network_writer_) {
    MV_ERROR("Save must be called successfully before PostSave");
    return false;
  }

  if (!IsPaused()) {
    Pause();
  }

  MV_LOG("start post-saving");
  saving_ = true;
  bool ret = false;

  if(!io_thread_->SaveDiskImage(network_writer_)) {
    MV_ERROR("failed to save disk images");
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateImageComplete)) {
    goto end;
  }

  if (!memory_manager_->SaveDirtyMemory(network_writer_, kDirtyMemoryTypeKvm)) {
    MV_ERROR("failed to save dirty memory from kvm");
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateDirtyMemoryFromKvmComplete)) {
    goto end;
  }

  if (!memory_manager_->SaveDirtyMemory(network_writer_, kDirtyMemoryTypeListener)) {
    MV_ERROR("failed to save dirty memory from listener");
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateDirtyMemoryFromListenerComplete)) {
    goto end;
  }

  /* Target machine need to get all memory before load device state,
   * so we send device state and dirty memory from dma together. */
  if (!device_manager_->SaveState(network_writer_)) {
    MV_ERROR("failed to save device states");
    goto end;
  }

  /* Save dirty memory from dma,
   * this step must be put after saving device state completely. */
  if (!memory_manager_->SaveDirtyMemory(network_writer_, kDirtyMemoryTypeDma)) {
    MV_ERROR("failed to save dirty memory from dma");
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateDirtyMemoryFromDmaComplete)) {
    goto end;
  }

  if (!network_writer_->WaitForSignal(kMigrateDeviceComplete)) {
    goto end;
  }

  /* Save vcpu states */
  for (auto vcpu : vcpus_) {
    if (!vcpu->SaveState(network_writer_)) {
      MV_ERROR("failed to save vcpu=%d states", vcpu->vcpu_id());
      goto end;
    }
  }

  if (!network_writer_->WaitForSignal(kMigrateVcpuComplete)) {
    goto end;
  }

  /* Wait for a finish signal */
  if (!network_writer_->WaitForSignal(kMigrateComplete)) {
    goto end;
  }
  ret = true;

end:
  delete network_writer_;
  network_writer_ = nullptr;

  saving_ = false;
  memory_manager_->StopTrackingDirtyMemory();
  MV_LOG("done post-saving");
  return ret;
}

/* Load through network */
void Machine::Load(uint16_t port) {
  MV_ASSERT(!loading_);
  if (!IsPaused()) {
    Pause();
  }

  MV_LOG("start loading");
  loading_ = true;
  
  // Bind port to wait connection
  MigrationNetworkReader reader;
  if (!reader.WaitForConnection(port)) {
    MV_PANIC("failed to setup connection");
  }
  
  /* Load backing disk image */
  if (!io_thread_->LoadBackingDiskImage(&reader)) {
    MV_PANIC("failed to load backing disk image");
  }
  reader.SendSignal(kMigrateBackingImageComplete);

  /* Load system RAM */
  if (!memory_manager_->LoadState(&reader)) {
    MV_PANIC("failed to load system ram");
  }
  reader.SendSignal(kMigrateRamComplete);

  /* Load disk image, LoadDiskImage must be called before virtio-block loadstate */
  if (!io_thread_->LoadDiskImage(&reader)) {
    MV_PANIC("failed to load disk image");
  }
  reader.SendSignal(kMigrateImageComplete);

  /* Load dirty memory from kvm */
  if (!memory_manager_->LoadDirtyMemory(&reader, kDirtyMemoryTypeKvm)) {
    MV_PANIC("failed to load dirty memory from kvm");
  }
  reader.SendSignal(kMigrateDirtyMemoryFromKvmComplete);

  /* Load dirty memory from listener */
  if (!memory_manager_->LoadDirtyMemory(&reader, kDirtyMemoryTypeListener)) {
    MV_PANIC("failed to load dirty memory from listener");
  }
  reader.SendSignal(kMigrateDirtyMemoryFromListenerComplete);

  /* Load dirty memory from Dma */
  if (!memory_manager_->LoadDirtyMemory(&reader, kDirtyMemoryTypeDma)) {
    MV_PANIC("failed to load dirty memory from dma");
  }
  reader.SendSignal(kMigrateDirtyMemoryFromDmaComplete);

  /* Load device states */
  if (!device_manager_->LoadState(&reader)) {
    MV_PANIC("failed to load device states");
  }
  reader.SendSignal(kMigrateDeviceComplete);

  /* Load vcpu states */
  for (auto vcpu : vcpus_) {
    if (!vcpu->LoadState(&reader)) {
      MV_PANIC("failed to load %s", vcpu->name());
    }
  }
  reader.SendSignal(kMigrateVcpuComplete);

  /* Make a finish signal to notice the source vm */
  reader.SendSignal(kMigrateComplete);

  loading_ = false;
  MV_LOG("done loading");
}

/* Should be called by UI thread */
void Machine::Save(const std::string path) {
  MV_ASSERT(!saving_);
  /* Make sure the machine is paused */
  if (!IsPaused()) {
    Pause();
  }
  saving_ = true;
  MV_LOG("start saving");

  MigrationFileWriter writer(path);
  /* Save device states */
  if (!device_manager_->SaveState(&writer)) {
    MV_ERROR("failed to save device states");
    goto end;
  }
  /* Save vcpu states */
  for (auto vcpu : vcpus_) {
    vcpu->SaveState(&writer);
  }
  /* Save system RAM */
  if (!memory_manager_->SaveState(&writer)) {
    MV_ERROR("failed to save RAM");
    goto end;
  }
  /* Save disk images */
  if (!io_thread_->SaveDiskImage(&writer)) {
    MV_ERROR("failed to sync disk images");
    goto end;
  }
  /* Save configuration after saving disk images (paths might changed) */
  if (!config_->Save(path + "/configuration.yaml")) {
    MV_ERROR("failed to save configuration yaml");
    goto end;
  }

end:
  saving_ = false;
  MV_LOG("done saving");
}

/* Should be called by UI thread */
void Machine::Load(const std::string path) {
  MV_ASSERT(!loading_);
  /* Make sure the machine is paused */
  if (!IsPaused()) {
    Pause();
  }
  loading_ = true;
  MV_LOG("start loading");

  MigrationFileReader reader(path);
  /* Load system RAM */
  if (!memory_manager_->LoadState(&reader)) {
    MV_PANIC("failed to load RAM");
  }
  /* Load device states */
  if (!device_manager_->LoadState(&reader)) {
    MV_PANIC("failed to load device states");
  }
  /* Load vcpu states */
  for (auto vcpu : vcpus_) {
    if (!vcpu->LoadState(&reader)) {
      MV_PANIC("failed to load %s", vcpu->name());
    }
  }

  loading_ = false;
  MV_LOG("done loading");
}

const char* Machine::GetStatus() {
  if (!valid_) {
    return "invalid";
  }

  if (saving_) {
    return "saving";
  }
  if (loading_) {
    return "loading";
  }
  if (!paused_) {
    return "running";
  }

  /* otherwise return paused */
  return "paused";
}

```

`core/memory_manager.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include "memory_manager.h"

#include <cstring>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <linux/kvm.h>

#include "dirty_memory.pb.h"
#include "machine.h"
#include "logger.h"


#define X86_EPT_IDENTITY_BASE 0xFEFFC000


MemoryManager::MemoryManager(const Machine* machine)
    : machine_(machine) {
  
  /* Get the number of slots we can allocate */
  uint max_slots = ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_NR_MEMSLOTS);
  for (uint i = 0; i < max_slots; i++) {
    free_slots_.insert(i);
  }

  /* Enable KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2 for migration */
  MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2));
  struct kvm_enable_cap enable_cap = {0};
  enable_cap.cap = KVM_CAP_MANUAL_DIRTY_LOG_PROTECT2;
  enable_cap.args[0] = KVM_DIRTY_LOG_MANUAL_PROTECT_ENABLE | KVM_DIRTY_LOG_INITIALLY_SET;
  MV_ASSERT(ioctl(machine_->vm_fd_, KVM_ENABLE_CAP, &enable_cap) == 0);

  /* Setup the memory slot to be traced */
  trace_slot_names_.insert("System");
  trace_slot_names_.insert("SeaBIOS");

  /* Setup the system memory map for BIOS to run */
  InitializeReservedMemory();
  InitializeSystemRam();
  LoadBiosFile();
}

MemoryManager::~MemoryManager() {
  for (auto listener: memory_listeners_) {
    delete listener;
  }
  for (auto listener: dirty_memory_listeners_) {
    delete listener;
  }
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); it++) {
    delete it->second;
  }
  for (auto region : regions_) {
    delete region;
  }
  munmap(ram_host_, machine_->ram_size_);
  dirty_memory_regions_.clear();
  if (bios_data_)
    free(bios_data_);
  if (bios_backup_)
    free(bios_backup_);
}

/* Allocate system ram for guest */
void MemoryManager::InitializeSystemRam() {
  if (machine_->debug_)
    MV_LOG("RAM size: %lu MB", machine_->ram_size_ >> 20);

  ram_host_ = mmap(nullptr, machine_->ram_size_, PROT_READ | PROT_WRITE,
    MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0);
  MV_ASSERT(ram_host_ != MAP_FAILED);

  /* Make host RAM mergeable (for KSM) */
  MV_ASSERT(madvise(ram_host_, machine_->ram_size_, MADV_MERGEABLE) == 0);
  MV_ASSERT(madvise(ram_host_, machine_->ram_size_, MADV_DONTDUMP) == 0);

  /* Don't map MMIO region */
  const uint64_t low_ram_upper_bound = 2 * (1LL << 30);
  const uint64_t high_ram_lower_bound = 1LL << 32;
  if (machine_->ram_size_ <= low_ram_upper_bound) {
    Map(0, machine_->ram_size_, ram_host_, kMemoryTypeRam, "System");
  } else {
    // Split the ram to two segments leaving a hole in the GPA
    Map(0, low_ram_upper_bound, ram_host_, kMemoryTypeRam, "System");
    // Skip the hole and map the rest
    Map(high_ram_lower_bound, machine_->ram_size_ - low_ram_upper_bound,
      (uint8_t*)ram_host_ + low_ram_upper_bound, kMemoryTypeRam, "System");
  }
}

/*
  * On older Intel CPUs, KVM uses vm86 mode to emulate 16-bit code directly.
  * In order to use vm86 mode, an EPT identity map and a TSS  are needed.
  * Since these must be part of guest physical memory, we need to allocate
  * them, both by setting their start addresses in the kernel and by
  * creating a corresponding e820 entry. We need 4 pages before the BIOS.
  *
  * Older KVM versions may not support setting the identity map base. In
  * that case we need to stick with the default, i.e. a 256K maximum BIOS
  * size.
  */
void MemoryManager::InitializeReservedMemory() {
  /* Allows up to 16M BIOSes. */
  uint64_t identity_base = X86_EPT_IDENTITY_BASE;
  if (ioctl(machine_->vm_fd_, KVM_SET_IDENTITY_MAP_ADDR, &identity_base) < 0) {
    MV_PANIC("failed to set identity map address");
  }

  if (ioctl(machine_->vm_fd_, KVM_SET_TSS_ADDR, identity_base + 0x1000) < 0) {
    MV_PANIC("failed to set tss");
  }
  
  /* Map these addresses as reserved so the guest never touch it */
  Map(X86_EPT_IDENTITY_BASE, 4 * PAGE_SIZE, nullptr, kMemoryTypeReserved, "EPT+TSS");
}

/* SeaBIOS is loaded into the end of 1MB and the end of 4GB */
void MemoryManager::LoadBiosFile() {
  auto& bios_path = machine_->config_->bios_path();
  // Read BIOS data from path to bios_data
  int fd = open(bios_path.c_str(), O_RDONLY);
  MV_ASSERT(fd > 0);  
  struct stat st;
  fstat(fd, &st);

  bios_size_ = st.st_size;
  bios_backup_ = malloc(bios_size_);
  read(fd, bios_backup_, bios_size_);
  safe_close(&fd);

  bios_data_ = valloc(bios_size_);
  memcpy(bios_data_, bios_backup_, bios_size_);
  // Map BIOS file to memory
  Map(0x100000 - bios_size_, bios_size_, bios_data_, kMemoryTypeRam, "SeaBIOS");
  Map(0x100000000 - bios_size_, bios_size_, bios_data_, kMemoryTypeRam, "SeaBIOS");
}

void MemoryManager::Reset() {
  /* Reset BIOS data */
  memcpy(bios_data_, bios_backup_, bios_size_);
  /* Reset 64KB low memory, or Windows 11 complains about some data at 0x6D80 when reboots */
  bzero(ram_host_, 0x10000);
}

/* The number of KVM slots is limited, try not to use out */
uint MemoryManager::AllocateSlotId() {
  MV_ASSERT(!free_slots_.empty());
  auto it = free_slots_.begin();
  uint slot_id = *it;
  free_slots_.erase(it);
  return slot_id;
}

void MemoryManager::UpdateKvmSlot(MemorySlot* slot, bool remove) {
  kvm_userspace_memory_region mr {
    .slot = slot->id,
    .flags = slot->flags,
    .guest_phys_addr = slot->begin,
    .memory_size = remove ? 0 : slot->end - slot->begin,
    .userspace_addr = slot->hva
  };

  if (ioctl(machine_->vm_fd_, KVM_SET_USER_MEMORY_REGION, &mr) < 0) {
    MV_PANIC("failed to set user memory region slot=%d gpa=%016lx size=%016lx hva=%016lx flags=%d",
      mr.slot, mr.guest_phys_addr, mr.memory_size, mr.userspace_addr, mr.flags);
  }
}

/* Don't call this funciton, use Map and Unmap */
void MemoryManager::AddMemoryRegion(MemoryRegion* region) {
  std::unordered_set<MemorySlot*> pending_add;
  std::unordered_set<MemorySlot*> pending_remove;
  
  /* Lock the global mutex while handling insert or remove */
  std::unique_lock lock(mutex_);

  MemorySlot* slot = new MemorySlot;
  slot->id = AllocateSlotId();
  slot->region = region;
  slot->type = region->type;
  slot->begin = region->gpa;
  slot->end = region->gpa + region->size;
  slot->hva = reinterpret_cast<uint64_t>(region->host);
  slot->flags = region->flags;
  pending_add.insert(slot);

  // Find all overlapped slots, split them, remove the old ones (resizing is not supported by KVM)
  // Maybe later we should support region priorities
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end() && it->second->begin < slot->end; ) {
    if (it->second->begin < slot->end && slot->begin < it->second->end) {
      MemorySlot *hit = it->second;
      MemorySlot *left = nullptr, *right = nullptr;
  
      // Collision found, split the slot
      if (hit->begin < slot->begin) {
        // Left collision
        left = new MemorySlot(*hit);
        left->end = slot->begin;
        left->id = AllocateSlotId();
      }
      if (slot->end < hit->end) {
        // Right collision
        right = new MemorySlot(*hit);
        right->begin = slot->end;
        right->hva = reinterpret_cast<uint64_t>(right->region->host) + (right->begin - right->region->gpa);
        right->id = AllocateSlotId();
      }
      // Move the iterator before we change kvm_slots
      if (!left && !right) {
        it = kvm_slots_.erase(it);
      } else {
        ++it;
        // Replace the hit slot with left and right
        if (left) {
          pending_add.insert(left);
          kvm_slots_[left->begin] = left;
        }
        if (right) {
          pending_add.insert(right);
          kvm_slots_[right->begin] = right;
        }
      }
      
      if (pending_add.find(hit) != pending_add.end()) {
        // Second collision happened, just remove the previous created
        pending_add.erase(hit);
        delete hit;
      } else {
        hit->region = nullptr;
        pending_remove.insert(hit);
      }
    } else {
      ++it;
    }
  }

  // Finally add the new slot
  kvm_slots_[slot->begin] = slot;
  regions_.insert(region);

  // Commit the pending slots to KVM
  for (auto slot : pending_remove) {
    if (slot->type == kMemoryTypeRam || slot->type == kMemoryTypeRom) {
      UpdateKvmSlot(slot, true);
      free_slots_.insert(slot->id);
    }
    // tell listeners we removed a slot
    for (auto listener : memory_listeners_) {
      listener->callback(slot, true);
    }
    delete slot;
  }
  for (auto slot : pending_add) {
    if (slot->type == kMemoryTypeRam || slot->type == kMemoryTypeRom) {
      UpdateKvmSlot(slot, false);
    }
    // tell listeners we have new slots
    for (auto listener : memory_listeners_) {
      listener->callback(slot, false);
    }
  }
}

/* Mapping a memory region in the guest address space */
const MemoryRegion* MemoryManager::Map(uint64_t gpa, uint64_t size, void* host, MemoryType type, const char* name) {
  MemoryRegion* region = new MemoryRegion;
  region->gpa = gpa;
  region->host = host;
  region->size = size;
  region->type = type;
  region->flags = type == kMemoryTypeRom ? KVM_MEM_READONLY : 0;
  if (type == kMemoryTypeRam && trace_slot_names_.find(name) != trace_slot_names_.end()) {
    region->flags |= KVM_MEM_LOG_DIRTY_PAGES;
  }
  strncpy(region->name, name, 20 - 1);

  if (machine_->debug_) {
    MV_LOG("map region %s gpa=0x%lx size=0x%lx type=0x%x", region->name,
      region->gpa, region->size, region->type);
  }

  AddMemoryRegion(region);
  return region;
}

/* TODO: should merge the slots after unmap */
void MemoryManager::Unmap(const MemoryRegion** pregion) {
  auto region = (MemoryRegion*)*pregion;
  if (machine_->debug_) {
    MV_LOG("unmap region %s gpa=0x%lx size=%lx type=%x", region->name,
      region->gpa, region->size, region->type);
  }

  std::unique_lock lock(mutex_);
  // Remove KVM slots
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); ) {
    auto slot = it->second;
    if (slot->region == region) {
      if (slot->type == kMemoryTypeRam || slot->type == kMemoryTypeRom) {
        UpdateKvmSlot(slot, true);
        free_slots_.insert(slot->id);
      }
      // tell listeners we removed a slot
      for (auto listener : memory_listeners_) {
        listener->callback(slot, true);
      }
      delete slot;
      it = kvm_slots_.erase(it);
    } else {
      ++it;
    }
  }

  // Remove region
  if (regions_.erase(region)) {
    delete region;
    *pregion = nullptr;
  }
}

/* StartTrackingDirtyMemory must be called in paused state to 
 * make sure that all dirty memory was updated completely */
void MemoryManager::StartTrackingDirtyMemory() {
  // flush dirty memory from kvm
  for (auto& slot : GetSlotsByNames(trace_slot_names_)) {
    size_t slot_size = slot.end - slot.begin;
    size_t bitmap_size = ALIGN(slot_size / PAGE_SIZE, 64) / 8;
    auto dirty_bitmap = new uint8_t[bitmap_size];
    if (GetDirtyBitmapFromKvm(slot.id, dirty_bitmap)) {
      kvm_clear_dirty_log clear_dirty = {
        .slot = slot.id,
        .num_pages = (uint32_t)(slot_size / PAGE_SIZE),
        .first_page = 0,
        .dirty_bitmap = dirty_bitmap
      };
      MV_ASSERT(ioctl(machine_->vm_fd_, KVM_CLEAR_DIRTY_LOG, &clear_dirty) == 0);
    }
    delete dirty_bitmap;
  }

  // tell listeners start tracking dirty memory
  for (auto listener : dirty_memory_listeners_) {
    listener->callback(kStartTrackingDirtyMemory);
  }

  // flush dirty memory from dirty_memory_regions_
  dirty_memory_regions_.clear();

  // open track memory switch
  track_dirty_memory_ = true;
}

void MemoryManager::StopTrackingDirtyMemory() {
  // tell listeners stop tracking dirty memory
  for (auto listener : dirty_memory_listeners_) {
    listener->callback(kStopTrackingDirtyMemory);
  }

  // close track memory switch
  track_dirty_memory_ = false;
}

// Update dirty memory map for migration
void MemoryManager::SetDirtyMemoryRegion(uint64_t gpa, size_t size) {
  if (!track_dirty_memory_) {
    return;
  }

  std::lock_guard<std::mutex> lock(dirty_memory_region_mutex_);
  auto item = dirty_memory_regions_.find(gpa);
  if (item != dirty_memory_regions_.end()) {
    item->second = std::max(item->second, size);
  } else {
    dirty_memory_regions_.insert(std::pair<uint64_t, size_t>(gpa, size));
  }
}

/* Since slots is a flat view without overlaps,
 * we simply use upper_bound to locate the slot in O(logN)
 */
void* MemoryManager::GuestToHostAddress(uint64_t gpa) {
  std::shared_lock lock(mutex_);

  // Find the first slot whose begin is smaller than gpa
  auto it = kvm_slots_.upper_bound(gpa);
  if (it != kvm_slots_.begin()) {
    --it;
  }
  MV_ASSERT(it != kvm_slots_.end());

  MemorySlot* slot = it->second;
  if (gpa >= slot->begin && gpa < slot->end) {
    uint64_t address = slot->hva + gpa - slot->begin;
    return reinterpret_cast<void*>(address);
  }

  // should never reach here
  PrintMemoryScope();
  MV_PANIC("failed to translate guest physical address 0x%016lx", gpa);
  return nullptr;
}

// WARN: low performance
uint64_t MemoryManager::HostToGuestAddress(void* host) {
  std::shared_lock lock(mutex_);
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); it++) { 
    auto slot = it->second;
    if (slot->type != kMemoryTypeRam) {
      continue;
    }

    auto hva = reinterpret_cast<uint64_t>(host);
    auto slot_size = slot->end - slot->begin;
    if (hva >= slot->hva && hva < slot->hva + slot_size) {
      return slot->begin + (hva - slot->hva);
    }
  }

  // should never reach here
  PrintMemoryScope();
  MV_PANIC("failed to translate host address to guest 0x%016lx", host);
  return 0;
}

bool MemoryManager::GetDirtyBitmapFromKvm(uint32_t slot, void* bitmap) {
  kvm_dirty_log dirty = {0};
  dirty.slot = slot;
  dirty.dirty_bitmap = bitmap;

  // dirty_bitmap containing any pages dirtied since the last call to this ioctl
  auto ret = ioctl(machine_->vm_fd_, KVM_GET_DIRTY_LOG, &dirty);
  if (ret != 0) {
    if (errno != ENOENT) {
      MV_PANIC("KVM_GET_DIRTY_LOG failed");
    }
    return false;
  }
  return true;
}

bool MemoryManager::HandleBitmap(const char* bitmap, size_t size, DirtyBitmapCallback callback) {
  for (size_t i = 0; i < size; i++) {
    if (bitmap[i] == 0) {
      continue;
    }

    for (size_t j = 0; j < 8; j++) {
      if ((bitmap[i] & (1 << j)) == 0) {
        continue;
      }

      if (!callback(i * 8 + j)) {
        MV_ERROR("failed to handle bitmap");
        return false;
      }
    }
  }
  return true;
}

bool MemoryManager::SaveDirtyMemory(MigrationNetworkWriter* writer, DirtyMemoryType type) {
  MV_ASSERT(track_dirty_memory_);
  size_t dirty_memory_size = 0;
  DirtyMemoryDescriptor memory_descriptor;

  switch (type) {
    case kDirtyMemoryTypeKvm: {
      memory_descriptor.set_size(PAGE_SIZE);
      for (auto& slot : GetSlotsByNames(trace_slot_names_)) {
        // kvm memory dirty bitmap is 64-page aligned
        size_t bitmap_size = ALIGN((slot.end - slot.begin) / PAGE_SIZE, 64) / 8;
        std::string dirty_bitmap(bitmap_size, '\0');
        if (!GetDirtyBitmapFromKvm(slot.id, dirty_bitmap.data())) {
          continue;
        }

        auto ret = HandleBitmap(dirty_bitmap.data(), bitmap_size, [&](auto offset) {
          memory_descriptor.set_gpa(slot.begin + offset * PAGE_SIZE);
          if (memory_descriptor.gpa() + memory_descriptor.size() > slot.end) {
            MV_PANIC("Guest phyical address is out of current slot, gpa=0x%lx slot=%s", memory_descriptor.gpa(), slot.region->name);
          }
          if (!writer->WriteProtobuf("DIRTY_MEMORY_DESCRIPTOR", memory_descriptor)) {
            return false;
          }
          uint64_t hva = slot.hva + offset * PAGE_SIZE;
          if (!writer->WriteRaw("DIRTY_MEMORY", reinterpret_cast<void*>(hva), memory_descriptor.size())) {
            return false;
          }
          dirty_memory_size += memory_descriptor.size();
          return true;
        });

        if (!ret) {
          return false;
        }
      }
      break;
    }
    case kDirtyMemoryTypeListener: {
      memory_descriptor.set_size(PAGE_SIZE);
      for (auto listener : dirty_memory_listeners_) {
        auto dirty_bitmaps = listener->callback(kGetDirtyMemoryBitmap);
        for (auto& bitmap : dirty_bitmaps) {
          auto ret = HandleBitmap(bitmap.data.data(), bitmap.data.size(), [&](auto offset) {
            memory_descriptor.set_gpa(bitmap.region.begin + offset * PAGE_SIZE);
            if (memory_descriptor.gpa() + memory_descriptor.size() > bitmap.region.end) {
              MV_PANIC("Guest phyical address is out of current bitmap region, gpa=0x%lx", memory_descriptor.gpa());
            }
            if (!writer->WriteProtobuf("DIRTY_MEMORY_DESCRIPTOR", memory_descriptor)) {
              return false;
            }
            uint64_t hva = bitmap.region.hva + offset * PAGE_SIZE;
            if (!writer->WriteRaw("DIRTY_MEMORY", reinterpret_cast<void*>(hva), memory_descriptor.size())) {
              return false;
            }
            dirty_memory_size += memory_descriptor.size();
            return true;
          });

          if (!ret) {
            return false;
          }
        }
      }
      break;
    }
    case kDirtyMemoryTypeDma: {
      for (auto it = dirty_memory_regions_.begin(); it != dirty_memory_regions_.end(); ++it) {
        memory_descriptor.set_gpa(it->first);
        memory_descriptor.set_size(it->second);
        if (!writer->WriteProtobuf("DIRTY_MEMORY_DESCRIPTOR", memory_descriptor)) {
          return false;
        }
        auto hva = GuestToHostAddress(memory_descriptor.gpa());
        if (!writer->WriteRaw("DIRTY_MEMORY", hva, memory_descriptor.size())) {
          return false;
        }
        dirty_memory_size += memory_descriptor.size();
      }
      break;
    }
    default:
      MV_PANIC("not implemented");
      break;
  }

  // send finish header
  memory_descriptor.set_size(0);
  if (!writer->WriteProtobuf("DIRTY_MEMORY_DESCRIPTOR", memory_descriptor)) {
    return false;
  }

  MV_LOG("Save dirty memory type=%d size=%ldMB", type, dirty_memory_size >> 20);
  return true;
}

bool MemoryManager::LoadDirtyMemory(MigrationNetworkReader* reader, DirtyMemoryType type) {
  size_t dirty_memory_size = 0;
  DirtyMemoryDescriptor memory_descriptor;

  while (true) {
    reader->ReadProtobuf("DIRTY_MEMORY_DESCRIPTOR", memory_descriptor);
    if (memory_descriptor.size() == 0) {
      break;
    }

    auto hva = GuestToHostAddress(memory_descriptor.gpa());
    reader->ReadRaw("DIRTY_MEMORY", hva, memory_descriptor.size());
    dirty_memory_size += memory_descriptor.size();
  }

  MV_LOG("Load dirty memory type=%d size=%ldMB", type, dirty_memory_size >> 20);
  return true;
}

/* Used for debugging */
void MemoryManager::PrintMemoryScope() {
  static const char* type_strings[] = { "Reserved", "RAM", "Device", "ROM", "Unknown" };
  std::shared_lock lock(mutex_);
  MV_LOG("%lu memory slots", kvm_slots_.size());
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); it++) {
    MemorySlot* slot = it->second;
    MV_LOG("Slot%3d %016lx-%016lx hva=%016lx %-10s %-10s",
      slot->id, slot->begin, slot->end, slot->hva, type_strings[slot->region->type],
      slot->region->name);
  }
}

/* Used to build E820 table */
std::vector<const MemorySlot*> MemoryManager::GetMemoryFlatView() {
  std::vector<const MemorySlot*> slots;
  std::shared_lock lock(mutex_);
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); it++) {
    slots.push_back(it->second);
  }
  return slots;
}

/* Vfio device tracks the memory map */
const MemoryListener* MemoryManager::RegisterMemoryListener(MemoryListenerCallback callback) {
  auto listener = new MemoryListener {
    .callback = callback
  };
  std::unique_lock lock(mutex_);
  memory_listeners_.insert(listener);
  return listener;
}

void MemoryManager::UnregisterMemoryListener(const MemoryListener** plistener) {
  std::unique_lock lock(mutex_);
  if (memory_listeners_.erase(*plistener)) {
    delete *plistener;
    *plistener = nullptr;
  }
}

/* Vfio device tracks dirty memory */
const DirtyMemoryListener* MemoryManager::RegisterDirtyMemoryListener(DirtyMemoryListenerCallback callback) {
  auto listener = new DirtyMemoryListener {
    .callback = callback
  };
  std::unique_lock lock(mutex_);
  dirty_memory_listeners_.insert(listener);
  return listener;
}

void MemoryManager::UnregisterDirtyMemoryListener(const DirtyMemoryListener** plistener) {
  std::unique_lock lock(mutex_);
  if (dirty_memory_listeners_.erase(*plistener)) {
    delete *plistener;
    *plistener = nullptr;
  }
}

std::vector<MemorySlot> MemoryManager::GetSlotsByNames(std::unordered_set<std::string> names) {
  std::vector<MemorySlot> slots;
  for (auto it = kvm_slots_.begin(); it != kvm_slots_.end(); ++it) {
    auto slot = it->second;
    if (names.find(slot->region->name) != names.end()) {
      slots.push_back(*slot);
    }
  }
  return slots;
}

/* Save memory to migration */
bool MemoryManager::SaveState(MigrationWriter* writer) {
  writer->SetPrefix("memory");
  writer->WriteRaw("BIOS", bios_data_, bios_size_);
  writer->WriteMemoryPages("RAM", ram_host_, machine_->ram_size_);
  return true;
}

/* Reading memory data from migration */
bool MemoryManager::LoadState(MigrationReader* reader) {
  reader->SetPrefix("memory");
  if (!reader->ReadRaw("BIOS", bios_data_, bios_size_)) {
    return false;
  }

  // get all system memory region from kvm_slots_
  auto system_slots = GetSlotsByNames({"System"});

  // unmap all system memory region
  for (auto it = system_slots.begin(); it != system_slots.end(); ++it) {
    Unmap((const MemoryRegion **)&it->region);
  }

  /* Map the RAM file as copy on write memory */
  if (!reader->ReadMemoryPages("RAM", &ram_host_, machine_->ram_size_)) {
    return false;
  }

  // reset system memory region
  for (auto it = system_slots.begin(); it != system_slots.end(); ++it) {
    Map(it->begin, it->end - it->begin, (void*)it->hva, kMemoryTypeRam, "System");
  }

  return true;
}

```

`core/meson.build`:

```build
mvisor_sources += files(
  'configuration.cc',
  'device_manager.cc',
  'device.cc',
  'io_thread.cc',
  'machine.cc',
  'memory_manager.cc',
  'object.cc',
  'pci_device.cc',
  'vcpu.cc'
)

proto_sources += proto_gen.process(
  'pci_device.proto',
  'vcpu.proto',
  'dirty_memory.proto',
  'image.proto'
)

mvisor_deps += dependency('yaml-cpp')

```

`core/object.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include "object.h"
#include <cstring>
#include <algorithm>
#include "logger.h"
#include "utilities.h"

Object* Object::Create(const char* class_name) {
  return realize_class(class_name);
}

void Object::set_name(const char* name) {
  strncpy(name_, name, OBJECT_MAX_NAME_LENGTH - 1);
}

void Object::set_classname(const char* classname) {
  strncpy(classname_, classname, OBJECT_MAX_NAME_LENGTH - 1);
}

void Object::set_parent_name(const char* parent_name) {
  strncpy(parent_name_, parent_name, OBJECT_MAX_NAME_LENGTH - 1);
}

void Object::set_default_parent_class(const char* primary, const char* secondary) {
  default_parent_classes_.clear();
  default_parent_classes_.push_back(primary);
  if (secondary) {
    default_parent_classes_.push_back(secondary);
  }
}

Object::Object() {
  name_[0] = 0;
  classname_[0] = 0;
  parent_name_[0] = 0;
}

Object::~Object() {

}

void Object::AddChild(Object* object) {
  object->parent_ = this;
  if (std::find(children_.begin(), children_.end(), object) == children_.end()) {
    children_.push_back(object);
  }
}

void Object::RemoveChild(Object* object) {
  object->parent_ = nullptr;
  auto it = std::find(children_.begin(), children_.end(), object);
  if (it != children_.end()) {
    children_.erase(it);
  }
}

```

`core/pci_device.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pci_device.h"
#include <cstring>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include "logger.h"
#include "machine.h"
#include "pci_device.pb.h"


PciDevice::PciDevice() {
  /* A pci device should be attached to pci bus */
  set_default_parent_class("Q35Host", "I440fxHost");

  bus_ = 0;
  slot_ = 0xFF;
  function_ = 0;
  bzero(&pci_header_, sizeof(pci_header_));
  bzero(&pci_bars_, sizeof(pci_bars_));
  bzero(&pci_rom_, sizeof(pci_rom_));
  bzero(&msi_config_, sizeof(msi_config_));

  next_capability_offset_ = 0x40;
  is_pcie_ = false;
}

PciDevice::~PciDevice() {
  if (pci_rom_.data) {
    free(pci_rom_.data);
  }
}

void PciDevice::Disconnect() {
  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    if (pci_bars_[i].active) {
      DeactivatePciBar(i);
    }
  }
  Device::Disconnect();
}

/* Some PCI device has ROM file, should we reset ROM data if system reset ??? */
void PciDevice::LoadRomFile(const char* path) {
  /* Load rom file from path */
  if (pci_rom_.data) {
    free(pci_rom_.data);
  }

  auto config = manager_->machine()->configuration();
  int fd = open(config->FindPath(path).c_str(), O_RDONLY);
  MV_ASSERT(fd >= 0);
  struct stat st;
  fstat(fd, &st);
  pci_rom_.size = st.st_size;

  /* 64KB alignment */
  size_t align = 0x10000;
  if (st.st_size % align) {
    pci_rom_.size = (st.st_size / align + 1) * align;
  }
  pci_rom_.data = valloc(pci_rom_.size);
  bzero(pci_rom_.data, pci_rom_.size);

  read(fd, pci_rom_.data, st.st_size);
  safe_close(&fd);
}

uint8_t* PciDevice::AddCapability(uint8_t cap, const uint8_t* data, uint8_t length) {
  PciCapabilityHeader cap_header = { .type = cap, .next = pci_header_.capability };
  uint8_t* ptr = pci_header_.data + next_capability_offset_;
  memcpy(ptr, &cap_header, sizeof(cap_header));
  memcpy(ptr + 2, data, length);
  pci_header_.capability = next_capability_offset_;

  next_capability_offset_ += 2 + length;
  pci_header_.status |= PCI_STATUS_CAP_LIST; /* Has capability */
  return ptr;
}

void PciDevice::AddMsiCapability() {
  MsiCapability64 cap64;
  bzero(&cap64, sizeof(cap64));
  cap64.control = PCI_MSI_FLAGS_64BIT;

  msi_config_.is_64bit = true;
  msi_config_.offset = next_capability_offset_;
  msi_config_.length = sizeof(cap64);
  msi_config_.msi64 = (MsiCapability64*)AddCapability(PCI_CAP_ID_MSI,
    (uint8_t*)&cap64.control, msi_config_.length - 2);
}

void PciDevice::AddMsiXCapability(uint8_t bar, uint16_t table_size, uint64_t space_offset, uint64_t space_size) {
  MV_ASSERT(table_size > 0 && table_size * sizeof(MsiXTableEntry) <= space_size);

  MsiXCapability cap;
  bzero(&cap, sizeof(cap));
  cap.control = table_size - 1;
  cap.table_offset = bar | space_offset;
  cap.pba_offset = bar | (space_offset + space_size / 2);

  msi_config_.is_msix = true;
  msi_config_.is_64bit = true;
  msi_config_.msix_bar = bar;
  msi_config_.msix_table_size = table_size;
  msi_config_.msix_space_offset = space_offset;
  msi_config_.msix_space_size = space_size;
  msi_config_.offset = next_capability_offset_;
  msi_config_.length = sizeof(cap);

  msi_config_.msix = (MsiXCapability*)AddCapability(PCI_CAP_ID_MSIX,
    (uint8_t*)&cap.control, msi_config_.length - 2);
}

void PciDevice::SignalMsi(int vector) {
  if (msi_config_.is_msix) {
    MV_ASSERT(vector < msi_config_.msix_table_size);
    auto &msix = msi_config_.msix_table[vector];
    if (msix.control & 1) {
      return; /* Masked */
    }
    uint64_t address = ((uint64_t)msix.message.address_hi << 32) | msix.message.address_lo;
    manager_->SignalMsi(address, msix.message.data);
  } else if (msi_config_.is_64bit) {
    MV_ASSERT(vector == 0);
    uint64_t address = ((uint64_t)msi_config_.msi64->address1 << 32) | msi_config_.msi64->address0;
    manager_->SignalMsi(address, msi_config_.msi64->data);
  } else {
    MV_PANIC("not implemented 32bit msi");
  }
}

void PciDevice::SetIrq(uint level) {
  MV_ASSERT(level == 0 || level == 1);
  MV_ASSERT(pci_header_.irq_pin);

  if (level) {
    pci_header_.status |= PCI_STATUS_INTERRUPT;
  } else {
    pci_header_.status &= ~PCI_STATUS_INTERRUPT;
  }

  if (pci_header_.command & PCI_COMMAND_INTX_DISABLE) {
    return;
  }

  manager_->SetPciIrqLevel(this, level);
}

void PciDevice::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (msi_config_.is_msix && resource->base == pci_bars_[msi_config_.msix_bar].address &&
    offset >= msi_config_.msix_space_offset &&
    offset + size <= msi_config_.msix_space_offset + msi_config_.msix_space_size
  ) {
    offset -= msi_config_.msix_space_offset;
    MV_ASSERT(offset + size <= sizeof(MsiXTableEntry) * msi_config_.msix_table_size);
    memcpy(data, (uint8_t*)msi_config_.msix_table + offset, size);
  } else {
    Device::Read(resource, offset, data, size);
  }
}

void PciDevice::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (msi_config_.is_msix && resource->base == pci_bars_[msi_config_.msix_bar].address) {
    if ( offset >= msi_config_.msix_space_offset && offset + size <= msi_config_.msix_space_offset + msi_config_.msix_space_size) {
      // set msix table
      offset -= msi_config_.msix_space_offset;
      MV_ASSERT(offset + size <= sizeof(MsiXTableEntry) * msi_config_.msix_table_size);
      memcpy((uint8_t*)msi_config_.msix_table + offset, data, size);
    } 
    return;
  } 

  Device::Write(resource, offset, data, size);
}

void PciDevice::ReadPciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
  if (offset + length > pci_config_size()) {
    MV_LOG("%s failed read config space at 0x%lx length=%d", name_, offset, length);
    return;
  }
  memcpy(data, pci_header_.data + offset, length);
  // if (debug_) {
  //   MV_LOG("%s read pci config 0x%lx size=%u data=0x%x", name_, offset, length, *(uint32_t*)data);
  // }
}

void PciDevice::WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
  if (offset + length > pci_config_size()) {
    MV_LOG("%s failed write config space at 0x%lx length=%d", name_, offset, length);
    return;
  }
  // if (debug_) {
  //   MV_LOG("%s write pci config 0x%lx size=%u data=0x%x", name_, offset, length, *(uint32_t*)data);
  // }

  if (offset == PCI_COMMAND) {
    if (length == 4) {
      WritePciConfigSpace(offset, data, 2);
      WritePciConfigSpace(offset + 2, data + 2, 2);
    } else {
      MV_ASSERT(length == 2);
      WritePciCommand(*(uint16_t*)data);
    }
    return;
  } else if (offset == PCI_STATUS) {
    MV_ASSERT(length == 2);
    pci_header_.status &= ~(*(uint16_t*)data);
    return;
  }

  uint8_t bar = (offset - PCI_BAR_OFFSET(0)) / sizeof(uint32_t);
  if (bar < PCI_BAR_NUMS) {
    MV_ASSERT(length == 4);;
    WritePciBar(bar, *(uint32_t*)data);
    return;
  } else if (bar == 8) {
    MV_ASSERT(length == 4);
    /* write rom bar address */
    uint32_t value = *(uint32_t*)data;
    if ((value & 0xfffff800) == 0xfffff800) {
      uint32_t mask = value;
      pci_header_.rom_bar = ~(pci_rom_.size - 1) & mask;
      return;
    } else if (value) {
      UpdateRomMapAddress(value & 0xfffff800);
    }
  }

  memcpy(pci_header_.data + offset, data, length);

  if (msi_config_.length) {
    /* Toggle MSI/MSI-X control */
    if (ranges_overlap(offset, length, msi_config_.offset + PCI_MSI_FLAGS, 1)) {
      if (msi_config_.is_msix) {
        msi_config_.enabled = msi_config_.msix->control & PCI_MSIX_FLAGS_ENABLE;
      } else if (msi_config_.is_64bit) {
        msi_config_.enabled = msi_config_.msi64->control & PCI_MSI_FLAGS_ENABLE;
      } else {
        msi_config_.enabled = msi_config_.msi32->control & PCI_MSI_FLAGS_ENABLE;
      }
    }
  }
}

/* Guest rewrite the ROM address, remmap to new address */
void PciDevice::UpdateRomMapAddress(uint32_t address) {
  auto mm = manager_->machine()->memory_manager();
  if (pci_rom_.mapped_region) {
    if (pci_rom_.mapped_region->gpa == address) {
      /* unchanged */
      return;
    }
    mm->Unmap(&pci_rom_.mapped_region);
  }

  pci_rom_.mapped_region = mm->Map(address, pci_rom_.size, pci_rom_.data, kMemoryTypeRom, "PCI ROM");
}

/* Handle IO, MMIO ON or OFF */
void PciDevice::WritePciCommand(uint16_t new_command) {
  uint diff = pci_header_.command ^ new_command;
  uint toggle_io = diff & PCI_COMMAND_IO;
  uint toggle_mem = diff & PCI_COMMAND_MEMORY;
  uint toggle_intx = diff & PCI_COMMAND_INTX_DISABLE;

  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    if (!pci_header_.bars[i])
      continue;

    bool bar_is_io = pci_header_.bars[i] & PCI_BASE_ADDRESS_SPACE_IO;
    if (toggle_io && bar_is_io) {
      if (new_command & PCI_COMMAND_IO)
        ActivatePciBar(i);
      else
        DeactivatePciBar(i);
    }

    if (toggle_mem && !bar_is_io) {
      if (new_command & PCI_COMMAND_MEMORY)
        ActivatePciBar(i);
      else
        DeactivatePciBar(i);
    }
  }

  pci_header_.command = new_command;

  /* If interrupt status is set, something has to be done */
  if (toggle_intx && (pci_header_.status & PCI_STATUS_INTERRUPT)) {
    bool disabled = new_command & PCI_COMMAND_INTX_DISABLE;
    manager_->SetPciIrqLevel(this, disabled ? 0 : 1);
  }
}

/* Call this function in device constructor */
void PciDevice::AddPciBar(uint8_t index, uint32_t size, IoResourceType type) {
  auto &bar = pci_bars_[index];
  MV_ASSERT(bar.size == 0);
  bar.size = size;
  bar.active = false;
  bar.type = type;
  if (type == kIoResourceTypePio) {
    bar.address_mask = PCI_BASE_ADDRESS_IO_MASK;
    bar.special_bits = PCI_BASE_ADDRESS_SPACE_IO;
  } else if (type == kIoResourceTypeMmio) {
    bar.address_mask = PCI_BASE_ADDRESS_MEM_MASK;
    bar.special_bits = 0;
  } else if (type == kIoResourceTypeRam) {
    bar.address_mask = PCI_BASE_ADDRESS_MEM_MASK;
    bar.special_bits = PCI_BASE_ADDRESS_MEM_PREFETCH;
  }
  pci_header_.bars[index] |= bar.special_bits;
}

/* Called when an bar is activate by guest BIOS or OS */
bool PciDevice::ActivatePciBar(uint8_t index) {
  auto &bar = pci_bars_[index];
  if (bar.active)
    return true;

  if (bar.type == kIoResourceTypePio) {
    AddIoResource(kIoResourceTypePio, bar.address, bar.size, "PCI BAR IO");
  } else if (bar.type == kIoResourceTypeMmio) {
    AddIoResource(kIoResourceTypeMmio, bar.address, bar.size, "PCI BAR MMIO");
  } else if (bar.type == kIoResourceTypeRam) {
    MV_ASSERT(bar.host_memory != nullptr);
    AddIoResource(kIoResourceTypeRam, bar.address, bar.size, "PCI BAR RAM", bar.host_memory);
  }
  bar.active = true;
  return true;
}

/* Release resources when resetting the bar address */
bool PciDevice::DeactivatePciBar(uint8_t index) {
  auto &bar = pci_bars_[index];
  if (!bar.active)
    return true;

  if (bar.type == kIoResourceTypePio) {
    RemoveIoResource(kIoResourceTypePio, bar.address);
  } else if (bar.type == kIoResourceTypeMmio) {
    RemoveIoResource(kIoResourceTypeMmio, bar.address);
  } else if (bar.type == kIoResourceTypeRam) {
    RemoveIoResource(kIoResourceTypeRam, bar.address);
  }
  bar.active = false;
  return true;
}

void PciDevice::WritePciBar(uint8_t index, uint32_t value) {
  auto &bar = pci_bars_[index];

  /*
   * If the kernel masks the BAR, it will expect to find the size of the
   * BAR there next time it reads from it. After the kernel reads the
   * size, it will write the address back.
   *
   * According to the PCI local bus specification REV 3.0: The number of
   * upper bits that a device actually implements depends on how much of
   * the address space the device will respond to. A device that wants a 1
   * MB memory address space (using a 32-bit base address register) would
   * build the top 12 bits of the address register, hardwiring the other
   * bits to 0.
   *
   * Furthermore, software can determine how much address space the device
   * requires by writing a value of all 1's to the register and then
   * reading the value back. The device will return 0's in all don't-care
   * address bits, effectively specifying the address space required.
   *
   * Software computes the size of the address space with the formula
   * S =  ~B + 1, where S is the memory size and B is the value read from
   * the BAR. This means that the BAR value that kvmtool should return is
   * B = ~(S - 1).
   */
  if (value == 0xffffffff) {
    value = ~(bar.size - 1);
    pci_header_.bars[index] = (value & bar.address_mask) | bar.special_bits;
    return;
  }

  uint64_t new_address = value & bar.address_mask;
  if (bar.address == new_address) {
    pci_header_.bars[index] = bar.address | bar.special_bits;
    return;
  }

  /* Don't toggle emulation when region type access is disabled. */
  if (bar.type == kIoResourceTypePio && !(pci_header_.command & PCI_COMMAND_IO)) {
    bar.address = new_address;
    pci_header_.bars[index] = bar.address | bar.special_bits;
    return;
  }

  if (bar.type != kIoResourceTypePio && !(pci_header_.command & PCI_COMMAND_MEMORY)) {
    bar.address = new_address;
    pci_header_.bars[index] = bar.address | bar.special_bits;
    return;
  }

  if (bar.active) {
    if(!DeactivatePciBar(index)){
      MV_PANIC("DeactivatePciBar would never fail");
      return;
    }
  }

  bar.address = new_address;
  pci_header_.bars[index] = bar.address | bar.special_bits;

  if (bar.address && !bar.active) {
    ActivatePciBar(index);
  }
}

bool PciDevice::SaveState(MigrationWriter* writer) {
  PciDeviceState state;
  state.set_bus(bus_);
  state.set_slot(slot_);
  state.set_function(function_);
  state.set_pcie(is_pcie_);
  state.set_config_space(pci_header_.data, pci_config_size());

  for (int i = 0; i < msi_config_.msix_table_size; i++) {
    auto& msix = msi_config_.msix_table[i];
    auto entry = state.add_msix_entries();
    entry->set_address(((uint64_t)msix.message.address_hi << 32) | msix.message.address_lo);
    entry->set_data(msix.message.data);
    entry->set_control(msix.control);
  }
  writer->WriteProtobuf("PCI", state);
  return Device::SaveState(writer);
}

bool PciDevice::LoadState(MigrationReader* reader) {
  if (!Device::LoadState(reader)) {
    return false;
  }
  PciDeviceState state;
  if (!reader->ReadProtobuf("PCI", state)) {
    return false;
  }
  bus_ = state.bus();
  slot_ = state.slot();
  function_ = state.function();
  is_pcie_ = state.pcie();
  auto& config_space = state.config_space();
  memcpy(pci_header_.data, config_space.data(), pci_config_size());

  /* recover pci bar information */
  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    auto &bar = pci_bars_[i];
    bar.address = pci_header_.bars[i] & bar.address_mask;
    if (bar.type == kIoResourceTypePio) {
      if (bar.address && (pci_header_.command & PCI_COMMAND_IO)) {
        ActivatePciBar(i);
      }
    } else {
      if (bar.address && (pci_header_.command & PCI_COMMAND_MEMORY)) {
        ActivatePciBar(i);
      }
    }
  }

  /* recover msix table */
  for (int i = 0; i < state.msix_entries_size(); i++) {
    auto& msix = msi_config_.msix_table[i];
    auto& entry = state.msix_entries(i);
    msix.message.address_hi = entry.address() >> 32;
    msix.message.address_lo = (uint32_t)entry.address();
    msix.message.data = entry.data();
    msix.control = entry.control();
  }

  /* enable msi / msix */
  if (msi_config_.length) {
    if (msi_config_.is_msix) {
      msi_config_.enabled = msi_config_.msix->control & PCI_MSIX_FLAGS_ENABLE;
    } else if (msi_config_.is_64bit) {
      msi_config_.enabled = msi_config_.msi64->control & PCI_MSI_FLAGS_ENABLE;
    } else {
      msi_config_.enabled = msi_config_.msi32->control & PCI_MSI_FLAGS_ENABLE;
    }
  }
  return true;
}

```

`core/pci_device.proto`:

```proto
syntax = "proto3";

message PciDeviceState {
  message MsiXTableEntry {
    uint64  address   = 1;
    uint32  data      = 2;
    uint32  control   = 3;
  }

  uint32  bus                           = 1;
  uint32  slot                          = 2;
  uint32  function                      = 3;
  bytes   config_space                  = 4;
  repeated MsiXTableEntry msix_entries  = 5;
  bool    pcie                          = 6;
}

```

`core/vcpu.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "vcpu.h"

#include <sys/ioctl.h>
#include <sys/mman.h>
#include <linux/kvm.h>
#include <cstring>

#include "machine.h"
#include "logger.h"
#include "hyperv/hyperv.h"
#include "hyperv/cpuid.h"
#include "linuz/kvm_para.h"


#define MAX_KVM_MSR_ENTRIES           256
#define MAX_KVM_CPUID_ENTRIES         100
#define KVM_MSR_ENTRY(_index, _data)  (struct kvm_msr_entry) { .index = _index, .reserved = 0, .data = _data }


/* Use Vcpu::current_vcpu() */
__thread Vcpu* Vcpu::current_vcpu_ = nullptr;


Vcpu::Vcpu(Machine* machine, int vcpu_id)
    : machine_(machine), vcpu_id_(vcpu_id) {

  fd_ = ioctl(machine_->vm_fd_, KVM_CREATE_VCPU, vcpu_id_);
  MV_ASSERT(fd_ > 0);

  /* A one page size memory region stored some information of current vcpu */
  kvm_run_ = (struct kvm_run*)mmap(nullptr, machine_->kvm_vcpu_mmap_size_,
    PROT_READ | PROT_WRITE, MAP_SHARED, fd_, 0);
  MV_ASSERT(kvm_run_ != MAP_FAILED);

  /* Handle multiple MMIO operations at one time */
  int coalesced_offset = ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_COALESCED_MMIO);
  if (coalesced_offset) {
    auto ring = (kvm_coalesced_mmio_ring*)((uint64_t)kvm_run_ + coalesced_offset * PAGE_SIZE);
    machine_->device_manager()->SetupCoalescingMmioRing(ring);
  }

  PrepareX86Vcpu();
}

Vcpu::~Vcpu() {
  if (thread_.joinable()) {
    thread_.join();
  }
  if (fd_ > 0)
    safe_close(&fd_);
  if (kvm_run_)
    munmap(kvm_run_, machine_->kvm_vcpu_mmap_size_);
}

/* Starting a vcpu is as simple as starting a thread on the host */
void Vcpu::Start() {
  thread_ = std::thread(&Vcpu::Process, this);
}


void Vcpu::Reset() {
  /* Reset CPU registers, MSRs */
  LoadStateFrom(default_state_, false);
}

/* 
 * Intel CPUID Instruction Reference
 * https://www.intel.com/content/dam/develop/external/us/en/documents/ \
 * architecture-instruction-set-extensions-programming-reference.pdf
 * Model: Skylake-Server Compatible
 */
#define CPU_VERSION(family, model, stepping) \
  (((family & 0xF) << 8) | (((model >> 4) & 0xF) << 16) | ((model & 0xF) << 4) | (stepping & 0xF))

void Vcpu::SetupCpuid() {
  struct {
    struct kvm_cpuid2 cpuid2;
    struct kvm_cpuid_entry2 entries[MAX_KVM_CPUID_ENTRIES];
  } cpuid;
  cpuid.cpuid2.nent = MAX_KVM_CPUID_ENTRIES;

  if (ioctl(machine_->kvm_fd_, KVM_GET_SUPPORTED_CPUID, &cpuid) < 0) {
    MV_PANIC("failed to get supported CPUID");
  }

  for (uint i = 0; i < cpuid.cpuid2.nent; i++) {
    auto entry = &cpuid.entries[i];
    switch (entry->function)
    {
    case 0x0: // CPUID Signature
      entry->eax = 0xD; // Max input value for basic information
      break;
    case 0x1: { // ACPI ID & Features
      entry->eax = CPU_VERSION(6, 85, 7);
      entry->ebx = (vcpu_id_ << 24) | (machine_->num_vcpus_ << 16) | (entry->ebx & 0xFFFF);

      bool tsc_deadline = ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_TSC_DEADLINE_TIMER);
      ALTER_FEATURE(entry->ecx, CPUID_EXT_TSC_DEADLINE_TIMER, tsc_deadline);
      ALTER_FEATURE(entry->ecx, CPUID_EXT_HYPERVISOR, machine_->hypervisor_);
      ALTER_FEATURE(entry->ecx, CPUID_EXT_PDCM, false); // Disable PMU
      ALTER_FEATURE(entry->edx, CPUID_HT, true);  // Max ACPI IDs reserved field is valid
      ALTER_FEATURE(entry->edx, CPUID_SS, false); // Self snoop

      cpuid_features_ = (uint64_t(entry->edx) << 32) | entry->ecx;
      break;
    }
    case 0x2: // Cache and TLB Information
      break;
    case 0x4: // Deterministic Cache Parameters Leaf
      entry->eax &= ~0xFC000000;
      if ((entry->eax & 0x1F) && machine_->num_vcpus_ >= 4) {
        int cores = machine_->num_vcpus_ / 2;
        entry->eax |= (cores - 1) << 26;
      }
      break;
    case 0x7: // Extended CPU features 7
      if (entry->index == 0) {
        // Disable HLE, RTM, MPX (Intel Memory Protection Extensions)
        entry->ebx &= (CPUID_7_0_EBX_FSGSBASE | CPUID_7_0_EBX_BMI1 |
          CPUID_7_0_EBX_AVX2 | CPUID_7_0_EBX_SMEP | CPUID_7_0_EBX_BMI2 |
          CPUID_7_0_EBX_ERMS | CPUID_7_0_EBX_INVPCID |
          CPUID_7_0_EBX_RDSEED | CPUID_7_0_EBX_ADX |
          CPUID_7_0_EBX_SMAP | CPUID_7_0_EBX_CLWB |
          CPUID_7_0_EBX_AVX512F | CPUID_7_0_EBX_AVX512DQ |
          CPUID_7_0_EBX_AVX512BW | CPUID_7_0_EBX_AVX512CD |
          CPUID_7_0_EBX_AVX512VL | CPUID_7_0_EBX_CLFLUSHOPT);
        // Disable PKU
        entry->ecx &= 0;
        entry->edx &= 0;
      }
      break;
    case 0xB: // CPU topology (cores = num_vcpus / 2, threads per core = 2)
      entry->edx = vcpu_id_;
      break;
    case 0xD:
      if (entry->index == 0) {
        entry->eax &= 0x2E7; // MPX is disabled in CPU features 7
      }
      break;
    case 0x80000000 ... 0x80000001: // Extended CPUID Information
      break;
    case 0x80000002 ... 0x80000004: { // CPU Model String
      static const char cpu_model[48] = "Intel Xeon Processor (Skylake-Server)";
      uint32_t offset = (entry->function - 0x80000002) * 16;
      memcpy(&entry->eax, cpu_model + offset, 16);
      break;
    }
    case 0x80000006: // Cache Line Information
    case 0x80000008: // Memory Address Size
      break;
    case 0x40000000 ... 0x4000FFFF:
      /* Move KVM CPUID to 0x40000100, leaving the place for Hyper-V */
      if (entry->function == 0x40000000) {
        entry->eax += 0x100;
      } else if (entry->function == 0x40000001) {
        entry->eax &= (
          KVM_FEATURE_CLOCKSOURCE | KVM_FEATURE_NOP_IO_DELAY | KVM_FEATURE_MMU_OP |
          KVM_FEATURE_CLOCKSOURCE2 | KVM_FEATURE_ASYNC_PF | KVM_FEATURE_STEAL_TIME |
          KVM_FEATURE_PV_EOI | KVM_FEATURE_PV_UNHALT | KVM_FEATURE_PV_TLB_FLUSH |       
          KVM_FEATURE_ASYNC_PF_VMEXIT | KVM_FEATURE_PV_SEND_IPI | KVM_FEATURE_POLL_CONTROL |
          KVM_FEATURE_PV_SCHED_YIELD | KVM_FEATURE_CLOCKSOURCE_STABLE_BIT
        );
      }
      entry->function += 0x100;
      break;
    default:
      /* Remove the function if not handled */
      memmove(entry, entry + 1, sizeof(*entry) * (cpuid.cpuid2.nent - i - 1));
      --i;
      --cpuid.cpuid2.nent;
      continue;
    }
  }

  /* Add Hyper-V functions to cpuid */
  if (machine_->hypervisor_) {
    SetupHyperV(&cpuid.cpuid2);
  }

  if (ioctl(fd_, KVM_SET_CPUID2, &cpuid) < 0)
    MV_PANIC("KVM_SET_CPUID2 failed");
}

void Vcpu::SetupHyperV(kvm_cpuid2* cpuid) {
  struct {
    struct kvm_cpuid2 cpuid2;
    struct kvm_cpuid_entry2 entries[MAX_KVM_CPUID_ENTRIES];
  } hyperv_cpuid;
  hyperv_cpuid.cpuid2.nent = MAX_KVM_CPUID_ENTRIES;

  if (ioctl(fd_, KVM_GET_SUPPORTED_HV_CPUID, &hyperv_cpuid) < 0) {
    MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_HYPERV));
    MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_HYPERV_TIME));
    MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_HYPERV_SYNIC));
    MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_HYPERV_TLBFLUSH));
    MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_HYPERV_SEND_IPI));
    MV_PANIC("failed to get supported Hyper-V CPUID. Please upgrade your kernel.");
  }

  for (uint i = 0; i < hyperv_cpuid.cpuid2.nent; i++) {
    auto entry = &hyperv_cpuid.entries[i];
    switch (entry->function)
    {
    case 0x40000000: // HV_CPUID_VENDOR_AND_MAX_FUNCTIONS
      entry->eax = HV_CPUID_IMPLEMENT_LIMITS;
      // entry->ebx defaults to "Linux KVM Hv"
      // memcpy(&entry->ebx, "Microsoft Hv", 12);
      break;
    case 0x40000001: // HV_CPUID_INTERFACE
      memcpy(&entry->eax, "Hv#1\0\0\0\0\0\0\0\0\0\0\0\0", 16);
      break;
    case 0x40000002: // HV_CPUID_VERSION
    case 0x40000005: // HV_CPUID_IMPLEMENT_LIMITS
      /* use the default values */
      break;
    case 0x40000003: // HV_CPUID_FEATURES
      entry->eax &= (
        HV_VP_RUNTIME_AVAILABLE | HV_TIME_REF_COUNT_AVAILABLE | HV_REFERENCE_TSC_AVAILABLE |
        HV_APIC_ACCESS_AVAILABLE | HV_SYNIC_AVAILABLE | HV_HYPERCALL_AVAILABLE |
        HV_VP_INDEX_AVAILABLE | HV_SYNTIMERS_AVAILABLE
      );
      entry->ebx &= HV_POST_MESSAGES | HV_SIGNAL_EVENTS;
      entry->edx = HV_CPU_DYNAMIC_PARTITIONING_AVAILABLE;

      hyperv_features_ = entry->eax;
      break;
    case 0x40000004: // HV_CPUID_ENLIGHTMENT_INFO
      entry->eax = HV_APIC_ACCESS_RECOMMENDED | HV_RELAXED_TIMING_RECOMMENDED |
        HV_CLUSTER_IPI_RECOMMENDED | HV_REMOTE_TLB_FLUSH_RECOMMENDED;
      /* spinlock retry attempts */
      entry->ebx = 0x0FFF;
      break;
    default:
      entry->function = 0; // disabled
    }
    
    if (entry->function) {
      cpuid->entries[cpuid->nent++] = *entry;
    }
  }

  if (hyperv_features_ & HV_SYNIC_AVAILABLE) {
    struct kvm_enable_cap enable_cap;
    bzero(&enable_cap, sizeof(enable_cap));
    enable_cap.cap = KVM_CAP_HYPERV_SYNIC;
    MV_ASSERT(ioctl(fd_, KVM_ENABLE_CAP, &enable_cap) == 0);
  }
}

void Vcpu::SetupMachineCheckException() {
  if (((cpuid_features_ >> 32) & 0x4080) != 0x4080) {
    /* MCE / MCA not supported */
    return;
  }
  
  uint64_t mce_cap;
  uint64_t banks = ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_MCE);
  MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_X86_GET_MCE_CAP_SUPPORTED, &mce_cap) == 0);
  mce_cap = (mce_cap & ~0xFF) | banks; 

  if (ioctl(fd_, KVM_X86_SETUP_MCE, &mce_cap) < 0) {
    MV_PANIC("failed to setup x86 MCE");
  }
}

uint64_t Vcpu::GetSupportedMsrFeature(uint index) {
  struct {
    kvm_msrs      msrs;
    kvm_msr_entry entries[1];
  } msrs;

  msrs.entries[0].index = index;
  msrs.msrs.nmsrs = 1;
  if (ioctl(machine_->kvm_fd_, KVM_GET_MSRS, &msrs) != 1) {
    MV_PANIC("failed to get msr feature index=0x%x", index);
  }
  return msrs.entries[0].data;
}

void Vcpu::SetupMsrIndices() {
  msr_indices_.clear();

  /* Setup common MSRS indices */
  struct {
    kvm_msr_list  list;
    uint32_t      indices[1000];
  } msr_list;
  msr_list.list.nmsrs = sizeof(msr_list.indices) / sizeof(uint32_t);
  MV_ASSERT(ioctl(machine_->kvm_fd_, KVM_GET_MSR_INDEX_LIST, &msr_list) == 0);

  for (uint i = 0; i < msr_list.list.nmsrs; i++) {
    auto index = msr_list.indices[i];
    // MSR_IA32_BNDCFGS
    if (index == 0xD90) {
      continue;
    }
    // PMU is disabled
    if(index >= 0x300 && index < 0x400) {
      continue;
    }
    // MSR_IA32_PERFCTR0
    if (index >= 0xC1 && index <= 0xC8) {
      continue;
    }
    // P4/Xeon+ specific
    if(index >= 0x180 && index < 0x200) {
      continue;
    }
    if (!(cpuid_features_ & CPUID_EXT_VMX) && (index >= 0x480 && index < 0x500)) {
      continue;
    }
    msr_indices_.insert(index);
  }

  /* Add up some MSR indices that we cannot get from supported list */
  if (hyperv_features_ & HV_SYNIC_AVAILABLE) {
    msr_indices_.insert(HV_X64_MSR_SCONTROL);
    msr_indices_.insert(HV_X64_MSR_SVERSION);
    msr_indices_.insert(HV_X64_MSR_SIMP);
    msr_indices_.insert(HV_X64_MSR_SIEFP);

    for (uint i = 0; i < HV_SINT_COUNT; i++) {
      msr_indices_.insert(HV_X64_MSR_SINT0 + i);
    }
  }

  if (hyperv_features_ & HV_SYNTIMERS_AVAILABLE) {
    for (uint i = 0; i < HV_STIMER_COUNT; i++) {
      msr_indices_.insert(HV_X64_MSR_STIMER0_CONFIG + i * 2);
      msr_indices_.insert(HV_X64_MSR_STIMER0_COUNT + i * 2);
    }
  }
}

void Vcpu::SetupModelSpecificRegisters() {
  struct {
    kvm_msrs      msrs;
    kvm_msr_entry entries[100];
  } msrs;
  uint index = 0;

  /* UCODE is needed for MCE / MCA */
  msrs.entries[index++] = KVM_MSR_ENTRY(MSR_IA32_TSC, 0);
  msrs.entries[index++] = KVM_MSR_ENTRY(MSR_IA32_UCODE_REV, GetSupportedMsrFeature(MSR_IA32_UCODE_REV));

  if (hyperv_features_ & HV_SYNIC_AVAILABLE) {
    msrs.entries[index++] = KVM_MSR_ENTRY(HV_X64_MSR_SVERSION, HV_SYNIC_VERSION);
    msrs.entries[index++] = KVM_MSR_ENTRY(HV_X64_MSR_SCONTROL, 0);
    msrs.entries[index++] = KVM_MSR_ENTRY(HV_X64_MSR_SIMP, 0);
    msrs.entries[index++] = KVM_MSR_ENTRY(HV_X64_MSR_SIEFP, 0);
  }

  msrs.msrs.nmsrs = index;
  auto ret = ioctl(fd_, KVM_SET_MSRS, &msrs);
  if (ret < 0)
    MV_PANIC("KVM_SET_MSRS failed");
}

/* Used for debugging sometimes */
void Vcpu::EnableSingleStep() {
  struct kvm_guest_debug debug = {
    .control = KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_SINGLESTEP,
    .pad = 0,
    .arch = {
      .debugreg = {0}
    }
  };

  if (ioctl(fd_, KVM_SET_GUEST_DEBUG, &debug) < 0)
    MV_PANIC("KVM_SET_GUEST_DEBUG");
  
  single_step_ = true;
}

/* Memory trapped IO */
void Vcpu::ProcessMmio() {
  auto dm = machine_->device_manager();
  dm->FlushCoalescingMmioBuffer();

  auto mmio = &kvm_run_->mmio;
  for (size_t i = mmio->len; i < sizeof(mmio->data); i++)
    mmio->data[i] = 0;
  dm->HandleMmio(mmio->phys_addr, mmio->data, mmio->len, mmio->is_write);
}

/* Traditional IN, OUT operations */
void Vcpu::ProcessIo() {
  auto dm = machine_->device_manager();
  dm->FlushCoalescingMmioBuffer();

  auto io = &kvm_run_->io;
  uint8_t* data = reinterpret_cast<uint8_t*>(kvm_run_) + kvm_run_->io.data_offset;
  dm->HandleIo(io->port, data, io->size, io->direction, io->count);
}

/* Hyper-V SynIc / Hypercalls */
void Vcpu::ProcessHyperV() {
  auto& hyperv_exit = kvm_run_->hyperv;
  switch (hyperv_exit.type)
  {
  case KVM_EXIT_HYPERV_SYNIC:
    switch (hyperv_exit.u.synic.msr) {
    case HV_X64_MSR_SCONTROL:
      if (machine_->debug_) {
        MV_LOG("msr_hv_synic_control = 0x%lx", hyperv_exit.u.synic.control);
      }
      hyperv_synic_.enabled = hyperv_exit.u.synic.control & 1;
      break;
    case HV_X64_MSR_SIMP:
      if (machine_->debug_) {
        MV_LOG("msr_hv_synic_msg_page = 0x%lx", hyperv_exit.u.synic.msg_page);
      }
      if (hyperv_exit.u.synic.msg_page & 1) {
        hyperv_synic_.message_address = hyperv_exit.u.synic.msg_page & 0xFFF;
      } else {
        hyperv_synic_.message_address = 0;
      }
      break;
    case HV_X64_MSR_SIEFP:
      if (machine_->debug_) {
        MV_LOG("msr_hv_synic_evt_page = 0x%lx", hyperv_exit.u.synic.evt_page);
      }
      if (hyperv_exit.u.synic.evt_page & 1) {
        hyperv_synic_.message_address = hyperv_exit.u.synic.evt_page & 0xFFF;
      } else {
        hyperv_synic_.event_address = 0;
      }
      break;
    default:
      MV_PANIC("invalid msr=%d", hyperv_exit.u.synic.msr);
    }
    break;
  case KVM_EXIT_HYPERV_HCALL:
    MV_PANIC("KVM_EXIT_HYPERV_HCALL not implemented");
    break;
  default:
    MV_PANIC("invalid hyperv exit type=%d", hyperv_exit.type);
  }
}

/* To wake up a vcpu thread, the easist way is to send a signal */
void Vcpu::SignalHandler(int signum) {
  // Do nothing now ...
  MV_UNUSED(signum);
}

/* Vcpu thread only response to SIG_USER at the moment */
void Vcpu::SetupSignalHandler() {
  sigset_t sigset;
  sigemptyset(&sigset);
  pthread_sigmask(SIG_BLOCK, &sigset, nullptr);

  signal(SIG_USER_INTERRUPT, Vcpu::SignalHandler);
}

void Vcpu::PrepareX86Vcpu() {
  SetupCpuid();
  SetupMsrIndices();
  SetupModelSpecificRegisters();

  /* Setup MCE for booting Linux */
  SetupMachineCheckException();

  /* Save default registers for system reset */
  SaveStateTo(default_state_);
}

/* Set the lowest priority to vcpu thread */
void Vcpu::SetupSchedPriority(int priority) {
  // https://man7.org/linux/man-pages/man7/sched.7.html
  if (priority == 0) {
    // linux set priority 0 to thread as default
    return;
  }
  MV_ASSERT(priority >= MIN_NICE && priority <= MAX_NICE);
  MV_ASSERT(nice(priority));
}

/* Initialize and executing a vCPU thread */
void Vcpu::Process() {
  current_vcpu_ = this;
  sprintf(name_, "mvisor-vcpu-%d", vcpu_id_);
  SetThreadName(name_);
  
  SetupSignalHandler();
  SetupSchedPriority(machine_->vcpu_priority_);

  if (machine_->debug()) MV_LOG("%s started", name_);

  while (true) {
    while (machine_->IsPaused()) {
      machine_->WaitToResume();
    }
    if (!machine_->IsValid()) {
      break;
    }
    int ret = ioctl(fd_, KVM_RUN, 0);
    if (ret < 0 && errno != EINTR) {
      if (errno == EAGAIN) {
        continue;
      }
      MV_LOG("KVM_RUN failed vcpu=%d ret=%d errno=%d", vcpu_id_, ret, errno);
    }

    switch (kvm_run_->exit_reason)
    {
    case KVM_EXIT_MMIO:
      ProcessMmio();
      break;
    case KVM_EXIT_IO:
      ProcessIo();
      break;
    case KVM_EXIT_HYPERV:
      ProcessHyperV();
      break;
    case KVM_EXIT_INTR:
      /* User interrupt */
      break;
    case KVM_EXIT_UNKNOWN:
      MV_PANIC("KVM_EXIT_UNKNOWN vcpu=%d", vcpu_id_);
      break;
    case KVM_EXIT_SHUTDOWN:
      /* A hard reset request reached here */
      MV_LOG("KVM_EXIT_SHUTDOWN vcpu=%d", vcpu_id_);
      machine_->Reset();
      break;
    case KVM_EXIT_HLT:
      MV_LOG("KVM_EXIT_HLT vcpu=%d", vcpu_id_);
      goto quit;
    case KVM_EXIT_DEBUG:
      PrintRegisters();
      getchar();
      break;
    default:
      MV_PANIC("vcpu %d exit reason %d, expected KVM_EXIT_HLT(%d)", vcpu_id_,
        kvm_run_->exit_reason, KVM_EXIT_HLT);
    }

    /* Execute tasks after processing IO/MMIO */
    ExecuteTasks();
  }

quit:
  if (machine_->debug_) MV_LOG("%s ended", name_);
}

void Vcpu::Kick() {
  if (thread_.joinable()) {
    pthread_kill(thread_.native_handle(), SIG_USER_INTERRUPT);
  }
}

void Vcpu::Schedule(VoidCallback callback) {
  std::lock_guard<std::mutex> lock(mutex_);
  tasks_.emplace_back(VcpuTask {
    .callback = std::move(callback)
  });
  Kick();
}

void Vcpu::ExecuteTasks() {
  while (!tasks_.empty()) {
    VcpuTask task = tasks_.front();
    task.callback();
  
    mutex_.lock();
    tasks_.pop_front();
    mutex_.unlock();
  }
}

/* Used for debugging */
void Vcpu::PrintRegisters() {
  struct kvm_regs regs;
  struct kvm_sregs sregs;
  if (ioctl(fd_, KVM_GET_REGS, &regs) < 0)
    MV_PANIC("KVM_GET_REGS failed");
  if (ioctl(fd_, KVM_GET_SREGS, &sregs) < 0)
    MV_PANIC("KVM_GET_REGS failed");

  // call logger.h
  ::PrintRegisters(regs, sregs);
}

void Vcpu::SaveStateTo(VcpuState& state) {
  /* KVM vcpu events */
  kvm_vcpu_events events;
  MV_ASSERT(ioctl(fd_, KVM_GET_VCPU_EVENTS, &events) == 0);
  state.set_events(&events, sizeof(events));

  /* KVM MP State */
  kvm_mp_state mp_state;
  MV_ASSERT(ioctl(fd_, KVM_GET_MP_STATE, &mp_state) == 0);
  state.set_mp_state(mp_state.mp_state);

  /* Common regsiters */
  kvm_regs regs;
  MV_ASSERT(ioctl(fd_, KVM_GET_REGS, &regs) == 0);
  state.set_regs(&regs, sizeof(regs));

  /* FPU regsiters */
  kvm_fpu fpu;
  MV_ASSERT(ioctl(fd_, KVM_GET_FPU, &fpu) == 0);
  state.set_fpu(&fpu, sizeof(fpu));

  /* XSAVE */
  kvm_xsave xsave;
  MV_ASSERT(ioctl(fd_, KVM_GET_XSAVE, &xsave) == 0);
  state.set_xsave(&xsave, sizeof(xsave));

  /* XCRS */
  kvm_xcrs xcrs;
  MV_ASSERT(ioctl(fd_, KVM_GET_XCRS, &xcrs) == 0);
  state.set_xcrs(&xcrs, sizeof(xcrs));

  /* Special registers */
  kvm_sregs sregs;
  MV_ASSERT(ioctl(fd_, KVM_GET_SREGS, &sregs) == 0);
  state.set_sregs(&sregs, sizeof(sregs));

  /* MSRS */
  struct {
    kvm_msrs      msrs;
    kvm_msr_entry entries[MAX_KVM_MSR_ENTRIES];
  } msrs;
  bzero(&msrs, sizeof(msrs));
  for (auto index : msr_indices_) {
    msrs.entries[msrs.msrs.nmsrs++].index = index;
  }
  int nr = ioctl(fd_, KVM_GET_MSRS, &msrs);
  if (nr != (int)msrs.msrs.nmsrs) {
    MV_PANIC("failed to get MSR(%d) index=0x%x", nr, msrs.entries[nr].index);
  }
  state.set_msrs(&msrs, sizeof(msrs));

  /* LAPIC */
  kvm_lapic_state lapic;
  MV_ASSERT(ioctl(fd_, KVM_GET_LAPIC, &lapic) == 0);
  state.set_lapic(&lapic, sizeof(lapic));

  /* TSC kHz */
  int64_t tsc_khz = ioctl(fd_, KVM_GET_TSC_KHZ);
  if (tsc_khz > 0) {
    state.set_tsc_khz(tsc_khz);
  }

  /* Guest debugs */
  kvm_guest_debug debug;
  MV_ASSERT(ioctl(fd_, KVM_GET_DEBUGREGS, &debug) == 0);
  state.set_debug_regs(&debug, sizeof(debug));
  
  /* CPUID (save for future use) */
  struct {
    struct kvm_cpuid2 cpuid2;
    struct kvm_cpuid_entry2 entries[MAX_KVM_CPUID_ENTRIES];
  } cpuid;
  bzero(&cpuid, sizeof(cpuid));
  cpuid.cpuid2.nent = MAX_KVM_CPUID_ENTRIES;
  MV_ASSERT(ioctl(fd_, KVM_GET_CPUID2, &cpuid) == 0);
  state.set_cpuid(&cpuid, sizeof(cpuid));
}

void Vcpu::LoadStateFrom(VcpuState& state, bool load_cpuid) {
  if (load_cpuid) {
    struct {
      struct kvm_cpuid2 cpuid2;
      struct kvm_cpuid_entry2 entries[MAX_KVM_CPUID_ENTRIES];
    } cpuid;
    memcpy(&cpuid, state.cpuid().data(), sizeof(cpuid));
    MV_ASSERT(ioctl(fd_, KVM_SET_CPUID2, &cpuid) == 0);
    
    /* Reset MSR indices */
    SetupMsrIndices();
  }

  /* Special registers */
  kvm_sregs sregs;
  memcpy(&sregs, state.sregs().data(), sizeof(sregs));
  MV_ASSERT(ioctl(fd_, KVM_SET_SREGS, &sregs) == 0);

  /* LAPIC */
  kvm_lapic_state lapic;
  memcpy(&lapic, state.lapic().data(), sizeof(lapic));
  MV_ASSERT(ioctl(fd_, KVM_SET_LAPIC, &lapic) == 0);

  /* Common regsiters */
  kvm_regs regs;
  memcpy(&regs, state.regs().data(), sizeof(regs));
  MV_ASSERT(ioctl(fd_, KVM_SET_REGS, &regs) == 0);

  /* FPU */
  kvm_fpu fpu;
  memcpy(&fpu, state.fpu().data(), sizeof(fpu));
  MV_ASSERT(ioctl(fd_, KVM_SET_FPU, &fpu) == 0);

  /* XSAVE */
  kvm_xsave xsave;
  memcpy(&xsave, state.xsave().data(), sizeof(xsave));
  MV_ASSERT(ioctl(fd_, KVM_SET_XSAVE, &xsave) == 0);

  /* XCRS */
  kvm_xcrs xcrs;
  memcpy(&xcrs, state.xcrs().data(), sizeof(xcrs));
  MV_ASSERT(ioctl(fd_, KVM_SET_XCRS, &xcrs) == 0);

  /* TSC must be set before KVM_SET_MSRS, otherwise it may cause the guest to get time in a mess */
  // https://patchwork.kernel.org/project/kvm/patch/1443418711-24106-4-git-send-email-haozhong.zhang@intel.com/#15469651
  if (ioctl(machine_->kvm_fd_, KVM_CHECK_EXTENSION, KVM_CAP_TSC_CONTROL)) {
    MV_ASSERT(ioctl(fd_, KVM_SET_TSC_KHZ, state.tsc_khz()) == 0);
  } else {
    MV_WARN("KVM_CAP_TSC_CONTROL was not supported");
  }

  /* MSRS */
  struct {
    kvm_msrs      msrs;
    kvm_msr_entry entries[MAX_KVM_MSR_ENTRIES];
  } msrs;
  memcpy(&msrs, state.msrs().data(), sizeof(msrs));
  int nmsrs = msrs.msrs.nmsrs;
  while (nmsrs > 0) {
    auto ret = ioctl(fd_, KVM_SET_MSRS, &msrs);
    MV_ASSERT(ret >= 0);
    if (ret < nmsrs) {
      MV_LOG("Failed to set MSR 0x%x=0x%x. Maybe kernel version is too old?",
        msrs.entries[ret].index, msrs.entries[ret].data);
      // Skip the failed one
      nmsrs -= ret + 1;
      memmove(msrs.entries, &msrs.entries[ret + 1], nmsrs * sizeof(kvm_msr_entry));
    } else {
      nmsrs -= ret;
    }
  }

  /* KVM vcpu events */
  kvm_vcpu_events events;
  memcpy(&events, state.events().data(), sizeof(events));
  MV_ASSERT(ioctl(fd_, KVM_SET_VCPU_EVENTS, &events) == 0);
  
  /* KVM MP State */
  kvm_mp_state mp_state;
  mp_state.mp_state = state.mp_state();
  MV_ASSERT(ioctl(fd_, KVM_SET_MP_STATE, &mp_state) == 0);

  /* Guest debugs */
  kvm_guest_debug debug;
  memcpy(&debug, state.debug_regs().data(), sizeof(debug));
  MV_ASSERT(ioctl(fd_, KVM_SET_GUEST_DEBUG, &debug) == 0);
}

bool Vcpu::SaveState(MigrationWriter* writer) {
  std::stringstream prefix;
  prefix << "vcpu-" << vcpu_id_;
  writer->SetPrefix(prefix.str());

  VcpuState state;
  SaveStateTo(state);

  writer->WriteProtobuf("CURRENT", state);
  writer->WriteProtobuf("DEFAULT", default_state_);
  return true;
}

bool Vcpu::LoadState(MigrationReader* reader) {
  std::stringstream prefix;
  prefix << "vcpu-" << vcpu_id_;
  reader->SetPrefix(prefix.str());

  if (!reader->ReadProtobuf("DEFAULT", default_state_)) {
    return false;
  }

  VcpuState state;
  if (!reader->ReadProtobuf("CURRENT", state)) {
    return false;
  }

  LoadStateFrom(state, true);
  return true;
}

```

`core/vcpu.proto`:

```proto
syntax = "proto3";

message VcpuState {
  /* KVM Multi-processor state */
  uint32  mp_state      = 1;
  /* X86 Regs */
  bytes   regs          = 2;
  /* X86 SRegs */
  bytes   sregs         = 3;
  /* X86 XSAVE */
  bytes   xsave         = 4;
  /* X86 XCRS */
  bytes   xcrs          = 5;
  /* X86 MSRS */
  bytes   msrs          = 6;
  /* X86 LAPIC */
  bytes   lapic         = 7;
  /* Debug regs */
  bytes   debug_regs    = 8;
  /* Nested states */
  bytes   nested_state  = 9;
  /* KVM Vcpu events */
  bytes   events        = 10;
  /* TSC kHz */
  int64   tsc_khz       = 11;
  /* X86 FPU */
  bytes   fpu           = 12;
  /* X86 CPUID */
  bytes   cpuid         = 13;
}

```

`devices/acpi/ich9_lpc.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pmio.h"
#include "ich9_lpc.pb.h"
#include "device_manager.h"
#include "machine.h"
#include "logger.h"

#define ICH9_LPC_PMIO_BASE                      0x40
#define ICH9_LPC_PMIO_BASE_RTE                  0x1
#define ICH9_LPC_PMIO_BASE_DEFAULT              0x1

#define ICH9_LPC_ACPI_CTRL                      0x44

#define ICH9_LPC_PIRQA_ROUTE                    0x60
#define ICH9_LPC_PIRQB_ROUTE                    0x61
#define ICH9_LPC_PIRQC_ROUTE                    0x62
#define ICH9_LPC_PIRQD_ROUTE                    0x63

#define ICH9_LPC_PIRQE_ROUTE                    0x68
#define ICH9_LPC_PIRQF_ROUTE                    0x69
#define ICH9_LPC_PIRQG_ROUTE                    0x6a
#define ICH9_LPC_PIRQH_ROUTE                    0x6b

#define ICH9_LPC_GEN_PMCON_1                    0xa0
#define ICH9_LPC_GEN_PMCON_1_SMI_LOCK           (1 << 4)
#define ICH9_LPC_GEN_PMCON_2                    0xa2
#define ICH9_LPC_GEN_PMCON_3                    0xa4
#define ICH9_LPC_GEN_PMCON_LOCK                 0xa6

#define ICH9_LPC_RCBA                           0xf0
#define ICH9_LPC_RCBA_BA_MASK                   Q35_MASK(32, 31, 14)
#define ICH9_LPC_RCBA_EN                        0x1
#define ICH9_LPC_RCBA_DEFAULT                   0x0

/* 16KB. Chipset configuration registers */
#define ICH9_CC_SIZE                            (16 * 1024)

#define ICH9_PMIO_SIZE                          128


class Ich9Lpc : public Pmio {
 private:
  struct {
    uint8_t     control;
    uint8_t     status;
  } apm_;

  bool          initialized_pmio_ = false;
  bool          initialized_rcrb_ = false;

  void UpdatePmio() {
    /* PM IO base should be 0xB000 */
    pmio_base_ = *(uint32_t*)&pci_header_.data[ICH9_LPC_PMIO_BASE];
    pmio_base_ &= 0xFFC0;
    uint8_t acpi_ctrl = pci_header_.data[ICH9_LPC_ACPI_CTRL];

    if (acpi_ctrl & 0x80) {
      if (!initialized_pmio_) {
        AddIoResource(kIoResourceTypePio, pmio_base_, ICH9_PMIO_SIZE, "PMIO");
        initialized_pmio_ = true;

        /* update system control irq, 0 means IRQ 9 */
        auto irq_select = acpi_ctrl & 7;
        MV_ASSERT(irq_select == 0);
      }
    } else {
      if (initialized_pmio_) {
        RemoveIoResource(kIoResourceTypePio, "PMIO");
        pmio_base_ = 0;
        initialized_pmio_ = false;
      }
    }
  }

  void UpdateRootComplexRegisterBlock() {
    uint32_t rcrb = *(uint32_t*)(pci_header_.data + ICH9_LPC_RCBA);
    if (rcrb & ICH9_LPC_RCBA_EN) {
      if (!initialized_rcrb_) {
        AddIoResource(kIoResourceTypeMmio, rcrb & ICH9_LPC_RCBA_BA_MASK, ICH9_CC_SIZE, "RCRB");
        initialized_rcrb_ = true;
        manager_->set_pci_irq_translator([this](uint slot, uint function, uint pin) -> uint {
          MV_UNUSED(function);
          return TranslatePciIrq(slot, pin);
        });
      }
    } else {
      if (initialized_rcrb_) {
        RemoveIoResource(kIoResourceTypeMmio, "RCRB");
        initialized_rcrb_ = false;
        manager_->set_pci_irq_translator(nullptr);
      }
    }
  }

  /* According to the ACPI configuration (check acpi_dsdt used by FirmwareConfig),
   * DEV 0-24       INTx[A-D] -> PIRQ[E-F]
   * DEV 25-29, 31  INTx[A-D] -> PIRQ[A-D]
   * DEV 30         INTx[A-D] -> PIRQ[E-F]
   */
  uint TranslatePciIrq(uint slot, uint pin) {
    uint8_t intx = pin - 1;
    uint8_t pirq = (slot + intx) % 4 + 4;

    /* For ICH9 special devices, we should read the configuration from LPC RCBA */
    if (slot == 30) {
      pirq = (intx % 4) + 4;
    } else if (slot >= 25) {
      pirq = intx % 4;
    }

    /* PIRQ is starting from index 16 */
    return 16 + pirq;
  }

 public:
  Ich9Lpc() {
    slot_ = 31;
    function_ = 0;
    
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x2918;
    pci_header_.class_code = 0x060100;
    pci_header_.revision_id = 2;
    pci_header_.header_type = PCI_MULTI_FUNCTION | PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;

    AddIoResource(kIoResourceTypePio, 0xB2, 2, "LPC APM");
    /* https://qemu.readthedocs.io/en/v6.2.0/specs/acpi_pci_hotplug.html */
    AddIoResource(kIoResourceTypePio, 0xAE00, 20, "ACPI PCI HOTPLUG");
  }

  void Connect() {
    Pmio::Connect();

    /* Device present COM1 COM2 LPT Floppy */
    pci_header_.data[0x82] = (0 << 0) | (0 << 1) | (0 << 2) | (0 << 3);
  }

  void Reset() {
    Pmio::Reset();
    
    for (int i = 0; i < 4; i++) {
      pci_header_.data[ICH9_LPC_PIRQA_ROUTE + i] = 0x80;
      pci_header_.data[ICH9_LPC_PIRQE_ROUTE + i] = 0x80;
    }
    
    bzero(&apm_, sizeof(apm_));
    *(uint32_t*)(pci_header_.data + ICH9_LPC_PMIO_BASE) = ICH9_LPC_PMIO_BASE_DEFAULT;
    *(uint8_t*)(pci_header_.data + ICH9_LPC_ACPI_CTRL) = 0;
    UpdatePmio();

    *(uint32_t*)(pci_header_.data + ICH9_LPC_RCBA) = 0;
    UpdateRootComplexRegisterBlock();
  }

  bool SaveState(MigrationWriter* writer) {
    Ich9LpcState state;
    auto apm = state.mutable_apm();
    apm->set_control(apm_.control);
    apm->set_status(apm_.status);

    writer->WriteProtobuf("LPC", state);
    return Pmio::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!Pmio::LoadState(reader)) {
      return false;
    }

    Ich9LpcState state;
    if (!reader->ReadProtobuf("LPC", state)) {
      return false;
    }
    auto& apm = state.apm();
    apm_.control = apm.control();
    apm_.status = apm.status();

    UpdatePmio();
    UpdateRootComplexRegisterBlock();
    return true;
  }

  void WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
    Pmio::WritePciConfigSpace(offset, data, length);

    if (ranges_overlap(offset, length, ICH9_LPC_PMIO_BASE, 4) ||
        ranges_overlap(offset, length, ICH9_LPC_ACPI_CTRL, 1)) {
      /* pm io base || lsacpi enable, SCI: IRQ9 000b = irq9*/
      UpdatePmio();
    }
    if (ranges_overlap(offset, length, ICH9_LPC_RCBA, 4)) {
      /* set root complex register block BAR */
      UpdateRootComplexRegisterBlock();
    }
    if (ranges_overlap(offset, length, ICH9_LPC_PIRQA_ROUTE, 4)) {
      /* activate irq remapping in LPC A-D */
      if (debug_) {
        MV_LOG("activate irq remapping in LPC A-D");
        MV_HEXDUMP("remapping", pci_header_.data + ICH9_LPC_PIRQA_ROUTE, 4);
      }
    }
    if (ranges_overlap(offset, length, ICH9_LPC_PIRQE_ROUTE, 4)) {
      /* activate irq remapping in LPC E-H */
      if (debug_) {
        MV_LOG("activate irq remapping in LPC E-H");
        MV_HEXDUMP("remapping", pci_header_.data + ICH9_LPC_PIRQA_ROUTE, 4);
      }
    }
    if (ranges_overlap(offset, length, ICH9_LPC_GEN_PMCON_1, 8)) {
      MV_PANIC("ich9_lpc_pmcon_update(lpc);");
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == 0xB2) { // APM IO
      if (offset == 0) {
        data[0] = apm_.control;
      } else {
        data[0] = apm_.status;
      }
    } else if (resource->base == 0xAE00) { // ACPI PCI HOTPLUG
      if (offset == 0x0C) { // PCI removability status
        /* disable all PCIs hotplug */
        bzero(data, size);
      }
    } else {
      Pmio::Read(resource, offset, data, size);
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == 0xB2) { // APM IO
      if (offset == 0) {
        apm_.control = data[0];
        if (apm_.control == 2) { // Enable ACPI
          pm1_.control |= PMIO_PM1_CTRL_SMI_EN;
        } else if (apm_.control == 3) { // Disable ACPI
          pm1_.control &= ~PMIO_PM1_CTRL_SMI_EN;
        } else {
          MV_PANIC("unknown apm control=0x%x", *data);
        }
      } else {
        apm_.status = data[0];
      }
    } else {
      Pmio::Write(resource, offset, data, size);
    }
  }
};

DECLARE_DEVICE(Ich9Lpc);

```

`devices/acpi/ich9_lpc.proto`:

```proto
syntax = "proto3";

message Ich9LpcState {
  message Apm {
    uint32  control         = 1;
    uint32  status          = 2;
  }

  Apm       apm             = 1;
}

```

`devices/acpi/ich9_smbus.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pci_device.h"

class Ich9Smbus : public PciDevice {
 public:
  Ich9Smbus() {
    slot_ = 31;
    function_ = 3;
    
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x2930;
    pci_header_.class_code = 0x0C0500;
    pci_header_.revision_id = 2;
    pci_header_.header_type = PCI_MULTI_FUNCTION | PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.irq_pin = 1;

    AddPciBar(4, 64, kIoResourceTypePio);
  }
};

DECLARE_DEVICE(Ich9Smbus);

```

`devices/acpi/meson.build`:

```build

mvisor_sources += files(
  'pmio.cc',
  'pmio.h',
  'ich9_lpc.cc',
  'ich9_smbus.cc',
  'piix3.cc',
  'piix4_pm.cc'
)

proto_sources += proto_gen.process(
  'pmio.proto',
  'ich9_lpc.proto',
  'piix3.proto',
  'piix4_pm.proto'
)

```

`devices/acpi/piix3.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "logger.h"
#include "pci_device.h"
#include "device_manager.h"


#define PIIX_PIRQA_ROUTE   0x60
#define PIIX_PIRQB_ROUTE   0x61
#define PIIX_PIRQC_ROUTE   0x62
#define PIIX_PIRQD_ROUTE   0x63


class Piix3 : public PciDevice {
 private:

  uint TranslatePciIrq(uint slot, uint function, uint pin) {
    /* According to ACPI configuration, slot 1 uses IRQ 9? */
    if (slot == 1 && function == 0) {
      return 9;
    }

    /* INTx[A-D] -> PIRQ[D-A] */
    uint8_t pirq = (slot + pin - 1 + 3) % 4;
    uint8_t gsi = pci_header_.data[PIIX_PIRQA_ROUTE + pirq] & ~0x80;
    return gsi;
  }

 public:
  Piix3() {
    slot_ = 1;
    function_ = 0;

    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x7000;
    pci_header_.class_code = 0x060100;
    pci_header_.header_type = PCI_MULTI_FUNCTION | PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
  }

  void Connect() {
    PciDevice::Connect();

    manager_->set_pci_irq_translator([this](uint slot, uint function, uint pin) -> uint {
      return TranslatePciIrq(slot, function, pin);
    });
  }

  void Disconnect() {
    PciDevice::Disconnect();
    manager_->set_pci_irq_translator(nullptr);
  }

  void Reset() {
    PciDevice::Reset();
    
    for (int i = 0; i < 4; i++) {
      pci_header_.data[PIIX_PIRQA_ROUTE + i] = 0x80;
    }
  }
};

DECLARE_DEVICE(Piix3);

```

`devices/acpi/piix3.proto`:

```proto
syntax = "proto3";

message Piix3State {
}

```

`devices/acpi/piix4_pm.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>

#include "logger.h"
#include "pmio.h"
#include "device_manager.h"
#include "machine.h"
#include "piix4_pm.pb.h"


#define PIIX_PMIO_BASE      0x40
#define PIIX_PMIO_MISC      0x80
#define PIIX_SMBUS_BASE     0x90
#define PIIX_SMBUS_MISC     0xD2
#define PIIX_PMIO_SIZE      64


class Piix4Pm : public Pmio {
 private:
  struct {
    uint8_t     control;
    uint8_t     status;
  } apm_;

  bool          initialized_pmio_ = false;
  bool          initialized_smbus_ = false;

  void UpdatePmio() {
    /* PM IO base should be 0xB000 */
    pmio_base_ = *(uint32_t*)(pci_header_.data + PIIX_PMIO_BASE);
    pmio_base_ &= 0xFFC0;
    uint8_t misc = pci_header_.data[PIIX_PMIO_MISC];

    if (misc & 1) {
      if (!initialized_pmio_) {
        AddIoResource(kIoResourceTypePio, pmio_base_, PIIX_PMIO_SIZE, "PMIO");
        initialized_pmio_ = true;
      }
    } else {
      if (initialized_pmio_) {
        RemoveIoResource(kIoResourceTypePio, "PMIO");
        pmio_base_ = 0;
        initialized_pmio_ = false;
      }
    }
  }

  void UpdateSmbus() {
    uint32_t smbus_base = *(uint32_t*)(pci_header_.data + PIIX_SMBUS_BASE);
    smbus_base &= 0xFFC0;
    uint8_t smbus_misc = pci_header_.data[PIIX_SMBUS_MISC];
    if (smbus_misc & 1) {
      if (!initialized_smbus_) {
        AddIoResource(kIoResourceTypePio, smbus_base, 64, "SMBUS");
        initialized_smbus_ = true;
      }
    } else {
      if (initialized_smbus_) {
        RemoveIoResource(kIoResourceTypePio, "SMBUS");
        initialized_smbus_ = false;
      }
    }
  }

 public:
  Piix4Pm() {
    slot_ = 1;
    function_ = 3;

    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x7113;
    pci_header_.class_code = 0x068000;
    pci_header_.revision_id = 3;
    pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.irq_pin = 1;

    AddIoResource(kIoResourceTypePio, 0xB2, 2, "LPC APM");
    // /* https://qemu.readthedocs.io/en/v6.2.0/specs/acpi_pci_hotplug.html */
    AddIoResource(kIoResourceTypePio, 0xAE00, 20, "ACPI PCI HOTPLUG");
  }

  void Connect() {
    Pmio::Connect();

    /* Device present mark at pci_header_.data 0x5F 0x67 not handled yet */
    pci_header_.data[0x5F] = 0;
  }

  void Reset() {
    Pmio::Reset();

    /* Mark SMM initialized (not supported now) */
    pci_header_.data[0x5B] = 2;
    
    bzero(&apm_, sizeof(apm_));
    *(uint32_t*)(pci_header_.data + PIIX_PMIO_BASE) = 1;
    pci_header_.data[PIIX_PMIO_MISC] = 0;
    UpdatePmio();
  }

  bool SaveState(MigrationWriter* writer) {
    Piix4PmState state;
    auto apm = state.mutable_apm();
    apm->set_control(apm_.control);
    apm->set_status(apm_.status);

    writer->WriteProtobuf("PIIX4_PM", state);
    return Pmio::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!Pmio::LoadState(reader)) {
      return false;
    }

    Piix4PmState state;
    if (!reader->ReadProtobuf("PIIX4_PM", state)) {
      return false;
    }
    auto& apm = state.apm();
    apm_.control = apm.control();
    apm_.status = apm.status();

    UpdatePmio();
    return true;
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == 0xB2) { // APM IO
      if (offset == 0) {
        data[0] = apm_.control;
      } else {
        data[0] = apm_.status;
      }
    } else if (resource->base == 0xAE00) { // ACPI PCI HOTPLUG
      if (offset == 0x0C) { // PCI removability status
        /* disable all PCIs hotplug */
        bzero(data, size);
      }
    } else {
      Pmio::Read(resource, offset, data, size);
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == 0xB2) { // APM IO
      if (offset == 0) {
        apm_.control = data[0] & 1;
        if (apm_.control == 1) { // Enable ACPI
          pm1_.control |= PMIO_PM1_CTRL_SMI_EN;
        } else if (apm_.control == 0) { // Disable ACPI
          pm1_.control &= ~PMIO_PM1_CTRL_SMI_EN;
        } else {
          MV_PANIC("unknown apm control=0x%x", *data);
        }
      } else {
        apm_.status = data[0];
      }
    } else {
      Pmio::Write(resource, offset, data, size);
    }
  }

  void WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
    Pmio::WritePciConfigSpace(offset, data, length);

    if (ranges_overlap(offset, length, PIIX_PMIO_BASE, 4) ||
        ranges_overlap(offset, length, PIIX_PMIO_MISC, 1)) {
      UpdatePmio();
    } else if (ranges_overlap(offset, length, PIIX_SMBUS_BASE, 4) ||
               ranges_overlap(offset, length, PIIX_SMBUS_MISC, 1)) {
      UpdateSmbus();
    }
  }
};

DECLARE_DEVICE(Piix4Pm);

```

`devices/acpi/piix4_pm.proto`:

```proto
syntax = "proto3";

message Piix4PmState {
  message Apm {
    uint32  control         = 1;
    uint32  status          = 2;
  }

  Apm       apm             = 1;
}

```

`devices/acpi/pmio.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pmio.h"

#include <sys/time.h>

#include "device_manager.h"
#include "machine.h"
#include "pmio.pb.h"


#define ACPI_BITMASK_SLEEP_ENABLE   0x2000
#define PM_TIMER_FREQUENCY          3579545


void Pmio::UpdateSystemControlIrq() {
  uint level = (pm1_.enable & pm1_.status & 0x521) || (gpe0_.enable & gpe0_.status);
  // FIXME: hardcoded IRQ 9
  manager_->SetGsiLevel(9, level);
}

void Pmio::Reset() {
  PciDevice::Reset();

  bzero(&pm1_, sizeof(pm1_));
  bzero(&gpe0_, sizeof(gpe0_));
  bzero(&smi_, sizeof(smi_));

  smi_.enable = PMIO_SMI_EN_APMC_EN;
  pmio_base_ = 0;
}

bool Pmio::SaveState(MigrationWriter* writer) {
  PmioState state;
  state.set_pm1_status(pm1_.status);
  state.set_pm1_enable(pm1_.enable);
  state.set_pm1_control(pm1_.control);
  state.set_pm1_timer(pm1_.timer);
  state.set_gpe0_enable(gpe0_.enable);
  state.set_gpe0_status(gpe0_.status);
  state.set_smi_enable(smi_.enable);
  state.set_smi_status(smi_.status);

  writer->WriteProtobuf("PMIO", state);
  return PciDevice::SaveState(writer);
}

bool Pmio::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }

  PmioState state;
  /* For old snapshots, PMIO is within LPC, so just skip it */
  if (!reader->Exists("PMIO")) {
    return true;
  }
  if (!reader->ReadProtobuf("PMIO", state)) {
    return false;
  }
  return true;
}

void Pmio::AcpiSuspend(uint8_t type) {
  switch (type)
  {
  case 0: // soft power off
    std::thread([this]() {
      manager_->machine()->Pause();
      MV_LOG("machine is power off");
    }).detach();
    break;
  case 1: // suspend request
    MV_PANIC("suspend is not supported");
    break;
  default:
    MV_ERROR("unknown acpi suspend type=%d", type);
    break;
  }
}


uint64_t Pmio::GetClock() {
  struct timeval tv;
  gettimeofday(&tv, NULL);
  uint64_t now = tv.tv_sec * 1000000000LL + (tv.tv_usec * 1000);

  auto clock = (__int128_t)now * PM_TIMER_FREQUENCY / 1000000000;
  return clock & 0xFFFFFF;
}

void Pmio::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pmio_base_) {
    uint64_t value;
    switch (offset)
    {
    case 0x00:
      value = pm1_.status;
      break;
    case 0x02:
      value = pm1_.enable;
      break;
    case 0x04:
      value = pm1_.control;
      break;
    case 0x08:
      value = GetClock();
      break;
    case 0x20 ... 0x27:
      value = gpe0_.status >> ((offset - 0x20) << 3);
      break;
    case 0x28 ... 0x2F:
      value = gpe0_.enable >> ((offset - 0x28) << 3);
      break;
    case 0x30:
      value = smi_.enable;
      break;
    case 0x34:
      value = smi_.status;
      break;
    default:
      MV_PANIC("not supported reading at ACPI offset=0x%x", offset);
      break;
    }
    memcpy(data, &value, size);
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

void Pmio::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pmio_base_) {
    uint64_t value = 0;
    memcpy(&value, data, size);

    switch (offset)
    {
    case 0x00:
      pm1_.status &= ~value;
      UpdateSystemControlIrq();
      break;
    case 0x02:
      pm1_.enable = value;
      UpdateSystemControlIrq();
      break;
    case 0x04:
      pm1_.control &= ~ACPI_BITMASK_SLEEP_ENABLE;
      if (value & ACPI_BITMASK_SLEEP_ENABLE) {
        AcpiSuspend((value >> 10) & 7);
      }
      break;
    case 0x20 ... 0x27:
      MV_ASSERT(size == 1);
      ((uint8_t*)&gpe0_.status)[offset - 0x20] &= ~data[0];
      break;
    case 0x28 ... 0x2F:
      memcpy((uint8_t*)&gpe0_.enable + (offset - 0x28), data, size);
      break;
    default:
      MV_PANIC("not supported writing at ACPI offset=0x%lx value=0x%lx", offset, value);
      break;
    }
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

/* Power down interface */
void Pmio::PowerDown() {
  Schedule([this]() {
    if (pm1_.enable & 0x100) {
      pm1_.status |= 0x100;
      UpdateSystemControlIrq();
    }
  });
}

```

`devices/acpi/pmio.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_PMIO_H
#define _MVISOR_DEVICES_PMIO_H

#include "device_interface.h"
#include "pci_device.h"

#define PMIO_SMI_EN_APMC_EN       (1 << 5)
#define PMIO_PM1_CTRL_SMI_EN      (1)


class Pmio : public PciDevice, public PowerDownInterface {
 protected:
  struct {
    uint16_t status;
    uint16_t enable;
    uint32_t control;
    uint32_t timer;
  } pm1_;

  struct {
    uint32_t status;
    uint32_t enable;
  } gpe0_;

  struct {
    uint32_t status;
    uint32_t enable;
  } smi_;

  uint32_t   pmio_base_ = 0;

  uint64_t GetClock();
  void UpdateSystemControlIrq();
  void AcpiSuspend(uint8_t type);
  void PowerDown();

  virtual void Reset();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
};

#endif // _MVISOR_DEVICES_PMIO_H

```

`devices/acpi/pmio.proto`:

```proto
syntax = "proto3";

message PmioState {
  uint32  pm1_status      = 1;
  uint32  pm1_enable      = 2;
  uint32  pm1_control     = 3;
  uint32  pm1_timer       = 4;

  uint64  gpe0_status     = 10;
  uint64  gpe0_enable     = 11;

  uint32  smi_enable      = 12;
  uint32  smi_status      = 13;
}

```

`devices/agents/meson.build`:

```build
mvisor_sources += files(
  'qemu_guest_agent.cc',
  'spice_agent.cc',
  'webdav_agent.cc'
)

```

`devices/agents/qemu_guest_agent.cc`:

```cc
/* 
 * MVisor Qemu Guest Agent
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 * Reference: https://qemu.readthedocs.io/en/latest/interop/qemu-ga-ref.html
 */

#include <string>

#include "device.h"
#include "device_manager.h"
#include "device_interface.h"
#include "utilities.h"
#include "logger.h"

class QemuGuestAgent : public Device, public SerialPortInterface {
 public:
  QemuGuestAgent() {
    set_default_parent_class("VirtioConsole");

    strcpy(port_name_, "org.qemu.guest_agent.0");
  }

  // virtual void set_ready(bool ready) {
  //   SerialPortInterface::set_ready(ready);
  //   if (ready) {
  //     std::string cmd = "{\"execute\":\"guest-info\"}\n";
  //     device_->SendMessage(this, (uint8_t*)cmd.data(), cmd.size());
  //   }
  // }

  /* This interface function is called by UI thread */
  virtual void SendMessage(uint8_t* data, size_t size) {
    Schedule([this, copied = std::string((char*)data, size)]() {
      device_->SendMessage(this, (uint8_t*)copied.data(), copied.size());
    });
  }
};

DECLARE_DEVICE(QemuGuestAgent)

```

`devices/agents/spice_agent.cc`:

```cc
/* 
 * MVisor Spice VDAgent
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 * Reference: https://www.spice-space.org/agent-protocol.html
 */

#include <cstring>
#include <chrono>
#include <cstdlib>

#include "device.h"
#include "device_manager.h"
#include "device_interface.h"
#include "spice/vd_agent.h"
#include "spice/enums.h"
#include "utilities.h"
#include "logger.h"

using namespace std::chrono;

class SpiceAgent : public Device, public SerialPortInterface,
  public DisplayResizeInterface, public PointerInputInterface,
  public ClipboardInterface
{
 private:
  int                             num_monitors_ = 1;
  /* Limit mouse event frequency */
  VDAgentMouseState               last_mouse_state_;
  /* Cache clipboard data */
  std::string                     outgoing_clipboard_;
  std::vector<ClipboardListener>  clipboard_listeners_;
  /* Buffer to build incoming message */
  std::string                     incoming_message_;
  /* Max clipboard size, default is 1MB */
  uint32_t                        max_clipboard_ = 1024 * 1024;

 public:
  SpiceAgent() {
    set_default_parent_class("VirtioConsole");

    strcpy(port_name_, "com.redhat.spice.0");
  }

  void Reset() {
    Device::Reset();
    outgoing_clipboard_.clear();
    incoming_message_.clear();
  }

  /* The message may consists of more than one chunk */
  virtual void OnMessage(uint8_t* data, size_t size) {
    auto chunk = (VDIChunkHeader*)data;
    MV_ASSERT(size >= sizeof(VDIChunkHeader));
    MV_ASSERT(size == sizeof(VDIChunkHeader) + chunk->size);

    incoming_message_.append((char*)data + sizeof(VDIChunkHeader), chunk->size);

    while (incoming_message_.size() >= sizeof(VDAgentMessage)) {
      auto message = (VDAgentMessage*)incoming_message_.data();
      auto message_length = sizeof(VDAgentMessage) + message->size;
      if (incoming_message_.size() < message_length) {
        return;
      }

      HandleAgentMessage(message);
      incoming_message_.erase(0, message_length);
    }
  }

  void HandleAgentMessage(VDAgentMessage* message) {
    switch (message->type)
    {
    case VD_AGENT_ANNOUNCE_CAPABILITIES: {
      /* This is the first message from VDAgent */
      auto announce_caps = (VDAgentAnnounceCapabilities*)message->data;
      auto caps_size = message->size - sizeof(announce_caps->request);
      auto caps = announce_caps->caps;
      if (announce_caps->request) {
        SendAgentCapabilities();
      }

      if (VD_AGENT_HAS_CAPABILITY(caps, caps_size, VD_AGENT_CAP_MAX_CLIPBOARD)) {
        if (has_key("max_clipboard")) {
          /* Read max_clipboard from configuration */
          max_clipboard_ = (uint32_t)std::get<uint64_t>(key_values_["max_clipboard"]);
        }
        SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_MAX_CLIPBOARD, &max_clipboard_, sizeof(max_clipboard_));
      }

      if (VD_AGENT_HAS_CAPABILITY(caps, caps_size, VD_AGENT_CAP_DISPLAY_CONFIG)) {
        /* ui effects & color depth */
        VDAgentDisplayConfig display_config = {
          .flags = 0,
          .depth = 0
        };
        SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_DISPLAY_CONFIG, &display_config, sizeof(display_config));
      }
      break;
    }
    case VD_AGENT_REPLY: {
      /* Handle reply of monitor config and display config */ 
      auto reply = (VDAgentReply*)message->data;
      if (reply->error != VD_AGENT_SUCCESS) {
        MV_LOG("agent reply type=%u error=%u", reply->type, reply->error);
      }
      break;
    }
    case VD_AGENT_CLIPBOARD_GRAB: {
      auto grab = (VDAgentClipboardGrab*)message->data; 
      VDAgentClipboardRequest request = {
        .type = grab->types[0]
      };
      SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_CLIPBOARD_REQUEST, &request, sizeof(request));
      break;
    }
    case VD_AGENT_CLIPBOARD: {
      auto clipboard = (VDAgentClipboard*)message->data;
      auto clipboard_data = ClipboardData {
        .type = clipboard->type,
        .data = std::string((const char*)clipboard->data, message->size - sizeof(VDAgentClipboard)),
        .file_name = ""
      };
      NotifyClipboardEvent(clipboard_data);
      break;
    }
    case VD_AGENT_CLIPBOARD_REQUEST:
      SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_CLIPBOARD, outgoing_clipboard_.data(), outgoing_clipboard_.size());
      break;
    case VD_AGENT_CLIPBOARD_RELEASE: {
      /* VM asks us to clear the clipboard */
      auto clipboard_data = ClipboardData {
        .type = VD_AGENT_CLIPBOARD_NONE,
        .data = "",
        .file_name = ""
      };
      NotifyClipboardEvent(clipboard_data);
      break;
    }
    default:
      MV_ERROR("Unhandled agent message type=0x%x size=%d", message->type, message->size);
      break;
    }
  }

  void SendMessage(int port, const std::string& message) {
    std::string buffer;
    size_t bytes_sent = 0;
    while (bytes_sent < message.size()) {
      size_t chunk_size = message.size() - bytes_sent;
      if (chunk_size > VD_AGENT_MAX_DATA_SIZE - sizeof(VDIChunkHeader)) {
        chunk_size = VD_AGENT_MAX_DATA_SIZE - sizeof(VDIChunkHeader);
      }
      buffer.resize(sizeof(VDIChunkHeader) + chunk_size);
      auto chunk_header = (VDIChunkHeader*)buffer.data();
      chunk_header->port = port;
      chunk_header->size = chunk_size;
      memcpy(buffer.data() + sizeof(VDIChunkHeader), message.data() + bytes_sent, chunk_size);
      bytes_sent += chunk_size;
      device_->SendMessage(this, (uint8_t*)buffer.data(), buffer.size());
    }
  }

  void SendAgentMessage(int port, int type, void* data, size_t length) {
    std::string outgoing_message;
    outgoing_message.resize(sizeof(VDAgentMessage) + length);
    VDAgentMessage* agent_message = (VDAgentMessage*)outgoing_message.data();
    agent_message->type = type;
    agent_message->protocol = 1;
    agent_message->opaque = 0UL;
    agent_message->size = length;
    memcpy(agent_message->data, data, length);
    SendMessage(port, outgoing_message);
  }

  void QueueEvent(uint buttons, int x, int y) {
    if (last_mouse_state_.buttons == buttons && last_mouse_state_.x == (uint)x && last_mouse_state_.y == (uint)y) {
      return;
    }

    /* This is a hack, flip the last bit to avoid guest frequency limitation */
    if (!(last_mouse_state_.buttons & (1 << 31))) {
      buttons |= 1 << 31;
    }

    last_mouse_state_.display_id = 0;
    last_mouse_state_.buttons = buttons;
    last_mouse_state_.x = x;
    last_mouse_state_.y = y;
    SendAgentMessage(VDP_SERVER_PORT, VD_AGENT_MOUSE_STATE, &last_mouse_state_, sizeof(last_mouse_state_));
  }

  virtual bool InputAcceptable() {
    return ready_;
  }

  /* This interface function is called by UI thread */
  virtual bool QueuePointerEvent(PointerEvent event) {
    if (!ready_) {
      return false;
    }

    Schedule([this, event]() {
      if (event.z > 0) {
        QueueEvent(event.buttons | (1 << SPICE_MOUSE_BUTTON_UP), event.x, event.y);
        QueueEvent(event.buttons, event.x, event.y);
      } else if (event.z < 0) {
        QueueEvent(event.buttons | (1 << SPICE_MOUSE_BUTTON_DOWN), event.x, event.y);
        QueueEvent(event.buttons, event.x, event.y);
      } else {
        QueueEvent(event.buttons, event.x, event.y);
      }
    });
    return true;
  }

  /* This interface function is called by UI thread */
  virtual bool Resize(int width, int height) {
    if (!ready_) {
      return false;
    }
    if (!manager_->LookupDeviceByClass("Qxl")) {
      return false;
    }

    Schedule([=]() {
      auto buffer = std::string(sizeof(VDAgentMonitorsConfig) + sizeof(VDAgentMonConfig), '\0');
      auto config = (VDAgentMonitorsConfig*)buffer.data();
      config->num_of_monitors = 1;
      config->monitors[0].depth = 32;
      config->monitors[0].width = width;
      config->monitors[0].height = height;
      SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_MONITORS_CONFIG, buffer.data(), buffer.size());
    });
    return true;
  }

  void SendAgentCapabilities() {
    auto buffer = std::string(sizeof(uint32_t) + VD_AGENT_CAPS_BYTES, '\0');
    auto caps = (VDAgentAnnounceCapabilities*)buffer.data();
    caps->request = false;
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_MOUSE_STATE);
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_MONITORS_CONFIG);
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_SPARSE_MONITORS_CONFIG);
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_REPLY);
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_DISPLAY_CONFIG);
    VD_AGENT_SET_CAPABILITY(caps->caps, VD_AGENT_CAP_CLIPBOARD_BY_DEMAND);
    SendAgentMessage(VDP_SERVER_PORT, VD_AGENT_ANNOUNCE_CAPABILITIES, buffer.data(), buffer.size());
  }

  void SendAgentClipboardGrab(uint type) {
    if (type == VD_AGENT_CLIPBOARD_UTF8_TEXT) {
      auto buffer = std::string(sizeof(VDAgentClipboardGrab), '\0');
      auto grab = (VDAgentClipboardGrab*)buffer.data();
      grab->types[0] = VD_AGENT_CLIPBOARD_UTF8_TEXT;
      SendAgentMessage(VDP_CLIENT_PORT, VD_AGENT_CLIPBOARD_GRAB, buffer.data(), buffer.size());
    } else {
      MV_LOG("unsupported clipboard type=0x%x", type);
    }
  }

  /* This interface function is called by UI thread */
  virtual bool ClipboardDataToGuest(uint type, const std::string& data) {
    if (!ready_) {
      return false;
    }
    outgoing_clipboard_.resize(sizeof(VDAgentClipboard) + data.size());  
    auto clipboard = (VDAgentClipboard*)outgoing_clipboard_.data();
    clipboard->type = type;
    memcpy(clipboard->data, data.data(), data.size());

    Schedule([this, type]() {
      SendAgentClipboardGrab(type);
    });
    return true;
  }

  void NotifyClipboardEvent(const ClipboardData& data) {
    for (auto& cb : clipboard_listeners_) {
      cb(data);
    }
  }

  void RegisterClipboardListener(ClipboardListener callback) {
    clipboard_listeners_.push_back(callback);
  }
};

DECLARE_DEVICE(SpiceAgent);

```

`devices/agents/webdav_agent.cc`:

```cc
/* 
 * MVisor WebDAV Agent
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 * Reference: https://qemu.readthedocs.io/en/latest/interop/qemu-ga-ref.html
 */

#include <string>

#include "device.h"
#include "device_interface.h"
#include "utilities.h"
#include "logger.h"

class WebdavAgent : public Device, public SerialPortInterface {
 private:
  std::string buffer_;

 public:
  WebdavAgent() {
    set_default_parent_class("VirtioConsole");

    strcpy(port_name_, "org.spice-space.webdav.0");
  }

  virtual void OnMessage(uint8_t* data, size_t size) {
    if (debug_) {
      MV_HEXDUMP("message", data, size);
    }
  }
};

DECLARE_DEVICE(WebdavAgent)

```

`devices/ahci/ahci_cdrom.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_cdrom.h"

class AhciCdrom: public AtaCdrom {
 public:
  AhciCdrom() {
    set_default_parent_class("Ich9Ahci");
  }
};

DECLARE_DEVICE(AhciCdrom);

```

`devices/ahci/ahci_disk.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_disk.h"

class AhciDisk: public AtaDisk {
 public:
  AhciDisk() {
    set_default_parent_class("Ich9Ahci");
  }
};

DECLARE_DEVICE(AhciDisk);

```

`devices/ahci/ahci_host.cc`:

```cc
/* 
 * MVisor - AHCI Host Controller
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ahci_host.h"

#include <sys/ioctl.h>
#include <cstring>

#include "logger.h"
#include "ata_storage.h"
#include "ata_disk.h"
#include "ahci_internal.h"
#include "ahci_host.pb.h"

/* Reference:
 * https://wiki.osdev.org/AHCI
 * https://www.intel.com/content/dam/www/public/us/en/documents/technical-specifications/serial-ata-ahci-spec-rev1_3.pdf
 */

AhciHost::AhciHost() {
  /* PCI config */
  pci_header_.class_code = 0x010601;
  pci_header_.revision_id = 2;
  pci_header_.header_type = PCI_MULTI_FUNCTION | PCI_HEADER_TYPE_NORMAL;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;
  pci_header_.irq_pin = 1;

  pci_header_.data[0x90] = 1 << 6; /* Address Map Register - AHCI mode */

  /* Add SATA capability */
  const uint8_t sata_cap[] = { 0x10, 0x00, 0x48, 0x00, 0x00, 0x00 };
  AddCapability(0x12, sata_cap, sizeof(sata_cap));
  /* Add MSI */
  AddMsiCapability();

  /* Memory bar */
  AddPciBar(5, 4096, kIoResourceTypeMmio);
}

AhciHost::~AhciHost() {
}

void AhciHost::Connect() {
  PciDevice::Connect();

  num_ports_ = 6;
  for (uint i = 0; i < num_ports_; i++) {
    ports_[i] = new AhciPort(manager_, this, i);

    /* Add storage devices */
    if (i < children_.size()) {
      auto device = dynamic_cast<AtaStorageDevice*>(children_[i]);
      ports_[i]->AttachDevice(device);
    }
  }
}

void AhciHost::Disconnect() {
  for (size_t i = 0; i < ports_.size(); i++) {
    if (ports_[i]) {
      delete ports_[i];
      ports_[i] = nullptr;
    }
  }
  PciDevice::Disconnect();
}

void AhciHost::Reset() {
  PciDevice::Reset();
  bzero(&host_control_, sizeof(host_control_));
  host_control_.global_host_control = HOST_CONTROL_AHCI_ENABLE;
  host_control_.capabilities = (num_ports_ > 0 ? num_ports_ - 1 : 0) |
    (AHCI_NUM_COMMAND_SLOTS << 8) |
    (AHCI_SUPPORTED_SPEED_GEN1 << AHCI_SUPPORTED_SPEED) |
    HOST_CAP_NCQ |
    HOST_CAP_AHCI |
    HOST_CAP_64;
  host_control_.ports_implemented = (1 << num_ports_) - 1;
  host_control_.version = AHCI_VERSION_1_0;
  
  for (uint i = 0; i < num_ports_; i++) {
    ports_[i]->Reset();
  }
}

void AhciHost::CheckIrq() {
  host_control_.irq_status = 0;
  for (uint i = 0; i < num_ports_; i++) {
    auto &pc = ports_[i]->port_control();
    if (pc.irq_status & pc.irq_mask) {
      host_control_.irq_status |= (1 << i);
    }
  }
  if (host_control_.irq_status && (host_control_.global_host_control & HOST_CONTROL_IRQ_ENABLE)) {
    if (msi_config_.enabled) {
      SignalMsi();
    } else {
      SetIrq(1);
    }
  } else {
    if (!msi_config_.enabled) {
      SetIrq(0);
    }
  }
}

void AhciHost::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(resource->type == kIoResourceTypeMmio);

  if (offset >= 0x100) {
    int port = (offset - 0x100) >> 7;
    if (ports_[port]) {
      ports_[port]->Read(offset & 0x7F, data, size);
    }
  } else {
    memcpy(data, (uint8_t*)&host_control_ + offset, size);
  }
}

void AhciHost::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(size == 4 && resource->type == kIoResourceTypeMmio);
  uint32_t value = *(uint32_t*)data;
  
  if (offset >= 0x100) {
    int port = (offset - 0x100) >> 7;
    if (ports_[port]) {
      ports_[port]->Write(offset & 0x7F, value);
    }
  } else {
    switch (offset / 4)
    {
    case kAhciHostRegCapabilities:
    case kAhciHostRegPortsImplemented:
      /* Why Linux writes these registers ??? */
      break;
    case kAhciHostRegControl:
      if (value & HOST_CONTROL_RESET) {
        Reset();
      } else {
        host_control_.global_host_control = (value & 3) | HOST_CONTROL_AHCI_ENABLE;
        // Maybe irq is enabled now, so call check
        CheckIrq();
      }
      break;
    case kAhciHostRegIrqStatus:
      host_control_.irq_status &= ~value;
      CheckIrq();
      break;
    default:
      MV_ERROR("%s unhandled write base=0x%lx offset=0x%lx size=%d data=0x%lx",
        name_, resource->base, offset, size, value);
    }
  }
}

bool AhciHost::SaveState(MigrationWriter* writer) {
  AhciHostState state;
  auto control = state.mutable_control();
  control->set_capabilities(host_control_.capabilities);
  control->set_global_host_control(host_control_.global_host_control);
  control->set_irq_status(host_control_.irq_status);
  control->set_ports_implemented(host_control_.ports_implemented);
  control->set_version(host_control_.version);

  for (uint i = 0; i < num_ports_; i++) {
    auto port_state = state.add_ports();
    ports_[i]->SaveState(port_state);
  }
  writer->WriteProtobuf("AHCI_HOST", state);
  return PciDevice::SaveState(writer);
}

bool AhciHost::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }
  AhciHostState state;
  if (!reader->ReadProtobuf("AHCI_HOST", state)) {
    return false;
  }
  auto &control = state.control();
  host_control_.capabilities = control.capabilities();
  host_control_.global_host_control = control.global_host_control();
  host_control_.irq_status = control.irq_status();
  host_control_.ports_implemented = control.ports_implemented();
  host_control_.version = control.version();

  for (uint i = 0; i < num_ports_; i++) {
    auto &port_state = state.ports(i);
    ports_[i]->LoadState(&port_state);
  }
  return true;
}

```

`devices/ahci/ahci_host.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AHCI_H
#define _MVISOR_DEVICES_AHCI_H

#include "pci_device.h"
#include "ahci_port.h"
#include <array>

struct AHCIHostControlRegs {
  uint32_t    capabilities;
  uint32_t    global_host_control;
  uint32_t    irq_status;
  uint32_t    ports_implemented;
  uint32_t    version;
  uint32_t    command_completion_coalescing_control;
  uint32_t    command_completion_coalescing_ports;
  uint32_t    enclosure_management_location;
  uint32_t    enclosure_management_control;
  uint32_t    extended_capabilities;
  uint32_t    bohc; // BIOS/OS handoff control and status

  // 0x2C - 0x9F, Reserved
  uint8_t     reserved[0xA0-0x2C];
 
  // 0xA0 - 0xFF, Vendor specific registers
  uint8_t     vendor[0x100-0xA0];
} __attribute__((packed));


class AhciHost : public PciDevice {
 public:
  AhciHost();
  virtual ~AhciHost();

  virtual void Connect();
  virtual void Disconnect();
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Reset();
  void CheckIrq();

  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);

 private:
  uint num_ports_;
  AHCIHostControlRegs host_control_;
  std::array<AhciPort*, 32> ports_ = { 0 };
};

#endif // _MVISOR_DEVICES_AHCI_H

```

`devices/ahci/ahci_host.proto`:

```proto
syntax = "proto3";

message AhciHostState {
  message ControlRegisters {
    uint32  capabilities          = 1;
    uint32  global_host_control   = 2;
    uint32  irq_status            = 3;
    uint32  ports_implemented     = 4;
    uint32  version               = 5;
  }

  message PortRegisters {
    uint32  command_list_base0= 1;
    uint32  command_list_base1= 2;
    uint32  fis_base0         = 3;
    uint32  fis_base1         = 4;
    uint32  irq_status        = 5;
    uint32  irq_mask          = 6;
    uint32  command           = 7;
    uint32  task_flie_data    = 8;
    uint32  signature         = 9;
    uint32  sata_status       = 10;
    uint32  sata_control      = 11;
    uint32  sata_error        = 12;
    uint32  sata_active       = 13;
  }

  message PortState {
    uint32            index          = 1;
    int32             busy_slot      = 2;
    bool              init_d2h_sent  = 3;
    PortRegisters     registers      = 4;
  }

  ControlRegisters    control     = 1;
  repeated PortState  ports       = 2;
}

```

`devices/ahci/ahci_internal.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AHCI_INTERNAL_H
#define _MVISOR_DEVICES_AHCI_INTERNAL_H

#include <stdint.h>

#define AHCI_MEM_BAR_SIZE         0x1000
#define AHCI_MAX_PORTS            32
#define AHCI_MAX_SG               168 /* hardware max is 64K */
#define AHCI_DMA_BOUNDARY         0xffffffff
#define AHCI_USE_CLUSTERING       0
#define AHCI_MAX_CMDS             32
#define AHCI_CMD_SZ               32
#define AHCI_CMD_SLOT_SZ          (AHCI_MAX_CMDS * AHCI_CMD_SZ)
#define AHCI_RX_FIS_SZ            256
#define AHCI_CMD_TBL_CDB          0x40
#define AHCI_CMD_TBL_HDR_SZ       0x80
#define AHCI_CMD_TBL_SZ           (AHCI_CMD_TBL_HDR_SZ + (AHCI_MAX_SG * 16))
#define AHCI_CMD_TBL_AR_SZ        (AHCI_CMD_TBL_SZ * AHCI_MAX_CMDS)
#define AHCI_PORT_PRIV_DMA_SZ     (AHCI_CMD_SLOT_SZ + AHCI_CMD_TBL_AR_SZ + \
                                   AHCI_RX_FIS_SZ)

#define AHCI_IRQ_ON_SG            (1U << 31)
#define AHCI_CMD_ATAPI            (1 << 5)
#define AHCI_CMD_WRITE            (1 << 6)
#define AHCI_CMD_PREFETCH         (1 << 7)
#define AHCI_CMD_RESET            (1 << 8)
#define AHCI_CMD_CLR_BUSY         (1 << 10)

#define RX_FIS_DMA_SETUP          0x00
#define RX_FIS_PIO_SETUP          0x20
#define RX_FIS_REG_D2H            0x40 /* offset of D2H Register FIS data */
#define RX_FIS_SET_DEVICE_BITS    0x58 /* offset of SDB FIS data */
#define RX_FIS_UNKNOWN            0x60 /* offset of Unknown FIS data */

/* global controller registers */
enum AhciHostReg {
  kAhciHostRegCapabilities = 0,  /* CAP: host capabilities */
  kAhciHostRegControl      = 1,  /* GHC: global host control */
  kAhciHostRegIrqStatus    = 2,  /* IS: interrupt status */
  kAhciHostRegPortsImplemented = 3,  /* PI: bitmap of implemented ports */
  kAhciHostRegVersion      = 4,  /* VS: AHCI spec. version compliancy */
  kAhciHostRegCccControl   = 5,  /* CCC_CTL: CCC Control */
  kAhciHostRegCccPorts     = 6,  /* CCC_PORTS: CCC Ports */
  kAhciHostRegEmLocation   = 7,  /* EM_LOC: Enclosure Mgmt Location */
  kAhciHostRegEmControl    = 8,  /* EM_CTL: Enclosure Mgmt Control */
  kAhciHostRegCapabilities2= 9,  /* CAP2: host capabilities, extended */
  kAhciHostRegBoch         = 10, /* BOHC: firmare/os handoff ctrl & status */
  kAhciHostRegCount     = 11
};

/* HOST_CONTROL bits */
#define HOST_CONTROL_RESET                (1 << 0)   /* reset controller; self-clear */
#define HOST_CONTROL_IRQ_ENABLE           (1 << 1)   /* global IRQ enable */
#define HOST_CONTROL_AHCI_ENABLE          (1U << 31) /* AHCI enabled */

/* HOST_CAP bits */
#define HOST_CAP_SLUMBER_CAPABLE         (1 << 14) /* Slumber capable */
#define HOST_CAP_AHCI                    (1 << 18) /* AHCI only */
#define HOST_CAP_COMMAND_LIST_OVERRIDE   (1 << 24) /* Command List Override support */
#define HOST_CAP_STAGGERED_SPIN_UP       (1 << 27) /* Staggered Spin-up */
#define HOST_CAP_NCQ                     (1 << 30) /* Native Command Queueing */
#define HOST_CAP_64                      (1U << 31) /* PCI DAC (64-bit DMA) support */

/* registers for each SATA port */
enum AhciPortReg {
  kAhciPortRegCommandListBase0 = 0, /* PxCLB: command list DMA addr */
  kAhciPortRegCommandListBase1 = 1, /* PxCLBU: command list DMA addr hi */
  kAhciPortRegReceivedFisBase0 = 2, /* PxFB: FIS rx buf addr */
  kAhciPortRegReceivedFisBase1 = 3, /* PxFBU: FIX rx buf addr hi */
  kAhciPortRegIrqStatus        = 4, /* PxIS: interrupt status */
  kAhciPortRegIrqMask          = 5, /* PxIE: interrupt enable/disable mask */
  kAhciPortRegCommand          = 6, /* PxCMD: port command */
  /* RESERVED */
  kAhciPortRegTaskFileData     = 8, /* PxTFD: taskfile data */
  kAhciPortRegSignature        = 9, /* PxSIG: device TF signature */
  kAhciPortRegSataStatus       = 10, /* PxSSTS: SATA phy register: SStatus */
  kAhciPortRegSataControl      = 11, /* PxSCTL: SATA phy register: SControl */
  kAhciPortRegSataError        = 12, /* PxSERR: SATA phy register: SError */
  kAhciPortRegSataActive       = 13, /* PxSACT: SATA phy register: SActive */
  kAhciPortRegCommandIssue     = 14, /* PxCI: command issue */
  kAhciPortRegSataNotification = 15, /* PxSNTF: SATA phy register: SNotification */
  kAhciPortRegFisControl       = 16, /* PxFBS: Port multiplier switching ctl */
  kAhciPortRegDeviceSleepControl = 17, /* PxDEVSLP: device sleep control */
  /* RESERVED */
  kAhciPortRegVendor1    = 28, /* PxVS: Vendor Specific */
  kAhciPortRegVendor2    = 29,
  kAhciPortRegVendor3    = 30,
  kAhciPortRegVendor4    = 31,
  kAhciPortRegCount      = 32
};

/* Port interrupt bit descriptors */
enum AhciPortIrq {
  kAhciPortIrqBitDeviceToHostFis = 0,
  kAhciPortIrqBitPioSetupFis     = 1,
  kAhciPortIrqBitDmaSetupFis     = 2,
  kAhciPortIrqBitSetDeviceBitsFis = 3,
  kAhciPortIrqBitUnknownFis      = 4,
  kAhciPortIrqBitDescriptorProcessed = 5,
  kAhciPortIrqBitPortConnectChanged = 6,
  kAhciPortIrqBitDeviceMechanicalPresense = 7,
  /* RESERVED */
  kAhciPortIrqBitPhyscalReadyChange = 22,
  kAhciPortIrqBitIncorrectPortMultiplier = 23,
  kAhciPortIrqBitOverflow  = 24,
  /* RESERVED */
  kAhciPortIrqBitInterfaceNonFatalError = 26,
  kAhciPortIrqBitInterfaceFatalError = 27,
  kAhciPortIrqBitHostBusDataError = 28,
  kAhciPortIrqBitHostBusFatalError = 29,
  kAhciPortIrqBitTaskFileError = 30,
  kAhciPortIrqBitColdPortDetect = 31,
  kAhciPortIrqCount = 32
};

/* PORT_CMD bits */
#define PORT_CMD_ATAPI            (1 << 24) /* Device is ATAPI */
#define PORT_CMD_LIST_ON          (1 << 15) /* cmd list DMA engine running */
#define PORT_CMD_FIS_ON           (1 << 14) /* FIS DMA engine running */
#define PORT_CMD_FIS_RX           (1 << 4)  /* Enable FIS receive DMA engine */
#define PORT_CMD_CLO              (1 << 3)  /* Command list override */
#define PORT_CMD_POWER_ON         (1 << 2)  /* Power up device */
#define PORT_CMD_SPIN_UP          (1 << 1)  /* Spin up device */
#define PORT_CMD_START            (1 << 0)  /* Enable port DMA engine */

#define PORT_CMD_ICC_MASK         (0xfU << 28) /* i/f ICC state mask */
#define PORT_CMD_ICC_ACTIVE       (0x1 << 28)  /* Put i/f in active state */
#define PORT_CMD_ICC_PARTIAL      (0x2 << 28)  /* Put i/f in partial state */
#define PORT_CMD_ICC_SLUMBER      (0x6 << 28)  /* Put i/f in slumber state */

#define PORT_CMD_RO_MASK          0x007dffe0   /* Which CMD bits are read only? */

/* ap->flags bits */
#define AHCI_FLAG_NO_NCQ                  (1 << 24)
#define AHCI_FLAG_IGNORE_IRQ_IF_ERR       (1 << 25) /* ignore IRQ_IF_ERR */
#define AHCI_FLAG_HONOR_PORTS_IMPL        (1 << 26) /* honor PORTS_IMPL */
#define AHCI_FLAG_IGNORE_SERR_INTERNAL    (1 << 27) /* ignore SERR_INTERNAL */
#define AHCI_FLAG_32BIT_ONLY              (1 << 28) /* force 32bit */

#define AHCI_SCR_SCTL_DET                 0xf

#define AHCI_CMD_HDR_CMD_FIS_LEN           0x1f
#define AHCI_CMD_HDR_PRDT_LEN              16

#define AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR 0x2c

#define AHCI_NUM_COMMAND_SLOTS             31
#define AHCI_SUPPORTED_SPEED               20
#define AHCI_SUPPORTED_SPEED_GEN1          1
#define AHCI_VERSION_1_0                   0x10000

#define AHCI_PROGMODE_MAJOR_REV_1          1

#define AHCI_PRDT_SIZE_MASK                0x3fffff

#define NCQ_FIS_FUA_MASK                   0x80
#define NCQ_FIS_RARC_MASK                  0x01

#define ATA_CAP_SIZE           0x8
#define ATA_CAP_REV            0x2
#define ATA_CAP_BAR            0x4

#define IDE_FEATURE_DMA                    1
#define ATA_SOFT_RESET                    (1 << 2)  /* software reset */

#define ATA_SCR_SSTATUS_DET_NODEV        0x0
#define ATA_SCR_SSTATUS_DET_DEV_PRESENT_PHY_UP 0x3

#define ATA_SCR_SSTATUS_SPD_NODEV        0x00
#define ATA_SCR_SSTATUS_SPD_GEN1         0x10

#define ATA_SCR_SSTATUS_IPM_NODEV        0x000
#define ATA_SCR_SSTATUS_IPM_ACTIVE       0X100

#define ATA_SIGNATURE_CDROM               0xeb140101
#define ATA_SIGNATURE_DISK                0x00000101


struct AhciPrdtEntry {
  uint64_t    address;
  uint32_t    reserved0;
  uint32_t    size : 22;    // 4MB max
  uint32_t    reserved1 : 9;
  uint32_t    interrupt : 1; // interrupt on completion
} __attribute__((packed));

struct AhciCommandTable {
  // 0x00
  uint8_t       command_fis[64];
  // 0x40
  uint8_t       atapi_command[16];
  // 0x50
  uint8_t       reserved[48];
  // 0x80
  AhciPrdtEntry prdt_entries[1];
} __attribute__((packed));


enum AhciFisType
{
  kAhciFisTypeRegH2D = 0x27, // Register FIS - host to device
  kAhciFisTypeRegD2H = 0x34, // Register FIS - device to host
  kAhciFisTypeDmaActivate = 0x39, // DMA activate FIS - device to host
  kAhciFisTypeDmaSetup = 0x41, // DMA setup FIS - bidirectional
  kAhciFisTypeData = 0x46, // Data FIS - bidirectional
  kAhciFisTypeSelfTest = 0x58, // Built-in Self Test activate FIS - bidirectional
  kAhciFisTypePioSetup = 0x5F, // PIO setup FIS - device to host
  kAhciFisTypeDeviceBits = 0xA1, // Set device bits FIS - device to host
};

struct AhciFisRegH2D
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypeRegH2D
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 3;        // Reserved
  uint8_t  is_command : 1;       // 1: Command, 0: Control
 
  uint8_t  command;              // Command register
  uint8_t  feature0;             // Feature register, 7:0
 
  // DWORD 1
  uint8_t  lba0;                 // LBA low register, 7:0
  uint8_t  lba1;                 // LBA mid register, 15:8
  uint8_t  lba2;                 // LBA high register, 23:16
  uint8_t  device;               // Device register
 
  // DWORD 2
  uint8_t  lba3;                 // LBA register, 31:24
  uint8_t  lba4;                 // LBA register, 39:32
  uint8_t  lba5;                 // LBA register, 47:40
  uint8_t  feature1;             // Feature register, 15:8
 
  // DWORD 3
  uint8_t  count0;               // Count register, 7:0
  uint8_t  count1;               // Count register, 15:8
  uint8_t  icc;                  // Isochronous command completion
  uint8_t  control;              // Control register
 
  // DWORD 4
  uint8_t  reserved1[4];         // Reserved
} __attribute__((packed));

struct AhciFisRegD2H
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypeRegD2H
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 2;        // Reserved
  uint8_t  interrupt : 1;        // Interrupt bit
  uint8_t  reserved1 : 1;        // Reserved
 
  uint8_t  status;               // Status register
  uint8_t  error;                // Error register
 
  // DWORD 1
  uint8_t  lba0;                 // LBA low register, 7:0
  uint8_t  lba1;                 // LBA mid register, 15:8
  uint8_t  lba2;                 // LBA high register, 23:16
  uint8_t  device;               // Device register
 
  // DWORD 2
  uint8_t  lba3;                 // LBA register, 31:24
  uint8_t  lba4;                 // LBA register, 39:32
  uint8_t  lba5;                 // LBA register, 47:40
  uint8_t  reserved2;            // Reserved
 
  // DWORD 3
  uint8_t  count0;               // Count register, 7:0
  uint8_t  count1;               // Count register, 15:8
  uint8_t  reserved3[2];         // Reserved
 
  // DWORD 4
  uint8_t  reserved4[4];         // Reserved
} __attribute__((packed));

struct AhciFisData
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypeData
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 4;        // Reserved
 
  uint8_t  reserved1[2];         // Reserved
 
  // DWORD 1 ~ N
  uint32_t data[1];              // Payload
} __attribute__((packed));

enum AhciFisPioDireciton {
  kAhciFisPioDirectionToDevice = 0,
  kAhciFisPioDirectionToHost   = 1
};

struct AhciFisPioSetup
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypePioSetup
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 1;        // Reserved
  uint8_t  direction : 1;        // Data transfer direction, 1 - device to host
  uint8_t  interrupt : 1;        // Interrupt bit
  uint8_t  reserved1 : 1;        // Reserved
 
  uint8_t  status;               // Status register
  uint8_t  error;                // Error register
 
  // DWORD 1
  uint8_t  lba0;                 // LBA low register, 7:0
  uint8_t  lba1;                 // LBA mid register, 15:8
  uint8_t  lba2;                 // LBA high register, 23:16
  uint8_t  device;               // Device register
 
  // DWORD 2
  uint8_t  lba3;                 // LBA register, 31:24
  uint8_t  lba4;                 // LBA register, 39:32
  uint8_t  lba5;                 // LBA register, 47:40
  uint8_t  reserved2;            // Reserved
 
  // DWORD 3
  uint8_t  count0;               // Count register, 7:0
  uint8_t  count1;               // Count register, 15:8
  uint8_t  reserved3;            // Reserved
  uint8_t  e_status;             // New value of status register
 
  // DWORD 4
  uint16_t transfer_count;       // Transfer count
  uint8_t  reserved4[2];         // Reserved
} __attribute__((packed));

struct AhciFisDmaSetup
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypeDmaSetup
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 1;        // Reserved
  uint8_t  direction : 1;        // Data transfer direction, 1 - device to host
  uint8_t  interrupt : 1;        // Interrupt bit
  uint8_t  auto_activate : 1;    // Auto-activate. Specifies if DMA Activate FIS is needed
 
  uint8_t  reserved1[2];         // Reserved
 
  // DWORD 1 & 2
  uint64_t dma_buffer_id;        // DMA Buffer Identifier. Used to Identify DMA buffer in host memory.
                                 // SATA Spec says host specific and not in Spec. Trying AHCI spec might work.
 
  // DWORD 3
  uint32_t reserved2;            // More reserved

  // DWORD 4
  uint32_t dma_buffer_offset;    // Byte offset into buffer. First 2 bits must be 0

  // DWORD 5
  uint32_t transfer_count;       // Number of bytes to transfer. Bit 0 must be 0

  // DWORD 6
  uint32_t reserved3;            // Reserved
} __attribute__((packed));

struct AhciFisSetDeviceBits {
  uint8_t type;
  uint8_t flags;
  uint8_t status;
  uint8_t error;
  uint32_t payload;
} __attribute__((packed));

/**
 * NCQFrame is the same as a Register H2D FIS (described in SATA 3.2),
 * but some fields have been re-mapped and re-purposed, as seen in
 * SATA 3.2 section 13.6.4.1 ("READ FPDMA QUEUED")
 *
 * cmd_fis[3], feature 7:0, becomes sector count 7:0.
 * cmd_fis[7], device 7:0, uses bit 7 as the Force Unit Access bit.
 * cmd_fis[11], feature 15:8, becomes sector count 15:8.
 * cmd_fis[12], count 7:0, becomes the NCQ TAG (7:3) and RARC bit (0)
 * cmd_fis[13], count 15:8, becomes the priority value (7:6)
 * bytes 16-19 become an le32 "auxiliary" field.
 */
struct AhciNcqFrame
{
  // DWORD 0
  uint8_t  fis_type;             // kAhciFisTypeRegH2D
 
  uint8_t  port_multiplier : 4;  // Port multiplier
  uint8_t  reserved0 : 3;        // Reserved
  uint8_t  is_command : 1;       // 1: Command, 0: Control
 
  uint8_t  command;              // Command register
  uint8_t  count0;               // Count register, 7:0
 
  // DWORD 1
  uint8_t  lba0;                 // LBA low register, 7:0
  uint8_t  lba1;                 // LBA mid register, 15:8
  uint8_t  lba2;                 // LBA high register, 23:16
  uint8_t  device;               // Device 7:0, uses bit 7 as the Force Unit Access bit.
 
  // DWORD 2
  uint8_t  lba3;                 // LBA register, 31:24
  uint8_t  lba4;                 // LBA register, 39:32
  uint8_t  lba5;                 // LBA register, 47:40
  uint8_t  count1;               // Count register, 15:8
 
  // DWORD 3
  uint8_t  tag;                  // NCQ tag
  uint8_t  priority;             // NCQ priority 7:6
  uint8_t  icc;                  // Isochronous command completion
  uint8_t  control;              // Control register
 
  // DWORD 4
  uint32_t auxiliary;            //
} __attribute__((packed));

struct AhciRxFis
{
  // 0x00
  AhciFisDmaSetup       dma_fis;
  uint8_t               pad0[4];
  // 0x20
  AhciFisPioSetup       pio_fis;
  uint8_t               pad1[12];
  // 0x40
  AhciFisRegD2H         d2h_fis;
  uint8_t               pad2[4];
  // 0x58
  AhciFisSetDeviceBits  sdb_fis;
  // 0x60
  uint8_t               unknown_fis[64];
  // 0xA0
  uint8_t               reserved[0x100 - 0xA0];
} __attribute__((packed));

#endif

```

`devices/ahci/ahci_port.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ahci_port.h"

#include <cstring>

#include "logger.h"
#include "device_manager.h"
#include "ahci_host.h"
#include "ahci_internal.h"
#include "ata_storage.h"


AhciPort::AhciPort(DeviceManager* manager, AhciHost* host, int index)
  : manager_(manager), host_(host), port_index_(index)
{
  bzero(&port_control_, sizeof(port_control_));
}

AhciPort::~AhciPort() {
}

void AhciPort::AttachDevice(AtaStorageDevice* device) {
  drive_ = device;
  drive_->set_port(this);
}

void AhciPort::Reset() {
  port_control_.command_issue = 0;
  port_control_.irq_status = 0;
  port_control_.irq_mask = 0;
  port_control_.sata_control = 0;
  port_control_.command = PORT_CMD_SPIN_UP | PORT_CMD_POWER_ON;
  SoftReset();
}

void AhciPort::SoftReset() {
  port_control_.sata_status = 0;
  port_control_.sata_error = 0;
  port_control_.sata_active = 0;
  port_control_.task_flie_data = 0x7F;
  port_control_.signature = 0xFFFFFFFF;
  init_d2h_sent_ = false;
  busy_slot_ = -1;

  bzero(&task_file_, sizeof(task_file_));

  if (!drive_) {
    return;
  }
  if (host_->debug())
    MV_LOG("%s port reseted", drive_->name());

  drive_->Reset();
  drive_->SetSignature(&task_file_);
}

void AhciPort::UpdateInitD2H() {
  if (init_d2h_sent_) {
    return;
  }
  init_d2h_sent_ = true;

  UpdateFisRegisterD2H();

  if (!drive_) {
    return;
  }

  switch (drive_->type())
  {
  case kAtaStorageTypeCdrom:
    port_control_.signature = ATA_SIGNATURE_CDROM;
    break;
  case kAtaStorageTypeDisk:
    port_control_.signature = ATA_SIGNATURE_DISK;
    break;
  }
}

void AhciPort::SetNcqError(int slot) {
  task_file_.error = ATA_CB_ER_ABRT;
  task_file_.status = ATA_CB_STAT_RDY | ATA_CB_STAT_ERR;
  port_control_.sata_error |= (1 << slot);
}

void AhciPort::HandleNcqCommand(int slot, void* fis) {
  auto frame = (AhciNcqFrame*)fis;
  MV_ASSERT((frame->tag >> 3) == slot);

  size_t lba =  ((size_t)frame->lba5 << 40) |
                ((size_t)frame->lba4 << 32) |
                ((size_t)frame->lba3 << 24) |
                ((size_t)frame->lba2 << 16) |
                ((size_t)frame->lba1 << 8)  |
                ((size_t)frame->lba0);
  size_t sector_count = (size_t(frame->count1) << 8) | frame->count0;
  if (!sector_count) {
    sector_count = 0x10000;
  }

  auto image = drive_->image();
  auto sector_size = drive_->geometry().sector_size;

  ImageIoRequest request = {
    .position = sector_size * lba,
    .length = sector_size * sector_count,
    .vector = std::move(current_dma_vector_)
  };

  switch (frame->command) {
    case 0x60: // READ_FPDMA_QUEUED
      request.type = kImageIoRead;
      break;
    case 0x61: // WRITE_FPDMA_QUEUED
      request.type = kImageIoWrite;
      break;
    default:
      SetNcqError(slot);
      return;
  }

  if (host_->debug()) {
    MV_LOG("NCQ slot %d %s lba=%lu count=%lu", slot, 
      request.type == kImageIoRead ? "read" : "write", lba, sector_count);
  }

  image->QueueIoRequest(request, [this, slot](auto ret) {
    if (ret < 0) {
      SetNcqError(slot);
    } else {
      task_file_.status = ATA_CB_STAT_RDY | ATA_CB_STAT_SKC;
      task_file_.error = 0;
    }
    UpdateFisSetDeviceBits(slot);
  });
}

/* return true if we have done handling the command */
bool AhciPort::HandleCommand(int slot) {
  MV_ASSERT(command_list_);
  MV_ASSERT(drive_);

  current_command_ = &((AhciCommandHeader*)command_list_)[slot];
  auto command_table = (AhciCommandTable*)manager_->TranslateGuestMemory(current_command_->command_table_base);

  auto fis = (AhciFisRegH2D*)command_table->command_fis;
  if (fis->fis_type != kAhciFisTypeRegH2D) {
    MV_ERROR("unknown fis type 0x%x", fis->fis_type);
    return true;
  }

  if (!fis->is_command) {
    MV_ERROR("not a command fis, control=%x", fis->control);
    return true;
  }

  if (fis->command >= 0x60 && fis->command <= 0x65) {
    ParseDmaVector(command_table->prdt_entries, current_command_->prdt_length, fis->command == 0x60);
    HandleNcqCommand(slot, fis);
    return true;
  }

  /* Copy IDE command parameters */
  auto io = drive_->io();
  task_file_.command = fis->command;
  task_file_.feature0 = fis->feature0;
  task_file_.lba0 = fis->lba0;
  task_file_.lba1 = fis->lba1;
  task_file_.lba2 = fis->lba2;
  task_file_.device = fis->device;
  task_file_.lba3 = fis->lba3;
  task_file_.lba4 = fis->lba4;
  task_file_.lba5 = fis->lba5;
  task_file_.control = fis->feature1;
  task_file_.count0 = fis->count0;
  task_file_.count1 = fis->count1;

  /* Copy the ACMD field (ATAPI packet, if any) from the AHCI command
   * table to ide_state->io_buffer */
  if (current_command_->is_atapi) {
    memcpy(io->atapi_command, command_table->atapi_command, sizeof(io->atapi_command));
    io->atapi_set = true;
  }

  bool is_write = fis->command == 0xC8 || io->atapi_command[0] == 0x28;
  ParseDmaVector(command_table->prdt_entries, current_command_->prdt_length, is_write);

  /* We have only one DMA engine each drive.
   * when async IO is running by IO thread, we should wait for the slot */
  MV_ASSERT(busy_slot_ == -1);

  io->vector = std::move(current_dma_vector_);
  if (io->vector.empty()) {
    io->buffer = nullptr;
    io->buffer_size = 0;
  } else {
    io->buffer = (uint8_t*)io->vector.front().iov_base;
    io->buffer_size = io->vector.front().iov_len;
  }

  bool should_wait = drive_->StartCommand(&task_file_);
  if (should_wait) { // BUSY
    busy_slot_ = slot;
    return false;
  }
  return true;
}

/* current_dma_vector_ contains a shadow copy to the PRDT (physical region descriptor table)
 * If prdt_length is zero, the function only clears the vector.
 * is_write=true means this dma vector is used for writing into.
 */
void AhciPort::ParseDmaVector(AhciPrdtEntry* entries, uint16_t prdt_length, bool is_write) {
  current_dma_vector_.clear();

  for (int prdt_index = 0; prdt_index < prdt_length; prdt_index++) {
    void* host = manager_->TranslateGuestMemory(entries[prdt_index].address);
    size_t length = entries[prdt_index].size + 1;
    if (is_write) {
      manager_->AddDirtyMemory(entries[prdt_index].address, length);
    }
    current_dma_vector_.emplace_back(iovec { .iov_base = host, .iov_len = length });
  }
}

void AhciPort::OnDmaPrepare() {
  auto io = drive_->io();
  /* We have already built io->dma_vector before StartCommand() */
  auto cb = std::move(io->dma_callback);
  cb();
}

void AhciPort::OnDmaTransfer() {
  auto io = drive_->io();

  current_command_->bytes_transferred += io->transfer_bytes;
  drive_->StopTransfer();
}

void AhciPort::OnPioTransfer() {
  auto io = drive_->io();

  if (io->transfer_bytes > 0) {
    UpdateFisSetupPio();
  }
  current_command_->bytes_transferred += io->transfer_bytes;
  drive_->StopTransfer();
}

void AhciPort::OnCommandDone() {
  UpdateFisRegisterD2H();

  if (busy_slot_ != -1) {
    port_control_.command_issue &= ~(1U << busy_slot_);
    busy_slot_ = -1;
    current_command_ = nullptr;
    /* Check next command */
    CheckCommand();
  }
}

void AhciPort::CheckCommand() {
  if (busy_slot_ != -1) {
    return;
  }
  if ((port_control_.command & PORT_CMD_START) && port_control_.command_issue) {
    for (int slot = 0; (slot < 32) && port_control_.command_issue; slot++) {
      if (port_control_.command_issue & (1U << slot)) {
        if (HandleCommand(slot)) {
          port_control_.command_issue &= ~(1U << slot);
        } else {
          /* Stop executing other commands if an async command is running */
          return;
        }
      }
    }
  }
}

void AhciPort::Read(uint64_t offset, uint8_t* data, uint32_t size) {
  AhciPortReg reg_index = (AhciPortReg)(offset / sizeof(uint32_t));
  MV_ASSERT(reg_index < 32);
  if (reg_index == kAhciPortRegSataStatus) {
    if (drive_ && drive_->IsAvailable()) {
      port_control_.sata_status = ATA_SCR_SSTATUS_DET_DEV_PRESENT_PHY_UP |  // Physical communication established
        ATA_SCR_SSTATUS_SPD_GEN1 |                      // Speed
        ATA_SCR_SSTATUS_IPM_ACTIVE;                     // Full power
    } else {
      port_control_.sata_status = ATA_SCR_SSTATUS_DET_NODEV;  // No device
    }
  }
  memcpy(data, (uint8_t*)&port_control_ + offset, size);
  if (host_->debug()) {
    MV_LOG("%d:%s read port index=%d ret=0x%x", port_index_, drive_ ? drive_->name() : "", reg_index, *data);
  }
}

void AhciPort::CheckEngines() {
  bool cmd_start = port_control_.command & PORT_CMD_START;
  bool cmd_on    = port_control_.command & PORT_CMD_LIST_ON;
  bool fis_start = port_control_.command & PORT_CMD_FIS_RX;
  bool fis_on    = port_control_.command & PORT_CMD_FIS_ON;

  MV_ASSERT(manager_);
  if (cmd_start && !cmd_on) {
    command_list_ = (uint8_t*)manager_->TranslateGuestMemory(
      ((uint64_t)port_control_.command_list_base1 << 32) | port_control_.command_list_base0);
    if (command_list_ != nullptr) {
      port_control_.command |= PORT_CMD_LIST_ON;
    } else {
      port_control_.command &= ~(PORT_CMD_START | PORT_CMD_LIST_ON);
      return;
    }
  } else if (!cmd_start && cmd_on) {
    port_control_.command &= ~PORT_CMD_LIST_ON;
    command_list_ = nullptr;
  }

  if (fis_start && !fis_on) {
    rx_fis_ = (AhciRxFis*)manager_->TranslateGuestMemory
      (((uint64_t)port_control_.fis_base1 << 32) | port_control_.fis_base0);
    if (rx_fis_ != nullptr) {
      port_control_.command |= PORT_CMD_FIS_ON;
    } else {
      port_control_.command &= ~(PORT_CMD_FIS_RX | PORT_CMD_FIS_ON);
      return;
    }
  } else if (!fis_start && fis_on) {
    port_control_.command &= ~PORT_CMD_FIS_ON;
    rx_fis_ = nullptr;
  }
}

void AhciPort::Write(uint64_t offset, uint32_t value) {
  AhciPortReg reg_index = (AhciPortReg)(offset / sizeof(uint32_t));
  MV_ASSERT(reg_index < 32);
  if (host_->debug()) {
    MV_LOG("%d:%s write port index=%d value=0x%x", port_index_, drive_ ? drive_->name() : "", reg_index, value);
  }

  switch (reg_index)
  {
  case kAhciPortRegCommandListBase0:
    port_control_.command_list_base0 = value;
    break;
  case kAhciPortRegCommandListBase1:
    port_control_.command_list_base1 = value;
    break;
  case kAhciPortRegReceivedFisBase0:
    port_control_.fis_base0 = value;
    break;
  case kAhciPortRegReceivedFisBase1:
    port_control_.fis_base1 = value;
    break;
  case kAhciPortRegIrqStatus:
    port_control_.irq_status &= ~value;
    host_->CheckIrq();
    break;
  case kAhciPortRegIrqMask:
    port_control_.irq_mask = value & 0xFDC000FF;
    host_->CheckIrq();
    break;
  case kAhciPortRegCommand:
    /* Block any Read-only fields from being set;
     * including LIST_ON and FIS_ON.
     * The spec requires to set ICC bits to zero after the ICC change
     * is done. We don't support ICC state changes, therefore always
     * force the ICC bits to zero.
     */
    port_control_.command = (port_control_.command & PORT_CMD_RO_MASK) |
      (value & ~(PORT_CMD_RO_MASK | PORT_CMD_ICC_MASK));

    /* Check FIS RX and CLB engines */
    CheckEngines();

    /* XXX usually the FIS would be pending on the bus here and
     * issuing deferred until the OS enables FIS receival.
     * Instead, we only submit it once - which works in most
     * cases, but is a hack. */
    if (port_control_.command & PORT_CMD_FIS_ON) {
      UpdateInitD2H();
    }

    CheckCommand();
    break;
  case kAhciPortRegTaskFileData:
  case kAhciPortRegSignature:
  case kAhciPortRegSataStatus:
    /* Read Only */
    break;
  case kAhciPortRegSataControl:
    if (((port_control_.sata_control & AHCI_SCR_SCTL_DET) == 1) && ((value & AHCI_SCR_SCTL_DET) == 0)) {
      SoftReset();
    }
    port_control_.sata_control = value;
    break;
  case kAhciPortRegSataError:
    port_control_.sata_error &= ~value;
    break;
  case kAhciPortRegSataActive:
    /* RW1 */
    port_control_.sata_active |= value;
    break;
  case kAhciPortRegCommandIssue:
    port_control_.command_issue |= value;
    CheckCommand();
    break;
  default:
    MV_ERROR("not implemented reg index = %x", reg_index);
  }
}

void AhciPort::UpdateFisRegisterD2H() {
  MV_ASSERT(rx_fis_ && port_control_.command & PORT_CMD_FIS_RX);
  auto d2h_fis = &rx_fis_->d2h_fis;
  bzero(d2h_fis, sizeof(*d2h_fis));

  d2h_fis->fis_type = kAhciFisTypeRegD2H;
  d2h_fis->interrupt = 1;
  d2h_fis->status = task_file_.status;
  d2h_fis->error = task_file_.error;

  d2h_fis->lba0 = task_file_.lba0;
  d2h_fis->lba1 = task_file_.lba1;
  d2h_fis->lba2 = task_file_.lba2;
  d2h_fis->device = task_file_.device;
  d2h_fis->lba3 = task_file_.lba3;
  d2h_fis->lba4 = task_file_.lba4;
  d2h_fis->lba5 = task_file_.lba5;
  d2h_fis->count0 = task_file_.count0;
  d2h_fis->count1 = task_file_.count1;

  port_control_.task_flie_data = (task_file_.error << 8) | (task_file_.status);
  if (task_file_.status & ATA_CB_STAT_ERR) {
    TrigerIrq(kAhciPortIrqBitTaskFileError);
  }
  TrigerIrq(kAhciPortIrqBitDeviceToHostFis);
}

void AhciPort::UpdateFisSetupPio() {
  MV_ASSERT(rx_fis_ && port_control_.command & PORT_CMD_FIS_RX);
  auto pio_fis = &rx_fis_->pio_fis;
  bzero(pio_fis, sizeof(*pio_fis));

  auto io = drive_->io();

  pio_fis->fis_type = kAhciFisTypePioSetup;
  pio_fis->interrupt = 1;
  pio_fis->status = task_file_.status;
  pio_fis->error = task_file_.error;

  pio_fis->lba0 = task_file_.lba0;
  pio_fis->lba1 = task_file_.lba1;
  pio_fis->lba2 = task_file_.lba2;
  pio_fis->device = task_file_.device;
  pio_fis->lba3 = task_file_.lba3;
  pio_fis->lba4 = task_file_.lba4;
  pio_fis->lba5 = task_file_.lba5;
  pio_fis->count0 = task_file_.count0;
  pio_fis->count1 = task_file_.count1;
  pio_fis->e_status = task_file_.status;
  pio_fis->transfer_count = io->transfer_bytes;

  port_control_.task_flie_data = (task_file_.error << 8) | (task_file_.status);

  if (task_file_.status & ATA_CB_STAT_ERR) {
    TrigerIrq(kAhciPortIrqBitTaskFileError);
  }
  TrigerIrq(kAhciPortIrqBitPioSetupFis);
}

void AhciPort::UpdateFisSetDeviceBits(int slot) {
  MV_ASSERT(rx_fis_ && port_control_.command & PORT_CMD_FIS_RX);
  auto sdb_fis = &rx_fis_->sdb_fis;

  sdb_fis->type = kAhciFisTypeDeviceBits;
  sdb_fis->flags = 0x40; // interrupt
  sdb_fis->status = task_file_.status;
  sdb_fis->error = task_file_.error;

  if (!(port_control_.sata_error & (1 << slot))) {
    sdb_fis->payload = 1 << slot;
  } else {
    sdb_fis->payload = 0;
  }

  port_control_.sata_active &= ~sdb_fis->payload;
  port_control_.task_flie_data = (task_file_.error << 8) | (task_file_.status);

  TrigerIrq(kAhciPortIrqBitSetDeviceBitsFis);
}

void AhciPort::TrigerIrq(int irqbit) {
  MV_ASSERT(irqbit < 32);
  uint32_t irq = 1U << irqbit;
  uint32_t irq_status = port_control_.irq_status | irq;
  port_control_.irq_status = irq_status;
  host_->CheckIrq();
}

void AhciPort::SaveState(AhciHostState_PortState* port_state) {
  /* Make sure no commands are running */
  MV_ASSERT(port_control_.command_issue == 0);

  port_state->set_index(port_index_);
  port_state->set_busy_slot(busy_slot_);
  port_state->set_init_d2h_sent(init_d2h_sent_);
  auto regs = port_state->mutable_registers();
  regs->set_command_list_base0(port_control_.command_list_base0);
  regs->set_command_list_base1(port_control_.command_list_base1);
  regs->set_fis_base0(port_control_.fis_base0);
  regs->set_fis_base1(port_control_.fis_base1);
  regs->set_irq_status(port_control_.irq_status);
  regs->set_irq_mask(port_control_.irq_mask);
  regs->set_command(port_control_.command);
  regs->set_task_flie_data(port_control_.task_flie_data);
  regs->set_signature(port_control_.signature);
  regs->set_sata_status(port_control_.sata_status);
  regs->set_sata_control(port_control_.sata_control);
  regs->set_sata_error(port_control_.sata_error);
  regs->set_sata_active(port_control_.sata_active);
}

void AhciPort::LoadState(const AhciHostState_PortState* port_state) {
  port_index_ = port_state->index();
  busy_slot_ = port_state->busy_slot();
  init_d2h_sent_ = port_state->init_d2h_sent();
  auto &regs = port_state->registers();
  port_control_.command_list_base0 = regs.command_list_base0();
  port_control_.command_list_base1 = regs.command_list_base1();
  port_control_.fis_base0 = regs.fis_base0();
  port_control_.fis_base1 = regs.fis_base1();
  port_control_.irq_status = regs.irq_status();
  port_control_.irq_mask = regs.irq_mask();
  port_control_.command = regs.command();
  port_control_.task_flie_data = regs.task_flie_data();
  port_control_.signature = regs.signature();
  port_control_.sata_status = regs.sata_status();
  port_control_.sata_control = regs.sata_control();
  port_control_.sata_error = regs.sata_error();
  port_control_.sata_active = regs.sata_active();

  /* Setup command_list_ and fis_rx_ pointers */
  port_control_.command &= ~(PORT_CMD_LIST_ON | PORT_CMD_FIS_ON);
  CheckEngines();
}

```

`devices/ahci/ahci_port.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef __MVISOR_DEVICES_AHCI_PORT_H
#define __MVISOR_DEVICES_AHCI_PORT_H

#include <mutex>
#include <deque>

#include <cstdint>
#include "ata_storage.h"
#include "device.h"
#include "ahci_host.pb.h"

struct AhciCommandHeader {
  uint8_t     command_fis_length : 5; // in DWORDS, 2 ~ 16
  uint8_t     is_atapi : 1;
  uint8_t     is_write : 1;
  uint8_t     prefetchable : 1;

  uint8_t     reset : 1;
  uint8_t     built_in_self_test : 1;
  uint8_t     clear_busy_upon_r_ok : 1;
  uint8_t     reserved0 : 1;
  uint8_t     port_multiplier : 4;

  uint16_t    prdt_length; // physical region descriptor table length in entries
  uint32_t    bytes_transferred;
  uint64_t    command_table_base;
  uint32_t    reserved[4];
} __attribute__((packed));

struct AhciPortRegs {
  uint32_t    command_list_base0;
  uint32_t    command_list_base1;
  uint32_t    fis_base0;
  uint32_t    fis_base1;
  uint32_t    irq_status;
  uint32_t    irq_mask;
  uint32_t    command;
  uint32_t    reserved0;
  uint32_t    task_flie_data;
  uint32_t    signature;
  uint32_t    sata_status;
  uint32_t    sata_control;
  uint32_t    sata_error;
  uint32_t    sata_active;
  uint32_t    command_issue;
  uint32_t    sata_notification;
  uint32_t    fis_based_switch_control;
  uint32_t    reserved1[11];
  uint32_t    vendor[4];
};

class DeviceManager;
class AhciHost;
struct AhciRxFis;
struct AhciPrdtEntry;

class AhciPort: public AtaPort {
 public:
  AhciPort(DeviceManager* manager, AhciHost* host, int index);
  virtual ~AhciPort();

  void AttachDevice(AtaStorageDevice* device);
  void Write(uint64_t offset, uint32_t value);
  void Read(uint64_t offset, uint8_t* data, uint32_t size);
  void Reset();

  /* Called by AhciHost */
  void SaveState(AhciHostState_PortState* port_state);
  void LoadState(const AhciHostState_PortState* port_state);

  /* Called by AtaStorage */
  virtual void OnDmaPrepare();
  virtual void OnDmaTransfer();
  virtual void OnPioTransfer();
  virtual void OnCommandDone();

  const AhciPortRegs& port_control() const { return port_control_; }

 private:
  void SoftReset();
  void TrigerIrq(int irqbit);
  void UpdateInitD2H();
  void UpdateFisRegisterD2H();
  void UpdateFisSetupPio();
  void UpdateFisSetDeviceBits(int slot);
  void SetNcqError(int slot);
  void HandleNcqCommand(int slot, void* fis);
  bool HandleCommand(int slot);
  void CheckEngines();
  void CheckCommand();
  void ParseDmaVector(AhciPrdtEntry* entries, uint16_t length, bool is_write);

  DeviceManager*        manager_;
  AhciHost*             host_;
  int                   port_index_;
  AhciPortRegs          port_control_;
  AtaStorageDevice*     drive_ = nullptr;
  TaskFile              task_file_;
  bool                  init_d2h_sent_ = false;
  uint8_t*              command_list_ = nullptr;
  AhciRxFis*            rx_fis_ = nullptr;
  int                   busy_slot_ = -1;
  AhciCommandHeader*    current_command_ = nullptr;
  std::vector<iovec>    current_dma_vector_;
};

#endif // __MVISOR_DEVICES_AHCI_PORT_H

```

`devices/ahci/ata_cdrom.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_cdrom.h"

#include <cstring>

#include "disk_image.h"
#include "logger.h"
#include "ahci_port.h"
#include "ata_cdrom.pb.h"
#include "ata_internal.h"

/*
 *  SENSE KEYS
 */

#define NO_SENSE            0x00
#define RECOVERED_ERROR     0x01
#define NOT_READY           0x02
#define MEDIUM_ERROR        0x03
#define HARDWARE_ERROR      0x04
#define ILLEGAL_REQUEST     0x05
#define UNIT_ATTENTION      0x06
#define DATA_PROTECT        0x07
#define BLANK_CHECK         0x08
#define COPY_ABORTED        0x0a
#define ABORTED_COMMAND     0x0b
#define VOLUME_OVERFLOW     0x0d
#define MISCOMPARE          0x0e

/* same constants as bochs */
#define ASC_NO_SEEK_COMPLETE                 0x02
#define ASC_ILLEGAL_OPCODE                   0x20
#define ASC_LOGICAL_BLOCK_OOR                0x21
#define ASC_INV_FIELD_IN_CMD_PACKET          0x24
#define ASC_MEDIUM_MAY_HAVE_CHANGED          0x28
#define ASC_INCOMPATIBLE_FORMAT              0x30
#define ASC_MEDIUM_NOT_PRESENT               0x3a
#define ASC_SAVING_PARAMETERS_NOT_SUPPORTED  0x39
#define ASC_DATA_PHASE_ERROR                 0x4b
#define ASC_MEDIA_REMOVAL_PREVENTED          0x53

static void padstr(char *str, const char *src, int len)
{
  int i, v;
  for(i = 0; i < len; i++) {
    if (*src)
      v = *src++;
    else
      v = ' ';
    str[i^1] = v;
  }
}

static void padstr8(uint8_t *buf, int buf_size, const char *src)
{
  for(int i = 0; i < buf_size; i++) {
    if (*src)
      buf[i] = *src++;
    else
      buf[i] = ' ';
  }
}


static void lba_to_msf(uint8_t *buf, int lba)
{
    lba += 150;
    buf[0] = (lba / 75) / 60;
    buf[1] = (lba / 75) % 60;
    buf[2] = lba % 75;
}

/* same toc as bochs. Return -1 if error or the toc length */
/* XXX: check this */
static int cdrom_read_toc(int nb_sectors, uint8_t *buf, int msf, int start_track)
{
  uint8_t *q;
  int len;

  if (start_track > 1 && start_track != 0xaa)
    return -1;
  q = buf + 2;
  *q++ = 1; /* first session */
  *q++ = 1; /* last session */
  if (start_track <= 1) {
    *q++ = 0; /* reserved */
    *q++ = 0x14; /* ADR, control */
    *q++ = 1;    /* track number */
    *q++ = 0; /* reserved */
    if (msf) {
      *q++ = 0; /* reserved */
      lba_to_msf(q, 0);
      q += 3;
    } else {
      /* sector 0 */
      *(uint32_t*)q = htobe32(0);
      q += 4;
    }
  }
  /* lead out track */
  *q++ = 0; /* reserved */
  *q++ = 0x16; /* ADR, control */
  *q++ = 0xaa; /* track number */
  *q++ = 0; /* reserved */
  if (msf) {
    *q++ = 0; /* reserved */
    lba_to_msf(q, nb_sectors);
    q += 3;
  } else {
    *(uint32_t*)q = htobe32(nb_sectors);
    q += 4;
  }
  len = q - buf;
  *(uint16_t*)buf = htobe16(len - 2);
  return len;
}

/* mostly same info as PearPc */
static int cdrom_read_toc_raw(int nb_sectors, uint8_t *buf, int msf, int session_num)
{
  MV_UNUSED(session_num);
  uint8_t *q;
  int len;

  q = buf + 2;
  *q++ = 1; /* first session */
  *q++ = 1; /* last session */

  *q++ = 1; /* session number */
  *q++ = 0x14; /* data track */
  *q++ = 0; /* track number */
  *q++ = 0xa0; /* lead-in */
  *q++ = 0; /* min */
  *q++ = 0; /* sec */
  *q++ = 0; /* frame */
  *q++ = 0;
  *q++ = 1; /* first track */
  *q++ = 0x00; /* disk type */
  *q++ = 0x00;

  *q++ = 1; /* session number */
  *q++ = 0x14; /* data track */
  *q++ = 0; /* track number */
  *q++ = 0xa1;
  *q++ = 0; /* min */
  *q++ = 0; /* sec */
  *q++ = 0; /* frame */
  *q++ = 0;
  *q++ = 1; /* last track */
  *q++ = 0x00;
  *q++ = 0x00;

  *q++ = 1; /* session number */
  *q++ = 0x14; /* data track */
  *q++ = 0; /* track number */
  *q++ = 0xa2; /* lead-out */
  *q++ = 0; /* min */
  *q++ = 0; /* sec */
  *q++ = 0; /* frame */
  if (msf) {
    *q++ = 0; /* reserved */
    lba_to_msf(q, nb_sectors);
    q += 3;
  } else {
    *(uint32_t*)q = htobe32(nb_sectors);
    q += 4;
  }

  *q++ = 1; /* session number */
  *q++ = 0x14; /* ADR, control */
  *q++ = 0;    /* track number */
  *q++ = 1;    /* point */
  *q++ = 0; /* min */
  *q++ = 0; /* sec */
  *q++ = 0; /* frame */
  if (msf) {
    *q++ = 0;
    lba_to_msf(q, 0);
    q += 3;
  } else {
    *q++ = 0;
    *q++ = 0;
    *q++ = 0;
    *q++ = 0;
  }

  len = q - buf;
  *(uint16_t*)buf = htobe16(len - 2);
  return len;
}


AtaCdrom::AtaCdrom()
{
  type_ = kAtaStorageTypeCdrom;

  drive_info_.world_wide_name = rand();
  sprintf(drive_info_.serial, "TC%05ld", drive_info_.world_wide_name);
  sprintf(drive_info_.model, "DVD-ROM");
  sprintf(drive_info_.version, "1.0");

  /* ATA command handlers */
  ata_handlers_[0xA0] = [=] () { // ATA_CMD_PACKET
    if (io_.atapi_set) {
      ParseCommandPacket();
    } else {
      io_.transfer_bytes = 12;
      task_file_->count0 = ATA_CB_SC_P_CD;
      StartTransfer(kTransferAtapiCommand, [this]() {
        memcpy(io_.atapi_command, io_.buffer, 12);
        task_file_->count0 = 0;
        ParseCommandPacket();
      });
    }
  };
  
  ata_handlers_[0xA1] = [=] () { // ATA_CMD_IDENTIFY_PACKET_DEVICE
    Atapi_IdentifyData();
  };


  /* ATAPI command handlers */
  atapi_handlers_[0x00] = [=] () { // test unit ready
    if (image_ == nullptr) {
      SetError(NOT_READY, ASC_MEDIUM_NOT_PRESENT);
    } else {
      task_file_->status |= ATA_CB_STAT_SKC;
    }
  };
  
  atapi_handlers_[0x03] = [=] () { // request sense
    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_RequestSense(); });
    } else {
      Atapi_RequestSense();
    }
  };
  
  atapi_handlers_[0x12] = [=] () { // inquiry
    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_Inquiry(); });
    } else {
      Atapi_Inquiry();
    }
  };
  
  atapi_handlers_[0x1B] = [=] () { // start stop unit such as load or eject the media
  };
  
  atapi_handlers_[0x1E] = [=] () { // prevent allow media removal
  };
  
  atapi_handlers_[0x25] = [=] () { // get media capacity
    if (image_ == nullptr) {
      SetError(NOT_READY, ASC_MEDIUM_NOT_PRESENT);
      return;
    }

    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_GetMediaCapacity(); });
    } else {
      Atapi_GetMediaCapacity();
    }
  };
  
  atapi_handlers_[0x28] = [=] () { // read 10
    if (image_ == nullptr) {
      SetError(NOT_READY, ASC_MEDIUM_NOT_PRESENT);
      return;
    }
    CBD_RW_DATA10* p = (CBD_RW_DATA10*)io_.atapi_command;
    io_.lba_block = be32toh(p->lba);
    io_.lba_count = be16toh(p->count);
    if (debug_) {
      MV_LOG("ATAPI read block=0x%lx count=0x%lx", io_.lba_block, io_.lba_count);
    }
    if (io_.lba_block + io_.lba_count > geometry_.total_sectors) {
      SetError(ILLEGAL_REQUEST, ASC_LOGICAL_BLOCK_OOR);
      return;
    }
  
    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_ReadSectors(io_.lba_count); });
    } else {
      Atapi_ReadSectors(1);
    }
  };
  
  atapi_handlers_[0x2B] = [=] () { // seek
  };
  
  atapi_handlers_[0x35] = [=] () { // flush cache
  };
  
  atapi_handlers_[0x42] = [=] () { // read subchannel
    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_ReadSubchannel(); });
    } else {
      Atapi_ReadSubchannel();
    }
  };
  
  atapi_handlers_[0x43] = [=] () { // read table of content
    if (image_ == nullptr) {
      SetError(NOT_READY, ASC_MEDIUM_NOT_PRESENT);
      return;
    }

    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_ReadTableOfContent(); });
    } else {
      Atapi_ReadTableOfContent();
    }
  };
  
  atapi_handlers_[0x46] =          // get configuration
  atapi_handlers_[0x4A] = [=] () { // get event status notification
    SetError(ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET);
  };

  atapi_handlers_[0x51] = [=] () { // read disc information
    SetError(ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET);
  };
  
  atapi_handlers_[0x5A] = [=] () { // mode sense 10
    if (task_file_->feature0 & 1) {
      WaitForDma([this]() { Atapi_ModeSense(); });
    } else {
      Atapi_ModeSense();
    }
  };
  
  ata_handlers_[0xEC] = [=] () { // ATA_CMD_IDENTIFY_DEVICE
    SetSignature(task_file_);
    AbortCommand();
    task_file_->status |= ATA_CB_STAT_BSY;
  };
}

void AtaCdrom::Connect() {
  AtaStorageDevice::Connect();

  if (image_) {
    ImageInformation info = image_->information();
    image_block_size_ = info.block_size;
    geometry_.sector_size = 2048;
    geometry_.total_sectors = info.total_blocks * info.block_size / geometry_.sector_size;
  }
}

void AtaCdrom::SetError(uint sense_key, uint asc) {
  task_file_->error = sense_key << 4;
  task_file_->status |= ATA_CB_STAT_ERR;
  task_file_->count0 = (task_file_->count0 & ~7) | ATA_CB_SC_P_CD | ATA_CB_SC_P_IO;
  sense_key_ = sense_key;
  asc_ = asc;
}


void AtaCdrom::ParseCommandPacket() {
  uint8_t command = io_.atapi_command[0];
  task_file_->error = 0;
  if (debug_) {
    MV_HEXDUMP("atapi", io_.atapi_command, sizeof(io_.atapi_command));
  }

  auto handler = atapi_handlers_[command];
  if (!handler) {
    SetError(ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET);
    MV_HEXDUMP("unhandled ATAPI command", io_.atapi_command, sizeof(io_.atapi_command));
    return;
  }

  if (handler) {
    handler();
  }
}


void AtaCdrom::StartTransfer(TransferType type, VoidCallback end_cb) {
  if (type == kTransferDataToHost) {
    task_file_->count0 |= ATA_CB_SC_P_IO;
  } else {
    task_file_->count0 &= ~ATA_CB_SC_P_IO;
  }
  task_file_->lba1 = io_.transfer_bytes & 0xFF;
  task_file_->lba2 = io_.transfer_bytes >> 8;
  AtaStorageDevice::StartTransfer(type, std::move(end_cb));
}

void AtaCdrom::EndCommand() {
  task_file_->count0 = (task_file_->count0 & ~7) | ATA_CB_SC_P_CD | ATA_CB_SC_P_IO;
  AtaStorageDevice::EndCommand();
}

void AtaCdrom::Atapi_ReadSectors(size_t sectors) {
  if (io_.lba_count == 0) {
    return;
  }

  io_async_ = true;
  size_t position = io_.lba_block * geometry_.sector_size;
  size_t remain_bytes = sectors * geometry_.sector_size;
  size_t vec_index = 0;
  ImageIoRequest request = {
    .type = kImageIoRead,
    .position = position,
    .length = 0
  };

  while (vec_index < io_.vector.size() && remain_bytes > 0) {
    auto& iov = io_.vector[vec_index];

    size_t length = remain_bytes < iov.iov_len ? remain_bytes : iov.iov_len;
    request.vector.emplace_back(iovec {
      .iov_base = iov.iov_base,
      .iov_len = length
    });

    request.length += length;
    remain_bytes -= length;
    vec_index++;
  }

  MV_ASSERT(request.length == geometry_.sector_size * sectors);
  io_.transfer_bytes = request.length;
  io_.lba_count -= sectors;
  io_.lba_block += sectors;

  image_->QueueIoRequest(request, [this, sectors](ssize_t ret) {
    if (ret <= 0) {
      SetError(ILLEGAL_REQUEST, ASC_LOGICAL_BLOCK_OOR);
      EndCommand();
    } else {
      StartTransfer(kTransferDataToHost, [this, sectors]() {
        Atapi_ReadSectors(sectors);
      });
    }
  });
}

void AtaCdrom::Atapi_RequestSense() {
  uint8_t* buf = io_.buffer;
  int max_len = io_.atapi_command[4];

  bzero(buf, 18);
  buf[0] = 0x70 | (1 << 7);
  buf[2] = sense_key_;
  buf[7] = 10;
  buf[12] = asc_;

  if (sense_key_ == UNIT_ATTENTION) {
    sense_key_ = NO_SENSE;
  }

  io_.transfer_bytes = max_len > 18 ? 18 : max_len;
  StartTransfer(kTransferDataToHost, []() {});
}

void AtaCdrom::Atapi_GetMediaCapacity() {
  io_.transfer_bytes = 8;
  *(uint32_t*)&io_.buffer[0] = htobe32(geometry_.total_sectors - 1);
  *(uint32_t*)&io_.buffer[4] = htobe32(geometry_.sector_size);
  StartTransfer(kTransferDataToHost, []() {});
}

void AtaCdrom::Atapi_ModeSense() {
  uint8_t buf[100] = { 0 };

  switch (io_.atapi_command[2])
  {
  case 0x2A: // Capabilities
    *(uint16_t*)&buf[0] = htobe16(30 - 2);
    buf[2] = 0x70;
    buf[8] = 0x2A;
    buf[9] = 30 - 10;
    // buf[10] = 0x3B; /* read CDR/CDRW/DVDROM/DVDR/DVDRAM */
    buf[12] = 0x70;
    buf[13] = 3 << 5;
    buf[14] = (1 << 0) | (1 << 3) | (1 << 5);
    *(uint16_t*)&buf[16] = htobe16(706);
    *(uint16_t*)&buf[18] = htobe16(2);
    *(uint16_t*)&buf[20] = htobe16(512);
    *(uint16_t*)&buf[22] = htobe16(706);
  
    io_.transfer_bytes = io_.buffer_size < 30 ? io_.buffer_size : 30;
    memcpy(io_.buffer, buf, io_.transfer_bytes);
    StartTransfer(kTransferDataToHost, []() {});
    break;
  default:
    if (debug_) {
      MV_ERROR("unhandled mode sense %x", io_.atapi_command[2]);
    }
    SetError(ILLEGAL_REQUEST, ASC_INV_FIELD_IN_CMD_PACKET);
    break;
  }
}

void AtaCdrom::Atapi_ReadTableOfContent() {
  uint8_t* buf = io_.buffer;

  size_t max_size = be16toh(*(uint16_t*)&io_.atapi_command[7]);
  int format = io_.atapi_command[9] >> 6;
  int msf = (io_.atapi_command[1] >> 1) & 1;
  int start_track = io_.atapi_command[6];

  MV_ASSERT(max_size <= io_.buffer_size);
  bzero(buf, max_size);
  switch (format)
  {
  case 0: // TOC Data format
    io_.transfer_bytes = (size_t)cdrom_read_toc(geometry_.total_sectors, buf, msf, start_track);
    break;
  case 1: // Multi-session
    *(uint16_t*)&buf[0] = htobe16(0x000A);
    buf[2] = 1;
    buf[3] = 1;
    io_.transfer_bytes = 12;
    break;
  case 2: // Raw TOC Data
    io_.transfer_bytes = (size_t)cdrom_read_toc_raw(geometry_.total_sectors, buf, msf, start_track);
    break;
  default:
    MV_PANIC("invalid TOC command %x", format);
    break;
  }

  // do not copy more than max_size
  if (io_.transfer_bytes > max_size)
    io_.transfer_bytes = max_size;
  StartTransfer(kTransferDataToHost, []() {});
}

void AtaCdrom::Atapi_ReadSubchannel() {
  uint8_t size = io_.atapi_command[8] < 8 ? io_.atapi_command[8] : 8;
  bzero(io_.buffer, size);

  io_.transfer_bytes = size;
  StartTransfer(kTransferDataToHost, []() {});
}

void AtaCdrom::Atapi_Inquiry() {
  uint8_t* buf = io_.buffer;

  uint8_t size = io_.atapi_command[4];

  buf[0] = 0x05; /* CD-ROM */
  buf[1] = 0x80; /* removable */
  buf[2] = 0x00; /* ISO */
  buf[3] = 0x21; /* ATAPI-2 (XXX: put ATAPI-4 ?) */
  buf[4] = 36 - 5;   /* size */
  buf[5] = 0;    /* reserved */
  buf[6] = 0;    /* reserved */
  buf[7] = 0;    /* reserved */
  padstr8(buf + 8, 8, "Tenclass");
  padstr8(buf + 16, 16, drive_info_.model);
  padstr8(buf + 32, 4, drive_info_.version);

  io_.transfer_bytes = size > 36 ? 36 : size;
  StartTransfer(kTransferDataToHost, []() {});
}

void AtaCdrom::Atapi_IdentifyData() {
  uint16_t p[256] = { 0 };
  bool dma_supported = true;

  /* Removable CDROM, 50us response, 12 byte packets */
  p[0] = (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0);

  padstr((char *)(p + 10), drive_info_.serial, 20); /* serial number */
  p[20] = 3; /* buffer type */
  p[21] = 512; /* cache size in sectors */
  p[22] = 4; /* ecc bytes */
  padstr((char *)(p + 23), drive_info_.version, 8); /* firmware version */
  padstr((char *)(p + 27), drive_info_.model, 40); /* model */
  p[48] = 1; /* dword I/O (XXX: should not be set on CDROM) */

  if (dma_supported) {
    p[49] = 1 << 9 | 1 << 8; /* LBA supported (DMA supported) */
    p[53] = 7; /* words 64-70, 54-58, 88 valid */
    p[62] = 7; /* 0 or 7: single word dma0-2 supported */
    p[63] = 7; /* 0 or 7: mdma0-2 supported */
  } else {
    p[49] = 1 << 9; /* LBA supported (no DMA) */
    p[53] = 3; /* words 64-70, 54-58 valid */
    p[63] = 0x103; /* ??? */
  }

  p[64] = 3; /* pio3-4 supported */
  p[65] = 0xb4; /* minimum DMA multiword tx cycle time */
  p[66] = 0xb4; /* recommended DMA multiword tx cycle time */
  p[67] = 0x12c; /* minimum PIO cycle time without flow control */
  p[68] = 0xb4; /* minimum PIO cycle time with IORDY flow control */

  p[71] = 30; /* in ns */
  p[72] = 30; /* in ns */

  p[75] = 32 - 1; /* AHCI MAX_COMMANDS */
  p[76] = (1 << 8); /* NCQ supported */

  p[80] = 0x1e; /* support up to ATA/ATAPI-4 */
  if (drive_info_.world_wide_name) {
      p[84] = (1 << 8); /* supports WWN for words 108-111 */
      p[87] = (1 << 8); /* WWN enabled */
  }
  
  if (dma_supported) {
    p[88] = 0x3f | (1 << 13); /* udma5 set and supported */
  }

  if (drive_info_.world_wide_name) {
      /* LE 16-bit words 111-108 contain 64-bit World Wide Name */
      p[108] = drive_info_.world_wide_name >> 48;
      p[109] = drive_info_.world_wide_name >> 32;
      p[110] = drive_info_.world_wide_name >> 16;
      p[111] = drive_info_.world_wide_name;
  }

  io_.transfer_bytes = io_.buffer_size < 512 ? io_.buffer_size : 512;
  memcpy(io_.buffer, p, io_.transfer_bytes);
  StartTransfer(kTransferDataToHost, []() {});
}


bool AtaCdrom::SaveState(MigrationWriter* writer) {
  AtaCdromState state;
  state.set_sense_key(sense_key_);
  state.set_asc(asc_);
  writer->WriteProtobuf("CDROM", state);
  return AtaStorageDevice::SaveState(writer);
}

bool AtaCdrom::LoadState(MigrationReader* reader) {
  if (!AtaStorageDevice::LoadState(reader)) {
    return false;
  }

  AtaCdromState state;
  if (!reader->ReadProtobuf("CDROM", state)) {
    return false;
  }
  sense_key_ = state.sense_key();
  asc_ = state.asc();
  return true;
}

DECLARE_DEVICE(AtaCdrom);

```

`devices/ahci/ata_cdrom.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AHCI_ATA_CDROM_H
#define _MVISOR_DEVICES_AHCI_ATA_CDROM_H

#include <string>

#include "ata_storage.h"


class AtaCdrom : public AtaStorageDevice {
 public:
  AtaCdrom();
  virtual void Connect();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);
  virtual void StartTransfer(TransferType type, VoidCallback end_cb);
  virtual void EndCommand();

 private:
  void ParseCommandPacket();
  void Atapi_IdentifyData();
  void Atapi_Inquiry();
  void Atapi_ReadSectors(size_t sectors);
  void Atapi_ReadTableOfContent();
  void Atapi_ModeSense();
  void Atapi_RequestSense();
  void Atapi_GetMediaCapacity();
  void Atapi_ReadSubchannel();
  void SetError(uint sense_key, uint asc);

  uint    sense_key_;
  uint    asc_;
  size_t  image_block_size_;

  VoidCallback atapi_handlers_[256];
};


#endif // _MVISOR_DEVICES_AHCI_ATA_CDROM_H

```

`devices/ahci/ata_cdrom.proto`:

```proto
syntax = "proto3";

message AtaCdromState {
  uint32  sense_key     = 1;
  uint32  asc           = 2;
}

```

`devices/ahci/ata_disk.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_disk.h"

#include <cstring>

#include "logger.h"
#include "disk_image.h"
#include "ahci_port.h"
#include "ata_internal.h"


static void padstr(char *str, const char *src, int len)
{
  int i, v;
  for(i = 0; i < len; i++) {
    if (*src)
      v = *src++;
    else
      v = ' ';
    str[i^1] = v;
  }
}

/*
 * Reference: https://read.seas.harvard.edu/cs161/2019/pdf/ata-atapi-8.pdf
 * The implemenation of ATA does not fully comply with the specification above.
 * It is a simplified version that just works.
 */
AtaDisk::AtaDisk() {
  type_ = kAtaStorageTypeDisk;

  drive_info_.world_wide_name = rand();
  sprintf(drive_info_.serial, "TC%05ld", drive_info_.world_wide_name);
  sprintf(drive_info_.model, "Tenclass Disk");
  sprintf(drive_info_.version, "1.0");
  
  ata_handlers_[0x06] = [=] () { // DATA SET MANAGEMENT
    if (task_file_->feature0 == 1) { // TRIM (Reference 7.5.6.1)
      WaitForDma([this]() { Ata_Trim(); });
    } else {
      AbortCommand();
      MV_PANIC("unknown data set management command=0x%x", task_file_->feature0);
    }
  };

  ata_handlers_[0x20] =
  ata_handlers_[0x29] =
  ata_handlers_[0xC4] = [=] () { // ATA_CMD_READ_SECTORS
    size_t sectors = task_file_->command == 0x20 ? 1 : multiple_sectors_;

    ReadLba(task_file_->command == 0x29 ? kLbaMode48 : kLbaMode28);
    if (debug_) {
      MV_LOG("read 0x%lx sectors at 0x%lx", io_.lba_count, io_.lba_block);
    }
    Ata_PioReadSectors(sectors);
  };

  ata_handlers_[0x30] =
  ata_handlers_[0x39] =
  ata_handlers_[0xC5] = [=] () { // ATA_CMD_WRITE_SECTORS
    size_t sectors = task_file_->command == 0x30 ? 1 : multiple_sectors_;

    ReadLba(task_file_->command == 0x39 ? kLbaMode48 : kLbaMode28);
    if (debug_) {
      MV_LOG("write 0x%lx sectors at 0x%lx", io_.lba_count, io_.lba_block);
    }
    Ata_PioWriteSectors(sectors);
  };

  ata_handlers_[0x40] = [=] () { // VERIFY
  };

  ata_handlers_[0x91] = [=] () { // set drive geometry translation, obsolete since ATA6
  };

  ata_handlers_[0xA1] = [=] () { // ATA_CMD_IDENTIFY_PACKET_DEVICE
    AbortCommand();
  };

  ata_handlers_[0xB0] = [=] () { // SMART
    AbortCommand();
  };

  ata_handlers_[0xC6] = [=] () { // multiple sectors
    multiple_sectors_ = task_file_->count0 & 0xFF;
    if (debug_) {
      MV_LOG("set multiple sectors %d", multiple_sectors_);
    }
    /* update pio buffer size */
    io_.pio_buffer_size = multiple_sectors_ * geometry_.sector_size;
  };
  
  ata_handlers_[0x25] =          // ATA_CMD_READ_DMA_EXT
  ata_handlers_[0xC8] = [=] () { // ATA_CMD_READ_DMA
    ReadLba(task_file_->command == 0x25 ? kLbaMode48 : kLbaMode28);
    if (debug_) {
      MV_LOG("DMA read 0x%lx sectors at 0x%lx", io_.lba_count, io_.lba_block);
    }
    WaitForDma([this]() { Ata_DmaReadWriteSectors(false, io_.lba_count); });
  };

  ata_handlers_[0x35] =          // ATA_CMD_WRITE_DMA_EXT
  ata_handlers_[0xCA] = [=] () { // ATA_CMD_WRITE_DMA
    ReadLba(task_file_->command == 0x35 ? kLbaMode48 : kLbaMode28);
    if (debug_) {
      MV_LOG("DMA write 0x%lx sectors at 0x%lx", io_.lba_count, io_.lba_block);
    }

    WaitForDma([this]() { Ata_DmaReadWriteSectors(true, io_.lba_count); });
  };

  ata_handlers_[0xE1] = [=] () { // IDLEIMMEDIATE
  };

  ata_handlers_[0xE7] =          // FLUSH_CACHE
  ata_handlers_[0xEA] = [=] () { // FLUSH_CACHE_EXT
    io_async_ = true;
    ImageIoRequest request = {
      .type = kImageIoFlush
    };
    image_->QueueIoRequest(request, [this](ssize_t ret) {
      if (ret < 0) {
        task_file_->status |= ATA_CB_STAT_ERR;
      }
      EndCommand();
    });
  };
  
  ata_handlers_[0xEC] = [=] () { // ATA_CMD_IDENTIFY_DEVICE
    if (image_) {
      Ata_IdentifyDevice();
    }
  };

  ata_handlers_[0xF5] = [=] () { // SECURITY_FREEZE_LOCK
    AbortCommand();
  };
}

void AtaDisk::Connect() {
  AtaStorageDevice::Connect();

  if (image_) {
    ImageInformation info = image_->information();
    geometry_.sector_size = info.block_size;
    geometry_.total_sectors = info.total_blocks;
    geometry_.heads = 16;
    geometry_.sectors_per_cylinder = 63;
    geometry_.cylinders_per_heads = geometry_.total_sectors / (geometry_.sectors_per_cylinder * geometry_.heads);
    geometry_.cylinders_per_heads = std::min(geometry_.cylinders_per_heads, 16383ul);
  }
}

void AtaDisk::ReadLba(LbaMode mode) {
  size_t block = task_file_->lba0;
  size_t count = 0;

  if (!(task_file_->device & 0x40)) {
    io_.lba_mode = kLbaModeChs;
  } else {
    io_.lba_mode = mode;
  }

  switch (io_.lba_mode)
  {
  case kLbaModeChs:
    if (task_file_->lba0 == 0) {
      io_.lba_block = 0;
      io_.lba_count = 0;
      return;
    }
    block = (((size_t)task_file_->lba2 << 8) | task_file_->lba1) * geometry_.heads * geometry_.sectors_per_cylinder +
        size_t(task_file_->device & 0xF) * geometry_.sectors_per_cylinder + (task_file_->lba0 - 1);
    count = task_file_->count0 == 0 ? 0x100 : task_file_->count0;
    break;
  case kLbaMode28:
    block |= (size_t)task_file_->lba1 << 8;
    block |= (size_t)task_file_->lba2 << 16;
    block |= (size_t)(task_file_->device & 0xF) << 24;
    count = task_file_->count0 == 0 ? 0x100 : task_file_->count0;
    break;
  case kLbaMode48:
    block |= (size_t)task_file_->lba1 << 8;
    block |= (size_t)task_file_->lba2 << 16;
    block |= (size_t)task_file_->lba3 << 24;
    block |= (size_t)task_file_->lba4 << 32;
    block |= (size_t)task_file_->lba5 << 40;
    if (task_file_->count0 == 0 && task_file_->count1 == 0) {
      count = 0x10000;
    } else {
      count = (task_file_->count1 << 8) | task_file_->count0;
    }
    break;
  default:
    MV_PANIC("unsupported lba mode %x", io_.lba_mode);
    break;
  }

  io_.lba_block = block;
  io_.lba_count = count;
}

void AtaDisk::WriteLba() {
  size_t block = io_.lba_block;
  size_t count = io_.lba_count;

  if (!(task_file_->device & 0x40)) {
    io_.lba_mode = kLbaModeChs;
  }

  switch (io_.lba_mode)
  {
  case kLbaModeChs: {
    size_t cyl = block / (geometry_.heads * geometry_.sectors_per_cylinder);
    size_t r = block % (geometry_.heads * geometry_.sectors_per_cylinder);
    task_file_->lba2 = cyl >> 8;
    task_file_->lba1 = cyl & 0xFF;
    task_file_->device = (task_file_->device & ~0xF) | ((r / geometry_.sectors_per_cylinder) & 0xF);
    task_file_->lba0 = (r % geometry_.sectors_per_cylinder) + 1;
    task_file_->count0 = count == 0x100 ? 0: count & 0xFF;
    break;
  }
  case kLbaMode28:
    task_file_->device = (task_file_->device & 0xF0) | ((block >> 24) & 0xF);
    task_file_->lba2 = (block >> 16) & 0xFF;
    task_file_->lba1 = (block >> 8) & 0xFF;
    task_file_->lba0 = (block >> 0) & 0xFF;
    task_file_->count0 = count == 0x100 ? 0: count & 0xFF;
    break;
  case kLbaMode48:
    task_file_->lba5 = (block >> 40) & 0xFF;
    task_file_->lba4 = (block >> 32) & 0xFF;
    task_file_->lba3 = (block >> 24) & 0xFF;
    task_file_->lba2 = (block >> 16) & 0xFF;
    task_file_->lba1 = (block >> 8) & 0xFF;
    task_file_->lba0 = (block >> 0) & 0xFF;
    if (count == 0x10000) {
      task_file_->count0 = task_file_->count1 = 0;
    } else {
      task_file_->count0 = count & 0xFF;
      task_file_->count1 = (count >> 8) & 0xFF;
    }
    break;
  default:
    MV_PANIC("unsupported lba mode %x", io_.lba_mode);
    break;
  }
}

void AtaDisk::Ata_DmaReadWriteSectors(bool is_write, size_t sectors) {
  if (io_.lba_count == 0) {
    return;
  }

  if (sectors > io_.lba_count) {
    sectors = io_.lba_count;
  }

  io_async_ = true;
  size_t position = io_.lba_block * geometry_.sector_size;
  size_t remain_bytes = sectors * geometry_.sector_size;
  size_t vec_index = 0;
  ImageIoRequest request = {
    .type = is_write ? kImageIoWrite : kImageIoRead,
    .position = position,
    .length = 0
  };

  while (vec_index < io_.vector.size() && remain_bytes > 0) {
    auto& iov = io_.vector[vec_index];

    size_t length = remain_bytes < iov.iov_len ? remain_bytes : iov.iov_len;
    request.vector.emplace_back(iovec {
      .iov_base = iov.iov_base,
      .iov_len = length
    });

    request.length += length;
    remain_bytes -= length;
    vec_index++;
  }

  MV_ASSERT(request.length == sectors * geometry_.sector_size);
  io_.transfer_bytes = request.length;
  io_.lba_count -= sectors;
  io_.lba_block += sectors;

  image_->QueueIoRequest(request, [this, is_write, sectors](ssize_t ret) {
    if (ret <= 0) {
      task_file_->status |= ATA_CB_STAT_ERR;
      EndCommand();
    } else {
      WriteLba();
      StartTransfer(kTransferDataToHost, [this, is_write, sectors]() {
        Ata_DmaReadWriteSectors(is_write, sectors);
      });
    }
  });
}

void AtaDisk::Ata_PioReadSectors(size_t sectors) {
  if (io_.lba_count == 0) {
    return;
  }

  if (sectors > io_.lba_count) {
    sectors = io_.lba_count;
  }

  task_file_->status |= ATA_CB_STAT_SKC;
  io_async_ = true;
  size_t position = io_.lba_block * geometry_.sector_size;
  size_t remain_bytes = sectors * geometry_.sector_size;
  size_t length = remain_bytes < io_.buffer_size ? remain_bytes : io_.buffer_size;

  ImageIoRequest request = {
    .type = kImageIoRead,
    .position = position,
    .length = length
  };
  request.vector.emplace_back(iovec {
    .iov_base = io_.buffer,
    .iov_len = length
  });

  io_.transfer_bytes = length;
  io_.lba_count -= sectors;
  io_.lba_block += sectors;

  image_->QueueIoRequest(request, [this, sectors](ssize_t ret) {
    if (ret <= 0) {
      task_file_->status |= ATA_CB_STAT_ERR;
      EndCommand();
    } else {
      WriteLba();
      StartTransfer(kTransferDataToHost, [this, sectors]() {
        Ata_PioReadSectors(sectors);
      });
    }
  });
}

void AtaDisk::Ata_PioWriteSectors(size_t sectors) {
  if (io_.lba_count == 0) {
    /* We might got here from IO request, end the command manually */
    EndCommand();
    return;
  }

  if (sectors > io_.lba_count) {
    sectors = io_.lba_count;
  }

  size_t position = io_.lba_block * geometry_.sector_size;
  size_t remain_bytes = sectors * geometry_.sector_size;
  size_t length = remain_bytes < io_.buffer_size ? remain_bytes : io_.buffer_size;
  io_.transfer_bytes = length;

  StartTransfer(kTransferDataToDevice, [this, position, length, sectors]() {
    ImageIoRequest request = {
      .type = kImageIoWrite,
      .position = position,
      .length = length
    };
    request.vector.emplace_back(iovec {
      .iov_base = io_.buffer,
      .iov_len = length
    });

    io_.lba_count -= sectors;
    io_.lba_block += sectors;
    io_async_ = true;

    image_->QueueIoRequest(request, [this, sectors](ssize_t ret) {
      if (ret <= 0) {
        task_file_->status |= ATA_CB_STAT_ERR;
        EndCommand();
      } else {
        WriteLba();
        Ata_PioWriteSectors(sectors);
      }
    });
  });
}


void AtaDisk::Ata_Trim() {
  if (io_.buffer_size == 0) {
    return;
  }

  size_t total_bytes = 0;
  struct Chunk {
    size_t position;
    size_t length;
  };

  std::vector<Chunk> chunks;
  for (size_t i = 0; i < io_.buffer_size / sizeof(uint64_t); i++) {
    uint64_t value = ((uint64_t*)io_.buffer)[i];
    size_t block = value & 0x0000FFFFFFFFFFFF;
    size_t count = value >> 48;
    if (count == 0) {
      continue;
    }
    if (block + count >= geometry_.total_sectors) {
      AbortCommand();
      return;
    }
    size_t length = count * geometry_.sector_size;
    chunks.push_back(Chunk {
      .position = block * geometry_.sector_size,
      .length = length
    });
    total_bytes += length;
  }

  std::vector<ImageIoRequest> requests;
  for (auto chunk : chunks) {
    io_async_ = true;
    requests.emplace_back(ImageIoRequest {
      .type = kImageIoDiscard,
      .position = chunk.position,
      .length = chunk.length
    });
    io_.transfer_bytes += chunk.length;
  }

  image_->QueueMultipleIoRequests(std::move(requests), [this](auto ret) {
    if (ret < 0) {
      task_file_->status |= ATA_CB_STAT_ERR;
    }
    EndCommand();
  });
}

void AtaDisk::Ata_IdentifyDevice() {
  uint16_t p[256] = { 0 };

  p[0] = 0x0040;
  p[1] = geometry_.cylinders_per_heads;
  p[3] = geometry_.heads;
  p[4] = 512 * geometry_.sectors_per_cylinder;
  p[5] = 512; /* Can we use larger sector size? */
  p[6] = geometry_.sectors_per_cylinder;
  padstr((char*)(p + 10), drive_info_.serial, 20);

  p[20] = 3; /* XXX: retired, remove ? */
  p[21] = 512; /* cache size in sectors */
  p[22] = 4; /* ecc bytes */
  padstr((char *)(p + 23), drive_info_.version, 8); /* firmware version */
  padstr((char *)(p + 27), drive_info_.model, 40); /* model */

  p[47] = 0x8000 | 16; /* Max multi sectors */

  p[48] = 1; /* dword I/O */
  p[49] = (1 << 11) | (1 << 9) | (1 << 8); /* DMA and LBA supported */
  p[51] = 0x200; /* PIO transfer cycle */
  p[52] = 0x200; /* DMA transfer cycle */
  p[53] = 1 | (1 << 1) | (1 << 2); /* words 54-58,64-70,88 are valid */
  p[54] = geometry_.cylinders_per_heads;
  p[55] = geometry_.heads;
  p[56] = geometry_.sectors_per_cylinder;
  
  uint oldsize = geometry_.cylinders_per_heads * geometry_.heads * geometry_.sectors_per_cylinder;
  p[57] = oldsize;
  p[58] = oldsize >> 16;
  if (multiple_sectors_)
      p[59] = 0x100 | multiple_sectors_;
  /* *(p + 60) := nb_sectors       -- see ide_identify_size */
  /* *(p + 61) := nb_sectors >> 16 -- see ide_identify_size */
  p[62] = 0x07; /* single word dma0-2 supported */
  p[63] = 0x07; /* mdma0-2 supported */
  p[64] = 0x03; /* pio3-4 supported */
  p[65] = 120;
  p[66] = 120;
  p[67] = 120;
  p[68] = 120;
  p[69] = (1 << 14); /* determinate TRIM behavior */

  /* NCQ supported */
  p[75] = 32 - 1; /* NCQ queues */
  p[76] = (1 << 8);

  p[80] = 0xf0; /* ata3 -> ata6 supported */
  p[81] = 0x16; /* conforms to ata5 */
  /* 14=NOP supported, 5=WCACHE supported, 0=SMART supported */
  p[82] = (1 << 14) | (1 << 5) | 0;
  /* 13=flush_cache_ext,12=flush_cache,10=lba48 */
  p[83] = (1 << 14) | (1 << 13) | (1 <<12) | (1 << 10);
  /* 14=set to 1, 8=has WWN, 1=SMART self test, 0=SMART error logging */
  if (drive_info_.world_wide_name) {
      p[84] = (1 << 14) | (1 << 8) | 0;
  } else {
      p[84] = (1 << 14) | 0;
  }
  /* 14 = NOP supported, 5=WCACHE enabled, 0=SMART feature set enabled */
  if (write_cache_) {
      p[85] = (1 << 14) | (1 << 5) | 1;
  } else {
      p[85] = (1 << 14) | 1;
  }
  /* 13=flush_cache_ext, 12=flush_cache, 10=lba48 */
  p[86] = (1 << 13) | (1 <<12) | (1 << 10);
  /* 14=set to 1, 8=has WWN, 1=SMART self test, 0=SMART error logging */
  if (drive_info_.world_wide_name) {
      p[87] = (1 << 14) | (1 << 8) | 0;
  } else {
      p[87] = (1 << 14) | 0;
  }
  p[88] = 0x3f | (1 << 13); /* udma5 set and supported */
  p[93] = 1 | (1 << 14) | 0x2000;

  /* p[106] = 0x6000 | get_physical_block_exp; */

  if (drive_info_.world_wide_name) {
      /* LE 16-bit words 111-108 contain 64-bit World Wide Name */
      p[108] = drive_info_.world_wide_name >> 48;
      p[109] = drive_info_.world_wide_name >> 32;
      p[110] = drive_info_.world_wide_name >> 16;
      p[111] = drive_info_.world_wide_name;
  }
  p[169] = 1; /* TRIM support */
  p[217] = 0; /* Nominal media rotation rate */

  /* update size */
  size_t nb_sectors_lba28 = geometry_.total_sectors;
  if (nb_sectors_lba28 >= 1 << 28) {
      nb_sectors_lba28 = (1 << 28) - 1;
  }
  p[60] = nb_sectors_lba28;
  p[61] = nb_sectors_lba28 >> 16;
  p[100] = geometry_.total_sectors;
  p[101] = geometry_.total_sectors >> 16;
  p[102] = geometry_.total_sectors >> 32;
  p[103] = geometry_.total_sectors >> 48;
  
  io_.transfer_bytes = io_.buffer_size < 512 ? io_.buffer_size : 512;
  memcpy(io_.buffer, p, io_.transfer_bytes);
  StartTransfer(kTransferDataToHost, []() {});
}

DECLARE_DEVICE(AtaDisk);

```

`devices/ahci/ata_disk.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AHCI_ATA_DISK_H
#define _MVISOR_DEVICES_AHCI_ATA_DISK_H

#include "ata_storage.h"


class AtaDisk : public AtaStorageDevice {
 public:
  AtaDisk();
  virtual void Connect();

 private:
  void ReadLba(LbaMode mode);
  void WriteLba();
  void Ata_IdentifyDevice();
  void Ata_DmaReadWriteSectors(bool is_write, size_t sectors);
  void Ata_PioReadSectors(size_t sectors);
  void Ata_PioWriteSectors(size_t sectors);
  void Ata_Trim();
};

#endif // _MVISOR_DEVICES_AHCI_ATA_DISK_H

```

`devices/ahci/ata_internal.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICE_ATA_INTERNAL_H
#define _MVISOR_DEVICE_ATA_INTERNAL_H

// ATA_CMD_IDENTIFY_PACKET and ATA_CMD_IDENTIFY return a buffer of 512 bytes called the identification space;
// the following definitions are used to read information from the identification space.

#define ATA_IDENT_DEVICETYPE   0
#define ATA_IDENT_CYLINDERS    2
#define ATA_IDENT_HEADS        6
#define ATA_IDENT_SECTORS      12
#define ATA_IDENT_SERIAL       20
#define ATA_IDENT_MODEL        54
#define ATA_IDENT_CAPABILITIES 98
#define ATA_IDENT_FIELDVALID   106
#define ATA_IDENT_MAX_LBA      120
#define ATA_IDENT_COMMANDSETS  164
#define ATA_IDENT_MAX_LBA_EXT  200

// When you select a drive, you should specify the interface type and whether it is the master or slave:

#define IDE_ATA        0x00
#define IDE_ATAPI      0x01
 
#define ATA_MASTER     0x00
#define ATA_SLAVE      0x01

// Task File is a range of 8 ports which are offsets from BAR0 (primary channel) and/or
// BAR2 (secondary channel). To exemplify:

// BAR0 + 0 is first port.
// BAR0 + 1 is second port.
// BAR0 + 2 is the third

#define ATA_REG_DATA       0x00
#define ATA_REG_ERROR      0x01
#define ATA_REG_FEATURES   0x01
#define ATA_REG_SECCOUNT0  0x02
#define ATA_REG_LBA0       0x03
#define ATA_REG_LBA1       0x04
#define ATA_REG_LBA2       0x05
#define ATA_REG_HDDEVSEL   0x06
#define ATA_REG_COMMAND    0x07
#define ATA_REG_STATUS     0x07
#define ATA_REG_SECCOUNT1  0x08
#define ATA_REG_LBA3       0x09
#define ATA_REG_LBA4       0x0A
#define ATA_REG_LBA5       0x0B

#define ATA_REG_CONTROL    0x02
#define ATA_REG_ALTSTATUS  0x02
#define ATA_REG_DEVADDRESS 0x03

// FROM SeaBIOS
#define PORT_ATA2_CMD_BASE     0x0170
#define PORT_ATA1_CMD_BASE     0x01f0
#define PORT_ATA2_CTRL_BASE    0x0374
#define PORT_ATA1_CTRL_BASE    0x03f4

// Global defines -- ATA register and register bits.
// command block & control block regs
#define ATA_CB_DATA  0   // data reg         in/out pio_base_addr1+0
#define ATA_CB_ERR   1   // error            in     pio_base_addr1+1
#define ATA_CB_FR    1   // feature reg         out pio_base_addr1+1
#define ATA_CB_SC    2   // sector count     in/out pio_base_addr1+2
#define ATA_CB_SN    3   // sector number    in/out pio_base_addr1+3
#define ATA_CB_CL    4   // cylinder low     in/out pio_base_addr1+4
#define ATA_CB_CH    5   // cylinder high    in/out pio_base_addr1+5
#define ATA_CB_DH    6   // device head      in/out pio_base_addr1+6
#define ATA_CB_STAT  7   // primary status   in     pio_base_addr1+7
#define ATA_CB_CMD   7   // command             out pio_base_addr1+7

#define ATA_CB_ASTAT 2   // alternate status in     pio_base_addr2+2
#define ATA_CB_DC    2   // device control      out pio_base_addr2+2
#define ATA_CB_DA    3   // device address   in     pio_base_addr2+3

#define ATA_CB_ER_ICRC 0x80    // ATA Ultra DMA bad CRC
#define ATA_CB_ER_BBK  0x80    // ATA bad block
#define ATA_CB_ER_UNC  0x40    // ATA uncorrected error
#define ATA_CB_ER_MC   0x20    // ATA media change
#define ATA_CB_ER_IDNF 0x10    // ATA id not found
#define ATA_CB_ER_MCR  0x08    // ATA media change request
#define ATA_CB_ER_ABRT 0x04    // ATA command aborted
#define ATA_CB_ER_NTK0 0x02    // ATA track 0 not found
#define ATA_CB_ER_NDAM 0x01    // ATA address mark not found

#define ATA_CB_ER_P_SNSKEY 0xf0   // ATAPI sense key (mask)
#define ATA_CB_ER_P_MCR    0x08   // ATAPI Media Change Request
#define ATA_CB_ER_P_ABRT   0x04   // ATAPI command abort
#define ATA_CB_ER_P_EOM    0x02   // ATAPI End of Media
#define ATA_CB_ER_P_ILI    0x01   // ATAPI Illegal Length Indication

// ATAPI Interrupt Reason bits in the Sector Count reg (CB_SC)
#define ATA_CB_SC_P_TAG    0xf8   // ATAPI tag (mask)
#define ATA_CB_SC_P_REL    0x04   // ATAPI release
#define ATA_CB_SC_P_IO     0x02   // ATAPI I/O
#define ATA_CB_SC_P_CD     0x01   // ATAPI C/D

// bits 7-4 of the device/head (CB_DH) reg
#define ATA_CB_DH_DEV0 0xa0    // select device 0
#define ATA_CB_DH_DEV1 0xb0    // select device 1
#define ATA_CB_DH_LBA 0x40    // use LBA

// status reg (CB_STAT and CB_ASTAT) bits
#define ATA_CB_STAT_BSY  0x80  // busy
#define ATA_CB_STAT_RDY  0x40  // ready
#define ATA_CB_STAT_DF   0x20  // device fault
#define ATA_CB_STAT_WFT  0x20  // write fault (old name)
#define ATA_CB_STAT_SKC  0x10  // seek complete
#define ATA_CB_STAT_SERV 0x10  // service
#define ATA_CB_STAT_DRQ  0x08  // data request
#define ATA_CB_STAT_CORR 0x04  // corrected
#define ATA_CB_STAT_IDX  0x02  // index
#define ATA_CB_STAT_ERR  0x01  // error (ATA)
#define ATA_CB_STAT_CHK  0x01  // check (ATAPI)

// device control reg (CB_DC) bits
#define ATA_CB_DC_HD15   0x08  // bit should always be set to one
#define ATA_CB_DC_SRST   0x04  // soft reset
#define ATA_CB_DC_NIEN   0x02  // disable interrupts

// Most mandtory and optional ATA commands (from ATA-3),
#define ATA_CMD_NOP                          0x00
#define ATA_CMD_CFA_REQUEST_EXT_ERR_CODE     0x03
#define ATA_CMD_DEVICE_RESET                 0x08
#define ATA_CMD_RECALIBRATE                  0x10
#define ATA_CMD_READ_SECTORS                 0x20
#define ATA_CMD_READ_SECTORS_EXT             0x24
#define ATA_CMD_READ_DMA_EXT                 0x25
#define ATA_CMD_READ_DMA_QUEUED_EXT          0x26
#define ATA_CMD_READ_NATIVE_MAX_ADDRESS_EXT  0x27
#define ATA_CMD_READ_MULTIPLE_EXT            0x29
#define ATA_CMD_READ_LOG_EXT                 0x2F
#define ATA_CMD_WRITE_SECTORS                0x30
#define ATA_CMD_WRITE_SECTORS_EXT            0x34
#define ATA_CMD_WRITE_DMA_EXT                0x35
#define ATA_CMD_WRITE_DMA_QUEUED_EXT         0x36
#define ATA_CMD_SET_MAX_ADDRESS_EXT          0x37
#define ATA_CMD_CFA_WRITE_SECTORS_WO_ERASE   0x38
#define ATA_CMD_WRITE_MULTIPLE_EXT           0x39
#define ATA_CMD_WRITE_VERIFY                 0x3C
#define ATA_CMD_WRITE_LOG_EXT                0x3F
#define ATA_CMD_READ_VERIFY_SECTORS          0x40
#define ATA_CMD_READ_VERIFY_SECTORS_EXT      0x42
#define ATA_CMD_FORMAT_TRACK                 0x50
#define ATA_CMD_SEEK                         0x70
#define ATA_CMD_CFA_TRANSLATE_SECTOR         0x87
#define ATA_CMD_EXECUTE_DEVICE_DIAGNOSTIC    0x90
#define ATA_CMD_INITIALIZE_DEVICE_PARAMETERS 0x91
#define ATA_CMD_STANDBY_IMMEDIATE2           0x94
#define ATA_CMD_IDLE_IMMEDIATE2              0x95
#define ATA_CMD_STANDBY2                     0x96
#define ATA_CMD_IDLE2                        0x97
#define ATA_CMD_CHECK_POWER_MODE2            0x98
#define ATA_CMD_SLEEP2                       0x99
#define ATA_CMD_PACKET                       0xA0
#define ATA_CMD_IDENTIFY_PACKET_DEVICE       0xA1
#define ATA_CMD_CFA_ERASE_SECTORS            0xC0
#define ATA_CMD_READ_MULTIPLE                0xC4
#define ATA_CMD_WRITE_MULTIPLE               0xC5
#define ATA_CMD_SET_MULTIPLE_MODE            0xC6
#define ATA_CMD_READ_DMA_QUEUED              0xC7
#define ATA_CMD_READ_DMA                     0xC8
#define ATA_CMD_WRITE_DMA                    0xCA
#define ATA_CMD_WRITE_DMA_QUEUED             0xCC
#define ATA_CMD_CFA_WRITE_MULTIPLE_WO_ERASE  0xCD
#define ATA_CMD_STANDBY_IMMEDIATE            0xE0
#define ATA_CMD_IDLE_IMMEDIATE               0xE1
#define ATA_CMD_STANDBY                      0xE2
#define ATA_CMD_IDLE                         0xE3
#define ATA_CMD_READ_BUFFER                  0xE4
#define ATA_CMD_CHECK_POWER_MODE             0xE5
#define ATA_CMD_SLEEP                        0xE6
#define ATA_CMD_FLUSH_CACHE                  0xE7
#define ATA_CMD_WRITE_BUFFER                 0xE8
#define ATA_CMD_IDENTIFY_DEVICE              0xEC
#define ATA_CMD_SET_FEATURES                 0xEF
#define ATA_CMD_READ_NATIVE_MAX_ADDRESS      0xF8
#define ATA_CMD_SET_MAX                      0xF9

#define ATA_SET_FEATRUE_TRANSFER_MODE        0x03
#define ATA_TRANSFER_MODE_ULTRA_DMA          0x40
#define ATA_TRANSFER_MODE_MULTIWORD_DMA      0x20
#define ATA_TRANSFER_MODE_PIO_FLOW_CTRL      0x08
#define ATA_TRANSFER_MODE_DEFAULT_PIO        0x00

inline static const char* __get_register_name(size_t index) {
  static const char* names[] = {
    "ATA_REG_DATA",
    "ATA_REG_ERROR/ATA_REG_FEATURES",
    "ATA_REG_SECCOUNT0",
    "ATA_REG_LBA0",
    "ATA_REG_LBA1",
    "ATA_REG_LBA2",
    "ATA_REG_HDDEVSEL",
    "ATA_REG_COMMAND",
    "ATA_REG_STATUS",
    "ATA_REG_SECCOUNT1",
    "ATA_REG_LBA3",
    "ATA_REG_LBA4",
    "ATA_REG_LBA5",
    "ATA_REG_CONTROL",
    "ATA_REG_ALTSTATUS",
    "ATA_REG_DEVADDRESS"
  };
  size_t max_index = (sizeof(names) / sizeof(names[0]));
  return index < max_index ? names[index] : "INVALID";
}

// Channels:
#define      ATA_PRIMARY      0x00
#define      ATA_SECONDARY    0x01
 
// Directions:
#define      ATA_READ      0x00
#define      ATA_WRITE     0x01


// SCSI

struct CBD_RW_DATA10 {
    uint8_t command;
    uint8_t flags;
    uint32_t lba;
    uint8_t resreved_06;
    uint16_t count;
    uint8_t reserved_09;
    uint8_t pad[6];
} __attribute__((packed));


struct CBD_READ_CAPACITY {
    uint8_t command;
    uint8_t flags;
    uint8_t resreved_02[8];
    uint8_t pad[6];
} __attribute__((packed));

struct CBD_RES_READ_CAPACITY {
    uint32_t sectors;
    uint32_t blksize;
} __attribute__((packed));


struct CBD_REQUEST_SENSE {
    uint8_t command;
    uint8_t flags;
    uint16_t reserved_02;
    uint8_t length;
    uint8_t reserved_05;
    uint8_t pad[10];
} __attribute__((packed));

struct CBD_RES_REQUEST_SENSE {
    uint8_t errcode;
    uint8_t segment;
    uint8_t flags;
    uint32_t info;
    uint8_t additional;
    uint32_t specific;
    uint8_t asc;
    uint8_t ascq;
    uint32_t reserved_0e;
} __attribute__((packed));

#define SCSI_TYPE_DISK  0x00
#define SCSI_TYPE_CDROM 0x05

struct CBD_RES_INQUERY {
    uint8_t pdt;
    uint8_t removable;
    uint8_t reserved_02[2];
    uint8_t additional;
    uint8_t reserved_05[3];
    char vendor[8];
    char product[16];
    char rev[4];
} __attribute__((packed));

#define MODE_PAGE_HD_GEOMETRY 0x04

struct CBD_MODE_SENSE {
    uint8_t command;
    uint8_t flags;
    uint8_t page;
    uint32_t reserved_03;
    uint16_t count;
    uint8_t reserved_09;
    uint8_t pad[6];
} __attribute__((packed));

struct CBD_RES_MODE_SENSE_GEOM {
    uint8_t unused_00[3];
    uint8_t read_only;
    uint32_t unused_04;
    uint8_t page;
    uint8_t length;
    uint8_t cyl[3];
    uint8_t heads;
    uint8_t precomp[3];
    uint8_t reduced[3];
    uint16_t step_rate;
    uint8_t landing[3];
    uint16_t rpm;
} __attribute__((packed));

/* The generic packet command opcodes for CD/DVD Logical Units,
 * From Table 57 of the SFF8090 Ver. 3 (Mt. Fuji) draft standard. */
#define GPCMD_BLANK          0xa1
#define GPCMD_CLOSE_TRACK        0x5b
#define GPCMD_FLUSH_CACHE        0x35
#define GPCMD_FORMAT_UNIT        0x04
#define GPCMD_GET_CONFIGURATION        0x46
#define GPCMD_GET_EVENT_STATUS_NOTIFICATION 0x4a
#define GPCMD_GET_PERFORMANCE        0xac
#define GPCMD_INQUIRY          0x12
#define GPCMD_LOAD_UNLOAD        0xa6
#define GPCMD_MECHANISM_STATUS        0xbd
#define GPCMD_MODE_SELECT_10        0x55
#define GPCMD_MODE_SENSE_10        0x5a
#define GPCMD_PAUSE_RESUME        0x4b
#define GPCMD_PLAY_AUDIO_10        0x45
#define GPCMD_PLAY_AUDIO_MSF        0x47
#define GPCMD_PLAY_AUDIO_TI        0x48
#define GPCMD_PLAY_CD          0xbc
#define GPCMD_PREVENT_ALLOW_MEDIUM_REMOVAL  0x1e
#define GPCMD_READ_10          0x28
#define GPCMD_READ_12          0xa8
#define GPCMD_READ_CDVD_CAPACITY      0x25
#define GPCMD_READ_CD          0xbe
#define GPCMD_READ_CD_MSF        0xb9
#define GPCMD_READ_DISC_INFO        0x51
#define GPCMD_READ_DVD_STRUCTURE      0xad
#define GPCMD_READ_FORMAT_CAPACITIES      0x23
#define GPCMD_READ_HEADER        0x44
#define GPCMD_READ_TRACK_RZONE_INFO      0x52
#define GPCMD_READ_SUBCHANNEL        0x42
#define GPCMD_READ_TOC_PMA_ATIP        0x43
#define GPCMD_REPAIR_RZONE_TRACK      0x58
#define GPCMD_REPORT_KEY        0xa4
#define GPCMD_REQUEST_SENSE        0x03
#define GPCMD_RESERVE_RZONE_TRACK      0x53
#define GPCMD_SCAN          0xba
#define GPCMD_SEEK          0x2b
#define GPCMD_SEND_DVD_STRUCTURE      0xad
#define GPCMD_SEND_EVENT        0xa2
#define GPCMD_SEND_KEY          0xa3
#define GPCMD_SEND_OPC          0x54
#define GPCMD_SET_READ_AHEAD        0xa7
#define GPCMD_SET_STREAMING        0xb6
#define GPCMD_START_STOP_UNIT        0x1b
#define GPCMD_STOP_PLAY_SCAN        0x4e
#define GPCMD_TEST_UNIT_READY        0x00
#define GPCMD_VERIFY_10          0x2f
#define GPCMD_WRITE_10          0x2a
#define GPCMD_WRITE_AND_VERIFY_10      0x2e

/* This is listed as optional in ATAPI 2.6, but is (curiously)
 * missing from Mt. Fuji, Table 57.  It _is_ mentioned in Mt. Fuji
 * Table 377 as an MMC command for SCSi devices though...  Most ATAPI
 * drives support it. */
#define GPCMD_SET_SPEED          0xbb
/* This seems to be a SCSI specific CD-ROM opcode
 * to play data at track/index */
#define GPCMD_PLAYAUDIO_TI        0x48
/*
 * From MS Media Status Notification Support Specification. For
 * older drives only.
 */
#define GPCMD_GET_MEDIA_STATUS        0xda
#define GPCMD_MODE_SENSE_6        0x1a


#endif // _MVISOR_DEVICE_ATA_INTERNAL_H

```

`devices/ahci/ata_storage.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_storage.h"

#include <cstring>

#include "logger.h"
#include "device_manager.h"
#include "ahci_port.h"


AtaStorageDevice::AtaStorageDevice() {
  set_default_parent_class("Ich9Ahci", "Piix3Ide");

  image_ = nullptr;
  bzero(&drive_info_, sizeof(drive_info_));
  bzero(&geometry_, sizeof(geometry_));

  multiple_sectors_ = 16;

  ata_handlers_[0x00] = [=] () { // NOP
    MV_PANIC("nop");
  };
  
  ata_handlers_[0x08] = [=] () { // ATA_CMD_DEVICE_RESET
    SetSignature(task_file_);
    task_file_->status |= ATA_CB_STAT_BSY;
  };
  
  ata_handlers_[0x2F] = [=] () { // READ_LOG
    AbortCommand();
  };

  ata_handlers_[0xE0] = [=] () { // STANDBYNOW1
  };
  
  ata_handlers_[0xEF] = [=] () { // ATA_CMD_SET_FEATURES
    Ata_SetFeatures();
  };
}

void AtaStorageDevice::Disconnect() {
  if (image_) {
    delete image_;
    image_ = nullptr;
  }
  Device::Disconnect();
}

void AtaStorageDevice::Connect() {
  Device::Connect();

  /* Connect to backend image */
  bool readonly = has_key("readonly") && std::get<bool>(key_values_["readonly"]);
  bool snapshot = has_key("snapshot") && std::get<bool>(key_values_["snapshot"]);
  if (type_ == kAtaStorageTypeCdrom) {
    readonly = true;
  }
  if (has_key("image")) {
    auto path = std::get<std::string>(key_values_["image"]);
    image_ = DiskImage::Create(this, path, readonly, snapshot);
  }
}

/* Windows checks CD-Rom status every second. It wastes CPU cycles.
 * We return false if image is not inserted but OS cannot detect the device at all.
 * Maybe we should support IDE hotplug?
 */
bool AtaStorageDevice::IsAvailable() {
  return image_ != nullptr;
}

void AtaStorageDevice::WaitForDma(VoidCallback dma_cb) {
  io_async_ = true;
  io_.dma_enabled = true;
  io_.dma_callback = std::move(dma_cb);
  port_->OnDmaPrepare();
}

void AtaStorageDevice::StartTransfer(TransferType type, VoidCallback end_cb) {
  io_async_ = true;
  io_.type = type;

  end_transfer_callback_ = std::move(end_cb);

  /* We remove BSY from status here, ensure that OS cannot touch the status until
   * the transfer function completes */
  MV_ASSERT(task_file_->status & ATA_CB_STAT_BSY);
  task_file_->status = (task_file_->status | ATA_CB_STAT_SKC | ATA_CB_STAT_DRQ) & ~ATA_CB_STAT_BSY;

  if (type != kTransferAtapiCommand && io_.dma_enabled) {
    // MV_LOG("%x DMA transfer data %lu status %x", task_file_->command, io_.transfer_bytes, task_file_->status);
    port_->OnDmaTransfer();
  } else {
    // MV_LOG("%x PIO transfer data %lu status %x", task_file_->command, io_.transfer_bytes, task_file_->status);
    port_->OnPioTransfer();
  }
}

void AtaStorageDevice::StopTransfer() {
  io_async_ = false;
  io_.transfer_bytes = 0;

  MV_ASSERT(task_file_->status & ATA_CB_STAT_DRQ);
  task_file_->status = (task_file_->status | ATA_CB_STAT_BSY) & ~ATA_CB_STAT_DRQ;

  auto cb = std::move(end_transfer_callback_);
  cb();

  if (!io_async_ && (task_file_->status & ATA_CB_STAT_BSY)) {
    EndCommand();
  }
}

void AtaStorageDevice::EndCommand() {
  MV_ASSERT(task_file_->status & ATA_CB_STAT_BSY);

  task_file_->status &= ~ATA_CB_STAT_BSY;
  port_->OnCommandDone();
}

bool AtaStorageDevice::StartCommand(TaskFile* tf) {
  MV_ASSERT(IsAvailable());

  task_file_ = tf;
  task_file_->error = 0;
  task_file_->status = ATA_CB_STAT_RDY | ATA_CB_STAT_BSY;

  io_.dma_enabled = false;
  io_.transfer_bytes = 0;
  io_async_ = false;

  auto handler = ata_handlers_[task_file_->command];
  if (handler) {
    handler();
  } else {
    AbortCommand();
    if (debug_) {
      MV_ERROR("%s unknown command 0x%x", name_, task_file_->command);
    }
  }

  if (!io_async_ && (task_file_->status & ATA_CB_STAT_BSY)) {
    EndCommand();
  }
  return io_async_;
}

/* Set Error and end this command */
void AtaStorageDevice::AbortCommand() {
  task_file_->status |= ATA_CB_STAT_ERR;
  task_file_->error = ATA_CB_ER_ABRT;
}

void AtaStorageDevice::Reset() {
  Device::Reset();

  if (type_ == kAtaStorageTypeCdrom) {
    io_.pio_buffer_size = 2048;
  } else {
    io_.pio_buffer_size = 512;
  }
}

void AtaStorageDevice::SetSignature(TaskFile* tf) {
  tf->device &= ~0xF;
  tf->count0 = 1;
  tf->lba0 = 1;
  tf->error = 1;
  if (type_ == kAtaStorageTypeCdrom) {
    tf->lba1 = 0x14;
    tf->lba2 = 0xEB;
    tf->status = 0;
  } else if (image_) {
    tf->lba1 = 0;
    tf->lba2 = 0;
    tf->status = ATA_CB_STAT_RDY | ATA_CB_STAT_SKC;
  } else {
    tf->lba1 = 0xFF;
    tf->lba2 = 0xFF;
  }
}

void AtaStorageDevice::Ata_SetFeatures() {
  switch (task_file_->feature0)
  {
  case 0x02: // enable write cache
    write_cache_ = true;
    break;
  case 0x82: // disable write cache
    write_cache_ = false;
    break;
  case 0x03: { // set transfer mode
    switch (task_file_->count0 >> 3)
    {
    case 0: // PIO default
    case 1: // PIO
      io_.dma_mode = kPioMode;
      break;
    case 2: // Single world DMA
      io_.dma_mode = kSingleWordDmaMode;
      break;
    case 4: // MDMA
      io_.dma_mode = kMDmaMode;
      break;
    case 8: // UDMA
      io_.dma_mode = kUDmaMode;
      break;
    default:
      MV_PANIC("unknown trasfer mode 0x%x", task_file_->count0);
      break;
    }
    if (debug_) {
      MV_LOG("switch to DMA mode 0x%x", io_.dma_mode);
    }
    break;
  }
  case 0xcc: /* reverting to power-on defaults enable */
  case 0x66: /* reverting to power-on defaults disable */
    break;
  default:
    MV_ERROR("unknown set features 0x%x", task_file_->feature0);
    AbortCommand();
    return;
  }
  
  /* success */
  task_file_->status |= ATA_CB_STAT_SKC;
}


```

`devices/ahci/ata_storage.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AHCI_ATA_STORAGE_H
#define _MVISOR_DEVICES_AHCI_ATA_STORAGE_H

#include "device.h"
#include "disk_image.h"

#include <sys/uio.h>
#include <vector>
#include <functional>

#include "ata_internal.h"

enum LbaMode {
  kLbaModeChs,
  kLbaMode28,
  kLbaMode48
};

enum DmaMode {
  kPioMode            = 1,
  kSingleWordDmaMode  = 2,
  kMDmaMode           = 4,
  kUDmaMode           = 8
};

struct TaskFile
{
  uint8_t feature0;
  uint8_t feature1;
  
  uint8_t count0;
  uint8_t count1;
  uint8_t lba0;
  uint8_t lba1;
  uint8_t lba2;
  uint8_t lba3;
  uint8_t lba4;
  uint8_t lba5;

  uint8_t device;
  uint8_t command;

  uint8_t control;

  uint8_t error;
  uint8_t status;
} __attribute__((packed));


enum TransferType {
  kTransferAtapiCommand,
  kTransferDataToDevice,
  kTransferDataToHost
};

struct AtaIo {
  TransferType      type;
  size_t            buffer_size;
  uint8_t*          buffer;
  std::vector<iovec>vector;
  LbaMode           lba_mode;
  size_t            lba_count;
  size_t            lba_block;
  bool              dma_enabled;
  DmaMode           dma_mode;
  VoidCallback      dma_callback;
  size_t            pio_buffer_size;
  size_t            transfer_bytes;
  uint8_t           atapi_command[12];
  bool              atapi_set;
};

struct AtaDriveInfo {
  char serial[21];
  char model[41];
  char version[41];
  uint64_t world_wide_name;
};

struct AtaStorageGeometry {
  size_t sector_size;
  size_t total_sectors;
  size_t sectors_per_cylinder;
  size_t cylinders_per_heads;
  size_t heads;
};

enum AtaStorageType {
  kAtaStorageTypeDisk,
  kAtaStorageTypeCdrom
};

typedef std::function<void(void)> VoidCallback;

class AtaPort {
 public:
  virtual void OnDmaPrepare() = 0;
  virtual void OnDmaTransfer() = 0;
  virtual void OnPioTransfer() = 0;
  virtual void OnCommandDone() = 0;
  virtual ~AtaPort() = default;
};

class AtaStorageDevice : public Device {
 public:
  AtaStorageDevice();
  virtual void Connect();
  virtual void Disconnect();
  virtual void Reset();
  bool IsAvailable();

  virtual void SetSignature(TaskFile* task_file);
  virtual bool StartCommand(TaskFile* task_file);
  virtual void AbortCommand();
  virtual void EndCommand();

  virtual void StartTransfer(TransferType type, VoidCallback end_cb);
  virtual void StopTransfer();
  virtual void WaitForDma(VoidCallback dma_cb);

  inline AtaStorageType     type() { return type_; }
  inline AtaIo*             io() { return &io_; }
  inline void               set_port(AtaPort* port) { port_ = port; }
  inline DiskImage*         image() { return image_; }
  const AtaStorageGeometry& geometry() const { return geometry_; }

 protected:
  virtual void Ata_SetFeatures();

  AtaPort*            port_ = nullptr;
  DiskImage*          image_ = nullptr;
  TaskFile*           task_file_ = nullptr;
  AtaIo               io_;

  AtaStorageType      type_; /* disk or cdrom */

  AtaDriveInfo        drive_info_;
  VoidCallback        ata_handlers_[256];
  bool                write_cache_ = true;
  bool                io_async_ = false;
  VoidCallback        end_transfer_callback_;
  int                 multiple_sectors_;
  AtaStorageGeometry  geometry_;
};


#endif // _MVISOR_DEVICES_AHCI_ATA_STORAGE_H

```

`devices/ahci/ich9_ahci.cc`:

```cc
/* 
 * MVisor - AHCI Host Controller
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ahci_host.h"

class Ich9Ahci : public AhciHost {
 public:
  Ich9Ahci() {
    slot_ = 31;
    function_ =  2;
    
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x2922;
  }
};

DECLARE_DEVICE(Ich9Ahci);

```

`devices/ahci/ide_cdrom.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_cdrom.h"

class IdeCdrom: public AtaCdrom {
 public:
  IdeCdrom() {
    set_default_parent_class("Piix3Ide");
  }
};

DECLARE_DEVICE(IdeCdrom);

```

`devices/ahci/ide_disk.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ata_disk.h"

class IdeDisk: public AtaDisk {
 public:
  IdeDisk() {
    set_default_parent_class("Piix3Ide");
  }
};

DECLARE_DEVICE(IdeDisk);

```

`devices/ahci/ide_host.cc`:

```cc
/* 
 * MVisor - IDE Host Controller
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ide_host.h"

#include <sys/ioctl.h>
#include <cstring>

#include "logger.h"
#include "device_manager.h"
#include "device_interface.h"
#include "ata_storage.h"
#include "ata_disk.h"

/* Reference:
 * https://wiki.osdev.org/PCI_IDE_Controller
 */

IdeHost::IdeHost() {
  /* IDE controller, primary and secondary channel in PCI native mode */
  pci_header_.class_code = 0x010180;
  pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;
  pci_header_.status |= PCI_STATUS_FAST_BACK;

  /* IDE Bus master */
  AddPciBar(4, 16, kIoResourceTypePio);

  /* Legacy IDE ports */
  AddIoResource(kIoResourceTypePio, 0x01F0, 8, "IDE Primary");
  AddIoResource(kIoResourceTypePio, 0x0170, 8, "IDE Secondary");
  AddIoResource(kIoResourceTypePio, 0x03F6, 1, "IDE Primary Control");
  AddIoResource(kIoResourceTypePio, 0x0376, 1, "IDE Secondary Control");
}

IdeHost::~IdeHost() {
}

void IdeHost::Connect() {
  PciDevice::Connect();

  for (size_t i = 0; i < ports_.size(); i++) {
    ports_[i] = new IdePort(manager_, this, i);
  }

  /* Add storage devices.
   * Old OS like Win98 requires the CDRom attached to the slave drive */
  int disk_cables[4][2] = {{ 0, 0 }, { 1, 0 }, { 0, 1 }, { 1, 1 }};
  int cdrom_cables[4][2] = {{ 0, 1 }, { 1, 1 }, { 0, 0 }, { 1, 0 }};
  for (size_t i = 0; i < children_.size(); i++) {
    auto device = dynamic_cast<AtaStorageDevice*>(children_[i]);
    auto cables = device->type() == kAtaStorageTypeCdrom ? cdrom_cables : disk_cables;
    for (size_t j = 0; j < 4; j++) {
      if (ports_[cables[j][0]]->drives()[cables[j][1]] == nullptr) {
        ports_[cables[j][0]]->AttachDevice(device, cables[j][1]);
        break;
      }
    }
  }
}

void IdeHost::Disconnect() {
  for (size_t i = 0; i < ports_.size(); i++) {
    if (ports_[i]) {
      delete ports_[i];
      ports_[i] = nullptr;
    }
  }
  PciDevice::Disconnect();
}

bool IdeHost::SaveState(MigrationWriter* writer) {
  IdeHostState state;
  for (size_t i = 0; i < ports_.size(); i++) {
    auto port_state = state.add_ports();
    ports_[i]->SaveState(port_state);
  }
  writer->WriteProtobuf("IDE_HOST", state);
  return PciDevice::SaveState(writer);
}

bool IdeHost::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }

  IdeHostState state;
  if (!reader->ReadProtobuf("IDE_HOST", state)) {
    return false;
  }
  for (size_t i = 0; i < ports_.size(); i++) {
    auto &port_state = state.ports(i);
    ports_[i]->LoadState(&port_state);
  }
  return true;
}

void SetCmosDiskInformation(CmosDataInterface* cmos, int type_index, int info_index, AtaStorageDevice* drive) {
  auto disk = dynamic_cast<AtaDisk*>(drive);
  auto &info = disk->geometry();
  cmos->SetData(type_index, 47);
  cmos->SetData(info_index, info.cylinders_per_heads);
  cmos->SetData(info_index + 1, info.cylinders_per_heads >> 8);
  cmos->SetData(info_index + 2, info.heads);
  cmos->SetData(info_index + 3, 0xFF);
  cmos->SetData(info_index + 4, 0xFF);
  cmos->SetData(info_index + 5, 0xC0 | ((info.heads > 8) << 3));
  cmos->SetData(info_index + 6, info.cylinders_per_heads);
  cmos->SetData(info_index + 7, info.cylinders_per_heads >> 8);
  cmos->SetData(info_index + 8, info.sectors_per_cylinder);
}

void IdeHost::Reset() {
  PciDevice::Reset();

  for (size_t i = 0; i < ports_.size(); i++) {
    ports_[i]->Reset();
  }

  /* IDE disk information */
  auto cmos = dynamic_cast<CmosDataInterface*>(manager_->LookupDeviceByClass("Cmos"));
  if (cmos) {
    /* hard disk type and size */
    uint8_t value = 0;
    auto primary_drives = ports_[0]->drives();
    if (primary_drives[0] && primary_drives[0]->type() == kAtaStorageTypeDisk) {
      SetCmosDiskInformation(cmos, 0x19, 0x1B, primary_drives[0]);
      value |= 0xF0;
    }
    if (primary_drives[1] && primary_drives[1]->type() == kAtaStorageTypeDisk) {
      SetCmosDiskInformation(cmos, 0x1A, 0x24, primary_drives[1]);
      value |= 0x0F;
    }
    cmos->SetData(0x12, value);

    /* set ATA translation policy (XP needs this to boot) */
    value = 0;
    for (size_t i = 0; i < 4; i++) {
      auto drive = ports_[i / 2]->drives()[i % 2];
      if (drive && drive->type() == kAtaStorageTypeDisk) {
        value += 1 << (i * 2);
      }
    }
    cmos->SetData(0x39, value);
  }
}

void IdeHost::SetPortIrq(int index, uint level) {
  if (index == 0) {
    manager_->SetGsiLevel(14, level);
  } else if (index == 1) {
    manager_->SetGsiLevel(15, level);
  }
}

void IdeHost::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0x1F0) {
    ports_[0]->Read(offset, data, size);
  } else if (resource->base == 0x3F6) {
    ports_[0]->ReadControl(offset + 2, data, size);
  } else if (resource->base == 0x170) {
    ports_[1]->Read(offset, data, size);
  } else if (resource->base == 0x376) {
    ports_[1]->ReadControl(offset + 2, data, size);
  } else if (resource->base == pci_bars_[4].address) {
    uint index = offset / 8;
    ports_[index]->ReadBusMaster(offset % 8, data, size);
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

void IdeHost::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0x1F0) {
    ports_[0]->Write(offset, data, size);
  } else if (resource->base == 0x3F6) {
    ports_[0]->WriteControl(offset + 2, data, size);
  } else if (resource->base == 0x170) {
    ports_[1]->Write(offset, data, size);
  } else if (resource->base == 0x376) {
    ports_[1]->WriteControl(offset + 2, data, size);
  } else if (resource->base == pci_bars_[4].address) {
    uint index = offset / 8;
    ports_[index]->WriteBusMaster(offset % 8, data, size);
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

```

`devices/ahci/ide_host.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_IDE_HOST_H
#define _MVISOR_DEVICES_IDE_HOST_H

#include "pci_device.h"
#include "ide_port.h"
#include <array>

class IdeHost : public PciDevice {
 public:
  IdeHost();
  virtual ~IdeHost();

  virtual void Connect();
  virtual void Disconnect();
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Reset();

  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);

  void SetPortIrq(int index, uint level);

 private:
  std::array<IdePort*, 2>       ports_ = { 0 };
};

#endif // _MVISOR_DEVICES_IDE_HOST_H

```

`devices/ahci/ide_host.proto`:

```proto
syntax = "proto3";

message IdeHostState {
  message BusMaster {
    uint32  command           = 1;
    uint32  status            = 2;
    uint32  prdt_address      = 3;
  }

  message TaskFile {
    uint32 feature0   = 1;
    uint32 feature1   = 2;
    
    uint32 count0     = 3;
    uint32 count1     = 4;
    uint32 lba0       = 5;
    uint32 lba1       = 6;
    uint32 lba2       = 7;
    uint32 lba3       = 8;
    uint32 lba4       = 9;
    uint32 lba5       = 10;
  
    uint32 device     = 11;
    uint32 command    = 12;
  
    uint32 error      = 13;
    uint32 status     = 14;
  
    uint32 control    = 15;
  }

  message PortState {
    BusMaster           bus_master      = 1;
    repeated  TaskFile  task_files      = 2;
    bytes               buffer          = 3;
    uint32              buffer_position = 4;
    uint32              control         = 5;
    uint32              active_tf_index = 6;
  }

  repeated PortState    ports   = 1;
}

```

`devices/ahci/ide_port.cc`:

```cc
/* 
 * MVisor - Ide Port
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ide_port.h"

#include <sys/ioctl.h>
#include <cstring>

#include "logger.h"
#include "ide_host.h"
#include "ata_storage.h"
#include "ata_internal.h"
#include "device_manager.h"


IdePort::IdePort(DeviceManager* manager, IdeHost* host, int index)
  : manager_(manager), host_(host), port_index_(index)
{
  drives_[0] = nullptr;
  drives_[1] = nullptr;
}

IdePort::~IdePort() {
}

void IdePort::Reset() {
  for (uint i = 0; i < 2; i++) {
    bzero(&task_files_[i], sizeof(task_files_[i]));
  
    if (drives_[i]) {
      drives_[i]->Reset();
      drives_[i]->SetSignature(&task_files_[i]);
    }
  }

  active_tf_index_ = 0;
  bus_master_.command = 0;
  bus_master_.prdt_address = 0;
  bus_master_.status = 0;
}

void IdePort::AttachDevice(AtaStorageDevice* device, bool slave) {
  if (host_->debug()) {
    MV_LOG("attach %s to [%d,%d]", device->name(), port_index_, slave);
  }
  device->set_port(this);
  if (slave) {
    drives_[1] = device;
  } else {
    drives_[0] = device;
  }
}

void IdePort::SetIrq(uint level) {
  if (control_ & ATA_CB_DC_NIEN) {
    return;
  }

  if (level) {
    bus_master_.status |= BM_STATUS_INT;
  }
  host_->SetPortIrq(port_index_, level);
}

void IdePort::Write(uint64_t offset, uint8_t* data, uint32_t size) {
  auto tf = &task_files_[active_tf_index_];

  switch (offset)
  {
  case 0:
    MV_ASSERT(tf->status & ATA_CB_STAT_DRQ);
    WriteIoBuffer(data, size);
    break;
  case 1:
    task_files_[0].feature1 = task_files_[0].feature0;
    task_files_[1].feature1 = task_files_[1].feature0;
    task_files_[0].feature0 = data[0];
    task_files_[1].feature0 = data[0];
    break;
  case 2:
    task_files_[0].count1 = task_files_[0].count0;
    task_files_[1].count1 = task_files_[1].count0;
    task_files_[0].count0 = data[0];
    task_files_[1].count0 = data[0];
    break;
  case 3:
    task_files_[0].lba3 = task_files_[0].lba0;
    task_files_[1].lba3 = task_files_[1].lba0;
    task_files_[0].lba0 = data[0];
    task_files_[1].lba0 = data[0];
    break;
  case 4:
    task_files_[0].lba4 = task_files_[0].lba1;
    task_files_[1].lba4 = task_files_[1].lba1;
    task_files_[0].lba1 = data[0];
    task_files_[1].lba1 = data[0];
    break;
  case 5:
    task_files_[0].lba5 = task_files_[0].lba2;
    task_files_[1].lba5 = task_files_[1].lba2;
    task_files_[0].lba2 = data[0];
    task_files_[1].lba2 = data[0];
    break;
  case 6: // device select
    active_tf_index_ = (data[0] >> 4) & 1;
    task_files_[0].device = data[0];
    task_files_[1].device = data[0];
    break;
  case 7: // command
    tf->command = data[0];
    if (drives_[active_tf_index_]) {
      ExecuteCommand();
    }
    break;
  default:
    MV_PANIC("offset=%lx data=%x size=%x", offset, *data, size);
    break;
  }
}

void IdePort::Read(uint64_t offset, uint8_t* data, uint32_t size) {
  auto tf = &task_files_[active_tf_index_];

  /* If no drives, disable this port */
  if (!drives_[0] && !drives_[1]) {
    data[0] = 0;
    return;
  }

  switch (offset)
  {
  case 0:
    MV_ASSERT(tf->status & ATA_CB_STAT_DRQ);
    ReadIoBuffer(data, size);
    break;
  case 1:
    data[0] = tf->error;
    break;
  case 2:
    data[0] = tf->count0;
    break;
  case 3:
    data[0] = tf->lba0;
    break;
  case 4:
    data[0] = tf->lba1;
    break;
  case 5:
    data[0] = tf->lba2;
    break;
  case 6: // device select
    data[0] = tf->device;
    break;
  case 7: // status
    SetIrq(0);
    data[0] = tf->status;
    break;
  default:
    MV_PANIC("offset=%lx data=%x size=%x", offset, *data, size);
    break;
  }
}

void IdePort::ReadControl(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(size == 1);
  auto tf = &task_files_[active_tf_index_];

  /* If no drives, disable this port */
  if (!drives_[0] && !drives_[1]) {
    data[0] = 0;
    return;
  }

  if (offset == ATA_CB_ASTAT) {
    data[0] = tf->status;
  }
}

void IdePort::WriteControl(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(size == 1);

  if (offset == ATA_CB_DC) {
    control_ = data[0];
    if (control_ & ATA_CB_DC_SRST) {
      Reset();
    }
  }
}

void IdePort::ReadIoBuffer(uint8_t* data, uint32_t size) {
  auto io = drives_[active_tf_index_]->io();
  auto ptr = buffer_.data() + buffer_position_;
  switch (size)
  {
  case 1:
    *data = *ptr;
    break;
  case 2:
    *(uint16_t*)data = *(uint16_t*)ptr;
    break;
  case 4:
    *(uint32_t*)data = *(uint32_t*)ptr;
    break;
  }

  buffer_position_ += size;
  if (buffer_position_ >= io->transfer_bytes) {
    MV_ASSERT(buffer_position_ <= io->transfer_bytes);
    buffer_position_ = 0;
    drives_[active_tf_index_]->StopTransfer();
  }
}

void IdePort::WriteIoBuffer(uint8_t* data, uint32_t size) {
  auto io = drives_[active_tf_index_]->io();
  auto ptr = buffer_.data() + buffer_position_;
  switch (size)
  {
  case 1:
    *ptr = *data;
    break;
  case 2:
    *(uint16_t*)ptr = *(uint16_t*)data;
    break;
  case 4:
    *(uint32_t*)ptr = *(uint32_t*)data;
    break;
  }

  buffer_position_ += size;
  if (buffer_position_ >= io->transfer_bytes) {
    MV_ASSERT(buffer_position_ <= io->transfer_bytes);
    buffer_position_ = 0;
    drives_[active_tf_index_]->StopTransfer();
  }
}

void IdePort::ExecuteCommand() {
  auto io = drives_[active_tf_index_]->io();
  if (buffer_.size() != io->pio_buffer_size) {
    buffer_.resize(io->pio_buffer_size);
  }
  buffer_position_ = 0;

  io->buffer = (uint8_t*)buffer_.data();
  io->buffer_size = buffer_.size();
  io->vector.clear();
  io->vector.emplace_back(iovec {
    .iov_base = buffer_.data(),
    .iov_len = buffer_.size()
  });

  io->atapi_set = false;
  drives_[active_tf_index_]->StartCommand(&task_files_[active_tf_index_]);
}

void IdePort::OnDmaPrepare() {
  auto io = drives_[active_tf_index_]->io();
  if (bus_master_.status & BM_STATUS_RUNNING) {
    if (io->dma_enabled && io->dma_callback) {
      MV_ASSERT(!current_dma_vector_.empty());
      auto &front = current_dma_vector_.front();
      io->buffer = (uint8_t*)front.iov_base;
      io->buffer_size = front.iov_len;
      io->vector = current_dma_vector_;

      auto cb = std::move(io->dma_callback);
      cb();
    }
  }
}

void IdePort::OnDmaTransfer() {
  drives_[active_tf_index_]->StopTransfer();
}

void IdePort::OnPioTransfer() {
  /* FIXME: What if user changed active device while data is transferring??? */
  auto io = drives_[active_tf_index_]->io();

  /* ATAPI DMA transfer doesn't need this interrupt while transferring commands with PIO */
  if (io->type == kTransferAtapiCommand) {
    return;
  }

  SetIrq(1);
}

void IdePort::OnCommandDone() {
  auto io = drives_[active_tf_index_]->io();
  if (io->dma_enabled) {
    StopBusMasterDma();
  }

  SetIrq(1);
}

void IdePort::ReadBusMaster(uint64_t offset, uint8_t* data, uint32_t size) {
  switch (offset)
  {
  case 0: // command
    data[0] = bus_master_.command;
    break;
  case 2: // status
    data[0] = bus_master_.status;
    break;
  case 4: // prdt address
    *(uint32_t*)data = bus_master_.prdt_address;
    break;
  default:
    memset(data, 0xFF, size);
  }
}

void IdePort::WriteBusMaster(uint64_t offset, uint8_t* data, uint32_t size) {
  switch (offset)
  {
  case 0: // command
    if ((bus_master_.command ^ data[0]) & BM_CMD_START) {
      if (data[0] & BM_CMD_START) {
        StartBusMasterDma();
      } else {
        StopBusMasterDma();
      }
    }
    bus_master_.command = data[0] & 0x09;
    break;
  case 2: // status
    bus_master_.status = (data[0] & 0x60) | (bus_master_.status & 1) | (bus_master_.status & ~data[0] & 0x06);
    break;
  case 4: // prdt address
    bus_master_.prdt_address = *(uint32_t*)data;
    break;
  default:
    MV_PANIC("write offset=%lx data=%x size=%d", offset, *data, size);
    break;
  }
}

void IdePort::StartBusMasterDma() {
  current_dma_vector_.clear();

  auto manager = host_->manager();
  auto entry = (PhysicalRegionDescriptor*)manager->TranslateGuestMemory(bus_master_.prdt_address);
  while (true) {
    void* host = manager->TranslateGuestMemory(entry->physical_address);
    size_t length = entry->byte_count ? entry->byte_count : 65536;
    current_dma_vector_.emplace_back(iovec {
      .iov_base = host,
      .iov_len = length
    });
    if (entry->end_of_table) {
      break;
    }
    ++entry;
  }

  if (!(bus_master_.status & BM_STATUS_RUNNING)) {
    bus_master_.status |= BM_STATUS_RUNNING;
    OnDmaPrepare();
  }
}

void IdePort::StopBusMasterDma() {
  bus_master_.status &= ~BM_STATUS_RUNNING;
}

/* Called by IdeHost */
void IdePort::SaveState(IdeHostState_PortState* port_state) {
  auto bm = port_state->mutable_bus_master();
  bm->set_command(bus_master_.command);
  bm->set_status(bus_master_.status);
  bm->set_prdt_address(bus_master_.prdt_address);

  port_state->set_active_tf_index(active_tf_index_);
  port_state->set_control(control_);
  port_state->set_buffer_position(buffer_position_);
  port_state->set_buffer(buffer_);

  for (int i = 0; i < 2; i++) {
    auto tf = &task_files_[i];
    auto tfs = port_state->add_task_files();
    tfs->set_command(tf->command);
    tfs->set_control(tf->control);
    tfs->set_count0(tf->count0);
    tfs->set_count1(tf->count1);
    tfs->set_device(tf->device);
    tfs->set_error(tf->error);
    tfs->set_feature0(tf->feature0);
    tfs->set_feature1(tf->feature1);
    tfs->set_lba0(tf->lba0);
    tfs->set_lba1(tf->lba1);
    tfs->set_lba2(tf->lba2);
    tfs->set_lba3(tf->lba3);
    tfs->set_lba4(tf->lba4);
    tfs->set_lba5(tf->lba5);
    tfs->set_status(tf->status);
  }

}

void IdePort::LoadState(const IdeHostState_PortState* port_state) {
  auto &bm = port_state->bus_master();
  bus_master_.command = bm.command();
  bus_master_.status = bm.status();
  bus_master_.prdt_address = bm.prdt_address();

  active_tf_index_ = port_state->active_tf_index();
  control_ = port_state->control();
  buffer_position_ = port_state->buffer_position();
  buffer_ = port_state->buffer();

  for (int i = 0; i < 2; i++) {
    auto tf = &task_files_[i];
    auto &tfs = port_state->task_files(i);
    tf->command = tfs.command();
    tf->control = tfs.control();
    tf->count0 = tfs.count0();
    tf->count1 = tfs.count1();
    tf->device = tfs.device();
    tf->error = tfs.error();
    tf->feature0 = tfs.feature0();
    tf->feature1 = tfs.feature1();
    tf->lba0 = tfs.lba0();
    tf->lba1 = tfs.lba1();
    tf->lba2 = tfs.lba2();
    tf->lba3 = tfs.lba3();
    tf->lba4 = tfs.lba4();
    tf->lba5 = tfs.lba5();
    tf->status = tfs.status();
  }

  /* FIXME: should setup drive PIO, not finished now */
  for (int i = 0; i < 2; i++) {
    auto drive = drives_[i];
    if (drive) {
    }
  }
}

```

`devices/ahci/ide_port.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_IDE_PORT_H
#define _MVISOR_DEVICES_IDE_PORT_H

#include <deque>
#include <vector>

#include <cstdint>
#include "ata_storage.h"
#include "device.h"
#include "ide_host.pb.h"


#define BM_STATUS_RUNNING 0x01
#define BM_STATUS_ERROR   0x02
#define BM_STATUS_INT     0x04

#define BM_CMD_START      0x01
#define BM_CMD_READ       0x08

struct PhysicalRegionDescriptor
{
  uint32_t  physical_address;
  uint16_t  byte_count;
  uint16_t  reserved : 15;
  uint16_t  end_of_table : 1;
} __attribute__((packed));

struct IdeBusMaster {
  uint8_t   command;
  uint8_t   status;
  uint32_t  prdt_address;
};


class DeviceManager;
class IdeHost;
class IdePort : public AtaPort {
 public:
  IdePort(DeviceManager* manager, IdeHost* host, int index);
  virtual ~IdePort();

  void AttachDevice(AtaStorageDevice* device, bool slave);
  void Write(uint64_t offset, uint8_t* data, uint32_t size);
  void Read(uint64_t offset, uint8_t* data, uint32_t size);
  void WriteControl(uint64_t offset, uint8_t* data, uint32_t size);
  void ReadControl(uint64_t offset, uint8_t* data, uint32_t size);
  void Reset();
  void OnBusMasterDmaStart(std::deque<iovec>& buffers);
  void OnBusMasterDmaStop();

  void ReadBusMaster(uint64_t offset, uint8_t* data, uint32_t size);
  void WriteBusMaster(uint64_t offset, uint8_t* data, uint32_t size);

  /* Called by AtaStorage */
  virtual void OnDmaPrepare();
  virtual void OnDmaTransfer();
  virtual void OnPioTransfer();
  virtual void OnCommandDone();

  /* Called by IdeHost */
  void SaveState(IdeHostState_PortState* port_state);
  void LoadState(const IdeHostState_PortState* port_state);

  inline AtaStorageDevice** drives() { return drives_; } 

 private:
  DeviceManager*        manager_;
  IdeHost *             host_;
  int                   port_index_;
  AtaStorageDevice*     drives_[2];
  TaskFile              task_files_[2];
  uint                  active_tf_index_ = 0;
  std::string           buffer_;
  size_t                buffer_position_;
  uint8_t               control_ = 0;
  IdeBusMaster          bus_master_;
  std::vector<iovec>    current_dma_vector_;

  void StartBusMasterDma();
  void StopBusMasterDma();
  void ExecuteCommand();
  void ReadIoBuffer(uint8_t* data, uint32_t size);
  void WriteIoBuffer(uint8_t* data, uint32_t size);
  void SetIrq(uint level);
};

#endif // _MVISOR_DEVICES_IDE_PORT_H


```

`devices/ahci/meson.build`:

```build
mvisor_sources += files(
  'ahci_cdrom.cc',
  'ahci_disk.cc',
  'ahci_host.cc',
  'ahci_host.h',
  'ahci_internal.h',
  'ahci_port.cc',
  'ahci_port.h',
  'ata_internal.h',
  'ata_cdrom.cc',
  'ata_disk.cc',
  'ata_storage.cc',
  'ata_storage.h',
  'ich9_ahci.cc',
  'ide_cdrom.cc',
  'ide_disk.cc',
  'ide_host.cc',
  'ide_host.h',
  'ide_port.cc',
  'ide_port.h',
  'piix3_ide.cc'
)

proto_sources += proto_gen.process(
  'ahci_host.proto',
  'ata_cdrom.proto',
  'ide_host.proto'
)

```

`devices/ahci/piix3_ide.cc`:

```cc
/* 
 * MVisor - IDE Host Controller
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ide_host.h"

class Piix3Ide : public IdeHost {
 public:
  Piix3Ide() {
    slot_ = 1;
    function_ =  1;
    
    /* PIIX3-IDE */
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x7010;
  }
};

DECLARE_DEVICE(Piix3Ide);

```

`devices/audio/ac97.cc`:

```cc
/* 
 * MVisor AC97 Sound Card
 * Reference: https://wiki.osdev.org/AC97
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pci_device.h"
#include "device_interface.h"
#include "device_manager.h"
#include "ac97.pb.h"

/* Transfer status of bus master */
#define TS_HALTED               (1 << 0)
#define TS_END_OF_TRANSFER      (1 << 1)
#define TS_END_INTERRUPT        (1 << 2)
#define TS_COMPLETION_INTERRUPT (1 << 3)
#define TS_ERROR_INTERRUPT      (1 << 4)


struct Ac97Mixer {
  uint16_t  reset;
  uint16_t  master_volume_mute;
  uint16_t  headphone_volume_mute;
  uint16_t  master_volume_mono_mute;
  uint16_t  master_tone_rl;
  uint16_t  pc_beep_volume_mute;
  uint16_t  phone_volume_mute;
  uint16_t  mic_volume_mute;
  uint16_t  line_in_volume_mute;
  uint16_t  cd_volume_mute;
  uint16_t  video_volume_mute;
  uint16_t  aux_volume_mute;
  uint16_t  pcm_out_volume_mute;
  uint16_t  record_select;
  uint16_t  record_gain_mute;
  uint16_t  record_gain_mic_mute;
  uint16_t  general_purpose;
  uint16_t  control_3d;
  uint16_t  reserved;
  uint16_t  powerdown_ctrl_stat;
  uint16_t  extended_audio_id;
  uint16_t  extended_audio_ctrl_stat;
  uint16_t  pcm_front_dac_rate;
  uint16_t  pcm_surround_dac_rate;
  uint16_t  pcm_lfe_dac_rate;
  uint16_t  pcm_lr_adc_rate;
  uint16_t  mic_adc_rate;
  uint16_t  vendor_reserved[0x23];
  uint16_t  vendor_id1;
  uint16_t  vendor_id2;
};

struct Ac97BusMaster {
  uint32_t  bdl_address;
  uint8_t   bdl_current_index;
  uint8_t   bdl_last_valid_index;
  uint16_t  status;
  uint16_t  samples_left;
  uint8_t   bdl_prefetched_index;
  uint8_t   control;
} __attribute__((packed));

struct BufferDescriptor {
  uint32_t  data_address;
  uint16_t  samples;
  uint16_t  flags;
};


#define STREAM_FRAME_INTERVAL_MS    10

struct StreamState {
  uint              index;
  bool              output = false;
  bool              running = false;

  IoTimer*          timer = nullptr;
  IoTimePoint       start_time;
  size_t            position;
  size_t            bytes_per_second;
  size_t            bytes_per_frame;
  std::string       buffer;
  size_t            buffer_pointer = 0;
  BufferDescriptor* bdl_entries = nullptr;
  BufferDescriptor* bdl_current = nullptr;
  uint8_t*          bdl_current_data = nullptr;
};


class Ac97 : public PciDevice, public PlaybackInterface {
 private:
  Ac97Mixer                     mixer_;
  std::array<Ac97BusMaster, 3>  bus_masters_;
  std::array<StreamState, 3>    streams_;
  uint32_t                      global_control_;
  uint32_t                      global_status_;
  uint8_t                       codec_accessing_;
  std::vector<PlaybackListener> playback_listeners_;

 public:
  Ac97() {
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x2415;
    pci_header_.class_code = 0x040100;
    pci_header_.revision_id = 1;
    pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.irq_pin = 1;
    pci_header_.status |= PCI_STATUS_FAST_BACK;

    AddPciBar(0, 1024, kIoResourceTypePio); // Native Audio Mixer
    AddPciBar(1, 256, kIoResourceTypePio);  // Native Audio Bus Master

    MV_ASSERT(sizeof(Ac97Mixer) == 0x80);

    for (size_t i = 0; i < streams_.size(); i++) {
      auto stream = &streams_[i];
      stream->index = i;
      stream->output = i == 1;
      stream->bytes_per_second = 2LL * 2 * 48000;
      stream->bytes_per_frame = stream->bytes_per_second / (1000 / STREAM_FRAME_INTERVAL_MS);
      stream->buffer.resize(stream->bytes_per_frame);
      bzero(stream->buffer.data(), stream->buffer.size());
    }
  }

  void Disconnect() {
    Reset();
    PciDevice::Disconnect();
  }

  bool SaveState(MigrationWriter* writer) {
    Ac97State state;
    state.set_mixer(&mixer_, sizeof(mixer_));
    for (size_t i = 0; i < bus_masters_.size(); i++) {
      auto &bm = bus_masters_[i];
      auto p = state.add_bus_masters();
      p->set_bdl_address(bm.bdl_address);
      p->set_bdl_current_index(bm.bdl_current_index);
      p->set_bdl_last_valid_index(bm.bdl_last_valid_index);
      p->set_bdl_prefetched_index(bm.bdl_prefetched_index);
      p->set_status(bm.status);
      p->set_control(bm.control);
    }

    writer->WriteProtobuf("AC97", state);
    return PciDevice::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!PciDevice::LoadState(reader)) {
      return false;
    }

    Ac97State state;
    if (!reader->ReadProtobuf("AC97", state)) {
      return false;
    }
    memcpy(&mixer_, state.mixer().data(), sizeof(mixer_));

    for (int i = 0; i < state.bus_masters_size(); i++) {
      auto &bm = bus_masters_[i];
      auto p = state.bus_masters(i);
      bm.bdl_address = p.bdl_address();
      bm.bdl_current_index = p.bdl_current_index();
      bm.bdl_last_valid_index = p.bdl_last_valid_index();
      bm.bdl_prefetched_index = p.bdl_prefetched_index();
      bm.status = p.status();
      bm.control = p.control();

      if (bm.control & 1) {
        Schedule([this, i]() {
          SetStreamRunning(i, true);
        });
      }
    }

    return true;
  }

  void Reset() {
    PciDevice::Reset();

    for (size_t i = 0; i < streams_.size(); i++) {
      if (streams_[i].running) {
        SetStreamRunning(i, false);
      }
    }

    bzero(&bus_masters_, sizeof(bus_masters_));

    global_status_ = (1 << 8);  // codec 0 is ready
    global_control_ = 0;
    codec_accessing_ = 0;

    ResetMixer();
  }

  void ResetMixer() {
    bzero(&mixer_, sizeof(mixer_));
    mixer_.vendor_id1 = 0x8384;
    mixer_.vendor_id2 = 0x7600;
    mixer_.powerdown_ctrl_stat = 0x000F; // vRef Analog DAC ADC ready

    /* AC97 2.3 compliant (https://hands.com/~lkcl/ac97_r23.pdf)
     * variable sample rate is not supported yet */
    mixer_.extended_audio_id = 0x0800;
    mixer_.extended_audio_ctrl_stat = 0x0000;

    mixer_.pcm_front_dac_rate = 48000;
    mixer_.pcm_lr_adc_rate = 48000;
    mixer_.mic_adc_rate = 48000;

    mixer_.record_select = 0;
    mixer_.master_volume_mute = 0x8000;
    mixer_.pcm_out_volume_mute = 0x8808;
    mixer_.record_gain_mute = 0x8808;
    mixer_.line_in_volume_mute = 0x8808;
  }

  void NotifyPlayback(PlaybackState state, void* data, size_t length) {
    for (auto& cb : playback_listeners_) {
      cb(state, iovec {
        .iov_base = data,
        .iov_len = length
      });
    }
  }

  void GetPlaybackFormat(uint* format, uint* channels, uint* frequency, uint* interval_ms) {
    *format = 2;
    *channels = 2;
    *frequency = 48000;
    *interval_ms = STREAM_FRAME_INTERVAL_MS;
  }

  void RegisterPlaybackListener(PlaybackListener callback) {
    playback_listeners_.push_back(callback);
  }

  void GetVolume(uint16_t value, uint16_t mask, bool reverse, bool* mute, int* left, int* right) {
    *mute = (value >> 15) & 1;
    *right = 256 * (value & mask) / mask;
    *left = 256 * ((value >> 8) & mask) / mask;
    if (reverse) {
      *right = 256 - *right;
      *left = 256 - *left;
    }
  }

  void ApplyStreamVolume(StreamState* stream) {
    bool mute;
    int left, right;

    if (stream->output) {
      bool master_mute;
      int master_left, master_right;
      GetVolume(mixer_.master_volume_mute, 0x3F, true, &master_mute, &master_left, &master_right);
      GetVolume(mixer_.pcm_out_volume_mute, 0x1F, true, &mute, &left, &right);
      mute = mute || master_mute;
      left = left * master_left / 256;
      right = right * master_right / 256;
    } else {
      GetVolume(mixer_.line_in_volume_mute, 0x1F, false, &mute, &left, &right);
    }

    auto begin = (int16_t*)stream->buffer.data();
    auto end = (int16_t*)(stream->buffer.data() + stream->buffer_pointer);
    if (mute) {
      bzero(begin, stream->buffer_pointer);
    } else {
      for (auto ptr = begin; ptr < end; ptr += 2) {
        ptr[0] = (left * ptr[0]) >> 8;
        ptr[1] = (right * ptr[1]) >> 8;
      }
    }
  }

  void OnStreamTimer(StreamState* stream) {
    if (stream->output) {
      auto to_transfer = stream->buffer.size() - stream->buffer_pointer;
      auto ptr = (uint8_t*)&stream->buffer.data()[stream->buffer_pointer];
      size_t bytes = TransferData(stream->index, ptr, to_transfer);
      stream->position += bytes;
      stream->buffer_pointer += bytes;

      if (stream->buffer_pointer >= stream->buffer.size()) {
        ApplyStreamVolume(stream);
        NotifyPlayback(kPlaybackData, stream->buffer.data(), stream->buffer_pointer);
        stream->buffer_pointer = 0;
      }
    } else {
      /* input silence if record buffer is unavailable */
      TransferData(stream->index, (uint8_t*)stream->buffer.data(), stream->buffer.size());
      stream->position += stream->buffer.size();
    }

    auto started_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
      std::chrono::steady_clock::now() - stream->start_time).count();
    auto current_ms = stream->position * 1000 / stream->bytes_per_second;
    int64_t next_interval_ms = current_ms - started_ms;
    
    if (next_interval_ms < 1) {
      /* If we cannot catch up, reset timer */
      if (next_interval_ms < -100) {
        MV_LOG("stream[%d] reset timer, current_ms=%dms started_ms=%dms", stream->index, current_ms, started_ms);
        stream->position = 0;
        stream->start_time = std::chrono::steady_clock::now();
      } 
      next_interval_ms = 1;
    }

    int64_t next_interval_ns = 1000000LL * next_interval_ms;
    if (stream->timer->interval_ns != next_interval_ns) {
      ModifyTimer(stream->timer, next_interval_ns);
    }
  }

  void SetStreamRunning(uint index, bool running) {
    auto stream = &streams_[index];
    if (stream->running == running) {
      return;
    }
    if (debug_) {
      MV_LOG("set stream[%u] running=%d", index, running);
    }

    stream->running = running;
    if (running) {
      if (stream->output) {
        NotifyPlayback(kPlaybackStart, nullptr, 0);
      }

      ParseBufferDescriptorList(index);
      stream->position = 0;
      stream->start_time = std::chrono::steady_clock::now();
      MV_ASSERT(stream->timer == nullptr);
      stream->timer = AddTimer(1, true, [this, stream]() {
        OnStreamTimer(stream);
      });
    } else {
      MV_ASSERT(stream->timer);
      RemoveTimer(stream->timer);
      stream->timer = nullptr;

      if (stream->output) {
        NotifyPlayback(kPlaybackStop, nullptr, 0);
      }
    }
  }

  void CheckIrqLevel() {
    for (size_t i = 0; i < bus_masters_.size(); i++) {
      auto &bm = bus_masters_[i];
      uint int_mask = 1 << (i + 5);
      if ((bm.status & TS_END_INTERRUPT) && (bm.control & (1 << 2))) {
        global_status_ |= int_mask;
      } else if ((bm.status & TS_COMPLETION_INTERRUPT) && (bm.control & (1 << 4))){
        global_status_ |= int_mask;
      } else {
        global_status_ &= ~int_mask;
      }
    }

    uint level = !!(global_status_ & ((1 << 5) | (1 << 6) | (1 << 7)));
    SetIrq(level);
  }

  void PrefetchBuffer(uint index) {
    auto &bm = bus_masters_[index];
    auto stream = &streams_[index];

    if (bm.bdl_current_index == bm.bdl_last_valid_index) {
      bm.status |= TS_HALTED;
      return;
    }

    bm.bdl_current_index = bm.bdl_prefetched_index;
    bm.bdl_prefetched_index = (bm.bdl_prefetched_index + 1) % 32;

    auto &bdl_entry = stream->bdl_entries[bm.bdl_current_index];
    stream->bdl_current_data = (uint8_t*)manager_->TranslateGuestMemory(bdl_entry.data_address);
    bm.samples_left = bdl_entry.samples;
    bm.status &= ~TS_END_OF_TRANSFER;
    
    if (!stream->output) {
      manager_->AddDirtyMemory(bdl_entry.data_address, 2ul * bm.samples_left);
    }
  }

  size_t TransferData(uint index, uint8_t* destination, size_t length) {
    auto &bm = bus_masters_[index];
    auto stream = &streams_[index];

    if (bm.status & TS_HALTED) { // halted
      // MV_LOG("halted");
      return length;
    }

    bool interrupt = false;
    size_t copied = 0;
    while (copied < length && !interrupt) {
      size_t to_copy = length - copied;

      auto &bdl_entry = stream->bdl_entries[bm.bdl_current_index];

      if (to_copy > 2ul * bm.samples_left) {
        to_copy = 2ul * bm.samples_left;
      }

      /* IN or OUT */
      if (stream->output) {
        memcpy(&destination[copied], stream->bdl_current_data, to_copy);
      } else {
        memcpy(stream->bdl_current_data, &destination[copied], to_copy);
      }
      stream->bdl_current_data += to_copy;
      bm.samples_left -= to_copy >> 1;
      copied += to_copy;

      /* Check if we should read next buffer */
      if (bm.samples_left == 0) {
        if (bdl_entry.flags & (1 << 15)) {  // Interrupt on completion
          bm.status |= TS_COMPLETION_INTERRUPT;
          interrupt = true;
        }

        if (bm.bdl_current_index == bm.bdl_last_valid_index) {
          bm.status |= TS_HALTED | TS_END_OF_TRANSFER | TS_END_INTERRUPT;
          interrupt = true;
        } else {
          PrefetchBuffer(index);
        }
      }
    }

    if (interrupt) {
      CheckIrqLevel();
    }

    if (debug_) {
      MV_LOG("stream[%u] transfer data %lu/%lu", index, copied, length);
    }
    return copied;
  }

  void ParseBufferDescriptorList(uint index) {
    auto &bm = bus_masters_[index];
    auto stream = &streams_[index];
    stream->bdl_entries = (BufferDescriptor*)manager_->TranslateGuestMemory(bm.bdl_address);
    PrefetchBuffer(index);
  }

  void WriteMixer(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(size == 2);
    uint16_t value = *(uint16_t*)data;
    switch (offset)
    {
    case offsetof(Ac97Mixer, reset):
      ResetMixer();
      break;
    case offsetof(Ac97Mixer, master_volume_mute):
    case offsetof(Ac97Mixer, pcm_out_volume_mute):
    case offsetof(Ac97Mixer, line_in_volume_mute):
    case offsetof(Ac97Mixer, record_gain_mute):
      memcpy((uint8_t*)&mixer_ + offset, data, size);
      break;
    case offsetof(Ac97Mixer, record_select):
      if (debug_) {
        MV_LOG("record select value=0x%x", value);
      }
      break;
    case offsetof(Ac97Mixer, powerdown_ctrl_stat):
      mixer_.powerdown_ctrl_stat = (value & ~0x800F) | (mixer_.powerdown_ctrl_stat & 0xF);
      break;
    case offsetof(Ac97Mixer, extended_audio_ctrl_stat):
      mixer_.extended_audio_ctrl_stat = value;
      break;
    default:
      if (debug_) {
        MV_LOG("ignore write mixer offset=0x%lx data=%x size=%d", offset, value, size);
      }
    }
  }

  void WriteBusMaster(uint index, uint64_t offset, uint8_t* data, uint32_t size) {
    auto &bm = bus_masters_[index];
    switch (offset)
    {
    case offsetof(Ac97BusMaster, bdl_address):
      memcpy((uint8_t*)&bm + offset, data, size);
      break;
    case offsetof(Ac97BusMaster, bdl_last_valid_index):
      if ((bm.control & 1) && (bm.status & TS_HALTED)) {  // running but halted, try to restart
        PrefetchBuffer(index);
        bm.status &= ~(TS_HALTED | TS_END_OF_TRANSFER);
      }
      bm.bdl_last_valid_index = data[0] & 0x1F;
      break;
    case offsetof(Ac97BusMaster, status):
      bm.status &= ~(data[0] & (TS_END_INTERRUPT | TS_COMPLETION_INTERRUPT | TS_ERROR_INTERRUPT));
      CheckIrqLevel();
      break;
    case offsetof(Ac97BusMaster, control):
      if (data[0] & 2) { // reset bus master
        bm.bdl_address = 0;
        bm.bdl_current_index = 0;
        bm.bdl_last_valid_index = 0;
        bm.bdl_prefetched_index = 0;
        bm.samples_left = 0;
        bm.status = TS_HALTED;
        bm.control = bm.control & ~3;
        SetStreamRunning(index, false);
        CheckIrqLevel();
      } else {
        bm.control = data[0];
        if (data[0] & 1) {  // run
          bm.status &= ~TS_HALTED;
          SetStreamRunning(index, true);
        } else {  // stop
          SetStreamRunning(index, false);
          bm.status |= TS_HALTED;
        }
      }
      break;
    }
  }

  void ReadBusMasterControl(uint64_t offset, uint8_t* data, uint32_t size) {
    switch (offset)
    {
    case 0x00 ... 0x2B: {
      uint index = (offset >> 4) & 3;
      offset &= 0xF;
      memcpy(data, (uint8_t*)&bus_masters_[index] + offset, size);
      break;
    }
    case 0x2C:  // global control
      memcpy(data, &global_control_, size);
      break;
    case 0x30:  // global status
      memcpy(data, &global_status_, size);
      break;
    case 0x34:  // codec access semaphore (0: no access in progress 1: busy)
      data[0] = codec_accessing_;
      codec_accessing_ = 1;
      break;
    default:
      memset(data, 0xFF, size);
      MV_ERROR("unhandled read bus master offset=0x%lx size=%u", offset, size);
    }
  }

  void WriteBusMasterControl(uint64_t offset, uint8_t* data, uint32_t size) {
    switch (offset)
    {
    case 0x00 ... 0x2B: {
      uint index = (offset >> 4) & 3;
      offset &= 0xF;
      WriteBusMaster(index, offset, data, size);
      break;
    }
    case 0x2C: { // global control
      MV_ASSERT(size == 4);
      uint32_t value = *(uint32_t*)data;
      uint32_t valid_mask = (1 << 6) - 1;
      if (value & 2) {  // cold reset
        Reset();
        if (debug_) {
          MV_LOG("cold reset");
        }
      } else if (value & 4) { // soft reset
        MV_ERROR("soft reset not supported yet");
      } else {
        global_control_ = value & valid_mask;
        if (debug_) {
          MV_LOG("set global control=%x", value);
        }
      }
      break;
    }
    case 0x30: {  // global status (support writing 1 to clear bits)
      uint32_t valid_mask = (1 << 0) | (1 << 10) | (1 << 15);
      uint32_t value = 0;
      memcpy(&value, data, size);
      global_status_ &= ~(value & valid_mask);
      break;
    }
    default:
      MV_ERROR("unhandled write bus master offset=0x%lx data=%x size=%u", offset, *(uint32_t*)data, size);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == pci_bars_[0].address) {
      if (offset + size > sizeof(mixer_)) {
        memset(data, 0xFF, size);
      } else {
        memcpy(data, (uint8_t*)&mixer_ + offset, size);
        codec_accessing_ = 0;
      }
      if (debug_) {
        MV_LOG("read mixer offset=0x%lx data=%x size=%u", offset, *(uint16_t*)data, size);
      }
    } else if (resource->base == pci_bars_[1].address) {
      ReadBusMasterControl(offset, data, size);
    } else {
      PciDevice::Read(resource, offset, data, size);
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == pci_bars_[0].address) {
      MV_ASSERT(offset + size <= sizeof(mixer_));
      WriteMixer(offset, data, size);
      codec_accessing_ = 0;
      if (debug_) {
        MV_LOG("write mixer offset=0x%lx data=%x size=%u", offset, *(uint16_t*)data, size);
      }
    } else if (resource->base == pci_bars_[1].address) {
      WriteBusMasterControl(offset, data, size);
    } else {
      PciDevice::Write(resource, offset, data, size);
    }
  }
};

DECLARE_DEVICE(Ac97);

```

`devices/audio/ac97.proto`:

```proto
syntax = "proto3";


message Ac97State {
  message BusMaster {
    uint32  bdl_address           = 1;
    uint32  bdl_current_index     = 2;
    uint32  bdl_last_valid_index  = 3;
    uint32  status                = 4;
    uint32  bdl_prefetched_index  = 5;
    uint32  control               = 6;
  }

  bytes               mixer       = 1;
  repeated  BusMaster bus_masters = 2;
}

```

`devices/audio/hda_codec.h`:

```h
/* 
 * MVisor HDA Codec
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AUDIO_HDA_CODEC_H
#define _MVISOR_DEVICES_AUDIO_HDA_CODEC_H

#include <cstdint>
#include <functional>
#include <vector>

typedef std::function<void(uint32_t)> ResponseCallback;
typedef std::function<size_t (uint8_t*, size_t)> TransferCallback;

struct HdaCodecBuffer {
  uint8_t*  data;
  size_t    length;
  bool      interrupt_on_completion;
  size_t    read_counter;
};

class HdaCodecInterface {
 public:
  virtual ~HdaCodecInterface() = default;
  virtual void StartCommand(uint8_t node_id, uint32_t data, ResponseCallback callback) = 0;
  virtual void StartStream(uint32_t stream_id, bool output, TransferCallback callback) = 0;
  virtual void StopStream(uint32_t stream_id, bool output) = 0;
};

#endif // _MVISOR_DEVICES_AUDIO_HDA_CODEC_H

```

`devices/audio/hda_duplex.cc`:

```cc
/* 
 * MVisor HDA Codec
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "hda_codec.h"

#include <cstring>
#include <cstdio>
#include <cmath>

#include <string>
#include <map>
#include <vector>
#include <chrono>
#include <array>

#include "device.h"
#include "hda_internal.h"
#include "device_manager.h"
#include "device_interface.h"
#include "hda_duplex.pb.h"
#include "logger.h"

#define STREAM_FRAME_INTERVAL_MS   (10)

struct HdaStream {
  uint32_t          id;
  uint32_t          channel;
  uint32_t          format;
  uint32_t          gain_left, gain_right;
  bool              mute_left, mute_right;

  bool              output;
  bool              running = false;
  size_t            position = 0;
  uint32_t          nchannels = 0;
  uint32_t          frequency = 0;
  size_t            bytes_per_second = 0;
  size_t            bytes_per_frame = 0;

  IoTimer*          timer = nullptr;
  IoTimePoint       start_time;
  TransferCallback  transfer_callback;
  std::string       buffer;
  size_t            buffer_pointer = 0;
};

struct HdaNode {
  uint32_t    id;
  std::string name;
  uint32_t    config = 0;
  uint32_t    pin_control = 0;
  uint32_t    stream_index = 0;
  std::map<uint32_t, uint32_t> parameters;
  std::vector<uint32_t> connection;
  HdaStream*  stream = nullptr;
};

class HdaDuplex : public Device, public HdaCodecInterface, public PlaybackInterface, public RecordInterface {
 private:
  uint32_t                      subsystem_id_;
  uint32_t                      pcm_formats_;
  std::vector<HdaNode>          nodes_;
  std::array<HdaStream, 2>      streams_;
  std::vector<PlaybackListener> playback_listeners_;
  std::vector<RecordListener>   record_listeners_;
  std::deque<std::string>       record_buffer_;
  PciDevice*                    hda_host_;

 public:
  HdaDuplex() {
    set_default_parent_class("Ich9Hda");
  }

  void Connect() {
    Device::Connect();

    hda_host_ = dynamic_cast<PciDevice*>(parent_);
    MV_ASSERT(hda_host_);
  }

  void Disconnect() {
    for (auto& stream : streams_) {
      if (stream.running) {
        SetStreamRunning(&stream, false);
      }
    }
    Device::Disconnect();
  }

  void Reset() {
    for (auto& stream : streams_) {
      if (stream.running) {
        SetStreamRunning(&stream, false);
      }
    }
    InitializeCodec();
  }

  bool SaveState(MigrationWriter* writer) {
    HdaDuplexState state;
    for (size_t i = 0; i < streams_.size(); i++) {
      auto s = state.add_streams();
      s->set_id(streams_[i].id);
      s->set_channel(streams_[i].channel);
      s->set_format(streams_[i].format);
      s->set_gain_left(streams_[i].gain_left);
      s->set_gain_right(streams_[i].gain_right);
      s->set_mute_left(streams_[i].mute_left);
      s->set_mute_right(streams_[i].mute_right);
    }
    writer->WriteProtobuf("HDA_DUPLEX_CODEC", state);
    return Device::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!Device::LoadState(reader))
      return false;

    HdaDuplexState state;
    if (!reader->ReadProtobuf("HDA_DUPLEX_CODEC", state)) {
      return false;
    }
    for (size_t i = 0; i < streams_.size(); i++) {
      auto& s = state.streams(i);
      streams_[i].id = s.id();
      streams_[i].channel = s.channel();
      streams_[i].format = s.format();
      streams_[i].gain_left = s.gain_left();
      streams_[i].gain_right = s.gain_right();
      streams_[i].mute_left = s.mute_left();
      streams_[i].mute_right = s.mute_right();
      SetupStream(&streams_[i]);
    }
    return true;
  }

  void InitializeCodec() {
    nodes_.clear();
    subsystem_id_ = (0x1AF4 << 16) | 0x21;  // duplex, no mixer
    pcm_formats_ = AC_SUPPCM_BITS_16 | (1 << 6); // 48000 Hz
    
    // root node
    HdaNode root;
    root.id = AC_NODE_ROOT;
    root.name = "root";
    root.parameters[AC_PAR_VENDOR_ID] = subsystem_id_;
    root.parameters[AC_PAR_SUBSYSTEM_ID] = subsystem_id_;
    root.parameters[AC_PAR_REV_ID] = 0x00100101;
    root.parameters[AC_PAR_NODE_COUNT] = 0x00010001;
    nodes_.push_back(root);

    // audio node
    HdaNode audio;
    audio.id = 1;
    audio.name = "func";
    audio.parameters[AC_PAR_SUBSYSTEM_ID] = subsystem_id_;
    audio.parameters[AC_PAR_FUNCTION_TYPE] = AC_GRP_AUDIO_FUNCTION;
    audio.parameters[AC_PAR_NODE_COUNT] = 0x00020004;
    audio.parameters[AC_PAR_PCM] = pcm_formats_;
    audio.parameters[AC_PAR_STREAM] = AC_SUPFMT_PCM;
    audio.parameters[AC_PAR_GPIO_CAP] = 0;
    audio.parameters[AC_PAR_AUDIO_FG_CAP] = 0x00000808;
    audio.parameters[AC_PAR_AMP_IN_CAP] = 0;
    audio.parameters[AC_PAR_AMP_OUT_CAP] = 0;
    audio.parameters[AC_PAR_POWER_STATE] = 0;
    audio.parameters[AC_PAR_AUDIO_WIDGET_CAP] = 0;
    audio.parameters[AC_PAR_PIN_CAP] = 0;
    audio.parameters[AC_PAR_CONNLIST_LEN] = 0;
    audio.parameters[AC_PAR_PROC_CAP] = 0;
    audio.parameters[AC_PAR_VOL_KNB_CAP] = 0;
    nodes_.push_back(audio);

    // dac node
    HdaNode dac;
    dac.id = 2;
    dac.name = "dac";
    dac.stream_index = 0;
    dac.stream = &streams_[0];
    dac.stream->output = true;
    dac.stream->gain_left = dac.stream->gain_right = 0x4A;
    dac.stream->format = AC_FMT_TYPE_PCM | AC_FMT_BITS_16 | (1 << AC_FMT_CHAN_SHIFT);
    dac.parameters[AC_PAR_AUDIO_WIDGET_CAP] = ((AC_WID_AUD_OUT << AC_WCAP_TYPE_SHIFT) |
      AC_WCAP_FORMAT_OVRD | AC_WCAP_STEREO);
    dac.parameters[AC_PAR_PCM] = pcm_formats_;
    dac.parameters[AC_PAR_STREAM] = AC_SUPFMT_PCM;
    nodes_.push_back(dac);

    // out node
    HdaNode out;
    out.id = 3;
    out.name = "out";
    out.config = (AC_JACK_PORT_COMPLEX << AC_DEFCFG_PORT_CONN_SHIFT) |
      (AC_JACK_LINE_OUT << AC_DEFCFG_DEVICE_SHIFT) |
      (AC_JACK_CONN_UNKNOWN << AC_DEFCFG_CONN_TYPE_SHIFT) |
      (AC_JACK_COLOR_GREEN << AC_DEFCFG_COLOR_SHIFT) | 0x10;
    out.connection.push_back(2);
    out.pin_control = AC_PINCTL_OUT_EN;
    out.parameters[AC_PAR_AUDIO_WIDGET_CAP] = (AC_WID_PIN << AC_WCAP_TYPE_SHIFT) |
      AC_WCAP_CONN_LIST | AC_WCAP_STEREO;
    out.parameters[AC_PAR_PIN_CAP] = AC_PINCAP_OUT;
    out.parameters[AC_PAR_CONNLIST_LEN] = out.connection.size();
    nodes_.push_back(out);

    // adc node
    HdaNode adc;
    adc.id = 4;
    adc.name = "adc";
    adc.stream_index = 1;
    adc.stream = &streams_[1];
    adc.stream->output = false;
    adc.stream->format = AC_FMT_TYPE_PCM | AC_FMT_BITS_16 | (1 << AC_FMT_CHAN_SHIFT);
    adc.connection.push_back(5);
    adc.parameters[AC_PAR_AUDIO_WIDGET_CAP] = (AC_WID_AUD_IN << AC_WCAP_TYPE_SHIFT) |
      AC_WCAP_CONN_LIST | AC_WCAP_FORMAT_OVRD | AC_WCAP_STEREO;
    adc.parameters[AC_PAR_CONNLIST_LEN] = adc.connection.size();
    adc.parameters[AC_PAR_PCM] = pcm_formats_;
    adc.parameters[AC_PAR_STREAM] = AC_SUPFMT_PCM;
    adc.parameters[AC_PAR_AMP_OUT_CAP] = 0;
    nodes_.push_back(adc);

    // in
    HdaNode in;
    in.id = 5;
    in.name = "in";
    in.config = (AC_JACK_PORT_COMPLEX << AC_DEFCFG_PORT_CONN_SHIFT) |
      (AC_JACK_LINE_IN << AC_DEFCFG_DEVICE_SHIFT) |
      (AC_JACK_CONN_UNKNOWN << AC_DEFCFG_CONN_TYPE_SHIFT) |
      (AC_JACK_COLOR_RED << AC_DEFCFG_COLOR_SHIFT) | 0x20;
    in.pin_control = AC_PINCTL_IN_EN;
    in.parameters[AC_PAR_AUDIO_WIDGET_CAP] = (AC_WID_PIN << AC_WCAP_TYPE_SHIFT) | AC_WCAP_STEREO;
    in.parameters[AC_PAR_PIN_CAP] = AC_PINCAP_IN;
    nodes_.push_back(in);

    // setup with default format
    for (auto &stream : streams_) {
      SetupStream(&stream);
    }
  }

  void StartCommand(uint8_t node_id, uint32_t data, ResponseCallback callback) {
    uint32_t verb, payload;
    if ((data & 0x70000) == 0x70000) { // id/payload 12/8
      verb = (data >> 8) & 0xFFF;
      payload = data & 0x00FF;
    } else { // id/payload 4/16
      verb = (data >> 8) & 0xF00;
      payload = data & 0xFFFF;
    }

    MV_ASSERT(node_id < nodes_.size());
    HdaNode& node = nodes_[node_id];
    if (debug_) {
      MV_LOG("node=%d verb=0x%x payload=0x%x", node_id, verb, payload);
    }

    switch (verb)
    {
    case AC_VERB_PARAMETERS:
      callback(FindNodeParameter(node, payload));
      break;
    case AC_VERB_GET_STREAM_FORMAT:
      MV_ASSERT(node.stream);
      callback(node.stream->format);
      break;
    case AC_VERB_GET_CONV:
      MV_ASSERT(node.stream);
      callback((node.stream->id << 4) | node.stream->channel);
      break;
    case AC_VERB_SET_CHANNEL_STREAMID:
      MV_ASSERT(node.stream);
      SetStreamRunning(node.stream, false);
      node.stream->id = (payload >> 4) & 0xF;
      node.stream->channel = payload & 0xF;
      callback(0);
      if (debug_) {
        MV_LOG("node[%d] %s stream_id=%d channel=%d", node.id, node.name.c_str(),
          node.stream->id, node.stream->channel);
      }
      break;
    case AC_VERB_SET_STREAM_FORMAT:
      node.stream->format = payload;
      SetupStream(node.stream);
      if (debug_) {
        MV_LOG("node[%d] %s format=0x%x nchannels=%d frequency=%d", node.id, node.name.c_str(),
          node.stream->format, node.stream->nchannels, node.stream->frequency);
      }
      callback(0);
      break;
    case AC_VERB_GET_PIN_WIDGET_CONTROL:
      callback(node.pin_control);
      break;
    case AC_VERB_SET_PIN_WIDGET_CONTROL:
      /* If OS volume is muted, pin_control is set zero. */
      node.pin_control = payload;
      callback(0);
      break;
    case AC_VERB_GET_CONFIG_DEFAULT:
      callback(node.config);
      break;
    case AC_VERB_GET_CONNECT_LIST: {
      uint32_t count = FindNodeParameter(node, AC_PAR_CONNLIST_LEN);
      uint32_t response = 0, shift = 0;
      while (payload < count && shift < 32) {
        response |= node.connection[payload] << shift;
        payload++;
        shift += 8;
      }
      callback(response);
      break;
    }
    case AC_VERB_GET_AMP_GAIN_MUTE:
      MV_ASSERT(node.stream);
      if (payload & AC_AMP_GET_LEFT) {
        callback(node.stream->gain_left | (node.stream->mute_left ? AC_AMP_MUTE : 0));
      } else {
        callback(node.stream->gain_right | (node.stream->mute_right ? AC_AMP_MUTE : 0));
      }
      break;
    case AC_VERB_SET_AMP_GAIN_MUTE:
      MV_ASSERT(node.stream);
      if (payload & AC_AMP_SET_LEFT) {
        node.stream->gain_left = payload & AC_AMP_GAIN;
        node.stream->mute_left = payload & AC_AMP_MUTE;
      }
      if (payload & AC_AMP_SET_RIGHT) {
        node.stream->gain_right = payload & AC_AMP_GAIN;
        node.stream->mute_right = payload & AC_AMP_MUTE;
      }
      callback(0);
      break;
    /* not supported */
    case AC_VERB_GET_SDI_SELECT:
    case AC_VERB_SET_CODEC_RESET:
    case AC_VERB_GET_POWER_STATE:
      callback(0);
      break;
    default:
      if (debug_) {
        MV_LOG("unhandled verb 0x%x payload=0x%x", verb, payload);
      }
      callback(0);
      break;
    }
  }

  uint32_t FindNodeParameter(const HdaNode& node, uint32_t id) {
    auto it = node.parameters.find(id);
    if (it == node.parameters.end()) {
      MV_PANIC("failed to find node %s parameter 0x%x", node.name.c_str(), id);
      return 0;
    }
    return it->second;
  }

  void SetupStream(HdaStream* stream) {
    stream->buffer_pointer = 0;
    stream->frequency = 0;
    stream->channel = 0;
    stream->bytes_per_second = stream->bytes_per_frame = 0;
    if (stream->format & AC_FMT_TYPE_NON_PCM) {
      return;
    }
    if ((stream->format & AC_FMT_BITS_MASK) != AC_FMT_BITS_16) {
      if (debug_) {
        MV_LOG("not supported audio format 0x%x", stream->format);
      }
      return;
    }

    stream->frequency = (stream->format & AC_FMT_BASE_44K) ? 44100 : 48000;

    uint32_t mul = (stream->format & AC_FMT_MULT_MASK) >> AC_FMT_MULT_SHIFT;
    uint32_t div = (stream->format & AC_FMT_DIV_MASK) >> AC_FMT_DIV_SHIFT;
    stream->frequency = stream->frequency * (mul + 1) / (div + 1);
    stream->nchannels = ((stream->format & AC_FMT_CHAN_MASK) >> AC_FMT_CHAN_SHIFT) + 1;
    stream->bytes_per_second = 2LL * stream->nchannels * stream->frequency;
    stream->bytes_per_frame = stream->bytes_per_second / (1000 / STREAM_FRAME_INTERVAL_MS);
    stream->buffer.resize(stream->bytes_per_frame);
    bzero(stream->buffer.data(), stream->buffer.size());
  }

  void OnStreamTimer(HdaStream* stream) {
    if (stream->output) {
      auto to_transfer = stream->buffer.size() - stream->buffer_pointer;
      auto ptr = (uint8_t*)&stream->buffer.data()[stream->buffer_pointer];
      size_t bytes = stream->transfer_callback(ptr, to_transfer);
      stream->position += bytes;
      stream->buffer_pointer += bytes;

      if (stream->buffer_pointer >= stream->buffer.size()) {
        NotifyPlayback(kPlaybackData, stream->buffer.data(), stream->buffer_pointer);
        stream->buffer_pointer = 0;
      }
    } else {
      if(!record_buffer_.empty()) {
        auto buffer = record_buffer_.front();
        record_buffer_.pop_front();
        stream->transfer_callback((uint8_t*)buffer.data(), buffer.size());
        stream->position += buffer.size();
      } else {
        /* input silence if record buffer is unavailable */
        stream->transfer_callback((uint8_t*)stream->buffer.data(), stream->buffer.size());
        stream->position += stream->buffer.size();
      }
    }

    auto started_ms = std::chrono::duration_cast<std::chrono::milliseconds>(
      std::chrono::steady_clock::now() - stream->start_time).count();
    auto current_ms = stream->position * 1000 / stream->bytes_per_second;
    int64_t next_interval_ms = current_ms - started_ms;
    
    if (next_interval_ms < 1) {
      /* If we cannot catch up, reset timer */
      if (next_interval_ms < -100) {
        MV_LOG("stream[%d] reset timer, current_ms=%dms started_ms=%dms", stream->id, current_ms, started_ms);
        stream->position = 0;
        stream->start_time = std::chrono::steady_clock::now();
      } 
      next_interval_ms = 1;
    }

    int64_t next_interval_ns = 1000000LL * next_interval_ms;
    if (stream->timer->interval_ns != next_interval_ns) {
      hda_host_->ModifyTimer(stream->timer, next_interval_ns);
    }
  }

  void SetStreamRunning(HdaStream* stream, bool running) {
    if (stream->running == running) {
      return;
    }
    stream->running = running;
    if (debug_) {
      MV_LOG("set stream[%d] running=%d", stream->id, running);
    }

    if (running) {
      if (stream->output) {
        NotifyPlayback(kPlaybackStart, nullptr, 0);
      } else {
        NotifyRecordEvent(kRecordStart);
        record_buffer_.clear();
      }
      stream->position = 0;
      stream->start_time = std::chrono::steady_clock::now();
      MV_ASSERT(stream->timer == nullptr);
      // FIXME: When should the first timer event happen?
      stream->timer = hda_host_->AddTimer(1, true, [this, stream]() {
        OnStreamTimer(stream);
      });
    } else {
      MV_ASSERT(stream->timer);
      hda_host_->RemoveTimer(stream->timer);
      stream->timer = nullptr;
      stream->transfer_callback = nullptr;
      if (stream->output) {
        NotifyPlayback(kPlaybackStop, nullptr, 0);
      } else {
        if(!record_buffer_.empty()) {
          record_buffer_.clear();
        }
        NotifyRecordEvent(kRecordStop);
      }
    }
  }

  HdaStream* FindStreamById(uint32_t stream_id, bool output) {
    for (auto& stream : streams_) {
      if (stream.output == output && stream.id == stream_id) {
        return &stream;
      }
    }
    return nullptr;
  }
  
  void StartStream(uint32_t stream_id, bool output, TransferCallback callback) {
    HdaStream* stream = FindStreamById(stream_id, output);
    if (stream) {
      stream->transfer_callback = callback;
      SetStreamRunning(stream, true);
    }
  }

  void StopStream(uint32_t stream_id, bool output) {
    HdaStream* stream = FindStreamById(stream_id, output);
    if (stream) {
      SetStreamRunning(stream, false);
    }
  }

  void NotifyPlayback(PlaybackState state, void* data, size_t length) {
    for (auto& cb : playback_listeners_) {
      cb(state, iovec {
        .iov_base = data,
        .iov_len = length
      });
    }
  }

  void GetPlaybackFormat(uint* format, uint* channels, uint* frequency, uint* interval_ms) {
    auto& stream = streams_[0];
    *format = 2;
    *channels = stream.nchannels;
    *frequency = stream.frequency;
    *interval_ms = STREAM_FRAME_INTERVAL_MS;
  }

  void RegisterPlaybackListener(PlaybackListener callback) {
    playback_listeners_.push_back(callback);
  }

  void WriteStreamToSharedBuffer(HdaStream* stream, const std::string& record_data) {
    size_t frame_bytes = stream->bytes_per_frame;
    size_t write_pos = 0;
    size_t size = record_data.size();
    std::string buffer;
    buffer.resize(frame_bytes);
    while (size >= frame_bytes) {
      memcpy(buffer.data(), record_data.data() + write_pos, frame_bytes);
      record_buffer_.push_back(buffer);
      write_pos += frame_bytes;
      size -= frame_bytes;
    }
  }

  void WriteRecordDataToDevice(const std::string& record_data) {
    HdaStream* stream = FindStreamById(1, false);
    if(stream == nullptr) {
      MV_ERROR("can't find stream by id");
      return;
    }

    hda_host_->Schedule([this, stream, record_data]() {
      WriteStreamToSharedBuffer(stream, record_data);
    });
  }

  void NotifyRecordEvent(RecordState state) {
    for (auto& cb : record_listeners_) {
      cb(state);
    }
  }

  void RegisterRecordListener(RecordListener callback) {
    record_listeners_.push_back(callback);
  }
};

DECLARE_DEVICE(HdaDuplex);

```

`devices/audio/hda_duplex.proto`:

```proto
syntax = "proto3";

message HdaDuplexState {
  message Stream {
    uint32  id          = 1;
    uint32  channel     = 2;
    uint32  format      = 3;
    uint32  gain_left   = 4;
    uint32  gain_right  = 5;
    bool    mute_left   = 6;
    bool    mute_right  = 7;
  }

  repeated Stream streams = 1;
}

```

`devices/audio/hda_internal.h`:

```h
/*
 * From linux/sound/pci/hda/hda_intel.c
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MVISOR_DEVICES_AUDIO_HDA_INTERNAL_H
#define MVISOR_DEVICES_AUDIO_HDA_INTERNAL_H

/*
 * registers
 */
#define ICH6_REG_GCAP      0x00
#define ICH6_GCAP_64OK  (1 << 0)   /* 64bit address support */
#define ICH6_GCAP_NSDO  (3 << 1)   /* # of serial data out signals */
#define ICH6_GCAP_BSS    (31 << 3)  /* # of bidirectional streams */
#define ICH6_GCAP_ISS    (15 << 8)  /* # of input streams */
#define ICH6_GCAP_OSS    (15 << 12) /* # of output streams */
#define ICH6_REG_VMIN      0x02
#define ICH6_REG_VMAJ      0x03
#define ICH6_REG_OUTPAY      0x04
#define ICH6_REG_INPAY      0x06
#define ICH6_REG_GCTL      0x08
#define ICH6_GCTL_RESET  (1 << 0)   /* controller reset */
#define ICH6_GCTL_FCNTRL  (1 << 1)   /* flush control */
#define ICH6_GCTL_UNSOL  (1 << 8)   /* accept unsol. response enable */
#define ICH6_REG_WAKEEN      0x0c
#define ICH6_REG_STATESTS    0x0e
#define ICH6_REG_GSTS      0x10
#define ICH6_GSTS_FSTS  (1 << 1)   /* flush status */
#define ICH6_REG_INTCTL      0x20
#define ICH6_REG_INTSTS      0x24
#define ICH6_REG_WALLCLK    0x30  /* 24Mhz source */
#define ICH6_REG_SYNC      0x34
#define ICH6_REG_CORBLBASE    0x40
#define ICH6_REG_CORBUBASE    0x44
#define ICH6_REG_CORBWP      0x48
#define ICH6_REG_CORBRP      0x4a
#define ICH6_CORBRP_RST  (1 << 15)  /* read pointer reset */
#define ICH6_REG_CORBCTL    0x4c
#define ICH6_CORBCTL_RUN  (1 << 1)   /* enable DMA */
#define ICH6_CORBCTL_CMEIE  (1 << 0)   /* enable memory error irq */
#define ICH6_REG_CORBSTS    0x4d
#define ICH6_CORBSTS_CMEI  (1 << 0)   /* memory error indication */
#define ICH6_REG_CORBSIZE    0x4e

#define ICH6_REG_RIRBLBASE    0x50
#define ICH6_REG_RIRBUBASE    0x54
#define ICH6_REG_RIRBWP      0x58
#define ICH6_RIRBWP_RST  (1 << 15)  /* write pointer reset */
#define ICH6_REG_RINTCNT    0x5a
#define ICH6_REG_RIRBCTL    0x5c
#define ICH6_RBCTL_IRQ_EN  (1 << 0)   /* enable IRQ */
#define ICH6_RBCTL_DMA_EN  (1 << 1)   /* enable DMA */
#define ICH6_RBCTL_OVERRUN_EN  (1 << 2)   /* enable overrun irq */
#define ICH6_REG_RIRBSTS    0x5d
#define ICH6_RBSTS_IRQ  (1 << 0)   /* response irq */
#define ICH6_RBSTS_OVERRUN  (1 << 2)   /* overrun irq */
#define ICH6_REG_RIRBSIZE    0x5e

#define ICH6_REG_IC      0x60
#define ICH6_REG_IR      0x64
#define ICH6_REG_IRS      0x68
#define ICH6_IRS_VALID  (1<<1)
#define ICH6_IRS_BUSY    (1<<0)

#define ICH6_REG_DPLBASE    0x70
#define ICH6_REG_DPUBASE    0x74
#define ICH6_DPLBASE_ENABLE  0x1  /* Enable position buffer */

/* SD offset: SDI0=0x80, SDI1=0xa0, ... SDO3=0x160 */
enum { SDI0, SDI1, SDI2, SDI3, SDO0, SDO1, SDO2, SDO3 };

/* stream register offsets from stream base */
#define ICH6_REG_SD_CTL      0x00
#define ICH6_REG_SD_STS      0x03
#define ICH6_REG_SD_LPIB    0x04
#define ICH6_REG_SD_CBL      0x08
#define ICH6_REG_SD_LVI      0x0c
#define ICH6_REG_SD_FIFOW    0x0e
#define ICH6_REG_SD_FIFOSIZE    0x10
#define ICH6_REG_SD_FORMAT    0x12
#define ICH6_REG_SD_BDLPL    0x18
#define ICH6_REG_SD_BDLPU    0x1c

/* PCI space */
#define ICH6_PCIREG_TCSEL  0x44

/*
 * other constants
 */

/* max number of SDs */
/* ICH, ATI and VIA have 4 playback and 4 capture */
#define ICH6_NUM_CAPTURE  4
#define ICH6_NUM_PLAYBACK  4

/* ULI has 6 playback and 5 capture */
#define ULI_NUM_CAPTURE    5
#define ULI_NUM_PLAYBACK  6

/* ATI HDMI has 1 playback and 0 capture */
#define ATIHDMI_NUM_CAPTURE  0
#define ATIHDMI_NUM_PLAYBACK  1

/* TERA has 4 playback and 3 capture */
#define TERA_NUM_CAPTURE  3
#define TERA_NUM_PLAYBACK  4

/* this number is statically defined for simplicity */
#define MAX_AZX_DEV    16

/* max number of fragments - we may use more if allocating more pages for BDL */
#define BDL_SIZE    4096
#define AZX_MAX_BDL_ENTRIES  (BDL_SIZE / 16)
#define AZX_MAX_FRAG    32
/* max buffer size - no h/w limit, you can increase as you like */
#define AZX_MAX_BUF_SIZE  (1024*1024*1024)

/* RIRB int mask: overrun[2], response[0] */
#define RIRB_INT_RESPONSE  0x01
#define RIRB_INT_OVERRUN  0x04
#define RIRB_INT_MASK    0x05

/* STATESTS int mask: S3,SD2,SD1,SD0 */
#define AZX_MAX_CODECS    8
#define AZX_DEFAULT_CODECS  4
#define STATESTS_INT_MASK  ((1 << AZX_MAX_CODECS) - 1)

/* SD_CTL bits */
#define SD_CTL_STREAM_RESET  0x01  /* stream reset bit */
#define SD_CTL_DMA_START  0x02  /* stream DMA start bit */
#define SD_CTL_STRIPE    (3 << 16)  /* stripe control */
#define SD_CTL_TRAFFIC_PRIO  (1 << 18)  /* traffic priority */
#define SD_CTL_DIR    (1 << 19)  /* bi-directional stream */
#define SD_CTL_STREAM_TAG_MASK  (0xf << 20)
#define SD_CTL_STREAM_TAG_SHIFT  20

/* SD_CTL and SD_STS */
#define SD_INT_DESC_ERR    0x10  /* descriptor error interrupt */
#define SD_INT_FIFO_ERR    0x08  /* FIFO error interrupt */
#define SD_INT_COMPLETE    0x04  /* completion interrupt */
#define SD_INT_MASK    (SD_INT_DESC_ERR|SD_INT_FIFO_ERR|\
         SD_INT_COMPLETE)

/* SD_STS */
#define SD_STS_FIFO_READY  0x20  /* FIFO ready */

/* INTCTL and INTSTS */
#define ICH6_INT_ALL_STREAM  0xff     /* all stream interrupts */
#define ICH6_INT_CTRL_EN  0x40000000 /* controller interrupt enable bit */
#define ICH6_INT_GLOBAL_EN  0x80000000 /* global interrupt enable bit */

/* below are so far hardcoded - should read registers in future */
#define ICH6_MAX_CORB_ENTRIES  256
#define ICH6_MAX_RIRB_ENTRIES  256

/* position fix mode */
enum {
  POS_FIX_AUTO,
  POS_FIX_LPIB,
  POS_FIX_POSBUF,
};

/* Defines for ATI HD Audio support in SB450 south bridge */
#define ATI_SB450_HDAUDIO_MISC_CNTR2_ADDR   0x42
#define ATI_SB450_HDAUDIO_ENABLE_SNOOP      0x02

/* Defines for Nvidia HDA support */
#define NVIDIA_HDA_TRANSREG_ADDR      0x4e
#define NVIDIA_HDA_ENABLE_COHBITS     0x0f
#define NVIDIA_HDA_ISTRM_COH          0x4d
#define NVIDIA_HDA_OSTRM_COH          0x4c
#define NVIDIA_HDA_ENABLE_COHBIT      0x01

/* Defines for Intel SCH HDA snoop control */
#define INTEL_SCH_HDA_DEVC      0x78
#define INTEL_SCH_HDA_DEVC_NOSNOOP       (0x1<<11)

/* Define IN stream 0 FIFO size offset in VIA controller */
#define VIA_IN_STREAM0_FIFO_SIZE_OFFSET  0x90
/* Define VIA HD Audio Device ID*/
#define VIA_HDAC_DEVICE_ID    0x3288

/* HD Audio class code */
#define PCI_CLASS_MULTIMEDIA_HD_AUDIO  0x0403

/* --------------------------------------------------------------------- */
/* from linux/sound/pci/hda/hda_codec.h                                  */

/*
 * nodes
 */
#define  AC_NODE_ROOT    0x00

/*
 * function group types
 */
enum {
  AC_GRP_AUDIO_FUNCTION = 0x01,
  AC_GRP_MODEM_FUNCTION = 0x02,
};
  
/*
 * widget types
 */
enum {
  AC_WID_AUD_OUT,    /* Audio Out */
  AC_WID_AUD_IN,    /* Audio In */
  AC_WID_AUD_MIX,    /* Audio Mixer */
  AC_WID_AUD_SEL,    /* Audio Selector */
  AC_WID_PIN,    /* Pin Complex */
  AC_WID_POWER,    /* Power */
  AC_WID_VOL_KNB,    /* Volume Knob */
  AC_WID_BEEP,    /* Beep Generator */
  AC_WID_VENDOR = 0x0f  /* Vendor specific */
};

/*
 * GET verbs
 */
#define AC_VERB_GET_STREAM_FORMAT    0x0a00
#define AC_VERB_GET_AMP_GAIN_MUTE    0x0b00
#define AC_VERB_GET_PROC_COEF      0x0c00
#define AC_VERB_GET_COEF_INDEX      0x0d00
#define AC_VERB_PARAMETERS      0x0f00
#define AC_VERB_GET_CONNECT_SEL      0x0f01
#define AC_VERB_GET_CONNECT_LIST    0x0f02
#define AC_VERB_GET_PROC_STATE      0x0f03
#define AC_VERB_GET_SDI_SELECT      0x0f04
#define AC_VERB_GET_POWER_STATE      0x0f05
#define AC_VERB_GET_CONV      0x0f06
#define AC_VERB_GET_PIN_WIDGET_CONTROL    0x0f07
#define AC_VERB_GET_UNSOLICITED_RESPONSE  0x0f08
#define AC_VERB_GET_PIN_SENSE      0x0f09
#define AC_VERB_GET_BEEP_CONTROL    0x0f0a
#define AC_VERB_GET_EAPD_BTLENABLE    0x0f0c
#define AC_VERB_GET_DIGI_CONVERT_1    0x0f0d
#define AC_VERB_GET_DIGI_CONVERT_2    0x0f0e /* unused */
#define AC_VERB_GET_VOLUME_KNOB_CONTROL    0x0f0f
/* f10-f1a: GPIO */
#define AC_VERB_GET_GPIO_DATA      0x0f15
#define AC_VERB_GET_GPIO_MASK      0x0f16
#define AC_VERB_GET_GPIO_DIRECTION    0x0f17
#define AC_VERB_GET_GPIO_WAKE_MASK    0x0f18
#define AC_VERB_GET_GPIO_UNSOLICITED_RSP_MASK  0x0f19
#define AC_VERB_GET_GPIO_STICKY_MASK    0x0f1a
#define AC_VERB_GET_CONFIG_DEFAULT    0x0f1c
/* f20: AFG/MFG */
#define AC_VERB_GET_SUBSYSTEM_ID    0x0f20
#define AC_VERB_GET_CVT_CHAN_COUNT    0x0f2d
#define AC_VERB_GET_HDMI_DIP_SIZE    0x0f2e
#define AC_VERB_GET_HDMI_ELDD      0x0f2f
#define AC_VERB_GET_HDMI_DIP_INDEX    0x0f30
#define AC_VERB_GET_HDMI_DIP_DATA    0x0f31
#define AC_VERB_GET_HDMI_DIP_XMIT    0x0f32
#define AC_VERB_GET_HDMI_CP_CTRL    0x0f33
#define AC_VERB_GET_HDMI_CHAN_SLOT    0x0f34

/*
 * SET verbs
 */
#define AC_VERB_SET_STREAM_FORMAT    0x200
#define AC_VERB_SET_AMP_GAIN_MUTE    0x300
#define AC_VERB_SET_PROC_COEF      0x400
#define AC_VERB_SET_COEF_INDEX      0x500
#define AC_VERB_SET_CONNECT_SEL      0x701
#define AC_VERB_SET_PROC_STATE      0x703
#define AC_VERB_SET_SDI_SELECT      0x704
#define AC_VERB_SET_POWER_STATE      0x705
#define AC_VERB_SET_CHANNEL_STREAMID    0x706
#define AC_VERB_SET_PIN_WIDGET_CONTROL    0x707
#define AC_VERB_SET_UNSOLICITED_ENABLE    0x708
#define AC_VERB_SET_PIN_SENSE      0x709
#define AC_VERB_SET_BEEP_CONTROL    0x70a
#define AC_VERB_SET_EAPD_BTLENABLE    0x70c
#define AC_VERB_SET_DIGI_CONVERT_1    0x70d
#define AC_VERB_SET_DIGI_CONVERT_2    0x70e
#define AC_VERB_SET_VOLUME_KNOB_CONTROL    0x70f
#define AC_VERB_SET_GPIO_DATA      0x715
#define AC_VERB_SET_GPIO_MASK      0x716
#define AC_VERB_SET_GPIO_DIRECTION    0x717
#define AC_VERB_SET_GPIO_WAKE_MASK    0x718
#define AC_VERB_SET_GPIO_UNSOLICITED_RSP_MASK  0x719
#define AC_VERB_SET_GPIO_STICKY_MASK    0x71a
#define AC_VERB_SET_CONFIG_DEFAULT_BYTES_0  0x71c
#define AC_VERB_SET_CONFIG_DEFAULT_BYTES_1  0x71d
#define AC_VERB_SET_CONFIG_DEFAULT_BYTES_2  0x71e
#define AC_VERB_SET_CONFIG_DEFAULT_BYTES_3  0x71f
#define AC_VERB_SET_EAPD        0x788
#define AC_VERB_SET_CODEC_RESET      0x7ff
#define AC_VERB_SET_CVT_CHAN_COUNT    0x72d
#define AC_VERB_SET_HDMI_DIP_INDEX    0x730
#define AC_VERB_SET_HDMI_DIP_DATA    0x731
#define AC_VERB_SET_HDMI_DIP_XMIT    0x732
#define AC_VERB_SET_HDMI_CP_CTRL    0x733
#define AC_VERB_SET_HDMI_CHAN_SLOT    0x734

/*
 * Parameter IDs
 */
#define AC_PAR_VENDOR_ID    0x00
#define AC_PAR_SUBSYSTEM_ID    0x01
#define AC_PAR_REV_ID      0x02
#define AC_PAR_NODE_COUNT    0x04
#define AC_PAR_FUNCTION_TYPE    0x05
#define AC_PAR_AUDIO_FG_CAP    0x08
#define AC_PAR_AUDIO_WIDGET_CAP    0x09
#define AC_PAR_PCM      0x0a
#define AC_PAR_STREAM      0x0b
#define AC_PAR_PIN_CAP      0x0c
#define AC_PAR_AMP_IN_CAP    0x0d
#define AC_PAR_CONNLIST_LEN    0x0e
#define AC_PAR_POWER_STATE    0x0f
#define AC_PAR_PROC_CAP      0x10
#define AC_PAR_GPIO_CAP      0x11
#define AC_PAR_AMP_OUT_CAP    0x12
#define AC_PAR_VOL_KNB_CAP    0x13
#define AC_PAR_HDMI_LPCM_CAP    0x20

/*
 * AC_VERB_PARAMETERS results (32bit)
 */

/* Function Group Type */
#define AC_FGT_TYPE      (0xff<<0)
#define AC_FGT_TYPE_SHIFT    0
#define AC_FGT_UNSOL_CAP    (1<<8)

/* Audio Function Group Capabilities */
#define AC_AFG_OUT_DELAY    (0xf<<0)
#define AC_AFG_IN_DELAY      (0xf<<8)
#define AC_AFG_BEEP_GEN      (1<<16)

/* Audio Widget Capabilities */
#define AC_WCAP_STEREO      (1<<0)  /* stereo I/O */
#define AC_WCAP_IN_AMP      (1<<1)  /* AMP-in present */
#define AC_WCAP_OUT_AMP      (1<<2)  /* AMP-out present */
#define AC_WCAP_AMP_OVRD    (1<<3)  /* AMP-parameter override */
#define AC_WCAP_FORMAT_OVRD    (1<<4)  /* format override */
#define AC_WCAP_STRIPE      (1<<5)  /* stripe */
#define AC_WCAP_PROC_WID    (1<<6)  /* Proc Widget */
#define AC_WCAP_UNSOL_CAP    (1<<7)  /* Unsol capable */
#define AC_WCAP_CONN_LIST    (1<<8)  /* connection list */
#define AC_WCAP_DIGITAL      (1<<9)  /* digital I/O */
#define AC_WCAP_POWER      (1<<10)  /* power control */
#define AC_WCAP_LR_SWAP      (1<<11)  /* L/R swap */
#define AC_WCAP_CP_CAPS      (1<<12) /* content protection */
#define AC_WCAP_CHAN_CNT_EXT    (7<<13)  /* channel count ext */
#define AC_WCAP_DELAY      (0xf<<16)
#define AC_WCAP_DELAY_SHIFT    16
#define AC_WCAP_TYPE      (0xf<<20)
#define AC_WCAP_TYPE_SHIFT    20

/* supported PCM rates and bits */
#define AC_SUPPCM_RATES      (0xfff << 0)
#define AC_SUPPCM_BITS_8    (1<<16)
#define AC_SUPPCM_BITS_16    (1<<17)
#define AC_SUPPCM_BITS_20    (1<<18)
#define AC_SUPPCM_BITS_24    (1<<19)
#define AC_SUPPCM_BITS_32    (1<<20)

/* supported PCM stream format */
#define AC_SUPFMT_PCM      (1<<0)
#define AC_SUPFMT_FLOAT32    (1<<1)
#define AC_SUPFMT_AC3      (1<<2)

/* GP I/O count */
#define AC_GPIO_IO_COUNT    (0xff<<0)
#define AC_GPIO_O_COUNT      (0xff<<8)
#define AC_GPIO_O_COUNT_SHIFT    8
#define AC_GPIO_I_COUNT      (0xff<<16)
#define AC_GPIO_I_COUNT_SHIFT    16
#define AC_GPIO_UNSOLICITED    (1<<30)
#define AC_GPIO_WAKE      (1<<31)

/* Converter stream, channel */
#define AC_CONV_CHANNEL      (0xf<<0)
#define AC_CONV_STREAM      (0xf<<4)
#define AC_CONV_STREAM_SHIFT    4

/* Input converter SDI select */
#define AC_SDI_SELECT      (0xf<<0)

/* stream format id */
#define AC_FMT_CHAN_SHIFT    0
#define AC_FMT_CHAN_MASK    (0x0f << 0)
#define AC_FMT_BITS_SHIFT    4
#define AC_FMT_BITS_MASK    (7 << 4)
#define AC_FMT_BITS_8      (0 << 4)
#define AC_FMT_BITS_16      (1 << 4)
#define AC_FMT_BITS_20      (2 << 4)
#define AC_FMT_BITS_24      (3 << 4)
#define AC_FMT_BITS_32      (4 << 4)
#define AC_FMT_DIV_SHIFT    8
#define AC_FMT_DIV_MASK      (7 << 8)
#define AC_FMT_MULT_SHIFT    11
#define AC_FMT_MULT_MASK    (7 << 11)
#define AC_FMT_BASE_SHIFT    14
#define AC_FMT_BASE_48K      (0 << 14)
#define AC_FMT_BASE_44K      (1 << 14)
#define AC_FMT_TYPE_SHIFT    15
#define AC_FMT_TYPE_PCM      (0 << 15)
#define AC_FMT_TYPE_NON_PCM    (1 << 15)

/* Unsolicited response control */
#define AC_UNSOL_TAG      (0x3f<<0)
#define AC_UNSOL_ENABLED    (1<<7)
#define AC_USRSP_EN      AC_UNSOL_ENABLED

/* Unsolicited responses */
#define AC_UNSOL_RES_TAG    (0x3f<<26)
#define AC_UNSOL_RES_TAG_SHIFT    26
#define AC_UNSOL_RES_SUBTAG    (0x1f<<21)
#define AC_UNSOL_RES_SUBTAG_SHIFT  21
#define AC_UNSOL_RES_ELDV    (1<<1)  /* ELD Data valid (for HDMI) */
#define AC_UNSOL_RES_PD      (1<<0)  /* pinsense detect */
#define AC_UNSOL_RES_CP_STATE    (1<<1)  /* content protection */
#define AC_UNSOL_RES_CP_READY    (1<<0)  /* content protection */

/* Pin widget capabilies */
#define AC_PINCAP_IMP_SENSE    (1<<0)  /* impedance sense capable */
#define AC_PINCAP_TRIG_REQ    (1<<1)  /* trigger required */
#define AC_PINCAP_PRES_DETECT    (1<<2)  /* presence detect capable */
#define AC_PINCAP_HP_DRV    (1<<3)  /* headphone drive capable */
#define AC_PINCAP_OUT      (1<<4)  /* output capable */
#define AC_PINCAP_IN      (1<<5)  /* input capable */
#define AC_PINCAP_BALANCE    (1<<6)  /* balanced I/O capable */
/* Note: This LR_SWAP pincap is defined in the Realtek ALC883 specification,
 *       but is marked reserved in the Intel HDA specification.
 */
#define AC_PINCAP_LR_SWAP    (1<<7)  /* L/R swap */
/* Note: The same bit as LR_SWAP is newly defined as HDMI capability
 *       in HD-audio specification
 */
#define AC_PINCAP_HDMI      (1<<7)  /* HDMI pin */
#define AC_PINCAP_DP      (1<<24)  /* DisplayPort pin, can coexist with AC_PINCAP_HDMI */
#define AC_PINCAP_VREF      (0x37<<8)
#define AC_PINCAP_VREF_SHIFT    8
#define AC_PINCAP_EAPD      (1<<16)  /* EAPD capable */
#define AC_PINCAP_HBR      (1<<27)  /* High Bit Rate */
/* Vref status (used in pin cap) */
#define AC_PINCAP_VREF_HIZ    (1<<0)  /* Hi-Z */
#define AC_PINCAP_VREF_50    (1<<1)  /* 50% */
#define AC_PINCAP_VREF_GRD    (1<<2)  /* ground */
#define AC_PINCAP_VREF_80    (1<<4)  /* 80% */
#define AC_PINCAP_VREF_100    (1<<5)  /* 100% */

/* Amplifier capabilities */
#define AC_AMPCAP_OFFSET    (0x7f<<0)  /* 0dB offset */
#define AC_AMPCAP_OFFSET_SHIFT    0
#define AC_AMPCAP_NUM_STEPS    (0x7f<<8)  /* number of steps */
#define AC_AMPCAP_NUM_STEPS_SHIFT  8
#define AC_AMPCAP_STEP_SIZE    (0x7f<<16) /* step size 0-32dB in 0.25dB */
#define AC_AMPCAP_STEP_SIZE_SHIFT  16
#define AC_AMPCAP_MUTE      (1<<31)    /* mute capable */
#define AC_AMPCAP_MUTE_SHIFT    31

/* Connection list */
#define AC_CLIST_LENGTH      (0x7f<<0)
#define AC_CLIST_LONG      (1<<7)

/* Supported power status */
#define AC_PWRST_D0SUP      (1<<0)
#define AC_PWRST_D1SUP      (1<<1)
#define AC_PWRST_D2SUP      (1<<2)
#define AC_PWRST_D3SUP      (1<<3)
#define AC_PWRST_D3COLDSUP    (1<<4)
#define AC_PWRST_S3D3COLDSUP    (1<<29)
#define AC_PWRST_CLKSTOP    (1<<30)
#define AC_PWRST_EPSS      (1U<<31)

/* Power state values */
#define AC_PWRST_SETTING    (0xf<<0)
#define AC_PWRST_ACTUAL      (0xf<<4)
#define AC_PWRST_ACTUAL_SHIFT    4
#define AC_PWRST_D0      0x00
#define AC_PWRST_D1      0x01
#define AC_PWRST_D2      0x02
#define AC_PWRST_D3      0x03

/* Processing capabilies */
#define AC_PCAP_BENIGN      (1<<0)
#define AC_PCAP_NUM_COEF    (0xff<<8)
#define AC_PCAP_NUM_COEF_SHIFT    8

/* Volume knobs capabilities */
#define AC_KNBCAP_NUM_STEPS    (0x7f<<0)
#define AC_KNBCAP_DELTA      (1<<7)

/* HDMI LPCM capabilities */
#define AC_LPCMCAP_48K_CP_CHNS    (0x0f<<0) /* max channels w/ CP-on */  
#define AC_LPCMCAP_48K_NO_CHNS    (0x0f<<4) /* max channels w/o CP-on */
#define AC_LPCMCAP_48K_20BIT    (1<<8)  /* 20b bitrate supported */
#define AC_LPCMCAP_48K_24BIT    (1<<9)  /* 24b bitrate supported */
#define AC_LPCMCAP_96K_CP_CHNS    (0x0f<<10) /* max channels w/ CP-on */  
#define AC_LPCMCAP_96K_NO_CHNS    (0x0f<<14) /* max channels w/o CP-on */
#define AC_LPCMCAP_96K_20BIT    (1<<18)  /* 20b bitrate supported */
#define AC_LPCMCAP_96K_24BIT    (1<<19)  /* 24b bitrate supported */
#define AC_LPCMCAP_192K_CP_CHNS    (0x0f<<20) /* max channels w/ CP-on */  
#define AC_LPCMCAP_192K_NO_CHNS    (0x0f<<24) /* max channels w/o CP-on */
#define AC_LPCMCAP_192K_20BIT    (1<<28)  /* 20b bitrate supported */
#define AC_LPCMCAP_192K_24BIT    (1<<29)  /* 24b bitrate supported */
#define AC_LPCMCAP_44K      (1<<30)  /* 44.1kHz support */
#define AC_LPCMCAP_44K_MS    (1<<31)  /* 44.1kHz-multiplies support */

/*
 * Control Parameters
 */

/* Amp gain/mute */
#define AC_AMP_MUTE      (1<<7)
#define AC_AMP_GAIN      (0x7f)
#define AC_AMP_GET_INDEX    (0xf<<0)

#define AC_AMP_GET_LEFT      (1<<13)
#define AC_AMP_GET_RIGHT    (0<<13)
#define AC_AMP_GET_OUTPUT    (1<<15)
#define AC_AMP_GET_INPUT    (0<<15)

#define AC_AMP_SET_INDEX    (0xf<<8)
#define AC_AMP_SET_INDEX_SHIFT    8
#define AC_AMP_SET_RIGHT    (1<<12)
#define AC_AMP_SET_LEFT      (1<<13)
#define AC_AMP_SET_INPUT    (1<<14)
#define AC_AMP_SET_OUTPUT    (1<<15)

/* DIGITAL1 bits */
#define AC_DIG1_ENABLE      (1<<0)
#define AC_DIG1_V      (1<<1)
#define AC_DIG1_VCFG      (1<<2)
#define AC_DIG1_EMPHASIS    (1<<3)
#define AC_DIG1_COPYRIGHT    (1<<4)
#define AC_DIG1_NONAUDIO    (1<<5)
#define AC_DIG1_PROFESSIONAL    (1<<6)
#define AC_DIG1_LEVEL      (1<<7)

/* DIGITAL2 bits */
#define AC_DIG2_CC      (0x7f<<0)

/* Pin widget control - 8bit */
#define AC_PINCTL_EPT      (0x3<<0)
#define AC_PINCTL_EPT_NATIVE    0
#define AC_PINCTL_EPT_HBR    3
#define AC_PINCTL_VREFEN    (0x7<<0)
#define AC_PINCTL_VREF_HIZ    0  /* Hi-Z */
#define AC_PINCTL_VREF_50    1  /* 50% */
#define AC_PINCTL_VREF_GRD    2  /* ground */
#define AC_PINCTL_VREF_80    4  /* 80% */
#define AC_PINCTL_VREF_100    5  /* 100% */
#define AC_PINCTL_IN_EN      (1<<5)
#define AC_PINCTL_OUT_EN    (1<<6)
#define AC_PINCTL_HP_EN      (1<<7)

/* Pin sense - 32bit */
#define AC_PINSENSE_IMPEDANCE_MASK  (0x7fffffff)
#define AC_PINSENSE_PRESENCE    (1<<31)
#define AC_PINSENSE_ELDV    (1<<30)  /* ELD valid (HDMI) */

/* EAPD/BTL enable - 32bit */
#define AC_EAPDBTL_BALANCED    (1<<0)
#define AC_EAPDBTL_EAPD      (1<<1)
#define AC_EAPDBTL_LR_SWAP    (1<<2)

/* HDMI ELD data */
#define AC_ELDD_ELD_VALID    (1<<31)
#define AC_ELDD_ELD_DATA    0xff

/* HDMI DIP size */
#define AC_DIPSIZE_ELD_BUF    (1<<3) /* ELD buf size of packet size */
#define AC_DIPSIZE_PACK_IDX    (0x07<<0) /* packet index */

/* HDMI DIP index */
#define AC_DIPIDX_PACK_IDX    (0x07<<5) /* packet idnex */
#define AC_DIPIDX_BYTE_IDX    (0x1f<<0) /* byte index */

/* HDMI DIP xmit (transmit) control */
#define AC_DIPXMIT_MASK      (0x3<<6)
#define AC_DIPXMIT_DISABLE    (0x0<<6) /* disable xmit */
#define AC_DIPXMIT_ONCE      (0x2<<6) /* xmit once then disable */
#define AC_DIPXMIT_BEST      (0x3<<6) /* best effort */

/* HDMI content protection (CP) control */
#define AC_CPCTRL_CES      (1<<9) /* current encryption state */
#define AC_CPCTRL_READY      (1<<8) /* ready bit */
#define AC_CPCTRL_SUBTAG    (0x1f<<3) /* subtag for unsol-resp */
#define AC_CPCTRL_STATE      (3<<0) /* current CP request state */

/* Converter channel <-> HDMI slot mapping */
#define AC_CVTMAP_HDMI_SLOT    (0xf<<0) /* HDMI slot number */
#define AC_CVTMAP_CHAN      (0xf<<4) /* converter channel number */

/* configuration default - 32bit */
#define AC_DEFCFG_SEQUENCE    (0xf<<0)
#define AC_DEFCFG_DEF_ASSOC    (0xf<<4)
#define AC_DEFCFG_ASSOC_SHIFT    4
#define AC_DEFCFG_MISC      (0xf<<8)
#define AC_DEFCFG_MISC_SHIFT    8
#define AC_DEFCFG_MISC_NO_PRESENCE  (1<<0)
#define AC_DEFCFG_COLOR      (0xf<<12)
#define AC_DEFCFG_COLOR_SHIFT    12
#define AC_DEFCFG_CONN_TYPE    (0xf<<16)
#define AC_DEFCFG_CONN_TYPE_SHIFT  16
#define AC_DEFCFG_DEVICE    (0xf<<20)
#define AC_DEFCFG_DEVICE_SHIFT    20
#define AC_DEFCFG_LOCATION    (0x3f<<24)
#define AC_DEFCFG_LOCATION_SHIFT  24
#define AC_DEFCFG_PORT_CONN    (0x3<<30)
#define AC_DEFCFG_PORT_CONN_SHIFT  30

/* device device types (0x0-0xf) */
enum {
  AC_JACK_LINE_OUT,
  AC_JACK_SPEAKER,
  AC_JACK_HP_OUT,
  AC_JACK_CD,
  AC_JACK_SPDIF_OUT,
  AC_JACK_DIG_OTHER_OUT,
  AC_JACK_MODEM_LINE_SIDE,
  AC_JACK_MODEM_HAND_SIDE,
  AC_JACK_LINE_IN,
  AC_JACK_AUX,
  AC_JACK_MIC_IN,
  AC_JACK_TELEPHONY,
  AC_JACK_SPDIF_IN,
  AC_JACK_DIG_OTHER_IN,
  AC_JACK_OTHER = 0xf,
};

/* jack connection types (0x0-0xf) */
enum {
  AC_JACK_CONN_UNKNOWN,
  AC_JACK_CONN_1_8,
  AC_JACK_CONN_1_4,
  AC_JACK_CONN_ATAPI,
  AC_JACK_CONN_RCA,
  AC_JACK_CONN_OPTICAL,
  AC_JACK_CONN_OTHER_DIGITAL,
  AC_JACK_CONN_OTHER_ANALOG,
  AC_JACK_CONN_DIN,
  AC_JACK_CONN_XLR,
  AC_JACK_CONN_RJ11,
  AC_JACK_CONN_COMB,
  AC_JACK_CONN_OTHER = 0xf,
};

/* jack colors (0x0-0xf) */
enum {
  AC_JACK_COLOR_UNKNOWN,
  AC_JACK_COLOR_BLACK,
  AC_JACK_COLOR_GREY,
  AC_JACK_COLOR_BLUE,
  AC_JACK_COLOR_GREEN,
  AC_JACK_COLOR_RED,
  AC_JACK_COLOR_ORANGE,
  AC_JACK_COLOR_YELLOW,
  AC_JACK_COLOR_PURPLE,
  AC_JACK_COLOR_PINK,
  AC_JACK_COLOR_WHITE = 0xe,
  AC_JACK_COLOR_OTHER,
};

/* Jack location (0x0-0x3f) */
/* common case */
enum {
  AC_JACK_LOC_NONE,
  AC_JACK_LOC_REAR,
  AC_JACK_LOC_FRONT,
  AC_JACK_LOC_LEFT,
  AC_JACK_LOC_RIGHT,
  AC_JACK_LOC_TOP,
  AC_JACK_LOC_BOTTOM,
};
/* bits 4-5 */
enum {
  AC_JACK_LOC_EXTERNAL = 0x00,
  AC_JACK_LOC_INTERNAL = 0x10,
  AC_JACK_LOC_SEPARATE = 0x20,
  AC_JACK_LOC_OTHER    = 0x30,
};
enum {
  /* external on primary chasis */
  AC_JACK_LOC_REAR_PANEL = 0x07,
  AC_JACK_LOC_DRIVE_BAY,
  /* internal */
  AC_JACK_LOC_RISER = 0x17,
  AC_JACK_LOC_HDMI,
  AC_JACK_LOC_ATAPI,
  /* others */
  AC_JACK_LOC_MOBILE_IN = 0x37,
  AC_JACK_LOC_MOBILE_OUT,
};

/* Port connectivity (0-3) */
enum {
  AC_JACK_PORT_COMPLEX,
  AC_JACK_PORT_NONE,
  AC_JACK_PORT_FIXED,
  AC_JACK_PORT_BOTH,
};

/* max. connections to a widget */
#define HDA_MAX_CONNECTIONS  32

/* max. codec address */
#define HDA_MAX_CODEC_ADDRESS  0x0f

/* max number of PCM devics per card */
#define HDA_MAX_PCMS    10

/* --------------------------------------------------------------------- */

#endif // MVISOR_DEVICES_AUDIO_HDA_INTERNAL_H

```

`devices/audio/ich9_hda.cc`:

```cc
/* 
 * MVisor ICH9 High Definition Audio Device
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "ich9_hda.h"

#include <cstring>
#include <vector>
#include <chrono>

#include "logger.h"
#include "pci_device.h"
#include "device_manager.h"
#include "hda_codec.h"
#include "machine.h"
#include "hda_internal.h"
#include "ich9_hda.pb.h"

using namespace std::chrono;


class Ich9Hda : public PciDevice {
 private:
  Ich9HdaRegisters  regs_;
  uint32_t          rirb_counter_;
  IoTimePoint       wall_clock_base_;

  const StateChangeListener*      state_change_listener_ = nullptr;
  std::vector<HdaCodecInterface*> codecs_;

  struct Ich9HdaStreamState {
    std::vector<HdaCodecBuffer> buffers;
    uint32_t buffers_index;
  } stream_states_[8];

 public:
  Ich9Hda() {
    slot_ = 27;
    function_ = 0;
    
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x293E;
    pci_header_.class_code = 0x040300;
    pci_header_.revision_id = 3;
    pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.command = PCI_COMMAND_MEMORY;
    pci_header_.irq_pin = 1;

    /* HDCTL off 0x40 bit 0 selects signaling mode (1-HDA, 0 - Ac97) 18.1.19 */
    pci_header_.data[0x40] = 0x01;

    /* Add MSI at 0x60 */
    next_capability_offset_ = 0x60;
    AddMsiCapability();
  
    /* Memory BAR */
    AddPciBar(0, 0x4000, kIoResourceTypeMmio);
  }

  virtual void Connect() {
    PciDevice::Connect();
    for (auto device : children_) {
      auto codec = dynamic_cast<HdaCodecInterface*>(device);
      if (codec) {
        codecs_.push_back(codec);
      }
    }

    auto machine = manager_->machine();
    state_change_listener_ = machine->RegisterStateChangeListener([=]() {
      for (uint i = 0; i < 8; i++) {
        StartStopStream(i);
      }
    });
  }

  virtual void Disconnect() {
    codecs_.clear();
    PciDevice::Disconnect();
    if (state_change_listener_) {
      manager_->machine()->UnregisterStateChangeListener(&state_change_listener_);
    }
  }

  virtual void Reset() {
    PciDevice::Reset();

    MV_ASSERT(sizeof(regs_) == 0x180);
    rirb_counter_ = 0;
    wall_clock_base_ = steady_clock::now();
    bzero(&regs_, sizeof(regs_));
    regs_.global_capabilities = 0x4401; // 4 input, 4 output, 64bit supported
    regs_.major_version = 1;
    regs_.minor_version = 0;
    regs_.output_payload_capacity = 0x3C;
    regs_.input_payload_capacity = 0x1D;
    regs_.corb_size = 0x42; // 1KB, 256 entries
    regs_.rirb_size = 0x42;
    for (auto &stream : regs_.streams) {
      stream.fifo_size = 0x100;
    }
    // Setup available codecs
    for (size_t i = 0; i < codecs_.size(); i++) {
      regs_.state_change_status |= (1 << i);
    }
    CheckIrqLevel();
  }

  uint32_t GetWallClockCounter() {
    auto delta_ns = duration_cast<nanoseconds>(steady_clock::now() - wall_clock_base_);
    return (uint32_t)(delta_ns.count() * 24 / 1000); /* 24 MHz */
  }

  virtual bool SaveState(MigrationWriter* writer) {
    Ich9HdaState state;
    state.set_hda_registers(&regs_, sizeof(regs_));
    state.set_rirb_counter(rirb_counter_);
    state.set_wall_clock_counter(GetWallClockCounter());

    writer->WriteProtobuf("HDA", state);

    if(regs_.dp_base & 1) {
      auto gpa = regs_.dp_base & ~1;
      manager_->AddDirtyMemory(gpa, sizeof(uint64_t) * 8);
    }
    return PciDevice::SaveState(writer);
  }

  virtual bool LoadState(MigrationReader* reader) {
    if (!PciDevice::LoadState(reader)) {
      return false;
    }

    Ich9HdaState state;
    if (!reader->ReadProtobuf("HDA", state)) {
      return false;
    }
    auto& regs = state.hda_registers();
    memcpy(&regs_, regs.data(), sizeof(regs_));
    rirb_counter_ = state.rirb_counter();
    wall_clock_base_ = steady_clock::now() - nanoseconds(state.wall_clock_counter() * 1000 / 24);

    /* When finished loading states, restart stream if started before */
    Schedule([this]() {
      for (uint i = 0; i < 8; i++) {
        StartStopStream(i);
      }
    });
    return true;
  }

  void UpdateInterruptStatus() {
    uint32_t status = 0;
  
    /* update controller status */
    if ((regs_.rirb_status & ICH6_RBSTS_IRQ) || (regs_.rirb_status & ICH6_RBSTS_OVERRUN)) {
      // RIRB interrupt or overrun
      status |= 1 << 30;
    }
    if (regs_.state_change_status & regs_.wake_enable) {
      status |= 1 << 30;
    }
    /* update stream status */
    for (int i = 0; i < 8; i++) {
      if (regs_.streams[i].status & (1 << 2)) { // buffer completion interrupt
        status |= 1 << i;
      }
    }
    /* update global status */
    if (status & regs_.interrupt_control) {
      status |= 1 << 31;
    }
    regs_.interrupt_status = status;
  }

  void CheckIrqLevel() {
    UpdateInterruptStatus();
  
    uint32_t level = (regs_.interrupt_status & (1 << 31)) && (regs_.interrupt_control & (1 << 31));
    if (msi_config_.enabled) {
      if (level) {
        SignalMsi();
      }
    } else {
      SetIrq(level);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(resource->base == pci_bars_[0].address);
    
    // Make memory 0x2000-0x4000 and 0x0000-0x2000 same data
    if (offset >= 0x2000) {
      offset -= 0x2000;
    }
    MV_ASSERT(offset + size <= sizeof(regs_));

    if (offset == offsetof(Ich9HdaRegisters, wall_clock_counter)) {
      regs_.wall_clock_counter = GetWallClockCounter();
    }
    memcpy(data, (uint8_t*)&regs_ + offset, size);

    // uint64_t value = 0;
    // memcpy(&value, data, size);
    // MV_LOG("read %s at 0x%lx size=%x ret=0x%lx", name_, offset, size, value);
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(resource->base == pci_bars_[0].address);
    MV_ASSERT(offset + size <= sizeof(regs_));
    // MV_LOG("write %s at 0x%lx size=%x data=0x%x", name_, offset, size, *(uint32_t*)data);

    if (offset >= 0x80 && offset < 0x180) {
      uint64_t stream_desc_index = (offset - 0x80) / 0x20;
      uint64_t stream_desc_offset = (offset - 0x80) % 0x20;
      // byte write
      for (uint i = 0; i < size; i++) {
        WriteStreamDescriptor(stream_desc_index, stream_desc_offset + i, &data[i], 1);
      }
      return;
    }

    switch (offset)
    {
    case offsetof(Ich9HdaRegisters, global_control):
      regs_.global_control = (*(uint32_t*)data) & 0x103;
      if ((regs_.global_control & ICH6_GCTL_RESET) == 0) {
        Reset();
      }
      break;
    case offsetof(Ich9HdaRegisters, state_change_status): {
      uint16_t value = *(uint16_t*)data;
      regs_.state_change_status &= ~(value & 0x7FFF);
      CheckIrqLevel();
      break;
    }
    case offsetof(Ich9HdaRegisters, interrupt_status): {
      uint32_t value = *(uint32_t*)data;
      regs_.interrupt_status &= ~(value & 0xC00000FF);
      break;
    }
    case offsetof(Ich9HdaRegisters, corb_size):
    case offsetof(Ich9HdaRegisters, rirb_size):
      /* readonly field */
      break;
    case offsetof(Ich9HdaRegisters, corb_status):
      regs_.corb_status &= ~(data[0] & 1);
      break;
    case offsetof(Ich9HdaRegisters, rirb_status): {
      uint8_t old = regs_.rirb_status;
      regs_.rirb_status &= ~(data[0] & 5);
      CheckIrqLevel();
      if ((old & ICH6_RBSTS_IRQ) && !(regs_.rirb_status & ICH6_RBSTS_IRQ)) {
        // cleared ICH6_RBSTS_IRQ
        rirb_counter_ = 0;
        PopCorbEntries();
      }
      break;
    }
    case offsetof(Ich9HdaRegisters, interrupt_control):
    case offsetof(Ich9HdaRegisters, wake_enable):
      memcpy((uint8_t*)&regs_ + offset, data, size);
      CheckIrqLevel();
      break;
    case offsetof(Ich9HdaRegisters, corb_write_pointer):
    case offsetof(Ich9HdaRegisters, corb_control):
      memcpy((uint8_t*)&regs_ + offset, data, size);
      PopCorbEntries();
      break;
    case offsetof(Ich9HdaRegisters, rirb_write_pointer):
      memcpy((uint8_t*)&regs_ + offset, data, size);
      if (regs_.rirb_write_pointer & ICH6_RIRBWP_RST) { // reset bit
        regs_.rirb_write_pointer = 0;
      }
      break;
    default:
      memcpy((uint8_t*)&regs_ + offset, data, size);
      break;
    }
  }

  void ParseBufferDescriptorList(uint64_t index) {
    auto &stream = regs_.streams[index];
    auto &stream_state = stream_states_[index];
    stream_state.buffers.clear();
    uint64_t addr = ((uint64_t)stream.bdl_base1 << 32) + stream.bdl_base0;
    MV_ASSERT((addr & 127) == 0); // aligned by 128 bytes

    Ich9HdaBdlEntry* entries = (Ich9HdaBdlEntry*)manager_->TranslateGuestMemory(addr);
    for (int i = 0; i <= stream.last_valid_index; i++) {
      if (index < 4) { // IN
        manager_->AddDirtyMemory(entries[i].address, entries[i].length);
      }

      auto buffer = HdaCodecBuffer {
        .data = (uint8_t*)manager_->TranslateGuestMemory(entries[i].address),
        .length = entries[i].length,
        .interrupt_on_completion = !!(entries[i].flags & 1),
        .read_counter = 0
      };

      if (debug_) {
        MV_LOG("buffer addr=0x%lx len=0x%x ioc=%d", entries[i].address, buffer.length, entries[i].flags);
      }
      stream_state.buffers.push_back(buffer);
    }
    stream_state.buffers_index = 0;
    stream.link_position_in_buffer = 0;
  }

  size_t TransferStreamData(uint64_t index, uint8_t* destination, size_t length) {
    auto &stream = regs_.streams[index];
    auto &stream_state = stream_states_[index];
    MV_ASSERT(stream_state.buffers_index <= stream.last_valid_index);

    bool interrupt = false;
    size_t copied = 0;
    while (copied < length && !interrupt) {
      auto &entry = stream_state.buffers[stream_state.buffers_index];
      size_t to_copy = length - copied;
      if (to_copy > entry.length - entry.read_counter) {
        to_copy = entry.length - entry.read_counter;
      }

      /* IN or OUT */
      if (index >= 4) {
        memcpy(&destination[copied], entry.data + entry.read_counter, to_copy);
      } else {
        memcpy(entry.data + entry.read_counter, &destination[copied], to_copy);
      }
      stream.link_position_in_buffer += to_copy;
      entry.read_counter += to_copy;
      copied += to_copy;

      /* Check if we should read next buffer */
      if (entry.read_counter == entry.length) {
        entry.read_counter = 0;
        stream_state.buffers_index++;

        if (stream_state.buffers_index > stream.last_valid_index) {
          stream.link_position_in_buffer = 0;
          stream_state.buffers_index = 0;
        }
        if (entry.interrupt_on_completion) {
          interrupt = true;
        }
      }
    }

    /* Linux uses this */
    if(regs_.dp_base & 1) {
      auto ptr = (uint64_t*)manager_->TranslateGuestMemory(regs_.dp_base & ~1);
      ptr[index] = stream.link_position_in_buffer;
    }
    if (interrupt) {
      stream.status |= 1 << 2;
      CheckIrqLevel();
    }
    if (debug_) {
      MV_LOG("stream[%d] nr=%d dma transferred %d bytes", index, stream.stream_id, copied);
    }
    return copied;
  }

  void StartStopStream(uint64_t index) {
    auto &stream = regs_.streams[index];
    if (stream.control & 0x02) { // start
      if (debug_) {
        MV_LOG("stream[%d] nr=%d start, ring buf %d bytes", index, stream.stream_id, stream.cyclic_buffer_length);
      }
      ParseBufferDescriptorList(index);

      for (auto codec : codecs_) {
        codec->StartStream(stream.stream_id, index >= 4,
          [index, this](uint8_t* destination, size_t length) -> size_t {
          return TransferStreamData(index, destination, length);
        });
      }
    } else { // stop
      if (debug_) {
        MV_LOG("stream[%d] nr=%d stop", index, stream.stream_id);
      }
      for (auto codec : codecs_) {
        codec->StopStream(stream.stream_id, index >= 4);
      }
    }
  }

  void WriteStreamControl(uint64_t index, uint8_t control) {
    auto &stream = regs_.streams[index];
    uint8_t old_control = stream.control;
    stream.control = control;
    if (stream.control & 0x01) { // reset
      if (debug_) {
        MV_LOG("streams[%d] reset", index);
      }
      stream.status = 0x20; // FIFO ready
    }

    if ((stream.control & 0x02) != (old_control & 0x02)) {
      StartStopStream(index);
    }
    CheckIrqLevel();
  }

  void WriteStreamDescriptor(uint64_t index, uint64_t offset, uint8_t* data, uint32_t size) {
    auto &stream = regs_.streams[index];
    switch (offset)
    {
    case offsetof(Ich9HdaStream, control):
      MV_ASSERT(size == 1);
      WriteStreamControl(index, data[0]);
      break;
    case offsetof(Ich9HdaStream, status):
      stream.status &= ~(data[0] & 0x1C);
      CheckIrqLevel();
      break;
    default:
      memcpy((uint8_t*)&stream + offset, data, size);
      break;
    }
  }

  void PopCorbEntries() {
    MV_ASSERT((regs_.ics & ICH6_IRS_BUSY) == 0);

    while (true) {
      if (!(regs_.corb_control & ICH6_CORBCTL_RUN)) {
        return;
      }
      if ((regs_.corb_read_pointer & 0xFF) == regs_.corb_write_pointer) {
        return;
      }
      if (rirb_counter_ == regs_.rirb_interrupt_count) {
        MV_WARN("rirb count reached");
        return;
      }

      uint32_t read_pointer = (regs_.corb_read_pointer + 1) & 0xFF;
      uint64_t addr = ((uint64_t)regs_.corb_base1 << 32) + regs_.corb_base0;
      uint32_t* ptr = (uint32_t*)manager_->TranslateGuestMemory(addr + 4 * read_pointer);
      regs_.corb_read_pointer = read_pointer;
      uint32_t entry = *ptr;
      ParseCorbEntry(entry);
    }
  }

  void ParseCorbEntry(uint32_t entry) {
    uint8_t codec_index = (entry >> 28) & 0x0F;
    uint8_t node_id = (entry >> 20) & 0x7F;
    uint32_t data = entry & 0xFFFFF;
    MV_ASSERT(codec_index < codecs_.size());
    auto codec = codecs_[codec_index];
    codec->StartCommand(node_id, data, [=](uint32_t response) {
      PushRirbEntry(codec_index, response);
    });
  }

  void PushRirbEntry(uint8_t codec_index, uint32_t response) {
    if (!(regs_.rirb_control & (1 << 1))) {
      MV_ERROR("RIRB DMA is not supported");
      return;
    }
    bool solicited = true;
    uint32_t extended = (solicited ? 0 : (1 << 4)) | codec_index;
    uint32_t write_pointer = (regs_.rirb_write_pointer + 1) & 0xFF;
    uint64_t addr = ((uint64_t)regs_.rirb_base1 << 32) + regs_.rirb_base0;

    auto gpa = addr + 8 * write_pointer;
    uint32_t* ptr = (uint32_t*)manager_->TranslateGuestMemory(gpa);
    manager_->AddDirtyMemory(gpa, sizeof(uint32_t) * 2);
    ptr[0] = response;
    ptr[1] = extended;
    regs_.rirb_write_pointer = write_pointer;
    rirb_counter_++;

    if (debug_) {
      MV_LOG("codec_index=%d wp=%x response=0x%x extended=0x%x", codec_index,
        write_pointer, response, extended);
    }

    if (regs_.rirb_control & ICH6_RBCTL_IRQ_EN) {
      // only raise interrupt if CORB is empty or RIRB is full
      if ((regs_.corb_read_pointer & 0xFF) == regs_.corb_write_pointer ||
        rirb_counter_ == regs_.rirb_interrupt_count) {
        regs_.rirb_status |= ICH6_RBSTS_IRQ;
        CheckIrqLevel();
      }
    }
  }
};

DECLARE_DEVICE(Ich9Hda);

```

`devices/audio/ich9_hda.h`:

```h
/* 
 * MVisor ICH9 High Definition Audio Device
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_AUDIO_ICH9_HDA_H
#define _MVISOR_DEVICES_AUDIO_ICH9_HDA_H

#include <cstdint>

struct Ich9HdaBdlEntry {
  uint64_t address;
  uint32_t length;
  uint32_t flags;
} __attribute__((packed));

struct Ich9HdaStream {
  uint8_t   control;
  uint8_t   pad0;
  uint8_t   stripe_control : 2;
  uint8_t   traffic_priority : 1;
  uint8_t   bidirectional : 1;
  uint8_t   stream_id : 4;
  uint8_t   status;
  uint32_t  link_position_in_buffer;
  uint32_t  cyclic_buffer_length;
  uint16_t  last_valid_index;
  uint8_t   pad1[2];

  uint16_t  fifo_size;
  uint16_t  format;
  uint8_t   pad2[4];
  uint32_t  bdl_base0;
  uint32_t  bdl_base1;
} __attribute__((packed));

struct Ich9HdaRegisters {
  /* 0x00-0x20 global */
  uint16_t  global_capabilities;      // includes number of DMA engines for input and output streams
  uint8_t   minor_version;
  uint8_t   major_version;
  uint16_t  output_payload_capacity;
  uint16_t  input_payload_capacity;
  uint32_t  global_control;           // used to reset the link and codec
  uint16_t  wake_enable;
  uint16_t  state_change_status;
  uint8_t   pad1[0x10];
  /* 0x20-0x30 interrupts */
  uint32_t  interrupt_control;
  uint32_t  interrupt_status;
  uint8_t   pad2[0x8];
  /* 0x30-0x40 misc */
  uint32_t  wall_clock_counter;
  uint8_t   pad3[0xC];
  /* 0x40-0x60 dma engine */
  uint32_t  corb_base0;
  uint32_t  corb_base1;
  uint16_t  corb_write_pointer;
  uint16_t  corb_read_pointer;
  uint8_t   corb_control;
  uint8_t   corb_status;
  uint8_t   corb_size;
  uint8_t   pad4[0x1];
  uint32_t  rirb_base0;
  uint32_t  rirb_base1;
  uint16_t  rirb_write_pointer;
  uint16_t  rirb_interrupt_count;
  uint8_t   rirb_control;
  uint8_t   rirb_status;
  uint8_t   rirb_size;
  uint8_t   pad5[0x1];
  /* 0x60-0x80 not used */
  uint32_t  icw;
  uint32_t  irr;
  uint32_t  ics;
  uint8_t   pad6[0x4];
  uint64_t  dp_base;
  uint8_t   pad7[0x8];
  /* 0x80-0x180 streams */
  Ich9HdaStream streams[8];
} __attribute__((packed));

#endif // _MVISOR_DEVICES_AUDIO_ICH9_HDA_H

```

`devices/audio/ich9_hda.proto`:

```proto
syntax = "proto3";

message Ich9HdaState {
  bytes   hda_registers       = 1;
  uint32  rirb_counter        = 2;
  uint64  wall_clock_counter  = 3;
}

```

`devices/audio/meson.build`:

```build
mvisor_sources += files(
  'ac97.cc',
  'hda_codec.h',
  'hda_duplex.cc',
  'hda_internal.h',
  'ich9_hda.cc',
  'ich9_hda.h'
)

proto_sources += proto_gen.process(
  'ac97.proto',
  'hda_duplex.proto',
  'ich9_hda.proto'
)

```

`devices/display/meson.build`:

```build
mvisor_sources += files(
  'vbe.h',
  'vga.cc',
  'vga.h'
)

proto_sources += proto_gen.process(
  'vga.proto'
)

if get_option('qxl')
  subdir('qxl')
endif

```

`devices/display/qxl/canvas/canvas_base.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#include "config.h"

#include <stdarg.h>
#include <stdlib.h>
#include <setjmp.h>
#include <stdio.h>
#include <math.h>

#ifdef USE_LZ4
#include <lz4.h>
#endif
#include <spice/macros.h>
#include "log.h"
#include "quic.h"
#include "lz.h"
#include "canvas_base.h"
#include "pixman_utils.h"
#include "canvas_utils.h"
#include "rect.h"
#include "lines.h"
#include "rop3.h"
#include "mem.h"
#include "macros.h"

#include <spice/start-packed.h>
typedef struct SPICE_ATTR_PACKED {
    uint32_t v;
} uint32_unaligned_t;
#include <spice/end-packed.h>

#define READ_UINT32_BE(ptr) GUINT32_FROM_BE(((uint32_unaligned_t *)(ptr))->v)

#define ROUND(_x) ((int)floor((_x) + 0.5))

 static inline int fix_to_int(SPICE_FIXED28_4 fixed)
{
    int val, rem;

    rem = fixed & 0x0f;
    val = fixed >> 4;
    if (rem > 8) {
        val++;
    }
    return val;
}

 static inline SPICE_FIXED28_4  int_to_fix(int v)
{
    return v << 4;
}

static inline double fix_to_double(SPICE_FIXED28_4 fixed)
{
    return (double)(fixed & 0x0f) / 0x0f + (fixed >> 4);
}

static inline uint16_t rgb_32_to_16_555(uint32_t color)
{
    return
        (((color) >> 3) & 0x001f) |
        (((color) >> 6) & 0x03e0) |
        (((color) >> 9) & 0x7c00);
}
static inline uint16_t rgb_32_to_16_565(uint32_t color)
{
    return
        (((color) >> 3) & 0x001f) |
        (((color) >> 5) & 0x07e0) |
        (((color) >> 8) & 0xf800);
}

static inline uint32_t canvas_16bpp_to_32bpp(uint32_t color)
{
    uint32_t ret;

    ret = ((color & 0x001f) << 3) | ((color & 0x001c) >> 2);
    ret |= ((color & 0x03e0) << 6) | ((color & 0x0380) << 1);
    ret |= ((color & 0x7c00) << 9) | ((color & 0x7000) << 4);

    return ret;
}

typedef struct LzData {
    LzUsrContext usr;
    LzContext *lz;
    LzDecodeUsrData decode_data;
    jmp_buf jmp_env;
    char message_buf[512];
} LzData;

typedef struct GlzData {
    SpiceGlzDecoder *decoder;
    LzDecodeUsrData decode_data;
} GlzData;

typedef struct QuicData {
    QuicUsrContext usr;
    QuicContext *quic;
    jmp_buf jmp_env;
    char message_buf[512];
    SpiceChunks *chunks;
    uint32_t current_chunk;
} QuicData;

typedef struct CanvasBase {
    SpiceCanvas parent;
    uint32_t color_shift;
    uint32_t color_mask;
    QuicData quic_data;

    uint32_t format;
    int width;
    int height;
    pixman_region32_t canvas_region;

    SpiceImageCache *bits_cache;
#ifdef SW_CANVAS_CACHE
    SpicePaletteCache *palette_cache;
#endif

    SpiceImageSurfaces *surfaces;

    LzData lz_data;
    GlzData glz_data;
    SpiceJpegDecoder* jpeg;
    SpiceZlibDecoder* zlib;
} CanvasBase;

typedef enum {
    ROP_INPUT_SRC,
    ROP_INPUT_BRUSH,
    ROP_INPUT_DEST
} ROPInput;

static SpiceROP ropd_descriptor_to_rop(int desc,
                                       ROPInput src_input,
                                       ROPInput dest_input)
{
    int old;
    int invert_masks[] = {
        SPICE_ROPD_INVERS_SRC,
        SPICE_ROPD_INVERS_BRUSH,
        SPICE_ROPD_INVERS_DEST
    };

    old = desc;

    desc &= ~(SPICE_ROPD_INVERS_SRC | SPICE_ROPD_INVERS_DEST);
    if (old & invert_masks[src_input]) {
        desc |= SPICE_ROPD_INVERS_SRC;
    }

    if (old & invert_masks[dest_input]) {
        desc |= SPICE_ROPD_INVERS_DEST;
    }

    if (desc & SPICE_ROPD_OP_PUT) {
        if (desc & SPICE_ROPD_INVERS_SRC) {
            if (desc & SPICE_ROPD_INVERS_RES) {
                return SPICE_ROP_COPY;
            }
            return SPICE_ROP_COPY_INVERTED;
        } else {
            if (desc & SPICE_ROPD_INVERS_RES) {
                return SPICE_ROP_COPY_INVERTED;
            }
            return SPICE_ROP_COPY;
        }
    } else if (desc & SPICE_ROPD_OP_OR) {

        if (desc & SPICE_ROPD_INVERS_RES) {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(!src or !dest) == src and dest*/
                    return SPICE_ROP_AND;
                } else {
                    /* ! (!src or dest) = src and !dest*/
                    return SPICE_ROP_AND_REVERSE;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(src or !dest) == !src and dest */
                    return SPICE_ROP_AND_INVERTED;
                } else {
                    /* !(src or dest) */
                    return SPICE_ROP_NOR;
                }
            }
        } else {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !src or !dest == !(src and dest)*/
                    return SPICE_ROP_NAND;
                } else {
                    /* !src or dest */
                    return SPICE_ROP_OR_INVERTED;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* src or !dest */
                    return SPICE_ROP_OR_REVERSE;
                } else {
                    /* src or dest */
                    return SPICE_ROP_OR;
                }
            }
        }

    } else if (desc & SPICE_ROPD_OP_AND) {

        if (desc & SPICE_ROPD_INVERS_RES) {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(!src and !dest) == src or dest*/
                    return SPICE_ROP_OR;
                } else {
                    /* ! (!src and dest) = src or !dest*/
                    return SPICE_ROP_OR_REVERSE;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(src and !dest) == !src or dest */
                    return SPICE_ROP_OR_INVERTED;
                } else {
                    /* !(src and dest) */
                    return SPICE_ROP_NAND;
                }
            }
        } else {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !src and !dest == !(src or dest)*/
                    return SPICE_ROP_NOR;
                } else {
                    /* !src and dest */
                    return SPICE_ROP_AND_INVERTED;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* src and !dest */
                    return SPICE_ROP_AND_REVERSE;
                } else {
                    /* src and dest */
                    return SPICE_ROP_AND;
                }
            }
        }

    } else if (desc & SPICE_ROPD_OP_XOR) {

        if (desc & SPICE_ROPD_INVERS_RES) {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(!src xor !dest) == !src xor dest */
                    return SPICE_ROP_EQUIV;
                } else {
                    /* ! (!src xor dest) = src xor dest*/
                    return SPICE_ROP_XOR;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !(src xor !dest) == src xor dest */
                    return SPICE_ROP_XOR;
                } else {
                    /* !(src xor dest) */
                    return SPICE_ROP_EQUIV;
                }
            }
        } else {
            if (desc & SPICE_ROPD_INVERS_SRC) {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* !src xor !dest == src xor dest */
                    return SPICE_ROP_XOR;
                } else {
                    /* !src xor dest */
                    return SPICE_ROP_EQUIV;
                }
            } else {
                if (desc & SPICE_ROPD_INVERS_DEST) {
                    /* src xor !dest */
                    return SPICE_ROP_EQUIV;
                } else {
                    /* src xor dest */
                    return SPICE_ROP_XOR;
                }
            }
        }

    } else if (desc & SPICE_ROPD_OP_BLACKNESS) {
        return SPICE_ROP_CLEAR;
    } else if (desc & SPICE_ROPD_OP_WHITENESS) {
        return SPICE_ROP_SET;
    } else if (desc & SPICE_ROPD_OP_INVERS) {
        return SPICE_ROP_INVERT;
    }
    return SPICE_ROP_COPY;
}

//#define DEBUG_DUMP_COMPRESS
#ifdef DEBUG_DUMP_COMPRESS
static void dump_surface(pixman_image_t *surface, int cache);
#endif


static pixman_format_code_t canvas_get_target_format(CanvasBase *canvas,
                                                     int source_has_alpha)
{
    pixman_format_code_t format;

    /* Convert to target surface format */
    format = spice_surface_format_to_pixman (canvas->format);

    if (source_has_alpha) {
        /* Even though the destination has no alpha, we make the source
         * remember there are alpha bits instead of throwing away this
         * information. The results are the same if alpha is not
         * interpreted, and if need to interpret alpha, don't use
         * conversion to target format.
         * This is needed for instance when doing the final
         * canvas_get_target_format() in canvas_get_image_internal
         * as otherwise we wouldn't know if the bitmap source
         * really had alpha.
         */
        if (format == PIXMAN_x8r8g8b8) {
            format = PIXMAN_a8r8g8b8;
        }
    } else { /* !source_has_alpha */
        /* If the source doesn't have alpha, but the destination has,
           don't convert to alpha, since that would just do an unnecessary
           copy to fill the alpha bytes with 0xff which is not expected if
           we just use the raw bits, (and handled implicitly by pixman if
           we're interpreting data) */
        if (format == PIXMAN_a8r8g8b8) {
            format = PIXMAN_x8r8g8b8;
        }
    }

    return format;
}

static pixman_image_t *canvas_get_quic(CanvasBase *canvas, SpiceImage *image,
                                       int want_original)
{
    pixman_image_t *surface = NULL;
    QuicData *quic_data = &canvas->quic_data;
    QuicImageType type, as_type;
    pixman_format_code_t pixman_format;
    uint8_t *dest;
    int stride;
    int width;
    int height;

    if (setjmp(quic_data->jmp_env)) {
        if (surface != NULL) {
            pixman_image_unref(surface);
        }
        g_warning("%s", quic_data->message_buf);
        return NULL;
    }

    quic_data->chunks = image->u.quic.data;
    quic_data->current_chunk = 0;

    if (quic_decode_begin(quic_data->quic,
                          SPICE_UNALIGNED_CAST(uint32_t *,image->u.quic.data->chunk[0].data),
                          image->u.quic.data->chunk[0].len >> 2,
                          &type, &width, &height) == QUIC_ERROR) {
        g_warning("quic decode begin failed");
        return NULL;
    }

    switch (type) {
    case QUIC_IMAGE_TYPE_RGBA:
        as_type = QUIC_IMAGE_TYPE_RGBA;
        pixman_format = PIXMAN_LE_a8r8g8b8;
        break;
    case QUIC_IMAGE_TYPE_RGB32:
    case QUIC_IMAGE_TYPE_RGB24:
        as_type = QUIC_IMAGE_TYPE_RGB32;
        pixman_format = PIXMAN_LE_x8r8g8b8;
        break;
    case QUIC_IMAGE_TYPE_RGB16:
        if (!want_original &&
            (canvas->format == SPICE_SURFACE_FMT_32_xRGB ||
             canvas->format == SPICE_SURFACE_FMT_32_ARGB)) {
            as_type = QUIC_IMAGE_TYPE_RGB32;
            pixman_format = PIXMAN_LE_x8r8g8b8;
        } else {
            as_type = QUIC_IMAGE_TYPE_RGB16;
            pixman_format = PIXMAN_x1r5g5b5;
        }
        break;
    case QUIC_IMAGE_TYPE_INVALID:
    case QUIC_IMAGE_TYPE_GRAY:
    default:
        spice_warn_if_reached();
        return NULL;
    }

    spice_return_val_if_fail((uint32_t)width == image->descriptor.width, NULL);
    spice_return_val_if_fail((uint32_t)height == image->descriptor.height, NULL);

    surface = surface_create(pixman_format,
                             width, height, FALSE);

    spice_return_val_if_fail(surface != NULL, NULL);

    dest = (uint8_t *)pixman_image_get_data(surface);
    stride = pixman_image_get_stride(surface);
    if (quic_decode(quic_data->quic, as_type,
                    dest, stride) == QUIC_ERROR) {
        pixman_image_unref(surface);
        g_warning("quic decode failed");
        return NULL;
    }

#ifdef DEBUG_DUMP_COMPRESS
    dump_surface(surface, 0);
#endif
    return surface;
}


//#define DUMP_JPEG
static void
dump_jpeg(SPICE_GNUC_UNUSED SpiceChunks* data, SPICE_GNUC_UNUSED uint32_t data_size)
{
#ifdef DUMP_JPEG
    static uint32_t jpeg_id = 0;
    char file_str[200];
    uint32_t id = ++jpeg_id;

#ifdef WIN32
    sprintf(file_str, "c:\\tmp\\spice_dump\\%u.jpg", id);
#else
    sprintf(file_str, "/tmp/spice_dump/%u.jpg", id);
#endif

    FILE *f = fopen(file_str, "wb");
    if (!f) {
        return;
    }

    for (uint32_t n = 0; n < data->num_chunks; ++n) {
        fwrite(data->chunk[n].data, 1, data->chunk[n].len, f);
    }
    fclose(f);
#endif
}

static pixman_image_t *canvas_get_jpeg(CanvasBase *canvas, SpiceImage *image)
{
    pixman_image_t *surface = NULL;
    int stride;
    int width;
    int height;
    uint8_t *dest;

    spice_return_val_if_fail(image->u.jpeg.data->num_chunks == 1, NULL);
    canvas->jpeg->ops->begin_decode(canvas->jpeg, image->u.jpeg.data->chunk[0].data, image->u.jpeg.data->chunk[0].len,
                                    &width, &height);
    spice_return_val_if_fail((uint32_t)width == image->descriptor.width, NULL);
    spice_return_val_if_fail((uint32_t)height == image->descriptor.height, NULL);

    surface = surface_create(PIXMAN_LE_x8r8g8b8,
                             width, height, FALSE);
    if (surface == NULL) {
        g_warning("create surface failed");
        return NULL;
    }

    dest = (uint8_t *)pixman_image_get_data(surface);
    stride = pixman_image_get_stride(surface);

    canvas->jpeg->ops->decode(canvas->jpeg, dest, stride, SPICE_BITMAP_FMT_32BIT);

    dump_jpeg(image->u.jpeg.data, image->u.jpeg.data_size);
    return surface;
}

#if defined(USE_LZ4) || defined(SW_CANVAS_CACHE)
static void canvas_fix_alignment(uint8_t *bits,
                                 int stride_encoded, int stride_pixman,
                                 int height)
{
    if (stride_pixman > stride_encoded) {
        // Fix the row alignment
        int row;
        for (row = height - 1; row > 0; --row) {
            uint8_t *aligned, *misaligned;
            aligned = bits + stride_pixman*row;
            misaligned = bits + stride_encoded*row;
            memmove(aligned, misaligned, stride_encoded);
        }
    }
}
#endif

#ifdef USE_LZ4
static pixman_image_t *canvas_get_lz4(CanvasBase *canvas, SpiceImage *image)
{
    pixman_image_t *surface = NULL;
    int dec_size, enc_size, available;
    int stride, stride_abs, stride_encoded;
    uint8_t *dest, *data, *data_end, *bits;
    int width, height, top_down;
    LZ4_streamDecode_t *stream;
    uint8_t spice_format;
    pixman_format_code_t format;

    spice_chunks_linearize(image->u.lz4.data);
    data = image->u.lz4.data->chunk[0].data;
    data_end = data + image->u.lz4.data->chunk[0].len;
    width = image->descriptor.width;
    stride_encoded = width;
    height = image->descriptor.height;
    if (data + 2 > data_end) {
        g_warning("missing header in LZ4 data");
        return NULL;
    }
    top_down = !!*(data++);
    spice_format = *(data++);
    switch (spice_format) {
        case SPICE_BITMAP_FMT_16BIT:
            format = PIXMAN_x1r5g5b5;
            stride_encoded *= 2;
            break;
        case SPICE_BITMAP_FMT_24BIT:
            format = PIXMAN_LE_r8g8b8;
            stride_encoded *= 3;
            break;
        case SPICE_BITMAP_FMT_32BIT:
            format = PIXMAN_LE_x8r8g8b8;
            stride_encoded *= 4;
            break;
        case SPICE_BITMAP_FMT_RGBA:
            format = PIXMAN_LE_a8r8g8b8;
            stride_encoded *= 4;
            break;
        default:
            g_warning("unsupported bitmap format %d with LZ4", spice_format);
            return NULL;
    }

    surface = surface_create(format,
                             width, height, top_down);
    if (surface == NULL) {
        g_warning("create surface failed");
        return NULL;
    }

    stream = LZ4_createStreamDecode();
    dest = (uint8_t *)pixman_image_get_data(surface);
    stride = pixman_image_get_stride(surface);
    stride_abs = abs(stride);
    available = height * stride_abs;
    if (!top_down) {
        dest -= (stride_abs * (height - 1));
    }
    bits = dest;

    do {
        if (data + 4 > data_end) {
            goto format_error;
        }
        // Read next compressed block
        enc_size = READ_UINT32_BE(data);
        data += 4;
        /* check overflow. This check is a bit different to avoid
         * possible overflows. From previous check data_end - data cannot overflow.
         * Computing data + enc_size on 32 bit could cause overflows. */
        if (enc_size < 0 || data_end - data < (unsigned int) enc_size) {
            goto format_error;
        }
        dec_size = LZ4_decompress_safe_continue(stream, (const char *) data,
                                                (char *) dest, enc_size, available);
        if (dec_size <= 0) {
            goto format_error;
        }
        dest += dec_size;
        available -= dec_size;
        data += enc_size;
    } while (data < data_end);

    canvas_fix_alignment(bits, stride_encoded, stride_abs, height);

    LZ4_freeStreamDecode(stream);
    return surface;

format_error:
    g_warning("error decoding LZ4 block");
    LZ4_freeStreamDecode(stream);
    pixman_image_unref(surface);
    return NULL;
}
#endif

static pixman_image_t *canvas_get_jpeg_alpha(CanvasBase *canvas, SpiceImage *image)
{
    pixman_image_t *surface = NULL;
    int stride;
    int width;
    int height;
    uint8_t *dest;
    int alpha_top_down = FALSE;
    LzData *lz_data = &canvas->lz_data;
    LzImageType lz_alpha_type;
    uint8_t *comp_alpha_buf = NULL;
    uint8_t *decomp_alpha_buf = NULL;
    int alpha_size;
    int lz_alpha_width, lz_alpha_height, n_comp_pixels, lz_alpha_top_down;

    spice_return_val_if_fail(image->u.jpeg_alpha.data->num_chunks == 1, NULL);
    canvas->jpeg->ops->begin_decode(canvas->jpeg,
                                    image->u.jpeg_alpha.data->chunk[0].data,
                                    image->u.jpeg_alpha.jpeg_size,
                                    &width, &height);
    spice_return_val_if_fail((uint32_t)width == image->descriptor.width, NULL);
    spice_return_val_if_fail((uint32_t)height == image->descriptor.height, NULL);

    if (image->u.jpeg_alpha.flags & SPICE_JPEG_ALPHA_FLAGS_TOP_DOWN) {
        alpha_top_down = TRUE;
    }

    surface = alloc_lz_image_surface(&lz_data->decode_data, PIXMAN_LE_a8r8g8b8,
                                     width, height, width*height, alpha_top_down);

    if (surface == NULL) {
        g_warning("create surface failed");
        return NULL;
    }

    dest = (uint8_t *)pixman_image_get_data(surface);
    stride = pixman_image_get_stride(surface);

    canvas->jpeg->ops->decode(canvas->jpeg, dest, stride, SPICE_BITMAP_FMT_32BIT);

    comp_alpha_buf = image->u.jpeg_alpha.data->chunk[0].data + image->u.jpeg_alpha.jpeg_size;
    alpha_size = image->u.jpeg_alpha.data_size - image->u.jpeg_alpha.jpeg_size;

    lz_decode_begin(lz_data->lz, comp_alpha_buf, alpha_size, &lz_alpha_type,
                    &lz_alpha_width, &lz_alpha_height, &n_comp_pixels,
                    &lz_alpha_top_down, NULL);
    spice_return_val_if_fail(lz_alpha_type == LZ_IMAGE_TYPE_XXXA, NULL);
    spice_return_val_if_fail(!!lz_alpha_top_down == !!alpha_top_down, NULL);
    spice_return_val_if_fail(lz_alpha_width == width, NULL);
    spice_return_val_if_fail(lz_alpha_height == height, NULL);
    spice_return_val_if_fail(n_comp_pixels == width * height, NULL);

    if (!alpha_top_down) {
        decomp_alpha_buf = dest + stride * (height - 1);
    } else {
        decomp_alpha_buf = dest;
    }
    lz_decode(lz_data->lz, LZ_IMAGE_TYPE_XXXA, decomp_alpha_buf);

    dump_jpeg(image->u.jpeg_alpha.data, image->u.jpeg_alpha.jpeg_size);
    return surface;
}

static pixman_image_t *canvas_bitmap_to_surface(CanvasBase *canvas, SpiceBitmap* bitmap,
                                                SpicePalette *palette, int want_original)
{
    uint8_t* src;
    pixman_image_t *image;
    pixman_format_code_t format;

    spice_chunks_linearize(bitmap->data);

    src = bitmap->data->chunk[0].data;

    if (want_original) {
        format = spice_bitmap_format_to_pixman(bitmap->format, canvas->format);
    } else {
        format = canvas_get_target_format(canvas,
                                          bitmap->format == SPICE_BITMAP_FMT_RGBA);
    }

    image = surface_create(format,
                           bitmap->x, bitmap->y, FALSE);
    if (image == NULL) {
        g_warning("create surface failed");
        return NULL;
    }

    spice_bitmap_convert_to_pixman(format, image,
                                   bitmap->format,
                                   bitmap->flags,
                                   bitmap->x, bitmap->y,
                                   src, bitmap->stride,
                                   canvas->format, palette);
    return image;
}


#ifdef SW_CANVAS_CACHE

static inline SpicePalette *canvas_get_palette(CanvasBase *canvas, SpicePalette *base_palette, uint64_t palette_id, uint8_t flags)
{
    SpicePalette *palette;

    if (flags & SPICE_BITMAP_FLAGS_PAL_FROM_CACHE) {
        palette = canvas->palette_cache->ops->get(canvas->palette_cache, palette_id);
    } else {
        palette = base_palette;
        if (palette != NULL && flags & SPICE_BITMAP_FLAGS_PAL_CACHE_ME) {
            canvas->palette_cache->ops->put(canvas->palette_cache, palette);
        }
    }
    return palette;
}

static inline SpicePalette *canvas_get_localized_palette(CanvasBase *canvas, SpicePalette *base_palette, uint64_t palette_id, uint8_t flags, int *free_palette)
{
    SpicePalette *palette = canvas_get_palette(canvas, base_palette, palette_id, flags);
    SpicePalette *copy;
    uint32_t *now, *end;

    if (canvas->format == SPICE_SURFACE_FMT_32_xRGB ||
        canvas->format == SPICE_SURFACE_FMT_32_ARGB) {
        return palette;
    }

    copy = spice_memdup(palette, sizeof(SpicePalette) + palette->num_ents * 4);

    switch (canvas->format) {
    case SPICE_SURFACE_FMT_32_xRGB:
    case SPICE_SURFACE_FMT_32_ARGB:
        /* Won't happen */
        break;
    case SPICE_SURFACE_FMT_16_555:
        now = copy->ents;
        end = now + copy->num_ents;
        for (; now < end; now++) {
            *now = canvas_16bpp_to_32bpp(*now);
        }
        break;
    case SPICE_SURFACE_FMT_16_565:
    default:
        spice_warn_if_reached();
        free(copy);
        return NULL;
    }
    *free_palette = TRUE;
    return copy;
}

static pixman_image_t *canvas_get_lz(CanvasBase *canvas, SpiceImage *image,
                                     int want_original)
{
    LzData *lz_data = &canvas->lz_data;
    uint8_t *comp_buf = NULL;
    int comp_size;
    uint8_t    *decomp_buf = NULL;
    pixman_format_code_t pixman_format;
    LzImageType type, as_type;
    SpicePalette *palette = NULL;
    int n_comp_pixels;
    int width;
    int height;
    int top_down;
    int stride_encoded;
    int stride;
    volatile int free_palette = FALSE;

    if (setjmp(lz_data->jmp_env)) {
        if (free_palette)  {
            free(palette);
        }
        free(decomp_buf);
        g_warning("%s", lz_data->message_buf);
        return NULL;
    }

    if (image->descriptor.type == SPICE_IMAGE_TYPE_LZ_RGB) {
        spice_return_val_if_fail(image->u.lz_rgb.data->num_chunks == 1, NULL); /* TODO: Handle chunks */
        comp_buf = image->u.lz_rgb.data->chunk[0].data;
        comp_size = image->u.lz_rgb.data->chunk[0].len;
        palette = NULL;
    } else if (image->descriptor.type == SPICE_IMAGE_TYPE_LZ_PLT) {
        spice_return_val_if_fail(image->u.lz_plt.data->num_chunks == 1, NULL); /* TODO: Handle chunks */
        comp_buf = image->u.lz_plt.data->chunk[0].data;
        comp_size = image->u.lz_plt.data->chunk[0].len;
        palette = canvas_get_localized_palette(canvas, image->u.lz_plt.palette,
                                               image->u.lz_plt.palette_id, image->u.lz_plt.flags,
                                               (int*) &free_palette);
    } else {
        spice_warn_if_reached();
        return NULL;
    }

    lz_decode_begin(lz_data->lz, comp_buf, comp_size, &type,
                    &width, &height, &n_comp_pixels, &top_down, palette);

    stride_encoded = n_comp_pixels / height;
    switch (type) {
    case LZ_IMAGE_TYPE_RGBA:
        as_type = LZ_IMAGE_TYPE_RGBA;
        pixman_format = PIXMAN_LE_a8r8g8b8;
        stride_encoded *= 4;
        break;
    case LZ_IMAGE_TYPE_RGB32:
    case LZ_IMAGE_TYPE_RGB24:
    case LZ_IMAGE_TYPE_PLT1_LE:
    case LZ_IMAGE_TYPE_PLT1_BE:
    case LZ_IMAGE_TYPE_PLT4_LE:
    case LZ_IMAGE_TYPE_PLT4_BE:
    case LZ_IMAGE_TYPE_PLT8:
        as_type = LZ_IMAGE_TYPE_RGB32;
        pixman_format = PIXMAN_LE_x8r8g8b8;
        stride_encoded *= 4;
        break;
    case LZ_IMAGE_TYPE_A8:
        as_type = LZ_IMAGE_TYPE_A8;
        pixman_format = PIXMAN_a8;
        break;
    case LZ_IMAGE_TYPE_RGB16:
        if (!want_original &&
            (canvas->format == SPICE_SURFACE_FMT_32_xRGB ||
             canvas->format == SPICE_SURFACE_FMT_32_ARGB)) {
            as_type = LZ_IMAGE_TYPE_RGB32;
            pixman_format = PIXMAN_LE_x8r8g8b8;
            stride_encoded *= 4;
        } else {
            as_type = LZ_IMAGE_TYPE_RGB16;
            pixman_format = PIXMAN_x1r5g5b5;
            stride_encoded *= 2;
        }
        break;
    default:
        spice_warn_if_reached();
        return NULL;
    }

    spice_return_val_if_fail((unsigned)width == image->descriptor.width, NULL);
    spice_return_val_if_fail((unsigned)height == image->descriptor.height, NULL);

    spice_return_val_if_fail((image->descriptor.type == SPICE_IMAGE_TYPE_LZ_PLT) || (n_comp_pixels == width * height), NULL);

    alloc_lz_image_surface(&lz_data->decode_data, pixman_format,
                           width, height, n_comp_pixels, top_down);

    stride = pixman_image_get_stride(lz_data->decode_data.out_surface);
    stride = abs(stride);

    decomp_buf = (uint8_t *)pixman_image_get_data(lz_data->decode_data.out_surface);
    if (!top_down) {
        decomp_buf -= stride * (height - 1);
    }

    lz_decode(lz_data->lz, as_type, decomp_buf);

    canvas_fix_alignment(decomp_buf, stride_encoded, stride, height);

    if (free_palette)  {
        free(palette);
    }

    return lz_data->decode_data.out_surface;
}

static pixman_image_t *canvas_get_glz_rgb_common(CanvasBase *canvas, uint8_t *data,
                                                 int want_original)
{
    spice_return_val_if_fail(canvas->glz_data.decoder != NULL, NULL);

    canvas->glz_data.decoder->ops->decode(canvas->glz_data.decoder,
                                          data, NULL,
                                          &canvas->glz_data.decode_data);

    /* global_decode calls alloc_lz_image, which sets canvas->glz_data.surface */
    return (canvas->glz_data.decode_data.out_surface);
}

// don't handle plts since bitmaps with plt can be decoded globally to RGB32 (because
// same byte sequence can be transformed to different RGB pixels by different plts)
static pixman_image_t *canvas_get_glz(CanvasBase *canvas, SpiceImage *image,
                                      int want_original)
{
    spice_return_val_if_fail(image->descriptor.type == SPICE_IMAGE_TYPE_GLZ_RGB, NULL);

    spice_return_val_if_fail(image->u.lz_rgb.data->num_chunks == 1, NULL); /* TODO: Handle chunks */
    return canvas_get_glz_rgb_common(canvas, image->u.lz_rgb.data->chunk[0].data, want_original);
}

static pixman_image_t *canvas_get_zlib_glz_rgb(CanvasBase *canvas, SpiceImage *image,
                                               int want_original)
{
    uint8_t *glz_data;
    pixman_image_t *surface;

    spice_return_val_if_fail(canvas->zlib != NULL, NULL);

    spice_return_val_if_fail(image->u.zlib_glz.data->num_chunks == 1, NULL); /* TODO: Handle chunks */
    glz_data = (uint8_t*)spice_malloc(image->u.zlib_glz.glz_data_size);
    canvas->zlib->ops->decode(canvas->zlib, image->u.zlib_glz.data->chunk[0].data,
                              image->u.zlib_glz.data->chunk[0].len,
                              glz_data, image->u.zlib_glz.glz_data_size);
    surface = canvas_get_glz_rgb_common(canvas, glz_data, want_original);
    free(glz_data);
    return surface;
}

//#define DEBUG_DUMP_BITMAP

#ifdef DEBUG_DUMP_BITMAP
static void dump_bitmap(SpiceBitmap *bitmap, SpicePalette *palette)
{
    uint8_t* data = (uint8_t *)SPICE_GET_ADDRESS(bitmap->data);
    static uint32_t file_id = 0;
    uint32_t i, j;
    char file_str[200];
    uint32_t id = ++file_id;

#ifdef WIN32
    sprintf(file_str, "c:\\tmp\\spice_dump\\%u.%ubpp", id, bitmap->format);
#else
    sprintf(file_str, "/tmp/spice_dump/%u.%ubpp", id, bitmap->format);
#endif
    FILE *f = fopen(file_str, "wb");
    if (!f) {
        return;
    }

    fprintf(f, "%d\n", bitmap->format);                          // 1_LE,1_BE,....
    fprintf(f, "%d %d\n", bitmap->x, bitmap->y);     // width and height
    fprintf(f, "%d\n", palette->num_ents);               // #plt entries
    for (i = 0; i < palette->num_ents; i++) {
        fwrite(&(palette->ents[i]), 4, 1, f);
    }
    fprintf(f, "\n");

    for (i = 0; i < bitmap->y; i++, data += bitmap->stride) {
        uint8_t *now = data;
        for (j = 0; j < bitmap->x; j++) {
            fwrite(now, 1, 1, f);
            now++;
        }
    }
}

#endif

static pixman_image_t *canvas_get_bits(CanvasBase *canvas, SpiceBitmap *bitmap,
                                       int want_original)
{
    pixman_image_t* surface;
    SpicePalette *palette;

    palette = canvas_get_palette(canvas, bitmap->palette, bitmap->palette_id, bitmap->flags);
#ifdef DEBUG_DUMP_BITMAP
    if (palette) {
        dump_bitmap(bitmap, palette);
    }
#endif

    surface = canvas_bitmap_to_surface(canvas, bitmap, palette, want_original);

    if (palette && (bitmap->flags & SPICE_BITMAP_FLAGS_PAL_FROM_CACHE)) {
        canvas->palette_cache->ops->release(canvas->palette_cache, palette);
    }

    return surface;
}

#else


static pixman_image_t *canvas_get_bits(CanvasBase *canvas, SpiceBitmap *bitmap,
                                       int want_original)
{
    SpicePalette *palette;

    if (!bitmap->palette) {
        return canvas_bitmap_to_surface(canvas, bitmap, NULL, want_original);
    }
    palette = (SpicePalette *)SPICE_GET_ADDRESS(bitmap->palette);
    return canvas_bitmap_to_surface(canvas, bitmap, palette, want_original);
}

#endif



// caution: defining DEBUG_DUMP_SURFACE will dump both cached & non-cached
//          images to disk. it will reduce performance dramatically & eat
//          disk space rapidly. use it only for debugging.
//#define DEBUG_DUMP_SURFACE

#if defined(DEBUG_DUMP_SURFACE) || defined(DEBUG_DUMP_COMPRESS)

static void dump_surface(pixman_image_t *surface, int cache)
{
    static uint32_t file_id = 0;
    int i, j;
    char file_str[200];
    int depth = pixman_image_get_depth(surface);

    if (depth != 24 && depth != 32) {
        return;
    }

    uint8_t *data = (uint8_t *)pixman_image_get_data(surface);
    int width = pixman_image_get_width(surface);
    int height = pixman_image_get_height(surface);
    int stride = pixman_image_get_stride(surface);

    uint32_t id = ++file_id;
#ifdef WIN32
    sprintf(file_str, "c:\\tmp\\spice_dump\\%d\\%u.ppm", cache, id);
#else
    sprintf(file_str, "/tmp/spice_dump/%u.ppm", id);
#endif
    FILE *f = fopen(file_str, "wb");
    if (!f) {
        return;
    }
    fprintf(f, "P6\n");
    fprintf(f, "%d %d\n", width, height);
    fprintf(f, "#spicec dump\n");
    fprintf(f, "255\n");
    for (i = 0; i < height; i++, data += stride) {
        uint8_t *now = data;
        for (j = 0; j < width; j++) {
            fwrite(&now[2], 1, 1, f);
            fwrite(&now[1], 1, 1, f);
            fwrite(&now[0], 1, 1, f);
            now += 4;
        }
    }
    fclose(f);
}

#endif

static SpiceCanvas *canvas_get_surface_internal(CanvasBase *canvas, SpiceImage *image)
{
    if (image->descriptor.type == SPICE_IMAGE_TYPE_SURFACE) {
        SpiceSurface *surface = &image->u.surface;
        return canvas->surfaces->ops->get(canvas->surfaces, surface->surface_id);
    }
    return NULL;
}

static SpiceCanvas *canvas_get_surface_mask_internal(CanvasBase *canvas, SpiceImage *image)
{
    if (image->descriptor.type == SPICE_IMAGE_TYPE_SURFACE) {
        SpiceSurface *surface = &image->u.surface;
        return canvas->surfaces->ops->get(canvas->surfaces, surface->surface_id);
    }
    return NULL;
}


#if defined(SW_CANVAS_CACHE)
static int image_has_palette_to_cache(SpiceImage *image)
{
    SpiceImageDescriptor *descriptor = &image->descriptor;

    if (descriptor->type == SPICE_IMAGE_TYPE_BITMAP) {
        return image->u.bitmap.palette &&
               (image->u.bitmap.flags & SPICE_BITMAP_FLAGS_PAL_CACHE_ME);
    } else if (descriptor->type == SPICE_IMAGE_TYPE_LZ_PLT) {
        return image->u.lz_plt.palette &&
               (image->u.lz_plt.flags & SPICE_BITMAP_FLAGS_PAL_CACHE_ME);
    }
    return FALSE;
}
#endif

//#define DEBUG_LZ

static pixman_image_t *get_surface_from_canvas(CanvasBase *canvas,
                                               SpiceImage *image,
                                               int want_original)
{
    switch (image->descriptor.type) {
    case SPICE_IMAGE_TYPE_QUIC:
        return canvas_get_quic(canvas, image, want_original);

#if defined(SW_CANVAS_CACHE)
    case SPICE_IMAGE_TYPE_LZ_PLT:
    case SPICE_IMAGE_TYPE_LZ_RGB:
        return canvas_get_lz(canvas, image, want_original);

    case SPICE_IMAGE_TYPE_GLZ_RGB:
        return canvas_get_glz(canvas, image, want_original);

    case SPICE_IMAGE_TYPE_ZLIB_GLZ_RGB:
        return canvas_get_zlib_glz_rgb(canvas, image, want_original);

    case SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS:
        return canvas->bits_cache->ops->get_lossless(canvas->bits_cache,
                                                     image->descriptor.id);
#endif

    case SPICE_IMAGE_TYPE_JPEG:
        return canvas_get_jpeg(canvas, image);

    case SPICE_IMAGE_TYPE_JPEG_ALPHA:
        return canvas_get_jpeg_alpha(canvas, image);

    case SPICE_IMAGE_TYPE_LZ4:
#ifdef USE_LZ4
        return canvas_get_lz4(canvas, image);
#else
        g_warning("LZ4 compression algorithm not supported");
        return NULL;
#endif

    case SPICE_IMAGE_TYPE_FROM_CACHE:
        return canvas->bits_cache->ops->get(canvas->bits_cache,
                                            image->descriptor.id);

    case SPICE_IMAGE_TYPE_BITMAP:
        return canvas_get_bits(canvas, &image->u.bitmap, want_original);

    default:
        spice_warn_if_reached();
        return NULL;
    }
}

/* If real get is FALSE, then only do whatever is needed but don't return an image. For instance,
 *  if we need to read it to cache it we do.
 *
 * This generally converts the image to the right type for the canvas.
 * However, if want_original is set the real source format is returned, and
 * you have to be able to handle any image format. This is useful to avoid
 * e.g. losing alpha when blending a argb32 image on a rgb16 surface.
 */
static pixman_image_t *canvas_get_image_internal(CanvasBase *canvas, SpiceImage *image,
                                                 int want_original, int real_get)
{
    SpiceImageDescriptor *descriptor = &image->descriptor;
    pixman_image_t *surface, *converted;
    pixman_format_code_t wanted_format, surface_format;
    int saved_want_original;

    /* When touching, only really allocate if we need to cache, or
     * if we're loading a GLZ stream (since those need inter-thread communication
     * to happen which breaks if we don't. */
    if (!real_get &&
        !(descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_ME) &&
#ifdef SW_CANVAS_CACHE
        !(descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_REPLACE_ME) &&
        !image_has_palette_to_cache(image) &&
#endif
        (descriptor->type != SPICE_IMAGE_TYPE_GLZ_RGB) &&
        (descriptor->type != SPICE_IMAGE_TYPE_ZLIB_GLZ_RGB)) {
        return NULL;
    }

    saved_want_original = want_original;
    if (descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_ME
#ifdef SW_CANVAS_CACHE
        || descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_REPLACE_ME
#endif
       ) {
        want_original = TRUE;
    }

    surface = get_surface_from_canvas(canvas, image, want_original);

    spice_return_val_if_fail(surface != NULL, NULL);
    spice_return_val_if_fail(spice_pixman_image_get_format(surface, &surface_format), NULL);

    if (descriptor->flags & SPICE_IMAGE_FLAGS_HIGH_BITS_SET &&
        descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE &&
#ifdef SW_CANVAS_CACHE
        descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS &&
#endif
        surface_format == PIXMAN_x8r8g8b8) {
        spice_pixman_fill_rect_rop(surface,
                                   0, 0,
                                   pixman_image_get_width(surface),
                                   pixman_image_get_height(surface),
                                   0xff000000U, SPICE_ROP_OR);
    }

    if (descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_ME &&
#ifdef SW_CANVAS_CACHE
        descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS &&
#endif
        descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE ) {
#ifdef SW_CANVAS_CACHE
        if (!spice_image_descriptor_is_lossy(descriptor)) {
            canvas->bits_cache->ops->put(canvas->bits_cache, descriptor->id, surface);
        } else {
            canvas->bits_cache->ops->put_lossy(canvas->bits_cache, descriptor->id, surface);
        }
#else
        canvas->bits_cache->ops->put(canvas->bits_cache, descriptor->id, surface);
#endif
#ifdef DEBUG_DUMP_SURFACE
        dump_surface(surface, 1);
#endif
#ifdef SW_CANVAS_CACHE
    } else if (descriptor->flags & SPICE_IMAGE_FLAGS_CACHE_REPLACE_ME) {
        if (spice_image_descriptor_is_lossy(descriptor)) {
            g_warning("invalid cache replace request: the image is lossy");
            return NULL;
        }
        canvas->bits_cache->ops->replace_lossy(canvas->bits_cache, descriptor->id, surface);
#ifdef DEBUG_DUMP_SURFACE
        dump_surface(surface, 1);
#endif
#endif
#ifdef DEBUG_DUMP_SURFACE
    } else if (descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE
#ifdef SW_CANVAS_CACHE
               && descriptor->type != SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS
#endif
    ) {

        dump_surface(surface, 0);
#endif
    }

    if (!real_get) {
        pixman_image_unref(surface);
        return NULL;
    }

    if (!saved_want_original) {
        /* Conversion to canvas format was requested, but maybe it didn't
           happen above (due to save/load to cache for instance, or
           maybe the reader didn't support conversion).
           If so we convert here. */

        wanted_format = canvas_get_target_format(canvas,
#ifdef WORDS_BIGENDIAN
                                                 surface_format == PIXMAN_b8g8r8a8 ||
#endif
                                                 surface_format == PIXMAN_a8r8g8b8);

        if (surface_format != wanted_format) {
            converted = surface_create(wanted_format,
                                       pixman_image_get_width(surface),
                                       pixman_image_get_height(surface),
                                       TRUE);
            pixman_image_composite32 (PIXMAN_OP_SRC,
                                      surface, NULL, converted,
                                      0, 0,
                                      0, 0,
                                      0, 0,
                                      pixman_image_get_width(surface),
                                      pixman_image_get_height(surface));
            pixman_image_unref (surface);
            surface = converted;
        }
    }

    return surface;
}

static SpiceCanvas *canvas_get_surface_mask(CanvasBase *canvas, SpiceImage *image)
{
    return canvas_get_surface_mask_internal(canvas, image);
}

static SpiceCanvas *canvas_get_surface(CanvasBase *canvas, SpiceImage *image)
{
    return canvas_get_surface_internal(canvas, image);
}

static pixman_image_t *canvas_get_image(CanvasBase *canvas, SpiceImage *image,
                                        int want_original)
{
    return canvas_get_image_internal(canvas, image, want_original, TRUE);
}

static void canvas_touch_image(CanvasBase *canvas, SpiceImage *image)
{
    canvas_get_image_internal(canvas, image, TRUE, FALSE);
}

static pixman_image_t* canvas_get_image_from_self(SpiceCanvas *canvas,
                                                  int x, int y,
                                                  int32_t width, int32_t height,
                                                  int force_opaque)
{
    CanvasBase *canvas_base = (CanvasBase *)canvas;
    pixman_image_t *surface;
    uint8_t *dest;
    int dest_stride;
    SpiceRect area;
    pixman_format_code_t format;

    format = spice_surface_format_to_pixman (canvas_base->format);
    if (force_opaque)
    {
        /* Set alpha bits of the format to 0 */
        format = (pixman_format_code_t)(((uint32_t)format) & ~(0xf << 12));

        spice_return_val_if_fail (
            pixman_format_supported_destination (format), NULL);
    }

    surface = pixman_image_create_bits(spice_surface_format_to_pixman (canvas_base->format),
                                       width, height, NULL, 0);
    spice_return_val_if_fail(surface != NULL, NULL);

    dest = (uint8_t *)pixman_image_get_data(surface);
    dest_stride = pixman_image_get_stride(surface);

    area.left = x;
    area.top = y;
    area.right = x + width;
    area.bottom = y + height;

    canvas->ops->read_bits(canvas, dest, dest_stride, &area);

    return surface;
}


#ifdef REVERS_BITS_SLOW
static inline uint8_t revers_bits(uint8_t byte)
{
    uint8_t ret = 0;
    int i;

    for (i = 0; i < 4; i++) {
        int shift = 7 - i * 2;
        ret |= (byte & (1 << i)) << shift;
        ret |= (byte & (0x80 >> i)) >> shift;
    }
    return ret;
}
#else
static inline uint8_t revers_bits(uint8_t byte)
{
    static const uint8_t revers[] = {
        0x0, 0x80, 0x40, 0xc0, 0x20, 0xa0, 0x60, 0xe0,
        0x10, 0x90, 0x50, 0xd0, 0x30, 0xb0, 0x70, 0xf0,
        0x8, 0x88, 0x48, 0xc8, 0x28, 0xa8, 0x68, 0xe8,
        0x18, 0x98, 0x58, 0xd8, 0x38, 0xb8, 0x78, 0xf8,
        0x4, 0x84, 0x44, 0xc4, 0x24, 0xa4, 0x64, 0xe4,
        0x14, 0x94, 0x54, 0xd4, 0x34, 0xb4, 0x74, 0xf4,
        0xc, 0x8c, 0x4c, 0xcc, 0x2c, 0xac, 0x6c, 0xec,
        0x1c, 0x9c, 0x5c, 0xdc, 0x3c, 0xbc, 0x7c, 0xfc,
        0x2, 0x82, 0x42, 0xc2, 0x22, 0xa2, 0x62, 0xe2,
        0x12, 0x92, 0x52, 0xd2, 0x32, 0xb2, 0x72, 0xf2,
        0xa, 0x8a, 0x4a, 0xca, 0x2a, 0xaa, 0x6a, 0xea,
        0x1a, 0x9a, 0x5a, 0xda, 0x3a, 0xba, 0x7a, 0xfa,
        0x6, 0x86, 0x46, 0xc6, 0x26, 0xa6, 0x66, 0xe6,
        0x16, 0x96, 0x56, 0xd6, 0x36, 0xb6, 0x76, 0xf6,
        0xe, 0x8e, 0x4e, 0xce, 0x2e, 0xae, 0x6e, 0xee,
        0x1e, 0x9e, 0x5e, 0xde, 0x3e, 0xbe, 0x7e, 0xfe,
        0x1, 0x81, 0x41, 0xc1, 0x21, 0xa1, 0x61, 0xe1,
        0x11, 0x91, 0x51, 0xd1, 0x31, 0xb1, 0x71, 0xf1,
        0x9, 0x89, 0x49, 0xc9, 0x29, 0xa9, 0x69, 0xe9,
        0x19, 0x99, 0x59, 0xd9, 0x39, 0xb9, 0x79, 0xf9,
        0x5, 0x85, 0x45, 0xc5, 0x25, 0xa5, 0x65, 0xe5,
        0x15, 0x95, 0x55, 0xd5, 0x35, 0xb5, 0x75, 0xf5,
        0xd, 0x8d, 0x4d, 0xcd, 0x2d, 0xad, 0x6d, 0xed,
        0x1d, 0x9d, 0x5d, 0xdd, 0x3d, 0xbd, 0x7d, 0xfd,
        0x3, 0x83, 0x43, 0xc3, 0x23, 0xa3, 0x63, 0xe3,
        0x13, 0x93, 0x53, 0xd3, 0x33, 0xb3, 0x73, 0xf3,
        0xb, 0x8b, 0x4b, 0xcb, 0x2b, 0xab, 0x6b, 0xeb,
        0x1b, 0x9b, 0x5b, 0xdb, 0x3b, 0xbb, 0x7b, 0xfb,
        0x7, 0x87, 0x47, 0xc7, 0x27, 0xa7, 0x67, 0xe7,
        0x17, 0x97, 0x57, 0xd7, 0x37, 0xb7, 0x77, 0xf7,
        0xf, 0x8f, 0x4f, 0xcf, 0x2f, 0xaf, 0x6f, 0xef,
        0x1f, 0x9f, 0x5f, 0xdf, 0x3f, 0xbf, 0x7f, 0xff
    };

    return revers[byte];
}
#endif

static pixman_image_t *canvas_get_bitmap_mask(CanvasBase *canvas, SpiceBitmap* bitmap, int invers)
{
    pixman_image_t *surface;
    uint8_t *src_line;
    uint8_t *end_line;
    uint8_t *dest_line;
    int src_stride;
    int line_size;
    int dest_stride;

    surface = surface_create(PIXMAN_a1, bitmap->x, bitmap->y, TRUE);
    spice_return_val_if_fail(surface != NULL, NULL);

    spice_chunks_linearize(bitmap->data);
    src_line = bitmap->data->chunk[0].data;
    src_stride = bitmap->stride;
    end_line = src_line + (bitmap->y * src_stride);
    line_size = SPICE_ALIGN(bitmap->x, 8) >> 3;

    dest_stride = pixman_image_get_stride(surface);
    dest_line = (uint8_t *)pixman_image_get_data(surface);
    if (!(bitmap->flags & SPICE_BITMAP_FLAGS_TOP_DOWN)) {
        spice_return_val_if_fail(bitmap->y > 0, NULL);
        dest_line += dest_stride * ((int)bitmap->y - 1);
        dest_stride = -dest_stride;
    }

    if (invers) {
        switch (bitmap->format) {
        case SPICE_BITMAP_FMT_1BIT_LE:
            for (; src_line != end_line; src_line += src_stride, dest_line += dest_stride) {
                uint8_t *dest = dest_line;
                uint8_t *now = src_line;
                uint8_t *end = now + line_size;
                while (now < end) {
                    *(dest++) = ~*(now++);
                }
            }
            break;
        case SPICE_BITMAP_FMT_1BIT_BE:
            for (; src_line != end_line; src_line += src_stride, dest_line += dest_stride) {
                uint8_t *dest = dest_line;
                uint8_t *now = src_line;
                uint8_t *end = now + line_size;

                while (now < end) {
                    *(dest++) = ~revers_bits(*(now++));
                }
            }
            break;
        default:
            pixman_image_unref(surface);
            surface = NULL;
            spice_warn_if_reached();
            return NULL;
        }
    } else {
        switch (bitmap->format) {
        case SPICE_BITMAP_FMT_1BIT_LE:
            for (; src_line != end_line; src_line += src_stride, dest_line += dest_stride) {
                memcpy(dest_line, src_line, line_size);
            }
            break;
        case SPICE_BITMAP_FMT_1BIT_BE:
            for (; src_line != end_line; src_line += src_stride, dest_line += dest_stride) {
                uint8_t *dest = dest_line;
                uint8_t *now = src_line;
                uint8_t *end = now + line_size;

                while (now < end) {
                    *(dest++) = revers_bits(*(now++));
                }
            }
            break;
        default:
            pixman_image_unref(surface);
            surface = NULL;
            spice_warn_if_reached();
            return NULL;
        }
    }
    return surface;
}

static inline pixman_image_t *canvas_A1_invers(pixman_image_t *src_surf)
{
    int width = pixman_image_get_width(src_surf);
    int height = pixman_image_get_height(src_surf);
    pixman_image_t * invers;
    uint8_t *src_line, *end_line,  *dest_line;
    int src_stride, line_size, dest_stride;

    spice_return_val_if_fail(pixman_image_get_depth(src_surf) == 1, NULL);

    invers = pixman_image_create_bits(PIXMAN_a1, width, height, NULL, 0);
    spice_return_val_if_fail(invers != NULL, NULL);

    src_line = (uint8_t *)pixman_image_get_data(src_surf);
    src_stride = pixman_image_get_stride(src_surf);
    end_line = src_line + (height * src_stride);
    line_size = SPICE_ALIGN(width, 8) >> 3;
    dest_line = (uint8_t *)pixman_image_get_data(invers);
    dest_stride = pixman_image_get_stride(invers);

    for (; src_line != end_line; src_line += src_stride, dest_line += dest_stride) {
        uint8_t *dest = dest_line;
        uint8_t *now = src_line;
        uint8_t *end = now + line_size;
        while (now < end) {
            *(dest++) = ~*(now++);
        }
    }
    return invers;
}

static pixman_image_t *canvas_get_mask(CanvasBase *canvas, SpiceQMask *mask, int *needs_invert_out)
{
    SpiceImage *image;
    pixman_image_t *surface;
    int need_invers;
    int is_invers;
    int cache_me;

    if (needs_invert_out) {
        *needs_invert_out = 0;
    }

    image = mask->bitmap;
    need_invers = mask->flags & SPICE_MASK_FLAGS_INVERS;

#ifdef SW_CANVAS_CACHE
    cache_me = image->descriptor.flags & SPICE_IMAGE_FLAGS_CACHE_ME;
#else
    cache_me = 0;
#endif

    switch (image->descriptor.type) {
    case SPICE_IMAGE_TYPE_BITMAP: {
        is_invers = need_invers && !cache_me;
        surface = canvas_get_bitmap_mask(canvas, &image->u.bitmap, is_invers);
        break;
    }
    case SPICE_IMAGE_TYPE_FROM_CACHE:
        surface = canvas->bits_cache->ops->get(canvas->bits_cache, image->descriptor.id);
        is_invers = 0;
        break;
#ifdef SW_CANVAS_CACHE
    case SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS:
        surface = canvas->bits_cache->ops->get_lossless(canvas->bits_cache, image->descriptor.id);
        is_invers = 0;
        break;
#endif
    default:
        spice_warn_if_reached();
        return NULL;
    }

    if (cache_me) {
        canvas->bits_cache->ops->put(canvas->bits_cache, image->descriptor.id, surface);
    }

    if (need_invers && !is_invers) { // surface is in cache
        if (needs_invert_out != NULL) {
            *needs_invert_out = TRUE;
        } else {
            pixman_image_t *inv_surf;
            inv_surf = canvas_A1_invers(surface);
            pixman_image_unref(surface);
            surface = inv_surf;
        }
    }

    return surface;
}

static inline void canvas_raster_glyph_box(const SpiceRasterGlyph *glyph, SpiceRect *r)
{
    spice_return_if_fail(r != NULL);

    r->top = glyph->render_pos.y + glyph->glyph_origin.y;
    r->bottom = r->top + glyph->height;
    r->left = glyph->render_pos.x + glyph->glyph_origin.x;
    r->right = r->left + glyph->width;
}

static inline void __canvas_put_bits(uint8_t *dest, int offset, uint8_t val, int n)
{
    uint8_t mask;
    int now;

    dest = dest + (offset >> 3);
    offset &= 0x07;

    now = MIN(8 - offset, n);

    mask = (1 << now) - 1;
    mask <<= offset;
    val = revers_bits(val);
    *dest = ((val << offset) & mask) | *dest;

    if ((n = n - now)) {
        mask = (1 << n) - 1;
        dest++;
        *dest = ((val >> now) & mask) | *dest;
    }
}

static inline void canvas_put_bits(uint8_t *dest, int dest_offset, uint8_t *src, int n)
{
    while (n) {
        int now = MIN(n, 8);

        n -= now;
        __canvas_put_bits(dest, dest_offset, *src, now);
        dest_offset += now;
        src++;
    }
}

static void canvas_put_glyph_bits(SpiceRasterGlyph *glyph, int bpp, uint8_t *dest, int dest_stride,
                                  SpiceRect *bounds)
{
    SpiceRect glyph_box;
    uint8_t *src;
    int lines;
    int width;

    //todo: support SPICE_STRING_FLAGS_RASTER_TOP_DOWN
    canvas_raster_glyph_box(glyph, &glyph_box);
    spice_return_if_fail(glyph_box.top >= bounds->top && glyph_box.bottom <= bounds->bottom);
    spice_return_if_fail(glyph_box.left >= bounds->left && glyph_box.right <= bounds->right);
    rect_offset(&glyph_box, -bounds->left, -bounds->top);

    dest += glyph_box.top * dest_stride;
    src = glyph->data;
    lines = glyph_box.bottom - glyph_box.top;
    width = glyph_box.right - glyph_box.left;
    switch (bpp) {
    case 1: {
        int src_stride = SPICE_ALIGN(width, 8) >> 3;
        int i;

        src += src_stride * (lines);
        for (i = 0; i < lines; i++) {
            src -= src_stride;
            canvas_put_bits(dest, glyph_box.left, src, width);
            dest += dest_stride;
        }
        break;
    }
    case 4: {
        uint8_t *end;
        int src_stride = SPICE_ALIGN(width * 4, 8) >> 3;

        src += src_stride * lines;
        dest += glyph_box.left;
        end = dest + dest_stride * lines;
        for (; dest != end; dest += dest_stride) {
            int i = 0;
            uint8_t *now;

            src -= src_stride;
            now = src;
            while (i < (width & ~1)) {
                dest[i] = MAX(dest[i], *now & 0xf0);
                dest[i + 1] = MAX(dest[i + 1], *now << 4);
                i += 2;
                now++;
            }
            if (i < width) {
                dest[i] = MAX(dest[i], *now & 0xf0);
                now++;
            }
        }
        break;
    }
    case 8: {
        uint8_t *end;
        src += width * lines;
        dest += glyph_box.left;
        end = dest + dest_stride * lines;
        for (; dest != end; dest += dest_stride, src -= width) {
            int i;

            for (i = 0; i < width; i++) {
                dest[i] = MAX(dest[i], src[i]);
            }
        }
        break;
    }
    default:
        spice_warn_if_reached();
        return;
    }
}

static pixman_image_t *canvas_get_str_mask(CanvasBase *canvas, SpiceString *str, int bpp, SpicePoint *pos)
{
    SpiceRasterGlyph *glyph;
    SpiceRect bounds;
    pixman_image_t *str_mask;
    uint8_t *dest;
    int dest_stride;
    int i;

    spice_return_val_if_fail(str->length > 0, NULL);

    glyph = str->glyphs[0];
    canvas_raster_glyph_box(glyph, &bounds);

    for (i = 1; i < str->length; i++) {
        SpiceRect glyph_box;

        canvas_raster_glyph_box(str->glyphs[i], &glyph_box);
        rect_union(&bounds, &glyph_box);
    }

    str_mask = pixman_image_create_bits((bpp == 1) ? PIXMAN_a1 : PIXMAN_a8,
                                        bounds.right - bounds.left,
                                        bounds.bottom - bounds.top, NULL, 0);
    spice_return_val_if_fail(str_mask != NULL, NULL);

    dest = (uint8_t *)pixman_image_get_data(str_mask);
    dest_stride = pixman_image_get_stride(str_mask);
    for (i = 0; i < str->length; i++) {
        glyph = str->glyphs[i];
        canvas_put_glyph_bits(glyph, bpp, dest, dest_stride, &bounds);
    }

    pos->x = bounds.left;
    pos->y = bounds.top;
    return str_mask;
}

static pixman_image_t *canvas_scale_surface(pixman_image_t *src, const SpiceRect *src_area, int width,
                                            int height, int scale_mode)
{
    pixman_image_t *surface;
    pixman_transform_t transform;
    pixman_format_code_t format;
    double sx, sy;

    spice_return_val_if_fail(spice_pixman_image_get_format (src, &format), NULL);

    surface = pixman_image_create_bits(format, width, height, NULL, 0);
    spice_return_val_if_fail(surface != NULL, NULL);

    sx = (double)(src_area->right - src_area->left) / width;
    sy = (double)(src_area->bottom - src_area->top) / height;

    pixman_transform_init_scale(&transform, pixman_double_to_fixed(sx), pixman_double_to_fixed(sy));

    pixman_image_set_transform (src, &transform);
    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);
    spice_return_val_if_fail(scale_mode == SPICE_IMAGE_SCALE_MODE_INTERPOLATE || scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST, NULL);
    pixman_image_set_filter(src,
                            (scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST) ?PIXMAN_FILTER_NEAREST : PIXMAN_FILTER_GOOD,
                            NULL, 0);

    pixman_image_composite32(PIXMAN_OP_SRC,
                             src, NULL, surface,
                             ROUND(src_area->left / sx), ROUND (src_area->top / sy),
                             0, 0, /* mask */
                             0, 0, /* dst */
                             width, height);

    pixman_transform_init_identity(&transform);
    pixman_image_set_transform(src, &transform);

    return surface;
}

SPICE_GNUC_NORETURN
SPICE_GNUC_PRINTF(2, 3) static void quic_usr_error(QuicUsrContext *usr, const char *fmt, ...)
{
    QuicData *usr_data = (QuicData *)usr;
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(usr_data->message_buf, sizeof(usr_data->message_buf), fmt, ap);
    va_end(ap);

    longjmp(usr_data->jmp_env, 1);
}

SPICE_GNUC_PRINTF(2, 3) static void quic_usr_warn(QuicUsrContext *usr, const char *fmt, ...)
{
    QuicData *usr_data = (QuicData *)usr;
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(usr_data->message_buf, sizeof(usr_data->message_buf), fmt, ap);
    va_end(ap);
}

static void *quic_usr_malloc(QuicUsrContext *usr, int size)
{
    return spice_malloc(size);
}

static void quic_usr_free(QuicUsrContext *usr, void *ptr)
{
    free(ptr);
}

SPICE_GNUC_PRINTF(2, 3) static void lz_usr_warn(LzUsrContext *usr, const char *fmt, ...)
{
    LzData *usr_data = (LzData *)usr;
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(usr_data->message_buf, sizeof(usr_data->message_buf), fmt, ap);
    va_end(ap);
}

SPICE_GNUC_NORETURN
SPICE_GNUC_PRINTF(2, 3) static void lz_usr_error(LzUsrContext *usr, const char *fmt, ...)
{
    LzData *usr_data = (LzData *)usr;
    va_list ap;

    va_start(ap, fmt);
    vsnprintf(usr_data->message_buf, sizeof(usr_data->message_buf), fmt, ap);
    va_end(ap);

    longjmp(usr_data->jmp_env, 1);
}

static void *lz_usr_malloc(LzUsrContext *usr, int size)
{
    return spice_malloc(size);
}

static void lz_usr_free(LzUsrContext *usr, void *ptr)
{
    free(ptr);
}

static int lz_usr_more_space(LzUsrContext *usr, uint8_t **io_ptr)
{
    return 0;
}

static int lz_usr_more_lines(LzUsrContext *usr, uint8_t **lines)
{
    return 0;
}

static int quic_usr_more_space(QuicUsrContext *usr, uint32_t **io_ptr, int rows_completed)
{
    QuicData *quic_data = (QuicData *)usr;

    if (quic_data->current_chunk == quic_data->chunks->num_chunks -1) {
        return 0;
    }
    quic_data->current_chunk++;

    *io_ptr = SPICE_ALIGNED_CAST(uint32_t *,
                                 quic_data->chunks->chunk[quic_data->current_chunk].data);
    return quic_data->chunks->chunk[quic_data->current_chunk].len >> 2;
}


static int quic_usr_more_lines(QuicUsrContext *usr, uint8_t **lines)
{
    return 0;
}

static void canvas_base_destroy(CanvasBase *canvas)
{
    quic_destroy(canvas->quic_data.quic);
    lz_destroy(canvas->lz_data.lz);
}

static void canvas_clip_pixman(CanvasBase *canvas,
                               pixman_region32_t *dest_region,
                               SpiceClip *clip)
{
    pixman_region32_intersect(dest_region, dest_region, &canvas->canvas_region);

    switch (clip->type) {
    case SPICE_CLIP_TYPE_NONE:
        break;
    case SPICE_CLIP_TYPE_RECTS: {
        uint32_t n = clip->rects->num_rects;
        SpiceRect *now = clip->rects->rects;

        pixman_region32_t pixman_clip;

        if (spice_pixman_region32_init_rects(&pixman_clip, now, n)) {
            pixman_region32_intersect(dest_region, dest_region, &pixman_clip);
            pixman_region32_fini(&pixman_clip);
        }

        break;
    }
    default:
        spice_warn_if_reached();
        return;
    }
}

static void canvas_mask_pixman(CanvasBase *canvas,
                               pixman_region32_t *dest_region,
                               SpiceQMask *mask, int x, int y)
{
    SpiceCanvas *surface_canvas;
    pixman_image_t *image, *subimage;
    int needs_invert;
    pixman_region32_t mask_region;
    uint32_t *mask_data;
    uint8_t *mask_data_src;
    int mask_x, mask_y;
    int mask_width, mask_height, mask_stride;
    pixman_box32_t extents;

    if (!mask->bitmap) {
        return;
    }

    surface_canvas = canvas_get_surface_mask(canvas, mask->bitmap);
    if (surface_canvas) {
        needs_invert = mask->flags & SPICE_MASK_FLAGS_INVERS;
        image = surface_canvas->ops->get_image(surface_canvas, FALSE);
    } else {
        needs_invert = FALSE;
        image = canvas_get_mask(canvas,
                                mask,
                                &needs_invert);
    }

    mask_data = pixman_image_get_data(image);
    mask_width = pixman_image_get_width(image);
    mask_height = pixman_image_get_height(image);
    mask_stride = pixman_image_get_stride(image);

    mask_x = mask->pos.x;
    mask_y = mask->pos.y;

    /* We need to subset the area of the mask that we turn into a region,
       because a cached mask may be much larger than what is used for
       the clip operation. */
    extents = *pixman_region32_extents(dest_region);

    /* convert from destination pixels to mask pixels */
    extents.x1 -= x - mask_x;
    extents.y1 -= y - mask_y;
    extents.x2 -= x - mask_x;
    extents.y2 -= y - mask_y;

    /* clip to mask size */
    if (extents.x1 < 0) {
        extents.x1 = 0;
    }
    if (extents.x2 >= mask_width) {
        extents.x2 = mask_width;
    }
    if (extents.x2 < extents.x1) {
        extents.x2 = extents.x1;
    }
    if (extents.y1 < 0) {
        extents.y1 = 0;
    }
    if (extents.y2 >= mask_height) {
        extents.y2 = mask_height;
    }
    if (extents.y2 < extents.y1) {
        extents.y2 = extents.y1;
    }

    /* round down X to even 32 pixels (i.e. uint32_t) */
    extents.x1 = extents.x1 & ~(0x1f);

    /* mask_data_src is surely aligned to 4 bytes:
     * - pixman requires mask_data (pixman_image_get_data) to be
     *   aligned to 4 bytes;
     * - pixman requires mask_stride (pixman_image_get_stride) to be
     *   multiple of 4;
     * - extents.x1 is multiple of 32 (see previous line) so
     *   extents.x1 / 8 is multiple of 4.
     */
    mask_data_src = (uint8_t *)mask_data + mask_stride * extents.y1 + extents.x1 / 8;
    mask_data = SPICE_ALIGNED_CAST(uint32_t *, mask_data_src);

    mask_x -= extents.x1;
    mask_y -= extents.y1;
    mask_width = extents.x2 - extents.x1;
    mask_height = extents.y2 - extents.y1;

    subimage = pixman_image_create_bits(PIXMAN_a1, mask_width, mask_height,
                                        mask_data, mask_stride);
    pixman_region32_init_from_image(&mask_region,
                                    subimage);
    pixman_image_unref(subimage);

    if (needs_invert) {
        pixman_box32_t rect;

        rect.x1 = rect.y1 = 0;
        rect.x2 = mask_width;
        rect.y2 = mask_height;

        pixman_region32_inverse(&mask_region, &mask_region, &rect);
    }

    pixman_region32_translate(&mask_region,
                              -mask_x + x, -mask_y + y);

    pixman_region32_intersect(dest_region, dest_region, &mask_region);
    pixman_region32_fini(&mask_region);

    pixman_image_unref(image);
}

static void draw_brush(SpiceCanvas *canvas,
                       pixman_region32_t *region,
                       SpiceBrush *brush,
                       SpiceROP rop)
{
    CanvasBase *canvas_base = (CanvasBase *)canvas;
    uint32_t color;
    SpicePattern *pattern;
    pixman_image_t *tile;
    int offset_x, offset_y;
    pixman_box32_t *rects;
    int n_rects;

    rects = pixman_region32_rectangles(region, &n_rects);

    switch (brush->type) {
    case SPICE_BRUSH_TYPE_SOLID:
        color = brush->u.color;
        if (rop == SPICE_ROP_COPY) {
            canvas->ops->fill_solid_rects(canvas, rects, n_rects, color);
        } else {
            canvas->ops->fill_solid_rects_rop(canvas, rects, n_rects, color, rop);
        }
        break;
    case SPICE_BRUSH_TYPE_PATTERN: {
        SpiceCanvas *surface_canvas;

        pattern = &brush->u.pattern;
        offset_x = pattern->pos.x;
        offset_y = pattern->pos.y;

        surface_canvas = canvas_get_surface(canvas_base, pattern->pat);
        if (surface_canvas) {
            if (rop == SPICE_ROP_COPY) {
                canvas->ops->fill_tiled_rects_from_surface(canvas, rects, n_rects, surface_canvas,
                                                           offset_x, offset_y);
            } else {
                canvas->ops->fill_tiled_rects_rop_from_surface(canvas, rects, n_rects,
                                                               surface_canvas, offset_x, offset_y,
                                                               rop);
            }
        } else {
            tile = canvas_get_image(canvas_base, pattern->pat, FALSE);
            spice_return_if_fail(tile != NULL);

            if (rop == SPICE_ROP_COPY) {
                canvas->ops->fill_tiled_rects(canvas, rects, n_rects, tile, offset_x, offset_y);
            } else {
                canvas->ops->fill_tiled_rects_rop(canvas, rects, n_rects,
                                                  tile, offset_x, offset_y, rop);
            }
            pixman_image_unref(tile);
        }
        break;
    }
    case SPICE_BRUSH_TYPE_NONE:
        /* Still need to do *something* here, because rop could be e.g invert dest */
        canvas->ops->fill_solid_rects_rop(canvas, rects, n_rects, 0, rop);
        break;
    default:
        spice_warn_if_reached();
        return;
    }
}

/* If we're exiting early we may still have to load an image in case
   it has to be cached or something */
static void touch_brush(CanvasBase *canvas, SpiceBrush *brush)
{
    SpicePattern *pattern;

    if (brush->type == SPICE_BRUSH_TYPE_PATTERN) {
        pattern = &brush->u.pattern;
        canvas_touch_image(canvas, pattern->pat);
    }
}

static void canvas_draw_fill(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceFill *fill)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    SpiceROP rop;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);


    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &fill->mask,
                       bbox->left, bbox->top);

    rop = ropd_descriptor_to_rop(fill->rop_descriptor,
                                 ROP_INPUT_BRUSH,
                                 ROP_INPUT_DEST);

    if (rop == SPICE_ROP_NOOP || !pixman_region32_not_empty(&dest_region)) {
        touch_brush(canvas, &fill->brush);
        pixman_region32_fini(&dest_region);
        return;
    }

    draw_brush(spice_canvas, &dest_region, &fill->brush, rop);

    pixman_region32_fini(&dest_region);
}

static void canvas_draw_copy(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceCopy *copy)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    SpiceCanvas *surface_canvas;
    pixman_image_t *src_image;
    SpiceROP rop;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &copy->mask,
                       bbox->left, bbox->top);

    rop = ropd_descriptor_to_rop(copy->rop_descriptor,
                                 ROP_INPUT_SRC,
                                 ROP_INPUT_DEST);

    if (rop == SPICE_ROP_NOOP || !pixman_region32_not_empty(&dest_region)) {
        canvas_touch_image(canvas, copy->src_bitmap);
        pixman_region32_fini(&dest_region);
        return;
    }

    surface_canvas = canvas_get_surface(canvas, copy->src_bitmap);
    if (surface_canvas) {
        if (rect_is_same_size(bbox, &copy->src_area)) {
            if (rop == SPICE_ROP_COPY) {
                spice_canvas->ops->blit_image_from_surface(spice_canvas, &dest_region,
                                                           surface_canvas,
                                                           bbox->left - copy->src_area.left,
                                                           bbox->top - copy->src_area.top);
            } else {
                spice_canvas->ops->blit_image_rop_from_surface(spice_canvas, &dest_region,
                                                               surface_canvas,
                                                               bbox->left - copy->src_area.left,
                                                               bbox->top - copy->src_area.top,
                                                               rop);
            }
        } else {
            if (rop == SPICE_ROP_COPY) {
                spice_canvas->ops->scale_image_from_surface(spice_canvas, &dest_region,
                                                            surface_canvas,
                                                            copy->src_area.left,
                                                            copy->src_area.top,
                                                            copy->src_area.right - copy->src_area.left,
                                                            copy->src_area.bottom - copy->src_area.top,
                                                            bbox->left,
                                                            bbox->top,
                                                            bbox->right - bbox->left,
                                                            bbox->bottom - bbox->top,
                                                            copy->scale_mode);
            } else {
                spice_canvas->ops->scale_image_rop_from_surface(spice_canvas, &dest_region,
                                                                surface_canvas,
                                                                copy->src_area.left,
                                                                copy->src_area.top,
                                                                copy->src_area.right - copy->src_area.left,
                                                                copy->src_area.bottom - copy->src_area.top,
                                                                bbox->left,
                                                                bbox->top,
                                                                bbox->right - bbox->left,
                                                                bbox->bottom - bbox->top,
                                                                copy->scale_mode,
                                                                rop);
            }
        }
    } else {
        src_image = canvas_get_image(canvas, copy->src_bitmap, FALSE);
        spice_return_if_fail(src_image != NULL);

        if (rect_is_same_size(bbox, &copy->src_area)) {
            if (rop == SPICE_ROP_COPY) {
                spice_canvas->ops->blit_image(spice_canvas, &dest_region,
                                              src_image,
                                              bbox->left - copy->src_area.left,
                                              bbox->top - copy->src_area.top);
            } else {
                spice_canvas->ops->blit_image_rop(spice_canvas, &dest_region,
                                                  src_image,
                                                  bbox->left - copy->src_area.left,
                                                  bbox->top - copy->src_area.top,
                                                  rop);
            }
        } else {
            if (rop == SPICE_ROP_COPY) {
                spice_canvas->ops->scale_image(spice_canvas, &dest_region,
                                               src_image,
                                               copy->src_area.left,
                                               copy->src_area.top,
                                               copy->src_area.right - copy->src_area.left,
                                               copy->src_area.bottom - copy->src_area.top,
                                               bbox->left,
                                               bbox->top,
                                               bbox->right - bbox->left,
                                               bbox->bottom - bbox->top,
                                               copy->scale_mode);
            } else {
                spice_canvas->ops->scale_image_rop(spice_canvas, &dest_region,
                                                   src_image,
                                                   copy->src_area.left,
                                                   copy->src_area.top,
                                                   copy->src_area.right - copy->src_area.left,
                                                   copy->src_area.bottom - copy->src_area.top,
                                                   bbox->left,
                                                   bbox->top,
                                                   bbox->right - bbox->left,
                                                   bbox->bottom - bbox->top,
                                                   copy->scale_mode,
                                                   rop);
            }
        }
        pixman_image_unref(src_image);
    }
    pixman_region32_fini(&dest_region);
}

static void canvas_draw_transparent(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceTransparent* transparent)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    SpiceCanvas *surface_canvas;
    pixman_image_t *src_image;
    pixman_region32_t dest_region;
    uint32_t transparent_color;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);

    if (pixman_region32_n_rects (&dest_region) == 0) {
        canvas_touch_image(canvas, transparent->src_bitmap);
        pixman_region32_fini(&dest_region);
        return;
    }

    switch (canvas->format) {
    case SPICE_SURFACE_FMT_32_xRGB:
    case SPICE_SURFACE_FMT_32_ARGB:
        transparent_color = transparent->true_color;
        break;
    case SPICE_SURFACE_FMT_16_555:
        transparent_color = rgb_32_to_16_555(transparent->true_color);
        break;
    case SPICE_SURFACE_FMT_16_565:
        transparent_color = rgb_32_to_16_565(transparent->true_color);
        break;
    default:
        transparent_color = 0;
    }

    surface_canvas = canvas_get_surface(canvas, transparent->src_bitmap);
    if (surface_canvas) {
        if (rect_is_same_size(bbox, &transparent->src_area)) {
            spice_canvas->ops->colorkey_image_from_surface(spice_canvas, &dest_region,
                                                           surface_canvas,
                                                           bbox->left - transparent->src_area.left,
                                                           bbox->top - transparent->src_area.top,
                                                           transparent_color);
        } else {
            spice_canvas->ops->colorkey_scale_image_from_surface(spice_canvas, &dest_region,
                                                                 surface_canvas,
                                                                 transparent->src_area.left,
                                                                 transparent->src_area.top,
                                                                 transparent->src_area.right - transparent->src_area.left,
                                                                 transparent->src_area.bottom - transparent->src_area.top,
                                                                 bbox->left,
                                                                 bbox->top,
                                                                 bbox->right - bbox->left,
                                                                 bbox->bottom - bbox->top,
                                                                 transparent_color);
        }
    } else {
        src_image = canvas_get_image(canvas, transparent->src_bitmap, FALSE);
        spice_return_if_fail(src_image != NULL);

        if (rect_is_same_size(bbox, &transparent->src_area)) {
            spice_canvas->ops->colorkey_image(spice_canvas, &dest_region,
                                              src_image,
                                              bbox->left - transparent->src_area.left,
                                              bbox->top - transparent->src_area.top,
                                              transparent_color);
        } else {
            spice_canvas->ops->colorkey_scale_image(spice_canvas, &dest_region,
                                                    src_image,
                                                    transparent->src_area.left,
                                                    transparent->src_area.top,
                                                    transparent->src_area.right - transparent->src_area.left,
                                                    transparent->src_area.bottom - transparent->src_area.top,
                                                    bbox->left,
                                                    bbox->top,
                                                    bbox->right - bbox->left,
                                                    bbox->bottom - bbox->top,
                                                    transparent_color);
        }
        pixman_image_unref(src_image);
    }
    pixman_region32_fini(&dest_region);
}

static void canvas_draw_alpha_blend(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceAlphaBlend* alpha_blend)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    SpiceCanvas *surface_canvas;
    pixman_image_t *src_image;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);

    if (alpha_blend->alpha == 0 ||
        !pixman_region32_not_empty(&dest_region)) {
        canvas_touch_image(canvas, alpha_blend->src_bitmap);
        pixman_region32_fini(&dest_region);
        return;
    }

    surface_canvas = canvas_get_surface(canvas, alpha_blend->src_bitmap);
    if (surface_canvas) {
        if (rect_is_same_size(bbox, &alpha_blend->src_area)) {
            spice_canvas->ops->blend_image_from_surface(spice_canvas, &dest_region,
                                                        alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_DEST_HAS_ALPHA,
                                                        surface_canvas,
                                                        alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_SRC_SURFACE_HAS_ALPHA,
                                                        alpha_blend->src_area.left,
                                                        alpha_blend->src_area.top,
                                                        bbox->left,
                                                        bbox->top,
                                                        bbox->right - bbox->left,
                                                        bbox->bottom - bbox->top,
                                                        alpha_blend->alpha);
        } else {
            spice_canvas->ops->blend_scale_image_from_surface(spice_canvas, &dest_region,
                                                              alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_DEST_HAS_ALPHA,
                                                              surface_canvas,
                                                              alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_SRC_SURFACE_HAS_ALPHA,
                                                              alpha_blend->src_area.left,
                                                              alpha_blend->src_area.top,
                                                              alpha_blend->src_area.right - alpha_blend->src_area.left,
                                                              alpha_blend->src_area.bottom - alpha_blend->src_area.top,
                                                              bbox->left,
                                                              bbox->top,
                                                              bbox->right - bbox->left,
                                                              bbox->bottom - bbox->top,
                                                              SPICE_IMAGE_SCALE_MODE_NEAREST,
                                                              alpha_blend->alpha);
        }
     } else {
        src_image = canvas_get_image(canvas, alpha_blend->src_bitmap, TRUE);
        spice_return_if_fail(src_image != NULL);

        if (rect_is_same_size(bbox, &alpha_blend->src_area)) {
            spice_canvas->ops->blend_image(spice_canvas, &dest_region,
                                           alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_DEST_HAS_ALPHA,
                                           src_image,
                                           alpha_blend->src_area.left,
                                           alpha_blend->src_area.top,
                                           bbox->left,
                                           bbox->top,
                                           bbox->right - bbox->left,
                                           bbox->bottom - bbox->top,
                                           alpha_blend->alpha);
        } else {
            spice_canvas->ops->blend_scale_image(spice_canvas, &dest_region,
                                                 alpha_blend->alpha_flags & SPICE_ALPHA_FLAGS_DEST_HAS_ALPHA,
                                                 src_image,
                                                 alpha_blend->src_area.left,
                                                 alpha_blend->src_area.top,
                                                 alpha_blend->src_area.right - alpha_blend->src_area.left,
                                                 alpha_blend->src_area.bottom - alpha_blend->src_area.top,
                                                 bbox->left,
                                                 bbox->top,
                                                 bbox->right - bbox->left,
                                                 bbox->bottom - bbox->top,
                                                 SPICE_IMAGE_SCALE_MODE_NEAREST,
                                                 alpha_blend->alpha);
        }

        pixman_image_unref(src_image);
    }

    pixman_region32_fini(&dest_region);
}

static void canvas_draw_opaque(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceOpaque *opaque)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_image_t *src_image;
    pixman_region32_t dest_region;
    SpiceCanvas *surface_canvas;
    SpiceROP rop;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &opaque->mask,
                       bbox->left, bbox->top);

    rop = ropd_descriptor_to_rop(opaque->rop_descriptor,
                                 ROP_INPUT_BRUSH,
                                 ROP_INPUT_SRC);

    if (rop == SPICE_ROP_NOOP || !pixman_region32_not_empty(&dest_region)) {
        canvas_touch_image(canvas, opaque->src_bitmap);
        touch_brush(canvas, &opaque->brush);
        pixman_region32_fini(&dest_region);
        return;
    }

    surface_canvas = canvas_get_surface(canvas, opaque->src_bitmap);
    if (surface_canvas) {
        if (rect_is_same_size(bbox, &opaque->src_area)) {
            spice_canvas->ops->blit_image_from_surface(spice_canvas, &dest_region,
                                                       surface_canvas,
                                                       bbox->left - opaque->src_area.left,
                                                       bbox->top - opaque->src_area.top);
        } else {
            spice_canvas->ops->scale_image_from_surface(spice_canvas, &dest_region,
                                                        surface_canvas,
                                                        opaque->src_area.left,
                                                        opaque->src_area.top,
                                                        opaque->src_area.right - opaque->src_area.left,
                                                        opaque->src_area.bottom - opaque->src_area.top,
                                                        bbox->left,
                                                        bbox->top,
                                                        bbox->right - bbox->left,
                                                        bbox->bottom - bbox->top,
                                                        opaque->scale_mode);
        }
    } else {
        src_image = canvas_get_image(canvas, opaque->src_bitmap, FALSE);
        spice_return_if_fail(src_image != NULL);

        if (rect_is_same_size(bbox, &opaque->src_area)) {
            spice_canvas->ops->blit_image(spice_canvas, &dest_region,
                                          src_image,
                                          bbox->left - opaque->src_area.left,
                                          bbox->top - opaque->src_area.top);
        } else {
            spice_canvas->ops->scale_image(spice_canvas, &dest_region,
                                           src_image,
                                           opaque->src_area.left,
                                           opaque->src_area.top,
                                           opaque->src_area.right - opaque->src_area.left,
                                           opaque->src_area.bottom - opaque->src_area.top,
                                           bbox->left,
                                           bbox->top,
                                           bbox->right - bbox->left,
                                           bbox->bottom - bbox->top,
                                           opaque->scale_mode);
        }
        pixman_image_unref(src_image);
    }

    draw_brush(spice_canvas, &dest_region, &opaque->brush, rop);

    pixman_region32_fini(&dest_region);
}

static void canvas_draw_blackness(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceBlackness *blackness)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    pixman_box32_t *rects;
    int n_rects;

   pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);


    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &blackness->mask,
                       bbox->left, bbox->top);

    if (!pixman_region32_not_empty(&dest_region)) {
        pixman_region32_fini (&dest_region);
        return;
    }

    rects = pixman_region32_rectangles(&dest_region, &n_rects);

    spice_canvas->ops->fill_solid_rects(spice_canvas, rects, n_rects, 0x000000);

    pixman_region32_fini(&dest_region);
}

static void canvas_draw_whiteness(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceWhiteness *whiteness)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    pixman_box32_t *rects;
    int n_rects;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);


    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &whiteness->mask,
                       bbox->left, bbox->top);

    if (!pixman_region32_not_empty(&dest_region)) {
        pixman_region32_fini(&dest_region);
        return;
    }

    rects = pixman_region32_rectangles(&dest_region, &n_rects);
    spice_canvas->ops->fill_solid_rects(spice_canvas, rects, n_rects, 0xffffffff);

    pixman_region32_fini(&dest_region);
}

static void canvas_draw_invers(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpiceInvers *invers)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    pixman_box32_t *rects;
    int n_rects;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);


    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &invers->mask,
                       bbox->left, bbox->top);

    if (!pixman_region32_not_empty(&dest_region)) {
        pixman_region32_fini(&dest_region);
        return;
    }

    rects = pixman_region32_rectangles(&dest_region, &n_rects);
    spice_canvas->ops->fill_solid_rects_rop(spice_canvas, rects, n_rects, 0x00000000,
                                            SPICE_ROP_INVERT);

    pixman_region32_fini(&dest_region);
}

typedef struct {
    lineGC base;
    SpiceCanvas *canvas;
    pixman_region32_t dest_region;
    SpiceROP fore_rop;
    SpiceROP back_rop;
    int solid;
    uint32_t color;
    int use_surface_canvas;
    union {
        SpiceCanvas *surface_canvas;
        pixman_image_t *tile;
    };
    int tile_offset_x;
    int tile_offset_y;
} StrokeGC;

static void stroke_fill_spans(lineGC * pGC,
                              int num_spans,
                              SpicePoint *points,
                              int *widths,
                              int sorted,
                              int foreground)
{
    SpiceCanvas *canvas;
    StrokeGC *strokeGC;
    int i;
    SpiceROP rop;

    strokeGC = (StrokeGC *)pGC;
    canvas = strokeGC->canvas;

    num_spans = spice_canvas_clip_spans(&strokeGC->dest_region,
                                        points, widths, num_spans,
                                        points, widths, sorted);

    if (foreground) {
        rop = strokeGC->fore_rop;
    } else {
        rop = strokeGC->back_rop;
    }

    if (strokeGC->solid) {
        if (rop == SPICE_ROP_COPY) {
            canvas->ops->fill_solid_spans(canvas, points, widths, num_spans,
                                          strokeGC->color);
        } else {
            for (i = 0; i < num_spans; i++) {
                pixman_box32_t r;
                r.x1 = points[i].x;
                r.y1 = points[i].y;
                r.x2 = points[i].x + widths[i];
                r.y2 = r.y1 + 1;
                canvas->ops->fill_solid_rects_rop(canvas, &r, 1,
                                                  strokeGC->color, rop);
            }
        }
    } else {
        if (rop == SPICE_ROP_COPY) {
            for (i = 0; i < num_spans; i++) {
                pixman_box32_t r;
                r.x1 = points[i].x;
                r.y1 = points[i].y;
                r.x2 = points[i].x + widths[i];
                r.y2 = r.y1 + 1;
                canvas->ops->fill_tiled_rects(canvas, &r, 1,
                                              strokeGC->tile,
                                              strokeGC->tile_offset_x,
                                              strokeGC->tile_offset_y);
            }
        } else {
            for (i = 0; i < num_spans; i++) {
                pixman_box32_t r;
                r.x1 = points[i].x;
                r.y1 = points[i].y;
                r.x2 = points[i].x + widths[i];
                r.y2 = r.y1 + 1;
                canvas->ops->fill_tiled_rects_rop(canvas, &r, 1,
                                                  strokeGC->tile,
                                                  strokeGC->tile_offset_x,
                                                  strokeGC->tile_offset_y, rop);
            }
        }
    }
}

static void stroke_fill_rects(lineGC * pGC,
                              int num_rects,
                              pixman_rectangle32_t *rects,
                              int foreground)
{
    SpiceCanvas *canvas;
    pixman_region32_t area;
    pixman_box32_t *boxes;
    StrokeGC *strokeGC;
    SpiceROP rop;
    int i;
    pixman_box32_t *area_rects;
    int n_area_rects;

    strokeGC = (StrokeGC *)pGC;
    canvas = strokeGC->canvas;

    if (foreground) {
        rop = strokeGC->fore_rop;
    } else {
        rop = strokeGC->back_rop;
    }

    /* TODO: We can optimize this for more common cases where
       dest is one rect */

    boxes = spice_new(pixman_box32_t, num_rects);
    for (i = 0; i < num_rects; i++) {
        boxes[i].x1 = rects[i].x;
        boxes[i].y1 = rects[i].y;
        boxes[i].x2 = rects[i].x + rects[i].width;
        boxes[i].y2 = rects[i].y + rects[i].height;
    }
    pixman_region32_init_rects(&area, boxes, num_rects);
    pixman_region32_intersect(&area, &area, &strokeGC->dest_region);
    free(boxes);

    area_rects = pixman_region32_rectangles(&area, &n_area_rects);

    if (strokeGC->solid) {
        if (rop == SPICE_ROP_COPY) {
            canvas->ops->fill_solid_rects(canvas, area_rects, n_area_rects,
                                          strokeGC->color);
        } else {
            canvas->ops->fill_solid_rects_rop(canvas, area_rects, n_area_rects,
                                              strokeGC->color, rop);
        }
    } else {
        if (rop == SPICE_ROP_COPY) {
            if (strokeGC->use_surface_canvas) {
                canvas->ops->fill_tiled_rects_from_surface(canvas, area_rects, n_area_rects,
                                                           strokeGC->surface_canvas,
                                                           strokeGC->tile_offset_x,
                                                           strokeGC->tile_offset_y);
            } else {
                canvas->ops->fill_tiled_rects(canvas, area_rects, n_area_rects,
                                              strokeGC->tile,
                                              strokeGC->tile_offset_x,
                                              strokeGC->tile_offset_y);
            }
        } else {
            if (strokeGC->use_surface_canvas) {
                canvas->ops->fill_tiled_rects_rop_from_surface(canvas, area_rects, n_area_rects,
                                                               strokeGC->surface_canvas,
                                                               strokeGC->tile_offset_x,
                                                               strokeGC->tile_offset_y,
                                                               rop);
            } else {
                canvas->ops->fill_tiled_rects_rop(canvas, area_rects, n_area_rects,
                                                  strokeGC->tile,
                                                  strokeGC->tile_offset_x,
                                                  strokeGC->tile_offset_y,
                                                  rop);
            }
        }
    }

   pixman_region32_fini(&area);
}

typedef struct {
    SpicePoint *points;
    int num_points;
    int size;
} StrokeLines;

static void stroke_lines_init(StrokeLines *lines)
{
    lines->points = spice_new(SpicePoint, 10);
    lines->size = 10;
    lines->num_points = 0;
}

static void stroke_lines_free(StrokeLines *lines)
{
    free(lines->points);
}

static void stroke_lines_append(StrokeLines *lines,
                                int x, int y)
{
    if (lines->num_points == lines->size) {
        lines->size *= 2;
        lines->points = spice_renew(SpicePoint, lines->points, lines->size);
    }
    lines->points[lines->num_points].x = x;
    lines->points[lines->num_points].y = y;
    lines->num_points++;
}

static void stroke_lines_append_fix(StrokeLines *lines,
                                    SpicePointFix *point)
{
    stroke_lines_append(lines,
                        fix_to_int(point->x),
                        fix_to_int(point->y));
}

static inline int64_t dot(SPICE_FIXED28_4 x1,
                          SPICE_FIXED28_4 y1,
                          SPICE_FIXED28_4 x2,
                          SPICE_FIXED28_4 y2)
{
    return (((int64_t)x1) *((int64_t)x2) +
            ((int64_t)y1) *((int64_t)y2)) >> 4;
}

static inline int64_t dot2(SPICE_FIXED28_4 x,
                           SPICE_FIXED28_4 y)
{
    return (((int64_t)x) *((int64_t)x) +
            ((int64_t)y) *((int64_t)y)) >> 4;
}

static void subdivide_bezier(StrokeLines *lines,
                             SpicePointFix point0,
                             SpicePointFix point1,
                             SpicePointFix point2,
                             SpicePointFix point3)
{
    int64_t A2, B2, C2, AB, CB, h1, h2;

    A2 = dot2(point1.x - point0.x,
              point1.y - point0.y);
    B2 = dot2(point3.x - point0.x,
              point3.y - point0.y);
    C2 = dot2(point2.x - point3.x,
              point2.y - point3.y);

    AB = dot(point1.x - point0.x,
             point1.y - point0.y,
             point3.x - point0.x,
             point3.y - point0.y);

    CB = dot(point2.x - point3.x,
             point2.y - point3.y,
             point0.x - point3.x,
             point0.y - point3.y);

    h1 = (A2*B2 - AB*AB) >> 3;
    h2 = (C2*B2 - CB*CB) >> 3;

    if (h1 < B2 && h2 < B2) {
        /* deviation squared less than half a pixel, use straight line */
        stroke_lines_append_fix(lines, &point3);
    } else {
        SpicePointFix point01, point23, point12, point012, point123, point0123;

        point01.x = (point0.x + point1.x) / 2;
        point01.y = (point0.y + point1.y) / 2;
        point12.x = (point1.x + point2.x) / 2;
        point12.y = (point1.y + point2.y) / 2;
        point23.x = (point2.x + point3.x) / 2;
        point23.y = (point2.y + point3.y) / 2;
        point012.x = (point01.x + point12.x) / 2;
        point012.y = (point01.y + point12.y) / 2;
        point123.x = (point12.x + point23.x) / 2;
        point123.y = (point12.y + point23.y) / 2;
        point0123.x = (point012.x + point123.x) / 2;
        point0123.y = (point012.y + point123.y) / 2;

        subdivide_bezier(lines, point0, point01, point012, point0123);
        subdivide_bezier(lines, point0123, point123, point23, point3);
    }
}

static void stroke_lines_append_bezier(StrokeLines *lines,
                                       SpicePointFix *point1,
                                       SpicePointFix *point2,
                                       SpicePointFix *point3)
{
    SpicePointFix point0;

    point0.x = int_to_fix(lines->points[lines->num_points-1].x);
    point0.y = int_to_fix(lines->points[lines->num_points-1].y);

    subdivide_bezier(lines, point0, *point1, *point2, *point3);
}

static void stroke_lines_draw(StrokeLines *lines,
                              lineGC *gc,
                              int dashed)
{
    if (lines->num_points != 0) {
        if (dashed) {
            spice_canvas_zero_dash_line(gc, CoordModeOrigin,
                                        lines->num_points, lines->points);
        } else {
            spice_canvas_zero_line(gc, CoordModeOrigin,
                                   lines->num_points, lines->points);
        }
        lines->num_points = 0;
    }
}


static void canvas_draw_stroke(SpiceCanvas *spice_canvas, SpiceRect *bbox,
                               SpiceClip *clip, SpiceStroke *stroke)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    SpiceCanvas *surface_canvas = NULL;
    StrokeGC gc;
    lineGCOps ops = {
        stroke_fill_spans,
        stroke_fill_rects
    };
    StrokeLines lines;
    unsigned int i;
    int dashed;

    memset(&gc, 0, sizeof(gc));

    pixman_region32_init_rect(&gc.dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &gc.dest_region, clip);

    if (!pixman_region32_not_empty(&gc.dest_region)) {
        touch_brush(canvas, &stroke->brush);
        pixman_region32_fini(&gc.dest_region);
        return;
    }

    gc.canvas = spice_canvas;
    gc.fore_rop = ropd_descriptor_to_rop(stroke->fore_mode,
                                         ROP_INPUT_BRUSH,
                                         ROP_INPUT_DEST);
    gc.back_rop = ropd_descriptor_to_rop(stroke->back_mode,
                                         ROP_INPUT_BRUSH,
                                         ROP_INPUT_DEST);

    gc.base.width = canvas->width;
    gc.base.height = canvas->height;
    gc.base.alu = gc.fore_rop;
    gc.base.lineWidth = 0;

    /* dash */
    gc.base.dashOffset = 0;
    gc.base.dash = NULL;
    gc.base.numInDashList = 0;
    gc.base.lineStyle = LineSolid;
    /* win32 cosmetic lines are endpoint-exclusive, so use CapNotLast */
    gc.base.capStyle = CapNotLast;
    gc.base.joinStyle = JoinMiter;
    gc.base.ops = &ops;

    dashed = 0;
    if (stroke->attr.flags & SPICE_LINE_FLAGS_STYLED) {
        SPICE_FIXED28_4 *style = stroke->attr.style;
        int nseg;

        dashed = 1;

        nseg = stroke->attr.style_nseg;

        /* To truly handle back_mode we should use LineDoubleDash here
           and treat !foreground as back_rop using the same brush.
           However, using the same brush for that seems wrong.
           The old cairo backend was stroking the non-dashed line with
           rop_mode before enabling dashes for the foreground which is
           not right either. The gl an gdi backend don't use back_mode
           at all */
        gc.base.lineStyle = LineOnOffDash;
        gc.base.dash = (unsigned char *)spice_malloc(nseg);
        gc.base.numInDashList = nseg;

        if (stroke->attr.flags & SPICE_LINE_FLAGS_START_WITH_GAP) {
            gc.base.dash[stroke->attr.style_nseg - 1] = fix_to_int(style[0]);
            for (i = 0; i < (unsigned int)(stroke->attr.style_nseg - 1); i++) {
                gc.base.dash[i] = fix_to_int(style[i+1]);
            }
            gc.base.dashOffset = gc.base.dash[0];
        } else {
            for (i = 0; i < stroke->attr.style_nseg; i++) {
                gc.base.dash[i] = fix_to_int(style[i]);
            }
        }
    }

    switch (stroke->brush.type) {
    case SPICE_BRUSH_TYPE_NONE:
        gc.solid = TRUE;
        gc.color = 0;
        break;
    case SPICE_BRUSH_TYPE_SOLID:
        gc.solid = TRUE;
        gc.color = stroke->brush.u.color;
        break;
    case SPICE_BRUSH_TYPE_PATTERN:
        gc.solid = FALSE;
        surface_canvas = canvas_get_surface(canvas,
                                            stroke->brush.u.pattern.pat);
        if (surface_canvas) {
            gc.use_surface_canvas = TRUE;
            gc.surface_canvas = surface_canvas;
        } else {
            gc.use_surface_canvas = FALSE;
            gc.tile = canvas_get_image(canvas,
                                       stroke->brush.u.pattern.pat,
                                       FALSE);
        }
        gc.tile_offset_x = stroke->brush.u.pattern.pos.x;
        gc.tile_offset_y = stroke->brush.u.pattern.pos.y;
        break;
    default:
        spice_warn_if_reached();
        return;
    }

    stroke_lines_init(&lines);

    for (i = 0; i < stroke->path->num_segments; i++) {
        SpicePathSeg *seg = stroke->path->segments[i];
        SpicePointFix* point, *end_point;

        point = seg->points;
        end_point = point + seg->count;

        if (seg->flags & SPICE_PATH_BEGIN) {
            stroke_lines_draw(&lines, (lineGC *)&gc, dashed);
            stroke_lines_append_fix(&lines, point);
            point++;
        }

        if (seg->flags & SPICE_PATH_BEZIER) {
            spice_return_if_fail((point - end_point) % 3 == 0);
            for (; point + 2 < end_point; point += 3) {
                stroke_lines_append_bezier(&lines,
                                           &point[0],
                                           &point[1],
                                           &point[2]);
            }
        } else
            {
            for (; point < end_point; point++) {
                stroke_lines_append_fix(&lines, point);
            }
        }
        if (seg->flags & SPICE_PATH_END) {
            if (seg->flags & SPICE_PATH_CLOSE) {
                stroke_lines_append(&lines,
                                    lines.points[0].x, lines.points[0].y);
            }
            stroke_lines_draw(&lines, (lineGC *)&gc, dashed);
        }
    }

    stroke_lines_draw(&lines, (lineGC *)&gc, dashed);

    free(gc.base.dash);
    stroke_lines_free(&lines);

    if (!gc.solid && gc.tile && !surface_canvas) {
        pixman_image_unref(gc.tile);
    }

    pixman_region32_fini(&gc.dest_region);
}


//need surfaces handling here !!!
static void canvas_draw_rop3(SpiceCanvas *spice_canvas, SpiceRect *bbox,
                             SpiceClip *clip, SpiceRop3 *rop3)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    SpiceCanvas *surface_canvas;
    pixman_region32_t dest_region;
    pixman_image_t *d;
    pixman_image_t *s;
    SpicePoint src_pos;
    int width;
    int heigth;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);
    canvas_mask_pixman(canvas, &dest_region, &rop3->mask,
                       bbox->left, bbox->top);

    width = bbox->right - bbox->left;
    heigth = bbox->bottom - bbox->top;

    d = canvas_get_image_from_self(spice_canvas, bbox->left, bbox->top, width, heigth, FALSE);
    surface_canvas = canvas_get_surface(canvas, rop3->src_bitmap);
    if (surface_canvas) {
        s = surface_canvas->ops->get_image(surface_canvas, FALSE);
    } else {
        s = canvas_get_image(canvas, rop3->src_bitmap, FALSE);
    }

    if (!rect_is_same_size(bbox, &rop3->src_area)) {
        pixman_image_t *scaled_s = canvas_scale_surface(s, &rop3->src_area, width, heigth,
                                                        rop3->scale_mode);
        pixman_image_unref(s);
        s = scaled_s;
        src_pos.x = 0;
        src_pos.y = 0;
    } else {
        src_pos.x = rop3->src_area.left;
        src_pos.y = rop3->src_area.top;
    }
    if (pixman_image_get_width(s) - src_pos.x < width ||
        pixman_image_get_height(s) - src_pos.y < heigth) {
        spice_critical("bad src bitmap size");
        return;
    }
    if (rop3->brush.type == SPICE_BRUSH_TYPE_PATTERN) {
        SpiceCanvas *_surface_canvas;
        pixman_image_t *p;

        _surface_canvas = canvas_get_surface(canvas, rop3->brush.u.pattern.pat);
        if (_surface_canvas) {
            p = _surface_canvas->ops->get_image(_surface_canvas, FALSE);
        } else {
            p = canvas_get_image(canvas, rop3->brush.u.pattern.pat, FALSE);
        }
        SpicePoint pat_pos;

        pat_pos.x = (bbox->left - rop3->brush.u.pattern.pos.x) % pixman_image_get_width(p);
        pat_pos.y = (bbox->top - rop3->brush.u.pattern.pos.y) % pixman_image_get_height(p);
        do_rop3_with_pattern(rop3->rop3, d, s, &src_pos, p, &pat_pos);
        pixman_image_unref(p);
    } else {
        do_rop3_with_color(rop3->rop3, d, s, &src_pos, rop3->brush.u.color);
    }
    pixman_image_unref(s);

    spice_canvas->ops->blit_image(spice_canvas, &dest_region, d,
                                  bbox->left,
                                  bbox->top);

    pixman_image_unref(d);

    pixman_region32_fini(&dest_region);
}

static void transform_to_pixman_transform(SpiceTransform *transform,
                                          pixman_transform_t *p)
{
    p->matrix[0][0] = transform->t00;
    p->matrix[0][1] = transform->t01;
    p->matrix[0][2] = transform->t02;
    p->matrix[1][0] = transform->t10;
    p->matrix[1][1] = transform->t11;
    p->matrix[1][2] = transform->t12;
    p->matrix[2][0] = 0;
    p->matrix[2][1] = 0;
    p->matrix[2][2] = pixman_fixed_1;
}

#define MASK(lo, hi)                                                    \
    (((1U << (hi)) - 1) - (((1U << (lo))) - 1))

#define EXTRACT(v, lo, hi)                                              \
    ((v & MASK(lo, hi)) >> lo)

static void canvas_draw_composite(SpiceCanvas *spice_canvas, SpiceRect *bbox,
                                  SpiceClip *clip, SpiceComposite *composite)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    SpiceCanvas *surface_canvas;
    pixman_region32_t dest_region;
    pixman_image_t *d;
    pixman_image_t *s;
    pixman_image_t *m;
    pixman_repeat_t src_repeat;
    pixman_filter_t src_filter;
    pixman_op_t op;
    pixman_transform_t transform;
    int width, height;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);

    width = bbox->right - bbox->left;
    height = bbox->bottom - bbox->top;

    /* Dest */
    d = canvas_get_image_from_self(spice_canvas, bbox->left, bbox->top, width, height,
                                   (composite->flags & SPICE_COMPOSITE_DEST_OPAQUE));

    /* Src */
    surface_canvas = canvas_get_surface(canvas, composite->src_bitmap);
    if (surface_canvas) {
        s = surface_canvas->ops->get_image(surface_canvas,
                                           (composite->flags & SPICE_COMPOSITE_SOURCE_OPAQUE));
    } else {
        s = canvas_get_image(canvas, composite->src_bitmap, FALSE);
    }
    if (composite->flags & SPICE_COMPOSITE_HAS_SRC_TRANSFORM)
    {
        transform_to_pixman_transform (&composite->src_transform, &transform);
        pixman_image_set_transform (s, &transform);
    }
    src_filter = (pixman_filter_t) EXTRACT (composite->flags, 8, 11);
    src_repeat = (pixman_repeat_t) EXTRACT (composite->flags, 14, 16);
    pixman_image_set_filter (s, src_filter, NULL, 0);
    pixman_image_set_repeat (s, src_repeat);

    /* Mask */
    m = NULL;
    if (composite->flags & SPICE_COMPOSITE_HAS_MASK) {
        pixman_filter_t mask_filter = (pixman_filter_t) EXTRACT (composite->flags, 11, 14);
        pixman_repeat_t mask_repeat = (pixman_repeat_t) EXTRACT (composite->flags, 16, 18);
        pixman_bool_t component_alpha = EXTRACT (composite->flags, 18, 19);

        surface_canvas = canvas_get_surface(canvas, composite->mask_bitmap);
        if (surface_canvas) {
            m = surface_canvas->ops->get_image(surface_canvas, FALSE);
        } else {
            m = canvas_get_image(canvas, composite->mask_bitmap, FALSE);
        }

        if (composite->flags & SPICE_COMPOSITE_HAS_MASK_TRANSFORM) {
            transform_to_pixman_transform (&composite->mask_transform, &transform);
            pixman_image_set_transform (m, &transform);
        }

        pixman_image_set_repeat (m, mask_repeat);
        pixman_image_set_filter (m, mask_filter, NULL, 0);
        pixman_image_set_component_alpha (m, component_alpha);
    }

    op = (pixman_op_t) EXTRACT (composite->flags, 0, 8);

    pixman_image_composite32 (op, s, m, d,
                              composite->src_origin.x, composite->src_origin.y,
                              composite->mask_origin.x, composite->mask_origin.y,
                              0, 0, width, height);

    pixman_image_unref(s);
    if (m)
        pixman_image_unref(m);

    spice_canvas->ops->blit_image(spice_canvas, &dest_region, d,
                                  bbox->left,
                                  bbox->top);

    pixman_image_unref(d);

    pixman_region32_fini(&dest_region);
}

static void canvas_copy_bits(SpiceCanvas *spice_canvas, SpiceRect *bbox, SpiceClip *clip, SpicePoint *src_pos)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_t dest_region;
    int dx, dy;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(canvas, &dest_region, clip);

    dx = bbox->left - src_pos->x;
    dy = bbox->top - src_pos->y;

    if (dx != 0 || dy != 0) {
        pixman_region32_t src_region;

        /* Clip so we don't read outside canvas */
        pixman_region32_init_rect(&src_region,
                                  dx, dy,
                                  canvas->width,
                                  canvas->height);
        pixman_region32_intersect(&dest_region, &dest_region, &src_region);
        pixman_region32_fini(&src_region);

        spice_canvas->ops->copy_region(spice_canvas, &dest_region, dx, dy);
    }

    pixman_region32_fini(&dest_region);
}



static void canvas_base_group_start(SpiceCanvas *spice_canvas, QRegion *region)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_fini(&canvas->canvas_region);

    /* Make sure we always clip to canvas size */
    pixman_region32_init_rect(&canvas->canvas_region,
                              0, 0,
                              canvas->width,
                              canvas->height);

    pixman_region32_intersect(&canvas->canvas_region, &canvas->canvas_region, region);
}

static void canvas_base_group_end(SpiceCanvas *spice_canvas)
{
    CanvasBase *canvas = (CanvasBase *)spice_canvas;
    pixman_region32_fini(&canvas->canvas_region);
    pixman_region32_init_rect(&canvas->canvas_region,
                              0, 0,
                              canvas->width,
                              canvas->height);
}


static void unimplemented_op(SpiceCanvas *canvas)
{
    spice_critical("unimplemented canvas operation");
}

inline static void canvas_base_init_ops(SpiceCanvasOps *ops)
{
    void **ops_cast;
    unsigned i;

    ops_cast = (void **)ops;
    for (i = 0; i < sizeof(SpiceCanvasOps) / sizeof(void *); i++) {
        ops_cast[i] = (void *) unimplemented_op;
    }

    ops->draw_fill = canvas_draw_fill;
    ops->draw_copy = canvas_draw_copy;
    ops->draw_opaque = canvas_draw_opaque;
    ops->copy_bits = canvas_copy_bits;
    ops->draw_blend = canvas_draw_copy; // copy and blend are the same
    ops->draw_blackness = canvas_draw_blackness;
    ops->draw_whiteness = canvas_draw_whiteness;
    ops->draw_invers = canvas_draw_invers;
    ops->draw_transparent = canvas_draw_transparent;
    ops->draw_alpha_blend = canvas_draw_alpha_blend;
    ops->draw_stroke = canvas_draw_stroke;
    ops->draw_rop3 = canvas_draw_rop3;
    ops->draw_composite = canvas_draw_composite;
    ops->group_start = canvas_base_group_start;
    ops->group_end = canvas_base_group_end;
}

static int canvas_base_init(CanvasBase *canvas, SpiceCanvasOps *ops,
                            int width, int height, uint32_t format
                            , SpiceImageCache *bits_cache
#ifdef SW_CANVAS_CACHE
                            , SpicePaletteCache *palette_cache
#endif
                            , SpiceImageSurfaces *surfaces
                            , SpiceGlzDecoder *glz_decoder
                            , SpiceJpegDecoder *jpeg_decoder
                            , SpiceZlibDecoder *zlib_decoder
                            )
{
    canvas->parent.ops = ops;
    canvas->quic_data.usr.error = quic_usr_error;
    canvas->quic_data.usr.warn = quic_usr_warn;
    canvas->quic_data.usr.info = quic_usr_warn;
    canvas->quic_data.usr.malloc = quic_usr_malloc;
    canvas->quic_data.usr.free = quic_usr_free;
    canvas->quic_data.usr.more_space = quic_usr_more_space;
    canvas->quic_data.usr.more_lines = quic_usr_more_lines;
    if (!(canvas->quic_data.quic = quic_create(&canvas->quic_data.usr))) {
            return 0;
    }

    canvas->lz_data.usr.error = lz_usr_error;
    canvas->lz_data.usr.warn = lz_usr_warn;
    canvas->lz_data.usr.info = lz_usr_warn;
    canvas->lz_data.usr.malloc = lz_usr_malloc;
    canvas->lz_data.usr.free = lz_usr_free;
    canvas->lz_data.usr.more_space = lz_usr_more_space;
    canvas->lz_data.usr.more_lines = lz_usr_more_lines;
    if (!(canvas->lz_data.lz = lz_create(&canvas->lz_data.usr))) {
            return 0;
    }

    canvas->surfaces = surfaces;
    canvas->glz_data.decoder = glz_decoder;
    canvas->jpeg = jpeg_decoder;
    canvas->zlib = zlib_decoder;

    canvas->format = format;

    /* TODO: This is all wrong now */
    if (SPICE_SURFACE_FMT_DEPTH(format) == 16) {
        canvas->color_shift = 5;
        canvas->color_mask = 0x1f;
    } else {
        canvas->color_shift = 8;
        canvas->color_mask = 0xff;
    }

    canvas->width = width;
    canvas->height = height;
    pixman_region32_init_rect(&canvas->canvas_region,
                              0, 0,
                              canvas->width,
                              canvas->height);

    canvas->bits_cache = bits_cache;
#ifdef SW_CANVAS_CACHE
    canvas->palette_cache = palette_cache;
#endif

    return 1;
}

```

`devices/display/qxl/canvas/canvas_base.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_CANVAS_BASE
#define H_SPICE_COMMON_CANVAS_BASE

#include <spice/macros.h>

#include "pixman_utils.h"
#include "lz.h"
#include "region.h"
#include "draw.h"

SPICE_BEGIN_DECLS

typedef void (*spice_destroy_fn_t)(void *data);

typedef struct _SpiceImageCache SpiceImageCache;
typedef struct _SpiceImageSurfaces SpiceImageSurfaces;
typedef struct _SpicePaletteCache SpicePaletteCache;
typedef struct _SpiceGlzDecoder SpiceGlzDecoder;
typedef struct _SpiceJpegDecoder SpiceJpegDecoder;
typedef struct _SpiceZlibDecoder SpiceZlibDecoder;
typedef struct _SpiceCanvas SpiceCanvas;

typedef struct {
    void (*put)(SpiceImageCache *cache,
                uint64_t id,
                pixman_image_t *surface);
    pixman_image_t *(*get)(SpiceImageCache *cache,
                           uint64_t id);
#ifdef SW_CANVAS_CACHE
    void (*put_lossy)(SpiceImageCache *cache,
                      uint64_t id,
                      pixman_image_t *surface);
    void (*replace_lossy)(SpiceImageCache *cache,
                          uint64_t id,
                          pixman_image_t *surface);
    pixman_image_t *(*get_lossless)(SpiceImageCache *cache,
                                    uint64_t id);
#endif
} SpiceImageCacheOps;

struct _SpiceImageCache {
  const SpiceImageCacheOps *ops;
};

typedef struct {
 SpiceCanvas *(*get)(SpiceImageSurfaces *surfaces,
                     uint32_t surface_id);
} SpiceImageSurfacesOps;

struct _SpiceImageSurfaces {
 const SpiceImageSurfacesOps *ops;
};

typedef struct {
    void (*put)(SpicePaletteCache *cache,
                SpicePalette *palette);
    SpicePalette *(*get)(SpicePaletteCache *cache,
                         uint64_t id);
    void (*release)(SpicePaletteCache *cache,
                    SpicePalette *palette);
} SpicePaletteCacheOps;

struct _SpicePaletteCache {
  SpicePaletteCacheOps *ops;
};

typedef struct {
    void (*decode)(SpiceGlzDecoder *decoder,
                   uint8_t *data,
                   SpicePalette *plt,
                   void *usr_data);
} SpiceGlzDecoderOps;

struct _SpiceGlzDecoder {
  SpiceGlzDecoderOps *ops;
};


typedef struct SpiceJpegDecoderOps {
    void (*begin_decode)(SpiceJpegDecoder *decoder,
                         uint8_t* data,
                         int data_size,
                         int* out_width,
                         int* out_height);
    void (*decode)(SpiceJpegDecoder *decoder,
                   uint8_t* dest,
                   int stride,
                   int format);
} SpiceJpegDecoderOps;

struct _SpiceJpegDecoder {
    SpiceJpegDecoderOps *ops;
};

typedef struct {
    void (*decode)(SpiceZlibDecoder *decoder,
                   uint8_t *data,
                   int data_size,
                   uint8_t *dest,
                   int dest_size);
} SpiceZlibDecoderOps;

struct _SpiceZlibDecoder {
  SpiceZlibDecoderOps *ops;
};

typedef struct {
    void (*draw_fill)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceFill *fill);
    void (*draw_copy)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceCopy *copy);
    void (*draw_opaque)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceOpaque *opaque);
    void (*copy_bits)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpicePoint *src_pos);
    void (*draw_text)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceText *text);
    void (*draw_stroke)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceStroke *stroke);
    void (*draw_rop3)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceRop3 *rop3);
    void (*draw_composite)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceComposite *composite);
    void (*draw_blend)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceBlend *blend);
    void (*draw_blackness)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceBlackness *blackness);
    void (*draw_whiteness)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceWhiteness *whiteness);
    void (*draw_invers)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceInvers *invers);
    void (*draw_transparent)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceTransparent* transparent);
    void (*draw_alpha_blend)(SpiceCanvas *canvas, SpiceRect *bbox, SpiceClip *clip, SpiceAlphaBlend* alpha_blend);
    void (*put_image)(SpiceCanvas *canvas,
                      const SpiceRect *dest, const uint8_t *src_data,
                      uint32_t src_width, uint32_t src_height, int src_stride,
                      const QRegion *clip);
    void (*clear)(SpiceCanvas *canvas);
    void (*read_bits)(SpiceCanvas *canvas, uint8_t *dest, int dest_stride, const SpiceRect *area);
    void (*group_start)(SpiceCanvas *canvas, QRegion *region);
    void (*group_end)(SpiceCanvas *canvas);
    void (*destroy)(SpiceCanvas *canvas);

    /* Implementation vfuncs */
    void (*fill_solid_spans)(SpiceCanvas *canvas,
                             SpicePoint *points,
                             int *widths,
                             int n_spans,
                             uint32_t color);
    void (*fill_solid_rects)(SpiceCanvas *canvas,
                             pixman_box32_t *rects,
                             int n_rects,
                             uint32_t color);
    void (*fill_solid_rects_rop)(SpiceCanvas *canvas,
                                 pixman_box32_t *rects,
                                 int n_rects,
                                 uint32_t color,
                                 SpiceROP rop);
    void (*fill_tiled_rects)(SpiceCanvas *canvas,
                             pixman_box32_t *rects,
                             int n_rects,
                             pixman_image_t *tile,
                             int offset_x, int offset_y);
    void (*fill_tiled_rects_from_surface)(SpiceCanvas *canvas,
                                          pixman_box32_t *rects,
                                          int n_rects,
                                          SpiceCanvas *tile,
                                          int offset_x, int offset_y);
    void (*fill_tiled_rects_rop)(SpiceCanvas *canvas,
                                 pixman_box32_t *rects,
                                 int n_rects,
                                 pixman_image_t *tile,
                                 int offset_x, int offset_y,
                                 SpiceROP rop);
    void (*fill_tiled_rects_rop_from_surface)(SpiceCanvas *canvas,
                                              pixman_box32_t *rects,
                                              int n_rects,
                                              SpiceCanvas *tile,
                                              int offset_x, int offset_y,
                                              SpiceROP rop);
    void (*blit_image)(SpiceCanvas *canvas,
                       pixman_region32_t *region,
                       pixman_image_t *src_image,
                       int offset_x, int offset_y);
    void (*blit_image_from_surface)(SpiceCanvas *canvas,
                                    pixman_region32_t *region,
                                    SpiceCanvas *src_image,
                                    int offset_x, int offset_y);
    void (*blit_image_rop)(SpiceCanvas *canvas,
                           pixman_region32_t *region,
                           pixman_image_t *src_image,
                           int offset_x, int offset_y,
                           SpiceROP rop);
    void (*blit_image_rop_from_surface)(SpiceCanvas *canvas,
                                        pixman_region32_t *region,
                                        SpiceCanvas *src_image,
                                        int offset_x, int offset_y,
                                        SpiceROP rop);
    void (*scale_image)(SpiceCanvas *canvas,
                        pixman_region32_t *region,
                        pixman_image_t *src_image,
                        int src_x, int src_y,
                        int src_width, int src_height,
                        int dest_x, int dest_y,
                        int dest_width, int dest_height,
                        int scale_mode);
    void (*scale_image_from_surface)(SpiceCanvas *canvas,
                                     pixman_region32_t *region,
                                     SpiceCanvas *src_image,
                                     int src_x, int src_y,
                                     int src_width, int src_height,
                                     int dest_x, int dest_y,
                                     int dest_width, int dest_height,
                                     int scale_mode);
    void (*scale_image_rop)(SpiceCanvas *canvas,
                            pixman_region32_t *region,
                            pixman_image_t *src_image,
                            int src_x, int src_y,
                            int src_width, int src_height,
                            int dest_x, int dest_y,
                            int dest_width, int dest_height,
                            int scale_mode, SpiceROP rop);
    void (*scale_image_rop_from_surface)(SpiceCanvas *canvas,
                                         pixman_region32_t *region,
                                         SpiceCanvas *src_image,
                                         int src_x, int src_y,
                                         int src_width, int src_height,
                                         int dest_x, int dest_y,
                                         int dest_width, int dest_height,
                                         int scale_mode, SpiceROP rop);
    void (*blend_image)(SpiceCanvas *canvas,
                        pixman_region32_t *region,
                        int dest_has_alpha,
                        pixman_image_t *src_image,
                        int src_x, int src_y,
                        int dest_x, int dest_y,
                        int width, int height,
                        int overall_alpha);
    void (*blend_image_from_surface)(SpiceCanvas *canvas,
                                     pixman_region32_t *region,
                                     int dest_has_alpha,
                                     SpiceCanvas *src_image,
                                     int src_has_alpha,
                                     int src_x, int src_y,
                                     int dest_x, int dest_y,
                                     int width, int height,
                                     int overall_alpha);
    void (*blend_scale_image)(SpiceCanvas *canvas,
                              pixman_region32_t *region,
                              int dest_has_alpha,
                              pixman_image_t *src_image,
                              int src_x, int src_y,
                              int src_width, int src_height,
                              int dest_x, int dest_y,
                              int dest_width, int dest_height,
                              int scale_mode,
                              int overall_alpha);
    void (*blend_scale_image_from_surface)(SpiceCanvas *canvas,
                                           pixman_region32_t *region,
                                           int dest_has_alpha,
                                           SpiceCanvas *src_image,
                                           int src_has_alpha,
                                           int src_x, int src_y,
                                           int src_width, int src_height,
                                           int dest_x, int dest_y,
                                           int dest_width, int dest_height,
                                           int scale_mode,
                                           int overall_alpha);
    void (*colorkey_image)(SpiceCanvas *canvas,
                           pixman_region32_t *region,
                           pixman_image_t *src_image,
                           int offset_x, int offset_y,
                           uint32_t transparent_color);
    void (*colorkey_image_from_surface)(SpiceCanvas *canvas,
                                        pixman_region32_t *region,
                                        SpiceCanvas *src_image,
                                        int offset_x, int offset_y,
                                        uint32_t transparent_color);
    void (*colorkey_scale_image)(SpiceCanvas *canvas,
                                 pixman_region32_t *region,
                                 pixman_image_t *src_image,
                                 int src_x, int src_y,
                                 int src_width, int src_height,
                                 int dest_x, int dest_y,
                                 int dest_width, int dest_height,
                                 uint32_t transparent_color);
    void (*colorkey_scale_image_from_surface)(SpiceCanvas *canvas,
                                              pixman_region32_t *region,
                                              SpiceCanvas *src_image,
                                              int src_x, int src_y,
                                              int src_width, int src_height,
                                              int dest_x, int dest_y,
                                              int dest_width, int dest_height,
                                              uint32_t transparent_color);
    void (*copy_region)(SpiceCanvas *canvas,
                        pixman_region32_t *dest_region,
                        int dx, int dy);
    pixman_image_t *(*get_image)(SpiceCanvas *canvas, int force_opaque);
} SpiceCanvasOps;

struct _SpiceCanvas {
  SpiceCanvasOps *ops;
};

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/canvas_utils.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#include "canvas_utils.h"
#include "mem.h"

typedef struct PixmanData {
    uint8_t *data;
    pixman_format_code_t format;
} PixmanData;

static void release_data(SPICE_GNUC_UNUSED pixman_image_t *image,
                         void *release_data)
{
    PixmanData *data = (PixmanData *)release_data;

    free(data->data);

    free(data);
}

static PixmanData *
pixman_image_add_data(pixman_image_t *image)
{
    PixmanData *data;

    data = (PixmanData *)pixman_image_get_destroy_data(image);
    if (data == NULL) {
        data = (PixmanData *)calloc(1, sizeof(PixmanData));
        if (data == NULL) {
            spice_error("out of memory");
        }
        pixman_image_set_destroy_function(image,
                                          release_data,
                                          data);
    }

    return data;
}

void
spice_pixman_image_set_format(pixman_image_t *image,
                              pixman_format_code_t format)
{
    PixmanData *data;

    data = pixman_image_add_data(image);
    data->format = format;
}


int spice_pixman_image_get_format(pixman_image_t *image, pixman_format_code_t *format)
{
    PixmanData *data;

    spice_return_val_if_fail(format != NULL, 0);

    data = (PixmanData *)pixman_image_get_destroy_data(image);
    if (data != NULL && data->format != 0) {
        *format = data->format;
        return 1;
    }

    spice_warn_if_reached();
    return 0;
}

pixman_image_t *surface_create_stride(pixman_format_code_t format, int width, int height,
                                      int stride)
{
    uint8_t *data;
    uint8_t *stride_data;
    pixman_image_t *surface;
    PixmanData *pixman_data;

    data = (uint8_t *)spice_malloc_n(abs(stride), height);
    if (stride < 0) {
        stride_data = data + (-stride) * (height - 1);
    } else {
        stride_data = data;
    }

    surface = pixman_image_create_bits(format, width, height, (uint32_t *)stride_data, stride);

    if (surface == NULL) {
        free(data);
        data = NULL;
        spice_error("create surface failed, out of memory");
    }

    pixman_data = pixman_image_add_data(surface);
    pixman_data->data = data;
    pixman_data->format = format;

    return surface;
}

pixman_image_t * surface_create(pixman_format_code_t format, int width, int height, int top_down)
{
    if (top_down) {
        pixman_image_t *surface;
        PixmanData *data;

        surface = pixman_image_create_bits(format, width, height, NULL, 0);
        data = pixman_image_add_data(surface);
        data->format = format;
        return surface;
    } else {
        // NOTE: we assume here that the lz decoders always decode to RGB32.
        int stride = 0;
        switch (format) {
        case PIXMAN_a8r8g8b8:
        case PIXMAN_x8r8g8b8:
#ifdef WORDS_BIGENDIAN
        case PIXMAN_b8g8r8a8:
        case PIXMAN_b8g8r8x8:
#endif
            stride = width * 4;
            break;
        case PIXMAN_r8g8b8:
#ifdef WORDS_BIGENDIAN
        case PIXMAN_b8g8r8:
#endif
            // NOTE: LZ4 also decodes to RGB24
            stride = SPICE_ALIGN(width * 3, 4);
            break;
        case PIXMAN_x1r5g5b5:
        case PIXMAN_r5g6b5:
            stride = SPICE_ALIGN(width * 2, 4);
            break;
        case PIXMAN_a8:
            stride = SPICE_ALIGN(width, 4);
            break;
        case PIXMAN_a1:
            stride = SPICE_ALIGN(width, 32) / 8;
            break;
        default:
            spice_error("invalid format");
        }
        stride = -stride;
        return surface_create_stride(format, width, height, stride);
    }
}

pixman_image_t *alloc_lz_image_surface(LzDecodeUsrData *canvas_data,
                                       pixman_format_code_t pixman_format, int width,
                                       int height, int gross_pixels, int top_down)
{
    int stride;
    pixman_image_t *surface = NULL;

    stride = (gross_pixels / height) * (PIXMAN_FORMAT_BPP (pixman_format) / 8);

    /* pixman requires strides to be 4-byte aligned */
    stride = SPICE_ALIGN(stride, 4);

    if (!top_down) {
        stride = -stride;
    }

    surface = surface_create_stride(pixman_format, width, height, stride);
    canvas_data->out_surface = surface;
    return surface;
}

```

`devices/display/qxl/canvas/canvas_utils.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_CANVAS_UTILS
#define H_SPICE_COMMON_CANVAS_UTILS

#include <spice/types.h>
#include <spice/macros.h>

#include "pixman_utils.h"
#include "lz.h"

SPICE_BEGIN_DECLS

void spice_pixman_image_set_format(pixman_image_t *image,
                                   pixman_format_code_t format);
int spice_pixman_image_get_format(pixman_image_t *image, pixman_format_code_t *format);


pixman_image_t *surface_create(pixman_format_code_t format, int width, int height, int top_down);

pixman_image_t *surface_create_stride(pixman_format_code_t format, int width, int height,
                                      int stride);


typedef struct LzDecodeUsrData {
    pixman_image_t       *out_surface;
} LzDecodeUsrData;


pixman_image_t *alloc_lz_image_surface(LzDecodeUsrData *canvas_data,
                                       pixman_format_code_t pixman_format, int width,
                                       int height, int gross_pixels, int top_down);

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/config.h`:

```h
/*
 * Autogenerated by the Meson build system.
 * Do not edit, your changes will be lost.
 */

#pragma once

#define HAVE_ALLOCA 1

#define HAVE_ALLOCA_H 1

#define HAVE_ARPA_INET_H 1

#define HAVE_DLFCN_H 1

#define HAVE_DRAND48 1

#define HAVE_INTTYPES_H 1

#define HAVE_NETINET_IN_H 1

#define HAVE_OPUS 1

#define HAVE_REGEX_H 1

#define HAVE_SETLINEBUF 1

#define HAVE_SIGACTION 1

#define HAVE_STDLIB_H 1

#define HAVE_SYS_MMAN_H 1

#define HAVE_SYS_SOCKET_H 1

#define HAVE_SYS_STAT_H 1

#define HAVE_SYS_TYPES_H 1

#define HAVE_UNISTD_H 1

#define SW_CANVAS_CACHE 1

```

`devices/display/qxl/canvas/draw.h`:

```h
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef H_SPICE_COMMON_DRAW
#define H_SPICE_COMMON_DRAW

#include <spice/macros.h>
#include <spice/types.h>
#include <spice/enums.h>
#include "mem.h"

SPICE_BEGIN_DECLS

#define SPICE_GET_ADDRESS(addr) ((void *)(uintptr_t)(addr))
#define SPICE_SET_ADDRESS(addr, val) ((addr) = (uintptr_t)(val))

typedef int32_t SPICE_FIXED28_4;

typedef struct SpicePointFix {
    SPICE_FIXED28_4 x;
    SPICE_FIXED28_4 y;
} SpicePointFix;

typedef struct SpicePoint {
    int32_t x;
    int32_t y;
} SpicePoint;

typedef struct SpicePoint16 {
    int16_t x;
    int16_t y;
} SpicePoint16;

typedef struct SpiceRect {
    int32_t left;
    int32_t top;
    int32_t right;
    int32_t bottom;
} SpiceRect;

typedef struct SpicePathSeg {
    uint32_t flags;
    uint32_t count;
    SpicePointFix points[0];
} SpicePathSeg;

typedef struct SpicePath {
  uint32_t num_segments;
  SpicePathSeg *segments[0];
} SpicePath;

typedef struct SpiceClipRects {
  uint32_t num_rects;
  SpiceRect rects[0];
} SpiceClipRects;

typedef struct SpiceClip {
    uint8_t type;
    SpiceClipRects *rects;
} SpiceClip;

typedef struct SpicePalette {
    uint64_t unique;
    uint16_t num_ents;
    uint32_t ents[0];
} SpicePalette;

#define SPICE_SURFACE_FMT_DEPTH(_d) ((_d) & 0x3f)

typedef struct SpiceImageDescriptor {
    uint64_t id;
    uint8_t type;
    uint8_t flags;
    uint32_t width;
    uint32_t height;
} SpiceImageDescriptor;

typedef struct SpiceBitmap {
    uint8_t format;
    uint8_t flags;
    uint32_t x;
    uint32_t y;
    uint32_t stride;
    SpicePalette *palette;
    uint64_t palette_id;
    SpiceChunks *data;
} SpiceBitmap;

typedef struct SpiceSurface {
    uint32_t surface_id;
} SpiceSurface;

typedef struct SpiceQUICData {
    uint32_t data_size;
    SpiceChunks *data;
} SpiceQUICData, SpiceLZRGBData, SpiceJPEGData, SpiceLZ4Data;

typedef struct SpiceLZPLTData {
    uint8_t flags;
    uint32_t data_size;
    SpicePalette *palette;
    uint64_t palette_id;
    SpiceChunks *data;
} SpiceLZPLTData;

typedef struct SpiceZlibGlzRGBData {
    uint32_t glz_data_size;
    uint32_t data_size;
    SpiceChunks *data;
} SpiceZlibGlzRGBData;

typedef struct SpiceJPEGAlphaData {
    uint8_t flags;
    uint32_t jpeg_size;
    uint32_t data_size;
    SpiceChunks *data;
} SpiceJPEGAlphaData;


typedef struct SpiceImage {
    SpiceImageDescriptor descriptor;
    union {
        SpiceBitmap         bitmap;
        SpiceQUICData       quic;
        SpiceSurface        surface;
        SpiceLZRGBData      lz_rgb;
        SpiceLZPLTData      lz_plt;
        SpiceJPEGData       jpeg;
        SpiceLZ4Data        lz4;
        SpiceZlibGlzRGBData zlib_glz;
        SpiceJPEGAlphaData  jpeg_alpha;
    } u;
} SpiceImage;

typedef struct SpicePattern {
    SpiceImage *pat;
    SpicePoint pos;
} SpicePattern;

typedef struct SpiceBrush {
    uint32_t type;
    union {
        uint32_t color;
        SpicePattern pattern;
    } u;
} SpiceBrush;

typedef struct SpiceQMask {
    uint8_t flags;
    SpicePoint pos;
    SpiceImage *bitmap;
} SpiceQMask;

typedef struct SpiceFill {
    SpiceBrush brush;
    uint16_t rop_descriptor;
    SpiceQMask mask;
} SpiceFill;

typedef struct SpiceOpaque {
    SpiceImage *src_bitmap;
    SpiceRect src_area;
    SpiceBrush brush;
    uint16_t rop_descriptor;
    uint8_t scale_mode;
    SpiceQMask mask;
} SpiceOpaque;

typedef struct SpiceCopy {
    SpiceImage *src_bitmap;
    SpiceRect src_area;
    uint16_t rop_descriptor;
    uint8_t scale_mode;
    SpiceQMask mask;
} SpiceCopy, SpiceBlend;

typedef struct SpiceTransparent {
    SpiceImage *src_bitmap;
    SpiceRect src_area;
    uint32_t src_color;
    uint32_t true_color;
} SpiceTransparent;

typedef struct SpiceAlphaBlend {
    uint16_t alpha_flags;
    uint8_t alpha;
    SpiceImage *src_bitmap;
    SpiceRect src_area;
} SpiceAlphaBlend;

typedef struct SpiceRop3 {
    SpiceImage *src_bitmap;
    SpiceRect src_area;
    SpiceBrush brush;
    uint8_t rop3;
    uint8_t scale_mode;
    SpiceQMask mask;
} SpiceRop3;

/* Given in 16.16 fixed point */
typedef struct SpiceTransform {
    uint32_t t00;
    uint32_t t01;
    uint32_t t02;
    uint32_t t10;
    uint32_t t11;
    uint32_t t12;
} SpiceTransform;

typedef struct SpiceComposite {
    uint32_t flags;
    SpiceImage *src_bitmap;
    SpiceImage *mask_bitmap;
    SpiceTransform src_transform;
    SpiceTransform mask_transform;
    SpicePoint16 src_origin;
    SpicePoint16 mask_origin;
} SpiceComposite;

typedef struct SpiceBlackness {
    SpiceQMask mask;
} SpiceBlackness, SpiceInvers, SpiceWhiteness;

typedef struct SpiceLineAttr {
    uint8_t flags;
    uint8_t style_nseg;
    SPICE_FIXED28_4 *style;
} SpiceLineAttr;

typedef struct SpiceStroke {
    SpicePath *path;
    SpiceLineAttr attr;
    SpiceBrush brush;
    uint16_t fore_mode;
    uint16_t back_mode;
} SpiceStroke;

typedef struct SpiceRasterGlyph {
    SpicePoint render_pos;
    SpicePoint glyph_origin;
    uint16_t width;
    uint16_t height;
    uint8_t data[0];
} SpiceRasterGlyph;

typedef struct SpiceString {
    uint16_t length;
    uint16_t flags;
    SpiceRasterGlyph *glyphs[0];
} SpiceString;

typedef struct SpiceText {
    SpiceString *str;
    SpiceRect back_area;
    SpiceBrush fore_brush;
    SpiceBrush back_brush;
    uint16_t fore_mode;
    uint16_t back_mode;
} SpiceText;

typedef struct SpiceCursorHeader {
    uint64_t unique;
    uint16_t type;
    uint16_t width;
    uint16_t height;
    uint16_t hot_spot_x;
    uint16_t hot_spot_y;
} SpiceCursorHeader;

static inline int spice_image_descriptor_is_lossy(const SpiceImageDescriptor *descriptor)
{
    return descriptor->type == SPICE_IMAGE_TYPE_JPEG ||
           descriptor->type == SPICE_IMAGE_TYPE_JPEG_ALPHA;
}

SPICE_END_DECLS

#endif // H_SPICE_COMMON_DRAW

```

`devices/display/qxl/canvas/lines.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/***********************************************************

Copyright 1989, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1989 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/
#include "config.h"

#include <stdio.h>
#include <spice/macros.h>
#ifdef _XOPEN_SOURCE
#include <math.h>
#else
#define _XOPEN_SOURCE           /* to get prototype for hypot on some systems */
#include <math.h>
#undef _XOPEN_SOURCE
#endif
#include "lines.h"
#include "mem.h"

#define xalloc(i) spice_malloc(i)
#define xrealloc(a,b) spice_realloc(a,b)
#define xfree(i) free(i)

typedef unsigned int CARD32;
typedef int Boolean;
typedef pixman_rectangle32_t xRectangle;
typedef SpicePoint DDXPointRec;
typedef DDXPointRec *DDXPointPtr;
typedef struct lineGC *GCPtr;

/* largest positive value that can fit into a component of a point.
 * Assumes that the point structure is {type x, y;} where type is
 * a signed type.
 */
#define MAX_COORDINATE 2147483647
#define MIN_COORDINATE -2147483647

#define miZeroLine spice_canvas_zero_line
#define miZeroDashLine spice_canvas_zero_dash_line
#define miWideDash spice_canvas_wide_dash_line
#define miWideLine spice_canvas_wide_line

static inline int ICEIL (double x)
{
    int _cTmp = (int)x;
    return ((x == _cTmp) || (x < 0.0)) ? _cTmp : _cTmp + 1;
}

typedef struct {
    int count;                  /* number of spans                  */
    DDXPointPtr points;         /* pointer to list of start points  */
    int *widths;                /* pointer to list of widths        */
} Spans;

typedef struct {
    int size;                   /* Total number of *Spans allocated     */
    int count;                  /* Number of *Spans actually in group   */
    Spans *group;               /* List of Spans                        */
    int ymin, ymax;             /* Min, max y values encountered        */
} SpanGroup;

/* Initialize SpanGroup.  MUST BE DONE before use. */
static void miInitSpanGroup (SpanGroup *        /*spanGroup */
    );

/* Add a Spans to a SpanGroup. The spans MUST BE in y-sorted order */
static void miAppendSpans (SpanGroup * /*spanGroup */ ,
                           SpanGroup * /*otherGroup */ ,
                           Spans *      /*spans */
    );

/* Paint a span group, insuring that each pixel is painted at most once */
static void miFillUniqueSpanGroup (GCPtr /*pGC */ ,
                                   SpanGroup * /*spanGroup */ ,
                                   Boolean /* foreground */
    );

/* Free up data in a span group.  MUST BE DONE or you'll suffer memory leaks */
static void miFreeSpanGroup (SpanGroup *        /*spanGroup */
    );

/* Rops which must use span groups */
#define miSpansCarefulRop(rop)  (((rop) & 0xc) == 0x8 || ((rop) & 0x3) == 0x2)
#define miSpansEasyRop(rop)     (!miSpansCarefulRop(rop))

/*
 * Public definitions used for configuring basic pixelization aspects
 * of the sample implementation line-drawing routines provided in
 * {mfb,mi,cfb*} at run-time.
 */

#define XDECREASING     4
#define YDECREASING     2
#define YMAJOR          1

#define OCTANT1                 (1 << (YDECREASING))
#define OCTANT2                 (1 << (YDECREASING|YMAJOR))
#define OCTANT3                 (1 << (XDECREASING|YDECREASING|YMAJOR))
#define OCTANT4                 (1 << (XDECREASING|YDECREASING))
#define OCTANT5                 (1 << (XDECREASING))
#define OCTANT6                 (1 << (XDECREASING|YMAJOR))
#define OCTANT7                 (1 << (YMAJOR))
#define OCTANT8                 (1 << (0))

#define XMAJOROCTANTS           (OCTANT1 | OCTANT4 | OCTANT5 | OCTANT8)

#define DEFAULTZEROLINEBIAS     (OCTANT2 | OCTANT3 | OCTANT4 | OCTANT5)

/*
 * Devices can configure the rendering of routines in mi, mfb, and cfb*
 * by specifying a thin line bias to be applied to a particular screen
 * using the following function.  The bias parameter is an OR'ing of
 * the appropriate OCTANT constants defined above to indicate which
 * octants to bias a line to prefer an axial step when the Bresenham
 * error term is exactly zero.  The octants are mapped as follows:
 *
 *   \    |    /
 *    \ 3 | 2 /
 *     \  |  /
 *    4 \ | / 1
 *       \|/
 *   -----------
 *       /|\
 *    5 / | \ 8
 *     /  |  \
 *    / 6 | 7 \
 *   /    |    \
 *
 * For more information, see "Ambiguities in Incremental Line Rastering,"
 * Jack E. Bresenham, IEEE CG&A, May 1987.
 */

/*
 * Private definitions needed for drawing thin (zero width) lines
 * Used by the mi, mfb, and all cfb* components.
 */

#define X_AXIS  0
#define Y_AXIS  1

#define OUT_LEFT  0x08
#define OUT_RIGHT 0x04
#define OUT_ABOVE 0x02
#define OUT_BELOW 0x01

#define OUTCODES(_result, _x, _y, _pbox) \
    if      ( (_x) <  (_pbox)->x1) (_result) |= OUT_LEFT; \
    else if ( (_x) >= (_pbox)->x2) (_result) |= OUT_RIGHT; \
    if      ( (_y) <  (_pbox)->y1) (_result) |= OUT_ABOVE; \
    else if ( (_y) >= (_pbox)->y2) (_result) |= OUT_BELOW;

#define MIOUTCODES(outcode, x, y, xmin, ymin, xmax, ymax) \
{\
     if (x < xmin) outcode |= OUT_LEFT;\
     if (x > xmax) outcode |= OUT_RIGHT;\
     if (y < ymin) outcode |= OUT_ABOVE;\
     if (y > ymax) outcode |= OUT_BELOW;\
}

#define SWAPINT(i, j) \
{  int _t = i;  i = j;  j = _t; }

#define SWAPPT(i, j) \
{  DDXPointRec _t; _t = i;  i = j; j = _t; }

#define SWAPINT_PAIR(x1, y1, x2, y2)\
{   int t = x1;  x1 = x2;  x2 = t;\
        t = y1;  y1 = y2;  y2 = t;\
}

#define miGetZeroLineBias(_pScreen) (DEFAULTZEROLINEBIAS)

#define CalcLineDeltas(_x1,_y1,_x2,_y2,_adx,_ady,_sx,_sy,_SX,_SY,_octant) \
    (_octant) = 0;                              \
    (_sx) = (_SX);                              \
    if (((_adx) = (_x2) - (_x1)) < 0) {                 \
        (_adx) = -(_adx);                       \
        (_sx = -(_sx));                                 \
        (_octant) |= XDECREASING;               \
    }                                           \
    (_sy) = (_SY);                              \
    if (((_ady) = (_y2) - (_y1)) < 0) {                 \
        (_ady) = -(_ady);                       \
        (_sy = -(_sy));                                 \
        (_octant) |= YDECREASING;               \
    }

#define SetYMajorOctant(_octant)        ((_octant) |= YMAJOR)

#define FIXUP_ERROR(_e, _octant, _bias) \
    (_e) -= (((_bias) >> (_octant)) & 1)

#define IsXMajorOctant(_octant)                 (!((_octant) & YMAJOR))
#define IsYMajorOctant(_octant)                 ((_octant) & YMAJOR)
#define IsXDecreasingOctant(_octant)    ((_octant) & XDECREASING)
#define IsYDecreasingOctant(_octant)    ((_octant) & YDECREASING)

static int miZeroClipLine (int /*xmin */ ,
                           int /*ymin */ ,
                           int /*xmax */ ,
                           int /*ymax */ ,
                           int * /*new_x1 */ ,
                           int * /*new_y1 */ ,
                           int * /*new_x2 */ ,
                           int * /*new_y2 */ ,
                           unsigned int /*adx */ ,
                           unsigned int /*ady */ ,
                           int * /*pt1_clipped */ ,
                           int * /*pt2_clipped */ ,
                           int /*octant */ ,
                           unsigned int /*bias */ ,
                           int /*oc1 */ ,
                           int  /*oc2 */
    );

/*
 * interface data to span-merging polygon filler
 */

typedef struct _SpanData {
    SpanGroup fgGroup, bgGroup;
} SpanDataRec, *SpanDataPtr;

#define AppendSpanGroup(pGC, foreground, spanPtr, spanData) { \
        SpanGroup   *group, *othergroup = NULL; \
        if (foreground) \
        { \
            group = &spanData->fgGroup; \
            if (pGC->lineStyle == LineDoubleDash) \
                othergroup = &spanData->bgGroup; \
        } \
        else \
        { \
            group = &spanData->bgGroup; \
            othergroup = &spanData->fgGroup; \
        } \
        miAppendSpans (group, othergroup, spanPtr); \
}

/*
 * Polygon edge description for integer wide-line routines
 */

typedef struct _PolyEdge {
    int height;                 /* number of scanlines to process */
    int x;                      /* starting x coordinate */
    int stepx;                  /* fixed integral dx */
    int signdx;                 /* variable dx sign */
    int e;                      /* initial error term */
    int dy;
    int dx;
} PolyEdgeRec, *PolyEdgePtr;

#define SQSECANT 108.856472512142       /* 1/sin^2(11/2) - miter limit constant */

/*
 * types for general polygon routines
 */

typedef struct _PolyVertex {
    double x, y;
} PolyVertexRec, *PolyVertexPtr;

typedef struct _PolySlope {
    int dx, dy;
    double k;                   /* x0 * dy - y0 * dx */
} PolySlopeRec, *PolySlopePtr;

/*
 * Line face description for caps/joins
 */

typedef struct _LineFace {
    double xa, ya;
    int dx, dy;
    int x, y;
    double k;
} LineFaceRec, *LineFacePtr;

/*
 * macros for polygon fillers
 */

#define MIPOLYRELOADLEFT    if (!left_height && left_count) { \
                                left_height = left->height; \
                                left_x = left->x; \
                                left_stepx = left->stepx; \
                                left_signdx = left->signdx; \
                                left_e = left->e; \
                                left_dy = left->dy; \
                                left_dx = left->dx; \
                                --left_count; \
                                ++left; \
                            }

#define MIPOLYRELOADRIGHT   if (!right_height && right_count) { \
                                right_height = right->height; \
                                right_x = right->x; \
                                right_stepx = right->stepx; \
                                right_signdx = right->signdx; \
                                right_e = right->e; \
                                right_dy = right->dy; \
                                right_dx = right->dx; \
                                --right_count; \
                                ++right; \
                        }

#define MIPOLYSTEPLEFT  left_x += left_stepx; \
                        left_e += left_dx; \
                        if (left_e > 0) \
                        { \
                            left_x += left_signdx; \
                            left_e -= left_dy; \
                        }

#define MIPOLYSTEPRIGHT right_x += right_stepx; \
                        right_e += right_dx; \
                        if (right_e > 0) \
                        { \
                            right_x += right_signdx; \
                            right_e -= right_dy; \
                        }

static void miRoundJoinClip (LineFacePtr /*pLeft */ ,
                             LineFacePtr /*pRight */ ,
                             PolyEdgePtr /*edge1 */ ,
                             PolyEdgePtr /*edge2 */ ,
                             int * /*y1 */ ,
                             int * /*y2 */ ,
                             Boolean * /*left1 */ ,
                             Boolean *     /*left2 */
    );

static int miRoundCapClip (LineFacePtr /*face */ ,
                           Boolean /*isInt */ ,
                           PolyEdgePtr /*edge */ ,
                           Boolean *       /*leftEdge */
    );

static int miPolyBuildEdge (double x0, double y0, double k, int dx, int dy,
                            int xi, int yi, int left, PolyEdgePtr edge);
static int miPolyBuildPoly (PolyVertexPtr vertices, PolySlopePtr slopes,
                            int count, int xi, int yi, PolyEdgePtr left,
                            PolyEdgePtr right, int *pnleft, int *pnright, int *h);


static void
miStepDash (int dist,           /* distance to step */
            int *pDashIndex,    /* current dash */
            unsigned char *pDash,       /* dash list */
            int numInDashList,  /* total length of dash list */
            int *pDashOffset    /* offset into current dash */
    )
{
    int dashIndex, dashOffset;
    int totallen;
    int i;

    dashIndex = *pDashIndex;
    dashOffset = *pDashOffset;
    if (dist < pDash[dashIndex] - dashOffset) {
        *pDashOffset = dashOffset + dist;
        return;
    }
    dist -= pDash[dashIndex] - dashOffset;
    if (++dashIndex == numInDashList)
        dashIndex = 0;
    totallen = 0;
    for (i = 0; i < numInDashList; i++)
        totallen += pDash[i];
    if (totallen > 0 && totallen <= dist)
        dist = dist % totallen;
    while (dist >= pDash[dashIndex]) {
        dist -= pDash[dashIndex];
        if (++dashIndex == numInDashList)
            dashIndex = 0;
    }
    *pDashIndex = dashIndex;
    *pDashOffset = dist;
}

/*

These routines maintain lists of Spans, in order to implement the
``touch-each-pixel-once'' rules of wide lines and arcs.

Written by Joel McCormack, Summer 1989.

*/


static void
miInitSpanGroup (SpanGroup * spanGroup)
{
    spanGroup->size = 0;
    spanGroup->count = 0;
    spanGroup->group = NULL;
    spanGroup->ymin = MAX_COORDINATE;
    spanGroup->ymax = MIN_COORDINATE;
}                               /* InitSpanGroup */

#define YMIN(spans) (spans->points[0].y)
#define YMAX(spans)  (spans->points[spans->count-1].y)

static void
miSubtractSpans (SpanGroup * spanGroup, Spans * sub)
{
    int i, subCount, spansCount;
    int ymin, ymax, xmin, xmax;
    Spans *spans;
    DDXPointPtr subPt, spansPt;
    int *subWid, *spansWid;
    int extra;

    ymin = YMIN (sub);
    ymax = YMAX (sub);
    spans = spanGroup->group;
    for (i = spanGroup->count; i; i--, spans++) {
        if (YMIN (spans) <= ymax && ymin <= YMAX (spans)) {
            subCount = sub->count;
            subPt = sub->points;
            subWid = sub->widths;
            spansCount = spans->count;
            spansPt = spans->points;
            spansWid = spans->widths;
            extra = 0;
            for (;;) {
                while (spansCount && spansPt->y < subPt->y) {
                    spansPt++;
                    spansWid++;
                    spansCount--;
                }
                if (!spansCount)
                    break;
                while (subCount && subPt->y < spansPt->y) {
                    subPt++;
                    subWid++;
                    subCount--;
                }
                if (!subCount)
                    break;
                if (subPt->y == spansPt->y) {
                    xmin = subPt->x;
                    xmax = xmin + *subWid;
                    if (xmin >= spansPt->x + *spansWid || spansPt->x >= xmax) {
                        ;
                    } else if (xmin <= spansPt->x) {
                        if (xmax >= spansPt->x + *spansWid) {
                            memmove (spansPt, spansPt + 1, sizeof *spansPt * (spansCount - 1));
                            memmove (spansWid, spansWid + 1, sizeof *spansWid * (spansCount - 1));
                            spansPt--;
                            spansWid--;
                            spans->count--;
                            extra++;
                        } else {
                            *spansWid = *spansWid - (xmax - spansPt->x);
                            spansPt->x = xmax;
                        }
                    } else {
                        if (xmax >= spansPt->x + *spansWid) {
                            *spansWid = xmin - spansPt->x;
                        } else {
                            if (!extra) {
                                DDXPointPtr newPt;
                                int *newwid;

#define EXTRA 8
                                newPt = xrealloc (spans->points,
                                                  (spans->count +
                                                   EXTRA) * sizeof (DDXPointRec));
                                if (!newPt)
                                    break;
                                spansPt = newPt + (spansPt - spans->points);
                                spans->points = newPt;
                                newwid = xrealloc (spans->widths,
                                                   (spans->count + EXTRA) * sizeof (int));
                                if (!newwid)
                                    break;
                                spansWid = newwid + (spansWid - spans->widths);
                                spans->widths = newwid;
                                extra = EXTRA;
                            }
                            memmove (spansPt + 1, spansPt, sizeof *spansPt * (spansCount));
                            memmove (spansWid + 1, spansWid, sizeof *spansWid * (spansCount));
                            spans->count++;
                            extra--;
                            *spansWid = xmin - spansPt->x;
                            spansWid++;
                            spansPt++;
                            *spansWid = *spansWid - (xmax - spansPt->x);
                            spansPt->x = xmax;
                        }
                    }
                }
                spansPt++;
                spansWid++;
                spansCount--;
            }
        }
    }
}

static void
miAppendSpans (SpanGroup * spanGroup, SpanGroup * otherGroup, Spans * spans)
{
    int ymin, ymax;
    int spansCount;

    spansCount = spans->count;
    if (spansCount > 0) {
        if (spanGroup->size == spanGroup->count) {
            spanGroup->size = (spanGroup->size + 8) * 2;
            spanGroup->group =
                xrealloc (spanGroup->group, sizeof (Spans) * spanGroup->size);
        }

        spanGroup->group[spanGroup->count] = *spans;
        (spanGroup->count)++;
        ymin = spans->points[0].y;
        if (ymin < spanGroup->ymin)
            spanGroup->ymin = ymin;
        ymax = spans->points[spansCount - 1].y;
        if (ymax > spanGroup->ymax)
            spanGroup->ymax = ymax;
        if (otherGroup && otherGroup->ymin < ymax && ymin < otherGroup->ymax) {
            miSubtractSpans (otherGroup, spans);
        }
    } else {
        xfree (spans->points);
        xfree (spans->widths);
    }
}                               /* AppendSpans */

static void
miFreeSpanGroup (SpanGroup * spanGroup)
{
    xfree (spanGroup->group);
}

static void
QuickSortSpansX (DDXPointRec points[], int widths[], int numSpans)
{
    int x;
    int i, j, m;
    DDXPointPtr r;

/* Always called with numSpans > 1 */
/* Sorts only by x, as all y should be the same */

#define ExchangeSpans(a, b)                                 \
{                                                           \
    DDXPointRec         tpt;                                \
    int                 tw;                                 \
                                                            \
    tpt = points[a]; points[a] = points[b]; points[b] = tpt;    \
    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \
}

    do {
        if (numSpans < 9) {
            /* Do insertion sort */
            int xprev;

            xprev = points[0].x;
            i = 1;
            do {                /* while i != numSpans */
                x = points[i].x;
                if (xprev > x) {
                    /* points[i] is out of order.  Move into proper location. */
                    DDXPointRec tpt;
                    int tw, k;

                    for (j = 0; x >= points[j].x; j++) {
                    }
                    tpt = points[i];
                    tw = widths[i];
                    for (k = i; k != j; k--) {
                        points[k] = points[k - 1];
                        widths[k] = widths[k - 1];
                    }
                    points[j] = tpt;
                    widths[j] = tw;
                    x = points[i].x;
                }               /* if out of order */
                xprev = x;
                i++;
            } while (i != numSpans);
            return;
        }

        /* Choose partition element, stick in location 0 */
        m = numSpans / 2;
        if (points[m].x > points[0].x)
            ExchangeSpans (m, 0);
        if (points[m].x > points[numSpans - 1].x)
            ExchangeSpans (m, numSpans - 1);
        if (points[m].x > points[0].x)
            ExchangeSpans (m, 0);
        x = points[0].x;

        /* Partition array */
        i = 0;
        j = numSpans;
        do {
            r = &(points[i]);
            do {
                r++;
                i++;
            } while (i != numSpans && r->x < x);
            r = &(points[j]);
            do {
                r--;
                j--;
            } while (x < r->x);
            if (i < j)
                ExchangeSpans (i, j);
        } while (i < j);

        /* Move partition element back to middle */
        ExchangeSpans (0, j);

        /* Recurse */
        if (numSpans - j - 1 > 1)
            QuickSortSpansX (&points[j + 1], &widths[j + 1], numSpans - j - 1);
        numSpans = j;
    } while (numSpans > 1);
}                               /* QuickSortSpans */


static int
UniquifySpansX (Spans * spans, DDXPointRec * newPoints, int *newWidths)
{
    int newx1, newx2, oldpt, i, y;
    DDXPointRec *oldPoints;
    int *oldWidths;
    int *startNewWidths;

/* Always called with numSpans > 1 */
/* Uniquify the spans, and stash them into newPoints and newWidths.  Return the
   number of unique spans. */


    startNewWidths = newWidths;

    oldPoints = spans->points;
    oldWidths = spans->widths;

    y = oldPoints->y;
    newx1 = oldPoints->x;
    newx2 = newx1 + *oldWidths;

    for (i = spans->count - 1; i != 0; i--) {
        oldPoints++;
        oldWidths++;
        oldpt = oldPoints->x;
        if (oldpt > newx2) {
            /* Write current span, start a new one */
            newPoints->x = newx1;
            newPoints->y = y;
            *newWidths = newx2 - newx1;
            newPoints++;
            newWidths++;
            newx1 = oldpt;
            newx2 = oldpt + *oldWidths;
        } else {
            /* extend current span, if old extends beyond new */
            oldpt = oldpt + *oldWidths;
            if (oldpt > newx2)
                newx2 = oldpt;
        }
    }                           /* for */

    /* Write final span */
    newPoints->x = newx1;
    *newWidths = newx2 - newx1;
    newPoints->y = y;

    return (newWidths - startNewWidths) + 1;
}                               /* UniquifySpansX */

static void
miDisposeSpanGroup (SpanGroup * spanGroup)
{
    int i;
    Spans *spans;

    for (i = 0; i < spanGroup->count; i++) {
        spans = spanGroup->group + i;
        xfree (spans->points);
        xfree (spans->widths);
    }
}

static void
miFillUniqueSpanGroup (GCPtr pGC, SpanGroup * spanGroup, Boolean foreground)
{
    int i;
    Spans *spans;
    Spans *yspans;
    int *ysizes;
    int ymin, ylength;

    /* Outgoing spans for one big call to FillSpans */
    DDXPointPtr points;
    int *widths;
    int count;

    if (spanGroup->count == 0)
        return;

    if (spanGroup->count == 1) {
        /* Already should be sorted, unique */
        spans = spanGroup->group;
        (*pGC->ops->FillSpans)
            (pGC, spans->count, spans->points, spans->widths, TRUE, foreground);
        xfree (spans->points);
        xfree (spans->widths);
    } else {
        /* Yuck.  Gross.  Radix sort into y buckets, then sort x and uniquify */
        /* This seems to be the fastest thing to do.  I've tried sorting on
           both x and y at the same time rather than creating into all those
           y buckets, but it was somewhat slower. */

        ymin = spanGroup->ymin;
        ylength = spanGroup->ymax - ymin + 1;

        /* Allocate Spans for y buckets */
        yspans = (Spans*)xalloc (ylength * sizeof (Spans));
        ysizes = (int *)xalloc (ylength * sizeof (int));

        if (!yspans || !ysizes) {
            xfree (yspans);
            xfree (ysizes);
            miDisposeSpanGroup (spanGroup);
            return;
        }

        for (i = 0; i != ylength; i++) {
            ysizes[i] = 0;
            yspans[i].count = 0;
            yspans[i].points = NULL;
            yspans[i].widths = NULL;
        }

        /* Go through every single span and put it into the correct bucket */
        count = 0;
        for (i = 0, spans = spanGroup->group; i != spanGroup->count; i++, spans++) {
            int index;
            int j;

            for (j = 0, points = spans->points, widths = spans->widths;
                 j != spans->count; j++, points++, widths++) {
                index = points->y - ymin;
                if (index >= 0 && index < ylength) {
                    Spans *newspans = &(yspans[index]);
                    if (newspans->count == ysizes[index]) {
                        DDXPointPtr newpoints;
                        int *newwidths;
                        ysizes[index] = (ysizes[index] + 8) * 2;
                        newpoints = xrealloc (newspans->points,
                                              ysizes[index] * sizeof (DDXPointRec));
                        newwidths = xrealloc (newspans->widths,
                                              ysizes[index] * sizeof (int));
                        if (!newpoints || !newwidths) {
                            for (i = 0; i < ylength; i++) {
                                xfree (yspans[i].points);
                                xfree (yspans[i].widths);
                            }
                            xfree (yspans);
                            xfree (ysizes);
                            xfree (newpoints);
                            xfree (newwidths);
                            miDisposeSpanGroup (spanGroup);
                            return;
                        }
                        newspans->points = newpoints;
                        newspans->widths = newwidths;
                    }
                    newspans->points[newspans->count] = *points;
                    newspans->widths[newspans->count] = *widths;
                    (newspans->count)++;
                }               /* if y value of span in range */
            }                   /* for j through spans */
            count += spans->count;
            xfree (spans->points);
            spans->points = NULL;
            xfree (spans->widths);
            spans->widths = NULL;
        }                       /* for i thorough Spans */

        /* Now sort by x and uniquify each bucket into the final array */
        points = (DDXPointRec*)xalloc (count * sizeof (DDXPointRec));
        widths = (int *)xalloc (count * sizeof (int));
        if (!points || !widths) {
            for (i = 0; i < ylength; i++) {
                xfree (yspans[i].points);
                xfree (yspans[i].widths);
            }
            xfree (yspans);
            xfree (ysizes);
            xfree (points);
            xfree (widths);
            return;
        }
        count = 0;
        for (i = 0; i != ylength; i++) {
            int ycount = yspans[i].count;
            if (ycount > 0) {
                if (ycount > 1) {
                    QuickSortSpansX (yspans[i].points, yspans[i].widths, ycount);
                    count += UniquifySpansX (&(yspans[i]), &(points[count]), &(widths[count]));
                } else {
                    points[count] = yspans[i].points[0];
                    widths[count] = yspans[i].widths[0];
                    count++;
                }
                xfree (yspans[i].points);
                xfree (yspans[i].widths);
            }
        }

        (*pGC->ops->FillSpans) (pGC, count, points, widths, TRUE, foreground);
        xfree (points);
        xfree (widths);
        xfree (yspans);
        xfree (ysizes);         /* use (DE)xalloc for these? */
    }

    spanGroup->count = 0;
    spanGroup->ymin = MAX_COORDINATE;
    spanGroup->ymax = MIN_COORDINATE;
}

/*

The bresenham error equation used in the mi/mfb/cfb line routines is:

        e = error
        dx = difference in raw X coordinates
        dy = difference in raw Y coordinates
        M = # of steps in X direction
        N = # of steps in Y direction
        B = 0 to prefer diagonal steps in a given octant,
            1 to prefer axial steps in a given octant

        For X major lines:
                e = 2Mdy - 2Ndx - dx - B
                -2dx <= e < 0

        For Y major lines:
                e = 2Ndx - 2Mdy - dy - B
                -2dy <= e < 0

At the start of the line, we have taken 0 X steps and 0 Y steps,
so M = 0 and N = 0:

        X major         e = 2Mdy - 2Ndx - dx - B
                  = -dx - B

        Y major         e = 2Ndx - 2Mdy - dy - B
                  = -dy - B

At the end of the line, we have taken dx X steps and dy Y steps,
so M = dx and N = dy:

        X major         e = 2Mdy - 2Ndx - dx - B
                  = 2dxdy - 2dydx - dx - B
                  = -dx - B
        Y major e = 2Ndx - 2Mdy - dy - B
                  = 2dydx - 2dxdy - dy - B
                  = -dy - B

Thus, the error term is the same at the start and end of the line.

Let us consider clipping an X coordinate.  There are 4 cases which
represent the two independent cases of clipping the start vs. the
end of the line and an X major vs. a Y major line.  In any of these
cases, we know the number of X steps (M) and we wish to find the
number of Y steps (N).  Thus, we will solve our error term equation.
If we are clipping the start of the line, we will find the smallest
N that satisfies our error term inequality.  If we are clipping the
end of the line, we will find the largest number of Y steps that
satisfies the inequality.  In that case, since we are representing
the Y steps as (dy - N), we will actually want to solve for the
smallest N in that equation.

Case 1:  X major, starting X coordinate moved by M steps

                -2dx <= 2Mdy - 2Ndx - dx - B < 0
        2Ndx <= 2Mdy - dx - B + 2dx     2Ndx > 2Mdy - dx - B
        2Ndx <= 2Mdy + dx - B           N > (2Mdy - dx - B) / 2dx
        N <= (2Mdy + dx - B) / 2dx

Since we are trying to find the smallest N that satisfies these
equations, we should use the > inequality to find the smallest:

        N = floor((2Mdy - dx - B) / 2dx) + 1
          = floor((2Mdy - dx - B + 2dx) / 2dx)
          = floor((2Mdy + dx - B) / 2dx)

Case 1b: X major, ending X coordinate moved to M steps

Same derivations as Case 1, but we want the largest N that satisfies
the equations, so we use the <= inequality:

        N = floor((2Mdy + dx - B) / 2dx)

Case 2: X major, ending X coordinate moved by M steps

                -2dx <= 2(dx - M)dy - 2(dy - N)dx - dx - B < 0
                -2dx <= 2dxdy - 2Mdy - 2dxdy + 2Ndx - dx - B < 0
                -2dx <= 2Ndx - 2Mdy - dx - B < 0
        2Ndx >= 2Mdy + dx + B - 2dx     2Ndx < 2Mdy + dx + B
        2Ndx >= 2Mdy - dx + B           N < (2Mdy + dx + B) / 2dx
        N >= (2Mdy - dx + B) / 2dx

Since we are trying to find the highest number of Y steps that
satisfies these equations, we need to find the smallest N, so
we should use the >= inequality to find the smallest:

        N = ceiling((2Mdy - dx + B) / 2dx)
          = floor((2Mdy - dx + B + 2dx - 1) / 2dx)
          = floor((2Mdy + dx + B - 1) / 2dx)

Case 2b: X major, starting X coordinate moved to M steps from end

Same derivations as Case 2, but we want the smallest number of Y
steps, so we want the highest N, so we use the < inequality:

        N = ceiling((2Mdy + dx + B) / 2dx) - 1
          = floor((2Mdy + dx + B + 2dx - 1) / 2dx) - 1
          = floor((2Mdy + dx + B + 2dx - 1 - 2dx) / 2dx)
          = floor((2Mdy + dx + B - 1) / 2dx)

Case 3: Y major, starting X coordinate moved by M steps

                -2dy <= 2Ndx - 2Mdy - dy - B < 0
        2Ndx >= 2Mdy + dy + B - 2dy     2Ndx < 2Mdy + dy + B
        2Ndx >= 2Mdy - dy + B           N < (2Mdy + dy + B) / 2dx
        N >= (2Mdy - dy + B) / 2dx

Since we are trying to find the smallest N that satisfies these
equations, we should use the >= inequality to find the smallest:

        N = ceiling((2Mdy - dy + B) / 2dx)
          = floor((2Mdy - dy + B + 2dx - 1) / 2dx)
          = floor((2Mdy - dy + B - 1) / 2dx) + 1

Case 3b: Y major, ending X coordinate moved to M steps

Same derivations as Case 3, but we want the largest N that satisfies
the equations, so we use the < inequality:

        N = ceiling((2Mdy + dy + B) / 2dx) - 1
          = floor((2Mdy + dy + B + 2dx - 1) / 2dx) - 1
          = floor((2Mdy + dy + B + 2dx - 1 - 2dx) / 2dx)
          = floor((2Mdy + dy + B - 1) / 2dx)

Case 4: Y major, ending X coordinate moved by M steps

                -2dy <= 2(dy - N)dx - 2(dx - M)dy - dy - B < 0
                -2dy <= 2dxdy - 2Ndx - 2dxdy + 2Mdy - dy - B < 0
                -2dy <= 2Mdy - 2Ndx - dy - B < 0
        2Ndx <= 2Mdy - dy - B + 2dy     2Ndx > 2Mdy - dy - B
        2Ndx <= 2Mdy + dy - B           N > (2Mdy - dy - B) / 2dx
        N <= (2Mdy + dy - B) / 2dx

Since we are trying to find the highest number of Y steps that
satisfies these equations, we need to find the smallest N, so
we should use the > inequality to find the smallest:

        N = floor((2Mdy - dy - B) / 2dx) + 1

Case 4b: Y major, starting X coordinate moved to M steps from end

Same analysis as Case 4, but we want the smallest number of Y steps
which means the largest N, so we use the <= inequality:

        N = floor((2Mdy + dy - B) / 2dx)

Now let's try the Y coordinates, we have the same 4 cases.

Case 5: X major, starting Y coordinate moved by N steps

                -2dx <= 2Mdy - 2Ndx - dx - B < 0
        2Mdy >= 2Ndx + dx + B - 2dx     2Mdy < 2Ndx + dx + B
        2Mdy >= 2Ndx - dx + B           M < (2Ndx + dx + B) / 2dy
        M >= (2Ndx - dx + B) / 2dy

Since we are trying to find the smallest M, we use the >= inequality:

        M = ceiling((2Ndx - dx + B) / 2dy)
          = floor((2Ndx - dx + B + 2dy - 1) / 2dy)
          = floor((2Ndx - dx + B - 1) / 2dy) + 1

Case 5b: X major, ending Y coordinate moved to N steps

Same derivations as Case 5, but we want the largest M that satisfies
the equations, so we use the < inequality:

        M = ceiling((2Ndx + dx + B) / 2dy) - 1
          = floor((2Ndx + dx + B + 2dy - 1) / 2dy) - 1
          = floor((2Ndx + dx + B + 2dy - 1 - 2dy) / 2dy)
          = floor((2Ndx + dx + B - 1) / 2dy)

Case 6: X major, ending Y coordinate moved by N steps

                -2dx <= 2(dx - M)dy - 2(dy - N)dx - dx - B < 0
                -2dx <= 2dxdy - 2Mdy - 2dxdy + 2Ndx - dx - B < 0
                -2dx <= 2Ndx - 2Mdy - dx - B < 0
        2Mdy <= 2Ndx - dx - B + 2dx     2Mdy > 2Ndx - dx - B
        2Mdy <= 2Ndx + dx - B           M > (2Ndx - dx - B) / 2dy
        M <= (2Ndx + dx - B) / 2dy

Largest # of X steps means smallest M, so use the > inequality:

        M = floor((2Ndx - dx - B) / 2dy) + 1

Case 6b: X major, starting Y coordinate moved to N steps from end

Same derivations as Case 6, but we want the smallest # of X steps
which means the largest M, so use the <= inequality:

        M = floor((2Ndx + dx - B) / 2dy)

Case 7: Y major, starting Y coordinate moved by N steps

                -2dy <= 2Ndx - 2Mdy - dy - B < 0
        2Mdy <= 2Ndx - dy - B + 2dy     2Mdy > 2Ndx - dy - B
        2Mdy <= 2Ndx + dy - B           M > (2Ndx - dy - B) / 2dy
        M <= (2Ndx + dy - B) / 2dy

To find the smallest M, use the > inequality:

        M = floor((2Ndx - dy - B) / 2dy) + 1
          = floor((2Ndx - dy - B + 2dy) / 2dy)
          = floor((2Ndx + dy - B) / 2dy)

Case 7b: Y major, ending Y coordinate moved to N steps

Same derivations as Case 7, but we want the largest M that satisfies
the equations, so use the <= inequality:

        M = floor((2Ndx + dy - B) / 2dy)

Case 8: Y major, ending Y coordinate moved by N steps

                -2dy <= 2(dy - N)dx - 2(dx - M)dy - dy - B < 0
                -2dy <= 2dxdy - 2Ndx - 2dxdy + 2Mdy - dy - B < 0
                -2dy <= 2Mdy - 2Ndx - dy - B < 0
        2Mdy >= 2Ndx + dy + B - 2dy     2Mdy < 2Ndx + dy + B
        2Mdy >= 2Ndx - dy + B           M < (2Ndx + dy + B) / 2dy
        M >= (2Ndx - dy + B) / 2dy

To find the highest X steps, find the smallest M, use the >= inequality:

        M = ceiling((2Ndx - dy + B) / 2dy)
          = floor((2Ndx - dy + B + 2dy - 1) / 2dy)
          = floor((2Ndx + dy + B - 1) / 2dy)

Case 8b: Y major, starting Y coordinate moved to N steps from the end

Same derivations as Case 8, but we want to find the smallest # of X
steps which means the largest M, so we use the < inequality:

        M = ceiling((2Ndx + dy + B) / 2dy) - 1
          = floor((2Ndx + dy + B + 2dy - 1) / 2dy) - 1
          = floor((2Ndx + dy + B + 2dy - 1 - 2dy) / 2dy)
          = floor((2Ndx + dy + B - 1) / 2dy)

So, our equations are:

        1:  X major move x1 to x1+M     floor((2Mdy + dx - B) / 2dx)
        1b: X major move x2 to x1+M     floor((2Mdy + dx - B) / 2dx)
        2:  X major move x2 to x2-M     floor((2Mdy + dx + B - 1) / 2dx)
        2b: X major move x1 to x2-M     floor((2Mdy + dx + B - 1) / 2dx)

        3:  Y major move x1 to x1+M     floor((2Mdy - dy + B - 1) / 2dx) + 1
        3b: Y major move x2 to x1+M     floor((2Mdy + dy + B - 1) / 2dx)
        4:  Y major move x2 to x2-M     floor((2Mdy - dy - B) / 2dx) + 1
        4b: Y major move x1 to x2-M     floor((2Mdy + dy - B) / 2dx)

        5:  X major move y1 to y1+N     floor((2Ndx - dx + B - 1) / 2dy) + 1
        5b: X major move y2 to y1+N     floor((2Ndx + dx + B - 1) / 2dy)
        6:  X major move y2 to y2-N     floor((2Ndx - dx - B) / 2dy) + 1
        6b: X major move y1 to y2-N     floor((2Ndx + dx - B) / 2dy)

        7:  Y major move y1 to y1+N     floor((2Ndx + dy - B) / 2dy)
        7b: Y major move y2 to y1+N     floor((2Ndx + dy - B) / 2dy)
        8:  Y major move y2 to y2-N     floor((2Ndx + dy + B - 1) / 2dy)
        8b: Y major move y1 to y2-N     floor((2Ndx + dy + B - 1) / 2dy)

We have the following constraints on all of the above terms:

        0 < M,N <= 2^15          2^15 can be imposed by miZeroClipLine
        0 <= dx/dy <= 2^16 - 1
        0 <= B <= 1

The floor in all of the above equations can be accomplished with a
simple C divide operation provided that both numerator and denominator
are positive.

Since dx,dy >= 0 and since moving an X coordinate implies that dx != 0
and moving a Y coordinate implies dy != 0, we know that the denominators
are all > 0.

For all lines, (-B) and (B-1) are both either 0 or -1, depending on the
bias.  Thus, we have to show that the 2MNdxy +/- dxy terms are all >= 1
or > 0 to prove that the numerators are positive (or zero).

For X Major lines we know that dx > 0 and since 2Mdy is >= 0 due to the
constraints, the first four equations all have numerators >= 0.

For the second four equations, M > 0, so 2Mdy >= 2dy so (2Mdy - dy) >= dy
So (2Mdy - dy) > 0, since they are Y major lines.  Also, (2Mdy + dy) >= 3dy
or (2Mdy + dy) > 0.  So all of their numerators are >= 0.

For the third set of four equations, N > 0, so 2Ndx >= 2dx so (2Ndx - dx)
>= dx > 0.  Similarly (2Ndx + dx) >= 3dx > 0.  So all numerators >= 0.

For the fourth set of equations, dy > 0 and 2Ndx >= 0, so all numerators
are > 0.

To consider overflow, consider the case of 2 * M,N * dx,dy + dx,dy.  This
is bounded <= 2 * 2^15 * (2^16 - 1) + (2^16 - 1)
           <= 2^16 * (2^16 - 1) + (2^16 - 1)
           <= 2^32 - 2^16 + 2^16 - 1
           <= 2^32 - 1
Since the (-B) and (B-1) terms are all 0 or -1, the maximum value of
the numerator is therefore (2^32 - 1), which does not overflow an unsigned
32 bit variable.

*/

/* Bit codes for the terms of the 16 clipping equations defined below. */

#define T_2NDX          (1 << 0)
#define T_2MDY          (0)     /* implicit term */
#define T_DXNOTY        (1 << 1)
#define T_DYNOTX        (0)     /* implicit term */
#define T_SUBDXORY      (1 << 2)
#define T_ADDDX                 (T_DXNOTY)      /* composite term */
#define T_SUBDX                 (T_DXNOTY | T_SUBDXORY) /* composite term */
#define T_ADDDY                 (T_DYNOTX)      /* composite term */
#define T_SUBDY                 (T_DYNOTX | T_SUBDXORY) /* composite term */
#define T_BIASSUBONE    (1 << 3)
#define T_SUBBIAS       (0)     /* implicit term */
#define T_DIV2DX        (1 << 4)
#define T_DIV2DY        (0)     /* implicit term */
#define T_ADDONE        (1 << 5)

/* Bit masks defining the 16 equations used in miZeroClipLine. */

#define EQN1    (T_2MDY | T_ADDDX | T_SUBBIAS    | T_DIV2DX)
#define EQN1B   (T_2MDY | T_ADDDX | T_SUBBIAS    | T_DIV2DX)
#define EQN2    (T_2MDY | T_ADDDX | T_BIASSUBONE | T_DIV2DX)
#define EQN2B   (T_2MDY | T_ADDDX | T_BIASSUBONE | T_DIV2DX)

#define EQN3    (T_2MDY | T_SUBDY | T_BIASSUBONE | T_DIV2DX | T_ADDONE)
#define EQN3B   (T_2MDY | T_ADDDY | T_BIASSUBONE | T_DIV2DX)
#define EQN4    (T_2MDY | T_SUBDY | T_SUBBIAS    | T_DIV2DX | T_ADDONE)
#define EQN4B   (T_2MDY | T_ADDDY | T_SUBBIAS    | T_DIV2DX)

#define EQN5    (T_2NDX | T_SUBDX | T_BIASSUBONE | T_DIV2DY | T_ADDONE)
#define EQN5B   (T_2NDX | T_ADDDX | T_BIASSUBONE | T_DIV2DY)
#define EQN6    (T_2NDX | T_SUBDX | T_SUBBIAS    | T_DIV2DY | T_ADDONE)
#define EQN6B   (T_2NDX | T_ADDDX | T_SUBBIAS    | T_DIV2DY)

#define EQN7    (T_2NDX | T_ADDDY | T_SUBBIAS    | T_DIV2DY)
#define EQN7B   (T_2NDX | T_ADDDY | T_SUBBIAS    | T_DIV2DY)
#define EQN8    (T_2NDX | T_ADDDY | T_BIASSUBONE | T_DIV2DY)
#define EQN8B   (T_2NDX | T_ADDDY | T_BIASSUBONE | T_DIV2DY)

/* miZeroClipLine
 *
 * returns:  1 for partially clipped line
 *          -1 for completely clipped line
 *
 */
static int
miZeroClipLine (int xmin, int ymin, int xmax, int ymax,
                int *new_x1, int *new_y1, int *new_x2, int *new_y2,
                unsigned int adx, unsigned int ady,
                int *pt1_clipped, int *pt2_clipped, int octant, unsigned int bias, int oc1, int oc2)
{
    int swapped = 0;
    int clipDone = 0;
    CARD32 utmp = 0;
    int clip1, clip2;
    int x1, y1, x2, y2;
    int x1_orig, y1_orig, x2_orig, y2_orig;
    int xmajor;
    int negslope = 0, anchorval = 0;
    unsigned int eqn = 0;

    x1 = x1_orig = *new_x1;
    y1 = y1_orig = *new_y1;
    x2 = x2_orig = *new_x2;
    y2 = y2_orig = *new_y2;

    clip1 = 0;
    clip2 = 0;

    xmajor = IsXMajorOctant (octant);
    bias = ((bias >> octant) & 1);

    while (1) {
        if ((oc1 & oc2) != 0) { /* trivial reject */
            clipDone = -1;
            clip1 = oc1;
            clip2 = oc2;
            break;
        } else if ((oc1 | oc2) == 0) {  /* trivial accept */
            clipDone = 1;
            if (swapped) {
                SWAPINT_PAIR (x1, y1, x2, y2);
                SWAPINT (clip1, clip2);
            }
            break;
        } else {                /* have to clip */

            /* only clip one point at a time */
            if (oc1 == 0) {
                SWAPINT_PAIR (x1, y1, x2, y2);
                SWAPINT_PAIR (x1_orig, y1_orig, x2_orig, y2_orig);
                SWAPINT (oc1, oc2);
                SWAPINT (clip1, clip2);
                swapped = !swapped;
            }

            clip1 |= oc1;
            if (oc1 & OUT_LEFT) {
                negslope = IsYDecreasingOctant (octant);
                utmp = xmin - x1_orig;
                if (utmp <= 32767) {    /* clip based on near endpt */
                    if (xmajor)
                        eqn = (swapped) ? EQN2 : EQN1;
                    else
                        eqn = (swapped) ? EQN4 : EQN3;
                    anchorval = y1_orig;
                } else {        /* clip based on far endpt */

                    utmp = x2_orig - xmin;
                    if (xmajor)
                        eqn = (swapped) ? EQN1B : EQN2B;
                    else
                        eqn = (swapped) ? EQN3B : EQN4B;
                    anchorval = y2_orig;
                    negslope = !negslope;
                }
                x1 = xmin;
            } else if (oc1 & OUT_ABOVE) {
                negslope = IsXDecreasingOctant (octant);
                utmp = ymin - y1_orig;
                if (utmp <= 32767) {    /* clip based on near endpt */
                    if (xmajor)
                        eqn = (swapped) ? EQN6 : EQN5;
                    else
                        eqn = (swapped) ? EQN8 : EQN7;
                    anchorval = x1_orig;
                } else {        /* clip based on far endpt */

                    utmp = y2_orig - ymin;
                    if (xmajor)
                        eqn = (swapped) ? EQN5B : EQN6B;
                    else
                        eqn = (swapped) ? EQN7B : EQN8B;
                    anchorval = x2_orig;
                    negslope = !negslope;
                }
                y1 = ymin;
            } else if (oc1 & OUT_RIGHT) {
                negslope = IsYDecreasingOctant (octant);
                utmp = x1_orig - xmax;
                if (utmp <= 32767) {    /* clip based on near endpt */
                    if (xmajor)
                        eqn = (swapped) ? EQN2 : EQN1;
                    else
                        eqn = (swapped) ? EQN4 : EQN3;
                    anchorval = y1_orig;
                } else {        /* clip based on far endpt */

                    /*
                     * Technically since the equations can handle
                     * utmp == 32768, this overflow code isn't
                     * needed since X11 protocol can't generate
                     * a line which goes more than 32768 pixels
                     * to the right of a clip rectangle.
                     */
                    utmp = xmax - x2_orig;
                    if (xmajor)
                        eqn = (swapped) ? EQN1B : EQN2B;
                    else
                        eqn = (swapped) ? EQN3B : EQN4B;
                    anchorval = y2_orig;
                    negslope = !negslope;
                }
                x1 = xmax;
            } else if (oc1 & OUT_BELOW) {
                negslope = IsXDecreasingOctant (octant);
                utmp = y1_orig - ymax;
                if (utmp <= 32767) {    /* clip based on near endpt */
                    if (xmajor)
                        eqn = (swapped) ? EQN6 : EQN5;
                    else
                        eqn = (swapped) ? EQN8 : EQN7;
                    anchorval = x1_orig;
                } else {        /* clip based on far endpt */

                    /*
                     * Technically since the equations can handle
                     * utmp == 32768, this overflow code isn't
                     * needed since X11 protocol can't generate
                     * a line which goes more than 32768 pixels
                     * below the bottom of a clip rectangle.
                     */
                    utmp = ymax - y2_orig;
                    if (xmajor)
                        eqn = (swapped) ? EQN5B : EQN6B;
                    else
                        eqn = (swapped) ? EQN7B : EQN8B;
                    anchorval = x2_orig;
                    negslope = !negslope;
                }
                y1 = ymax;
            }

            if (swapped)
                negslope = !negslope;

            utmp <<= 1;         /* utmp = 2N or 2M */
            if (eqn & T_2NDX)
                utmp = (utmp * adx);
            else                /* (eqn & T_2MDY) */
                utmp = (utmp * ady);
            if (eqn & T_DXNOTY)
                if (eqn & T_SUBDXORY)
                    utmp -= adx;
                else
                    utmp += adx;
            else /* (eqn & T_DYNOTX) */ if (eqn & T_SUBDXORY)
                utmp -= ady;
            else
                utmp += ady;
            if (eqn & T_BIASSUBONE)
                utmp += bias - 1;
            else                /* (eqn & T_SUBBIAS) */
                utmp -= bias;
            if (eqn & T_DIV2DX)
                utmp /= (adx << 1);
            else                /* (eqn & T_DIV2DY) */
                utmp /= (ady << 1);
            if (eqn & T_ADDONE)
                utmp++;

            if (negslope)
                utmp = (uint32_t)(-(int32_t)utmp);

            if (eqn & T_2NDX)   /* We are calculating X steps */
                x1 = anchorval + utmp;
            else                /* else, Y steps */
                y1 = anchorval + utmp;

            oc1 = 0;
            MIOUTCODES (oc1, x1, y1, xmin, ymin, xmax, ymax);
        }
    }

    *new_x1 = x1;
    *new_y1 = y1;
    *new_x2 = x2;
    *new_y2 = y2;

    *pt1_clipped = clip1;
    *pt2_clipped = clip2;

    return clipDone;
}

/* Draw lineSolid, fillStyle-independent zero width lines.
 *
 * Must keep X and Y coordinates in "ints" at least until after they're
 * translated and clipped to accomodate CoordModePrevious lines with very
 * large coordinates.
 *
 * Draws the same pixels regardless of sign(dx) or sign(dy).
 *
 * Ken Whaley
 *
 */

#define MI_OUTPUT_POINT(xx, yy)\
{\
    if ( !new_span && yy == current_y)\
    {\
        if (xx < spans->x)\
            spans->x = xx;\
        ++*widths;\
    }\
    else\
    {\
        ++Nspans;\
        ++spans;\
        ++widths;\
        spans->x = xx;\
        spans->y = yy;\
        *widths = 1;\
        current_y = yy;\
        new_span = FALSE;\
    }\
}

void
miZeroLine (GCPtr pGC, int mode,        /* Origin or Previous */
            int npt,            /* number of points */
            DDXPointPtr pptInit)
{
    int Nspans, current_y = 0;
    DDXPointPtr ppt;
    DDXPointPtr pspanInit, spans;
    int *pwidthInit, *widths, list_len;
    int xleft, ytop, xright, ybottom;
    int new_x1, new_y1, new_x2, new_y2;
    int x = 0, y = 0, x1, y1, x2, y2, xstart, ystart;
    int oc1, oc2;
    int result;
    int pt1_clipped, pt2_clipped = 0;
    Boolean new_span;
    int signdx, signdy;
    int clipdx, clipdy;
    int width, height;
    int adx, ady;
    int octant;
    unsigned int bias = miGetZeroLineBias (screen);
    int e, e1, e2, e3;          /* Bresenham error terms */
    int length;                 /* length of lines == # of pixels on major axis */

    xleft = 0;
    ytop = 0;
    xright = pGC->width - 1;
    ybottom = pGC->height - 1;

    /* it doesn't matter whether we're in drawable or screen coordinates,
     * FillSpans simply cannot take starting coordinates outside of the
     * range of a DDXPointRec component.
     */
    if (xright > MAX_COORDINATE)
        xright = MAX_COORDINATE;
    if (ybottom > MAX_COORDINATE)
        ybottom = MAX_COORDINATE;

    /* since we're clipping to the drawable's boundaries & coordinate
     * space boundaries, we're guaranteed that the larger of width/height
     * is the longest span we'll need to output
     */
    width = xright - xleft + 1;
    height = ybottom - ytop + 1;
    list_len = (height >= width) ? height : width;
    pspanInit = (DDXPointRec *)xalloc (list_len * sizeof (DDXPointRec));
    pwidthInit = (int *)xalloc (list_len * sizeof (int));
    if (!pspanInit || !pwidthInit)
        goto out;

    Nspans = 0;
    new_span = TRUE;
    spans = pspanInit - 1;
    widths = pwidthInit - 1;
    ppt = pptInit;

    xstart = ppt->x;
    ystart = ppt->y;

    /* x2, y2, oc2 copied to x1, y1, oc1 at top of loop to simplify
     * iteration logic
     */
    x2 = xstart;
    y2 = ystart;
    oc2 = 0;
    MIOUTCODES (oc2, x2, y2, xleft, ytop, xright, ybottom);

    while (--npt > 0) {
        if (Nspans > 0)
            (*pGC->ops->FillSpans) (pGC, Nspans, pspanInit, pwidthInit, FALSE, TRUE);
        Nspans = 0;
        new_span = TRUE;
        spans = pspanInit - 1;
        widths = pwidthInit - 1;

        x1 = x2;
        y1 = y2;
        oc1 = oc2;
        ++ppt;

        x2 = ppt->x;
        y2 = ppt->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }

        oc2 = 0;
        MIOUTCODES (oc2, x2, y2, xleft, ytop, xright, ybottom);

        CalcLineDeltas (x1, y1, x2, y2, adx, ady, signdx, signdy, 1, 1, octant);

        if (adx > ady) {
            e1 = ady << 1;
            e2 = e1 - (adx << 1);
            e = e1 - adx;
            length = adx;       /* don't draw endpoint in main loop */

            FIXUP_ERROR (e, octant, bias);

            new_x1 = x1;
            new_y1 = y1;
            new_x2 = x2;
            new_y2 = y2;
            pt1_clipped = 0;
            pt2_clipped = 0;

            if ((oc1 | oc2) != 0) {
                result = miZeroClipLine (xleft, ytop, xright, ybottom,
                                         &new_x1, &new_y1, &new_x2, &new_y2,
                                         adx, ady,
                                         &pt1_clipped, &pt2_clipped, octant, bias, oc1, oc2);
                if (result == -1)
                    continue;

                length = abs (new_x2 - new_x1);

                /* if we've clipped the endpoint, always draw the full length
                 * of the segment, because then the capstyle doesn't matter
                 */
                if (pt2_clipped)
                    length++;

                if (pt1_clipped) {
                    /* must calculate new error terms */
                    clipdx = abs (new_x1 - x1);
                    clipdy = abs (new_y1 - y1);
                    e += (clipdy * e2) + ((clipdx - clipdy) * e1);
                }
            }

            /* draw the segment */

            x = new_x1;
            y = new_y1;

            e3 = e2 - e1;
            e = e - e1;

            while (length--) {
                MI_OUTPUT_POINT (x, y);
                e += e1;
                if (e >= 0) {
                    y += signdy;
                    e += e3;
                }
                x += signdx;
            }
        } else {                /* Y major line */

            e1 = adx << 1;
            e2 = e1 - (ady << 1);
            e = e1 - ady;
            length = ady;       /* don't draw endpoint in main loop */

            SetYMajorOctant (octant);
            FIXUP_ERROR (e, octant, bias);

            new_x1 = x1;
            new_y1 = y1;
            new_x2 = x2;
            new_y2 = y2;
            pt1_clipped = 0;
            pt2_clipped = 0;

            if ((oc1 | oc2) != 0) {
                result = miZeroClipLine (xleft, ytop, xright, ybottom,
                                         &new_x1, &new_y1, &new_x2, &new_y2,
                                         adx, ady,
                                         &pt1_clipped, &pt2_clipped, octant, bias, oc1, oc2);
                if (result == -1)
                    continue;

                length = abs (new_y2 - new_y1);

                /* if we've clipped the endpoint, always draw the full length
                 * of the segment, because then the capstyle doesn't matter
                 */
                if (pt2_clipped)
                    length++;

                if (pt1_clipped) {
                    /* must calculate new error terms */
                    clipdx = abs (new_x1 - x1);
                    clipdy = abs (new_y1 - y1);
                    e += (clipdx * e2) + ((clipdy - clipdx) * e1);
                }
            }

            /* draw the segment */

            x = new_x1;
            y = new_y1;

            e3 = e2 - e1;
            e = e - e1;

            while (length--) {
                MI_OUTPUT_POINT (x, y);
                e += e1;
                if (e >= 0) {
                    x += signdx;
                    e += e3;
                }
                y += signdy;
            }
        }
    }

    /* only do the capnotlast check on the last segment
     * and only if the endpoint wasn't clipped.  And then, if the last
     * point is the same as the first point, do not draw it, unless the
     * line is degenerate
     */
    if ((!pt2_clipped) && (pGC->capStyle != CapNotLast) &&
        (((xstart != x2) || (ystart != y2)) || (ppt == pptInit + 1))) {
        MI_OUTPUT_POINT (x, y);
    }

    if (Nspans > 0)
        (*pGC->ops->FillSpans) (pGC, Nspans, pspanInit, pwidthInit, FALSE, TRUE);

out:
    xfree (pwidthInit);
    xfree (pspanInit);
}

void
miZeroDashLine (GCPtr pgc, int mode, int nptInit,       /* number of points in polyline */
                DDXPointRec * pptInit   /* points in the polyline */
    )
{
    /* XXX kludge until real zero-width dash code is written */
    pgc->lineWidth = 1;
    miWideDash (pgc, mode, nptInit, pptInit);
    pgc->lineWidth = 0;
}

static void miLineArc (GCPtr pGC,
                       Boolean foreground, SpanDataPtr spanData,
                       LineFacePtr leftFace,
                       LineFacePtr rightFace, double xorg, double yorg, Boolean isInt);


/*
 * spans-based polygon filler
 */

static void
miFillPolyHelper (GCPtr pGC, Boolean foreground,
                  SpanDataPtr spanData, int y, int overall_height,
                  PolyEdgePtr left, PolyEdgePtr right, int left_count, int right_count)
{
    int left_x = 0, left_e = 0;
    int left_stepx = 0;
    int left_signdx = 0;
    int left_dy = 0, left_dx = 0;

    int right_x = 0, right_e = 0;
    int right_stepx = 0;
    int right_signdx = 0;
    int right_dy = 0, right_dx = 0;

    int height = 0;
    int left_height = 0, right_height = 0;

    DDXPointPtr ppt;
    DDXPointPtr pptInit = NULL;
    int *pwidth;
    int *pwidthInit = NULL;
    int xorg;
    Spans spanRec;

    left_height = 0;
    right_height = 0;

    if (!spanData) {
        pptInit = (DDXPointRec *)xalloc (overall_height * sizeof (*ppt));
        if (!pptInit)
            return;
        pwidthInit = (int *)xalloc (overall_height * sizeof (*pwidth));
        if (!pwidthInit) {
            xfree (pptInit);
            return;
        }
        ppt = pptInit;
        pwidth = pwidthInit;
    } else {
        spanRec.points = (DDXPointRec *)xalloc (overall_height * sizeof (*ppt));
        if (!spanRec.points)
            return;
        spanRec.widths = (int *)xalloc (overall_height * sizeof (int));
        if (!spanRec.widths) {
            xfree (spanRec.points);
            return;
        }
        ppt = spanRec.points;
        pwidth = spanRec.widths;
    }

    xorg = 0;
    while ((left_count || left_height) && (right_count || right_height)) {
        MIPOLYRELOADLEFT MIPOLYRELOADRIGHT height = left_height;
        if (height > right_height)
            height = right_height;

        left_height -= height;
        right_height -= height;

        while (--height >= 0) {
            if (right_x >= left_x) {
                ppt->y = y;
                ppt->x = left_x + xorg;
                ppt++;
                *pwidth++ = right_x - left_x + 1;
            }
            y++;

        MIPOLYSTEPLEFT MIPOLYSTEPRIGHT}
    }
    if (!spanData) {
        (*pGC->ops->FillSpans) (pGC, ppt - pptInit, pptInit, pwidthInit, TRUE, foreground);
        xfree (pwidthInit);
        xfree (pptInit);
    } else {
        spanRec.count = ppt - spanRec.points;
        AppendSpanGroup (pGC, foreground, &spanRec, spanData)
    }
}

static void
miFillRectPolyHelper (GCPtr pGC, Boolean foreground, SpanDataPtr spanData, int x, int y, int w, int h)
{
    DDXPointPtr ppt;
    int *pwidth;
    Spans spanRec;
    xRectangle rect;

    if (!spanData) {
        rect.x = x;
        rect.y = y;
        rect.width = w;
        rect.height = h;
        (*pGC->ops->FillRects) (pGC, 1, &rect, foreground);
    } else {
        spanRec.points = (DDXPointRec *)xalloc (h * sizeof (*ppt));
        if (!spanRec.points)
            return;
        spanRec.widths = (int *)xalloc (h * sizeof (int));
        if (!spanRec.widths) {
            xfree (spanRec.points);
            return;
        }
        ppt = spanRec.points;
        pwidth = spanRec.widths;

        while (h--) {
            ppt->x = x;
            ppt->y = y;
            ppt++;
            *pwidth++ = w;
            y++;
        }
        spanRec.count = ppt - spanRec.points;
        AppendSpanGroup (pGC, foreground, &spanRec, spanData)
    }
}

static int
miPolyBuildEdge (SPICE_GNUC_UNUSED double x0, double y0, double k, /* x0 * dy - y0 * dx */
                 int dx, int dy, int xi, int yi, int left, PolyEdgePtr edge)
{
    int x, y, e;
    int xady;

    if (dy < 0) {
        dy = -dy;
        dx = -dx;
        k = -k;
    }
    y = ICEIL (y0);
    xady = ICEIL (k) + y * dx;

    if (xady <= 0)
        x = -(-xady / dy) - 1;
    else
        x = (xady - 1) / dy;

    e = xady - x * dy;

    if (dx >= 0) {
        edge->signdx = 1;
        edge->stepx = dx / dy;
        edge->dx = dx % dy;
    } else {
        edge->signdx = -1;
        edge->stepx = -(-dx / dy);
        edge->dx = -dx % dy;
        e = dy - e + 1;
    }
    edge->dy = dy;
    edge->x = x + left + xi;
    edge->e = e - dy;           /* bias to compare against 0 instead of dy */
    return y + yi;
}

#define StepAround(v, incr, max) (((v) + (incr) < 0) ? (max - 1) : ((v) + (incr) == max) ? 0 : ((v) + (incr)))

static int
miPolyBuildPoly (PolyVertexPtr vertices,
                 PolySlopePtr slopes,
                 int count,
                 int xi,
                 int yi, PolyEdgePtr left, PolyEdgePtr right, int *pnleft, int *pnright, int *h)
{
    int top, bottom;
    double miny, maxy;
    int i;
    int j;
    int clockwise;
    int slopeoff;
    int s;
    int nright, nleft;
    int y, lasty = 0, bottomy, topy = 0;

    /* find the top of the polygon */
    maxy = miny = vertices[0].y;
    bottom = top = 0;
    for (i = 1; i < count; i++) {
        if (vertices[i].y < miny) {
            top = i;
            miny = vertices[i].y;
        }
        if (vertices[i].y >= maxy) {
            bottom = i;
            maxy = vertices[i].y;
        }
    }
    clockwise = 1;
    slopeoff = 0;

    i = top;
    j = StepAround (top, -1, count);

    if (slopes[j].dy * slopes[i].dx > slopes[i].dy * slopes[j].dx) {
        clockwise = -1;
        slopeoff = -1;
    }

    bottomy = ICEIL (maxy) + yi;

    nright = 0;

    s = StepAround (top, slopeoff, count);
    i = top;
    while (i != bottom) {
        if (slopes[s].dy != 0) {
            y = miPolyBuildEdge (vertices[i].x, vertices[i].y,
                                 slopes[s].k,
                                 slopes[s].dx, slopes[s].dy, xi, yi, 0, &right[nright]);
            if (nright != 0)
                right[nright - 1].height = y - lasty;
            else
                topy = y;
            nright++;
            lasty = y;
        }

        i = StepAround (i, clockwise, count);
        s = StepAround (s, clockwise, count);
    }
    if (nright != 0)
        right[nright - 1].height = bottomy - lasty;

    if (slopeoff == 0)
        slopeoff = -1;
    else
        slopeoff = 0;

    nleft = 0;
    s = StepAround (top, slopeoff, count);
    i = top;
    while (i != bottom) {
        if (slopes[s].dy != 0) {
            y = miPolyBuildEdge (vertices[i].x, vertices[i].y,
                                 slopes[s].k, slopes[s].dx, slopes[s].dy, xi, yi, 1, &left[nleft]);

            if (nleft != 0)
                left[nleft - 1].height = y - lasty;
            nleft++;
            lasty = y;
        }
        i = StepAround (i, -clockwise, count);
        s = StepAround (s, -clockwise, count);
    }
    if (nleft != 0)
        left[nleft - 1].height = bottomy - lasty;
    *pnleft = nleft;
    *pnright = nright;
    *h = bottomy - topy;
    return topy;
}

static void
miLineOnePoint (GCPtr pGC,
                Boolean foreground,
                SPICE_GNUC_UNUSED SpanDataPtr spanData,
                int x,
                int y)
{
    DDXPointRec pt;
    int wid;

    wid = 1;
    pt.x = x;
    pt.y = y;
    (*pGC->ops->FillSpans) (pGC, 1, &pt, &wid, TRUE, foreground);
}

static void
miLineJoin (GCPtr pGC, Boolean foreground, SpanDataPtr spanData, LineFacePtr pLeft, LineFacePtr pRight)
{
    double mx = 0, my = 0;
    double denom = 0.0;
    PolyVertexRec vertices[4];
    PolySlopeRec slopes[4];
    int edgecount;
    PolyEdgeRec left[4], right[4];
    int nleft, nright;
    int y, height;
    int swapslopes;
    int joinStyle = pGC->joinStyle;
    int lw = pGC->lineWidth;

    if (lw == 1 && !spanData) {
        /* See if one of the lines will draw the joining pixel */
        if (pLeft->dx > 0 || (pLeft->dx == 0 && pLeft->dy > 0))
            return;
        if (pRight->dx > 0 || (pRight->dx == 0 && pRight->dy > 0))
            return;
        if (joinStyle != JoinRound) {
            denom = -pLeft->dx * (double) pRight->dy + pRight->dx * (double) pLeft->dy;
            if (denom == 0)
                return;         /* no join to draw */
        }
        if (joinStyle != JoinMiter) {
            miLineOnePoint (pGC, foreground, spanData, pLeft->x, pLeft->y);
            return;
        }
    } else {
        if (joinStyle == JoinRound) {
            miLineArc (pGC, foreground, spanData, pLeft, pRight, (double) 0.0, (double) 0.0, TRUE);
            return;
        }
        denom = -pLeft->dx * (double) pRight->dy + pRight->dx * (double) pLeft->dy;
        if (denom == 0.0)
            return;             /* no join to draw */
    }

    swapslopes = 0;
    if (denom > 0) {
        pLeft->xa = -pLeft->xa;
        pLeft->ya = -pLeft->ya;
        pLeft->dx = -pLeft->dx;
        pLeft->dy = -pLeft->dy;
    } else {
        swapslopes = 1;
        pRight->xa = -pRight->xa;
        pRight->ya = -pRight->ya;
        pRight->dx = -pRight->dx;
        pRight->dy = -pRight->dy;
    }

    vertices[0].x = pRight->xa;
    vertices[0].y = pRight->ya;
    slopes[0].dx = -pRight->dy;
    slopes[0].dy = pRight->dx;
    slopes[0].k = 0;

    vertices[1].x = 0;
    vertices[1].y = 0;
    slopes[1].dx = pLeft->dy;
    slopes[1].dy = -pLeft->dx;
    slopes[1].k = 0;

    vertices[2].x = pLeft->xa;
    vertices[2].y = pLeft->ya;

    if (joinStyle == JoinMiter) {
        my = (pLeft->dy * (pRight->xa * pRight->dy - pRight->ya * pRight->dx) -
              pRight->dy * (pLeft->xa * pLeft->dy - pLeft->ya * pLeft->dx)) / denom;
        if (pLeft->dy != 0) {
            mx = pLeft->xa + (my - pLeft->ya) * (double) pLeft->dx / (double) pLeft->dy;
        } else {
            mx = pRight->xa + (my - pRight->ya) * (double) pRight->dx / (double) pRight->dy;
        }
        /* check miter limit */
        if ((mx * mx + my * my) * 4 > SQSECANT * lw * lw)
            joinStyle = JoinBevel;
    }

    if (joinStyle == JoinMiter) {
        slopes[2].dx = pLeft->dx;
        slopes[2].dy = pLeft->dy;
        slopes[2].k = pLeft->k;
        if (swapslopes) {
            slopes[2].dx = -slopes[2].dx;
            slopes[2].dy = -slopes[2].dy;
            slopes[2].k = -slopes[2].k;
        }
        vertices[3].x = mx;
        vertices[3].y = my;
        slopes[3].dx = pRight->dx;
        slopes[3].dy = pRight->dy;
        slopes[3].k = pRight->k;
        if (swapslopes) {
            slopes[3].dx = -slopes[3].dx;
            slopes[3].dy = -slopes[3].dy;
            slopes[3].k = -slopes[3].k;
        }
        edgecount = 4;
    } else {
        double scale, dx, dy, adx, ady;

        adx = dx = pRight->xa - pLeft->xa;
        ady = dy = pRight->ya - pLeft->ya;
        if (adx < 0)
            adx = -adx;
        if (ady < 0)
            ady = -ady;
        scale = ady;
        if (adx > ady)
            scale = adx;
        slopes[2].dx = (int) ((dx * 65536) / scale);
        slopes[2].dy = (int) ((dy * 65536) / scale);
        slopes[2].k = ((pLeft->xa + pRight->xa) * slopes[2].dy -
                       (pLeft->ya + pRight->ya) * slopes[2].dx) / 2.0;
        edgecount = 3;
    }

    y = miPolyBuildPoly (vertices, slopes, edgecount, pLeft->x, pLeft->y,
                         left, right, &nleft, &nright, &height);
    miFillPolyHelper (pGC, foreground, spanData, y, height, left, right, nleft, nright);
}

static int
miLineArcI (GCPtr pGC, int xorg, int yorg, DDXPointPtr points, int *widths)
{
    DDXPointPtr tpts, bpts;
    int *twids, *bwids;
    int x, y, e, ex, slw;

    tpts = points;
    twids = widths;
    slw = pGC->lineWidth;
    if (slw == 1) {
        tpts->x = xorg;
        tpts->y = yorg;
        *twids = 1;
        return 1;
    }
    bpts = tpts + slw;
    bwids = twids + slw;
    y = (slw >> 1) + 1;
    if (slw & 1)
        e = -((y << 2) + 3);
    else
        e = -(y << 3);
    ex = -4;
    x = 0;
    while (y) {
        e += (y << 3) - 4;
        while (e >= 0) {
            x++;
            e += (ex = -((x << 3) + 4));
        }
        y--;
        slw = (x << 1) + 1;
        if ((e == ex) && (slw > 1))
            slw--;
        tpts->x = xorg - x;
        tpts->y = yorg - y;
        tpts++;
        *twids++ = slw;
        if ((y != 0) && ((slw > 1) || (e != ex))) {
            bpts--;
            bpts->x = xorg - x;
            bpts->y = yorg + y;
            *--bwids = slw;
        }
    }
    return (pGC->lineWidth);
}

#define CLIPSTEPEDGE(edgey,edge,edgeleft) \
    if (ybase == edgey) \
    { \
        if (edgeleft) \
        { \
            if (edge->x > xcl) \
                xcl = edge->x; \
        } \
        else \
        { \
            if (edge->x < xcr) \
                xcr = edge->x; \
        } \
        edgey++; \
        edge->x += edge->stepx; \
        edge->e += edge->dx; \
        if (edge->e > 0) \
        { \
            edge->x += edge->signdx; \
            edge->e -= edge->dy; \
        } \
    }

static int
miLineArcD (GCPtr pGC,
            double xorg,
            double yorg,
            DDXPointPtr points,
            int *widths,
            PolyEdgePtr edge1,
            int edgey1, Boolean edgeleft1, PolyEdgePtr edge2, int edgey2, Boolean edgeleft2)
{
    DDXPointPtr pts;
    int *wids;
    double radius, x0, y0, el, er, yk, xlk, xrk, k;
    int xbase, ybase, y, boty, xl, xr, xcl, xcr;
    int ymin, ymax;
    Boolean edge1IsMin, edge2IsMin;
    int ymin1, ymin2;

    pts = points;
    wids = widths;
    xbase = (int)floor (xorg);
    x0 = xorg - xbase;
    ybase = ICEIL (yorg);
    y0 = yorg - ybase;
    xlk = x0 + x0 + 1.0;
    xrk = x0 + x0 - 1.0;
    yk = y0 + y0 - 1.0;
    radius = ((double) pGC->lineWidth) / 2.0;
    y = (int)floor (radius - y0 + 1.0);
    ybase -= y;
    ymin = ybase;
    ymax = 65536;
    edge1IsMin = FALSE;
    ymin1 = edgey1;
    if (edge1->dy >= 0) {
        if (!edge1->dy) {
            if (edgeleft1)
                edge1IsMin = TRUE;
            else
                ymax = edgey1;
            edgey1 = 65536;
        } else {
            if ((edge1->signdx < 0) == edgeleft1)
                edge1IsMin = TRUE;
        }
    }
    edge2IsMin = FALSE;
    ymin2 = edgey2;
    if (edge2->dy >= 0) {
        if (!edge2->dy) {
            if (edgeleft2)
                edge2IsMin = TRUE;
            else
                ymax = edgey2;
            edgey2 = 65536;
        } else {
            if ((edge2->signdx < 0) == edgeleft2)
                edge2IsMin = TRUE;
        }
    }
    if (edge1IsMin) {
        ymin = ymin1;
        if (edge2IsMin && ymin1 > ymin2)
            ymin = ymin2;
    } else if (edge2IsMin)
        ymin = ymin2;
    el = radius * radius - ((y + y0) * (y + y0)) - (x0 * x0);
    er = el + xrk;
    xl = 1;
    xr = 0;
    if (x0 < 0.5) {
        xl = 0;
        el -= xlk;
    }
    boty = (y0 < -0.5) ? 1 : 0;
    if (ybase + y - boty > ymax)
        boty = ymax - ybase - y;
    while (y > boty) {
        k = (y << 1) + yk;
        er += k;
        while (er > 0.0) {
            xr++;
            er += xrk - (xr << 1);
        }
        el += k;
        while (el >= 0.0) {
            xl--;
            el += (xl << 1) - xlk;
        }
        y--;
        ybase++;
        if (ybase < ymin)
            continue;
        xcl = xl + xbase;
        xcr = xr + xbase;
        CLIPSTEPEDGE (edgey1, edge1, edgeleft1);
        CLIPSTEPEDGE (edgey2, edge2, edgeleft2);
        if (xcr >= xcl) {
            pts->x = xcl;
            pts->y = ybase;
            pts++;
            *wids++ = xcr - xcl + 1;
        }
    }
    er = xrk - (xr << 1) - er;
    el = (xl << 1) - xlk - el;
    boty = (int)floor (-y0 - radius + 1.0);
    if (ybase + y - boty > ymax)
        boty = ymax - ybase - y;
    while (y > boty) {
        k = (y << 1) + yk;
        er -= k;
        while ((er >= 0.0) && (xr >= 0)) {
            xr--;
            er += xrk - (xr << 1);
        }
        el -= k;
        while ((el > 0.0) && (xl <= 0)) {
            xl++;
            el += (xl << 1) - xlk;
        }
        y--;
        ybase++;
        if (ybase < ymin)
            continue;
        xcl = xl + xbase;
        xcr = xr + xbase;
        CLIPSTEPEDGE (edgey1, edge1, edgeleft1);
        CLIPSTEPEDGE (edgey2, edge2, edgeleft2);
        if (xcr >= xcl) {
            pts->x = xcl;
            pts->y = ybase;
            pts++;
            *wids++ = xcr - xcl + 1;
        }
    }
    return (pts - points);
}

static int
miRoundJoinFace (LineFacePtr face, PolyEdgePtr edge, Boolean * leftEdge)
{
    int y;
    int dx, dy;
    double xa, ya;
    Boolean left;

    dx = -face->dy;
    dy = face->dx;
    xa = face->xa;
    ya = face->ya;
    left = 1;
    if (ya > 0) {
        ya = 0.0;
        xa = 0.0;
    }
    if (dy < 0 || (dy == 0 && dx > 0)) {
        dx = -dx;
        dy = -dy;
        left = !left;
    }
    if (dx == 0 && dy == 0)
        dy = 1;
    if (dy == 0) {
        y = ICEIL (face->ya) + face->y;
        edge->x = -32767;
        edge->stepx = 0;
        edge->signdx = 0;
        edge->e = -1;
        edge->dy = 0;
        edge->dx = 0;
        edge->height = 0;
    } else {
        y = miPolyBuildEdge (xa, ya, 0.0, dx, dy, face->x, face->y, !left, edge);
        edge->height = 32767;
    }
    *leftEdge = !left;
    return y;
}

static void
miRoundJoinClip (LineFacePtr pLeft, LineFacePtr pRight,
                 PolyEdgePtr edge1, PolyEdgePtr edge2, int *y1, int *y2, Boolean * left1, Boolean * left2)
{
    double denom;

    denom = -pLeft->dx * (double) pRight->dy + pRight->dx * (double) pLeft->dy;

    if (denom >= 0) {
        pLeft->xa = -pLeft->xa;
        pLeft->ya = -pLeft->ya;
    } else {
        pRight->xa = -pRight->xa;
        pRight->ya = -pRight->ya;
    }
    *y1 = miRoundJoinFace (pLeft, edge1, left1);
    *y2 = miRoundJoinFace (pRight, edge2, left2);
}

static int
miRoundCapClip (LineFacePtr face, Boolean isInt, PolyEdgePtr edge, Boolean * leftEdge)
{
    int y;
    int dx, dy;
    double xa, ya, k;
    Boolean left;

    dx = -face->dy;
    dy = face->dx;
    xa = face->xa;
    ya = face->ya;
    k = 0.0;
    if (!isInt)
        k = face->k;
    left = 1;
    if (dy < 0 || (dy == 0 && dx > 0)) {
        dx = -dx;
        dy = -dy;
        xa = -xa;
        ya = -ya;
        left = !left;
    }
    if (dx == 0 && dy == 0)
        dy = 1;
    if (dy == 0) {
        y = ICEIL (face->ya) + face->y;
        edge->x = -32767;
        edge->stepx = 0;
        edge->signdx = 0;
        edge->e = -1;
        edge->dy = 0;
        edge->dx = 0;
        edge->height = 0;
    } else {
        y = miPolyBuildEdge (xa, ya, k, dx, dy, face->x, face->y, !left, edge);
        edge->height = 32767;
    }
    *leftEdge = !left;
    return y;
}

static void
miLineArc (GCPtr pGC,
           Boolean foreground,
           SpanDataPtr spanData,
           LineFacePtr leftFace, LineFacePtr rightFace, double xorg, double yorg, Boolean isInt)
{
    DDXPointPtr points;
    int *widths;
    int xorgi = 0, yorgi = 0;
    Spans spanRec;
    int n;
    PolyEdgeRec edge1 = { 0 }, edge2 = { 0 };
    int edgey1, edgey2;
    Boolean edgeleft1, edgeleft2;

    if (isInt) {
        xorgi = leftFace ? leftFace->x : rightFace->x;
        yorgi = leftFace ? leftFace->y : rightFace->y;
    }
    edgey1 = 65536;
    edgey2 = 65536;
    edge1.x = 0;                /* not used, keep memory checkers happy */
    edge1.dy = -1;
    edge2.x = 0;                /* not used, keep memory checkers happy */
    edge2.dy = -1;
    edgeleft1 = FALSE;
    edgeleft2 = FALSE;
    if ((pGC->lineStyle != LineSolid || pGC->lineWidth > 2) &&
        ((pGC->capStyle == CapRound && pGC->joinStyle != JoinRound) ||
         (pGC->joinStyle == JoinRound && pGC->capStyle == CapButt))) {
        if (isInt) {
            xorg = (double) xorgi;
            yorg = (double) yorgi;
        }
        if (leftFace && rightFace) {
            miRoundJoinClip (leftFace, rightFace, &edge1, &edge2,
                             &edgey1, &edgey2, &edgeleft1, &edgeleft2);
        } else if (leftFace) {
            edgey1 = miRoundCapClip (leftFace, isInt, &edge1, &edgeleft1);
        } else if (rightFace) {
            edgey2 = miRoundCapClip (rightFace, isInt, &edge2, &edgeleft2);
        }
        isInt = FALSE;
    }
    if (!spanData) {
        points = (DDXPointRec *)xalloc (sizeof (DDXPointRec) * pGC->lineWidth);
        if (!points)
            return;
        widths = (int *)xalloc (sizeof (int) * pGC->lineWidth);
        if (!widths) {
            xfree (points);
            return;
        }
    } else {
        points = (DDXPointRec *)xalloc (pGC->lineWidth * sizeof (DDXPointRec));
        if (!points)
            return;
        widths = (int *)xalloc (pGC->lineWidth * sizeof (int));
        if (!widths) {
            xfree (points);
            return;
        }
        spanRec.points = points;
        spanRec.widths = widths;
    }
    if (isInt)
        n = miLineArcI (pGC, xorgi, yorgi, points, widths);
    else
        n = miLineArcD (pGC, xorg, yorg, points, widths,
                        &edge1, edgey1, edgeleft1, &edge2, edgey2, edgeleft2);

    if (!spanData) {
        (*pGC->ops->FillSpans) (pGC, n, points, widths, TRUE, foreground);
        xfree (widths);
        xfree (points);
    } else {
        spanRec.count = n;
        AppendSpanGroup (pGC, foreground, &spanRec, spanData)
    }
}

static void
miLineProjectingCap (GCPtr pGC,
                     Boolean foreground,
                     SpanDataPtr spanData,
                     LineFacePtr face,
                     Boolean isLeft,
                     SPICE_GNUC_UNUSED double xorg,
                     SPICE_GNUC_UNUSED double yorg,
                     Boolean isInt)
{
    int xorgi = 0, yorgi = 0;
    int lw;
    PolyEdgeRec lefts[4], rights[4];
    int lefty, righty, topy, bottomy;
    PolyEdgePtr left, right;
    PolyEdgePtr top, bottom;
    double xa, ya;
    double k;
    double xap, yap;
    int dx, dy;
    double projectXoff, projectYoff;
    double maxy;
    int finaly;

    if (isInt) {
        xorgi = face->x;
        yorgi = face->y;
    }
    lw = pGC->lineWidth;
    dx = face->dx;
    dy = face->dy;
    k = face->k;
    if (dy == 0) {
        lefts[0].height = lw;
        lefts[0].x = xorgi;
        if (isLeft)
            lefts[0].x -= (lw >> 1);
        lefts[0].stepx = 0;
        lefts[0].signdx = 1;
        lefts[0].e = -lw;
        lefts[0].dx = 0;
        lefts[0].dy = lw;
        rights[0].height = lw;
        rights[0].x = xorgi;
        if (!isLeft)
            rights[0].x += ((lw + 1) >> 1);
        rights[0].stepx = 0;
        rights[0].signdx = 1;
        rights[0].e = -lw;
        rights[0].dx = 0;
        rights[0].dy = lw;
        miFillPolyHelper (pGC, foreground, spanData, yorgi - (lw >> 1), lw, lefts, rights, 1, 1);
    } else if (dx == 0) {
        if (dy < 0) {
            dy = -dy;
            isLeft = !isLeft;
        }
        topy = yorgi;
        bottomy = yorgi + dy;
        if (isLeft)
            topy -= (lw >> 1);
        else
            bottomy += (lw >> 1);
        lefts[0].height = bottomy - topy;
        lefts[0].x = xorgi - (lw >> 1);
        lefts[0].stepx = 0;
        lefts[0].signdx = 1;
        lefts[0].e = -dy;
        lefts[0].dx = dx;
        lefts[0].dy = dy;

        rights[0].height = bottomy - topy;
        rights[0].x = lefts[0].x + (lw - 1);
        rights[0].stepx = 0;
        rights[0].signdx = 1;
        rights[0].e = -dy;
        rights[0].dx = dx;
        rights[0].dy = dy;
        miFillPolyHelper (pGC, foreground, spanData, topy, bottomy - topy, lefts, rights, 1, 1);
    } else {
        xa = face->xa;
        ya = face->ya;
        projectXoff = -ya;
        projectYoff = xa;
        if (dx < 0) {
            right = &rights[1];
            left = &lefts[0];
            top = &rights[0];
            bottom = &lefts[1];
        } else {
            right = &rights[0];
            left = &lefts[1];
            top = &lefts[0];
            bottom = &rights[1];
        }
        if (isLeft) {
            righty = miPolyBuildEdge (xa, ya, k, dx, dy, xorgi, yorgi, 0, right);

            xa = -xa;
            ya = -ya;
            k = -k;
            lefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
                                     k, dx, dy, xorgi, yorgi, 1, left);
            if (dx > 0) {
                ya = -ya;
                xa = -xa;
            }
            xap = xa - projectXoff;
            yap = ya - projectYoff;
            topy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
                                    -dy, dx, xorgi, yorgi, dx > 0, top);
            bottomy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, xorgi, yorgi, dx < 0, bottom);
            maxy = -ya;
        } else {
            righty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
                                      k, dx, dy, xorgi, yorgi, 0, right);

            xa = -xa;
            ya = -ya;
            k = -k;
            lefty = miPolyBuildEdge (xa, ya, k, dx, dy, xorgi, yorgi, 1, left);
            if (dx > 0) {
                ya = -ya;
                xa = -xa;
            }
            xap = xa - projectXoff;
            yap = ya - projectYoff;
            topy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, xorgi, xorgi, dx > 0, top);
            bottomy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
                                       -dy, dx, xorgi, xorgi, dx < 0, bottom);
            maxy = -ya + projectYoff;
        }
        finaly = ICEIL (maxy) + yorgi;
        if (dx < 0) {
            left->height = bottomy - lefty;
            right->height = finaly - righty;
            top->height = righty - topy;
        } else {
            right->height = bottomy - righty;
            left->height = finaly - lefty;
            top->height = lefty - topy;
        }
        bottom->height = finaly - bottomy;
        miFillPolyHelper (pGC, foreground, spanData, topy,
                          bottom->height + bottomy - topy, lefts, rights, 2, 2);
    }
}

static void
miWideSegment (GCPtr pGC,
               Boolean foreground,
               SpanDataPtr spanData,
               int x1,
               int y1,
               int x2,
               int y2,
               Boolean projectLeft, Boolean projectRight, LineFacePtr leftFace, LineFacePtr rightFace)
{
    double l, L, r;
    double xa, ya;
    double projectXoff = 0.0, projectYoff = 0.0;
    double k;
    double maxy;
    int x, y;
    int dx, dy;
    int finaly;
    PolyEdgePtr left, right;
    PolyEdgePtr top, bottom;
    int lefty, righty, topy, bottomy;
    int signdx;
    PolyEdgeRec lefts[4], rights[4];
    LineFacePtr tface;
    int lw = pGC->lineWidth;

    /* draw top-to-bottom always */
    if (y2 < y1 || (y2 == y1 && x2 < x1)) {
        x = x1;
        x1 = x2;
        x2 = x;

        y = y1;
        y1 = y2;
        y2 = y;

        x = projectLeft;
        projectLeft = projectRight;
        projectRight = x;

        tface = leftFace;
        leftFace = rightFace;
        rightFace = tface;
    }

    dy = y2 - y1;
    signdx = 1;
    dx = x2 - x1;
    if (dx < 0)
        signdx = -1;

    leftFace->x = x1;
    leftFace->y = y1;
    leftFace->dx = dx;
    leftFace->dy = dy;

    rightFace->x = x2;
    rightFace->y = y2;
    rightFace->dx = -dx;
    rightFace->dy = -dy;

    if (dy == 0) {
        rightFace->xa = 0;
        rightFace->ya = (double) lw / 2.0;
        rightFace->k = -(double) (lw * dx) / 2.0;
        leftFace->xa = 0;
        leftFace->ya = -rightFace->ya;
        leftFace->k = rightFace->k;
        x = x1;
        if (projectLeft)
            x -= (lw >> 1);
        y = y1 - (lw >> 1);
        dx = x2 - x;
        if (projectRight)
            dx += ((lw + 1) >> 1);
        dy = lw;
        miFillRectPolyHelper (pGC, foreground, spanData, x, y, dx, dy);
    } else if (dx == 0) {
        leftFace->xa = (double) lw / 2.0;
        leftFace->ya = 0;
        leftFace->k = (double) (lw * dy) / 2.0;
        rightFace->xa = -leftFace->xa;
        rightFace->ya = 0;
        rightFace->k = leftFace->k;
        y = y1;
        if (projectLeft)
            y -= lw >> 1;
        x = x1 - (lw >> 1);
        dy = y2 - y;
        if (projectRight)
            dy += ((lw + 1) >> 1);
        dx = lw;
        miFillRectPolyHelper (pGC, foreground, spanData, x, y, dx, dy);
    } else {
        l = ((double) lw) / 2.0;
        L = hypot ((double) dx, (double) dy);

        if (dx < 0) {
            right = &rights[1];
            left = &lefts[0];
            top = &rights[0];
            bottom = &lefts[1];
        } else {
            right = &rights[0];
            left = &lefts[1];
            top = &lefts[0];
            bottom = &rights[1];
        }
        r = l / L;

        /* coord of upper bound at integral y */
        ya = -r * dx;
        xa = r * dy;

        if (projectLeft | projectRight) {
            projectXoff = -ya;
            projectYoff = xa;
        }

        /* xa * dy - ya * dx */
        k = l * L;

        leftFace->xa = xa;
        leftFace->ya = ya;
        leftFace->k = k;
        rightFace->xa = -xa;
        rightFace->ya = -ya;
        rightFace->k = k;

        if (projectLeft)
            righty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
                                      k, dx, dy, x1, y1, 0, right);
        else
            righty = miPolyBuildEdge (xa, ya, k, dx, dy, x1, y1, 0, right);

        /* coord of lower bound at integral y */
        ya = -ya;
        xa = -xa;

        /* xa * dy - ya * dx */
        k = -k;

        if (projectLeft)
            lefty = miPolyBuildEdge (xa - projectXoff, ya - projectYoff,
                                     k, dx, dy, x1, y1, 1, left);
        else
            lefty = miPolyBuildEdge (xa, ya, k, dx, dy, x1, y1, 1, left);

        /* coord of top face at integral y */

        if (signdx > 0) {
            ya = -ya;
            xa = -xa;
        }

        if (projectLeft) {
            double xap = xa - projectXoff;
            double yap = ya - projectYoff;
            topy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy, -dy, dx, x1, y1, dx > 0, top);
        } else
            topy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, x1, y1, dx > 0, top);

        /* coord of bottom face at integral y */

        if (projectRight) {
            double xap = xa + projectXoff;
            double yap = ya + projectYoff;
            bottomy = miPolyBuildEdge (xap, yap, xap * dx + yap * dy,
                                       -dy, dx, x2, y2, dx < 0, bottom);
            maxy = -ya + projectYoff;
        } else {
            bottomy = miPolyBuildEdge (xa, ya, 0.0, -dy, dx, x2, y2, dx < 0, bottom);
            maxy = -ya;
        }

        finaly = ICEIL (maxy) + y2;

        if (dx < 0) {
            left->height = bottomy - lefty;
            right->height = finaly - righty;
            top->height = righty - topy;
        } else {
            right->height = bottomy - righty;
            left->height = finaly - lefty;
            top->height = lefty - topy;
        }
        bottom->height = finaly - bottomy;
        miFillPolyHelper (pGC, foreground, spanData, topy,
                          bottom->height + bottomy - topy, lefts, rights, 2, 2);
    }
}

static SpanDataPtr
miSetupSpanData (GCPtr pGC, SpanDataPtr spanData, int npt)
{
    if ((npt < 3 && pGC->capStyle != CapRound) || miSpansEasyRop (pGC->alu))
        return (SpanDataPtr) NULL;
    if (pGC->lineStyle == LineDoubleDash)
        miInitSpanGroup (&spanData->bgGroup);
    miInitSpanGroup (&spanData->fgGroup);
    return spanData;
}

static void
miCleanupSpanData (GCPtr pGC, SpanDataPtr spanData)
{
    if (pGC->lineStyle == LineDoubleDash) {
        miFillUniqueSpanGroup (pGC, &spanData->bgGroup, FALSE);
        miFreeSpanGroup (&spanData->bgGroup);
    }
    miFillUniqueSpanGroup (pGC, &spanData->fgGroup, TRUE);
    miFreeSpanGroup (&spanData->fgGroup);
}

void
miWideLine (GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
{
    int x1, y1, x2, y2;
    SpanDataRec spanDataRec;
    SpanDataPtr spanData;
    Boolean projectLeft, projectRight;
    LineFaceRec leftFace, rightFace, prevRightFace;
    LineFaceRec firstFace;
    int first;
    Boolean somethingDrawn = FALSE;
    Boolean selfJoin;

    spanData = miSetupSpanData (pGC, &spanDataRec, npt);
    x2 = pPts->x;
    y2 = pPts->y;
    first = TRUE;
    selfJoin = FALSE;
    if (npt > 1) {
        if (mode == CoordModePrevious) {
            int nptTmp;
            DDXPointPtr pPtsTmp;

            x1 = x2;
            y1 = y2;
            nptTmp = npt;
            pPtsTmp = pPts + 1;
            while (--nptTmp) {
                x1 += pPtsTmp->x;
                y1 += pPtsTmp->y;
                ++pPtsTmp;
            }
            if (x2 == x1 && y2 == y1)
                selfJoin = TRUE;
        } else if (x2 == pPts[npt - 1].x && y2 == pPts[npt - 1].y) {
            selfJoin = TRUE;
        }
    }
    projectLeft = pGC->capStyle == CapProjecting && !selfJoin;
    projectRight = FALSE;
    while (--npt) {
        x1 = x2;
        y1 = y2;
        ++pPts;
        x2 = pPts->x;
        y2 = pPts->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }
        if (x1 != x2 || y1 != y2) {
            somethingDrawn = TRUE;
            if (npt == 1 && pGC->capStyle == CapProjecting && !selfJoin)
                projectRight = TRUE;
            miWideSegment (pGC, TRUE, spanData, x1, y1, x2, y2,
                           projectLeft, projectRight, &leftFace, &rightFace);
            if (first) {
                if (selfJoin)
                    firstFace = leftFace;
                else if (pGC->capStyle == CapRound) {
                    if (pGC->lineWidth == 1 && !spanData)
                        miLineOnePoint (pGC, TRUE, spanData, x1, y1);
                    else
                        miLineArc (pGC, TRUE, spanData,
                                   &leftFace, (LineFacePtr) NULL, (double) 0.0, (double) 0.0, TRUE);
                }
            } else {
                miLineJoin (pGC, TRUE, spanData, &leftFace, &prevRightFace);
            }
            prevRightFace = rightFace;
            first = FALSE;
            projectLeft = FALSE;
        }
        if (npt == 1 && somethingDrawn) {
            if (selfJoin)
                miLineJoin (pGC, TRUE, spanData, &firstFace, &rightFace);
            else if (pGC->capStyle == CapRound) {
                if (pGC->lineWidth == 1 && !spanData)
                    miLineOnePoint (pGC, TRUE, spanData, x2, y2);
                else
                    miLineArc (pGC, TRUE, spanData,
                               (LineFacePtr) NULL, &rightFace, (double) 0.0, (double) 0.0, TRUE);
            }
        }
    }
    /* handle crock where all points are coincedent */
    if (!somethingDrawn) {
        projectLeft = pGC->capStyle == CapProjecting;
        miWideSegment (pGC, TRUE, spanData,
                       x2, y2, x2, y2, projectLeft, projectLeft, &leftFace, &rightFace);
        if (pGC->capStyle == CapRound) {
            miLineArc (pGC, TRUE, spanData,
                       &leftFace, (LineFacePtr) NULL, (double) 0.0, (double) 0.0, TRUE);
            rightFace.dx = -1;  /* sleezy hack to make it work */
            miLineArc (pGC, TRUE, spanData,
                       (LineFacePtr) NULL, &rightFace, (double) 0.0, (double) 0.0, TRUE);
        }
    }
    if (spanData)
        miCleanupSpanData (pGC, spanData);
}

#define V_TOP       0
#define V_RIGHT     1
#define V_BOTTOM    2
#define V_LEFT      3

static void
miWideDashSegment (GCPtr pGC,
                   SpanDataPtr spanData,
                   int *pDashOffset,
                   int *pDashIndex,
                   int x1,
                   int y1,
                   int x2,
                   int y2,
                   Boolean projectLeft, Boolean projectRight, LineFacePtr leftFace, LineFacePtr rightFace)
{
    int dashIndex, dashRemain;
    unsigned char *pDash;
    double L, l;
    double k;
    PolyVertexRec vertices[4];
    PolyVertexRec saveRight = { 0, 0 }, saveBottom;
    PolySlopeRec slopes[4];
    PolyEdgeRec left[4], right[4];
    LineFaceRec lcapFace, rcapFace;
    int nleft, nright;
    int h;
    int y;
    int dy, dx;
    Boolean foreground;
    double LRemain;
    double r;
    double rdx, rdy;
    double dashDx, dashDy;
    double saveK = 0.0;
    Boolean first = TRUE;
    double lcenterx, lcentery, rcenterx = 0.0, rcentery = 0.0;

    dx = x2 - x1;
    dy = y2 - y1;
    dashIndex = *pDashIndex;
    pDash = pGC->dash;
    dashRemain = pDash[dashIndex] - *pDashOffset;

    l = ((double) pGC->lineWidth) / 2.0;
    if (dx == 0) {
        L = dy;
        rdx = 0;
        rdy = l;
        if (dy < 0) {
            L = -dy;
            rdy = -l;
        }
    } else if (dy == 0) {
        L = dx;
        rdx = l;
        rdy = 0;
        if (dx < 0) {
            L = -dx;
            rdx = -l;
        }
    } else {
        L = hypot ((double) dx, (double) dy);
        r = l / L;

        rdx = r * dx;
        rdy = r * dy;
    }
    k = l * L;
    LRemain = L;
    /* All position comments are relative to a line with dx and dy > 0,
     * but the code does not depend on this */
    /* top */
    slopes[V_TOP].dx = dx;
    slopes[V_TOP].dy = dy;
    slopes[V_TOP].k = k;
    /* right */
    slopes[V_RIGHT].dx = -dy;
    slopes[V_RIGHT].dy = dx;
    slopes[V_RIGHT].k = 0;
    /* bottom */
    slopes[V_BOTTOM].dx = -dx;
    slopes[V_BOTTOM].dy = -dy;
    slopes[V_BOTTOM].k = k;
    /* left */
    slopes[V_LEFT].dx = dy;
    slopes[V_LEFT].dy = -dx;
    slopes[V_LEFT].k = 0;

    /* preload the start coordinates */
    vertices[V_RIGHT].x = vertices[V_TOP].x = rdy;
    vertices[V_RIGHT].y = vertices[V_TOP].y = -rdx;

    vertices[V_BOTTOM].x = vertices[V_LEFT].x = -rdy;
    vertices[V_BOTTOM].y = vertices[V_LEFT].y = rdx;

    if (projectLeft) {
        vertices[V_TOP].x -= rdx;
        vertices[V_TOP].y -= rdy;

        vertices[V_LEFT].x -= rdx;
        vertices[V_LEFT].y -= rdy;

        slopes[V_LEFT].k = rdx * dx + rdy * dy;
    }

    lcenterx = x1;
    lcentery = y1;

    if (pGC->capStyle == CapRound) {
        lcapFace.dx = dx;
        lcapFace.dy = dy;
        lcapFace.x = x1;
        lcapFace.y = y1;

        rcapFace.dx = -dx;
        rcapFace.dy = -dy;
        rcapFace.x = x1;
        rcapFace.y = y1;
    }
    while (LRemain > dashRemain) {
        dashDx = (dashRemain * dx) / L;
        dashDy = (dashRemain * dy) / L;

        rcenterx = lcenterx + dashDx;
        rcentery = lcentery + dashDy;

        vertices[V_RIGHT].x += dashDx;
        vertices[V_RIGHT].y += dashDy;

        vertices[V_BOTTOM].x += dashDx;
        vertices[V_BOTTOM].y += dashDy;

        slopes[V_RIGHT].k = vertices[V_RIGHT].x * dx + vertices[V_RIGHT].y * dy;

        if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1)) {
            if (pGC->lineStyle == LineOnOffDash && pGC->capStyle == CapProjecting) {
                saveRight = vertices[V_RIGHT];
                saveBottom = vertices[V_BOTTOM];
                saveK = slopes[V_RIGHT].k;

                if (!first) {
                    vertices[V_TOP].x -= rdx;
                    vertices[V_TOP].y -= rdy;

                    vertices[V_LEFT].x -= rdx;
                    vertices[V_LEFT].y -= rdy;

                    slopes[V_LEFT].k = vertices[V_LEFT].x *
                        slopes[V_LEFT].dy - vertices[V_LEFT].y * slopes[V_LEFT].dx;
                }

                vertices[V_RIGHT].x += rdx;
                vertices[V_RIGHT].y += rdy;

                vertices[V_BOTTOM].x += rdx;
                vertices[V_BOTTOM].y += rdy;

                slopes[V_RIGHT].k = vertices[V_RIGHT].x *
                    slopes[V_RIGHT].dy - vertices[V_RIGHT].y * slopes[V_RIGHT].dx;
            }
            y = miPolyBuildPoly (vertices, slopes, 4, x1, y1, left, right, &nleft, &nright, &h);
            foreground = (dashIndex & 1) == 0;
            miFillPolyHelper (pGC, foreground, spanData, y, h, left, right, nleft, nright);

            if (pGC->lineStyle == LineOnOffDash) {
                switch (pGC->capStyle) {
                case CapProjecting:
                    vertices[V_BOTTOM] = saveBottom;
                    vertices[V_RIGHT] = saveRight;
                    slopes[V_RIGHT].k = saveK;
                    break;
                case CapRound:
                    if (!first) {
                        if (dx < 0) {
                            lcapFace.xa = -vertices[V_LEFT].x;
                            lcapFace.ya = -vertices[V_LEFT].y;
                            lcapFace.k = slopes[V_LEFT].k;
                        } else {
                            lcapFace.xa = vertices[V_TOP].x;
                            lcapFace.ya = vertices[V_TOP].y;
                            lcapFace.k = -slopes[V_LEFT].k;
                        }
                        miLineArc (pGC, foreground, spanData,
                                   &lcapFace, (LineFacePtr) NULL, lcenterx, lcentery, FALSE);
                    }
                    if (dx < 0) {
                        rcapFace.xa = vertices[V_BOTTOM].x;
                        rcapFace.ya = vertices[V_BOTTOM].y;
                        rcapFace.k = slopes[V_RIGHT].k;
                    } else {
                        rcapFace.xa = -vertices[V_RIGHT].x;
                        rcapFace.ya = -vertices[V_RIGHT].y;
                        rcapFace.k = -slopes[V_RIGHT].k;
                    }
                    miLineArc (pGC, foreground, spanData,
                               (LineFacePtr) NULL, &rcapFace, rcenterx, rcentery, FALSE);
                    break;
                }
            }
        }
        LRemain -= dashRemain;
        ++dashIndex;
        if (dashIndex == pGC->numInDashList)
            dashIndex = 0;
        dashRemain = pDash[dashIndex];

        lcenterx = rcenterx;
        lcentery = rcentery;

        vertices[V_TOP] = vertices[V_RIGHT];
        vertices[V_LEFT] = vertices[V_BOTTOM];
        slopes[V_LEFT].k = -slopes[V_RIGHT].k;
        first = FALSE;
    }

    if (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1)) {
        vertices[V_TOP].x -= dx;
        vertices[V_TOP].y -= dy;

        vertices[V_LEFT].x -= dx;
        vertices[V_LEFT].y -= dy;

        vertices[V_RIGHT].x = rdy;
        vertices[V_RIGHT].y = -rdx;

        vertices[V_BOTTOM].x = -rdy;
        vertices[V_BOTTOM].y = rdx;


        if (projectRight) {
            vertices[V_RIGHT].x += rdx;
            vertices[V_RIGHT].y += rdy;

            vertices[V_BOTTOM].x += rdx;
            vertices[V_BOTTOM].y += rdy;
            slopes[V_RIGHT].k = vertices[V_RIGHT].x *
                slopes[V_RIGHT].dy - vertices[V_RIGHT].y * slopes[V_RIGHT].dx;
        } else
            slopes[V_RIGHT].k = 0;

        if (!first && pGC->lineStyle == LineOnOffDash && pGC->capStyle == CapProjecting) {
            vertices[V_TOP].x -= rdx;
            vertices[V_TOP].y -= rdy;

            vertices[V_LEFT].x -= rdx;
            vertices[V_LEFT].y -= rdy;
            slopes[V_LEFT].k = vertices[V_LEFT].x *
                slopes[V_LEFT].dy - vertices[V_LEFT].y * slopes[V_LEFT].dx;
        } else
            slopes[V_LEFT].k += dx * dx + dy * dy;


        y = miPolyBuildPoly (vertices, slopes, 4, x2, y2, left, right, &nleft, &nright, &h);

        foreground = (dashIndex & 1) == 0;
        miFillPolyHelper (pGC, foreground, spanData, y, h, left, right, nleft, nright);
        if (!first && pGC->lineStyle == LineOnOffDash && pGC->capStyle == CapRound) {
            lcapFace.x = x2;
            lcapFace.y = y2;
            if (dx < 0) {
                lcapFace.xa = -vertices[V_LEFT].x;
                lcapFace.ya = -vertices[V_LEFT].y;
                lcapFace.k = slopes[V_LEFT].k;
            } else {
                lcapFace.xa = vertices[V_TOP].x;
                lcapFace.ya = vertices[V_TOP].y;
                lcapFace.k = -slopes[V_LEFT].k;
            }
            miLineArc (pGC, foreground, spanData,
                       &lcapFace, (LineFacePtr) NULL, rcenterx, rcentery, FALSE);
        }
    }
    dashRemain = (int)(((double) dashRemain) - LRemain);
    if (dashRemain == 0) {
        dashIndex++;
        if (dashIndex == pGC->numInDashList)
            dashIndex = 0;
        dashRemain = pDash[dashIndex];
    }

    leftFace->x = x1;
    leftFace->y = y1;
    leftFace->dx = dx;
    leftFace->dy = dy;
    leftFace->xa = rdy;
    leftFace->ya = -rdx;
    leftFace->k = k;

    rightFace->x = x2;
    rightFace->y = y2;
    rightFace->dx = -dx;
    rightFace->dy = -dy;
    rightFace->xa = -rdy;
    rightFace->ya = rdx;
    rightFace->k = k;

    *pDashIndex = dashIndex;
    *pDashOffset = pDash[dashIndex] - dashRemain;
}

void
miWideDash (GCPtr pGC, int mode, int npt, DDXPointPtr pPts)
{
    int x1, y1, x2, y2;
    Boolean foreground;
    Boolean projectLeft, projectRight;
    LineFaceRec leftFace, rightFace, prevRightFace;
    LineFaceRec firstFace;
    int first;
    int dashIndex, dashOffset;
    int prevDashIndex;
    SpanDataRec spanDataRec;
    SpanDataPtr spanData;
    Boolean somethingDrawn = FALSE;
    Boolean selfJoin;
    Boolean endIsFg = FALSE, startIsFg = FALSE;
    Boolean firstIsFg = FALSE, prevIsFg = FALSE;

    if (npt == 0)
        return;
    spanData = miSetupSpanData (pGC, &spanDataRec, npt);
    x2 = pPts->x;
    y2 = pPts->y;
    first = TRUE;
    selfJoin = FALSE;
    if (mode == CoordModePrevious) {
        int nptTmp;
        DDXPointPtr pPtsTmp;

        x1 = x2;
        y1 = y2;
        nptTmp = npt;
        pPtsTmp = pPts + 1;
        while (--nptTmp) {
            x1 += pPtsTmp->x;
            y1 += pPtsTmp->y;
            ++pPtsTmp;
        }
        if (x2 == x1 && y2 == y1)
            selfJoin = TRUE;
    } else if (x2 == pPts[npt - 1].x && y2 == pPts[npt - 1].y) {
        selfJoin = TRUE;
    }
    projectLeft = pGC->capStyle == CapProjecting && !selfJoin;
    projectRight = FALSE;
    dashIndex = 0;
    dashOffset = 0;
    miStepDash ((int) pGC->dashOffset, &dashIndex,
                pGC->dash, (int) pGC->numInDashList, &dashOffset);
    while (--npt) {
        x1 = x2;
        y1 = y2;
        ++pPts;
        x2 = pPts->x;
        y2 = pPts->y;
        if (mode == CoordModePrevious) {
            x2 += x1;
            y2 += y1;
        }
        if (x1 != x2 || y1 != y2) {
            somethingDrawn = TRUE;
            if (npt == 1 && pGC->capStyle == CapProjecting && (!selfJoin || !firstIsFg))
                projectRight = TRUE;
            prevDashIndex = dashIndex;
            miWideDashSegment (pGC, spanData, &dashOffset, &dashIndex,
                               x1, y1, x2, y2, projectLeft, projectRight, &leftFace, &rightFace);
            startIsFg = !(prevDashIndex & 1);
            endIsFg = (dashIndex & 1) ^ (dashOffset != 0);
            if (pGC->lineStyle == LineDoubleDash || startIsFg) {
                foreground = startIsFg;
                if (first || (pGC->lineStyle == LineOnOffDash && !prevIsFg)) {
                    if (first && selfJoin) {
                        firstFace = leftFace;
                        firstIsFg = startIsFg;
                    } else if (pGC->capStyle == CapRound)
                        miLineArc (pGC, foreground, spanData,
                                   &leftFace, (LineFacePtr) NULL, (double) 0.0, (double) 0.0, TRUE);
                } else {
                    miLineJoin (pGC, foreground, spanData, &leftFace, &prevRightFace);
                }
            }
            prevRightFace = rightFace;
            prevIsFg = endIsFg;
            first = FALSE;
            projectLeft = FALSE;
        }
        if (npt == 1 && somethingDrawn) {
            if (pGC->lineStyle == LineDoubleDash || endIsFg) {
                foreground = endIsFg;
                if (selfJoin && (pGC->lineStyle == LineDoubleDash || firstIsFg)) {
                    miLineJoin (pGC, foreground, spanData, &firstFace, &rightFace);
                } else {
                    if (pGC->capStyle == CapRound)
                        miLineArc (pGC, foreground, spanData,
                                   (LineFacePtr) NULL, &rightFace,
                                   (double) 0.0, (double) 0.0, TRUE);
                }
            } else {
                /* glue a cap to the start of the line if
                 * we're OnOffDash and ended on odd dash
                 */
                if (selfJoin && firstIsFg) {
                    foreground = TRUE;
                    if (pGC->capStyle == CapProjecting)
                        miLineProjectingCap (pGC, foreground, spanData,
                                             &firstFace, TRUE, (double) 0.0, (double) 0.0, TRUE);
                    else if (pGC->capStyle == CapRound)
                        miLineArc (pGC, foreground, spanData,
                                   &firstFace, (LineFacePtr) NULL,
                                   (double) 0.0, (double) 0.0, TRUE);
                }
            }
        }
    }
    /* handle crock where all points are coincident */
    if (!somethingDrawn && (pGC->lineStyle == LineDoubleDash || !(dashIndex & 1))) {
        /* not the same as endIsFg computation above */
        foreground = (dashIndex & 1) == 0;
        switch (pGC->capStyle) {
        case CapRound:
            miLineArc (pGC, foreground, spanData,
                       (LineFacePtr) NULL, (LineFacePtr) NULL, (double) x2, (double) y2, FALSE);
            break;
        case CapProjecting:
            x1 = pGC->lineWidth;
            miFillRectPolyHelper (pGC, foreground, spanData,
                                  x2 - (x1 >> 1), y2 - (x1 >> 1), x1, x1);
            break;
        }
    }
    if (spanData)
        miCleanupSpanData (pGC, spanData);
}

#undef ExchangeSpans
#define ExchangeSpans(a, b)                                 \
{                                                           \
    DDXPointRec tpt;                                        \
    int         tw;                                         \
                                                            \
    tpt = spans[a]; spans[a] = spans[b]; spans[b] = tpt;    \
    tw = widths[a]; widths[a] = widths[b]; widths[b] = tw;  \
}

static void QuickSortSpans(
    DDXPointRec spans[],
    int         widths[],
    int         numSpans)
{
    int     y;
    int     i, j, m;
    DDXPointPtr    r;

    /* Always called with numSpans > 1 */
    /* Sorts only by y, doesn't bother to sort by x */

    do
    {
        if (numSpans < 9)
        {
            /* Do insertion sort */
            int yprev;

            yprev = spans[0].y;
            i = 1;
            do
            { /* while i != numSpans */
                y = spans[i].y;
                if (yprev > y)
                {
                    /* spans[i] is out of order.  Move into proper location. */
                    DDXPointRec tpt;
                    int     tw, k;

                    for (j = 0; y >= spans[j].y; j++) {}
                    tpt = spans[i];
                    tw  = widths[i];
                    for (k = i; k != j; k--)
                    {
                        spans[k] = spans[k-1];
                        widths[k] = widths[k-1];
                    }
                    spans[j] = tpt;
                    widths[j] = tw;
                    y = spans[i].y;
                } /* if out of order */
                yprev = y;
                i++;
            } while (i != numSpans);
            return;
        }

        /* Choose partition element, stick in location 0 */
        m = numSpans / 2;
        if (spans[m].y > spans[0].y)            ExchangeSpans(m, 0);
        if (spans[m].y > spans[numSpans-1].y)   ExchangeSpans(m, numSpans-1);
        if (spans[m].y > spans[0].y)            ExchangeSpans(m, 0);
        y = spans[0].y;

        /* Partition array */
        i = 0;
        j = numSpans;
        do
        {
            r = &(spans[i]);
            do
            {
                r++;
                i++;
            } while (i != numSpans && r->y < y);
            r = &(spans[j]);
            do
            {
                r--;
                j--;
            } while (y < r->y);
            if (i < j)
                ExchangeSpans(i, j);
        } while (i < j);

        /* Move partition element back to middle */
        ExchangeSpans(0, j);

        /* Recurse */
        if (numSpans-j-1 > 1)
            QuickSortSpans(&spans[j+1], &widths[j+1], numSpans-j-1);
        numSpans = j;
    } while (numSpans > 1);
}

#define NextBand()                                                  \
{                                                                   \
    clipy1 = pboxBandStart->y1;                                     \
    clipy2 = pboxBandStart->y2;                                     \
    pboxBandEnd = pboxBandStart + 1;                                \
    while (pboxBandEnd != pboxLast && pboxBandEnd->y1 == clipy1) {  \
        pboxBandEnd++;                                              \
    }                                                               \
    for (; ppt != pptLast && ppt->y < clipy1; ppt++, pwidth++) {} \
}

/*
    Clip a list of scanlines to a region.  The caller has allocated the
    space.  FSorted is non-zero if the scanline origins are in ascending
    order.
    returns the number of new, clipped scanlines.
*/

int spice_canvas_clip_spans(pixman_region32_t *prgnDst,
                            DDXPointPtr ppt,
                            int         *pwidth,
                            int                 nspans,
                            DDXPointPtr         pptNew,
                            int                 *pwidthNew,
                            int                 fSorted)
{
    DDXPointPtr pptLast;
    int         *pwidthNewStart;        /* the vengeance of Xerox! */
    int         y, x1, x2;
    int         numRects;
    pixman_box32_t *pboxBandStart;

    pptLast = ppt + nspans;
    pwidthNewStart = pwidthNew;

    pboxBandStart = pixman_region32_rectangles (prgnDst, &numRects);

    if (numRects == 1) {
        /* Do special fast code with clip boundaries in registers(?) */
        /* It doesn't pay much to make use of fSorted in this case,
           so we lump everything together. */

        int clipx1, clipx2, clipy1, clipy2;

        clipx1 = pboxBandStart->x1;
        clipy1 = pboxBandStart->y1;
        clipx2 = pboxBandStart->x2;
        clipy2 = pboxBandStart->y2;

        for (; ppt != pptLast; ppt++, pwidth++) {
            y = ppt->y;
            x1 = ppt->x;
            if (clipy1 <= y && y < clipy2) {
                x2 = x1 + *pwidth;
                if (x1 < clipx1)
                    x1 = clipx1;
                if (x2 > clipx2)
                    x2 = clipx2;
                if (x1 < x2) {
                    /* part of span in clip rectangle */
                    pptNew->x = x1;
                    pptNew->y = y;
                    *pwidthNew = x2 - x1;
                    pptNew++;
                    pwidthNew++;
                }
            }
        } /* end for */
    } else if (numRects != 0) {
        /* Have to clip against many boxes */
        pixman_box32_t *pboxBandEnd, *pbox, *pboxLast;
        int clipy1, clipy2;

        /* In this case, taking advantage of sorted spans gains more than
           the sorting costs. */
        if ((! fSorted) && (nspans > 1))
            QuickSortSpans(ppt, pwidth, nspans);

        pboxLast = pboxBandStart + numRects;

        NextBand();

        for (; ppt != pptLast; ) {
            y = ppt->y;
            if (y < clipy2) {
                /* span is in the current band */
                pbox = pboxBandStart;
                x1 = ppt->x;
                x2 = x1 + *pwidth;
                do { /* For each box in band */
                    int newx1, newx2;

                    newx1 = x1;
                    newx2 = x2;
                    if (newx1 < pbox->x1)
                        newx1 = pbox->x1;
                    if (newx2 > pbox->x2)
                        newx2 = pbox->x2;
                    if (newx1 < newx2) {
                        /* Part of span in clip rectangle */
                        pptNew->x = newx1;
                        pptNew->y = y;
                        *pwidthNew = newx2 - newx1;
                        pptNew++;
                        pwidthNew++;
                    }
                    pbox++;
                } while (pbox != pboxBandEnd);
                ppt++;
                pwidth++;
            } else {
                /* Move to next band, adjust ppt as needed */
                pboxBandStart = pboxBandEnd;
                if (pboxBandStart == pboxLast)
                    break; /* We're completely done */
                NextBand();
            }
        }
    }
    return (pwidthNew - pwidthNewStart);
}

```

`devices/display/qxl/canvas/lines.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/***********************************************************

Copyright 1987, 1998  The Open Group

Permission to use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided that
the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation.

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
OPEN GROUP BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Except as contained in this notice, the name of The Open Group shall not be
used in advertising or otherwise to promote the sale, use or other dealings
in this Software without prior written authorization from The Open Group.


Copyright 1987 by Digital Equipment Corporation, Maynard, Massachusetts.

                        All Rights Reserved

Permission to use, copy, modify, and distribute this software and its
documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and that
both that copyright notice and this permission notice appear in
supporting documentation, and that the name of Digital not be
used in advertising or publicity pertaining to distribution of the
software without specific, written prior permission.

DIGITAL DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING
ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL
DIGITAL BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR
ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,
ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS
SOFTWARE.

******************************************************************/

#ifndef H_SPICE_COMMON_LINES
#define H_SPICE_COMMON_LINES

#include <stdlib.h>
#include <string.h>
#include <spice/macros.h>

#include "pixman_utils.h"
#include "draw.h"

SPICE_BEGIN_DECLS

typedef struct lineGC lineGC;

typedef struct {
    void (*FillSpans)(lineGC * pGC,
                      int num_spans, SpicePoint * points, int *widths,
                      int sorted, int foreground);
    void (*FillRects)(lineGC * pGC,
                      int nun_rects, pixman_rectangle32_t * rects,
                      int foreground);
} lineGCOps;

struct lineGC {
    int width;
    int height;
    unsigned char alu;
    unsigned short lineWidth;
    unsigned short dashOffset;
    unsigned short numInDashList;
    unsigned char *dash;
    unsigned int lineStyle:2;
    unsigned int capStyle:2;
    unsigned int joinStyle:2;
    lineGCOps *ops;
};

/* CoordinateMode for drawing routines */

#define CoordModeOrigin         0       /* relative to the origin */
#define CoordModePrevious       1       /* relative to previous point */

/* LineStyle */

#define LineSolid               0
#define LineOnOffDash           1
#define LineDoubleDash          2

/* capStyle */

#define CapNotLast              0
#define CapButt                 1
#define CapRound                2
#define CapProjecting           3

/* joinStyle */

#define JoinMiter               0
#define JoinRound               1
#define JoinBevel               2

extern void spice_canvas_zero_line(lineGC *pgc,
                                   int mode,
                                   int num_points,
                                   SpicePoint * points);
extern void spice_canvas_zero_dash_line(lineGC * pgc,
                                        int mode,
                                        int n_points,
                                        SpicePoint * points);
extern void spice_canvas_wide_dash_line(lineGC * pGC,
                                        int mode,
                                        int num_points,
                                        SpicePoint * points);
extern void spice_canvas_wide_line(lineGC *pGC,
                                   int mode,
                                   int num_points,
                                   SpicePoint * points);
extern int spice_canvas_clip_spans(pixman_region32_t *clip_region,
                                   SpicePoint *points,
                                   int *widths,
                                   int num_spans,
                                   SpicePoint *new_points,
                                   int *new_widths,
                                   int sorted);

SPICE_END_DECLS

#endif // H_SPICE_COMMON_LINES

```

`devices/display/qxl/canvas/log.c`:

```c
/*
   Copyright (C) 2012-2015 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#include "config.h"

#include <glib.h>
#include <stdlib.h>

#include "log.h"

G_GNUC_PRINTF(5, 0)
static void spice_logv(const char *log_domain,
                       GLogLevelFlags log_level,
                       const char *strloc,
                       const char *function,
                       const char *format,
                       va_list args)
{
    GString *log_msg;

    log_msg = g_string_new(NULL);
    if (strloc && function) {
        g_string_append_printf(log_msg, "%s:%s: ", strloc, function);
    }
    if (format) {
        g_string_append_vprintf(log_msg, format, args);
    }
    g_log(log_domain, log_level, "%s", log_msg->str);
    g_string_free(log_msg, TRUE);

    if ((log_level & G_LOG_LEVEL_CRITICAL) != 0) {
        abort();
    }
}

void spice_log(GLogLevelFlags log_level,
               const char *strloc,
               const char *function,
               const char *format,
               ...)
{
    va_list args;

    va_start (args, format);
    spice_logv (G_LOG_DOMAIN, log_level, strloc, function, format, args);
    va_end (args);
}

```

`devices/display/qxl/canvas/log.h`:

```h
/*
   Copyright (C) 2012 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_LOG
#define H_SPICE_COMMON_LOG

#include <stdarg.h>
#include <stdio.h>
#include <glib.h>
#include <spice/macros.h>

#include "macros.h"

SPICE_BEGIN_DECLS

#ifdef SPICE_LOG_DOMAIN
#error Do not use obsolete SPICE_LOG_DOMAIN macro, is currently unused
#endif

#define SPICE_STRLOC  __FILE__ ":" G_STRINGIFY (__LINE__)

void spice_log(GLogLevelFlags log_level,
               const char *strloc,
               const char *function,
               const char *format,
               ...) G_GNUC_PRINTF(4, 5);

/* FIXME: name is misleading, this aborts.. */
#define spice_return_if_fail(x) G_STMT_START {                          \
    if G_LIKELY(x) { } else {                                           \
        spice_critical("condition `%s' failed", #x);                    \
        return;                                                         \
    }                                                                   \
} G_STMT_END

/* FIXME: name is misleading, this aborts.. */
#define spice_return_val_if_fail(x, val) G_STMT_START {                 \
    if G_LIKELY(x) { } else {                                           \
        spice_critical("condition `%s' failed", #x);                    \
        return (val);                                                   \
    }                                                                   \
} G_STMT_END

#define spice_warn_if_reached() G_STMT_START {                          \
    spice_log(G_LOG_LEVEL_WARNING, SPICE_STRLOC, __FUNCTION__, "should not be reached"); \
} G_STMT_END

#define spice_info(...) G_STMT_START {                                  \
    spice_log(G_LOG_LEVEL_INFO, SPICE_STRLOC, __FUNCTION__, "" __VA_ARGS__); \
} G_STMT_END

#define spice_debug(...) G_STMT_START {                                 \
    spice_log(G_LOG_LEVEL_DEBUG, SPICE_STRLOC, __FUNCTION__, "" __VA_ARGS__); \
} G_STMT_END

#define spice_warning(...) G_STMT_START {                               \
    spice_log(G_LOG_LEVEL_WARNING, SPICE_STRLOC, __FUNCTION__, "" __VA_ARGS__); \
} G_STMT_END

#define spice_critical(...) G_STMT_START {                              \
    spice_log(G_LOG_LEVEL_CRITICAL, SPICE_STRLOC, __FUNCTION__, "" __VA_ARGS__); \
    SPICE_UNREACHABLE;                                                  \
} G_STMT_END

#define spice_error(...) G_STMT_START {                                 \
    spice_log(G_LOG_LEVEL_ERROR, SPICE_STRLOC, __FUNCTION__, "" __VA_ARGS__); \
    SPICE_UNREACHABLE;                                                  \
} G_STMT_END

#define spice_warn_if_fail(x) G_STMT_START {            \
    if G_LIKELY(x) { } else {                           \
        spice_warning("condition `%s' failed", #x);     \
    }                                                   \
} G_STMT_END

#define spice_assert(x) G_STMT_START {                  \
    if G_LIKELY(x) { } else {                           \
        spice_error("assertion `%s' failed", #x);       \
    }                                                   \
} G_STMT_END

#if ENABLE_EXTRA_CHECKS
enum { spice_extra_checks = 1 };
#else
enum { spice_extra_checks = 0 };
#endif

#define spice_extra_assert(x) G_STMT_START {            \
    if (!spice_extra_checks || G_LIKELY(x)) { } else {  \
        spice_error("assertion `%s' failed", #x);       \
    }                                                   \
} G_STMT_END

SPICE_END_DECLS

#endif // H_SPICE_COMMON_LOG

```

`devices/display/qxl/canvas/lz.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*

 Copyright (C) 2009 Red Hat, Inc. and/or its affiliates.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.

 This file incorporates work covered by the following copyright and
 permission notice:
   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the "Software"), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

*/
#include "config.h"

#include "lz.h"

#define HASH_LOG 13
#define HASH_SIZE (1 << HASH_LOG)
#define HASH_MASK (HASH_SIZE - 1)

/* Maximum image size, mainly to avoid possible integer overflows */
#define SPICE_MAX_IMAGE_SIZE (1024 * 1024 * 1024 - 1)

typedef struct LzImageSegment LzImageSegment;
struct LzImageSegment {
    uint8_t            *lines;
    uint8_t            *lines_end;
    unsigned int size_delta;    // total size of the previous segments in units of
                                // pixels for rgb and bytes for plt.
    LzImageSegment    *next;
};

//    TODO: pack?
typedef struct HashEntry {
    LzImageSegment    *image_seg;
    uint8_t            *ref;
} HashEntry;

typedef struct Encoder {
    LzUsrContext    *usr;

    LzImageType type;
    const SpicePalette    *palette;    // for decoding images with palettes to rgb
    int stride;                       // stride is in bytes. For rgb must be equal to
                                      // width*bytes_per_pix.
    // For palettes stride can be bigger than width/pixels_per_byte by 1 only if
    // width%pixels_per_byte != 0.
    int height;
    int width;                       // the original width (in pixels)

    LzImageSegment *head_image_segs;
    LzImageSegment *tail_image_segs;
    LzImageSegment *free_image_segs;

    // the dictionary hash table is composed (1) a pointer to the segment the word was found in
    // (2) a pointer to the first byte in the segment that matches the word
    HashEntry htab[HASH_SIZE];

    uint8_t            *io_now;
    uint8_t            *io_end;
    size_t io_bytes_count;

    uint8_t            *io_last_copy;  // pointer to the last byte in which copy count was written
} Encoder;

/****************************************************/
/* functions for managing the pool of image segments*/
/****************************************************/
static inline LzImageSegment *lz_alloc_image_seg(Encoder *encoder);
static void lz_reset_image_seg(Encoder *encoder);
static int lz_read_image_segments(Encoder *encoder, uint8_t *first_lines,
                                  unsigned int num_first_lines);


// return a free image segment if one exists. Make allocation if needed. adds it to the
// tail of the image segments lists
static inline LzImageSegment *lz_alloc_image_seg(Encoder *encoder)
{
    LzImageSegment *ret;

    if (encoder->free_image_segs) {
        ret = encoder->free_image_segs;
        encoder->free_image_segs = ret->next;
    } else {
        if (!(ret = (LzImageSegment *)encoder->usr->malloc(encoder->usr, sizeof(*ret)))) {
            return NULL;
        }
    }

    ret->next = NULL;
    if (encoder->tail_image_segs) {
        encoder->tail_image_segs->next = ret;
    }
    encoder->tail_image_segs = ret;

    if (!encoder->head_image_segs) {
        encoder->head_image_segs = ret;
    }

    return ret;
}

// adding seg to the head of free segments (lz_reset_image_seg removes it from used ones)
static inline void __lz_free_image_seg(Encoder *encoder, LzImageSegment *seg)
{
    seg->next = encoder->free_image_segs;
    encoder->free_image_segs = seg;
}

// moves all the used image segments to the free pool
static void lz_reset_image_seg(Encoder *encoder)
{
    while (encoder->head_image_segs) {
        LzImageSegment *seg = encoder->head_image_segs;
        encoder->head_image_segs = seg->next;
        __lz_free_image_seg(encoder, seg);
    }
    encoder->tail_image_segs = NULL;
}

static void lz_dealloc_free_segments(Encoder *encoder)
{
    while (encoder->free_image_segs) {
        LzImageSegment *seg = encoder->free_image_segs;
        encoder->free_image_segs = seg->next;
        encoder->usr->free(encoder->usr, seg);
    }
}

// return FALSE when operation fails (due to failure in allocation)
static int lz_read_image_segments(Encoder *encoder, uint8_t *first_lines,
                                  unsigned int num_first_lines)
{
    LzImageSegment *image_seg;
    uint32_t size_delta = 0;
    unsigned int num_lines = num_first_lines;
    uint8_t* lines = first_lines;
    int row;

    spice_return_val_if_fail(!encoder->head_image_segs, FALSE);

    image_seg = lz_alloc_image_seg(encoder);
    if (!image_seg) {
        goto error_1;
    }

    image_seg->lines = lines;
    image_seg->lines_end = lines + num_lines * encoder->stride;
    image_seg->size_delta = size_delta;

    size_delta += num_lines * encoder->stride / RGB_BYTES_PER_PIXEL[encoder->type];

    for (row = num_first_lines; row < encoder->height; row += num_lines) {
        num_lines = encoder->usr->more_lines(encoder->usr, &lines);
        if (num_lines <= 0) {
            encoder->usr->error(encoder->usr, "more lines failed\n");
        }
        image_seg = lz_alloc_image_seg(encoder);

        if (!image_seg) {
            goto error_1;
        }

        image_seg->lines = lines;
        image_seg->lines_end = lines + num_lines * encoder->stride;
        image_seg->size_delta = size_delta;

        size_delta += num_lines * encoder->stride / RGB_BYTES_PER_PIXEL[encoder->type];
    }

    return TRUE;
error_1:
    lz_reset_image_seg(encoder);
    return FALSE;
}

/**************************************************************************
* Handling encoding and decoding of a byte
***************************************************************************/
static inline int more_io_bytes(Encoder *encoder)
{
    uint8_t *io_ptr;
    int num_io_bytes = encoder->usr->more_space(encoder->usr, &io_ptr);
    encoder->io_bytes_count += num_io_bytes;
    encoder->io_now = io_ptr;
    encoder->io_end = encoder->io_now + num_io_bytes;
    return num_io_bytes;
}

static inline void encode(Encoder *encoder, uint8_t byte)
{
    if (encoder->io_now == encoder->io_end) {
        if (more_io_bytes(encoder) <= 0) {
            encoder->usr->error(encoder->usr, "%s: no more bytes\n", __FUNCTION__);
        }
        spice_return_if_fail(encoder->io_now);
    }

    spice_return_if_fail(encoder->io_now < encoder->io_end);
    *(encoder->io_now++) = byte;
}

static inline void encode_32(Encoder *encoder, unsigned int word)
{
    encode(encoder, (uint8_t)(word >> 24));
    encode(encoder, (uint8_t)(word >> 16) & 0x0000ff);
    encode(encoder, (uint8_t)(word >> 8) & 0x0000ff);
    encode(encoder, (uint8_t)(word & 0x0000ff));
}

static inline void encode_copy_count(Encoder *encoder, uint8_t copy_count)
{
    encode(encoder, copy_count);
    encoder->io_last_copy = encoder->io_now - 1; // io_now cannot be the first byte of the buffer
}

static inline void update_copy_count(Encoder *encoder, uint8_t copy_count)
{
    spice_return_if_fail(encoder->io_last_copy);
    *(encoder->io_last_copy) = copy_count;
}

// decrease the io ptr by 1
static inline void compress_output_prev(Encoder *encoder)
{
    // io_now cannot be the first byte of the buffer
    encoder->io_now--;
    // the function should be called only when copy count is written unnecessarily by lz_compress
    spice_return_if_fail(encoder->io_now == encoder->io_last_copy);
}

static int encoder_reset(Encoder *encoder, uint8_t *io_ptr, uint8_t *io_ptr_end)
{
    spice_return_val_if_fail(io_ptr <= io_ptr_end, FALSE);

    encoder->io_bytes_count = io_ptr_end - io_ptr;
    encoder->io_now = io_ptr;
    encoder->io_end = io_ptr_end;
    encoder->io_last_copy = NULL;

    return TRUE;
}

static inline uint8_t decode(Encoder *encoder)
{
    if (encoder->io_now == encoder->io_end) {
        int num_io_bytes = more_io_bytes(encoder);
        if (num_io_bytes <= 0) {
            encoder->usr->error(encoder->usr, "%s: no more bytes\n", __FUNCTION__);
        }
        spice_assert(encoder->io_now);
    }
    spice_assert(encoder->io_now < encoder->io_end);
    return *(encoder->io_now++);
}

static inline uint32_t decode_32(Encoder *encoder)
{
    uint32_t word = 0;
    word |= decode(encoder);
    word <<= 8;
    word |= decode(encoder);
    word <<= 8;
    word |= decode(encoder);
    word <<= 8;
    word |= decode(encoder);
    return word;
}

static inline int is_io_to_decode_end(Encoder *encoder)
{
    if (encoder->io_now != encoder->io_end) {
        return FALSE;
    } else {
        int num_io_bytes = more_io_bytes(encoder); //disable inline optimizations
        return (num_io_bytes <= 0);
    }
}

/*******************************************************************
* intialization and finalization of lz
********************************************************************/
static int init_encoder(Encoder *encoder, LzUsrContext *usr)
{
    encoder->usr = usr;
    encoder->free_image_segs = NULL;
    encoder->head_image_segs = NULL;
    encoder->tail_image_segs = NULL;
    return TRUE;
}

LzContext *lz_create(LzUsrContext *usr)
{
    Encoder *encoder;

    if (!usr || !usr->error || !usr->warn || !usr->info || !usr->malloc ||
        !usr->free || !usr->more_space || !usr->more_lines) {
        return NULL;
    }

    if (!(encoder = (Encoder *)usr->malloc(usr, sizeof(Encoder)))) {
        return NULL;
    }

    if (!init_encoder(encoder, usr)) {
        usr->free(usr, encoder);
        return NULL;
    }
    return (LzContext *)encoder;
}

void lz_destroy(LzContext *lz)
{
    Encoder *encoder = (Encoder *)lz;

    if (!lz) {
        return;
    }

    if (encoder->head_image_segs) {
        encoder->usr->error(encoder->usr, "%s: used_image_segments not empty\n", __FUNCTION__);
        lz_reset_image_seg(encoder);
    }
    lz_dealloc_free_segments(encoder);

    encoder->usr->free(encoder->usr, encoder);
}

/*******************************************************************
*                encoding and decoding the image
********************************************************************/
/*
 * Give hints to the compiler for branch prediction optimization.
 */
#if defined(__GNUC__) && (__GNUC__ > 2)
#define LZ_EXPECT_CONDITIONAL(c) (__builtin_expect((c), 1))
#define LZ_UNEXPECT_CONDITIONAL(c) (__builtin_expect((c), 0))
#else
#define LZ_EXPECT_CONDITIONAL(c) (c)
#define LZ_UNEXPECT_CONDITIONAL(c) (c)
#endif


#include <spice/start-packed.h>

/* the palette images will be treated as one byte pixels. Their width should be transformed
   accordingly.
*/
typedef struct SPICE_ATTR_PACKED one_byte_pixel_t {
    uint8_t a;
} one_byte_pixel_t;

typedef struct SPICE_ATTR_PACKED rgb32_pixel_t {
    uint8_t b;
    uint8_t g;
    uint8_t r;
    uint8_t pad;
} rgb32_pixel_t;

typedef struct SPICE_ATTR_PACKED rgb24_pixel_t {
    uint8_t b;
    uint8_t g;
    uint8_t r;
} rgb24_pixel_t;

typedef uint16_t rgb16_pixel_t;

#include <spice/end-packed.h>


#define MAX_COPY 32
#define MAX_LEN 264          /* 256 + 8 */
#define BOUND_OFFSET 2
#define LIMIT_OFFSET 6
#define MIN_FILE_SIZE 4
#define COMP_LEVEL_SIZE_LIMIT 65536

// TODO: implemented lz2. should lz1 be an option (no RLE + distance limitation of MAX_DISTANCE)
// TODO: I think MAX_FARDISTANCE can be changed easily to 2^29
//       (and maybe even more when pixel > byte).
// i.e. we can support 512M Bytes/Pixels distance instead of only ~68K.
#define MAX_DISTANCE 8191                        // 2^13
#define MAX_FARDISTANCE (65535 + MAX_DISTANCE - 1)    // ~2^16+2^13


#define LZ_PLT
#include "lz_compress_tmpl.c"
#define LZ_PLT
#include "lz_decompress_tmpl.c"

#define LZ_PLT
#define PLT8
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_PLT
#define PLT4_BE
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_PLT
#define PLT4_LE
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_PLT
#define PLT1_BE
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_PLT
#define PLT1_LE
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_A8
#include "lz_compress_tmpl.c"
#define LZ_A8
#include "lz_decompress_tmpl.c"
#define LZ_A8
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_RGB16
#include "lz_compress_tmpl.c"
#define LZ_RGB16
#include "lz_decompress_tmpl.c"
#define LZ_RGB16
#define TO_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_RGB24
#include "lz_compress_tmpl.c"
#define LZ_RGB24
#include "lz_decompress_tmpl.c"


#define LZ_RGB32
#include "lz_compress_tmpl.c"
#define LZ_RGB32
#include "lz_decompress_tmpl.c"

#define LZ_RGB_ALPHA
#include "lz_compress_tmpl.c"
#define LZ_RGB_ALPHA
#include "lz_decompress_tmpl.c"

#undef LZ_UNEXPECT_CONDITIONAL
#undef LZ_EXPECT_CONDITIONAL

static void lz_set_sizes(Encoder *encoder, int type, int width, int height, int stride)
{
    if (width < 0) {
        encoder->usr->error(encoder->usr, "invalid lz width %d\n", width);
    }
    if (height < 0) {
        encoder->usr->error(encoder->usr, "invalid lz height %d\n", height);
    }
    if (stride < 0) {
        encoder->usr->error(encoder->usr, "invalid lz stride %d\n", stride);
    }

    if (IS_IMAGE_TYPE_PLT[type]) {
        if (stride > (width / PLT_PIXELS_PER_BYTE[type])) {
            if (((width % PLT_PIXELS_PER_BYTE[type]) == 0) || (
                    (stride - (width / PLT_PIXELS_PER_BYTE[type])) > 1)) {
                encoder->usr->error(encoder->usr, "stride overflows (plt)\n");
            }
        }
    } else {
        if (stride != width * RGB_BYTES_PER_PIXEL[type]) {
            encoder->usr->error(encoder->usr, "stride != width*bytes_per_pixel (rgb) %d != %d * %d (%d)\n",
                                stride, width, RGB_BYTES_PER_PIXEL[type],
                                type);
        }
    }

    // avoid too big images
    if ((uint64_t) stride * height > SPICE_MAX_IMAGE_SIZE) {
        encoder->usr->error(encoder->usr, "image too large\n");
    }

    encoder->type = type;
    encoder->width = width;
    encoder->height = height;
    encoder->stride = stride;
}

int lz_encode(LzContext *lz, LzImageType type, int width, int height, int top_down,
              uint8_t *lines, unsigned int num_lines, int stride,
              uint8_t *io_ptr, unsigned int num_io_bytes)
{
    Encoder *encoder = (Encoder *)lz;
    uint8_t *io_ptr_end = io_ptr + num_io_bytes;

    lz_set_sizes(encoder, type, width, height, stride);

    // assign the output buffer
    if (!encoder_reset(encoder, io_ptr, io_ptr_end)) {
        encoder->usr->error(encoder->usr, "lz encoder io reset failed\n");
    }

    // first read the list of the image segments
    if (!lz_read_image_segments(encoder, lines, num_lines)) {
        encoder->usr->error(encoder->usr, "lz encoder reading image segments failed\n");
    }

    encode_32(encoder, LZ_MAGIC);
    encode_32(encoder, LZ_VERSION);
    encode_32(encoder, type);
    encode_32(encoder, width);
    encode_32(encoder, height);
    encode_32(encoder, stride);
    encode_32(encoder, top_down); // TODO: maybe compress type and top_down to one byte

    switch (encoder->type) {
    case LZ_IMAGE_TYPE_PLT1_BE:
    case LZ_IMAGE_TYPE_PLT1_LE:
    case LZ_IMAGE_TYPE_PLT4_BE:
    case LZ_IMAGE_TYPE_PLT4_LE:
    case LZ_IMAGE_TYPE_PLT8:
        lz_plt_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_RGB16:
        lz_rgb16_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_RGB24:
        lz_rgb24_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_RGB32:
        lz_rgb32_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_RGBA:
        lz_rgb32_compress(encoder);
        lz_rgb_alpha_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_XXXA:
        lz_rgb_alpha_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_A8:
        lz_a8_compress(encoder);
        break;
    case LZ_IMAGE_TYPE_INVALID:
    default:
        encoder->usr->error(encoder->usr, "bad image type\n");
    }

    // move all the used segments to the free ones
    lz_reset_image_seg(encoder);

    encoder->io_bytes_count -= (encoder->io_end - encoder->io_now);

    return encoder->io_bytes_count;
}

/*
    initialize and read lz magic
*/
void lz_decode_begin(LzContext *lz, uint8_t *io_ptr, unsigned int num_io_bytes,
                     LzImageType *out_type, int *out_width, int *out_height,
                     int *out_n_pixels, int *out_top_down, const SpicePalette *palette)
{
    Encoder *encoder = (Encoder *)lz;
    uint8_t *io_ptr_end = io_ptr + num_io_bytes;
    uint32_t magic;
    uint32_t version;

    if (!encoder_reset(encoder, io_ptr, io_ptr_end)) {
        encoder->usr->error(encoder->usr, "io reset failed");
    }

    magic = decode_32(encoder);
    if (magic != LZ_MAGIC) {
        encoder->usr->error(encoder->usr, "bad magic\n");
    }

    version = decode_32(encoder);
    if (version != LZ_VERSION) {
        encoder->usr->error(encoder->usr, "bad version\n");
    }

    int type = decode_32(encoder);
    if (type <= LZ_IMAGE_TYPE_INVALID || type > LZ_IMAGE_TYPE_A8) {
        encoder->usr->error(encoder->usr, "invalid lz type %d\n", type);
    }
    int width = decode_32(encoder);
    int height = decode_32(encoder);
    int stride = decode_32(encoder);
    lz_set_sizes(encoder, type, width, height, stride);

    *out_top_down = decode_32(encoder);

    *out_width = encoder->width;
    *out_height = encoder->height;
//    *out_stride = encoder->stride;
    *out_type = encoder->type;

    // TODO: maybe instead of stride we can encode out_n_pixels
    //       (if stride is not necessary in decoding).
    if (IS_IMAGE_TYPE_PLT[encoder->type]) {
        encoder->palette = palette;
        *out_n_pixels = encoder->stride * PLT_PIXELS_PER_BYTE[encoder->type] * encoder->height;
    } else {
        *out_n_pixels = encoder->width * encoder->height;
    }
}

void lz_decode(LzContext *lz, LzImageType to_type, uint8_t *buf)
{
    Encoder *encoder = (Encoder *)lz;
    size_t out_size = 0;
    size_t alpha_size = 0;
    size_t size = 0;
    if (IS_IMAGE_TYPE_PLT[encoder->type]) {
        if (to_type == encoder->type) {
            size = encoder->height * encoder->stride;
            out_size = lz_plt_decompress(encoder, (one_byte_pixel_t *)buf, size);
        } else if (to_type == LZ_IMAGE_TYPE_RGB32) {
            size = encoder->height * encoder->stride * PLT_PIXELS_PER_BYTE[encoder->type];
            if (!encoder->palette) {
                encoder->usr->error(encoder->usr,
                                    "a palette is missing (for bpp to rgb decoding)\n");
                return;
            }
            switch (encoder->type) {
            case LZ_IMAGE_TYPE_PLT1_BE:
                out_size = lz_plt1_be_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                break;
            case LZ_IMAGE_TYPE_PLT1_LE:
                out_size = lz_plt1_le_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                break;
            case LZ_IMAGE_TYPE_PLT4_BE:
                out_size = lz_plt4_be_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                break;
            case LZ_IMAGE_TYPE_PLT4_LE:
                out_size = lz_plt4_le_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                break;
            case LZ_IMAGE_TYPE_PLT8:
                out_size = lz_plt8_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                break;
            case LZ_IMAGE_TYPE_RGB16:
            case LZ_IMAGE_TYPE_RGB24:
            case LZ_IMAGE_TYPE_RGB32:
            case LZ_IMAGE_TYPE_RGBA:
            case LZ_IMAGE_TYPE_XXXA:
            case LZ_IMAGE_TYPE_INVALID:
            default:
                encoder->usr->error(encoder->usr, "bad image type\n");
            }
        } else {
            encoder->usr->error(encoder->usr, "unsupported output format\n");
        }
    } else {
        size = encoder->height * encoder->width;
        switch (encoder->type) {
        case LZ_IMAGE_TYPE_RGB16:
            if (encoder->type == to_type) {
                out_size = lz_rgb16_decompress(encoder, (rgb16_pixel_t *)buf, size);
            } else if (to_type == LZ_IMAGE_TYPE_RGB32) {
                out_size = lz_rgb16_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_RGB24:
            if (encoder->type == to_type) {
                out_size = lz_rgb24_decompress(encoder, (rgb24_pixel_t *)buf, size);
            } else if (to_type == LZ_IMAGE_TYPE_RGB32) {
                out_size = lz_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_RGB32:
            if (encoder->type == to_type) {
                out_size = lz_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_RGBA:
            if (encoder->type == to_type) {
                out_size = lz_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                alpha_size = lz_rgb_alpha_decompress(encoder, (rgb32_pixel_t *)buf, size);
                spice_assert(alpha_size == size);
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_XXXA:
            if (encoder->type == to_type) {
                alpha_size = lz_rgb_alpha_decompress(encoder, (rgb32_pixel_t *)buf, size);
                out_size = alpha_size;
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_A8:
            if (encoder->type == to_type) {
                alpha_size = lz_a8_decompress(encoder, (one_byte_pixel_t *)buf, size);
                out_size = alpha_size;
            } else if (to_type == LZ_IMAGE_TYPE_RGB32) {
                alpha_size = lz_a8_to_rgb32_decompress(encoder, (rgb32_pixel_t *)buf, size);
                out_size = alpha_size;
            } else {
                encoder->usr->error(encoder->usr, "unsupported output format\n");
            }
            break;
        case LZ_IMAGE_TYPE_PLT1_LE:
        case LZ_IMAGE_TYPE_PLT1_BE:
        case LZ_IMAGE_TYPE_PLT4_LE:
        case LZ_IMAGE_TYPE_PLT4_BE:
        case LZ_IMAGE_TYPE_PLT8:
        case LZ_IMAGE_TYPE_INVALID:
        default:
            encoder->usr->error(encoder->usr, "bad image type\n");
        }
    }

    spice_assert(is_io_to_decode_end(encoder));
    spice_assert(out_size == size);

    if (out_size != size) {
        encoder->usr->error(encoder->usr, "bad decode size\n");
    }
}

```

`devices/display/qxl/canvas/lz.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
        dictionary compression for images based on fastlz (http://www.fastlz.org/)
        (Distributed under MIT license).
*/
#ifndef H_SPICE_COMMON_LZ
#define H_SPICE_COMMON_LZ

#include <spice/macros.h>

#include "lz_common.h"
#include "lz_config.h"
#include "draw.h"
#include "macros.h"

SPICE_BEGIN_DECLS

typedef void *LzContext;

typedef struct LzUsrContext LzUsrContext;
struct LzUsrContext {
    SPICE_GNUC_NORETURN
    SPICE_GNUC_PRINTF(2, 3) void (*error)(LzUsrContext *usr, const char *fmt, ...);
    SPICE_GNUC_PRINTF(2, 3) void (*warn)(LzUsrContext *usr, const char *fmt, ...);
    SPICE_GNUC_PRINTF(2, 3) void (*info)(LzUsrContext *usr, const char *fmt, ...);
    void    *(*malloc)(LzUsrContext *usr, int size);
    void (*free)(LzUsrContext *usr, void *ptr);
    int (*more_space)(LzUsrContext *usr, uint8_t **io_ptr);     // get the next chunk of the
                                                                // compressed buffer. return
                                                                // number of bytes in the chunk.
    int (*more_lines)(LzUsrContext *usr, uint8_t **lines);      // get the next chunk of the
                                                                // original image. If the image
                                                                // is down to top, return it from
                                                                // the last line to the first one
                                                                // (stride should always be
                                                                // positive)
};

/*
        assumes width is in pixels and stride is in bytes
        return: the number of bytes in the compressed data

        TODO :	determine size limit for the first segment and each chunk. check validity
                        of the segment or go to literal copy.
        TODO :	currently support only rgb images in which width*bytes_per_pixel = stride OR
                        palette images in which stride equals the min number of bytes to
                        hold a line. stride is not necessary for now. just for sanity check.
                        stride should be > 0
*/
int lz_encode(LzContext *lz, LzImageType type, int width, int height, int top_down,
              uint8_t *lines, unsigned int num_lines, int stride,
              uint8_t *io_ptr, unsigned int num_io_bytes);

/*
        prepare encoder and read lz magic.
        out_n_pixels number of compressed pixels. May differ from Width*height in plt1/4.
        Use it for allocation the decompressed buffer.

*/
void lz_decode_begin(LzContext *lz, uint8_t *io_ptr, unsigned int num_io_bytes,
                     LzImageType *out_type, int *out_width, int *out_height,
                     int *out_n_pixels, int *out_top_down, const SpicePalette *palette);

/*
        to_type = the image output type.
        We assume the buffer is consecutive. i.e. width = stride

        Important: if the image is plt1/4 and to_type is rgb32, the image
        will decompressed including the last bits in each line. This means buffer should be
        larger than width*height if needed and you should use stride to fix it.
        Note: If the image is down to top, set the stride in the sw surface to negative.
        use alloc_lz_image_surface create the surface.
*/
void lz_decode(LzContext *lz, LzImageType to_type, uint8_t *buf);

LzContext *lz_create(LzUsrContext *usr);

void lz_destroy(LzContext *lz);

SPICE_END_DECLS

#endif // H_SPICE_COMMON_LZ

```

`devices/display/qxl/canvas/lz_common.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software

   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/

/*common header for encoder and decoder*/

#ifndef H_SPICE_COMMON_LZ_COMMON
#define H_SPICE_COMMON_LZ_COMMON

#include <spice/macros.h>
#include "verify.h"

SPICE_BEGIN_DECLS

/* change the max window size will require change in the encoding format*/
#define LZ_MAX_WINDOW_SIZE (1 << 25)
#define MAX_COPY 32

typedef enum {
    LZ_IMAGE_TYPE_INVALID,
    LZ_IMAGE_TYPE_PLT1_LE,
    LZ_IMAGE_TYPE_PLT1_BE,      // PLT stands for palette
    LZ_IMAGE_TYPE_PLT4_LE,
    LZ_IMAGE_TYPE_PLT4_BE,
    LZ_IMAGE_TYPE_PLT8,
    LZ_IMAGE_TYPE_RGB16,
    LZ_IMAGE_TYPE_RGB24,
    LZ_IMAGE_TYPE_RGB32,
    LZ_IMAGE_TYPE_RGBA,
    LZ_IMAGE_TYPE_XXXA,
    LZ_IMAGE_TYPE_A8
} LzImageType;

#define LZ_IMAGE_TYPE_MASK 0x0f
#define LZ_IMAGE_TYPE_LOG 4 // number of bits required for coding the image type

/* access to the arrays is based on the image types */
static const int IS_IMAGE_TYPE_PLT[] = {0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0};
static const int IS_IMAGE_TYPE_RGB[] = {0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1};
static const int PLT_PIXELS_PER_BYTE[] = {0, 8, 8, 2, 2, 1};
static const int RGB_BYTES_PER_PIXEL[] = {0, 1, 1, 1, 1, 1, 2, 3, 4, 4, 4, 1};

verify(SPICE_N_ELEMENTS(IS_IMAGE_TYPE_PLT) == (LZ_IMAGE_TYPE_A8 + 1));
verify(SPICE_N_ELEMENTS(IS_IMAGE_TYPE_RGB) == (LZ_IMAGE_TYPE_A8 + 1));
verify(SPICE_N_ELEMENTS(PLT_PIXELS_PER_BYTE) == (LZ_IMAGE_TYPE_PLT8 + 1));
verify(SPICE_N_ELEMENTS(RGB_BYTES_PER_PIXEL) == (LZ_IMAGE_TYPE_A8 + 1));

/* ASCII "LZ  " */
#define LZ_MAGIC 0x20205a4c
#define LZ_VERSION_MAJOR 1U
#define LZ_VERSION_MINOR 1U
#define LZ_VERSION ((LZ_VERSION_MAJOR << 16) | (LZ_VERSION_MINOR & 0xffff))

SPICE_END_DECLS

#endif // H_SPICE_COMMON_LZ_COMMON

```

`devices/display/qxl/canvas/lz_compress_tmpl.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*

 Copyright (C) 2009 Red Hat, Inc. and/or its affiliates.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

 This file incorporates work covered by the following copyright and
 permission notice:
   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the "Software"), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

*/
#include "config.h"

#define DJB2_START 5381
#define DJB2_HASH(hash, c) (hash = ((hash << 5) + hash) ^ (c)) //|{hash = ((hash << 5) + hash) + c;}

/*
    For each pixel type the following macros are defined:
    PIXEL                         : input type
    FNAME(name)
    ENCODE_PIXEL(encoder, pixel) : writing a pixel to the compressed buffer (byte by byte)
    SAME_PIXEL(pix1, pix2)         : comparing two pixels
    HASH_FUNC(value, pix_ptr)    : hash func of 3 consecutive pixels
*/

#ifdef LZ_PLT
#define PIXEL one_byte_pixel_t
#define FNAME(name) lz_plt_##name
#define ENCODE_PIXEL(e, pix) encode(e, (pix).a)   // gets the pixel and write only the needed bytes
                                                  // from the pixel
#define SAME_PIXEL(pix1, pix2) ((pix1).a == (pix2).a)
#define HASH_FUNC(v, p) {  \
    v = DJB2_START;        \
    DJB2_HASH(v, p[0].a);  \
    DJB2_HASH(v, p[1].a);  \
    DJB2_HASH(v, p[2].a);  \
    v &= HASH_MASK;        \
    }
#endif

#ifdef LZ_A8
#define PIXEL one_byte_pixel_t
#define FNAME(name) lz_a8_##name
#define ENCODE_PIXEL(e, pix) encode(e, (pix).a)   // gets the pixel and write only the needed bytes
                                                  // from the pixel
#define SAME_PIXEL(pix1, pix2) ((pix1).a == (pix2).a)
#define HASH_FUNC(v, p) {  \
    v = DJB2_START;        \
    DJB2_HASH(v, p[0].a);  \
    DJB2_HASH(v, p[1].a);  \
    DJB2_HASH(v, p[2].a);  \
    v &= HASH_MASK;        \
    }
#endif

#ifdef LZ_RGB_ALPHA
//#undef LZ_RGB_ALPHA
#define PIXEL rgb32_pixel_t
#define FNAME(name) lz_rgb_alpha_##name
#define ENCODE_PIXEL(e, pix) {encode(e, (pix).pad);}
#define SAME_PIXEL(pix1, pix2) ((pix1).pad == (pix2).pad)
#define HASH_FUNC(v, p) {    \
    v = DJB2_START;          \
    DJB2_HASH(v, p[0].pad);  \
    DJB2_HASH(v, p[1].pad);  \
    DJB2_HASH(v, p[2].pad);  \
    v &= HASH_MASK;          \
    }
#endif


#ifdef LZ_RGB16
#define PIXEL rgb16_pixel_t
#define FNAME(name) lz_rgb16_##name
#define GET_rgb(pix) ((pix) & 0x7fffu)
#define SAME_PIXEL(p1, p2) (GET_rgb(p1) == GET_rgb(p2))
#define ENCODE_PIXEL(e, pix) {encode(e, (pix) >> 8); encode(e, (pix) & 0xff);}

#define HASH_FUNC(v, p) {                 \
    v = DJB2_START;                       \
    DJB2_HASH(v, p[0] & (0x00ff));        \
    DJB2_HASH(v, (p[0] >> 8) & (0x007f)); \
    DJB2_HASH(v, p[1]&(0x00ff));          \
    DJB2_HASH(v, (p[1] >> 8) & (0x007f)); \
    DJB2_HASH(v, p[2] & (0x00ff));        \
    DJB2_HASH(v, (p[2] >> 8) & (0x007f)); \
    v &= HASH_MASK;                       \
}
#endif

#ifdef LZ_RGB24
#define PIXEL rgb24_pixel_t
#define FNAME(name) lz_rgb24_##name
#endif

#ifdef LZ_RGB32
#define PIXEL rgb32_pixel_t
#define FNAME(name) lz_rgb32_##name
#endif


#if  defined(LZ_RGB24) || defined(LZ_RGB32)
#define ENCODE_PIXEL(e, pix) {encode(e, (pix).b); encode(e, (pix).g); encode(e, (pix).r);}
#define SAME_PIXEL(p1, p2) ((p1).r == (p2).r && (p1).g == (p2).g && (p1).b == (p2).b)
#define HASH_FUNC(v, p) {    \
    v = DJB2_START;          \
    DJB2_HASH(v, p[0].r);    \
    DJB2_HASH(v, p[0].g);    \
    DJB2_HASH(v, p[0].b);    \
    DJB2_HASH(v, p[1].r);    \
    DJB2_HASH(v, p[1].g);    \
    DJB2_HASH(v, p[1].b);    \
    DJB2_HASH(v, p[2].r);    \
    DJB2_HASH(v, p[2].g);    \
    DJB2_HASH(v, p[2].b);    \
    v &= HASH_MASK;          \
    }
#endif

#define PIXEL_ID(pix_ptr, seg_ptr) (pix_ptr - ((PIXEL *)seg_ptr->lines) + seg_ptr->size_delta)

// when encoding, the ref can be in previous segment, and we should check that it doesn't
// exceeds its bounds.
// TODO: optimization: when only one chunk exists or when the reference is in the same segment,
//       don't make checks if we reach end of segments
// TODO: optimize to continue match between segments?
// TODO: check hash function
// TODO: check times

/* compresses one segment starting from 'from'.*/
static void FNAME(compress_seg)(Encoder *encoder, LzImageSegment *seg, PIXEL *from, int copied)
{
    const PIXEL *ip = from;
    const PIXEL *ip_bound = (PIXEL *)(seg->lines_end) - BOUND_OFFSET;
    const PIXEL *ip_limit = (PIXEL *)(seg->lines_end) - LIMIT_OFFSET;
    HashEntry    *hslot;
    int hval;
    int copy = copied;

    if (copy == 0) {
        encode_copy_count(encoder, MAX_COPY - 1);
    }


    while (LZ_EXPECT_CONDITIONAL(ip < ip_limit)) {   // TODO: maybe change ip_limit and enabling
                                                     //       moving to the next seg
        const PIXEL            *ref;
        const PIXEL            *ref_limit;
        size_t distance;

        /* minimum match length */
#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_A8)
        size_t len = 3;
#elif defined(LZ_RGB16)
        size_t len = 2;
#else
        size_t len = 1;
#endif
        /* comparison starting-point */
        const PIXEL            *anchor = ip;



        // TODO: RLE without checking if not first byte.
        // TODO: optimize comparisons

        /* check for a run */ // TODO for RGB we can use less pixels
        if (LZ_EXPECT_CONDITIONAL(ip > (PIXEL *)(seg->lines))) {
            if (SAME_PIXEL(ip[-1], ip[0]) && SAME_PIXEL(ip[0], ip[1]) && SAME_PIXEL(ip[1], ip[2])) {
                distance = 1;
                ip += 3;
                ref = anchor + 2;
                ref_limit = (PIXEL *)(seg->lines_end);

                goto match;
            }
        }

        /* find potential match */
        HASH_FUNC(hval, ip);
        hslot = encoder->htab + hval;
        ref = (PIXEL *)(hslot->ref);
        ref_limit = (PIXEL *)(hslot->image_seg->lines_end);

        /* calculate distance to the match */
        distance = PIXEL_ID(anchor, seg) - PIXEL_ID(ref, hslot->image_seg);

        /* update hash table */
        hslot->image_seg = seg;
        hslot->ref = (uint8_t *)anchor;

        /* is this a match? check the first 3 pixels */
        if (distance == 0 || (distance >= MAX_FARDISTANCE)) {
            goto literal;
        }
        /* check if the hval key identical*/
        // no need to check ref limit here because the word size in the htab is 3 pixels
        if (!SAME_PIXEL(*ref, *ip)) {
            ref++;
            ip++;
            goto literal;
        }
        ref++;
        ip++;

        /* minimum match length for rgb16 is 2 and for plt and alpha is 3 */
#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_RGB16) || defined(LZ_A8)
        if (!SAME_PIXEL(*ref, *ip)) {
            ref++;
            ip++;
            goto literal;
        }
        ref++;
        ip++;
#endif

#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_A8)
        if (!SAME_PIXEL(*ref, *ip)) {
            ref++;
            ip++;
            goto literal;
        }
        ref++;
        ip++;
#endif
        /* far, needs at least 5-byte match */
        if (distance >= MAX_DISTANCE) {
#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_A8)
            if (ref >= (ref_limit - 1)) {
                goto literal;
            }
#else
            if (ref > (ref_limit - 1)) {
                goto literal;
            }
#endif
            if (!SAME_PIXEL(*ref, *ip)) {
                ref++;
                ip++;
                goto literal;
            }
            ref++;
            ip++;
            len++;
#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_A8)
            if (!SAME_PIXEL(*ref, *ip)) {
                ref++;
                ip++;
                goto literal;
            }
            ref++;
            ip++;
            len++;
#endif
        }
match:        // RLE or dictionary (both are encoded by distance from ref (-1) and length)

        /* distance is biased */
        distance--;

        // ip is located now at the position of the second mismatch.
        // later it will be subtracted by 3

        if (!distance) {
            /* zero distance means a run */
            PIXEL x = *ref;
            while ((ip < ip_bound) && (ref < ref_limit)) { // TODO: maybe separate a run from
                                                           //       the same seg or from different
                                                           //       ones in order to spare
                                                           //       ref < ref_limit
                if (!SAME_PIXEL(*ref, x)) {
                    ref++;
                    break;
                } else {
                    ref++;
                    ip++;
                }
            }
        } else {
            // TODO: maybe separate a run from the same seg or from different ones in order
            //       to spare ref < ref_limit and that way we can also perform 8 calls of
            //       (ref++ != ip++) outside a loop
            while ((ip < ip_bound) && (ref < ref_limit)) {
                if (!SAME_PIXEL(*ref, *ip)) {
                    ref++;
                    ip++;
                    break;
                } else {
                    ref++;
                    ip++;
                }
            }
        }

        /* if we have copied something, adjust the copy count */
        if (copy) {
            /* copy is biased, '0' means 1 byte copy */
            update_copy_count(encoder, copy - 1);
        } else {
            /* back, to overwrite the copy count */
            compress_output_prev(encoder);
        }

        /* reset literal counter */
        copy = 0;

        /* length is biased, '1' means a match of 3 pixels for PLT and alpha*/
        /* for RGB 16 1 means 2 */
        /* for RGB24/32 1 means 1...*/
        ip -= 3;
        len = ip - anchor;
#if defined(LZ_RGB16)
        len++;
#elif defined(LZ_RGB24) || defined(LZ_RGB32)
        len += 2;
#endif
        /* encode the match (like fastlz level 2)*/
        if (distance < MAX_DISTANCE) { // MAX_DISTANCE is 2^13 - 1
            // when copy is performed, the byte that holds the copy count is smaller than 32.
            // When there is a reference, the first byte is always larger then 32

            // 3 bits = length, 5 bits = 5 MSB of distance, 8 bits = 8 LSB of distance
            if (len < 7) {
                encode(encoder, (uint8_t)((len << 5) + (distance >> 8)));
                encode(encoder, (uint8_t)(distance & 255));
            } else { // more than 3 bits are needed for length
                    // 3 bits 7, 5 bits = 5 MSB of distance, next bytes are 255 till we
                    // receive a smaller number, last byte = 8 LSB of distance
                encode(encoder, (uint8_t)((7 << 5) + (distance >> 8)));
                for (len -= 7; len >= 255; len -= 255) {
                    encode(encoder, 255);
                }
                encode(encoder, (uint8_t)len);
                encode(encoder, (uint8_t)(distance & 255));
            }
        } else {
            /* far away */
            if (len < 7) { // the max_far_distance is ~2^16+2^13 so two more bytes are needed
                // 3 bits = length, 5 bits = 5 MSB of MAX_DISTANCE, 8 bits = 8 LSB of MAX_DISTANCE,
                // 8 bits = 8 MSB distance-MAX_distance (smaller than 2^16),8 bits=8 LSB of
                // distance-MAX_distance
                distance -= MAX_DISTANCE;
                encode(encoder, (uint8_t)((len << 5) + 31));
                encode(encoder, (uint8_t)255);
                encode(encoder, (uint8_t)(distance >> 8));
                encode(encoder, (uint8_t)(distance & 255));
            } else {
                // same as before, but the first byte is followed by the left overs of len
                distance -= MAX_DISTANCE;
                encode(encoder, (uint8_t)((7 << 5) + 31));
                for (len -= 7; len >= 255; len -= 255) {
                    encode(encoder, 255);
                }
                encode(encoder, (uint8_t)len);
                encode(encoder, 255);
                encode(encoder, (uint8_t)(distance >> 8));
                encode(encoder, (uint8_t)(distance & 255));
            }
        }

        /* update the hash at match boundary */
#if defined(LZ_RGB16) || defined(LZ_RGB24) || defined(LZ_RGB32)
        if (ip > anchor)
#endif
        {
            HASH_FUNC(hval, ip);
            encoder->htab[hval].ref = (uint8_t *)ip;
            encoder->htab[hval].image_seg = seg;
        }
        ip++;
#if defined(LZ_RGB24) || defined(LZ_RGB32)
        if (ip > anchor)
#endif
        {
            HASH_FUNC(hval, ip);
            encoder->htab[hval].ref = (uint8_t *)ip;
            encoder->htab[hval].image_seg = seg;
        }
        ip++;
        /* assuming literal copy */
        encode_copy_count(encoder, MAX_COPY - 1);
        continue;

literal:
        ENCODE_PIXEL(encoder, *anchor);
        anchor++;
        ip = anchor;
        copy++;

        if (LZ_UNEXPECT_CONDITIONAL(copy == MAX_COPY)) {
            copy = 0;
            encode_copy_count(encoder, MAX_COPY - 1);
        }
    } // END LOOP (ip < ip_limit)


    /* left-over as literal copy */
    ip_bound++;
    while (ip <= ip_bound) {
        ENCODE_PIXEL(encoder, *ip);
        ip++;
        copy++;
        if (copy == MAX_COPY) {
            copy = 0;
            encode_copy_count(encoder, MAX_COPY - 1);
        }
    }

    /* if we have copied something, adjust the copy length */
    if (copy) {
        update_copy_count(encoder, copy - 1);
    } else {
        compress_output_prev(encoder); // in case we created a new buffer for copy, check that
                                       // red_worker could handle size that do not contain the
                                       // ne buffer
    }
}


/*    initializes the hash table. if the file is very small, copies it.
    copies the first two pixels of the first segment, and sends the segments
    one by one to compress_seg.
    the number of bytes compressed are stored inside encoder.
    */
static void FNAME(compress)(Encoder *encoder)
{
    LzImageSegment    *cur_seg = encoder->head_image_segs;
    HashEntry        *hslot;
    PIXEL            *ip;

    // fetch the first image segment that is not too small
    while (cur_seg && ((((PIXEL *)cur_seg->lines_end) - ((PIXEL *)cur_seg->lines)) < 4)) {
        // coping the segment
        if (cur_seg->lines != cur_seg->lines_end) {
            ip = (PIXEL *)cur_seg->lines;
            // Note: we assume MAX_COPY > 3
            encode_copy_count(encoder, (uint8_t)(
                                  (((PIXEL *)cur_seg->lines_end) - ((PIXEL *)cur_seg->lines)) - 1));
            while (ip < (PIXEL *)cur_seg->lines_end) {
                ENCODE_PIXEL(encoder, *ip);
                ip++;
            }
        }
        cur_seg = cur_seg->next;
    }

    if (!cur_seg) {
        return;
    }

    ip = (PIXEL *)cur_seg->lines;

    /* initialize hash table */
    for (hslot = encoder->htab; hslot < encoder->htab + HASH_SIZE; hslot++) {
        hslot->ref = (uint8_t*)ip;
        hslot->image_seg = cur_seg;
    }

    encode_copy_count(encoder, MAX_COPY - 1);
    ENCODE_PIXEL(encoder, *ip);
    ip++;
    ENCODE_PIXEL(encoder, *ip);
    ip++;

    // compressing the first segment
    FNAME(compress_seg)(encoder, cur_seg, ip, 2);

    // compressing the next segments
    for (cur_seg = cur_seg->next; cur_seg; cur_seg = cur_seg->next) {
        FNAME(compress_seg)(encoder, cur_seg, (PIXEL *)cur_seg->lines, 0);
    }
}

#undef FNAME
#undef PIXEL_ID
#undef PIXEL
#undef ENCODE_PIXEL
#undef SAME_PIXEL
#undef HASH_FUNC
#undef GET_rgb
#undef LZ_PLT
#undef LZ_RGB_ALPHA
#undef LZ_RGB16
#undef LZ_RGB24
#undef LZ_RGB32
#undef LZ_A8

```

`devices/display/qxl/canvas/lz_config.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, write to the Free Software

   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
*/

#ifndef H_SPICE_COMMON_LZ_CONFIG
#define H_SPICE_COMMON_LZ_CONFIG

#include <spice/types.h>
#include <spice/macros.h>

#ifdef __GNUC__
#include <string.h>
#else
#ifdef QXLDD
#include <windef.h>
#include "os_dep.h"
#else
#include <stddef.h>
#include <string.h>
#endif  // QXLDD
#endif  //__GNUC__

#endif // H_SPICE_COMMON_LZ_CONFIG

```

`devices/display/qxl/canvas/lz_decompress_tmpl.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*

 Copyright (C) 2009 Red Hat, Inc. and/or its affiliates.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.

 This file incorporates work covered by the following copyright and
 permission notice:
      Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the "Software"), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
   BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
   ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
   CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   SOFTWARE.

*/

// External defines: PLT, RGBX/PLTXX/ALPHA, TO_RGB32.
// If PLT4/1 and TO_RGB32 are defined, we need CAST_PLT_DISTANCE (because then the number of
// pixels differ from the units used in the compression)

/*
    For each output pixel type the following macros are defined:
    OUT_PIXEL                     - the output pixel type
    COPY_PIXEL(p, out)            - assigns the pixel to the place pointed by out and increases
                                    out. Used in RLE. Need special handling because in alpha we
                                    copy only the pad byte.
    COPY_REF_PIXEL(ref, out)      - copies the pixel pointed by ref to the pixel pointed by out.
                                    Increases ref and out.
    COPY_COMP_PIXEL(encoder, out) - copies pixel from the compressed buffer to the decompressed
                                    buffer. Increases out.
*/
#include "config.h"

#if !defined(LZ_RGB_ALPHA)
#define COPY_PIXEL(p, out) (*out++ = p)
#define COPY_REF_PIXEL(ref, out) (*out++ = *ref++)
#endif


// decompressing plt to plt
#ifdef LZ_PLT
#ifndef TO_RGB32
#define OUT_PIXEL one_byte_pixel_t
#define FNAME(name) lz_plt_##name
#define COPY_COMP_PIXEL(encoder, out) {out->a = decode(encoder); out++;}
#else // TO_RGB32
#define OUT_PIXEL rgb32_pixel_t
#define COPY_PLT_ENTRY(ent, out) {    \
    (out)->b = ent;                   \
    (out)->g = (ent >> 8);            \
    (out)->r = (ent >> 16);           \
    (out)->pad = 0;                   \
}
#ifdef PLT8
#define FNAME(name) lz_plt8_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out) {                     \
    uint32_t rgb = encoder->palette->ents[decode(encoder)]; \
    COPY_PLT_ENTRY(rgb, out);                               \
    out++;}
#elif defined(PLT4_BE)
#define FNAME(name) lz_plt4_be_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out){                                                             \
    uint8_t byte = decode(encoder);                                                                \
    uint32_t rgb = encoder->palette->ents[((byte >> 4) & 0x0f) % (encoder->palette->num_ents)];    \
    COPY_PLT_ENTRY(rgb, out);                                                                      \
    out++;                                                                                         \
    rgb = encoder->palette->ents[(byte & 0x0f) % (encoder->palette->num_ents)];                    \
    COPY_PLT_ENTRY(rgb, out);                                                                      \
    out++;                                                                                         \
}
#define CAST_PLT_DISTANCE(dist) (dist*2)
#elif  defined(PLT4_LE)
#define FNAME(name) lz_plt4_le_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out){                                                      \
    uint8_t byte = decode(encoder);                                                         \
    uint32_t rgb = encoder->palette->ents[(byte & 0x0f) % (encoder->palette->num_ents)];    \
    COPY_PLT_ENTRY(rgb, out);                                                               \
    out++;                                                                                  \
    rgb = encoder->palette->ents[((byte >> 4) & 0x0f) % (encoder->palette->num_ents)];      \
    COPY_PLT_ENTRY(rgb, out);                                                               \
    out++;                                                                                  \
}
#define CAST_PLT_DISTANCE(dist) (dist*2)
#elif defined(PLT1_BE) // TODO store palette entries for direct access
#define FNAME(name) lz_plt1_be_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out){                                    \
    uint8_t byte = decode(encoder);                                       \
    int i;                                                                \
    uint32_t fore = encoder->palette->ents[1];                            \
    uint32_t back = encoder->palette->ents[0];                            \
    for (i = 7; i >= 0; i--)                                              \
    {                                                                     \
        if ((byte >> i) & 1) {                                            \
            COPY_PLT_ENTRY(fore, out);                                    \
        } else {                                                          \
            COPY_PLT_ENTRY(back, out);                                    \
        }                                                                 \
        out++;                                                            \
    }                                                                     \
}
#define CAST_PLT_DISTANCE(dist) (dist*8)
#elif defined(PLT1_LE)
#define FNAME(name) lz_plt1_le_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out){                                    \
    uint8_t byte = decode(encoder);                                       \
    int i;                                                                \
    uint32_t fore = encoder->palette->ents[1];                            \
    uint32_t back = encoder->palette->ents[0];                            \
    for (i = 0; i < 8; i++)                                               \
    {                                                                     \
        if ((byte >> i) & 1) {                                            \
            COPY_PLT_ENTRY(fore, out);                                    \
        } else {                                                          \
            COPY_PLT_ENTRY(back, out);                                    \
        }                                                                 \
        out++;                                                            \
    }                                                                     \
}
#define CAST_PLT_DISTANCE(dist) (dist*8)
#endif // PLT Type
#endif // TO_RGB32
#endif

#ifndef CAST_PLT_DISTANCE
#define CAST_PLT_DISTANCE(dist) (dist)
#endif

#ifdef LZ_A8
#ifndef TO_RGB32
#define OUT_PIXEL one_byte_pixel_t
#define FNAME(name) lz_a8_##name
#define COPY_COMP_PIXEL(encoder, out) {out->a = decode(encoder); out++;}
#else // TO_RGB32
#define OUT_PIXEL rgb32_pixel_t
#define FNAME(name) lz_a8_to_rgb32_##name
#define COPY_COMP_PIXEL(encoder, out) {                     \
        (out)->b = (out)->g = (out)->r = 0;                 \
        (out)->pad = decode(encoder);                       \
        (out)++;                                            \
    }
#endif
#endif

#ifdef LZ_RGB16
#ifndef TO_RGB32
#define OUT_PIXEL rgb16_pixel_t
#define FNAME(name) lz_rgb16_##name
#define COPY_COMP_PIXEL(e, out) {*out = ((decode(e) << 8) | decode(e)); out++;}
#else
#define OUT_PIXEL rgb32_pixel_t
#define FNAME(name) lz_rgb16_to_rgb32_##name
#define COPY_COMP_PIXEL(e, out) {                                      \
    out->r = decode(e);                                                \
    out->b = decode(e);                                                \
    out->g = (((out->r) << 6) | ((out->b) >> 2)) & ~0x07;              \
    out->g |= (out->g >> 5);                                           \
    out->r = ((out->r << 1) & ~0x07)| ((out->r >> 4) & 0x07);          \
    out->b =  (out->b << 3) | ((out->b >> 2) & 0x07);                  \
    out->pad = 0;                                                      \
    out++;                                                             \
}
#endif
#endif

#ifdef LZ_RGB24
#define OUT_PIXEL rgb24_pixel_t
#define FNAME(name) lz_rgb24_##name
#define COPY_COMP_PIXEL(e, out) {out->b = decode(e); out->g = decode(e); out->r = decode(e); out++;}
#endif

#ifdef LZ_RGB32
#define OUT_PIXEL rgb32_pixel_t
#define FNAME(name) lz_rgb32_##name
#define COPY_COMP_PIXEL(e, out) {   \
    out->b = decode(e);             \
    out->g = decode(e);             \
    out->r = decode(e);             \
    out->pad = 0;                   \
    out++;                          \
}
#endif

#ifdef LZ_RGB_ALPHA
#define OUT_PIXEL rgb32_pixel_t
#define FNAME(name) lz_rgb_alpha_##name
#define COPY_PIXEL(p, out) {out->pad = p.pad; out++;}
#define COPY_REF_PIXEL(ref, out) {out->pad = ref->pad; out++; ref++;}
#define COPY_COMP_PIXEL(e, out) {out->pad = decode(e); out++;}
#endif

// return num of bytes in out_buf
static size_t FNAME(decompress)(Encoder *encoder, OUT_PIXEL *out_buf, int size)
{
    OUT_PIXEL    *op = out_buf;
    OUT_PIXEL    *const op_limit = out_buf + size;

    for (;;) {
        uint32_t ctrl = decode(encoder);

        if (ctrl >= MAX_COPY) { // reference (dictionary/RLE)
            /* retrieving the reference and the match length */

            const OUT_PIXEL *ref = op;
            uint32_t len = ctrl >> 5;
            uint32_t ofs = (ctrl & 31) << 8; // 5 MSb of distance

            uint8_t code;
            len--;
            //ref -= ofs;
            if (len == 7 - 1) { // match length is bigger than 7
                do {
                    code = decode(encoder);
                    len += code;
                } while (code == 255); // remaining of len
            }
            code = decode(encoder);
            ofs += code;

            /* match from 16-bit distance */
            if (LZ_UNEXPECT_CONDITIONAL(code == 255)) {
                if (LZ_EXPECT_CONDITIONAL((ofs - code) == (31 << 8))) {
                    ofs = decode(encoder) << 8;
                    ofs += decode(encoder);
                    ofs += MAX_DISTANCE;
                }
            }

#if defined(LZ_PLT) || defined(LZ_RGB_ALPHA) || defined(LZ_A8)
            len += 3; // length is biased by 2 + 1 (fixing bias)
#elif defined(LZ_RGB16)
            len += 2; // length is biased by 1 + 1 (fixing bias)
#else
            len += 1;
#endif
            ofs += 1; // offset is biased by 1       (fixing bias)

            ofs = CAST_PLT_DISTANCE(ofs);
            len = CAST_PLT_DISTANCE(len);
            ref -= ofs;

            spice_assert(op + len <= op_limit);
            spice_assert(ref + len <= op_limit);
            spice_assert(ref >= out_buf);

            // TODO: optimize by not calling loop at least 3 times when not PLT_TO_RGB32 (len is
            //       always >=3). in PLT_TO_RGB32 len >= 3*number_of_pixels_per_byte

            /* copying the match*/

            if (ref == (op - 1)) { // run // TODO: this will never be called in PLT4/1_TO_RGB
                                          //       because the number of pixel copied is larger
                                          //       then one...
                /* optimize copy for a run */
                const OUT_PIXEL b = *ref;
                for (; len; --len) {
                    COPY_PIXEL(b, op);
                    spice_extra_assert(op <= op_limit);
                }
            } else {
                for (; len; --len) {
                    COPY_REF_PIXEL(ref, op);
                    spice_extra_assert(op <= op_limit);
                }
            }
        } else { // copy
            ctrl++; // copy count is biased by 1
            spice_assert(op + CAST_PLT_DISTANCE(ctrl) <= op_limit);

            do {
                COPY_COMP_PIXEL(encoder, op);
                spice_extra_assert(op <= op_limit);
            } while(--ctrl);
        }

        if (LZ_UNEXPECT_CONDITIONAL(op >= op_limit)) {
            break;
        }
    }

    return (op - out_buf);
}

#undef LZ_PLT
#undef PLT8
#undef PLT4_BE
#undef PLT4_LE
#undef PLT1_BE
#undef PLT1_LE
#undef LZ_RGB16
#undef LZ_RGB24
#undef LZ_RGB32
#undef LZ_A8
#undef LZ_RGB_ALPHA
#undef TO_RGB32
#undef OUT_PIXEL
#undef FNAME
#undef COPY_PIXEL
#undef COPY_REF_PIXEL
#undef COPY_COMP_PIXEL
#undef COPY_PLT_ENTRY
#undef CAST_PLT_DISTANCE

```

`devices/display/qxl/canvas/macros.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_MACROS
#define H_SPICE_COMMON_MACROS

#include "verify.h"

#ifdef __GNUC__
#define SPICE_CONSTRUCTOR_FUNC(func_name) \
    static void __attribute__((constructor)) func_name(void)
#define SPICE_DESTRUCTOR_FUNC(func_name) \
    static void __attribute__((destructor)) func_name(void)
#elif defined(_MSC_VER)
#define SPICE_CONSTRUCTOR_FUNC(func_name) \
    static void func_name(void); \
    static int func_name ## _wrapper(void) { func_name(); return 0; } \
    __pragma(section(".CRT$XCU",read)) \
    __declspec(allocate(".CRT$XCU")) static int (* _array ## func_name)(void) = func_name ## _wrapper; \
    static void func_name(void)
#define SPICE_DESTRUCTOR_FUNC(func_name) \
    static void func_name(void); \
    static int func_name ## _wrapper(void) { func_name(); return 0; } \
    __pragma(section(".CRT$XPU",read)) \
    __declspec(allocate(".CRT$XPU")) static int (* _array ## func_name)(void) = func_name ## _wrapper; \
    static void func_name(void)
#else
#error Please implement SPICE_CONSTRUCTOR_FUNC and SPICE_DESTRUCTOR_FUNC for this compiler
#endif

#define SPICE_VERIFY(cond) verify_expr(cond, (void)1)

#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5)
#define SPICE_UNREACHABLE __builtin_unreachable()
#elif defined(_MSC_VER)
#define SPICE_UNREACHABLE __assume(0)
#else
#define SPICE_UNREACHABLE for(;;) continue
#endif

#endif // H_SPICE_COMMON_MACROS

```

`devices/display/qxl/canvas/mem.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2010 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#include "mem.h"

#include <string.h>

#ifndef MALLOC_ERROR
#define MALLOC_ERROR(...) SPICE_STMT_START {    \
    spice_error(__VA_ARGS__);                   \
    abort();                                    \
} SPICE_STMT_END
#endif

size_t spice_strnlen(const char *str, size_t max_len)
{
    size_t len = 0;

    while (len < max_len && *str != 0) {
        len++;
        str++;
    }

    return len;
}

char *spice_strdup(const char *str)
{
    char *copy;
    size_t len;

    if (str == NULL) {
        return NULL;
    }

    len = strlen(str) + 1;
    copy = (char *)spice_malloc(len);
    memcpy(copy, str, len);
    return copy;
}

char *spice_strndup(const char *str, size_t n_bytes)
{
    char *copy;

    if (str == NULL) {
        return NULL;
    }

    copy = (char *)spice_malloc(n_bytes + 1);
    strncpy(copy, str, n_bytes);
    copy[n_bytes] = 0;
    return copy;
}

void *spice_memdup(const void *mem, size_t n_bytes)
{
    void *copy;

    if (mem == NULL) {
        return NULL;
    }

    copy = spice_malloc(n_bytes);
    memcpy(copy, mem, n_bytes);
    return copy;
}

void *spice_malloc(size_t n_bytes)
{
    void *mem;

    if (SPICE_LIKELY(n_bytes)) {
        mem = malloc(n_bytes);

        if (SPICE_LIKELY(mem != NULL)) {
            return mem;
        }

        MALLOC_ERROR("unable to allocate %lu bytes", (unsigned long)n_bytes);
    }
    return NULL;
}

void *spice_malloc0(size_t n_bytes)
{
    void *mem;

    if (SPICE_LIKELY(n_bytes)) {
        mem = calloc(1, n_bytes);

        if (SPICE_LIKELY(mem != NULL)) {
            return mem;
        }

        MALLOC_ERROR("unable to allocate %lu bytes", (unsigned long)n_bytes);
    }
    return NULL;
}

void *spice_realloc(void *mem, size_t n_bytes)
{
    if (SPICE_LIKELY(n_bytes)) {
        mem = realloc(mem, n_bytes);

        if (SPICE_LIKELY(mem != NULL)) {
            return mem;
        }

        MALLOC_ERROR("unable to allocate %lu bytes", (unsigned long)n_bytes);
    }

    free(mem);

    return NULL;
}

#define SIZE_OVERFLOWS(a,b) (SPICE_UNLIKELY ((a) > SIZE_MAX / (b)))

void *spice_malloc_n(size_t n_blocks, size_t n_block_bytes)
{
    if (SIZE_OVERFLOWS (n_blocks, n_block_bytes)) {
        MALLOC_ERROR("overflow allocating %lu*%lu bytes",
                     (unsigned long)n_blocks, (unsigned long)n_block_bytes);
    }

    return spice_malloc(n_blocks * n_block_bytes);
}

void *spice_malloc_n_m(size_t n_blocks, size_t n_block_bytes, size_t extra_size)
{
    size_t size1, size2;
    if (SIZE_OVERFLOWS (n_blocks, n_block_bytes)) {
        MALLOC_ERROR("spice_malloc_n: overflow allocating %lu*%lu + %lubytes",
                     (unsigned long)n_blocks, (unsigned long)n_block_bytes, (unsigned long)extra_size);
    }
    size1 = n_blocks * n_block_bytes;
    size2 = size1 + extra_size;
    if (size2 < size1) {
        MALLOC_ERROR("spice_malloc_n: overflow allocating %lu*%lu + %lubytes",
                     (unsigned long)n_blocks, (unsigned long)n_block_bytes, (unsigned long)extra_size);
    }
    return spice_malloc(size2);
}


void *spice_malloc0_n(size_t n_blocks, size_t n_block_bytes)
{
    if (SIZE_OVERFLOWS (n_blocks, n_block_bytes)) {
        MALLOC_ERROR("spice_malloc0_n: overflow allocating %lu*%lu bytes",
                     (unsigned long)n_blocks, (unsigned long)n_block_bytes);
    }

    return spice_malloc0 (n_blocks * n_block_bytes);
}

void *spice_realloc_n(void *mem, size_t n_blocks, size_t n_block_bytes)
{
    if (SIZE_OVERFLOWS (n_blocks, n_block_bytes)) {
        MALLOC_ERROR("spice_realloc_n: overflow allocating %lu*%lu bytes",
                     (unsigned long)n_blocks, (unsigned long)n_block_bytes);
    }

    return spice_realloc(mem, n_blocks * n_block_bytes);
}

SpiceChunks *spice_chunks_new(uint32_t count)
{
    SpiceChunks *chunks;

    chunks = (SpiceChunks *)spice_malloc_n_m(count, sizeof(SpiceChunk), sizeof(SpiceChunks));
    chunks->flags = 0;
    chunks->num_chunks = count;

    return chunks;
}

SpiceChunks *spice_chunks_new_linear(uint8_t *data, uint32_t len)
{
    SpiceChunks *chunks;

    chunks = spice_chunks_new(1);
    chunks->data_size = chunks->chunk[0].len = len;
    chunks->chunk[0].data = data;
    return chunks;
}

void spice_chunks_destroy(SpiceChunks *chunks)
{
    unsigned int i;

    if (chunks->flags & SPICE_CHUNKS_FLAGS_FREE) {
        for (i = 0; i < chunks->num_chunks; i++) {
            free(chunks->chunk[i].data);
        }
    }

    free(chunks);
}

void spice_chunks_linearize(SpiceChunks *chunks)
{
    uint8_t *data, *p;
    unsigned int i;

    if (chunks->num_chunks > 1) {
        data = (uint8_t*)spice_malloc(chunks->data_size);
        for (p = data, i = 0; i < chunks->num_chunks; i++) {
            memcpy(p, chunks->chunk[i].data,
                   chunks->chunk[i].len);
            p += chunks->chunk[i].len;
        }
        if (chunks->flags & SPICE_CHUNKS_FLAGS_FREE) {
            for (i = 0; i < chunks->num_chunks; i++) {
                free(chunks->chunk[i].data);
            }
        }
        chunks->num_chunks = 1;
        chunks->flags |= SPICE_CHUNKS_FLAGS_FREE;
        chunks->flags &= ~SPICE_CHUNKS_FLAGS_UNSTABLE;
        chunks->chunk[0].data = data;
        chunks->chunk[0].len = chunks->data_size;
    }
}

void spice_buffer_reserve(SpiceBuffer *buffer, size_t len)
{
    if ((buffer->capacity - buffer->offset) < len) {
        buffer->capacity += (len + 1024);
        buffer->buffer = (uint8_t*)spice_realloc(buffer->buffer, buffer->capacity);
    }
}

int spice_buffer_empty(SpiceBuffer *buffer)
{
    return buffer->offset == 0;
}

uint8_t *spice_buffer_end(SpiceBuffer *buffer)
{
    return buffer->buffer + buffer->offset;
}

void spice_buffer_reset(SpiceBuffer *buffer)
{
    buffer->offset = 0;
}

void spice_buffer_free(SpiceBuffer *buffer)
{
    free(buffer->buffer);
    buffer->offset = 0;
    buffer->capacity = 0;
    buffer->buffer = NULL;
}

void spice_buffer_append(SpiceBuffer *buffer, const void *data, size_t len)
{
    spice_buffer_reserve(buffer, len);
    memcpy(buffer->buffer + buffer->offset, data, len);
    buffer->offset += len;
}

size_t spice_buffer_copy(SpiceBuffer *buffer, void *dest, size_t len)
{
    len = MIN(buffer->offset, len);
    memcpy(dest, buffer->buffer, len);
    return len;
}

size_t spice_buffer_remove(SpiceBuffer *buffer, size_t len)
{
    len = MIN(buffer->offset, len);
    memmove(buffer->buffer, buffer->buffer + len, buffer->offset - len);
    buffer->offset -= len;
    return len;
}

#ifdef SPICE_DEBUG_ALIGNMENT
void spice_alignment_warning(const char *loc, void *p, unsigned sz)
{
    static const char *last_loc = NULL;
    if (loc != last_loc) {
        last_loc = loc;
        spice_log(G_LOG_LEVEL_WARNING, loc, __FUNCTION__,
                  "Misaligned access at %p, alignment %u", p, sz);
    }
}

void spice_alignment_debug(const char *loc, void *p, unsigned sz)
{
    static const char *last_loc = NULL;
    if (loc != last_loc) {
        last_loc = loc;
        spice_log(G_LOG_LEVEL_DEBUG, loc, __FUNCTION__,
                  "Expected misaligned access at %p, alignment %u", p, sz);
    }
}
#endif // SPICE_DEBUG_ALIGNMENT

```

`devices/display/qxl/canvas/mem.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2010 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_MEM
#define H_SPICE_COMMON_MEM

#include "log.h"
#include <stdlib.h>
#include <spice/macros.h>

SPICE_BEGIN_DECLS

#ifdef STDC_HEADERS
# include <stdlib.h>
# include <stddef.h>
#else
# ifdef HAVE_STDLIB_H
#  include <stdlib.h>
# endif
#endif
#ifdef HAVE_ALLOCA_H
# include <alloca.h>
#elif defined __GNUC__
#if !defined alloca
# define alloca __builtin_alloca
#endif
#elif defined _AIX
# define alloca __alloca
#elif defined _MSC_VER
# include <malloc.h>
# define alloca _alloca
#else
# ifndef HAVE_ALLOCA
#  ifdef  __cplusplus
extern "C"
#  endif
void *alloca (size_t);
# endif
#endif

typedef struct SpiceChunk {
    uint8_t *data;
    uint32_t len;
} SpiceChunk;

enum {
    SPICE_CHUNKS_FLAGS_UNSTABLE = (1<<0),
    SPICE_CHUNKS_FLAGS_FREE = (1<<1)
};

typedef struct SpiceChunks {
    uint32_t     data_size;
    uint32_t     num_chunks;
    uint32_t     flags;
    SpiceChunk   chunk[0];
} SpiceChunks;

typedef struct SpiceBuffer
{
    size_t capacity;
    size_t offset;
    uint8_t *buffer;
} SpiceBuffer;

char *spice_strdup(const char *str) SPICE_GNUC_MALLOC;
char *spice_strndup(const char *str, size_t n_bytes) SPICE_GNUC_MALLOC;
void *spice_memdup(const void *mem, size_t n_bytes) SPICE_GNUC_MALLOC;
void *spice_malloc(size_t n_bytes) SPICE_GNUC_MALLOC SPICE_GNUC_ALLOC_SIZE(1);
void *spice_malloc0(size_t n_bytes) SPICE_GNUC_MALLOC SPICE_GNUC_ALLOC_SIZE(1);
void *spice_realloc(void *mem, size_t n_bytes) SPICE_GNUC_WARN_UNUSED_RESULT;
void *spice_malloc_n(size_t n_blocks, size_t n_block_bytes) SPICE_GNUC_MALLOC SPICE_GNUC_ALLOC_SIZE2(1,2);
void *spice_malloc_n_m(size_t n_blocks, size_t n_block_bytes, size_t extra_size) SPICE_GNUC_MALLOC;
void *spice_malloc0_n(size_t n_blocks, size_t n_block_bytes) SPICE_GNUC_MALLOC SPICE_GNUC_ALLOC_SIZE2(1,2);
void *spice_realloc_n(void *mem, size_t n_blocks, size_t n_block_bytes) SPICE_GNUC_WARN_UNUSED_RESULT;
SpiceChunks *spice_chunks_new(uint32_t count) SPICE_GNUC_MALLOC;
SpiceChunks *spice_chunks_new_linear(uint8_t *data, uint32_t len) SPICE_GNUC_MALLOC;
void spice_chunks_destroy(SpiceChunks *chunks);
void spice_chunks_linearize(SpiceChunks *chunks);

size_t spice_strnlen(const char *str, size_t max_len);

/* Optimize: avoid the call to the (slower) _n function if we can
 * determine at compile-time that no overflow happens.
 */
#if defined (__GNUC__) && (__GNUC__ >= 2) && defined (__OPTIMIZE__)
#  define _SPICE_NEW(struct_type, n_structs, func)        \
    (struct_type *) (__extension__ ({                     \
        size_t __n = (size_t) (n_structs);                \
        size_t __s = sizeof (struct_type);                \
        void *__p;                                        \
        if (__s == 1)                                     \
            __p = spice_##func (__n);                     \
        else if (__builtin_constant_p (__n) &&            \
                 __n <= SIZE_MAX / __s)                   \
            __p = spice_##func (__n * __s);               \
        else                                              \
            __p = spice_##func##_n (__n, __s);            \
        __p;                                              \
    }))
#  define _SPICE_RENEW(struct_type, mem, n_structs, func) \
    (struct_type *) (__extension__ ({                     \
        size_t __n = (size_t) (n_structs);                \
        size_t __s = sizeof (struct_type);                \
        void *__p = (void *) (mem);                       \
        if (__s == 1)                                     \
            __p = spice_##func (__p, __n);                \
        else if (__builtin_constant_p (__n) &&            \
                 __n <= SIZE_MAX / __s)                   \
            __p = spice_##func (__p, __n * __s);          \
        else                                              \
            __p = spice_##func##_n (__p, __n, __s);       \
        __p;                                              \
    }))
#else

/* Unoptimized version: always call the _n() function. */
#define _SPICE_NEW(struct_type, n_structs, func)                        \
    ((struct_type *) spice_##func##_n ((n_structs), sizeof (struct_type)))
#define _SPICE_RENEW(struct_type, mem, n_structs, func)                 \
    ((struct_type *) spice_##func##_n (mem, (n_structs), sizeof (struct_type)))

#endif

/* Cast to a type with stricter alignment constraints (to build with clang) */

/* Misaligned cast to a type with stricter alignment */
#ifndef SPICE_DEBUG_ALIGNMENT
#define SPICE_UNALIGNED_CAST(type, value) ((type)(void *)(value))
#define SPICE_ALIGNED_CAST(type, value)   ((type)(void *)(value))

#else // SPICE_DEBUG_ALIGNMENT
#define SPICE_ALIGNED_CAST(type, value)                                 \
    ((type)spice_alignment_check(G_STRLOC,                              \
                                 (void *)(value),                       \
                                 __alignof(*((type)0))))

#define SPICE_UNALIGNED_CAST(type, value)                               \
    ((type)spice_alignment_weak_check(G_STRLOC,                         \
                                      (void *)(value),                  \
                                      __alignof(*((type)0))))

extern void spice_alignment_warning(const char *loc, void *p, unsigned sz);
extern void spice_alignment_debug(const char *loc, void *p, unsigned sz);

static inline void *spice_alignment_check(const char *loc,
                                          void *ptr, unsigned sz)
{
    if (G_UNLIKELY(((uintptr_t) ptr & (sz-1U)) != 0))
        spice_alignment_warning(loc, ptr, sz);
    return ptr;

}

static inline void *spice_alignment_weak_check(const char *loc,
                                               void *ptr, unsigned sz)
{
    if (G_UNLIKELY(((uintptr_t) ptr & (sz-1U)) != 0))
        spice_alignment_debug(loc, ptr, sz);
    return ptr;

}
#endif // SPICE_DEBUG_ALIGNMENT

#define spice_new(struct_type, n_structs) _SPICE_NEW(struct_type, n_structs, malloc)
#define spice_new0(struct_type, n_structs) _SPICE_NEW(struct_type, n_structs, malloc0)
#define spice_renew(struct_type, mem, n_structs) _SPICE_RENEW(struct_type, mem, n_structs, realloc)

/* Buffer management */
void spice_buffer_reserve(SpiceBuffer *buffer, size_t len);
int spice_buffer_empty(SpiceBuffer *buffer);
uint8_t *spice_buffer_end(SpiceBuffer *buffer);
void spice_buffer_reset(SpiceBuffer *buffer);
void spice_buffer_free(SpiceBuffer *buffer);
void spice_buffer_append(SpiceBuffer *buffer, const void *data, size_t len);
size_t spice_buffer_copy(SpiceBuffer *buffer, void *dest, size_t len);
size_t spice_buffer_remove(SpiceBuffer *buffer, size_t len);

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/meson.build`:

```build

mvisor_sources += files(
  'canvas_utils.c',
  'canvas_utils.h',
  'draw.h',
  'lines.c',
  'lines.h',
  'log.c',
  'log.h',
  'lz.c',
  'lz.h',
  'lz_common.h',
  'lz_config.h',
  'macros.h',
  'mem.c',
  'mem.h',
  'pixman_utils.c',
  'pixman_utils.h',
  'quic.c',
  'quic.h',
  'quic_config.h',
  'rect.h',
  'region.c',
  'region.h',
  'ring.h',
  'rop3.c',
  'rop3.h',
  'verify.h',
  'sw_canvas.c',
  'sw_canvas.h'
)

mvisor_deps += [
  dependency('pixman-1', version: '>= 0.17.7'),
  dependency('glib-2.0', version: '>= 2.38')
]

add_project_arguments('-Wno-unused-parameter', language: 'c')

```

`devices/display/qxl/canvas/pixman_utils.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil; -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#include "pixman_utils.h"

#include <string.h>
#include "mem.h"

/*
 * src is used for most OPs, hidden within _equation attribute. For some
 * operations (such as "clear" and "noop") src is not used and then we have
 * to add SPICE_GNUC_UNUSED, that's just a __attribute__((__unused__)), to
 * make GCC happy.
 * Also, according to GCC documentation [0], the unused attribute "(...) means
 * that the variable is meant to be possibly unused. GCC does not produce a
 * warning for this variable.". So, we are safe adding it, even if src is used
 * for most OPs.
 */
#define SOLID_RASTER_OP(_name, _size, _type, _equation)  \
static void                                        \
solid_rop_ ## _name ## _ ## _size (_type *ptr, int len, SPICE_GNUC_UNUSED _type src)  \
{                                                  \
    while (len--) {                                \
        _type dst = *ptr;                          \
        if (dst) /* avoid unused warning */{};       \
        *ptr = (_type)(_equation);                 \
        ptr++;                                     \
    }                                              \
}                                                  \

#define TILED_RASTER_OP(_name, _size, _type, _equation) \
static void                                        \
tiled_rop_ ## _name ## _ ## _size (_type *ptr, int len, _type *tile, _type *tile_end, int tile_width)   \
{                                                  \
    while (len--) {                                \
        _type src = *tile;                         \
        _type dst = *ptr;                          \
        if (src) /* avoid unused warning */{};       \
        if (dst) /* avoid unused warning */{};       \
        *ptr = (_type)(_equation);                 \
        ptr++;                                     \
        tile++;                                    \
        if (tile == tile_end)                      \
            tile -= tile_width;                    \
    }                                              \
}                                                  \

#define COPY_RASTER_OP(_name, _size, _type, _equation) \
static void                                        \
 copy_rop_ ## _name ## _ ## _size (_type *ptr, _type *src_line, int len)        \
{                                                  \
    while (len--) {                                \
        _type src = *src_line;                     \
        _type dst = *ptr;                          \
        if (src) /* avoid unused warning */ {};       \
        if (dst) /* avoid unused warning */{};       \
        *ptr = (_type)(_equation);                 \
        ptr++;                                     \
        src_line++;                                \
    }                                              \
}                                                  \

#define RASTER_OP(name, equation) \
    SOLID_RASTER_OP(name, 8, uint8_t, equation) \
    SOLID_RASTER_OP(name, 16, uint16_t, equation) \
    SOLID_RASTER_OP(name, 32, uint32_t, equation) \
    TILED_RASTER_OP(name, 8, uint8_t, equation) \
    TILED_RASTER_OP(name, 16, uint16_t, equation) \
    TILED_RASTER_OP(name, 32, uint32_t, equation) \
    COPY_RASTER_OP(name, 8, uint8_t, equation) \
    COPY_RASTER_OP(name, 16, uint16_t, equation) \
    COPY_RASTER_OP(name, 32, uint32_t, equation)

RASTER_OP(clear, 0x0)
RASTER_OP(and, src & dst)
RASTER_OP(and_reverse, src & ~dst)
RASTER_OP(copy, src)
RASTER_OP(and_inverted, ~src & dst)
RASTER_OP(noop, dst)
RASTER_OP(xor, src ^ dst)
RASTER_OP(or, src | dst)
RASTER_OP(nor, ~src & ~dst)
RASTER_OP(equiv, ~src ^ dst)
RASTER_OP(invert, ~dst)
RASTER_OP(or_reverse, src | ~dst)
RASTER_OP(copy_inverted, ~src)
RASTER_OP(or_inverted, ~src | dst)
RASTER_OP(nand, ~src | ~dst)
RASTER_OP(set, 0xffffffff)

typedef void (*solid_rop_8_func_t)(uint8_t *ptr, int len, uint8_t src);
typedef void (*solid_rop_16_func_t)(uint16_t *ptr, int len, uint16_t src);
typedef void (*solid_rop_32_func_t)(uint32_t *ptr, int len, uint32_t src);
typedef void (*tiled_rop_8_func_t)(uint8_t *ptr, int len,
                                   uint8_t *tile, uint8_t *tile_end, int tile_width);
typedef void (*tiled_rop_16_func_t)(uint16_t *ptr, int len,
                                    uint16_t *tile, uint16_t *tile_end, int tile_width);
typedef void (*tiled_rop_32_func_t)(uint32_t *ptr, int len,
                                    uint32_t *tile, uint32_t *tile_end, int tile_width);
typedef void (*copy_rop_8_func_t)(uint8_t *ptr, uint8_t *src, int len);
typedef void (*copy_rop_16_func_t)(uint16_t *ptr, uint16_t *src, int len);
typedef void (*copy_rop_32_func_t)(uint32_t *ptr, uint32_t *src, int len);

#define ROP_TABLE(_type, _size)                                                 \
static void (*solid_rops_ ## _size[16]) (_type *ptr, int len, _type src) = { \
    solid_rop_clear_ ## _size,  \
    solid_rop_and_ ## _size,    \
    solid_rop_and_reverse_ ## _size,    \
    solid_rop_copy_ ## _size,    \
    solid_rop_and_inverted_ ## _size,    \
    solid_rop_noop_ ## _size,    \
    solid_rop_xor_ ## _size,    \
    solid_rop_or_ ## _size,    \
    solid_rop_nor_ ## _size,    \
    solid_rop_equiv_ ## _size,    \
    solid_rop_invert_ ## _size,    \
    solid_rop_or_reverse_ ## _size,    \
    solid_rop_copy_inverted_ ## _size,    \
    solid_rop_or_inverted_ ## _size,    \
    solid_rop_nand_ ## _size,    \
    solid_rop_set_ ## _size    \
};                          \
static void (*tiled_rops_ ## _size[16]) (_type *ptr, int len, _type *tile, _type *tile_end, int tile_width) = { \
    tiled_rop_clear_ ## _size,  \
    tiled_rop_and_ ## _size,    \
    tiled_rop_and_reverse_ ## _size,    \
    tiled_rop_copy_ ## _size,    \
    tiled_rop_and_inverted_ ## _size,    \
    tiled_rop_noop_ ## _size,    \
    tiled_rop_xor_ ## _size,    \
    tiled_rop_or_ ## _size,    \
    tiled_rop_nor_ ## _size,    \
    tiled_rop_equiv_ ## _size,    \
    tiled_rop_invert_ ## _size,    \
    tiled_rop_or_reverse_ ## _size,    \
    tiled_rop_copy_inverted_ ## _size,    \
    tiled_rop_or_inverted_ ## _size,    \
    tiled_rop_nand_ ## _size,    \
    tiled_rop_set_ ## _size    \
}; \
static void (*copy_rops_ ## _size[16]) (_type *ptr, _type *tile, int len) = { \
    copy_rop_clear_ ## _size,  \
    copy_rop_and_ ## _size,    \
    copy_rop_and_reverse_ ## _size,    \
    copy_rop_copy_ ## _size,    \
    copy_rop_and_inverted_ ## _size,    \
    copy_rop_noop_ ## _size,    \
    copy_rop_xor_ ## _size,    \
    copy_rop_or_ ## _size,    \
    copy_rop_nor_ ## _size,    \
    copy_rop_equiv_ ## _size,    \
    copy_rop_invert_ ## _size,    \
    copy_rop_or_reverse_ ## _size,    \
    copy_rop_copy_inverted_ ## _size,    \
    copy_rop_or_inverted_ ## _size,    \
    copy_rop_nand_ ## _size,    \
    copy_rop_set_ ## _size    \
};

ROP_TABLE(uint8_t, 8)
ROP_TABLE(uint16_t, 16)
ROP_TABLE(uint32_t, 32)

/* We can't get the real bits per pixel info from pixman_image_t,
   only the DEPTH which is the sum of all a+r+g+b bits, which
   is e.g. 24 for 32bit xRGB. We really want the bpp, so
   we have this ugly conversion thing */
int spice_pixman_image_get_bpp(pixman_image_t *image)
{
    int depth;

    depth = pixman_image_get_depth(image);
    if (depth == 24) {
        return 32;
    }
    if (depth == 15) {
        return 16;
    }
    return depth;
}

void spice_pixman_fill_rect(pixman_image_t *dest,
                            int x, int y,
                            int width, int height,
                            uint32_t value)
{
    uint32_t *bits;
    int stride, depth;
    uint32_t byte_width;
    uint8_t *byte_line;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    spice_assert(x >= 0);
    spice_assert(y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(x + width <= pixman_image_get_width(dest));
    spice_assert(y + height <= pixman_image_get_height(dest));

    if (pixman_fill(bits,
                    stride / 4,
                    depth,
                    x, y,
                    width, height,
                    value)) {
        return;
    }

    if (depth == 8) {
        byte_line = ((uint8_t *)bits) + stride * y + x;
        byte_width = width;
        value = (value & 0xff) * 0x01010101;
    } else if (depth == 16) {
        byte_line = ((uint8_t *)bits) + stride * y + x * 2;
        byte_width = 2 * width;
        value = (value & 0xffff) * 0x00010001;
    } else {
        spice_assert (depth == 32);
        byte_line = ((uint8_t *)bits) + stride * y + x * 4;
        byte_width = 4 * width;
    }

    while (height--) {
        int w;
        uint8_t *d = byte_line;

        byte_line += stride;
        w = byte_width;

        while (w >= 1 && ((uintptr_t)d & 1)) {
            *(uint8_t *)d = (value & 0xff);
            w--;
            d++;
        }

        while (w >= 2 && ((uintptr_t)d & 3)) {
            *(uint16_t *)d = value;
            w -= 2;
            d += 2;
        }

        while (w >= 4 && ((uintptr_t)d & 7)) {
            *(uint32_t *)d = value;

            w -= 4;
            d += 4;
        }

        while (w >= 4) {
            *(uint32_t *)d = value;

            w -= 4;
            d += 4;
        }

        while (w >= 2) {
            *(uint16_t *)d = value;
            w -= 2;
            d += 2;
        }

        while (w >= 1) {
            *(uint8_t *)d = (value & 0xff);
            w--;
            d++;
        }
    }
}

void spice_pixman_fill_rect_rop(pixman_image_t *dest,
                                int x, int y,
                                int width, int height,
                                uint32_t value,
                                SpiceROP rop)
{
    uint32_t *bits;
    int stride, depth;
    uint8_t *byte_line;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    spice_assert(x >= 0);
    spice_assert(y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(x + width <= pixman_image_get_width(dest));
    spice_assert(y + height <= pixman_image_get_height(dest));
    spice_assert(rop < 16);

    if (depth == 8) {
        solid_rop_8_func_t rop_func = solid_rops_8[rop];

        byte_line = ((uint8_t *)bits) + stride * y + x;
        while (height--) {
            rop_func((uint8_t *)byte_line, width, (uint8_t)value);
            byte_line += stride;
        }

    } else if (depth == 16) {
        solid_rop_16_func_t rop_func = solid_rops_16[rop];

        byte_line = ((uint8_t *)bits) + stride * y + x * 2;
        while (height--) {
            rop_func((uint16_t *)byte_line, width, (uint16_t)value);
            byte_line += stride;
        }
    }  else {
        solid_rop_32_func_t rop_func = solid_rops_32[rop];

        byte_line = ((uint8_t *)bits) + stride * y + x * 4;
        while (height--) {
            rop_func((uint32_t *)byte_line, width, (uint32_t)value);
            byte_line += stride;
        }
    }
}

void spice_pixman_tile_rect(pixman_image_t *dest,
                            int x, int y,
                            int width, int height,
                            pixman_image_t *tile,
                            int offset_x,
                            int offset_y)
{
    uint32_t *bits, *tile_bits;
    int stride, depth;
    int tile_width, tile_height, tile_stride;
    uint8_t *byte_line;
    uint8_t *tile_line;
    int tile_start_x, tile_start_y, tile_end_dx;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    tile_bits = pixman_image_get_data(tile);
    tile_stride = pixman_image_get_stride(tile);
    tile_width = pixman_image_get_width(tile);
    tile_height = pixman_image_get_height(tile);

    spice_assert(x >= 0);
    spice_assert(y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(x + width <= pixman_image_get_width(dest));
    spice_assert(y + height <= pixman_image_get_height(dest));
    spice_assert(depth == spice_pixman_image_get_bpp(tile));

    tile_start_x = (x - offset_x) % tile_width;
    if (tile_start_x < 0) {
        tile_start_x += tile_width;
    }
    tile_start_y = (y - offset_y) % tile_height;
    if (tile_start_y < 0) {
        tile_start_y += tile_height;
    }
    tile_end_dx = tile_width - tile_start_x;

    if (depth == 8) {
        byte_line = ((uint8_t *)bits) + stride * y + x;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x;
        while (height--) {
            tiled_rop_copy_8((uint8_t *)byte_line, width,
                             (uint8_t *)tile_line, (uint8_t *)tile_line + tile_end_dx,
                             tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }

    } else if (depth == 16) {
        byte_line = ((uint8_t *)bits) + stride * y + x * 2;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x * 2;
        while (height--) {
            tiled_rop_copy_16((uint16_t *)byte_line, width,
                              (uint16_t *)tile_line, (uint16_t *)tile_line + tile_end_dx,
                              tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }
    }  else {
        spice_assert (depth == 32);

        byte_line = ((uint8_t *)bits) + stride * y + x * 4;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x * 4;
        while (height--) {
            tiled_rop_copy_32((uint32_t *)byte_line, width,
                              (uint32_t *)tile_line, (uint32_t *)tile_line + tile_end_dx,
                              tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }
    }
}

void spice_pixman_tile_rect_rop(pixman_image_t *dest,
                                int x, int y,
                                int width, int height,
                                pixman_image_t *tile,
                                int offset_x,
                                int offset_y,
                                SpiceROP rop)
{
    uint32_t *bits, *tile_bits;
    int stride, depth;
    int tile_width, tile_height, tile_stride;
    uint8_t *byte_line;
    uint8_t *tile_line;
    int tile_start_x, tile_start_y, tile_end_dx;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    tile_bits = pixman_image_get_data(tile);
    tile_stride = pixman_image_get_stride(tile);
    tile_width = pixman_image_get_width(tile);
    tile_height = pixman_image_get_height(tile);

    spice_assert(x >= 0);
    spice_assert(y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(x + width <= pixman_image_get_width(dest));
    spice_assert(y + height <= pixman_image_get_height(dest));
    spice_assert(rop < 16);
    spice_assert(depth == spice_pixman_image_get_bpp(tile));

    tile_start_x = (x - offset_x) % tile_width;
    if (tile_start_x < 0) {
        tile_start_x += tile_width;
    }
    tile_start_y = (y - offset_y) % tile_height;
    if (tile_start_y < 0) {
        tile_start_y += tile_height;
    }
    tile_end_dx = tile_width - tile_start_x;

    if (depth == 8) {
        tiled_rop_8_func_t rop_func = tiled_rops_8[rop];

        byte_line = ((uint8_t *)bits) + stride * y + x;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x;
        while (height--) {
            rop_func((uint8_t *)byte_line, width,
                     (uint8_t *)tile_line, (uint8_t *)tile_line + tile_end_dx,
                     tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }

    } else if (depth == 16) {
        tiled_rop_16_func_t rop_func = tiled_rops_16[rop];

        byte_line = ((uint8_t *)bits) + stride * y + x * 2;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x * 2;
        while (height--) {
            rop_func((uint16_t *)byte_line, width,
                     (uint16_t *)tile_line, (uint16_t *)tile_line + tile_end_dx,
                     tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }
    }  else {
        tiled_rop_32_func_t rop_func = tiled_rops_32[rop];

        spice_assert (depth == 32);

        byte_line = ((uint8_t *)bits) + stride * y + x * 4;
        tile_line = ((uint8_t *)tile_bits) + tile_stride * tile_start_y + tile_start_x * 4;
        while (height--) {
            rop_func((uint32_t *)byte_line, width,
                     (uint32_t *)tile_line, (uint32_t *)tile_line + tile_end_dx,
                     tile_width);
            byte_line += stride;
            tile_line += tile_stride;
            if (++tile_start_y == tile_height) {
                tile_line -= tile_height * tile_stride;
                tile_start_y = 0;
            }
        }
    }
}


void spice_pixman_blit(pixman_image_t *dest,
                       pixman_image_t *src,
                       int src_x, int src_y,
                       int dest_x, int dest_y,
                       int width, int height)
{
    uint32_t *bits, *src_bits;
    int stride, depth, src_depth;
    int src_width, src_height, src_stride;
    uint8_t *byte_line;
    uint8_t *src_line;
    int byte_width;

    if (!src) {
        fprintf(stderr, "missing src!");
        return;
    }

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    src_bits = pixman_image_get_data(src);
    src_stride = pixman_image_get_stride(src);
    src_width = pixman_image_get_width(src);
    src_height = pixman_image_get_height(src);
    src_depth = spice_pixman_image_get_bpp(src);

    /* Clip source */
    if (src_x < 0) {
        width += src_x;
        dest_x -= src_x;
        src_x = 0;
    }
    if (src_y < 0) {
        height += src_y;
        dest_y -= src_y;
        src_y = 0;
    }
    if (src_x + width > src_width) {
        width = src_width - src_x;
    }
    if (src_y + height > src_height) {
        height = src_height - src_y;
    }

    if (width <= 0 || height <= 0) {
        return;
    }

    spice_assert(src_x >= 0);
    spice_assert(src_y >= 0);
    spice_assert(dest_x >= 0);
    spice_assert(dest_y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(dest_x + width <= pixman_image_get_width(dest));
    spice_assert(dest_y + height <= pixman_image_get_height(dest));
    spice_assert(src_x + width <= pixman_image_get_width(src));
    spice_assert(src_y + height <= pixman_image_get_height(src));
    spice_assert(depth == src_depth);

    if (pixman_blt(src_bits,
                   bits,
                   src_stride / 4,
                   stride / 4,
                   depth, depth,
                   src_x, src_y,
                   dest_x, dest_y,
                   width, height)) {
        return;
    }

    if (depth == 8) {
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x;
        byte_width = width;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x;
    } else if (depth == 16) {
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 2;
        byte_width = width * 2;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 2;
    }  else {
        spice_assert (depth == 32);
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 4;
        byte_width = width * 4;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 4;
    }

    while (height--) {
        memcpy(byte_line, src_line, byte_width);
        byte_line += stride;
        src_line += src_stride;
    }
}

void spice_pixman_blit_rop (pixman_image_t *dest,
                            pixman_image_t *src,
                            int src_x, int src_y,
                            int dest_x, int dest_y,
                            int width, int height,
                            SpiceROP rop)
{
    uint32_t *bits, *src_bits;
    int stride, depth, src_depth;
    int src_width, src_height, src_stride;
    uint8_t *byte_line;
    uint8_t *src_line;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    src_bits = pixman_image_get_data(src);
    src_stride = pixman_image_get_stride(src);
    src_width = pixman_image_get_width(src);
    src_height = pixman_image_get_height(src);
    src_depth = spice_pixman_image_get_bpp(src);

    /* Clip source */
    if (src_x < 0) {
        width += src_x;
        dest_x -= src_x;
        src_x = 0;
    }
    if (src_y < 0) {
        height += src_y;
        dest_y -= src_y;
        src_y = 0;
    }
    if (src_x + width > src_width) {
        width = src_width - src_x;
    }
    if (src_y + height > src_height) {
        height = src_height - src_y;
    }

    if (width <= 0 || height <= 0) {
        return;
    }

    spice_assert(src_x >= 0);
    spice_assert(src_y >= 0);
    spice_assert(dest_x >= 0);
    spice_assert(dest_y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(dest_x + width <= pixman_image_get_width(dest));
    spice_assert(dest_y + height <= pixman_image_get_height(dest));
    spice_assert(src_x + width <= pixman_image_get_width(src));
    spice_assert(src_y + height <= pixman_image_get_height(src));
    spice_assert(depth == src_depth);

    if (depth == 8) {
        copy_rop_8_func_t rop_func = copy_rops_8[rop];

        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x;

        while (height--) {
            rop_func((uint8_t *)byte_line, (uint8_t *)src_line, width);
            byte_line += stride;
            src_line += src_stride;
        }
    } else if (depth == 16) {
        copy_rop_16_func_t rop_func = copy_rops_16[rop];

        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 2;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 2;

        while (height--) {
            rop_func((uint16_t *)byte_line, (uint16_t *)src_line, width);
            byte_line += stride;
            src_line += src_stride;
        }
    }  else {
        copy_rop_32_func_t rop_func = copy_rops_32[rop];

        spice_assert (depth == 32);
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 4;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 4;

        while (height--) {
            rop_func((uint32_t *)byte_line, (uint32_t *)src_line, width);
            byte_line += stride;
            src_line += src_stride;
        }
    }

}

void spice_pixman_blit_colorkey (pixman_image_t *dest,
                                 pixman_image_t *src,
                                 int src_x, int src_y,
                                 int dest_x, int dest_y,
                                 int width, int height,
                                 uint32_t transparent_color)
{
    uint32_t *bits, *src_bits;
    int stride, depth;
    int src_width, src_height, src_stride;
    uint8_t *byte_line;
    uint8_t *src_line;
    int x;

    bits = pixman_image_get_data(dest);
    stride = pixman_image_get_stride(dest);
    depth = spice_pixman_image_get_bpp(dest);
    /* stride is in bytes, depth in bits */

    src_bits = pixman_image_get_data(src);
    src_stride = pixman_image_get_stride(src);
    src_width = pixman_image_get_width(src);
    src_height = pixman_image_get_height(src);

    /* Clip source */
    if (src_x < 0) {
        width += src_x;
        dest_x -= src_x;
        src_x = 0;
    }
    if (src_y < 0) {
        height += src_y;
        dest_y -= src_y;
        src_y = 0;
    }
    if (src_x + width > src_width) {
        width = src_width - src_x;
    }
    if (src_y + height > src_height) {
        height = src_height - src_y;
    }

    if (width <= 0 || height <= 0) {
        return;
    }

    spice_assert(src_x >= 0);
    spice_assert(src_y >= 0);
    spice_assert(dest_x >= 0);
    spice_assert(dest_y >= 0);
    spice_assert(width > 0);
    spice_assert(height > 0);
    spice_assert(dest_x + width <= pixman_image_get_width(dest));
    spice_assert(dest_y + height <= pixman_image_get_height(dest));
    spice_assert(src_x + width <= pixman_image_get_width(src));
    spice_assert(src_y + height <= pixman_image_get_height(src));
    spice_assert(depth == spice_pixman_image_get_bpp(src));

    if (depth == 8) {
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x;

        while (height--) {
            uint8_t *d = (uint8_t *)byte_line;
            uint8_t *s = (uint8_t *)src_line;
            for (x = 0; x < width; x++) {
                uint8_t val = *s;
                if (val != (uint8_t)transparent_color) {
                    *d = val;
                }
                s++; d++;
            }

            byte_line += stride;
            src_line += src_stride;
        }
    } else if (depth == 16) {
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 2;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 2;

        while (height--) {
            uint16_t *d = (uint16_t *)byte_line;
            uint16_t *s = (uint16_t *)src_line;

            for (x = 0; x < width; x++) {
                uint16_t val = *s;
                if (val != (uint16_t)transparent_color) {
                    *d = val;
                }
                s++; d++;
            }

            byte_line += stride;
            src_line += src_stride;
        }
    }  else {
        spice_assert (depth == 32);
        byte_line = ((uint8_t *)bits) + stride * dest_y + dest_x * 4;
        src_line = ((uint8_t *)src_bits) + src_stride * src_y + src_x * 4;

        while (height--) {
            uint32_t *d = (uint32_t *)byte_line;
            uint32_t *s = (uint32_t *)src_line;

            transparent_color &= 0xffffff;
            for (x = 0; x < width; x++) {
                uint32_t val = *s;
                if ((0xffffff & val) != transparent_color) {
                    *d = val;
                }
                s++; d++;
            }

            byte_line += stride;
            src_line += src_stride;
        }
    }
}

static void copy_bits_up(uint8_t *data, const int stride, int bpp,
                         const int src_x, const int src_y,
                         const int width, const int height,
                         const int dest_x, const int dest_y)
{
    uint8_t *src = data + src_y * stride + src_x * bpp;
    uint8_t *dest = data + dest_y * stride + dest_x * bpp;
    uint8_t *end = dest + height * stride;
    for (; dest != end; dest += stride, src += stride) {
        memcpy(dest, src, width * bpp);
    }
}

static void copy_bits_down(uint8_t *data, const int stride, int bpp,
                           const int src_x, const int src_y,
                           const int width, const int height,
                           const int dest_x, const int dest_y)
{
    uint8_t *src = data + (src_y + height - 1) * stride + src_x * bpp;
    uint8_t *end = data + (dest_y - 1) * stride + dest_x * bpp;
    uint8_t *dest = end + height * stride;

    for (; dest != end; dest -= stride, src -= stride) {
        memcpy(dest, src, width * bpp);
    }
}

static void copy_bits_same_line(uint8_t *data, const int stride, int bpp,
                                const int src_x, const int src_y,
                                const int width, const int height,
                                const int dest_x, const int dest_y)
{
    uint8_t *src = data + src_y * stride + src_x * bpp;
    uint8_t *dest = data + dest_y * stride + dest_x * bpp;
    uint8_t *end = dest + height * stride;
    for (; dest != end; dest += stride, src += stride) {
        memmove(dest, src, width * bpp);
    }
}

void spice_pixman_copy_rect (pixman_image_t *image,
                             int src_x, int src_y,
                             int width, int height,
                             int dest_x, int dest_y)
{
    uint8_t *data;
    int stride;
    int bpp;

    data = (uint8_t *)pixman_image_get_data(image);
    stride = pixman_image_get_stride(image);
    bpp = spice_pixman_image_get_bpp(image) / 8;

    if (dest_y > src_y) {
        copy_bits_down(data, stride, bpp,
                       src_x, src_y,
                       width, height,
                       dest_x, dest_y);
    } else if (dest_y < src_y) {
        copy_bits_up(data, stride, bpp,
                     src_x, src_y,
                     width, height,
                     dest_x, dest_y);
    } else {
        copy_bits_same_line(data, stride, bpp,
                            src_x, src_y,
                            width, height,
                            dest_x, dest_y);
    }
}

pixman_bool_t spice_pixman_region32_init_rects (pixman_region32_t *region,
                                                const SpiceRect   *rects,
                                                int                count)
{
    /* These types are compatible, so just cast */
    return pixman_region32_init_rects(region, (pixman_box32_t *)rects, count);
}

pixman_format_code_t spice_surface_format_to_pixman(uint32_t surface_format)
{
    switch (surface_format) {
    case SPICE_SURFACE_FMT_1_A:
        return PIXMAN_a1;
    case SPICE_SURFACE_FMT_8_A:
        return PIXMAN_a8;
    case SPICE_SURFACE_FMT_16_555:
        return PIXMAN_x1r5g5b5;
    case SPICE_SURFACE_FMT_16_565:
        return PIXMAN_r5g6b5;
    case SPICE_SURFACE_FMT_32_xRGB:
        return PIXMAN_x8r8g8b8;
    case SPICE_SURFACE_FMT_32_ARGB:
        return PIXMAN_a8r8g8b8;
    default:
        g_error("Unknown surface format %d\n", surface_format);
        break;
    }
        return (pixman_format_code_t)0; /* Not reached */
}

/* Returns the "spice native" pixman version of a specific bitmap format.
 * This isn't bitwise the same as the bitmap format, for instance we
 * typically convert indexed to real color modes and use the standard
 * surface modes rather than weird things like 24bit
 */
pixman_format_code_t spice_bitmap_format_to_pixman(int bitmap_format,
                                                   uint32_t palette_surface_format)
{
    switch (bitmap_format) {
    case SPICE_BITMAP_FMT_1BIT_LE:
    case SPICE_BITMAP_FMT_1BIT_BE:
    case SPICE_BITMAP_FMT_4BIT_LE:
    case SPICE_BITMAP_FMT_4BIT_BE:
    case SPICE_BITMAP_FMT_8BIT:
        /* Indexed mode palettes are the same as their destination canvas format */
        return spice_surface_format_to_pixman(palette_surface_format);

    case SPICE_BITMAP_FMT_16BIT:
        return PIXMAN_x1r5g5b5;

    case SPICE_BITMAP_FMT_24BIT:
    case SPICE_BITMAP_FMT_32BIT:
        return PIXMAN_x8r8g8b8;

    case SPICE_BITMAP_FMT_RGBA:
        return PIXMAN_a8r8g8b8;

    case SPICE_BITMAP_FMT_8BIT_A:
        return PIXMAN_a8;

    case SPICE_BITMAP_FMT_INVALID:
    default:
        g_error("Unknown bitmap format %d\n", bitmap_format);
        return PIXMAN_a8r8g8b8;
    }
}

/* Tries to view a spice bitmap as a pixman_image_t without copying,
 * will often fail due to unhandled formats or strides.
 */
pixman_image_t *spice_bitmap_try_as_pixman(int src_format,
                                           int flags,
                                           int width,
                                           int height,
                                           uint8_t *data,
                                           int stride)
{
    pixman_format_code_t pixman_format;

    /* Pixman stride must be multiple of 4 */
    if (stride % 4 != 0) {
        return NULL;
    }

    switch (src_format) {
    case SPICE_BITMAP_FMT_32BIT:
        pixman_format = PIXMAN_LE_x8r8g8b8;
        break;
    case SPICE_BITMAP_FMT_RGBA:
        pixman_format = PIXMAN_LE_a8r8g8b8;
        break;
    case SPICE_BITMAP_FMT_24BIT:
        pixman_format = PIXMAN_LE_r8g8b8;
        break;
    case SPICE_BITMAP_FMT_16BIT:
#ifdef WORDS_BIGENDIAN
        return NULL;
#else
        pixman_format = PIXMAN_x1r5g5b5;
#endif
        break;

    default:
        return NULL;
    }

    if (!(flags & SPICE_BITMAP_FLAGS_TOP_DOWN)) {
        data += stride * (height - 1);
        stride = -stride;
    }

    return pixman_image_create_bits (pixman_format,
                                     width,
                                     height,
                                     (uint32_t *)data,
                                     stride);
}

#ifdef WORDS_BIGENDIAN
#define UINT16_FROM_LE(x) SPICE_BYTESWAP16(x)
#define UINT32_FROM_LE(x) SPICE_BYTESWAP32(x)
#else
#define UINT16_FROM_LE(x) (x)
#define UINT32_FROM_LE(x) (x)
#endif

static void bitmap_32_to_32(uint8_t* dest, int dest_stride,
                            uint8_t* src, int src_stride,
                            int width, uint8_t* end)
{
#ifdef WORDS_BIGENDIAN
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint32_t* src_line = (uint32_t *)src;
        uint32_t* src_line_end = src_line + width;
        uint32_t* dest_line = (uint32_t *)dest;

        for (; src_line < src_line_end; ++dest_line, ++src_line) {
            *dest_line = UINT32_FROM_LE(*src_line);
        }
    }
#else
    for (; src != end; src += src_stride, dest += dest_stride) {
        memcpy(dest, src, width * 4);
    }
#endif
}

static void bitmap_8_to_8(uint8_t* dest, int dest_stride,
                          uint8_t* src, int src_stride,
                          int width, uint8_t* end)
{
    for (; src != end; src += src_stride, dest += dest_stride) {
        memcpy(dest, src, width);
    }
}

static void bitmap_24_to_32(uint8_t* dest, int dest_stride,
                            uint8_t* src, int src_stride,
                            int width, uint8_t* end)
{
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint8_t* src_line = src;
        uint8_t* src_line_end = src_line + width * 3;
        uint32_t* dest_line = (uint32_t *)dest;

        for (; src_line < src_line_end; ++dest_line) {
            uint32_t r, g, b;
            b = *(src_line++);
            g = *(src_line++);
            r = *(src_line++);
            *dest_line = (r << 16) | (g << 8) | (b);
        }
    }
}

static void bitmap_16_to_16_555(uint8_t* dest, int dest_stride,
                                uint8_t* src, int src_stride,
                                int width, uint8_t* end)
{
#ifdef WORDS_BIGENDIAN
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint16_t* src_line = (uint16_t *)src;
        uint16_t* src_line_end = src_line + width;
        uint16_t* dest_line = (uint16_t *)dest;

        for (; src_line < src_line_end; ++dest_line, ++src_line) {
            *dest_line = UINT16_FROM_LE(*src_line);
        }
    }
#else
    for (; src != end; src += src_stride, dest += dest_stride) {
        memcpy(dest, src, width * 2);
    }
#endif
}

static void bitmap_8_32_to_32(uint8_t *dest, int dest_stride,
                              uint8_t *src, int src_stride,
                              int width, uint8_t *end,
                              SpicePalette *palette)
{
    uint32_t local_ents[256];
    uint32_t *ents;
    int n_ents;
#ifdef WORDS_BIGENDIAN
    int i;
#endif

    if (!palette) {
        spice_error("No palette");
        return;
    }

    n_ents = MIN(palette->num_ents, 256);
    ents = palette->ents;

    if (n_ents < 255
#ifdef WORDS_BIGENDIAN
        || TRUE
#endif
        ) {
        memcpy(local_ents, ents, n_ents*4);
        ents = local_ents;

#ifdef WORDS_BIGENDIAN
        for (i = 0; i < n_ents; i++) {
            ents[i] = UINT32_FROM_LE(ents[i]);
        }
#endif
    }

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint32_t *dest_line = (uint32_t*)dest;
        uint8_t *src_line = src;
        uint8_t *src_line_end = src_line + width;

        while (src_line < src_line_end) {
            *(dest_line++) = ents[*(src_line++)];
        }
    }
}

static void bitmap_8_16_to_16_555(uint8_t *dest, int dest_stride,
                                  uint8_t *src, int src_stride,
                                  int width, uint8_t *end,
                                  SpicePalette *palette)
{
    uint32_t local_ents[256];
    uint32_t *ents;
    int n_ents;
#ifdef WORDS_BIGENDIAN
    int i;
#endif

    if (!palette) {
        spice_error("No palette");
        return;
    }

    n_ents = MIN(palette->num_ents, 256);
    ents = palette->ents;

    if (n_ents < 255
#ifdef WORDS_BIGENDIAN
        || TRUE
#endif
        ) {
        memcpy(local_ents, ents, n_ents*4);
        ents = local_ents;

#ifdef WORDS_BIGENDIAN
        for (i = 0; i < n_ents; i++) {
            ents[i] = UINT32_FROM_LE(ents[i]);
        }
#endif
    }

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint16_t *dest_line = (uint16_t*)dest;
        uint8_t *src_line = src;
        uint8_t *src_line_end = src_line + width;

        while (src_line < src_line_end) {
            *(dest_line++) = ents[*(src_line++)];
        }
    }
}

static void bitmap_4be_32_to_32(uint8_t* dest, int dest_stride,
                                uint8_t* src, int src_stride,
                                int width, uint8_t* end,
                                SpicePalette *palette)
{
    uint32_t local_ents[16];
    uint32_t *ents;
    int n_ents;
#ifdef WORDS_BIGENDIAN
    int i;
#endif

    if (!palette) {
        spice_error("No palette");
        return;
    }

    n_ents = MIN(palette->num_ents, 16);
    ents = palette->ents;

    if (n_ents < 16
#ifdef WORDS_BIGENDIAN
        || TRUE
#endif
        ) {
        memcpy(local_ents, ents, n_ents*4);
        ents = local_ents;

#ifdef WORDS_BIGENDIAN
        for (i = 0; i < n_ents; i++) {
            ents[i] = UINT32_FROM_LE(ents[i]);
        }
#endif
    }

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint32_t *dest_line = (uint32_t *)dest;
        uint8_t *row = src;
        int i;

        for (i = 0; i < (width >> 1); i++) {
            *(dest_line++) = ents[(*row >> 4) & 0x0f];
            *(dest_line++) = ents[*(row++) & 0x0f];
        }
        if (width & 1) {
            *(dest_line) = ents[(*row >> 4) & 0x0f];
        }
    }
}

static void bitmap_4be_16_to_16_555(uint8_t* dest, int dest_stride,
                                    uint8_t* src, int src_stride,
                                    int width, uint8_t* end,
                                    SpicePalette *palette)
{
    uint32_t local_ents[16];
    uint32_t *ents;
    int n_ents;
#ifdef WORDS_BIGENDIAN
    int i;
#endif

    if (!palette) {
        spice_error("No palette");
        return;
    }

    n_ents = MIN(palette->num_ents, 16);
    ents = palette->ents;

    if (n_ents < 16
#ifdef WORDS_BIGENDIAN
        || TRUE
#endif
        ) {
        memcpy(local_ents, ents, n_ents*4);
        ents = local_ents;

#ifdef WORDS_BIGENDIAN
        for (i = 0; i < n_ents; i++) {
            ents[i] = UINT32_FROM_LE(ents[i]);
        }
#endif
    }

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint16_t *dest_line = (uint16_t *)dest;
        uint8_t *row = src;
        int i;

        for (i = 0; i < (width >> 1); i++) {
            *(dest_line++) = ents[(*row >> 4) & 0x0f];
            *(dest_line++) = ents[*(row++) & 0x0f];
        }
        if (width & 1) {
            *(dest_line) = ents[(*row >> 4) & 0x0f];
        }
    }
}

static inline int test_bit_be(void* addr, int bit)
{
    return !!(((uint8_t*)addr)[bit >> 3] & (0x80 >> (bit & 0x07)));
}

static void bitmap_1be_32_to_32(uint8_t* dest, int dest_stride,
                                uint8_t* src, int src_stride,
                                int width, uint8_t* end,
                                SpicePalette *palette)
{
    uint32_t fore_color;
    uint32_t back_color;

    spice_assert(palette != NULL);

    if (!palette) {
        return;
    }

    fore_color = UINT32_FROM_LE(palette->ents[1]);
    back_color = UINT32_FROM_LE(palette->ents[0]);

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint32_t* dest_line = (uint32_t*)dest;
        int i;

        for (i = 0; i < width; i++) {
            if (test_bit_be(src, i)) {
                *(dest_line++) = fore_color;
            } else {
                *(dest_line++) = back_color;
            }
        }
    }
}


static void bitmap_1be_16_to_16_555(uint8_t* dest, int dest_stride,
                                    uint8_t* src, int src_stride,
                                    int width, uint8_t* end,
                                    SpicePalette *palette)
{
    uint16_t fore_color;
    uint16_t back_color;

    spice_assert(palette != NULL);

    if (!palette) {
        return;
    }

    fore_color = (uint16_t) UINT32_FROM_LE(palette->ents[1]);
    back_color = (uint16_t) UINT32_FROM_LE(palette->ents[0]);

    for (; src != end; src += src_stride, dest += dest_stride) {
        uint16_t* dest_line = (uint16_t*)dest;
        int i;

        for (i = 0; i < width; i++) {
            if (test_bit_be(src, i)) {
                *(dest_line++) = fore_color;
            } else {
                *(dest_line++) = back_color;
            }
        }
    }
}

#ifdef NOT_USED_ATM

static inline uint32_t rgb_16_555_to_32(uint16_t color)
{
    uint32_t ret;

    ret = ((color & 0x001f) << 3) | ((color & 0x001c) >> 2);
    ret |= ((color & 0x03e0) << 6) | ((color & 0x0380) << 1);
    ret |= ((color & 0x7c00) << 9) | ((color & 0x7000) << 4);

    return ret;
}

static inline uint16_t rgb_32_to_16_555(uint32_t color)
{
    return
        (((color) >> 3) & 0x001f) |
        (((color) >> 6) & 0x03e0) |
        (((color) >> 9) & 0x7c00);
}

static void bitmap_16_to_32(uint8_t* dest, int dest_stride,
                            uint8_t* src, int src_stride,
                            int width, uint8_t* end)
{
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint16_t* src_line = (uint16_t*)src;
        uint16_t* src_line_end = src_line + width;
        uint32_t* dest_line = (uint32_t*)dest;

        for (; src_line < src_line_end; ++dest_line, src_line++) {
            *dest_line = rgb_16_555_to_32(UINT16_FROM_LE(*src_line));
        }
    }
}

static void bitmap_32_to_16_555(uint8_t* dest, int dest_stride,
                                uint8_t* src, int src_stride,
                                int width, uint8_t* end)
{
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint32_t* src_line = (uint32_t *)src;
        uint32_t* src_line_end = src_line + width;
        uint16_t* dest_line = (uint16_t *)dest;

        for (; src_line < src_line_end; ++dest_line, ++src_line) {
            *dest_line = rgb_32_to_16_555(UINT16_FROM_LE(*src_line));
        }
    }
}


static void bitmap_24_to_16_555(uint8_t* dest, int dest_stride,
                                uint8_t* src, int src_stride,
                                int width, uint8_t* end)
{
    for (; src != end; src += src_stride, dest += dest_stride) {
        uint8_t* src_line = src;
        uint8_t* src_line_end = src_line + width * 3;
        uint16_t* dest_line = (uint16_t *)dest;

        for (; src_line < src_line_end; ++dest_line) {
            uint8_t r, g, b;
            b = *(src_line++);
            g = *(src_line++);
            r = *(src_line++);
            *dest_line = rgb_32_to_16_555(r << 24 | g << 16 | b);
        }
    }
}

#endif

/* This assumes that the dest, if set is the same format as
   spice_bitmap_format_to_pixman would have picked */
pixman_image_t *spice_bitmap_to_pixman(pixman_image_t *dest_image,
                                       int src_format,
                                       int flags,
                                       int width,
                                       int height,
                                       uint8_t *src,
                                       int src_stride,
                                       uint32_t palette_surface_format,
                                       SpicePalette *palette)
{
    uint8_t* dest;
    int dest_stride;
    uint8_t* end;

    if (dest_image == NULL) {
        pixman_format_code_t dest_format;

        dest_format = spice_bitmap_format_to_pixman(src_format,
                                                    palette_surface_format);
        dest_image = pixman_image_create_bits (dest_format,
                                               width, height,
                                               NULL, 0);
    }

    dest = (uint8_t *)pixman_image_get_data(dest_image);
    dest_stride = pixman_image_get_stride(dest_image);
    if (!(flags & SPICE_BITMAP_FLAGS_TOP_DOWN)) {
        spice_assert(height > 0);
        dest += dest_stride * (height - 1);
        dest_stride = -dest_stride;
    }
    end = src + (height * src_stride);

    switch (src_format) {
    case SPICE_BITMAP_FMT_32BIT:
    case SPICE_BITMAP_FMT_RGBA:
        bitmap_32_to_32(dest, dest_stride, src, src_stride, width, end);
        break;
    case SPICE_BITMAP_FMT_8BIT_A:
        bitmap_8_to_8(dest, dest_stride, src, src_stride, width, end);
        break;
    case SPICE_BITMAP_FMT_24BIT:
        bitmap_24_to_32(dest, dest_stride, src, src_stride, width, end);
        break;
    case SPICE_BITMAP_FMT_16BIT:
        bitmap_16_to_16_555(dest, dest_stride, src, src_stride, width, end);
        break;
    case SPICE_BITMAP_FMT_8BIT:
        if (palette_surface_format == SPICE_SURFACE_FMT_32_ARGB ||
            palette_surface_format == SPICE_SURFACE_FMT_32_xRGB) {
            bitmap_8_32_to_32(dest, dest_stride, src, src_stride, width, end, palette);
        } else if (palette_surface_format == SPICE_SURFACE_FMT_16_555) {
            bitmap_8_16_to_16_555(dest, dest_stride, src, src_stride, width, end, palette);
        } else {
            spice_error("Unsupported palette format");
        }
        break;
    case SPICE_BITMAP_FMT_4BIT_BE:
        if (palette_surface_format == SPICE_SURFACE_FMT_32_ARGB ||
            palette_surface_format == SPICE_SURFACE_FMT_32_xRGB) {
            bitmap_4be_32_to_32(dest, dest_stride, src, src_stride, width, end, palette);
        } else if (palette_surface_format == SPICE_SURFACE_FMT_16_555) {
            bitmap_4be_16_to_16_555(dest, dest_stride, src, src_stride, width, end, palette);
        } else {
            spice_error("Unsupported palette format");
        }
        break;
    case SPICE_BITMAP_FMT_1BIT_BE:
        if (palette_surface_format == SPICE_SURFACE_FMT_32_ARGB ||
            palette_surface_format == SPICE_SURFACE_FMT_32_xRGB) {
            bitmap_1be_32_to_32(dest, dest_stride, src, src_stride, width, end, palette);
        } else if (palette_surface_format == SPICE_SURFACE_FMT_16_555) {
            bitmap_1be_16_to_16_555(dest, dest_stride, src, src_stride, width, end, palette);
        } else {
            spice_error("Unsupported palette format");
        }
        break;
    default:
        spice_error("Unsupported bitmap format");
        break;
    }

    return dest_image;
}

static int pixman_format_compatible (pixman_format_code_t dest_format,
                              pixman_format_code_t src_format)
{
    if (dest_format == src_format) {
        return TRUE;
    }

    if (src_format == PIXMAN_a8r8g8b8 &&
        dest_format == PIXMAN_x8r8g8b8) {
        /* This is the same, we just ignore the alphas */
        return TRUE;
    }

    return FALSE;
}

pixman_image_t *spice_bitmap_convert_to_pixman(pixman_format_code_t dest_format,
                                               pixman_image_t *dest_image,
                                               int src_format,
                                               int flags,
                                               int width,
                                               int height,
                                               uint8_t *src,
                                               int src_stride,
                                               uint32_t palette_surface_format,
                                               SpicePalette *palette)
{
    pixman_image_t *src_image;
    pixman_format_code_t native_format;

    if (dest_image == NULL) {
        dest_image = pixman_image_create_bits (dest_format,
                                               width, height,
                                               NULL, 0);
    }

    native_format =
        spice_bitmap_format_to_pixman(src_format, palette_surface_format);

    if (pixman_format_compatible (dest_format, native_format)) {
        return spice_bitmap_to_pixman(dest_image,
                                      src_format,
                                      flags, width,height,
                                      src, src_stride,
                                      palette_surface_format, palette);
    }

    src_image = spice_bitmap_try_as_pixman(src_format,
                                           flags, width,height,
                                           src, src_stride);

    /* Can't convert directly, need a temporary copy
     * Hopefully most bitmap reads should not need conversion (i.e.
     * hit the spice_bitmap_to_pixmap case above) or work with the
     * try_as_pixmap case, but in case some specific combination
     * shows up here commonly we might want to add non-temporary
     * conversion special casing here */
    if (src_image == NULL) {
        src_image = spice_bitmap_to_pixman(NULL,
                                           src_format,
                                           flags, width,height,
                                           src, src_stride,
                                           palette_surface_format, palette);
    }

    pixman_image_composite32 (PIXMAN_OP_SRC,
                              src_image, NULL, dest_image,
                              0, 0,
                              0, 0,
                              0, 0,
                              width, height);

    pixman_image_unref (src_image);

    return dest_image;
}

```

`devices/display/qxl/canvas/pixman_utils.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_PIXMAN_UTILS
#define H_SPICE_COMMON_PIXMAN_UTILS

#include <spice/types.h>
#include <spice/macros.h>
#include <stdlib.h>
#define PIXMAN_DONT_DEFINE_STDINT
#include <pixman.h>

#include "draw.h"

#ifdef WORDS_BIGENDIAN
# define PIXMAN_LE_x8r8g8b8   PIXMAN_b8g8r8x8
# define PIXMAN_LE_a8r8g8b8   PIXMAN_b8g8r8a8
# define PIXMAN_LE_r8g8b8     PIXMAN_b8g8r8
#else
# define PIXMAN_LE_x8r8g8b8   PIXMAN_x8r8g8b8
# define PIXMAN_LE_a8r8g8b8   PIXMAN_a8r8g8b8
# define PIXMAN_LE_r8g8b8     PIXMAN_r8g8b8
#endif

SPICE_BEGIN_DECLS

/* This lists all possible 2 argument binary raster ops.
 * This enum has the same values as the X11 GXcopy type
 * and same as the GL constants (GL_AND etc) if you
 * or it with 0x1500. However it is not exactly the
 * same as the win32 ROP2 type (they use another order).
 */
typedef enum {
    SPICE_ROP_CLEAR,         /* 0x0    0 */
    SPICE_ROP_AND,           /* 0x1    src AND dst */
    SPICE_ROP_AND_REVERSE,   /* 0x2    src AND NOT dst */
    SPICE_ROP_COPY,          /* 0x3    src */
    SPICE_ROP_AND_INVERTED,  /* 0x4    (NOT src) AND dst */
    SPICE_ROP_NOOP,          /* 0x5    dst */
    SPICE_ROP_XOR,           /* 0x6    src XOR dst */
    SPICE_ROP_OR,            /* 0x7    src OR dst */
    SPICE_ROP_NOR,           /* 0x8    (NOT src) AND (NOT dst) */
    SPICE_ROP_EQUIV,         /* 0x9    (NOT src) XOR dst */
    SPICE_ROP_INVERT,        /* 0xa    NOT dst */
    SPICE_ROP_OR_REVERSE,    /* 0xb    src OR (NOT dst) */
    SPICE_ROP_COPY_INVERTED, /* 0xc    NOT src */
    SPICE_ROP_OR_INVERTED,   /* 0xd    (NOT src) OR dst */
    SPICE_ROP_NAND,          /* 0xe    (NOT src) OR (NOT dst) */
    SPICE_ROP_SET            /* 0xf    1 */
} SpiceROP;


int spice_pixman_image_get_bpp(pixman_image_t *image);

pixman_format_code_t spice_surface_format_to_pixman(uint32_t surface_format);
pixman_format_code_t spice_bitmap_format_to_pixman(int bitmap_format,
                                                   uint32_t palette_surface_format);
pixman_image_t *spice_bitmap_try_as_pixman(int src_format, int flags,
                                           int width, int height,
                                           uint8_t *data, int stride);
pixman_image_t *spice_bitmap_to_pixman(pixman_image_t *dest_image,
                                       int src_format, int flags,
                                       int width, int height,
                                       uint8_t *src, int src_stride,
                                       uint32_t palette_surface_format,
                                       SpicePalette *palette);
pixman_image_t *spice_bitmap_convert_to_pixman(pixman_format_code_t dest_format,
                                               pixman_image_t *dest_image,
                                               int src_format, int flags,
                                               int width, int height,
                                               uint8_t *src, int src_stride,
                                               uint32_t palette_surface_format,
                                               SpicePalette *palette);

void spice_pixman_region32_init_from_bitmap(pixman_region32_t *region,
                                            uint32_t *data,
                                            int width, int height,
                                            int stride);
pixman_bool_t spice_pixman_region32_init_rects(pixman_region32_t *region,
                                               const SpiceRect   *rects,
                                               int                count);
void spice_pixman_fill_rect(pixman_image_t *dest,
                            int x, int y,
                            int w, int h,
                            uint32_t value);
void spice_pixman_fill_rect_rop(pixman_image_t *dest,
                                int x, int y,
                                int w, int h,
                                uint32_t value,
                                SpiceROP rop);
void spice_pixman_tile_rect(pixman_image_t *dest,
                            int x, int y,
                            int w, int h,
                            pixman_image_t *tile,
                            int offset_x,
                            int offset_y);
void spice_pixman_tile_rect_rop(pixman_image_t *dest,
                                int x, int y,
                                int w, int h,
                                pixman_image_t *tile,
                                int offset_x,
                                int offset_y,
                                SpiceROP rop);
void spice_pixman_blit(pixman_image_t *dest,
                       pixman_image_t *src,
                       int src_x, int src_y,
                       int dest_x, int dest_y,
                       int w, int h);
void spice_pixman_blit_rop(pixman_image_t *dest,
                           pixman_image_t *src,
                           int src_x, int src_y,
                           int dest_x, int dest_y,
                           int w, int h,
                           SpiceROP rop);
void spice_pixman_blit_colorkey(pixman_image_t *dest,
                                pixman_image_t *src,
                                int src_x, int src_y,
                                int dest_x, int dest_y,
                                int width, int height,
                                uint32_t transparent_color);
void spice_pixman_copy_rect(pixman_image_t *image,
                            int src_x, int src_y,
                            int w, int h,
                            int dest_x, int dest_y);

SPICE_END_DECLS

#endif // H_SPICE_COMMON_PIXMAN_UTILS

```

`devices/display/qxl/canvas/quic.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

// Red Hat image compression based on SFALIC by Roman Starosolski
// http://sun.iinf.polsl.gliwice.pl/~rstaros/sfalic/index.html

#include "config.h"

#include "quic_config.h"
#include "quic.h"
#include "log.h"

/* ASCII "QUIC" */
#define QUIC_MAGIC 0x43495551
#define QUIC_VERSION_MAJOR 0U
#define QUIC_VERSION_MINOR 0U
#define QUIC_VERSION ((QUIC_VERSION_MAJOR << 16) | (QUIC_VERSION_MINOR & 0xffff))

typedef uint8_t BYTE;

/* maximum number of codes in family */
#define MAXNUMCODES 8

/* model evolution, warning: only 1,3 and 5 allowed */
#define DEFevol 3
#define MINevol 0
#define MAXevol 5

/* starting wait mask index */
#define DEFwmistart 0
#define MINwmistart 0

/* codeword length limit */
#define DEFmaxclen 26

/* target wait mask index */
#define DEFwmimax 6

/* number of symbols to encode before increasing wait mask index */
#define DEFwminext 2048
#define MINwminext 1
#define MAXwminext 100000000

/* Maximum image size in pixels, mainly to avoid possible integer overflows */
#define SPICE_MAX_IMAGE_SIZE (512 * 1024 * 1024 - 1)

typedef struct QuicFamily {
    unsigned int nGRcodewords[MAXNUMCODES];      /* indexed by code number, contains number of
                                                    unmodified GR codewords in the code */
    unsigned int notGRcwlen[MAXNUMCODES];        /* indexed by code number, contains codeword
                                                    length of the not-GR codeword */
    unsigned int notGRprefixmask[MAXNUMCODES];   /* indexed by code number, contains mask to
                                                    determine if the codeword is GR or not-GR */
    unsigned int notGRsuffixlen[MAXNUMCODES];    /* indexed by code number, contains suffix
                                                    length of the not-GR codeword */

    unsigned int golomb_code_len[256][MAXNUMCODES];
    unsigned int golomb_code[256][MAXNUMCODES];

    /* array for translating distribution U to L for depths up to 8 bpp,
    initialized by decorrelate_init() */
    BYTE xlatU2L[256];

    /* array for translating distribution L to U for depths up to 8 bpp,
       initialized by correlate_init() */
    unsigned int xlatL2U[256];
} QuicFamily;

static QuicFamily family_8bpc;
static QuicFamily family_5bpc;

typedef unsigned COUNTER;   /* counter in the array of counters in bucket of the data model */

typedef struct s_bucket {
    COUNTER *pcounters;     /* pointer to array of counters */
    unsigned int bestcode;  /* best code so far */
} s_bucket;

typedef struct Encoder Encoder;

static inline void encode(Encoder *encoder, unsigned int word, unsigned int len);

typedef struct CommonState {
    unsigned int waitcnt;
    unsigned int tabrand_seed;
    unsigned int wm_trigger;
    unsigned int wmidx;
    unsigned int wmileft;

    int melcstate; /* index to the state array */

    int melclen;  /* contents of the state array location
                     indexed by melcstate: the "expected"
                     run length is 2^melclen, shorter runs are
                     encoded by a 1 followed by the run length
                     in binary representation, wit a fixed length
                     of melclen bits */

    unsigned long melcorder;  /* 2^ melclen */
} CommonState;


#define MAX_CHANNELS 4

typedef struct FamilyStat {
    s_bucket **buckets_ptrs;
    s_bucket *buckets_buf;
    COUNTER *counters;
} FamilyStat;

typedef struct Channel {
    int correlate_row_width;
    BYTE *correlate_row;

    s_bucket **_buckets_ptrs;

    FamilyStat family_stat_8bpc;
    FamilyStat family_stat_5bpc;

    CommonState state;
} Channel;

struct Encoder {
    QuicUsrContext *usr;
    QuicImageType type;
    unsigned int width;
    unsigned int height;

    unsigned int n_buckets_8bpc;
    unsigned int n_buckets_5bpc;

    unsigned int io_available_bits;
    uint32_t io_word;
    uint32_t io_next_word;
    uint32_t *io_now;
    uint32_t *io_end;
    uint32_t io_words_count;

    int rows_completed;

    Channel channels[MAX_CHANNELS];

    CommonState rgb_state;
};

/* bppmask[i] contains i ones as lsb-s */
static const unsigned int bppmask[33] = {
    0x00000000, /* [0] */
    0x00000001, 0x00000003, 0x00000007, 0x0000000f,
    0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff,
    0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff,
    0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff,
    0x0001ffff, 0x0003ffff, 0x0007ffff, 0x000fffff,
    0x001fffff, 0x003fffff, 0x007fffff, 0x00ffffff,
    0x01ffffff, 0x03ffffff, 0x07ffffff, 0x0fffffff,
    0x1fffffff, 0x3fffffff, 0x7fffffff, 0xffffffff /* [32] */
};

#define bitat(n) (1u<<(n))


#define TABRAND_TABSIZE 256
#define TABRAND_SEEDMASK 0x0ff

static const unsigned int tabrand_chaos[TABRAND_TABSIZE] = {
    0x02c57542, 0x35427717, 0x2f5a2153, 0x9244f155, 0x7bd26d07, 0x354c6052, 0x57329b28, 0x2993868e,
    0x6cd8808c, 0x147b46e0, 0x99db66af, 0xe32b4cac, 0x1b671264, 0x9d433486, 0x62a4c192, 0x06089a4b,
    0x9e3dce44, 0xdaabee13, 0x222425ea, 0xa46f331d, 0xcd589250, 0x8bb81d7f, 0xc8b736b9, 0x35948d33,
    0xd7ac7fd0, 0x5fbe2803, 0x2cfbc105, 0x013dbc4e, 0x7a37820f, 0x39f88e9e, 0xedd58794, 0xc5076689,
    0xfcada5a4, 0x64c2f46d, 0xb3ba3243, 0x8974b4f9, 0x5a05aebd, 0x20afcd00, 0x39e2b008, 0x88a18a45,
    0x600bde29, 0xf3971ace, 0xf37b0a6b, 0x7041495b, 0x70b707ab, 0x06beffbb, 0x4206051f, 0xe13c4ee3,
    0xc1a78327, 0x91aa067c, 0x8295f72a, 0x732917a6, 0x1d871b4d, 0x4048f136, 0xf1840e7e, 0x6a6048c1,
    0x696cb71a, 0x7ff501c3, 0x0fc6310b, 0x57e0f83d, 0x8cc26e74, 0x11a525a2, 0x946934c7, 0x7cd888f0,
    0x8f9d8604, 0x4f86e73b, 0x04520316, 0xdeeea20c, 0xf1def496, 0x67687288, 0xf540c5b2, 0x22401484,
    0x3478658a, 0xc2385746, 0x01979c2c, 0x5dad73c8, 0x0321f58b, 0xf0fedbee, 0x92826ddf, 0x284bec73,
    0x5b1a1975, 0x03df1e11, 0x20963e01, 0xa17cf12b, 0x740d776e, 0xa7a6bf3c, 0x01b5cce4, 0x1118aa76,
    0xfc6fac0a, 0xce927e9b, 0x00bf2567, 0x806f216c, 0xbca69056, 0x795bd3e9, 0xc9dc4557, 0x8929b6c2,
    0x789d52ec, 0x3f3fbf40, 0xb9197368, 0xa38c15b5, 0xc3b44fa8, 0xca8333b0, 0xb7e8d590, 0xbe807feb,
    0xbf5f8360, 0xd99e2f5c, 0x372928e1, 0x7c757c4c, 0x0db5b154, 0xc01ede02, 0x1fc86e78, 0x1f3985be,
    0xb4805c77, 0x00c880fa, 0x974c1b12, 0x35ab0214, 0xb2dc840d, 0x5b00ae37, 0xd313b026, 0xb260969d,
    0x7f4c8879, 0x1734c4d3, 0x49068631, 0xb9f6a021, 0x6b863e6f, 0xcee5debf, 0x29f8c9fb, 0x53dd6880,
    0x72b61223, 0x1f67a9fd, 0x0a0f6993, 0x13e59119, 0x11cca12e, 0xfe6b6766, 0x16b6effc, 0x97918fc4,
    0xc2b8a563, 0x94f2f741, 0x0bfa8c9a, 0xd1537ae8, 0xc1da349c, 0x873c60ca, 0x95005b85, 0x9b5c080e,
    0xbc8abbd9, 0xe1eab1d2, 0x6dac9070, 0x4ea9ebf1, 0xe0cf30d4, 0x1ef5bd7b, 0xd161043e, 0x5d2fa2e2,
    0xff5d3cae, 0x86ed9f87, 0x2aa1daa1, 0xbd731a34, 0x9e8f4b22, 0xb1c2c67a, 0xc21758c9, 0xa182215d,
    0xccb01948, 0x8d168df7, 0x04238cfe, 0x368c3dbc, 0x0aeadca5, 0xbad21c24, 0x0a71fee5, 0x9fc5d872,
    0x54c152c6, 0xfc329483, 0x6783384a, 0xeddb3e1c, 0x65f90e30, 0x884ad098, 0xce81675a, 0x4b372f7d,
    0x68bf9a39, 0x43445f1e, 0x40f8d8cb, 0x90d5acb6, 0x4cd07282, 0x349eeb06, 0x0c9d5332, 0x520b24ef,
    0x80020447, 0x67976491, 0x2f931ca3, 0xfe9b0535, 0xfcd30220, 0x61a9e6cc, 0xa487d8d7, 0x3f7c5dd1,
    0x7d0127c5, 0x48f51d15, 0x60dea871, 0xc9a91cb7, 0x58b53bb3, 0x9d5e0b2d, 0x624a78b4, 0x30dbee1b,
    0x9bdf22e7, 0x1df5c299, 0x2d5643a7, 0xf4dd35ff, 0x03ca8fd6, 0x53b47ed8, 0x6f2c19aa, 0xfeb0c1f4,
    0x49e54438, 0x2f2577e6, 0xbf876969, 0x72440ea9, 0xfa0bafb8, 0x74f5b3a0, 0x7dd357cd, 0x89ce1358,
    0x6ef2cdda, 0x1e7767f3, 0xa6be9fdb, 0x4f5f88f8, 0xba994a3a, 0x08ca6b65, 0xe0893818, 0x9e00a16a,
    0xf42bfc8f, 0x9972eedc, 0x749c8b51, 0x32c05f5e, 0xd706805f, 0x6bfbb7cf, 0xd9210a10, 0x31a1db97,
    0x923a9559, 0x37a7a1f6, 0x059f8861, 0xca493e62, 0x65157e81, 0x8f6467dd, 0xab85ff9f, 0x9331aff2,
    0x8616b9f5, 0xedbd5695, 0xee7e29b1, 0x313ac44f, 0xb903112f, 0x432ef649, 0xdc0a36c0, 0x61cf2bba,
    0x81474925, 0xa8b6c7ad, 0xee5931de, 0xb2f8158d, 0x59fb7409, 0x2e3dfaed, 0x9af25a3f, 0xe1fed4d5,
};

static unsigned int stabrand(void)
{
    SPICE_VERIFY( !(TABRAND_SEEDMASK & TABRAND_TABSIZE));
    SPICE_VERIFY( TABRAND_SEEDMASK + 1 == TABRAND_TABSIZE );

    return TABRAND_SEEDMASK;
}

static unsigned int tabrand(unsigned int *tabrand_seed)
{
    return tabrand_chaos[++*tabrand_seed & TABRAND_SEEDMASK];
}

static const unsigned short besttrigtab[3][11] = { /* array of wm_trigger for waitmask and DEFevol,
                                                    used by set_wm_trigger() */
    /* 1 */ { 550, 900, 800, 700, 500, 350, 300, 200, 180, 180, 160},
    /* 3 */ { 110, 550, 900, 800, 550, 400, 350, 250, 140, 160, 140},
    /* 5 */ { 100, 120, 550, 900, 700, 500, 400, 300, 220, 250, 160}
};

/* set wm_trigger knowing waitmask (param) and DEFevol (glob)*/
static void set_wm_trigger(CommonState *state)
{
    unsigned int wm = state->wmidx;
    if (wm > 10) {
        wm = 10;
    }

    SPICE_VERIFY(DEFevol < 6);

    state->wm_trigger = besttrigtab[DEFevol / 2][wm];

    spice_assert(state->wm_trigger <= 2000);
    spice_assert(state->wm_trigger >= 1);
}

static int ceil_log_2(int val) /* ceil(log_2(val)) */
{
    int result;

    //spice_assert(val>0);

    if (val == 1) {
        return 0;
    }

    result = 1;
    val -= 1;
    while (val >>= 1) {
        result++;
    }

    return result;
}

/* number of leading zeroes in the byte, used by cntlzeroes(uint)*/
static const BYTE lzeroes[256] = {
    8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

/* count leading zeroes */
static unsigned int cnt_l_zeroes(const unsigned int bits)
{
    spice_extra_assert(bits != 0);
#if defined(__GNUC__) && __GNUC__ >= 4
    return __builtin_clz(bits);
#else
    if (bits & 0xff800000) {
        return lzeroes[bits >> 24];
    } else if (bits & 0xffff8000) {
        return 8 + lzeroes[(bits >> 16) & 0x000000ff];
    } else if (bits & 0xffffff80) {
        return 16 + lzeroes[(bits >> 8) & 0x000000ff];
    } else {
        return 24 + lzeroes[bits & 0x000000ff];
    }
#endif
}

#define QUIC_FAMILY_8BPC
#include "quic_family_tmpl.c"

#define QUIC_FAMILY_5BPC
#include "quic_family_tmpl.c"

static void decorrelate_init(QuicFamily *family, int bpc)
{
    const unsigned int pixelbitmask = bppmask[bpc];
    const unsigned int pixelbitmaskshr = pixelbitmask >> 1;
    unsigned int s;

    //spice_assert(bpc <= 8);

    for (s = 0; s <= pixelbitmask; s++) {
        if (s <= pixelbitmaskshr) {
            family->xlatU2L[s] = s << 1;
        } else {
            family->xlatU2L[s] = ((pixelbitmask - s) << 1) + 1;
        }
    }
}

static void correlate_init(QuicFamily *family, int bpc)
{
    const unsigned int pixelbitmask = bppmask[bpc];
    unsigned long int s;

    //spice_assert(bpc <= 8);

    for (s = 0; s <= pixelbitmask; s++) {
        if (s & 0x01) {
            family->xlatL2U[s] = pixelbitmask - (s >> 1);
        } else {
            family->xlatL2U[s] = (s >> 1);
        }
    }
}

static void golomb_coding_slow(const QuicFamily *family, const BYTE n, const unsigned int l,
                               unsigned int * const codeword,
                               unsigned int * const codewordlen)
{
    if (n < family->nGRcodewords[l]) {
        (*codeword) = bitat(l) | (n & bppmask[l]);
        (*codewordlen) = (n >> l) + l + 1;
    } else {
        (*codeword) = n - family->nGRcodewords[l];
        (*codewordlen) = family->notGRcwlen[l];
    }
}

static void family_init(QuicFamily *family, int bpc, int limit)
{
    int l, b;

    for (l = 0; l < bpc; l++) { /* fill arrays indexed by code number */
        int altprefixlen, altcodewords;

        altprefixlen = limit - bpc;
        if (altprefixlen > (int)(bppmask[bpc - l])) {
            altprefixlen = bppmask[bpc - l];
        }

        altcodewords = bppmask[bpc] + 1 - (altprefixlen << l);

        family->nGRcodewords[l] = (altprefixlen << l);
        family->notGRsuffixlen[l] = ceil_log_2(altcodewords); /* needed for decoding only */
        family->notGRcwlen[l] = altprefixlen + family->notGRsuffixlen[l];
        family->notGRprefixmask[l] = bppmask[32 - altprefixlen]; /* needed for decoding only */

        for (b = 0; b < 256; b++) {
            unsigned int code, len;
            golomb_coding_slow(family, b, l, &code, &len);
            family->golomb_code[b][l] = code;
            family->golomb_code_len[b][l] = len;
        }
    }

    decorrelate_init(family, bpc);
    correlate_init(family, bpc);
}

static void more_io_words(Encoder *encoder)
{
    uint32_t *io_ptr;
    int num_io_words = encoder->usr->more_space(encoder->usr, &io_ptr, encoder->rows_completed);
    if (num_io_words <= 0) {
        encoder->usr->error(encoder->usr, "%s: no more words\n", __FUNCTION__);
    }
    spice_assert(io_ptr);
    encoder->io_words_count += num_io_words;
    encoder->io_now = io_ptr;
    encoder->io_end = encoder->io_now + num_io_words;
}

static inline void write_io_word(Encoder *encoder)
{
    if (G_UNLIKELY(encoder->io_now == encoder->io_end)) {
        more_io_words(encoder);
    }
    *(encoder->io_now++) = GUINT32_TO_LE(encoder->io_word);
}

static inline void encode(Encoder *encoder, unsigned int word, unsigned int len)
{
    int delta;

    spice_extra_assert(len > 0 && len < 32);
    spice_extra_assert(!(word & ~bppmask[len]));

    if ((delta = ((int)encoder->io_available_bits - len)) >= 0) {
        encoder->io_available_bits = delta;
        encoder->io_word |= word << encoder->io_available_bits;
        return;
    }
    delta = -delta;
    encoder->io_word |= word >> delta;
    write_io_word(encoder);
    encoder->io_available_bits = 32 - delta;
    encoder->io_word = word << encoder->io_available_bits;

    spice_extra_assert(encoder->io_available_bits < 32);
    spice_extra_assert((encoder->io_word & bppmask[encoder->io_available_bits]) == 0);
}

static inline void encode_32(Encoder *encoder, unsigned int word)
{
    encode(encoder, word >> 16, 16);
    encode(encoder, word & 0x0000ffff, 16);
}

static inline void flush(Encoder *encoder)
{
    if (encoder->io_available_bits > 0 && encoder->io_available_bits != 32) {
        encode(encoder, 0, encoder->io_available_bits);
    }
    encode_32(encoder, 0);
    encode(encoder, 0, 1);
}

static inline void read_io_word(Encoder *encoder)
{
    if (G_UNLIKELY(encoder->io_now == encoder->io_end)) {
        more_io_words(encoder);
    }
    spice_extra_assert(encoder->io_now < encoder->io_end);

    encoder->io_next_word = GUINT32_FROM_LE(*(encoder->io_now));
    encoder->io_now++;
}

static inline void decode_eatbits(Encoder *encoder, int len)
{
    int delta;

    spice_extra_assert(len > 0 && len < 32);
    encoder->io_word <<= len;

    if ((delta = ((int)encoder->io_available_bits - len)) >= 0) {
        encoder->io_available_bits = delta;
        encoder->io_word |= encoder->io_next_word >> encoder->io_available_bits;
        return;
    }

    delta = -delta;
    encoder->io_word |= encoder->io_next_word << delta;
    read_io_word(encoder);
    encoder->io_available_bits = 32 - delta;
    encoder->io_word |= (encoder->io_next_word >> encoder->io_available_bits);
}

static inline void decode_eat32bits(Encoder *encoder)
{
    decode_eatbits(encoder, 16);
    decode_eatbits(encoder, 16);
}

static inline void encode_ones(Encoder *encoder, unsigned int n)
{
    unsigned int count;

    for (count = n >> 5; count; count--) {
        encode_32(encoder, ~0U);
    }

    if ((n &= 0x1f)) {
        encode(encoder, (1U << n) - 1, n);
    }
}

#define MELCSTATES 32 /* number of melcode states */

static const int J[MELCSTATES] = {
    0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 5, 5, 6, 6, 7,
    7, 8, 9, 10, 11, 12, 13, 14, 15
};

static void encoder_init_rle(CommonState *state)
{
    state->melcstate = 0;
    state->melclen = J[0];
    state->melcorder = 1 << state->melclen;
}


static void encode_state_run(Encoder *encoder, CommonState *state, unsigned int runlen)
{
    int hits = 0;

    while (runlen >= state->melcorder) {
        hits++;
        runlen -= state->melcorder;
        if (state->melcstate < MELCSTATES - 1) {
            state->melclen = J[++state->melcstate];
            state->melcorder = (1L << state->melclen);
        }
    }

    /* send the required number of "hit" bits (one per occurrence
       of a run of length melcorder). This number is never too big:
       after 31 such "hit" bits, each "hit" would represent a run of 32K
       pixels.
    */
    encode_ones(encoder, hits);

    encode(encoder, runlen, state->melclen + 1);

    /* adjust melcoder parameters */
    if (state->melcstate) {
        state->melclen = J[--state->melcstate];
        state->melcorder = (1L << state->melclen);
    }
}


/* decoding routine: reads bits from the input and returns a run length. */
/* argument is the number of pixels left to end-of-line (bound on run length) */

static int decode_state_run(Encoder *encoder, CommonState *state)
{
    int runlen = 0;

    do {
        register int temp, hits;
        temp = lzeroes[(BYTE)(~(encoder->io_word >> 24))];/* number of leading ones in the
                                                                      input stream, up to 8 */
        for (hits = 1; hits <= temp; hits++) {
            runlen += state->melcorder;

            if (state->melcstate < MELCSTATES - 1) {
                state->melclen = J[++state->melcstate];
                state->melcorder = (1U << state->melclen);
            }
        }
        if (temp != 8) {
            decode_eatbits(encoder, temp + 1);  /* consume the leading
                                                            0 of the remainder encoding */
            break;
        }
        decode_eatbits(encoder, 8);
    } while (1);

    /* read the length of the remainder */
    if (state->melclen) {
        runlen += encoder->io_word >> (32 - state->melclen);
        decode_eatbits(encoder, state->melclen);
    }

    /* adjust melcorder parameters */
    if (state->melcstate) {
        state->melclen = J[--state->melcstate];
        state->melcorder = (1U << state->melclen);
    }

    return runlen;
}

static inline void init_decode_io(Encoder *encoder)
{
    encoder->io_next_word = encoder->io_word = GUINT32_FROM_LE(*(encoder->io_now));
    encoder->io_now++;
    encoder->io_available_bits = 0;
}

#include <spice/start-packed.h>

typedef struct SPICE_ATTR_PACKED one_byte_pixel_t {
    BYTE a;
} one_byte_t;

typedef struct SPICE_ATTR_PACKED four_bytes_pixel_t {
    BYTE a;
    BYTE b;
    BYTE c;
    BYTE d;
} four_bytes_t;

typedef struct SPICE_ATTR_PACKED rgb32_pixel_t {
    BYTE b;
    BYTE g;
    BYTE r;
    BYTE pad;
} rgb32_pixel_t;

typedef struct SPICE_ATTR_PACKED rgb24_pixel_t {
    BYTE b;
    BYTE g;
    BYTE r;
} rgb24_pixel_t;

typedef uint16_t rgb16_pixel_t;

#include <spice/end-packed.h>

#define ONE_BYTE
#include "quic_tmpl.c"

#define FOUR_BYTE
#include "quic_tmpl.c"

#define QUIC_RGB32
#include "quic_tmpl.c"

#define QUIC_RGB24
#include "quic_tmpl.c"

#define QUIC_RGB16
#include "quic_tmpl.c"

#define QUIC_RGB16_TO_32
#include "quic_tmpl.c"

static void fill_model_structures(SPICE_GNUC_UNUSED Encoder *encoder, FamilyStat *family_stat,
                                  unsigned int rep_first, unsigned int first_size,
                                  unsigned int rep_next, unsigned int mul_size,
                                  unsigned int levels, unsigned int ncounters,
                                  unsigned int nbuckets, unsigned int n_buckets_ptrs)
{
    unsigned int
    bsize,
    bstart,
    bend = 0,
    repcntr,
    bnumber;

    COUNTER * free_counter = family_stat->counters;/* first free location in the array of
                                                      counters */

    bnumber = 0;

    repcntr = rep_first + 1;    /* first bucket */
    bsize = first_size;

    do { /* others */
        if (bnumber) {
            bstart = bend + 1;
        } else {
            bstart = 0;
        }

        if (!--repcntr) {
            repcntr = rep_next;
            bsize *= mul_size;
        }

        bend = bstart + bsize - 1;
        if (bend + bsize >= levels) {
            bend = levels - 1;
        }

        family_stat->buckets_buf[bnumber].pcounters = free_counter;
        free_counter += ncounters;

        spice_assert(bstart < n_buckets_ptrs);
        {
            unsigned int i;
            spice_assert(bend < n_buckets_ptrs);
            for (i = bstart; i <= bend; i++) {
                family_stat->buckets_ptrs[i] = family_stat->buckets_buf + bnumber;
            }
        }

        bnumber++;
    } while (bend < levels - 1);

    spice_assert(free_counter - family_stat->counters == (ptrdiff_t)(nbuckets * ncounters));
}

static void find_model_params(Encoder *encoder,
                              const int bpc,
                              unsigned int *ncounters,
                              unsigned int *levels,
                              unsigned int *n_buckets_ptrs,
                              unsigned int *repfirst,
                              unsigned int *firstsize,
                              unsigned int *repnext,
                              unsigned int *mulsize,
                              unsigned int *nbuckets)
{
    unsigned int bsize;              /* bucket size */
    unsigned int bstart, bend = 0;   /* bucket start and end, range : 0 to levels-1*/
    unsigned int repcntr;            /* helper */

    /* The only valid values are 1, 3 and 5.
       0, 2 and 4 are obsolete and the rest of the
       values are considered out of the range. */
    SPICE_VERIFY(DEFevol == 1 || DEFevol == 3 || DEFevol == 5);
    spice_assert(bpc <= 8 && bpc > 0);

    *ncounters = 8;

    *levels = 0x1 << bpc;

    *n_buckets_ptrs = 0;  /* ==0 means: not set yet */

    switch (DEFevol) {   /* set repfirst firstsize repnext mulsize */
    case 1: /* buckets contain following numbers of contexts: 1 1 1 2 2 4 4 8 8 ... */
        *repfirst = 3;
        *firstsize = 1;
        *repnext = 2;
        *mulsize = 2;
        break;
    case 3: /* 1 2 4 8 16 32 64 ... */
        *repfirst = 1;
        *firstsize = 1;
        *repnext = 1;
        *mulsize = 2;
        break;
    case 5:                     /* 1 4 16 64 256 1024 4096 16384 65536 */
        *repfirst = 1;
        *firstsize = 1;
        *repnext = 1;
        *mulsize = 4;
        break;
    default:
        encoder->usr->error(encoder->usr, "findmodelparams(): DEFevol out of range!!!\n");
        return;
    }

    *nbuckets = 0;
    repcntr = *repfirst + 1;    /* first bucket */
    bsize = *firstsize;

    do { /* other buckets */
        if (*nbuckets) {         /* bucket start */
            bstart = bend + 1;
        } else {
            bstart = 0;
        }

        if (!--repcntr) {         /* bucket size */
            repcntr = *repnext;
            bsize *= *mulsize;
        }

        bend = bstart + bsize - 1;  /* bucket end */
        if (bend + bsize >= *levels) {  /* if following bucked was bigger than current one */
            bend = *levels - 1;     /* concatenate them */
        }

        if (!*n_buckets_ptrs) {           /* array size not set yet? */
            *n_buckets_ptrs = *levels;
 #if 0
            if (bend == *levels - 1) {   /* this bucket is last - all in the first array */
                *n_buckets_ptrs = *levels;
            } else if (bsize >= 256) { /* this bucket is allowed to reside in the 2nd table */
                b_lo_ptrs = bstart;
                spice_assert(bstart);     /* previous bucket exists */
            }
 #endif
        }

        (*nbuckets)++;
    } while (bend < *levels - 1);
}

static int init_model_structures(Encoder *encoder, FamilyStat *family_stat,
                                 unsigned int rep_first, unsigned int first_size,
                                 unsigned int rep_next, unsigned int mul_size,
                                 unsigned int levels, unsigned int ncounters,
                                 unsigned int n_buckets_ptrs, unsigned int n_buckets)
{
    family_stat->buckets_ptrs = (s_bucket **)encoder->usr->malloc(encoder->usr,
                                                                  n_buckets_ptrs *
                                                                  sizeof(s_bucket *));
    if (!family_stat->buckets_ptrs) {
        return FALSE;
    }

    family_stat->counters = (COUNTER *)encoder->usr->malloc(encoder->usr,
                                                            n_buckets * sizeof(COUNTER) *
                                                            MAXNUMCODES);
    if (!family_stat->counters) {
        goto error_1;
    }

    family_stat->buckets_buf = (s_bucket *)encoder->usr->malloc(encoder->usr,
                                                                n_buckets * sizeof(s_bucket));
    if (!family_stat->buckets_buf) {
        goto error_2;
    }

    fill_model_structures(encoder, family_stat, rep_first, first_size, rep_next, mul_size, levels,
                          ncounters, n_buckets, n_buckets_ptrs);

    return TRUE;

error_2:
    encoder->usr->free(encoder->usr, family_stat->counters);

error_1:
    encoder->usr->free(encoder->usr, family_stat->buckets_ptrs);

    return FALSE;
}

static void free_family_stat(QuicUsrContext *usr, FamilyStat *family_stat)
{
    usr->free(usr, family_stat->buckets_ptrs);
    usr->free(usr, family_stat->counters);
    usr->free(usr, family_stat->buckets_buf);
}

static int init_channel(Encoder *encoder, Channel *channel)
{
    unsigned int ncounters;
    unsigned int levels;
    unsigned int rep_first;
    unsigned int first_size;
    unsigned int rep_next;
    unsigned int mul_size;
    unsigned int n_buckets;
    unsigned int n_buckets_ptrs;

    channel->correlate_row_width = 0;
    channel->correlate_row = NULL;

    find_model_params(encoder, 8, &ncounters, &levels, &n_buckets_ptrs, &rep_first,
                      &first_size, &rep_next, &mul_size, &n_buckets);
    encoder->n_buckets_8bpc = n_buckets;
    if (!init_model_structures(encoder, &channel->family_stat_8bpc, rep_first, first_size,
                               rep_next, mul_size, levels, ncounters, n_buckets_ptrs,
                               n_buckets)) {
        return FALSE;
    }

    find_model_params(encoder, 5, &ncounters, &levels, &n_buckets_ptrs, &rep_first,
                      &first_size, &rep_next, &mul_size, &n_buckets);
    encoder->n_buckets_5bpc = n_buckets;
    if (!init_model_structures(encoder, &channel->family_stat_5bpc, rep_first, first_size,
                               rep_next, mul_size, levels, ncounters, n_buckets_ptrs,
                               n_buckets)) {
        free_family_stat(encoder->usr, &channel->family_stat_8bpc);
        return FALSE;
    }

    return TRUE;
}

static void destroy_channel(Encoder *encoder, Channel *channel)
{
    QuicUsrContext *usr = encoder->usr;
    if (channel->correlate_row) {
        usr->free(usr, channel->correlate_row - 1);
    }
    free_family_stat(usr, &channel->family_stat_8bpc);
    free_family_stat(usr, &channel->family_stat_5bpc);
}

static int init_encoder(Encoder *encoder, QuicUsrContext *usr)
{
    int i;

    encoder->usr = usr;

    for (i = 0; i < MAX_CHANNELS; i++) {
        if (!init_channel(encoder, &encoder->channels[i])) {
            for (--i; i >= 0; i--) {
                destroy_channel(encoder, &encoder->channels[i]);
            }
            return FALSE;
        }
    }
    return TRUE;
}

static int encoder_reset(Encoder *encoder, uint32_t *io_ptr, uint32_t *io_ptr_end)
{
    spice_assert(((uintptr_t)io_ptr % 4) == ((uintptr_t)io_ptr_end % 4));
    spice_assert(io_ptr <= io_ptr_end);

    encoder->rgb_state.waitcnt = 0;
    encoder->rgb_state.tabrand_seed = stabrand();
    encoder->rgb_state.wmidx = DEFwmistart;
    encoder->rgb_state.wmileft = DEFwminext;
    set_wm_trigger(&encoder->rgb_state);

    encoder_init_rle(&encoder->rgb_state);

    encoder->io_words_count = io_ptr_end - io_ptr;
    encoder->io_now = io_ptr;
    encoder->io_end = io_ptr_end;
    encoder->rows_completed = 0;

    return TRUE;
}

static int encoder_reset_channels(Encoder *encoder, int channels, int width, int bpc)
{
    int i;

    for (i = 0; i < channels; i++) {
        s_bucket *bucket;
        s_bucket *end_bucket;

        if (encoder->channels[i].correlate_row_width < width) {
            encoder->channels[i].correlate_row_width = 0;
            if (encoder->channels[i].correlate_row) {
                encoder->usr->free(encoder->usr, encoder->channels[i].correlate_row - 1);
            }
            if (!(encoder->channels[i].correlate_row = (BYTE *)encoder->usr->malloc(encoder->usr,
                                                                                    width + 1))) {
                return FALSE;
            }
            encoder->channels[i].correlate_row++;
            encoder->channels[i].correlate_row_width = width;
        }

        if (bpc == 8) {
            MEMCLEAR(encoder->channels[i].family_stat_8bpc.counters,
                     encoder->n_buckets_8bpc * sizeof(COUNTER) * MAXNUMCODES);
            bucket = encoder->channels[i].family_stat_8bpc.buckets_buf;
            end_bucket = bucket + encoder->n_buckets_8bpc;
            for (; bucket < end_bucket; bucket++) {
                bucket->bestcode = /*BPC*/ 8 - 1;
            }
            encoder->channels[i]._buckets_ptrs = encoder->channels[i].family_stat_8bpc.buckets_ptrs;
        } else if (bpc == 5) {
            MEMCLEAR(encoder->channels[i].family_stat_5bpc.counters,
                     encoder->n_buckets_5bpc * sizeof(COUNTER) * MAXNUMCODES);
            bucket = encoder->channels[i].family_stat_5bpc.buckets_buf;
            end_bucket = bucket + encoder->n_buckets_5bpc;
            for (; bucket < end_bucket; bucket++) {
                bucket->bestcode = /*BPC*/ 5 - 1;
            }
            encoder->channels[i]._buckets_ptrs = encoder->channels[i].family_stat_5bpc.buckets_ptrs;
        } else {
            encoder->usr->warn(encoder->usr, "%s: bad bpc %d\n", __FUNCTION__, bpc);
            return FALSE;
        }

        encoder->channels[i].state.waitcnt = 0;
        encoder->channels[i].state.tabrand_seed = stabrand();
        encoder->channels[i].state.wmidx = DEFwmistart;
        encoder->channels[i].state.wmileft = DEFwminext;
        set_wm_trigger(&encoder->channels[i].state);

        encoder_init_rle(&encoder->channels[i].state);
    }
    return TRUE;
}

static void quic_image_params(Encoder *encoder, QuicImageType type, int *channels, int *bpc)
{
    spice_assert(channels && bpc);
    switch (type) {
    case QUIC_IMAGE_TYPE_GRAY:
        *channels = 1;
        *bpc = 8;
        break;
    case QUIC_IMAGE_TYPE_RGB16:
        *channels = 3;
        *bpc = 5;
        break;
    case QUIC_IMAGE_TYPE_RGB24:
        *channels = 3;
        *bpc = 8;
        break;
    case QUIC_IMAGE_TYPE_RGB32:
        *channels = 3;
        *bpc = 8;
        break;
    case QUIC_IMAGE_TYPE_RGBA:
        *channels = 4;
        *bpc = 8;
        break;
    case QUIC_IMAGE_TYPE_INVALID:
    default:
        *channels = 0;
        *bpc = 0;
        encoder->usr->error(encoder->usr, "bad image type\n");
    }
}

#define FILL_LINES() {                                                  \
    if (line == lines_end) {                                            \
        int n = encoder->usr->more_lines(encoder->usr, &line);          \
        if (n <= 0 || line == NULL) {                                   \
            encoder->usr->error(encoder->usr, "more lines failed\n");   \
        }                                                               \
        lines_end = line + n * stride;                                  \
    }                                                                   \
}

#define NEXT_LINE() {       \
    line += stride;         \
    FILL_LINES();           \
}

#define QUIC_COMPRESS_RGB(bits)                                                                 \
        encoder->channels[0].correlate_row[-1] = 0;                                             \
        encoder->channels[1].correlate_row[-1] = 0;                                             \
        encoder->channels[2].correlate_row[-1] = 0;                                             \
        quic_rgb##bits##_compress_row0(encoder, (rgb##bits##_pixel_t *)(line), width);          \
        encoder->rows_completed++;                                                              \
        for (row = 1; row < height; row++) {                                                    \
            prev = line;                                                                        \
            NEXT_LINE();                                                                        \
            encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];     \
            encoder->channels[1].correlate_row[-1] = encoder->channels[1].correlate_row[0];     \
            encoder->channels[2].correlate_row[-1] = encoder->channels[2].correlate_row[0];     \
            quic_rgb##bits##_compress_row(encoder, (rgb##bits##_pixel_t *)prev,                 \
                                          (rgb##bits##_pixel_t *)line, width);                  \
            encoder->rows_completed++;                                                          \
        }

int quic_encode(QuicContext *quic, QuicImageType type, int width, int height,
                uint8_t *line, unsigned int num_lines, int stride,
                uint32_t *io_ptr, unsigned int num_io_words)
{
    Encoder *encoder = (Encoder *)quic;
    uint32_t *io_ptr_end = io_ptr + num_io_words;
    uint8_t *lines_end;
    int row;
    uint8_t *prev;
    int channels;
    int bpc;

    lines_end = line + num_lines * stride;
    if (line == NULL && lines_end != line) {
        spice_warn_if_reached();
        return QUIC_ERROR;
    }

    quic_image_params(encoder, type, &channels, &bpc);

    if (!encoder_reset(encoder, io_ptr, io_ptr_end) ||
        !encoder_reset_channels(encoder, channels, width, bpc)) {
        return QUIC_ERROR;
    }

    encoder->io_word = 0;
    encoder->io_available_bits = 32;

    encode_32(encoder, QUIC_MAGIC);
    encode_32(encoder, QUIC_VERSION);
    encode_32(encoder, type);
    encode_32(encoder, width);
    encode_32(encoder, height);

    FILL_LINES();

    switch (type) {
    case QUIC_IMAGE_TYPE_RGB32:
        spice_assert(ABS(stride) >= width * 4);
        QUIC_COMPRESS_RGB(32);
        break;
    case QUIC_IMAGE_TYPE_RGB24:
        spice_assert(ABS(stride) >= width * 3);
        QUIC_COMPRESS_RGB(24);
        break;
    case QUIC_IMAGE_TYPE_RGB16:
        spice_assert(ABS(stride) >= width * 2);
        QUIC_COMPRESS_RGB(16);
        break;
    case QUIC_IMAGE_TYPE_RGBA:
        spice_assert(ABS(stride) >= width * 4);

        encoder->channels[0].correlate_row[-1] = 0;
        encoder->channels[1].correlate_row[-1] = 0;
        encoder->channels[2].correlate_row[-1] = 0;
        quic_rgb32_compress_row0(encoder, (rgb32_pixel_t *)(line), width);

        encoder->channels[3].correlate_row[-1] = 0;
        quic_four_compress_row0(encoder, &encoder->channels[3], (four_bytes_t *)(line + 3), width);

        encoder->rows_completed++;

        for (row = 1; row < height; row++) {
            prev = line;
            NEXT_LINE();
            encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];
            encoder->channels[1].correlate_row[-1] = encoder->channels[1].correlate_row[0];
            encoder->channels[2].correlate_row[-1] = encoder->channels[2].correlate_row[0];
            quic_rgb32_compress_row(encoder, (rgb32_pixel_t *)prev, (rgb32_pixel_t *)line, width);

            encoder->channels[3].correlate_row[-1] = encoder->channels[3].correlate_row[0];
            quic_four_compress_row(encoder, &encoder->channels[3], (four_bytes_t *)(prev + 3),
                                   (four_bytes_t *)(line + 3), width);
            encoder->rows_completed++;
        }
        break;
    case QUIC_IMAGE_TYPE_GRAY:
        spice_assert(ABS(stride) >= width);
        encoder->channels[0].correlate_row[-1] = 0;
        quic_one_compress_row0(encoder, &encoder->channels[0], (one_byte_t *)line, width);
        encoder->rows_completed++;
        for (row = 1; row < height; row++) {
            prev = line;
            NEXT_LINE();
            encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];
            quic_one_compress_row(encoder, &encoder->channels[0], (one_byte_t *)prev,
                                  (one_byte_t *)line, width);
            encoder->rows_completed++;
        }
        break;
    case QUIC_IMAGE_TYPE_INVALID:
    default:
        encoder->usr->error(encoder->usr, "bad image type\n");
    }

    flush(encoder);
    encoder->io_words_count -= (encoder->io_end - encoder->io_now);

    return encoder->io_words_count;
}

int quic_decode_begin(QuicContext *quic, uint32_t *io_ptr, unsigned int num_io_words,
                      QuicImageType *out_type, int *out_width, int *out_height)
{
    Encoder *encoder = (Encoder *)quic;
    uint32_t *io_ptr_end = io_ptr + num_io_words;
    QuicImageType type;
    int width;
    int height;
    uint32_t magic;
    uint32_t version;
    int channels;
    int bpc;

    if (!num_io_words || !encoder_reset(encoder, io_ptr, io_ptr_end)) {
        return QUIC_ERROR;
    }

    init_decode_io(encoder);

    magic = encoder->io_word;
    decode_eat32bits(encoder);
    if (magic != QUIC_MAGIC) {
        encoder->usr->warn(encoder->usr, "bad magic\n");
        return QUIC_ERROR;
    }

    version = encoder->io_word;
    decode_eat32bits(encoder);
    if (version != QUIC_VERSION) {
        encoder->usr->warn(encoder->usr, "bad version\n");
        return QUIC_ERROR;
    }

    type = (QuicImageType)encoder->io_word;
    decode_eat32bits(encoder);

    width = encoder->io_word;
    decode_eat32bits(encoder);

    height = encoder->io_word;
    decode_eat32bits(encoder);

    if (width <= 0 || height <= 0) {
        encoder->usr->warn(encoder->usr, "invalid size\n");
        return QUIC_ERROR;
    }

    /* avoid too big images */
    if ((uint64_t) width * height > SPICE_MAX_IMAGE_SIZE) {
        encoder->usr->error(encoder->usr, "image too large\n");
    }

    quic_image_params(encoder, type, &channels, &bpc);

    if (!encoder_reset_channels(encoder, channels, width, bpc)) {
        return QUIC_ERROR;
    }

    *out_width = encoder->width = width;
    *out_height = encoder->height = height;
    *out_type = encoder->type = type;
    return QUIC_OK;
}

static void uncompress_rgba(Encoder *encoder, uint8_t *buf, int stride)
{
    unsigned int row;
    uint8_t *prev;

    encoder->channels[0].correlate_row[-1] = 0;
    encoder->channels[1].correlate_row[-1] = 0;
    encoder->channels[2].correlate_row[-1] = 0;
    quic_rgb32_uncompress_row0(encoder, (rgb32_pixel_t *)buf, encoder->width);

    encoder->channels[3].correlate_row[-1] = 0;
    quic_four_uncompress_row0(encoder, &encoder->channels[3], (four_bytes_t *)(buf + 3),
                              encoder->width);

    encoder->rows_completed++;
    for (row = 1; row < encoder->height; row++) {
        prev = buf;
        buf += stride;

        encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];
        encoder->channels[1].correlate_row[-1] = encoder->channels[1].correlate_row[0];
        encoder->channels[2].correlate_row[-1] = encoder->channels[2].correlate_row[0];
        quic_rgb32_uncompress_row(encoder, (rgb32_pixel_t *)prev, (rgb32_pixel_t *)buf,
                                  encoder->width);

        encoder->channels[3].correlate_row[-1] = encoder->channels[3].correlate_row[0];
        quic_four_uncompress_row(encoder, &encoder->channels[3], (four_bytes_t *)(prev + 3),
                                 (four_bytes_t *)(buf + 3), encoder->width);

        encoder->rows_completed++;
    }
}

static void uncompress_gray(Encoder *encoder, uint8_t *buf, int stride)
{
    unsigned int row;
    uint8_t *prev;

    encoder->channels[0].correlate_row[-1] = 0;
    quic_one_uncompress_row0(encoder, &encoder->channels[0], (one_byte_t *)buf, encoder->width);
    encoder->rows_completed++;
    for (row = 1; row < encoder->height; row++) {
        prev = buf;
        buf += stride;
        encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];
        quic_one_uncompress_row(encoder, &encoder->channels[0], (one_byte_t *)prev,
                                (one_byte_t *)buf, encoder->width);
        encoder->rows_completed++;
    }
}

#define QUIC_UNCOMPRESS_RGB(prefix, type)                                                       \
        encoder->channels[0].correlate_row[-1] = 0;                                             \
        encoder->channels[1].correlate_row[-1] = 0;                                             \
        encoder->channels[2].correlate_row[-1] = 0;                                             \
        quic_rgb##prefix##_uncompress_row0(encoder, (type *)buf, encoder->width);  \
        encoder->rows_completed++;                                                              \
        for (row = 1; row < encoder->height; row++) {                                           \
            prev = buf;                                                                         \
            buf += stride;                                                                      \
            encoder->channels[0].correlate_row[-1] = encoder->channels[0].correlate_row[0];     \
            encoder->channels[1].correlate_row[-1] = encoder->channels[1].correlate_row[0];     \
            encoder->channels[2].correlate_row[-1] = encoder->channels[2].correlate_row[0];     \
            quic_rgb##prefix##_uncompress_row(encoder, (type *)prev, (type *)buf,               \
                                              encoder->width);                                  \
            encoder->rows_completed++;                                                          \
        }

int quic_decode(QuicContext *quic, QuicImageType type, uint8_t *buf, int stride)
{
    Encoder *encoder = (Encoder *)quic;
    unsigned int row;
    uint8_t *prev;

    spice_assert(buf);

    switch (encoder->type) {
    case QUIC_IMAGE_TYPE_RGB32:
    case QUIC_IMAGE_TYPE_RGB24:
        if (type == QUIC_IMAGE_TYPE_RGB32) {
            spice_assert(ABS(stride) >= (int)encoder->width * 4);
            QUIC_UNCOMPRESS_RGB(32, rgb32_pixel_t);
            break;
        } else if (type == QUIC_IMAGE_TYPE_RGB24) {
            spice_assert(ABS(stride) >= (int)encoder->width * 3);
            QUIC_UNCOMPRESS_RGB(24, rgb24_pixel_t);
            break;
        }
        encoder->usr->warn(encoder->usr, "unsupported output format\n");
        return QUIC_ERROR;
    case QUIC_IMAGE_TYPE_RGB16:
        if (type == QUIC_IMAGE_TYPE_RGB16) {
            spice_assert(ABS(stride) >= (int)encoder->width * 2);
            QUIC_UNCOMPRESS_RGB(16, rgb16_pixel_t);
        } else if (type == QUIC_IMAGE_TYPE_RGB32) {
            spice_assert(ABS(stride) >= (int)encoder->width * 4);
            QUIC_UNCOMPRESS_RGB(16_to_32, rgb32_pixel_t);
        } else {
            encoder->usr->warn(encoder->usr, "unsupported output format\n");
            return QUIC_ERROR;
        }

        break;
    case QUIC_IMAGE_TYPE_RGBA:

        if (type != QUIC_IMAGE_TYPE_RGBA) {
            encoder->usr->warn(encoder->usr, "unsupported output format\n");
            return QUIC_ERROR;
        }
        spice_assert(ABS(stride) >= (int)encoder->width * 4);
        uncompress_rgba(encoder, buf, stride);
        break;
    case QUIC_IMAGE_TYPE_GRAY:

        if (type != QUIC_IMAGE_TYPE_GRAY) {
            encoder->usr->warn(encoder->usr, "unsupported output format\n");
            return QUIC_ERROR;
        }
        spice_assert(ABS(stride) >= (int)encoder->width);
        uncompress_gray(encoder, buf, stride);
        break;
    case QUIC_IMAGE_TYPE_INVALID:
    default:
        encoder->usr->error(encoder->usr, "bad image type\n");
    }
    return QUIC_OK;
}

QuicContext *quic_create(QuicUsrContext *usr)
{
    Encoder *encoder;

    if (!usr || !usr->error || !usr->warn || !usr->info || !usr->malloc ||
        !usr->free || !usr->more_space || !usr->more_lines) {
        return NULL;
    }

    if (!(encoder = (Encoder *)usr->malloc(usr, sizeof(Encoder)))) {
        return NULL;
    }

    if (!init_encoder(encoder, usr)) {
        usr->free(usr, encoder);
        return NULL;
    }
    return (QuicContext *)encoder;
}

void quic_destroy(QuicContext *quic)
{
    Encoder *encoder = (Encoder *)quic;
    int i;

    if (!quic) {
        return;
    }

    for (i = 0; i < MAX_CHANNELS; i++) {
        destroy_channel(encoder, &encoder->channels[i]);
    }
    encoder->usr->free(encoder->usr, encoder);
}

SPICE_CONSTRUCTOR_FUNC(quic_global_init)
{
    family_init(&family_8bpc, 8, DEFmaxclen);
    family_init(&family_5bpc, 5, DEFmaxclen);
}

```

`devices/display/qxl/canvas/quic.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_QUIC
#define H_SPICE_COMMON_QUIC

#include <spice/macros.h>
#include "macros.h"

SPICE_BEGIN_DECLS

typedef enum {
    QUIC_IMAGE_TYPE_INVALID,
    QUIC_IMAGE_TYPE_GRAY,
    QUIC_IMAGE_TYPE_RGB16,
    QUIC_IMAGE_TYPE_RGB24,
    QUIC_IMAGE_TYPE_RGB32,
    QUIC_IMAGE_TYPE_RGBA
} QuicImageType;

#define QUIC_ERROR -1
#define QUIC_OK 0

typedef void *QuicContext;

typedef struct QuicUsrContext QuicUsrContext;
struct QuicUsrContext {
    SPICE_GNUC_NORETURN
    SPICE_GNUC_PRINTF(2, 3) void (*error)(QuicUsrContext *usr, const char *fmt, ...);
    SPICE_GNUC_PRINTF(2, 3) void (*warn)(QuicUsrContext *usr, const char *fmt, ...);
    SPICE_GNUC_PRINTF(2, 3) void (*info)(QuicUsrContext *usr, const char *fmt, ...);
    void *(*malloc)(QuicUsrContext *usr, int size);
    void (*free)(QuicUsrContext *usr, void *ptr);
    int (*more_space)(QuicUsrContext *usr, uint32_t **io_ptr, int rows_completed);
    int (*more_lines)(QuicUsrContext *usr, uint8_t **lines); // on return the last line of previous
                                                             // lines bunch must still be valid
};

int quic_encode(QuicContext *quic, QuicImageType type, int width, int height,
                uint8_t *lines, unsigned int num_lines, int stride,
                uint32_t *io_ptr, unsigned int num_io_words);

int quic_decode_begin(QuicContext *quic, uint32_t *io_ptr, unsigned int num_io_words,
                      QuicImageType *type, int *width, int *height);
int quic_decode(QuicContext *quic, QuicImageType type, uint8_t *buf, int stride);


QuicContext *quic_create(QuicUsrContext *usr);
void quic_destroy(QuicContext *quic);

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/quic_config.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_QUIC_CONFIG
#define H_SPICE_COMMON_QUIC_CONFIG

#include <spice/types.h>
#include <spice/macros.h>

SPICE_BEGIN_DECLS

#ifdef __GNUC__
#include <string.h>
#define MEMCLEAR(ptr, size) memset(ptr, 0, size)
#else
#ifdef QXLDD
#include <windef.h>
#include "os_dep.h"
#define MEMCLEAR(ptr, size) RtlZeroMemory(ptr, size)
#else
#include <stddef.h>
#include <string.h>
#define MEMCLEAR(ptr, size) memset(ptr, 0, size)
#endif  // QXLDD
#endif  //__GNUC__

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/quic_family_tmpl.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#ifdef QUIC_FAMILY_8BPC
#undef QUIC_FAMILY_8BPC
#define FNAME(name) name##_8bpc
#define VNAME(name) name##_8bpc
#define BPC 8
#endif


#ifdef QUIC_FAMILY_5BPC
#undef QUIC_FAMILY_5BPC
#define FNAME(name) name##_5bpc
#define VNAME(name) name##_5bpc
#define BPC 5
#endif

static inline unsigned int FNAME(golomb_code)(const BYTE n, const unsigned int l)
{
    return VNAME(family).golomb_code[n][l];
}

static inline unsigned int FNAME(golomb_code_len)(const BYTE n, const unsigned int l)
{
    return VNAME(family).golomb_code_len[n][l];
}

static void FNAME(golomb_coding)(Encoder *encoder, const BYTE n, const unsigned int l)
{
    encode(encoder, FNAME(golomb_code)(n, l), FNAME(golomb_code_len)(n, l));
}

static unsigned int FNAME(golomb_decoding)(const unsigned int l, const unsigned int bits,
                                           unsigned int * const codewordlen)
{
    if (bits > VNAME(family).notGRprefixmask[l]) { /*GR*/
        const unsigned int zeroprefix = cnt_l_zeroes(bits);       /* leading zeroes in codeword */
        const unsigned int cwlen = zeroprefix + 1 + l;            /* codeword length */
        (*codewordlen) = cwlen;
        return (zeroprefix << l) | ((bits >> (32 - cwlen)) & bppmask[l]);
    } else { /* not-GR */
        const unsigned int cwlen = VNAME(family).notGRcwlen[l];
        (*codewordlen) = cwlen;
        return VNAME(family).nGRcodewords[l] + ((bits) >> (32 - cwlen) &
                                                bppmask[VNAME(family).notGRsuffixlen[l]]);
    }
}

/* update the bucket using just encoded curval */
static void FNAME(update_model)(CommonState *state, s_bucket * const bucket,
                                const BYTE curval)
{
    SPICE_VERIFY(BPC >= 1);
    spice_return_if_fail (bucket != NULL);

    const unsigned int bpp = BPC;
    COUNTER * const pcounters = bucket->pcounters;
    unsigned int i;
    unsigned int bestcode;
    unsigned int bestcodelen;

    /* update counters, find minimum */

    bestcode = bpp - 1;
    bestcodelen = (pcounters[bestcode] += FNAME(golomb_code_len)(curval, bestcode));

    for (i = bpp - 2; i < bpp; i--) { /* NOTE: expression i<bpp for signed int i would be: i>=0 */
        const unsigned int ithcodelen = (pcounters[i] += FNAME(golomb_code_len)(curval, i));

        if (ithcodelen < bestcodelen) {
            bestcode = i;
            bestcodelen = ithcodelen;
        }
    }

    bucket->bestcode = bestcode; /* store the found minimum */

    if (bestcodelen > state->wm_trigger) { /* halving counters? */
        for (i = 0; i < bpp; i++) {
            pcounters[i] >>= 1;
        }
    }
}

static s_bucket *FNAME(find_bucket)(Channel *channel, const unsigned int val)
{
    spice_extra_assert(val < (0x1U << BPC));

    /* The and (&) here is to avoid buffer overflows in case of garbage or malicious
     * attempts. Is much faster then using comparisons and save us from such situations.
     * Note that on normal build the check above won't be compiled as this code path
     * is pretty hot and would cause speed regressions.
     */
    return channel->_buckets_ptrs[val & ((1U << BPC) - 1)];
}

#undef FNAME
#undef VNAME
#undef BPC

```

`devices/display/qxl/canvas/quic_tmpl.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#define COMPRESS_IMP

#if defined(ONE_BYTE) || defined(FOUR_BYTE)
#  define FARGS_DECL(...) (Encoder *encoder, Channel *channel_a, __VA_ARGS__)
#  define FARGS_CALL(...) (encoder, channel_a, __VA_ARGS__)
#  define UNCOMPRESS_PIX_START(row) do { } while (0)
#  define SET_a(pix, val) ((pix)->a = val)
#  define GET_a(pix) ((pix)->a)
#  define SAME_PIXEL(p1, p2) (GET_a(p1) == GET_a(p2))
#  define COPY_PIXEL(dest, src) \
    SET_a(dest, GET_a(src));
#  define DECLARE_STATE_VARIABLES \
    CommonState *state = &channel_a->state
#  define DECLARE_CHANNEL_VARIABLES \
    BYTE * const correlate_row_a = channel_a->correlate_row
#  define APPLY_ALL_COMP(macro, ...) \
    macro(a, ## __VA_ARGS__)
#else
#  define FARGS_DECL(...) (Encoder *encoder, __VA_ARGS__)
#  define FARGS_CALL(...) (encoder, __VA_ARGS__)
#  define SAME_PIXEL(p1, p2)                               \
    (GET_r(p1) == GET_r(p2) && GET_g(p1) == GET_g(p2) &&   \
     GET_b(p1) == GET_b(p2))
#  define COPY_PIXEL(dest, src) \
    SET_r(dest, GET_r(src)); \
    SET_g(dest, GET_g(src)); \
    SET_b(dest, GET_b(src))
#  define DECLARE_STATE_VARIABLES \
    CommonState *state = &encoder->rgb_state
#  define DECLARE_CHANNEL_VARIABLES \
    Channel * const channel_r = encoder->channels; \
    Channel * const channel_g = channel_r + 1; \
    Channel * const channel_b = channel_g + 1; \
    BYTE * const correlate_row_r = channel_r->correlate_row; \
    BYTE * const correlate_row_g = channel_g->correlate_row; \
    BYTE * const correlate_row_b = channel_b->correlate_row
#  define APPLY_ALL_COMP(macro, ...) \
    macro(r, ## __VA_ARGS__); \
    macro(g, ## __VA_ARGS__); \
    macro(b, ## __VA_ARGS__)
#endif

#ifdef ONE_BYTE
#undef ONE_BYTE
#define FNAME(name) quic_one_##name
#define PIXEL one_byte_t
#define BPC 8
#endif

#ifdef FOUR_BYTE
#undef FOUR_BYTE
#define FNAME(name) quic_four_##name
#define PIXEL four_bytes_t
#define BPC 8
#endif

#ifdef QUIC_RGB32
#undef QUIC_RGB32
#define PIXEL rgb32_pixel_t
#define FNAME(name) quic_rgb32_##name
#define BPC 8
#define SET_r(pix, val) ((pix)->r = val)
#define GET_r(pix) ((pix)->r)
#define SET_g(pix, val) ((pix)->g = val)
#define GET_g(pix) ((pix)->g)
#define SET_b(pix, val) ((pix)->b = val)
#define GET_b(pix) ((pix)->b)
#define UNCOMPRESS_PIX_START(pix) ((pix)->pad = 0)
#endif

#ifdef QUIC_RGB24
#undef QUIC_RGB24
#define PIXEL rgb24_pixel_t
#define FNAME(name) quic_rgb24_##name
#define BPC 8
#define SET_r(pix, val) ((pix)->r = val)
#define GET_r(pix) ((pix)->r)
#define SET_g(pix, val) ((pix)->g = val)
#define GET_g(pix) ((pix)->g)
#define SET_b(pix, val) ((pix)->b = val)
#define GET_b(pix) ((pix)->b)
#define UNCOMPRESS_PIX_START(pix)
#endif

#ifdef QUIC_RGB16
#undef QUIC_RGB16
#define PIXEL rgb16_pixel_t
#define FNAME(name) quic_rgb16_##name
#define BPC 5
#define SET_r(pix, val) (*(pix) = (*(pix) & ~(0x1f << 10)) | ((val) << 10))
#define GET_r(pix) ((*(pix) >> 10) & 0x1f)
#define SET_g(pix, val) (*(pix) = (*(pix) & ~(0x1f << 5)) | ((val) << 5))
#define GET_g(pix) ((*(pix) >> 5) & 0x1f)
#define SET_b(pix, val) (*(pix) = (*(pix) & ~0x1f) | (val))
#define GET_b(pix) (*(pix) & 0x1f)
#define UNCOMPRESS_PIX_START(pix) (*(pix) = 0)
#endif

#ifdef QUIC_RGB16_TO_32
#undef QUIC_RGB16_TO_32
#define PIXEL rgb32_pixel_t
#define FNAME(name) quic_rgb16_to_32_##name
#define BPC 5
#undef COMPRESS_IMP
#define SET_r(pix, val) ((pix)->r = ((val) << 3) | (((val) & 0x1f) >> 2))
#define GET_r(pix) ((pix)->r >> 3)
#define SET_g(pix, val) ((pix)->g = ((val) << 3) | (((val) & 0x1f) >> 2))
#define GET_g(pix) ((pix)->g >> 3)
#define SET_b(pix, val) ((pix)->b = ((val) << 3) | (((val) & 0x1f) >> 2))
#define GET_b(pix) ((pix)->b >> 3)
#define UNCOMPRESS_PIX_START(pix) ((pix)->pad = 0)
#endif

#define FNAME_DECL(name) FNAME(name) FARGS_DECL
#define FNAME_CALL(name) FNAME(name) FARGS_CALL

#if BPC == 5
#  define golomb_coding golomb_coding_5bpc
#  define golomb_decoding golomb_decoding_5bpc
#  define update_model update_model_5bpc
#  define find_bucket find_bucket_5bpc
#  define family family_5bpc
#  define BPC_MASK 0x1fU
#elif BPC == 8
#  define golomb_coding golomb_coding_8bpc
#  define golomb_decoding golomb_decoding_8bpc
#  define update_model update_model_8bpc
#  define find_bucket find_bucket_8bpc
#  define family family_8bpc
#  define BPC_MASK 0xffU
#else
#  error BPC must be 5 or 8
#endif

#define _PIXEL_A(channel, curr) ((unsigned int)GET_##channel((curr) - 1))
#define _PIXEL_B(channel, prev) ((unsigned int)GET_##channel(prev))

/*  a  */

#define DECORRELATE_0(channel, curr, bpc_mask)\
    family.xlatU2L[(unsigned)((int)GET_##channel(curr) - (int)_PIXEL_A(channel, curr)) & bpc_mask]

#define CORRELATE_0(channel, curr, correlate, bpc_mask)\
    ((family.xlatL2U[correlate] + _PIXEL_A(channel, curr)) & bpc_mask)


/*  (a+b)/2  */
#define DECORRELATE(channel, prev, curr, bpc_mask, r)                                          \
    r = family.xlatU2L[(unsigned)((int)GET_##channel(curr) - (int)((_PIXEL_A(channel, curr) +  \
    _PIXEL_B(channel, prev)) >> 1)) & bpc_mask]

#define CORRELATE(channel, prev, curr, correlate, bpc_mask, r)                                  \
    SET_##channel(r, ((family.xlatL2U[correlate] +                                              \
         (int)((_PIXEL_A(channel, curr) + _PIXEL_B(channel, prev)) >> 1)) & bpc_mask))


#define COMPRESS_ONE_ROW0_0(channel)                                    \
    correlate_row_##channel[0] = family.xlatU2L[GET_##channel(cur_row)];\
    golomb_coding(encoder, correlate_row_##channel[0],                  \
                  find_bucket(channel_##channel,                        \
                              correlate_row_##channel[-1])->bestcode)

#define COMPRESS_ONE_ROW0(channel, index)                                               \
    correlate_row_##channel[index] = DECORRELATE_0(channel, &cur_row[index], bpc_mask); \
    golomb_coding(encoder, correlate_row_##channel[index],                              \
                  find_bucket(channel_##channel,                                        \
                              correlate_row_##channel[index - 1])->bestcode)

#define UPDATE_MODEL_COMP(channel, index)                                                   \
    update_model(state, find_bucket(channel_##channel, correlate_row_##channel[index - 1]), \
                 correlate_row_##channel[index])
#define UPDATE_MODEL(index) APPLY_ALL_COMP(UPDATE_MODEL_COMP, index)

#define RLE_PRED_IMP                                                                \
if (SAME_PIXEL(&prev_row[i - 1], &prev_row[i])) {                                   \
    if (run_index != i && i > 2 && SAME_PIXEL(&cur_row[i - 1], &cur_row[i - 2])) {  \
        goto do_run;                                                                \
    }                                                                               \
}

#ifdef COMPRESS_IMP

static void FNAME_DECL(compress_row0_seg)(int i,
                                          const PIXEL * const cur_row,
                                          const int end,
                                          const unsigned int waitmask,
                                          const unsigned int bpc_mask)
{
    DECLARE_STATE_VARIABLES;
    DECLARE_CHANNEL_VARIABLES;
    int stopidx;

    spice_assert(end - i > 0);

    if (i == 0) {
        APPLY_ALL_COMP(COMPRESS_ONE_ROW0_0);

        if (state->waitcnt) {
            state->waitcnt--;
        } else {
            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);
            UPDATE_MODEL(0);
        }
        stopidx = ++i + state->waitcnt;
    } else {
        stopidx = i + state->waitcnt;
    }

    while (stopidx < end) {
        for (; i <= stopidx; i++) {
            APPLY_ALL_COMP(COMPRESS_ONE_ROW0, i);
        }

        UPDATE_MODEL(stopidx);
        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);
    }

    for (; i < end; i++) {
        APPLY_ALL_COMP(COMPRESS_ONE_ROW0, i);
    }
    state->waitcnt = stopidx - end;
}

#undef COMPRESS_ONE_ROW0_0
#undef COMPRESS_ONE_ROW0

static void FNAME_DECL(compress_row0)(const PIXEL *cur_row, unsigned int width)
{
    DECLARE_STATE_VARIABLES;
    const unsigned int bpc_mask = BPC_MASK;
    int pos = 0;

    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {
        if (state->wmileft) {
            FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + state->wmileft,
                                          bppmask[state->wmidx], bpc_mask);
            width -= state->wmileft;
            pos += state->wmileft;
        }

        state->wmidx++;
        set_wm_trigger(state);
        state->wmileft = DEFwminext;
    }

    if (width) {
        FNAME_CALL(compress_row0_seg)(pos, cur_row, pos + width,
                                      bppmask[state->wmidx], bpc_mask);
        if (DEFwmimax > (int)state->wmidx) {
            state->wmileft -= width;
        }
    }

    spice_assert((int)state->wmidx <= DEFwmimax);
    spice_assert(state->wmidx <= 32);
    spice_assert(DEFwminext > 0);
}

#define COMPRESS_ONE_0(channel) \
    correlate_row_##channel[0] = family.xlatU2L[(unsigned)((int)GET_##channel(cur_row) -              \
                                                          (int)GET_##channel(prev_row) ) & bpc_mask]; \
    golomb_coding(encoder, correlate_row_##channel[0],                                                \
                  find_bucket(channel_##channel, correlate_row_##channel[-1])->bestcode)

#define COMPRESS_ONE(channel, index)                                                                   \
     DECORRELATE(channel, &prev_row[index], &cur_row[index],bpc_mask, correlate_row_##channel[index]); \
     golomb_coding(encoder, correlate_row_##channel[index],                                            \
                   find_bucket(channel_##channel, correlate_row_##channel[index - 1])->bestcode)

static void FNAME_DECL(compress_row_seg)(int i,
                                         const PIXEL * const prev_row,
                                         const PIXEL * const cur_row,
                                         const int end,
                                         const unsigned int waitmask,
                                         const unsigned int bpc_mask)
{
    DECLARE_STATE_VARIABLES;
    DECLARE_CHANNEL_VARIABLES;
    int stopidx;
    int run_index = 0;
    int run_size;

    spice_assert(end - i > 0);

    if (i == 0) {
        APPLY_ALL_COMP(COMPRESS_ONE_0);

        if (state->waitcnt) {
            state->waitcnt--;
        } else {
            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);
            UPDATE_MODEL(0);
        }
        stopidx = ++i + state->waitcnt;
    } else {
        stopidx = i + state->waitcnt;
    }
    for (;;) {
        while (stopidx < end) {
            for (; i <= stopidx; i++) {
                RLE_PRED_IMP;
                APPLY_ALL_COMP(COMPRESS_ONE, i);
            }

            UPDATE_MODEL(stopidx);
            stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);
        }

        for (; i < end; i++) {
            RLE_PRED_IMP;
            APPLY_ALL_COMP(COMPRESS_ONE, i);
        }
        state->waitcnt = stopidx - end;

        return;

do_run:
        run_index = i;
        state->waitcnt = stopidx - i;
        run_size = 0;

        while (SAME_PIXEL(&cur_row[i], &cur_row[i - 1])) {
            run_size++;
            if (++i == end) {
                encode_state_run(encoder, state, run_size);
                return;
            }
        }
        encode_state_run(encoder, state, run_size);
        stopidx = i + state->waitcnt;
    }
}

static void FNAME_DECL(compress_row)(const PIXEL * const prev_row,
                                     const PIXEL * const cur_row,
                                     unsigned int width)

{
    DECLARE_STATE_VARIABLES;
    const unsigned int bpc_mask = BPC_MASK;
    unsigned int pos = 0;

    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {
        if (state->wmileft) {
            FNAME_CALL(compress_row_seg)(pos, prev_row, cur_row,
                                         pos + state->wmileft, bppmask[state->wmidx],
                                         bpc_mask);
            width -= state->wmileft;
            pos += state->wmileft;
        }

        state->wmidx++;
        set_wm_trigger(state);
        state->wmileft = DEFwminext;
    }

    if (width) {
        FNAME_CALL(compress_row_seg)(pos, prev_row, cur_row, pos + width,
                                     bppmask[state->wmidx], bpc_mask);
        if (DEFwmimax > (int)state->wmidx) {
            state->wmileft -= width;
        }
    }

    spice_assert((int)state->wmidx <= DEFwmimax);
    spice_assert(state->wmidx <= 32);
    spice_assert(DEFwminext > 0);
}

#endif

#define UNCOMPRESS_ONE_ROW0_0(channel)                                                                      \
    correlate_row_##channel[0] = (BYTE)golomb_decoding(find_bucket(channel_##channel,                       \
                                                                   correlate_row_##channel[-1])->bestcode,  \
                                                       encoder->io_word, &codewordlen);                     \
    SET_##channel(&cur_row[0], (BYTE)family.xlatL2U[correlate_row_##channel[0]]);                           \
    decode_eatbits(encoder, codewordlen);

#define UNCOMPRESS_ONE_ROW0(channel)                                                                           \
    correlate_row_##channel[i] = (BYTE)golomb_decoding(find_bucket(channel_##channel,                          \
                                                                   correlate_row_##channel[i - 1])->bestcode,  \
                                                       encoder->io_word, &codewordlen);                        \
    SET_##channel(&cur_row[i], CORRELATE_0(channel, &cur_row[i], correlate_row_##channel[i],                   \
                  bpc_mask));                                                                                  \
    decode_eatbits(encoder, codewordlen);

static void FNAME_DECL(uncompress_row0_seg)(int i,
                                            PIXEL * const cur_row,
                                            const int end,
                                            const unsigned int waitmask,
                                            const unsigned int bpc_mask)
{
    DECLARE_STATE_VARIABLES;
    DECLARE_CHANNEL_VARIABLES;
    int stopidx;

    spice_assert(end - i > 0);

    if (i == 0) {
        unsigned int codewordlen;

        UNCOMPRESS_PIX_START(&cur_row[i]);
        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0_0);

        if (state->waitcnt) {
            --state->waitcnt;
        } else {
            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);
            UPDATE_MODEL(0);
        }
        stopidx = ++i + state->waitcnt;
    } else {
        stopidx = i + state->waitcnt;
    }

    while (stopidx < end) {
        for (; i <= stopidx; i++) {
            unsigned int codewordlen;

            UNCOMPRESS_PIX_START(&cur_row[i]);
            APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);
        }
        UPDATE_MODEL(stopidx);
        stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);
    }

    for (; i < end; i++) {
        unsigned int codewordlen;

        UNCOMPRESS_PIX_START(&cur_row[i]);
        APPLY_ALL_COMP(UNCOMPRESS_ONE_ROW0);
    }
    state->waitcnt = stopidx - end;
}

static void FNAME_DECL(uncompress_row0)(PIXEL * const cur_row,
                                        unsigned int width)

{
    DECLARE_STATE_VARIABLES;
    const unsigned int bpc_mask = BPC_MASK;
    unsigned int pos = 0;

    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {
        if (state->wmileft) {
            FNAME_CALL(uncompress_row0_seg)(pos, cur_row,
                                            pos + state->wmileft,
                                            bppmask[state->wmidx],
                                            bpc_mask);
            pos += state->wmileft;
            width -= state->wmileft;
        }

        state->wmidx++;
        set_wm_trigger(state);
        state->wmileft = DEFwminext;
    }

    if (width) {
        FNAME_CALL(uncompress_row0_seg)(pos, cur_row, pos + width,
                                        bppmask[state->wmidx], bpc_mask);
        if (DEFwmimax > (int)state->wmidx) {
            state->wmileft -= width;
        }
    }

    spice_assert((int)state->wmidx <= DEFwmimax);
    spice_assert(state->wmidx <= 32);
    spice_assert(DEFwminext > 0);
}

#define UNCOMPRESS_ONE_0(channel)                                                                          \
    correlate_row_##channel[0] = (BYTE)golomb_decoding(find_bucket(channel_##channel,                      \
                                                                   correlate_row_##channel[-1])->bestcode, \
                                                       encoder->io_word, &codewordlen);                    \
    SET_##channel(&cur_row[0], (family.xlatL2U[correlate_row_##channel[0]] +                               \
                  GET_##channel(prev_row)) & bpc_mask);                                                    \
    decode_eatbits(encoder, codewordlen);

#define UNCOMPRESS_ONE(channel)                                                                               \
    correlate_row_##channel[i] = (BYTE)golomb_decoding(find_bucket(channel_##channel,                         \
                                                                   correlate_row_##channel[i - 1])->bestcode, \
                                                       encoder->io_word, &codewordlen);                       \
    CORRELATE(channel, &prev_row[i], &cur_row[i], correlate_row_##channel[i], bpc_mask,                       \
              &cur_row[i]);                                                                                   \
    decode_eatbits(encoder, codewordlen);

static void FNAME_DECL(uncompress_row_seg)(const PIXEL * const prev_row,
                                           PIXEL * const cur_row,
                                           int i,
                                           const int end,
                                           const unsigned int bpc_mask)
{
    DECLARE_STATE_VARIABLES;
    DECLARE_CHANNEL_VARIABLES;
    const unsigned int waitmask = bppmask[state->wmidx];
    int stopidx;
    int run_index = 0;
    int run_end;

    spice_assert(end - i > 0);

    if (i == 0) {
        unsigned int codewordlen;

        UNCOMPRESS_PIX_START(&cur_row[i]);
        APPLY_ALL_COMP(UNCOMPRESS_ONE_0);

        if (state->waitcnt) {
            --state->waitcnt;
        } else {
            state->waitcnt = (tabrand(&state->tabrand_seed) & waitmask);
            UPDATE_MODEL(0);
        }
        stopidx = ++i + state->waitcnt;
    } else {
        stopidx = i + state->waitcnt;
    }
    for (;;) {
        while (stopidx < end) {
            for (; i <= stopidx; i++) {
                unsigned int codewordlen;
                RLE_PRED_IMP;
                UNCOMPRESS_PIX_START(&cur_row[i]);
                APPLY_ALL_COMP(UNCOMPRESS_ONE);
            }

            UPDATE_MODEL(stopidx);

            stopidx = i + (tabrand(&state->tabrand_seed) & waitmask);
        }

        for (; i < end; i++) {
            unsigned int codewordlen;
            RLE_PRED_IMP;
            UNCOMPRESS_PIX_START(&cur_row[i]);
            APPLY_ALL_COMP(UNCOMPRESS_ONE);
        }

        state->waitcnt = stopidx - end;

        return;

do_run:
        state->waitcnt = stopidx - i;
        run_index = i;
        run_end = decode_state_run(encoder, state);
        if (run_end < 0 || run_end > (end - i)) {
            encoder->usr->error(encoder->usr, "wrong RLE\n");
        }
        run_end += i;

        for (; i < run_end; i++) {
            UNCOMPRESS_PIX_START(&cur_row[i]);
            COPY_PIXEL(&cur_row[i], &cur_row[i - 1]);
        }

        if (i == end) {
            return;
        }

        stopidx = i + state->waitcnt;
    }
}

static void FNAME_DECL(uncompress_row)(const PIXEL * const prev_row,
                                       PIXEL * const cur_row,
                                       unsigned int width)

{
    DECLARE_STATE_VARIABLES;
    const unsigned int bpc_mask = BPC_MASK;
    unsigned int pos = 0;

    while ((DEFwmimax > (int)state->wmidx) && (state->wmileft <= width)) {
        if (state->wmileft) {
            FNAME_CALL(uncompress_row_seg)(prev_row, cur_row, pos,
                                           pos + state->wmileft, bpc_mask);
            pos += state->wmileft;
            width -= state->wmileft;
        }

        state->wmidx++;
        set_wm_trigger(state);
        state->wmileft = DEFwminext;
    }

    if (width) {
        FNAME_CALL(uncompress_row_seg)(prev_row, cur_row, pos,
                                       pos + width, bpc_mask);
        if (DEFwmimax > (int)state->wmidx) {
            state->wmileft -= width;
        }
    }

    spice_assert((int)state->wmidx <= DEFwmimax);
    spice_assert(state->wmidx <= 32);
    spice_assert(DEFwminext > 0);
}

#undef PIXEL
#undef FARGS_CALL
#undef FARGS_DECL
#undef FNAME
#undef FNAME_CALL
#undef FNAME_DECL
#undef _PIXEL_A
#undef _PIXEL_B
#undef SAME_PIXEL
#undef RLE_PRED_IMP
#undef UPDATE_MODEL
#undef DECORRELATE_0
#undef DECORRELATE
#undef COMPRESS_ONE_0
#undef COMPRESS_ONE
#undef CORRELATE_0
#undef CORRELATE
#undef UNCOMPRESS_ONE_ROW0_0
#undef UNCOMPRESS_ONE_ROW0
#undef UNCOMPRESS_ONE_0
#undef UNCOMPRESS_ONE
#undef golomb_coding
#undef golomb_decoding
#undef update_model
#undef find_bucket
#undef family
#undef BPC
#undef BPC_MASK
#undef COMPRESS_IMP
#undef SET_r
#undef GET_r
#undef SET_g
#undef GET_g
#undef SET_b
#undef GET_b
#undef SET_a
#undef GET_a
#undef UNCOMPRESS_PIX_START
#undef UPDATE_MODEL_COMP
#undef APPLY_ALL_COMP
#undef DECLARE_STATE_VARIABLES
#undef DECLARE_CHANNEL_VARIABLES
#undef COPY_PIXEL

```

`devices/display/qxl/canvas/rect.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_RECT
#define H_SPICE_COMMON_RECT

#include <spice/macros.h>
#include "draw.h"
#include "log.h"

SPICE_BEGIN_DECLS

static inline void rect_sect(SpiceRect* r, const SpiceRect* bounds)
{
    r->left = MAX(r->left, bounds->left);
    r->right = MIN(r->right, bounds->right);
    r->right = MAX(r->left, r->right);

    r->top = MAX(r->top, bounds->top);
    r->bottom = MIN(r->bottom, bounds->bottom);
    r->bottom = MAX(r->top, r->bottom);
}

static inline void rect_offset(SpiceRect* r, int dx, int dy)
{
    r->left += dx;
    r->right += dx;
    r->top += dy;
    r->bottom += dy;
}

static inline int rect_is_empty(const SpiceRect* r)
{
    return r->top == r->bottom || r->left == r->right;
}

static inline int rect_intersects(const SpiceRect* r1, const SpiceRect* r2)
{
    return r1->left < r2->right && r1->right > r2->left &&
           r1->top < r2->bottom && r1->bottom > r2->top;
}

static inline int rect_is_equal(const SpiceRect *r1, const SpiceRect *r2)
{
    return r1->top == r2->top && r1->left == r2->left &&
           r1->bottom == r2->bottom && r1->right == r2->right;
}

static inline void rect_union(SpiceRect *dest, const SpiceRect *r)
{
    dest->top = MIN(dest->top, r->top);
    dest->left = MIN(dest->left, r->left);
    dest->bottom = MAX(dest->bottom, r->bottom);
    dest->right = MAX(dest->right, r->right);
}

static inline int rect_is_same_size(const SpiceRect *r1, const SpiceRect *r2)
{
    return r1->right - r1->left == r2->right - r2->left &&
           r1->bottom - r1->top == r2->bottom - r2->top;
}

static inline int rect_contains(const SpiceRect *big_rect, const SpiceRect *small_rect)
{
    return big_rect->left <= small_rect->left && big_rect->right >= small_rect->right &&
           big_rect->top <= small_rect->top && big_rect->bottom >= small_rect->bottom;
}

static inline int rect_get_area(const SpiceRect *r)
{
    return (r->right - r->left) * (r->bottom - r->top);
}

static inline void rect_debug(const SpiceRect *r)
{
    spice_debug("(%d, %d) (%d, %d)", r->left, r->top, r->right, r->bottom);
}

SPICE_END_DECLS

#ifdef __cplusplus

static inline void rect_sect(SpiceRect& r, const SpiceRect& bounds)
{
    rect_sect(&r, &bounds);
}

static inline void rect_offset(SpiceRect& r, int dx, int dy)
{
    rect_offset(&r, dx, dy);
}

static inline int rect_is_empty(const SpiceRect& r)
{
    return rect_is_empty(&r);
}

static inline int rect_intersects(const SpiceRect& r1, const SpiceRect& r2)
{
    return rect_intersects(&r1, &r2);
}

static inline int rect_is_equal(const SpiceRect& r1, const SpiceRect& r2)
{
    return rect_is_equal(&r1, &r2);
}

static inline void rect_union(SpiceRect& dest, const SpiceRect& r)
{
    rect_union(&dest, &r);
}

static inline int rect_is_same_size(const SpiceRect& r1, const SpiceRect& r2)
{
    return rect_is_same_size(&r1, &r2);
}

static inline int rect_contains(const SpiceRect& big_rect, const SpiceRect& small_rect)
{
    return rect_contains(&big_rect, &small_rect);
}

static inline int rect_get_area(const SpiceRect& r)
{
    return rect_get_area(&r);
}

static inline void rect_debug(const SpiceRect &r)
{
    rect_debug(&r);
}

#endif /* __cplusplus */

#endif

```

`devices/display/qxl/canvas/region.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <spice/macros.h>

#include "region.h"
#include "rect.h"
#include "mem.h"

/*  true iff two Boxes overlap */
#define EXTENTCHECK(r1, r2)        \
    (!( ((r1)->x2 <= (r2)->x1)  || \
        ((r1)->x1 >= (r2)->x2)  || \
        ((r1)->y2 <= (r2)->y1)  || \
        ((r1)->y1 >= (r2)->y2) ) )

/* true iff Box r1 contains Box r2 */
#define SUBSUMES(r1, r2)        \
    ( ((r1)->x1 <= (r2)->x1) && \
      ((r1)->x2 >= (r2)->x2) && \
      ((r1)->y1 <= (r2)->y1) && \
      ((r1)->y2 >= (r2)->y2) )


void region_init(QRegion *rgn)
{
    pixman_region32_init(rgn);
}

void region_clear(QRegion *rgn)
{
    pixman_region32_fini(rgn);
    pixman_region32_init(rgn);
}

void region_destroy(QRegion *rgn)
{
    pixman_region32_fini(rgn);
}

void region_clone(QRegion *dest, const QRegion *src)
{
    pixman_region32_init(dest);
    pixman_region32_copy(dest, (pixman_region32_t *)src);
}

#define FIND_BAND(r, r_band_end, r_end, ry1)                         \
    do {                                                             \
        ry1 = r->y1;                                                 \
        r_band_end = r + 1;                                          \
        while ((r_band_end != r_end) && (r_band_end->y1 == ry1)) {   \
            r_band_end++;                                            \
        }                                                            \
    } while (0)

static int test_band(int query,
                     int res,
                     pixman_box32_t *r1,
                     pixman_box32_t *r1_end,
                     pixman_box32_t *r2,
                     pixman_box32_t *r2_end)
{
    int x1;
    int x2;

    do {
        x1 = MAX(r1->x1, r2->x1);
        x2 = MIN(r1->x2, r2->x2);

        /*
         * Is there any overlap between the two rectangles?
         */
        if (x1 < x2) {
            res |= REGION_TEST_SHARED;

            if (r1->x1 < r2->x1 || r1->x2 > r2->x2) {
                res |= REGION_TEST_LEFT_EXCLUSIVE;
            }

            if (r2->x1 < r1->x1 || r2->x2 > r1->x2) {
                res |= REGION_TEST_RIGHT_EXCLUSIVE;
            }
        } else {
            /* No overlap at all, the leftmost is exclusive */
            if (r1->x1 < r2->x1) {
                res |= REGION_TEST_LEFT_EXCLUSIVE;
            } else {
                res |= REGION_TEST_RIGHT_EXCLUSIVE;
            }
        }

        if ((res & query) == query) {
            return res;
        }

        /*
         * Advance the pointer(s) with the leftmost right side, since the next
         * rectangle on that list may still overlap the other region's
         * current rectangle.
         */
        if (r1->x2 == x2) {
            r1++;
        }
        if (r2->x2 == x2) {
            r2++;
        }
    } while ((r1 != r1_end) && (r2 != r2_end));

    /*
     * Deal with whichever band (if any) still has rectangles left.
     */
    if (r1 != r1_end) {
        res |= REGION_TEST_LEFT_EXCLUSIVE;
    } else if (r2 != r2_end) {
        res |= REGION_TEST_RIGHT_EXCLUSIVE;
    }

    return res;
}

static int test_generic (pixman_region32_t *reg1,
                         pixman_region32_t *reg2,
                         int query)
{
    pixman_box32_t *r1;             /* Pointer into first region     */
    pixman_box32_t *r2;             /* Pointer into 2d region        */
    pixman_box32_t *r1_end;         /* End of 1st region             */
    pixman_box32_t *r2_end;         /* End of 2d region              */
    int ybot;                       /* Bottom of intersection        */
    int ytop;                       /* Top of intersection           */
    pixman_box32_t * r1_band_end;   /* End of current band in r1     */
    pixman_box32_t * r2_band_end;   /* End of current band in r2     */
    int top;                        /* Top of non-overlapping band   */
    int bot;                        /* Bottom of non-overlapping band*/
    int r1y1;                       /* Temps for r1->y1 and r2->y1   */
    int r2y1;
    int r1_num_rects;
    int r2_num_rects;
    int res;

    r1 = pixman_region32_rectangles(reg1, &r1_num_rects);
    r1_end = r1 + r1_num_rects;

    r2 = pixman_region32_rectangles(reg2, &r2_num_rects);
    r2_end = r2 + r2_num_rects;

    res = 0;

    /*
     * Initialize ybot.
     * In the upcoming loop, ybot and ytop serve different functions depending
     * on whether the band being handled is an overlapping or non-overlapping
     * band.
     *  In the case of a non-overlapping band (only one of the regions
     * has points in the band), ybot is the bottom of the most recent
     * intersection and thus clips the top of the rectangles in that band.
     * ytop is the top of the next intersection between the two regions and
     * serves to clip the bottom of the rectangles in the current band.
     *  For an overlapping band (where the two regions intersect), ytop clips
     * the top of the rectangles of both regions and ybot clips the bottoms.
     */

    ybot = MIN(r1->y1, r2->y1);

    do {
        /*
         * This algorithm proceeds one source-band (as opposed to a
         * destination band, which is determined by where the two regions
         * intersect) at a time. r1_band_end and r2_band_end serve to mark the
         * rectangle after the last one in the current band for their
         * respective regions.
         */
        FIND_BAND(r1, r1_band_end, r1_end, r1y1);
        FIND_BAND(r2, r2_band_end, r2_end, r2y1);

        /*
         * First handle the band that doesn't intersect, if any.
         *
         * Note that attention is restricted to one band in the
         * non-intersecting region at once, so if a region has n
         * bands between the current position and the next place it overlaps
         * the other, this entire loop will be passed through n times.
         */
        if (r1y1 < r2y1) {
            top = MAX (r1y1, ybot);
            bot = MIN (r1->y2, r2y1);
            if (top != bot) {
                res |= REGION_TEST_LEFT_EXCLUSIVE;

                if ((res & query) == query) {
                    return res & query;
                }
            }

            ytop = r2y1;
        } else if (r2y1 < r1y1) {
            top = MAX (r2y1, ybot);
            bot = MIN (r2->y2, r1y1);

            if (top != bot) {
                res |= REGION_TEST_RIGHT_EXCLUSIVE;

                if ((res & query) == query) {
                    return res & query;
                }
            }
            ytop = r1y1;
        } else {
            ytop = r1y1;
        }

        /*
         * Now see if we've hit an intersecting band. The two bands only
         * intersect if ybot > ytop
         */
        ybot = MIN (r1->y2, r2->y2);
        if (ybot > ytop) {
            res = test_band(query, res,
                            r1, r1_band_end,
                            r2, r2_band_end);
            if ((res & query) == query) {
                return res & query;
            }
        }

        /*
         * If we've finished with a band (y2 == ybot) we skip forward
         * in the region to the next band.
         */
        if (r1->y2 == ybot) {
            r1 = r1_band_end;
        }

        if (r2->y2 == ybot) {
            r2 = r2_band_end;
        }

    }
    while (r1 != r1_end && r2 != r2_end);

    /*
     * Deal with whichever region (if any) still has rectangles left.
     */

    if (r1 != r1_end) {
        res |= REGION_TEST_LEFT_EXCLUSIVE;
    } else if (r2 != r2_end) {
        res |= REGION_TEST_RIGHT_EXCLUSIVE;
    }

    return res & query;
}

int region_test(const QRegion *_reg1, const QRegion *_reg2, int query)
{
    int res;
    pixman_region32_t *reg1 = (pixman_region32_t *)_reg1;
    pixman_region32_t *reg2 = (pixman_region32_t *)_reg2;

    query = (query) ? query & REGION_TEST_ALL : REGION_TEST_ALL;

    res = 0;

    if (!pixman_region32_not_empty(reg1) || !pixman_region32_not_empty(reg2) ||
        !EXTENTCHECK (&reg1->extents, &reg2->extents)) {
        /* One or more regions are empty or they are disjoint */

        if (pixman_region32_not_empty(reg1)) {
            res |= REGION_TEST_LEFT_EXCLUSIVE;
        }

        if (pixman_region32_not_empty(reg2)) {
            res |= REGION_TEST_RIGHT_EXCLUSIVE;
        }

        return res & query;
    } else if (!reg1->data && !reg2->data) {
        /* Just two rectangles that intersect */
        res |= REGION_TEST_SHARED;

        if (!SUBSUMES(&reg1->extents, &reg2->extents)) {
            res |= REGION_TEST_RIGHT_EXCLUSIVE;
        }

        if (!SUBSUMES(&reg2->extents, &reg1->extents)) {
            res |= REGION_TEST_LEFT_EXCLUSIVE;
        }

        return res & query;
    } else if (!reg2->data && SUBSUMES (&reg2->extents, &reg1->extents)) {
        /* reg2 is just a rect that contains all of reg1 */

        res |= REGION_TEST_SHARED; /* some piece must be shared, because reg is not empty */
        res |= REGION_TEST_RIGHT_EXCLUSIVE; /* reg2 contains all of reg1 and then some */

        return res & query;
    } else if (!reg1->data && SUBSUMES (&reg1->extents, &reg2->extents)) {
        /* reg1 is just a rect that contains all of reg2 */

        res |= REGION_TEST_SHARED; /* some piece must be shared, because reg is not empty */
        res |= REGION_TEST_LEFT_EXCLUSIVE; /* reg1 contains all of reg2 and then some */

        return res & query;
    } else if (reg1 == reg2) {
        res |= REGION_TEST_SHARED;
        return res & query;
    } else {
        /* General purpose intersection */
        return test_generic (reg1, reg2, query);
    }
}

int region_is_valid(const QRegion *rgn)
{
    return pixman_region32_selfcheck((pixman_region32_t *)rgn);
}

int region_is_empty(const QRegion *rgn)
{
    return !pixman_region32_not_empty((pixman_region32_t *)rgn);
}

SpiceRect *region_dup_rects(const QRegion *rgn, uint32_t *num_rects)
{
    pixman_box32_t *boxes;
    SpiceRect *rects;
    int n, i;

    boxes = pixman_region32_rectangles((pixman_region32_t *)rgn, &n);
    if (num_rects) {
        *num_rects = n;
    }
    rects = spice_new(SpiceRect, n);
    for (i = 0; i < n; i++) {
        rects[i].left = boxes[i].x1;
        rects[i].top = boxes[i].y1;
        rects[i].right = boxes[i].x2;
        rects[i].bottom = boxes[i].y2;
    }
    return rects;
}

void region_ret_rects(const QRegion *rgn, SpiceRect *rects, uint32_t num_rects)
{
    pixman_box32_t *boxes;
    unsigned int n, i;

    boxes = pixman_region32_rectangles((pixman_region32_t *)rgn, (int *)&n);
    for (i = 0; i < n && i < num_rects; i++) {
        rects[i].left = boxes[i].x1;
        rects[i].top = boxes[i].y1;
        rects[i].right = boxes[i].x2;
        rects[i].bottom = boxes[i].y2;
    }

    if (i && i != n) {
        unsigned int x;

        for (x = 0; x < (n - num_rects); ++x) {
            rects[i - 1].left = MIN(rects[i - 1].left, boxes[i + x].x1);
            rects[i - 1].top = MIN(rects[i - 1].top, boxes[i + x].y1);
            rects[i - 1].right = MAX(rects[i - 1].right, boxes[i + x].x2);
            rects[i - 1].bottom = MAX(rects[i - 1].bottom, boxes[i + x].y2);
        }
    }
}

void region_extents(const QRegion *rgn, SpiceRect *r)
{
    pixman_box32_t *extents;

    extents = pixman_region32_extents((pixman_region32_t *)rgn);

    r->left = extents->x1;
    r->top = extents->y1;
    r->right = extents->x2;
    r->bottom = extents->y2;
}

int region_is_equal(const QRegion *rgn1, const QRegion *rgn2)
{
    return pixman_region32_equal((pixman_region32_t *)rgn1, (pixman_region32_t *)rgn2);
}

int region_intersects(const QRegion *rgn1, const QRegion *rgn2)
{
    int test_res;

    if (!region_bounds_intersects(rgn1, rgn2)) {
        return FALSE;
    }

    test_res = region_test(rgn1, rgn2, REGION_TEST_SHARED);
    return !!test_res;
}

int region_bounds_intersects(const QRegion *rgn1, const QRegion *rgn2)
{
    pixman_box32_t *extents1, *extents2;

    extents1 = pixman_region32_extents((pixman_region32_t *)rgn1);
    extents2 = pixman_region32_extents((pixman_region32_t *)rgn2);

    return EXTENTCHECK(extents1, extents2);
}

int region_contains(const QRegion *rgn, const QRegion *other)
{
    int test_res;

    test_res = region_test(rgn, other, REGION_TEST_RIGHT_EXCLUSIVE);
    return !test_res;
}

int region_contains_point(const QRegion *rgn, int32_t x, int32_t y)
{
    return pixman_region32_contains_point((pixman_region32_t *)rgn, x, y, NULL);
}

void region_or(QRegion *rgn, const QRegion *other_rgn)
{
    pixman_region32_union(rgn, rgn, (pixman_region32_t *)other_rgn);
}

void region_and(QRegion *rgn, const QRegion *other_rgn)
{
    pixman_region32_intersect(rgn, rgn, (pixman_region32_t *)other_rgn);
}

void region_xor(QRegion *rgn, const QRegion *other_rgn)
{
    pixman_region32_t intersection;

    pixman_region32_init(&intersection);
    pixman_region32_copy(&intersection, rgn);
    pixman_region32_intersect(&intersection,
                              &intersection,
                              (pixman_region32_t *)other_rgn);
    pixman_region32_union(rgn, rgn, (pixman_region32_t *)other_rgn);
    pixman_region32_subtract(rgn, rgn, &intersection);
    pixman_region32_fini(&intersection);
}

void region_exclude(QRegion *rgn, const QRegion *other_rgn)
{
    pixman_region32_subtract(rgn, rgn, (pixman_region32_t *)other_rgn);
}

void region_add(QRegion *rgn, const SpiceRect *r)
{
    pixman_region32_union_rect(rgn, rgn, r->left, r->top,
                               r->right - r->left,
                               r->bottom - r->top);
}

void region_remove(QRegion *rgn, const SpiceRect *r)
{
    pixman_region32_t rg;

    pixman_region32_init_rect(&rg, r->left, r->top,
                              r->right - r->left,
                              r->bottom - r->top);
    pixman_region32_subtract(rgn, rgn, &rg);
    pixman_region32_fini(&rg);
}


void region_offset(QRegion *rgn, int32_t dx, int32_t dy)
{
    pixman_region32_translate(rgn, dx, dy);
}

void region_dump(const QRegion *rgn, const char *prefix)
{
    pixman_box32_t *rects, *extents;
    int n_rects, i;

    printf("%sREGION: %p, ", prefix, rgn);

    if (!pixman_region32_not_empty((pixman_region32_t *)rgn)) {
        printf("EMPTY\n");
        return;
    }

    extents = pixman_region32_extents((pixman_region32_t *)rgn);
    rects = pixman_region32_rectangles((pixman_region32_t *)rgn, &n_rects);
    printf("num %u bounds (%d, %d, %d, %d)\n",
           n_rects,
           extents->x1,
           extents->y1,
           extents->x2,
           extents->y2);


    for (i = 0; i < n_rects; i++) {
        printf("%*s  %12d %12d %12d %12d\n",
               (int)strlen(prefix), "",
               rects[i].x1,
               rects[i].y1,
               rects[i].x2,
               rects[i].y2);
    }
}

```

`devices/display/qxl/canvas/region.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_REGION
#define H_SPICE_COMMON_REGION

#include <stdint.h>
#include <spice/macros.h>

#include "draw.h"
#include "pixman_utils.h"

SPICE_BEGIN_DECLS

typedef pixman_region32_t QRegion;

/* the left region is not contained entirely within the right region */
#define REGION_TEST_LEFT_EXCLUSIVE (1 << 0)
/* the right region is not contained entirely within the left region */
#define REGION_TEST_RIGHT_EXCLUSIVE (1 << 1)
/* the regions overlap */
#define REGION_TEST_SHARED (1 << 2)
#define REGION_TEST_ALL \
    (REGION_TEST_LEFT_EXCLUSIVE | REGION_TEST_RIGHT_EXCLUSIVE | REGION_TEST_SHARED)

void region_init(QRegion *rgn);
void region_clear(QRegion *rgn);
void region_destroy(QRegion *rgn);
void region_clone(QRegion *dest, const QRegion *src);
SpiceRect *region_dup_rects(const QRegion *rgn, uint32_t *num_rects);
void region_ret_rects(const QRegion *rgn, SpiceRect *rects, uint32_t num_rects);
void region_extents(const QRegion *rgn, SpiceRect *r);

int region_test(const QRegion *rgn, const QRegion *other_rgn, int query);
int region_is_valid(const QRegion *rgn);
int region_is_empty(const QRegion *rgn);
int region_is_equal(const QRegion *rgn1, const QRegion *rgn2);
int region_intersects(const QRegion *rgn1, const QRegion *rgn2);
int region_bounds_intersects(const QRegion *rgn1, const QRegion *rgn2);
int region_contains(const QRegion *rgn, const QRegion *other);
int region_contains_point(const QRegion *rgn, int32_t x, int32_t y);

void region_or(QRegion *rgn, const QRegion *other_rgn);
void region_and(QRegion *rgn, const QRegion *other_rgn);
void region_xor(QRegion *rgn, const QRegion *other_rgn);
void region_exclude(QRegion *rgn, const QRegion *other_rgn);

void region_add(QRegion *rgn, const SpiceRect *r);
void region_remove(QRegion *rgn, const SpiceRect *r);

void region_offset(QRegion *rgn, int32_t dx, int32_t dy);


void region_dump(const QRegion *rgn, const char *prefix);

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/ring.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_RING
#define H_SPICE_COMMON_RING

#include "log.h"

SPICE_BEGIN_DECLS

typedef struct Ring RingItem;
typedef struct Ring {
    RingItem *prev;
    RingItem *next;
} Ring;

static inline void ring_init(Ring *ring)
{
    ring->next = ring->prev = ring;
}

static inline void ring_item_init(RingItem *item)
{
    item->next = item->prev = NULL;
}

static inline int ring_item_is_linked(RingItem *item)
{
    return !!item->next;
}

static inline int ring_is_empty(Ring *ring)
{
    spice_assert(ring->next != NULL && ring->prev != NULL);
    return ring == ring->next;
}

static inline void ring_add(Ring *ring, RingItem *item)
{
    spice_assert(ring->next != NULL && ring->prev != NULL);
    spice_assert(item->next == NULL && item->prev == NULL);

    item->next = ring->next;
    item->prev = ring;
    ring->next = item->next->prev = item;
}

static inline void ring_add_after(RingItem *item, RingItem *pos)
{
    ring_add(pos, item);
}

static inline void ring_add_before(RingItem *item, RingItem *pos)
{
    ring_add(pos->prev, item);
}

static inline void ring_remove(RingItem *item)
{
    spice_assert(item->next != NULL && item->prev != NULL);
    spice_assert(item->next != item);

    item->next->prev = item->prev;
    item->prev->next = item->next;
    item->prev = item->next = NULL;
}

static inline RingItem *ring_get_head(Ring *ring)
{
    spice_assert(ring->next != NULL && ring->prev != NULL);

    if (ring_is_empty(ring)) {
        return NULL;
    }
    return ring->next;
}

static inline RingItem *ring_get_tail(Ring *ring)
{
    spice_assert(ring->next != NULL && ring->prev != NULL);

    if (ring_is_empty(ring)) {
        return NULL;
    }
    return ring->prev;
}

static inline RingItem *ring_next(Ring *ring, RingItem *pos)
{
    RingItem *ret;

    spice_assert(ring->next != NULL && ring->prev != NULL);
    spice_assert(pos);
    spice_assert(pos->next != NULL && pos->prev != NULL);
    ret = pos->next;
    return (ret == ring) ? NULL : ret;
}

static inline RingItem *ring_prev(Ring *ring, RingItem *pos)
{
    RingItem *ret;

    spice_assert(ring->next != NULL && ring->prev != NULL);
    spice_assert(pos);
    spice_assert(pos->next != NULL && pos->prev != NULL);
    ret = pos->prev;
    return (ret == ring) ? NULL : ret;
}

#define RING_FOREACH_SAFE(var, next, ring)                    \
    for ((var) = ring_get_head(ring);                         \
            (var) && ((next) = ring_next(ring, (var)), 1);    \
            (var) = (next))


#define RING_FOREACH(var, ring)                 \
    for ((var) = ring_get_head(ring);           \
            (var);                              \
            (var) = ring_next(ring, var))

#define RING_FOREACH_REVERSED(var, ring)        \
    for ((var) = ring_get_tail(ring);           \
            (var);                              \
            (var) = ring_prev(ring, var))


static inline unsigned int ring_get_length(Ring *ring)
{
    RingItem *i;
    unsigned int ret = 0;

    RING_FOREACH(i, ring)
        ret++;

    return ret;
}

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/rop3.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#include "config.h"

#include "rop3.h"

typedef void (*rop3_with_pattern_handler_t)(pixman_image_t *d, pixman_image_t *s,
                                            SpicePoint *src_pos, pixman_image_t *p,
                                            SpicePoint *pat_pos);

typedef void (*rop3_with_color_handler_t)(pixman_image_t *d, pixman_image_t *s,
                                          SpicePoint *src_pos, uint32_t rgb);

typedef void (*rop3_test_handler_t)(void);

#define ROP3_NUM_OPS 256

static rop3_with_pattern_handler_t rop3_with_pattern_handlers_32[ROP3_NUM_OPS];
static rop3_with_pattern_handler_t rop3_with_pattern_handlers_16[ROP3_NUM_OPS];
static rop3_with_color_handler_t rop3_with_color_handlers_32[ROP3_NUM_OPS];
static rop3_with_color_handler_t rop3_with_color_handlers_16[ROP3_NUM_OPS];
static rop3_test_handler_t rop3_test_handlers_32[ROP3_NUM_OPS];
static rop3_test_handler_t rop3_test_handlers_16[ROP3_NUM_OPS];


static void default_rop3_with_pattern_handler(SPICE_GNUC_UNUSED pixman_image_t *d,
                                              SPICE_GNUC_UNUSED pixman_image_t *s,
                                              SPICE_GNUC_UNUSED SpicePoint *src_pos,
                                              SPICE_GNUC_UNUSED pixman_image_t *p,
                                              SPICE_GNUC_UNUSED SpicePoint *pat_pos)
{
    spice_critical("not implemented");
}

static void default_rop3_withe_color_handler(SPICE_GNUC_UNUSED pixman_image_t *d,
                                             SPICE_GNUC_UNUSED pixman_image_t *s,
                                             SPICE_GNUC_UNUSED SpicePoint *src_pos,
                                             SPICE_GNUC_UNUSED uint32_t rgb)
{
    spice_critical("not implemented");
}

static void default_rop3_test_handler(void)
{
}

#define ROP3_HANDLERS_DEPTH(name, formula, index, depth)                            \
static void rop3_handle_p##depth##_##name(pixman_image_t *d, pixman_image_t *s,                 \
                                          SpicePoint *src_pos,                                  \
                                          pixman_image_t *p, SpicePoint *pat_pos)               \
{                                                                                               \
    int width = pixman_image_get_width(d);                                                      \
    int height = pixman_image_get_height(d);                                                    \
    uint8_t *dest_line = (uint8_t *)pixman_image_get_data(d);                                   \
    int dest_stride = pixman_image_get_stride(d);                                               \
    uint8_t *end_line = dest_line + height * dest_stride;                                       \
                                                                                                \
    int pat_width = pixman_image_get_width(p);                                                  \
    int pat_height = pixman_image_get_height(p);                                                \
    uint8_t *pat_base = (uint8_t *)pixman_image_get_data(p);                                    \
    int pat_stride = pixman_image_get_stride(p);                                                \
    int pat_v_offset = pat_pos->y;                                                              \
                                                                                                \
    int src_stride = pixman_image_get_stride(s);                                                \
    uint8_t *src_line;                                                                          \
    src_line = (uint8_t *)pixman_image_get_data(s) + src_pos->y * src_stride + (src_pos->x * depth / 8); \
                                                                                                \
    for (; dest_line < end_line; dest_line += dest_stride, src_line += src_stride) {            \
        uint##depth##_t *dest = (uint##depth##_t *)dest_line;                                   \
        uint##depth##_t *end = dest + width;                                                    \
        uint##depth##_t *src = (uint##depth##_t *)src_line;                                     \
                                                                                                \
        int pat_h_offset = pat_pos->x;                                                          \
                                                                                                \
        for (; dest < end; dest++, src++) {                                                     \
            uint##depth##_t *pat;                                                               \
            pat  = (uint##depth##_t *)                                                          \
                        (pat_base + pat_v_offset * pat_stride + (pat_h_offset * depth / 8));    \
            *dest = formula;                                                                    \
            pat_h_offset = (pat_h_offset + 1) % pat_width;                                      \
        }                                                                                       \
                                                                                                \
        pat_v_offset = (pat_v_offset + 1) % pat_height;                                         \
    }                                                                                           \
}                                                                                               \
                                                                                                \
static void rop3_handle_c##depth##_##name(pixman_image_t *d, pixman_image_t *s,                 \
                                          SpicePoint *src_pos,                                  \
                                          uint32_t rgb)                                         \
{                                                                                               \
    int width = pixman_image_get_width(d);                                                      \
    int height = pixman_image_get_height(d);                                                    \
    uint8_t *dest_line = (uint8_t *)pixman_image_get_data(d);                                   \
    int dest_stride = pixman_image_get_stride(d);                                               \
    uint8_t *end_line = dest_line + height * dest_stride;                                       \
    uint##depth##_t _pat = rgb;                                                                \
    uint##depth##_t *pat = &_pat;                                                               \
                                                                                                \
    int src_stride = pixman_image_get_stride(s);                                                \
    uint8_t *src_line;                                                                          \
    src_line = (uint8_t *)                                                                      \
        pixman_image_get_data(s) + src_pos->y * src_stride + (src_pos->x * depth / 8);          \
                                                                                                \
    for (; dest_line < end_line; dest_line += dest_stride, src_line += src_stride) {            \
        uint##depth##_t *dest = (uint##depth##_t *)dest_line;                                   \
        uint##depth##_t *end = dest + width;                                                    \
        uint##depth##_t *src = (uint##depth##_t *)src_line;                                     \
        for (; dest < end; dest++, src++) {                                                     \
            *dest = formula;                                                                    \
        }                                                                                       \
    }                                                                                           \
}                                                                                               \
                                                                                                \
static void rop3_test##depth##_##name(void)                                                     \
{                                                                                               \
    uint8_t d = 0xaa;                                                                           \
    uint8_t s = 0xcc;                                                                           \
    uint8_t p = 0xf0;                                                                           \
    uint8_t *pat = &p;                                                                          \
    uint8_t *src = &s;                                                                          \
    uint8_t *dest = &d;                                                                         \
                                                                                                \
    d = formula;                                                                                \
    if (d != index) {                                                                           \
        printf("%s: failed, result is 0x%x expect 0x%x\n", __FUNCTION__, d, index);             \
    }                                                                                           \
}

#define ROP3_HANDLERS(name, formula, index) \
    ROP3_HANDLERS_DEPTH(name, formula, index, 32)  \
    ROP3_HANDLERS_DEPTH(name, formula, index, 16)

ROP3_HANDLERS(DPSoon, ~(*pat | *src | *dest), 0x01);
ROP3_HANDLERS(DPSona, ~(*pat | *src) & *dest, 0x02);
ROP3_HANDLERS(SDPona, ~(*pat | *dest) & *src, 0x04);
ROP3_HANDLERS(PDSxnon, ~(~(*src ^ *dest) | *pat), 0x06);
ROP3_HANDLERS(PDSaon, ~((*src & *dest) | *pat), 0x07);
ROP3_HANDLERS(SDPnaa, ~*pat & *dest & *src, 0x08);
ROP3_HANDLERS(PDSxon, ~((*src ^ *dest) | *pat), 0x09);
ROP3_HANDLERS(PSDnaon, ~((~*dest & *src) | *pat), 0x0b);
ROP3_HANDLERS(PDSnaon, ~((~*src & *dest) | *pat), 0x0d);
ROP3_HANDLERS(PDSonon, ~(~(*src | *dest) | *pat), 0x0e);
ROP3_HANDLERS(PDSona, ~(*src | *dest) & *pat, 0x10);
ROP3_HANDLERS(SDPxnon, ~(~(*pat ^ *dest) | *src), 0x12);
ROP3_HANDLERS(SDPaon, ~((*pat & *dest) | *src), 0x13);
ROP3_HANDLERS(DPSxnon, ~(~(*pat ^ *src) | *dest), 0x14);
ROP3_HANDLERS(DPSaon, ~((*pat & *src) | *dest), 0x15);
ROP3_HANDLERS(PSDPSanaxx, (~(*pat & *src) & *dest) ^ *src ^ *pat, 0x16);
ROP3_HANDLERS(SSPxDSxaxn, ~(((*src ^ *dest) & (*src ^ *pat)) ^ *src), 0x17);
ROP3_HANDLERS(SPxPDxa, (*src ^ *pat) & (*pat ^ *dest), 0x18);
ROP3_HANDLERS(SDPSanaxn, ~((~(*pat & *src) & *dest) ^ *src), 0x19);
ROP3_HANDLERS(PDSPaox, ((*pat & *src) | *dest) ^ *pat, 0x1a);
ROP3_HANDLERS(SDPSxaxn, ~(((*pat ^ *src) & *dest) ^ *src), 0x1b);
ROP3_HANDLERS(PSDPaox, ((*pat & *dest) | *src) ^ *pat, 0x1c);
ROP3_HANDLERS(DSPDxaxn, ~(((*pat ^ *dest) & *src) ^ *dest), 0x1d);
ROP3_HANDLERS(PDSox, (*dest | *src) ^ *pat, 0x1e);
ROP3_HANDLERS(PDSoan, ~((*src | *dest) & *pat), 0x1f);
ROP3_HANDLERS(DPSnaa, ~*src & *pat & *dest, 0x20);
ROP3_HANDLERS(SDPxon, ~((*pat ^ *dest) | *src), 0x21);
ROP3_HANDLERS(SPDnaon, ~((~*dest & *pat) | *src), 0x23);
ROP3_HANDLERS(SPxDSxa, (*src ^ *pat) & (*dest ^ *src), 0x24);
ROP3_HANDLERS(PDSPanaxn, ~((~(*src & *pat) & *dest) ^ *pat), 0x25);
ROP3_HANDLERS(SDPSaox, ((*src & *pat) | *dest) ^ *src, 0x26);
ROP3_HANDLERS(SDPSxnox, (~(*src ^ *pat) | *dest) ^ *src, 0x27);
ROP3_HANDLERS(DPSxa, (*pat ^ *src) & *dest, 0x28);
ROP3_HANDLERS(PSDPSaoxxn, ~(((*src & *pat) | *dest) ^ *src ^ *pat), 0x29);
ROP3_HANDLERS(DPSana, ~(*src & *pat) & *dest, 0x2a);
ROP3_HANDLERS(SSPxPDxaxn, ~(((*pat ^ *dest) & (*src ^ *pat)) ^ *src), 0x2b);
ROP3_HANDLERS(SPDSoax, ((*src | *dest) & *pat) ^ *src, 0x2c);
ROP3_HANDLERS(PSDnox, (~*dest | *src) ^ *pat, 0x2d);
ROP3_HANDLERS(PSDPxox, ((*pat ^ *dest) | *src) ^ *pat, 0x2e);
ROP3_HANDLERS(PSDnoan, ~((~*dest | *src) & *pat), 0x2f);
ROP3_HANDLERS(SDPnaon, ~((~*pat & *dest) | *src), 0x31);
ROP3_HANDLERS(SDPSoox, (*src | *pat | *dest) ^ *src, 0x32);
ROP3_HANDLERS(SPDSaox, ((*src & *dest) | *pat) ^ *src, 0x34);
ROP3_HANDLERS(SPDSxnox, (~(*src ^ *dest) | *pat) ^ *src, 0x35);
ROP3_HANDLERS(SDPox, (*pat | *dest) ^ *src, 0x36);
ROP3_HANDLERS(SDPoan, ~((*pat | *dest) & *src), 0x37);
ROP3_HANDLERS(PSDPoax, ((*pat | *dest) & *src) ^ *pat, 0x38);
ROP3_HANDLERS(SPDnox, (~*dest | *pat) ^ *src, 0x39);
ROP3_HANDLERS(SPDSxox, ((*src ^ *dest) | *pat) ^ *src, 0x3a);
ROP3_HANDLERS(SPDnoan, ~((~*dest | *pat) & *src), 0x3b);
ROP3_HANDLERS(SPDSonox, (~(*src | *dest) | *pat) ^ *src, 0x3d);
ROP3_HANDLERS(SPDSnaox, ((~*src & *dest) | *pat) ^ *src, 0x3e);
ROP3_HANDLERS(PSDnaa, ~*dest & *src & *pat, 0x40);
ROP3_HANDLERS(DPSxon, ~((*src ^ *pat) | *dest), 0x41);
ROP3_HANDLERS(SDxPDxa, (*src ^ *dest) & (*pat ^ *dest), 0x42);
ROP3_HANDLERS(SPDSanaxn, ~((~(*src & *dest) & *pat) ^ *src), 0x43);
ROP3_HANDLERS(DPSnaon, ~((~*src & *pat) | *dest), 0x45);
ROP3_HANDLERS(DSPDaox, ((*dest & *pat) | *src) ^ *dest, 0x46);
ROP3_HANDLERS(PSDPxaxn, ~(((*pat ^ *dest) & *src) ^ *pat), 0x47);
ROP3_HANDLERS(SDPxa, (*pat ^ *dest) & *src, 0x48);
ROP3_HANDLERS(PDSPDaoxxn, ~(((*dest & *pat) | *src) ^ *dest ^ *pat), 0x49);
ROP3_HANDLERS(DPSDoax, ((*dest | *src) & *pat) ^ *dest, 0x4a);
ROP3_HANDLERS(PDSnox, (~*src | *dest) ^ *pat, 0x4b);
ROP3_HANDLERS(SDPana, ~(*pat & *dest) & *src, 0x4c);
ROP3_HANDLERS(SSPxDSxoxn, ~(((*src ^ *dest) | (*src ^ *pat)) ^ *src), 0x4d);
ROP3_HANDLERS(PDSPxox, ((*pat ^ *src) | *dest) ^ *pat, 0x4e);
ROP3_HANDLERS(PDSnoan, ~((~*src | *dest) & *pat), 0x4f);
ROP3_HANDLERS(DSPnaon, ~((~*pat & *src) | *dest), 0x51);
ROP3_HANDLERS(DPSDaox, ((*dest & *src) | *pat) ^ *dest, 0x52);
ROP3_HANDLERS(SPDSxaxn, ~(((*src ^ *dest) & *pat) ^ *src), 0x53);
ROP3_HANDLERS(DPSonon, ~(~(*src | *pat) | *dest), 0x54);
ROP3_HANDLERS(DPSox, (*src | *pat) ^ *dest, 0x56);
ROP3_HANDLERS(DPSoan, ~((*src | *pat) & *dest), 0x57);
ROP3_HANDLERS(PDSPoax, ((*pat | *src) & *dest) ^ *pat, 0x58);
ROP3_HANDLERS(DPSnox, (~*src | *pat) ^ *dest, 0x59);
ROP3_HANDLERS(DPSDonox, (~(*dest | *src) | *pat) ^ *dest, 0x5b);
ROP3_HANDLERS(DPSDxox, ((*dest ^ *src) | *pat) ^ *dest, 0x5c);
ROP3_HANDLERS(DPSnoan, ~((~*src | *pat) & *dest), 0x5d);
ROP3_HANDLERS(DPSDnaox, ((~*dest & *src) | *pat) ^ *dest, 0x5e);
ROP3_HANDLERS(PDSxa, (*src ^ *dest) & *pat, 0x60);
ROP3_HANDLERS(DSPDSaoxxn, ~(((*src & *dest) | *pat) ^ *src ^ *dest), 0x61);
ROP3_HANDLERS(DSPDoax, ((*dest | *pat) & *src) ^ *dest, 0x62);
ROP3_HANDLERS(SDPnox, (~*pat | *dest) ^ *src, 0x63);
ROP3_HANDLERS(SDPSoax, ((*src | *pat) & *dest) ^ *src, 0x64);
ROP3_HANDLERS(DSPnox, (~*pat | *src) ^ *dest, 0x65);
ROP3_HANDLERS(SDPSonox, (~(*src | *pat) | *dest) ^ *src, 0x67);
ROP3_HANDLERS(DSPDSonoxxn, ~((~(*src | *dest) | *pat) ^ *src ^ *dest), 0x68);
ROP3_HANDLERS(PDSxxn, ~(*src ^ *dest ^ *pat), 0x69);
ROP3_HANDLERS(DPSax, (*src & *pat) ^ *dest, 0x6a);
ROP3_HANDLERS(PSDPSoaxxn, ~(((*src | *pat) & *dest) ^ *src ^ *pat), 0x6b);
ROP3_HANDLERS(SDPax, (*pat & *dest) ^ *src, 0x6c);
ROP3_HANDLERS(PDSPDoaxxn, ~(((*dest | *pat) & *src) ^ *dest ^ *pat), 0x6d);
ROP3_HANDLERS(SDPSnoax, ((~*src | *pat) & *dest) ^ *src, 0x6e);
ROP3_HANDLERS(PDSxnan, ~(~(*src ^ *dest) & *pat), 0x6f);
ROP3_HANDLERS(PDSana, ~(*src & *dest) & *pat, 0x70);
ROP3_HANDLERS(SSDxPDxaxn, ~(((*dest ^ *pat) & (*src ^ *dest)) ^ *src), 0x71);
ROP3_HANDLERS(SDPSxox, ((*src ^ *pat) | *dest) ^ *src, 0x72);
ROP3_HANDLERS(SDPnoan, ~((~*pat | *dest) & *src), 0x73);
ROP3_HANDLERS(DSPDxox, ((*dest ^ *pat) | *src) ^ *dest, 0x74);
ROP3_HANDLERS(DSPnoan, ~((~*pat | *src) & *dest), 0x75);
ROP3_HANDLERS(SDPSnaox, ((~*src & *pat) | *dest) ^ *src, 0x76);
ROP3_HANDLERS(PDSax, (*src & *dest) ^ *pat, 0x78);
ROP3_HANDLERS(DSPDSoaxxn, ~(((*src | *dest) & *pat) ^ *src ^ *dest), 0x79);
ROP3_HANDLERS(DPSDnoax, ((~*dest | *src) & *pat) ^ *dest, 0x7a);
ROP3_HANDLERS(SDPxnan, ~(~(*pat ^ *dest) & *src), 0x7b);
ROP3_HANDLERS(SPDSnoax, ((~*src | *dest) & *pat) ^ *src, 0x7c);
ROP3_HANDLERS(DPSxnan, ~(~(*src ^ *pat) & *dest), 0x7d);
ROP3_HANDLERS(SPxDSxo, (*src ^ *dest) | (*pat ^ *src), 0x7e);
ROP3_HANDLERS(DPSaan, ~(*src & *pat & *dest), 0x7f);
ROP3_HANDLERS(DPSaa, *src & *pat & *dest, 0x80);
ROP3_HANDLERS(SPxDSxon, ~((*src ^ *dest) | (*pat ^ *src)), 0x81);
ROP3_HANDLERS(DPSxna, ~(*src ^ *pat) & *dest, 0x82);
ROP3_HANDLERS(SPDSnoaxn, ~(((~*src | *dest) & *pat) ^ *src), 0x83);
ROP3_HANDLERS(SDPxna, ~(*pat ^ *dest) & *src, 0x84);
ROP3_HANDLERS(PDSPnoaxn, ~(((~*pat | *src) & *dest) ^ *pat), 0x85);
ROP3_HANDLERS(DSPDSoaxx, ((*src | *dest) & *pat) ^ *src ^ *dest, 0x86);
ROP3_HANDLERS(PDSaxn, ~((*src & *dest) ^ *pat), 0x87);
ROP3_HANDLERS(SDPSnaoxn, ~(((~*src & *pat) | *dest) ^ *src), 0x89);
ROP3_HANDLERS(DSPnoa, (~*pat | *src) & *dest, 0x8a);
ROP3_HANDLERS(DSPDxoxn, ~(((*dest ^ *pat) | *src) ^ *dest), 0x8b);
ROP3_HANDLERS(SDPnoa, (~*pat | *dest) & *src, 0x8c);
ROP3_HANDLERS(SDPSxoxn, ~(((*src ^ *pat) | *dest) ^ *src), 0x8d);
ROP3_HANDLERS(SSDxPDxax, ((*dest ^ *pat) & (*dest ^ *src)) ^ *src, 0x8e);
ROP3_HANDLERS(PDSanan, ~(~(*src & *dest) & *pat), 0x8f);
ROP3_HANDLERS(PDSxna, ~(*src ^ *dest) & *pat, 0x90);
ROP3_HANDLERS(SDPSnoaxn, ~(((~*src | *pat) & *dest) ^ *src), 0x91);
ROP3_HANDLERS(DPSDPoaxx, ((*pat | *dest) & *src) ^ *pat ^ *dest, 0x92);
ROP3_HANDLERS(SPDaxn, ~((*dest & *pat) ^ *src), 0x93);
ROP3_HANDLERS(PSDPSoaxx, ((*src | *pat) & *dest) ^ *src ^ *pat, 0x94);
ROP3_HANDLERS(DPSaxn, ~((*src & *pat) ^ *dest), 0x95);
ROP3_HANDLERS(DPSxx, *src ^ *pat ^ *dest, 0x96);
ROP3_HANDLERS(PSDPSonoxx, (~(*src | *pat) | *dest) ^ *src ^ *pat, 0x97);
ROP3_HANDLERS(SDPSonoxn, ~((~(*src | *pat) | *dest) ^ *src), 0x98);
ROP3_HANDLERS(DPSnax, (~*src & *pat) ^ *dest, 0x9a);
ROP3_HANDLERS(SDPSoaxn, ~(((*src | *pat) & *dest) ^ *src), 0x9b);
ROP3_HANDLERS(SPDnax, (~*dest & *pat) ^ *src, 0x9c);
ROP3_HANDLERS(DSPDoaxn, ~(((*dest | *pat) & *src) ^ *dest), 0x9d);
ROP3_HANDLERS(DSPDSaoxx, ((*src & *dest) | *pat) ^ *src ^ *dest, 0x9e);
ROP3_HANDLERS(PDSxan, ~((*src ^ *dest) & *pat), 0x9f);
ROP3_HANDLERS(PDSPnaoxn, ~(((~*pat & *src) | *dest) ^ *pat), 0xa1);
ROP3_HANDLERS(DPSnoa, (~*src | *pat) & *dest, 0xa2);
ROP3_HANDLERS(DPSDxoxn, ~(((*dest ^ *src) | *pat) ^ *dest), 0xa3);
ROP3_HANDLERS(PDSPonoxn, ~((~(*pat | *src) | *dest) ^ *pat), 0xa4);
ROP3_HANDLERS(DSPnax, (~*pat & *src) ^ *dest, 0xa6);
ROP3_HANDLERS(PDSPoaxn, ~(((*pat | *src) & *dest) ^ *pat), 0xa7);
ROP3_HANDLERS(DPSoa, (*src | *pat) & *dest, 0xa8);
ROP3_HANDLERS(DPSoxn, ~((*src | *pat) ^ *dest), 0xa9);
ROP3_HANDLERS(DPSono, ~(*src | *pat) | *dest, 0xab);
ROP3_HANDLERS(SPDSxax, ((*src ^ *dest) & *pat) ^ *src, 0xac);
ROP3_HANDLERS(DPSDaoxn, ~(((*dest & *src) | *pat) ^ *dest), 0xad);
ROP3_HANDLERS(DSPnao, (~*pat & *src) | *dest, 0xae);
ROP3_HANDLERS(PDSnoa, (~*src | *dest) & *pat, 0xb0);
ROP3_HANDLERS(PDSPxoxn, ~(((*pat ^ *src) | *dest) ^ *pat), 0xb1);
ROP3_HANDLERS(SSPxDSxox, ((*src ^ *dest) | (*pat ^ *src)) ^ *src, 0xb2);
ROP3_HANDLERS(SDPanan, ~(~(*pat & *dest) & *src), 0xb3);
ROP3_HANDLERS(PSDnax, (~*dest & *src) ^ *pat, 0xb4);
ROP3_HANDLERS(DPSDoaxn, ~(((*dest | *src) & *pat) ^ *dest), 0xb5);
ROP3_HANDLERS(DPSDPaoxx, ((*pat & *dest) | *src) ^ *pat ^ *dest, 0xb6);
ROP3_HANDLERS(SDPxan, ~((*pat ^ *dest) & *src), 0xb7);
ROP3_HANDLERS(PSDPxax, ((*dest ^ *pat) & *src) ^ *pat, 0xb8);
ROP3_HANDLERS(DSPDaoxn, ~(((*dest & *pat) | *src) ^ *dest), 0xb9);
ROP3_HANDLERS(DPSnao, (~*src & *pat) | *dest, 0xba);
ROP3_HANDLERS(SPDSanax, (~(*src & *dest) & *pat) ^ *src, 0xbc);
ROP3_HANDLERS(SDxPDxan, ~((*dest ^ *pat) & (*dest ^ *src)), 0xbd);
ROP3_HANDLERS(DPSxo, (*src ^ *pat) | *dest, 0xbe);
ROP3_HANDLERS(DPSano, ~(*src & *pat) | *dest, 0xbf);
ROP3_HANDLERS(SPDSnaoxn, ~(((~*src & *dest) | *pat) ^ *src), 0xc1);
ROP3_HANDLERS(SPDSonoxn, ~((~(*src | *dest) | *pat) ^ *src), 0xc2);
ROP3_HANDLERS(SPDnoa, (~*dest | *pat) & *src, 0xc4);
ROP3_HANDLERS(SPDSxoxn, ~(((*src ^ *dest) | *pat) ^ *src), 0xc5);
ROP3_HANDLERS(SDPnax, (~*pat & *dest) ^ *src, 0xc6);
ROP3_HANDLERS(PSDPoaxn, ~(((*pat | *dest) & *src) ^ *pat), 0xc7);
ROP3_HANDLERS(SDPoa, (*pat | *dest) & *src, 0xc8);
ROP3_HANDLERS(SPDoxn, ~((*dest | *pat) ^ *src), 0xc9);
ROP3_HANDLERS(DPSDxax, ((*dest ^ *src) & *pat) ^ *dest, 0xca);
ROP3_HANDLERS(SPDSaoxn, ~(((*src & *dest) | *pat) ^ *src), 0xcb);
ROP3_HANDLERS(SDPono, ~(*pat | *dest) | *src, 0xcd);
ROP3_HANDLERS(SDPnao, (~*pat & *dest) | *src, 0xce);
ROP3_HANDLERS(PSDnoa, (~*dest | *src) & *pat, 0xd0);
ROP3_HANDLERS(PSDPxoxn, ~(((*pat ^ *dest) | *src) ^ *pat), 0xd1);
ROP3_HANDLERS(PDSnax, (~*src & *dest) ^ *pat, 0xd2);
ROP3_HANDLERS(SPDSoaxn, ~(((*src | *dest) & *pat) ^ *src), 0xd3);
ROP3_HANDLERS(SSPxPDxax, ((*dest ^ *pat) & (*pat ^ *src)) ^ *src, 0xd4);
ROP3_HANDLERS(DPSanan, ~(~(*src & *pat) & *dest), 0xd5);
ROP3_HANDLERS(PSDPSaoxx, ((*src & *pat) | *dest) ^ *src ^ *pat, 0xd6);
ROP3_HANDLERS(DPSxan, ~((*src ^ *pat) & *dest), 0xd7);
ROP3_HANDLERS(PDSPxax, ((*pat ^ *src) & *dest) ^ *pat, 0xd8);
ROP3_HANDLERS(SDPSaoxn, ~(((*src & *pat) | *dest) ^ *src), 0xd9);
ROP3_HANDLERS(DPSDanax, (~(*dest & *src) & *pat) ^ *dest, 0xda);
ROP3_HANDLERS(SPxDSxan, ~((*src ^ *dest) & (*pat ^ *src)), 0xdb);
ROP3_HANDLERS(SPDnao, (~*dest & *pat) | *src, 0xdc);
ROP3_HANDLERS(SDPxo, (*pat ^ *dest) | *src, 0xde);
ROP3_HANDLERS(SDPano, ~(*pat & *dest) | *src, 0xdf);
ROP3_HANDLERS(PDSoa, (*src | *dest) & *pat, 0xe0);
ROP3_HANDLERS(PDSoxn, ~((*src | *dest) ^ *pat), 0xe1);
ROP3_HANDLERS(DSPDxax, ((*dest ^ *pat) & *src) ^ *dest, 0xe2);
ROP3_HANDLERS(PSDPaoxn, ~(((*pat & *dest) | *src) ^ *pat), 0xe3);
ROP3_HANDLERS(SDPSxax, ((*src ^ *pat) & *dest) ^ *src, 0xe4);
ROP3_HANDLERS(PDSPaoxn, ~(((*pat & *src) | *dest) ^ *pat), 0xe5);
ROP3_HANDLERS(SDPSanax, (~(*src & *pat) & *dest) ^ *src, 0xe6);
ROP3_HANDLERS(SPxPDxan, ~((*dest ^ *pat) & (*pat ^ *src)), 0xe7);
ROP3_HANDLERS(SSPxDSxax, ((*src ^ *dest) & (*pat ^ *src)) ^ *src, 0xe8);
ROP3_HANDLERS(DSPDSanaxxn, ~((~(*src & *dest) & *pat) ^ *src ^ *dest), 0xe9);
ROP3_HANDLERS(DPSao, (*src & *pat) | *dest, 0xea);
ROP3_HANDLERS(DPSxno, ~(*src ^ *pat) | *dest, 0xeb);
ROP3_HANDLERS(SDPao, (*pat & *dest) | *src, 0xec);
ROP3_HANDLERS(SDPxno, ~(*pat ^ *dest) | *src, 0xed);
ROP3_HANDLERS(SDPnoo, ~*pat | *dest | *src, 0xef);
ROP3_HANDLERS(PDSono, ~(*src | *dest) | *pat, 0xf1);
ROP3_HANDLERS(PDSnao, (~*src & *dest) | *pat, 0xf2);
ROP3_HANDLERS(PSDnao, (~*dest & *src) | *pat, 0xf4);
ROP3_HANDLERS(PDSxo, (*src ^ *dest) | *pat, 0xf6);
ROP3_HANDLERS(PDSano, ~(*src & *dest) | *pat, 0xf7);
ROP3_HANDLERS(PDSao, (*src & *dest) | *pat, 0xf8);
ROP3_HANDLERS(PDSxno, ~(*src ^ *dest) | *pat, 0xf9);
ROP3_HANDLERS(DPSnoo, ~*src | *pat | *dest, 0xfb);
ROP3_HANDLERS(PSDnoo, ~*dest | *src | *pat, 0xfd);
ROP3_HANDLERS(DPSoo, *src | *pat | *dest, 0xfe);


#define ROP3_FILL_HANDLERS(op, index)                       \
    rop3_with_pattern_handlers_32[index] = rop3_handle_p32_##op; \
    rop3_with_pattern_handlers_16[index] = rop3_handle_p16_##op; \
    rop3_with_color_handlers_32[index] = rop3_handle_c32_##op;   \
    rop3_with_color_handlers_16[index] = rop3_handle_c16_##op;   \
    rop3_test_handlers_32[index] = rop3_test32_##op;             \
    rop3_test_handlers_16[index] = rop3_test16_##op;

SPICE_CONSTRUCTOR_FUNC(rop3_global_init)
{
    int i;

    for (i = 0; i < ROP3_NUM_OPS; i++) {
        rop3_with_pattern_handlers_32[i] = default_rop3_with_pattern_handler;
        rop3_with_pattern_handlers_16[i] = default_rop3_with_pattern_handler;
        rop3_with_color_handlers_32[i] = default_rop3_withe_color_handler;
        rop3_with_color_handlers_16[i] = default_rop3_withe_color_handler;
        rop3_test_handlers_32[i] = default_rop3_test_handler;
        rop3_test_handlers_16[i] = default_rop3_test_handler;
    }

    ROP3_FILL_HANDLERS(DPSoon, 0x01);
    ROP3_FILL_HANDLERS(DPSona, 0x02);
    ROP3_FILL_HANDLERS(SDPona, 0x04);
    ROP3_FILL_HANDLERS(PDSxnon, 0x06);
    ROP3_FILL_HANDLERS(PDSaon, 0x07);
    ROP3_FILL_HANDLERS(SDPnaa, 0x08);
    ROP3_FILL_HANDLERS(PDSxon, 0x09);
    ROP3_FILL_HANDLERS(PSDnaon, 0x0b);
    ROP3_FILL_HANDLERS(PDSnaon, 0x0d);
    ROP3_FILL_HANDLERS(PDSonon, 0x0e);
    ROP3_FILL_HANDLERS(PDSona, 0x10);
    ROP3_FILL_HANDLERS(SDPxnon, 0x12);
    ROP3_FILL_HANDLERS(SDPaon, 0x13);
    ROP3_FILL_HANDLERS(DPSxnon, 0x14);
    ROP3_FILL_HANDLERS(DPSaon, 0x15);
    ROP3_FILL_HANDLERS(PSDPSanaxx, 0x16);
    ROP3_FILL_HANDLERS(SSPxDSxaxn, 0x17);
    ROP3_FILL_HANDLERS(SPxPDxa, 0x18);
    ROP3_FILL_HANDLERS(SDPSanaxn, 0x19);
    ROP3_FILL_HANDLERS(PDSPaox, 0x1a);
    ROP3_FILL_HANDLERS(SDPSxaxn, 0x1b);
    ROP3_FILL_HANDLERS(PSDPaox, 0x1c);
    ROP3_FILL_HANDLERS(DSPDxaxn, 0x1d);
    ROP3_FILL_HANDLERS(PDSox, 0x1e);
    ROP3_FILL_HANDLERS(PDSoan, 0x1f);
    ROP3_FILL_HANDLERS(DPSnaa, 0x20);
    ROP3_FILL_HANDLERS(SDPxon, 0x21);
    ROP3_FILL_HANDLERS(SPDnaon, 0x23);
    ROP3_FILL_HANDLERS(SPxDSxa, 0x24);
    ROP3_FILL_HANDLERS(PDSPanaxn, 0x25);
    ROP3_FILL_HANDLERS(SDPSaox, 0x26);
    ROP3_FILL_HANDLERS(SDPSxnox, 0x27);
    ROP3_FILL_HANDLERS(DPSxa, 0x28);
    ROP3_FILL_HANDLERS(PSDPSaoxxn, 0x29);
    ROP3_FILL_HANDLERS(DPSana, 0x2a);
    ROP3_FILL_HANDLERS(SSPxPDxaxn, 0x2b);
    ROP3_FILL_HANDLERS(SPDSoax, 0x2c);
    ROP3_FILL_HANDLERS(PSDnox, 0x2d);
    ROP3_FILL_HANDLERS(PSDPxox, 0x2e);
    ROP3_FILL_HANDLERS(PSDnoan, 0x2f);
    ROP3_FILL_HANDLERS(SDPnaon, 0x31);
    ROP3_FILL_HANDLERS(SDPSoox, 0x32);
    ROP3_FILL_HANDLERS(SPDSaox, 0x34);
    ROP3_FILL_HANDLERS(SPDSxnox, 0x35);
    ROP3_FILL_HANDLERS(SDPox, 0x36);
    ROP3_FILL_HANDLERS(SDPoan, 0x37);
    ROP3_FILL_HANDLERS(PSDPoax, 0x38);
    ROP3_FILL_HANDLERS(SPDnox, 0x39);
    ROP3_FILL_HANDLERS(SPDSxox, 0x3a);
    ROP3_FILL_HANDLERS(SPDnoan, 0x3b);
    ROP3_FILL_HANDLERS(SPDSonox, 0x3d);
    ROP3_FILL_HANDLERS(SPDSnaox, 0x3e);
    ROP3_FILL_HANDLERS(PSDnaa, 0x40);
    ROP3_FILL_HANDLERS(DPSxon, 0x41);
    ROP3_FILL_HANDLERS(SDxPDxa, 0x42);
    ROP3_FILL_HANDLERS(SPDSanaxn, 0x43);
    ROP3_FILL_HANDLERS(DPSnaon, 0x45);
    ROP3_FILL_HANDLERS(DSPDaox, 0x46);
    ROP3_FILL_HANDLERS(PSDPxaxn, 0x47);
    ROP3_FILL_HANDLERS(SDPxa, 0x48);
    ROP3_FILL_HANDLERS(PDSPDaoxxn, 0x49);
    ROP3_FILL_HANDLERS(DPSDoax, 0x4a);
    ROP3_FILL_HANDLERS(PDSnox, 0x4b);
    ROP3_FILL_HANDLERS(SDPana, 0x4c);
    ROP3_FILL_HANDLERS(SSPxDSxoxn, 0x4d);
    ROP3_FILL_HANDLERS(PDSPxox, 0x4e);
    ROP3_FILL_HANDLERS(PDSnoan, 0x4f);
    ROP3_FILL_HANDLERS(DSPnaon, 0x51);
    ROP3_FILL_HANDLERS(DPSDaox, 0x52);
    ROP3_FILL_HANDLERS(SPDSxaxn, 0x53);
    ROP3_FILL_HANDLERS(DPSonon, 0x54);
    ROP3_FILL_HANDLERS(DPSox, 0x56);
    ROP3_FILL_HANDLERS(DPSoan, 0x57);
    ROP3_FILL_HANDLERS(PDSPoax, 0x58);
    ROP3_FILL_HANDLERS(DPSnox, 0x59);
    ROP3_FILL_HANDLERS(DPSDonox, 0x5b);
    ROP3_FILL_HANDLERS(DPSDxox, 0x5c);
    ROP3_FILL_HANDLERS(DPSnoan, 0x5d);
    ROP3_FILL_HANDLERS(DPSDnaox, 0x5e);
    ROP3_FILL_HANDLERS(PDSxa, 0x60);
    ROP3_FILL_HANDLERS(DSPDSaoxxn, 0x61);
    ROP3_FILL_HANDLERS(DSPDoax, 0x62);
    ROP3_FILL_HANDLERS(SDPnox, 0x63);
    ROP3_FILL_HANDLERS(SDPSoax, 0x64);
    ROP3_FILL_HANDLERS(DSPnox, 0x65);
    ROP3_FILL_HANDLERS(SDPSonox, 0x67);
    ROP3_FILL_HANDLERS(DSPDSonoxxn, 0x68);
    ROP3_FILL_HANDLERS(PDSxxn, 0x69);
    ROP3_FILL_HANDLERS(DPSax, 0x6a);
    ROP3_FILL_HANDLERS(PSDPSoaxxn, 0x6b);
    ROP3_FILL_HANDLERS(SDPax, 0x6c);
    ROP3_FILL_HANDLERS(PDSPDoaxxn, 0x6d);
    ROP3_FILL_HANDLERS(SDPSnoax, 0x6e);
    ROP3_FILL_HANDLERS(PDSxnan, 0x6f);
    ROP3_FILL_HANDLERS(PDSana, 0x70);
    ROP3_FILL_HANDLERS(SSDxPDxaxn, 0x71);
    ROP3_FILL_HANDLERS(SDPSxox, 0x72);
    ROP3_FILL_HANDLERS(SDPnoan, 0x73);
    ROP3_FILL_HANDLERS(DSPDxox, 0x74);
    ROP3_FILL_HANDLERS(DSPnoan, 0x75);
    ROP3_FILL_HANDLERS(SDPSnaox, 0x76);
    ROP3_FILL_HANDLERS(PDSax, 0x78);
    ROP3_FILL_HANDLERS(DSPDSoaxxn, 0x79);
    ROP3_FILL_HANDLERS(DPSDnoax, 0x7a);
    ROP3_FILL_HANDLERS(SDPxnan, 0x7b);
    ROP3_FILL_HANDLERS(SPDSnoax, 0x7c);
    ROP3_FILL_HANDLERS(DPSxnan, 0x7d);
    ROP3_FILL_HANDLERS(SPxDSxo, 0x7e);
    ROP3_FILL_HANDLERS(DPSaan, 0x7f);
    ROP3_FILL_HANDLERS(DPSaa, 0x80);
    ROP3_FILL_HANDLERS(SPxDSxon, 0x81);
    ROP3_FILL_HANDLERS(DPSxna, 0x82);
    ROP3_FILL_HANDLERS(SPDSnoaxn, 0x83);
    ROP3_FILL_HANDLERS(SDPxna, 0x84);
    ROP3_FILL_HANDLERS(PDSPnoaxn, 0x85);
    ROP3_FILL_HANDLERS(DSPDSoaxx, 0x86);
    ROP3_FILL_HANDLERS(PDSaxn, 0x87);
    ROP3_FILL_HANDLERS(SDPSnaoxn, 0x89);
    ROP3_FILL_HANDLERS(DSPnoa, 0x8a);
    ROP3_FILL_HANDLERS(DSPDxoxn, 0x8b);
    ROP3_FILL_HANDLERS(SDPnoa, 0x8c);
    ROP3_FILL_HANDLERS(SDPSxoxn, 0x8d);
    ROP3_FILL_HANDLERS(SSDxPDxax, 0x8e);
    ROP3_FILL_HANDLERS(PDSanan, 0x8f);
    ROP3_FILL_HANDLERS(PDSxna, 0x90);
    ROP3_FILL_HANDLERS(SDPSnoaxn, 0x91);
    ROP3_FILL_HANDLERS(DPSDPoaxx, 0x92);
    ROP3_FILL_HANDLERS(SPDaxn, 0x93);
    ROP3_FILL_HANDLERS(PSDPSoaxx, 0x94);
    ROP3_FILL_HANDLERS(DPSaxn, 0x95);
    ROP3_FILL_HANDLERS(DPSxx, 0x96);
    ROP3_FILL_HANDLERS(PSDPSonoxx, 0x97);
    ROP3_FILL_HANDLERS(SDPSonoxn, 0x98);
    ROP3_FILL_HANDLERS(DPSnax, 0x9a);
    ROP3_FILL_HANDLERS(SDPSoaxn, 0x9b);
    ROP3_FILL_HANDLERS(SPDnax, 0x9c);
    ROP3_FILL_HANDLERS(DSPDoaxn, 0x9d);
    ROP3_FILL_HANDLERS(DSPDSaoxx, 0x9e);
    ROP3_FILL_HANDLERS(PDSxan, 0x9f);
    ROP3_FILL_HANDLERS(PDSPnaoxn, 0xa1);
    ROP3_FILL_HANDLERS(DPSnoa, 0xa2);
    ROP3_FILL_HANDLERS(DPSDxoxn, 0xa3);
    ROP3_FILL_HANDLERS(PDSPonoxn, 0xa4);
    ROP3_FILL_HANDLERS(DSPnax, 0xa6);
    ROP3_FILL_HANDLERS(PDSPoaxn, 0xa7);
    ROP3_FILL_HANDLERS(DPSoa, 0xa8);
    ROP3_FILL_HANDLERS(DPSoxn, 0xa9);
    ROP3_FILL_HANDLERS(DPSono, 0xab);
    ROP3_FILL_HANDLERS(SPDSxax, 0xac);
    ROP3_FILL_HANDLERS(DPSDaoxn, 0xad);
    ROP3_FILL_HANDLERS(DSPnao, 0xae);
    ROP3_FILL_HANDLERS(PDSnoa, 0xb0);
    ROP3_FILL_HANDLERS(PDSPxoxn, 0xb1);
    ROP3_FILL_HANDLERS(SSPxDSxox, 0xb2);
    ROP3_FILL_HANDLERS(SDPanan, 0xb3);
    ROP3_FILL_HANDLERS(PSDnax, 0xb4);
    ROP3_FILL_HANDLERS(DPSDoaxn, 0xb5);
    ROP3_FILL_HANDLERS(DPSDPaoxx, 0xb6);
    ROP3_FILL_HANDLERS(SDPxan, 0xb7);
    ROP3_FILL_HANDLERS(PSDPxax, 0xb8);
    ROP3_FILL_HANDLERS(DSPDaoxn, 0xb9);
    ROP3_FILL_HANDLERS(DPSnao, 0xba);
    ROP3_FILL_HANDLERS(SPDSanax, 0xbc);
    ROP3_FILL_HANDLERS(SDxPDxan, 0xbd);
    ROP3_FILL_HANDLERS(DPSxo, 0xbe);
    ROP3_FILL_HANDLERS(DPSano, 0xbf);
    ROP3_FILL_HANDLERS(SPDSnaoxn, 0xc1);
    ROP3_FILL_HANDLERS(SPDSonoxn, 0xc2);
    ROP3_FILL_HANDLERS(SPDnoa, 0xc4);
    ROP3_FILL_HANDLERS(SPDSxoxn, 0xc5);
    ROP3_FILL_HANDLERS(SDPnax, 0xc6);
    ROP3_FILL_HANDLERS(PSDPoaxn, 0xc7);
    ROP3_FILL_HANDLERS(SDPoa, 0xc8);
    ROP3_FILL_HANDLERS(SPDoxn, 0xc9);
    ROP3_FILL_HANDLERS(DPSDxax, 0xca);
    ROP3_FILL_HANDLERS(SPDSaoxn, 0xcb);
    ROP3_FILL_HANDLERS(SDPono, 0xcd);
    ROP3_FILL_HANDLERS(SDPnao, 0xce);
    ROP3_FILL_HANDLERS(PSDnoa, 0xd0);
    ROP3_FILL_HANDLERS(PSDPxoxn, 0xd1);
    ROP3_FILL_HANDLERS(PDSnax, 0xd2);
    ROP3_FILL_HANDLERS(SPDSoaxn, 0xd3);
    ROP3_FILL_HANDLERS(SSPxPDxax, 0xd4);
    ROP3_FILL_HANDLERS(DPSanan, 0xd5);
    ROP3_FILL_HANDLERS(PSDPSaoxx, 0xd6);
    ROP3_FILL_HANDLERS(DPSxan, 0xd7);
    ROP3_FILL_HANDLERS(PDSPxax, 0xd8);
    ROP3_FILL_HANDLERS(SDPSaoxn, 0xd9);
    ROP3_FILL_HANDLERS(DPSDanax, 0xda);
    ROP3_FILL_HANDLERS(SPxDSxan, 0xdb);
    ROP3_FILL_HANDLERS(SPDnao, 0xdc);
    ROP3_FILL_HANDLERS(SDPxo, 0xde);
    ROP3_FILL_HANDLERS(SDPano, 0xdf);
    ROP3_FILL_HANDLERS(PDSoa, 0xe0);
    ROP3_FILL_HANDLERS(PDSoxn, 0xe1);
    ROP3_FILL_HANDLERS(DSPDxax, 0xe2);
    ROP3_FILL_HANDLERS(PSDPaoxn, 0xe3);
    ROP3_FILL_HANDLERS(SDPSxax, 0xe4);
    ROP3_FILL_HANDLERS(PDSPaoxn, 0xe5);
    ROP3_FILL_HANDLERS(SDPSanax, 0xe6);
    ROP3_FILL_HANDLERS(SPxPDxan, 0xe7);
    ROP3_FILL_HANDLERS(SSPxDSxax, 0xe8);
    ROP3_FILL_HANDLERS(DSPDSanaxxn, 0xe9);
    ROP3_FILL_HANDLERS(DPSao, 0xea);
    ROP3_FILL_HANDLERS(DPSxno, 0xeb);
    ROP3_FILL_HANDLERS(SDPao, 0xec);
    ROP3_FILL_HANDLERS(SDPxno, 0xed);
    ROP3_FILL_HANDLERS(SDPnoo, 0xef);
    ROP3_FILL_HANDLERS(PDSono, 0xf1);
    ROP3_FILL_HANDLERS(PDSnao, 0xf2);
    ROP3_FILL_HANDLERS(PSDnao, 0xf4);
    ROP3_FILL_HANDLERS(PDSxo, 0xf6);
    ROP3_FILL_HANDLERS(PDSano, 0xf7);
    ROP3_FILL_HANDLERS(PDSao, 0xf8);
    ROP3_FILL_HANDLERS(PDSxno, 0xf9);
    ROP3_FILL_HANDLERS(DPSnoo, 0xfb);
    ROP3_FILL_HANDLERS(PSDnoo, 0xfd);
    ROP3_FILL_HANDLERS(DPSoo, 0xfe);

    for (i = 0; i < ROP3_NUM_OPS; i++) {
        rop3_test_handlers_32[i]();
        rop3_test_handlers_16[i]();
    }
}

void do_rop3_with_pattern(uint8_t rop3, pixman_image_t *d, pixman_image_t *s, SpicePoint *src_pos,
                          pixman_image_t *p, SpicePoint *pat_pos)
{
    int bpp;

    bpp = spice_pixman_image_get_bpp(d);
    spice_assert(bpp == spice_pixman_image_get_bpp(s));
    spice_assert(bpp == spice_pixman_image_get_bpp(p));

    if (bpp == 32) {
        rop3_with_pattern_handlers_32[rop3](d, s, src_pos, p, pat_pos);
    } else {
        rop3_with_pattern_handlers_16[rop3](d, s, src_pos, p, pat_pos);
    }
}

void do_rop3_with_color(uint8_t rop3, pixman_image_t *d, pixman_image_t *s, SpicePoint *src_pos,
                        uint32_t rgb)
{
    int bpp;

    bpp = spice_pixman_image_get_bpp(d);
    spice_assert(bpp == spice_pixman_image_get_bpp(s));

    if (bpp == 32) {
        rop3_with_color_handlers_32[rop3](d, s, src_pos, rgb);
    } else {
        rop3_with_color_handlers_16[rop3](d, s, src_pos, rgb);
    }
}

```

`devices/display/qxl/canvas/rop3.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_ROP3
#define H_SPICE_COMMON_ROP3

#include <stdint.h>
#include <spice/macros.h>

#include "draw.h"
#include "pixman_utils.h"

SPICE_BEGIN_DECLS

void do_rop3_with_pattern(uint8_t rop3, pixman_image_t *d, pixman_image_t *s, SpicePoint *src_pos,
                          pixman_image_t *p, SpicePoint *pat_pos);
void do_rop3_with_color(uint8_t rop3, pixman_image_t *d, pixman_image_t *s, SpicePoint *src_pos,
                        uint32_t rgb);

SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/sw_canvas.c`:

```c
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/
#ifdef __MINGW32__
#undef HAVE_STDLIB_H
#endif
#include "config.h"

#include <math.h>
#include "sw_canvas.h"
#include "canvas_base.c"
#include "rect.h"
#include "region.h"
#include "pixman_utils.h"

typedef struct SwCanvas SwCanvas;

struct SwCanvas {
    CanvasBase base;
    uint32_t *private_data;
    int private_data_size;
    pixman_image_t *image;
};

static pixman_image_t *canvas_get_pixman_brush(SwCanvas *canvas,
                                               SpiceBrush *brush)
{
    switch (brush->type) {
    case SPICE_BRUSH_TYPE_SOLID: {
        uint32_t color = brush->u.color;
        pixman_color_t c;

        c.blue = ((color & canvas->base.color_mask) * 0xffff) / canvas->base.color_mask;
        color >>= canvas->base.color_shift;
        c.green = ((color & canvas->base.color_mask) * 0xffff) / canvas->base.color_mask;
        color >>= canvas->base.color_shift;
        c.red = ((color & canvas->base.color_mask) * 0xffff) / canvas->base.color_mask;
        c.alpha = 0xffff;

        return pixman_image_create_solid_fill(&c);
    }
    case SPICE_BRUSH_TYPE_PATTERN: {
        SwCanvas *surface_canvas;
        pixman_image_t* surface;
        pixman_transform_t t;

        surface_canvas = (SwCanvas *)canvas_get_surface(&canvas->base, brush->u.pattern.pat);
        if (surface_canvas) {
            surface = surface_canvas->image;
            surface = pixman_image_ref(surface);
        } else {
            surface = canvas_get_image(&canvas->base, brush->u.pattern.pat, FALSE);
        }
        pixman_transform_init_translate(&t,
                                        pixman_int_to_fixed(-brush->u.pattern.pos.x),
                                        pixman_int_to_fixed(-brush->u.pattern.pos.y));
        pixman_image_set_transform(surface, &t);
        pixman_image_set_repeat(surface, PIXMAN_REPEAT_NORMAL);
        return surface;
    }
    case SPICE_BRUSH_TYPE_NONE:
        return NULL;
    default:
        spice_warn_if_reached();
        return NULL;
    }
    return NULL;
}

static pixman_image_t *get_image(SpiceCanvas *canvas, int force_opaque)
{
    SwCanvas *sw_canvas = (SwCanvas *)canvas;
    pixman_format_code_t format;

    spice_pixman_image_get_format(sw_canvas->image, &format);
    if (force_opaque && PIXMAN_FORMAT_A (format) != 0) {
        uint32_t *data;
        int stride;
        int width, height;

        /* Remove alpha bits from format */
        format = (pixman_format_code_t)(((uint32_t)format) & ~(0xf << 12));
        data = pixman_image_get_data(sw_canvas->image);
        stride = pixman_image_get_stride(sw_canvas->image);
        width = pixman_image_get_width(sw_canvas->image);
        height = pixman_image_get_height(sw_canvas->image);
        return pixman_image_create_bits(format, width, height, data, stride);
    } else {
        pixman_image_ref(sw_canvas->image);
    }

    return sw_canvas->image;
}

static void copy_region(SpiceCanvas *spice_canvas,
                        pixman_region32_t *dest_region,
                        int dx, int dy)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_box32_t *dest_rects;
    int n_rects;
    int i, j, end_line;

    dest_rects = pixman_region32_rectangles(dest_region, &n_rects);

    if (dy > 0) {
        if (dx >= 0) {
            /* south-east: copy x and y in reverse order */
            for (i = n_rects - 1; i >= 0; i--) {
                spice_pixman_copy_rect(canvas->image,
                                       dest_rects[i].x1 - dx, dest_rects[i].y1 - dy,
                                       dest_rects[i].x2 - dest_rects[i].x1,
                                       dest_rects[i].y2 - dest_rects[i].y1,
                                       dest_rects[i].x1, dest_rects[i].y1);
            }
        } else {
            /* south-west: Copy y in reverse order, but x in forward order */
            i = n_rects - 1;

            while (i >= 0) {
                /* Copy all rects with same y in forward order */
                for (end_line = i - 1;
                     end_line >= 0 && dest_rects[end_line].y1 == dest_rects[i].y1;
                     end_line--) {
                }
                for (j = end_line + 1; j <= i; j++) {
                    spice_pixman_copy_rect(canvas->image,
                                           dest_rects[j].x1 - dx, dest_rects[j].y1 - dy,
                                           dest_rects[j].x2 - dest_rects[j].x1,
                                           dest_rects[j].y2 - dest_rects[j].y1,
                                           dest_rects[j].x1, dest_rects[j].y1);
                }
                i = end_line;
            }
        }
    } else {
        if (dx > 0) {
            /* north-east: copy y in forward order, but x in reverse order */
            i = 0;

            while (i < n_rects) {
                /* Copy all rects with same y in reverse order */
                for (end_line = i;
                     end_line < n_rects && dest_rects[end_line].y1 == dest_rects[i].y1;
                     end_line++) {
                }
                for (j = end_line - 1; j >= i; j--) {
                    spice_pixman_copy_rect(canvas->image,
                                           dest_rects[j].x1 - dx, dest_rects[j].y1 - dy,
                                           dest_rects[j].x2 - dest_rects[j].x1,
                                           dest_rects[j].y2 - dest_rects[j].y1,
                                           dest_rects[j].x1, dest_rects[j].y1);
                }
                i = end_line;
            }
        } else {
            /* north-west: Copy x and y in forward order */
            for (i = 0; i < n_rects; i++) {
                spice_pixman_copy_rect(canvas->image,
                                       dest_rects[i].x1 - dx, dest_rects[i].y1 - dy,
                                       dest_rects[i].x2 - dest_rects[i].x1,
                                       dest_rects[i].y2 - dest_rects[i].y1,
                                       dest_rects[i].x1, dest_rects[i].y1);
            }
        }
    }
}

static void fill_solid_spans(SpiceCanvas *spice_canvas,
                             SpicePoint *points,
                             int *widths,
                             int n_spans,
                             uint32_t color)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    int i;

   for (i = 0; i < n_spans; i++) {
        spice_pixman_fill_rect(canvas->image,
                               points[i].x, points[i].y,
                               widths[i],
                               1,
                               color);
    }
}

static void fill_solid_rects(SpiceCanvas *spice_canvas,
                             pixman_box32_t *rects,
                             int n_rects,
                             uint32_t color)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    int i;

   for (i = 0; i < n_rects; i++) {
        spice_pixman_fill_rect(canvas->image,
                               rects[i].x1, rects[i].y1,
                               rects[i].x2 - rects[i].x1,
                               rects[i].y2 - rects[i].y1,
                               color);
    }
}

static void fill_solid_rects_rop(SpiceCanvas *spice_canvas,
                                 pixman_box32_t *rects,
                                 int n_rects,
                                 uint32_t color,
                                 SpiceROP rop)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    int i;

   for (i = 0; i < n_rects; i++) {
        spice_pixman_fill_rect_rop(canvas->image,
                                   rects[i].x1, rects[i].y1,
                                   rects[i].x2 - rects[i].x1,
                                   rects[i].y2 - rects[i].y1,
                                   color, rop);
    }
}

static void __fill_tiled_rects(SpiceCanvas *spice_canvas,
                               pixman_box32_t *rects,
                               int n_rects,
                               pixman_image_t *tile,
                               int offset_x, int offset_y)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    int i;

    for (i = 0; i < n_rects; i++) {
        spice_pixman_tile_rect(canvas->image,
                               rects[i].x1, rects[i].y1,
                               rects[i].x2 - rects[i].x1,
                               rects[i].y2 - rects[i].y1,
                               tile, offset_x, offset_y);
    }
}

static void fill_tiled_rects(SpiceCanvas *spice_canvas,
                               pixman_box32_t *rects,
                               int n_rects,
                               pixman_image_t *tile,
                               int offset_x, int offset_y)
{
    __fill_tiled_rects(spice_canvas, rects, n_rects, tile, offset_x, offset_y);
}

static void fill_tiled_rects_from_surface(SpiceCanvas *spice_canvas,
                                          pixman_box32_t *rects,
                                          int n_rects,
                                          SpiceCanvas *surface_canvas,
                                          int offset_x, int offset_y)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __fill_tiled_rects(spice_canvas, rects, n_rects, sw_surface_canvas->image, offset_x,
                       offset_y);
}

static void __fill_tiled_rects_rop(SpiceCanvas *spice_canvas,
                                   pixman_box32_t *rects,
                                   int n_rects,
                                   pixman_image_t *tile,
                                   int offset_x, int offset_y,
                                   SpiceROP rop)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    int i;

    for (i = 0; i < n_rects; i++) {
        spice_pixman_tile_rect_rop(canvas->image,
                                   rects[i].x1, rects[i].y1,
                                   rects[i].x2 - rects[i].x1,
                                   rects[i].y2 - rects[i].y1,
                                   tile, offset_x, offset_y,
                                   rop);
    }
}
static void fill_tiled_rects_rop(SpiceCanvas *spice_canvas,
                                 pixman_box32_t *rects,
                                 int n_rects,
                                 pixman_image_t *tile,
                                 int offset_x, int offset_y,
                                 SpiceROP rop)
{
    __fill_tiled_rects_rop(spice_canvas, rects, n_rects, tile, offset_x, offset_y, rop);
}

static void fill_tiled_rects_rop_from_surface(SpiceCanvas *spice_canvas,
                                              pixman_box32_t *rects,
                                              int n_rects,
                                              SpiceCanvas *surface_canvas,
                                              int offset_x, int offset_y,
                                              SpiceROP rop)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __fill_tiled_rects_rop(spice_canvas, rects, n_rects, sw_surface_canvas->image, offset_x,
                           offset_y, rop);
}

/* Some pixman implementations of OP_OVER on xRGB32 sets
   the high bit to 0xff (which is the right value if the
   destination was ARGB32, and it should be ignored for
   xRGB32. However, this fills our alpha bits with
   data that is not wanted or expected by windows, and its
   causing us to send rgba images rather than rgb images to
   the client. So, we manually clear these bytes. */
static void clear_dest_alpha(pixman_image_t *dest,
                             int x, int y,
                             int width, int height)
{
    uint32_t *data;
    int stride;
    int w, h;

    w = pixman_image_get_width(dest);
    h = pixman_image_get_height(dest);

    if (x + width <= 0 || x >= w ||
        y + height <= 0 || y >= h ||
        width == 0 || height == 0) {
        return;
    }

    if (x < 0) {
        width += x;
        x = 0;
    }
    if (x + width > w) {
        width = w - x;
    }

    if (y < 0) {
        height += y;
        y = 0;
    }
    if (y + height > h) {
        height = h - y;
    }

    stride = pixman_image_get_stride(dest);
    data = SPICE_ALIGNED_CAST(uint32_t *,
                              (uint8_t *)pixman_image_get_data(dest) + y * stride + 4 * x);

    if ((*data & 0xff000000U) == 0xff000000U) {
        spice_pixman_fill_rect_rop(dest,
                                   x, y, width, height,
                                   0x00ffffff, SPICE_ROP_AND);
    }
}

static void __blit_image(SpiceCanvas *spice_canvas,
                         pixman_region32_t *region,
                         pixman_image_t *src_image,
                         int offset_x, int offset_y)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_box32_t *rects;
    int n_rects, i;

    rects = pixman_region32_rectangles(region, &n_rects);

    for (i = 0; i < n_rects; i++) {
        int src_x, src_y, dest_x, dest_y, width, height;

        dest_x = rects[i].x1;
        dest_y = rects[i].y1;
        width = rects[i].x2 - rects[i].x1;
        height = rects[i].y2 - rects[i].y1;

        src_x = rects[i].x1 - offset_x;
        src_y = rects[i].y1 - offset_y;

        spice_pixman_blit(canvas->image,
                          src_image,
                          src_x, src_y,
                          dest_x, dest_y,
                          width, height);
    }
}

static void blit_image(SpiceCanvas *spice_canvas,
                       pixman_region32_t *region,
                       pixman_image_t *src_image,
                       int offset_x, int offset_y)
{
    __blit_image(spice_canvas, region, src_image, offset_x, offset_y);
}

static void blit_image_from_surface(SpiceCanvas *spice_canvas,
                                    pixman_region32_t *region,
                                    SpiceCanvas *surface_canvas,
                                    int offset_x, int offset_y)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __blit_image(spice_canvas, region, sw_surface_canvas->image, offset_x, offset_y);
}

static void __blit_image_rop(SpiceCanvas *spice_canvas,
                             pixman_region32_t *region,
                             pixman_image_t *src_image,
                             int offset_x, int offset_y,
                             SpiceROP rop)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_box32_t *rects;
    int n_rects, i;

    rects = pixman_region32_rectangles(region, &n_rects);

    for (i = 0; i < n_rects; i++) {
        int src_x, src_y, dest_x, dest_y, width, height;

        dest_x = rects[i].x1;
        dest_y = rects[i].y1;
        width = rects[i].x2 - rects[i].x1;
        height = rects[i].y2 - rects[i].y1;

        src_x = rects[i].x1 - offset_x;
        src_y = rects[i].y1 - offset_y;

        spice_pixman_blit_rop(canvas->image,
                              src_image,
                              src_x, src_y,
                              dest_x, dest_y,
                              width, height, rop);
    }
}

static void blit_image_rop(SpiceCanvas *spice_canvas,
                           pixman_region32_t *region,
                           pixman_image_t *src_image,
                           int offset_x, int offset_y,
                           SpiceROP rop)
{
    __blit_image_rop(spice_canvas, region, src_image, offset_x, offset_y, rop);
}

static void blit_image_rop_from_surface(SpiceCanvas *spice_canvas,
                                        pixman_region32_t *region,
                                        SpiceCanvas *surface_canvas,
                                        int offset_x, int offset_y,
                                        SpiceROP rop)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __blit_image_rop(spice_canvas, region, sw_surface_canvas->image, offset_x, offset_y, rop);
}



static void __scale_image(SpiceCanvas *spice_canvas,
                          pixman_region32_t *region,
                          pixman_image_t *src,
                          int src_x, int src_y,
                          int src_width, int src_height,
                          int dest_x, int dest_y,
                          int dest_width, int dest_height,
                          int scale_mode)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_transform_t transform;
    pixman_fixed_t fsx, fsy;

    fsx = ((pixman_fixed_48_16_t) src_width * 65536) / dest_width;
    fsy = ((pixman_fixed_48_16_t) src_height * 65536) / dest_height;

    pixman_image_set_clip_region32(canvas->image, region);

    pixman_transform_init_scale(&transform, fsx, fsy);
    pixman_transform_translate(&transform, NULL,
                               pixman_int_to_fixed(src_x),
                               pixman_int_to_fixed(src_y));

    pixman_image_set_transform(src, &transform);
    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);
    spice_return_if_fail(scale_mode == SPICE_IMAGE_SCALE_MODE_INTERPOLATE ||
                         scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST);
    pixman_image_set_filter(src,
                            (scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST) ?
                            PIXMAN_FILTER_NEAREST : PIXMAN_FILTER_GOOD,
                            NULL, 0);

    pixman_image_composite32(PIXMAN_OP_SRC,
                             src, NULL, canvas->image,
                             0, 0, /* src */
                             0, 0, /* mask */
                             dest_x, dest_y, /* dst */
                             dest_width, dest_height);

    pixman_transform_init_identity(&transform);
    pixman_image_set_transform(src, &transform);

    pixman_image_set_clip_region32(canvas->image, NULL);
}

static void scale_image(SpiceCanvas *spice_canvas,
                        pixman_region32_t *region,
                        pixman_image_t *src,
                        int src_x, int src_y,
                        int src_width, int src_height,
                        int dest_x, int dest_y,
                        int dest_width, int dest_height,
                        int scale_mode)
{
    __scale_image(spice_canvas, region, src, src_x, src_y, src_width, src_height, dest_x, dest_y,
                  dest_width,dest_height,scale_mode);
}

static void scale_image_from_surface(SpiceCanvas *spice_canvas,
                                     pixman_region32_t *region,
                                     SpiceCanvas *surface_canvas,
                                     int src_x, int src_y,
                                     int src_width, int src_height,
                                     int dest_x, int dest_y,
                                     int dest_width, int dest_height,
                                     int scale_mode)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __scale_image(spice_canvas, region, sw_surface_canvas->image, src_x, src_y, src_width,
                  src_height, dest_x, dest_y, dest_width,dest_height,scale_mode);
}

static void __scale_image_rop(SpiceCanvas *spice_canvas,
                              pixman_region32_t *region,
                              pixman_image_t *src,
                              int src_x, int src_y,
                              int src_width, int src_height,
                              int dest_x, int dest_y,
                              int dest_width, int dest_height,
                              int scale_mode, SpiceROP rop)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_transform_t transform;
    pixman_image_t *scaled;
    pixman_box32_t *rects;
    int n_rects, i;
    pixman_fixed_t fsx, fsy;
    pixman_format_code_t format;

    fsx = ((pixman_fixed_48_16_t) src_width * 65536) / dest_width;
    fsy = ((pixman_fixed_48_16_t) src_height * 65536) / dest_height;

    spice_return_if_fail(spice_pixman_image_get_format(src, &format));
    scaled = pixman_image_create_bits(format,
                                      dest_width,
                                      dest_height,
                                      NULL, 0);

    pixman_region32_translate(region, -dest_x, -dest_y);
    pixman_image_set_clip_region32(scaled, region);

    pixman_transform_init_scale(&transform, fsx, fsy);
    pixman_transform_translate(&transform, NULL,
                               pixman_int_to_fixed(src_x),
                               pixman_int_to_fixed(src_y));

    pixman_image_set_transform(src, &transform);
    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);
    spice_return_if_fail(scale_mode == SPICE_IMAGE_SCALE_MODE_INTERPOLATE ||
                         scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST);
    pixman_image_set_filter(src,
                            (scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST) ?
                            PIXMAN_FILTER_NEAREST : PIXMAN_FILTER_GOOD,
                            NULL, 0);

    pixman_image_composite32(PIXMAN_OP_SRC,
                             src, NULL, scaled,
                             0, 0, /* src */
                             0, 0, /* mask */
                             0, 0, /* dst */
                             dest_width,
                             dest_height);

    pixman_transform_init_identity(&transform);
    pixman_image_set_transform(src, &transform);

    /* Translate back */
    pixman_region32_translate(region, dest_x, dest_y);

    rects = pixman_region32_rectangles(region, &n_rects);

    for (i = 0; i < n_rects; i++) {
        spice_pixman_blit_rop(canvas->image,
                              scaled,
                              rects[i].x1 - dest_x,
                              rects[i].y1 - dest_y,
                              rects[i].x1, rects[i].y1,
                              rects[i].x2 - rects[i].x1,
                              rects[i].y2 - rects[i].y1,
                              rop);
    }

    pixman_image_unref(scaled);
}

static void scale_image_rop(SpiceCanvas *spice_canvas,
                            pixman_region32_t *region,
                            pixman_image_t *src,
                            int src_x, int src_y,
                            int src_width, int src_height,
                            int dest_x, int dest_y,
                            int dest_width, int dest_height,
                            int scale_mode, SpiceROP rop)
{
    __scale_image_rop(spice_canvas, region, src, src_x, src_y, src_width, src_height, dest_x,
                      dest_y, dest_width, dest_height, scale_mode, rop);
}

static void scale_image_rop_from_surface(SpiceCanvas *spice_canvas,
                                         pixman_region32_t *region,
                                         SpiceCanvas *surface_canvas,
                                         int src_x, int src_y,
                                         int src_width, int src_height,
                                         int dest_x, int dest_y,
                                         int dest_width, int dest_height,
                                         int scale_mode, SpiceROP rop)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __scale_image_rop(spice_canvas, region, sw_surface_canvas->image, src_x, src_y, src_width,
                      src_height, dest_x, dest_y, dest_width, dest_height, scale_mode, rop);
}

static pixman_image_t *canvas_get_as_surface(SwCanvas *canvas,
                                          int with_alpha)
{
    pixman_image_t *target;

    if (with_alpha &&
        canvas->base.format == SPICE_SURFACE_FMT_32_xRGB) {
        target = pixman_image_create_bits(PIXMAN_a8r8g8b8,
                                          pixman_image_get_width(canvas->image),
                                          pixman_image_get_height(canvas->image),
                                          pixman_image_get_data(canvas->image),
                                          pixman_image_get_stride(canvas->image));
    } else {
        target = pixman_image_ref(canvas->image);
    }

    return target;
}

static void __blend_image(SpiceCanvas *spice_canvas,
                          pixman_region32_t *region,
                          int dest_has_alpha,
                          pixman_image_t *src,
                          int src_x, int src_y,
                          int dest_x, int dest_y,
                          int width, int height,
                          int overall_alpha)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_image_t *mask, *dest;

    dest = canvas_get_as_surface(canvas, dest_has_alpha);

    pixman_image_set_clip_region32(dest, region);

    mask = NULL;
    if (overall_alpha != 0xff) {
        pixman_color_t color = { 0, 0, 0, 0 };
        color.alpha = overall_alpha * 0x101;
        mask = pixman_image_create_solid_fill(&color);
    }

    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);

    pixman_image_composite32(PIXMAN_OP_OVER,
                             src, mask, dest,
                             src_x, src_y, /* src */
                             0, 0, /* mask */
                             dest_x, dest_y, /* dst */
                             width,
                             height);

    if (canvas->base.format == SPICE_SURFACE_FMT_32_xRGB &&
        !dest_has_alpha) {
        clear_dest_alpha(dest, dest_x, dest_y, width, height);
    }

    if (mask) {
        pixman_image_unref(mask);
    }

    pixman_image_set_clip_region32(dest, NULL);
    pixman_image_unref(dest);
}

static void blend_image(SpiceCanvas *spice_canvas,
                        pixman_region32_t *region,
                        int dest_has_alpha,
                        pixman_image_t *src,
                        int src_x, int src_y,
                        int dest_x, int dest_y,
                        int width, int height,
                        int overall_alpha)
{
    __blend_image(spice_canvas, region, dest_has_alpha, src, src_x, src_y,
                  dest_x, dest_y, width, height,
                  overall_alpha);
}

static void blend_image_from_surface(SpiceCanvas *spice_canvas,
                                     pixman_region32_t *region,
                                     int dest_has_alpha,
                                     SpiceCanvas *surface_canvas,
                                     int src_has_alpha,
                                     int src_x, int src_y,
                                     int dest_x, int dest_y,
                                     int width, int height,
                                     int overall_alpha)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    pixman_image_t *src;

    src = canvas_get_as_surface(sw_surface_canvas, src_has_alpha);
    __blend_image(spice_canvas, region, dest_has_alpha,
                  src, src_x, src_y,
                  dest_x, dest_y,
                  width, height, overall_alpha);
    pixman_image_unref(src);
}

static void __blend_scale_image(SpiceCanvas *spice_canvas,
                                pixman_region32_t *region,
                                int dest_has_alpha,
                                pixman_image_t *src,
                                int src_x, int src_y,
                                int src_width, int src_height,
                                int dest_x, int dest_y,
                                int dest_width, int dest_height,
                                int scale_mode,
                                int overall_alpha)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_transform_t transform;
    pixman_image_t *mask, *dest;
    pixman_fixed_t fsx, fsy;

    fsx = ((pixman_fixed_48_16_t) src_width * 65536) / dest_width;
    fsy = ((pixman_fixed_48_16_t) src_height * 65536) / dest_height;

    dest = canvas_get_as_surface(canvas, dest_has_alpha);

    pixman_image_set_clip_region32(dest, region);

    pixman_transform_init_scale(&transform, fsx, fsy);
    pixman_transform_translate(&transform, NULL,
                               pixman_int_to_fixed(src_x),
                               pixman_int_to_fixed(src_y));

    mask = NULL;
    if (overall_alpha != 0xff) {
        pixman_color_t color = { 0, 0, 0, 0 };
        color.alpha = overall_alpha * 0x101;
        mask = pixman_image_create_solid_fill(&color);
    }

    pixman_image_set_transform(src, &transform);
    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);
    spice_return_if_fail(scale_mode == SPICE_IMAGE_SCALE_MODE_INTERPOLATE ||
                         scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST);
    pixman_image_set_filter(src,
                            (scale_mode == SPICE_IMAGE_SCALE_MODE_NEAREST) ?
                            PIXMAN_FILTER_NEAREST : PIXMAN_FILTER_GOOD,
                            NULL, 0);

    pixman_image_composite32(PIXMAN_OP_OVER,
                             src, mask, dest,
                             0, 0, /* src */
                             0, 0, /* mask */
                             dest_x, dest_y, /* dst */
                             dest_width, dest_height);

    if (canvas->base.format == SPICE_SURFACE_FMT_32_xRGB &&
        !dest_has_alpha) {
        clear_dest_alpha(dest, dest_x, dest_y, dest_width, dest_height);
    }

    pixman_transform_init_identity(&transform);
    pixman_image_set_transform(src, &transform);

    if (mask) {
        pixman_image_unref(mask);
    }

    pixman_image_set_clip_region32(dest, NULL);
    pixman_image_unref(dest);
}

static void blend_scale_image(SpiceCanvas *spice_canvas,
                              pixman_region32_t *region,
                              int dest_has_alpha,
                              pixman_image_t *src,
                              int src_x, int src_y,
                              int src_width, int src_height,
                              int dest_x, int dest_y,
                              int dest_width, int dest_height,
                              int scale_mode,
                              int overall_alpha)
{
    __blend_scale_image(spice_canvas, region, dest_has_alpha,
                        src, src_x, src_y, src_width, src_height,
                        dest_x, dest_y, dest_width, dest_height,
                        scale_mode, overall_alpha);
}

static void blend_scale_image_from_surface(SpiceCanvas *spice_canvas,
                                           pixman_region32_t *region,
                                           int dest_has_alpha,
                                           SpiceCanvas *surface_canvas,
                                           int src_has_alpha,
                                           int src_x, int src_y,
                                           int src_width, int src_height,
                                           int dest_x, int dest_y,
                                           int dest_width, int dest_height,
                                           int scale_mode,
                                           int overall_alpha)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    pixman_image_t *src;

    src = canvas_get_as_surface(sw_surface_canvas, src_has_alpha);
    __blend_scale_image(spice_canvas, region, dest_has_alpha, src, src_x, src_y, src_width,
                        src_height, dest_x, dest_y, dest_width, dest_height, scale_mode,
                        overall_alpha);
    pixman_image_unref(src);
}

static void __colorkey_image(SpiceCanvas *spice_canvas,
                             pixman_region32_t *region,
                             pixman_image_t *src_image,
                             int offset_x, int offset_y,
                             uint32_t transparent_color)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_box32_t *rects;
    int n_rects, i;

    rects = pixman_region32_rectangles(region, &n_rects);

    for (i = 0; i < n_rects; i++) {
        int src_x, src_y, dest_x, dest_y, width, height;

        dest_x = rects[i].x1;
        dest_y = rects[i].y1;
        width = rects[i].x2 - rects[i].x1;
        height = rects[i].y2 - rects[i].y1;

        src_x = rects[i].x1 - offset_x;
        src_y = rects[i].y1 - offset_y;

        spice_pixman_blit_colorkey(canvas->image,
                                   src_image,
                                   src_x, src_y,
                                   dest_x, dest_y,
                                   width, height,
                                   transparent_color);
    }
}

static void colorkey_image(SpiceCanvas *spice_canvas,
                           pixman_region32_t *region,
                           pixman_image_t *src_image,
                           int offset_x, int offset_y,
                           uint32_t transparent_color)
{
    __colorkey_image(spice_canvas, region, src_image, offset_x, offset_y, transparent_color);
}

static void colorkey_image_from_surface(SpiceCanvas *spice_canvas,
                                        pixman_region32_t *region,
                                        SpiceCanvas *surface_canvas,
                                        int offset_x, int offset_y,
                                        uint32_t transparent_color)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __colorkey_image(spice_canvas, region, sw_surface_canvas->image, offset_x, offset_y,
                     transparent_color);
}

static void __colorkey_scale_image(SpiceCanvas *spice_canvas,
                                   pixman_region32_t *region,
                                   pixman_image_t *src,
                                   int src_x, int src_y,
                                   int src_width, int src_height,
                                   int dest_x, int dest_y,
                                   int dest_width, int dest_height,
                                   uint32_t transparent_color)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_transform_t transform;
    pixman_image_t *scaled;
    pixman_box32_t *rects;
    int n_rects, i;
    pixman_fixed_t fsx, fsy;
    pixman_format_code_t format;

    fsx = ((pixman_fixed_48_16_t) src_width * 65536) / dest_width;
    fsy = ((pixman_fixed_48_16_t) src_height * 65536) / dest_height;

    spice_return_if_fail(spice_pixman_image_get_format(src, &format));
    scaled = pixman_image_create_bits(format,
                                      dest_width,
                                      dest_height,
                                      NULL, 0);

    pixman_region32_translate(region, -dest_x, -dest_y);
    pixman_image_set_clip_region32(scaled, region);

    pixman_transform_init_scale(&transform, fsx, fsy);
    pixman_transform_translate(&transform, NULL,
                               pixman_int_to_fixed(src_x),
                               pixman_int_to_fixed(src_y));

    pixman_image_set_transform(src, &transform);
    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);
    pixman_image_set_filter(src,
                            PIXMAN_FILTER_NEAREST,
                            NULL, 0);

    pixman_image_composite32(PIXMAN_OP_SRC,
                             src, NULL, scaled,
                             0, 0, /* src */
                             0, 0, /* mask */
                             0, 0, /* dst */
                             dest_width,
                             dest_height);

    pixman_transform_init_identity(&transform);
    pixman_image_set_transform(src, &transform);

    /* Translate back */
    pixman_region32_translate(region, dest_x, dest_y);

    rects = pixman_region32_rectangles(region, &n_rects);

    for (i = 0; i < n_rects; i++) {
        spice_pixman_blit_colorkey(canvas->image,
                                   scaled,
                                   rects[i].x1 - dest_x,
                                   rects[i].y1 - dest_y,
                                   rects[i].x1, rects[i].y1,
                                   rects[i].x2 - rects[i].x1,
                                   rects[i].y2 - rects[i].y1,
                                   transparent_color);
    }

    pixman_image_unref(scaled);
}

static void colorkey_scale_image(SpiceCanvas *spice_canvas,
                                 pixman_region32_t *region,
                                 pixman_image_t *src,
                                 int src_x, int src_y,
                                 int src_width, int src_height,
                                 int dest_x, int dest_y,
                                 int dest_width, int dest_height,
                                 uint32_t transparent_color)
{
    __colorkey_scale_image(spice_canvas, region, src, src_x, src_y, src_width, src_height, dest_x,
                           dest_y, dest_width, dest_height, transparent_color);
}

static void colorkey_scale_image_from_surface(SpiceCanvas *spice_canvas,
                                              pixman_region32_t *region,
                                              SpiceCanvas *surface_canvas,
                                              int src_x, int src_y,
                                              int src_width, int src_height,
                                              int dest_x, int dest_y,
                                              int dest_width, int dest_height,
                                              uint32_t transparent_color)
{
    SwCanvas *sw_surface_canvas = (SwCanvas *)surface_canvas;
    __colorkey_scale_image(spice_canvas, region, sw_surface_canvas->image, src_x, src_y,
                           src_width, src_height, dest_x, dest_y, dest_width, dest_height,
                           transparent_color);
}

static void canvas_put_image(SpiceCanvas *spice_canvas,
                             const SpiceRect *dest, const uint8_t *src_data,
                             uint32_t src_width, uint32_t src_height, int src_stride,
                             const QRegion *clip)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_image_t *src;
    uint32_t dest_width;
    uint32_t dest_height;
    double sx, sy;
    pixman_transform_t transform;

    src = pixman_image_create_bits(PIXMAN_x8r8g8b8,
                                   src_width,
                                   src_height,
                                   SPICE_ALIGNED_CAST(uint32_t*,src_data),
                                   src_stride);


    if (clip) {
        pixman_image_set_clip_region32 (canvas->image, (pixman_region32_t *)clip);
    }

    dest_width = dest->right - dest->left;
    dest_height = dest->bottom - dest->top;

    if (dest_width != src_width || dest_height != src_height) {
        sx = (double)(src_width) / (dest_width);
        sy = (double)(src_height) / (dest_height);

        pixman_transform_init_scale(&transform,
                                    pixman_double_to_fixed(sx),
                                    pixman_double_to_fixed(sy));
        pixman_image_set_transform(src, &transform);
        pixman_image_set_filter(src,
                                PIXMAN_FILTER_NEAREST,
                                NULL, 0);
    }

    pixman_image_set_repeat(src, PIXMAN_REPEAT_NONE);

    pixman_image_composite32(PIXMAN_OP_SRC,
                             src, NULL, canvas->image,
                             0, 0, /* src */
                             0, 0, /* mask */
                             dest->left, dest->top, /* dst */
                             dest_width, dest_height);


    if (clip) {
        pixman_image_set_clip_region32(canvas->image, NULL);
    }
    pixman_image_unref(src);
}


static void canvas_draw_text(SpiceCanvas *spice_canvas, SpiceRect *bbox,
                             SpiceClip *clip, SpiceText *text)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_region32_t dest_region;
    pixman_image_t *str_mask, *brush;
    SpiceString *str;
    SpicePoint pos = { 0, 0 };
    int depth;

    pixman_region32_init_rect(&dest_region,
                              bbox->left, bbox->top,
                              bbox->right - bbox->left,
                              bbox->bottom - bbox->top);

    canvas_clip_pixman(&canvas->base, &dest_region, clip);

    if (!pixman_region32_not_empty(&dest_region)) {
        touch_brush(&canvas->base, &text->fore_brush);
        touch_brush(&canvas->base, &text->back_brush);
        pixman_region32_fini(&dest_region);
        return;
    }

    if (!rect_is_empty(&text->back_area)) {
        pixman_region32_t back_region;

        /* Nothing else makes sense for text and we should deprecate it
         * and actually it means OVER really */
        spice_return_if_fail(text->fore_mode == SPICE_ROPD_OP_PUT);

        pixman_region32_init_rect(&back_region,
                                  text->back_area.left,
                                  text->back_area.top,
                                  text->back_area.right - text->back_area.left,
                                  text->back_area.bottom - text->back_area.top);

        pixman_region32_intersect(&back_region, &back_region, &dest_region);

        if (pixman_region32_not_empty(&back_region)) {
            draw_brush(spice_canvas, &back_region, &text->back_brush, SPICE_ROP_COPY);
        }

        pixman_region32_fini(&back_region);
    }
    str = (SpiceString *)SPICE_GET_ADDRESS(text->str);

    if (str->flags & SPICE_STRING_FLAGS_RASTER_A1) {
        depth = 1;
    } else if (str->flags & SPICE_STRING_FLAGS_RASTER_A4) {
        depth = 4;
    } else if (str->flags & SPICE_STRING_FLAGS_RASTER_A8) {
        spice_warning("untested path A8 glyphs");
        depth = 8;
    } else {
        spice_warning("unsupported path vector glyphs");
        pixman_region32_fini (&dest_region);
        return;
    }

    brush = canvas_get_pixman_brush(canvas, &text->fore_brush);

    str_mask = canvas_get_str_mask(&canvas->base, str, depth, &pos);
    if (brush) {
        pixman_image_set_clip_region32(canvas->image, &dest_region);

        pixman_image_composite32(PIXMAN_OP_OVER,
                                 brush,
                                 str_mask,
                                 canvas->image,
                                 0, 0,
                                 0, 0,
                                 pos.x, pos.y,
                                 pixman_image_get_width(str_mask),
                                 pixman_image_get_height(str_mask));
        if (canvas->base.format == SPICE_SURFACE_FMT_32_xRGB) {
            clear_dest_alpha(canvas->image, pos.x, pos.y,
                             pixman_image_get_width(str_mask),
                             pixman_image_get_height(str_mask));
        }
        pixman_image_unref(brush);

        pixman_image_set_clip_region32(canvas->image, NULL);
    }
    pixman_image_unref(str_mask);
    pixman_region32_fini(&dest_region);
}

static void canvas_read_bits(SpiceCanvas *spice_canvas, uint8_t *dest,
                             int dest_stride, const SpiceRect *area)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    pixman_image_t* surface;
    uint8_t *src;
    int src_stride;
    uint8_t *dest_end;
    int bpp;

    spice_return_if_fail(canvas && area);

    surface = canvas->image;

    bpp = spice_pixman_image_get_bpp(surface) / 8;

    src_stride = pixman_image_get_stride(surface);
    src = (uint8_t *)pixman_image_get_data(surface) +
        area->top * src_stride + area->left * bpp;
    dest_end = dest + (area->bottom - area->top) * dest_stride;
    for (; dest != dest_end; dest += dest_stride, src += src_stride) {
        memcpy(dest, src, (area->right - area->left) * bpp);
    }
}

static void canvas_clear(SpiceCanvas *spice_canvas)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    spice_pixman_fill_rect(canvas->image,
                           0, 0,
                           pixman_image_get_width(canvas->image),
                           pixman_image_get_height(canvas->image),
                           0);
}

static void canvas_destroy(SpiceCanvas *spice_canvas)
{
    SwCanvas *canvas = (SwCanvas *)spice_canvas;
    if (!canvas) {
        return;
    }
    pixman_image_unref(canvas->image);
    canvas_base_destroy(&canvas->base);
    free(canvas->private_data);
    free(canvas);
}

static SpiceCanvasOps sw_canvas_ops;

static SpiceCanvas *canvas_create_common(pixman_image_t *image,
                                         uint32_t format,
                                         SpiceImageCache *bits_cache,
#ifdef SW_CANVAS_CACHE
                                         SpicePaletteCache *palette_cache,
#endif
                                         SpiceImageSurfaces *surfaces,
                                         SpiceGlzDecoder *glz_decoder,
                                         SpiceJpegDecoder *jpeg_decoder,
                                         SpiceZlibDecoder *zlib_decoder)
{
    SwCanvas *canvas;

    spice_pixman_image_set_format(image,
                                  spice_surface_format_to_pixman(format));

    canvas = spice_new0(SwCanvas, 1);
    canvas_base_init(&canvas->base, &sw_canvas_ops,
                     pixman_image_get_width(image),
                     pixman_image_get_height(image),
                     format,
                     bits_cache,
#ifdef SW_CANVAS_CACHE
                     palette_cache,
#endif
                     surfaces,
                     glz_decoder,
                     jpeg_decoder,
                     zlib_decoder);
    canvas->private_data = NULL;
    canvas->private_data_size = 0;

    canvas->image = image;

    return (SpiceCanvas *)canvas;
}

SpiceCanvas *canvas_create_for_data(int width, int height, uint32_t format,
                                    uint8_t *data, int stride,
                                    SpiceImageCache *bits_cache,
#ifdef SW_CANVAS_CACHE
                                    SpicePaletteCache *palette_cache,
#endif
                                    SpiceImageSurfaces *surfaces,
                                    SpiceGlzDecoder *glz_decoder,
                                    SpiceJpegDecoder *jpeg_decoder,
                                    SpiceZlibDecoder *zlib_decoder)
{
    pixman_image_t *image;

    image = pixman_image_create_bits(spice_surface_format_to_pixman(format),
                                     width, height,
                                     SPICE_ALIGNED_CAST(uint32_t *,data),
                                     stride);

    return canvas_create_common(image, format,
                                bits_cache,
#ifdef SW_CANVAS_CACHE
                                palette_cache,
#endif
                                surfaces,
                                glz_decoder,
                                jpeg_decoder,
                                zlib_decoder);
}

SPICE_CONSTRUCTOR_FUNC(sw_canvas_global_init) //unsafe global function
{
    canvas_base_init_ops(&sw_canvas_ops);
    sw_canvas_ops.draw_text = canvas_draw_text;
    sw_canvas_ops.put_image = canvas_put_image;
    sw_canvas_ops.clear = canvas_clear;
    sw_canvas_ops.read_bits = canvas_read_bits;
    sw_canvas_ops.destroy = canvas_destroy;

    sw_canvas_ops.fill_solid_spans = fill_solid_spans;
    sw_canvas_ops.fill_solid_rects = fill_solid_rects;
    sw_canvas_ops.fill_solid_rects_rop = fill_solid_rects_rop;
    sw_canvas_ops.fill_tiled_rects = fill_tiled_rects;
    sw_canvas_ops.fill_tiled_rects_from_surface = fill_tiled_rects_from_surface;
    sw_canvas_ops.fill_tiled_rects_rop = fill_tiled_rects_rop;
    sw_canvas_ops.fill_tiled_rects_rop_from_surface = fill_tiled_rects_rop_from_surface;
    sw_canvas_ops.blit_image = blit_image;
    sw_canvas_ops.blit_image_from_surface = blit_image_from_surface;
    sw_canvas_ops.blit_image_rop = blit_image_rop;
    sw_canvas_ops.blit_image_rop_from_surface = blit_image_rop_from_surface;
    sw_canvas_ops.scale_image = scale_image;
    sw_canvas_ops.scale_image_from_surface = scale_image_from_surface;
    sw_canvas_ops.scale_image_rop = scale_image_rop;
    sw_canvas_ops.scale_image_rop_from_surface = scale_image_rop_from_surface;
    sw_canvas_ops.blend_image = blend_image;
    sw_canvas_ops.blend_image_from_surface = blend_image_from_surface;
    sw_canvas_ops.blend_scale_image = blend_scale_image;
    sw_canvas_ops.blend_scale_image_from_surface = blend_scale_image_from_surface;
    sw_canvas_ops.colorkey_image = colorkey_image;
    sw_canvas_ops.colorkey_image_from_surface = colorkey_image_from_surface;
    sw_canvas_ops.colorkey_scale_image = colorkey_scale_image;
    sw_canvas_ops.colorkey_scale_image_from_surface = colorkey_scale_image_from_surface;
    sw_canvas_ops.copy_region = copy_region;
    sw_canvas_ops.get_image = get_image;
}

```

`devices/display/qxl/canvas/sw_canvas.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

#ifndef H_SPICE_COMMON_SW_CANVAS
#define H_SPICE_COMMON_SW_CANVAS

#include <stdint.h>
#include <spice/macros.h>

#include "draw.h"
#include "pixman_utils.h"
#include "canvas_base.h"
#include "region.h"

SPICE_BEGIN_DECLS

SpiceCanvas *canvas_create_for_data(int width, int height, uint32_t format, uint8_t *data, int stride
                           , SpiceImageCache *bits_cache
#ifdef SW_CANVAS_CACHE
                           , SpicePaletteCache *palette_cache
#endif
                           , SpiceImageSurfaces *surfaces
                           , SpiceGlzDecoder *glz_decoder
                           , SpiceJpegDecoder *jpeg_decoder
                           , SpiceZlibDecoder *zlib_decoder
                           );


SPICE_END_DECLS

#endif

```

`devices/display/qxl/canvas/verify.h`:

```h
/* Compile-time assert-like macros.

   Copyright (C) 2005-2006, 2009-2019 Free Software Foundation, Inc.

   This program is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation; either version 2.1 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <https://www.gnu.org/licenses/>.  */

/* Written by Paul Eggert, Bruno Haible, and Jim Meyering.  */

#ifndef _GL_VERIFY_H
#define _GL_VERIFY_H


/* Define _GL_HAVE__STATIC_ASSERT to 1 if _Static_assert works as per C11.
   This is supported by GCC 4.6.0 and later, in C mode, and its use
   here generates easier-to-read diagnostics when verify (R) fails.

   Define _GL_HAVE_STATIC_ASSERT to 1 if static_assert works as per C++11.
   This is supported by GCC 6.1.0 and later, in C++ mode.

   Use this only with GCC.  If we were willing to slow 'configure'
   down we could also use it with other compilers, but since this
   affects only the quality of diagnostics, why bother?  */
#if (4 < __GNUC__ + (6 <= __GNUC_MINOR__) \
     && (201112L <= __STDC_VERSION__  || !defined __STRICT_ANSI__) \
     && !defined __cplusplus)
# define _GL_HAVE__STATIC_ASSERT 1
#endif
#if (6 <= __GNUC__) && defined __cplusplus
# define _GL_HAVE_STATIC_ASSERT 1
#endif

/* FreeBSD 9.1 <sys/cdefs.h>, included by <stddef.h> and lots of other
   system headers, defines a conflicting _Static_assert that is no
   better than ours; override it.  */
#ifndef _GL_HAVE_STATIC_ASSERT
# include <stddef.h>
# undef _Static_assert
#endif

/* Each of these macros verifies that its argument R is nonzero.  To
   be portable, R should be an integer constant expression.  Unlike
   assert (R), there is no run-time overhead.

   If _Static_assert works, verify (R) uses it directly.  Similarly,
   _GL_VERIFY_TRUE works by packaging a _Static_assert inside a struct
   that is an operand of sizeof.

   The code below uses several ideas for C++ compilers, and for C
   compilers that do not support _Static_assert:

   * The first step is ((R) ? 1 : -1).  Given an expression R, of
     integral or boolean or floating-point type, this yields an
     expression of integral type, whose value is later verified to be
     constant and nonnegative.

   * Next this expression W is wrapped in a type
     struct _gl_verify_type {
       unsigned int _gl_verify_error_if_negative: W;
     }.
     If W is negative, this yields a compile-time error.  No compiler can
     deal with a bit-field of negative size.

     One might think that an array size check would have the same
     effect, that is, that the type struct { unsigned int dummy[W]; }
     would work as well.  However, inside a function, some compilers
     (such as C++ compilers and GNU C) allow local parameters and
     variables inside array size expressions.  With these compilers,
     an array size check would not properly diagnose this misuse of
     the verify macro:

       void function (int n) { verify (n < 0); }

   * For the verify macro, the struct _gl_verify_type will need to
     somehow be embedded into a declaration.  To be portable, this
     declaration must declare an object, a constant, a function, or a
     typedef name.  If the declared entity uses the type directly,
     such as in

       struct dummy {...};
       typedef struct {...} dummy;
       extern struct {...} *dummy;
       extern void dummy (struct {...} *);
       extern struct {...} *dummy (void);

     two uses of the verify macro would yield colliding declarations
     if the entity names are not disambiguated.  A workaround is to
     attach the current line number to the entity name:

       #define _GL_CONCAT0(x, y) x##y
       #define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
       extern struct {...} * _GL_CONCAT (dummy, __LINE__);

     But this has the problem that two invocations of verify from
     within the same macro would collide, since the __LINE__ value
     would be the same for both invocations.  (The GCC __COUNTER__
     macro solves this problem, but is not portable.)

     A solution is to use the sizeof operator.  It yields a number,
     getting rid of the identity of the type.  Declarations like

       extern int dummy [sizeof (struct {...})];
       extern void dummy (int [sizeof (struct {...})]);
       extern int (*dummy (void)) [sizeof (struct {...})];

     can be repeated.

   * Should the implementation use a named struct or an unnamed struct?
     Which of the following alternatives can be used?

       extern int dummy [sizeof (struct {...})];
       extern int dummy [sizeof (struct _gl_verify_type {...})];
       extern void dummy (int [sizeof (struct {...})]);
       extern void dummy (int [sizeof (struct _gl_verify_type {...})]);
       extern int (*dummy (void)) [sizeof (struct {...})];
       extern int (*dummy (void)) [sizeof (struct _gl_verify_type {...})];

     In the second and sixth case, the struct type is exported to the
     outer scope; two such declarations therefore collide.  GCC warns
     about the first, third, and fourth cases.  So the only remaining
     possibility is the fifth case:

       extern int (*dummy (void)) [sizeof (struct {...})];

   * GCC warns about duplicate declarations of the dummy function if
     -Wredundant-decls is used.  GCC 4.3 and later have a builtin
     __COUNTER__ macro that can let us generate unique identifiers for
     each dummy function, to suppress this warning.

   * This implementation exploits the fact that older versions of GCC,
     which do not support _Static_assert, also do not warn about the
     last declaration mentioned above.

   * GCC warns if -Wnested-externs is enabled and verify() is used
     within a function body; but inside a function, you can always
     arrange to use verify_expr() instead.

   * In C++, any struct definition inside sizeof is invalid.
     Use a template type to work around the problem.  */

/* Concatenate two preprocessor tokens.  */
#define _GL_CONCAT(x, y) _GL_CONCAT0 (x, y)
#define _GL_CONCAT0(x, y) x##y

/* _GL_COUNTER is an integer, preferably one that changes each time we
   use it.  Use __COUNTER__ if it works, falling back on __LINE__
   otherwise.  __LINE__ isn't perfect, but it's better than a
   constant.  */
#if defined __COUNTER__ && __COUNTER__ != __COUNTER__
# define _GL_COUNTER __COUNTER__
#else
# define _GL_COUNTER __LINE__
#endif

/* Generate a symbol with the given prefix, making it unique if
   possible.  */
#define _GL_GENSYM(prefix) _GL_CONCAT (prefix, _GL_COUNTER)

/* Verify requirement R at compile-time, as an integer constant expression
   that returns 1.  If R is false, fail at compile-time, preferably
   with a diagnostic that includes the string-literal DIAGNOSTIC.  */

#define _GL_VERIFY_TRUE(R, DIAGNOSTIC) \
   (!!sizeof (_GL_VERIFY_TYPE (R, DIAGNOSTIC)))

#ifdef __cplusplus
# if !GNULIB_defined_struct__gl_verify_type
template <int w>
  struct _gl_verify_type {
    unsigned int _gl_verify_error_if_negative: w;
  };
#  define GNULIB_defined_struct__gl_verify_type 1
# endif
# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
    _gl_verify_type<(R) ? 1 : -1>
#elif defined _GL_HAVE__STATIC_ASSERT
# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
    struct {                                   \
      _Static_assert (R, DIAGNOSTIC);          \
      int _gl_dummy;                          \
    }
#else
# define _GL_VERIFY_TYPE(R, DIAGNOSTIC) \
    struct { unsigned int _gl_verify_error_if_negative: (R) ? 1 : -1; }
#endif

/* Verify requirement R at compile-time, as a declaration without a
   trailing ';'.  If R is false, fail at compile-time, preferably
   with a diagnostic that includes the string-literal DIAGNOSTIC.

   Unfortunately, unlike C11, this implementation must appear as an
   ordinary declaration, and cannot appear inside struct { ... }.  */

#ifdef _GL_HAVE__STATIC_ASSERT
# define _GL_VERIFY _Static_assert
#else
# define _GL_VERIFY(R, DIAGNOSTIC)				       \
    extern int (*_GL_GENSYM (_gl_verify_function) (void))	       \
      [_GL_VERIFY_TRUE (R, DIAGNOSTIC)]
#endif

/* _GL_STATIC_ASSERT_H is defined if this code is copied into assert.h.  */
#ifdef _GL_STATIC_ASSERT_H
# if !defined _GL_HAVE__STATIC_ASSERT && !defined _Static_assert
#  define _Static_assert(R, DIAGNOSTIC) _GL_VERIFY (R, DIAGNOSTIC)
# endif
# if !defined _GL_HAVE_STATIC_ASSERT && !defined static_assert
#  define static_assert _Static_assert /* C11 requires this #define.  */
# endif
#endif

/* @assert.h omit start@  */

/* Each of these macros verifies that its argument R is nonzero.  To
   be portable, R should be an integer constant expression.  Unlike
   assert (R), there is no run-time overhead.

   There are two macros, since no single macro can be used in all
   contexts in C.  verify_true (R) is for scalar contexts, including
   integer constant expression contexts.  verify (R) is for declaration
   contexts, e.g., the top level.  */

/* Verify requirement R at compile-time, as an integer constant expression.
   Return 1.  This is equivalent to verify_expr (R, 1).

   verify_true is obsolescent; please use verify_expr instead.  */

#define verify_true(R) _GL_VERIFY_TRUE (R, "verify_true (" #R ")")

/* Verify requirement R at compile-time.  Return the value of the
   expression E.  */

#define verify_expr(R, E) \
   (_GL_VERIFY_TRUE (R, "verify_expr (" #R ", " #E ")") ? (E) : (E))

/* Verify requirement R at compile-time, as a declaration without a
   trailing ';'.  */

#ifdef __GNUC__
# define verify(R) _GL_VERIFY (R, "verify (" #R ")")
#else
/* PGI barfs if R is long.  Play it safe.  */
# define verify(R) _GL_VERIFY (R, "verify (...)")
#endif

#ifndef __has_builtin
# define __has_builtin(x) 0
#endif

/* Assume that R always holds.  This lets the compiler optimize
   accordingly.  R should not have side-effects; it may or may not be
   evaluated.  Behavior is undefined if R is false.  */

#if (__has_builtin (__builtin_unreachable) \
     || 4 < __GNUC__ + (5 <= __GNUC_MINOR__))
# define assume(R) ((R) ? (void) 0 : __builtin_unreachable ())
#elif 1200 <= _MSC_VER
# define assume(R) __assume (R)
#elif ((defined GCC_LINT || defined lint) \
       && (__has_builtin (__builtin_trap) \
           || 3 < __GNUC__ + (3 < __GNUC_MINOR__ + (4 <= __GNUC_PATCHLEVEL__))))
  /* Doing it this way helps various packages when configured with
     --enable-gcc-warnings, which compiles with -Dlint.  It's nicer
     when 'assume' silences warnings even with older GCCs.  */
# define assume(R) ((R) ? (void) 0 : __builtin_trap ())
#else
  /* Some tools grok NOTREACHED, e.g., Oracle Studio 12.6.  */
# define assume(R) ((R) ? (void) 0 : /*NOTREACHED*/ (void) 0)
#endif

/* @assert.h omit end@  */

#endif

```

`devices/display/qxl/meson.build`:

```build
mvisor_sources += files(
  'qxl.cc',
  'qxl.h',
  'qxl_render.cc',
  'qxl_render.h',
  'qxl_modes.h',
  'qxl_parser.cc',
  'qxl_parser.h'
)

proto_sources += proto_gen.process(
  'qxl.proto'
)

mvisor_deps += [
  dependency('zlib'),
  dependency('glib-2.0', version: '>= 2.38')
]

subdir('canvas')

```

`devices/display/qxl/qxl.cc`:

```cc
/* 
 * MVisor QXL
 * Support latest Linux & Windows QXLDoD
 * 
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include <cstring>
#include <algorithm>

#include <zlib.h>
#include <sys/mman.h>

#include "qxl.h"
#include "qxl_render.h"
#include "qxl_modes.h"
#include "qxl.pb.h"
#include "logger.h"


Qxl::Qxl() {
  default_rom_path_ = "../share/vgabios-qxl.bin";
  pci_header_.vendor_id = 0x1B36;
  pci_header_.device_id = 0x0100;
  pci_header_.revision_id = 5;
  pci_header_.irq_pin = 1;
  
  /* Bar 1: Windows driver uses this block of memory as a normal memslot
    * Linux driver named it surface RAM */
  qxl_vram32_size_ = _MB(16);
  qxl_vram32_base_ = (uint8_t*)mmap(nullptr, qxl_vram32_size_, PROT_READ | PROT_WRITE,
    MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0);
  pci_bars_[1].host_memory = qxl_vram32_base_;

  MV_ASSERT(madvise(qxl_vram32_base_, qxl_vram32_size_, MADV_DONTDUMP) == 0);

  /* Bar 2: 8KB ROM */
  qxl_rom_size_ = 8192;
  qxl_rom_base_ = valloc(qxl_rom_size_);
  pci_bars_[2].host_memory = qxl_rom_base_;

  AddPciBar(1, qxl_vram32_size_, kIoResourceTypeRam); /* QXL VRAM32 8MB */
  AddPciBar(2, 8192, kIoResourceTypeRam);             /* QXL ROM */
  AddPciBar(3, 32, kIoResourceTypePio);               /* QXL PIO */

  render_ = new QxlRender(this);
}

Qxl::~Qxl() {
  /* Destroy renderer */
  delete render_;

  if (qxl_vram32_base_) {
    munmap(qxl_vram32_base_, qxl_vram32_size_);
  }
  if (qxl_rom_base_) {
    free(qxl_rom_base_);
  }
}

void Qxl::Connect() {
  Vga::Connect();

  /* Push all free resources to the ring before saving VM */
  auto machine = manager_->machine();
  state_change_listener_ = machine->RegisterStateChangeListener([=]() {
    if (machine->IsPaused()) {
      FreeGuestResources();
    }
  });
}

void Qxl::Disconnect() {
  manager_->machine()->UnregisterStateChangeListener(&state_change_listener_);

  Vga::Disconnect();
}

void Qxl::Reset() {
  std::lock_guard<std::recursive_mutex> render_lock(render_mutex_);

  /* Vga Reset() resets mode */
  Vga::Reset();

  IntializeQxlRom();
  IntializeQxlRam();

  delete render_;
  render_ = new QxlRender(this);

  bzero(guest_slots_, sizeof(guest_slots_));
  primary_surface_.active = false;
  current_cursor_.visible = false;
  free_resources_.clear();
}

bool Qxl::SaveState(MigrationWriter* writer) {
  /* We have added all free resources to release ring when VM pause */
  MV_ASSERT(free_resources_.empty());

  QxlState state;
  for (int i = 0; i < NUM_MEMSLOTS; i++) {
    auto slot = state.add_guest_slots();
    slot->set_mem_start(guest_slots_[i].slot.mem_start);
    slot->set_mem_end(guest_slots_[i].slot.mem_end);
    slot->set_active(guest_slots_[i].active);
  }

  if (primary_surface_.active) {
    auto primary = state.mutable_guest_primary();
    auto& surface_create = qxl_ram_->create_surface;
    primary->set_width(surface_create.width);
    primary->set_height(surface_create.height);
    primary->set_stride(surface_create.stride);
    primary->set_format(surface_create.format);
    primary->set_position(surface_create.position);
    primary->set_mouse_mode(surface_create.mouse_mode);
    primary->set_flags(surface_create.flags);
    primary->set_type(surface_create.type);
    primary->set_mem_address(surface_create.mem);
  }

  /* surfaces are not used now, but save it any way */
  auto& surfaces = render_->surfaces();
  for (auto it = surfaces.begin(); it != surfaces.end(); it++) {
    if (it->first == 0)
      continue;
    auto& surface = it->second;
    auto sf = state.add_surfaces();
    sf->set_id(surface.id);
    sf->set_slot_address(surface.slot_address);
  }

  writer->WriteProtobuf("QXL", state);
  writer->WriteMemoryPages("VRAM32", qxl_vram32_base_, qxl_vram32_size_);
  return Vga::SaveState(writer);
}

/* Reset should be called before load state */
bool Qxl::LoadState(MigrationReader* reader) {
  if (!Vga::LoadState(reader)) {
    return false;
  }

  if (!reader->ReadMemoryPages("VRAM32", (void**)&qxl_vram32_base_, qxl_vram32_size_)) {
    return false;
  }

  QxlState state;
  if (!reader->ReadProtobuf("QXL", state)) {
    return false;
  }
  for (int i = 0; i < NUM_MEMSLOTS && i < state.guest_slots_size(); i++) {
    auto& slot = state.guest_slots(i);
    if (slot.active()) {
      QXLMemSlot mem_slot = {
        .mem_start = slot.mem_start(),
        .mem_end = slot.mem_end()
      };
      AddMemSlot(i, mem_slot);
    }
  }

  for (int i = 0; i < state.surfaces_size(); i++) {
    auto& sf = state.surfaces(i);
    if (sf.id() == 0) {
      MV_ERROR("invalid surface id %u", sf.id());
      continue;
    }
    render_->ParseSurfaceCommand(sf.slot_address());
  }

  if (state.has_guest_primary()) {
    primary_surface_.active = true;
    render_->CreatePrimarySurface(qxl_ram_->create_surface, false);
    UpdateDisplayMode();

    for (int i = 0; i < state.drawbles_size(); i++) {
      auto& dr = state.drawbles(i);
      render_->ParseDrawCommand(dr.slot_address());
    }
  
    /* push update event after loaded */
    Schedule([this]() {
      NotifyDisplayUpdate();
    });
  }
  return true;
}

void Qxl::IntializeQxlRom() {
  bzero(qxl_rom_base_, qxl_rom_size_);

  QXLRom* rom = (QXLRom*)qxl_rom_base_;
  QXLModes* modes = (QXLModes*)(rom + 1);
  rom->magic = QXL_ROM_MAGIC;
  rom->id = 0;
  rom->log_level = 0; /* Guest debug */
  rom->modes_offset = sizeof(QXLRom);

  rom->slot_gen_bits = MEMSLOT_GENERATION_BITS;
  rom->slot_id_bits = MEMSLOT_SLOT_BITS;
  rom->slots_start = 1;
  rom->slots_end = NUM_MEMSLOTS - 1;
  rom->n_surfaces = 1024;

  uint32_t n = 0;
  for (size_t i = 0; i < sizeof(qxl_modes) / sizeof(qxl_modes[0]); i++) {
    size_t size_needed = qxl_modes[i].y_res * qxl_modes[i].stride;
    if (size_needed > vga_mem_size_) {
      continue;
    }
    modes->modes[n] = qxl_modes[i];
    modes->modes[n].id = i;
    n++;
  }
  modes->n_modes = n;

  uint32_t ram_header_size = SPICE_ALIGN(sizeof(QXLRam), 4096);
  uint32_t surface0_area_size = SPICE_ALIGN(vga_mem_size_, 4096);
  uint32_t num_pages = (vram_size_ - ram_header_size - surface0_area_size) / PAGE_SIZE;
  MV_ASSERT(ram_header_size + surface0_area_size <= vram_size_);

  rom->draw_area_offset = 0;
  rom->surface0_area_size = surface0_area_size;
  rom->pages_offset = surface0_area_size;
  rom->num_pages = num_pages;
  rom->ram_header_offset = vram_size_ - ram_header_size;

  qxl_rom_ = rom;
  qxl_modes_ = modes;
}

void Qxl::IntializeQxlRam() {
  qxl_ram_ = (QXLRam*)(vram_base_ + qxl_rom_->ram_header_offset);
  qxl_ram_->magic = QXL_RAM_MAGIC;
  qxl_ram_->int_pending = 0;
  qxl_ram_->int_mask = 0;
  qxl_ram_->update_surface = 0;
  qxl_ram_->monitors_config = 0;
  SPICE_RING_INIT(&qxl_ram_->cmd_ring);
  SPICE_RING_INIT(&qxl_ram_->cursor_ring);
  SPICE_RING_INIT(&qxl_ram_->release_ring);
}

/* Setup ioeventfd for notify commands, reduce IO operations */
bool Qxl::ActivatePciBar(uint8_t index) {
  if (index == 3) {
    manager_->RegisterIoEvent(this, kIoResourceTypePio, pci_bars_[index].address + QXL_IO_NOTIFY_CMD);
    manager_->RegisterIoEvent(this, kIoResourceTypePio, pci_bars_[index].address + QXL_IO_NOTIFY_CURSOR);
  }
  return Vga::ActivatePciBar(index);
}

bool Qxl::DeactivatePciBar(uint8_t index) {
  if (index == 3) {
    manager_->UnregisterIoEvent(this, kIoResourceTypePio, pci_bars_[index].address + QXL_IO_NOTIFY_CMD);
    manager_->UnregisterIoEvent(this, kIoResourceTypePio, pci_bars_[index].address + QXL_IO_NOTIFY_CURSOR);
  }
  return Vga::DeactivatePciBar(index);
}

void Qxl::UpdateDisplayMode() {
  /* Prevent from calling AcquireUpdate() when setting mode */
  if (primary_surface_.active) {
    auto& create = qxl_ram_->create_surface;
    if (mode_ == kDisplayQxlMode && width_ == (int)create.width && height_ == (int)create.height &&
      bpp_ == GetBitsPerPixelByFormat(create.format)) {
      return;
    }
    mode_ = kDisplayQxlMode;
    width_ = create.width;
    height_ = create.height;
    stride_ = create.stride;
    bpp_ = GetBitsPerPixelByFormat(create.format);

    NotifyDisplayModeChange();
  } else {
    Vga::UpdateDisplayMode();
  }
}

void Qxl::SetInterrupt(uint32_t interrupt) {
  auto old_pending = __atomic_fetch_or(&qxl_ram_->int_pending, interrupt, __ATOMIC_SEQ_CST);
  if (old_pending & interrupt)
    return;
  UpdateIrqLevel();
}

void Qxl::UpdateIrqLevel() {
  int level = !!(qxl_ram_->int_pending & qxl_ram_->int_mask);
  SetIrq(level);
}

/* Display resize interface */
bool Qxl::Resize(int width, int height) {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  /*
    * Older windows drivers set int_mask to 0 when their ISR is called,
    * then later set it to ~0. So it doesn't relate to the actual interrupts
    * handled. However, they are old, so clearly they don't support this
    * interrupt
    */
  if (qxl_ram_->int_mask == 0 || qxl_ram_->int_mask == ~0u ||
    !(qxl_ram_->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {
    return false;
  }

  /* This should return true if QXL is capable of sending interrupts to config monitors */
  if (mode_ != kDisplayQxlMode || !width || !height) {
    return true;
  }

  Schedule([=]() {
    bzero(&qxl_rom_->client_monitors_config, sizeof(qxl_rom_->client_monitors_config));
    qxl_rom_->client_monitors_config.count = 1;
    auto& head = qxl_rom_->client_monitors_config.heads[0];
    head.left = 0;
    head.top = 0;
    head.right = head.left + width;
    head.bottom = head.top + height;
    qxl_rom_->client_monitors_config_crc = crc32(0xFFFFFFFF,
      (uint8_t*)&qxl_rom_->client_monitors_config, sizeof(qxl_rom_->client_monitors_config)) ^ 0xFFFFFFFF;
    SetInterrupt(QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);
  });

  return true;
}

uint64_t Qxl::TranslateAsyncCommand(uint64_t command, bool* async) {
  *async = true;
  switch (command)
  {
  case QXL_IO_UPDATE_AREA_ASYNC:
    command = QXL_IO_UPDATE_AREA;
    break;
  case QXL_IO_MEMSLOT_ADD_ASYNC:
    command = QXL_IO_MEMSLOT_ADD;
    break;
  case QXL_IO_CREATE_PRIMARY_ASYNC:
    command = QXL_IO_CREATE_PRIMARY;
    break;
  case QXL_IO_DESTROY_PRIMARY_ASYNC:
    command = QXL_IO_DESTROY_PRIMARY;
    break;
  case QXL_IO_DESTROY_SURFACE_ASYNC:
    command = QXL_IO_DESTROY_SURFACE_WAIT;
    break;
  case QXL_IO_DESTROY_ALL_SURFACES_ASYNC:
    command = QXL_IO_DESTROY_ALL_SURFACES;
    break;
  case QXL_IO_FLUSH_SURFACES_ASYNC:
  case QXL_IO_MONITORS_CONFIG_ASYNC:
    break;
  default:
    *async = false;
    break;
  }
  return command;
}

void Qxl::ParseControlCommand(uint64_t command, uint32_t argument) {
  std::lock_guard<std::recursive_mutex> render_lock(render_mutex_);
  switch (command) {
  case QXL_IO_UPDATE_AREA:
    FetchCommands();
    render_->UpdateArea(qxl_ram_->update_area, qxl_ram_->update_surface);
    NotifyDisplayUpdate();
    break;
  case QXL_IO_NOTIFY_OOM:
    MV_LOG("QXL_IO_NOTIFY_OOM");
    FlushCommandsAndResources();
    break;
  case QXL_IO_RESET:
    Reset();
    UpdateIrqLevel();
    break;
  case QXL_IO_LOG:
    if (!qxl_ram_->log_buf[0]) {
      MV_LOG("QXL_IO_LOG", qxl_ram_->log_buf);
    }
    break;
  case QXL_IO_MEMSLOT_ADD:
    MV_ASSERT(argument < NUM_MEMSLOTS);
    MV_ASSERT(!guest_slots_[argument].active);
    AddMemSlot(argument, qxl_ram_->mem_slot);
    break;
  case QXL_IO_MEMSLOT_DEL:
    DeleteMemSlot(argument);
    break;
  case QXL_IO_CREATE_PRIMARY:
    render_->CreatePrimarySurface(qxl_ram_->create_surface, true);
    primary_surface_.active = true;
    UpdateDisplayMode();
    break;
  case QXL_IO_DESTROY_PRIMARY:
    FlushCommandsAndResources();
    if (primary_surface_.active) {
      render_->DestroyPrimarySurface();
      primary_surface_.active = false;
      mode_ = kDisplayUnknownMode;
    }
    break;
  case QXL_IO_DESTROY_ALL_SURFACES:
    FlushCommandsAndResources();
    delete render_;
    render_ = new QxlRender(this);
    break;
  case QXL_IO_FLUSH_SURFACES_ASYNC:
    if (debug_) {
      MV_LOG("QXL_IO_FLUSH_SURFACES_ASYNC");
    }
    break;
  case QXL_IO_MONITORS_CONFIG_ASYNC:
    if (debug_) {
      MV_LOG("QXL_IO_MONITORS_CONFIG_ASYNC");
    }
    break;
  case QXL_IO_FLUSH_RELEASE:
    FreeGuestResources();
    break;
  default:
    MV_PANIC("unhandled QXL command=0x%lx", command);
    break;
  }
}

void Qxl::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[3].address) {
    /* ignore all reads to the QXL io ports */
    memset(data, 0xFF, size);
  } else {
    Vga::Read(resource, offset, data, size);
  }
}

void Qxl::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[3].address) {
    bool async;
    uint64_t command = TranslateAsyncCommand(offset, &async);
    switch (command)
    {
    case QXL_IO_NOTIFY_CMD:
    case QXL_IO_NOTIFY_CURSOR:
      NotifyDisplayUpdate();
      break;
    case QXL_IO_UPDATE_IRQ:
      UpdateIrqLevel();
      break;
    default:
      ParseControlCommand(command, data[0]);
    }

    if (async) {
      /* Async command needs interrupt */
      Schedule([this]() {
        SetInterrupt(QXL_INTERRUPT_IO_CMD);
      });
    }
  } else {
    Vga::Write(resource, offset, data, size);
  }
}

void Qxl::FlushCommandsAndResources() {
  /* Fetch any commands on ring */
  flushing_commands_ = true;
  FetchCommands();
  flushing_commands_ = false;

  /* Free released resources */
  FreeGuestResources();
}

void Qxl::AddMemSlot(int slot_id, QXLMemSlot& slot) {
  int bar_index;
  for (bar_index = 0; bar_index < PCI_BAR_NUMS; bar_index++) {
    if (!pci_bars_[bar_index].active)
      continue;
    if (slot.mem_start >= pci_bars_[bar_index].address &&
      slot.mem_end <= pci_bars_[bar_index].address + pci_bars_[bar_index].size) {
      break;
    }
  }
  if (bar_index == PCI_BAR_NUMS) {
    MV_PANIC("Invalid slot %d 0x%lx-0x%lx", slot_id, slot.mem_start, slot.mem_end);
    return;
  }

  guest_slots_[slot_id].slot = slot;
  guest_slots_[slot_id].offset = slot.mem_start - pci_bars_[bar_index].address;
  guest_slots_[slot_id].hva = (uint8_t*)pci_bars_[bar_index].host_memory + guest_slots_[slot_id].offset;
  guest_slots_[slot_id].active = true;
  if (debug_) {
    MV_LOG("add QXL memslot %d bar=%d 0x%lx-0x%lx", slot_id, bar_index, slot.mem_start, slot.mem_end);
  }
}

void Qxl::DeleteMemSlot(int slot_id) {
  guest_slots_[slot_id].active = false;
}

int Qxl::GetBitsPerPixelByFormat(uint32_t format) {
  switch (format)
  {
  case SPICE_SURFACE_FMT_32_xRGB:
  case SPICE_SURFACE_FMT_32_ARGB:
    return 32;
  default:
    MV_ERROR("unsupported format=0x%x", format);
    return 0;
  }
}

void* Qxl::GetMemSlotAddress(uint64_t data) {
  uint64_t slot_id = data >> (64 - qxl_rom_->slot_id_bits);
  MV_ASSERT(slot_id < NUM_MEMSLOTS);

  uint64_t generation_mask = ((1UL << qxl_rom_->slot_gen_bits) - 1);
  uint64_t generation_shift = 64 - qxl_rom_->slot_id_bits - qxl_rom_->slot_gen_bits;
  uint64_t generation = (data >> generation_shift) & generation_mask;
  MV_ASSERT(generation == qxl_rom_->slot_generation);

  uint64_t virtual_mask = (1UL << generation_shift) - 1;
  return guest_slots_[slot_id].hva + (data & virtual_mask);
}

size_t Qxl::GetMemSlotChunkData(uint64_t data, std::vector<iovec>& vector) {
  size_t size = 0;
  while (data) {
    QXLDataChunk* chunk = (QXLDataChunk*)GetMemSlotAddress(data);
    vector.emplace_back(iovec {
      .iov_base = chunk->data,
      .iov_len = chunk->data_size
    });
    size += chunk->data_size;
    data = chunk->next_chunk;
  }
  return size;
}

size_t Qxl::GetMemSlotChunkData(QXLDataChunk* chunk, std::vector<iovec>& vector) {
  size_t size = 0;
  while (chunk) {
    vector.emplace_back(iovec {
      .iov_base = chunk->data,
      .iov_len = chunk->data_size
    });
    size += chunk->data_size;
    if (chunk->next_chunk) {
      chunk = (QXLDataChunk*)GetMemSlotAddress(chunk->next_chunk);
    } else {
      chunk = nullptr;
    }
  }
  return size;
}

void Qxl::GetMemSlotLinearizedChunkData(QXLDataChunk* chunk, std::string& data) {
  std::vector<iovec> v;
  size_t size = GetMemSlotChunkData(chunk, v);
  data.resize(size);
  size_t offset = 0;
  for (auto& iov : v) {
    memcpy(data.data() + offset, iov.iov_base, iov.iov_len);
    offset += iov.iov_len;
  }
}

void Qxl::FreeGuestResources() {
  if (flushing_commands_ || free_resources_.empty()) {
    return;
  }

  QXLReleaseRing* ring = &qxl_ram_->release_ring;
  if (ring->prod - ring->cons == ring->num_items - 1) {
    return; // ring is full
  }

  auto *el = SPICE_RING_PROD_ITEM(ring);
  /* Careful! Union member info->id and info->next have same guest address */
  *el = free_resources_.front()->id;
  for (auto it = free_resources_.begin(); it != free_resources_.end(); it++) {
    if (it + 1 == free_resources_.end()) {
      (*it)->next = 0;
    } else {
      (*it)->next = (*(it + 1))->id;
    }
  }

  bool should_notify;
  SPICE_RING_PUSH(ring, should_notify);
  if (should_notify) {
    SetInterrupt(QXL_INTERRUPT_DISPLAY);
  }
  free_resources_.clear();
}

void Qxl::ReleaseGuestResource(QXLReleaseInfo* info) {
  free_resources_.push_back(info);

  if (free_resources_.size() >= 32) {
    FreeGuestResources();
  }
}

/* Lock the drawables and translate to display partial bitmaps */
bool Qxl::AcquireUpdate(DisplayUpdate& update, bool redraw) {
  std::unique_lock<std::recursive_mutex>  lock(mutex_);
  std::lock_guard<std::recursive_mutex>   render_lock(render_mutex_);
  if (mode_ != kDisplayQxlMode) {
    return Vga::AcquireUpdate(update, redraw);
  }

  /* We cannot hold the device lock for so long, here switch to render lock */
  lock.unlock();

  if (!manager_->machine()->IsPaused()) {
    FetchCommands();
  }

  if (redraw) {
    render_->Redraw();
  }
  render_->GetUpdatePartials(update.partials);
  update.cursor = current_cursor_;
  return true;
}

/* Update the drawing drawables to drawed */
void Qxl::ReleaseUpdate() {
  std::lock_guard<std::recursive_mutex> lock(mutex_);
  if (mode_ != kDisplayQxlMode) {
    return Vga::ReleaseUpdate();
  }
}

void Qxl::FetchCommands() {
  QXLCommand command;
  while (FetchGraphicsCommand(command)) {
    switch (command.type)
    {
    case QXL_CMD_SURFACE:
      render_->ParseSurfaceCommand(command.data);
      break;
    case QXL_CMD_DRAW:
      render_->ParseDrawCommand(command.data);
      break;
    default:
      MV_PANIC("unhandled command type=0x%x data=0x%lx", command.type, command.data);
      break;
    }
  }

  while (FetchCursorCommand(command)) {
    MV_ASSERT(command.type == QXL_CMD_CURSOR);
    ParseCursorCommand(command.data);
  }
}

bool Qxl::FetchGraphicsCommand(QXLCommand& command) {
  QXLCommandRing* ring = &qxl_ram_->cmd_ring;
  if (!SPICE_RING_IS_EMPTY(ring)) {
    command = *SPICE_RING_CONS_ITEM(ring);

    bool should_notify;
    SPICE_RING_POP(ring, should_notify);
    if (should_notify) {
      SetInterrupt(QXL_INTERRUPT_DISPLAY);
    }
    bool should_wait;
    SPICE_RING_CONS_WAIT(ring, should_wait);
    return true;
  }
  return false;
}

bool Qxl::FetchCursorCommand(QXLCommand& command) {
  QXLCursorRing* ring = &qxl_ram_->cursor_ring;
  if (!SPICE_RING_IS_EMPTY(ring)) {
    command = *SPICE_RING_CONS_ITEM(ring);
    bool should_notify;
    SPICE_RING_POP(ring, should_notify);
    if (should_notify) {
      SetInterrupt(QXL_INTERRUPT_CURSOR);
    }
    bool should_wait;
    SPICE_RING_CONS_WAIT(ring, should_wait);
    return true;
  }
  return false;
}

void Qxl::ParseCursorCommand(uint64_t slot_address) {
  auto cursor_cmd = (QXLCursorCmd*)GetMemSlotAddress(slot_address);
  switch (cursor_cmd->type)
  {
  case QXL_CURSOR_HIDE:
    current_cursor_.visible = false;
    ++current_cursor_.update_timestamp;
    break;
  case QXL_CURSOR_MOVE:
    current_cursor_.visible = true;
    current_cursor_.x = cursor_cmd->u.position.x;
    current_cursor_.y = cursor_cmd->u.position.y;
    ++current_cursor_.update_timestamp;
    break;
  case QXL_CURSOR_SET: {
    QXLCursor* cursor = (QXLCursor*)GetMemSlotAddress(cursor_cmd->u.set.shape);
    current_cursor_.visible = cursor_cmd->u.set.visible;
    current_cursor_.x = cursor_cmd->u.set.position.x;
    current_cursor_.y = cursor_cmd->u.set.position.y;

    auto& shape = current_cursor_.shape;
    shape.type = cursor->header.type;
    shape.width = cursor->header.width;
    shape.height = cursor->header.height;
    shape.hotspot_x = cursor->header.hot_spot_x;
    shape.hotspot_y = cursor->header.hot_spot_y;
  
    /* Linearize chunked data */
    GetMemSlotLinearizedChunkData(&cursor->chunk, shape.data);

    ++shape.id;
    ++current_cursor_.update_timestamp;
    break;
  }
  default:
    MV_HEXDUMP("unhandled cursor", cursor_cmd, sizeof(*cursor_cmd));
    break;
  }

  ReleaseGuestResource(&cursor_cmd->release_info);
}


DECLARE_DEVICE(Qxl);

```

`devices/display/qxl/qxl.h`:

```h
/* 
 * MVisor QXL
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * Copy and modified from QEMU
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_QXL_H
#define _MVISOR_DEVICES_QXL_H

#include "../vga.h"

#include <list>
#include <vector>
#include <mutex>

#include "qxl_dev.h"
#include "machine.h"


#define NUM_MEMSLOTS 8
#define MEMSLOT_GENERATION_BITS 8
#define MEMSLOT_SLOT_BITS 8

struct PrimarySurface {
  bool            active;
};


class QxlRender;
class Qxl : public Vga, public DisplayResizeInterface {
 private:
  uint32_t  qxl_rom_size_ = 0;
  void*     qxl_rom_base_ = nullptr;
  uint32_t  qxl_vram32_size_ = 0;
  uint8_t*  qxl_vram32_base_ = nullptr;

  QXLRom*   qxl_rom_ = nullptr;
  QXLModes* qxl_modes_ = nullptr;
  QXLRam*   qxl_ram_ = nullptr;

  struct guest_slots {
    QXLMemSlot    slot;
    uint64_t      offset;
    bool          active;
    uint8_t*      hva; 
  } guest_slots_[NUM_MEMSLOTS];

  PrimarySurface                primary_surface_;
  std::vector<QXLReleaseInfo*>  free_resources_;
  DisplayMouseCursor            current_cursor_;
  const StateChangeListener*    state_change_listener_ = nullptr;

  QxlRender*                    render_ = nullptr;
  std::recursive_mutex          render_mutex_;
  bool                          flushing_commands_ = false;

 public:
  Qxl();
  virtual ~Qxl();
  virtual void Connect();
  virtual void Disconnect();
  virtual void Reset();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);

  // Interfaces
  virtual bool AcquireUpdate(DisplayUpdate& update, bool redraw);
  virtual void ReleaseUpdate();
  virtual bool Resize(int width, int height);

  // QxlRender make use of these methods
  void* GetMemSlotAddress(uint64_t data);
  void ReleaseGuestResource(QXLReleaseInfo* info);
  int GetBitsPerPixelByFormat(uint32_t format);
  size_t GetMemSlotChunkData(uint64_t data, std::vector<iovec>& vector);
  size_t GetMemSlotChunkData(QXLDataChunk* chunk, std::vector<iovec>& vector);
  void GetMemSlotLinearizedChunkData(QXLDataChunk* chunk, std::string& data);

 private:
  virtual bool ActivatePciBar(uint8_t index);
  virtual bool DeactivatePciBar(uint8_t index);
  virtual void UpdateDisplayMode();

  void IntializeQxlRom();
  void IntializeQxlRam();
  void SetInterrupt(uint32_t interrupt);
  void UpdateIrqLevel();
  uint64_t TranslateAsyncCommand(uint64_t command, bool* async);
  void ParseControlCommand(uint64_t command, uint32_t argument);
  void FlushCommandsAndResources();
  void AddMemSlot(int slot_id, QXLMemSlot& slot);
  void DeleteMemSlot(int slot_id);
  void FreeGuestResources();
  void FetchCommands();
  bool FetchGraphicsCommand(QXLCommand& command);
  bool FetchCursorCommand(QXLCommand& command);
  void ParseSurfaceCommand(uint64_t slot_address);
  void ParseCursorCommand(uint64_t slot_address);
};



#endif // _MVISOR_DEVICES_QXL_H

```

`devices/display/qxl/qxl.proto`:

```proto
syntax = "proto3";

message QxlState {
  message GuestSlot {
    uint64  mem_start           = 1;
    uint64  mem_end             = 2;
    bool    active              = 3;
  }

  message GuestPrimary {
    uint32  width               = 1;
    uint32  height              = 2;
    int32   stride              = 3;
    uint32  format              = 4;
    uint32  position            = 5;
    uint32  mouse_mode          = 6;
    uint32  flags               = 7;
    uint32  type                = 8;
    uint64  mem_address         = 9;
  }

  message Surface {
    uint32  id                  = 1;
    uint64  slot_address        = 2;
  }

  message Drawable {
    uint64  slot_address        = 1;
  }

  repeated GuestSlot  guest_slots         = 2;
  GuestPrimary        guest_primary       = 3;
  repeated uint64     free_resources      = 5;
  repeated Surface    surfaces            = 6;
  repeated Drawable   drawbles            = 7;
}

```

`devices/display/qxl/qxl_dev.h`:

```h
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef _H_QXL_DEV
#define _H_QXL_DEV

#include <spice/types.h>
#include <spice/barrier.h>
#include <spice/ipc_ring.h>
#include <spice/enums.h>
#include <spice/macros.h>

#include <spice/start-packed.h>

#define REDHAT_PCI_VENDOR_ID 0x1b36

/* 0x100-0x11f reserved for spice, 0x1ff used for unstable work */
#define QXL_DEVICE_ID_STABLE 0x0100

enum {
    QXL_REVISION_STABLE_V04=0x01,
    QXL_REVISION_STABLE_V06=0x02,
    QXL_REVISION_STABLE_V10=0x03,
    QXL_REVISION_STABLE_V12=0x04,
};

#define QXL_DEVICE_ID_DEVEL 0x01ff
#define QXL_REVISION_DEVEL 0x01

#define QXL_ROM_MAGIC SPICE_MAGIC_CONST("QXRO")
#define QXL_RAM_MAGIC SPICE_MAGIC_CONST("QXRA")

enum {
    QXL_RAM_RANGE_INDEX,
    QXL_VRAM_RANGE_INDEX,
    QXL_ROM_RANGE_INDEX,
    QXL_IO_RANGE_INDEX,

    QXL_PCI_RANGES
};

/* qxl-1 compat: append only */
enum {
    QXL_IO_NOTIFY_CMD,
    QXL_IO_NOTIFY_CURSOR,
    QXL_IO_UPDATE_AREA,
    QXL_IO_UPDATE_IRQ,
    QXL_IO_NOTIFY_OOM,
    QXL_IO_RESET,
    QXL_IO_SET_MODE,                  /* qxl-1 */
    QXL_IO_LOG,
    /* appended for qxl-2 */
    QXL_IO_MEMSLOT_ADD,
    QXL_IO_MEMSLOT_DEL,
    QXL_IO_DETACH_PRIMARY,
    QXL_IO_ATTACH_PRIMARY,
    QXL_IO_CREATE_PRIMARY,
    QXL_IO_DESTROY_PRIMARY,
    QXL_IO_DESTROY_SURFACE_WAIT,
    QXL_IO_DESTROY_ALL_SURFACES,
    /* appended for qxl-3 */
    QXL_IO_UPDATE_AREA_ASYNC,
    QXL_IO_MEMSLOT_ADD_ASYNC,
    QXL_IO_CREATE_PRIMARY_ASYNC,
    QXL_IO_DESTROY_PRIMARY_ASYNC,
    QXL_IO_DESTROY_SURFACE_ASYNC,
    QXL_IO_DESTROY_ALL_SURFACES_ASYNC,
    QXL_IO_FLUSH_SURFACES_ASYNC,
    QXL_IO_FLUSH_RELEASE,
    /* appended for qxl-4 */
    QXL_IO_MONITORS_CONFIG_ASYNC,

    QXL_IO_RANGE_SIZE
};

typedef uint64_t QXLPHYSICAL;
typedef int32_t QXLFIXED; //fixed 28.4

typedef struct SPICE_ATTR_PACKED QXLPointFix {
    QXLFIXED x;
    QXLFIXED y;
} QXLPointFix;

typedef struct SPICE_ATTR_PACKED QXLPoint {
    int32_t x;
    int32_t y;
} QXLPoint;

typedef struct SPICE_ATTR_PACKED QXLPoint16 {
    int16_t x;
    int16_t y;
} QXLPoint16;

typedef struct SPICE_ATTR_PACKED QXLRect {
    int32_t top;
    int32_t left;
    int32_t bottom;
    int32_t right;
} QXLRect;

typedef struct SPICE_ATTR_PACKED QXLURect {
    uint32_t top;
    uint32_t left;
    uint32_t bottom;
    uint32_t right;
} QXLURect;

/* qxl-1 compat: append only */
typedef struct SPICE_ATTR_PACKED QXLRom {
    uint32_t magic;
    uint32_t id;
    uint32_t update_id;
    uint32_t compression_level;
    uint32_t log_level;
    uint32_t mode;                    /* qxl-1 */
    uint32_t modes_offset;
    uint32_t num_pages;
    uint32_t pages_offset;            /* qxl-1 */
    uint32_t draw_area_offset;        /* qxl-1 */
    uint32_t surface0_area_size;      /* qxl-1 name: draw_area_size */
    uint32_t ram_header_offset;
    uint32_t mm_clock;
    /* appended for qxl-2 */
    uint32_t n_surfaces;
    uint64_t flags;
    uint8_t slots_start;
    uint8_t slots_end;
    uint8_t slot_gen_bits;
    uint8_t slot_id_bits;
    uint8_t slot_generation;
    /* appended for qxl-4 */
    uint8_t client_present;
    uint8_t client_capabilities[58];
    uint32_t client_monitors_config_crc;
    struct {
        uint16_t count;
        uint16_t padding;
        QXLURect heads[64];
    } client_monitors_config;
} QXLRom;

#define CLIENT_MONITORS_CONFIG_CRC32_POLY 0xedb88320

/* qxl-1 compat: fixed */
typedef struct SPICE_ATTR_PACKED QXLMode {
    uint32_t id;
    uint32_t x_res;
    uint32_t y_res;
    uint32_t bits;
    uint32_t stride;
    uint32_t x_mili;
    uint32_t y_mili;
    uint32_t orientation;
} QXLMode;

/* qxl-1 compat: fixed */
typedef struct SPICE_ATTR_PACKED QXLModes {
    uint32_t n_modes;
    QXLMode modes[0];
} QXLModes;

/* qxl-1 compat: append only */
typedef enum QXLCmdType {
    QXL_CMD_NOP,
    QXL_CMD_DRAW,
    QXL_CMD_UPDATE,
    QXL_CMD_CURSOR,
    QXL_CMD_MESSAGE,
    QXL_CMD_SURFACE,
} QXLCmdType;

/* qxl-1 compat: fixed */
typedef struct SPICE_ATTR_PACKED QXLCommand {
    QXLPHYSICAL data;
    uint32_t type;
    uint32_t padding;
} QXLCommand;

#define QXL_COMMAND_FLAG_COMPAT          (1<<0)
#define QXL_COMMAND_FLAG_COMPAT_16BPP    (2<<0)

typedef struct SPICE_ATTR_PACKED QXLCommandExt {
    QXLCommand cmd;
    uint32_t group_id;
    uint32_t flags;
} QXLCommandExt;

typedef struct SPICE_ATTR_PACKED QXLMemSlot {
    uint64_t mem_start;
    uint64_t mem_end;
} QXLMemSlot;

#define QXL_SURF_TYPE_PRIMARY      0

#define QXL_SURF_FLAG_KEEP_DATA    (1 << 0)

typedef struct SPICE_ATTR_PACKED QXLSurfaceCreate {
    uint32_t width;
    uint32_t height;
    int32_t stride;
    uint32_t format;
    uint32_t position;
    uint32_t mouse_mode;
    uint32_t flags;
    uint32_t type;
    QXLPHYSICAL mem;
} QXLSurfaceCreate;

#define QXL_COMMAND_RING_SIZE 32
#define QXL_CURSOR_RING_SIZE 32
#define QXL_RELEASE_RING_SIZE 8

SPICE_RING_DECLARE(QXLCommandRing, QXLCommand, QXL_COMMAND_RING_SIZE);
SPICE_RING_DECLARE(QXLCursorRing, QXLCommand, QXL_CURSOR_RING_SIZE);

SPICE_RING_DECLARE(QXLReleaseRing, uint64_t, QXL_RELEASE_RING_SIZE);

#define QXL_LOG_BUF_SIZE 4096

#define QXL_INTERRUPT_DISPLAY (1 << 0)
#define QXL_INTERRUPT_CURSOR (1 << 1)
#define QXL_INTERRUPT_IO_CMD (1 << 2)
#define QXL_INTERRUPT_ERROR  (1 << 3)
#define QXL_INTERRUPT_CLIENT (1 << 4)
#define QXL_INTERRUPT_CLIENT_MONITORS_CONFIG  (1 << 5)

/* qxl-1 compat: append only */
typedef struct SPICE_ATTR_ALIGNED(4) SPICE_ATTR_PACKED QXLRam {
    uint32_t magic;
    uint32_t int_pending;
    uint32_t int_mask;
    uint8_t log_buf[QXL_LOG_BUF_SIZE];
    QXLCommandRing cmd_ring;
    QXLCursorRing cursor_ring;
    QXLReleaseRing release_ring;
    QXLRect update_area;
    /* appended for qxl-2 */
    uint32_t update_surface;
    QXLMemSlot mem_slot;
    QXLSurfaceCreate create_surface;
    uint64_t flags;

    /* appended for qxl-4 */

    /* used by QXL_IO_MONITORS_CONFIG_ASYNC */
    QXLPHYSICAL monitors_config;

} QXLRam;

typedef union SPICE_ATTR_PACKED QXLReleaseInfo {
    uint64_t id;      // in
    uint64_t next;    // out
} QXLReleaseInfo;

typedef struct  SPICE_ATTR_PACKED QXLDataChunk {
    uint32_t data_size;
    QXLPHYSICAL prev_chunk;
    QXLPHYSICAL next_chunk;
    uint8_t data[0];
} QXLDataChunk;

typedef struct SPICE_ATTR_PACKED QXLMessage {
    QXLReleaseInfo release_info;
    uint8_t data[0];
} QXLMessage;

typedef struct SPICE_ATTR_PACKED QXLCompatUpdateCmd {
    QXLReleaseInfo release_info;
    QXLRect area;
    uint32_t update_id;
} QXLCompatUpdateCmd;

typedef struct SPICE_ATTR_PACKED QXLUpdateCmd {
    QXLReleaseInfo release_info;
    QXLRect area;
    uint32_t update_id;
    uint32_t surface_id;
} QXLUpdateCmd;

typedef struct SPICE_ATTR_PACKED QXLCursorHeader {
    uint64_t unique;
    uint16_t type;
    uint16_t width;
    uint16_t height;
    uint16_t hot_spot_x;
    uint16_t hot_spot_y;
} QXLCursorHeader;

typedef struct SPICE_ATTR_PACKED QXLCursor {
    QXLCursorHeader header;
    uint32_t data_size;
    QXLDataChunk chunk;
} QXLCursor;

enum {
    QXL_CURSOR_SET,
    QXL_CURSOR_MOVE,
    QXL_CURSOR_HIDE,
    QXL_CURSOR_TRAIL,
};

#define QXL_CURSUR_DEVICE_DATA_SIZE 128

typedef struct SPICE_ATTR_PACKED QXLCursorCmd {
    QXLReleaseInfo release_info;
    uint8_t type;
    union {
        struct SPICE_ATTR_PACKED {
            QXLPoint16 position;
            uint8_t visible;
            QXLPHYSICAL shape;
        } set;
        struct SPICE_ATTR_PACKED {
            uint16_t length;
            uint16_t frequency;
        } trail;
        QXLPoint16 position;
    } u;
    uint8_t device_data[QXL_CURSUR_DEVICE_DATA_SIZE]; //todo: dynamic size from rom
} QXLCursorCmd;

enum {
    QXL_DRAW_NOP,
    QXL_DRAW_FILL,
    QXL_DRAW_OPAQUE,
    QXL_DRAW_COPY,
    QXL_COPY_BITS,
    QXL_DRAW_BLEND,
    QXL_DRAW_BLACKNESS,
    QXL_DRAW_WHITENESS,
    QXL_DRAW_INVERS,
    QXL_DRAW_ROP3,
    QXL_DRAW_STROKE,
    QXL_DRAW_TEXT,
    QXL_DRAW_TRANSPARENT,
    QXL_DRAW_ALPHA_BLEND,
    QXL_DRAW_COMPOSITE
};

typedef struct SPICE_ATTR_PACKED QXLRasterGlyph {
    QXLPoint render_pos;
    QXLPoint glyph_origin;
    uint16_t width;
    uint16_t height;
    uint8_t data[0];
} QXLRasterGlyph;

typedef struct SPICE_ATTR_PACKED QXLString {
    uint32_t data_size;
    uint16_t length;
    uint16_t flags;
    QXLDataChunk chunk;
} QXLString;

typedef struct SPICE_ATTR_PACKED QXLCopyBits {
    QXLPoint src_pos;
} QXLCopyBits;

typedef enum QXLEffectType
{
    QXL_EFFECT_BLEND = 0,
    QXL_EFFECT_OPAQUE = 1,
    QXL_EFFECT_REVERT_ON_DUP = 2,
    QXL_EFFECT_BLACKNESS_ON_DUP = 3,
    QXL_EFFECT_WHITENESS_ON_DUP = 4,
    QXL_EFFECT_NOP_ON_DUP = 5,
    QXL_EFFECT_NOP = 6,
    QXL_EFFECT_OPAQUE_BRUSH = 7
} QXLEffectType;

typedef struct SPICE_ATTR_PACKED QXLPattern {
    QXLPHYSICAL pat;
    QXLPoint pos;
} QXLPattern;

typedef struct SPICE_ATTR_PACKED QXLBrush {
    uint32_t type;
    union {
        uint32_t color;
        QXLPattern pattern;
    } u;
} QXLBrush;

typedef struct SPICE_ATTR_PACKED QXLQMask {
    uint8_t flags;
    QXLPoint pos;
    QXLPHYSICAL bitmap;
} QXLQMask;

typedef struct SPICE_ATTR_PACKED QXLFill {
    QXLBrush brush;
    uint16_t rop_descriptor;
    QXLQMask mask;
} QXLFill;

typedef struct SPICE_ATTR_PACKED QXLOpaque {
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
    QXLBrush brush;
    uint16_t rop_descriptor;
    uint8_t scale_mode;
    QXLQMask mask;
} QXLOpaque;

typedef struct SPICE_ATTR_PACKED QXLCopy {
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
    uint16_t rop_descriptor;
    uint8_t scale_mode;
    QXLQMask mask;
} QXLCopy, QXLBlend;

typedef struct SPICE_ATTR_PACKED QXLTransparent {
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
    uint32_t src_color;
    uint32_t true_color;
} QXLTransparent;

typedef struct SPICE_ATTR_PACKED QXLAlphaBlend {
    uint16_t alpha_flags;
    uint8_t alpha;
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
} QXLAlphaBlend;

typedef struct SPICE_ATTR_PACKED QXLCompatAlphaBlend {
    uint8_t alpha;
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
} QXLCompatAlphaBlend;

typedef struct SPICE_ATTR_PACKED QXLRop3 {
    QXLPHYSICAL src_bitmap;
    QXLRect src_area;
    QXLBrush brush;
    uint8_t rop3;
    uint8_t scale_mode;
    QXLQMask mask;
} QXLRop3;

typedef struct SPICE_ATTR_PACKED QXLLineAttr {
    uint8_t flags;
    uint8_t join_style;
    uint8_t end_style;
    uint8_t style_nseg;
    QXLFIXED width;
    QXLFIXED miter_limit;
    QXLPHYSICAL style;
} QXLLineAttr;

typedef struct SPICE_ATTR_PACKED QXLStroke {
    QXLPHYSICAL path;
    QXLLineAttr attr;
    QXLBrush brush;
    uint16_t fore_mode;
    uint16_t back_mode;
} QXLStroke;

typedef struct SPICE_ATTR_PACKED QXLText {
    QXLPHYSICAL str;
    QXLRect back_area;
    QXLBrush fore_brush;
    QXLBrush back_brush;
    uint16_t fore_mode;
    uint16_t back_mode;
} QXLText;

typedef struct SPICE_ATTR_PACKED QXLBlackness {
    QXLQMask mask;
} QXLBlackness, QXLInvers, QXLWhiteness;

typedef struct SPICE_ATTR_PACKED QXLClip {
    uint32_t type;
    QXLPHYSICAL data;
} QXLClip;

typedef enum {
    QXL_OP_CLEAR                     = 0x00,
    QXL_OP_SOURCE		     = 0x01,
    QXL_OP_DST                       = 0x02,
    QXL_OP_OVER                      = 0x03,
    QXL_OP_OVER_REVERSE              = 0x04,
    QXL_OP_IN                        = 0x05,
    QXL_OP_IN_REVERSE                = 0x06,
    QXL_OP_OUT                       = 0x07,
    QXL_OP_OUT_REVERSE               = 0x08,
    QXL_OP_ATOP                      = 0x09,
    QXL_OP_ATOP_REVERSE              = 0x0a,
    QXL_OP_XOR                       = 0x0b,
    QXL_OP_ADD                       = 0x0c,
    QXL_OP_SATURATE                  = 0x0d,
    /* Note the jump here from 0x0d to 0x30 */
    QXL_OP_MULTIPLY                  = 0x30,
    QXL_OP_SCREEN                    = 0x31,
    QXL_OP_OVERLAY                   = 0x32,
    QXL_OP_DARKEN                    = 0x33,
    QXL_OP_LIGHTEN                   = 0x34,
    QXL_OP_COLOR_DODGE               = 0x35,
    QXL_OP_COLOR_BURN                = 0x36,
    QXL_OP_HARD_LIGHT                = 0x37,
    QXL_OP_SOFT_LIGHT                = 0x38,
    QXL_OP_DIFFERENCE                = 0x39,
    QXL_OP_EXCLUSION                 = 0x3a,
    QXL_OP_HSL_HUE                   = 0x3b,
    QXL_OP_HSL_SATURATION            = 0x3c,
    QXL_OP_HSL_COLOR                 = 0x3d,
    QXL_OP_HSL_LUMINOSITY            = 0x3e
} QXLOperator;

typedef struct {
    uint32_t	t00;
    uint32_t	t01;
    uint32_t	t02;
    uint32_t	t10;
    uint32_t	t11;
    uint32_t	t12;
} QXLTransform;

/* The flags field has the following bit fields:
 *
 *     operator:		[  0 -  7 ]
 *     src_filter:		[  8 - 10 ]
 *     mask_filter:		[ 11 - 13 ]
 *     src_repeat:		[ 14 - 15 ]
 *     mask_repeat:		[ 16 - 17 ]
 *     component_alpha:		[ 18 - 18 ]
 *     reserved:		[ 19 - 31 ]
 *
 * The repeat and filter values are those of pixman:
 *		REPEAT_NONE =		0
 *              REPEAT_NORMAL =		1
 *		REPEAT_PAD =		2
 *		REPEAT_REFLECT =	3
 *
 * The filter values are:
 *		FILTER_NEAREST =	0
 *		FILTER_BILINEAR	=	1
 */
typedef struct SPICE_ATTR_PACKED QXLComposite {
    uint32_t		flags;

    QXLPHYSICAL		src;
    QXLPHYSICAL		src_transform;		/* May be NULL */
    QXLPHYSICAL		mask;			/* May be NULL */
    QXLPHYSICAL		mask_transform;		/* May be NULL */
    QXLPoint16		src_origin;
    QXLPoint16		mask_origin;
} QXLComposite;

typedef struct SPICE_ATTR_PACKED QXLCompatDrawable {
    QXLReleaseInfo release_info;
    uint8_t effect;
    uint8_t type;
    uint16_t bitmap_offset;
    QXLRect bitmap_area;
    QXLRect bbox;
    QXLClip clip;
    uint32_t mm_time;
    union {
        QXLFill fill;
        QXLOpaque opaque;
        QXLCopy copy;
        QXLTransparent transparent;
        QXLCompatAlphaBlend alpha_blend;
        QXLCopyBits copy_bits;
        QXLBlend blend;
        QXLRop3 rop3;
        QXLStroke stroke;
        QXLText text;
        QXLBlackness blackness;
        QXLInvers invers;
        QXLWhiteness whiteness;
    } u;
} QXLCompatDrawable;

typedef struct SPICE_ATTR_PACKED QXLDrawable {
    QXLReleaseInfo release_info;
    uint32_t surface_id;
    uint8_t effect;
    uint8_t type;
    uint8_t self_bitmap;
    QXLRect self_bitmap_area;
    QXLRect bbox;
    QXLClip clip;
    uint32_t mm_time;
    int32_t surfaces_dest[3];
    QXLRect surfaces_rects[3];
    union {
        QXLFill fill;
        QXLOpaque opaque;
        QXLCopy copy;
        QXLTransparent transparent;
        QXLAlphaBlend alpha_blend;
        QXLCopyBits copy_bits;
        QXLBlend blend;
        QXLRop3 rop3;
        QXLStroke stroke;
        QXLText text;
        QXLBlackness blackness;
        QXLInvers invers;
        QXLWhiteness whiteness;
        QXLComposite composite;
    } u;
} QXLDrawable;

typedef enum QXLSurfaceCmdType {
    QXL_SURFACE_CMD_CREATE,
    QXL_SURFACE_CMD_DESTROY,
} QXLSurfaceCmdType;

typedef struct SPICE_ATTR_PACKED QXLSurface {
    uint32_t format;
    uint32_t width;
    uint32_t height;
    int32_t stride;
    QXLPHYSICAL data;
} QXLSurface;

typedef struct SPICE_ATTR_PACKED QXLSurfaceCmd {
    QXLReleaseInfo release_info;
    uint32_t surface_id;
    uint8_t type;
    uint32_t flags;
    union {
        QXLSurface surface_create;
    } u;
} QXLSurfaceCmd;

typedef struct SPICE_ATTR_PACKED QXLClipRects {
    uint32_t num_rects;
    QXLDataChunk chunk;
} QXLClipRects;

enum {
    QXL_PATH_BEGIN = (1 << 0),
    QXL_PATH_END = (1 << 1),
    QXL_PATH_CLOSE = (1 << 3),
    QXL_PATH_BEZIER = (1 << 4),
};

typedef struct SPICE_ATTR_PACKED QXLPathSeg {
    uint32_t flags;
    uint32_t count;
    QXLPointFix points[0];
} QXLPathSeg;

typedef struct SPICE_ATTR_PACKED QXLPath {
    uint32_t data_size;
    QXLDataChunk chunk;
} QXLPath;

enum {
    QXL_IMAGE_GROUP_DRIVER,
    QXL_IMAGE_GROUP_DEVICE,
    QXL_IMAGE_GROUP_RED,
    QXL_IMAGE_GROUP_DRIVER_DONT_CACHE,
};

typedef struct SPICE_ATTR_PACKED QXLImageID {
    uint32_t group;
    uint32_t unique;
} QXLImageID;

typedef union {
  QXLImageID id;
  uint64_t value;
} QXLImageIDUnion;

typedef enum QXLImageFlags {
    QXL_IMAGE_CACHE = (1 << 0),
    QXL_IMAGE_HIGH_BITS_SET = (1 << 1),
} QXLImageFlags;

typedef enum QXLBitmapFlags {
    QXL_BITMAP_DIRECT = (1 << 0),
    QXL_BITMAP_UNSTABLE = (1 << 1),
    QXL_BITMAP_TOP_DOWN = (1 << 2), // == SPICE_BITMAP_FLAGS_TOP_DOWN
} QXLBitmapFlags;

#define QXL_SET_IMAGE_ID(image, _group, _unique) {              \
    (image)->descriptor.id = (((uint64_t)_unique) << 32) | _group;	\
}

typedef struct SPICE_ATTR_PACKED QXLImageDescriptor {
    uint64_t id;
    uint8_t type;
    uint8_t flags;
    uint32_t width;
    uint32_t height;
} QXLImageDescriptor;

typedef struct SPICE_ATTR_PACKED QXLPalette {
    uint64_t unique;
    uint16_t num_ents;
    uint32_t ents[0];
} QXLPalette;

typedef struct SPICE_ATTR_PACKED QXLBitmap {
    uint8_t format;
    uint8_t flags;
    uint32_t x;
    uint32_t y;
    uint32_t stride;
    QXLPHYSICAL palette;
    QXLPHYSICAL data; //data[0] ?
} QXLBitmap;

typedef struct SPICE_ATTR_PACKED QXLSurfaceId {
    uint32_t surface_id;
} QXLSurfaceId;

typedef struct SPICE_ATTR_PACKED QXLQUICData {
    uint32_t data_size;
    /* This data for QUIC is a QXLDataChunk.
     * This differs from QXLBitmap where it's a reference to bitmap data or
     * a reference to QXLDataChunk */
    uint8_t data[0];
} QXLQUICData, QXLLZRGBData, QXLJPEGData;

typedef struct SPICE_ATTR_PACKED QXLImage {
    QXLImageDescriptor descriptor;
    union { // variable length
        QXLBitmap bitmap;
        QXLQUICData quic;
        QXLSurfaceId surface_image;
    };
} QXLImage;

/* A QXLHead is a single monitor output backed by a QXLSurface.
 * x and y offsets are unsigned since they are used in relation to
 * the given surface, not the same as the x, y coordinates in the guest
 * screen reference frame. */
typedef struct SPICE_ATTR_PACKED QXLHead {
    uint32_t id;
    uint32_t surface_id;
    uint32_t width;
    uint32_t height;
    uint32_t x;
    uint32_t y;
    uint32_t flags;
} QXLHead;

typedef struct SPICE_ATTR_PACKED QXLMonitorsConfig {
    uint16_t count;
    uint16_t max_allowed; /* If it is 0 no fixed limit is given by the driver */
    QXLHead heads[0];
} QXLMonitorsConfig;

#include <spice/end-packed.h>

typedef struct QXLReleaseInfoExt {
    QXLReleaseInfo *info;
    uint32_t group_id;
} QXLReleaseInfoExt;

#endif /* _H_QXL_DEV */

```

`devices/display/qxl/qxl_modes.h`:

```h
/* 
 * MVisor QXL Modes
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#ifndef _MVISOR_DEVICES_QXL_MODES_H
#define _MVISOR_DEVICES_QXL_MODES_H

#include "qxl_dev.h"

#define PIXEL_SIZE 0.2936875 // 1280x1024 is 14.8" x 11.9" 

#define QXL_MODE(_x, _y, _b, _o)              \
  {   .id = 0,                                \
    .x_res = _x,                              \
    .y_res = _y,                              \
    .bits  = _b,                              \
    .stride = (_x) * (_b) / 8,                \
    .x_mili = (uint32_t)(PIXEL_SIZE * (_x)),  \
    .y_mili = (uint32_t)(PIXEL_SIZE * (_y)),  \
    .orientation = _o,                        \
  }

#define QXL_MODE_EX(x_res, y_res)             \
  QXL_MODE(x_res, y_res, 32, 0),                  \
  QXL_MODE(x_res, y_res, 32, 1)

static QXLMode qxl_modes[] = {
  QXL_MODE_EX(640, 480),
  QXL_MODE_EX(800, 480),
  QXL_MODE_EX(800, 600),
  QXL_MODE_EX(832, 624),
  QXL_MODE_EX(960, 640),
  QXL_MODE_EX(1024, 600),
  QXL_MODE_EX(1024, 768),
  QXL_MODE_EX(1152, 864),
  QXL_MODE_EX(1152, 870),
  QXL_MODE_EX(1280, 720),
  QXL_MODE_EX(1280, 760),
  QXL_MODE_EX(1280, 768),
  QXL_MODE_EX(1280, 800),
  QXL_MODE_EX(1280, 960),
  QXL_MODE_EX(1280, 1024),
  QXL_MODE_EX(1360, 768),
  QXL_MODE_EX(1366, 768),
  QXL_MODE_EX(1400, 1050),
  QXL_MODE_EX(1440, 900),
  QXL_MODE_EX(1440, 1024),
  QXL_MODE_EX(1600, 900),
  QXL_MODE_EX(1600, 1200),
  QXL_MODE_EX(1680, 1050),
  QXL_MODE_EX(1896, 1024),
  QXL_MODE_EX(1920, 920),
  QXL_MODE_EX(1920, 1080),
  /* these modes need more than 8 MB video memory */
  QXL_MODE_EX(1920, 1200),
  QXL_MODE_EX(1920, 1440),
  QXL_MODE_EX(2000, 2000),
  QXL_MODE_EX(2048, 1536),
  QXL_MODE_EX(2048, 2048),
  QXL_MODE_EX(2560, 1440),
  QXL_MODE_EX(2560, 1600),
  /* these modes need more than 16 MB video memory */
  QXL_MODE_EX(2560, 2048),
  QXL_MODE_EX(2800, 2100),
  QXL_MODE_EX(3200, 2400),
  /* these modes need more than 32 MB video memory */
  QXL_MODE_EX(3840, 2160), /* 4k mainstream */
  QXL_MODE_EX(4096, 2160), /* 4k            */
  /* these modes need more than 64 MB video memory */
  QXL_MODE_EX(7680, 4320), /* 8k mainstream */
  /* these modes need more than 128 MB video memory */
  QXL_MODE_EX(8192, 4320), /* 8k            */
};

#endif // _MVISOR_DEVICES_QXL_MODES_H

```

`devices/display/qxl/qxl_parser.cc`:

```cc
/* 
 * MVisor QXL Parser
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <string>

#include "qxl_parser.h"
#include "qxl_render.h"
#include "qxl.h"
#include "logger.h"

static inline void parse_rect(SpiceRect* s, QXLRect* q) {
  s->top = q->top;
  s->bottom = q->bottom;
  s->left = q->left;
  s->right = q->right;
}

static inline void parse_point(SpicePoint* s, QXLPoint* q) {
  s->x = q->x;
  s->y = q->y;
}

static inline bool is_valid_rect(SpiceRect* s) {
  return s->top >= 0 && s->left >= 0 && s->top <= s->bottom && s->left <= s->right;
}

QxlParser::QxlParser(QxlRender* render) {
  render_ = render;
  qxl_ = render->qxl();
}

QxlParser::~QxlParser() {
  for (auto ptr : gc_) {
    free(ptr);
  }
  for (auto chunks : chunks_) {
    spice_chunks_destroy(chunks);
  }
}

bool QxlParser::Parse(QXLDrawable* q) {
  surface_id = q->surface_id;
  type = q->type;
  effect = q->effect;

  parse_rect(&bbox, &q->bbox);
  if (!is_valid_rect(&bbox)) {
    return false;
  }

  self_bitmap = q->self_bitmap;
  parse_rect(&self_bitmap_area, &q->self_bitmap_area);

  clip.type = q->clip.type;
  if (clip.type == SPICE_CLIP_TYPE_RECTS) {
    clip.rects = GetClipRects(q->clip.data);
  } else {
    clip.rects = nullptr;
  }

  bool ret;
  switch (type)
  {
  case QXL_DRAW_FILL:
    ret = ParseDrawFill(&q->u.fill);
    break;
  case QXL_DRAW_OPAQUE:
    ret = ParseDrawOpaque(&q->u.opaque);
    break;
  case QXL_DRAW_COPY:
    ret = ParseDrawCopy(&q->u.copy);
    break;
  case QXL_COPY_BITS:
    ret = ParseCopyBits(&q->u.copy_bits);
    break;
  case QXL_DRAW_BLEND:
    ret = ParseDrawBlend(&q->u.blend);
    break;
  case QXL_DRAW_BLACKNESS:
    ret = ParseDrawBlackness(&q->u.blackness);
    break;
  case QXL_DRAW_WHITENESS:
    ret = ParseDrawWhiteness(&q->u.whiteness);
    break;
  case QXL_DRAW_INVERS:
    ret = ParseDrawInvers(&q->u.invers);
    break;
  case QXL_DRAW_ROP3:
    ret = ParseDrawRop3(&q->u.rop3);
    break;
  case QXL_DRAW_STROKE:
    ret = ParseDrawStroke(&q->u.stroke);
    break;
  case QXL_DRAW_TEXT:
    ret = ParseDrawText(&q->u.text);
    break;
  case QXL_DRAW_TRANSPARENT:
    ret = ParseDrawTransparent(&q->u.transparent);
    break;
  case QXL_DRAW_ALPHA_BLEND:
    ret = ParseDrawAlphaBlend(&q->u.alpha_blend);
    break;
  default:
    MV_ERROR("unhandled drawable type=%d", type);
    ret = false;
  }

  return ret;
}

SpiceClipRects* QxlParser::GetClipRects(uint64_t address) {
  auto q = (QXLClipRects*)qxl_->GetMemSlotAddress(address);
  auto r = (SpiceClipRects*)spice_malloc_n_m(q->num_rects, sizeof(SpiceRect), sizeof(SpiceClipRects));
  gc_.push_back(r);

  r->num_rects = q->num_rects;

  std::string data;
  qxl_->GetMemSlotLinearizedChunkData(&q->chunk, data);
  auto q_rects = (QXLRect*)data.data();

  for (uint i = 0; i < r->num_rects; i++) {
    parse_rect(&r->rects[i], &q_rects[i]);
  }
  
  return r;
}

SpiceImage* QxlParser::GetImage(uint64_t address) {
  if (address == 0) {
    return nullptr;
  }

  auto q = (QXLImage*)qxl_->GetMemSlotAddress(address);
  auto r = (SpiceImage*)spice_new0(SpiceImage, 1);
  gc_.push_back(r);

  r->descriptor.id = q->descriptor.id;
  r->descriptor.type = q->descriptor.type;
  r->descriptor.flags = 0;
  if (q->descriptor.flags & QXL_IMAGE_HIGH_BITS_SET)
    r->descriptor.flags |= SPICE_IMAGE_FLAGS_HIGH_BITS_SET;
  if (q->descriptor.flags & QXL_IMAGE_CACHE)
    r->descriptor.flags |= SPICE_IMAGE_FLAGS_CACHE_ME;
  
  r->descriptor.width = q->descriptor.width;
  r->descriptor.height = q->descriptor.height;

  /* Try to find image from cache */
  if (render_->images().Contains(r->descriptor.id)) {
    r->descriptor.type = SPICE_IMAGE_TYPE_FROM_CACHE;
    r->descriptor.flags = 0;
    return r;
  }

  if (r->descriptor.type == SPICE_IMAGE_TYPE_BITMAP) {
    r->u.bitmap.format = q->bitmap.format;
    r->u.bitmap.x = q->bitmap.x;
    r->u.bitmap.y = q->bitmap.y;
    r->u.bitmap.stride = q->bitmap.stride;
    r->u.bitmap.flags = 0;
    
    if (q->bitmap.flags & QXL_BITMAP_TOP_DOWN) {
      r->u.bitmap.flags |= SPICE_BITMAP_FLAGS_TOP_DOWN;
    }
    
    if (q->bitmap.palette) {
      auto qp = (QXLPalette*)qxl_->GetMemSlotAddress(q->bitmap.palette);
      auto sp = (SpicePalette*)spice_malloc_n_m(qp->num_ents, sizeof(uint32_t), sizeof(SpicePalette));
      gc_.push_back(sp);

      sp->unique = qp->unique;
      sp->num_ents = qp->num_ents;
      for (uint i = 0; i < sp->num_ents; i++) {
        sp->ents[i] = qp->ents[i];
      }
      r->u.bitmap.palette = sp;
      r->u.bitmap.palette_id = sp->unique;
    }
    
    MV_ASSERT(!(q->bitmap.flags & QXL_BITMAP_DIRECT));

    std::vector<iovec> v;
    size_t data_size = qxl_->GetMemSlotChunkData(q->bitmap.data, v);
    auto chunks = (SpiceChunks*)spice_chunks_new(v.size());
    chunks_.push_back(chunks);

    chunks->data_size = data_size;
    for (size_t i = 0; i < chunks->num_chunks; i++) {
      chunks->chunk[i].data = (uint8_t*)v[i].iov_base;
      chunks->chunk[i].len = v[i].iov_len;
    }
    r->u.bitmap.data = chunks;
  } else {
    MV_PANIC("unhandled descriptor type=%d", r->descriptor.type);
  }
  return r;
}

void QxlParser::GetQMask(SpiceQMask* s, QXLQMask* q) {
  s->bitmap = GetImage(q->bitmap);
  if (s->bitmap) {
    s->flags = q->flags;
    parse_point(&s->pos, &q->pos);
  } else {
    s->flags = 0;
    s->pos.x = 0;
    s->pos.y = 0;
  }
}

void QxlParser::GetBrush(SpiceBrush* s, QXLBrush* q) {
  s->type = q->type;
  if (q->type == SPICE_BRUSH_TYPE_SOLID) {
    s->u.color = q->u.color;
  } else if (q->type == SPICE_BRUSH_TYPE_PATTERN) {
    s->u.pattern.pat = GetImage(q->u.pattern.pat);
    parse_point(&s->u.pattern.pos, &q->u.pattern.pos);
  }
}

SpiceString* QxlParser::GetString(uint64_t address) {
  auto q = (QXLString*)qxl_->GetMemSlotAddress(address);
  std::string data;
  qxl_->GetMemSlotLinearizedChunkData(&q->chunk, data);
  MV_ASSERT(data.size() == q->data_size);

  uint bpp = 0;
  if (q->flags & SPICE_STRING_FLAGS_RASTER_A1) {
    bpp = 1;
  } else if (q->flags & SPICE_STRING_FLAGS_RASTER_A4) {
    bpp = 4;
  } else if (q->flags & SPICE_STRING_FLAGS_RASTER_A8) {
    bpp = 8;
  }
  MV_ASSERT(bpp != 0);

  std::vector<SpiceRasterGlyph*> glyphs;
  auto start = (QXLRasterGlyph*)data.data();
  auto end = (QXLRasterGlyph*)(data.data() + data.size());
  while (start < end) {
    size_t glyph_size = start->height * ((start->width * bpp + 7U) / 8U);
    auto spice_glyph = (SpiceRasterGlyph*)spice_malloc_n_m(glyph_size, 1, sizeof(SpiceRasterGlyph));
    gc_.push_back(spice_glyph);

    spice_glyph->width = start->width;
    spice_glyph->height = start->height;
    parse_point(&spice_glyph->render_pos, &start->render_pos);
    parse_point(&spice_glyph->glyph_origin, &start->glyph_origin);
    memcpy(spice_glyph->data, start->data, glyph_size);

    glyphs.push_back(spice_glyph);
    start = (QXLRasterGlyph*)&start->data[glyph_size];
  }

  auto s = (SpiceString*)spice_malloc_n_m(glyphs.size(), sizeof(SpiceRasterGlyph*), sizeof(SpiceString));
  gc_.push_back(s);

  s->length = q->length;
  s->flags = q->flags;
  for (size_t i = 0; i < glyphs.size(); i++) {
    s->glyphs[i] = glyphs[i];
  }
  return s;
}

SpicePath* QxlParser::GetPath(uint64_t address) {
  auto q = (QXLPath*)qxl_->GetMemSlotAddress(address);
  std::string data;
  qxl_->GetMemSlotLinearizedChunkData(&q->chunk, data);
  MV_ASSERT(data.size() == q->data_size);
  
  std::vector<SpicePathSeg*> path_segs;
  auto start = (QXLPathSeg*)data.data();
  auto end = (QXLPathSeg*)(data.data() + data.size());
  while (start < end) {
    auto spice_seg = (SpicePathSeg*)spice_malloc_n_m(start->count, sizeof(SpicePointFix), sizeof(SpicePathSeg));
    gc_.push_back(spice_seg);

    spice_seg->flags = start->flags;
    spice_seg->count = start->count;
    for (uint i = 0; i < spice_seg->count; i++) {
      spice_seg->points[i].x = start->points[i].x;
      spice_seg->points[i].y = start->points[i].y;
    }

    path_segs.push_back(spice_seg);
    start = (QXLPathSeg*)&start->points[start->count];
  }

  auto s = (SpicePath*)spice_malloc_n_m(path_segs.size(), sizeof(SpicePathSeg*), sizeof(SpicePath));
  gc_.push_back(s);

  s->num_segments = path_segs.size();
  for (size_t i = 0; i < s->num_segments; i++) {
    s->segments[i] = path_segs[i];
  }
  return s;
}

bool QxlParser::ParseDrawCopy(QXLCopy* q) {
  SpiceCopy* s = &u.copy;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap) {
    return false;
  }
  parse_rect(&s->src_area, &q->src_area);

  s->rop_descriptor = q->rop_descriptor;
  s->scale_mode = q->scale_mode;

  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawOpaque(QXLOpaque* q) {
  SpiceOpaque* s = &u.opaque;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap)
    return false;
  parse_rect(&s->src_area, &q->src_area);

  GetBrush(&s->brush, &q->brush);

  s->rop_descriptor = q->rop_descriptor;
  s->scale_mode = q->scale_mode;

  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawFill(QXLFill* q) {
  SpiceFill* s = &u.fill;
  GetBrush(&s->brush, &q->brush);
  s->rop_descriptor = q->rop_descriptor;
  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawStroke(QXLStroke* q) {
  SpiceStroke* s = &u.stroke;
  s->path = GetPath(q->path);
  if (!s->path) {
    return false;
  }

  s->back_mode = q->back_mode;
  s->fore_mode = q->fore_mode;
  GetBrush(&s->brush, &q->brush);

  s->attr.flags = q->attr.flags;
  if (s->attr.flags & SPICE_LINE_FLAGS_STYLED) {
    s->attr.style_nseg = q->attr.style_nseg;
    auto qs = (uint8_t*)qxl_->GetMemSlotAddress(q->attr.style);
    s->attr.style = (SPICE_FIXED28_4*)spice_malloc_n(q->attr.style_nseg, sizeof(SPICE_FIXED28_4));
    gc_.push_back(s->attr.style);

    memcpy(s->attr.style, qs, s->attr.style_nseg * sizeof(QXLFIXED));
  } else {
    s->attr.style_nseg = 0;
    s->attr.style = nullptr;
  }
  return true;
}

bool QxlParser::ParseDrawText(QXLText* q) {
  SpiceText* s = &u.text;
  s->back_mode = q->back_mode;
  s->fore_mode = q->fore_mode;
  parse_rect(&s->back_area, &q->back_area);
  GetBrush(&s->back_brush, &q->back_brush);
  GetBrush(&s->fore_brush, &q->fore_brush);
  s->str = GetString(q->str);
  return true;
}

bool QxlParser::ParseDrawTransparent(QXLTransparent* q) {
  SpiceTransparent* s = &u.transparent;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap)
    return false;
  parse_rect(&s->src_area, &q->src_area);

  s->src_color = q->src_color;
  s->true_color = q->true_color;
  return true;
}

bool QxlParser::ParseDrawAlphaBlend(QXLAlphaBlend* q) {
  SpiceAlphaBlend* s = &u.alphablend;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap)
    return false;
  parse_rect(&s->src_area, &q->src_area);

  s->alpha_flags = q->alpha_flags;
  s->alpha = q->alpha;
  return true;
}

bool QxlParser::ParseCopyBits(QXLCopyBits* q) {
  parse_point(&u.copy_bits.src_pos, &q->src_pos);
  return true;
}

bool QxlParser::ParseDrawBlend(QXLBlend* q) {
  SpiceBlend* s = &u.blend;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap)
    return false;
  parse_rect(&s->src_area, &q->src_area);
  
  s->rop_descriptor = q->rop_descriptor;
  s->scale_mode = q->scale_mode;

  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawBlackness(QXLBlackness* q) {
  SpiceBlackness* s = &u.blackness;
  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawWhiteness(QXLWhiteness* q) {
  SpiceWhiteness* s = &u.whiteness;
  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawInvers(QXLInvers* q) {
  SpiceInvers* s = &u.invers;
  GetQMask(&s->mask, &q->mask);
  return true;
}

bool QxlParser::ParseDrawRop3(QXLRop3* q) {
  SpiceRop3* s = &u.rop3;
  s->src_bitmap = GetImage(q->src_bitmap);
  if (!s->src_bitmap)
    return false;
  parse_rect(&s->src_area, &q->src_area);

  s->rop3 = q->rop3;
  s->scale_mode = q->scale_mode;
  GetBrush(&s->brush, &q->brush);
  GetQMask(&s->mask, &q->mask);
  return true;
}

```

`devices/display/qxl/qxl_parser.h`:

```h
/* 
 * MVisor QXL Parser
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
#ifndef _MVISOR_DEVICES_QXL_PARSER_H
#define _MVISOR_DEVICES_QXL_PARSER_H

#include "qxl_dev.h"
#include "canvas/draw.h"

#include <functional>
#include <vector>

class Qxl;
class QxlRender;

struct QxlParser {
 public:
  uint32_t      surface_id;
  uint8_t       effect;
  uint8_t       type;
  uint8_t       self_bitmap;
  SpiceRect     self_bitmap_area;
  SpiceImage*   self_bitmap_image;
  SpiceRect     bbox;
  SpiceClip     clip;
  union {
    SpiceFill         fill;
    SpiceOpaque       opaque;
    SpiceCopy         copy;
    SpiceTransparent  transparent;
    SpiceAlphaBlend   alphablend;
    SpiceBlend        blend;
    struct {
      SpicePoint      src_pos;
    } copy_bits;
    SpiceRop3         rop3;
    SpiceStroke       stroke;
    SpiceText         text;
    SpiceBlackness    blackness;
    SpiceInvers       invers;
    SpiceWhiteness    whiteness;
    SpiceComposite    composite;
  } u;

 public:
  QxlParser(QxlRender* render);
  ~QxlParser();

  bool Parse(QXLDrawable* drawable);

 private:
  QxlRender*                render_;
  Qxl*                      qxl_;
  std::vector<void*>        gc_;
  std::vector<SpiceChunks*> chunks_;

  bool ParseDrawOpaque(QXLOpaque* q);
  bool ParseDrawBlend(QXLBlend* q);
  bool ParseDrawBlackness(QXLBlackness* q);
  bool ParseDrawWhiteness(QXLWhiteness* q);
  bool ParseDrawInvers(QXLInvers* q);
  bool ParseDrawRop3(QXLRop3* q);
  bool ParseDrawCopy(QXLCopy* q);
  bool ParseDrawStroke(QXLStroke* q);
  bool ParseDrawText(QXLText* q);
  bool ParseDrawTransparent(QXLTransparent* q);
  bool ParseDrawAlphaBlend(QXLAlphaBlend* q);
  bool ParseCopyBits(QXLCopyBits* q);
  bool ParseDrawFill(QXLFill* q);

  SpiceClipRects* GetClipRects(uint64_t address);
  SpiceImage* GetImage(uint64_t address);
  void GetQMask(SpiceQMask* s, QXLQMask* q);
  void GetBrush(SpiceBrush* s, QXLBrush* q);
  SpiceString* GetString(uint64_t address);
  SpicePath* GetPath(uint64_t address);
};


#endif

```

`devices/display/qxl/qxl_render.cc`:

```cc
/* 
 * MVisor QXL Render
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * Copy and modified from QEMU
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <pixman.h>

#include "qxl_render.h"
#include "qxl.h"
#include "qxl_parser.h"
#include "logger.h"


static pixman_image_t *image_get(SpiceImageCache *cache, uint64_t id)
{
  auto ops = SPICE_CONTAINEROF(cache, QxlRenderOps, image_cache);
  auto& images = ops->render->images();

  void* data;
  if (!images.Get(id, data)) {
    return nullptr;
  }
  return pixman_image_ref((pixman_image_t*)data);
}

static void image_put(SpiceImageCache *image_cache, uint64_t id, pixman_image_t *image)
{
  auto ops = SPICE_CONTAINEROF(image_cache, QxlRenderOps, image_cache);
  auto& images = ops->render->images();
  if (images.Contains(id)) {
    return;
  }

  void* data = pixman_image_ref(image);
  images.Put(id, data);
}

static SpiceCanvas *surfaces_get(SpiceImageSurfaces *image_surfaces, uint32_t surface_id)
{
  auto ops = SPICE_CONTAINEROF(image_surfaces, QxlRenderOps, image_surfaces);
  auto& surfaces = ops->render->surfaces();

  auto it = surfaces.find(surface_id);
  return it != surfaces.end() ? it->second.canvas : nullptr;
}


static SpiceImageSurfacesOps image_surfaces_ops = {
  .get = surfaces_get
};

static SpiceImageCacheOps image_cache_ops = {
  .put = image_put,
  .get = image_get
};


QxlRender::QxlRender(Qxl* qxl) : qxl_(qxl) {
  render_ops_.image_cache.ops = &image_cache_ops;
  render_ops_.image_surfaces.ops = &image_surfaces_ops;
  render_ops_.render = this;
  debug_ = qxl->debug();

  images_.Initialize(1024, [this](auto key, void* data) {
    MV_UNUSED(key);
    pixman_image_unref((pixman_image_t*)data);
  });
}

QxlRender::~QxlRender() {
  images_.Clear();

  for (auto it = surfaces_.begin(); it != surfaces_.end(); it++) {
    auto& surface = it->second;
    surface.canvas->ops->destroy(surface.canvas);
    if (surface.qxl_surface_cmd) {
      qxl_->ReleaseGuestResource(&surface.qxl_surface_cmd->release_info);
    }
  }
}


void QxlRender::ParseSurfaceCommand(uint64_t slot_address) {
  auto surface_cmd = (QXLSurfaceCmd*)qxl_->GetMemSlotAddress(slot_address);
  switch (surface_cmd->type)
  {
  case QXL_SURFACE_CMD_CREATE:
    CreateSurface(surface_cmd->surface_id, slot_address);
    break;
  case QXL_SURFACE_CMD_DESTROY:
    DestroySurface(surface_cmd->surface_id);
    qxl_->ReleaseGuestResource(&surface_cmd->release_info);
    break;
  default:
    MV_PANIC("invalid cmd=%d", surface_cmd->type);
    break;
  }
}


void QxlRender::ParseDrawCommand(uint64_t slot_address) {
  // struct timespec ts1, ts2;
  // clock_gettime(CLOCK_REALTIME, &ts1);
  auto qxl_drawable = (QXLDrawable*)qxl_->GetMemSlotAddress(slot_address);

  QxlParser drawable(this);
  if (!drawable.Parse(qxl_drawable)) {
    qxl_->ReleaseGuestResource(&qxl_drawable->release_info);
    MV_ERROR("failed to parse drawable type=%d", drawable.type);
    return;
  }

  auto& bbox = drawable.bbox;
  auto& surface = GetSurface(drawable.surface_id);
  auto canvas = surface.canvas;

  switch (drawable.type)
  {
  case QXL_DRAW_FILL:
    canvas->ops->draw_fill(canvas, &drawable.bbox, &drawable.clip, &drawable.u.fill);
    break;
  case QXL_DRAW_OPAQUE:
    canvas->ops->draw_opaque(canvas, &drawable.bbox, &drawable.clip, &drawable.u.opaque);
    break;
  case QXL_DRAW_COPY:
    canvas->ops->draw_copy(canvas, &drawable.bbox, &drawable.clip, &drawable.u.copy);
    break;
  case QXL_COPY_BITS:
    canvas->ops->copy_bits(canvas, &drawable.bbox, &drawable.clip, &drawable.u.copy_bits.src_pos);
    break;
  case QXL_DRAW_BLEND:
    canvas->ops->draw_blend(canvas, &drawable.bbox, &drawable.clip, &drawable.u.blend);
    break;
  case QXL_DRAW_BLACKNESS:
    canvas->ops->draw_blackness(canvas, &drawable.bbox, &drawable.clip, &drawable.u.blackness);
    break;
  case QXL_DRAW_WHITENESS:
    canvas->ops->draw_whiteness(canvas, &drawable.bbox, &drawable.clip, &drawable.u.whiteness);
    break;
  case QXL_DRAW_INVERS:
    canvas->ops->draw_invers(canvas, &drawable.bbox, &drawable.clip, &drawable.u.invers);
    break;
  case QXL_DRAW_ROP3:
    canvas->ops->draw_rop3(canvas, &drawable.bbox, &drawable.clip, &drawable.u.rop3);
    break;
  case QXL_DRAW_STROKE:
    canvas->ops->draw_stroke(canvas, &drawable.bbox, &drawable.clip, &drawable.u.stroke);
    break;
  case QXL_DRAW_TEXT:
    canvas->ops->draw_text(canvas, &drawable.bbox, &drawable.clip, &drawable.u.text);
    break;
  case QXL_DRAW_TRANSPARENT:
    canvas->ops->draw_transparent(canvas, &drawable.bbox, &drawable.clip, &drawable.u.transparent);
    break;
  case QXL_DRAW_ALPHA_BLEND:
    canvas->ops->draw_alpha_blend(canvas, &drawable.bbox, &drawable.clip, &drawable.u.alphablend);
    break;
  default:
    MV_ERROR("unsupported type %d", drawable.type);
    break;
  }
  qxl_->ReleaseGuestResource(&qxl_drawable->release_info);

  AddDirtyRect(bbox.top, bbox.left, bbox.bottom, bbox.right);
  // clock_gettime(CLOCK_REALTIME, &ts2);
  // printf("diff draw %lu ns\n", ts2.tv_nsec - ts1.tv_nsec);
}

void QxlRender::UpdateArea(const QXLRect& rect, bool update_surface) {
  if (update_surface == 0) {
    AddDirtyRect(rect.top, rect.left, rect.bottom, rect.right);
  }
}

void QxlRender::GetUpdatePartials(std::vector<DisplayPartialBitmap>& partials) {
  if (dirty_rects_.empty())
    return;

  auto& surface = GetSurface(0);

  for (auto& rect : dirty_rects_) {
    DisplayPartialBitmap partial;
    partial.stride = surface.stride;
    partial.bpp = surface.bpp;
    partial.width = rect.right - rect.left;
    partial.height = rect.bottom - rect.top;
    partial.x = rect.left;
    partial.y = rect.top;
    partial.palette = nullptr;
    partial.data = surface.data + partial.stride * partial.y + partial.x * (partial.bpp / 8);
    partials.emplace_back(std::move(partial));
  }
  dirty_rects_.clear();
}

void QxlRender::Redraw() {
  dirty_rects_.clear();

  auto& surface = GetSurface(0);
  AddDirtyRect(0, 0, surface.height, surface.width);
}


void QxlRender::CreatePrimarySurface(const QXLSurfaceCreate& create, bool clear) {
  MV_ASSERT(surfaces_.find(0) == surfaces_.end());
  Surface surface;
  surface.id = 0;
  surface.slot_address = 0;
  surface.qxl_surface_cmd = nullptr;
  surface.bpp = qxl_->GetBitsPerPixelByFormat(create.format);
  surface.width = create.width;
  surface.height = create.height;
  surface.stride = create.stride;
  surface.data = (uint8_t*)qxl_->GetMemSlotAddress(create.mem);
  if (surface.stride < 0) {
    surface.data -= surface.stride * (surface.height - 1);
  }
  surface.canvas = canvas_create_for_data(surface.width, surface.height, create.format, surface.data, surface.stride,
    &render_ops_.image_cache, &render_ops_.image_surfaces, nullptr, nullptr, nullptr);
  surfaces_[surface.id] = surface;

  if (clear) {
    surface.canvas->ops->clear(surface.canvas);
  }

  Redraw();
  if (debug_) {
    MV_LOG("create primary %dx%dx%d stride=%d", surface.width, surface.height, surface.bpp, surface.stride);
  }
}

void QxlRender::DestroyPrimarySurface() {
  DestroySurface(0);
}

void QxlRender::CreateSurface(int surface_id, uint64_t slot_address) {
  MV_ASSERT(surfaces_.find(surface_id) == surfaces_.end());
  MV_ASSERT(surface_id > 0);
  MV_ASSERT(slot_address > 0);

  Surface surface;
  surface.id = surface_id;
  surface.slot_address = slot_address;
  surface.qxl_surface_cmd = (QXLSurfaceCmd*)qxl_->GetMemSlotAddress(slot_address);
  auto& create = surface.qxl_surface_cmd->u.surface_create;
  surface.bpp = qxl_->GetBitsPerPixelByFormat(create.format);
  surface.width = create.width;
  surface.height = create.height;
  surface.stride = create.stride;
  surface.data = (uint8_t*)qxl_->GetMemSlotAddress(create.data);
  if (surface.stride < 0) {
    surface.data -= surface.stride * (surface.height - 1);
  }
  surface.canvas = canvas_create_for_data(surface.width, surface.height, create.format, surface.data, surface.stride,
    &render_ops_.image_cache, &render_ops_.image_surfaces, nullptr, nullptr, nullptr);
  surfaces_[surface.id] = surface;

  if (debug_) {
    MV_LOG("create surface id=%d %dx%dx%d", surface_id, surface.width, surface.height, surface.bpp);
  }
}

const Surface& QxlRender::GetSurface(int surface_id) {
  auto it = surfaces_.find(surface_id);
  MV_ASSERT(it != surfaces_.end());
  return it->second;
}

void QxlRender::DestroySurface(int surface_id) {
  auto it = surfaces_.find(surface_id);
  if (it == surfaces_.end()) {
    MV_ERROR("failed to destroy surface %d", surface_id);
    return;
  }

  auto& surface = it->second;
  surface.canvas->ops->destroy(surface.canvas);
  surfaces_.erase(it);
  if (surface.qxl_surface_cmd) {
    qxl_->ReleaseGuestResource(&surface.qxl_surface_cmd->release_info);
  }

  if (debug_) {
    MV_LOG("destroy surface id=%d", surface.id);
  }
}

/* Align width to 16 and height to 2 for SSE or AVX */
void QxlRender::AddDirtyRect(int32_t top, int32_t left, int32_t bottom, int32_t right) {
  auto &surface = GetSurface(0);
  /* make sure position and size of the created slice is multiple of 2 */
  const int width_alignment = 16;
  if (left % width_alignment) {
    left -= left % width_alignment;
  }
  if (right % width_alignment) {
    right += width_alignment - (right % width_alignment);
  }

  const int height_alignment = 2;
  if (top % height_alignment) {
    top -= top % height_alignment;
  }
  if (bottom % height_alignment) {
    bottom += height_alignment - (bottom % height_alignment);
  }
  /* avoid overflow */
  if (right > surface.width) {
    right = surface.width;
  }
  if (bottom > surface.height) {
    bottom = surface.height;
  }
  if (right - left < 2 || bottom - top < 2) {
    return;
  }

  AddDirtyRectInternal(top, left, bottom, right);
}

/* Use dirty rectangle algorithm to remove overlapped parts */
void QxlRender::AddDirtyRectInternal(int32_t top, int32_t left, int32_t bottom, int32_t right) {
  if (left >= right || top >= bottom) {
    return;
  }

  size_t current_size = dirty_rects_.size();
  for (size_t i = 0; i < current_size; i++) {
    auto r = dirty_rects_[i];
    if (left < r.right && top < r.bottom && r.left < right && r.top < bottom) {
      if (top < r.top)
        AddDirtyRectInternal(top, left, r.top, right);
      if (bottom > r.bottom)
        AddDirtyRectInternal(r.bottom, left, bottom, right);
      if (left < r.left)
        AddDirtyRectInternal(std::max(top, r.top), left, std::min(bottom, r.bottom), r.left);
      if (right > r.right)
        AddDirtyRectInternal(std::max(top, r.top), r.right, std::min(bottom, r.bottom), right);
      return;
    }
  }

  dirty_rects_.emplace_back(QXLRect {
    top, left, bottom, right
  });
}

```

`devices/display/qxl/qxl_render.h`:

```h
/* 
 * MVisor QXL Render
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * Copy and modified from QEMU
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_QXL_RENDER_H
#define _MVISOR_DEVICES_QXL_RENDER_H

#include <cstdint>

#include <array>
#include <map>

#include "lru_cache.h"
#include "qxl_dev.h"
#include "canvas/sw_canvas.h"
#include "device_interface.h"

class Qxl;
class QxlRender;

struct QxlRenderOps {
  SpiceImageCache     image_cache;
  SpiceImageSurfaces  image_surfaces;
  QxlRender*          render = nullptr;
};

struct Surface {
  uint            id;
  uint64_t        slot_address;
  QXLSurfaceCmd*  qxl_surface_cmd;
  int             bpp;
  int             width;
  int             height;
  int             stride;
  uint8_t*        data;
  SpiceCanvas*    canvas;
};


class QxlRender {
 private:
  Qxl*                          qxl_;
  std::map<uint32_t, Surface>   surfaces_;
  SimpleLRUCache<uint64_t, void*> images_;
  QxlRenderOps                  render_ops_;
  bool                          debug_;
  std::vector<QXLRect>          dirty_rects_;

 public:
  inline std::map<uint32_t, Surface>&       surfaces() { return surfaces_; }
  inline SimpleLRUCache<uint64_t, void*>&   images() { return images_; }
  inline Qxl*                               qxl() { return qxl_; }

  QxlRender(Qxl* qxl);
  ~QxlRender();

  void CreatePrimarySurface(const QXLSurfaceCreate& create, bool clear);
  void DestroyPrimarySurface();

  void ParseSurfaceCommand(uint64_t slot_address);
  void ParseDrawCommand(uint64_t slot_address);

  void GetUpdatePartials(std::vector<DisplayPartialBitmap>& partials);
  void UpdateArea(const QXLRect& rect, bool update_surface);
  void Redraw();

 private:
  void CreateSurface(int surface_id, uint64_t slot_address);
  void DestroySurface(int surface_id);
  const Surface& GetSurface(int surface_id);
  void AddDirtyRect(int32_t top, int32_t left, int32_t bottom, int32_t right);
  void AddDirtyRectInternal(int32_t top, int32_t left, int32_t bottom, int32_t right);
};

#endif // _MVISOR_DEVICES_QXL_RENDER_H

```

`devices/display/vbe.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_VBE_H
#define _MVISOR_DEVICES_VBE_H

/*
 * bochs vesa bios extension interface
 */
#define VBE_DISPI_MAX_XRES              16000
#define VBE_DISPI_MAX_YRES              12000
#define VBE_DISPI_MAX_BPP               32

#define VBE_DISPI_INDEX_ID              0x0
#define VBE_DISPI_INDEX_XRES            0x1
#define VBE_DISPI_INDEX_YRES            0x2
#define VBE_DISPI_INDEX_BPP             0x3
#define VBE_DISPI_INDEX_ENABLE          0x4
#define VBE_DISPI_INDEX_BANK            0x5
#define VBE_DISPI_INDEX_VIRT_WIDTH      0x6
#define VBE_DISPI_INDEX_VIRT_HEIGHT     0x7
#define VBE_DISPI_INDEX_X_OFFSET        0x8
#define VBE_DISPI_INDEX_Y_OFFSET        0x9
#define VBE_DISPI_INDEX_NB              0xa /* size of vbe_regs[] */
#define VBE_DISPI_INDEX_VIDEO_MEMORY_64K 0xa /* read-only, not in vbe_regs */

/* VBE_DISPI_INDEX_ID */
#define VBE_DISPI_ID0                   0xB0C0
#define VBE_DISPI_ID1                   0xB0C1
#define VBE_DISPI_ID2                   0xB0C2
#define VBE_DISPI_ID3                   0xB0C3
#define VBE_DISPI_ID4                   0xB0C4
#define VBE_DISPI_ID5                   0xB0C5

/* VBE_DISPI_INDEX_ENABLE */
#define VBE_DISPI_DISABLED              0x00
#define VBE_DISPI_ENABLED               0x01
#define VBE_DISPI_GETCAPS               0x02
#define VBE_DISPI_8BIT_DAC              0x20
#define VBE_DISPI_LFB_ENABLED           0x40
#define VBE_DISPI_NOCLEARMEM            0x80

#endif // _MVISOR_DEVICES_VBE_H

```

`devices/display/vga.cc`:

```cc
/* 
 * MVisor VGA/VBE
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 * Since we want to implement QXL, don't waste time on VGA.
 * It's not recommended to use VGA mode due to performance problems.
 * Reference:
 * https://wiki.osdev.org/Bochs_VBE_Extensions
 * http://osdever.net/FreeVGA/vga/portidx.htm
 * https://wiki.osdev.org/VGA_Hardware
 */

#include "vga.h"
#include <cstring>
#include <sys/mman.h>

#include "logger.h"
#include "vbe.h"
#include "vga.pb.h"
#include "vga_regs.h"
#include "machine.h"

#define VGA_PIO_BASE    0x3C0
#define VGA_PIO_SIZE    0x20
#define VBE_PIO_BASE    0x1CE
#define VBE_PIO_SIZE    2
#define VBE_LINEAR_FRAMEBUFFER_BASE 0xE0000000

// When LFB mode disabled, the tradition VGA video memory address is used
#define VGA_MMIO_BASE   0x000A0000
#define VGA_MMIO_SIZE   0x00020000


Vga::Vga() {
  default_rom_path_ = "../share/vgabios-stdvga.bin";
  
  /* PCI config */
  pci_header_.vendor_id = 0x1234;
  pci_header_.device_id = 0x1111;
  pci_header_.class_code = 0x030000;
  pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;
  

  /* Bar 0: 256MB VRAM */
  vga_mem_size_ = _MB(16);
  vram_size_ = _MB(256);

  AddPciBar(0, vram_size_, kIoResourceTypeRam);    /* vgamem */
  /* FIXME: bar 2 should be implemented for stdvga if Qxl is not enabled??? */

  AddIoResource(kIoResourceTypePio, VGA_PIO_BASE, VGA_PIO_SIZE, "VGA IO");
  AddIoResource(kIoResourceTypePio, VBE_PIO_BASE, VBE_PIO_SIZE, "VBE IO");
  AddIoResource(kIoResourceTypeMmio, VGA_MMIO_BASE, VGA_MMIO_SIZE, "VGA MMIO",
    nullptr, kIoResourceFlagCoalescingMmio);
}

Vga::~Vga() {
}

void Vga::Reset() {
  PciDevice::Reset();
  bzero(&vbe_, sizeof(vbe_));
  bzero(&vga_, sizeof(vga_));

  vram_map_addr_ = 0;
  vram_map_size_ = 0;
  mode_ = kDisplayUnknownMode;
  width_ = 640;
  height_ = 480;
  bpp_ = 8;
  rows_ = cols_ = 0;
  font_height_ = font_width_ = 0;
  cursor_blink_time_ = std::chrono::steady_clock::now();
  cursor_visible_ = false;
  text_mode_ = false;

  if (vram_rw_mapped_) {
    RemoveIoResource(kIoResourceTypeRam, "VGA RAM");
    vram_rw_mapped_ = nullptr;
  }
}


bool Vga::SaveState(MigrationWriter* writer) {
  VgaState state;
  state.set_misc_output(vga_.misc_output);
  state.set_status(*(uint16_t*)vga_.status);
  state.set_sequencer_index(vga_.sequencer_index);
  state.set_sequencer(vga_.sequencer, sizeof(vga_.sequencer));
  state.set_gfx_index(vga_.gfx_index);
  state.set_gfx(vga_.gfx, sizeof(vga_.gfx));
  state.set_attribute_index(vga_.attribute_index);
  state.set_attribute(vga_.attribute, sizeof(vga_.attribute));
  state.set_crtc_index(vga_.crtc_index);
  state.set_crtc(vga_.crtc, sizeof(vga_.crtc));
  state.set_palette_read_index(vga_.palette_read_index);
  state.set_palette_write_index(vga_.palette_write_index);
  state.set_palette(vga_.palette, sizeof(vga_.palette));
  state.set_dac_state(vga_.dac_state);
  state.set_feature_control(vga_.feature_control);
  state.set_latch(vga_.latch);
  writer->WriteProtobuf("VGA", state);

  VbeState vbe_state;
  vbe_state.set_version(vbe_.version);
  vbe_state.set_index(vbe_.index);
  vbe_state.set_registers(vbe_.registers, sizeof(vbe_.registers));
  writer->WriteProtobuf("VBE", vbe_state);
  writer->WriteMemoryPages("VRAM", vram_base_, vram_size_);
  return PciDevice::SaveState(writer);
}

bool Vga::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }

  if (!reader->ReadMemoryPages("VRAM", (void**)&vram_base_, vram_size_)) {
    return false;
  }

  VgaState state;
  if (!reader->ReadProtobuf("VGA", state)) {
    return false;
  }
  vga_.misc_output = state.misc_output();
  *(uint16_t*)vga_.status = state.status();
  vga_.sequencer_index = state.sequencer_index();
  memcpy(vga_.sequencer, state.sequencer().data(), sizeof(vga_.sequencer));
  vga_.gfx_index = state.gfx_index();
  memcpy(vga_.gfx, state.gfx().data(), sizeof(vga_.gfx));
  vga_.attribute_index = state.attribute_index();
  memcpy(vga_.attribute, state.attribute().data(), sizeof(vga_.attribute));
  vga_.crtc_index = state.crtc_index();
  memcpy(vga_.crtc, state.crtc().data(), sizeof(vga_.crtc));
  vga_.palette_read_index = state.palette_read_index();
  vga_.palette_write_index = state.palette_write_index();
  memcpy(vga_.palette, state.palette().data(), sizeof(vga_.palette));
  vga_.dac_state = state.dac_state();
  vga_.feature_control = state.feature_control();
  vga_.latch = state.latch();

  VbeState vbe_state;
  if (!reader->ReadProtobuf("VBE", vbe_state)) {
    return false;
  }
  vbe_.version = vbe_state.version();
  vbe_.index = vbe_state.index();
  memcpy(vbe_.registers, vbe_state.registers().data(), sizeof(vbe_.registers));

  UpdateDisplayMode();
  UpdateVRamMemoryMap();
  return true;
}

void Vga::Connect() {
  /* Initialize rom data and rom bar size */
  if (!pci_rom_.data) {
    if (has_key("rom")) {
      std::string path = std::get<std::string>(key_values_["rom"]);
      LoadRomFile(path.c_str());
    } else {
      LoadRomFile(default_rom_path_.c_str());
    }
  }
  if (!vram_base_) {
    if (has_key("vram_size")) {
      uint64_t size = std::get<uint64_t>(key_values_["vram_size"]);
      MV_ASSERT(size >= 16 && size <= 512);
      if (size & (size - 1)) {
        MV_PANIC("vram_size must be power of 2");
      }
      vram_size_ = size << 20;
    }
    if (has_key("vga_size")) {
      uint64_t size = std::get<uint64_t>(key_values_["vga_size"]);
      MV_ASSERT(size >= 2 && size <= 256);
      if (size & (size - 1)) {
        MV_PANIC("vga_size must be power of 2");
      }
      vga_mem_size_ = size << 20;
    }
    vram_base_ = (uint8_t*)mmap(nullptr, vram_size_, PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE, -1, 0);
    pci_bars_[0].size = vram_size_;
    pci_bars_[0].host_memory = vram_base_;

    MV_ASSERT(madvise(vram_base_, vram_size_, MADV_DONTDUMP) == 0);
  }

  if (has_key("debug_io")) {
    debug_io_ = std::get<bool>(key_values_["debug_io"]);
  }

  PciDevice::Connect();

  refresh_timer_ = AddTimer(NS_PER_SECOND / 30, true, std::bind(&Vga::OnRefreshTimer, this));
}

void Vga::Disconnect() {
  if (vram_base_) {
    munmap((void*)vram_base_, vram_size_);
    vram_base_ = nullptr;
  }

  if (refresh_timer_) {
    RemoveTimer(refresh_timer_);
    refresh_timer_ = nullptr;
  }
  mode_ = kDisplayUnknownMode;
  PciDevice::Disconnect();
}

void Vga::OnRefreshTimer() {
  if (mode_ == kDisplayVbeMode || mode_ == kDisplayVgaMode) {
    NotifyDisplayUpdate();
  }
}

void Vga::GetCursorLocation(uint8_t* x, uint8_t* y, uint8_t* sel_start, uint8_t* sel_end) {
  uint16_t location = (vga_.crtc[VGA_CRTC_CURSOR_HI] << 8) | (vga_.crtc[VGA_CRTC_CURSOR_LO]);
  *sel_start = vga_.crtc[VGA_CRTC_CURSOR_START] & 0x1F;
  *sel_end = vga_.crtc[VGA_CRTC_CURSOR_END] & 0x1F;
  *y = (location / 80) % 25;
  *x = location % 80;
}

void Vga::GetDisplayMode(int* w, int* h, int* bpp, int* stride) {
  if (w)
    *w = width_;
  if (h)
    *h = height_;
  if (bpp)
    *bpp = bpp_;
  if (stride)
    *stride = stride_;
}

void Vga::GetPalette(const uint8_t** palette, int* count) {
  int shift_control = (vga_.gfx[VGA_GFX_MODE] >> 5) & 3;
  *count = shift_control >= 2 ? 256 : 16;
  *palette = (const uint8_t*)vga_.palette;
  if (vbe_.registers[VBE_DISPI_ENABLED] & VBE_DISPI_8BIT_DAC) {
    MV_LOG("warning: 8bit DAC is in use");
  }
}

void Vga::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  uint64_t port = resource->base + offset;

  if (resource->base == VGA_MMIO_BASE) {
    for (size_t i = 0; i < size; i++) {
      VgaReadMemory(port + i, &data[i]);
    }
  } else if (resource->base == VGA_PIO_BASE) {
    VgaReadPort(port, &data[0]);
    for (size_t i = 1; i < size; i++) {
      VgaReadPort(port + 1, &data[i]);
    }
  } else if (resource->base == VBE_PIO_BASE) {
    if (size == 2) {
      VbeReadPort(port, (uint16_t*)data);
    }
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

void Vga::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  uint64_t port = resource->base + offset;
  if (resource->base == VGA_MMIO_BASE) {
    for (size_t i = 0; i < size; i++) {
      VgaWriteMemory(port + i, data[i]);
    }
  } else if (resource->base == VGA_PIO_BASE) {
    VgaWritePort(port, data[0]);
    for (size_t i = 1; i < size; i++) {
      VgaWritePort(port + 1, data[i]);
    }
  } else if (resource->base == VBE_PIO_BASE) {
    MV_ASSERT(size == 2);
    VbeWritePort(port, *(uint16_t*)data);
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

void Vga::VbeReadPort(uint64_t port, uint16_t* data) {
  if (port == 0x1CE) {
    *data = vbe_.index;
  } else if (port == 0x1CF) {
    MV_ASSERT(vbe_.index <= VBE_DISPI_INDEX_NB);
    if (vbe_.index == VBE_DISPI_INDEX_VIDEO_MEMORY_64K) {
      *data = vram_size_ >> 16;
    } else {
      if (vbe_.registers[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {
        /* VBE initialization will enable and get capabilities and then disable */
        const uint16_t max_values[] = {
          0, VBE_DISPI_MAX_XRES, VBE_DISPI_MAX_YRES, VBE_DISPI_MAX_BPP
        };
        MV_ASSERT(vbe_.index < sizeof(max_values) / sizeof(uint16_t));
        *data = max_values[vbe_.index];
      } else {
        *data = vbe_.registers[vbe_.index];
      }
    }
  }
}

void Vga::VbeWritePort(uint64_t port, uint16_t value) {
  if (port == 0x1CE) { // index
    MV_ASSERT(value <= VBE_DISPI_INDEX_NB);
    vbe_.index = value;
  } else if (port == 0x1CF) { // data
    vbe_.registers[vbe_.index] = value;
    switch (vbe_.index)
    {
    case VBE_DISPI_INDEX_ID:
      vbe_.version = value;
      break;
    case VBE_DISPI_INDEX_ENABLE:
      if (debug_) {
        MV_LOG("set vbe enable to %x(mode=%d) %dx%d bpp=%d", value, mode_,
          vbe_.registers[1], vbe_.registers[2], vbe_.registers[3]);
      }
      if (value & VBE_DISPI_ENABLED) {
        vbe_.registers[VBE_DISPI_INDEX_VIRT_WIDTH] = 0;
        vbe_.registers[VBE_DISPI_INDEX_VIRT_HEIGHT] = 0;
        vbe_.registers[VBE_DISPI_INDEX_X_OFFSET] = 0;
        vbe_.registers[VBE_DISPI_INDEX_Y_OFFSET] = 0;
        UpdateDisplayMode();
        if (!(value & VBE_DISPI_NOCLEARMEM)) {
          bzero(vram_base_, height_ * stride_);
        }
      } else {
        vbe_.registers[VBE_DISPI_INDEX_BANK] = 0;
      }
      UpdateVRamMemoryMap();
      break;
    case VBE_DISPI_INDEX_BANK:
      UpdateVRamMemoryMap();
      break;
    }
  }
}

void Vga::VgaReadPort(uint64_t port, uint8_t* data) {
  switch (port)
  {
  case VGA_ATT_W:
    *data = vga_.attribute_index & 0x80 ? 0 : vga_.attribute_index;
    break;
  case VGA_ATT_R:
    *data = vga_.attribute[vga_.attribute_index & 0x1F];
    break;
  case VGA_SEQ_I:
    *data = vga_.sequencer_index;
    break;
  case VGA_SEQ_D:
    *data = vga_.sequencer[vga_.sequencer_index];
    break;
  case VGA_PEL_MSK: 
    *data = 0xFF;
    break;
  case VGA_PEL_IR:
    *data = vga_.dac_state;
    break;
  case VGA_PEL_IW:
    *data = vga_.palette_write_index;
    break;
  case VGA_PEL_D:
    *data = vga_.palette[vga_.palette_read_index++];
    break;
  case VGA_FTC_R:
    *data = vga_.feature_control;
    break;
  case VGA_MIS_R:
    *data = vga_.misc_output;
    break;
  case VGA_GFX_I:
    *data = vga_.gfx_index;
    break;
  case VGA_GFX_D:
    *data = vga_.gfx[vga_.gfx_index];
    break;
  case VGA_CRT_IC:
    *data = vga_.crtc_index;
    break;
  case VGA_CRT_DC:
    *data = vga_.crtc[vga_.crtc_index];
    break;
  case VGA_IS1_RC:
    vga_.attribute_index &= ~0x80; // Clears attribute flip-flop
    vga_.status[1] ^= 9;
    *data = vga_.status[1];
    break;
  default:
    *data = 0xFF;
    MV_ERROR("not implemented %s port=0x%lX data=0x%02X", name_, port, *data);
    break;
  }

  if (debug_io_) {
    MV_LOG("R %s(%lX) data=0x%02X", vga_port_name(port, false), port, *data);
  }
}

void Vga::VgaWritePort(uint64_t port, uint32_t value) {
  if (debug_io_) {
    MV_LOG("W %s(%lX) data=0x%02X", vga_port_name(port, true), port, value);
  }

  switch (port)
  {
  case VGA_ATT_IW:
    if (vga_.attribute_index & 0x80) { // set data
      vga_.attribute_index &= 0x1F;
      switch (vga_.attribute_index)
      {
      case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:
        vga_.attribute[vga_.attribute_index] = value & 0x3F;
        break;
      case VGA_ATC_MODE:
        vga_.attribute[vga_.attribute_index] = value & ~0x10;
        break;
      case VGA_ATC_OVERSCAN:
        vga_.attribute[vga_.attribute_index] = value;
        break;
      case VGA_ATC_PLANE_ENABLE:
        vga_.attribute[vga_.attribute_index] = value & ~0xC0;
        break;
      case VGA_ATC_PEL:
      case VGA_ATC_COLOR_PAGE:
        vga_.attribute[vga_.attribute_index] = value & ~0xF0;
        break;
      default:
        break;
      }
    } else { // set index
      vga_.attribute_index = 0x80 | (value & 0x3F);
      if (vga_.attribute_index & VGA_AR_ENABLE_DISPLAY) {
        // renderer changed event
        UpdateDisplayMode();
      }
    }
    break;
  case VGA_MIS_W:
    vga_.misc_output = value & ~0x10;
    break;
  case VGA_SEQ_I:
    vga_.sequencer_index = value & 7;
    break;
  case VGA_SEQ_D: {
    const uint8_t masks[] = { 0x3, 0x3D, 0xF, 0x3F, 0xE, 0, 0, 0xFF };
    vga_.sequencer[vga_.sequencer_index] = value & masks[vga_.sequencer_index];
    break;
  }
  case VGA_PEL_MSK:
    MV_ASSERT(value == 0xFF); // palette mask
    break;
  case VGA_PEL_IR:
    vga_.palette_read_index = value * 3;
    vga_.dac_state = 3;
    break;
  case VGA_PEL_IW:
    vga_.palette_write_index = value * 3;
    vga_.dac_state = 0;
    break;
  case VGA_PEL_D:
    vga_.palette[vga_.palette_write_index++] = value;
    break;
  case VGA_GFX_I:
    vga_.gfx_index = value & 0xF;
    break;
  case VGA_GFX_D: {
    const uint8_t masks[16] = { 0xF, 0xF, 0xF, 0x1F, 0x3, 0x7B, 0xF, 0xF, 0xFF, 0 };
    vga_.gfx[vga_.gfx_index] = value & masks[vga_.gfx_index];
    if (vga_.gfx_index == VGA_GFX_MISC) {
      UpdateVRamMemoryMap();
    }
    break;
  }
  case VGA_CRT_IC:
    vga_.crtc_index = value;
    break;
  case VGA_CRT_DC:
    vga_.crtc[vga_.crtc_index] = value;
    break;
  default:
    MV_ERROR("not implemented %s port=0x%lx data=0x%x", name_, port, value);
    break;
  }
}

void Vga::VgaReadMemory(uint64_t addr, uint8_t* data) {
  if (addr < vram_map_addr_ || addr >= vram_map_addr_ + vram_map_size_) {
    *data = 0xFF;
    return;
  }

  addr -= vram_map_addr_;

  if (vga_.sequencer[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {
    /* chain 4 mode */
    MV_ASSERT(addr < vram_size_);
    *data = vram_base_[addr];
  } else if (vga_.gfx[VGA_GFX_MODE] & 0x10) {
    /* odd / even (text) mode */
    uint plane = (vga_.gfx[VGA_GFX_PLANE_READ] & 2) | (addr & 1);
    addr = ((addr & ~1) << 1) | plane;
    MV_ASSERT(addr < vram_size_);
    *data = vram_base_[addr];
  } else {
    /* standard VGA latched access */
    MV_ASSERT(addr * sizeof(uint32_t) < vram_size_);
    vga_.latch = ((uint32_t*)vram_base_)[addr];

    if (vga_.gfx[VGA_GFX_MODE] & 8) {
      /* read mode 1 */
      uint value = (vga_.latch ^ mask16[vga_.gfx[VGA_GFX_COMPARE_VALUE]]) &
        mask16[vga_.gfx[VGA_GFX_COMPARE_MASK]];
      value |= value >> 16;
      value |= value >> 8;
      *data = (~value) & 0xFF;
    } else {
      /* read mode 0 */
      int plane = vga_.gfx[VGA_GFX_PLANE_READ];
      *data = (vga_.latch >> (plane * 8)) & 0xFF;
    }
  }
}

/* For graphic mode, VGA RAM normally starts at 0xA0000 while text mode at 0xB8000 */
void Vga::VgaWriteMemory(uint64_t addr, uint32_t value) {
  if (addr < vram_map_addr_ || addr >= vram_map_addr_ + vram_map_size_) {
    return;
  }

  addr -= vram_map_addr_;

  if (vga_.sequencer[VGA_SEQ_MEMORY_MODE] & VGA_SR04_CHN_4M) {
    /* chain 4 mode */
    uint plane = addr & 3;
    uint mask = (1 << plane);
    if (vga_.sequencer[VGA_SEQ_PLANE_WRITE] & mask) {
      vram_base_[addr] = value;
    }
  } else if (vga_.gfx[VGA_GFX_MODE] & 0x10) {
    /* odd / even (text) mode */
    uint plane = (vga_.gfx[VGA_GFX_PLANE_READ] & 2) | (addr & 1);
    uint mask = (1 << plane);
    if (vga_.sequencer[VGA_SEQ_PLANE_WRITE] & mask) {
      addr = ((addr & ~1) << 1) | plane;
      MV_ASSERT(addr < vram_size_);
      vram_base_[addr] = value;
    }
  } else {
    /* standard VGA latched access */
    uint write_mode = vga_.gfx[VGA_GFX_MODE] & 3;
    uint set_mask, bit_mask, write_mask, logical_function, b;

    switch (write_mode)
    {
    case 0:
      /* rotate */
      b = vga_.gfx[VGA_GFX_DATA_ROTATE] & 7;
      value = ((value >> b) | (value << (8 - b))) & 0xFF;
      value |= value << 8;
      value |= value << 16;

      /* apply set / reset mask */
      set_mask = mask16[vga_.gfx[VGA_GFX_SR_ENABLE]];
      value = (value & ~set_mask) | (mask16[vga_.gfx[VGA_GFX_SR_VALUE]] & set_mask);
      bit_mask = vga_.gfx[VGA_GFX_BIT_MASK];
      break;
    case 1:
      value = vga_.latch;
      goto write_value;
    case 2:
      value = mask16[value & 0xF];
      bit_mask = vga_.gfx[VGA_GFX_BIT_MASK];
      break;
    case 3:
      /* rotate */
      b = vga_.gfx[VGA_GFX_DATA_ROTATE] & 7;
      value = (value >> b) | (value << (8 - b));
      
      bit_mask = vga_.gfx[VGA_GFX_BIT_MASK] & value;
      value = mask16[vga_.gfx[VGA_GFX_SR_VALUE]];
      break;
    }

    /* apply logical operation */
    logical_function = vga_.gfx[VGA_GFX_DATA_ROTATE] >> 3;
    switch (logical_function)
    {
    case 1:
      value &= vga_.latch;
      break;
    case 2:
      value |= vga_.latch;
      break;
    case 3:
      value ^= vga_.latch;
      break;
    default:
      break;
    }

    /* apply bit mask */
    bit_mask |= bit_mask << 8;
    bit_mask |= bit_mask << 16;
    value = (value & bit_mask) | (vga_.latch & ~bit_mask);

write_value:
    /* mask data according to plane write */
    write_mask = mask16[vga_.sequencer[VGA_SEQ_PLANE_WRITE]];
    MV_ASSERT(addr * sizeof(uint32_t) < vram_size_);
    auto write_ptr = (uint32_t*)vram_base_;
    write_ptr[addr] = (write_ptr[addr] & ~write_mask) | (value & write_mask);

    // printf("vga: latch: [0x%016lx] mask=0x%08x val=0x%08x\n",
    //         addr * 4, write_mask, value);
  }
}

void Vga::UpdateVRamMemoryMap() {
  uint8_t* map_memory = nullptr;
  if (vbe_.registers[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED) {
    vram_map_addr_ = VGA_MMIO_BASE;
    vram_map_size_ = VGA_MMIO_SIZE;
  
    map_memory = vram_base_ + (vbe_.registers[VBE_DISPI_INDEX_BANK] << 16);
  } else {
    const size_t map_types[][2] = {
      { 0xA0000, 0x20000 }, { 0xA0000, 0x10000 },
      { 0xB0000, 0x08000 }, { 0xB8000, 0x08000 }
    };
    
    /* Memory map select controls visual area while read select controls IO */
    int index = (vga_.gfx[VGA_GFX_MISC] >> 2) & 0b11;
    auto& map_type = map_types[index];
    vram_map_addr_ = map_type[0];
    vram_map_size_ = map_type[1];
  }
  
  /* Map / unmap the area as ram to accelerate */
  if (vram_rw_mapped_ != map_memory) {
    if (vram_rw_mapped_) {
      RemoveIoResource(kIoResourceTypeRam, "VGA RAM");
    }
    if (map_memory) {
      AddIoResource(kIoResourceTypeRam, vram_map_addr_, vram_map_size_, "VGA RAM", map_memory);
      if (debug_) {
        MV_LOG("map plane addr=0x%08x[0x08%x] to 0x%016lx", vram_map_addr_, vram_map_size_, map_memory);
      }

      vram_rw_mapped_ = map_memory;
    }
  }
}

void Vga::UpdateDisplayMode() {
  auto old_mode = mode_;
  auto old_w = width_, old_h = height_, old_bpp = bpp_;

  if (vbe_.registers[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED) {
    /* Read resolution from VBE regsiters */
    mode_ = kDisplayVbeMode;

    auto& r = vbe_.registers;
    r[VBE_DISPI_INDEX_XRES] &= ~3;
    if (r[VBE_DISPI_INDEX_XRES] == 0) {
      r[VBE_DISPI_INDEX_XRES] = 4;
    }
    if (r[VBE_DISPI_INDEX_XRES] > VBE_DISPI_MAX_XRES) {
      r[VBE_DISPI_INDEX_XRES] = VBE_DISPI_MAX_XRES;
    }
    r[VBE_DISPI_INDEX_VIRT_WIDTH] &= ~3;
    if (r[VBE_DISPI_INDEX_VIRT_WIDTH] > VBE_DISPI_MAX_XRES) {
      r[VBE_DISPI_INDEX_VIRT_WIDTH] = VBE_DISPI_MAX_XRES;
    }
    if (r[VBE_DISPI_INDEX_VIRT_WIDTH] < r[VBE_DISPI_INDEX_XRES]) {
      r[VBE_DISPI_INDEX_VIRT_WIDTH] = r[VBE_DISPI_INDEX_XRES];
    }

    if (r[VBE_DISPI_INDEX_YRES] == 0) {
      r[VBE_DISPI_INDEX_YRES] = 1;
    }
    if (r[VBE_DISPI_INDEX_YRES] > VBE_DISPI_MAX_YRES) {
      r[VBE_DISPI_INDEX_YRES] = VBE_DISPI_MAX_YRES;
    }

    if (r[VBE_DISPI_INDEX_X_OFFSET] > VBE_DISPI_MAX_XRES) {
      r[VBE_DISPI_INDEX_X_OFFSET] = VBE_DISPI_MAX_XRES;
    }
    if (r[VBE_DISPI_INDEX_Y_OFFSET] > VBE_DISPI_MAX_YRES) {
      r[VBE_DISPI_INDEX_Y_OFFSET] = VBE_DISPI_MAX_YRES;
    }

    width_ = r[VBE_DISPI_INDEX_XRES];
    height_ = r[VBE_DISPI_INDEX_YRES];
    bpp_ = r[VBE_DISPI_INDEX_BPP];
    stride_ = r[VBE_DISPI_INDEX_VIRT_WIDTH] * bpp_ / 8;
  } else  if (vga_.attribute_index & VGA_AR_ENABLE_DISPLAY) {
    /* Read resolution from VGA registers */
    mode_ = kDisplayVgaMode;
    text_mode_ = !(vga_.gfx[VGA_GFX_MISC] & VGA_GR06_GRAPHICS_MODE);
  
    font_height_ = (vga_.crtc[VGA_CRTC_MAX_SCAN] & 0x1F) + 1;
    font_width_ = 8;
    if (!(vga_.sequencer[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {
      font_width_ = 9;
    }
    cols_ = vga_.crtc[VGA_CRTC_H_DISP] + 1;
    width_ = cols_ * font_width_;
    height_ = vga_.crtc[VGA_CRTC_V_DISP_END] |
      ((vga_.crtc[VGA_CRTC_OVERFLOW] & 0x02) << 7) |
      ((vga_.crtc[VGA_CRTC_OVERFLOW] & 0x40) << 3);
    height_ += 1;
    rows_ = height_ / font_height_;
    bpp_ = 8;
    stride_ = width_ * bpp_ / 8;
  } else {
    mode_ = kDisplayUnknownMode;
    return;
  }

  if (old_mode != mode_ || old_w != width_ || old_h != height_ || old_bpp != bpp_) {
    NotifyDisplayModeChange();
  }
}

void Vga::NotifyDisplayModeChange() {
  if (debug_) {
    MV_LOG("update mode=%d %dx%dx%d stride=%d", mode_, width_, height_, bpp_, stride_);
  }
  for (auto &listener : display_mode_change_listeners_) {
    listener();
  }
}

void Vga::NotifyDisplayUpdate() {
  for (auto &listener : display_update_listeners_) {
    listener();
  }
}

void Vga::RegisterDisplayModeChangeListener(DisplayModeChangeListener callback) {
  display_mode_change_listeners_.push_back(callback);
}

void Vga::RegisterDisplayUpdateListener(DisplayUpdateListener callback) {
  display_update_listeners_.push_back(callback);
}

/* This interface method is called by UI thread, remember to lock the device */
bool Vga::AcquireUpdate(DisplayUpdate& update, bool redraw) {
  std::unique_lock<std::recursive_mutex> lock(mutex_);
  if (mode_ == kDisplayUnknownMode) {
    return false;
  }
  /* VGA always update the whole surface */
  MV_UNUSED(redraw);

  DisplayPartialBitmap partial;
  partial.stride = stride_;
  partial.bpp = bpp_;
  partial.width = width_;
  partial.height = height_;
  partial.x = 0;
  partial.y = 0;
  partial.palette = vga_.palette;

  if (mode_ == kDisplayVbeMode) {
    size_t offset = vbe_.registers[VBE_DISPI_INDEX_X_OFFSET] * bpp_ / 8;
    offset += vbe_.registers[VBE_DISPI_INDEX_Y_OFFSET] * stride_;
    partial.data = vram_base_ + offset;
  } else if (mode_ == kDisplayVgaMode) {
    size_t data_size = stride_ * height_;
    if (vga_surface_.size() != data_size) {
      vga_surface_.resize(data_size);
    }
    partial.data = (uint8_t*)vga_surface_.data();

    /* FIXME: Should unlock the device but crashed when display mode was changing */
    // lock.unlock();
    if (text_mode_) {
      DrawText(partial.data);

      /* blink cursor */
      auto now = std::chrono::steady_clock::now();
      if (now >= cursor_blink_time_) {
        cursor_blink_time_ = now + std::chrono::milliseconds(250);
        cursor_visible_ = !cursor_visible_;
      }
      if (cursor_visible_) {
        DrawTextCursor(partial.data);
      }
    } else if (mode_ == kDisplayVgaMode) {
      DrawGraphic(partial.data);
    }
  }

  update.partials.emplace_back(std::move(partial));
  update.cursor.visible = false;
  return true;
}

void Vga::ReleaseUpdate() {
}

void Vga::DrawGraphic(uint8_t* buffer) {
  /* shift_control to determine 640x480 16 or 256 color mode */
  int shift_control = (vga_.gfx[VGA_GFX_MODE] >> 5) & 3;
  uint plane_mask = vga_.attribute[VGA_ATC_PLANE_ENABLE];
  uint8_t* dst = buffer;
  uint8_t* src = vram_base_;
  uint src_stride = vga_.crtc[VGA_CRTC_OFFSET] << 3;
  uint start_addr = vga_.crtc[VGA_CRTC_START_LO] | (vga_.crtc[VGA_CRTC_START_HI] << 8);
  src += start_addr * 4;

  for (int y = 0; y < rows_; y++) {
    auto s = src, d = dst;

    if (shift_control >= 2) {
      for (int x = 0; x < cols_; x++) {
        d[0] = d[1] = s[0];
        d[2] = d[3] = s[1];
        d[4] = d[5] = s[2];
        d[6] = d[7] = s[3];
        d += 8;
        s += 4;
      }
    } else {
      for (int x = 0; x < cols_; x++) {
        uint8_t p0 = s[0], p1 = s[1], p2 = s[2], p3 = s[3];
        for (int bit = 0x80; bit >= 1; bit >>= 1) {
          uint8_t pixel = ((p0 & bit) ? 1 : 0) |
                          ((p1 & bit) ? 2 : 0) |
                          ((p2 & bit) ? 4 : 0) |
                          ((p3 & bit) ? 8 : 0);
          pixel &= plane_mask;
          *d++ = vga_.attribute[pixel] & 0xF;
        }
        s += 4;
      }
    }
    src += src_stride;
    dst += stride_;
  }
}

void Vga::DrawText(uint8_t* buffer) {
  uint character_map = vga_.sequencer[VGA_SEQ_CHARACTER_MAP];
  uint8_t* fonts[2];
  fonts[0] = vram_base_ + ((character_map >> 5 & 1) | (character_map >> 1 & 6)) * 0x4000;
  fonts[1] = vram_base_ + ((character_map >> 4 & 1) | (character_map << 1 & 6)) * 0x4000;

  uint line_offset = vga_.crtc[VGA_CRTC_OFFSET] << 3;
  uint start_addr = (vga_.crtc[VGA_CRTC_START_HI] << 8) | (vga_.crtc[VGA_CRTC_START_LO]);
  uint8_t* dst = buffer;
  uint8_t* src = vram_base_ + start_addr * 4;

  for (int y = 0; y < rows_; y++) {
    auto s = src, d = dst;
    for (int x = 0; x < cols_; x++) {
      int character = s[0], attribute = s[1];
      DrawCharacter(d, fonts[(attribute >> 3) & 1], character, attribute);
      s += 4;
      d += font_width_;
    }

    src += line_offset;
    dst += stride_ * font_height_;
  }
}

/* supports font width 8 / 9 */
void Vga::DrawCharacter(uint8_t* dest, uint8_t* font, int character, int attribute) {
  uint8_t fore_color = attribute & 0xF;
  uint8_t back_color = (attribute >> 4) & 0xF;
  font += 2 + character * 32 * 4;
  bool dup9 = (vga_.attribute[VGA_ATC_MODE] & 0x4) && character >= 0xB0 && character <= 0xDF;

  for (int yy = 0; yy < font_height_; yy++) {
    uint value;
    uint font_data = font[0];
    uint8_t* ptr = dest;
    for (uint bit = 0x80; bit >= 1; bit >>= 1) {
      value = font_data & bit ? fore_color : back_color;
      *ptr++ = value;
    }
    if (font_width_ >= 9) {
      *ptr++ = dup9 ? value : back_color;
    }
    dest += stride_;
    font += 4;
  }
}

void Vga::DrawTextCursor(uint8_t* buffer) {
  uint32_t fore_color = 7;
  uint8_t cx, cy, sl_start, sl_end;
  GetCursorLocation(&cx, &cy, &sl_start, &sl_end);

  buffer += (cy * font_height_) * stride_;
  buffer += cx * font_width_;

  uint8_t* end = buffer + stride_ * height_;

  buffer += stride_ * sl_start;

  for (int y = sl_start; y < sl_end; y++) {
    for (int x = 0; x < font_width_; x++) {
      if (buffer + x < end) {
        buffer[x] = fore_color;
      }
    }
    buffer += stride_;
  }
}

DECLARE_DEVICE(Vga);

```

`devices/display/vga.h`:

```h
/* 
 * MVisor VGA/VBE
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_VGA_H
#define _MVISOR_DEVICES_VGA_H

#include <mutex>

#include "pci_device.h"
#include "device_interface.h"
#include "device_manager.h"

#define _MB(x) (x * (1 << 20))

enum DisplayMode {
  kDisplayUnknownMode,
  kDisplayVgaMode,
  kDisplayVbeMode,
  kDisplayQxlMode
};

class Vga : public PciDevice, public DisplayInterface {
 private:
  struct {
  uint8_t   misc_output;
  uint8_t   status[2];
  uint8_t   sequencer_index;
  uint8_t   sequencer[256];
  uint8_t   gfx_index;
  uint8_t   gfx[256];
  uint8_t   attribute_index;
  uint8_t   attribute[0x15];
  uint8_t   crtc_index;
  uint8_t   crtc[0x19];
  uint16_t  palette_read_index;
  uint16_t  palette_write_index;
  uint8_t   palette[256 * 3];
  uint8_t   dac_state;
  uint8_t   feature_control;
  uint32_t  latch;
  } vga_;

  struct {
    uint16_t version;
    uint16_t index;
    uint16_t registers[16];
  } vbe_;

  uint32_t  vram_map_addr_;
  uint32_t  vram_map_size_;
  uint8_t*  vram_rw_mapped_ = nullptr;

  std::vector<DisplayModeChangeListener> display_mode_change_listeners_;
  std::vector<DisplayUpdateListener> display_update_listeners_;

  void VbeReadPort(uint64_t port, uint16_t* data);
  void VbeWritePort(uint64_t port, uint16_t value);
  void VgaReadPort(uint64_t port, uint8_t* data);
  void VgaWritePort(uint64_t port, uint32_t value);
  void VgaWriteMemory(uint64_t offset, uint32_t value);
  void VgaReadMemory(uint64_t offset, uint8_t* data);
  void UpdateVRamMemoryMap();
  void RenderTextMode();
  void RenderGraphicsMode();
  void GetTextResolution();
  void DrawGraphic(uint8_t* buffer);
  void DrawText(uint8_t* buffer);
  void DrawCharacter(uint8_t* dest, uint8_t* font, int character, int attribute);
  void DrawTextCursor(uint8_t* buffer);
  void GetCursorLocation(uint8_t* x, uint8_t* y, uint8_t* sel_start, uint8_t* sel_end);

 protected:
  uint32_t    vram_size_;
  uint8_t*    vram_base_ = nullptr;
  uint32_t    vga_mem_size_;

  /* Render mode */
  DisplayMode mode_;
  int         width_;
  int         height_;
  int         bpp_;
  int         stride_;

  /* VGA mode */
  int         rows_;
  int         cols_;
  int         font_width_;
  int         font_height_;
  IoTimePoint cursor_blink_time_;
  bool        cursor_visible_;
  bool        text_mode_;

  std::string vga_surface_;
  std::recursive_mutex      mutex_;
  std::string default_rom_path_;
  IoTimer*    refresh_timer_ = nullptr;
  bool        debug_io_ = false;

  void NotifyDisplayModeChange();
  void NotifyDisplayUpdate();
  void OnRefreshTimer();
  virtual void UpdateDisplayMode();

 public:
  Vga();
  virtual ~Vga();

  virtual void Reset();
  virtual void Connect();
  virtual void Disconnect();
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

  virtual void GetDisplayMode(int* w, int* h, int* bpp, int* stride);
  virtual void GetPalette(const uint8_t** palette, int* count);

  virtual void RegisterDisplayModeChangeListener(DisplayModeChangeListener callback);
  virtual void RegisterDisplayUpdateListener(DisplayUpdateListener callback);
  virtual bool AcquireUpdate(DisplayUpdate& update, bool redraw);
  virtual void ReleaseUpdate();
};

#endif // _MVISOR_DEVICES_VGA_H

```

`devices/display/vga.proto`:

```proto
syntax ="proto3";

message VgaState {
  uint32  misc_output             = 1;
  uint32  status                  = 2;
  uint32  sequencer_index         = 3;
  bytes   sequencer               = 4;
  uint32  gfx_index               = 5;
  bytes   gfx                     = 6;
  uint32  attribute_index         = 7;
  bytes   attribute               = 8;
  uint32  crtc_index              = 9;
  bytes   crtc                    = 10;
  uint32  palette_read_index      = 11;
  uint32  palette_write_index     = 12;
  bytes   palette                 = 13;
  uint32  dac_state               = 14;
  uint32  feature_control         = 15;
  uint32  latch                   = 16;
}

message VbeState {
  uint32  version                 = 1;
  uint32  index                   = 2;
  bytes   registers               = 3;
}

```

`devices/display/vga_regs.h`:

```h
/*
 * linux/include/video/vga.h -- standard VGA chipset interaction
 *
 * Copyright 1999 Jeff Garzik <jgarzik@pobox.com>
 *
 * Copyright history from vga16fb.c:
 *	Copyright 1999 Ben Pfaff and Petr Vandrovec
 *	Based on VGA info at http://www.osdever.net/FreeVGA/home.htm
 *	Based on VESA framebuffer (c) 1998 Gerd Knorr
 *
 * This file is subject to the terms and conditions of the GNU General
 * Public License.  See the file COPYING in the main directory of this
 * archive for more details.
 *
 */

#ifndef DEVICES_VGA_REGS_H
#define DEVICES_VGA_REGS_H

/* Some of the code below is taken from SVGAlib.  The original,
   unmodified copyright notice for that code is below. */
/* VGAlib version 1.2 - (c) 1993 Tommy Frandsen                    */
/*                                                                 */
/* This library is free software; you can redistribute it and/or   */
/* modify it without any restrictions. This library is distributed */
/* in the hope that it will be useful, but without any warranty.   */

/* Multi-chipset support Copyright 1993 Harm Hanemaayer */
/* partially copyrighted (C) 1993 by Hartmut Schirmer */

/* VGA data register ports */
#define VGA_CRT_DC      0x3D5   /* CRT Controller Data Register - color emulation */
#define VGA_CRT_DM      0x3B5   /* CRT Controller Data Register - mono emulation */
#define VGA_ATT_R       0x3C1   /* Attribute Controller Data Read Register */
#define VGA_ATT_W       0x3C0   /* Attribute Controller Data Write Register */
#define VGA_GFX_D       0x3CF   /* Graphics Controller Data Register */
#define VGA_SEQ_D       0x3C5   /* Sequencer Data Register */
#define VGA_MIS_R       0x3CC   /* Misc Output Read Register */
#define VGA_MIS_W       0x3C2   /* Misc Output Write Register */
#define VGA_FTC_R       0x3CA   /* Feature Control Read Register */
#define VGA_IS1_RC      0x3DA   /* Input Status Register 1 - color emulation */
#define VGA_IS1_RM      0x3BA   /* Input Status Register 1 - mono emulation */
#define VGA_PEL_D       0x3C9   /* PEL Data Register */
#define VGA_PEL_MSK     0x3C6   /* PEL mask register */

/* EGA-specific registers */
#define EGA_GFX_E0      0x3CC   /* Graphics enable processor 0 */
#define EGA_GFX_E1      0x3CA   /* Graphics enable processor 1 */

/* VGA index register ports */
#define VGA_CRT_IC      0x3D4   /* CRT Controller Index - color emulation */
#define VGA_CRT_IM      0x3B4   /* CRT Controller Index - mono emulation */
#define VGA_ATT_IW      0x3C0   /* Attribute Controller Index & Data Write Register */
#define VGA_GFX_I       0x3CE   /* Graphics Controller Index */
#define VGA_SEQ_I       0x3C4   /* Sequencer Index */
#define VGA_PEL_IW      0x3C8   /* PEL Write Index */
#define VGA_PEL_IR      0x3C7   /* PEL Read Index */

/* standard VGA indexes max counts */
#define VGA_CRT_C       0x19    /* Number of CRT Controller Registers */
#define VGA_ATT_C       0x15    /* Number of Attribute Controller Registers */
#define VGA_GFX_C       0x09    /* Number of Graphics Controller Registers */
#define VGA_SEQ_C       0x05    /* Number of Sequencer Registers */
#define VGA_MIS_C       0x01    /* Number of Misc Output Register */

/* VGA misc register bit masks */
#define VGA_MIS_COLOR           0x01
#define VGA_MIS_ENB_MEM_ACCESS  0x02
#define VGA_MIS_DCLK_28322_720  0x04
#define VGA_MIS_ENB_PLL_LOAD    (0x04 | 0x08)
#define VGA_MIS_SEL_HIGH_PAGE   0x20

/* VGA CRT controller register indices */
#define VGA_CRTC_H_TOTAL        0
#define VGA_CRTC_H_DISP         1
#define VGA_CRTC_H_BLANK_START  2
#define VGA_CRTC_H_BLANK_END    3
#define VGA_CRTC_H_SYNC_START   4
#define VGA_CRTC_H_SYNC_END     5
#define VGA_CRTC_V_TOTAL        6
#define VGA_CRTC_OVERFLOW       7
#define VGA_CRTC_PRESET_ROW     8
#define VGA_CRTC_MAX_SCAN       9
#define VGA_CRTC_CURSOR_START   0x0A
#define VGA_CRTC_CURSOR_END     0x0B
#define VGA_CRTC_START_HI       0x0C
#define VGA_CRTC_START_LO       0x0D
#define VGA_CRTC_CURSOR_HI      0x0E
#define VGA_CRTC_CURSOR_LO      0x0F
#define VGA_CRTC_V_SYNC_START   0x10
#define VGA_CRTC_V_SYNC_END     0x11
#define VGA_CRTC_V_DISP_END     0x12
#define VGA_CRTC_OFFSET         0x13
#define VGA_CRTC_UNDERLINE      0x14
#define VGA_CRTC_V_BLANK_START  0x15
#define VGA_CRTC_V_BLANK_END    0x16
#define VGA_CRTC_MODE           0x17
#define VGA_CRTC_LINE_COMPARE   0x18
#define VGA_CRTC_REGS           VGA_CRT_C

/* VGA CRT controller bit masks */
#define VGA_CR11_LOCK_CR0_CR7   0x80 /* lock writes to CR0 - CR7 */
#define VGA_CR17_H_V_SIGNALS_ENABLED 0x80

/* VGA attribute controller register indices */
#define VGA_ATC_PALETTE0        0x00
#define VGA_ATC_PALETTE1        0x01
#define VGA_ATC_PALETTE2        0x02
#define VGA_ATC_PALETTE3        0x03
#define VGA_ATC_PALETTE4        0x04
#define VGA_ATC_PALETTE5        0x05
#define VGA_ATC_PALETTE6        0x06
#define VGA_ATC_PALETTE7        0x07
#define VGA_ATC_PALETTE8        0x08
#define VGA_ATC_PALETTE9        0x09
#define VGA_ATC_PALETTEA        0x0A
#define VGA_ATC_PALETTEB        0x0B
#define VGA_ATC_PALETTEC        0x0C
#define VGA_ATC_PALETTED        0x0D
#define VGA_ATC_PALETTEE        0x0E
#define VGA_ATC_PALETTEF        0x0F
#define VGA_ATC_MODE            0x10
#define VGA_ATC_OVERSCAN        0x11
#define VGA_ATC_PLANE_ENABLE    0x12
#define VGA_ATC_PEL             0x13
#define VGA_ATC_COLOR_PAGE      0x14

#define VGA_AR_ENABLE_DISPLAY   0x20

/* VGA sequencer register indices */
#define VGA_SEQ_RESET           0x00
#define VGA_SEQ_CLOCK_MODE      0x01
#define VGA_SEQ_PLANE_WRITE     0x02
#define VGA_SEQ_CHARACTER_MAP   0x03
#define VGA_SEQ_MEMORY_MODE     0x04

/* VGA sequencer register bit masks */
#define VGA_SR01_CHAR_CLK_8DOTS 0x01 /* bit 0: character clocks 8 dots wide are generated */
#define VGA_SR01_SCREEN_OFF     0x20 /* bit 5: Screen is off */
#define VGA_SR02_ALL_PLANES     0x0F /* bits 3-0: enable access to all planes */
#define VGA_SR04_EXT_MEM        0x02 /* bit 1: allows complete mem access to 256K */
#define VGA_SR04_SEQ_MODE       0x04 /* bit 2: directs system to use a sequential addressing mode */
#define VGA_SR04_CHN_4M         0x08 /* bit 3: selects modulo 4 addressing for CPU access to display memory */

/* VGA graphics controller register indices */
#define VGA_GFX_SR_VALUE        0x00
#define VGA_GFX_SR_ENABLE       0x01
#define VGA_GFX_COMPARE_VALUE   0x02
#define VGA_GFX_DATA_ROTATE     0x03
#define VGA_GFX_PLANE_READ      0x04
#define VGA_GFX_MODE            0x05
#define VGA_GFX_MISC            0x06
#define VGA_GFX_COMPARE_MASK    0x07
#define VGA_GFX_BIT_MASK        0x08

/* VGA graphics controller bit masks */
#define VGA_GR06_GRAPHICS_MODE  0x01


static const char* vga_port_name(unsigned short port, bool is_write) {
  static const struct {
    unsigned short port;
    const char* read_name;
    const char* write_name;
  } port_list[] = {
    { 0x3C0, "ATT_I", "ATT_I" },
    { 0x3C1, "ATT_D", "ATT_D" },
    { 0x3C2, "STS_0", "MISC_" },
    { 0x3C4, "SEQ_I", "SEQ_I" },
    { 0x3C5, "SEQ_D", "SEQ_D" },
    { 0x3C6, "DAC_M", "DAC_M" },
    { 0x3C7, "DAC_S", "DAC_R" },
    { 0x3C8, "DAC_I", "DAC_I" },
    { 0x3C9, "DAC_D", "DAC_D" },
    { 0x3CA, "FTCTL", "3CA__" },
    { 0x3CC, "MISC_", "3CC__" },
    { 0x3CE, "GFX_I", "GFX_I" },
    { 0x3CF, "GFX_D", "GFX_D" },
    { 0x3D4, "CRT_I", "CRT_I" },
    { 0x3D5, "CRT_D", "CRT_D" },
    { 0x3DA, "STS_1", "FTCTL" }
  };

  for (size_t i = 0; i < sizeof(port_list) / sizeof(port_list[0]); i++) {
    if (port_list[i].port == port) {
      return is_write ? port_list[i].write_name : port_list[i].read_name;
    }
  }
  return "INV__";
}

#define cbswap_32(__x) \
((uint32_t)( \
                (((uint32_t)(__x) & (uint32_t)0x000000ffUL) << 24) | \
                (((uint32_t)(__x) & (uint32_t)0x0000ff00UL) <<  8) | \
                (((uint32_t)(__x) & (uint32_t)0x00ff0000UL) >>  8) | \
                (((uint32_t)(__x) & (uint32_t)0xff000000UL) >> 24) ))

/* Little Endian */
#define PAT(x) (x)

static const uint32_t mask16[16] = {
    PAT(0x00000000),
    PAT(0x000000ff),
    PAT(0x0000ff00),
    PAT(0x0000ffff),
    PAT(0x00ff0000),
    PAT(0x00ff00ff),
    PAT(0x00ffff00),
    PAT(0x00ffffff),
    PAT(0xff000000),
    PAT(0xff0000ff),
    PAT(0xff00ff00),
    PAT(0xff00ffff),
    PAT(0xffff0000),
    PAT(0xffff00ff),
    PAT(0xffffff00),
    PAT(0xffffffff),
};


#endif /* DEVICES_VGA_REGS_H */

```

`devices/kvm/kvm_clock.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <linux/kvm.h>
#include <sys/ioctl.h>

#include <cstring>

#include "device_manager.h"
#include "logger.h"
#include "machine.h"

class KvmClock : public Device {
 private:
  kvm_clock_data              kvm_clock_;
  const StateChangeListener*  state_change_listener_ = nullptr;

  void SynchronizeClock() {
    auto machine = manager_->machine();
    MV_ASSERT(ioctl(machine->kvm_fd(), KVM_CHECK_EXTENSION, KVM_CAP_KVMCLOCK_CTRL) == 1);
    for (auto vcpu: machine->vcpus()) {
      vcpu->Schedule([vcpu]() {
        auto ret = ioctl(vcpu->fd(), KVM_KVMCLOCK_CTRL, 0);
        MV_ASSERT(ret == 0 || (ret == -1 && errno == EINVAL));
      });
    }
  }

  void SaveClock() {
    bzero(&kvm_clock_, sizeof(kvm_clock_));
    MV_ASSERT(ioctl(manager_->machine()->vm_fd(), KVM_GET_CLOCK, &kvm_clock_) == 0);
  }

  void LoadClock() {
    /* Reset kvm clock, only when kvm_clock_ was set before */
    if (!kvm_clock_.clock) {
      return;
    }

    kvm_clock_.flags = 0;
    bzero(kvm_clock_.pad, sizeof(kvm_clock_.pad));
    MV_ASSERT(ioctl(manager_->machine()->vm_fd(), KVM_SET_CLOCK, &kvm_clock_) == 0);

    /* Synchronize kvm-clock among all vcpus */
    SynchronizeClock();
  }

 public:
  KvmClock() {
    bzero(&kvm_clock_, sizeof(kvm_clock_));
  }

  void Connect() {
    Device::Connect();
    auto machine = manager_->machine();
    state_change_listener_ = machine->RegisterStateChangeListener([=]() {
      if (machine->IsPaused()) {
        SaveClock();
      } else {
        LoadClock();
      }
    });
  }

  void Disconnect () {
    if (state_change_listener_) {
      manager_->machine()->UnregisterStateChangeListener(&state_change_listener_);
    }
    Device::Disconnect();
  }

  bool SaveState(MigrationWriter* writer) {
    writer->WriteRaw("CLOCK", &kvm_clock_, sizeof(kvm_clock_));
    return Device::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!reader->ReadRaw("CLOCK", &kvm_clock_, sizeof(kvm_clock_))) {
      return false;
    }

    // KVM_SET_CLOCK would be called when vm was resumed
    return Device::LoadState(reader);
  }
};

DECLARE_DEVICE(KvmClock);

```

`devices/kvm/meson.build`:

```build
mvisor_sources += files(
  'kvm_clock.cc'
)

```

`devices/meson.build`:

```build
# Order by alphabet

subdir('acpi')
subdir('agents')
subdir('ahci')
subdir('audio')
subdir('display')
subdir('kvm')
subdir('nvram')
subdir('pci')
subdir('superio')
subdir('usb')
subdir('vfio')
subdir('virtio')

```

`devices/nvram/acpi_dsdt/acpi-dsdt-cpu-hotplug.dsl`:

```dsl
/****************************************************************
 * CPU hotplug
 ****************************************************************/

Scope(\_SB) {
    /* Objects filled in by run-time generated SSDT */
    External(NTFY, MethodObj)
    External(CPON, PkgObj)

    /* Methods called by run-time generated SSDT Processor objects */
    Method(CPMA, 1, NotSerialized) {
        // _MAT method - create an madt apic buffer
        // Arg0 = Processor ID = Local APIC ID
        // Local0 = CPON flag for this cpu
        Store(DerefOf(Index(CPON, Arg0)), Local0)
        // Local1 = Buffer (in madt apic form) to return
        Store(Buffer(8) {0x00, 0x08, 0x00, 0x00, 0x00, 0, 0, 0}, Local1)
        // Update the processor id, lapic id, and enable/disable status
        Store(Arg0, Index(Local1, 2))
        Store(Arg0, Index(Local1, 3))
        Store(Local0, Index(Local1, 4))
        Return (Local1)
    }
    Method(CPST, 1, NotSerialized) {
        // _STA method - return ON status of cpu
        // Arg0 = Processor ID = Local APIC ID
        // Local0 = CPON flag for this cpu
        Store(DerefOf(Index(CPON, Arg0)), Local0)
        If (Local0) {
            Return (0xF)
        } Else {
            Return (0x0)
        }
    }
    Method(CPEJ, 2, NotSerialized) {
        // _EJ0 method - eject callback
        Sleep(200)
    }

    /* CPU hotplug notify method */
    OperationRegion(PRST, SystemIO, 0xaf00, 32)
    Field(PRST, ByteAcc, NoLock, Preserve) {
        PRS, 256
    }
    Method(PRSC, 0) {
        // Local5 = active cpu bitmap
        Store(PRS, Local5)
        // Local2 = last read byte from bitmap
        Store(Zero, Local2)
        // Local0 = Processor ID / APIC ID iterator
        Store(Zero, Local0)
        While (LLess(Local0, SizeOf(CPON))) {
            // Local1 = CPON flag for this cpu
            Store(DerefOf(Index(CPON, Local0)), Local1)
            If (And(Local0, 0x07)) {
                // Shift down previously read bitmap byte
                ShiftRight(Local2, 1, Local2)
            } Else {
                // Read next byte from cpu bitmap
                Store(DerefOf(Index(Local5, ShiftRight(Local0, 3))), Local2)
            }
            // Local3 = active state for this cpu
            Store(And(Local2, 1), Local3)

            If (LNotEqual(Local1, Local3)) {
                // State change - update CPON with new state
                Store(Local3, Index(CPON, Local0))
                // Do CPU notify
                If (LEqual(Local3, 1)) {
                    NTFY(Local0, 1)
                } Else {
                    NTFY(Local0, 3)
                }
            }
            Increment(Local0)
        }
    }
}

```

`devices/nvram/acpi_dsdt/acpi-dsdt-dbug.dsl`:

```dsl
/****************************************************************
 * Debugging
 ****************************************************************/

Scope(\) {
    /* Debug Output */
    OperationRegion(DBG, SystemIO, 0x0402, 0x01)
    Field(DBG, ByteAcc, NoLock, Preserve) {
        DBGB,   8,
    }

    /* Debug method - use this method to send output to the QEMU
     * BIOS debug port.  This method handles strings, integers,
     * and buffers.  For example: DBUG("abc") DBUG(0x123) */
    Method(DBUG, 1) {
        ToHexString(Arg0, Local0)
        ToBuffer(Local0, Local0)
        Subtract(SizeOf(Local0), 1, Local1)
        Store(Zero, Local2)
        While (LLess(Local2, Local1)) {
            Store(DerefOf(Index(Local0, Local2)), DBGB)
            Increment(Local2)
        }
        Store(0x0A, DBGB)
    }
}

```

`devices/nvram/acpi_dsdt/acpi-dsdt-hpet.dsl`:

```dsl
/****************************************************************
 * HPET
 ****************************************************************/

Scope(\_SB) {
    Device(HPET) {
        Name(_HID, EISAID("PNP0103"))
        Name(_UID, 0)
        OperationRegion(HPTM, SystemMemory, 0xFED00000, 0x400)
        Field(HPTM, DWordAcc, Lock, Preserve) {
            VEND, 32,
            PRD, 32,
        }
        Method(_STA, 0, NotSerialized) {
            Store(VEND, Local0)
            Store(PRD, Local1)
            ShiftRight(Local0, 16, Local0)
            If (LOr(LEqual(Local0, 0), LEqual(Local0, 0xffff))) {
                Return (0x0)
            }
            If (LOr(LEqual(Local1, 0), LGreater(Local1, 100000000))) {
                Return (0x0)
            }
            Return (0x0F)
        }
        Name(_CRS, ResourceTemplate() {
#if 0       /* This makes WinXP BSOD for not yet figured reasons. */
            IRQNoFlags() {2, 8}
#endif
            Memory32Fixed(ReadOnly,
                0xFED00000,         // Address Base
                0x00000400,         // Address Length
                )
        })
    }
}

```

`devices/nvram/acpi_dsdt/acpi-dsdt-isa.dsl`:

```dsl
/* Common legacy ISA style devices. */
Scope(\_SB.PCI0.ISA) {

    Device(RTC) {
        Name(_HID, EisaId("PNP0B00"))
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x0070, 0x0070, 0x10, 0x02)
            IRQNoFlags() { 8 }
            IO(Decode16, 0x0072, 0x0072, 0x02, 0x06)
        })
    }

    Device(KBD) {
        Name(_HID, EisaId("PNP0303"))
        Method(_STA, 0, NotSerialized) {
            Return (0x0f)
        }
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x0060, 0x0060, 0x01, 0x01)
            IO(Decode16, 0x0064, 0x0064, 0x01, 0x01)
            IRQNoFlags() { 1 }
        })
    }

    Device(MOU) {
        Name(_HID, EisaId("PNP0F13"))
        Method(_STA, 0, NotSerialized) {
            Return (0x0f)
        }
        Name(_CRS, ResourceTemplate() {
            IRQNoFlags() { 12 }
        })
    }

    Device(FDC0) {
        Name(_HID, EisaId("PNP0700"))
        Method(_STA, 0, NotSerialized) {
            Store(FDEN, Local0)
            If (LEqual(Local0, 0)) {
                Return (0x00)
            } Else {
                Return (0x0F)
            }
        }
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x03F2, 0x03F2, 0x00, 0x04)
            IO(Decode16, 0x03F7, 0x03F7, 0x00, 0x01)
            IRQNoFlags() { 6 }
            DMA(Compatibility, NotBusMaster, Transfer8) { 2 }
        })
    }

    Device(LPT) {
        Name(_HID, EisaId("PNP0400"))
        Method(_STA, 0, NotSerialized) {
            Store(LPEN, Local0)
            If (LEqual(Local0, 0)) {
                Return (0x00)
            } Else {
                Return (0x0F)
            }
        }
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x0378, 0x0378, 0x08, 0x08)
            IRQNoFlags() { 7 }
        })
    }

    Device(COM1) {
        Name(_HID, EisaId("PNP0501"))
        Name(_UID, 0x01)
        Method(_STA, 0, NotSerialized) {
            Store(CAEN, Local0)
            If (LEqual(Local0, 0)) {
                Return (0x00)
            } Else {
                Return (0x0F)
            }
        }
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x03F8, 0x03F8, 0x00, 0x08)
            IRQNoFlags() { 4 }
        })
    }

    Device(COM2) {
        Name(_HID, EisaId("PNP0501"))
        Name(_UID, 0x02)
        Method(_STA, 0, NotSerialized) {
            Store(CBEN, Local0)
            If (LEqual(Local0, 0)) {
                Return (0x00)
            } Else {
                Return (0x0F)
            }
        }
        Name(_CRS, ResourceTemplate() {
            IO(Decode16, 0x02F8, 0x02F8, 0x00, 0x08)
            IRQNoFlags() { 3 }
        })
    }
}

```

`devices/nvram/acpi_dsdt/acpi-dsdt-pci-crs.dsl`:

```dsl
/* PCI CRS (current resources) definition. */
Scope(\_SB.PCI0) {

    Name(CRES, ResourceTemplate() {
        WordBusNumber(ResourceProducer, MinFixed, MaxFixed, PosDecode,
            0x0000,             // Address Space Granularity
            0x0000,             // Address Range Minimum
            0x00FF,             // Address Range Maximum
            0x0000,             // Address Translation Offset
            0x0100,             // Address Length
            ,, )
        IO(Decode16,
            0x0CF8,             // Address Range Minimum
            0x0CF8,             // Address Range Maximum
            0x01,               // Address Alignment
            0x08,               // Address Length
            )
        WordIO(ResourceProducer, MinFixed, MaxFixed, PosDecode, EntireRange,
            0x0000,             // Address Space Granularity
            0x0000,             // Address Range Minimum
            0x0CF7,             // Address Range Maximum
            0x0000,             // Address Translation Offset
            0x0CF8,             // Address Length
            ,, , TypeStatic)
        WordIO(ResourceProducer, MinFixed, MaxFixed, PosDecode, EntireRange,
            0x0000,             // Address Space Granularity
            0x0D00,             // Address Range Minimum
            0xFFFF,             // Address Range Maximum
            0x0000,             // Address Translation Offset
            0xF300,             // Address Length
            ,, , TypeStatic)
        DWordMemory(ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
            0x00000000,         // Address Space Granularity
            0x000A0000,         // Address Range Minimum
            0x000BFFFF,         // Address Range Maximum
            0x00000000,         // Address Translation Offset
            0x00020000,         // Address Length
            ,, , AddressRangeMemory, TypeStatic)
        DWordMemory(ResourceProducer, PosDecode, MinFixed, MaxFixed, NonCacheable, ReadWrite,
            0x00000000,         // Address Space Granularity
            0xE0000000,         // Address Range Minimum
            0xFEBFFFFF,         // Address Range Maximum
            0x00000000,         // Address Translation Offset
            0x1EC00000,         // Address Length
            ,, PW32, AddressRangeMemory, TypeStatic)
    })

    Name(CR64, ResourceTemplate() {
        QWordMemory(ResourceProducer, PosDecode, MinFixed, MaxFixed, Cacheable, ReadWrite,
            0x00000000,          // Address Space Granularity
            0x8000000000,        // Address Range Minimum
            0xFFFFFFFFFF,        // Address Range Maximum
            0x00000000,          // Address Translation Offset
            0x8000000000,        // Address Length
            ,, PW64, AddressRangeMemory, TypeStatic)
    })

    Method(_CRS, 0) {
        /* Fields provided by dynamically created ssdt */
        External(P0S, IntObj)
        External(P0E, IntObj)
        External(P1V, IntObj)
        External(P1S, BuffObj)
        External(P1E, BuffObj)
        External(P1L, BuffObj)

        /* fixup 32bit pci io window */
        CreateDWordField(CRES, \_SB.PCI0.PW32._MIN, PS32)
        CreateDWordField(CRES, \_SB.PCI0.PW32._MAX, PE32)
        CreateDWordField(CRES, \_SB.PCI0.PW32._LEN, PL32)
        Store(P0S, PS32)
        Store(P0E, PE32)
        Store(Add(Subtract(P0E, P0S), 1), PL32)

        If (LEqual(P1V, Zero)) {
            Return (CRES)
        }

        /* fixup 64bit pci io window */
        CreateQWordField(CR64, \_SB.PCI0.PW64._MIN, PS64)
        CreateQWordField(CR64, \_SB.PCI0.PW64._MAX, PE64)
        CreateQWordField(CR64, \_SB.PCI0.PW64._LEN, PL64)
        Store(P1S, PS64)
        Store(P1E, PE64)
        Store(P1L, PL64)
        /* add window and return result */
        ConcatenateResTemplate(CRES, CR64, Local0)
        Return (Local0)
    }
}

```

`devices/nvram/acpi_dsdt/acpi-dsdt.dsl`:

```dsl
/*
 * Bochs/QEMU ACPI DSDT ASL definition
 *
 * Copyright (c) 2006 Fabrice Bellard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License version 2 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

DefinitionBlock (
    "acpi-dsdt.aml",    // Output Filename
    "DSDT",             // Signature
    0x01,               // DSDT Compliance Revision
    "BXPC",             // OEMID
    "BXDSDT",           // TABLE ID
    0x1                 // OEM Revision
    )
{

#include "acpi-dsdt-dbug.dsl"


/****************************************************************
 * PCI Bus definition
 ****************************************************************/

    Scope(\_SB) {
        Device(PCI0) {
            Name(_HID, EisaId("PNP0A03"))
            Name(_ADR, 0x00)
            Name(_UID, 1)
        }
    }

#include "acpi-dsdt-pci-crs.dsl"
#include "acpi-dsdt-hpet.dsl"


/****************************************************************
 * VGA
 ****************************************************************/

    Scope(\_SB.PCI0) {
        Device(VGA) {
            Name(_ADR, 0x00020000)
            OperationRegion(PCIC, PCI_Config, Zero, 0x4)
            Field(PCIC, DWordAcc, NoLock, Preserve) {
                VEND, 32
            }
            Method(_S1D, 0, NotSerialized) {
                Return (0x00)
            }
            Method(_S2D, 0, NotSerialized) {
                Return (0x00)
            }
            Method(_S3D, 0, NotSerialized) {
                If (LEqual(VEND, 0x1001b36)) {
                    Return (0x03)           // QXL
                } Else {
                    Return (0x00)
                }
            }
        }
    }


/****************************************************************
 * PIIX4 PM
 ****************************************************************/

    Scope(\_SB.PCI0) {
        Device(PX13) {
            Name(_ADR, 0x00010003)
            OperationRegion(P13C, PCI_Config, 0x00, 0xff)
        }
    }


/****************************************************************
 * PIIX3 ISA bridge
 ****************************************************************/

    Scope(\_SB.PCI0) {
        Device(ISA) {
            Name(_ADR, 0x00010000)

            /* PIIX PCI to ISA irq remapping */
            OperationRegion(P40C, PCI_Config, 0x60, 0x04)

            /* enable bits */
            Field(\_SB.PCI0.PX13.P13C, AnyAcc, NoLock, Preserve) {
                Offset(0x5f),
                , 7,
                LPEN, 1,         // LPT
                Offset(0x67),
                , 3,
                CAEN, 1,         // COM1
                , 3,
                CBEN, 1,         // COM2
            }
            Name(FDEN, 1)
        }
    }

#include "acpi-dsdt-isa.dsl"


/****************************************************************
 * PCI hotplug
 ****************************************************************/

    Scope(\_SB.PCI0) {
        OperationRegion(PCST, SystemIO, 0xae00, 0x08)
        Field(PCST, DWordAcc, NoLock, WriteAsZeros) {
            PCIU, 32,
            PCID, 32,
        }

        OperationRegion(SEJ, SystemIO, 0xae08, 0x04)
        Field(SEJ, DWordAcc, NoLock, WriteAsZeros) {
            B0EJ, 32,
        }

        /* Methods called by bulk generated PCI devices below */

        /* Methods called by hotplug devices */
        Method(PCEJ, 1, NotSerialized) {
            // _EJ0 method - eject callback
            Store(ShiftLeft(1, Arg0), B0EJ)
        }

        /* Hotplug notification method supplied by SSDT */
        External(\_SB.PCI0.PCNT, MethodObj)

        /* PCI hotplug notify method */
        Method(PCNF, 0) {
            // Local0 = iterator
            Store(Zero, Local0)
            While (LLess(Local0, 31)) {
                Increment(Local0)
                If (And(PCIU, ShiftLeft(1, Local0))) {
                    PCNT(Local0, 1)
                }
                If (And(PCID, ShiftLeft(1, Local0))) {
                    PCNT(Local0, 3)
                }
            }
        }
    }


/****************************************************************
 * PCI IRQs
 ****************************************************************/

    Scope(\_SB) {
        Scope(PCI0) {
            Name(_PRT, Package() {
                /* PCI IRQ routing table, example from ACPI 2.0a specification,
                   section 6.2.8.1 */
                /* Note: we provide the same info as the PCI routing
                   table of the Bochs BIOS */

#define prt_slot(nr, lnk0, lnk1, lnk2, lnk3) \
    Package() { nr##ffff, 0, lnk0, 0 }, \
    Package() { nr##ffff, 1, lnk1, 0 }, \
    Package() { nr##ffff, 2, lnk2, 0 }, \
    Package() { nr##ffff, 3, lnk3, 0 }

#define prt_slot0(nr) prt_slot(nr, LNKD, LNKA, LNKB, LNKC)
#define prt_slot1(nr) prt_slot(nr, LNKA, LNKB, LNKC, LNKD)
#define prt_slot2(nr) prt_slot(nr, LNKB, LNKC, LNKD, LNKA)
#define prt_slot3(nr) prt_slot(nr, LNKC, LNKD, LNKA, LNKB)

                prt_slot0(0x0000),
                /* Device 1 is power mgmt device, and can only use irq 9 */
                prt_slot(0x0001, LNKS, LNKB, LNKC, LNKD),
                prt_slot2(0x0002),
                prt_slot3(0x0003),
                prt_slot0(0x0004),
                prt_slot1(0x0005),
                prt_slot2(0x0006),
                prt_slot3(0x0007),
                prt_slot0(0x0008),
                prt_slot1(0x0009),
                prt_slot2(0x000a),
                prt_slot3(0x000b),
                prt_slot0(0x000c),
                prt_slot1(0x000d),
                prt_slot2(0x000e),
                prt_slot3(0x000f),
                prt_slot0(0x0010),
                prt_slot1(0x0011),
                prt_slot2(0x0012),
                prt_slot3(0x0013),
                prt_slot0(0x0014),
                prt_slot1(0x0015),
                prt_slot2(0x0016),
                prt_slot3(0x0017),
                prt_slot0(0x0018),
                prt_slot1(0x0019),
                prt_slot2(0x001a),
                prt_slot3(0x001b),
                prt_slot0(0x001c),
                prt_slot1(0x001d),
                prt_slot2(0x001e),
                prt_slot3(0x001f),
            })
        }

        Field(PCI0.ISA.P40C, ByteAcc, NoLock, Preserve) {
            PRQ0,   8,
            PRQ1,   8,
            PRQ2,   8,
            PRQ3,   8
        }

        Method(IQST, 1, NotSerialized) {
            // _STA method - get status
            If (And(0x80, Arg0)) {
                Return (0x09)
            }
            Return (0x0B)
        }
        Method(IQCR, 1, Serialized) {
            // _CRS method - get current settings
            Name(PRR0, ResourceTemplate() {
                Interrupt(, Level, ActiveHigh, Shared) { 0 }
            })
            CreateDWordField(PRR0, 0x05, PRRI)
            If (LLess(Arg0, 0x80)) {
                Store(Arg0, PRRI)
            }
            Return (PRR0)
        }

#define define_link(link, uid, reg)                             \
        Device(link) {                                          \
            Name(_HID, EISAID("PNP0C0F"))                       \
            Name(_UID, uid)                                     \
            Name(_PRS, ResourceTemplate() {                     \
                Interrupt(, Level, ActiveHigh, Shared) {        \
                    5, 10, 11                                   \
                }                                               \
            })                                                  \
            Method(_STA, 0, NotSerialized) {                    \
                Return (IQST(reg))                              \
            }                                                   \
            Method(_DIS, 0, NotSerialized) {                    \
                Or(reg, 0x80, reg)                              \
            }                                                   \
            Method(_CRS, 0, NotSerialized) {                    \
                Return (IQCR(reg))                              \
            }                                                   \
            Method(_SRS, 1, NotSerialized) {                    \
                CreateDWordField(Arg0, 0x05, PRRI)              \
                Store(PRRI, reg)                                \
            }                                                   \
        }

        define_link(LNKA, 0, PRQ0)
        define_link(LNKB, 1, PRQ1)
        define_link(LNKC, 2, PRQ2)
        define_link(LNKD, 3, PRQ3)

        Device(LNKS) {
            Name(_HID, EISAID("PNP0C0F"))
            Name(_UID, 4)
            Name(_PRS, ResourceTemplate() {
                Interrupt(, Level, ActiveHigh, Shared) { 9 }
            })

            // The SCI cannot be disabled and is always attached to GSI 9,
            // so these are no-ops.  We only need this link to override the
            // polarity to active high and match the content of the MADT.
            Method(_STA, 0, NotSerialized) { Return (0x0b) }
            Method(_DIS, 0, NotSerialized) { }
            Method(_CRS, 0, NotSerialized) { Return (_PRS) }
            Method(_SRS, 1, NotSerialized) { }
        }
    }

#include "acpi-dsdt-cpu-hotplug.dsl"


/****************************************************************
 * General purpose events
 ****************************************************************/

    Scope(\_GPE) {
        Name(_HID, "ACPI0006")

        Method(_L00) {
        }
        Method(_E01) {
            // PCI hotplug event
            \_SB.PCI0.PCNF()
        }
        Method(_E02) {
            // CPU hotplug event
            \_SB.PRSC()
        }
        Method(_L03) {
        }
        Method(_L04) {
        }
        Method(_L05) {
        }
        Method(_L06) {
        }
        Method(_L07) {
        }
        Method(_L08) {
        }
        Method(_L09) {
        }
        Method(_L0A) {
        }
        Method(_L0B) {
        }
        Method(_L0C) {
        }
        Method(_L0D) {
        }
        Method(_L0E) {
        }
        Method(_L0F) {
        }
    }
}

```

`devices/nvram/acpi_dsdt/acpi_dsdt.hex.h`:

```h
/*
 * 
 * Intel ACPI Component Architecture
 * ASL+ Optimizing Compiler/Disassembler version 20200925 (64-bit version)
 * Copyright (c) 2000 - 2020 Intel Corporation
 * 
 * Compilation of "acpi-dsdt.dsl.i" - Mon Sep  5 06:16:01 2022
 * 
 * C source code output
 * AML code block contains 0x11E9 bytes
 *
 */
#ifndef __ACPI_DSDT_HEX__
#define __ACPI_DSDT_HEX__

unsigned char acpi_dsdt_aml_code[] =
{
    0x44,0x53,0x44,0x54,0xE9,0x11,0x00,0x00,  /* 00000000    "DSDT...." */
    0x01,0x54,0x42,0x58,0x50,0x43,0x00,0x00,  /* 00000008    ".TBXPC.." */
    0x42,0x58,0x44,0x53,0x44,0x54,0x00,0x00,  /* 00000010    "BXDSDT.." */
    0x01,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
    0x25,0x09,0x20,0x20,0xA0,0x43,0x0B,0x00,  /* 00000020    "%.  .C.." */
    0x15,0x5C,0x2F,0x04,0x5F,0x53,0x42,0x5F,  /* 00000028    ".\/._SB_" */
    0x50,0x43,0x49,0x30,0x5F,0x43,0x52,0x53,  /* 00000030    "PCI0_CRS" */
    0x50,0x30,0x53,0x5F,0x01,0x00,0x15,0x5C,  /* 00000038    "P0S_...\" */
    0x2F,0x04,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 00000040    "/._SB_PC" */
    0x49,0x30,0x5F,0x43,0x52,0x53,0x50,0x30,  /* 00000048    "I0_CRSP0" */
    0x45,0x5F,0x01,0x00,0x15,0x5C,0x2F,0x04,  /* 00000050    "E_...\/." */
    0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,0x30,  /* 00000058    "_SB_PCI0" */
    0x5F,0x43,0x52,0x53,0x50,0x31,0x56,0x5F,  /* 00000060    "_CRSP1V_" */
    0x01,0x00,0x15,0x5C,0x2F,0x04,0x5F,0x53,  /* 00000068    "...\/._S" */
    0x42,0x5F,0x50,0x43,0x49,0x30,0x5F,0x43,  /* 00000070    "B_PCI0_C" */
    0x52,0x53,0x50,0x31,0x53,0x5F,0x03,0x00,  /* 00000078    "RSP1S_.." */
    0x15,0x5C,0x2F,0x04,0x5F,0x53,0x42,0x5F,  /* 00000080    ".\/._SB_" */
    0x50,0x43,0x49,0x30,0x5F,0x43,0x52,0x53,  /* 00000088    "PCI0_CRS" */
    0x50,0x31,0x45,0x5F,0x03,0x00,0x15,0x5C,  /* 00000090    "P1E_...\" */
    0x2F,0x04,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 00000098    "/._SB_PC" */
    0x49,0x30,0x5F,0x43,0x52,0x53,0x50,0x31,  /* 000000A0    "I0_CRSP1" */
    0x4C,0x5F,0x03,0x00,0x15,0x5C,0x2F,0x03,  /* 000000A8    "L_...\/." */
    0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,0x30,  /* 000000B0    "_SB_PCI0" */
    0x50,0x43,0x4E,0x54,0x08,0x02,0x15,0x5C,  /* 000000B8    "PCNT...\" */
    0x2E,0x5F,0x53,0x42,0x5F,0x4E,0x54,0x46,  /* 000000C0    "._SB_NTF" */
    0x59,0x08,0x02,0x15,0x5C,0x2E,0x5F,0x53,  /* 000000C8    "Y...\._S" */
    0x42,0x5F,0x43,0x50,0x4F,0x4E,0x04,0x00,  /* 000000D0    "B_CPON.." */
    0x10,0x49,0x04,0x5C,0x00,0x5B,0x80,0x44,  /* 000000D8    ".I.\.[.D" */
    0x42,0x47,0x5F,0x01,0x0B,0x02,0x04,0x01,  /* 000000E0    "BG_....." */
    0x5B,0x81,0x0B,0x44,0x42,0x47,0x5F,0x01,  /* 000000E8    "[..DBG_." */
    0x44,0x42,0x47,0x42,0x08,0x14,0x2C,0x44,  /* 000000F0    "DBGB..,D" */
    0x42,0x55,0x47,0x01,0x98,0x68,0x60,0x96,  /* 000000F8    "BUG..h`." */
    0x60,0x60,0x74,0x87,0x60,0x01,0x61,0x70,  /* 00000100    "``t.`.ap" */
    0x00,0x62,0xA2,0x10,0x95,0x62,0x61,0x70,  /* 00000108    ".b...bap" */
    0x83,0x88,0x60,0x62,0x00,0x44,0x42,0x47,  /* 00000110    "..`b.DBG" */
    0x42,0x75,0x62,0x70,0x0A,0x0A,0x44,0x42,  /* 00000118    "Bubp..DB" */
    0x47,0x42,0x10,0x22,0x5F,0x53,0x42,0x5F,  /* 00000120    "GB."_SB_" */
    0x5B,0x82,0x1B,0x50,0x43,0x49,0x30,0x08,  /* 00000128    "[..PCI0." */
    0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,0x0A,  /* 00000130    "_HID.A.." */
    0x03,0x08,0x5F,0x41,0x44,0x52,0x00,0x08,  /* 00000138    ".._ADR.." */
    0x5F,0x55,0x49,0x44,0x01,0x10,0x4E,0x15,  /* 00000140    "_UID..N." */
    0x2E,0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,  /* 00000148    "._SB_PCI" */
    0x30,0x08,0x43,0x52,0x45,0x53,0x11,0x42,  /* 00000150    "0.CRES.B" */
    0x07,0x0A,0x6E,0x88,0x0D,0x00,0x02,0x0C,  /* 00000158    "..n....." */
    0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,  /* 00000160    "........" */
    0x00,0x00,0x01,0x47,0x01,0xF8,0x0C,0xF8,  /* 00000168    "...G...." */
    0x0C,0x01,0x08,0x88,0x0D,0x00,0x01,0x0C,  /* 00000170    "........" */
    0x03,0x00,0x00,0x00,0x00,0xF7,0x0C,0x00,  /* 00000178    "........" */
    0x00,0xF8,0x0C,0x88,0x0D,0x00,0x01,0x0C,  /* 00000180    "........" */
    0x03,0x00,0x00,0x00,0x0D,0xFF,0xFF,0x00,  /* 00000188    "........" */
    0x00,0x00,0xF3,0x87,0x17,0x00,0x00,0x0C,  /* 00000190    "........" */
    0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,  /* 00000198    "........" */
    0x00,0xFF,0xFF,0x0B,0x00,0x00,0x00,0x00,  /* 000001A0    "........" */
    0x00,0x00,0x00,0x02,0x00,0x87,0x17,0x00,  /* 000001A8    "........" */
    0x00,0x0C,0x01,0x00,0x00,0x00,0x00,0x00,  /* 000001B0    "........" */
    0x00,0x00,0xE0,0xFF,0xFF,0xBF,0xFE,0x00,  /* 000001B8    "........" */
    0x00,0x00,0x00,0x00,0x00,0xC0,0x1E,0x79,  /* 000001C0    ".......y" */
    0x00,0x08,0x43,0x52,0x36,0x34,0x11,0x33,  /* 000001C8    "..CR64.3" */
    0x0A,0x30,0x8A,0x2B,0x00,0x00,0x0C,0x03,  /* 000001D0    ".0.+...." */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001D8    "........" */
    0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,  /* 000001E0    "........" */
    0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,  /* 000001E8    "........" */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000001F0    "........" */
    0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,  /* 000001F8    "........" */
    0x79,0x00,0x14,0x41,0x0A,0x5F,0x43,0x52,  /* 00000200    "y..A._CR" */
    0x53,0x00,0x8A,0x43,0x52,0x45,0x53,0x0A,  /* 00000208    "S..CRES." */
    0x5C,0x50,0x53,0x33,0x32,0x8A,0x43,0x52,  /* 00000210    "\PS32.CR" */
    0x45,0x53,0x0A,0x60,0x50,0x45,0x33,0x32,  /* 00000218    "ES.`PE32" */
    0x8A,0x43,0x52,0x45,0x53,0x0A,0x68,0x50,  /* 00000220    ".CRES.hP" */
    0x4C,0x33,0x32,0x70,0x50,0x30,0x53,0x5F,  /* 00000228    "L32pP0S_" */
    0x50,0x53,0x33,0x32,0x70,0x50,0x30,0x45,  /* 00000230    "PS32pP0E" */
    0x5F,0x50,0x45,0x33,0x32,0x70,0x72,0x74,  /* 00000238    "_PE32prt" */
    0x50,0x30,0x45,0x5F,0x50,0x30,0x53,0x5F,  /* 00000240    "P0E_P0S_" */
    0x00,0x01,0x00,0x50,0x4C,0x33,0x32,0xA0,  /* 00000248    "...PL32." */
    0x0C,0x93,0x50,0x31,0x56,0x5F,0x00,0xA4,  /* 00000250    "..P1V_.." */
    0x43,0x52,0x45,0x53,0x8F,0x43,0x52,0x36,  /* 00000258    "CRES.CR6" */
    0x34,0x0A,0x0E,0x50,0x53,0x36,0x34,0x8F,  /* 00000260    "4..PS64." */
    0x43,0x52,0x36,0x34,0x0A,0x16,0x50,0x45,  /* 00000268    "CR64..PE" */
    0x36,0x34,0x8F,0x43,0x52,0x36,0x34,0x0A,  /* 00000270    "64.CR64." */
    0x26,0x50,0x4C,0x36,0x34,0x70,0x50,0x31,  /* 00000278    "&PL64pP1" */
    0x53,0x5F,0x50,0x53,0x36,0x34,0x70,0x50,  /* 00000280    "S_PS64pP" */
    0x31,0x45,0x5F,0x50,0x45,0x36,0x34,0x70,  /* 00000288    "1E_PE64p" */
    0x50,0x31,0x4C,0x5F,0x50,0x4C,0x36,0x34,  /* 00000290    "P1L_PL64" */
    0x84,0x43,0x52,0x45,0x53,0x43,0x52,0x36,  /* 00000298    ".CRESCR6" */
    0x34,0x60,0xA4,0x60,0x10,0x4D,0x08,0x5F,  /* 000002A0    "4`.`.M._" */
    0x53,0x42,0x5F,0x5B,0x82,0x45,0x08,0x48,  /* 000002A8    "SB_[.E.H" */
    0x50,0x45,0x54,0x08,0x5F,0x48,0x49,0x44,  /* 000002B0    "PET._HID" */
    0x0C,0x41,0xD0,0x01,0x03,0x08,0x5F,0x55,  /* 000002B8    ".A...._U" */
    0x49,0x44,0x00,0x5B,0x80,0x48,0x50,0x54,  /* 000002C0    "ID.[.HPT" */
    0x4D,0x00,0x0C,0x00,0x00,0xD0,0xFE,0x0B,  /* 000002C8    "M......." */
    0x00,0x04,0x5B,0x81,0x10,0x48,0x50,0x54,  /* 000002D0    "..[..HPT" */
    0x4D,0x13,0x56,0x45,0x4E,0x44,0x20,0x50,  /* 000002D8    "M.VEND P" */
    0x52,0x44,0x5F,0x20,0x14,0x36,0x5F,0x53,  /* 000002E0    "RD_ .6_S" */
    0x54,0x41,0x00,0x70,0x56,0x45,0x4E,0x44,  /* 000002E8    "TA.pVEND" */
    0x60,0x70,0x50,0x52,0x44,0x5F,0x61,0x7A,  /* 000002F0    "`pPRD_az" */
    0x60,0x0A,0x10,0x60,0xA0,0x0C,0x91,0x93,  /* 000002F8    "`..`...." */
    0x60,0x00,0x93,0x60,0x0B,0xFF,0xFF,0xA4,  /* 00000300    "`..`...." */
    0x00,0xA0,0x0E,0x91,0x93,0x61,0x00,0x94,  /* 00000308    ".....a.." */
    0x61,0x0C,0x00,0xE1,0xF5,0x05,0xA4,0x00,  /* 00000310    "a......." */
    0xA4,0x0A,0x0F,0x08,0x5F,0x43,0x52,0x53,  /* 00000318    "...._CRS" */
    0x11,0x11,0x0A,0x0E,0x86,0x09,0x00,0x00,  /* 00000320    "........" */
    0x00,0x00,0xD0,0xFE,0x00,0x04,0x00,0x00,  /* 00000328    "........" */
    0x79,0x00,0x10,0x40,0x06,0x2E,0x5F,0x53,  /* 00000330    "y..@.._S" */
    0x42,0x5F,0x50,0x43,0x49,0x30,0x5B,0x82,  /* 00000338    "B_PCI0[." */
    0x43,0x05,0x56,0x47,0x41,0x5F,0x08,0x5F,  /* 00000340    "C.VGA_._" */
    0x41,0x44,0x52,0x0C,0x00,0x00,0x02,0x00,  /* 00000348    "ADR....." */
    0x5B,0x80,0x50,0x43,0x49,0x43,0x02,0x00,  /* 00000350    "[.PCIC.." */
    0x0A,0x04,0x5B,0x81,0x0B,0x50,0x43,0x49,  /* 00000358    "..[..PCI" */
    0x43,0x03,0x56,0x45,0x4E,0x44,0x20,0x14,  /* 00000360    "C.VEND ." */
    0x08,0x5F,0x53,0x31,0x44,0x00,0xA4,0x00,  /* 00000368    "._S1D..." */
    0x14,0x08,0x5F,0x53,0x32,0x44,0x00,0xA4,  /* 00000370    ".._S2D.." */
    0x00,0x14,0x19,0x5F,0x53,0x33,0x44,0x00,  /* 00000378    "..._S3D." */
    0xA0,0x0E,0x93,0x56,0x45,0x4E,0x44,0x0C,  /* 00000380    "...VEND." */
    0x36,0x1B,0x00,0x01,0xA4,0x0A,0x03,0xA1,  /* 00000388    "6......." */
    0x03,0xA4,0x00,0x10,0x25,0x2E,0x5F,0x53,  /* 00000390    "....%._S" */
    0x42,0x5F,0x50,0x43,0x49,0x30,0x5B,0x82,  /* 00000398    "B_PCI0[." */
    0x19,0x50,0x58,0x31,0x33,0x08,0x5F,0x41,  /* 000003A0    ".PX13._A" */
    0x44,0x52,0x0C,0x03,0x00,0x01,0x00,0x5B,  /* 000003A8    "DR.....[" */
    0x80,0x50,0x31,0x33,0x43,0x02,0x00,0x0A,  /* 000003B0    ".P13C..." */
    0xFF,0x10,0x46,0x05,0x2E,0x5F,0x53,0x42,  /* 000003B8    "..F.._SB" */
    0x5F,0x50,0x43,0x49,0x30,0x5B,0x82,0x49,  /* 000003C0    "_PCI0[.I" */
    0x04,0x49,0x53,0x41,0x5F,0x08,0x5F,0x41,  /* 000003C8    ".ISA_._A" */
    0x44,0x52,0x0C,0x00,0x00,0x01,0x00,0x5B,  /* 000003D0    "DR.....[" */
    0x80,0x50,0x34,0x30,0x43,0x02,0x0A,0x60,  /* 000003D8    ".P40C..`" */
    0x0A,0x04,0x5B,0x81,0x26,0x5E,0x2E,0x50,  /* 000003E0    "..[.&^.P" */
    0x58,0x31,0x33,0x50,0x31,0x33,0x43,0x00,  /* 000003E8    "X13P13C." */
    0x00,0x48,0x2F,0x00,0x07,0x4C,0x50,0x45,  /* 000003F0    ".H/..LPE" */
    0x4E,0x01,0x00,0x38,0x00,0x03,0x43,0x41,  /* 000003F8    "N..8..CA" */
    0x45,0x4E,0x01,0x00,0x03,0x43,0x42,0x45,  /* 00000400    "EN...CBE" */
    0x4E,0x01,0x08,0x46,0x44,0x45,0x4E,0x01,  /* 00000408    "N..FDEN." */
    0x10,0x4C,0x1B,0x2F,0x03,0x5F,0x53,0x42,  /* 00000410    ".L./._SB" */
    0x5F,0x50,0x43,0x49,0x30,0x49,0x53,0x41,  /* 00000418    "_PCI0ISA" */
    0x5F,0x5B,0x82,0x2D,0x52,0x54,0x43,0x5F,  /* 00000420    "_[.-RTC_" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 00000428    "._HID.A." */
    0x0B,0x00,0x08,0x5F,0x43,0x52,0x53,0x11,  /* 00000430    "..._CRS." */
    0x18,0x0A,0x15,0x47,0x01,0x70,0x00,0x70,  /* 00000438    "...G.p.p" */
    0x00,0x10,0x02,0x22,0x00,0x01,0x47,0x01,  /* 00000440    "..."..G." */
    0x72,0x00,0x72,0x00,0x02,0x06,0x79,0x00,  /* 00000448    "r.r...y." */
    0x5B,0x82,0x37,0x4B,0x42,0x44,0x5F,0x08,  /* 00000450    "[.7KBD_." */
    0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,0x03,  /* 00000458    "_HID.A.." */
    0x03,0x14,0x09,0x5F,0x53,0x54,0x41,0x00,  /* 00000460    "..._STA." */
    0xA4,0x0A,0x0F,0x08,0x5F,0x43,0x52,0x53,  /* 00000468    "...._CRS" */
    0x11,0x18,0x0A,0x15,0x47,0x01,0x60,0x00,  /* 00000470    "....G.`." */
    0x60,0x00,0x01,0x01,0x47,0x01,0x64,0x00,  /* 00000478    "`...G.d." */
    0x64,0x00,0x01,0x01,0x22,0x02,0x00,0x79,  /* 00000480    "d..."..y" */
    0x00,0x5B,0x82,0x27,0x4D,0x4F,0x55,0x5F,  /* 00000488    ".[.'MOU_" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 00000490    "._HID.A." */
    0x0F,0x13,0x14,0x09,0x5F,0x53,0x54,0x41,  /* 00000498    "...._STA" */
    0x00,0xA4,0x0A,0x0F,0x08,0x5F,0x43,0x52,  /* 000004A0    "....._CR" */
    0x53,0x11,0x08,0x0A,0x05,0x22,0x00,0x10,  /* 000004A8    "S....".." */
    0x79,0x00,0x5B,0x82,0x4A,0x04,0x46,0x44,  /* 000004B0    "y.[.J.FD" */
    0x43,0x30,0x08,0x5F,0x48,0x49,0x44,0x0C,  /* 000004B8    "C0._HID." */
    0x41,0xD0,0x07,0x00,0x14,0x18,0x5F,0x53,  /* 000004C0    "A....._S" */
    0x54,0x41,0x00,0x70,0x46,0x44,0x45,0x4E,  /* 000004C8    "TA.pFDEN" */
    0x60,0xA0,0x06,0x93,0x60,0x00,0xA4,0x00,  /* 000004D0    "`...`..." */
    0xA1,0x04,0xA4,0x0A,0x0F,0x08,0x5F,0x43,  /* 000004D8    "......_C" */
    0x52,0x53,0x11,0x1B,0x0A,0x18,0x47,0x01,  /* 000004E0    "RS....G." */
    0xF2,0x03,0xF2,0x03,0x00,0x04,0x47,0x01,  /* 000004E8    "......G." */
    0xF7,0x03,0xF7,0x03,0x00,0x01,0x22,0x40,  /* 000004F0    "......"@" */
    0x00,0x2A,0x04,0x00,0x79,0x00,0x5B,0x82,  /* 000004F8    ".*..y.[." */
    0x3E,0x4C,0x50,0x54,0x5F,0x08,0x5F,0x48,  /* 00000500    ">LPT_._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x04,0x00,0x14,  /* 00000508    "ID.A...." */
    0x18,0x5F,0x53,0x54,0x41,0x00,0x70,0x4C,  /* 00000510    "._STA.pL" */
    0x50,0x45,0x4E,0x60,0xA0,0x06,0x93,0x60,  /* 00000518    "PEN`...`" */
    0x00,0xA4,0x00,0xA1,0x04,0xA4,0x0A,0x0F,  /* 00000520    "........" */
    0x08,0x5F,0x43,0x52,0x53,0x11,0x10,0x0A,  /* 00000528    "._CRS..." */
    0x0D,0x47,0x01,0x78,0x03,0x78,0x03,0x08,  /* 00000530    ".G.x.x.." */
    0x08,0x22,0x80,0x00,0x79,0x00,0x5B,0x82,  /* 00000538    "."..y.[." */
    0x45,0x04,0x43,0x4F,0x4D,0x31,0x08,0x5F,  /* 00000540    "E.COM1._" */
    0x48,0x49,0x44,0x0C,0x41,0xD0,0x05,0x01,  /* 00000548    "HID.A..." */
    0x08,0x5F,0x55,0x49,0x44,0x01,0x14,0x18,  /* 00000550    "._UID..." */
    0x5F,0x53,0x54,0x41,0x00,0x70,0x43,0x41,  /* 00000558    "_STA.pCA" */
    0x45,0x4E,0x60,0xA0,0x06,0x93,0x60,0x00,  /* 00000560    "EN`...`." */
    0xA4,0x00,0xA1,0x04,0xA4,0x0A,0x0F,0x08,  /* 00000568    "........" */
    0x5F,0x43,0x52,0x53,0x11,0x10,0x0A,0x0D,  /* 00000570    "_CRS...." */
    0x47,0x01,0xF8,0x03,0xF8,0x03,0x00,0x08,  /* 00000578    "G......." */
    0x22,0x10,0x00,0x79,0x00,0x5B,0x82,0x46,  /* 00000580    ""..y.[.F" */
    0x04,0x43,0x4F,0x4D,0x32,0x08,0x5F,0x48,  /* 00000588    ".COM2._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x05,0x01,0x08,  /* 00000590    "ID.A...." */
    0x5F,0x55,0x49,0x44,0x0A,0x02,0x14,0x18,  /* 00000598    "_UID...." */
    0x5F,0x53,0x54,0x41,0x00,0x70,0x43,0x42,  /* 000005A0    "_STA.pCB" */
    0x45,0x4E,0x60,0xA0,0x06,0x93,0x60,0x00,  /* 000005A8    "EN`...`." */
    0xA4,0x00,0xA1,0x04,0xA4,0x0A,0x0F,0x08,  /* 000005B0    "........" */
    0x5F,0x43,0x52,0x53,0x11,0x10,0x0A,0x0D,  /* 000005B8    "_CRS...." */
    0x47,0x01,0xF8,0x02,0xF8,0x02,0x00,0x08,  /* 000005C0    "G......." */
    0x22,0x08,0x00,0x79,0x00,0x10,0x49,0x08,  /* 000005C8    ""..y..I." */
    0x2E,0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,  /* 000005D0    "._SB_PCI" */
    0x30,0x5B,0x80,0x50,0x43,0x53,0x54,0x01,  /* 000005D8    "0[.PCST." */
    0x0B,0x00,0xAE,0x0A,0x08,0x5B,0x81,0x10,  /* 000005E0    ".....[.." */
    0x50,0x43,0x53,0x54,0x43,0x50,0x43,0x49,  /* 000005E8    "PCSTCPCI" */
    0x55,0x20,0x50,0x43,0x49,0x44,0x20,0x5B,  /* 000005F0    "U PCID [" */
    0x80,0x53,0x45,0x4A,0x5F,0x01,0x0B,0x08,  /* 000005F8    ".SEJ_..." */
    0xAE,0x0A,0x04,0x5B,0x81,0x0B,0x53,0x45,  /* 00000600    "...[..SE" */
    0x4A,0x5F,0x43,0x42,0x30,0x45,0x4A,0x20,  /* 00000608    "J_CB0EJ " */
    0x14,0x0F,0x50,0x43,0x45,0x4A,0x01,0x70,  /* 00000610    "..PCEJ.p" */
    0x79,0x01,0x68,0x00,0x42,0x30,0x45,0x4A,  /* 00000618    "y.h.B0EJ" */
    0x14,0x36,0x50,0x43,0x4E,0x46,0x00,0x70,  /* 00000620    ".6PCNF.p" */
    0x00,0x60,0xA2,0x2C,0x95,0x60,0x0A,0x1F,  /* 00000628    ".`.,.`.." */
    0x75,0x60,0xA0,0x11,0x7B,0x50,0x43,0x49,  /* 00000630    "u`..{PCI" */
    0x55,0x79,0x01,0x60,0x00,0x00,0x50,0x43,  /* 00000638    "Uy.`..PC" */
    0x4E,0x54,0x60,0x01,0xA0,0x12,0x7B,0x50,  /* 00000640    "NT`...{P" */
    0x43,0x49,0x44,0x79,0x01,0x60,0x00,0x00,  /* 00000648    "CIDy.`.." */
    0x50,0x43,0x4E,0x54,0x60,0x0A,0x03,0x10,  /* 00000650    "PCNT`..." */
    0x4A,0xA0,0x5F,0x53,0x42,0x5F,0x10,0x47,  /* 00000658    "J._SB_.G" */
    0x74,0x50,0x43,0x49,0x30,0x08,0x5F,0x50,  /* 00000660    "tPCI0._P" */
    0x52,0x54,0x12,0x4B,0x73,0x80,0x12,0x0B,  /* 00000668    "RT.Ks..." */
    0x04,0x0B,0xFF,0xFF,0x00,0x4C,0x4E,0x4B,  /* 00000670    ".....LNK" */
    0x44,0x00,0x12,0x0B,0x04,0x0B,0xFF,0xFF,  /* 00000678    "D......." */
    0x01,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0C,  /* 00000680    ".LNKA..." */
    0x04,0x0B,0xFF,0xFF,0x0A,0x02,0x4C,0x4E,  /* 00000688    "......LN" */
    0x4B,0x42,0x00,0x12,0x0C,0x04,0x0B,0xFF,  /* 00000690    "KB......" */
    0xFF,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000698    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x01,0x00,  /* 000006A0    "........" */
    0x00,0x4C,0x4E,0x4B,0x53,0x00,0x12,0x0D,  /* 000006A8    ".LNKS..." */
    0x04,0x0C,0xFF,0xFF,0x01,0x00,0x01,0x4C,  /* 000006B0    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 000006B8    "NKB....." */
    0xFF,0xFF,0x01,0x00,0x0A,0x02,0x4C,0x4E,  /* 000006C0    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000006C8    "KC......" */
    0xFF,0x01,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 000006D0    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000006D8    "D......." */
    0x02,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 000006E0    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x02,0x00,  /* 000006E8    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 000006F0    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x02,0x00,0x0A,0x02,  /* 000006F8    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 00000700    "LNKD...." */
    0x0C,0xFF,0xFF,0x02,0x00,0x0A,0x03,0x4C,  /* 00000708    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00000710    "NKA....." */
    0xFF,0xFF,0x03,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000718    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000720    "C......." */
    0x03,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000728    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x03,0x00,  /* 00000730    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000738    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x03,0x00,0x0A,  /* 00000740    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000748    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x04,0x00,0x00,0x4C,  /* 00000750    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000758    "NKD....." */
    0xFF,0xFF,0x04,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000760    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000768    "A......." */
    0x04,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000770    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x04,  /* 00000778    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000780    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x05,0x00,  /* 00000788    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000790    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x05,0x00,0x01,0x4C,  /* 00000798    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 000007A0    "NKB....." */
    0xFF,0xFF,0x05,0x00,0x0A,0x02,0x4C,0x4E,  /* 000007A8    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000007B0    "KC......" */
    0xFF,0x05,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 000007B8    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000007C0    "D......." */
    0x06,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 000007C8    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x06,0x00,  /* 000007D0    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 000007D8    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x06,0x00,0x0A,0x02,  /* 000007E0    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 000007E8    "LNKD...." */
    0x0C,0xFF,0xFF,0x06,0x00,0x0A,0x03,0x4C,  /* 000007F0    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 000007F8    "NKA....." */
    0xFF,0xFF,0x07,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000800    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000808    "C......." */
    0x07,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000810    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x07,0x00,  /* 00000818    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000820    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x07,0x00,0x0A,  /* 00000828    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000830    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x08,0x00,0x00,0x4C,  /* 00000838    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000840    "NKD....." */
    0xFF,0xFF,0x08,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000848    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000850    "A......." */
    0x08,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000858    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x08,  /* 00000860    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000868    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x09,0x00,  /* 00000870    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000878    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x09,0x00,0x01,0x4C,  /* 00000880    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000888    "NKB....." */
    0xFF,0xFF,0x09,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000890    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000898    "KC......" */
    0xFF,0x09,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 000008A0    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000008A8    "D......." */
    0x0A,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 000008B0    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0A,0x00,  /* 000008B8    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 000008C0    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x0A,0x00,0x0A,0x02,  /* 000008C8    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 000008D0    "LNKD...." */
    0x0C,0xFF,0xFF,0x0A,0x00,0x0A,0x03,0x4C,  /* 000008D8    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 000008E0    "NKA....." */
    0xFF,0xFF,0x0B,0x00,0x00,0x4C,0x4E,0x4B,  /* 000008E8    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000008F0    "C......." */
    0x0B,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 000008F8    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0B,0x00,  /* 00000900    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000908    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x0B,0x00,0x0A,  /* 00000910    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000918    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x0C,0x00,0x00,0x4C,  /* 00000920    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000928    "NKD....." */
    0xFF,0xFF,0x0C,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000930    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000938    "A......." */
    0x0C,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000940    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0C,  /* 00000948    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000950    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0D,0x00,  /* 00000958    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000960    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x0D,0x00,0x01,0x4C,  /* 00000968    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000970    "NKB....." */
    0xFF,0xFF,0x0D,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000978    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000980    "KC......" */
    0xFF,0x0D,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 00000988    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000990    "D......." */
    0x0E,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 00000998    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0E,0x00,  /* 000009A0    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 000009A8    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x0E,0x00,0x0A,0x02,  /* 000009B0    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 000009B8    "LNKD...." */
    0x0C,0xFF,0xFF,0x0E,0x00,0x0A,0x03,0x4C,  /* 000009C0    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 000009C8    "NKA....." */
    0xFF,0xFF,0x0F,0x00,0x00,0x4C,0x4E,0x4B,  /* 000009D0    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000009D8    "C......." */
    0x0F,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 000009E0    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0F,0x00,  /* 000009E8    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 000009F0    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x0F,0x00,0x0A,  /* 000009F8    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000A00    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x10,0x00,0x00,0x4C,  /* 00000A08    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000A10    "NKD....." */
    0xFF,0xFF,0x10,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000A18    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000A20    "A......." */
    0x10,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000A28    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x10,  /* 00000A30    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000A38    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x11,0x00,  /* 00000A40    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000A48    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x11,0x00,0x01,0x4C,  /* 00000A50    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000A58    "NKB....." */
    0xFF,0xFF,0x11,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000A60    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000A68    "KC......" */
    0xFF,0x11,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 00000A70    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000A78    "D......." */
    0x12,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 00000A80    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x12,0x00,  /* 00000A88    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 00000A90    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x12,0x00,0x0A,0x02,  /* 00000A98    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 00000AA0    "LNKD...." */
    0x0C,0xFF,0xFF,0x12,0x00,0x0A,0x03,0x4C,  /* 00000AA8    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00000AB0    "NKA....." */
    0xFF,0xFF,0x13,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000AB8    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000AC0    "C......." */
    0x13,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000AC8    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x13,0x00,  /* 00000AD0    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000AD8    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x13,0x00,0x0A,  /* 00000AE0    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000AE8    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x14,0x00,0x00,0x4C,  /* 00000AF0    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000AF8    "NKD....." */
    0xFF,0xFF,0x14,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000B00    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000B08    "A......." */
    0x14,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000B10    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x14,  /* 00000B18    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000B20    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x15,0x00,  /* 00000B28    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000B30    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x15,0x00,0x01,0x4C,  /* 00000B38    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000B40    "NKB....." */
    0xFF,0xFF,0x15,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000B48    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000B50    "KC......" */
    0xFF,0x15,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 00000B58    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000B60    "D......." */
    0x16,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 00000B68    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x16,0x00,  /* 00000B70    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 00000B78    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x16,0x00,0x0A,0x02,  /* 00000B80    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 00000B88    "LNKD...." */
    0x0C,0xFF,0xFF,0x16,0x00,0x0A,0x03,0x4C,  /* 00000B90    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00000B98    "NKA....." */
    0xFF,0xFF,0x17,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000BA0    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000BA8    "C......." */
    0x17,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000BB0    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x17,0x00,  /* 00000BB8    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000BC0    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x17,0x00,0x0A,  /* 00000BC8    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000BD0    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x18,0x00,0x00,0x4C,  /* 00000BD8    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000BE0    "NKD....." */
    0xFF,0xFF,0x18,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000BE8    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000BF0    "A......." */
    0x18,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000BF8    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x18,  /* 00000C00    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000C08    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x19,0x00,  /* 00000C10    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000C18    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x19,0x00,0x01,0x4C,  /* 00000C20    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000C28    "NKB....." */
    0xFF,0xFF,0x19,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000C30    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000C38    "KC......" */
    0xFF,0x19,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 00000C40    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000C48    "D......." */
    0x1A,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 00000C50    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1A,0x00,  /* 00000C58    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 00000C60    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x1A,0x00,0x0A,0x02,  /* 00000C68    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 00000C70    "LNKD...." */
    0x0C,0xFF,0xFF,0x1A,0x00,0x0A,0x03,0x4C,  /* 00000C78    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00000C80    "NKA....." */
    0xFF,0xFF,0x1B,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000C88    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000C90    "C......." */
    0x1B,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000C98    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1B,0x00,  /* 00000CA0    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000CA8    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x1B,0x00,0x0A,  /* 00000CB0    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0D,  /* 00000CB8    ".LNKB..." */
    0x04,0x0C,0xFF,0xFF,0x1C,0x00,0x00,0x4C,  /* 00000CC0    ".......L" */
    0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00000CC8    "NKD....." */
    0xFF,0xFF,0x1C,0x00,0x01,0x4C,0x4E,0x4B,  /* 00000CD0    ".....LNK" */
    0x41,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000CD8    "A......." */
    0x1C,0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x42,  /* 00000CE0    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1C,  /* 00000CE8    "........" */
    0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000CF0    "...LNKC." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1D,0x00,  /* 00000CF8    "........" */
    0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,  /* 00000D00    ".LNKA..." */
    0x04,0x0C,0xFF,0xFF,0x1D,0x00,0x01,0x4C,  /* 00000D08    ".......L" */
    0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 00000D10    "NKB....." */
    0xFF,0xFF,0x1D,0x00,0x0A,0x02,0x4C,0x4E,  /* 00000D18    "......LN" */
    0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000D20    "KC......" */
    0xFF,0x1D,0x00,0x0A,0x03,0x4C,0x4E,0x4B,  /* 00000D28    ".....LNK" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000D30    "D......." */
    0x1E,0x00,0x00,0x4C,0x4E,0x4B,0x42,0x00,  /* 00000D38    "...LNKB." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1E,0x00,  /* 00000D40    "........" */
    0x01,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 00000D48    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x1E,0x00,0x0A,0x02,  /* 00000D50    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0E,0x04,  /* 00000D58    "LNKD...." */
    0x0C,0xFF,0xFF,0x1E,0x00,0x0A,0x03,0x4C,  /* 00000D60    ".......L" */
    0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00000D68    "NKA....." */
    0xFF,0xFF,0x1F,0x00,0x00,0x4C,0x4E,0x4B,  /* 00000D70    ".....LNK" */
    0x43,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000D78    "C......." */
    0x1F,0x00,0x01,0x4C,0x4E,0x4B,0x44,0x00,  /* 00000D80    "...LNKD." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1F,0x00,  /* 00000D88    "........" */
    0x0A,0x02,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000D90    "..LNKA.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x1F,0x00,0x0A,  /* 00000D98    "........" */
    0x03,0x4C,0x4E,0x4B,0x42,0x00,0x5B,0x81,  /* 00000DA0    ".LNKB.[." */
    0x24,0x2F,0x03,0x50,0x43,0x49,0x30,0x49,  /* 00000DA8    "$/.PCI0I" */
    0x53,0x41,0x5F,0x50,0x34,0x30,0x43,0x01,  /* 00000DB0    "SA_P40C." */
    0x50,0x52,0x51,0x30,0x08,0x50,0x52,0x51,  /* 00000DB8    "PRQ0.PRQ" */
    0x31,0x08,0x50,0x52,0x51,0x32,0x08,0x50,  /* 00000DC0    "1.PRQ2.P" */
    0x52,0x51,0x33,0x08,0x14,0x13,0x49,0x51,  /* 00000DC8    "RQ3...IQ" */
    0x53,0x54,0x01,0xA0,0x09,0x7B,0x0A,0x80,  /* 00000DD0    "ST...{.." */
    0x68,0x00,0xA4,0x0A,0x09,0xA4,0x0A,0x0B,  /* 00000DD8    "h......." */
    0x14,0x36,0x49,0x51,0x43,0x52,0x09,0x08,  /* 00000DE0    ".6IQCR.." */
    0x50,0x52,0x52,0x30,0x11,0x0E,0x0A,0x0B,  /* 00000DE8    "PRR0...." */
    0x89,0x06,0x00,0x09,0x01,0x00,0x00,0x00,  /* 00000DF0    "........" */
    0x00,0x79,0x00,0x8A,0x50,0x52,0x52,0x30,  /* 00000DF8    ".y..PRR0" */
    0x0A,0x05,0x50,0x52,0x52,0x49,0xA0,0x0B,  /* 00000E00    "..PRRI.." */
    0x95,0x68,0x0A,0x80,0x70,0x68,0x50,0x52,  /* 00000E08    ".h..phPR" */
    0x52,0x49,0xA4,0x50,0x52,0x52,0x30,0x5B,  /* 00000E10    "RI.PRR0[" */
    0x82,0x4C,0x07,0x4C,0x4E,0x4B,0x41,0x08,  /* 00000E18    ".L.LNKA." */
    0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,0x0C,  /* 00000E20    "_HID.A.." */
    0x0F,0x08,0x5F,0x55,0x49,0x44,0x00,0x08,  /* 00000E28    ".._UID.." */
    0x5F,0x50,0x52,0x53,0x11,0x16,0x0A,0x13,  /* 00000E30    "_PRS...." */
    0x89,0x0E,0x00,0x09,0x03,0x05,0x00,0x00,  /* 00000E38    "........" */
    0x00,0x0A,0x00,0x00,0x00,0x0B,0x00,0x00,  /* 00000E40    "........" */
    0x00,0x79,0x00,0x14,0x0F,0x5F,0x53,0x54,  /* 00000E48    ".y..._ST" */
    0x41,0x00,0xA4,0x49,0x51,0x53,0x54,0x50,  /* 00000E50    "A..IQSTP" */
    0x52,0x51,0x30,0x14,0x11,0x5F,0x44,0x49,  /* 00000E58    "RQ0.._DI" */
    0x53,0x00,0x7D,0x50,0x52,0x51,0x30,0x0A,  /* 00000E60    "S.}PRQ0." */
    0x80,0x50,0x52,0x51,0x30,0x14,0x0F,0x5F,  /* 00000E68    ".PRQ0.._" */
    0x43,0x52,0x53,0x00,0xA4,0x49,0x51,0x43,  /* 00000E70    "CRS..IQC" */
    0x52,0x50,0x52,0x51,0x30,0x14,0x17,0x5F,  /* 00000E78    "RPRQ0.._" */
    0x53,0x52,0x53,0x01,0x8A,0x68,0x0A,0x05,  /* 00000E80    "SRS..h.." */
    0x50,0x52,0x52,0x49,0x70,0x50,0x52,0x52,  /* 00000E88    "PRRIpPRR" */
    0x49,0x50,0x52,0x51,0x30,0x5B,0x82,0x4C,  /* 00000E90    "IPRQ0[.L" */
    0x07,0x4C,0x4E,0x4B,0x42,0x08,0x5F,0x48,  /* 00000E98    ".LNKB._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,  /* 00000EA0    "ID.A...." */
    0x5F,0x55,0x49,0x44,0x01,0x08,0x5F,0x50,  /* 00000EA8    "_UID.._P" */
    0x52,0x53,0x11,0x16,0x0A,0x13,0x89,0x0E,  /* 00000EB0    "RS......" */
    0x00,0x09,0x03,0x05,0x00,0x00,0x00,0x0A,  /* 00000EB8    "........" */
    0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0x79,  /* 00000EC0    ".......y" */
    0x00,0x14,0x0F,0x5F,0x53,0x54,0x41,0x00,  /* 00000EC8    "..._STA." */
    0xA4,0x49,0x51,0x53,0x54,0x50,0x52,0x51,  /* 00000ED0    ".IQSTPRQ" */
    0x31,0x14,0x11,0x5F,0x44,0x49,0x53,0x00,  /* 00000ED8    "1.._DIS." */
    0x7D,0x50,0x52,0x51,0x31,0x0A,0x80,0x50,  /* 00000EE0    "}PRQ1..P" */
    0x52,0x51,0x31,0x14,0x0F,0x5F,0x43,0x52,  /* 00000EE8    "RQ1.._CR" */
    0x53,0x00,0xA4,0x49,0x51,0x43,0x52,0x50,  /* 00000EF0    "S..IQCRP" */
    0x52,0x51,0x31,0x14,0x17,0x5F,0x53,0x52,  /* 00000EF8    "RQ1.._SR" */
    0x53,0x01,0x8A,0x68,0x0A,0x05,0x50,0x52,  /* 00000F00    "S..h..PR" */
    0x52,0x49,0x70,0x50,0x52,0x52,0x49,0x50,  /* 00000F08    "RIpPRRIP" */
    0x52,0x51,0x31,0x5B,0x82,0x4D,0x07,0x4C,  /* 00000F10    "RQ1[.M.L" */
    0x4E,0x4B,0x43,0x08,0x5F,0x48,0x49,0x44,  /* 00000F18    "NKC._HID" */
    0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,  /* 00000F20    ".A...._U" */
    0x49,0x44,0x0A,0x02,0x08,0x5F,0x50,0x52,  /* 00000F28    "ID..._PR" */
    0x53,0x11,0x16,0x0A,0x13,0x89,0x0E,0x00,  /* 00000F30    "S......." */
    0x09,0x03,0x05,0x00,0x00,0x00,0x0A,0x00,  /* 00000F38    "........" */
    0x00,0x00,0x0B,0x00,0x00,0x00,0x79,0x00,  /* 00000F40    "......y." */
    0x14,0x0F,0x5F,0x53,0x54,0x41,0x00,0xA4,  /* 00000F48    ".._STA.." */
    0x49,0x51,0x53,0x54,0x50,0x52,0x51,0x32,  /* 00000F50    "IQSTPRQ2" */
    0x14,0x11,0x5F,0x44,0x49,0x53,0x00,0x7D,  /* 00000F58    ".._DIS.}" */
    0x50,0x52,0x51,0x32,0x0A,0x80,0x50,0x52,  /* 00000F60    "PRQ2..PR" */
    0x51,0x32,0x14,0x0F,0x5F,0x43,0x52,0x53,  /* 00000F68    "Q2.._CRS" */
    0x00,0xA4,0x49,0x51,0x43,0x52,0x50,0x52,  /* 00000F70    "..IQCRPR" */
    0x51,0x32,0x14,0x17,0x5F,0x53,0x52,0x53,  /* 00000F78    "Q2.._SRS" */
    0x01,0x8A,0x68,0x0A,0x05,0x50,0x52,0x52,  /* 00000F80    "..h..PRR" */
    0x49,0x70,0x50,0x52,0x52,0x49,0x50,0x52,  /* 00000F88    "IpPRRIPR" */
    0x51,0x32,0x5B,0x82,0x4D,0x07,0x4C,0x4E,  /* 00000F90    "Q2[.M.LN" */
    0x4B,0x44,0x08,0x5F,0x48,0x49,0x44,0x0C,  /* 00000F98    "KD._HID." */
    0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,0x49,  /* 00000FA0    "A...._UI" */
    0x44,0x0A,0x03,0x08,0x5F,0x50,0x52,0x53,  /* 00000FA8    "D..._PRS" */
    0x11,0x16,0x0A,0x13,0x89,0x0E,0x00,0x09,  /* 00000FB0    "........" */
    0x03,0x05,0x00,0x00,0x00,0x0A,0x00,0x00,  /* 00000FB8    "........" */
    0x00,0x0B,0x00,0x00,0x00,0x79,0x00,0x14,  /* 00000FC0    ".....y.." */
    0x0F,0x5F,0x53,0x54,0x41,0x00,0xA4,0x49,  /* 00000FC8    "._STA..I" */
    0x51,0x53,0x54,0x50,0x52,0x51,0x33,0x14,  /* 00000FD0    "QSTPRQ3." */
    0x11,0x5F,0x44,0x49,0x53,0x00,0x7D,0x50,  /* 00000FD8    "._DIS.}P" */
    0x52,0x51,0x33,0x0A,0x80,0x50,0x52,0x51,  /* 00000FE0    "RQ3..PRQ" */
    0x33,0x14,0x0F,0x5F,0x43,0x52,0x53,0x00,  /* 00000FE8    "3.._CRS." */
    0xA4,0x49,0x51,0x43,0x52,0x50,0x52,0x51,  /* 00000FF0    ".IQCRPRQ" */
    0x33,0x14,0x17,0x5F,0x53,0x52,0x53,0x01,  /* 00000FF8    "3.._SRS." */
    0x8A,0x68,0x0A,0x05,0x50,0x52,0x52,0x49,  /* 00001000    ".h..PRRI" */
    0x70,0x50,0x52,0x52,0x49,0x50,0x52,0x51,  /* 00001008    "pPRRIPRQ" */
    0x33,0x5B,0x82,0x4F,0x04,0x4C,0x4E,0x4B,  /* 00001010    "3[.O.LNK" */
    0x53,0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,  /* 00001018    "S._HID.A" */
    0xD0,0x0C,0x0F,0x08,0x5F,0x55,0x49,0x44,  /* 00001020    "...._UID" */
    0x0A,0x04,0x08,0x5F,0x50,0x52,0x53,0x11,  /* 00001028    "..._PRS." */
    0x0E,0x0A,0x0B,0x89,0x06,0x00,0x09,0x01,  /* 00001030    "........" */
    0x09,0x00,0x00,0x00,0x79,0x00,0x14,0x09,  /* 00001038    "....y..." */
    0x5F,0x53,0x54,0x41,0x00,0xA4,0x0A,0x0B,  /* 00001040    "_STA...." */
    0x14,0x06,0x5F,0x44,0x49,0x53,0x00,0x14,  /* 00001048    ".._DIS.." */
    0x0B,0x5F,0x43,0x52,0x53,0x00,0xA4,0x5F,  /* 00001050    "._CRS.._" */
    0x50,0x52,0x53,0x14,0x06,0x5F,0x53,0x52,  /* 00001058    "PRS.._SR" */
    0x53,0x01,0x10,0x47,0x0E,0x5F,0x53,0x42,  /* 00001060    "S..G._SB" */
    0x5F,0x14,0x35,0x43,0x50,0x4D,0x41,0x01,  /* 00001068    "_.5CPMA." */
    0x70,0x83,0x88,0x43,0x50,0x4F,0x4E,0x68,  /* 00001070    "p..CPONh" */
    0x00,0x60,0x70,0x11,0x0B,0x0A,0x08,0x00,  /* 00001078    ".`p....." */
    0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x61,  /* 00001080    ".......a" */
    0x70,0x68,0x88,0x61,0x0A,0x02,0x00,0x70,  /* 00001088    "ph.a...p" */
    0x68,0x88,0x61,0x0A,0x03,0x00,0x70,0x60,  /* 00001090    "h.a...p`" */
    0x88,0x61,0x0A,0x04,0x00,0xA4,0x61,0x14,  /* 00001098    ".a....a." */
    0x1A,0x43,0x50,0x53,0x54,0x01,0x70,0x83,  /* 000010A0    ".CPST.p." */
    0x88,0x43,0x50,0x4F,0x4E,0x68,0x00,0x60,  /* 000010A8    ".CPONh.`" */
    0xA0,0x05,0x60,0xA4,0x0A,0x0F,0xA1,0x03,  /* 000010B0    "..`....." */
    0xA4,0x00,0x14,0x0A,0x43,0x50,0x45,0x4A,  /* 000010B8    "....CPEJ" */
    0x02,0x5B,0x22,0x0A,0xC8,0x5B,0x80,0x50,  /* 000010C0    ".["..[.P" */
    0x52,0x53,0x54,0x01,0x0B,0x00,0xAF,0x0A,  /* 000010C8    "RST....." */
    0x20,0x5B,0x81,0x0C,0x50,0x52,0x53,0x54,  /* 000010D0    " [..PRST" */
    0x01,0x50,0x52,0x53,0x5F,0x40,0x10,0x14,  /* 000010D8    ".PRS_@.." */
    0x4A,0x06,0x50,0x52,0x53,0x43,0x00,0x70,  /* 000010E0    "J.PRSC.p" */
    0x50,0x52,0x53,0x5F,0x65,0x70,0x00,0x62,  /* 000010E8    "PRS_ep.b" */
    0x70,0x00,0x60,0xA2,0x46,0x05,0x95,0x60,  /* 000010F0    "p.`.F..`" */
    0x87,0x43,0x50,0x4F,0x4E,0x70,0x83,0x88,  /* 000010F8    ".CPONp.." */
    0x43,0x50,0x4F,0x4E,0x60,0x00,0x61,0xA0,  /* 00001100    "CPON`.a." */
    0x0A,0x7B,0x60,0x0A,0x07,0x00,0x7A,0x62,  /* 00001108    ".{`...zb" */
    0x01,0x62,0xA1,0x0C,0x70,0x83,0x88,0x65,  /* 00001110    ".b..p..e" */
    0x7A,0x60,0x0A,0x03,0x00,0x00,0x62,0x70,  /* 00001118    "z`....bp" */
    0x7B,0x62,0x01,0x00,0x63,0xA0,0x22,0x92,  /* 00001120    "{b..c."." */
    0x93,0x61,0x63,0x70,0x63,0x88,0x43,0x50,  /* 00001128    ".acpc.CP" */
    0x4F,0x4E,0x60,0x00,0xA0,0x0A,0x93,0x63,  /* 00001130    "ON`....c" */
    0x01,0x4E,0x54,0x46,0x59,0x60,0x01,0xA1,  /* 00001138    ".NTFY`.." */
    0x08,0x4E,0x54,0x46,0x59,0x60,0x0A,0x03,  /* 00001140    ".NTFY`.." */
    0x75,0x60,0x10,0x4E,0x09,0x5F,0x47,0x50,  /* 00001148    "u`.N._GP" */
    0x45,0x08,0x5F,0x48,0x49,0x44,0x0D,0x41,  /* 00001150    "E._HID.A" */
    0x43,0x50,0x49,0x30,0x30,0x30,0x36,0x00,  /* 00001158    "CPI0006." */
    0x14,0x06,0x5F,0x4C,0x30,0x30,0x00,0x14,  /* 00001160    ".._L00.." */
    0x15,0x5F,0x45,0x30,0x31,0x00,0x5C,0x2F,  /* 00001168    "._E01.\/" */
    0x03,0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,  /* 00001170    "._SB_PCI" */
    0x30,0x50,0x43,0x4E,0x46,0x14,0x10,0x5F,  /* 00001178    "0PCNF.._" */
    0x45,0x30,0x32,0x00,0x5C,0x2E,0x5F,0x53,  /* 00001180    "E02.\._S" */
    0x42,0x5F,0x50,0x52,0x53,0x43,0x14,0x06,  /* 00001188    "B_PRSC.." */
    0x5F,0x4C,0x30,0x33,0x00,0x14,0x06,0x5F,  /* 00001190    "_L03..._" */
    0x4C,0x30,0x34,0x00,0x14,0x06,0x5F,0x4C,  /* 00001198    "L04..._L" */
    0x30,0x35,0x00,0x14,0x06,0x5F,0x4C,0x30,  /* 000011A0    "05..._L0" */
    0x36,0x00,0x14,0x06,0x5F,0x4C,0x30,0x37,  /* 000011A8    "6..._L07" */
    0x00,0x14,0x06,0x5F,0x4C,0x30,0x38,0x00,  /* 000011B0    "..._L08." */
    0x14,0x06,0x5F,0x4C,0x30,0x39,0x00,0x14,  /* 000011B8    ".._L09.." */
    0x06,0x5F,0x4C,0x30,0x41,0x00,0x14,0x06,  /* 000011C0    "._L0A..." */
    0x5F,0x4C,0x30,0x42,0x00,0x14,0x06,0x5F,  /* 000011C8    "_L0B..._" */
    0x4C,0x30,0x43,0x00,0x14,0x06,0x5F,0x4C,  /* 000011D0    "L0C..._L" */
    0x30,0x44,0x00,0x14,0x06,0x5F,0x4C,0x30,  /* 000011D8    "0D..._L0" */
    0x45,0x00,0x14,0x06,0x5F,0x4C,0x30,0x46,  /* 000011E0    "E..._L0F" */
    0x00                                      /* 000011E8    "."        */
};

#endif

```

`devices/nvram/acpi_dsdt/build_hex.sh`:

```sh
#!/bin/sh
cpp -P -o acpi-dsdt.dsl.i acpi-dsdt.dsl
iasl -tc -p acpi_dsdt acpi-dsdt.dsl.i
rm acpi_dsdt.aml acpi-dsdt.dsl.i
mv acpi_dsdt.hex acpi_dsdt.hex.h

cpp -P -o q35-acpi-dsdt.dsl.i q35-acpi-dsdt.dsl
iasl -tc -p q35_acpi_dsdt q35-acpi-dsdt.dsl.i
rm q35_acpi_dsdt.aml q35-acpi-dsdt.dsl.i
mv q35_acpi_dsdt.hex q35_acpi_dsdt.hex.h


```

`devices/nvram/acpi_dsdt/meson.build`:

```build

mvisor_sources += files(
  'acpi_dsdt.hex.h',
  'q35_acpi_dsdt.hex.h'
)

```

`devices/nvram/acpi_dsdt/q35-acpi-dsdt.dsl`:

```dsl
/*
 * Bochs/QEMU ACPI DSDT ASL definition
 *
 * Copyright (c) 2006 Fabrice Bellard
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License version 2 as published by the Free Software Foundation.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
 */
/*
 * Copyright (c) 2010 Isaku Yamahata
 *                    yamahata at valinux co jp
 * Based on acpi-dsdt.dsl, but heavily modified for q35 chipset.
 */

DefinitionBlock (
    "q35-acpi-dsdt.aml",// Output Filename
    "DSDT",             // Signature
    0x01,               // DSDT Compliance Revision
    "BXPC",             // OEMID
    "BXDSDT",           // TABLE ID
    0x2                 // OEM Revision
    )
{

#include "acpi-dsdt-dbug.dsl"

    Scope(\_SB) {
        OperationRegion(PCST, SystemIO, 0xae00, 0x0c)
        OperationRegion(PCSB, SystemIO, 0xae0c, 0x01)
        Field(PCSB, AnyAcc, NoLock, WriteAsZeros) {
            PCIB, 8,
        }
    }


/****************************************************************
 * PCI Bus definition
 ****************************************************************/

    Scope(\_SB) {
        Device(PCI0) {
            Name(_HID, EisaId("PNP0A08"))
            Name(_CID, EisaId("PNP0A03"))
            Name(_ADR, 0x00)
            Name(_UID, 1)

            // _OSC: based on sample of ACPI3.0b spec
            Name(SUPP, 0) // PCI _OSC Support Field value
            Name(CTRL, 0) // PCI _OSC Control Field value
            Method(_OSC, 4) {
                // Create DWORD-addressable fields from the Capabilities Buffer
                CreateDWordField(Arg3, 0, CDW1)

                // Check for proper UUID
                If (LEqual(Arg0, ToUUID("33DB4D5B-1FF7-401C-9657-7441C03DD766"))) {
                    // Create DWORD-addressable fields from the Capabilities Buffer
                    CreateDWordField(Arg3, 4, CDW2)
                    CreateDWordField(Arg3, 8, CDW3)

                    // Save Capabilities DWORD2 & 3
                    Store(CDW2, SUPP)
                    Store(CDW3, CTRL)

                    // Always allow native PME, AER (no dependencies)
                    // Never allow SHPC (no SHPC controller in this system)
                    And(CTRL, 0x1D, CTRL)

#if 0 // For now, nothing to do
                    If (Not(And(CDW1, 1))) { // Query flag clear?
                        // Disable GPEs for features granted native control.
                        If (And(CTRL, 0x01)) { // Hot plug control granted?
                            Store(0, HPCE) // clear the hot plug SCI enable bit
                            Store(1, HPCS) // clear the hot plug SCI status bit
                        }
                        If (And(CTRL, 0x04)) { // PME control granted?
                            Store(0, PMCE) // clear the PME SCI enable bit
                            Store(1, PMCS) // clear the PME SCI status bit
                        }
                        If (And(CTRL, 0x10)) { // OS restoring PCI Express cap structure?
                            // Set status to not restore PCI Express cap structure
                            // upon resume from S3
                            Store(1, S3CR)
                        }
                    }
#endif
                    If (LNotEqual(Arg1, One)) {
                        // Unknown revision
                        Or(CDW1, 0x08, CDW1)
                    }
                    If (LNotEqual(CDW3, CTRL)) {
                        // Capabilities bits were masked
                        Or(CDW1, 0x10, CDW1)
                    }
                    // Update DWORD3 in the buffer
                    Store(CTRL, CDW3)
                } Else {
                    Or(CDW1, 4, CDW1) // Unrecognized UUID
                }
                Return (Arg3)
            }
        }
    }

#include "acpi-dsdt-pci-crs.dsl"
#include "acpi-dsdt-hpet.dsl"


/****************************************************************
 * VGA
 ****************************************************************/

    Scope(\_SB.PCI0) {
        Device(VGA) {
            Name(_ADR, 0x00010000)
            Method(_S1D, 0, NotSerialized) {
                Return (0x00)
            }
            Method(_S2D, 0, NotSerialized) {
                Return (0x00)
            }
            Method(_S3D, 0, NotSerialized) {
                Return (0x00)
            }
        }
    }


/****************************************************************
 * LPC ISA bridge
 ****************************************************************/

    Scope(\_SB.PCI0) {
        /* PCI D31:f0 LPC ISA bridge */
        Device(ISA) {
            /* PCI D31:f0 */
            Name(_ADR, 0x001f0000)

            /* ICH9 PCI to ISA irq remapping */
            OperationRegion(PIRQ, PCI_Config, 0x60, 0x0C)

            OperationRegion(LPCD, PCI_Config, 0x80, 0x2)
            Field(LPCD, AnyAcc, NoLock, Preserve) {
                COMA,   3,
                    ,   1,
                COMB,   3,

                Offset(0x01),
                LPTD,   2,
                    ,   2,
                FDCD,   2
            }
            OperationRegion(LPCE, PCI_Config, 0x82, 0x2)
            Field(LPCE, AnyAcc, NoLock, Preserve) {
                CAEN,   1,
                CBEN,   1,
                LPEN,   1,
                FDEN,   1
            }
        }
    }

#include "acpi-dsdt-isa.dsl"


/****************************************************************
 * PCI IRQs
 ****************************************************************/

    /* Zero => PIC mode, One => APIC Mode */
    Name(\PICF, Zero)
    Method(\_PIC, 1, NotSerialized) {
        Store(Arg0, \PICF)
    }

    Scope(\_SB) {
        Scope(PCI0) {
#define prt_slot_lnk(nr, lnk0, lnk1, lnk2, lnk3)  \
    Package() { nr##ffff, 0, lnk0, 0 },           \
    Package() { nr##ffff, 1, lnk1, 0 },           \
    Package() { nr##ffff, 2, lnk2, 0 },           \
    Package() { nr##ffff, 3, lnk3, 0 }

#define prt_slot_lnkA(nr) prt_slot_lnk(nr, LNKA, LNKB, LNKC, LNKD)
#define prt_slot_lnkB(nr) prt_slot_lnk(nr, LNKB, LNKC, LNKD, LNKA)
#define prt_slot_lnkC(nr) prt_slot_lnk(nr, LNKC, LNKD, LNKA, LNKB)
#define prt_slot_lnkD(nr) prt_slot_lnk(nr, LNKD, LNKA, LNKB, LNKC)

#define prt_slot_lnkE(nr) prt_slot_lnk(nr, LNKE, LNKF, LNKG, LNKH)
#define prt_slot_lnkF(nr) prt_slot_lnk(nr, LNKF, LNKG, LNKH, LNKE)
#define prt_slot_lnkG(nr) prt_slot_lnk(nr, LNKG, LNKH, LNKE, LNKF)
#define prt_slot_lnkH(nr) prt_slot_lnk(nr, LNKH, LNKE, LNKF, LNKG)

            Name(PRTP, package() {
                prt_slot_lnkE(0x0000),
                prt_slot_lnkF(0x0001),
                prt_slot_lnkG(0x0002),
                prt_slot_lnkH(0x0003),
                prt_slot_lnkE(0x0004),
                prt_slot_lnkF(0x0005),
                prt_slot_lnkG(0x0006),
                prt_slot_lnkH(0x0007),
                prt_slot_lnkE(0x0008),
                prt_slot_lnkF(0x0009),
                prt_slot_lnkG(0x000a),
                prt_slot_lnkH(0x000b),
                prt_slot_lnkE(0x000c),
                prt_slot_lnkF(0x000d),
                prt_slot_lnkG(0x000e),
                prt_slot_lnkH(0x000f),
                prt_slot_lnkE(0x0010),
                prt_slot_lnkF(0x0011),
                prt_slot_lnkG(0x0012),
                prt_slot_lnkH(0x0013),
                prt_slot_lnkE(0x0014),
                prt_slot_lnkF(0x0015),
                prt_slot_lnkG(0x0016),
                prt_slot_lnkH(0x0017),
                prt_slot_lnkE(0x0018),

                /* INTA -> PIRQA for slot 25 - 31
                   see the default value of D<N>IR */
                prt_slot_lnkA(0x0019),
                prt_slot_lnkA(0x001a),
                prt_slot_lnkA(0x001b),
                prt_slot_lnkA(0x001c),
                prt_slot_lnkA(0x001d),

                /* PCIe->PCI bridge. use PIRQ[E-H] */
                prt_slot_lnkE(0x001e),

                prt_slot_lnkA(0x001f)
            })

#define prt_slot_gsi(nr, gsi0, gsi1, gsi2, gsi3)  \
    Package() { nr##ffff, 0, gsi0, 0 },           \
    Package() { nr##ffff, 1, gsi1, 0 },           \
    Package() { nr##ffff, 2, gsi2, 0 },           \
    Package() { nr##ffff, 3, gsi3, 0 }

#define prt_slot_gsiA(nr) prt_slot_gsi(nr, GSIA, GSIB, GSIC, GSID)
#define prt_slot_gsiB(nr) prt_slot_gsi(nr, GSIB, GSIC, GSID, GSIA)
#define prt_slot_gsiC(nr) prt_slot_gsi(nr, GSIC, GSID, GSIA, GSIB)
#define prt_slot_gsiD(nr) prt_slot_gsi(nr, GSID, GSIA, GSIB, GSIC)

#define prt_slot_gsiE(nr) prt_slot_gsi(nr, GSIE, GSIF, GSIG, GSIH)
#define prt_slot_gsiF(nr) prt_slot_gsi(nr, GSIF, GSIG, GSIH, GSIE)
#define prt_slot_gsiG(nr) prt_slot_gsi(nr, GSIG, GSIH, GSIE, GSIF)
#define prt_slot_gsiH(nr) prt_slot_gsi(nr, GSIH, GSIE, GSIF, GSIG)

            Name(PRTA, package() {
                prt_slot_gsiE(0x0000),
                prt_slot_gsiF(0x0001),
                prt_slot_gsiG(0x0002),
                prt_slot_gsiH(0x0003),
                prt_slot_gsiE(0x0004),
                prt_slot_gsiF(0x0005),
                prt_slot_gsiG(0x0006),
                prt_slot_gsiH(0x0007),
                prt_slot_gsiE(0x0008),
                prt_slot_gsiF(0x0009),
                prt_slot_gsiG(0x000a),
                prt_slot_gsiH(0x000b),
                prt_slot_gsiE(0x000c),
                prt_slot_gsiF(0x000d),
                prt_slot_gsiG(0x000e),
                prt_slot_gsiH(0x000f),
                prt_slot_gsiE(0x0010),
                prt_slot_gsiF(0x0011),
                prt_slot_gsiG(0x0012),
                prt_slot_gsiH(0x0013),
                prt_slot_gsiE(0x0014),
                prt_slot_gsiF(0x0015),
                prt_slot_gsiG(0x0016),
                prt_slot_gsiH(0x0017),
                prt_slot_gsiE(0x0018),

                /* INTA -> PIRQA for slot 25 - 31, but 30
                   see the default value of D<N>IR */
                prt_slot_gsiA(0x0019),
                prt_slot_gsiA(0x001a),
                prt_slot_gsiA(0x001b),
                prt_slot_gsiA(0x001c),
                prt_slot_gsiA(0x001d),

                /* PCIe->PCI bridge. use PIRQ[E-H] */
                prt_slot_gsiE(0x001e),

                prt_slot_gsiA(0x001f)
            })

            Method(_PRT, 0, NotSerialized) {
                /* PCI IRQ routing table, example from ACPI 2.0a specification,
                   section 6.2.8.1 */
                /* Note: we provide the same info as the PCI routing
                   table of the Bochs BIOS */
                If (LEqual(\PICF, Zero)) {
                    Return (PRTP)
                } Else {
                    Return (PRTA)
                }
            }
        }

        Field(PCI0.ISA.PIRQ, ByteAcc, NoLock, Preserve) {
            PRQA,   8,
            PRQB,   8,
            PRQC,   8,
            PRQD,   8,

            Offset(0x08),
            PRQE,   8,
            PRQF,   8,
            PRQG,   8,
            PRQH,   8
        }

        Method(IQST, 1, NotSerialized) {
            // _STA method - get status
            If (And(0x80, Arg0)) {
                Return (0x09)
            }
            Return (0x0B)
        }
        Method(IQCR, 1, Serialized) {
            // _CRS method - get current settings
            Name(PRR0, ResourceTemplate() {
                Interrupt(, Level, ActiveHigh, Shared) { 0 }
            })
            CreateDWordField(PRR0, 0x05, PRRI)
            Store(And(Arg0, 0x0F), PRRI)
            Return (PRR0)
        }

#define define_link(link, uid, reg)                             \
        Device(link) {                                          \
            Name(_HID, EISAID("PNP0C0F"))                       \
            Name(_UID, uid)                                     \
            Name(_PRS, ResourceTemplate() {                     \
                Interrupt(, Level, ActiveHigh, Shared) {        \
                    5, 10, 11                                   \
                }                                               \
            })                                                  \
            Method(_STA, 0, NotSerialized) {                    \
                Return (IQST(reg))                              \
            }                                                   \
            Method(_DIS, 0, NotSerialized) {                    \
                Or(reg, 0x80, reg)                              \
            }                                                   \
            Method(_CRS, 0, NotSerialized) {                    \
                Return (IQCR(reg))                              \
            }                                                   \
            Method(_SRS, 1, NotSerialized) {                    \
                CreateDWordField(Arg0, 0x05, PRRI)              \
                Store(PRRI, reg)                                \
            }                                                   \
        }

        define_link(LNKA, 0, PRQA)
        define_link(LNKB, 1, PRQB)
        define_link(LNKC, 2, PRQC)
        define_link(LNKD, 3, PRQD)
        define_link(LNKE, 4, PRQE)
        define_link(LNKF, 5, PRQF)
        define_link(LNKG, 6, PRQG)
        define_link(LNKH, 7, PRQH)

#define define_gsi_link(link, uid, gsi)                         \
        Device(link) {                                          \
            Name(_HID, EISAID("PNP0C0F"))                       \
            Name(_UID, uid)                                     \
            Name(_PRS, ResourceTemplate() {                     \
                Interrupt(, Level, ActiveHigh, Shared) {        \
                    gsi                                         \
                }                                               \
            })                                                  \
            Name(_CRS, ResourceTemplate() {                     \
                Interrupt(, Level, ActiveHigh, Shared) {        \
                    gsi                                         \
                }                                               \
            })                                                  \
            Method(_SRS, 1, NotSerialized) {                    \
            }                                                   \
        }

        define_gsi_link(GSIA, 0, 0x10)
        define_gsi_link(GSIB, 0, 0x11)
        define_gsi_link(GSIC, 0, 0x12)
        define_gsi_link(GSID, 0, 0x13)
        define_gsi_link(GSIE, 0, 0x14)
        define_gsi_link(GSIF, 0, 0x15)
        define_gsi_link(GSIG, 0, 0x16)
        define_gsi_link(GSIH, 0, 0x17)
    }

#include "acpi-dsdt-cpu-hotplug.dsl"


/****************************************************************
 * General purpose events
 ****************************************************************/

    Scope(\_GPE) {
        Name(_HID, "ACPI0006")

        Method(_L00) {
        }
        Method(_L01) {
            // CPU hotplug event
            \_SB.PRSC()
        }
        Method(_L02) {
        }
        Method(_L03) {
        }
        Method(_L04) {
        }
        Method(_L05) {
        }
        Method(_L06) {
        }
        Method(_L07) {
        }
        Method(_L08) {
        }
        Method(_L09) {
        }
        Method(_L0A) {
        }
        Method(_L0B) {
        }
        Method(_L0C) {
        }
        Method(_L0D) {
        }
        Method(_L0E) {
        }
        Method(_L0F) {
        }
    }
}

```

`devices/nvram/acpi_dsdt/q35_acpi_dsdt.hex.h`:

```h
/*
 * 
 * Intel ACPI Component Architecture
 * ASL+ Optimizing Compiler/Disassembler version 20200925 (64-bit version)
 * Copyright (c) 2000 - 2020 Intel Corporation
 * 
 * Compilation of "q35-acpi-dsdt.dsl.i" - Mon Sep  5 06:16:01 2022
 * 
 * C source code output
 * AML code block contains 0x1D52 bytes
 *
 */
#ifndef __Q35_ACPI_DSDT_HEX__
#define __Q35_ACPI_DSDT_HEX__

unsigned char q35_acpi_dsdt_aml_code[] =
{
    0x44,0x53,0x44,0x54,0x52,0x1D,0x00,0x00,  /* 00000000    "DSDTR..." */
    0x01,0x25,0x42,0x58,0x50,0x43,0x00,0x00,  /* 00000008    ".%BXPC.." */
    0x42,0x58,0x44,0x53,0x44,0x54,0x00,0x00,  /* 00000010    "BXDSDT.." */
    0x02,0x00,0x00,0x00,0x49,0x4E,0x54,0x4C,  /* 00000018    "....INTL" */
    0x25,0x09,0x20,0x20,0xA0,0x41,0x0A,0x00,  /* 00000020    "%.  .A.." */
    0x15,0x5C,0x2F,0x04,0x5F,0x53,0x42,0x5F,  /* 00000028    ".\/._SB_" */
    0x50,0x43,0x49,0x30,0x5F,0x43,0x52,0x53,  /* 00000030    "PCI0_CRS" */
    0x50,0x30,0x53,0x5F,0x01,0x00,0x15,0x5C,  /* 00000038    "P0S_...\" */
    0x2F,0x04,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 00000040    "/._SB_PC" */
    0x49,0x30,0x5F,0x43,0x52,0x53,0x50,0x30,  /* 00000048    "I0_CRSP0" */
    0x45,0x5F,0x01,0x00,0x15,0x5C,0x2F,0x04,  /* 00000050    "E_...\/." */
    0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,0x30,  /* 00000058    "_SB_PCI0" */
    0x5F,0x43,0x52,0x53,0x50,0x31,0x56,0x5F,  /* 00000060    "_CRSP1V_" */
    0x01,0x00,0x15,0x5C,0x2F,0x04,0x5F,0x53,  /* 00000068    "...\/._S" */
    0x42,0x5F,0x50,0x43,0x49,0x30,0x5F,0x43,  /* 00000070    "B_PCI0_C" */
    0x52,0x53,0x50,0x31,0x53,0x5F,0x03,0x00,  /* 00000078    "RSP1S_.." */
    0x15,0x5C,0x2F,0x04,0x5F,0x53,0x42,0x5F,  /* 00000080    ".\/._SB_" */
    0x50,0x43,0x49,0x30,0x5F,0x43,0x52,0x53,  /* 00000088    "PCI0_CRS" */
    0x50,0x31,0x45,0x5F,0x03,0x00,0x15,0x5C,  /* 00000090    "P1E_...\" */
    0x2F,0x04,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 00000098    "/._SB_PC" */
    0x49,0x30,0x5F,0x43,0x52,0x53,0x50,0x31,  /* 000000A0    "I0_CRSP1" */
    0x4C,0x5F,0x03,0x00,0x15,0x5C,0x2E,0x5F,  /* 000000A8    "L_...\._" */
    0x53,0x42,0x5F,0x4E,0x54,0x46,0x59,0x08,  /* 000000B0    "SB_NTFY." */
    0x02,0x15,0x5C,0x2E,0x5F,0x53,0x42,0x5F,  /* 000000B8    "..\._SB_" */
    0x43,0x50,0x4F,0x4E,0x04,0x00,0x10,0x49,  /* 000000C0    "CPON...I" */
    0x04,0x5C,0x00,0x5B,0x80,0x44,0x42,0x47,  /* 000000C8    ".\.[.DBG" */
    0x5F,0x01,0x0B,0x02,0x04,0x01,0x5B,0x81,  /* 000000D0    "_.....[." */
    0x0B,0x44,0x42,0x47,0x5F,0x01,0x44,0x42,  /* 000000D8    ".DBG_.DB" */
    0x47,0x42,0x08,0x14,0x2C,0x44,0x42,0x55,  /* 000000E0    "GB..,DBU" */
    0x47,0x01,0x98,0x68,0x60,0x96,0x60,0x60,  /* 000000E8    "G..h`.``" */
    0x74,0x87,0x60,0x01,0x61,0x70,0x00,0x62,  /* 000000F0    "t.`.ap.b" */
    0xA2,0x10,0x95,0x62,0x61,0x70,0x83,0x88,  /* 000000F8    "...bap.." */
    0x60,0x62,0x00,0x44,0x42,0x47,0x42,0x75,  /* 00000100    "`b.DBGBu" */
    0x62,0x70,0x0A,0x0A,0x44,0x42,0x47,0x42,  /* 00000108    "bp..DBGB" */
    0x10,0x29,0x5F,0x53,0x42,0x5F,0x5B,0x80,  /* 00000110    ".)_SB_[." */
    0x50,0x43,0x53,0x54,0x01,0x0B,0x00,0xAE,  /* 00000118    "PCST...." */
    0x0A,0x0C,0x5B,0x80,0x50,0x43,0x53,0x42,  /* 00000120    "..[.PCSB" */
    0x01,0x0B,0x0C,0xAE,0x01,0x5B,0x81,0x0B,  /* 00000128    ".....[.." */
    0x50,0x43,0x53,0x42,0x40,0x50,0x43,0x49,  /* 00000130    "PCSB@PCI" */
    0x42,0x08,0x10,0x4F,0x0C,0x5F,0x53,0x42,  /* 00000138    "B..O._SB" */
    0x5F,0x5B,0x82,0x47,0x0C,0x50,0x43,0x49,  /* 00000140    "_[.G.PCI" */
    0x30,0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,  /* 00000148    "0._HID.A" */
    0xD0,0x0A,0x08,0x08,0x5F,0x43,0x49,0x44,  /* 00000150    "...._CID" */
    0x0C,0x41,0xD0,0x0A,0x03,0x08,0x5F,0x41,  /* 00000158    ".A...._A" */
    0x44,0x52,0x00,0x08,0x5F,0x55,0x49,0x44,  /* 00000160    "DR.._UID" */
    0x01,0x08,0x53,0x55,0x50,0x50,0x00,0x08,  /* 00000168    "..SUPP.." */
    0x43,0x54,0x52,0x4C,0x00,0x14,0x44,0x09,  /* 00000170    "CTRL..D." */
    0x5F,0x4F,0x53,0x43,0x04,0x8A,0x6B,0x00,  /* 00000178    "_OSC..k." */
    0x43,0x44,0x57,0x31,0xA0,0x46,0x07,0x93,  /* 00000180    "CDW1.F.." */
    0x68,0x11,0x13,0x0A,0x10,0x5B,0x4D,0xDB,  /* 00000188    "h....[M." */
    0x33,0xF7,0x1F,0x1C,0x40,0x96,0x57,0x74,  /* 00000190    "3...@.Wt" */
    0x41,0xC0,0x3D,0xD7,0x66,0x8A,0x6B,0x0A,  /* 00000198    "A.=.f.k." */
    0x04,0x43,0x44,0x57,0x32,0x8A,0x6B,0x0A,  /* 000001A0    ".CDW2.k." */
    0x08,0x43,0x44,0x57,0x33,0x70,0x43,0x44,  /* 000001A8    ".CDW3pCD" */
    0x57,0x32,0x53,0x55,0x50,0x50,0x70,0x43,  /* 000001B0    "W2SUPPpC" */
    0x44,0x57,0x33,0x43,0x54,0x52,0x4C,0x7B,  /* 000001B8    "DW3CTRL{" */
    0x43,0x54,0x52,0x4C,0x0A,0x1D,0x43,0x54,  /* 000001C0    "CTRL..CT" */
    0x52,0x4C,0xA0,0x10,0x92,0x93,0x69,0x01,  /* 000001C8    "RL....i." */
    0x7D,0x43,0x44,0x57,0x31,0x0A,0x08,0x43,  /* 000001D0    "}CDW1..C" */
    0x44,0x57,0x31,0xA0,0x16,0x92,0x93,0x43,  /* 000001D8    "DW1....C" */
    0x44,0x57,0x33,0x43,0x54,0x52,0x4C,0x7D,  /* 000001E0    "DW3CTRL}" */
    0x43,0x44,0x57,0x31,0x0A,0x10,0x43,0x44,  /* 000001E8    "CDW1..CD" */
    0x57,0x31,0x70,0x43,0x54,0x52,0x4C,0x43,  /* 000001F0    "W1pCTRLC" */
    0x44,0x57,0x33,0xA1,0x0C,0x7D,0x43,0x44,  /* 000001F8    "DW3..}CD" */
    0x57,0x31,0x0A,0x04,0x43,0x44,0x57,0x31,  /* 00000200    "W1..CDW1" */
    0xA4,0x6B,0x10,0x4E,0x15,0x2E,0x5F,0x53,  /* 00000208    ".k.N.._S" */
    0x42,0x5F,0x50,0x43,0x49,0x30,0x08,0x43,  /* 00000210    "B_PCI0.C" */
    0x52,0x45,0x53,0x11,0x42,0x07,0x0A,0x6E,  /* 00000218    "RES.B..n" */
    0x88,0x0D,0x00,0x02,0x0C,0x00,0x00,0x00,  /* 00000220    "........" */
    0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x01,  /* 00000228    "........" */
    0x47,0x01,0xF8,0x0C,0xF8,0x0C,0x01,0x08,  /* 00000230    "G......." */
    0x88,0x0D,0x00,0x01,0x0C,0x03,0x00,0x00,  /* 00000238    "........" */
    0x00,0x00,0xF7,0x0C,0x00,0x00,0xF8,0x0C,  /* 00000240    "........" */
    0x88,0x0D,0x00,0x01,0x0C,0x03,0x00,0x00,  /* 00000248    "........" */
    0x00,0x0D,0xFF,0xFF,0x00,0x00,0x00,0xF3,  /* 00000250    "........" */
    0x87,0x17,0x00,0x00,0x0C,0x03,0x00,0x00,  /* 00000258    "........" */
    0x00,0x00,0x00,0x00,0x0A,0x00,0xFF,0xFF,  /* 00000260    "........" */
    0x0B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 00000268    "........" */
    0x02,0x00,0x87,0x17,0x00,0x00,0x0C,0x01,  /* 00000270    "........" */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,  /* 00000278    "........" */
    0xFF,0xFF,0xBF,0xFE,0x00,0x00,0x00,0x00,  /* 00000280    "........" */
    0x00,0x00,0xC0,0x1E,0x79,0x00,0x08,0x43,  /* 00000288    "....y..C" */
    0x52,0x36,0x34,0x11,0x33,0x0A,0x30,0x8A,  /* 00000290    "R64.3.0." */
    0x2B,0x00,0x00,0x0C,0x03,0x00,0x00,0x00,  /* 00000298    "+......." */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000002A0    "........" */
    0x00,0x80,0x00,0x00,0x00,0xFF,0xFF,0xFF,  /* 000002A8    "........" */
    0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000002B0    "........" */
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,  /* 000002B8    "........" */
    0x00,0x80,0x00,0x00,0x00,0x79,0x00,0x14,  /* 000002C0    ".....y.." */
    0x41,0x0A,0x5F,0x43,0x52,0x53,0x00,0x8A,  /* 000002C8    "A._CRS.." */
    0x43,0x52,0x45,0x53,0x0A,0x5C,0x50,0x53,  /* 000002D0    "CRES.\PS" */
    0x33,0x32,0x8A,0x43,0x52,0x45,0x53,0x0A,  /* 000002D8    "32.CRES." */
    0x60,0x50,0x45,0x33,0x32,0x8A,0x43,0x52,  /* 000002E0    "`PE32.CR" */
    0x45,0x53,0x0A,0x68,0x50,0x4C,0x33,0x32,  /* 000002E8    "ES.hPL32" */
    0x70,0x50,0x30,0x53,0x5F,0x50,0x53,0x33,  /* 000002F0    "pP0S_PS3" */
    0x32,0x70,0x50,0x30,0x45,0x5F,0x50,0x45,  /* 000002F8    "2pP0E_PE" */
    0x33,0x32,0x70,0x72,0x74,0x50,0x30,0x45,  /* 00000300    "32prtP0E" */
    0x5F,0x50,0x30,0x53,0x5F,0x00,0x01,0x00,  /* 00000308    "_P0S_..." */
    0x50,0x4C,0x33,0x32,0xA0,0x0C,0x93,0x50,  /* 00000310    "PL32...P" */
    0x31,0x56,0x5F,0x00,0xA4,0x43,0x52,0x45,  /* 00000318    "1V_..CRE" */
    0x53,0x8F,0x43,0x52,0x36,0x34,0x0A,0x0E,  /* 00000320    "S.CR64.." */
    0x50,0x53,0x36,0x34,0x8F,0x43,0x52,0x36,  /* 00000328    "PS64.CR6" */
    0x34,0x0A,0x16,0x50,0x45,0x36,0x34,0x8F,  /* 00000330    "4..PE64." */
    0x43,0x52,0x36,0x34,0x0A,0x26,0x50,0x4C,  /* 00000338    "CR64.&PL" */
    0x36,0x34,0x70,0x50,0x31,0x53,0x5F,0x50,  /* 00000340    "64pP1S_P" */
    0x53,0x36,0x34,0x70,0x50,0x31,0x45,0x5F,  /* 00000348    "S64pP1E_" */
    0x50,0x45,0x36,0x34,0x70,0x50,0x31,0x4C,  /* 00000350    "PE64pP1L" */
    0x5F,0x50,0x4C,0x36,0x34,0x84,0x43,0x52,  /* 00000358    "_PL64.CR" */
    0x45,0x53,0x43,0x52,0x36,0x34,0x60,0xA4,  /* 00000360    "ESCR64`." */
    0x60,0x10,0x4D,0x08,0x5F,0x53,0x42,0x5F,  /* 00000368    "`.M._SB_" */
    0x5B,0x82,0x45,0x08,0x48,0x50,0x45,0x54,  /* 00000370    "[.E.HPET" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 00000378    "._HID.A." */
    0x01,0x03,0x08,0x5F,0x55,0x49,0x44,0x00,  /* 00000380    "..._UID." */
    0x5B,0x80,0x48,0x50,0x54,0x4D,0x00,0x0C,  /* 00000388    "[.HPTM.." */
    0x00,0x00,0xD0,0xFE,0x0B,0x00,0x04,0x5B,  /* 00000390    ".......[" */
    0x81,0x10,0x48,0x50,0x54,0x4D,0x13,0x56,  /* 00000398    "..HPTM.V" */
    0x45,0x4E,0x44,0x20,0x50,0x52,0x44,0x5F,  /* 000003A0    "END PRD_" */
    0x20,0x14,0x36,0x5F,0x53,0x54,0x41,0x00,  /* 000003A8    " .6_STA." */
    0x70,0x56,0x45,0x4E,0x44,0x60,0x70,0x50,  /* 000003B0    "pVEND`pP" */
    0x52,0x44,0x5F,0x61,0x7A,0x60,0x0A,0x10,  /* 000003B8    "RD_az`.." */
    0x60,0xA0,0x0C,0x91,0x93,0x60,0x00,0x93,  /* 000003C0    "`....`.." */
    0x60,0x0B,0xFF,0xFF,0xA4,0x00,0xA0,0x0E,  /* 000003C8    "`......." */
    0x91,0x93,0x61,0x00,0x94,0x61,0x0C,0x00,  /* 000003D0    "..a..a.." */
    0xE1,0xF5,0x05,0xA4,0x00,0xA4,0x0A,0x0F,  /* 000003D8    "........" */
    0x08,0x5F,0x43,0x52,0x53,0x11,0x11,0x0A,  /* 000003E0    "._CRS..." */
    0x0E,0x86,0x09,0x00,0x00,0x00,0x00,0xD0,  /* 000003E8    "........" */
    0xFE,0x00,0x04,0x00,0x00,0x79,0x00,0x10,  /* 000003F0    ".....y.." */
    0x36,0x2E,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 000003F8    "6._SB_PC" */
    0x49,0x30,0x5B,0x82,0x2A,0x56,0x47,0x41,  /* 00000400    "I0[.*VGA" */
    0x5F,0x08,0x5F,0x41,0x44,0x52,0x0C,0x00,  /* 00000408    "_._ADR.." */
    0x00,0x01,0x00,0x14,0x08,0x5F,0x53,0x31,  /* 00000410    "....._S1" */
    0x44,0x00,0xA4,0x00,0x14,0x08,0x5F,0x53,  /* 00000418    "D....._S" */
    0x32,0x44,0x00,0xA4,0x00,0x14,0x08,0x5F,  /* 00000420    "2D....._" */
    0x53,0x33,0x44,0x00,0xA4,0x00,0x10,0x4C,  /* 00000428    "S3D....L" */
    0x07,0x2E,0x5F,0x53,0x42,0x5F,0x50,0x43,  /* 00000430    ".._SB_PC" */
    0x49,0x30,0x5B,0x82,0x4F,0x06,0x49,0x53,  /* 00000438    "I0[.O.IS" */
    0x41,0x5F,0x08,0x5F,0x41,0x44,0x52,0x0C,  /* 00000440    "A_._ADR." */
    0x00,0x00,0x1F,0x00,0x5B,0x80,0x50,0x49,  /* 00000448    "....[.PI" */
    0x52,0x51,0x02,0x0A,0x60,0x0A,0x0C,0x5B,  /* 00000450    "RQ..`..[" */
    0x80,0x4C,0x50,0x43,0x44,0x02,0x0A,0x80,  /* 00000458    ".LPCD..." */
    0x0A,0x02,0x5B,0x81,0x20,0x4C,0x50,0x43,  /* 00000460    "..[. LPC" */
    0x44,0x00,0x43,0x4F,0x4D,0x41,0x03,0x00,  /* 00000468    "D.COMA.." */
    0x01,0x43,0x4F,0x4D,0x42,0x03,0x00,0x01,  /* 00000470    ".COMB..." */
    0x4C,0x50,0x54,0x44,0x02,0x00,0x02,0x46,  /* 00000478    "LPTD...F" */
    0x44,0x43,0x44,0x02,0x5B,0x80,0x4C,0x50,  /* 00000480    "DCD.[.LP" */
    0x43,0x45,0x02,0x0A,0x82,0x0A,0x02,0x5B,  /* 00000488    "CE.....[" */
    0x81,0x1A,0x4C,0x50,0x43,0x45,0x00,0x43,  /* 00000490    "..LPCE.C" */
    0x41,0x45,0x4E,0x01,0x43,0x42,0x45,0x4E,  /* 00000498    "AEN.CBEN" */
    0x01,0x4C,0x50,0x45,0x4E,0x01,0x46,0x44,  /* 000004A0    ".LPEN.FD" */
    0x45,0x4E,0x01,0x10,0x4C,0x1B,0x2F,0x03,  /* 000004A8    "EN..L./." */
    0x5F,0x53,0x42,0x5F,0x50,0x43,0x49,0x30,  /* 000004B0    "_SB_PCI0" */
    0x49,0x53,0x41,0x5F,0x5B,0x82,0x2D,0x52,  /* 000004B8    "ISA_[.-R" */
    0x54,0x43,0x5F,0x08,0x5F,0x48,0x49,0x44,  /* 000004C0    "TC_._HID" */
    0x0C,0x41,0xD0,0x0B,0x00,0x08,0x5F,0x43,  /* 000004C8    ".A...._C" */
    0x52,0x53,0x11,0x18,0x0A,0x15,0x47,0x01,  /* 000004D0    "RS....G." */
    0x70,0x00,0x70,0x00,0x10,0x02,0x22,0x00,  /* 000004D8    "p.p..."." */
    0x01,0x47,0x01,0x72,0x00,0x72,0x00,0x02,  /* 000004E0    ".G.r.r.." */
    0x06,0x79,0x00,0x5B,0x82,0x37,0x4B,0x42,  /* 000004E8    ".y.[.7KB" */
    0x44,0x5F,0x08,0x5F,0x48,0x49,0x44,0x0C,  /* 000004F0    "D_._HID." */
    0x41,0xD0,0x03,0x03,0x14,0x09,0x5F,0x53,  /* 000004F8    "A....._S" */
    0x54,0x41,0x00,0xA4,0x0A,0x0F,0x08,0x5F,  /* 00000500    "TA....._" */
    0x43,0x52,0x53,0x11,0x18,0x0A,0x15,0x47,  /* 00000508    "CRS....G" */
    0x01,0x60,0x00,0x60,0x00,0x01,0x01,0x47,  /* 00000510    ".`.`...G" */
    0x01,0x64,0x00,0x64,0x00,0x01,0x01,0x22,  /* 00000518    ".d.d..."" */
    0x02,0x00,0x79,0x00,0x5B,0x82,0x27,0x4D,  /* 00000520    "..y.[.'M" */
    0x4F,0x55,0x5F,0x08,0x5F,0x48,0x49,0x44,  /* 00000528    "OU_._HID" */
    0x0C,0x41,0xD0,0x0F,0x13,0x14,0x09,0x5F,  /* 00000530    ".A....._" */
    0x53,0x54,0x41,0x00,0xA4,0x0A,0x0F,0x08,  /* 00000538    "STA....." */
    0x5F,0x43,0x52,0x53,0x11,0x08,0x0A,0x05,  /* 00000540    "_CRS...." */
    0x22,0x00,0x10,0x79,0x00,0x5B,0x82,0x4A,  /* 00000548    ""..y.[.J" */
    0x04,0x46,0x44,0x43,0x30,0x08,0x5F,0x48,  /* 00000550    ".FDC0._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x07,0x00,0x14,  /* 00000558    "ID.A...." */
    0x18,0x5F,0x53,0x54,0x41,0x00,0x70,0x46,  /* 00000560    "._STA.pF" */
    0x44,0x45,0x4E,0x60,0xA0,0x06,0x93,0x60,  /* 00000568    "DEN`...`" */
    0x00,0xA4,0x00,0xA1,0x04,0xA4,0x0A,0x0F,  /* 00000570    "........" */
    0x08,0x5F,0x43,0x52,0x53,0x11,0x1B,0x0A,  /* 00000578    "._CRS..." */
    0x18,0x47,0x01,0xF2,0x03,0xF2,0x03,0x00,  /* 00000580    ".G......" */
    0x04,0x47,0x01,0xF7,0x03,0xF7,0x03,0x00,  /* 00000588    ".G......" */
    0x01,0x22,0x40,0x00,0x2A,0x04,0x00,0x79,  /* 00000590    "."@.*..y" */
    0x00,0x5B,0x82,0x3E,0x4C,0x50,0x54,0x5F,  /* 00000598    ".[.>LPT_" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 000005A0    "._HID.A." */
    0x04,0x00,0x14,0x18,0x5F,0x53,0x54,0x41,  /* 000005A8    "...._STA" */
    0x00,0x70,0x4C,0x50,0x45,0x4E,0x60,0xA0,  /* 000005B0    ".pLPEN`." */
    0x06,0x93,0x60,0x00,0xA4,0x00,0xA1,0x04,  /* 000005B8    "..`....." */
    0xA4,0x0A,0x0F,0x08,0x5F,0x43,0x52,0x53,  /* 000005C0    "...._CRS" */
    0x11,0x10,0x0A,0x0D,0x47,0x01,0x78,0x03,  /* 000005C8    "....G.x." */
    0x78,0x03,0x08,0x08,0x22,0x80,0x00,0x79,  /* 000005D0    "x..."..y" */
    0x00,0x5B,0x82,0x45,0x04,0x43,0x4F,0x4D,  /* 000005D8    ".[.E.COM" */
    0x31,0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,  /* 000005E0    "1._HID.A" */
    0xD0,0x05,0x01,0x08,0x5F,0x55,0x49,0x44,  /* 000005E8    "...._UID" */
    0x01,0x14,0x18,0x5F,0x53,0x54,0x41,0x00,  /* 000005F0    "..._STA." */
    0x70,0x43,0x41,0x45,0x4E,0x60,0xA0,0x06,  /* 000005F8    "pCAEN`.." */
    0x93,0x60,0x00,0xA4,0x00,0xA1,0x04,0xA4,  /* 00000600    ".`......" */
    0x0A,0x0F,0x08,0x5F,0x43,0x52,0x53,0x11,  /* 00000608    "..._CRS." */
    0x10,0x0A,0x0D,0x47,0x01,0xF8,0x03,0xF8,  /* 00000610    "...G...." */
    0x03,0x00,0x08,0x22,0x10,0x00,0x79,0x00,  /* 00000618    "..."..y." */
    0x5B,0x82,0x46,0x04,0x43,0x4F,0x4D,0x32,  /* 00000620    "[.F.COM2" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 00000628    "._HID.A." */
    0x05,0x01,0x08,0x5F,0x55,0x49,0x44,0x0A,  /* 00000630    "..._UID." */
    0x02,0x14,0x18,0x5F,0x53,0x54,0x41,0x00,  /* 00000638    "..._STA." */
    0x70,0x43,0x42,0x45,0x4E,0x60,0xA0,0x06,  /* 00000640    "pCBEN`.." */
    0x93,0x60,0x00,0xA4,0x00,0xA1,0x04,0xA4,  /* 00000648    ".`......" */
    0x0A,0x0F,0x08,0x5F,0x43,0x52,0x53,0x11,  /* 00000650    "..._CRS." */
    0x10,0x0A,0x0D,0x47,0x01,0xF8,0x02,0xF8,  /* 00000658    "...G...." */
    0x02,0x00,0x08,0x22,0x08,0x00,0x79,0x00,  /* 00000660    "..."..y." */
    0x08,0x50,0x49,0x43,0x46,0x00,0x14,0x0C,  /* 00000668    ".PICF..." */
    0x5F,0x50,0x49,0x43,0x01,0x70,0x68,0x50,  /* 00000670    "_PIC.phP" */
    0x49,0x43,0x46,0x10,0x8E,0x55,0x01,0x5F,  /* 00000678    "ICF..U._" */
    0x53,0x42,0x5F,0x10,0x43,0xEA,0x50,0x43,  /* 00000680    "SB_.C.PC" */
    0x49,0x30,0x08,0x50,0x52,0x54,0x50,0x12,  /* 00000688    "I0.PRTP." */
    0x4B,0x73,0x80,0x12,0x0B,0x04,0x0B,0xFF,  /* 00000690    "Ks......" */
    0xFF,0x00,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 00000698    "..LNKE.." */
    0x0B,0x04,0x0B,0xFF,0xFF,0x01,0x4C,0x4E,  /* 000006A0    "......LN" */
    0x4B,0x46,0x00,0x12,0x0C,0x04,0x0B,0xFF,  /* 000006A8    "KF......" */
    0xFF,0x0A,0x02,0x4C,0x4E,0x4B,0x47,0x00,  /* 000006B0    "...LNKG." */
    0x12,0x0C,0x04,0x0B,0xFF,0xFF,0x0A,0x03,  /* 000006B8    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 000006C0    "LNKH...." */
    0x0C,0xFF,0xFF,0x01,0x00,0x00,0x4C,0x4E,  /* 000006C8    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 000006D0    "KF......" */
    0xFF,0x01,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 000006D8    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x01,  /* 000006E0    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 000006E8    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x01,0x00,  /* 000006F0    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 000006F8    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x02,0x00,0x00,  /* 00000700    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 00000708    "LNKG...." */
    0x0C,0xFF,0xFF,0x02,0x00,0x01,0x4C,0x4E,  /* 00000710    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000718    "KH......" */
    0xFF,0x02,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000720    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000728    "E......." */
    0x02,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 00000730    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x03,  /* 00000738    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 00000740    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x03,0x00,0x01,  /* 00000748    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000750    "LNKE...." */
    0x0C,0xFF,0xFF,0x03,0x00,0x0A,0x02,0x4C,  /* 00000758    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000760    "NKF....." */
    0xFF,0xFF,0x03,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000768    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000770    "KG......" */
    0xFF,0x04,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000778    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x04,  /* 00000780    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000788    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x04,0x00,0x0A,  /* 00000790    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000798    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x04,0x00,0x0A,0x03,  /* 000007A0    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 000007A8    "LNKH...." */
    0x0C,0xFF,0xFF,0x05,0x00,0x00,0x4C,0x4E,  /* 000007B0    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 000007B8    "KF......" */
    0xFF,0x05,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 000007C0    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x05,  /* 000007C8    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 000007D0    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x05,0x00,  /* 000007D8    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 000007E0    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x06,0x00,0x00,  /* 000007E8    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 000007F0    "LNKG...." */
    0x0C,0xFF,0xFF,0x06,0x00,0x01,0x4C,0x4E,  /* 000007F8    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000800    "KH......" */
    0xFF,0x06,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000808    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000810    "E......." */
    0x06,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 00000818    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x07,  /* 00000820    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 00000828    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x07,0x00,0x01,  /* 00000830    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000838    "LNKE...." */
    0x0C,0xFF,0xFF,0x07,0x00,0x0A,0x02,0x4C,  /* 00000840    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000848    "NKF....." */
    0xFF,0xFF,0x07,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000850    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000858    "KG......" */
    0xFF,0x08,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000860    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x08,  /* 00000868    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000870    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x08,0x00,0x0A,  /* 00000878    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000880    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x08,0x00,0x0A,0x03,  /* 00000888    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 00000890    "LNKH...." */
    0x0C,0xFF,0xFF,0x09,0x00,0x00,0x4C,0x4E,  /* 00000898    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 000008A0    "KF......" */
    0xFF,0x09,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 000008A8    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x09,  /* 000008B0    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 000008B8    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x09,0x00,  /* 000008C0    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 000008C8    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x0A,0x00,0x00,  /* 000008D0    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 000008D8    "LNKG...." */
    0x0C,0xFF,0xFF,0x0A,0x00,0x01,0x4C,0x4E,  /* 000008E0    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000008E8    "KH......" */
    0xFF,0x0A,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 000008F0    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 000008F8    "E......." */
    0x0A,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 00000900    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0B,  /* 00000908    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 00000910    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x0B,0x00,0x01,  /* 00000918    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000920    "LNKE...." */
    0x0C,0xFF,0xFF,0x0B,0x00,0x0A,0x02,0x4C,  /* 00000928    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000930    "NKF....." */
    0xFF,0xFF,0x0B,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000938    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000940    "KG......" */
    0xFF,0x0C,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000948    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0C,  /* 00000950    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000958    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x0C,0x00,0x0A,  /* 00000960    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000968    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x0C,0x00,0x0A,0x03,  /* 00000970    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 00000978    "LNKH...." */
    0x0C,0xFF,0xFF,0x0D,0x00,0x00,0x4C,0x4E,  /* 00000980    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000988    "KF......" */
    0xFF,0x0D,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 00000990    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0D,  /* 00000998    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 000009A0    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0D,0x00,  /* 000009A8    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 000009B0    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x0E,0x00,0x00,  /* 000009B8    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 000009C0    "LNKG...." */
    0x0C,0xFF,0xFF,0x0E,0x00,0x01,0x4C,0x4E,  /* 000009C8    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000009D0    "KH......" */
    0xFF,0x0E,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 000009D8    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 000009E0    "E......." */
    0x0E,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 000009E8    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0F,  /* 000009F0    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 000009F8    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x0F,0x00,0x01,  /* 00000A00    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000A08    "LNKE...." */
    0x0C,0xFF,0xFF,0x0F,0x00,0x0A,0x02,0x4C,  /* 00000A10    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000A18    "NKF....." */
    0xFF,0xFF,0x0F,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000A20    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000A28    "KG......" */
    0xFF,0x10,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000A30    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x10,  /* 00000A38    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000A40    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x10,0x00,0x0A,  /* 00000A48    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000A50    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x10,0x00,0x0A,0x03,  /* 00000A58    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 00000A60    "LNKH...." */
    0x0C,0xFF,0xFF,0x11,0x00,0x00,0x4C,0x4E,  /* 00000A68    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000A70    "KF......" */
    0xFF,0x11,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 00000A78    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x11,  /* 00000A80    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 00000A88    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x11,0x00,  /* 00000A90    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 00000A98    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x12,0x00,0x00,  /* 00000AA0    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 00000AA8    "LNKG...." */
    0x0C,0xFF,0xFF,0x12,0x00,0x01,0x4C,0x4E,  /* 00000AB0    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000AB8    "KH......" */
    0xFF,0x12,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000AC0    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000AC8    "E......." */
    0x12,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 00000AD0    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x13,  /* 00000AD8    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 00000AE0    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x13,0x00,0x01,  /* 00000AE8    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000AF0    "LNKE...." */
    0x0C,0xFF,0xFF,0x13,0x00,0x0A,0x02,0x4C,  /* 00000AF8    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000B00    "NKF....." */
    0xFF,0xFF,0x13,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000B08    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000B10    "KG......" */
    0xFF,0x14,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000B18    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x14,  /* 00000B20    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000B28    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x14,0x00,0x0A,  /* 00000B30    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000B38    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x14,0x00,0x0A,0x03,  /* 00000B40    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 00000B48    "LNKH...." */
    0x0C,0xFF,0xFF,0x15,0x00,0x00,0x4C,0x4E,  /* 00000B50    "......LN" */
    0x4B,0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000B58    "KF......" */
    0xFF,0x15,0x00,0x01,0x4C,0x4E,0x4B,0x47,  /* 00000B60    "....LNKG" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x15,  /* 00000B68    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x48,0x00,  /* 00000B70    "...LNKH." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x15,0x00,  /* 00000B78    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x45,0x00,0x12,  /* 00000B80    "..LNKE.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x16,0x00,0x00,  /* 00000B88    "........" */
    0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0D,0x04,  /* 00000B90    "LNKG...." */
    0x0C,0xFF,0xFF,0x16,0x00,0x01,0x4C,0x4E,  /* 00000B98    "......LN" */
    0x4B,0x48,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000BA0    "KH......" */
    0xFF,0x16,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000BA8    ".....LNK" */
    0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000BB0    "E......." */
    0x16,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x46,  /* 00000BB8    "....LNKF" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x17,  /* 00000BC0    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x48,0x00,0x12,  /* 00000BC8    "..LNKH.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x17,0x00,0x01,  /* 00000BD0    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0E,0x04,  /* 00000BD8    "LNKE...." */
    0x0C,0xFF,0xFF,0x17,0x00,0x0A,0x02,0x4C,  /* 00000BE0    ".......L" */
    0x4E,0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 00000BE8    "NKF....." */
    0xFF,0xFF,0x17,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000BF0    "......LN" */
    0x4B,0x47,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000BF8    "KG......" */
    0xFF,0x18,0x00,0x00,0x4C,0x4E,0x4B,0x45,  /* 00000C00    "....LNKE" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x18,  /* 00000C08    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x46,0x00,0x12,  /* 00000C10    "..LNKF.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x18,0x00,0x0A,  /* 00000C18    "........" */
    0x02,0x4C,0x4E,0x4B,0x47,0x00,0x12,0x0E,  /* 00000C20    ".LNKG..." */
    0x04,0x0C,0xFF,0xFF,0x18,0x00,0x0A,0x03,  /* 00000C28    "........" */
    0x4C,0x4E,0x4B,0x48,0x00,0x12,0x0D,0x04,  /* 00000C30    "LNKH...." */
    0x0C,0xFF,0xFF,0x19,0x00,0x00,0x4C,0x4E,  /* 00000C38    "......LN" */
    0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000C40    "KA......" */
    0xFF,0x19,0x00,0x01,0x4C,0x4E,0x4B,0x42,  /* 00000C48    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x19,  /* 00000C50    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000C58    "...LNKC." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x19,0x00,  /* 00000C60    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x44,0x00,0x12,  /* 00000C68    "..LNKD.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x1A,0x00,0x00,  /* 00000C70    "........" */
    0x4C,0x4E,0x4B,0x41,0x00,0x12,0x0D,0x04,  /* 00000C78    "LNKA...." */
    0x0C,0xFF,0xFF,0x1A,0x00,0x01,0x4C,0x4E,  /* 00000C80    "......LN" */
    0x4B,0x42,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000C88    "KB......" */
    0xFF,0x1A,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000C90    ".....LNK" */
    0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000C98    "C......." */
    0x1A,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x44,  /* 00000CA0    "....LNKD" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1B,  /* 00000CA8    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000CB0    "..LNKA.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x1B,0x00,0x01,  /* 00000CB8    "........" */
    0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,  /* 00000CC0    "LNKB...." */
    0x0C,0xFF,0xFF,0x1B,0x00,0x0A,0x02,0x4C,  /* 00000CC8    ".......L" */
    0x4E,0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,  /* 00000CD0    "NKC....." */
    0xFF,0xFF,0x1B,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000CD8    "......LN" */
    0x4B,0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000CE0    "KD......" */
    0xFF,0x1C,0x00,0x00,0x4C,0x4E,0x4B,0x41,  /* 00000CE8    "....LNKA" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1C,  /* 00000CF0    "........" */
    0x00,0x01,0x4C,0x4E,0x4B,0x42,0x00,0x12,  /* 00000CF8    "..LNKB.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x1C,0x00,0x0A,  /* 00000D00    "........" */
    0x02,0x4C,0x4E,0x4B,0x43,0x00,0x12,0x0E,  /* 00000D08    ".LNKC..." */
    0x04,0x0C,0xFF,0xFF,0x1C,0x00,0x0A,0x03,  /* 00000D10    "........" */
    0x4C,0x4E,0x4B,0x44,0x00,0x12,0x0D,0x04,  /* 00000D18    "LNKD...." */
    0x0C,0xFF,0xFF,0x1D,0x00,0x00,0x4C,0x4E,  /* 00000D20    "......LN" */
    0x4B,0x41,0x00,0x12,0x0D,0x04,0x0C,0xFF,  /* 00000D28    "KA......" */
    0xFF,0x1D,0x00,0x01,0x4C,0x4E,0x4B,0x42,  /* 00000D30    "....LNKB" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1D,  /* 00000D38    "........" */
    0x00,0x0A,0x02,0x4C,0x4E,0x4B,0x43,0x00,  /* 00000D40    "...LNKC." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1D,0x00,  /* 00000D48    "........" */
    0x0A,0x03,0x4C,0x4E,0x4B,0x44,0x00,0x12,  /* 00000D50    "..LNKD.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x1E,0x00,0x00,  /* 00000D58    "........" */
    0x4C,0x4E,0x4B,0x45,0x00,0x12,0x0D,0x04,  /* 00000D60    "LNKE...." */
    0x0C,0xFF,0xFF,0x1E,0x00,0x01,0x4C,0x4E,  /* 00000D68    "......LN" */
    0x4B,0x46,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000D70    "KF......" */
    0xFF,0x1E,0x00,0x0A,0x02,0x4C,0x4E,0x4B,  /* 00000D78    ".....LNK" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000D80    "G......." */
    0x1E,0x00,0x0A,0x03,0x4C,0x4E,0x4B,0x48,  /* 00000D88    "....LNKH" */
    0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1F,  /* 00000D90    "........" */
    0x00,0x00,0x4C,0x4E,0x4B,0x41,0x00,0x12,  /* 00000D98    "..LNKA.." */
    0x0D,0x04,0x0C,0xFF,0xFF,0x1F,0x00,0x01,  /* 00000DA0    "........" */
    0x4C,0x4E,0x4B,0x42,0x00,0x12,0x0E,0x04,  /* 00000DA8    "LNKB...." */
    0x0C,0xFF,0xFF,0x1F,0x00,0x0A,0x02,0x4C,  /* 00000DB0    ".......L" */
    0x4E,0x4B,0x43,0x00,0x12,0x0E,0x04,0x0C,  /* 00000DB8    "NKC....." */
    0xFF,0xFF,0x1F,0x00,0x0A,0x03,0x4C,0x4E,  /* 00000DC0    "......LN" */
    0x4B,0x44,0x00,0x08,0x50,0x52,0x54,0x41,  /* 00000DC8    "KD..PRTA" */
    0x12,0x4B,0x73,0x80,0x12,0x0B,0x04,0x0B,  /* 00000DD0    ".Ks....." */
    0xFF,0xFF,0x00,0x47,0x53,0x49,0x45,0x00,  /* 00000DD8    "...GSIE." */
    0x12,0x0B,0x04,0x0B,0xFF,0xFF,0x01,0x47,  /* 00000DE0    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0C,0x04,0x0B,  /* 00000DE8    "SIF....." */
    0xFF,0xFF,0x0A,0x02,0x47,0x53,0x49,0x47,  /* 00000DF0    "....GSIG" */
    0x00,0x12,0x0C,0x04,0x0B,0xFF,0xFF,0x0A,  /* 00000DF8    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 00000E00    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x01,0x00,0x00,0x47,  /* 00000E08    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 00000E10    "SIF....." */
    0xFF,0xFF,0x01,0x00,0x01,0x47,0x53,0x49,  /* 00000E18    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000E20    "G......." */
    0x01,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 00000E28    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x01,  /* 00000E30    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 00000E38    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x02,0x00,  /* 00000E40    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 00000E48    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x02,0x00,0x01,0x47,  /* 00000E50    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 00000E58    "SIH....." */
    0xFF,0xFF,0x02,0x00,0x0A,0x02,0x47,0x53,  /* 00000E60    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000E68    "IE......" */
    0xFF,0x02,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 00000E70    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000E78    "F......." */
    0x03,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00000E80    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x03,0x00,  /* 00000E88    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00000E90    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x03,0x00,0x0A,0x02,  /* 00000E98    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00000EA0    "GSIF...." */
    0x0C,0xFF,0xFF,0x03,0x00,0x0A,0x03,0x47,  /* 00000EA8    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00000EB0    "SIG....." */
    0xFF,0xFF,0x04,0x00,0x00,0x47,0x53,0x49,  /* 00000EB8    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000EC0    "E......." */
    0x04,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00000EC8    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x04,0x00,  /* 00000ED0    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 00000ED8    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x04,0x00,0x0A,  /* 00000EE0    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 00000EE8    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x05,0x00,0x00,0x47,  /* 00000EF0    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 00000EF8    "SIF....." */
    0xFF,0xFF,0x05,0x00,0x01,0x47,0x53,0x49,  /* 00000F00    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000F08    "G......." */
    0x05,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 00000F10    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x05,  /* 00000F18    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 00000F20    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x06,0x00,  /* 00000F28    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 00000F30    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x06,0x00,0x01,0x47,  /* 00000F38    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 00000F40    "SIH....." */
    0xFF,0xFF,0x06,0x00,0x0A,0x02,0x47,0x53,  /* 00000F48    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00000F50    "IE......" */
    0xFF,0x06,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 00000F58    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000F60    "F......." */
    0x07,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00000F68    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x07,0x00,  /* 00000F70    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00000F78    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x07,0x00,0x0A,0x02,  /* 00000F80    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00000F88    "GSIF...." */
    0x0C,0xFF,0xFF,0x07,0x00,0x0A,0x03,0x47,  /* 00000F90    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00000F98    "SIG....." */
    0xFF,0xFF,0x08,0x00,0x00,0x47,0x53,0x49,  /* 00000FA0    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00000FA8    "E......." */
    0x08,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00000FB0    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x08,0x00,  /* 00000FB8    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 00000FC0    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x08,0x00,0x0A,  /* 00000FC8    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 00000FD0    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x09,0x00,0x00,0x47,  /* 00000FD8    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 00000FE0    "SIF....." */
    0xFF,0xFF,0x09,0x00,0x01,0x47,0x53,0x49,  /* 00000FE8    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00000FF0    "G......." */
    0x09,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 00000FF8    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x09,  /* 00001000    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 00001008    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0A,0x00,  /* 00001010    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 00001018    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x0A,0x00,0x01,0x47,  /* 00001020    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 00001028    "SIH....." */
    0xFF,0xFF,0x0A,0x00,0x0A,0x02,0x47,0x53,  /* 00001030    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00001038    "IE......" */
    0xFF,0x0A,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 00001040    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001048    "F......." */
    0x0B,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00001050    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0B,0x00,  /* 00001058    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00001060    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x0B,0x00,0x0A,0x02,  /* 00001068    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00001070    "GSIF...." */
    0x0C,0xFF,0xFF,0x0B,0x00,0x0A,0x03,0x47,  /* 00001078    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00001080    "SIG....." */
    0xFF,0xFF,0x0C,0x00,0x00,0x47,0x53,0x49,  /* 00001088    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001090    "E......." */
    0x0C,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00001098    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0C,0x00,  /* 000010A0    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 000010A8    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x0C,0x00,0x0A,  /* 000010B0    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 000010B8    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x0D,0x00,0x00,0x47,  /* 000010C0    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 000010C8    "SIF....." */
    0xFF,0xFF,0x0D,0x00,0x01,0x47,0x53,0x49,  /* 000010D0    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 000010D8    "G......." */
    0x0D,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 000010E0    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x0D,  /* 000010E8    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 000010F0    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0E,0x00,  /* 000010F8    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 00001100    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x0E,0x00,0x01,0x47,  /* 00001108    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 00001110    "SIH....." */
    0xFF,0xFF,0x0E,0x00,0x0A,0x02,0x47,0x53,  /* 00001118    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00001120    "IE......" */
    0xFF,0x0E,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 00001128    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001130    "F......." */
    0x0F,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00001138    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x0F,0x00,  /* 00001140    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00001148    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x0F,0x00,0x0A,0x02,  /* 00001150    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00001158    "GSIF...." */
    0x0C,0xFF,0xFF,0x0F,0x00,0x0A,0x03,0x47,  /* 00001160    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00001168    "SIG....." */
    0xFF,0xFF,0x10,0x00,0x00,0x47,0x53,0x49,  /* 00001170    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001178    "E......." */
    0x10,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00001180    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x10,0x00,  /* 00001188    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 00001190    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x10,0x00,0x0A,  /* 00001198    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 000011A0    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x11,0x00,0x00,0x47,  /* 000011A8    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 000011B0    "SIF....." */
    0xFF,0xFF,0x11,0x00,0x01,0x47,0x53,0x49,  /* 000011B8    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 000011C0    "G......." */
    0x11,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 000011C8    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x11,  /* 000011D0    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 000011D8    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x12,0x00,  /* 000011E0    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 000011E8    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x12,0x00,0x01,0x47,  /* 000011F0    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 000011F8    "SIH....." */
    0xFF,0xFF,0x12,0x00,0x0A,0x02,0x47,0x53,  /* 00001200    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 00001208    "IE......" */
    0xFF,0x12,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 00001210    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001218    "F......." */
    0x13,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00001220    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x13,0x00,  /* 00001228    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00001230    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x13,0x00,0x0A,0x02,  /* 00001238    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00001240    "GSIF...." */
    0x0C,0xFF,0xFF,0x13,0x00,0x0A,0x03,0x47,  /* 00001248    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00001250    "SIG....." */
    0xFF,0xFF,0x14,0x00,0x00,0x47,0x53,0x49,  /* 00001258    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001260    "E......." */
    0x14,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00001268    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x14,0x00,  /* 00001270    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 00001278    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x14,0x00,0x0A,  /* 00001280    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 00001288    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x15,0x00,0x00,0x47,  /* 00001290    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0D,0x04,0x0C,  /* 00001298    "SIF....." */
    0xFF,0xFF,0x15,0x00,0x01,0x47,0x53,0x49,  /* 000012A0    ".....GSI" */
    0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 000012A8    "G......." */
    0x15,0x00,0x0A,0x02,0x47,0x53,0x49,0x48,  /* 000012B0    "....GSIH" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x15,  /* 000012B8    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x45,0x00,  /* 000012C0    "...GSIE." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x16,0x00,  /* 000012C8    "........" */
    0x00,0x47,0x53,0x49,0x47,0x00,0x12,0x0D,  /* 000012D0    ".GSIG..." */
    0x04,0x0C,0xFF,0xFF,0x16,0x00,0x01,0x47,  /* 000012D8    ".......G" */
    0x53,0x49,0x48,0x00,0x12,0x0E,0x04,0x0C,  /* 000012E0    "SIH....." */
    0xFF,0xFF,0x16,0x00,0x0A,0x02,0x47,0x53,  /* 000012E8    "......GS" */
    0x49,0x45,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000012F0    "IE......" */
    0xFF,0x16,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 000012F8    ".....GSI" */
    0x46,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001300    "F......." */
    0x17,0x00,0x00,0x47,0x53,0x49,0x48,0x00,  /* 00001308    "...GSIH." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x17,0x00,  /* 00001310    "........" */
    0x01,0x47,0x53,0x49,0x45,0x00,0x12,0x0E,  /* 00001318    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x17,0x00,0x0A,0x02,  /* 00001320    "........" */
    0x47,0x53,0x49,0x46,0x00,0x12,0x0E,0x04,  /* 00001328    "GSIF...." */
    0x0C,0xFF,0xFF,0x17,0x00,0x0A,0x03,0x47,  /* 00001330    ".......G" */
    0x53,0x49,0x47,0x00,0x12,0x0D,0x04,0x0C,  /* 00001338    "SIG....." */
    0xFF,0xFF,0x18,0x00,0x00,0x47,0x53,0x49,  /* 00001340    ".....GSI" */
    0x45,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001348    "E......." */
    0x18,0x00,0x01,0x47,0x53,0x49,0x46,0x00,  /* 00001350    "...GSIF." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x18,0x00,  /* 00001358    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x47,0x00,0x12,  /* 00001360    "..GSIG.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x18,0x00,0x0A,  /* 00001368    "........" */
    0x03,0x47,0x53,0x49,0x48,0x00,0x12,0x0D,  /* 00001370    ".GSIH..." */
    0x04,0x0C,0xFF,0xFF,0x19,0x00,0x00,0x47,  /* 00001378    ".......G" */
    0x53,0x49,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00001380    "SIA....." */
    0xFF,0xFF,0x19,0x00,0x01,0x47,0x53,0x49,  /* 00001388    ".....GSI" */
    0x42,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00001390    "B......." */
    0x19,0x00,0x0A,0x02,0x47,0x53,0x49,0x43,  /* 00001398    "....GSIC" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x19,  /* 000013A0    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x44,0x00,  /* 000013A8    "...GSID." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1A,0x00,  /* 000013B0    "........" */
    0x00,0x47,0x53,0x49,0x41,0x00,0x12,0x0D,  /* 000013B8    ".GSIA..." */
    0x04,0x0C,0xFF,0xFF,0x1A,0x00,0x01,0x47,  /* 000013C0    ".......G" */
    0x53,0x49,0x42,0x00,0x12,0x0E,0x04,0x0C,  /* 000013C8    "SIB....." */
    0xFF,0xFF,0x1A,0x00,0x0A,0x02,0x47,0x53,  /* 000013D0    "......GS" */
    0x49,0x43,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000013D8    "IC......" */
    0xFF,0x1A,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 000013E0    ".....GSI" */
    0x44,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000013E8    "D......." */
    0x1B,0x00,0x00,0x47,0x53,0x49,0x41,0x00,  /* 000013F0    "...GSIA." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1B,0x00,  /* 000013F8    "........" */
    0x01,0x47,0x53,0x49,0x42,0x00,0x12,0x0E,  /* 00001400    ".GSIB..." */
    0x04,0x0C,0xFF,0xFF,0x1B,0x00,0x0A,0x02,  /* 00001408    "........" */
    0x47,0x53,0x49,0x43,0x00,0x12,0x0E,0x04,  /* 00001410    "GSIC...." */
    0x0C,0xFF,0xFF,0x1B,0x00,0x0A,0x03,0x47,  /* 00001418    ".......G" */
    0x53,0x49,0x44,0x00,0x12,0x0D,0x04,0x0C,  /* 00001420    "SID....." */
    0xFF,0xFF,0x1C,0x00,0x00,0x47,0x53,0x49,  /* 00001428    ".....GSI" */
    0x41,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 00001430    "A......." */
    0x1C,0x00,0x01,0x47,0x53,0x49,0x42,0x00,  /* 00001438    "...GSIB." */
    0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1C,0x00,  /* 00001440    "........" */
    0x0A,0x02,0x47,0x53,0x49,0x43,0x00,0x12,  /* 00001448    "..GSIC.." */
    0x0E,0x04,0x0C,0xFF,0xFF,0x1C,0x00,0x0A,  /* 00001450    "........" */
    0x03,0x47,0x53,0x49,0x44,0x00,0x12,0x0D,  /* 00001458    ".GSID..." */
    0x04,0x0C,0xFF,0xFF,0x1D,0x00,0x00,0x47,  /* 00001460    ".......G" */
    0x53,0x49,0x41,0x00,0x12,0x0D,0x04,0x0C,  /* 00001468    "SIA....." */
    0xFF,0xFF,0x1D,0x00,0x01,0x47,0x53,0x49,  /* 00001470    ".....GSI" */
    0x42,0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,  /* 00001478    "B......." */
    0x1D,0x00,0x0A,0x02,0x47,0x53,0x49,0x43,  /* 00001480    "....GSIC" */
    0x00,0x12,0x0E,0x04,0x0C,0xFF,0xFF,0x1D,  /* 00001488    "........" */
    0x00,0x0A,0x03,0x47,0x53,0x49,0x44,0x00,  /* 00001490    "...GSID." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1E,0x00,  /* 00001498    "........" */
    0x00,0x47,0x53,0x49,0x45,0x00,0x12,0x0D,  /* 000014A0    ".GSIE..." */
    0x04,0x0C,0xFF,0xFF,0x1E,0x00,0x01,0x47,  /* 000014A8    ".......G" */
    0x53,0x49,0x46,0x00,0x12,0x0E,0x04,0x0C,  /* 000014B0    "SIF....." */
    0xFF,0xFF,0x1E,0x00,0x0A,0x02,0x47,0x53,  /* 000014B8    "......GS" */
    0x49,0x47,0x00,0x12,0x0E,0x04,0x0C,0xFF,  /* 000014C0    "IG......" */
    0xFF,0x1E,0x00,0x0A,0x03,0x47,0x53,0x49,  /* 000014C8    ".....GSI" */
    0x48,0x00,0x12,0x0D,0x04,0x0C,0xFF,0xFF,  /* 000014D0    "H......." */
    0x1F,0x00,0x00,0x47,0x53,0x49,0x41,0x00,  /* 000014D8    "...GSIA." */
    0x12,0x0D,0x04,0x0C,0xFF,0xFF,0x1F,0x00,  /* 000014E0    "........" */
    0x01,0x47,0x53,0x49,0x42,0x00,0x12,0x0E,  /* 000014E8    ".GSIB..." */
    0x04,0x0C,0xFF,0xFF,0x1F,0x00,0x0A,0x02,  /* 000014F0    "........" */
    0x47,0x53,0x49,0x43,0x00,0x12,0x0E,0x04,  /* 000014F8    "GSIC...." */
    0x0C,0xFF,0xFF,0x1F,0x00,0x0A,0x03,0x47,  /* 00001500    ".......G" */
    0x53,0x49,0x44,0x00,0x14,0x1A,0x5F,0x50,  /* 00001508    "SID..._P" */
    0x52,0x54,0x00,0xA0,0x0C,0x93,0x50,0x49,  /* 00001510    "RT....PI" */
    0x43,0x46,0x00,0xA4,0x50,0x52,0x54,0x50,  /* 00001518    "CF..PRTP" */
    0xA1,0x06,0xA4,0x50,0x52,0x54,0x41,0x5B,  /* 00001520    "...PRTA[" */
    0x81,0x3A,0x2F,0x03,0x50,0x43,0x49,0x30,  /* 00001528    ".:/.PCI0" */
    0x49,0x53,0x41,0x5F,0x50,0x49,0x52,0x51,  /* 00001530    "ISA_PIRQ" */
    0x01,0x50,0x52,0x51,0x41,0x08,0x50,0x52,  /* 00001538    ".PRQA.PR" */
    0x51,0x42,0x08,0x50,0x52,0x51,0x43,0x08,  /* 00001540    "QB.PRQC." */
    0x50,0x52,0x51,0x44,0x08,0x00,0x20,0x50,  /* 00001548    "PRQD.. P" */
    0x52,0x51,0x45,0x08,0x50,0x52,0x51,0x46,  /* 00001550    "RQE.PRQF" */
    0x08,0x50,0x52,0x51,0x47,0x08,0x50,0x52,  /* 00001558    ".PRQG.PR" */
    0x51,0x48,0x08,0x14,0x13,0x49,0x51,0x53,  /* 00001560    "QH...IQS" */
    0x54,0x01,0xA0,0x09,0x7B,0x0A,0x80,0x68,  /* 00001568    "T...{..h" */
    0x00,0xA4,0x0A,0x09,0xA4,0x0A,0x0B,0x14,  /* 00001570    "........" */
    0x34,0x49,0x51,0x43,0x52,0x09,0x08,0x50,  /* 00001578    "4IQCR..P" */
    0x52,0x52,0x30,0x11,0x0E,0x0A,0x0B,0x89,  /* 00001580    "RR0....." */
    0x06,0x00,0x09,0x01,0x00,0x00,0x00,0x00,  /* 00001588    "........" */
    0x79,0x00,0x8A,0x50,0x52,0x52,0x30,0x0A,  /* 00001590    "y..PRR0." */
    0x05,0x50,0x52,0x52,0x49,0x70,0x7B,0x68,  /* 00001598    ".PRRIp{h" */
    0x0A,0x0F,0x00,0x50,0x52,0x52,0x49,0xA4,  /* 000015A0    "...PRRI." */
    0x50,0x52,0x52,0x30,0x5B,0x82,0x4C,0x07,  /* 000015A8    "PRR0[.L." */
    0x4C,0x4E,0x4B,0x41,0x08,0x5F,0x48,0x49,  /* 000015B0    "LNKA._HI" */
    0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,  /* 000015B8    "D.A...._" */
    0x55,0x49,0x44,0x00,0x08,0x5F,0x50,0x52,  /* 000015C0    "UID.._PR" */
    0x53,0x11,0x16,0x0A,0x13,0x89,0x0E,0x00,  /* 000015C8    "S......." */
    0x09,0x03,0x05,0x00,0x00,0x00,0x0A,0x00,  /* 000015D0    "........" */
    0x00,0x00,0x0B,0x00,0x00,0x00,0x79,0x00,  /* 000015D8    "......y." */
    0x14,0x0F,0x5F,0x53,0x54,0x41,0x00,0xA4,  /* 000015E0    ".._STA.." */
    0x49,0x51,0x53,0x54,0x50,0x52,0x51,0x41,  /* 000015E8    "IQSTPRQA" */
    0x14,0x11,0x5F,0x44,0x49,0x53,0x00,0x7D,  /* 000015F0    ".._DIS.}" */
    0x50,0x52,0x51,0x41,0x0A,0x80,0x50,0x52,  /* 000015F8    "PRQA..PR" */
    0x51,0x41,0x14,0x0F,0x5F,0x43,0x52,0x53,  /* 00001600    "QA.._CRS" */
    0x00,0xA4,0x49,0x51,0x43,0x52,0x50,0x52,  /* 00001608    "..IQCRPR" */
    0x51,0x41,0x14,0x17,0x5F,0x53,0x52,0x53,  /* 00001610    "QA.._SRS" */
    0x01,0x8A,0x68,0x0A,0x05,0x50,0x52,0x52,  /* 00001618    "..h..PRR" */
    0x49,0x70,0x50,0x52,0x52,0x49,0x50,0x52,  /* 00001620    "IpPRRIPR" */
    0x51,0x41,0x5B,0x82,0x4C,0x07,0x4C,0x4E,  /* 00001628    "QA[.L.LN" */
    0x4B,0x42,0x08,0x5F,0x48,0x49,0x44,0x0C,  /* 00001630    "KB._HID." */
    0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,0x49,  /* 00001638    "A...._UI" */
    0x44,0x01,0x08,0x5F,0x50,0x52,0x53,0x11,  /* 00001640    "D.._PRS." */
    0x16,0x0A,0x13,0x89,0x0E,0x00,0x09,0x03,  /* 00001648    "........" */
    0x05,0x00,0x00,0x00,0x0A,0x00,0x00,0x00,  /* 00001650    "........" */
    0x0B,0x00,0x00,0x00,0x79,0x00,0x14,0x0F,  /* 00001658    "....y..." */
    0x5F,0x53,0x54,0x41,0x00,0xA4,0x49,0x51,  /* 00001660    "_STA..IQ" */
    0x53,0x54,0x50,0x52,0x51,0x42,0x14,0x11,  /* 00001668    "STPRQB.." */
    0x5F,0x44,0x49,0x53,0x00,0x7D,0x50,0x52,  /* 00001670    "_DIS.}PR" */
    0x51,0x42,0x0A,0x80,0x50,0x52,0x51,0x42,  /* 00001678    "QB..PRQB" */
    0x14,0x0F,0x5F,0x43,0x52,0x53,0x00,0xA4,  /* 00001680    ".._CRS.." */
    0x49,0x51,0x43,0x52,0x50,0x52,0x51,0x42,  /* 00001688    "IQCRPRQB" */
    0x14,0x17,0x5F,0x53,0x52,0x53,0x01,0x8A,  /* 00001690    ".._SRS.." */
    0x68,0x0A,0x05,0x50,0x52,0x52,0x49,0x70,  /* 00001698    "h..PRRIp" */
    0x50,0x52,0x52,0x49,0x50,0x52,0x51,0x42,  /* 000016A0    "PRRIPRQB" */
    0x5B,0x82,0x4D,0x07,0x4C,0x4E,0x4B,0x43,  /* 000016A8    "[.M.LNKC" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 000016B0    "._HID.A." */
    0x0C,0x0F,0x08,0x5F,0x55,0x49,0x44,0x0A,  /* 000016B8    "..._UID." */
    0x02,0x08,0x5F,0x50,0x52,0x53,0x11,0x16,  /* 000016C0    ".._PRS.." */
    0x0A,0x13,0x89,0x0E,0x00,0x09,0x03,0x05,  /* 000016C8    "........" */
    0x00,0x00,0x00,0x0A,0x00,0x00,0x00,0x0B,  /* 000016D0    "........" */
    0x00,0x00,0x00,0x79,0x00,0x14,0x0F,0x5F,  /* 000016D8    "...y..._" */
    0x53,0x54,0x41,0x00,0xA4,0x49,0x51,0x53,  /* 000016E0    "STA..IQS" */
    0x54,0x50,0x52,0x51,0x43,0x14,0x11,0x5F,  /* 000016E8    "TPRQC.._" */
    0x44,0x49,0x53,0x00,0x7D,0x50,0x52,0x51,  /* 000016F0    "DIS.}PRQ" */
    0x43,0x0A,0x80,0x50,0x52,0x51,0x43,0x14,  /* 000016F8    "C..PRQC." */
    0x0F,0x5F,0x43,0x52,0x53,0x00,0xA4,0x49,  /* 00001700    "._CRS..I" */
    0x51,0x43,0x52,0x50,0x52,0x51,0x43,0x14,  /* 00001708    "QCRPRQC." */
    0x17,0x5F,0x53,0x52,0x53,0x01,0x8A,0x68,  /* 00001710    "._SRS..h" */
    0x0A,0x05,0x50,0x52,0x52,0x49,0x70,0x50,  /* 00001718    "..PRRIpP" */
    0x52,0x52,0x49,0x50,0x52,0x51,0x43,0x5B,  /* 00001720    "RRIPRQC[" */
    0x82,0x4D,0x07,0x4C,0x4E,0x4B,0x44,0x08,  /* 00001728    ".M.LNKD." */
    0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,0x0C,  /* 00001730    "_HID.A.." */
    0x0F,0x08,0x5F,0x55,0x49,0x44,0x0A,0x03,  /* 00001738    ".._UID.." */
    0x08,0x5F,0x50,0x52,0x53,0x11,0x16,0x0A,  /* 00001740    "._PRS..." */
    0x13,0x89,0x0E,0x00,0x09,0x03,0x05,0x00,  /* 00001748    "........" */
    0x00,0x00,0x0A,0x00,0x00,0x00,0x0B,0x00,  /* 00001750    "........" */
    0x00,0x00,0x79,0x00,0x14,0x0F,0x5F,0x53,  /* 00001758    "..y..._S" */
    0x54,0x41,0x00,0xA4,0x49,0x51,0x53,0x54,  /* 00001760    "TA..IQST" */
    0x50,0x52,0x51,0x44,0x14,0x11,0x5F,0x44,  /* 00001768    "PRQD.._D" */
    0x49,0x53,0x00,0x7D,0x50,0x52,0x51,0x44,  /* 00001770    "IS.}PRQD" */
    0x0A,0x80,0x50,0x52,0x51,0x44,0x14,0x0F,  /* 00001778    "..PRQD.." */
    0x5F,0x43,0x52,0x53,0x00,0xA4,0x49,0x51,  /* 00001780    "_CRS..IQ" */
    0x43,0x52,0x50,0x52,0x51,0x44,0x14,0x17,  /* 00001788    "CRPRQD.." */
    0x5F,0x53,0x52,0x53,0x01,0x8A,0x68,0x0A,  /* 00001790    "_SRS..h." */
    0x05,0x50,0x52,0x52,0x49,0x70,0x50,0x52,  /* 00001798    ".PRRIpPR" */
    0x52,0x49,0x50,0x52,0x51,0x44,0x5B,0x82,  /* 000017A0    "RIPRQD[." */
    0x4D,0x07,0x4C,0x4E,0x4B,0x45,0x08,0x5F,  /* 000017A8    "M.LNKE._" */
    0x48,0x49,0x44,0x0C,0x41,0xD0,0x0C,0x0F,  /* 000017B0    "HID.A..." */
    0x08,0x5F,0x55,0x49,0x44,0x0A,0x04,0x08,  /* 000017B8    "._UID..." */
    0x5F,0x50,0x52,0x53,0x11,0x16,0x0A,0x13,  /* 000017C0    "_PRS...." */
    0x89,0x0E,0x00,0x09,0x03,0x05,0x00,0x00,  /* 000017C8    "........" */
    0x00,0x0A,0x00,0x00,0x00,0x0B,0x00,0x00,  /* 000017D0    "........" */
    0x00,0x79,0x00,0x14,0x0F,0x5F,0x53,0x54,  /* 000017D8    ".y..._ST" */
    0x41,0x00,0xA4,0x49,0x51,0x53,0x54,0x50,  /* 000017E0    "A..IQSTP" */
    0x52,0x51,0x45,0x14,0x11,0x5F,0x44,0x49,  /* 000017E8    "RQE.._DI" */
    0x53,0x00,0x7D,0x50,0x52,0x51,0x45,0x0A,  /* 000017F0    "S.}PRQE." */
    0x80,0x50,0x52,0x51,0x45,0x14,0x0F,0x5F,  /* 000017F8    ".PRQE.._" */
    0x43,0x52,0x53,0x00,0xA4,0x49,0x51,0x43,  /* 00001800    "CRS..IQC" */
    0x52,0x50,0x52,0x51,0x45,0x14,0x17,0x5F,  /* 00001808    "RPRQE.._" */
    0x53,0x52,0x53,0x01,0x8A,0x68,0x0A,0x05,  /* 00001810    "SRS..h.." */
    0x50,0x52,0x52,0x49,0x70,0x50,0x52,0x52,  /* 00001818    "PRRIpPRR" */
    0x49,0x50,0x52,0x51,0x45,0x5B,0x82,0x4D,  /* 00001820    "IPRQE[.M" */
    0x07,0x4C,0x4E,0x4B,0x46,0x08,0x5F,0x48,  /* 00001828    ".LNKF._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,  /* 00001830    "ID.A...." */
    0x5F,0x55,0x49,0x44,0x0A,0x05,0x08,0x5F,  /* 00001838    "_UID..._" */
    0x50,0x52,0x53,0x11,0x16,0x0A,0x13,0x89,  /* 00001840    "PRS....." */
    0x0E,0x00,0x09,0x03,0x05,0x00,0x00,0x00,  /* 00001848    "........" */
    0x0A,0x00,0x00,0x00,0x0B,0x00,0x00,0x00,  /* 00001850    "........" */
    0x79,0x00,0x14,0x0F,0x5F,0x53,0x54,0x41,  /* 00001858    "y..._STA" */
    0x00,0xA4,0x49,0x51,0x53,0x54,0x50,0x52,  /* 00001860    "..IQSTPR" */
    0x51,0x46,0x14,0x11,0x5F,0x44,0x49,0x53,  /* 00001868    "QF.._DIS" */
    0x00,0x7D,0x50,0x52,0x51,0x46,0x0A,0x80,  /* 00001870    ".}PRQF.." */
    0x50,0x52,0x51,0x46,0x14,0x0F,0x5F,0x43,  /* 00001878    "PRQF.._C" */
    0x52,0x53,0x00,0xA4,0x49,0x51,0x43,0x52,  /* 00001880    "RS..IQCR" */
    0x50,0x52,0x51,0x46,0x14,0x17,0x5F,0x53,  /* 00001888    "PRQF.._S" */
    0x52,0x53,0x01,0x8A,0x68,0x0A,0x05,0x50,  /* 00001890    "RS..h..P" */
    0x52,0x52,0x49,0x70,0x50,0x52,0x52,0x49,  /* 00001898    "RRIpPRRI" */
    0x50,0x52,0x51,0x46,0x5B,0x82,0x4D,0x07,  /* 000018A0    "PRQF[.M." */
    0x4C,0x4E,0x4B,0x47,0x08,0x5F,0x48,0x49,  /* 000018A8    "LNKG._HI" */
    0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,  /* 000018B0    "D.A...._" */
    0x55,0x49,0x44,0x0A,0x06,0x08,0x5F,0x50,  /* 000018B8    "UID..._P" */
    0x52,0x53,0x11,0x16,0x0A,0x13,0x89,0x0E,  /* 000018C0    "RS......" */
    0x00,0x09,0x03,0x05,0x00,0x00,0x00,0x0A,  /* 000018C8    "........" */
    0x00,0x00,0x00,0x0B,0x00,0x00,0x00,0x79,  /* 000018D0    ".......y" */
    0x00,0x14,0x0F,0x5F,0x53,0x54,0x41,0x00,  /* 000018D8    "..._STA." */
    0xA4,0x49,0x51,0x53,0x54,0x50,0x52,0x51,  /* 000018E0    ".IQSTPRQ" */
    0x47,0x14,0x11,0x5F,0x44,0x49,0x53,0x00,  /* 000018E8    "G.._DIS." */
    0x7D,0x50,0x52,0x51,0x47,0x0A,0x80,0x50,  /* 000018F0    "}PRQG..P" */
    0x52,0x51,0x47,0x14,0x0F,0x5F,0x43,0x52,  /* 000018F8    "RQG.._CR" */
    0x53,0x00,0xA4,0x49,0x51,0x43,0x52,0x50,  /* 00001900    "S..IQCRP" */
    0x52,0x51,0x47,0x14,0x17,0x5F,0x53,0x52,  /* 00001908    "RQG.._SR" */
    0x53,0x01,0x8A,0x68,0x0A,0x05,0x50,0x52,  /* 00001910    "S..h..PR" */
    0x52,0x49,0x70,0x50,0x52,0x52,0x49,0x50,  /* 00001918    "RIpPRRIP" */
    0x52,0x51,0x47,0x5B,0x82,0x4D,0x07,0x4C,  /* 00001920    "RQG[.M.L" */
    0x4E,0x4B,0x48,0x08,0x5F,0x48,0x49,0x44,  /* 00001928    "NKH._HID" */
    0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,  /* 00001930    ".A...._U" */
    0x49,0x44,0x0A,0x07,0x08,0x5F,0x50,0x52,  /* 00001938    "ID..._PR" */
    0x53,0x11,0x16,0x0A,0x13,0x89,0x0E,0x00,  /* 00001940    "S......." */
    0x09,0x03,0x05,0x00,0x00,0x00,0x0A,0x00,  /* 00001948    "........" */
    0x00,0x00,0x0B,0x00,0x00,0x00,0x79,0x00,  /* 00001950    "......y." */
    0x14,0x0F,0x5F,0x53,0x54,0x41,0x00,0xA4,  /* 00001958    ".._STA.." */
    0x49,0x51,0x53,0x54,0x50,0x52,0x51,0x48,  /* 00001960    "IQSTPRQH" */
    0x14,0x11,0x5F,0x44,0x49,0x53,0x00,0x7D,  /* 00001968    ".._DIS.}" */
    0x50,0x52,0x51,0x48,0x0A,0x80,0x50,0x52,  /* 00001970    "PRQH..PR" */
    0x51,0x48,0x14,0x0F,0x5F,0x43,0x52,0x53,  /* 00001978    "QH.._CRS" */
    0x00,0xA4,0x49,0x51,0x43,0x52,0x50,0x52,  /* 00001980    "..IQCRPR" */
    0x51,0x48,0x14,0x17,0x5F,0x53,0x52,0x53,  /* 00001988    "QH.._SRS" */
    0x01,0x8A,0x68,0x0A,0x05,0x50,0x52,0x52,  /* 00001990    "..h..PRR" */
    0x49,0x70,0x50,0x52,0x52,0x49,0x50,0x52,  /* 00001998    "IpPRRIPR" */
    0x51,0x48,0x5B,0x82,0x45,0x04,0x47,0x53,  /* 000019A0    "QH[.E.GS" */
    0x49,0x41,0x08,0x5F,0x48,0x49,0x44,0x0C,  /* 000019A8    "IA._HID." */
    0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,0x49,  /* 000019B0    "A...._UI" */
    0x44,0x00,0x08,0x5F,0x50,0x52,0x53,0x11,  /* 000019B8    "D.._PRS." */
    0x0E,0x0A,0x0B,0x89,0x06,0x00,0x09,0x01,  /* 000019C0    "........" */
    0x10,0x00,0x00,0x00,0x79,0x00,0x08,0x5F,  /* 000019C8    "....y.._" */
    0x43,0x52,0x53,0x11,0x0E,0x0A,0x0B,0x89,  /* 000019D0    "CRS....." */
    0x06,0x00,0x09,0x01,0x10,0x00,0x00,0x00,  /* 000019D8    "........" */
    0x79,0x00,0x14,0x06,0x5F,0x53,0x52,0x53,  /* 000019E0    "y..._SRS" */
    0x01,0x5B,0x82,0x45,0x04,0x47,0x53,0x49,  /* 000019E8    ".[.E.GSI" */
    0x42,0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,  /* 000019F0    "B._HID.A" */
    0xD0,0x0C,0x0F,0x08,0x5F,0x55,0x49,0x44,  /* 000019F8    "...._UID" */
    0x00,0x08,0x5F,0x50,0x52,0x53,0x11,0x0E,  /* 00001A00    ".._PRS.." */
    0x0A,0x0B,0x89,0x06,0x00,0x09,0x01,0x11,  /* 00001A08    "........" */
    0x00,0x00,0x00,0x79,0x00,0x08,0x5F,0x43,  /* 00001A10    "...y.._C" */
    0x52,0x53,0x11,0x0E,0x0A,0x0B,0x89,0x06,  /* 00001A18    "RS......" */
    0x00,0x09,0x01,0x11,0x00,0x00,0x00,0x79,  /* 00001A20    ".......y" */
    0x00,0x14,0x06,0x5F,0x53,0x52,0x53,0x01,  /* 00001A28    "..._SRS." */
    0x5B,0x82,0x45,0x04,0x47,0x53,0x49,0x43,  /* 00001A30    "[.E.GSIC" */
    0x08,0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,  /* 00001A38    "._HID.A." */
    0x0C,0x0F,0x08,0x5F,0x55,0x49,0x44,0x00,  /* 00001A40    "..._UID." */
    0x08,0x5F,0x50,0x52,0x53,0x11,0x0E,0x0A,  /* 00001A48    "._PRS..." */
    0x0B,0x89,0x06,0x00,0x09,0x01,0x12,0x00,  /* 00001A50    "........" */
    0x00,0x00,0x79,0x00,0x08,0x5F,0x43,0x52,  /* 00001A58    "..y.._CR" */
    0x53,0x11,0x0E,0x0A,0x0B,0x89,0x06,0x00,  /* 00001A60    "S......." */
    0x09,0x01,0x12,0x00,0x00,0x00,0x79,0x00,  /* 00001A68    "......y." */
    0x14,0x06,0x5F,0x53,0x52,0x53,0x01,0x5B,  /* 00001A70    ".._SRS.[" */
    0x82,0x45,0x04,0x47,0x53,0x49,0x44,0x08,  /* 00001A78    ".E.GSID." */
    0x5F,0x48,0x49,0x44,0x0C,0x41,0xD0,0x0C,  /* 00001A80    "_HID.A.." */
    0x0F,0x08,0x5F,0x55,0x49,0x44,0x00,0x08,  /* 00001A88    ".._UID.." */
    0x5F,0x50,0x52,0x53,0x11,0x0E,0x0A,0x0B,  /* 00001A90    "_PRS...." */
    0x89,0x06,0x00,0x09,0x01,0x13,0x00,0x00,  /* 00001A98    "........" */
    0x00,0x79,0x00,0x08,0x5F,0x43,0x52,0x53,  /* 00001AA0    ".y.._CRS" */
    0x11,0x0E,0x0A,0x0B,0x89,0x06,0x00,0x09,  /* 00001AA8    "........" */
    0x01,0x13,0x00,0x00,0x00,0x79,0x00,0x14,  /* 00001AB0    ".....y.." */
    0x06,0x5F,0x53,0x52,0x53,0x01,0x5B,0x82,  /* 00001AB8    "._SRS.[." */
    0x45,0x04,0x47,0x53,0x49,0x45,0x08,0x5F,  /* 00001AC0    "E.GSIE._" */
    0x48,0x49,0x44,0x0C,0x41,0xD0,0x0C,0x0F,  /* 00001AC8    "HID.A..." */
    0x08,0x5F,0x55,0x49,0x44,0x00,0x08,0x5F,  /* 00001AD0    "._UID.._" */
    0x50,0x52,0x53,0x11,0x0E,0x0A,0x0B,0x89,  /* 00001AD8    "PRS....." */
    0x06,0x00,0x09,0x01,0x14,0x00,0x00,0x00,  /* 00001AE0    "........" */
    0x79,0x00,0x08,0x5F,0x43,0x52,0x53,0x11,  /* 00001AE8    "y.._CRS." */
    0x0E,0x0A,0x0B,0x89,0x06,0x00,0x09,0x01,  /* 00001AF0    "........" */
    0x14,0x00,0x00,0x00,0x79,0x00,0x14,0x06,  /* 00001AF8    "....y..." */
    0x5F,0x53,0x52,0x53,0x01,0x5B,0x82,0x45,  /* 00001B00    "_SRS.[.E" */
    0x04,0x47,0x53,0x49,0x46,0x08,0x5F,0x48,  /* 00001B08    ".GSIF._H" */
    0x49,0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,  /* 00001B10    "ID.A...." */
    0x5F,0x55,0x49,0x44,0x00,0x08,0x5F,0x50,  /* 00001B18    "_UID.._P" */
    0x52,0x53,0x11,0x0E,0x0A,0x0B,0x89,0x06,  /* 00001B20    "RS......" */
    0x00,0x09,0x01,0x15,0x00,0x00,0x00,0x79,  /* 00001B28    ".......y" */
    0x00,0x08,0x5F,0x43,0x52,0x53,0x11,0x0E,  /* 00001B30    ".._CRS.." */
    0x0A,0x0B,0x89,0x06,0x00,0x09,0x01,0x15,  /* 00001B38    "........" */
    0x00,0x00,0x00,0x79,0x00,0x14,0x06,0x5F,  /* 00001B40    "...y..._" */
    0x53,0x52,0x53,0x01,0x5B,0x82,0x45,0x04,  /* 00001B48    "SRS.[.E." */
    0x47,0x53,0x49,0x47,0x08,0x5F,0x48,0x49,  /* 00001B50    "GSIG._HI" */
    0x44,0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,  /* 00001B58    "D.A...._" */
    0x55,0x49,0x44,0x00,0x08,0x5F,0x50,0x52,  /* 00001B60    "UID.._PR" */
    0x53,0x11,0x0E,0x0A,0x0B,0x89,0x06,0x00,  /* 00001B68    "S......." */
    0x09,0x01,0x16,0x00,0x00,0x00,0x79,0x00,  /* 00001B70    "......y." */
    0x08,0x5F,0x43,0x52,0x53,0x11,0x0E,0x0A,  /* 00001B78    "._CRS..." */
    0x0B,0x89,0x06,0x00,0x09,0x01,0x16,0x00,  /* 00001B80    "........" */
    0x00,0x00,0x79,0x00,0x14,0x06,0x5F,0x53,  /* 00001B88    "..y..._S" */
    0x52,0x53,0x01,0x5B,0x82,0x45,0x04,0x47,  /* 00001B90    "RS.[.E.G" */
    0x53,0x49,0x48,0x08,0x5F,0x48,0x49,0x44,  /* 00001B98    "SIH._HID" */
    0x0C,0x41,0xD0,0x0C,0x0F,0x08,0x5F,0x55,  /* 00001BA0    ".A...._U" */
    0x49,0x44,0x00,0x08,0x5F,0x50,0x52,0x53,  /* 00001BA8    "ID.._PRS" */
    0x11,0x0E,0x0A,0x0B,0x89,0x06,0x00,0x09,  /* 00001BB0    "........" */
    0x01,0x17,0x00,0x00,0x00,0x79,0x00,0x08,  /* 00001BB8    ".....y.." */
    0x5F,0x43,0x52,0x53,0x11,0x0E,0x0A,0x0B,  /* 00001BC0    "_CRS...." */
    0x89,0x06,0x00,0x09,0x01,0x17,0x00,0x00,  /* 00001BC8    "........" */
    0x00,0x79,0x00,0x14,0x06,0x5F,0x53,0x52,  /* 00001BD0    ".y..._SR" */
    0x53,0x01,0x10,0x47,0x0E,0x5F,0x53,0x42,  /* 00001BD8    "S..G._SB" */
    0x5F,0x14,0x35,0x43,0x50,0x4D,0x41,0x01,  /* 00001BE0    "_.5CPMA." */
    0x70,0x83,0x88,0x43,0x50,0x4F,0x4E,0x68,  /* 00001BE8    "p..CPONh" */
    0x00,0x60,0x70,0x11,0x0B,0x0A,0x08,0x00,  /* 00001BF0    ".`p....." */
    0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x61,  /* 00001BF8    ".......a" */
    0x70,0x68,0x88,0x61,0x0A,0x02,0x00,0x70,  /* 00001C00    "ph.a...p" */
    0x68,0x88,0x61,0x0A,0x03,0x00,0x70,0x60,  /* 00001C08    "h.a...p`" */
    0x88,0x61,0x0A,0x04,0x00,0xA4,0x61,0x14,  /* 00001C10    ".a....a." */
    0x1A,0x43,0x50,0x53,0x54,0x01,0x70,0x83,  /* 00001C18    ".CPST.p." */
    0x88,0x43,0x50,0x4F,0x4E,0x68,0x00,0x60,  /* 00001C20    ".CPONh.`" */
    0xA0,0x05,0x60,0xA4,0x0A,0x0F,0xA1,0x03,  /* 00001C28    "..`....." */
    0xA4,0x00,0x14,0x0A,0x43,0x50,0x45,0x4A,  /* 00001C30    "....CPEJ" */
    0x02,0x5B,0x22,0x0A,0xC8,0x5B,0x80,0x50,  /* 00001C38    ".["..[.P" */
    0x52,0x53,0x54,0x01,0x0B,0x00,0xAF,0x0A,  /* 00001C40    "RST....." */
    0x20,0x5B,0x81,0x0C,0x50,0x52,0x53,0x54,  /* 00001C48    " [..PRST" */
    0x01,0x50,0x52,0x53,0x5F,0x40,0x10,0x14,  /* 00001C50    ".PRS_@.." */
    0x4A,0x06,0x50,0x52,0x53,0x43,0x00,0x70,  /* 00001C58    "J.PRSC.p" */
    0x50,0x52,0x53,0x5F,0x65,0x70,0x00,0x62,  /* 00001C60    "PRS_ep.b" */
    0x70,0x00,0x60,0xA2,0x46,0x05,0x95,0x60,  /* 00001C68    "p.`.F..`" */
    0x87,0x43,0x50,0x4F,0x4E,0x70,0x83,0x88,  /* 00001C70    ".CPONp.." */
    0x43,0x50,0x4F,0x4E,0x60,0x00,0x61,0xA0,  /* 00001C78    "CPON`.a." */
    0x0A,0x7B,0x60,0x0A,0x07,0x00,0x7A,0x62,  /* 00001C80    ".{`...zb" */
    0x01,0x62,0xA1,0x0C,0x70,0x83,0x88,0x65,  /* 00001C88    ".b..p..e" */
    0x7A,0x60,0x0A,0x03,0x00,0x00,0x62,0x70,  /* 00001C90    "z`....bp" */
    0x7B,0x62,0x01,0x00,0x63,0xA0,0x22,0x92,  /* 00001C98    "{b..c."." */
    0x93,0x61,0x63,0x70,0x63,0x88,0x43,0x50,  /* 00001CA0    ".acpc.CP" */
    0x4F,0x4E,0x60,0x00,0xA0,0x0A,0x93,0x63,  /* 00001CA8    "ON`....c" */
    0x01,0x4E,0x54,0x46,0x59,0x60,0x01,0xA1,  /* 00001CB0    ".NTFY`.." */
    0x08,0x4E,0x54,0x46,0x59,0x60,0x0A,0x03,  /* 00001CB8    ".NTFY`.." */
    0x75,0x60,0x10,0x4F,0x08,0x5F,0x47,0x50,  /* 00001CC0    "u`.O._GP" */
    0x45,0x08,0x5F,0x48,0x49,0x44,0x0D,0x41,  /* 00001CC8    "E._HID.A" */
    0x43,0x50,0x49,0x30,0x30,0x30,0x36,0x00,  /* 00001CD0    "CPI0006." */
    0x14,0x06,0x5F,0x4C,0x30,0x30,0x00,0x14,  /* 00001CD8    ".._L00.." */
    0x10,0x5F,0x4C,0x30,0x31,0x00,0x5C,0x2E,  /* 00001CE0    "._L01.\." */
    0x5F,0x53,0x42,0x5F,0x50,0x52,0x53,0x43,  /* 00001CE8    "_SB_PRSC" */
    0x14,0x06,0x5F,0x4C,0x30,0x32,0x00,0x14,  /* 00001CF0    ".._L02.." */
    0x06,0x5F,0x4C,0x30,0x33,0x00,0x14,0x06,  /* 00001CF8    "._L03..." */
    0x5F,0x4C,0x30,0x34,0x00,0x14,0x06,0x5F,  /* 00001D00    "_L04..._" */
    0x4C,0x30,0x35,0x00,0x14,0x06,0x5F,0x4C,  /* 00001D08    "L05..._L" */
    0x30,0x36,0x00,0x14,0x06,0x5F,0x4C,0x30,  /* 00001D10    "06..._L0" */
    0x37,0x00,0x14,0x06,0x5F,0x4C,0x30,0x38,  /* 00001D18    "7..._L08" */
    0x00,0x14,0x06,0x5F,0x4C,0x30,0x39,0x00,  /* 00001D20    "..._L09." */
    0x14,0x06,0x5F,0x4C,0x30,0x41,0x00,0x14,  /* 00001D28    ".._L0A.." */
    0x06,0x5F,0x4C,0x30,0x42,0x00,0x14,0x06,  /* 00001D30    "._L0B..." */
    0x5F,0x4C,0x30,0x43,0x00,0x14,0x06,0x5F,  /* 00001D38    "_L0C..._" */
    0x4C,0x30,0x44,0x00,0x14,0x06,0x5F,0x4C,  /* 00001D40    "L0D..._L" */
    0x30,0x45,0x00,0x14,0x06,0x5F,0x4C,0x30,  /* 00001D48    "0E..._L0" */
    0x46,0x00                                 /* 00001D50    "F."       */
};

#endif

```

`devices/nvram/firmware_config.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "firmware_config.h"

#include <cstring>

#include "logger.h"
#include "device_manager.h"
#include "memory_manager.h"
#include "machine.h"
#include "smbios.h"
#include "firmware_config.pb.h"
#include "acpi_dsdt/acpi_dsdt.hex.h"
#include "acpi_dsdt/q35_acpi_dsdt.hex.h"


#define FW_CFG_ACPI_DEVICE_ID "QEMU0002"

#define FEATURE_CONTROL_LOCKED                    (1<<0)
#define FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX  (1ULL << 1)
#define FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX (1<<2)
#define FEATURE_CONTROL_SGX_LC                    (1ULL << 17)
#define FEATURE_CONTROL_SGX                       (1ULL << 18)
#define FEATURE_CONTROL_LMCE                      (1<<20)


class FirmwareConfig : public Device {
 private:
  uint16_t current_index_ = 0;
  uint32_t current_offset_ = 0;
  uint64_t dma_address_ = 0;
  std::map<uint16_t, std::string> config_;
  std::map<std::string, std::string> files_;


  void DmaTransfer() {
    fw_cfg_dma_access* dma = (fw_cfg_dma_access*)manager_->TranslateGuestMemory(dma_address_);
    dma_address_ = 0;

    dma->control = be32toh(dma->control);
    dma->address = be64toh(dma->address);
    dma->length = be32toh(dma->length);
    
    if (dma->control & FW_CFG_DMA_CTL_SELECT) {
      current_index_ = dma->control >> 16;
      current_offset_ = 0;
    }

    auto it = config_.find(current_index_);
    if (it == config_.end()) {
      dma->control = be32toh(FW_CFG_DMA_CTL_ERROR);
      if (current_index_ & 0x8000) {
        /* Skip ARCH_LOCAL entries like ACPI, SMBIOS */
        return;
      }
      MV_PANIC("config entry not found 0x%x", current_index_);
    }

    uint8_t* data = (uint8_t*)manager_->TranslateGuestMemory(dma->address);
    if (dma->control & FW_CFG_DMA_CTL_READ) {
      uint32_t size = it->second.size() - current_offset_;
      if (size > dma->length)
        size = dma->length;
      memcpy(data, it->second.data() + current_offset_, size);
      current_offset_ += size;
    } else if (dma->control & FW_CFG_DMA_CTL_WRITE) {
      MV_PANIC("not supported");
    }
    dma->control = 0;
  }

  void SetConfigBytes(uint16_t index, std::string bytes) {
    config_[index] = bytes;
  }

  void SetConfigUInt32(uint16_t index, uint32_t value) {
    config_[index] = std::string((const char*)&value, sizeof(value));
  }

  void SetConfigUInt16(uint16_t index, uint16_t value) {
    config_[index] = std::string((const char*)&value, sizeof(value));
  }

  void AddConfigFile(std::string path, void* data, size_t size) {
    files_[path] = std::string((const char*)data, size);
    if (debug_) {
      MV_HEXDUMP(path.c_str(), files_[path].data(), files_[path].size());
    }
  }

  void AddConfigFile(std::string path, std::string local_path) {
    FILE *fp = fopen(local_path.c_str(), "rb");
    if (fp == NULL) {
      MV_PANIC("failed to locate file %s", local_path.c_str());
    }
    fseek(fp, 0, SEEK_END);
    ssize_t file_size = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    uint8_t* buf = new uint8_t[file_size];
    fread(buf, file_size, 1, fp);
    fclose(fp);

    AddConfigFile(path, buf, file_size);
    delete buf;
  }

  void InitializeConfig() {
    SetConfigBytes(FW_CFG_SIGNATURE, "QEMU");
    uint32_t version = FW_CFG_VERSION | FW_CFG_VERSION_DMA;
    SetConfigUInt32(FW_CFG_ID, version);
    SetConfigUInt32(FW_CFG_FILE_DIR, 0);

    auto machine = manager_->machine();
    int num_vcpus = machine->num_vcpus();
    SetConfigUInt16(FW_CFG_NB_CPUS, num_vcpus);
    SetConfigUInt16(FW_CFG_MAX_CPUS, num_vcpus);
    uint64_t numa_cfg[num_vcpus + 1] = { 0 };
    SetConfigBytes(FW_CFG_NUMA, std::string((const char*)numa_cfg, sizeof(numa_cfg)));
    SetConfigUInt16(FW_CFG_NOGRAPHIC, 0);
    SetConfigUInt32(FW_CFG_IRQ0_OVERRIDE, 1);
    SetConfigUInt16(FW_CFG_BOOT_MENU, 0);

    InitializeE820Table();

    InitializeFiles();
    InitializeFileDir();
  }

  void InitializeFiles () {
    /* disable S3 S4 (suspend / hibernate) */
    bool disable_s3 = true, disable_s4 = true;
    uint8_t suspend[6] = {128, 0, 0, 129, 128, 128};
    suspend[3] = 1 | (uint(!disable_s3) << 7);
    suspend[4] = 2 | (uint(!disable_s4) << 7);
    AddConfigFile("etc/system-states", suspend, sizeof(suspend));

    /* ACPI DSDT */
    auto machine = manager_->machine();
    if (machine->LookupObjectByClass("I440fxHost")) {
      AddConfigFile("acpi/dsdt", acpi_dsdt_aml_code, sizeof(acpi_dsdt_aml_code));
    } else if (machine->LookupObjectByClass("Q35Host")) {
      AddConfigFile("acpi/dsdt", q35_acpi_dsdt_aml_code, sizeof(q35_acpi_dsdt_aml_code));
    } else {
      MV_WARN("Unknown motherboard. ACPI might not work.");
    }

    std::string smbios_anchor, smbios_table;
    Smbios smbios(manager_->machine());
    smbios.GetTables(smbios_anchor, smbios_table);

    // FIXME: Not implemented yet. Uncommenting these lines would cause windows BSOD 0x7B
    AddConfigFile("etc/smbios/smbios-tables", smbios_table.data(), smbios_table.size());
    AddConfigFile("etc/smbios/smbios-anchor", smbios_anchor.data(), smbios_anchor.size());
  }

  void InitializeFileDir() {
    fw_cfg_files dir;
    int index = 0;
    for (auto &item : files_) {
      auto cfg_file = &dir.files[index];
      strncpy(cfg_file->name, item.first.c_str(), item.first.size());
      cfg_file->size = htobe32(item.second.size());
      cfg_file->select = htobe16(FW_CFG_FILE_FIRST + index);
      cfg_file->reserved = 0;
      SetConfigBytes(FW_CFG_FILE_FIRST + index, item.second);

      if (++index >= FW_CFG_MAX_FILES) {
        break;
      }
    }
    dir.count = htobe32(index);

    std::string data((const char*)&dir, sizeof(dir.count) + index * sizeof(dir.files[0]));
    SetConfigBytes(FW_CFG_FILE_DIR, std::move(data));
  }

  void InitializeE820Table() {
    MemoryManager* mm = manager_->machine()->memory_manager();
    std::vector<e820_entry> entries;

    for (auto region : mm->regions()) {
      e820_entry entry;
      entry.address = region->gpa;
      entry.length = region->size;

      if (region->type == kMemoryTypeRam && std::string("System") == region->name) {
        entry.type = E820_RAM;
      } else if (region->type == kMemoryTypeReserved) {
        entry.type = E820_RESERVED;
      } else {
        continue;
      }

      entries.emplace_back(std::move(entry));
    }

    AddConfigFile("etc/e820", entries.data(), sizeof(e820_entry) * entries.size());
  }


 public:
  FirmwareConfig() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    AddIoResource(kIoResourceTypePio, FW_CFG_IO_BASE, 2, "Config IO");
    AddIoResource(kIoResourceTypePio, FW_CFG_DMA_IO_BASE, 8, "Config DMA");
  }

  void Connect() {
    Device::Connect();
    InitializeConfig();
  }

  void Reset() {
    Device::Reset();

    /* show menu if more than 1 drives */
    if (manager_->io()->GetDiskImageCount() > 1) {
      SetConfigUInt16(FW_CFG_BOOT_MENU, 2);
    } else {
      SetConfigUInt16(FW_CFG_BOOT_MENU, 0);
    }

    /* check VMX after vcpu started */
    auto vcpu = manager_->machine()->first_vcpu();
    MV_ASSERT(vcpu);
    if (vcpu->cpuid_features() & (1U << 5)) {
      uint64_t feature_control = FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX | FEATURE_CONTROL_LOCKED;
      AddConfigFile("etc/msr_feature_control", &feature_control, sizeof(feature_control));
    }

  }

  bool SaveState(MigrationWriter* writer) {
    FirmwareConfigState state;
    state.set_current_index(current_index_);
    state.set_current_offset(current_offset_);
    state.set_dma_address(dma_address_);
    writer->WriteProtobuf("FIRMWARE_CONFIG", state);
    return Device::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    FirmwareConfigState state;
    if (!reader->ReadProtobuf("FIRMWARE_CONFIG", state)) {
      return false;
    }
    current_index_ = state.current_index();
    current_offset_ = state.current_offset();
    dma_address_ = state.dma_address();
    return Device::LoadState(reader);
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == FW_CFG_IO_BASE && size == 2) {
      current_index_ = *(uint16_t*)data;
      current_offset_ = 0;
    } else if (resource->base == FW_CFG_DMA_IO_BASE) {
      if (size == 4) {
        if (offset == 0) { // High 32bit address
          dma_address_ = be32toh(*(uint32_t*)data);
          dma_address_ <<= 32;
        } else if (offset == 4) { // Low 32bit address
          dma_address_ |= be32toh(*(uint32_t*)data);
          DmaTransfer();
        }
      } else if (size == 8) {
        dma_address_ = be64toh(*(uint64_t*)data);
        DmaTransfer();
      }
    } else {
      MV_PANIC("not implemented Write for %s base=0x%lx offset=0x%lx size=%d",
        name_, resource->base, offset, size);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (resource->base == FW_CFG_IO_BASE && offset == 1) {
      auto it = config_.find(current_index_);
      if (it == config_.end()) {
        MV_PANIC("config entry %d not found", current_index_);
      }
      while (size--) {
        if (current_offset_ < it->second.size()) {
          *data++ = it->second[current_offset_++];
        } else {
          *data++ = 0;
        }
      }
    } else {
      MV_PANIC("not implemented Read for %s offset=0x%lx size=%d", name_, offset, size);
    }
  }
};

DECLARE_DEVICE(FirmwareConfig);

```

`devices/nvram/firmware_config.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_FIRMWARE_CONFIG_H
#define _MVISOR_FIRMWARE_CONFIG_H

#include "device.h"
#include <string>
#include <map>


/* selector key values for "well-known" fw_cfg entries */
#define FW_CFG_SIGNATURE 0x00
#define FW_CFG_ID  0x01
#define FW_CFG_UUID  0x02
#define FW_CFG_RAM_SIZE  0x03
#define FW_CFG_NOGRAPHIC 0x04
#define FW_CFG_NB_CPUS  0x05
#define FW_CFG_MACHINE_ID 0x06
#define FW_CFG_KERNEL_ADDR 0x07
#define FW_CFG_KERNEL_SIZE 0x08
#define FW_CFG_KERNEL_CMDLINE 0x09
#define FW_CFG_INITRD_ADDR 0x0a
#define FW_CFG_INITRD_SIZE 0x0b
#define FW_CFG_BOOT_DEVICE 0x0c
#define FW_CFG_NUMA  0x0d
#define FW_CFG_BOOT_MENU 0x0e
#define FW_CFG_MAX_CPUS  0x0f
#define FW_CFG_KERNEL_ENTRY 0x10
#define FW_CFG_KERNEL_DATA 0x11
#define FW_CFG_INITRD_DATA 0x12
#define FW_CFG_CMDLINE_ADDR 0x13
#define FW_CFG_CMDLINE_SIZE 0x14
#define FW_CFG_CMDLINE_DATA 0x15
#define FW_CFG_SETUP_ADDR 0x16
#define FW_CFG_SETUP_SIZE 0x17
#define FW_CFG_SETUP_DATA 0x18
#define FW_CFG_FILE_DIR  0x19

#define FW_CFG_FILE_FIRST 0x20
#define FW_CFG_FILE_SLOTS_MIN 0x10

#define FW_CFG_WRITE_CHANNEL 0x4000
#define FW_CFG_ARCH_LOCAL 0x8000
#define FW_CFG_ENTRY_MASK (~(FW_CFG_WRITE_CHANNEL | FW_CFG_ARCH_LOCAL))

#define FW_CFG_ACPI_TABLES      (FW_CFG_ARCH_LOCAL + 0)
#define FW_CFG_SMBIOS_ENTRIES   (FW_CFG_ARCH_LOCAL + 1)
#define FW_CFG_IRQ0_OVERRIDE    (FW_CFG_ARCH_LOCAL + 2)
#define FW_CFG_E820_TABLE       (FW_CFG_ARCH_LOCAL + 3)
#define FW_CFG_HPET             (FW_CFG_ARCH_LOCAL + 4)

#define FW_CFG_INVALID  0xffff

/* width in bytes of fw_cfg control register */
#define FW_CFG_CTL_SIZE  0x02

/* size in bytes of fw_cfg signature */
#define FW_CFG_SIG_SIZE 4

/* FW_CFG_ID bits */
#define FW_CFG_VERSION      0x01
#define FW_CFG_VERSION_DMA  0x02

/* fw_cfg "file name" is up to 56 characters (including terminating nul) */
#define FW_CFG_MAX_FILE_PATH 56

/* fw_cfg file directory entry type */
struct fw_cfg_file {
  uint32_t size;
  uint16_t select;
  uint16_t reserved;
  char name[FW_CFG_MAX_FILE_PATH];
};

#define FW_CFG_MAX_FILES 256

struct fw_cfg_files {
    uint32_t  count;
    fw_cfg_file files[FW_CFG_MAX_FILES];
};

/* FW_CFG_DMA_CONTROL bits */
#define FW_CFG_DMA_CTL_ERROR  0x01
#define FW_CFG_DMA_CTL_READ   0x02
#define FW_CFG_DMA_CTL_SKIP   0x04
#define FW_CFG_DMA_CTL_SELECT 0x08
#define FW_CFG_DMA_CTL_WRITE  0x10

#define FW_CFG_DMA_SIGNATURE    0x51454d5520434647ULL /* "QEMU CFG" */

/* Control as first field allows for different structures selected by this
 * field, which might be useful in the future
 */
struct fw_cfg_dma_access {
  uint32_t control;
  uint32_t length;
  uint64_t address;
};

#define FW_CFG_VMCOREINFO_FILENAME "etc/vmcoreinfo"

#define FW_CFG_VMCOREINFO_FORMAT_NONE 0x0
#define FW_CFG_VMCOREINFO_FORMAT_ELF  0x1

struct fw_cfg_vmcoreinfo {
  uint16_t host_format;
  uint16_t guest_format;
  uint32_t size;
  uint64_t paddr;
};

/* e820 types */
#define E820_RAM        1
#define E820_RESERVED   2

struct e820_entry {
    uint64_t address;
    uint64_t length;
    uint32_t type;
} __attribute((packed));

#define FW_CFG_IO_BASE        0x510
#define FW_CFG_DMA_IO_BASE    0x514


enum FirmwareConfigEntryType {
  kFirmwareConfigEntryTypeString,
  kFirmwareConfigEntryTypeUInt16,
  kFirmwareConfigEntryTypeUInt32,
  kFirmwareConfigEntryTypeUInt64,
  kFirmwareConfigEntryTypeBytes,
  kFirmwareConfigEntryTypeFile
};

struct FirmwareConfigEntry {
  FirmwareConfigEntryType type;
  std::string file;
  std::string bytes;
};



#endif // _MVISOR_FIRMWARE_CONFIG_H

```

`devices/nvram/firmware_config.proto`:

```proto
syntax = "proto3";

message FirmwareConfigState {
  uint32  current_index      = 1;
  uint32  current_offset     = 2;
  uint64  dma_address        = 3;
}

```

`devices/nvram/meson.build`:

```build
mvisor_sources += files(
  'firmware_config.cc',
  'firmware_config.h',
  'smbios.cc',
  'smbios.h'
)

proto_sources += proto_gen.process(
  'firmware_config.proto'
)

subdir('acpi_dsdt')

```

`devices/nvram/smbios.cc`:

```cc
/* 
 * MVisor SMBIOS Support
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.
 * Authors:
 *  Alex Williamson <alex.williamson@hp.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "smbios.h"
#include <cstring>
#include "logger.h"

Smbios::Smbios(Machine* machine) : machine_(machine) {
  SetupEntryPoint();
}

void Smbios::GetTables(std::string& anchor, std::string& tables) {
  /* FIXME: this tables should be implemented */
  tables = std::string("\x7F\x04\x00\x7F\x00\x00", 6);
  entry_point_.max_structure_size = 6;
  entry_point_.structure_table_length = tables.length();
  entry_point_.number_of_structures = 1;

  anchor = std::string((char*)&entry_point_, sizeof(entry_point_));
}

void Smbios::SetupEntryPoint() {
  bzero(&entry_point_, sizeof(entry_point_));
  entry_point_.length = sizeof(smbios_21_entry_point);

  memcpy(entry_point_.anchor_string, "_SM_", 4);
  memcpy(entry_point_.intermediate_anchor_string, "_DMI_", 5);

  /* smbios spec v2.8 */
  entry_point_.smbios_major_version = 2;
  entry_point_.smbios_minor_version = 8;
  entry_point_.smbios_bcd_revision = 0x28;
}


```

`devices/nvram/smbios.h`:

```h
/* 
 * MVisor SMBIOS Support
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.
 * Authors:
 *  Alex Williamson <alex.williamson@hp.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef _MVISOR_DEVICES_SMBIOS_H
#define _MVISOR_DEVICES_SMBIOS_H

#include <cstdint>
#include <string>

#define SMBIOS_MAX_TYPE 127

/* memory area description, used by type 19 table */
struct smbios_phys_mem_area {
  uint64_t address;
  uint64_t length;
};

/*
 * SMBIOS spec defined tables
 */
typedef enum SmbiosEntryPointType {
  SMBIOS_ENTRY_POINT_21,
  SMBIOS_ENTRY_POINT_30,
} SmbiosEntryPointType;

/* SMBIOS Entry Point
 * There are two types of entry points defined in the SMBIOS specification
 * (see below). BIOS must place the entry point(s) at a 16-byte-aligned
 * address between 0xf0000 and 0xfffff. Note that either entry point type
 * can be used in a 64-bit target system, except that SMBIOS 2.1 entry point
 * only allows the SMBIOS struct table to reside below 4GB address space.
 */

/* SMBIOS 2.1 (32-bit) Entry Point
 *  - introduced since SMBIOS 2.1
 *  - supports structure table below 4GB only
 */
struct smbios_21_entry_point {
  uint8_t anchor_string[4];
  uint8_t checksum;
  uint8_t length;
  uint8_t smbios_major_version;
  uint8_t smbios_minor_version;
  uint16_t max_structure_size;
  uint8_t entry_point_revision;
  uint8_t formatted_area[5];
  uint8_t intermediate_anchor_string[5];
  uint8_t intermediate_checksum;
  uint16_t structure_table_length;
  uint32_t structure_table_address;
  uint16_t number_of_structures;
  uint8_t smbios_bcd_revision;
} __attribute__((packed));

/* SMBIOS 3.0 (64-bit) Entry Point
 *  - introduced since SMBIOS 3.0
 *  - supports structure table at 64-bit address space
 */
struct smbios_30_entry_point {
  uint8_t anchor_string[5];
  uint8_t checksum;
  uint8_t length;
  uint8_t smbios_major_version;
  uint8_t smbios_minor_version;
  uint8_t smbios_doc_rev;
  uint8_t entry_point_revision;
  uint8_t reserved;
  uint32_t structure_table_max_size;
  uint64_t structure_table_address;
} __attribute__((packed));

typedef union {
  struct smbios_21_entry_point ep21;
  struct smbios_30_entry_point ep30;
} __attribute__((packed)) SmbiosEntryPoint;

/* This goes at the beginning of every SMBIOS structure. */
struct smbios_structure_header {
  uint8_t type;
  uint8_t length;
  uint16_t handle;
} __attribute__((packed));

/* SMBIOS type 0 - BIOS Information */
struct smbios_type_0 {
  struct smbios_structure_header header;
  uint8_t vendor_str;
  uint8_t bios_version_str;
  uint16_t bios_starting_address_segment;
  uint8_t bios_release_date_str;
  uint8_t bios_rom_size;
  uint64_t bios_characteristics;
  uint8_t bios_characteristics_extension_bytes[2];
  uint8_t system_bios_major_release;
  uint8_t system_bios_minor_release;
  uint8_t embedded_controller_major_release;
  uint8_t embedded_controller_minor_release;
} __attribute__((packed));

/* UUID encoding. The time_* fields are little-endian, as specified by SMBIOS
 * version 2.6.
 */
struct smbios_uuid {
  uint32_t time_low;
  uint16_t time_mid;
  uint16_t time_hi_and_version;
  uint8_t clock_seq_hi_and_reserved;
  uint8_t clock_seq_low;
  uint8_t node[6];
} __attribute__((packed));

/* SMBIOS type 1 - System Information */
struct smbios_type_1 {
  struct smbios_structure_header header;
  uint8_t manufacturer_str;
  uint8_t product_name_str;
  uint8_t version_str;
  uint8_t serial_number_str;
  struct smbios_uuid uuid;
  uint8_t wake_up_type;
  uint8_t sku_number_str;
  uint8_t family_str;
} __attribute__((packed));

/* SMBIOS type 2 - Base Board */
struct smbios_type_2 {
  struct smbios_structure_header header;
  uint8_t manufacturer_str;
  uint8_t product_str;
  uint8_t version_str;
  uint8_t serial_number_str;
  uint8_t asset_tag_number_str;
  uint8_t feature_flags;
  uint8_t location_str;
  uint16_t chassis_handle;
  uint8_t board_type;
  uint8_t contained_element_count;
  /* contained elements follow */
} __attribute__((packed));

/* SMBIOS type 3 - System Enclosure (v2.7) */
struct smbios_type_3 {
  struct smbios_structure_header header;
  uint8_t manufacturer_str;
  uint8_t type;
  uint8_t version_str;
  uint8_t serial_number_str;
  uint8_t asset_tag_number_str;
  uint8_t boot_up_state;
  uint8_t power_supply_state;
  uint8_t thermal_state;
  uint8_t security_status;
  uint32_t oem_defined;
  uint8_t height;
  uint8_t number_of_power_cords;
  uint8_t contained_element_count;
  uint8_t contained_element_record_length;
  uint8_t sku_number_str;
  /* contained elements follow */
} __attribute__((packed));

/* SMBIOS type 4 - Processor Information (v2.6) */
struct smbios_type_4 {
  struct smbios_structure_header header;
  uint8_t socket_designation_str;
  uint8_t processor_type;
  uint8_t processor_family;
  uint8_t processor_manufacturer_str;
  uint32_t processor_id[2];
  uint8_t processor_version_str;
  uint8_t voltage;
  uint16_t external_clock;
  uint16_t max_speed;
  uint16_t current_speed;
  uint8_t status;
  uint8_t processor_upgrade;
  uint16_t l1_cache_handle;
  uint16_t l2_cache_handle;
  uint16_t l3_cache_handle;
  uint8_t serial_number_str;
  uint8_t asset_tag_number_str;
  uint8_t part_number_str;
  uint8_t core_count;
  uint8_t core_enabled;
  uint8_t thread_count;
  uint16_t processor_characteristics;
  uint16_t processor_family2;
} __attribute__((packed));

/* SMBIOS type 11 - OEM strings */
struct smbios_type_11 {
  struct smbios_structure_header header;
  uint8_t count;
} __attribute__((packed));

/* SMBIOS type 16 - Physical Memory Array (v2.7) */
struct smbios_type_16 {
  struct smbios_structure_header header;
  uint8_t location;
  uint8_t use;
  uint8_t error_correction;
  uint32_t maximum_capacity;
  uint16_t memory_error_information_handle;
  uint16_t number_of_memory_devices;
  uint64_t extended_maximum_capacity;
} __attribute__((packed));

/* SMBIOS type 17 - Memory Device (v2.8) */
struct smbios_type_17 {
  struct smbios_structure_header header;
  uint16_t physical_memory_array_handle;
  uint16_t memory_error_information_handle;
  uint16_t total_width;
  uint16_t data_width;
  uint16_t size;
  uint8_t form_factor;
  uint8_t device_set;
  uint8_t device_locator_str;
  uint8_t bank_locator_str;
  uint8_t memory_type;
  uint16_t type_detail;
  uint16_t speed;
  uint8_t manufacturer_str;
  uint8_t serial_number_str;
  uint8_t asset_tag_number_str;
  uint8_t part_number_str;
  uint8_t attributes;
  uint32_t extended_size;
  uint16_t configured_clock_speed;
  uint16_t minimum_voltage;
  uint16_t maximum_voltage;
  uint16_t configured_voltage;
} __attribute__((packed));

/* SMBIOS type 19 - Memory Array Mapped Address (v2.7) */
struct smbios_type_19 {
  struct smbios_structure_header header;
  uint32_t starting_address;
  uint32_t ending_address;
  uint16_t memory_array_handle;
  uint8_t partition_width;
  uint64_t extended_starting_address;
  uint64_t extended_ending_address;
} __attribute__((packed));

/* SMBIOS type 32 - System Boot Information */
struct smbios_type_32 {
  struct smbios_structure_header header;
  uint8_t reserved[6];
  uint8_t boot_status;
} __attribute__((packed));

/* SMBIOS type 127 -- End-of-table */
struct smbios_type_127 {
  struct smbios_structure_header header;
} __attribute__((packed));


class Machine;
class Smbios {
 public:
  Smbios(Machine* machine);
  void GetTables(std::string& anchor, std::string& tables);

 private:
  void SetupEntryPoint();
  Machine* machine_;

  smbios_21_entry_point entry_point_;
};

#endif // _MVISOR_DEVICES_SMBIOS_H

```

`devices/pci/i440fx_host.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include "logger.h"
#include "pci_host.h"


class I440fxHost : public PciHost {
 public:
  I440fxHost() {
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x1237;
    pci_header_.revision_id = 2;
  }
};

DECLARE_DEVICE(I440fxHost);

```

`devices/pci/meson.build`:

```build
mvisor_sources += files(
  'i440fx_host.cc',
  'pci_host.cc',
  'q35_host.cc'
)

proto_sources += proto_gen.process(
  'pci_host.proto'
)

```

`devices/pci/pci_host.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "pci_host.h"

#include <cstring>

#include "logger.h"
#include "device_manager.h"
#include "machine.h"
#include "pci_host.pb.h"


PciHost::PciHost() {
  slot_ = 0;
  function_ = 0;
  set_default_parent_class("SystemRoot");
  
  pci_header_.class_code = 0x060000;
  pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;

  AddIoResource(kIoResourceTypePio, 0xCF8, 4, "PCI Config Address Port",
    nullptr, kIoResourceFlagCoalescingMmio);
  AddIoResource(kIoResourceTypePio, 0xCFC, 4, "PCI Config Data Port");
}

bool PciHost::SaveState(MigrationWriter* writer) {
  PciHostState state;
  state.set_config_address(config_.value);
  writer->WriteProtobuf("PCI_HOST", state);
  return PciDevice::SaveState(writer);
}

bool PciHost::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }

  PciHostState state;
  /* For old snapshots, the name is not PCI_HOST, so just skip it */
  if (!reader->Exists("PCI_HOST")) {
    return true;
  }
  if (!reader->ReadProtobuf("PCI_HOST", state)) {
    return false;
  }
  config_.value = state.config_address();
  return true;
}

void PciHost::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0xCF8) {
    if (offset == 1 && size == 1) {
      /* 0xCF9 old system reset (DOS)
       * data[0] bit 2: soft reset 4: hard reset 8: full reset */
      if (debug_) {
        MV_LOG("system reset");
      }
      manager_->machine()->Reset();
      return;
    }
    memcpy(config_.data + offset, data, size);
  } else if (resource->base == 0xCFC) {
    PciDevice* pci = manager_->LookupPciDevice(config_.bus, config_.slot, config_.function);
    if (pci) {
      config_.reg_offset = offset;
      pci->WritePciConfigSpace(config_.value & 0xFF, data, size);
    } else {
      MV_ERROR("failed to lookup pci %x:%x.%x", config_.bus, config_.slot, config_.function);
    }
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

void PciHost::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0xCF8) {
    MV_ASSERT(size == 4);
    memcpy(data, config_.data + offset, size);
  } else if (resource->base == 0xCFC) {
    PciDevice* pci = manager_->LookupPciDevice(config_.bus, config_.slot, config_.function);
    if (pci) {
      config_.reg_offset = offset;
      pci->ReadPciConfigSpace(config_.value & 0xFF, data, size);
    } else {
      memset(data, 0xFF, size);
    }
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

```

`devices/pci/pci_host.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021-2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MVISOR_DEVICES_PCI_HOST_H
#define MVISOR_DEVICES_PCI_HOST_H

#include "pci_device.h"


class PciHost : public PciDevice {
 private:
  PciConfigAddress  config_;

 public:
  PciHost();

  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);

};

#endif // MVISOR_DEVICES_PCI_HOST_H

```

`devices/pci/pci_host.proto`:

```proto
syntax = "proto3";

message PciHostState {
  uint32  config_address  = 1;
}

```

`devices/pci/q35_host.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include "logger.h"
#include "device_manager.h"
#include "pci_host.h"

#define MCH_PCIE_XBAR                0x60
#define MCH_PCIE_XBAR_SIZE           0x04

class Q35Host : public PciHost {
 private:
  uint64_t  pcie_xbar_base_ = 0;

 public:
  Q35Host() {
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x29C0;

    is_pcie_ = true;
  }

  virtual bool LoadState(MigrationReader* reader) {
    if (!PciHost::LoadState(reader)) {
      return false;
    }

    MchUpdatePcieXBar();
    return true;
  }

  void MchUpdatePcieXBar() {
    uint32_t xbar = *(uint32_t*)(pci_header_.data + MCH_PCIE_XBAR);
    int enabled = xbar & 1;

    if (!!enabled != !!pcie_xbar_base_) {
      uint32_t base = xbar & Q35_MASK(64, 35, 28);
      uint64_t length = (1LL << 20) * 256;
      if (pcie_xbar_base_) {
        RemoveIoResource(kIoResourceTypeMmio, pcie_xbar_base_);
        pcie_xbar_base_ = 0;
      }
      if (enabled) {
        AddIoResource(kIoResourceTypeMmio, base, length, "PCIE XBAR");
        pcie_xbar_base_ = base;
      }
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (pcie_xbar_base_ && resource->base == pcie_xbar_base_) {
      /*
      * PCI express ECAM (Enhanced Configuration Address Mapping) format.
      * AKA mmcfg address
      * bit 20 - 28: bus number
      * bit 15 - 19: device number
      * bit 12 - 14: function number
      * bit  0 - 11: offset in configuration space of a given device
      */
      uint32_t addr = offset;
      uint16_t bus = (addr >> 20) & 0x1FF;
      uint8_t slot = (addr >> 15) & 0x1F;
      uint8_t function = (addr >> 12) & 0x7;
      PciDevice* pci = manager_->LookupPciDevice(bus, slot, function);
      if (pci) {
        pci->WritePciConfigSpace(addr & 0xFFF, data, size);
      } else {
        MV_ERROR("failed to lookup pci %x:%x.%x offset=0x%lx", bus, slot, function, offset);
      }
    } else {
      PciHost::Write(resource, offset, data, size);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    if (pcie_xbar_base_ && resource->base == pcie_xbar_base_) {
      uint32_t addr = offset;
      uint16_t bus = (addr >> 20) & 0x1FF;
      uint8_t slot = (addr >> 15) & 0x1F;
      uint8_t function = (addr >> 12) & 0x7;
      PciDevice* pci = manager_->LookupPciDevice(bus, slot, function);
      if (pci) {
        pci->ReadPciConfigSpace(addr & 0xFFF, data, size);
      } else {
        memset(data, 0xFF, size);
      }
    } else {
      PciHost::Read(resource, offset, data, size);
    }
  }

  void WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
    PciHost::WritePciConfigSpace(offset, data, length);

    if (ranges_overlap(offset, length, MCH_PCIE_XBAR, MCH_PCIE_XBAR_SIZE)) {
      MchUpdatePcieXBar();
    } else if (ranges_overlap(offset, length, 0x9D, 2)) {
      MV_PANIC("SMRAM not supported yet");
    }
  }

};

DECLARE_DEVICE(Q35Host);

```

`devices/superio/cmos.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <algorithm>
#include <cstring>
#include <ctime>

#include "device_manager.h"
#include "device_interface.h"
#include "logger.h"
#include "cmos.pb.h"
#include "machine.h"


#define RTC_BASE_ADDRESS 0x70

/*
 * MC146818 RTC registers
 * https://artax.karlin.mff.cuni.cz/~boham5bm/krypto/programy/Bochs-2.5.1/docs/development/cmos-map.html
 * https://bochs.sourceforge.io/techspec/CMOS-reference.txt
 * https://wiki.osdev.org/CMOS
 */
#define RTC_SECONDS               0x00
#define RTC_SECONDS_ALARM         0x01
#define RTC_MINUTES               0x02
#define RTC_MINUTES_ALARM         0x03
#define RTC_HOURS                 0x04
#define RTC_HOURS_ALARM           0x05
#define RTC_DAY_OF_WEEK           0x06
#define RTC_DAY_OF_MONTH          0x07
#define RTC_MONTH                 0x08
#define RTC_YEAR                  0x09
#define RTC_CENTURY               0x32
#define RTC_IBM_PS2_CENTURY_BYTE  0x37  // XP reads this

#define RTC_IRQ         8

#define RTC_REG_A       0x0A
#define RTC_REG_B       0x0B
#define RTC_REG_C       0x0C
#define RTC_REG_D       0x0D

#define REG_A_UIP       0x80 // Update in progress (0 = Date and time can be read, 1 = Time update in progress)

#define REG_B_SET       0x80 // Clock cycle update (0 = Update normally, 1 = Abort update in progress)
#define REG_B_PIE       0x40 // Periodic interrupt (0 = Disable interrupt (default), 1 = Enable interrupt)
#define REG_B_AIE       0x20 // Alarm interrupt (0 = Disable interrupt (default), 1 = Enable interrupt)
#define REG_B_UIE       0x10 // Update ended interrupt (0 = Disable interrupt (default), 1 = Enable interrupt)
#define REG_B_SQWE      0x08 // Status register A square wave frequency (0 = Disable square wave (default), 1 = Enable square wave)
#define REG_B_DM        0x04 // Data mode (0 = BCD, 1: Binary)
#define REG_B_24H       0x02 // 24 hour clock (0 = 24 hour mode (default), 1 = 12 hour mode)
#define REG_B_DSE       0x01 // Daylight savings enable (0 = Disable, 1 = Enable)

#define REG_C_IRQF      0x80 // Interrupt flag (1 when any or all of bits 6-4 are 1 and appropriate enables)
#define REG_C_PF        0x40 // Periodic interrupt flag
#define REG_C_AF        0x20 // Alarm interrupt flag
#define REG_C_UF        0x10 // Update ended interrupt flag
#define REG_C_MASK      0x70

#define REG_D_VALID_RAM 0x80 // Valid RAM - 1 indicates batery power good, 0 if dead or disconnected.


static inline unsigned char bin2bcd(unsigned val) {
  return ((val / 10) << 4) + val % 10;
}

static inline unsigned int bcd2bin(uint8_t val) {
	return ((val) & 0x0f) + ((val) >> 4) * 10;
}


class Cmos : public Device, public CmosDataInterface {
 private:
  bool      non_maskable_interrupt_disabled_;
  uint8_t   cmos_index_;
  uint8_t   cmos_data_[128];
  IoTimer*  rtc_timer_ = nullptr;
  bool      rtc_timer_warned_ = false;
  IoTimer*  guest_timer_ = nullptr;
  time_t    guest_time_ = 0;
  bool      use_utc_time_ = false;

 public:

  Cmos() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    AddIoResource(kIoResourceTypePio, RTC_BASE_ADDRESS, 2, "CMOS");

    bzero(cmos_data_, sizeof(cmos_data_));
  }

  void Connect() {
    Device::Connect();
    
    if (has_key("rtc") && std::get<std::string>(key_values_["rtc"]) == "gmtime") {
      use_utc_time_ = true;
    }
  
    /* Initialize guest time to host time or may be configured manually? */
    guest_time_ = time(nullptr);
  }

  void Disconnect() {
    DisableTimer(&rtc_timer_);
    DisableTimer(&guest_timer_);
    Device::Disconnect();
  }

  void DisableTimer(IoTimer** timer) {
    if (*timer) {
      RemoveTimer(*timer);
      *timer = nullptr;
    }
  }

  void Reset() {
    Device::Reset();
  
    DisableTimer(&rtc_timer_);
    DisableTimer(&guest_timer_);
    non_maskable_interrupt_disabled_ = false;
    cmos_index_ = 0;

    /* timer frequency = 32.768kHz, alarm frequency = 1.024Hz */
    cmos_data_[RTC_REG_A] = 0x26;
    /* 24 hour mode */
    cmos_data_[RTC_REG_B] = REG_B_24H;
    /* interrupt flags */
    cmos_data_[RTC_REG_C] = 0x00;
    /* battery power good */ 
    cmos_data_[RTC_REG_D] = REG_D_VALID_RAM;

    /* set number of processors */
    auto vcpu_count = manager_->machine()->num_vcpus();
    if (vcpu_count < 0x100) {
      cmos_data_[0x5F] = manager_->machine()->num_vcpus() - 1;
    }

    /* IBM equipment byte 1:fpu 2:ps2 3:vga */
    cmos_data_[0x14] = (1 << 1) | (1 << 2) | (1 << 3);

    EnableGuestTimer();
  }

  bool SaveState(MigrationWriter* writer) {
    /* force to update cmos from host time */
    SetGuestTimeToCmos();

    CmosState state;
    state.set_index(cmos_index_);
    state.set_data(cmos_data_, sizeof(cmos_data_));
    state.set_nmi_disabled(non_maskable_interrupt_disabled_);
    writer->WriteProtobuf("CMOS", state);
    return Device::SaveState(writer);
  } 

  bool LoadState(MigrationReader* reader) {
    if (!Device::LoadState(reader)) {
      return false;
    }
    CmosState state;
    if (!reader->ReadProtobuf("CMOS", state)) {
      return false;
    }
    non_maskable_interrupt_disabled_ = state.nmi_disabled();
    cmos_index_ = state.index();
    memcpy(cmos_data_, state.data().data(), sizeof(cmos_data_));

    /* get guest_time_ from cmos at first */
    GetGuestTimeFromCmos();
  
    UpdateRtcTimer();
    return true;
  }

  void EnableGuestTimer() {
    MV_ASSERT(!guest_timer_);
    guest_timer_ = AddTimer(NS_PER_SECOND, true, [this]() {
      /* To keep time, we either increase every second or synchronize the host time
       * This should be configurable */
      guest_time_++; 
    });
  }

  void GetGuestTimeFromCmos() {
    struct tm guest_tm = {0};
    guest_tm.tm_sec = bcd2bin(cmos_data_[RTC_SECONDS] & 0x7F);
    guest_tm.tm_min = bcd2bin(cmos_data_[RTC_MINUTES] & 0x7F);
    guest_tm.tm_hour = bcd2bin(cmos_data_[RTC_HOURS] & 0x3F);
    guest_tm.tm_mday = bcd2bin(cmos_data_[RTC_DAY_OF_MONTH] & 0x3F);
    guest_tm.tm_mon = bcd2bin(cmos_data_[RTC_MONTH] & 0x1F) - 1;
    guest_tm.tm_year = bcd2bin(cmos_data_[RTC_CENTURY]) * 100 + bcd2bin(cmos_data_[RTC_YEAR]) - 1900;
    guest_tm.tm_wday = bcd2bin(cmos_data_[RTC_DAY_OF_WEEK] & 0x07) - 1;
    guest_tm.tm_yday = 0;
    guest_tm.tm_isdst = 0;

    // FIXME: should check use_utc_time_ here
    guest_time_ = mktime(&guest_tm);
  }

  void SetGuestTimeToCmos() {
    struct tm tm;
    if (use_utc_time_) {
      gmtime_r(&guest_time_, &tm);
    } else {
      localtime_r(&guest_time_, &tm);
    }

    cmos_data_[RTC_SECONDS] = bin2bcd(tm.tm_sec);
    cmos_data_[RTC_MINUTES] = bin2bcd(tm.tm_min);
    cmos_data_[RTC_HOURS] = bin2bcd(tm.tm_hour);
    cmos_data_[RTC_DAY_OF_WEEK] = bin2bcd(tm.tm_wday + 1);
    cmos_data_[RTC_DAY_OF_MONTH] = bin2bcd(tm.tm_mday);
    cmos_data_[RTC_MONTH] = bin2bcd(tm.tm_mon + 1);

    int year = tm.tm_year + 1900;
    cmos_data_[RTC_YEAR] = bin2bcd(year % 100);
    cmos_data_[RTC_CENTURY] = bin2bcd(year / 100);
  }

  void PrintTicksPerSecond() {
    static time_t counter = 0, last_time =0;
    if (time(NULL) > last_time) {
      last_time = time(NULL);
      MV_LOG("ticks=%ld", counter);
      counter = 0;
    } else {
      counter++;
    }
  }

  void OnRtcTimer() {
    /* set RTC interrupt flag */
    cmos_data_[RTC_REG_C] |= REG_C_PF;
    /* check if RTC interrupt enabled */
    if (cmos_data_[RTC_REG_B] & REG_B_PIE) {
      /* set IRQ flag */
      if (!(cmos_data_[RTC_REG_C] & REG_C_IRQF)) {
        cmos_data_[RTC_REG_C] |= REG_C_IRQF;
        manager_->SetGsiLevel(RTC_IRQ, 1);
      }

      // PrintTicksPerSecond();
    }
  }

  void UpdateRtcTimer() {
    uint period_code = cmos_data_[RTC_REG_A] & 0xF;
    if (!period_code) {
      return;
    }
    if (period_code <= 2) {
      period_code += 7;
    }
    uint period = 1 << (period_code - 1);
    int64_t period_ns = NS_PER_SECOND * period / 32768; // use 32k Hz clock rate

    if (cmos_data_[RTC_REG_B] & REG_C_PF) {
      if (rtc_timer_ == nullptr) {
        rtc_timer_ = AddTimer(period_ns, true, std::bind(&Cmos::OnRtcTimer, this));
        // Try to warn user if OS switches to RTC timer
        if (!rtc_timer_warned_) {
          MV_LOG("The OS is using RTC timer which has performance problem!");
          rtc_timer_warned_ = true;
        }
      } else {
        ModifyTimer(rtc_timer_, period_ns);
      }
    } else {
      DisableTimer(&rtc_timer_);
    }
  }

  bool IsUpdateInProgress() {
    if (!guest_timer_) {
      return false;
    }
  
    /* fake UIP at last 1ms of every second */
    auto now = std::chrono::steady_clock::now();
    auto delta_ms = std::chrono::duration_cast<std::chrono::milliseconds>(guest_timer_->next_timepoint - now).count();
    if (delta_ms <= 1) {
      return true;
    }
    return false;
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_UNUSED(resource);
    MV_ASSERT(size == 1);

    if (offset == 0) {
      data[0] = 0xFF;
      return;
    }

    switch (cmos_index_) {
    case RTC_REG_A:
      data[0] = cmos_data_[cmos_index_];
      if (IsUpdateInProgress()) {
        data[0] |= REG_A_UIP;
      }
      break;
    case RTC_REG_C:
      manager_->SetGsiLevel(RTC_IRQ, 0);
      data[0] = cmos_data_[RTC_REG_C];
      cmos_data_[RTC_REG_C] = 0;
      break;
    case RTC_IBM_PS2_CENTURY_BYTE:
      cmos_index_ = RTC_CENTURY;
      /* fall through */
    case RTC_SECONDS:
    case RTC_MINUTES:
    case RTC_HOURS:
    case RTC_DAY_OF_WEEK:
    case RTC_DAY_OF_MONTH:
    case RTC_MONTH:
    case RTC_YEAR:
    case RTC_CENTURY:
      SetGuestTimeToCmos();
      /* fall through */
    case RTC_REG_B:
      data[0] = cmos_data_[cmos_index_];
      break;
    default:
      /* data memory */
      data[0] = cmos_data_[cmos_index_];
      break;
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_UNUSED(resource);
    MV_ASSERT(size == 1);
    uint8_t value = data[0];

    if (offset == 0) { /* index register */
      cmos_index_  = value & ~(1UL << 7);
      non_maskable_interrupt_disabled_ = value & (1UL << 7);
    } else { /* data register */
      uint8_t diff = cmos_data_[cmos_index_] ^ value;
      switch (cmos_index_) {
      case RTC_IBM_PS2_CENTURY_BYTE:
        cmos_index_ = RTC_CENTURY;
        /* fall through */
      case RTC_SECONDS:
      case RTC_MINUTES:
      case RTC_HOURS:
      case RTC_DAY_OF_WEEK:
      case RTC_DAY_OF_MONTH:
      case RTC_MONTH:
      case RTC_YEAR:
      case RTC_CENTURY:
        cmos_data_[cmos_index_] = value;
        /* only update guest_time_ when REG_B_SET is not set */
        if (!(cmos_data_[RTC_REG_B] & REG_B_SET)) {
          GetGuestTimeFromCmos();
        }
        break;
      case RTC_REG_A:
        /* bit 7 (update in progress) is readonly */
        cmos_data_[RTC_REG_A] = (value & ~REG_A_UIP) | (cmos_data_[RTC_REG_A] & REG_A_UIP);
        /* periodic code changed */
        if (diff & 0xF) {
          UpdateRtcTimer();
        }
        break;
      case RTC_REG_B:
        cmos_data_[RTC_REG_B] = value;

        /* check if enable or disable update timer */
        if (diff & REG_B_SET) {
          if (value & REG_B_SET) {
            /* update cmos data before stopping timer */
            SetGuestTimeToCmos();
            DisableTimer(&guest_timer_);
            /* reset update flags */
            cmos_data_[RTC_REG_A] &= ~REG_A_UIP;
            cmos_data_[RTC_REG_B] &= ~REG_B_UIE;
          } else {
            /* update guset_time_ before starting timer */
            GetGuestTimeFromCmos();
            EnableGuestTimer();
          }
        }

        /* check if RTC interrupt is toggled */
        if (diff & REG_B_PIE) {
          UpdateRtcTimer();
        }
        if (diff & REG_B_AIE) {
          MV_PANIC("alarm is not implemented");
        }
        if (diff & REG_B_UIE) {
          MV_PANIC("update-ended interrupt is not implemented");
        }
        break;
      case RTC_REG_C:
      case RTC_REG_D:
        /* Read-only */
        break;
      default:
        cmos_data_[cmos_index_] = value;
        break;
      }
    }
  }

  void SetData(uint8_t index, uint8_t data) {
    MV_ASSERT(index < 128);
    cmos_data_[index] = data;
  }
};

DECLARE_DEVICE(Cmos);

```

`devices/superio/cmos.proto`:

```proto
syntax = "proto3";

message CmosState {
  uint32  index         = 1;
  bytes   data          = 2;
  bool    nmi_disabled  = 3;
}

```

`devices/superio/debug_console.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "device.h"
#include "machine.h"

class DebugConsole : public Device {
 public:
  DebugConsole() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    AddIoResource(kIoResourceTypePio, 0x402, 1, "SeaBIOS Output");
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_UNUSED(resource);
    MV_UNUSED(offset);
    MV_UNUSED(size);
    if (manager_->machine()->debug()) {
      putchar(*data);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_UNUSED(resource);
    MV_UNUSED(offset);
    MV_UNUSED(size);
    *data = 0xe9;
  }

};

DECLARE_DEVICE(DebugConsole);

```

`devices/superio/dummy.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include "logger.h"
#include "device.h"
#include "machine.h"

/* All IO devices not implemented, put them here to ignore IO access */
class DummyDevice : public Device {
 public:
  DummyDevice() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    /* Legacy ioport setup */

    /* PORT 0x0020-0x003F - 8259A PIC 1 */
    AddIoResource(kIoResourceTypePio, 0x0020, 2, "PIC 1");

    /* PORT 0040-005F - PIT - PROGRAMMABLE INTERVAL TIMER (8253, 8254) */
    AddIoResource(kIoResourceTypePio, 0x0040, 4, "PIT");

    /* PORT 0x00A0-0x00AF - 8259A PIC 2 */
    AddIoResource(kIoResourceTypePio, 0x00A0, 2, "PIC 2");

    /* PORT 00ED */
    AddIoResource(kIoResourceTypePio, 0x00ED, 1, "IO Delay");

    /* PORT 00F0-00FF - Math co-processor */
    AddIoResource(kIoResourceTypePio, 0x00F0, 2, "Math Processor");
    
    /* Game port (joystick) */
    AddIoResource(kIoResourceTypePio, 0x0200, 8, "Joystick");

    /* PORT 0278-027A - PARALLEL PRINTER PORT (usually LPT1, sometimes LPT2) */
    AddIoResource(kIoResourceTypePio, 0x0278, 3, "Parallel LPT1");

    /* PORT 02F2 DOS access this port */
    AddIoResource(kIoResourceTypePio, 0x02F2, 6, "PMC for Susi");

    /* PORT 0378-037A - PARALLEL PRINTER PORT (usually LPT2, sometimes LPT3) */
    AddIoResource(kIoResourceTypePio, 0x0378, 3, "Parallel LPT2");

    /* PORT 06F2 DOS access this port */
    AddIoResource(kIoResourceTypePio, 0x06F2, 8, "Unknown");
    
    /* PORT A20-A24 IBM Token Ring */
    AddIoResource(kIoResourceTypePio, 0x0A20, 5, "IBM Token Ring");
    
    /* PORT A79 Microsoft PnP */
    AddIoResource(kIoResourceTypePio, 0x0A79, 1, "Plug-N-Play");

    /* HPET MMIO */
    AddIoResource(kIoResourceTypeMmio, 0xFED00000, 0x400, "HPET");
  }

  void Connect() {
    Device::Connect();

    /* IDE Ports */
    if (!manager_->machine()->LookupObjectByClass("Piix3Ide")) {
      AddIoResource(kIoResourceTypePio, 0x01F0, 8, "IDE Primary");
      AddIoResource(kIoResourceTypePio, 0x0170, 8, "IDE Secondary");
      AddIoResource(kIoResourceTypePio, 0x01E8, 8, "IDE Tertiary");
      AddIoResource(kIoResourceTypePio, 0x0168, 8, "IDE Quaternary");
      AddIoResource(kIoResourceTypePio, 0x03F6, 1, "IDE Primary Control");
      AddIoResource(kIoResourceTypePio, 0x0376, 1, "IDE Secondary Control");
    }

    /* ISA DMA Ports */
    if (!manager_->machine()->LookupObjectByClass("I8257Dma")) {
      AddIoResource(kIoResourceTypePio, 0x0000, 0x10, "DMA Controller 1");
      AddIoResource(kIoResourceTypePio, 0x00C0, 0x20, "DMA Controller 2");
      AddIoResource(kIoResourceTypePio, 0x0080, 0x10, "DMA Page");
    }

    /* ISA Floppy */
    if (!manager_->machine()->LookupObjectByClass("I82078Fdc")) {
      AddIoResource(kIoResourceTypePio, 0x3F0, 6, "Floppy");
      AddIoResource(kIoResourceTypePio, 0x3F7, 1, "Floppy Control");
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    // Do nothing
    if (resource->base == 0x00ED) {
      /* IO Delay */
      return;
    }
    if (manager_->machine()->debug()) {
      MV_LOG("%s ignore %s write base=0x%lx offset=0x%lx data=0x%lx size=%d",
        resource->type == kIoResourceTypeMmio ? "MMIO" : "PIO",
        resource->name, resource->base, offset, *(uint64_t*)data, size);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    // Do nothing
    if (manager_->machine()->debug()) {
      MV_LOG("%s ignore %s read base=0x%lx offset=0x%lx size=%d",
        resource->type == kIoResourceTypeMmio ? "MMIO" : "PIO",
        resource->name, resource->base, offset, size);
    }
    if (resource->type == kIoResourceTypePio) {
      memset(data, 0xFF, size);
    } else {
      memset(data, 0x00, size);
    }
  }

};

DECLARE_DEVICE(DummyDevice);

```

`devices/superio/floppy.cc`:

```cc
/* 
 * MVisor Floppy Disk
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#include "floppy.h"

Floppy::Floppy() {
  set_default_parent_class("I82078Fdc");
}

void Floppy::Connect() {
  Device::Connect();

  /* Connect to backend image */
  bool readonly = has_key("readonly") && std::get<bool>(key_values_["readonly"]);
  bool snapshot = has_key("snapshot") && std::get<bool>(key_values_["snapshot"]);
  if (has_key("image")) {
    auto path = std::get<std::string>(key_values_["image"]);
    image_ = DiskImage::Create(this, path, readonly, snapshot);
  }
}

void Floppy::Disconnect() {
  if (image_) {
    delete image_;
    image_ = nullptr;
  }
  Device::Disconnect();
}

void Floppy::Reset() {
  Device::Reset();

  perpendicular_ = 0;
  cylinder_ = 0;
  head_ = 0;
  sector_ = 1;
  sectors_per_cylinder_ = 18;
}

void Floppy::Seek(uint8_t cylinder, uint8_t head, uint8_t sector) {
  cylinder_ = cylinder;
  head_ = head;
  sector_ = sector;
}

uint Floppy::GetLba() {
  uint lba = (2 * cylinder_ + head_) * sectors_per_cylinder_ + sector_ - 1;
  return lba;
}

void Floppy::SetLba(uint lba) {
  cylinder_ = lba / (2 * sectors_per_cylinder_);
  head_ = (lba % (2 * sectors_per_cylinder_)) / sectors_per_cylinder_;
  sector_ = (lba % (2 * sectors_per_cylinder_)) % sectors_per_cylinder_ + 1;
}

DECLARE_DEVICE(Floppy);

```

`devices/superio/floppy.h`:

```h
/* 
 * MVisor Floppy Disk
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_FLOPPY_DISK_H
#define _MVISOR_DEVICES_FLOPPY_DISK_H

#include "disk_image.h"
#include "device.h"

class Floppy : public Device {
 private:
  DiskImage*  image_ = nullptr;
  uint8_t     perpendicular_;
  uint8_t     cylinder_;
  uint8_t     head_;
  uint8_t     sector_;
  uint8_t     sectors_per_cylinder_;

 public:
  Floppy();
  void Connect();
  void Disconnect();
  void Reset();

  void Seek(uint8_t cylinder, uint8_t head, uint8_t sector);
  uint GetLba();
  void SetLba(uint lba);

  void set_perpendicular(uint8_t perpendicular) { perpendicular_ = perpendicular; }
  void set_head(uint8_t head) { head_ = head; }

  inline DiskImage*   image() { return image_; }
  inline uint8_t      sectors_per_cylinder() { return sectors_per_cylinder_; }
  inline uint8_t      perpendicular() { return perpendicular_; }
  inline uint8_t      cylinder() { return cylinder_; }
  inline uint8_t      head() { return head_; }
  inline uint8_t      sector() { return sector_; }
};

#endif // _MVISOR_DEVICES_FLOPPY_DISK_H


```

`devices/superio/i82078_fdc.cc`:

```cc
/* 
 * MVisor Intel 82078
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * Reference: https://wiki.osdev.org/Floppy_Disk_Controller
 *            https://www.isdaman.com/alsos/hardware/fdc/floppy.htm
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <deque>

#include "device.h"
#include "floppy.h"
#include "i8257_dma.h"
#include "i82078_fdc.pb.h"
#include "device_manager.h"
#include "device_interface.h"


#define REG_STATUS_A        0x3F0
#define REG_STATUS_B        0x3F1
#define REG_DIGITAL_OUTPUT  0x3F2
#define REG_TAPE_DRIVE      0x3F3
#define REG_MAIN_STATUS     0x3F4
#define REG_DATARATE_SELECT 0x3F4
#define REG_DATA_FIFO       0x3F5
#define REG_DIGITAL_INPUT   0x3F7
#define REG_CONFIG_CONTROL  0x3F7

#define DOR_RESET           (1<<2)
#define DOR_IRQ             (1<<3)
#define DOR_MOTOR0          (1<<4)

#define MSR_READY           (1<<7)
#define MSR_DIO             (1<<6)
#define MSR_NO_DMA          (1<<5)
#define MSR_COMMAND_BUSY    (1<<4)

#define SR0_HEAD            0x04
#define SR0_SEEK            0x20
#define SR0_READY_CHANGED   0xC0

#define SECTOR_SIZE         512


class I82078Fdc : public Device {
 private:
  uint8_t             digital_output_;
  uint8_t             main_status_;
  uint8_t             datarate_select_;
  uint8_t             error_status_[4];
  uint8_t             step_rate_;
  uint8_t             head_load_time_;
  uint8_t             lock_;
  uint8_t             reset_sense_remained_;
  uint8_t             config_;
  std::deque<uint8_t> fifo_;
  I8257Dma*           isa_dma_;
  Floppy*             drives_[2] = {0};
  uint8_t             drive_index_;

 public:
  I82078Fdc() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    AddIoResource(kIoResourceTypePio, 0x3F0, 6, "Floppy");
    AddIoResource(kIoResourceTypePio, 0x3F7, 1, "Floppy Control");
  }

  void Connect() {
    Device::Connect();

    isa_dma_ = dynamic_cast<I8257Dma*>(manager_->LookupDeviceByClass("I8257Dma"));
    if (isa_dma_ == nullptr) {
      MV_PANIC("Floppy controller without ISA DMA is not implemented yet");
    }


    auto cmos = dynamic_cast<CmosDataInterface*>(manager_->LookupDeviceByClass("Cmos"));
    if (cmos) {
      uint8_t value = 0;
      for (size_t i = 0; i < children_.size() && i < 2; i++) {
        drives_[i] = dynamic_cast<Floppy*>(children_[i]);
        if (drives_[i]) {
          // Type 4 - 1.44MB, 3.5" - 2 heads, 80 tracks, 18 sectors
          value |= i == 0 ? 0x40 : 0x04;
        }
      }
      cmos->SetData(0x10, value);
    }
  }

  void Reset() {
    Device::Reset();

    main_status_ = MSR_READY;
    digital_output_ = 0;
    datarate_select_ = 0;
    drive_index_ = 0;
    step_rate_ = head_load_time_ = 0;
    lock_ = 0;
    config_ = 0;
    reset_sense_remained_ = 0;
    error_status_[0] = 0;
    error_status_[1] = 0;
    error_status_[2] = 0;
    error_status_[3] = 0;

    for (int i = 0; i < 2; i++) {
      if (drives_[i]) {
        drives_[i]->Reset();
      }
    }
    fifo_.clear();

    SetIrqLevel(0);
  }


  bool SaveState(MigrationWriter* writer) {
    I82078FdcState state;
    
    state.set_digital_output(digital_output_);
    state.set_main_status(main_status_);
    state.set_datarate_select(datarate_select_);
    state.set_error_status_0(error_status_[0]);
    state.set_config(config_);
    state.set_step_rate(step_rate_);
    state.set_head_load_time(head_load_time_);
    state.set_lock(lock_);
    state.set_drive_index(drive_index_);

    std::string fifo(fifo_.begin(), fifo_.end());
    state.set_fifo(fifo);

    for (auto i = 0; i < 2; i++) {
      if (drives_[i]) {
        auto pd = state.add_drives();
        pd->set_cylinder(drives_[i]->cylinder());
        pd->set_head(drives_[i]->head());
        pd->set_sector(drives_[i]->sector());
        pd->set_perpendicular(drives_[i]->perpendicular());
      }
    }

    writer->WriteProtobuf("FDC", state);
    return Device::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!Device::LoadState(reader)) {
      return false;
    }

    I82078FdcState state;
    if (!reader->ReadProtobuf("FDC", state)) {
      return false;
    }

    digital_output_ = state.digital_output();
    main_status_ = state.main_status();
    datarate_select_ = state.datarate_select();
    error_status_[0] = state.error_status_0();
    config_ = state.config();
    step_rate_ = state.step_rate();
    head_load_time_ = state.head_load_time();
    lock_ = state.lock();
    drive_index_ = state.drive_index();

    fifo_.clear();
    for (auto c : state.fifo()) {
      fifo_.push_back(c);
    }

    for (auto i = 0; i < state.drives_size() && i < 2; i++) {
      if (drives_[i]) {
        auto& d = state.drives(i);
        drives_[i]->set_perpendicular(d.perpendicular());
        drives_[i]->Seek(d.cylinder(), d.head(), d.sector());
      }
    }
    return true;
  }

  void SetIrqLevel(uint level) {
    manager_->SetGsiLevel(6, level);
    if (level == 0) {
      error_status_[0] = 0;
    }
  }

  void SenseDriveStatus() {
    auto drive_index = fifo_[1] & 3;
    auto drive = drives_[drive_index];
    auto head = (fifo_[1] >> 2) & 1;

    error_status_[3] = (1 << 5) | (1 << 3) | (head << 2) | drive_index;
    if (drive->image()->readonly()) {
      error_status_[3] |= 1 << 6;
    }
    if (drive->cylinder() == 0) {
      error_status_[3] |= 1 << 4;
    }

    fifo_.clear();
    fifo_.push_back(error_status_[3]);
    main_status_ |= MSR_DIO;
  }

  void SenseInterrupt() {
    auto drive = drives_[drive_index_];
    fifo_.clear();
    if (reset_sense_remained_ > 0) {
      fifo_.push_back(SR0_READY_CHANGED | (4 - reset_sense_remained_));
      reset_sense_remained_--;
    } else {
      fifo_.push_back(error_status_[0]);
    }
    fifo_.push_back(drive ? drive->cylinder(): 0);

    main_status_ |= MSR_DIO;
    SetIrqLevel(0);
    error_status_[0] = SR0_READY_CHANGED;
  }

  void Lock() {
    lock_ = (fifo_[0] & 0x80) ? 1 : 0;
    fifo_.clear();

    fifo_.push_back(lock_ << 4);

    main_status_ |= MSR_DIO;
  }

  void DumpRegisters() {
    auto drive = drives_[drive_index_];
    fifo_.clear();

    /* Drive positions */
    fifo_.push_back(drives_[0] ? drives_[0]->cylinder() : 0);
    fifo_.push_back(drives_[1] ? drives_[1]->cylinder() : 0);
    fifo_.push_back(0);
    fifo_.push_back(0);

    /* Timers */
    fifo_.push_back(step_rate_);
    fifo_.push_back(head_load_time_ << 1);
    fifo_.push_back(drive->sectors_per_cylinder());
    fifo_.push_back((lock_ << 7) | drive->perpendicular() << 2);
    fifo_.push_back(config_);
    fifo_.push_back(0);

    main_status_ |= MSR_DIO;
  }

  void Recalibrate() {
    drive_index_ = fifo_[1] & 3;
    auto drive = drives_[drive_index_];

    drive->Seek(0, 0, 1);
    fifo_.clear();

    error_status_[0] |= SR0_SEEK;
    main_status_ = MSR_READY;
    SetIrqLevel(1);
  }

  void Seek() {
    drive_index_ = fifo_[1] & 3;
    auto drive = drives_[drive_index_];

    drive->Seek(fifo_[2], (fifo_[1] >> 2) & 1, 1);
    fifo_.clear();

    error_status_[0] |= SR0_SEEK;
    main_status_ = MSR_READY;
    SetIrqLevel(1);
  }

  void StopTransfer() {
    auto drive = drives_[drive_index_];
    error_status_[0] &= ~7;
    error_status_[0] |= SR0_SEEK;
    error_status_[0] |= drive_index_;
    error_status_[0] |= drive->head() ? SR0_HEAD : 0;
    fifo_.push_back(error_status_[0]);
    fifo_.push_back(error_status_[1]);
    fifo_.push_back(error_status_[2]);
    fifo_.push_back(drive->cylinder());
    fifo_.push_back(drive->head());
    fifo_.push_back(drive->sector());
    fifo_.push_back(2);

    main_status_ |= MSR_READY | MSR_DIO;
    SetIrqLevel(1);
  }

  void ReadId() {
    drive_index_ = fifo_[1] & 3;
    auto drive = drives_[drive_index_];

    drive->set_head((fifo_[1] >> 2) & 1);
    fifo_.clear();

    StopTransfer();
  }

  void ReadWriteSector() {
    bool multi_track = fifo_[0] & 0x80;
    bool is_write = !(fifo_[0] & 2);
    drive_index_ = fifo_[1] & 3;
    auto drive = drives_[drive_index_];
  
    drive->Seek(fifo_[2], fifo_[3], fifo_[4]);
    
    auto count = fifo_[6];
    fifo_.clear();
    
    main_status_ &= ~MSR_READY;
    // read sector means write to dma buffer
    isa_dma_->WaitForChannel(!is_write, 2, [=](auto iov) {
      size_t bytes = count * SECTOR_SIZE;
      auto lba = drive->GetLba();
      auto image = drive->image();
      auto request = ImageIoRequest {
        .type = is_write ? kImageIoWrite : kImageIoRead,
        .position = lba * SECTOR_SIZE,
        .length = std::min(bytes, iov.iov_len),
      };
      request.vector.push_back(iov);

      image->QueueIoRequest(request, [this, drive, multi_track, is_write, lba, iov](auto ret) {
        if (ret < 0) {
          MV_PANIC("not implemented IO error");
          return;
        }

        if (multi_track) {
          drive->SetLba(lba + (ret / SECTOR_SIZE));
        } else {
          drive->Seek(drive->cylinder() + 1, drive->head(), 1);
        }
        StopTransfer();
      });
    });
  }

  void FormatTrack() {
    uint drive_index = fifo_[1] & 3;
    auto drive = drives_[drive_index];

    auto fill_byte = fifo_[5];
    auto count = fifo_[3];
    fifo_.clear();
    
    main_status_ &= ~MSR_READY;
    isa_dma_->WaitForChannel(false, 2, [=](auto iov) {
      MV_ASSERT(iov.iov_len >= count * 4);
      uint8_t buffer[SECTOR_SIZE];
      memset(buffer, fill_byte, SECTOR_SIZE);

      std::vector<ImageIoRequest> requests;

      auto image = drive->image();
      auto ptr = (uint8_t*)iov.iov_base;
      for (auto i = 0; i < count; i++) {
        drive->Seek(ptr[i * 4 + 0], ptr[i * 4 + 1], ptr[i * 4 + 2]);

        auto request = ImageIoRequest {
          .type = kImageIoWrite,
          .position = drive->GetLba() * SECTOR_SIZE,
          .length = SECTOR_SIZE,
        };
        request.vector.push_back(iovec {
          .iov_base = buffer,
          .iov_len = SECTOR_SIZE
        });
        requests.push_back(request);
      }


      image->QueueMultipleIoRequests(requests, [this, drive](auto ret) {
        if (ret < 0) {
          MV_PANIC("not implemented IO error");
          return;
        }

        drive->Seek(drive->cylinder() + 1, drive->head(), 1);
        StopTransfer();
      });
    });
  }

  void CheckCommand() {
    auto cmd = fifo_[0];
    auto length = fifo_.size();

    switch (cmd)
    {
    case 0x03:  // Specify
      if (length >= 3) {
        /* Step rate time, Head load time, Head unload time */
        step_rate_ = (fifo_[1] >> 4) & 0xF;
        head_load_time_ = fifo_[2] >> 1;
        fifo_.clear();
        main_status_ = MSR_READY;
      }
      break;
    case 0x04:  // Sense Drive Status
      if (length >= 2) {
        SenseDriveStatus();
      }
      break;
    case 0x45:  // Write Sector Without Multi-track
    case 0x46:  // Read Sector Without Multi-track
    case 0xC5:  // Write Sector
    case 0xE6:  // Read Sector
      if (length >= 9) {
        ReadWriteSector();
      }
      break;
    case 0x4d:  // Format Track Without Multi-track
    case 0xEd:  // Format Track
      if (length >= 6) {
        FormatTrack();
      }
      break;
    case 0x07:  // Recalibrate
      if (length >= 2) {
        Recalibrate();
      }
      break;
    case 0x08:  // Sense Interrupt Status
      SenseInterrupt();
      break;
    case 0x12:  // Perpendicular Mode
      if (length >= 2) {
        if (fifo_[1] & 0x80) {
          if (drives_[drive_index_]) {
            drives_[drive_index_]->set_perpendicular(fifo_[1] & 7);
          }
        }
        fifo_.clear();
        main_status_ = MSR_READY;
      }
      break;
    case 0x13:  // Configure
      if (length >= 4) {
        config_ = fifo_[2];
        fifo_.clear();
        main_status_ = MSR_READY;
      }
      break;
    case 0x14:  // Lock And Unlock
    case 0x94:
      Lock();
      break;
    case 0x18:  // Part ID
      fifo_.clear();
      fifo_.push_back(0x41);
      main_status_ |= MSR_DIO;
      break;
    case 0x0A:  // Read ID
    case 0x4A:
      if (length >= 2) {
        ReadId();
      }
      break;
    case 0x0E:  // Dump Registers
      DumpRegisters();
      break;
    case 0x0F:  // Seek
      if (length >= 3) {
        Seek();
      }
      break;
    case 0x10:  // Version
      fifo_.clear();
      fifo_.push_back(0x90);
      main_status_ |= MSR_DIO;
      break;
    default:
      MV_PANIC("unimplemented FIFO command 0x%x", cmd);
    }
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    auto port = resource->base + offset;
    auto value = data[0];

    if (debug_) {
      MV_LOG("write FDC 0x%x value=0x%x", port, value);
    }

    switch (port)
    {
    case REG_DIGITAL_OUTPUT:
      if ((value & DOR_RESET) && !(digital_output_ & DOR_RESET)) {
        Reset();
        reset_sense_remained_ = 4;
        /* Set interrupt code to 3: abnormal termination */
        error_status_[0] = SR0_READY_CHANGED;
        SetIrqLevel(1);
      }
      digital_output_ = value;
      drive_index_ = value & 3;
      break;
    case REG_DATA_FIFO:
      main_status_ |= MSR_COMMAND_BUSY;
      fifo_.push_back(value);
      CheckCommand();
      break;
    case REG_DATARATE_SELECT:
      if (value & 0x80) { // Soft Reset ??
        Reset();
        reset_sense_remained_ = 4;
        /* Set interrupt code to 3: abnormal termination */
        error_status_[0] = SR0_READY_CHANGED;
        SetIrqLevel(1);
      }
      datarate_select_ = value;
      break;
    case REG_CONFIG_CONTROL:
      datarate_select_ = (datarate_select_ & ~3) | (value & 3);
      break;
    default:
      Device::Write(resource, offset, data, size);
    }
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    auto port = resource->base + offset;

    switch (port)
    {
    case REG_MAIN_STATUS:
      data[0] = main_status_;
      break;
    case REG_DATA_FIFO:
      if (!fifo_.empty()) {
        data[0] = fifo_.front();
        fifo_.pop_front();
      }
      if (fifo_.empty()) {
        main_status_ = MSR_READY;
        SetIrqLevel(0);
      }
      break;
    case REG_DIGITAL_INPUT:
      /* Or 0x80 if disk media changed */
      data[0] = 0x78;
      break;
    default:
      Device::Read(resource, offset, data, size);
    }

    if (debug_) {
      MV_LOG("read FDC 0x%x value=0x%x", port, data[0]);
    }
  }

};


DECLARE_DEVICE(I82078Fdc);

```

`devices/superio/i82078_fdc.proto`:

```proto
syntax = "proto3";

message I82078FdcState {
  message FloppyDrive {   
    uint32  cylinder            = 1;
    uint32  head                = 2;
    uint32  sector              = 3;
    uint32  perpendicular       = 4;
  }   

  uint32    digital_output      = 1;
  uint32    main_status         = 2;
  uint32    datarate_select     = 3;
  uint32    error_status_0      = 4;

  uint32    step_rate           = 8;
  uint32    head_load_time      = 9;
  uint32    lock                = 10;
  uint32    config              = 11;
  bytes     fifo                = 12;

  repeated  FloppyDrive drives  = 13;
  uint32    drive_index         = 14;
}

```

`devices/superio/i8257_dma.cc`:

```cc
/* 
 * MVisor Intel 8257 DMA
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * Reference: https://wiki.osdev.org/ISA_DMA
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "i8257_dma.h"
#include "i8257_dma.pb.h"
#include "logger.h"
#include "device_manager.h"


I8257Dma::I8257Dma() {
  set_default_parent_class("Ich9Lpc", "Piix3");

  AddIoResource(kIoResourceTypePio, 0x00, 0x10, "DMA Controller 1");
  AddIoResource(kIoResourceTypePio, 0xC0, 0x20, "DMA Controller 2");
  AddIoResource(kIoResourceTypePio, 0x80, 0x10, "DMA Page");
}

void I8257Dma::Reset() {
  Device::Reset();
  bzero(&controllers_, sizeof(controllers_));
}

bool I8257Dma::SaveState(MigrationWriter* writer) {
  I8257DmaState state;
  
  for (auto& c: controllers_) {
    auto pc = state.add_controllers();
    pc->set_mask(c.mask);
    pc->set_flip_flop(c.flip_flop);
    for (auto i = 0; i < 4; i++) {
      auto& ch = c.channels[i];
      auto pch = pc->add_channels();
      pch->set_base((ch.base[1] << 8) | ch.base[0]);
      pch->set_count((ch.count[1] << 8) | ch.count[0]);
      pch->set_page(ch.page);
      pch->set_mode(ch.mode);
    }
  }

  writer->WriteProtobuf("DMA", state);
  return Device::SaveState(writer);
}

bool I8257Dma::LoadState(MigrationReader* reader) {
  if (!Device::LoadState(reader)) {
    return false;
  }

  I8257DmaState state;
  if (!reader->ReadProtobuf("DMA", state)) {
    return false;
  }

  for (auto i = 0; i < state.controllers_size() && i < 2; i++) {
    auto& c = controllers_[i];
    auto& d = state.controllers(i);
    c.mask = d.mask();
    c.flip_flop = d.flip_flop();
    for (auto j = 0; j < d.channels_size() && j < 4; j++) {
      auto& ch = c.channels[j];
      auto& dh = d.channels(j);
      ch.base[0] = dh.base() & 0xFF;
      ch.base[1] = (dh.base() >> 8) & 0xFF;
      ch.count[0] = dh.count() & 0xFF;
      ch.count[1] = (dh.count() >> 8) & 0xFF;
      ch.page = dh.page();
      ch.mode = dh.mode();
    }
  }
  return true;
}

uint8_t I8257Dma::ReadDmaControl(uint controller_index, uint64_t offset) {
  auto controller = &controllers_[controller_index];
  uint8_t ret = 0;

  switch (offset)
  {
  default:
    MV_PANIC("read controller=%x off=%x data=%x",
      controller_index, offset, ret);
  }

  MV_UNUSED(controller);
  return ret;
}

void I8257Dma::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0x00) {
    data[0] = ReadDmaControl(0, offset);
  } else if (resource->base == 0xC0) {
    data[0] = ReadDmaControl(1, offset / 2);
  } else if (resource->base == 0x80) {
    ReadWriteDmaPage(offset, data, false);
  } else {
    Device::Read(resource, offset, data, size);
  }
}

void I8257Dma::WriteDmaControl(uint controller_index, uint64_t offset, uint8_t value) {
  auto controller = &controllers_[controller_index];

  switch (offset)
  {
  case 0x00:
  case 0x02:
  case 0x04:
  case 0x06: {  // Start Address
    uint channel_index = offset / 2;
    controller->channels[channel_index].base[controller->flip_flop++ & 1] = value;
    break;
  }
  case 0x01:
  case 0x03:
  case 0x05:
  case 0x07: {  // Count
    uint channel_index = offset / 2;
    controller->channels[channel_index].count[controller->flip_flop++ & 1] = value;
    break;
  }
  case 0x0A: {  // Single Mask
    if (value & 4) {
      controller->mask |= 1 << (value & 3);
    } else {
      controller->mask &= ~(1 << (value & 3));
    }
    break;
  }
  case 0x0B: {  // Mode
    uint channel_index = value & 3;
    controller->channels[channel_index].mode = value;
    break;
  }
  case 0x0C:  // Clear Flip Flop
    controller->flip_flop = 0;
    break;
  case 0x0D:  // Reset
    bzero(controller, sizeof(*controller));
    break;
  default:
    MV_PANIC("write controller=%x off=%x data=%x",
      controller_index, offset, value);
  }
}

void I8257Dma::ReadWriteDmaPage(uint64_t offset, uint8_t* data, bool is_write) {
  I8257DmaChannel* channel = nullptr;
  switch (offset)
  {
  case 0x3:
    channel = &controllers_[0].channels[1];
    break;
  case 0x1:
    channel = &controllers_[0].channels[2];
    break;
  case 0x2:
    channel = &controllers_[0].channels[3];
    break;
  case 0xB:
    channel = &controllers_[1].channels[1];
    break;
  case 0x9:
    channel = &controllers_[1].channels[2];
    break;
  case 0xA:
    channel = &controllers_[1].channels[3];
    break;
  default:
    if (debug_) {
      MV_WARN("invalid RW page offset=0x%lx", offset);
    }
  }

  if (channel) {
    if (is_write) {
      channel->page = data[0];
    } else {
      data[0] = channel->page;
    }
  }
}

void I8257Dma::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == 0x00) {
    WriteDmaControl(0, offset, data[0]);
  } else if (resource->base == 0xC0) {
    WriteDmaControl(1, offset / 2, data[0]);
  } else if (resource->base == 0x80) {
    ReadWriteDmaPage(offset, data, true);
  } else {
    Device::Write(resource, offset, data, size);
  }
}

void I8257Dma::WaitForChannel(bool is_write, uint channel_id, BufferCallback callback) {
  MV_ASSERT(channel_id < 8);

  uint controller_index = channel_id / 4;
  uint channel_index = channel_id % 5;
  auto channel = &controllers_[controller_index].channels[channel_index];
  
  uint64_t gpa = (channel->page << 16) | (channel->base[1] << 8) | (channel->base[0]);
  uint64_t count = (channel->count[1] << 8) | (channel->count[0]);
  if (debug_) {
    MV_LOG("dma address gpa=%lx count=%lx", gpa, count);
  }
  
  auto iov = iovec {
    .iov_base = manager_->TranslateGuestMemory(gpa),
    .iov_len = count + 1
  };

  if (is_write) {
    manager_->AddDirtyMemory(gpa, iov.iov_len);   
  }
  callback(iov);
}

DECLARE_DEVICE(I8257Dma);

```

`devices/superio/i8257_dma.h`:

```h
/* 
 * MVisor Intel 8257 DMA
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_I8257_DMA_H
#define _MVISOR_DEVICES_I8257_DMA_H

#include <functional>
#include "device.h"

struct I8257DmaChannel {
  uint8_t mode;
  uint8_t base[2];
  uint8_t count[2];
  uint8_t page;
};

struct I8257DmaController {
  uint8_t         mask;
  uint8_t         flip_flop;
  I8257DmaChannel channels[4];
};

typedef std::function<void(iovec iov)> BufferCallback;

class I8257Dma : public Device {
 private:
  I8257DmaController  controllers_[2];

  uint8_t ReadDmaControl(uint controller_index, uint64_t offset);
  void WriteDmaControl(uint controller_index, uint64_t offset, uint8_t value);
  void ReadWriteDmaPage(uint64_t offset, uint8_t* data, bool is_write);

 public:
  I8257Dma();
  void Reset();
  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);
  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);

  void WaitForChannel(bool is_write, uint channel_id, BufferCallback callback);
};

#endif // _MVISOR_DEVICES_I8257_DMA_H

```

`devices/superio/i8257_dma.proto`:

```proto
syntax = "proto3";

message I8257DmaState {
  message I8257DmaChannel {
    uint32  base    = 1;
    uint32  count   = 2;
    uint32  page    = 3;
    uint32  mode    = 4;
  }

  message I8257DmaController {
    repeated  I8257DmaChannel channels    = 1;
    uint32                    mask        = 2;
    uint32                    flip_flop   = 3;
  }

  repeated I8257DmaController controllers = 1;
}

```

`devices/superio/meson.build`:

```build
mvisor_sources += files(
  'cmos.cc',
  'debug_console.cc',
  'dummy.cc',
  'floppy.cc',
  'i8257_dma.cc',
  'i82078_fdc.cc',
  'ps2.cc',
  'uart.cc'
)

proto_sources += proto_gen.process(
  'cmos.proto',
  'i8257_dma.proto',
  'i82078_fdc.proto',
  'ps2.proto'
)

```

`devices/superio/ps2.cc`:

```cc
/* 
 * MVisor I8042 PS/2
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include <mutex>
#include "logger.h"
#include "device_manager.h"
#include "machine.h"
#include "device_interface.h"
#include "ps2.pb.h"

#define STATUS_OFULL    0x01
#define STATUS_SYSFLAG  0x04
#define STATUS_COMMAND  0x08
#define STATUS_KEYLOCK  0x10
#define STATUS_AUXDATA  0x20
#define STATUS_TIMEOUT  0x40

#define MODE_KBD_INTERRUPT  0x01
#define MODE_AUX_INTERRUPT  0x02
#define MODE_KBD_DISABLED   0x10
#define MODE_AUX_DISABLED   0x20

#define OUTPORT_RESET   0x01
#define OUTPORT_A20     0x02
#define OUTPORT_OFULL   0x10
#define OUTPORT_AUXDATA 0x20
#define OUTPORT_CC      0xCC

#define RESPONSE_ACK 0xFA

#define KEYBOARD_IRQ 1
#define MOUSE_IRQ 12

/* Reference: https://wiki.osdev.org/%228042%22_PS/2_Controller
 */

class Ps2 : public Device, public KeyboardInputInterface {
 private:
  std::deque<uint8_t> keyboard_queue_;
  std::deque<uint8_t> mouse_queue_;

  uint8_t status_;
  uint8_t mode_;
  uint8_t last_command_;
  uint8_t output_data_;
  bool    output_data_is_read_;
  int     raised_irq_;
  uint8_t a20_gate_ = 0;

  struct {
    uint8_t buttons;
    int     dx;
    int     dy;
    uint8_t resolution;
    uint8_t sample_rate;
    uint8_t command;
    uint8_t scaling;
    uint8_t id;
    uint8_t stream_mode;
    bool    disable_streaming;
  } mouse_;

  struct {
    uint8_t leds;
    uint8_t scancode_set;
    bool    disable_scanning;
  } keyboard_;

  bool SaveState(MigrationWriter* writer) {
    Ps2State state;
    state.set_mode(mode_);
    state.set_status(status_);
    state.set_a20_gate(a20_gate_);

    auto keyboard = state.mutable_keyboard();
    keyboard->set_scancode_set(keyboard_.scancode_set);
    keyboard->set_leds(keyboard_.leds);

    auto mouse = state.mutable_mouse();
    mouse->set_resolution(mouse_.resolution);
    mouse->set_buttons(mouse_.buttons);
    mouse->set_sample_rate(mouse_.sample_rate);
    mouse->set_scaling(mouse_.scaling);
    mouse->set_stream_mode(mouse_.stream_mode);
    mouse->set_dx(mouse_.dx);
    mouse->set_dy(mouse_.dy);

    writer->WriteProtobuf("PS2", state);
    return Device::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    Ps2State state;
    if (!reader->ReadProtobuf("PS2", state)) {
      return false;
    }
    mode_ = state.mode();
    status_ = state.status();
    a20_gate_ = state.a20_gate();

    /* For compatibility, defaults to enabled a20 gate */
    if (!a20_gate_) {
      a20_gate_ = OUTPORT_A20;
    }
    
    auto& keyboard = state.keyboard();
    keyboard_.scancode_set = keyboard.scancode_set();
    keyboard_.leds = keyboard.leds();

    auto& mouse = state.mouse();
    mouse_.resolution = mouse.resolution();
    mouse_.buttons = mouse.buttons();
    mouse_.sample_rate = mouse.sample_rate();
    mouse_.scaling = mouse.scaling();
    mouse_.stream_mode = mouse.stream_mode();
    mouse_.dx = mouse.dx();
    mouse_.dy = mouse.dy();
    return Device::LoadState(reader);
  }
  
  void Reset() {
    Device::Reset();

    status_ = STATUS_KEYLOCK | STATUS_COMMAND;
    mode_ = 5;
    raised_irq_ = -1;
    last_command_ = 0;
    output_data_is_read_ = true;
    a20_gate_ &= ~OUTPORT_RESET;
    
    ResetKeyboard();
    ResetMouse();
  }

  void ResetKeyboard() {
    keyboard_queue_.clear();
    keyboard_.scancode_set = 2;
    keyboard_.disable_scanning = false;
  }

  void ResetMouse() {
    mouse_queue_.clear();
    mouse_.command = 0;
    mouse_.resolution = 4;
    mouse_.sample_rate = 100;
    mouse_.scaling = 1;
    mouse_.dx = mouse_.dy = 0;
    mouse_.disable_streaming = false;
    mouse_.stream_mode = 1;
    /* 
     * https://wiki.osdev.org/PS/2_Mouse
     * 0: Normal 2 buttons mouse
     * 3: Use 3 buttons
     * 5: Use 5 buttons
     */
    mouse_.id = 3;
  }

  void RaiseIrq(int irq) {
    bool enabled = false;
    status_ |= STATUS_OFULL;
    if (irq == MOUSE_IRQ) {
      status_ |= STATUS_AUXDATA;
      enabled = mode_ & MODE_AUX_INTERRUPT;
    } else {
      status_ &= ~STATUS_AUXDATA;
      enabled = mode_ & MODE_KBD_INTERRUPT;
    }

    if (enabled) {
      manager_->SetGsiLevel(irq, 0);
      manager_->SetGsiLevel(irq, 1);
      raised_irq_ = irq;
    }
  }

  void FillOutputData() {
    if (!output_data_is_read_) {
      if (!keyboard_queue_.empty()) {
        RaiseIrq(KEYBOARD_IRQ);
      } else if (!mouse_queue_.empty()) {
        RaiseIrq(MOUSE_IRQ);
      }
      return;
    }

    if (!keyboard_queue_.empty()) {
      output_data_ = keyboard_queue_.front();
      keyboard_queue_.pop_front();
      output_data_is_read_ = false;
      RaiseIrq(KEYBOARD_IRQ);
    } else if (!mouse_queue_.empty()) {
      output_data_ = mouse_queue_.front();
      mouse_queue_.pop_front();
      output_data_is_read_ = false;
      RaiseIrq(MOUSE_IRQ);
    }
  }


  void PushKeyboard(uint8_t data) {
    keyboard_queue_.push_back(data);
    FillOutputData();
  }

  void PushMouse(uint8_t data) {
    mouse_queue_.push_back(data);
    FillOutputData();
  }

  void PushMouse4(uint8_t data[3]) {
    mouse_queue_.push_back(data[0]);
    mouse_queue_.push_back(data[1]);
    mouse_queue_.push_back(data[2]);
    mouse_queue_.push_back(data[3]);
    FillOutputData();
  }

  uint8_t ReadData() {
    status_ &= ~(STATUS_AUXDATA | STATUS_OFULL);

    if (raised_irq_ != -1) {
      manager_->SetGsiLevel(raised_irq_, 0);
      raised_irq_ = -1;
    }
    
    uint8_t ret = output_data_;
    output_data_is_read_ = true;
    FillOutputData();
    return ret;
  }

  void WriteMouseCommand(uint8_t data) {
    switch (mouse_.command)
    {
    case 0xE8: // resolution
      mouse_.resolution = data;
      mouse_.command = 0;
      PushMouse(RESPONSE_ACK);
      break;
    case 0xF3: // sample rate
      mouse_.sample_rate = data;
      mouse_.command = 0;
      PushMouse(RESPONSE_ACK);
      break;
    case 0:
      switch (data)
      {
      case 0x00:
      case 0x0A:
      case 0x88:
      case 0xE1:
        /* Linux uses these commands, why ??? */
        PushMouse(0xFE);
        break;
      case 0xE6:
        mouse_.scaling = 1;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xE7:
        mouse_.scaling = 2;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xE8: // set resolution
        mouse_.command = data;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xE9: // send status
        PushMouse(RESPONSE_ACK);
        PushMouse(mouse_.stream_mode << 6 | (!mouse_.disable_streaming << 5) | (!mouse_.scaling << 4) | mouse_.buttons);
        PushMouse(mouse_.resolution);
        PushMouse(mouse_.sample_rate);
        break;
      case 0xEA: // set stream mode
        MV_ASSERT(data == 1);
        PushMouse(RESPONSE_ACK);
        break;
      case 0xF2: // get mouse ID
        PushMouse(RESPONSE_ACK);
        PushMouse(mouse_.id);
        break;
      case 0xF3: // set sample rate
        mouse_.command = data;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xF4: // enable mouse
        mouse_.disable_streaming = false;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xF5: // disable mouse
        mouse_.disable_streaming = true;
        PushMouse(RESPONSE_ACK);
        break;
      case 0xF6: // set defaults
        ResetMouse();
        PushMouse(RESPONSE_ACK);
        break;
      case 0xFF: // reset mouse
        ResetMouse();
        PushMouse(RESPONSE_ACK);
        PushMouse(0xAA);
        PushMouse(0x00);
        break;
      default:
        MV_ERROR("unhandled mouse command = 0x%x", data);
        break;
      }
      break;
    default:
      MV_ERROR("unhandled mouse command = 0x%x", mouse_.command);
      break;
    }
  }

  void WritePs2Command(uint8_t data) {
    switch (data)
    {
    case 0xED: // set LED state
      last_command_ = data;
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xF0: // get/set keyboard scancode set
      last_command_ = data;
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xF2: // set LED state
      PushKeyboard(RESPONSE_ACK);
      PushKeyboard(0xAB);
      PushKeyboard(0x41);
      break;
    case 0xF3: // set typematic rate
      last_command_ = data;
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xF4: // enable keyboard scanning
      keyboard_.disable_scanning = false;
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xF5: // disable keyboard scanning
      keyboard_.disable_scanning = true;
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xF6: // reset keyboard and enable scanning
      Reset();
      PushKeyboard(RESPONSE_ACK);
      break;
    case 0xFF: // reset keyboard
      ResetKeyboard();
      PushKeyboard(RESPONSE_ACK);
      PushKeyboard(0xAA);
      break;
    default:
      MV_ERROR("unhandled ps2 command=0x%x", data);
      break;
    }
  }

  void WriteCommandPort(uint8_t command) {
    switch (command)
    {
    case 0x20: // read 
      PushKeyboard(mode_ | (status_ & STATUS_SYSFLAG));
      break;
    case 0x60: // control mode
      last_command_ = command;
      break;
    case 0xA7: // disable mouse
      mode_ |= MODE_AUX_DISABLED;
      break;
    case 0xA8: // enable mouse
      mode_ &= ~MODE_AUX_DISABLED;
      FillOutputData();
      if (!output_data_is_read_) {
        RaiseIrq(MOUSE_IRQ);
      }
      break;
    case 0xA9: // Test mouse port
      PushKeyboard(0);
      break;
    case 0xAA: // Test controller
      status_ |= STATUS_SYSFLAG;
      PushKeyboard(0x55);
      break;
    case 0xAB: // Test keyboard
      PushKeyboard(0);
      break;
    case 0xAD: // disable keyboard
      mode_ |= MODE_KBD_DISABLED;
      break;
    case 0xAE: // enable keyboard
      mode_ &= ~MODE_KBD_DISABLED;
      FillOutputData();
      if (!output_data_is_read_) {
        RaiseIrq(KEYBOARD_IRQ);
      }
      break;
    case 0xD1 ... 0xD4: // outport utilities
      last_command_ = command;
      break;
    case 0xFE ... 0xFF: // pulse output line
      if ((command & 1) == 0) {
        if (debug_) {
          MV_LOG("system reset");
        }
        manager_->machine()->Reset();
      }
      break;
    default:
      MV_ERROR("unhandled command=0x%x", command);
      break;
    }
    status_ |= STATUS_COMMAND;
  }

  void WriteDataPort(uint8_t data) {
    uint8_t command = last_command_;
    last_command_ = 0;
    switch (command)
    {
    case 0:
      WritePs2Command(data);
      break;
    case 0x60: // write to control mode
      mode_ = data;
      break;
    case 0xD1: // write to outport (Windows use this to control a20 gate)
      if (data & OUTPORT_A20) {
        a20_gate_ |= OUTPORT_A20;
      } else {
        a20_gate_ &= ~OUTPORT_A20;
      }
      break;
    case 0xD3: // mouse loop
      PushMouse(data);
      PushMouse(RESPONSE_ACK);
      break;
    case 0xD4: // mouse status
      WriteMouseCommand(data);
      break;
    case 0xED: // set leds
      PushKeyboard(RESPONSE_ACK);
      keyboard_.leds = data;
      break;
    case 0xF0: // keyboard scancode set
      PushKeyboard(RESPONSE_ACK);
      if (data == 0) {
        PushKeyboard(keyboard_.scancode_set);
      } else {
        keyboard_.scancode_set = data;
        MV_ASSERT(keyboard_.scancode_set == 2);
      }
      break;
    case 0xF3: // set typematic rate
      PushKeyboard(RESPONSE_ACK);
      break;
    default:
      MV_ERROR("unhandled command=0x%x data=0x%x", command, data);
      break;
    }
  }


 public:
  Ps2() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    AddIoResource(kIoResourceTypePio, 0x92, 1, "A20 Gate");
    AddIoResource(kIoResourceTypePio, 0x60, 1, "PS2 Data");
    AddIoResource(kIoResourceTypePio, 0x64, 1, "PS2 Command");
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(size == 1);
    MV_UNUSED(offset);

    switch (resource->base)
    {
    case 0x64: // command port
      status_ &= ~STATUS_TIMEOUT;
      *data = status_;
      break;
    case 0x60: // data port
      *data = ReadData();
      break;
    case 0x92: // A20 gate
      /* Always return enabled A20 gate */
      *data = a20_gate_;
      break;
    }
    if (debug_) {
      MV_LOG("read %x %x", resource->base, *data);
    }
  }


  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(size == 1);
    MV_UNUSED(offset);

    if (debug_) {
      MV_LOG("write %x %x", resource->base, *data);
    }

    if (resource->base == 0x64) { // command port
      WriteCommandPort(*data);
    } else if (resource->base == 0x60) { // data port
      WriteDataPort(*data);
    } else if (resource->base == 0x92) { // port 92
      a20_gate_ = *data;
      if (a20_gate_ & 1) {
        if (debug_) {
          MV_LOG("system reset");
          manager_->machine()->Reset();
        }
      }
    }
  }

  /* Called by UI thread */
  bool QueueKeyboardEvent(uint8_t scancode[10], uint8_t modifiers) {
    std::lock_guard<std::recursive_mutex> lock(mutex_);
    if (keyboard_.disable_scanning) {
      return false;
    }

    if (modifiers != keyboard_.leds) {
      uint8_t diff = modifiers ^ keyboard_.leds;
      if (diff & 1) {
        PushKeyboard(0x46);
        PushKeyboard(0x46 | 0x80);
      } else if (diff & 2) {
        PushKeyboard(0x45);
        PushKeyboard(0x45 | 0x80);
      } else if (diff & 4) {
        PushKeyboard(0x3A);
        PushKeyboard(0x3A | 0x80);
      }
    }

    /* skip modifiers input */
    uint8_t code = (scancode[0] == 0xE0 ? scancode[1] : scancode[0]) & 0x7F;
    if (code == 0x45 || code == 0x46 || code == 0x3A) {
      return true;
    }
  
    for (int i = 0; i < 10 && scancode[i]; i++) {
      PushKeyboard(scancode[i]);
    }
    return true;
  }

  /* Called by UI thread */
  bool QueueMouseEvent(uint button_state, int rel_x, int rel_y, int rel_z) {
    std::lock_guard<std::recursive_mutex> lock(mutex_);
    if (mouse_.disable_streaming) {
      return false;
    }
  
    uint8_t state = mouse_.buttons = (uint8_t)button_state;
    rel_y = -rel_y;
    state |= 8; // Always 1
    if (rel_x < 0) {
      rel_x = 0x100 + rel_x;
      state |= 0x10;
    }
    if (rel_y < 0) {
      rel_y = 0x100 + rel_y;
      state |= 0x20;
    }
    uint8_t data[] = { state, (uint8_t)rel_x, (uint8_t)rel_y, (uint8_t)rel_z };
    PushMouse4(data);
    return true;
  }

  bool InputAcceptable() {
    return !keyboard_.disable_scanning && !mouse_.disable_streaming;
  }
};

DECLARE_DEVICE(Ps2);

```

`devices/superio/ps2.proto`:

```proto
syntax = "proto3";

message Ps2State {
  uint32    status          = 1;
  uint32    mode            = 2;

  message Mouse {
    uint32  buttons         = 1;
    uint32  dx              = 2;
    uint32  dy              = 3;
    uint32  resolution      = 4;
    uint32  sample_rate     = 5;
    uint32  scaling         = 6;
    uint32  stream_mode     = 7;
  }

  message Keyboard {
    uint32  scancode_set    = 1;
    uint32  leds            = 2;
  }
  
  Keyboard  keyboard        = 3;
  Mouse     mouse           = 4;
  uint32    a20_gate        = 5;
}

```

`devices/superio/uart.cc`:

```cc
/* 
 * Universal Asynchronous Receiver Transmitter 16550A
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "device.h"

#include <string>
#include <linux/serial_reg.h>

#include "device_manager.h"
#include "logger.h"

/*
 * This fakes a U6_16550A. The fifo len needs to be 64 as the kernel
 * expects that for autodetection.
 */
#define FIFO_LEN            64
#define FIFO_MASK           (FIFO_LEN - 1)
#define UART_IIR_TYPE_BITS  0xC0

struct Console {
  uint          index;
  std::string   name;
  uint64_t      ioport_base;

  uint          irq_line;
  uint8_t       irq_status;
  int           write_count;
  int           read_count;
  int           read_done;

  char          read_buffer[FIFO_LEN];
  char          write_buffer[FIFO_LEN];

  uint8_t       interrupt_id;
  uint8_t       interrupt_enable;
  uint8_t       fifo_control;
  uint8_t       line_control;
  uint8_t       line_status;
  uint8_t       modem_status;
  uint8_t       modem_control;
  uint8_t       scratch;
  uint16_t      divsor_latch;
};

class Uart : public Device {
 private:
  std::array<Console, 4>  consoles_;

  void AddConsole(uint index, const char* name, uint64_t ioport_base, uint irq_line) {
    MV_ASSERT(index < consoles_.size());
    auto& console = consoles_[index];
    console.index = index;
    console.name = name;
    console.ioport_base = ioport_base;
    console.irq_line = irq_line;
    console.interrupt_id = UART_IIR_NO_INT;
    console.line_status = UART_LSR_TEMT | UART_LSR_THRE;
    console.modem_status = UART_MSR_DCD | UART_MSR_DSR | UART_MSR_CTS;
    console.modem_control = UART_MCR_OUT2;
    AddIoResource(kIoResourceTypePio, ioport_base, 8, name);
  }

  Console* GetConsoleByIoPortBase(uint64_t ioport_base) {
    for (auto& console : consoles_) {
      if (console.ioport_base == ioport_base)
        return &console;
    }
    return nullptr;
  }

  void UpdateIrqLevel(Console* console) {
    uint8_t status = 0;

    /* Handle clear rx */
    if (console->line_control & UART_FCR_CLEAR_RCVR) {
      console->line_control &= ~UART_FCR_CLEAR_RCVR;
      console->read_count = console->read_done = 0;
      console->line_status &= ~UART_LSR_DR;
    }

    /* Handle clear tx */
    if (console->line_control & UART_FCR_CLEAR_XMIT) {
      console->line_control &= ~UART_FCR_CLEAR_XMIT;
      console->write_count = 0;
      console->line_status |= UART_LSR_TEMT | UART_LSR_THRE;
    }

    /* Data ready and rcv interrupt enabled ? */
    if ((console->interrupt_enable & UART_IER_RDI) && (console->line_status & UART_LSR_DR))
      status |= UART_IIR_RDI;

    /* Transmitter empty and interrupt enabled ? */
    if ((console->interrupt_enable & UART_IER_THRI) && (console->line_status & UART_LSR_TEMT))
      status |= UART_IIR_THRI;

    /* Now update the irq line, if necessary */
    if (!status) {
      console->interrupt_id = UART_IIR_NO_INT;
      if (console->irq_status)
        manager_->SetGsiLevel(console->irq_line, 0);
    } else {
      console->interrupt_id = status;
      if (!console->irq_status)
        manager_->SetGsiLevel(console->irq_line, 1);
    }
    console->irq_status = status;

    /*
    * If the kernel disabled the tx interrupt, we know that there
    * is nothing more to transmit, so we can reset our tx logic
    * here.
    */
    if (!(console->interrupt_enable & UART_IER_THRI))
      FlushConsole(console);
  }

  void FlushConsole(Console* console) {
    console->line_status |= UART_LSR_TEMT | UART_LSR_THRE;
    if (console->write_count) {
      for (int i = 0; i < console->write_count; i++) {
        putchar(console->write_buffer[i]);
      }
      console->write_count = 0;
    }
  }

  uint8_t ReadConsole(Console* console) {
    if (console->read_done == console->read_count)
      return 0;
    
    if (console->line_status & UART_LSR_BI) {
      console->line_status &= ~UART_LSR_BI;
      return 0;
    }

    auto data = console->read_buffer[console->read_done++];
    if (console->read_count == console->read_done) {
      console->line_status &= ~UART_LSR_DR;
      console->read_count = console->read_done = 0;
    }
    return data;
  }

 public:
  Uart() {
    set_default_parent_class("Ich9Lpc", "Piix3");

    bzero(&consoles_, sizeof(consoles_));
    AddConsole(0, "COM 1", 0x3F8, 4);
    AddConsole(1, "COM 2", 0x2F8, 3);
    AddConsole(2, "COM 3", 0x3E8, 4);
    AddConsole(3, "COM 4", 0x2E8, 3);
  }

  virtual void Reset() {
    Device::Reset();
  }

  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    auto console = GetConsoleByIoPortBase(resource->base);
    MV_ASSERT(console);
    switch (offset)
    {
    case UART_RX:
      if (console->line_control & UART_LCR_DLAB)
        data[0] = console->divsor_latch & 0xFF;
      else
        data[0] = ReadConsole(console);
      break;
    case UART_IER:
      if (console->line_control & UART_LCR_DLAB)
        data[0] = console->divsor_latch >> 8;
      else
        data[0] = console->interrupt_enable;
      break;
    case UART_IIR:
      data[0] = console->interrupt_id | UART_IIR_TYPE_BITS;
      break;
    case UART_LCR:
      data[0] = console->line_control;
      break;
    case UART_MCR:
      data[0] = console->modem_control;
      break;
    case UART_LSR:
      data[0] = console->line_status;
      break;
    case UART_MSR:
      data[0] = console->modem_status;
      break;
    case UART_SCR:
      data[0] = console->scratch;
      break;
    default:
      Device::Read(resource, offset, data, size);
    }
    UpdateIrqLevel(console);
  }

  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
    auto console = GetConsoleByIoPortBase(resource->base);
    MV_ASSERT(console);

    switch (offset)
    {
    case UART_TX:
      if (console->line_control & UART_LCR_DLAB) {
        console->divsor_latch = (console->divsor_latch & 0xFF00) | data[0];
        break;
      }

      /* Loopback mode */
      if (console->modem_control & UART_MCR_LOOP) {
        if (console->read_count < FIFO_LEN) {
          console->read_buffer[console->read_count++] = data[0];
          console->line_status |= UART_LSR_DR;
        }
        break;
      }

      if (console->write_count < FIFO_LEN) {
        console->write_buffer[console->write_count++] = data[0];
        console->line_status &= ~UART_LSR_TEMT;
        if (console->write_count == FIFO_LEN / 2)
          console->line_status &= ~UART_LSR_THRE;
        /* Flush every write currently */
        FlushConsole(console);
      } else {
        console->line_status &= ~(UART_LSR_TEMT | UART_LSR_THRE);
        MV_PANIC("should never got here");
      }
      break;
    case UART_IER:
      if (console->line_control & UART_LCR_DLAB)
        console->divsor_latch = (console->divsor_latch & 0xFF) | (data[0] << 8);
      else
        console->interrupt_enable = data[0] & 0xF;
      break;
    case UART_FCR:
      console->fifo_control = data[0];
      break;
    case UART_LCR:
      console->line_control = data[0];
      break;
    case UART_MCR:
      console->modem_control = data[0];
      break;
    case UART_SCR:
      console->scratch = data[0];
      break;
    case UART_LSR:
    case UART_MSR:
    default:
      Device::Write(resource, offset, data, size);
    }
    UpdateIrqLevel(console);
  }
};

DECLARE_DEVICE(Uart);

```

`devices/usb/meson.build`:

```build

mvisor_sources += files(
  'piix3_uhci.cc',
  'uhci_host.cc',
  'uhci_host.h',
  'usb_descriptor.h',
  'usb_device.cc',
  'usb_device.h',
  'usb_hid.cc',
  'usb_hid.h',
  'usb_midi.cc',
  'usb_tablet.cc',
  'usb_wacom.cc',
  'usb.h',
  'xhci_host.cc',
  'xhci_internal.h',
)

proto_sources += proto_gen.process(
  'uhci_host.proto',
  'usb_device.proto',
  'xhci_host.proto'
)

```

`devices/usb/piix3_uhci.cc`:

```cc
/* 
 * MVisor USB 1.0 UHCI
 * https://wiki.osdev.org/Universal_Host_Controller_Interface
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uhci_host.h"

class Piix3Uhci : public UhciHost {
 public:
  Piix3Uhci() {
    slot_ = 1;
    function_ = 2;

    /* PCI_DEVICE_ID_INTEL_82371SB_2 */
    pci_header_.vendor_id = 0x8086;
    pci_header_.device_id = 0x7020;
    pci_header_.irq_pin = 3;
  }
};

DECLARE_DEVICE(Piix3Uhci);

```

`devices/usb/uhci_host.cc`:

```cc
/* 
 * MVisor USB 1.0 UHCI
 * Reference: https://wiki.osdev.org/Universal_Host_Controller_Interface
 * Reference: http://www.ece.mcgill.ca/~zzilic/426/USB.ppt
 * Specification: ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uhci_host.h"
#include "device_manager.h"
#include "usb.h"
#include "uhci_host.pb.h"


#define UHCI_FRAME_TIMER_FREQUENCY    1000
#define UHCI_FRAME_TIMER_INTERVAL_NS  (NS_PER_SECOND / UHCI_FRAME_TIMER_FREQUENCY)


UhciHost::UhciHost() {
  pci_header_.class_code = 0x0C0300;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;
  pci_header_.irq_pin = 1;

  /* Specification Release 1.0 */
  pci_header_.data[0x60] = 0x10;

  AddPciBar(4, 32, kIoResourceTypePio);
}

void UhciHost::Connect() {
  PciDevice::Connect();

  /* USB ports support low speed and full speed */
  for (size_t i = 0; i < max_ports_; i++) {
    port_states_[i].id = i + 1;
    port_states_[i].speed_mask = 0b0011;
    port_states_[i].device = nullptr;
  }

  /* Connect USB devices to ports */
  for (auto device : children_) {
    UsbDevice* usb = dynamic_cast<UsbDevice*>(device);
    if (usb) {
      AttachUsbDevice(usb);
    }
  }
}

bool UhciHost::AttachUsbDevice(UsbDevice* device) {
  for (auto &port_state : port_states_) {
    if (port_state.device)
      continue;
    if ((port_state.speed_mask & (1 << device->speed())) == 0)
      continue;
    port_state.device = device;
    if (debug_) {
      MV_LOG("Attach USB device %s to port %d", device->name(), port_state.id);
    }
    return true;
  }
  MV_PANIC("failed to attach USB device %s", device->name());
  return false;
}

void UhciHost::Disconnect() {
  Halt();
  PciDevice::Disconnect();
}

bool UhciHost::SaveState(MigrationWriter* writer) {
  UhciHostState state;
  auto operational = state.mutable_operational();
  operational->set_usb_command(uhci_.usb_command);
  operational->set_usb_status(uhci_.usb_status);
  operational->set_usb_interrupt_enable(uhci_.usb_interrupt_enable);
  operational->set_frame_number(uhci_.frame_number);
  operational->set_frame_timing(uhci_.frame_timing);
  operational->set_frame_list_base(uhci_.frame_list_base);

  for (uint i = 0; i < max_ports_; i++) {
    auto port = state.add_ports();
    port->set_status_control(uhci_.port_sc[i]);
  }
  writer->WriteProtobuf("UHCI", state);
  return PciDevice::SaveState(writer);
}

bool UhciHost::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }

  UhciHostState state;
  if (!reader->ReadProtobuf("UHCI", state)) {
    return false;
  }
  auto& operational = state.operational();
  uhci_.usb_command = operational.usb_command();
  uhci_.usb_status = operational.usb_status();
  uhci_.usb_interrupt_enable = operational.usb_interrupt_enable();
  uhci_.frame_number = operational.frame_number();
  uhci_.frame_timing = operational.frame_timing();
  uhci_.frame_list_base = operational.frame_list_base();

  if (uhci_.frame_list_base) {
    frame_list_ = (uint32_t*)manager_->TranslateGuestMemory(uhci_.frame_list_base);
  }

  for (uint i = 0; i < max_ports_; i++) {
    auto& port = state.ports(i);
    uhci_.port_sc[i] = port.status_control();
  }

  if (uhci_.usb_command & UHCI_CMD_RS) {
    Run();
  }
  return true;
}

void UhciHost::Reset() {
  PciDevice::Reset();
  
  bzero(&uhci_, sizeof(uhci_));
  uhci_.frame_timing = 64;
  Halt();

  for (size_t i = 0; i < max_ports_; i++) {
    uhci_.port_sc[i] = 0x0080;
    ResetPort(i);
  }
  UpdateIrqLevel();
}

void UhciHost::UpdateIrqLevel() {
  int level = 0;
  if (((uhci_.usb_interrupt_enable & 0b1100) && (uhci_.usb_status & UHCI_STS_USBINT)) ||
      ((uhci_.usb_interrupt_enable & 0b0001) && (uhci_.usb_status & UHCI_STS_USBERR)) ||
      ((uhci_.usb_interrupt_enable & 0b0010) && (uhci_.usb_status & UHCI_STS_RD)) ||
      ((uhci_.usb_status & UHCI_STS_HSERR)) ||
      ((uhci_.usb_status & UHCI_STS_HCPERR))
  ) {
    level = 1;
  }
  SetIrq(level);
}

void UhciHost::ResetPort(uint index) {
  /* set connect status */
  if (port_states_[index].device) {
    uhci_.port_sc[index] |= UHCI_PORT_CCS | UHCI_PORT_CSC;
  } else {
    if (uhci_.port_sc[index] & UHCI_PORT_CCS) {
      uhci_.port_sc[index] &= ~UHCI_PORT_CCS;
      uhci_.port_sc[index] |= UHCI_PORT_CSC;
    }
    if (uhci_.port_sc[index] & UHCI_PORT_EN) {
      uhci_.port_sc[index] &= ~UHCI_PORT_EN;
      uhci_.port_sc[index] |= UHCI_PORT_ENC;
    }
  }

  /* force global resume and set resume detect */
  if (uhci_.usb_command & UHCI_CMD_EGSM) {
    uhci_.usb_command |= UHCI_CMD_FGR;
    uhci_.usb_status |= UHCI_STS_RD;
    UpdateIrqLevel();
  }
}

void UhciHost::Run() {
  if (frame_timer_ == nullptr) {
    frame_timer_ = AddTimer(UHCI_FRAME_TIMER_INTERVAL_NS, true, [this]() {
      OnFrameTimer();
    });
  }
  uhci_.usb_status &= ~UHCI_STS_HCHALTED;
}

void UhciHost::Halt() {
  if (frame_timer_) {
    RemoveTimer(frame_timer_);
    frame_timer_ = nullptr;
  }

  /* Cleanup queues */
  for (auto it = queues_.begin(); it != queues_.end(); it++) {
    if (it->second->transfer) {
      FreeTransfer(it->second->transfer);
    }
    delete it->second;
  }
  queues_.clear();

  uhci_.usb_status |= UHCI_STS_HCHALTED;
}

void UhciHost::SetError(UhciTransferDescriptor* td, int status) {
  switch (status) {
  case USB_RET_NAK:
    td->nak = 1;
    break;
  case USB_RET_STALL:
    td->stalled = 1;
    break;
  case USB_RET_BABBLE:
    td->stalled = 1;
    td->babble = 1;
    break;
  case USB_RET_IOERROR:
  case USB_RET_NODEV:
  default:
    td->timeout = 1;
    td->error_count = 0;
    break;
  }

  td->active = 0;
  uhci_.usb_status |= UHCI_STS_USBERR;
}

UsbDevice* UhciHost::FindDevice(UhciTransferDescriptor* td) {
  for (auto &port_state : port_states_) {
    if (port_state.device && port_state.device->device_address() == td->device) {
      return port_state.device;
    }
  }
  return nullptr;
}

void UhciHost::NotifyEndpoint(UsbDevice* device, uint endpoint_address) {
  for (auto it = queues_.begin(); it != queues_.end(); it++) {
    if (it->second->device == device && it->second->endpoint_address == endpoint_address) {
      it->second->nak = false;
      break;
    }
  }
}

void UhciHost::CompleteTransfer(UhciTransfer* transfer, uint32_t* next_link) {
  MV_ASSERT(transfer->tds[0]->active);

  auto packet = transfer->packet;
  if (transfer->isochronous) {
    for (auto td: transfer->tds) {
      td->active = 0;
    }
  }

  transfer->completed = true;
  if (packet->status != USB_RET_SUCCESS) {
    transfer->stop = true;
    return SetError(transfer->tds[0], packet->status);
  }

  size_t left = transfer->packet->content_length;
  for (auto td : transfer->tds) {
    if (td->pid == USB_TOKEN_SETUP) {
      td->actual_length = 8 - 1;
    } else {
      size_t chunk = td->max_length + 1;
      if (chunk > left) {
        chunk = left;
      }
      left -= chunk;
      td->actual_length = chunk - 1;
    }
    td->timeout = 0;
    td->nak = 0;
    td->active = 0;

    if (td->pid == USB_TOKEN_IN && td->short_packet && td->actual_length < td->max_length) {
      transfer->interrupt_on_completion = true;
      transfer->stop = true;
      break;
    }
    
    if (next_link) {
      // advance element pointer
      *next_link = td->link;
    }
  }
}

void UhciHost::FreeTransfer(UhciTransfer* transfer) {
  delete transfer->packet;
  delete transfer;
}

/* Create a transfer object for a USB transaction */
UhciTransfer* UhciHost::CreateTransfer(UhciTransferDescriptor* td, uint32_t link) {
  /* Find device */
  auto device = FindDevice(td);
  if (!device) {
    MV_ERROR("failed to find usb device by id %d", td->device);
    SetError(td, USB_RET_NODEV);
    return nullptr;
  }

  /* A transaction may have multiple transfer descriptors */
  std::vector<UhciTransferDescriptor*> tds;
  tds.push_back(td);

  if (td->endpoint == 0) {
    /* Control endpoint */
    if (td->pid == USB_TOKEN_SETUP) {
      while (!(td->link & UHCI_LINK_TERM)) {
        td = (UhciTransferDescriptor*)manager_->TranslateGuestMemory(td->link & ~0xF);
        if (!td->active) {
          break;  // don't add inactive TDs
        }
        tds.push_back(td);

        if (tds.size() >= 3 && tds[1]->pid != tds.back()->pid) {
          break;  // ack TD is already pushed
        }
      }

      if (tds.size() < 2) {
        MV_ERROR("setup tds size=%lu", tds.size());
        return nullptr;
      }
    } else {
      MV_ERROR("invalid pid %x", td->pid);
    }
  } else {
    MV_ASSERT(td->pid == USB_TOKEN_IN || td->pid == USB_TOKEN_OUT);
  }

  uint endpoint_address;
  if (tds[0]->pid == USB_TOKEN_SETUP) {
    endpoint_address = (tds[1]->pid == USB_TOKEN_IN ? 0x80 : 0) | tds[1]->endpoint;
  } else {
    endpoint_address = (tds[0]->pid == USB_TOKEN_IN ? 0x80 : 0) | tds[0]->endpoint;
  }

  /* Build USB packet that we pass it to device later */
  auto packet = new UsbPacket;
  packet->endpoint_address = endpoint_address;
  packet->stream_id = 0;
  packet->id = link;
  packet->status = USB_RET_SUCCESS;
  packet->content_length = 0;
  packet->control_parameter = 0;
  packet->size = 0;

  if (tds[0]->pid == USB_TOKEN_SETUP) {
    auto setup = manager_->TranslateGuestMemory(tds[0]->buffer);
    memcpy(&packet->control_parameter, setup, tds[0]->max_length + 1);
    
    for (size_t i = 1; i < tds.size() - 1; i++) {
      packet->iov.push_back(iovec {
        .iov_base = manager_->TranslateGuestMemory(tds[i]->buffer),
        .iov_len = size_t(tds[i]->max_length + 1)
      });
      if (endpoint_address & 0x80) {
        manager_->AddDirtyMemory(tds[i]->buffer, packet->iov.back().iov_len);
      }
      packet->size += packet->iov.back().iov_len;
    }
  } else {
    for (auto td : tds) {
      packet->iov.push_back(iovec {
        .iov_base = manager_->TranslateGuestMemory(td->buffer),
        .iov_len = size_t(td->max_length + 1)
      });
      if (endpoint_address & 0x80) {
        manager_->AddDirtyMemory(td->buffer, packet->iov.back().iov_len);
      }
      packet->size += packet->iov.back().iov_len;
    }
  }

  /* Create a transfer to hold all the TDs and USB packet */
  auto transfer = new UhciTransfer;
  transfer->packet = packet;
  transfer->device = device;
  transfer->endpoint_address = endpoint_address;
  transfer->link = link;
  transfer->stop = false;
  transfer->completed = false;
  transfer->isochronous = tds[0]->isochronous;
  for (auto td: tds) {
    if (td->interrupt) {
      transfer->interrupt_on_completion = true;
    }
  }

  transfer->tds = std::move(tds);
  return transfer;
}

void UhciHost::OnFrameTimer() {
  uint32_t link = frame_list_[uhci_.frame_number & 0x3FF];
  std::unordered_set<uint32_t> visited_qh;
  bool interrupt = false;
  UhciQueue* current_queue = nullptr;
  UhciTransfer* transfer = nullptr;

  /* Cleanup invalid queues */
  for (auto it = queues_.begin(); it != queues_.end();) {
    if (--it->second->valid == 0) {
      auto q = it->second;
      if (q->transfer) {
        FreeTransfer(q->transfer);
      }
      delete q;
      it = queues_.erase(it);
    } else {
      it++;
    }
  }

  while (!(link & UHCI_LINK_TERM)) {
    /* link is Queue head */
    if (link & UHCI_LINK_QUEUE) {
      /* avoid infinite loop */
      if (visited_qh.find(link) != visited_qh.end()) {
        break;
      }
      visited_qh.insert(link);

      auto it = queues_.find(link & ~0xF);
      if (it == queues_.end()) {
        auto q = new UhciQueue;
        q->device = nullptr;
        q->endpoint_address = 0;
        q->qh = (UhciQueueHead*)manager_->TranslateGuestMemory(link & ~0xF);
        q->transfer = nullptr;
        q->nak = false;
        queues_[link & ~0xF] = q;
        current_queue = q;
      } else {
        current_queue = it->second;
      }
      
      current_queue->valid = 32;
      if (current_queue->qh->element_link & UHCI_LINK_TERM) {
        link = current_queue->qh->link;
        current_queue = nullptr;
      } else {
        link = current_queue->qh->element_link;
      }
      continue;
    }

    /* link is Transfer descriptor */
    auto gpa = link & ~0xF;
    auto td = (UhciTransferDescriptor*)manager_->TranslateGuestMemory(gpa);
    manager_->AddDirtyMemory(gpa, sizeof(UhciTransferDescriptor));
    if (!td->active) {
      if (td->interrupt) {
        interrupt = true;
      }
      goto next_qh;
    }

    /* TD without queue not supported yet */
    if (current_queue == nullptr) {
      MV_ERROR("TD without queue %x not supported yet", link);
      goto next_qh;
    }
    
    /* Ignore ACK packet of control endpoint */
    if (td->endpoint == 0 && td->pid == USB_TOKEN_OUT) {
      td->active = 0;
      current_queue->qh->element_link = td->link;
      if (td->interrupt) {
        interrupt = true;
      }
      goto next_qh;
    }

    /* If current transfer link differs from the queue, it becomes invalid */
    transfer = current_queue->transfer;
    if (transfer) {
      if (transfer->link != link) {
        FreeTransfer(transfer);
        current_queue->transfer = transfer = nullptr;
      } else if (current_queue->nak) {
        link = current_queue->qh->link;
        continue;
      }
    }

    if (!transfer) {
      current_queue->transfer = transfer = CreateTransfer(td, link);
    }

    if (transfer) {
      if (!current_queue->device) {
        current_queue->device = transfer->device;
        current_queue->endpoint_address = transfer->endpoint_address;
      }
      current_queue->device->HandlePacket(transfer->packet);
    
      if (transfer->packet->status == USB_RET_NAK) {
        current_queue->nak = true;
      } else {
        CompleteTransfer(transfer, current_queue ? &current_queue->qh->element_link : nullptr);
        bool stop = transfer->stop;
        if (transfer->interrupt_on_completion) {
          interrupt = true;
        }
        FreeTransfer(transfer);
        current_queue->transfer = nullptr;

        if (!stop && (current_queue->qh->element_link & UHCI_LINK_VF)) {
          link = current_queue->qh->element_link;
          continue; // not tested yet
        }
      }
    }

    /* Next QH */
next_qh:
    link = current_queue ? current_queue->qh->link : td->link;
  }

  uhci_.frame_number++;
  if (interrupt) {
    uhci_.usb_status |= UHCI_STS_USBINT;
    UpdateIrqLevel();
  }
}

void UhciHost::WriteUsbCommand(uint16_t value) {
  if ((value & UHCI_CMD_RS) && !(uhci_.usb_command & UHCI_CMD_RS)) {
    Run();
  } else if (!(value & UHCI_CMD_RS)) {
    Halt();
  }
  if ((value & UHCI_CMD_GRESET) | (value & UHCI_CMD_HCRESET)) {
    Reset();
    return;
  }

  uhci_.usb_command = value;
}

void UhciHost::WritePortStatusControl(uint index, uint16_t value) {
  if (value & UHCI_PORT_RESET && !(uhci_.port_sc[index] & UHCI_PORT_RESET)) {
    /* Reset the device */
    if (port_states_[index].device) {
      port_states_[index].device->Reset();
    }
  }

  uhci_.port_sc[index] &= UHCI_PORT_READ_ONLY;
  if (!(uhci_.port_sc[index] & UHCI_PORT_CCS)) {
    value &= ~UHCI_PORT_EN;
  }
  uhci_.port_sc[index] |= (value & ~UHCI_PORT_READ_ONLY);
  uhci_.port_sc[index] &= ~(value & UHCI_PORT_WRITE_CLEAR);
}

void UhciHost::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[4].address) {
    switch (offset)
    {
    case 0x00:  // USB COMMAND
      WriteUsbCommand(*(uint16_t*)data);
      break;
    case 0x02:  // USB Status
      uhci_.usb_status &= ~*(uint16_t*)data;
      UpdateIrqLevel();
      break;
    case 0x04:  // USB Interrupt Enable
      uhci_.usb_interrupt_enable = *(uint16_t*)data;
      UpdateIrqLevel();
      break;
    case 0x06:  // Frame Number
      if (uhci_.usb_status & UHCI_STS_HCHALTED) {
        uhci_.frame_number = *(uint16_t*)data;
      }
      break;
    case 0x08:  // Frame List Base Address
      MV_ASSERT(size == 4);
      uhci_.frame_list_base = *(uint32_t*)data;
      frame_list_ = (uint32_t*)manager_->TranslateGuestMemory(uhci_.frame_list_base);
      break;
    case 0x0C:  // Frame Timing
      uhci_.frame_timing = data[0];
      break;
    case 0x10 ... 0x1E:  // Port status control
      WritePortStatusControl((offset - 0x10) / 2, *(uint16_t*)data);
      break;
    default:
      MV_PANIC("write 0x%lx data=0x%x size=%u", offset, data[0], size);
      break;
    }
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

void UhciHost::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[4].address) {
    MV_ASSERT(offset + size <= sizeof(uhci_));
    memcpy(data, (uint8_t*)&uhci_ + offset, size);
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

```

`devices/usb/uhci_host.h`:

```h
/* 
 * MVisor USB 1.0 UHCI
 * https://wiki.osdev.org/Universal_Host_Controller_Interface
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_UHCI_HOST_H
#define _MVISOR_DEVICES_USB_UHCI_HOST_H

#include <set>

#include "pci_device.h"
#include "usb_device.h"
#include "uhci_internal.h"

struct UhciTransfer {
  bool                    isochronous;
  bool                    completed;
  bool                    stop;
  bool                    interrupt_on_completion;
  uint                    link;
  UsbPacket*              packet;
  UsbDevice*              device;
  uint                    endpoint_address;
  std::vector<UhciTransferDescriptor*> tds;
};

struct UhciQueue {
  UhciQueueHead*          qh;
  UsbDevice*              device;
  uint                    endpoint_address;
  UhciTransfer*           transfer;
  int                     valid;
  bool                    nak;
};

struct UhciPortSate {
  uint                    id;
  uint                    speed_mask;
  UsbDevice*              device;
};

class UhciHost : public UsbHost {
 public:
  UhciHost();

  virtual void Reset();
  virtual void Connect();
  virtual void Disconnect();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);

 private:
  void Run();
  void Halt();
  bool AttachUsbDevice(UsbDevice* device);
  void UpdateIrqLevel();
  void ResetPort(uint index);

  void SetError(UhciTransferDescriptor* td, int status);
  void NotifyEndpoint(UsbDevice* device, uint endpoint_address);

  UsbDevice* FindDevice(UhciTransferDescriptor* td);
  UhciTransfer* CreateTransfer(UhciTransferDescriptor* td, uint32_t link);
  void CompleteTransfer(UhciTransfer* transfer, uint32_t* next_link);
  void FreeTransfer(UhciTransfer* transfer);

  void OnFrameTimer();
  void WriteUsbCommand(uint16_t value);
  void WritePortStatusControl(uint index, uint16_t value);

  UhciRegisters                       uhci_;
  IoTimer*                            frame_timer_ = nullptr;
  uint32_t*                           frame_list_ = nullptr;

  uint                                max_ports_ = 8;
  std::array<UhciPortSate, 128>       port_states_;
  std::map<uint32_t, UhciQueue*>      queues_;
};

#endif // _MVISOR_DEVICES_USB_UHCI_HOST_H

```

`devices/usb/uhci_host.proto`:

```proto
syntax = "proto3";

message UhciHostState {
  message Operational {
    uint32  usb_command               = 1;
    uint32  usb_status                = 2;
    uint32  usb_interrupt_enable      = 3;
    uint32  frame_number              = 4;
    uint32  frame_list_base           = 5;
    uint32  frame_timing              = 6;
  }

  message Port {
    uint32            status_control  = 1;
  }

  Operational         operational     = 1;
  repeated Port       ports           = 2;
}

```

`devices/usb/uhci_internal.h`:

```h
/* 
 * MVisor USB 1.0 UHCI
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_UHCI_INTERNAL_H
#define _MVISOR_DEVICES_USB_UHCI_INTERNAL_H

#include <cstdint>

#define UHCI_LINK_TERM    (1 << 0)
#define UHCI_LINK_QUEUE   (1 << 1)
#define UHCI_LINK_VF      (1 << 2)

struct UhciTransferDescriptor {
  uint32_t  link;

  uint32_t  actual_length : 11;
  uint32_t  reserved1     : 5;

  /* status */
  uint32_t  reserved4     : 1;
  uint32_t  bitstuff      : 1;
  uint32_t  timeout       : 1;
  uint32_t  nak           : 1;
  uint32_t  babble        : 1;
  uint32_t  buffer_error  : 1;
  uint32_t  stalled       : 1;
  uint32_t  active        : 1;

  uint32_t  interrupt     : 1;
  uint32_t  isochronous   : 1;
  uint32_t  low_speed     : 1;
  uint32_t  error_count   : 2;
  uint32_t  short_packet  : 1;
  uint32_t  reserved2     : 2;

  uint32_t  pid           : 8;
  uint32_t  device        : 7;
  uint32_t  endpoint      : 4;
  uint32_t  data01        : 1;
  uint32_t  reserved3     : 1;
  uint32_t  max_length    : 11;

  uint32_t  buffer;
} __attribute__((packed));

struct UhciQueueHead {
  uint32_t  link;
  uint32_t  element_link;
} __attribute__((packed));

struct UhciRegisters {
  uint16_t  usb_command;
  uint16_t  usb_status;
  uint16_t  usb_interrupt_enable;
  uint16_t  frame_number;
  uint32_t  frame_list_base;
  uint8_t   frame_timing;
  uint8_t   reserved[3];
  uint16_t  port_sc[8];
} __attribute__((packed));


#define UHCI_CMD_FGR      (1 << 4)
#define UHCI_CMD_EGSM     (1 << 3)
#define UHCI_CMD_GRESET   (1 << 2)
#define UHCI_CMD_HCRESET  (1 << 1)
#define UHCI_CMD_RS       (1 << 0)

#define UHCI_STS_HCHALTED (1 << 5)
#define UHCI_STS_HCPERR   (1 << 4)
#define UHCI_STS_HSERR    (1 << 3)
#define UHCI_STS_RD       (1 << 2)
#define UHCI_STS_USBERR   (1 << 1)
#define UHCI_STS_USBINT   (1 << 0)

#define TD_CTRL_SPD     (1 << 29)
#define TD_CTRL_ERROR_SHIFT  27
#define TD_CTRL_IOS     (1 << 25)
#define TD_CTRL_IOC     (1 << 24)
#define TD_CTRL_ACTIVE  (1 << 23)
#define TD_CTRL_STALL   (1 << 22)
#define TD_CTRL_BABBLE  (1 << 20)
#define TD_CTRL_NAK     (1 << 19)
#define TD_CTRL_TIMEOUT (1 << 18)

#define UHCI_PORT_SUSPEND (1 << 12)
#define UHCI_PORT_RESET (1 << 9)
#define UHCI_PORT_LSDA  (1 << 8)
#define UHCI_PORT_RSVD1 (1 << 7)
#define UHCI_PORT_RD    (1 << 6)
#define UHCI_PORT_ENC   (1 << 3)
#define UHCI_PORT_EN    (1 << 2)
#define UHCI_PORT_CSC   (1 << 1)
#define UHCI_PORT_CCS   (1 << 0)

#define UHCI_PORT_READ_ONLY    (0x1bb)
#define UHCI_PORT_WRITE_CLEAR  (UHCI_PORT_CSC | UHCI_PORT_ENC)

#endif // _MVISOR_DEVICES_USB_UHCI_INTERNAL_H

```

`devices/usb/usb.h`:

```h
/* 
 * MVisor USB 3.0
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_USB_H
#define _MVISOR_DEVICES_USB_USB_H

#include <cstdint>

/* Constants related to the USB / PCI interaction */
#define USB_SBRN       0x60 /* Serial Bus Release Number Register */
#define USB_RELEASE_1  0x10 /* USB 1.0 */
#define USB_RELEASE_2  0x20 /* USB 2.0 */
#define USB_RELEASE_3  0x30 /* USB 3.0 */

#define USB_TOKEN_SETUP 0x2d
#define USB_TOKEN_IN    0x69 /* device -> host */
#define USB_TOKEN_OUT   0xe1 /* host -> device */

#define USB_RET_SUCCESS           (0)
#define USB_RET_NODEV             (-1)
#define USB_RET_NAK               (-2)
#define USB_RET_STALL             (-3)
#define USB_RET_BABBLE            (-4)
#define USB_RET_IOERROR           (-5)
#define USB_RET_ASYNC             (-6)
#define USB_RET_ADD_TO_QUEUE      (-7)
#define USB_RET_REMOVE_FROM_QUEUE (-8)

#define USB_SPEED_LOW   0
#define USB_SPEED_FULL  1
#define USB_SPEED_HIGH  2
#define USB_SPEED_SUPER 3

#define USB_SPEED_MASK_LOW   (1 << USB_SPEED_LOW)
#define USB_SPEED_MASK_FULL  (1 << USB_SPEED_FULL)
#define USB_SPEED_MASK_HIGH  (1 << USB_SPEED_HIGH)
#define USB_SPEED_MASK_SUPER (1 << USB_SPEED_SUPER)

#define USB_STATE_NOTATTACHED   0
#define USB_STATE_ATTACHED      1
//#define USB_STATE_POWERED     2
#define USB_STATE_DEFAULT       3
//#define USB_STATE_ADDRESS     4
//#define USB_STATE_CONFIGURED  5
#define USB_STATE_SUSPENDED     6

#define USB_CLASS_AUDIO                  1
#define USB_CLASS_COMM                   2
#define USB_CLASS_HID                    3
#define USB_CLASS_PHYSICAL               5
#define USB_CLASS_STILL_IMAGE            6
#define USB_CLASS_PRINTER                7
#define USB_CLASS_MASS_STORAGE           8
#define USB_CLASS_HUB                    9
#define USB_CLASS_CDC_DATA            0x0a
#define USB_CLASS_CSCID               0x0b
#define USB_CLASS_CONTENT_SEC         0x0d
#define USB_CLASS_APP_SPEC            0xfe
#define USB_CLASS_VENDOR_SPEC         0xff

#define USB_SUBCLASS_UNDEFINED           0
#define USB_SUBCLASS_AUDIO_CONTROL       1
#define USB_SUBCLASS_AUDIO_STREAMING     2
#define USB_SUBCLASS_AUDIO_MIDISTREAMING 3

#define USB_DIR_OUT         0
#define USB_DIR_IN          0x80

#define USB_TYPE_MASK       (0x03 << 5)
#define USB_TYPE_STANDARD   (0x00 << 5)
#define USB_TYPE_CLASS      (0x01 << 5)
#define USB_TYPE_VENDOR     (0x02 << 5)
#define USB_TYPE_RESERVED   (0x03 << 5)

#define USB_RECIP_MASK      0x1f
#define USB_RECIP_DEVICE    0x00
#define USB_RECIP_INTERFACE 0x01
#define USB_RECIP_ENDPOINT  0x02
#define USB_RECIP_OTHER     0x03

#define DeviceRequest ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_DEVICE)<<8)
#define DeviceOutRequest ((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_DEVICE)<<8)
#define VendorDeviceRequest ((USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_DEVICE)<<8)
#define VendorDeviceOutRequest \
        ((USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_DEVICE)<<8)

#define InterfaceRequest                                        \
        ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
#define InterfaceOutRequest \
        ((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_INTERFACE)<<8)
#define ClassInterfaceRequest \
        ((USB_DIR_IN|USB_TYPE_CLASS|USB_RECIP_INTERFACE)<<8)
#define ClassInterfaceOutRequest \
        ((USB_DIR_OUT|USB_TYPE_CLASS|USB_RECIP_INTERFACE)<<8)
#define VendorInterfaceRequest \
        ((USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE)<<8)
#define VendorInterfaceOutRequest \
        ((USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE)<<8)

#define EndpointRequest ((USB_DIR_IN|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)<<8)
#define EndpointOutRequest \
        ((USB_DIR_OUT|USB_TYPE_STANDARD|USB_RECIP_ENDPOINT)<<8)

#define USB_REQ_GET_STATUS              0x00
#define USB_REQ_CLEAR_FEATURE           0x01
#define USB_REQ_SET_FEATURE             0x03
#define USB_REQ_SET_ADDRESS             0x05
#define USB_REQ_GET_DESCRIPTOR          0x06
#define USB_REQ_SET_DESCRIPTOR          0x07
#define USB_REQ_GET_CONFIGURATION       0x08
#define USB_REQ_SET_CONFIGURATION       0x09
#define USB_REQ_GET_INTERFACE           0x0A
#define USB_REQ_SET_INTERFACE           0x0B
#define USB_REQ_SYNCH_FRAME             0x0C
#define USB_REQ_SET_SEL                 0x30
#define USB_REQ_SET_ISOCH_DELAY         0x31

#define USB_DEVICE_SELF_POWERED            0
#define USB_DEVICE_REMOTE_WAKEUP           1

#define USB_DT_DEVICE                   0x01
#define USB_DT_CONFIG                   0x02
#define USB_DT_STRING                   0x03
#define USB_DT_INTERFACE                0x04
#define USB_DT_ENDPOINT                 0x05
#define USB_DT_DEVICE_QUALIFIER         0x06
#define USB_DT_OTHER_SPEED_CONFIG       0x07
#define USB_DT_DEBUG                    0x0A
#define USB_DT_INTERFACE_ASSOC          0x0B
#define USB_DT_BOS                      0x0F
#define USB_DT_DEVICE_CAPABILITY        0x10
#define USB_DT_CS_INTERFACE             0x24
#define USB_DT_CS_ENDPOINT              0x25
#define USB_DT_ENDPOINT_COMPANION       0x30

#define USB_DEV_CAP_WIRELESS            0x01
#define USB_DEV_CAP_USB2_EXT            0x02
#define USB_DEV_CAP_SUPERSPEED          0x03

#define USB_CFG_ATT_ONE              (1 << 7) /* should always be set */
#define USB_CFG_ATT_SELFPOWER        (1 << 6)
#define USB_CFG_ATT_WAKEUP           (1 << 5)
#define USB_CFG_ATT_BATTERY          (1 << 4)

#define USB_ENDPOINT_XFER_CONTROL       0
#define USB_ENDPOINT_XFER_ISOC          1
#define USB_ENDPOINT_XFER_BULK          2
#define USB_ENDPOINT_XFER_INT           3
#define USB_ENDPOINT_XFER_INVALID     255

#define USB_INTERFACE_INVALID         255


#endif // _MVISOR_DEVICES_USB_USB_H

```

`devices/usb/usb_descriptor.h`:

```h
/* 
 * MVisor USB Descriptor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */


#ifndef _MVISOR_DEVICES_USB_USB_DESCRIPTOR_H
#define _MVISOR_DEVICES_USB_USB_DESCRIPTOR_H

#include <cstdint>

typedef const char *UsbStringsDescriptor[256];

struct UsbOtherDescriptor {
  const uint8_t*            data;
} __attribute__((packed));


struct UsbEndpointDescriptor {
  uint8_t                   bLength = 9;
  uint8_t                   bDescriptorType = 0x05;
  uint8_t                   bEndpointAddress;
  uint8_t                   bmAttributes;
  uint16_t                  wMaxPacketSize;
  uint8_t                   bInterval;
  uint8_t                   bRefresh;
  uint8_t                   bSynchAddress;

  const bool                is_audio; /* has bRefresh + bSynchAddress */
  const uint8_t*            extra;
} __attribute__((packed));

struct UsbInterfaceDescriptor {
  uint8_t                   bLength = 9;
  uint8_t                   bDescriptorType = 0x04;
  uint8_t                   bInterfaceNumber;
  uint8_t                   bAlternateSetting;
  uint8_t                   bNumEndpoints;
  uint8_t                   bInterfaceClass;
  uint8_t                   bInterfaceSubClass;
  uint8_t                   bInterfaceProtocol;
  uint8_t                   iInterface;

  uint8_t                         ndesc;
  const UsbOtherDescriptor*       descriptors;
  const UsbEndpointDescriptor*    endpoints;
} __attribute__((packed));

struct UsbConfigurationDescriptor {
  uint8_t                   bLength = 9;
  uint8_t                   bDescriptorType = 0x02;
  uint16_t                  wTotalLength = 0;
  uint8_t                   bNumInterfaces = 1;
  uint8_t                   bConfigurationValue = 1;
  uint8_t                   iConfiguration = 0;
  uint8_t                   bmAttributes;
  uint8_t                   bMaxPower = 50;

  const UsbInterfaceDescriptor*   interfaces;
} __attribute__((packed));

struct UsbDeviceDescriptor {
  uint8_t                   bLength = 18;
  uint8_t                   bDescriptorType = 0x01;
  uint16_t                  bcdUSB = 0x0200;
  uint8_t                   bDeviceClass;
  uint8_t                   bDeviceSubClass;
  uint8_t                   bDeviceProtocol;
  uint8_t                   bMaxPacketSize0 = 8;
  uint16_t                  idVendor;
  uint16_t                  idProduct;
  uint16_t                  bcdDevice;
  uint8_t                   iManufacturer = 1;
  uint8_t                   iProduct = 2;
  uint8_t                   iSerialNumber = 3;
  uint8_t                   bNumConfigurations = 1;

  const UsbConfigurationDescriptor*  configurations;
} __attribute__((packed));


#endif // _MVISOR_DEVICES_USB_USB_DESCRIPTOR_H

```

`devices/usb/usb_device.cc`:

```cc
/* 
 * MVisor USB Device
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "usb_device.h"

#include <cstring>

#include "usb.h"
#include "logger.h"
#include "device_manager.h"
#include "usb_device.pb.h"

UsbDevice::UsbDevice() {
  set_default_parent_class("XhciHost", "Piix3Uhci");

  speed_ = kUsbSpeedFull;
}

void UsbDevice::Connect() {
  Device::Connect();
  host_ = dynamic_cast<UsbHost*>(parent_);
  MV_ASSERT(host_);
}

void UsbDevice::Disconnect() {
  RemoveEndpoints();
  Device::Disconnect();
}

void UsbDevice::Reset() {
  Device::Reset();

  configuration_value_ = 0;
  config_ = nullptr;
  device_address_ = 0;

  RemoveEndpoints();
}

void UsbDevice::RemoveEndpoints() {
  for (auto endpoint : endpoints_) {
    delete endpoint;
  }
  endpoints_.clear();
}

bool UsbDevice::SaveState(MigrationWriter* writer) {
  UsbDeviceState state;
  state.set_device_address(device_address_);
  state.set_configuration_value(configuration_value_);
  state.set_remote_wakeup(remote_wakeup_);
  writer->WriteProtobuf("USB_DEVICE", state);
  return Device::SaveState(writer);
}

bool UsbDevice::LoadState(MigrationReader* reader) {
  if (!Device::LoadState(reader)) {
    return false;
  }
  UsbDeviceState state;
  if (!reader->ReadProtobuf("USB_DEVICE", state)) {
    return false;
  }
  device_address_ = state.device_address();
  remote_wakeup_ = state.remote_wakeup();
  SetConfiguration(state.configuration_value());
  return true;
}

bool UsbDevice::HandlePacket(UsbPacket* packet) {
  if (packet->endpoint_address & 0xF) {
    OnDataPacket(packet);
  } else {
    OnControlPacket(packet);
  }
  return true;
}

void UsbDevice::OnControlPacket(UsbPacket* packet) {
  uint8_t* setup_buf = (uint8_t*)&packet->control_parameter;
  uint request  = (setup_buf[0] << 8) | setup_buf[1];
  uint value    = (setup_buf[3] << 8) | setup_buf[2];
  uint index    = (setup_buf[5] << 8) | setup_buf[4];

  uint setup_len = (setup_buf[7] << 8) | setup_buf[6];
  if (debug_) {
    MV_LOG("control ep=0x%x request=0x%x value=0x%x index=0x%x setup_len=0x%x",
      packet->endpoint_address, request, value, index, setup_len);
  }
  
  uint8_t buffer[setup_len];
  if (packet->endpoint_address == 0x00 && setup_len) {
    CopyPacketData(packet, buffer, setup_len);
  }

  packet->status = USB_RET_SUCCESS;
  int ret = OnControl(request, value, index, buffer, setup_len);
  if (ret < 0) {
    packet->status = ret;
    return;
  }

  if (packet->endpoint_address == 0x80) {
    CopyPacketData(packet, buffer, ret);
  }
}

void UsbDevice::OnDataPacket(UsbPacket* packet) {
  uint8_t buffer[packet->size];
  packet->status = USB_RET_SUCCESS;

  if (packet->endpoint_address & 0x80) { // IN
    int ret = OnInputData(packet->endpoint_address, buffer, packet->size);
    if (ret < 0) {
      packet->status = ret;
    } else {
      CopyPacketData(packet, buffer, ret);
    }
  } else { // OUT
    CopyPacketData(packet, buffer, packet->size);
    int ret = OnOutputData(packet->endpoint_address, buffer, packet->size);
    if (ret < 0) {
      packet->status = ret;
    }
  }
}

/* Ask host controller to handle data packets */
void UsbDevice::NotifyEndpoint(uint endpoint_address) {
  host_->Schedule([this, endpoint_address]() {
    host_->NotifyEndpoint(this, endpoint_address);
  });
}

void UsbDevice::CopyPacketData(UsbPacket* packet, uint8_t* data, int length) {
  MV_ASSERT(packet->content_length + length <= packet->size);

  size_t left = length;
  uint8_t* ptr = data;
  for (auto &v : packet->iov) {
    size_t copy = left;
    if (copy > v.iov_len) {
      copy = v.iov_len;
    }
    if (packet->endpoint_address & 0x80) {
      memcpy(v.iov_base, ptr, copy);
    } else {
      memcpy(ptr, v.iov_base, copy);
    }
    ptr += copy;
    left -= copy;
    if (left == 0)
      break;
  }
  packet->content_length += length;
}

int UsbDevice::OnInputData(uint endpoint_address, uint8_t* data, int length) {
  MV_UNUSED(endpoint_address);
  MV_UNUSED(data);
  MV_UNUSED(length);
  return USB_RET_STALL;
}

int UsbDevice::OnOutputData(uint endpoint_address, uint8_t* data, int length) {
  MV_UNUSED(endpoint_address);
  MV_UNUSED(data);
  MV_UNUSED(length);
  return USB_RET_STALL;
}

int UsbDevice::OnControl(uint request, uint value, uint index, uint8_t* data, int length) {
  switch (request)
  {
  case DeviceOutRequest | USB_REQ_SET_ADDRESS:
    device_address_ = value;
    return 0;

  case DeviceRequest | USB_REQ_GET_DESCRIPTOR:
    return GetDescriptor(value, data, length);
  
  case DeviceRequest | USB_REQ_GET_CONFIGURATION:
    data[0] = config_ ? config_->bConfigurationValue : 0;
    return 1;
  
  case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:
    return SetConfiguration(value);
  
  case DeviceRequest | USB_REQ_GET_STATUS:
    return GetStatus(data, length);
  
  case DeviceOutRequest | USB_REQ_CLEAR_FEATURE:
    if (value == USB_DEVICE_REMOTE_WAKEUP) {
      remote_wakeup_ = false;
      return 0;
    }
    break;
  
  case DeviceOutRequest | USB_REQ_SET_FEATURE:
    if (value == USB_DEVICE_REMOTE_WAKEUP) {
      remote_wakeup_ = true;
      return 0;
    }
    break;

  case DeviceOutRequest | USB_REQ_SET_SEL:
  case DeviceOutRequest | USB_REQ_SET_ISOCH_DELAY:
    if (speed_ == USB_SPEED_SUPER) {
      return 0;
    }
    break;

  case InterfaceRequest | USB_REQ_GET_INTERFACE:
    if (config_ && index < config_->bNumInterfaces) {
      data[0] = alternate_settings_[index];
      return 1;
    }
    break;

  case InterfaceOutRequest | USB_REQ_SET_INTERFACE:
    return SetInterface(index, value);

  case VendorDeviceRequest | 'Q':
  case VendorInterfaceRequest | 'Q':
    return GetMicrosoftOsDescriptor(index, data, length);
  }

  MV_ERROR("not implemented request=0x%x value=0x%x index=0x%x", request, value, index);
  return USB_RET_STALL;
}

void UsbDevice::SetupDescriptor(const UsbDeviceDescriptor* device_desc,
  const UsbStringsDescriptor* strings_desc) {
  device_descriptor_ = device_desc;
  strings_descriptor_ = strings_desc;
}

int UsbDevice::CopyStringsDescriptor(uint index, uint8_t* data, int length) {
  if (length < 4) {
    return USB_RET_IOERROR;
  }
  
  if (index == 0) {
    data[0] = 4;
    data[1] = USB_DT_STRING;
    data[2] = 9;
    data[3] = 4;
    return 4;
  }

  const char* str = (*strings_descriptor_)[index];
  if (str == nullptr) {
    MV_LOG("invalid string index=0x%x length=%d", index, length);
    return USB_RET_STALL;
  }
  int bLength = strlen(str) * 2 + 2;
  data[0] = bLength;
  data[1] = USB_DT_STRING;
  int pos = 2;
  for (int i = 0; pos + 1 < bLength && pos + 1 < length;) {
    data[pos++] = str[i++];
    data[pos++] = 0;
  }
  return pos;
}

int UsbDevice::CopyDeviceQualifier(uint8_t* data, int length) {
  uint8_t bLength = 0x0A;

  if (length < bLength) {
    return USB_RET_IOERROR;
  }

  data[0] = bLength;
  data[1] = USB_DT_DEVICE_QUALIFIER;

  data[2] = device_descriptor_->bcdUSB & 0xFF;
  data[3] = device_descriptor_->bcdUSB >> 8;
  data[4] = device_descriptor_->bDeviceClass;
  data[5] = device_descriptor_->bDeviceSubClass;
  data[6] = device_descriptor_->bDeviceProtocol;
  data[7] = device_descriptor_->bMaxPacketSize0;
  data[8] = device_descriptor_->bNumConfigurations;
  data[9] = 0; // reserved
  return bLength;
}

int UsbDevice::CopyConfigurationDescriptor(uint index, uint8_t* data, int length) {
  if (index >= device_descriptor_->bNumConfigurations) {
    return USB_RET_IOERROR;
  }

  uint8_t buffer[4096];
  uint16_t wTotalLength = 0;
  auto config = &device_descriptor_->configurations[index];
  
  // Copy configuration
  memcpy(&buffer[wTotalLength], config, config->bLength);
  wTotalLength += config->bLength;

  // Copy interfaces
  for (int i = 0; i < config->bNumInterfaces; i++) {
    // interface
    auto interface = &config->interfaces[i];
    memcpy(&buffer[wTotalLength], interface, interface->bLength);
    wTotalLength += interface->bLength;
    // other
    for (int j = 0; j < interface->ndesc; j++) {
      auto other = &interface->descriptors[j];
      uint length = other->data[0];
      memcpy(&buffer[wTotalLength], other->data, length);
      wTotalLength += length;
    }
    // endpoint
    for (int j = 0; j < interface->bNumEndpoints; j++) {
      auto endpoint = &interface->endpoints[j];
      uint length = endpoint->is_audio ? endpoint->bLength : endpoint->bLength - 2;
      memcpy(&buffer[wTotalLength], endpoint, length);
      buffer[wTotalLength] = length;
      wTotalLength += length;

      if (endpoint->extra) {
        length = endpoint->extra[0];
        memcpy(&buffer[wTotalLength], endpoint->extra, length);
        wTotalLength += length;
      }
    }
  }

  *(uint16_t*)&buffer[2] = wTotalLength;
  if (length > wTotalLength) {
    length = wTotalLength;
  }
  memcpy(data, buffer, length);
  return length;
}

int UsbDevice::GetDescriptor(uint value, uint8_t* data, int length) {
  uint8_t type = value >> 8;
  uint8_t index = value & 0xFF;

  switch (type)
  {
  case USB_DT_DEVICE:
    if (length > device_descriptor_->bLength) {
      length = device_descriptor_->bLength;
    }
    memcpy(data, device_descriptor_, length);
    return length;
  
  case USB_DT_CONFIG:
    return CopyConfigurationDescriptor(index, data, length);
  
  case USB_DT_STRING:
    return CopyStringsDescriptor(index, data, length);

  case USB_DT_DEVICE_QUALIFIER:
    return CopyDeviceQualifier(data, length);

  default:
    MV_ERROR("unknown type=%d", type);
    return USB_RET_STALL;
  }
}

int UsbDevice::GetStatus(uint8_t* data, int length) {
  MV_PANIC("not implemented data=%d length=%d", data[0], length);
  return USB_RET_STALL;
}

int UsbDevice::SetConfiguration(uint value) {
  /* delete all endpoints */
  RemoveEndpoints();
  configuration_value_ = 0;
  config_ = nullptr;

  if (value == 0) {
    return 0;
  }

  for (uint i = 0; i < device_descriptor_->bNumConfigurations; i++) {
    auto c = &device_descriptor_->configurations[i];
    if (c->bConfigurationValue == value) {
      config_ = c;
      configuration_value_ = value;
      /* initialize interfaces */
      for (uint j = 0; j < config_->bNumInterfaces; j++) {
        auto interface = &config_->interfaces[j];
        for (uint k = 0; k < interface->bNumEndpoints; k++) {
          auto desc = &interface->endpoints[k];
          /* create endpoint */
          auto endpoint = new UsbEndpoint;
          endpoint->device = this;
          endpoint->address = desc->bEndpointAddress;
          endpoint->type = UsbEndpointType(desc->bmAttributes & 3);
          endpoint->interface = j;
          endpoint->interval = (1 << (desc->bInterval - 1)) * 125 / 1000;
          if (endpoint->interval < 1 || endpoint->interval > 1000) {
            MV_ERROR("invalid interval=%u", endpoint->interval);
            endpoint->interval = 1;
          }
          endpoints_.push_back(endpoint);
        }
      }
    }
  }
  return 0;
}

int UsbDevice::SetInterface(uint index, uint value) {
  MV_PANIC("not implemented index=0x%x value=0x%x", index, value);
  return USB_RET_STALL;
}

UsbEndpoint* UsbDevice::FindEndpoint(uint address) {
  for (auto endpoint : endpoints_) {
    if (endpoint->address == address) {
      return endpoint;
    }
  }
  return nullptr;
}

/* 
 * Not implemented yet. Maybe cellphones use this feature.
 * https://docs.microsoft.com/en-us/windows-hardware/drivers/usbcon/microsoft-defined-usb-descriptors 
 */
int UsbDevice::GetMicrosoftOsDescriptor(uint index, uint8_t* data, int length) {
  if (debug_) {
    MV_LOG("unhandled MsOsd index=%d data=%d length=%d", index, data[0], length);
  }
  return USB_RET_STALL;
}


```

`devices/usb/usb_device.h`:

```h
/* 
 * MVisor USB Device
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_USB_DEVICE_H
#define _MVISOR_DEVICES_USB_USB_DEVICE_H

#include "pci_device.h"
#include "usb_descriptor.h"
#include <sys/uio.h>
#include <list>
#include "io_thread.h"

#define USB_MAX_INTERFACES 16

enum UsbSpeed {
  kUsbSpeedLow = 0,
  kUsbSpeedFull,
  kUsbSpeedHigh,
  kUsbSpeedSuper
};

enum UsbEndpointType {
  kUsbEndpointControl,
  kUsbEndpointIsochronous,
  kUsbEndpointBulk,
  kUsbEndpointInterrupt
};

class UsbDevice;
struct UsbPacket;
struct UsbEndpoint {
  UsbDevice*                device;
  uint                      address;
  UsbEndpointType           type;
  uint                      interface;
  uint                      interval;
};

struct UsbPacket {
  uint                      endpoint_address;
  uint                      stream_id;
  uint64_t                  id;
  int                       status;
  size_t                    content_length;
  uint64_t                  control_parameter;
  size_t                    size;
  std::vector<struct iovec> iov;
};

class UsbHost : public PciDevice {
 public:
  virtual ~UsbHost() {}
  virtual void NotifyEndpoint(UsbDevice* device, uint endpoint_address) = 0;
};

class UsbDevice : public Device {
 public:
  UsbDevice();
  virtual void Connect();
  virtual void Disconnect();
  virtual void Reset();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

  bool HandlePacket(UsbPacket* packet);

  int speed() { return speed_; }
  int device_address() { return device_address_; }
  bool configured() { return configuration_value_ > 0; }

 protected:
  int                               device_address_ = 0;
  int                               speed_;
  std::vector<UsbEndpoint*>         endpoints_;
  const UsbDeviceDescriptor*        device_descriptor_ = nullptr;
  const UsbStringsDescriptor*       strings_descriptor_ = nullptr;
  const UsbConfigurationDescriptor* config_ = nullptr;
  uint8_t                           configuration_value_ = 0;
  bool                              remote_wakeup_ = false;
  int                               alternate_settings_[16] = { 0 };
  UsbHost*                          host_ = nullptr;

  void SetupDescriptor(const UsbDeviceDescriptor*, const UsbStringsDescriptor*);

  /* Low level interfaces */
  virtual void OnControlPacket(UsbPacket* packet);
  virtual void OnDataPacket(UsbPacket* packet);

  virtual int OnControl(uint request, uint value, uint index, uint8_t* data, int length);
  virtual int OnInputData(uint endpoint_address, uint8_t* data, int length);
  virtual int OnOutputData(uint endpoint_address, uint8_t* data, int length);

  UsbEndpoint* FindEndpoint(uint endpoint_address);
  virtual void NotifyEndpoint(uint endpoint_address);

 private:
  void RemoveEndpoints();
  void CopyPacketData(UsbPacket* packet, uint8_t* data, int length);
  int CopyConfigurationDescriptor(uint index, uint8_t* data, int length);
  int CopyStringsDescriptor(uint index, uint8_t* data, int length);
  int CopyDeviceQualifier(uint8_t* data, int length);
  int GetDescriptor(uint value, uint8_t* data, int length);
  int GetStatus(uint8_t* data, int length);
  int SetConfiguration(uint value);
  int SetInterface(uint index, uint value);
  int GetMicrosoftOsDescriptor(uint index, uint8_t* data, int length);
};

#endif // _MVISOR_DEVICES_USB_USB_DEVICE_H

```

`devices/usb/usb_device.proto`:

```proto
syntax = "proto3";

message UsbDeviceState {
  uint32  configuration_value     = 1;
  uint32  remote_wakeup           = 2;
  uint32  device_address          = 3;
}

```

`devices/usb/usb_hid.cc`:

```cc
/* 
 * MVisor USB HID
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "usb_hid.h"


```

`devices/usb/usb_hid.h`:

```h
/* 
 * MVisor USB HID
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_USB_HID_H
#define _MVISOR_DEVICES_USB_USB_HID_H

#include "usb_device.h"

/* HID interface requests */
#define HID_GET_REPORT   0xA101
#define HID_GET_IDLE     0xA102
#define HID_GET_PROTOCOL 0xA103
#define HID_SET_REPORT   0x2109
#define HID_SET_IDLE     0x210A
#define HID_SET_PROTOCOL 0x210B

/* HID descriptor types */
#define USB_DT_HID    0x21
#define USB_DT_REPORT 0x22
#define USB_DT_PHY    0x23


class UsbHid : public UsbDevice {
 protected:
  
 public:

};


#endif // _MVISOR_DEVICES_USB_USB_HID_H

```

`devices/usb/usb_midi.cc`:

```cc
/*
 * MVisor USB MIDI
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include <deque>

#include "device_interface.h"
#include "device_manager.h"
#include "logger.h"
#include "usb.h"
#include "usb_descriptor.h"
#include "usb_hid.h"

enum {
  STR_MANUFACTURER = 1,
  STR_PRODUCT,
  STR_CONFIG,
};

static const UsbStringsDescriptor strings_desc = {
  [0] = "",
  [STR_MANUFACTURER]     = "Tenclass",
  [STR_PRODUCT]          = "Tenclass USB Midi",
  [STR_CONFIG]           = "HID Midi",
  [4]                    = "HID Midi",
  [5]                    = "HID Midi",
  [6]                    = "END",
};


static const UsbDeviceDescriptor device_desc = {
  .bLength = 18,
  .bDescriptorType = 1,
  .bcdUSB = 0x110,
  .bDeviceClass = 0,
  .bDeviceSubClass = 0,
  .bDeviceProtocol = 0,
  .bMaxPacketSize0 = 64,
  .idVendor = 0x2467,
  .idProduct = 0x2016,
  .bcdDevice = 0x0032,
  .iManufacturer = STR_MANUFACTURER,
  .iProduct = STR_PRODUCT,
  .iSerialNumber = 0,
  .bNumConfigurations = 1,
  .configurations = (UsbConfigurationDescriptor[]) {
    { 
      .bLength = 9,
      .bDescriptorType = 2,
      .wTotalLength = 117,
      .bNumInterfaces = 2,
      .bConfigurationValue = 1,
      .iConfiguration = STR_CONFIG,
      .bmAttributes = 0xc0,
      .bMaxPower = 50,
      .interfaces =(UsbInterfaceDescriptor[]) {
        {
          .bLength = 9,
          .bDescriptorType = 4,
          .bInterfaceNumber = 0,
          .bAlternateSetting = 0,
          .bNumEndpoints = 0,
          .bInterfaceClass = 1,
          .bInterfaceSubClass = 1,
          .bInterfaceProtocol = 0,
          .iInterface = 0,
          .ndesc = 1,
          .descriptors = (UsbOtherDescriptor[]) {
            {
              //MIDI Adapter Class-specific AC Interface Descriptor (MIDI10.pdf Appendix B.3.2)
              .data = (uint8_t[]){
                9,			    /* sizeof(usbDescrCDC_HeaderFn): length of descriptor in bytes */
                0x24,			  /* descriptor type 0x24: CS_INTERFACE - special to USB, so not defined in usbdrv.h */
                1,			    /* header functional descriptor */
                0x0, 0x01,  /* bcdADC */
                9, 0,			  /* wTotalLength */
                1,			    /* */
                1,			    /* */
              }
            }
          }
        },
        {
          .bLength = 9,
          .bDescriptorType = 4,
          .bInterfaceNumber = 1,
          .bAlternateSetting = 0,
          .bNumEndpoints = 2,
          .bInterfaceClass = 1,
          .bInterfaceSubClass = 3,
          .bInterfaceProtocol = 0,
          .iInterface = 0,
          .ndesc = 7,
          .descriptors = (UsbOtherDescriptor[]) {
            {
              // Class-specific MIDI Streaming Interface Descriptor: Header Descriptor
              .data = (uint8_t[]) {
                7,			    /* length of descriptor in bytes */
                0x24,			  /* descriptor type 0x24: CS_INTERFACE */
                1,			    /* header functional descriptor */
                0x0, 0x01,	/* bcdADC */
                81, 0,			/* wTotalLength */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI IN Jack descriptor
              .data = (uint8_t[]) {
                6,			/* bLength */
                0x24,		/* descriptor type 0x24: CS_INTERFACE */
                2,			/* MIDI_IN_JACK desc subtype */
                1,			/* EXTERNAL bJackType */
                1,			/* bJackID */
                4,			/* iJack */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI IN Jack descriptor
              .data = (uint8_t[]) {
                6,			/* bLength */
                0x24,		/* descriptor type 0x24: CS_INTERFACE */
                2,			/* MIDI_IN_JACK desc subtype */
                2,			/* EMBEDDED bJackType */
                2,			/* bJackID */
                0,			/* iJack */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI OUT Jack descriptor
              .data = (uint8_t[]) {
                9,			/* length of descriptor in bytes */
                0x24,		/* descriptor type 0x24: CS_INTERFACE */
                3,			/* MIDI_OUT_JACK descriptor */
                1,			/* EMBEDDED bJackType */
                3,			/* bJackID */
                1,			/* No of input pins */
                2,			/* BaSourceID */
                1,			/* BaSourcePin */
                3,			/* iJack */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI OUT Jack descriptor
              .data = (uint8_t[]) {
                9,			/* bLength of descriptor in bytes */
                0x24,		/* bDescriptorType */
                3,			/* MIDI_OUT_JACK bDescriptorSubtype */
                2,			/* EXTERNAL bJackType */
                4,			/* bJackID */
                1,			/* bNrInputPins */
                1,			/* baSourceID (0) */
                1,			/* baSourcePin (0) */
                0,			/* iJack */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI IN Jack descriptor
              .data = (uint8_t[]) {
                6,			/* bLength */
                0x24,		/* descriptor type 0x24: CS_INTERFACE */
                2,			/* MIDI_IN_JACK desc subtype */
                2,			/* EXTERNAL bJackType */
                5,			/* bJackID */
                0,			/* iJack */
              }
            },
            {
              // Class-specific MIDI Streaming Interface Descriptor: MIDI OUT Jack descriptor
              .data = (uint8_t[]) {
                9,			/* bLength of descriptor in bytes */
                0x24,		/* bDescriptorType */
                3,			/* MIDI_OUT_JACK bDescriptorSubtype */
                1,			/* EXTERNAL bJackType */
                6,			/* bJackID */
                1,			/* bNrInputPins */
                5,			/* baSourceID (0) */
                1,			/* baSourcePin (0) */
                5,			/* iJack */
              }
            }
          },
          .endpoints = (UsbEndpointDescriptor[]) {
             {
              .bLength = 9,
              .bDescriptorType = 5,
              .bEndpointAddress = 0x82,
              .bmAttributes = 2,
              .wMaxPacketSize = 64,
              .bInterval = 4,
              .bRefresh = 0,
              .bSynchAddress = 0,
              .is_audio = true,

              //Class-specific MS Bulk IN Endpoint Descriptor (MIDI10.pdf Appendix Descriptor B.6.2)
              .extra = (uint8_t[]) {
                6,			/* bLength of descriptor in bytes */
                0x25,		/* bDescriptorType 0x25: CS_ENDPOINT */
                1,			/* bDescriptorSubtype */
                2,			/* bNumEmbMIDIJack (0) */
                3,			/* baAssocJackID (0) */
                6       /* baAssocJackID (0) */
              }
            },
            {
              .bLength = 9,
              .bDescriptorType = 5,
              .bEndpointAddress = 2,
              .bmAttributes = 2,
              .wMaxPacketSize = 64,
              .bInterval = 4,
              .bRefresh = 0,
              .bSynchAddress = 0,
              .is_audio = true,

              //Class-specific MS Bulk OUT Endpoint (MIDI10.pdf Appendix Descriptor B.5.2)
              .extra = (uint8_t[]) {
                5,			/* bLength of descriptor in bytes */
                0x25,		/* bDescriptorType 0x25: CS_ENDPOINT */
                1,			/* bDescriptorSubtype */
                1,			/* bNumEmbMIDIJack  */
                1,			/* baAssocJackID (0) */
              }
            }
          }
        }
      }
    }
  }
};

class UsbMidi : public UsbHid, public MidiInputInterface {
 private:
  std::deque<MidiEvent> queue_;
  uint max_queue_size_ = 16;
  bool started_ = false;

 public:
  UsbMidi() { SetupDescriptor(&device_desc, &strings_desc); }

  virtual int OnInputData(uint endpoint_address, uint8_t* data, int length) {
    if (debug_) {
      MV_LOG("request=%x data=%p length=%d", endpoint_address, data, length);
    }

    std::unique_lock<std::recursive_mutex> lock(mutex_);
    if (queue_.empty()) {
      return USB_RET_NAK;
    }

    auto event = queue_.front();
    queue_.pop_front();

    auto data_size = sizeof(MidiEvent);
    MV_ASSERT(length >= (int)data_size);
    memcpy(data, &event, data_size);
    return data_size;
  }

  /* This interface function is called by the UI thread, so use a mutex */
  virtual bool QueueMidiEvent(MidiEvent event) {
    std::lock_guard<std::recursive_mutex> lock(mutex_);

    if (!started_) {
      return false;
    }

    queue_.push_back(event);
    while (queue_.size() > max_queue_size_) {
      queue_.pop_front();
    }

    NotifyEndpoint(0x82);
    return true;
  }

  virtual bool InputAcceptable() { return started_ && configured(); }
  virtual void Start() { started_ = true; }
  virtual void Stop() { started_ = false; }
};

DECLARE_DEVICE(UsbMidi);

```

`devices/usb/usb_tablet.cc`:

```cc
/* 
 * MVisor USB Tablet
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "usb_hid.h"
#include <deque>
#include <cstring>
#include "usb_descriptor.h"
#include "usb.h"
#include "device_interface.h"
#include "device_manager.h"
#include "logger.h"

enum {
  STR_MANUFACTURER = 1,
  STR_PRODUCT,
  STR_CONFIG,
  STR_SERIAL
};

static const UsbStringsDescriptor strings_desc = {
  [0] = "",
  [STR_MANUFACTURER]     = "Tenclass",
  [STR_PRODUCT]          = "Tenclass USB Tablet",
  [STR_CONFIG]           = "HID Tablet",
  [STR_SERIAL]           = "28754",
};

static const UsbInterfaceDescriptor interfaces[] = {
  {
    .bInterfaceNumber   = 0,
    .bNumEndpoints      = 1,
    .bInterfaceClass    = USB_CLASS_HID,
    .ndesc              = 1,
    .descriptors = (UsbOtherDescriptor[]) {
      {
        /* HID descriptor */
        .data = (uint8_t[]) {
            0x09,          /*  u8  bLength */
            USB_DT_HID,    /*  u8  bDescriptorType */
            0x01, 0x00,    /*  u16 HID_class */
            0x00,          /*  u8  country_code */
            0x01,          /*  u8  num_descriptors */
            USB_DT_REPORT, /*  u8  type: Report */
            74, 0,         /*  u16 len */
        }
      }
    },
    .endpoints = (UsbEndpointDescriptor[]) {
      {
        .bEndpointAddress      = USB_DIR_IN | 0x01,
        .bmAttributes          = USB_ENDPOINT_XFER_INT,
        .wMaxPacketSize        = 8,
        .bInterval             = 4, /* 2 ^ (4-1) * 125 usecs = 1 ms */
      }
    }
  }
};

static const UsbDeviceDescriptor device_desc = {
  .bcdUSB                        = 0x0200,
  .bMaxPacketSize0               = 64,
  .idVendor                      = 0x0627,
  .idProduct                     = 0x0001,
  .bcdDevice                     = 0,
  .iManufacturer                 = STR_MANUFACTURER,
  .iProduct                      = STR_PRODUCT,
  .iSerialNumber                 = STR_SERIAL,
  .bNumConfigurations            = 1,
  .configurations = (UsbConfigurationDescriptor[]) {
    {
      .bNumInterfaces        = 1,
      .bConfigurationValue   = 1,
      .iConfiguration        = STR_CONFIG,
      .bmAttributes          = USB_CFG_ATT_ONE | USB_CFG_ATT_WAKEUP,
      .bMaxPower             = 50,
      .interfaces = interfaces
    }
  }
};

static const uint8_t hid_report_desc[] = {
  0x05, 0x01,    /* Usage Page (Generic Desktop) */
  0x09, 0x02,    /* Usage (Mouse) */
  0xa1, 0x01,    /* Collection (Application) */
  0x09, 0x01,    /*   Usage (Pointer) */
  0xa1, 0x00,    /*   Collection (Physical) */
  0x05, 0x09,    /*     Usage Page (Button) */
  0x19, 0x01,    /*     Usage Minimum (1) */
  0x29, 0x03,    /*     Usage Maximum (3) */
  0x15, 0x00,    /*     Logical Minimum (0) */
  0x25, 0x01,    /*     Logical Maximum (1) */
  0x95, 0x03,    /*     Report Count (3) */
  0x75, 0x01,    /*     Report Size (1) */
  0x81, 0x02,    /*     Input (Data, Variable, Absolute) */
  0x95, 0x01,    /*     Report Count (1) */
  0x75, 0x05,    /*     Report Size (5) */
  0x81, 0x01,    /*     Input (Constant) */
  0x05, 0x01,    /*     Usage Page (Generic Desktop) */
  0x09, 0x30,    /*     Usage (X) */
  0x09, 0x31,    /*     Usage (Y) */
  0x15, 0x00,    /*     Logical Minimum (0) */
  0x26, 0xff, 0x7f,  /*     Logical Maximum (0x7fff) */
  0x35, 0x00,    /*     Physical Minimum (0) */
  0x46, 0xff, 0x7f,  /*     Physical Maximum (0x7fff) */
  0x75, 0x10,    /*     Report Size (16) */
  0x95, 0x02,    /*     Report Count (2) */
  0x81, 0x02,    /*     Input (Data, Variable, Absolute) */
  0x05, 0x01,    /*     Usage Page (Generic Desktop) */
  0x09, 0x38,    /*     Usage (Wheel) */
  0x15, 0x81,    /*     Logical Minimum (-0x7f) */
  0x25, 0x7f,    /*     Logical Maximum (0x7f) */
  0x35, 0x00,    /*     Physical Minimum (same as logical) */
  0x45, 0x00,    /*     Physical Maximum (same as logical) */
  0x75, 0x08,    /*     Report Size (8) */
  0x95, 0x01,    /*     Report Count (1) */
  0x81, 0x06,    /*     Input (Data, Variable, Relative) */
  0xc0,    /*   End Collection */
  0xc0,    /* End Collection */
};

class UsbTablet : public UsbHid, public PointerInputInterface {
 private:
  std::deque<PointerEvent> queue_;
  uint idle_ = 0;
  uint max_queue_size_ = 16;

 public:
  UsbTablet() {
    SetupDescriptor(&device_desc, &strings_desc);
  }

  virtual int OnControl(uint request, uint value, uint index, uint8_t* data, int length) {
    switch (request)
    {
    /* hid specific requests */
    case InterfaceRequest | USB_REQ_GET_DESCRIPTOR:
      if ((value >> 8) == 0x22) {
        size_t copy = (size_t)length < sizeof(hid_report_desc) ? length : sizeof(hid_report_desc);
        memcpy(data, hid_report_desc, copy);
        return copy;
      } else {
        return USB_RET_STALL;
      }
    case HID_SET_IDLE:
      idle_ = uint8_t(value >> 8);
      return 0;
    default:
      return UsbHid::OnControl(request, value, index, data, length);
    }
  }

  virtual int OnInputData(uint endpoint_address, uint8_t* data, int length) {
    MV_UNUSED(endpoint_address);

    std::unique_lock<std::recursive_mutex> lock(mutex_);
    if (queue_.empty()) {
      return USB_RET_NAK;
    }

    auto event = queue_.front();
    queue_.pop_front();
    
    MV_ASSERT(length >= 6);
    data[0] = event.buttons;
    data[1] = event.x & 0xFF;
    data[2] = event.x >> 8;
    data[3] = event.y & 0xFF;
    data[4] = event.y >> 8;
    data[5] = event.z;
    return length;
  }

  /* This interface function is called by the UI thread, so use a mutex */
  virtual bool QueuePointerEvent(PointerEvent event) {
    std::lock_guard<std::recursive_mutex> lock(mutex_);

    /* SPICE buttons to PS/2 buttons */
    event.buttons = ((event.buttons & 2) ? 1 : 0) | ((event.buttons & 4) ? 4 : 0) | ((event.buttons & 8) ? 2 : 0);
    event.x = event.x * 0x8000 / event.screen_width;
    event.y = event.y * 0x8000 / event.screen_height;
    queue_.push_back(event);
    while (queue_.size() > max_queue_size_) {
      queue_.pop_front();
    }

    NotifyEndpoint(0x81);
    return true;
  }

  virtual bool InputAcceptable() {
    return configured();
  }

};

DECLARE_DEVICE(UsbTablet);

```

`devices/usb/usb_wacom.cc`:

```cc
/* 
 * MVisor USB Wacom
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "usb_hid.h"
#include <deque>
#include <cstring>
#include "usb_descriptor.h"
#include "usb.h"
#include "device_interface.h"
#include "device_manager.h"
#include "logger.h"

// wacom's width/height and pressure based on
// https://github.com/t3r1337/tablet/blob/49ce3cc5ff01e8eb0bdc872bbbe28c282a5a4bf0/config/wacom.cfg
#define MAX_PRESSURE 2047
#define MAX_WIDTH 15200
#define MAX_HEIGHT 9500

enum {
  STR_MANUFACTURER = 1,
  STR_PRODUCT,
  STR_SERIAL
};

static const UsbStringsDescriptor strings_desc = {
  [0] = "",
  [STR_MANUFACTURER]     = "Tenclass",
  [STR_PRODUCT]          = "Tenclass USB Wacom",
  [STR_SERIAL]           = "8EE00L1005567",
};

static const UsbInterfaceDescriptor interfaces[] = {
  {
    .bInterfaceNumber   = 0,
    .bNumEndpoints      = 1,
    .bInterfaceClass    = USB_CLASS_HID,
    .bInterfaceSubClass = 0x01,
    .bInterfaceProtocol = 0x02,
    .ndesc              = 1,
    .descriptors = (UsbOtherDescriptor[]) {
      {
        /* HID descriptor */
        .data = (uint8_t[]) {
            0x09,          /*  u8  bLength */
            USB_DT_HID,    /*  u8  bDescriptorType */
            0x10, 0x01,    /*  u16 HID_class */
            0x00,          /*  u8  country_code */
            0x01,          /*  u8  num_descriptors */
            USB_DT_REPORT, /*  u8  type: Report */
            0xe4, 0,         /*  u16 len */
        }
      }
    },
    .endpoints = (UsbEndpointDescriptor[]) {
      {
        .bEndpointAddress      = USB_DIR_IN | 0x03,
        .bmAttributes          = USB_ENDPOINT_XFER_INT,
        .wMaxPacketSize        = 16,
        .bInterval             = 4, /* 2 ^ (4-1) * 125 usecs = 1 ms */
        .is_audio              = true
      }
    }
  },
  {
    .bInterfaceNumber   = 1,
    .bNumEndpoints      = 1,
    .bInterfaceClass    = USB_CLASS_HID,
    .bInterfaceSubClass = 0x00,
    .bInterfaceProtocol = 0x02,
    .ndesc              = 1,
    .descriptors = (UsbOtherDescriptor[]) {
      {
        /* HID descriptor */
        .data = (uint8_t[]) {
            0x09,          /*  u8  bLength */
            USB_DT_HID,    /*  u8  bDescriptorType */
            0x10, 0x01,    /*  u16 HID_class */
            0x00,          /*  u8  country_code */
            0x01,          /*  u8  num_descriptors */
            USB_DT_REPORT, /*  u8  type: Report */
            0x26, 0,         /*  u16 len */
        }
      }
    },
    .endpoints = (UsbEndpointDescriptor[]) {
      {
        .bEndpointAddress      = USB_DIR_IN | 0x04,
        .bmAttributes          = USB_ENDPOINT_XFER_INT,
        .wMaxPacketSize        = 64,
        .bInterval             = 4, /* 2 ^ (4-1) * 125 usecs = 1 ms */
        .is_audio              = true
      }
    }
  }
};

static const UsbDeviceDescriptor device_desc = {
  .bcdUSB                        = 0x0200,
  .bMaxPacketSize0               = 64,
  .idVendor                      = 0x056a,
  .idProduct                     = 0x037a,
  .bcdDevice                     = 0x0100,
  .iManufacturer                 = STR_MANUFACTURER,
  .iProduct                      = STR_PRODUCT,
  .iSerialNumber                 = STR_SERIAL,
  .bNumConfigurations            = 1,
  .configurations = (UsbConfigurationDescriptor[]) {
    {
      .wTotalLength          = 59,
      .bNumInterfaces        = 2,
      .bConfigurationValue   = 1,
      .iConfiguration        = 0,
      .bmAttributes          = 0x80,
      .bMaxPower             = 249,
      .interfaces = interfaces
    }
  }
};

static const uint8_t hid_report_desc_interface[][300] = {
  {
    // interface1 hid_report_desc size = 292
    0x05,0x01,0x09,0x02,0xa1,0x01,0x85,0x01,0x09,0x01,0xa1,0x00,0x05,0x09,0x19,0x01,
    0x29,0x05,0x15,0x00,0x25,0x01,0x95,0x05,0x75,0x01,0x81,0x02,0x95,0x01,0x75,0x03,
    0x81,0x01,0x05,0x01,0x09,0x30,0x09,0x31,0x15,0x81,0x25,0x7f,0x75,0x08,0x95,0x02,
    0x81,0x06,0xc0,0xc0,0x06,0x0d,0xff,0x09,0x01,0xa1,0x01,0x85,0x02,0xa1,0x00,0x06,
    0x00,0xff,0x09,0x01,0x15,0x00,0x26,0xff,0x00,0x75,0x08,0x95,0x09,0x81,0x02,0xc0,
    0x09,0x01,0x85,0x02,0x95,0x01,0xb1,0x02,0x09,0x01,0x85,0x03,0x95,0x01,0xb1,0x02,
    0x09,0x01,0x85,0x04,0x95,0x01,0xb1,0x02,0x09,0x01,0x85,0x05,0x95,0x01,0xb1,0x02,
    0x09,0x01,0x85,0x10,0x95,0x02,0xb1,0x02,0x09,0x01,0x85,0x11,0x95,0x10,0xb1,0x02,
    0x09,0x01,0x85,0x13,0x95,0x01,0xb1,0x02,0x09,0x01,0x85,0x14,0x95,0x0d,0xb1,0x02,
    0x09,0x01,0x85,0x15,0x95,0x0e,0xb1,0x02,0x09,0x01,0x85,0x21,0x95,0x01,0xb1,0x02,
    0x09,0x01,0x85,0x22,0x95,0x01,0xb1,0x02,0x09,0x01,0x85,0x23,0x95,0x0e,0xb1,0x02,
    0x09,0x01,0x85,0x30,0x96,0x02,0x00,0xb1,0x02,0x09,0x01,0x85,0x31,0x96,0x09,0x01,
    0xb1,0x02,0x09,0x01,0x85,0x32,0x96,0x08,0x01,0xb1,0x02,0x09,0x01,0x85,0x24,0x95,
    0x1f,0xb1,0x02,0x09,0x01,0x85,0x25,0x95,0x04,0xb1,0x1f,0x85,0xc0,0x09,0x00,0x95,
    0x09,0x81,0x02,0xc0
  },
  {
    // interface2 hid_report_desc size = 102
    0x06,0x00,0xff,0x09,0x80,0xa1,0x01,0x85,0x02,0x09,0x01,0x15,0x00,0x26,0xff,0x00,
    0x75,0x08,0x95,0x3f,0x81,0x03,0x85,0x03,0x09,0x01,0x15,0x00,0x26,0xff,0x00,0x75,
    0x08,0x95,0x3f,0x81,0x03,0xc0
  }
};

class UsbWacom : public UsbHid, public WacomInputInterface {
 private:
  uint idle_ = 0;
  std::deque<WacomEvent> queue_;
  uint max_queue_size_ = 16;
  bool started_ = false;
  IoTimer* status_report_timer_ = nullptr;
  const uint8_t hid_data_report_[10] = {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01};

 public:
  UsbWacom() { SetupDescriptor(&device_desc, &strings_desc); }

  virtual void Reset() {
    // remove status report timer
    if (status_report_timer_) {
      RemoveTimer(status_report_timer_);
      status_report_timer_ = nullptr;
    }
    
    UsbHid::Reset();
  }

  void StartStatusReport() {
    auto timer_callback = [this]() {
      WacomEvent event;
      bzero(&event, sizeof(event));
      QueueWacomEvent(event);
    };

    if (!status_report_timer_) {
      status_report_timer_ = AddTimer(NS_PER_SECOND * 5, true, timer_callback);
    }
  }

  virtual int OnControl(uint request, uint value, uint index, uint8_t* data, int length) {
    switch (request) {
      /* hid specific requests */
      case InterfaceRequest | USB_REQ_GET_DESCRIPTOR:
        if ((value >> 8) == 0x22) {
          MV_ASSERT(index < 2);
          auto copy = std::min((size_t)length, sizeof(hid_report_desc_interface[index]));
          memcpy(data, hid_report_desc_interface[index], copy);
          return copy;
        } else {
          return USB_RET_STALL;
        }
      case DeviceRequest | USB_REQ_GET_STATUS: 
        MV_ASSERT(length >= 2);
        bzero(data, 2);
        return length;
      case HID_SET_REPORT:
        return USB_RET_SUCCESS;
      case HID_GET_REPORT:
        if (value == 0x0314) {
          auto serial_length = strlen(strings_desc[STR_SERIAL]);
          MV_ASSERT(length >= (int)serial_length + 1);
          
          // copy serial number to data at index 1
          bzero(data, length);
          memcpy(data + 1, strings_desc[STR_SERIAL], serial_length);
          return serial_length + 1;
        } else if (value == 0x0303) {
          MV_ASSERT(length == 3);
          bzero(data, length);
          memcpy(data, &value, 2);
          StartStatusReport();
          return length;
        } else {
          MV_LOG("unknown report %x", value);
          return USB_RET_SUCCESS;
        }
      case HID_SET_IDLE:
        idle_ = uint8_t(value >> 8);
        return USB_RET_SUCCESS;
      default:
        return UsbHid::OnControl(request, value, index, data, length);
    }
  }

  virtual int OnInputData(uint endpoint_address, uint8_t* data, int length) {
    if (debug_) {
      MV_LOG("request=%x data=%p length=%d", endpoint_address, data, length);
    }

    std::unique_lock<std::recursive_mutex> lock(mutex_);
    if (queue_.empty()) {
      return USB_RET_NAK;
    }

    auto event = queue_.front();
    queue_.pop_front();

    return TranslateWacomEventToHidData(event, data, length);
  }

  int TranslateWacomEventToHidData(WacomEvent& event, uint8_t* data, int length) {
    if (!event.x && !event.y && !event.pressure && !event.buttons) {
      int data_size = sizeof(hid_data_report_);
      MV_ASSERT(length >= data_size);

      // set status report
      memcpy(data, hid_data_report_, data_size);
      return data_size;
    }

    // hid base data 
    uint8_t hid_data[] = {0x02, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
    
    int data_size = sizeof(hid_data);
    MV_ASSERT(length >= data_size);

    // set buttons and pressure
    if (event.buttons || event.pressure) {
      hid_data[1] |= 0x20;
      if (event.buttons & 1) {
        hid_data[1] |= 1;
      }
      if (event.buttons & 2) {
        hid_data[1] |= 4;
      }
      if (event.buttons & 4) {
        hid_data[1] |= 2;
      }
      auto pressure = (uint16_t)(event.pressure * MAX_PRESSURE);
      memcpy(&hid_data[6], &pressure, sizeof(uint16_t));
    }

    // prox
    hid_data[1] |= 0x40;
    auto x = (uint16_t)(event.x * MAX_WIDTH);
    memcpy(&hid_data[2], &x, sizeof(uint16_t));
    auto y = (uint16_t)(event.y * MAX_HEIGHT);
    memcpy(&hid_data[4], &y, sizeof(uint16_t));

    // range
    hid_data[1] |= 0x80;
    hid_data[8] = 0x1f;
    memcpy(data, hid_data, data_size);
    return data_size;
  }

  /* This interface function is called by the UI thread, so use a mutex */
  virtual bool QueueWacomEvent(WacomEvent event) {
    std::lock_guard<std::recursive_mutex> lock(mutex_);

    if (!started_) {
      return false;
    }

    if (debug_) {
      MV_LOG("event data=%f data=%f data=%f data=%d data=%d data=%d", event.x,
             event.y, event.buttons, event.pressure, event.tilt_x, event.tilt_y);
    }

    queue_.push_back(event);
    while (queue_.size() > max_queue_size_) {
      queue_.pop_front();
    }

    NotifyEndpoint(0x83);
    return true;
  }

  virtual void Start() { started_ = true; }
  virtual void Stop() { started_ = false; }
  virtual bool InputAcceptable() { return started_ && configured(); }
};

DECLARE_DEVICE(UsbWacom);

```

`devices/usb/xhci_host.cc`:

```cc
/* 
 * MVisor USB 3.0 XHCI
 * SPEC: <https://www.intel.com/content/dam/www/public/us/en/documents/ \
 *    technical-specifications/extensible-host-controler-interface-usb-xhci.pdf>
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "xhci_host.h"

#include <chrono>
#include <cstring>

#include "usb.h"
#include "xhci_host.pb.h"
#include "device_manager.h"
#include "logger.h"

using namespace std::chrono;

XhciHost::XhciHost() {
  pci_header_.vendor_id = 0x1B36;
  pci_header_.device_id = 0x000D;
  pci_header_.class_code = 0x0C0330;
  pci_header_.revision_id = 1;
  pci_header_.header_type = PCI_HEADER_TYPE_NORMAL;
  pci_header_.subsys_vendor_id = 0x1AF4;
  pci_header_.subsys_id = 0x1100;
  pci_header_.cacheline_size = 0x10;
  pci_header_.command = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
  pci_header_.irq_pin = 1;

  /* Specification Release 3.0 */
  pci_header_.data[0x60] = 0x30;
  next_capability_offset_ = 0x90;

  AddPciBar(0, 0x4000, kIoResourceTypeMmio);
  AddMsiXCapability(0, 16, 0x3000, 0x1000);

  bzero(port_states_.data(), sizeof(port_states_[0]) * port_states_.size());
  bzero(port_regs_.data(), sizeof(port_regs_[0]) * port_regs_.size());
  bzero(slots_.data(), sizeof(slots_[0]) * slots_.size());
  bzero(interrupt_regs_.data(), sizeof(interrupt_regs_[0]) * interrupt_regs_.size());
}

void XhciHost::Connect() {
  PciDevice::Connect();
  
  MV_ASSERT(max_interrupts_ <= 128);
  MV_ASSERT(max_ports_ <= 128);
  MV_ASSERT(max_slots_ <= 128);

  /* USB ports are divided in half, 2.0 ports and 3.0 ports. */
  for (uint i = 0; i < max_ports_; i++) {
    port_states_[i].id = i + 1;
    port_states_[i].speed_mask = uint32_t(i < max_ports_ / 2 ? 0b111 : 0b1000);
    port_states_[i].device = nullptr;
  }

  /* Connect USB devices to ports */
  for (auto device : children_) {
    UsbDevice* usb = dynamic_cast<UsbDevice*>(device);
    if (usb) {
      AttachUsbDevice(usb);
    }
  }
}

void XhciHost::Disconnect() {
  /* disable slots and endpoints */
  for (uint i = 1; i <= max_slots_; i++) {
    DisableSlot(i);
  }
  PciDevice::Disconnect();
}

bool XhciHost::AttachUsbDevice(UsbDevice* device) {
  for (auto &port_state : port_states_) {
    if (port_state.device)
      continue;
    if ((port_state.speed_mask & (1 << device->speed())) == 0)
      continue;
    port_state.device = device;
    if (debug_) {
      MV_LOG("Attach USB device %s to port %d", device->name(), port_state.id);
    }
    return true;
  }
  MV_PANIC("failed to attach USB device %s", device->name());
  return false;
}

bool XhciHost::SaveState(MigrationWriter* writer) {
  XhciHostState state;
  auto operational = state.mutable_operational();
  operational->set_usb_command(operational_regs_.usb_command);
  operational->set_usb_status(operational_regs_.usb_status);
  operational->set_device_notification_control(operational_regs_.device_notification_control);
  operational->set_command_ring_control(operational_regs_.command_ring_control);
  operational->set_context_base_array_pointer(operational_regs_.context_base_array_pointer);
  operational->set_configure(operational_regs_.configure);

  auto runtime = state.mutable_runtime();
  runtime->set_microframe_index(GetMicroFrameIndex());

  auto command_ring = state.mutable_command_ring();
  command_ring->set_dequeue(command_ring_.dequeue);
  command_ring->set_consumer_cycle_bit(command_ring_.consumer_cycle_bit);

  for (uint i = 0; i < max_ports_; i++) {
    auto port = state.add_ports();
    port->set_status_control(port_regs_[i].status_control);
  }

  for (uint i = 0; i < max_slots_; i++) {
    auto slot = state.add_slots();
    slot->set_enabled(slots_[i].enabled);
    slot->set_addressed(slots_[i].addressed);
  }

  for (uint i = 0; i < max_interrupts_; i++) {
    auto interrupt = state.add_interrupts();
    interrupt->set_management(interrupt_regs_[i].management);
    interrupt->set_moderation(interrupt_regs_[i].moderation);
    interrupt->set_event_ring_table_size(interrupt_regs_[i].event_ring_table_size);
    interrupt->set_event_ring_table_base(interrupt_regs_[i].event_ring_table_base);
    interrupt->set_event_ring_dequeue_pointer(interrupt_regs_[i].event_ring_dequeue_pointer);
    interrupt->set_event_ring_segment_start(interrupt_regs_[i].event_ring_segment.start);
    interrupt->set_event_ring_segment_size(interrupt_regs_[i].event_ring_segment.size);
    interrupt->set_event_ring_enqueue_index(interrupt_regs_[i].event_ring_enqueue_index);
    interrupt->set_event_ring_producer_cycle_bit(interrupt_regs_[i].producer_cycle_bit);
  }

  writer->WriteProtobuf("XHCI", state);
  return PciDevice::SaveState(writer);
}

bool XhciHost::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }
  XhciHostState state;
  if (!reader->ReadProtobuf("XHCI", state)) {
    return false;
  }
  auto& operational = state.operational();
  operational_regs_.usb_command = operational.usb_command();
  operational_regs_.usb_status = operational.usb_status();
  operational_regs_.device_notification_control = operational.device_notification_control();
  operational_regs_.command_ring_control = operational.command_ring_control();
  operational_regs_.context_base_array_pointer = operational.context_base_array_pointer();
  operational_regs_.configure = operational.configure();

  auto& runtime = state.runtime();
  microframe_index_start_ = steady_clock::now() - nanoseconds(runtime.microframe_index() * 125000);

  auto& command_ring = state.command_ring();
  command_ring_.dequeue = command_ring.dequeue();
  command_ring_.consumer_cycle_bit = command_ring.consumer_cycle_bit();

  for (uint i = 0; i < max_ports_; i++) {
    auto& port = state.ports(i);
    port_regs_[i].status_control = port.status_control();
  }

  for (uint i = 0; i < max_slots_; i++) {
    auto& slot = state.slots(i);
    slots_[i].enabled = slot.enabled();
    slots_[i].addressed = slot.addressed();
    if (slot.addressed()) {
      PostLoadSlot(i + 1);
    }
  }

  for (uint i = 0; i < max_interrupts_; i++) {
    auto& interrupt = state.interrupts(i);
    interrupt_regs_[i].management = interrupt.management();
    interrupt_regs_[i].moderation = interrupt.moderation();
    interrupt_regs_[i].event_ring_table_size = interrupt.event_ring_table_size();
    interrupt_regs_[i].event_ring_table_base = interrupt.event_ring_table_base();
    interrupt_regs_[i].event_ring_dequeue_pointer = interrupt.event_ring_dequeue_pointer();
    interrupt_regs_[i].event_ring_segment.start = interrupt.event_ring_segment_start();
    interrupt_regs_[i].event_ring_segment.size = interrupt.event_ring_segment_size();
    interrupt_regs_[i].event_ring_enqueue_index = interrupt.event_ring_enqueue_index();
    interrupt_regs_[i].producer_cycle_bit = interrupt.event_ring_producer_cycle_bit();
  }
  return true;
}

void XhciHost::Reset() {
  PciDevice::Reset();

  MV_ASSERT(sizeof(capability_regs_) == 0x40);
  bzero(&capability_regs_, sizeof(capability_regs_));
  bzero(&operational_regs_, sizeof(operational_regs_));
  bzero(&runtime_regs_, sizeof(runtime_regs_));

  capability_regs_.capability_length = sizeof(capability_regs_);
  capability_regs_.interface_version = 0x0100;
  capability_regs_.max_slots = max_slots_;
  capability_regs_.max_interrupts = max_interrupts_;
  capability_regs_.max_ports = max_ports_;
  capability_regs_.hcs_params2 = 0x0000000F;
  capability_regs_.hcs_params3 = 0x00000000;
  capability_regs_.capability_params1 = 0x00080001 | (max_pstreams_mask_ << 12);
  capability_regs_.doorbell_offset = 0x2000;
  capability_regs_.runtime_registers_offset = 0x1000;

  /* Extended capabilites */
  uint32_t* ext = capability_regs_.extended_capabilities;
  /* Supported protocol USB 2.0 (port 1-4) */
  *ext++ = 0x02000402;
  *ext++ = 0x20425355;
  *ext++ = (4 << 8) | 1;
  *ext++ = 0;
  /* Supported protocol USB 3.0 (port 5-8) */
  *ext++ = 0x03000002;
  *ext++ = 0x20425355;
  *ext++ = (4 << 8) | 5;
  *ext++ = 0;

  /* Operational registers */
  operational_regs_.usb_status = USBSTS_HCH; // halted
  operational_regs_.page_size = 1; // 4KB

  for (uint i = 1; i <= max_slots_; i++) {
    DisableSlot(i);
  }

  for (auto &interrupt: interrupt_regs_) {
    bzero(&interrupt, sizeof(interrupt));
    interrupt.producer_cycle_bit = true;
  }
  
  for (uint i = 0; i < max_ports_; i++) {
    SetupPort(i);
  }
}

bool XhciHost::IsRunning() {
  return !(operational_regs_.usb_status & USBSTS_HCH);
}

void XhciHost::PushEvent(uint vector, XhciEvent &event) {
  if (debug_) {
    MV_LOG("ring[%d] event type=%d code=%d slot=%d", vector,
      event.type, event.completion_code, event.slot_id);
  }
  MV_ASSERT(vector < max_interrupts_);
  auto &interrupt = interrupt_regs_[vector];
  auto &segment = interrupt.event_ring_segment;
  auto dequeue_pointer = interrupt.event_ring_dequeue_pointer;
  auto dequeue_index = (dequeue_pointer - segment.start) / TRB_SIZE;
  auto enqueue_index = interrupt.event_ring_enqueue_index;
  MV_ASSERT(dequeue_index < segment.size);

  if ((enqueue_index + 2) % segment.size == dequeue_index) {
    MV_LOG("event ring[%d] is full, send error", vector);
    XhciEvent full = { ER_HOST_CONTROLLER, CC_EVENT_RING_FULL_ERROR };
    WriteEvent(vector, full);
  } else if ((enqueue_index + 1) % segment.size == dequeue_index) {
    MV_LOG("event ring[%d] is full, drop event", vector);
  } else {
    WriteEvent(vector, event);
  }
  RaiseInterrupt(vector);
}

void XhciHost::WriteEvent(uint vector, XhciEvent &event) {
  auto &interrupt = interrupt_regs_[vector];
  auto addr = interrupt.event_ring_segment.start + interrupt.event_ring_enqueue_index * TRB_SIZE;
  auto trb = (XhciTransferRequestBlock*)manager_->TranslateGuestMemory(addr);
  manager_->AddDirtyMemory(addr, sizeof(XhciTransferRequestBlock));
  trb->parameter = event.poniter;
  trb->status = event.length | (event.completion_code << 24);
  trb->control = (event.slot_id << 24) | (event.endpoint_id << 16) |
    event.flags | (event.type << TRB_TYPE_SHIFT);
  if (interrupt.producer_cycle_bit) {
    trb->control |= TRB_C;
  }

  interrupt.event_ring_enqueue_index++;
  if (interrupt.event_ring_enqueue_index >= interrupt.event_ring_segment.size) {
    interrupt.event_ring_enqueue_index = 0;
    interrupt.producer_cycle_bit = !interrupt.producer_cycle_bit;
  }
}

void XhciHost::SetupRing(XhciRing &ring, uint64_t base) {
  ring.consumer_cycle_bit = true;
  ring.dequeue = base;
}

bool XhciHost::PopRing(XhciRing &ring, XhciTransferRequestBlock &trb) {
  while (true) {
    void* hva = manager_->TranslateGuestMemory(ring.dequeue);
    memcpy(&trb, hva, TRB_SIZE);
    trb.address = ring.dequeue;
    trb.cycle_bit = ring.consumer_cycle_bit;
    
    if (!!(trb.control & TRB_C) != ring.consumer_cycle_bit) {
      // Maybe software is still writing the ring ??
      return false;
    }

    auto type = TRB_TYPE(trb);
    if (type == TR_LINK) {
      ring.dequeue = trb.parameter;
      if (trb.control & TRB_LK_TC) {
        ring.consumer_cycle_bit = !ring.consumer_cycle_bit;
      }
    } else {
      ring.dequeue += TRB_SIZE;
      return true;
    }
  }
}

void XhciHost::ResetEventRing(int index) {
  auto &interrupt = interrupt_regs_[index];

  if (interrupt.event_ring_table_size == 0 || interrupt.event_ring_table_base == 0) {
    /* disabled */
    manager_->AddDirtyMemory(interrupt.event_ring_table_base, sizeof(interrupt.event_ring_segment));
    bzero(&interrupt.event_ring_segment, sizeof(interrupt.event_ring_segment));
    return;
  }
  MV_ASSERT(interrupt.event_ring_table_size == 1);

  interrupt.event_ring_segment = *(XhciEventRingSegment*)manager_->TranslateGuestMemory(
    interrupt.event_ring_table_base);
  interrupt.event_ring_enqueue_index = 0;
  interrupt.producer_cycle_bit = true;
  auto &segment = interrupt.event_ring_segment;

  if (debug_) {
    MV_LOG("reset event ring[%d] start=0x%lX size=%d table_base=0x%lx", index,
      segment.start, segment.size, interrupt.event_ring_table_base); 
  }
  MV_ASSERT(segment.size >= 16 && segment.size < 4096);
}

void XhciHost::RaiseInterrupt(uint vector) {
  auto &interrupt = interrupt_regs_[vector];
  bool pending = interrupt.event_ring_dequeue_pointer & ERDP_EHB;

  interrupt.event_ring_dequeue_pointer |= ERDP_EHB;
  interrupt.management |= IMAN_IP;
  operational_regs_.usb_status |= USBSTS_EINT;

  if (pending) {
    return;
  }
  if (!(interrupt.management & IMAN_IE)) {
    return;
  }
  if (!(operational_regs_.usb_command & USBCMD_INTE)) {
    return;
  }
  if (msi_config_.enabled) {
    SignalMsi(vector);
  }
}

void XhciHost::CheckInterrupt(uint vector) {
  if (vector == 0) {
    auto &interrupt = interrupt_regs_[0];
    if ((interrupt.management & IMAN_IP) && (interrupt.management & IMAN_IE) &&
      (operational_regs_.usb_command & USBCMD_INTE)) {
      RaiseInterrupt(vector);
    }
  }
}

void XhciHost::WriteRuntimeRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(offset >= 0x20);
  MV_ASSERT(size == 4);
  uint32_t value = *(uint32_t*)data;
  uint index = (offset - 0x20) / 0x20;
  uint index_offset = offset % 0x20;

  auto &interrupt = interrupt_regs_[index];
  switch (index_offset)
  {
  case offsetof(XhciInterruptRegisters, management):
    if (value & IMAN_IP) {
      interrupt.management &= ~IMAN_IP;
    }
    interrupt.management &= ~IMAN_IE;
    interrupt.management |= value & IMAN_IE;
    CheckInterrupt(index);
    break;
  case offsetof(XhciInterruptRegisters, moderation):
    interrupt.moderation = value;
    break;
  case offsetof(XhciInterruptRegisters, event_ring_table_size):
    interrupt.event_ring_table_size = value & 0xFFFF;
    break;
  case offsetof(XhciInterruptRegisters, event_ring_table_base_low):
    interrupt.event_ring_table_base_low = value & 0xFFFFFFC0UL;
    break;
  case offsetof(XhciInterruptRegisters, event_ring_table_base_high):
    interrupt.event_ring_table_base_high = value;
    ResetEventRing(index);
    break;
  case offsetof(XhciInterruptRegisters, event_ring_dequeue_pointer_low): {
    if (value & ERDP_EHB) {
      interrupt.event_ring_dequeue_pointer_low &= ~ERDP_EHB;
    }
    interrupt.event_ring_dequeue_pointer_low = (value & ~ERDP_EHB) | (interrupt.event_ring_dequeue_pointer_low & ERDP_EHB);
    if (value & ERDP_EHB) {
      auto dequeue = interrupt.event_ring_dequeue_pointer;
      auto &segment = interrupt.event_ring_segment;
      uint64_t dequeue_index = (dequeue - segment.start) / TRB_SIZE;
      if (dequeue >= segment.start && dequeue < (segment.start + TRB_SIZE * segment.size) &&
        dequeue_index != interrupt.event_ring_enqueue_index) {
        RaiseInterrupt(index);
      }
    }
    break;
  }
  case offsetof(XhciInterruptRegisters, event_ring_dequeue_pointer_high):
    interrupt.event_ring_dequeue_pointer_high = value;
    break;
  default:
    MV_PANIC("invalid offset=0x%x", index_offset);
  }
}

void XhciHost::ReadOperationalRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  memcpy(data, (uint8_t*)&operational_regs_ + offset, size);
  if (debug_) {
    MV_LOG("offset=0x%lx size=%u data=0x%x", offset, size, *(uint32_t*)data);
  }
}

void XhciHost::ReadPortRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  uint64_t index = offset / sizeof(XhciPortRegisters);
  offset = offset % sizeof(XhciPortRegisters);
  auto& port = port_regs_[index];
  switch (offset)
  {
  case offsetof(XhciPortRegisters, status_control):
  case offsetof(XhciPortRegisters, link_info):
    memcpy(data, (uint8_t*)&port + offset, size);
    break;
  default:
    MV_PANIC("ReadPortRegs offset=0x%lx size=%u", offset, size);
    break;
  }
}

int64_t XhciHost::GetMicroFrameIndex() {
  auto delta_ns = (steady_clock::now() - microframe_index_start_).count();
  return delta_ns / 125000;
}

void XhciHost::ReadRuntimeRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  if (offset < 0x20) {
    if (offset == offsetof(XhciRuntimeRegisters, microframe_index)) {
      auto mfindex = GetMicroFrameIndex();
      memcpy(data, &mfindex, size);
    } else {
      MV_PANIC("ReadRuntimeRegs offset=0x%lx size=%u", offset, size);
    }
  } else {
    auto index = (offset - 0x20) / sizeof(XhciInterruptRegisters);
    offset = offset % sizeof(XhciInterruptRegisters);
    auto &interrupt = interrupt_regs_[index];
    memcpy(data, (uint8_t*)&interrupt + offset, size);
  }
}

void XhciHost::Run() {      
  operational_regs_.usb_status &= ~USBSTS_HCH;
  microframe_index_start_ = steady_clock::now();
}

void XhciHost::Halt() {
  operational_regs_.usb_status |= USBSTS_HCH;
  operational_regs_.command_ring_control &= ~CRCR_CRR;
}

void XhciHost::WriteOperationalUsbCommand(uint32_t command) {
  if ((command & USBCMD_RS) && !(operational_regs_.usb_command & USBCMD_RS)) {
    Run();
  } else if (!(command & USBCMD_RS) && (operational_regs_.usb_command & USBCMD_RS)) {
    Halt();
  }
  if (command & USBCMD_CSS) { // Save state
    operational_regs_.usb_status &= ~USBSTS_SRE;
  }
  if (command & USBCMD_CRS) { // Restore state
    operational_regs_.usb_status |= USBSTS_SRE;
  }
  operational_regs_.usb_command = command & 0xC0F;
  // mfwrap_timer is not supported yet
  MV_ASSERT((command & (USBCMD_RS | USBCMD_EWE)) != (USBCMD_RS | USBCMD_EWE));
  if (command & USBCMD_HCRST) {
    Reset();
  }
  CheckInterrupt(0);
}

void XhciHost::WriteOperationalRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(size == 4);
  uint32_t value = *(uint32_t*)data;
  if (debug_) {
    MV_LOG("offset=0x%lx size=%u data=0x%x", offset, size, value);
  }
  switch (offset)
  {
  case offsetof(XhciOperationalRegisters, usb_command):
    WriteOperationalUsbCommand(value);
    break;
  case offsetof(XhciOperationalRegisters, usb_status): {
    operational_regs_.usb_status &= ~(value & (USBSTS_HSE|USBSTS_EINT|USBSTS_PCD|USBSTS_SRE));
    CheckInterrupt(0);
    break;
  }
  case offsetof(XhciOperationalRegisters, device_notification_control):
    operational_regs_.device_notification_control = value & 0xFFFF;
    break;
  case offsetof(XhciOperationalRegisters, command_ring_control_low):
    operational_regs_.command_ring_control_low = (value & 0xFFFFFFCF) | (operational_regs_.command_ring_control_low & CRCR_CRR);
    break;
  case offsetof(XhciOperationalRegisters, command_ring_control_high):
    operational_regs_.command_ring_control_high = value;
    if ((operational_regs_.command_ring_control_low & (CRCR_CA|CRCR_CS)) && (operational_regs_.command_ring_control_low & CRCR_CRR)) {
      XhciEvent event = { ER_COMMAND_COMPLETE, CC_COMMAND_RING_STOPPED };
      operational_regs_.command_ring_control_low &= ~CRCR_CRR;
      PushEvent(0, event);
    } else {
      SetupRing(command_ring_, operational_regs_.command_ring_control & ~0x3F);
    }
    operational_regs_.command_ring_control_low &= ~(CRCR_CA | CRCR_CS);
    break;
  case offsetof(XhciOperationalRegisters, context_base_array_pointer_low):
    operational_regs_.context_base_array_pointer_low = value & 0xFFFFFFC0;
    break;
  case offsetof(XhciOperationalRegisters, context_base_array_pointer_high):
    operational_regs_.context_base_array_pointer_high = value;
    break;
  case offsetof(XhciOperationalRegisters, configure):
    operational_regs_.configure = value & 0xFF;
    break;
  default:
    MV_PANIC("WriteOperationalRegs offset=0x%lx size=%u data=0x%x", offset, size, value);
    break;
  }
}

  /* ======================== Slot Functions ======================= */

TRBCCode XhciHost::EnableSlot(uint slot_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];
  if (!slot.enabled) {
    if (debug_) {
      MV_LOG("enable slot=%u", slot_id);
    }
    slot.enabled = true;
    bzero(slot.endpoints, sizeof(slot.endpoints));
  }
  return CC_SUCCESS;
}

TRBCCode XhciHost::DisableSlot(uint slot_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];
  if (slot.enabled) {
    if (debug_) {
      MV_LOG("disable slot=%u", slot_id);
    }
    for (uint i = 0; i < 31; i++) {
      if (slot.endpoints[i]) {
        DisableEndpoint(slot_id, i + 1);
      }
    }

    slot.device = nullptr;
    slot.enabled = false;
    slot.addressed = false;
  }
  return CC_SUCCESS;
}

TRBCCode XhciHost::ResetSlot(uint slot_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];

  for (uint i = 1; i < 31; i++) {
    if (slot.endpoints[i]) {
      DisableEndpoint(slot_id, i + 1);
    }
  }

  auto slot_context = (uint32_t*)manager_->TranslateGuestMemory(slot.context_address);
  manager_->AddDirtyMemory(slot.context_address, sizeof(uint32_t) * 4);
  slot_context[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);
  slot_context[3] |= SLOT_DEFAULT << SLOT_STATE_SHIFT;
  return CC_SUCCESS;
}

bool XhciHost::GetSlot(XhciEvent &event, XhciTransferRequestBlock &trb, uint &slot_id) {
  slot_id = (trb.control >> TRB_CR_SLOTID_SHIFT) & TRB_CR_SLOTID_MASK;
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];
  if (!slot.enabled) {
    MV_LOG("slot %u is not enabled", slot_id);
    event.completion_code = CC_SLOT_NOT_ENABLED_ERROR;
    return false;
  }
  return true;
}

TRBCCode XhciHost::EvaluateSlot(uint slot_id, uint64_t input_addr) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];
  auto output_addr = slot.context_address;

  auto input = (uint32_t*)manager_->TranslateGuestMemory(input_addr);
  auto output = (uint32_t*)manager_->TranslateGuestMemory(output_addr);
  manager_->AddDirtyMemory(input_addr);

  MV_ASSERT(input[0] == 0 && !(input[1] & ~0x3));

  auto input_slot = input + 8;
  if (input[1] & 1) {
    /* max exit latency */
    output[1] &= ~0xFFFF;
    output[1] |= input_slot[1] & 0xFFFF;
    slot.interrupt_vector = get_field(input_slot[2], TRB_INTR);
    set_field(&output[2], slot.interrupt_vector, TRB_INTR);
  }

  if (input[1] & 2) {
    auto input_endpoint0 = input_slot + 8;
    auto output_endpoint0 = output + 8;
    /* max packet size */
    output_endpoint0[1] &= ~0xFFFF0000;
    output_endpoint0[1] |= input_endpoint0[1] & 0xFFFF0000;
  }
  return CC_SUCCESS;
}

TRBCCode XhciHost::ConfigureSlot(uint slot_id, uint64_t input_addr, bool deconfigure) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];
  auto output_addr = slot.context_address;

  auto output = (uint32_t*)manager_->TranslateGuestMemory(output_addr);
  manager_->AddDirtyMemory(output_addr);

  if (deconfigure) {
    for (int i = 2; i <= 31; i++) {
      if (slot.endpoints[i - 1]) {
        DisableEndpoint(slot_id, i);
      }
    }
    output[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);
    output[3] |= SLOT_ADDRESSED << SLOT_STATE_SHIFT;
    return CC_SUCCESS;
  }

  auto input = (uint32_t*)manager_->TranslateGuestMemory(input_addr);
  manager_->AddDirtyMemory(input_addr);
  MV_ASSERT((input[0] & 0x03) == 0 && (input[1] & 0x03) == 1);

  auto input_slot = input + 8;
  if (SLOT_STATE(output[3] < SLOT_ADDRESSED)) {
    return CC_CONTEXT_STATE_ERROR;
  }

  for (int i = 2; i <= 31; i++) {
    if (input[0] & (1 << i)) {
      DisableEndpoint(slot_id, i);
    }
    if (input[1] & (1 << i)) {
      auto endpoint_context = input_slot + 8 * i;
      DisableEndpoint(slot_id, i);
      EnableEndpoint(slot_id, i, endpoint_context, true);
      memcpy(output + 8 * i, endpoint_context, 0x20);
    }
  }

  output[3] &= ~(SLOT_STATE_MASK << SLOT_STATE_SHIFT);
  output[3] |= SLOT_CONFIGURED << SLOT_STATE_SHIFT;
  output[0] &= ~(SLOT_CONTEXT_ENTRIES_MASK << SLOT_CONTEXT_ENTRIES_SHIFT);
  output[0] |= input_slot[0] & (SLOT_CONTEXT_ENTRIES_MASK << SLOT_CONTEXT_ENTRIES_SHIFT);
  return CC_SUCCESS;
}

void XhciHost::PostLoadSlot(uint slot_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];

  auto context_base_array = (uint64_t*)manager_->TranslateGuestMemory(
    operational_regs_.context_base_array_pointer);
  slot.context_address = context_base_array[slot_id];

  auto slot_context = (uint32_t*)manager_->TranslateGuestMemory(slot.context_address);
  manager_->AddDirtyMemory(slot.context_address);

  uint port_id = (slot_context[1] >> 16) & 0xFF;
  slot.interrupt_vector = get_field(slot_context[2], TRB_INTR);
  slot.device = LookupDevice(port_id, slot_context[0] & 0xFFFFF);
  MV_ASSERT(slot.device);
  
  for (uint endpoint_id = 1; endpoint_id <= 31; endpoint_id++) {
    auto endpoint_context = slot_context + 8 * endpoint_id;
    auto state = endpoint_context[0] & EP_STATE_MASK;
    if (state == EP_DISABLED)
      continue;
    
    EnableEndpoint(slot_id, endpoint_id, endpoint_context, false);
    if (state == EP_RUNNING) {
      /* Restart kicking endpoint */
      Schedule([this, slot_id, endpoint_id]() {
        KickEndpoint(slot_id, endpoint_id, 0);
      });
    }
  }
}

TRBCCode XhciHost::AddressSlot(uint slot_id, uint64_t input_addr, bool block_set_request) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  auto &slot = slots_[slot_id - 1];

  auto context_base_array = (uint64_t*)manager_->TranslateGuestMemory(
    operational_regs_.context_base_array_pointer);
  auto output_addr = context_base_array[slot_id];
  
  auto input = (uint32_t*)manager_->TranslateGuestMemory(input_addr);
  manager_->AddDirtyMemory(input_addr);
  auto output = (uint32_t*)manager_->TranslateGuestMemory(output_addr);
  manager_->AddDirtyMemory(output_addr);
  MV_ASSERT(input[0] == 0x0 && input[1] == 0x3);

  auto input_slot = input + 8;
  auto input_endpoint0 = input_slot + 8;
  
  uint port_id = (input_slot[1] >> 16) & 0xFF;
  UsbDevice* device = LookupDevice(port_id, input_slot[0] & 0xFFFFF);
  if (device == nullptr) {
    MV_LOG("device not found, port=%d", port_id);
    return CC_TRB_ERROR;
  }

  for (uint i = 0; i < max_slots_; i++) {
    if (i != slot_id - 1 && slots_[i].device == device) {
      MV_LOG("USB device %s is already assigned to slot %u", device->name(), i + 1);
      return CC_TRB_ERROR;
    }
  }

  slot.addressed = true;
  slot.device = device;
  slot.context_address = output_addr;
  slot.interrupt_vector = get_field(input_slot[2], TRB_INTR);
  device->Reset();
  if (block_set_request) {
    input_slot[3] = SLOT_DEFAULT << SLOT_STATE_SHIFT;
  } else {
    input_slot[3] = (SLOT_ADDRESSED << SLOT_STATE_SHIFT) | slot_id;
    if (debug_) {
      MV_LOG("USB device %s assigned to slot %u", device->name(), slot_id);
    }
  }

  EnableEndpoint(slot_id, 1, input_endpoint0, true);
  
  memcpy(output, input_slot, 0x20);
  memcpy(output + 8, input_endpoint0, 0x20);
  return CC_SUCCESS;
}

/* ======================== Port Functions ======================= */

/* USB 3.0 ports resets to U0 automatically */
void XhciHost::SetupPort(int index) {
  auto &port_state = port_states_[index];
  auto &port = port_regs_[index];
  port.status_control = PORTSC_PP; // port power
  uint32_t port_link_state = PLS_RX_DETECT;

  if (port_state.device) {
    port.status_control |= PORTSC_CCS;
    switch (port_state.device->speed())
    {
    case kUsbSpeedLow:
      port.status_control |= PORTSC_SPEED_LOW;
      port_link_state = PLS_POLLING;
      break;
    case kUsbSpeedFull:
      port.status_control |= PORTSC_SPEED_FULL;
      port_link_state = PLS_POLLING;
      break;
    case kUsbSpeedHigh:
      port.status_control |= PORTSC_SPEED_HIGH;
      port_link_state = PLS_POLLING;
      break;
    case kUsbSpeedSuper:
      port.status_control |= PORTSC_SPEED_SUPER | PORTSC_PED;
      port_link_state = PLS_U0;
      break;
    }
  }
  port.status_control |= port_link_state << PORTSC_PLS_SHIFT;
  NotifyPort(index, PORTSC_CSC);
}

void XhciHost::ResetPort(int index, bool warm_reset) {
  auto &port_state = port_states_[index];
  auto &port = port_regs_[index];
  if (!port_state.device) {
    return;
  }
  port_state.device->Reset();

  MV_ASSERT(!warm_reset);
  set_field(&port.status_control, PLS_U0, PORTSC_PLS);
  port.status_control |= PORTSC_PED;
  port.status_control &= ~PORTSC_PR;
  NotifyPort(index, PORTSC_PRC);
}

void XhciHost::NotifyPort(uint index, uint32_t bits) {
  auto &port = port_regs_[index];
  if ((port.status_control & bits) == bits) {
    return;
  }
  port.status_control |= bits;

  if (!IsRunning()) {
    return;
  }
  XhciEvent event = { ER_PORT_STATUS_CHANGE, CC_SUCCESS, (index + 1ULL) << 24 };
  PushEvent(0, event);
}

void XhciHost::WritePortStatusControl(uint64_t index, uint32_t value) {
  auto& port = port_regs_[index];
  /* write-1-to-start bits */
  if (value & PORTSC_WPR) {
    ResetPort(index, true);
    return;
  }
  if (value & PORTSC_PR) {
    ResetPort(index, false);
    return;
  }
  uint32_t sc = port.status_control;
  uint32_t notify = 0;
  /* write-1-to-clear bits */
  sc &= ~(value & (PORTSC_CSC|PORTSC_PEC|PORTSC_WRC|PORTSC_OCC|PORTSC_PRC|PORTSC_PLC|PORTSC_CEC));
  
  if (value & PORTSC_LWS) { // overwrite PLS
    uint32_t old_pls = get_field(port.status_control, PORTSC_PLS);
    uint32_t new_pls = get_field(value, PORTSC_PLS);
    switch (new_pls)
    {
    case PLS_U0:
      if (old_pls != PLS_U0) {
        set_field(&sc, new_pls, PORTSC_PLS);
        notify = PORTSC_PLC;
      }
      break;
    case PLS_U3:
      if (old_pls < PLS_U3) {
        set_field(&sc, new_pls, PORTSC_PLS);
      }
      break;
    case PLS_RESUME:
      /* windows does this for some reason, don't spam stderr */
      break;
    default:
      MV_PANIC("ignore PLS write old=0x%x new=0x%x", old_pls, new_pls);
      break;
    }
  }

  /* read/write bits */
  sc &= ~(PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE);
  sc |= (value & (PORTSC_PP|PORTSC_WCE|PORTSC_WDE|PORTSC_WOE));
  port.status_control = sc;
  if (notify) {
    NotifyPort(index, notify);
  }
}

void XhciHost::WritePortRegs(uint64_t offset, uint8_t* data, uint32_t size) {
  uint64_t index = offset / sizeof(XhciPortRegisters);
  offset = offset % sizeof(XhciPortRegisters);
  switch (offset)
  {
  case offsetof(XhciPortRegisters, status_control):
    MV_ASSERT(size == 4);
    WritePortStatusControl(index, *(uint32_t*)data);
    break;
  default:
    MV_PANIC("WritePortRegs offset=0x%lx size=%u data=0x%lx", offset, size, *(uint64_t*)data);
    break;
  }
}

/* FIXME: route_string is not supported yet */
UsbDevice* XhciHost::LookupDevice(uint port_id, uint32_t route_string) {
  MV_UNUSED(route_string);
  MV_ASSERT(port_id >= 1 && port_id <= max_ports_);
  for (auto &port_state : port_states_) {
    if (port_state.id == port_id) {
      return port_state.device;
    }
  }
  return nullptr;
}

/* ======================== Endpoint Functions ======================= */

XhciEndpoint* XhciHost::CreateEndpoint(uint slot_id, uint endpoint_id, uint32_t* context) {
  auto endpoint = new XhciEndpoint;
  endpoint->id = endpoint_id;
  endpoint->slot_id = slot_id;

  uint64_t dequee_pointer = ((uint64_t)context[3] << 32) | (context[2] & ~0xF);
  endpoint->type = (EPType)((context[1] >> EP_TYPE_SHIFT) & EP_TYPE_MASK);
  endpoint->endpoint_address = ((endpoint->type >> 2) ? 0x80 : 0) | endpoint_id / 2;
  endpoint->max_packet_size = context[1] >> 16;
  endpoint->max_packet_size *= 1 + ((context[1] >> 8) & 0xFF);
  endpoint->max_pstreams = (context[0] >> 10) & max_pstreams_mask_;
  endpoint->linear_stream_array = (context[0] >> 15) & 1;
  if (endpoint->max_pstreams) {
    MV_PANIC("not implemented");
  } else {
    SetupRing(endpoint->ring, dequee_pointer);
    endpoint->ring.consumer_cycle_bit = context[2] & 1;
  }
  endpoint->interval = 1 << ((context[0] >> 16) & 0xFF);
  endpoint->state = 0;
  endpoint->mfindex_last = 0;
  endpoint->context_address = slots_[slot_id - 1].context_address + 0x20 * endpoint_id;
  return endpoint;
}

void XhciHost::EnableEndpoint(uint slot_id, uint endpoint_id, uint32_t* context, bool autorun) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);

  auto &slot = slots_[slot_id - 1];
  if (slot.endpoints[endpoint_id - 1]) {
    DisableEndpoint(slot_id, endpoint_id);
  }

  auto endpoint = CreateEndpoint(slot_id, endpoint_id, context);
  if (debug_) {
    MV_LOG("endpoint %d.%d type=%d, max packet size=%d interval=%d", endpoint_id / 2, endpoint_id % 2,
      endpoint->type, endpoint->max_packet_size, endpoint->interval);
  }
  slot.endpoints[endpoint_id - 1] = endpoint;
  if (autorun) {
    context[0] &= ~EP_STATE_MASK;
    context[0] |= EP_RUNNING;
  }
  endpoint->state = context[0] & EP_STATE_MASK;
}

TRBCCode XhciHost::DisableEndpoint(uint slot_id, uint endpoint_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);
  
  auto &slot = slots_[slot_id - 1];
  auto endpoint = slot.endpoints[endpoint_id - 1];
  if (!endpoint) {
    if (debug_) {
      MV_LOG("slot %d endpoint %d already disabled", slot_id, endpoint_id);
    }
    return CC_EP_NOT_ENABLED_ERROR;
  }

  TerminateAllTransfers(endpoint, CC_INVALID);

  /* only touch guest RAM if we're not resetting the HC */
  if (operational_regs_.context_base_array_pointer) {
    SetEndpointState(endpoint, EP_DISABLED);
  }

  delete endpoint;
  slot.endpoints[endpoint_id - 1] = nullptr;
  return CC_SUCCESS;
}

TRBCCode XhciHost::StopEndpoint(uint slot_id, uint endpoint_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);
  
  auto &slot = slots_[slot_id - 1];
  auto endpoint = slot.endpoints[endpoint_id - 1];
  if (!endpoint) {
    MV_LOG("slot %d endpoint %d already disabled", slot_id, endpoint_id);
    return CC_EP_NOT_ENABLED_ERROR;
  }

  TerminateAllTransfers(endpoint, CC_STOPPED);
  SetEndpointState(endpoint, EP_STOPPED);
  return CC_SUCCESS;
}

TRBCCode XhciHost::ResetEndpoint(uint slot_id, uint endpoint_id) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);
  
  auto &slot = slots_[slot_id - 1];
  auto endpoint = slot.endpoints[endpoint_id - 1];
  if (!endpoint) {
    MV_LOG("slot %d endpoint %d already disabled", slot_id, endpoint_id);
    return CC_EP_NOT_ENABLED_ERROR;
  }

  if (endpoint->state != EP_HALTED) {
    MV_LOG("reset endpoint while endpoint %d not halted", endpoint_id);
    return CC_CONTEXT_STATE_ERROR;
  }
  
  TerminateAllTransfers(endpoint, CC_INVALID);
  SetEndpointState(endpoint, EP_STOPPED);
  return CC_SUCCESS;
}

TRBCCode XhciHost::SetEndpointDequee(uint slot_id, uint endpoint_id, uint stream_id, uint64_t dequeue) {
  MV_ASSERT(slot_id >= 1 && slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);
  MV_UNUSED(stream_id);
  
  auto &slot = slots_[slot_id - 1];
  auto endpoint = slot.endpoints[endpoint_id - 1];
  if (!endpoint) {
    MV_LOG("slot %d endpoint %d already disabled", slot_id, endpoint_id);
    return CC_EP_NOT_ENABLED_ERROR;
  }

  if (endpoint->state != EP_STOPPED) {
    MV_LOG("reset endpoint while endpoint %d not halted", endpoint_id);
    return CC_CONTEXT_STATE_ERROR;
  }

  SetupRing(endpoint->ring, dequeue & ~0xF);
  endpoint->ring.consumer_cycle_bit = dequeue & 1;
  
  SetEndpointState(endpoint, EP_STOPPED);
  return CC_SUCCESS;
}

void XhciHost::StallEndpoint(XhciTransfer* transfer) {
  auto endpoint = transfer->endpoint;
  MV_ASSERT(endpoint->type != ET_ISO_IN && endpoint->type != ET_ISO_OUT);

  endpoint->ring.dequeue = transfer->trbs[0].address;
  endpoint->ring.consumer_cycle_bit = transfer->trbs[0].cycle_bit;

  SetEndpointState(endpoint, EP_HALTED);
  if (debug_) {
    MV_LOG("%s stalled endpoint 0x%x", transfer->device->name(), endpoint->endpoint_address);
  }
}

void XhciHost::SetEndpointState(XhciEndpoint* endpoint, uint32_t state) {
  uint32_t* context = (uint32_t*)manager_->TranslateGuestMemory(endpoint->context_address);
  manager_->AddDirtyMemory(endpoint->context_address, sizeof(uint32_t) * 4);

  context[0] &= ~EP_STATE_MASK;
  context[0] |= state;

  auto &ring = endpoint->ring;
  context[2] = ring.dequeue | ring.consumer_cycle_bit;
  context[3] = ring.dequeue >> 32;
  endpoint->state = state;
  if (debug_) {
    MV_LOG("set endpoint=%d state=%d dequeue=0x%lx", endpoint->id, state, ring.dequeue);
  }
}

void XhciHost::NotifyEndpoint(UsbDevice* device, uint endpoint_address) {
  for (auto& slot : slots_) {
    if (slot.device == device) {
      for (auto endpoint : slot.endpoints) {
        if (endpoint && endpoint->endpoint_address == endpoint_address) {
          KickEndpoint(endpoint->slot_id, endpoint->id, 0);
          return;
        }
      }
    }
  }

  // MV_PANIC("endpoint of %s not found addr=0x%x", device->name(), endpoint_address);
}

/* ======================== Transfer Functions ======================= */

XhciTransfer* XhciHost::CreateTransfer(XhciEndpoint* endpoint, uint stream_id, int length) {
  auto transfer = new XhciTransfer;
  transfer->completed = false;
  transfer->endpoint = endpoint;
  transfer->device = slots_[endpoint->slot_id - 1].device;
  transfer->trbs.resize(length);
  transfer->status = CC_INVALID;
  transfer->packet = nullptr;
  transfer->stream_id = stream_id;
  endpoint->transfers.insert(transfer);
  return transfer;
}

void XhciHost::SetupTransfer(XhciTransfer* transfer) {
  auto packet = new UsbPacket;
  packet->endpoint_address = transfer->endpoint->endpoint_address;
  packet->stream_id = transfer->stream_id;
  packet->id = transfer->trbs[0].address;
  packet->status = USB_RET_SUCCESS;
  packet->content_length = 0;
  packet->control_parameter = 0;
  packet->size = 0;

  if (transfer->endpoint->id == 1) {
    /* Control endpoint */
    auto setup_trb = &transfer->trbs[0];
    auto status_trb = &transfer->trbs[transfer->trbs.size() - 1];

    if (TRB_TYPE(*status_trb) == TR_EVDATA && transfer->trbs.size() > 2) {
      status_trb--;
    }
    MV_ASSERT(TRB_TYPE(*setup_trb) == TR_SETUP);
    MV_ASSERT(TRB_TYPE(*status_trb) == TR_STATUS);
    MV_ASSERT(setup_trb->control & TRB_TR_IDT);
    MV_ASSERT((setup_trb->status & 0x1FFFF) == 8);

    transfer->in_direction = setup_trb->parameter & USB_DIR_IN;
    packet->control_parameter = setup_trb->parameter;
  } else {
    transfer->in_direction = transfer->endpoint->type >> 2;
  }

  for (auto &trb : transfer->trbs) {
    if (trb.control & TRB_TR_IOC) {
      transfer->interrupt_on_completion = true;
    }

    uint chunk = trb.status & 0x1FFFF;
    uint64_t address = trb.parameter;
    switch (TRB_TYPE(trb))
    {
    case TR_DATA:
      MV_ASSERT(!!(trb.control & TRB_TR_DIR) == transfer->in_direction);
      /* fallthrough */
    case TR_NORMAL:
    case TR_ISOCH:
      if (trb.control & TRB_TR_IDT) {
        MV_ASSERT(chunk <= 8 && !transfer->in_direction);
        address = trb.address;
      }
      packet->iov.push_back(iovec {
        .iov_base = manager_->TranslateGuestMemory(address),
        .iov_len = chunk
      });
      if (packet->endpoint_address & 0x80) {
        manager_->AddDirtyMemory(address, chunk);
      }
      packet->size += chunk;
    }
  }
  transfer->packet = packet;
}

void XhciHost::HandleTransfer(XhciTransfer* transfer) {
  transfer->device->HandlePacket(transfer->packet);

  if (transfer->packet->status == USB_RET_NAK) {
    return;
  }

  CompleteTransfer(transfer);
  FreeTransfer(transfer);
}

void XhciHost::TerminateTransfer(XhciTransfer* transfer, TRBCCode report) {
  MV_ASSERT(!transfer->completed);
  if (report) {
    transfer->status = report;
    ReportTransfer(transfer);
  }
}

void XhciHost::TerminateAllTransfers(XhciEndpoint* endpoint, TRBCCode report) {
  auto copied(endpoint->transfers);
  for (auto transfer : copied) {
    TerminateTransfer(transfer, report);
    FreeTransfer(transfer);
  }
}

void XhciHost::FreeTransfer(XhciTransfer* transfer) {
  if (transfer->endpoint->transfers.erase(transfer)) {
    if (transfer->packet) {
      delete transfer->packet;
    }
    delete transfer;
  }
}

void XhciHost::ReportTransfer(XhciTransfer* transfer) {
  XhciEvent event = { ER_TRANSFER, CC_SUCCESS };
  bool reported = false;
  bool short_packet = false;
  uint left = transfer->packet ? transfer->packet->content_length : 0;
  uint event_data_transfered = 0;

  for (auto &trb : transfer->trbs) {
    auto type = TRB_TYPE(trb);
    uint chunk = 0;
    switch (type)
    {
    case TR_SETUP:
      chunk = trb.status & 0x1FFFF;
      MV_ASSERT(chunk <= 8);
      break;
    case TR_DATA:
    case TR_NORMAL:
    case TR_ISOCH:
      chunk = trb.status & 0x1FFFF;
      if (chunk > left) {
        chunk = left;
        if (transfer->status == CC_SUCCESS)
          short_packet = true;
      }
      left -= chunk;
      event_data_transfered += chunk;
      break;
    case TR_STATUS:
      reported = false;
      short_packet = false;
      break;
    }

    if (!reported) {
      if ((trb.control & TRB_TR_IOC) ||
          (short_packet && (trb.control & TRB_TR_ISP)) ||
          (transfer->status != CC_SUCCESS && left == 0))
      {
        event.slot_id = transfer->endpoint->slot_id;
        event.endpoint_id = transfer->endpoint->id;
        if (transfer->status == CC_SUCCESS) {
          event.completion_code = short_packet ? CC_SHORT_PACKET : CC_SUCCESS;
        } else {
          event.completion_code = transfer->status;
        }
        if (type == TR_EVDATA) {
          event.poniter = trb.parameter;
          event.flags |= TRB_EV_ED;
          event.length = event_data_transfered & 0xFFFFFF;
          if (debug_) {
            MV_LOG("bytes transferred=%d status=%d", event_data_transfered, transfer->status);
          }
          event_data_transfered = 0;
        } else {
          event.poniter = trb.address;
          event.flags = 0;
          event.length = (trb.status & 0x1FFFF) - chunk;
        }

        PushEvent(TRB_INTR(trb), event);
        reported = true;
        if (transfer->status != CC_SUCCESS) {
          return;
        }
      }
    }
    
    if (type == TR_SETUP) {
      reported = false;
      short_packet = false;
    }
  }
}

void XhciHost::CompleteTransfer(XhciTransfer* transfer) {
  MV_ASSERT(transfer && !transfer->completed);
  transfer->completed = true;

  auto packet = transfer->packet;
  MV_ASSERT(packet);

  switch (packet->status)
  {
  case USB_RET_SUCCESS:
    transfer->status = CC_SUCCESS;
    break;
  case USB_RET_NODEV:
  case USB_RET_IOERROR:
    transfer->status = CC_USB_TRANSACTION_ERROR;
    break;
  case USB_RET_STALL:
    transfer->status = CC_STALL_ERROR;
    break;
  case USB_RET_BABBLE:
    transfer->status = CC_BABBLE_DETECTED;
    break;
  default:
    MV_PANIC("Unknown packet %p status=0x%x", packet, packet->status);
    break;
  }

  if (transfer->status != CC_SUCCESS) {
    StallEndpoint(transfer);
  } else {
    // Update ring dequeue to context
    auto endpoint = transfer->endpoint;
    SetEndpointState(endpoint, endpoint->state);
  }

  ReportTransfer(transfer);
}

int XhciHost::GetRingChainLength(XhciRing &ring) {
  /* hack to bundle together the two/three TDs that make a setup transfer */
  int length = 0;
  bool control_td_set = false;
  bool cycle_bit = ring.consumer_cycle_bit;
  auto dequeue = ring.dequeue;
  while (true) {
    XhciTransferRequestBlock trb;
    memcpy(&trb, manager_->TranslateGuestMemory(dequeue), TRB_SIZE);
    if ((trb.control & TRB_C) != cycle_bit) {
      return -length;
    }

    auto type = TRB_TYPE(trb);
    if (type == TR_LINK) {
      dequeue = trb.parameter;
      if (trb.control & TRB_LK_TC) {
        cycle_bit = !cycle_bit;
      }
      continue;
    }

    length++;
    dequeue += TRB_SIZE;

    if (type == TR_SETUP) {
      control_td_set = true;
    } else if (type == TR_STATUS) {
      control_td_set = false;
    }
    if (!control_td_set && !(trb.control & TRB_TR_CH)) {
      return length;
    }
  }
}

/* Concurrent transfers handling is not implemented yet */
void XhciHost::KickEndpoint(uint slot_id, uint endpoint_id, uint stream_id) {
  MV_ASSERT(slot_id <= max_slots_);
  MV_ASSERT(endpoint_id >= 1 && endpoint_id <= 31);
  MV_ASSERT(stream_id == 0);
  auto &slot = slots_[slot_id - 1];
  if (!slot.enabled) {
    MV_LOG("kick disabled slot %d", slot_id);
    return;
  }
  auto endpoint = slot.endpoints[endpoint_id - 1];
  if (!endpoint || endpoint->state == EP_HALTED) {
    MV_LOG("kick disabled endpoint %d of %d", endpoint_id, slot_id);
    return;
  } 
  if (debug_) {
    MV_LOG("kick endpoint slot=%u ep=%u stream=%u", slot_id, endpoint_id, stream_id);
  }
  if(endpoint->state != EP_RUNNING) {
    SetEndpointState(endpoint, EP_RUNNING);
  }

  if(!endpoint->transfers.empty()) {
    auto copied(endpoint->transfers);
    for (auto transfer : copied) {
      HandleTransfer(transfer);
    }
    return;
  }

  auto &ring = endpoint->ring;
  MV_ASSERT(ring.dequeue);

  while (endpoint->state != EP_HALTED && endpoint->transfers.empty()) {
    int length = GetRingChainLength(ring);
    if (debug_) {
      MV_LOG("ring chain length=%d", length);
    }
    if (length <= 0) {
      if (endpoint->type == ET_ISO_OUT || endpoint->type == ET_ISO_IN) {
        XhciEvent event = { ER_TRANSFER,
          .completion_code = endpoint->type == ET_ISO_IN ? CC_RING_OVERRUN : CC_RING_UNDERRUN,
          .poniter = endpoint->ring.dequeue,
          .slot_id = endpoint->slot_id,
          .endpoint_id = endpoint->id
        };
        PushEvent(slot.interrupt_vector, event);
      }
      break;
    }

    auto transfer = CreateTransfer(endpoint, stream_id, length);
    MV_ASSERT(transfer);

    for (int i = 0; i < length; i++) {
      if (!PopRing(ring, transfer->trbs[i])) {
        FreeTransfer(transfer);
        MV_PANIC("failed to pop ring");
        return;
      }
    }

    SetupTransfer(transfer);
    HandleTransfer(transfer);
  }
}

void XhciHost::ProcessCommands() {
  operational_regs_.command_ring_control |= CRCR_CRR;

  XhciTransferRequestBlock trb;
  while (PopRing(command_ring_, trb)) {
    uint slot_id = 0;
    TRBCCode code = CC_SUCCESS;
    XhciEvent event;
    event.type = ER_COMMAND_COMPLETE;
    event.poniter = trb.address;

    auto type = TRB_TYPE(trb);
    if (debug_) {
      MV_LOG("command=%d", type);
    }
    switch (type)
    {
    case CR_ENABLE_SLOT:
      for (uint i = 0; i < max_slots_; i++) {
        if (!slots_[i].enabled) {
          slot_id = i + 1;
          break;
        }
      }
      MV_ASSERT(slot_id);
      code = EnableSlot(slot_id);
      break;
    case CR_DISABLE_SLOT:
      if (GetSlot(event, trb, slot_id)) {
        code = DisableSlot(slot_id);
      }
      break;
    case CR_ADDRESS_DEVICE:
      if (GetSlot(event, trb, slot_id)) {
        code = AddressSlot(slot_id, trb.parameter, trb.control & TRB_CR_BSR);
      }
      break;
    case CR_CONFIGURE_ENDPOINT:
      if (GetSlot(event, trb, slot_id)) {
        code = ConfigureSlot(slot_id, trb.parameter, trb.control & TRB_CR_DC);
      }
      break;
    case CR_EVALUATE_CONTEXT:
      if (GetSlot(event, trb, slot_id)) {
        code = EvaluateSlot(slot_id, trb.parameter);
      }
      break;
    case CR_RESET_ENDPOINT:
      if (GetSlot(event, trb, slot_id)) {
        uint endpoint_id = (trb.control >> TRB_CR_EPID_SHIFT) & TRB_CR_EPID_MASK;
        code = ResetEndpoint(slot_id, endpoint_id);
      }
      break;
    case CR_STOP_ENDPOINT:
      if (GetSlot(event, trb, slot_id)) {
        uint endpoint_id = (trb.control >> TRB_CR_EPID_SHIFT) & TRB_CR_EPID_MASK;
        code = StopEndpoint(slot_id, endpoint_id);
      }
      break;
    case CR_SET_TR_DEQUEUE:
      if (GetSlot(event, trb, slot_id)) {
        uint endpoint_id = (trb.control >> TRB_CR_EPID_SHIFT) & TRB_CR_EPID_MASK;
        uint stream_id = (trb.status >> 16) & 0xFFFF;
        code = SetEndpointDequee(slot_id, endpoint_id, stream_id, trb.parameter);
      }
      break;
    case CR_RESET_DEVICE:
      if (GetSlot(event, trb, slot_id)) {
        code = ResetSlot(slot_id);
      }
      break;
    default:
      MV_ERROR("unhandled TRB type=%d", type);
      break;
    }
    event.completion_code = code;
    event.slot_id = slot_id;
    PushEvent(0, event);
  }
}

void XhciHost::WriteDoorbellRegs(uint64_t address, uint64_t offset, uint8_t* data, uint32_t size) {
  MV_UNUSED(address);
  MV_ASSERT(size == 4);
  uint64_t slot_id = offset >> 2;
  uint32_t value = *(uint32_t*)data;

  /* Let io thread handle this */
  Schedule([=]() {
    if (slot_id == 0) {
      ProcessCommands();
    } else {
      uint endpoint_id = value & 0xFF;
      uint stream_id = (value >> 16) & 0xFFFF;
      KickEndpoint(slot_id, endpoint_id, stream_id);
    }
  });
}

void XhciHost::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[0].address && offset < 0x3000) {
    if (offset < capability_regs_.capability_length) {
      memcpy(data, (uint8_t*)&capability_regs_ + offset, size);
    } else if (offset < capability_regs_.capability_length + 0x400ULL) {
      ReadOperationalRegs(offset - capability_regs_.capability_length, data, size);
    } else if (offset < 0x1000) {
      ReadPortRegs(offset - capability_regs_.capability_length - 0x400, data, size);
    } else if (offset < 0x2000) {
      ReadRuntimeRegs(offset - 0x1000, data, size);
    } else if (offset < 0x3000) {
      bzero(data, size);
    }
    // if (debug_) {
    //   MV_LOG("Read offset=0x%lx size=%u data=0x%lx", offset, size, *(uint64_t*)data);
    // }
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}

void XhciHost::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[0].address && offset < 0x3000) {
    if (debug_) {
      MV_LOG("Write offset=0x%lx size=%u data=0x%lx", offset, size, *(uint64_t*)data);
    }
    if (offset < capability_regs_.capability_length) {
    } else if (offset < capability_regs_.capability_length + 0x400ULL) {
      if (size == 8) {
        WriteOperationalRegs(offset - capability_regs_.capability_length, data, 4);
        WriteOperationalRegs(offset - capability_regs_.capability_length + 4, data + 4, 4);
      } else {
        WriteOperationalRegs(offset - capability_regs_.capability_length, data, size);
      }
    } else if (offset < 0x1000) {
      WritePortRegs(offset - capability_regs_.capability_length - 0x400, data, size);
    } else if (offset < 0x2000) {
      if (size == 8) {
        WriteRuntimeRegs(offset - 0x1000, data, 4);
        WriteRuntimeRegs(offset - 0x1000 + 4, data + 4, 4);
      } else {
        WriteRuntimeRegs(offset - 0x1000, data, size);
      }
    } else if (offset < 0x3000) {
      WriteDoorbellRegs(resource->base + offset, offset - 0x2000, data, size);
    }
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

DECLARE_DEVICE(XhciHost);

```

`devices/usb/xhci_host.h`:

```h
/* 
 * MVisor USB 3.0 XHCI
 * SPEC: <https://www.intel.com/content/dam/www/public/us/en/documents/ \
 *    technical-specifications/extensible-host-controler-interface-usb-xhci.pdf>
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_XHCI_HOST_H
#define _MVISOR_DEVICES_USB_XHCI_HOST_H

#include <array>
#include <vector>
#include <set>

#include "pci_device.h"
#include "usb_device.h"
#include "xhci_internal.h"

struct XhciPortState {
  uint          id;
  uint          speed_mask;
  UsbDevice*    device;
};

struct XhciRing {
  bool          consumer_cycle_bit;
  uint64_t      dequeue;
};

struct XhciTransfer;
struct XhciEndpoint {
  uint                    id;
  uint                    slot_id;
  EPType                  type;
  uint                    max_packet_size;
  uint                    max_pstreams;
  bool                    linear_stream_array;
  uint                    interval;
  XhciRing                ring;
  int64_t                 mfindex_last;
  uint                    state;
  uint64_t                context_address;
  std::set<XhciTransfer*> transfers;
  uint                    endpoint_address;
};

struct XhciSlot {
  bool          enabled;
  bool          addressed;
  uint64_t      context_address;
  XhciEndpoint* endpoints[31];
  UsbDevice*    device;
  int           interrupt_vector;
};

struct XhciEvent {
  TRBType       type;
  TRBCCode      completion_code = CC_INVALID;
  uint64_t      poniter = 0;
  uint32_t      length = 0;
  uint32_t      flags = 0;
  uint          slot_id = 0;
  uint          endpoint_id = 0;
};

struct XhciTransfer {
  XhciEndpoint* endpoint;
  TRBCCode      status;
  uint          stream_id;
  bool          completed;
  bool          in_direction;
  bool          interrupt_on_completion;
  std::vector<XhciTransferRequestBlock> trbs;
  UsbPacket*    packet;
  UsbDevice*    device;
};

class XhciHost : public UsbHost {
 private:
    /* 8 ports in total, USB 2.0 ports 1-4, USB 3.0 ports 5-8 */
    uint max_ports_ = 8;
    uint max_interrupts_ = 16;
    uint max_slots_ = 64;
    uint max_pstreams_mask_ = 7;
  
    std::array<XhciPortState, 128>          port_states_;
    std::array<XhciPortRegisters, 128>      port_regs_;
    std::array<XhciInterruptRegisters, 128> interrupt_regs_;
    std::array<XhciSlot, 128>               slots_;
    XhciRing                                command_ring_;
    IoTimePoint                             microframe_index_start_;
    XhciCapabilityRegisters                 capability_regs_;
    XhciOperationalRegisters                operational_regs_;
    XhciRuntimeRegisters                    runtime_regs_;

 private:
  void Run();
  void Halt();
  bool IsRunning();
  bool AttachUsbDevice(UsbDevice* device);
  void PushEvent(uint vector, XhciEvent &event);
  void WriteEvent(uint vector, XhciEvent &event);
  void SetupRing(XhciRing &ring, uint64_t base);
  bool PopRing(XhciRing &ring, XhciTransferRequestBlock &trb);
  void ResetEventRing(int index);
  void RaiseInterrupt(uint vector);
  void CheckInterrupt(uint vector);

  void WriteRuntimeRegs(uint64_t offset, uint8_t* data, uint32_t size);
  void ReadOperationalRegs(uint64_t offset, uint8_t* data, uint32_t size);
  void ReadPortRegs(uint64_t offset, uint8_t* data, uint32_t size);
  int64_t GetMicroFrameIndex();
  void ReadRuntimeRegs(uint64_t offset, uint8_t* data, uint32_t size);
  void WriteOperationalUsbCommand(uint32_t command);
  void WriteOperationalRegs(uint64_t offset, uint8_t* data, uint32_t size);

  /* ======================== Slot Functions ======================= */
  TRBCCode EnableSlot(uint slot_id);
  TRBCCode DisableSlot(uint slot_id);
  TRBCCode ResetSlot(uint slot_id);
  bool GetSlot(XhciEvent &event, XhciTransferRequestBlock &trb, uint &slot_id);
  TRBCCode EvaluateSlot(uint slot_id, uint64_t input_addr);
  TRBCCode ConfigureSlot(uint slot_id, uint64_t input_addr, bool deconfigure);
  void PostLoadSlot(uint slot_id);
  TRBCCode AddressSlot(uint slot_id, uint64_t input_addr, bool block_set_request);

  /* ======================== Port Functions ======================= */
  void SetupPort(int index);
  void ResetPort(int index, bool warm_reset);
  void NotifyPort(uint index, uint32_t bits);
  void WritePortStatusControl(uint64_t index, uint32_t value);
  void WritePortRegs(uint64_t offset, uint8_t* data, uint32_t size);

  UsbDevice* LookupDevice(uint port_id, uint32_t route_string);

  /* ======================== Endpoint Functions ======================= */
  XhciEndpoint* CreateEndpoint(uint slot_id, uint endpoint_id, uint32_t* context);
  void EnableEndpoint(uint slot_id, uint endpoint_id, uint32_t* context, bool autorun);
  TRBCCode DisableEndpoint(uint slot_id, uint endpoint_id);
  TRBCCode StopEndpoint(uint slot_id, uint endpoint_id);
  TRBCCode ResetEndpoint(uint slot_id, uint endpoint_id);
  TRBCCode SetEndpointDequee(uint slot_id, uint endpoint_id, uint stream_id, uint64_t dequeue);
  void StallEndpoint(XhciTransfer* transfer);
  void SetEndpointState(XhciEndpoint* endpoint, uint32_t state);
  void NotifyEndpoint(UsbDevice* device, uint endpoint_address);

  /* ======================== Transfer Functions ======================= */
  XhciTransfer* CreateTransfer(XhciEndpoint* endpoint, uint stream_id, int length);
  void TerminateTransfer(XhciTransfer* transfer, TRBCCode report);
  void TerminateAllTransfers(XhciEndpoint* endpoint, TRBCCode report);
  void FreeTransfer(XhciTransfer* transfer);
  void ReportTransfer(XhciTransfer* transfer);
  void CompleteTransfer(XhciTransfer* transfer);
  void SetupTransfer(XhciTransfer* transfer);
  void HandleTransfer(XhciTransfer* transfer);
  int GetRingChainLength(XhciRing &ring);
  void KickEndpoint(uint slot_id, uint endpoint_id, uint stream_id);
  void ProcessCommands();
  void WriteDoorbellRegs(uint64_t address, uint64_t offset, uint8_t* data, uint32_t size);

 public:
  XhciHost();

  virtual void Reset();
  virtual void Connect();
  virtual void Disconnect();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
};

#endif // _MVISOR_DEVICES_USB_XHCI_HOST_H

```

`devices/usb/xhci_host.proto`:

```proto
syntax = "proto3";

message XhciHostState {
  message Operational {
    uint32  usb_command                   = 1;
    uint32  usb_status                    = 2;
    uint32  device_notification_control   = 3;
    uint64  command_ring_control          = 4;
    uint64  context_base_array_pointer    = 5;
    uint32  configure                     = 6;
  }

  message Runtime {
    uint32  microframe_index      = 1;
  }

  message CommandRing {
    uint32  dequeue               = 1;
    bool    consumer_cycle_bit    = 2;
  }

  message Port {
    uint32  status_control  = 1;
  }

  message Slot {
    bool    enabled         = 1;
    bool    addressed       = 2;
  }

  message Interrupt {
    uint32  management                    = 1;
    uint32  moderation                    = 2;
    uint32  event_ring_table_size         = 3;
    uint64  event_ring_table_base         = 4;
    uint64  event_ring_dequeue_pointer    = 5;
    uint64  event_ring_segment_start      = 6;
    uint32  event_ring_segment_size       = 7;
    uint64  event_ring_enqueue_index      = 8;
    bool    event_ring_producer_cycle_bit = 9;
  }

  Operational         operational   = 2;
  Runtime             runtime       = 3;
  CommandRing         command_ring  = 4;
  repeated Port       ports         = 5;
  repeated Slot       slots         = 6;
  repeated Interrupt  interrupts    = 7;
}

```

`devices/usb/xhci_internal.h`:

```h
/* 
 * MVisor USB 3.0 XHCI
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_USB_XHCI_INTERNAL_H
#define _MVISOR_DEVICES_USB_XHCI_INTERNAL_H

#include <cstdint>

struct XhciCapabilityRegisters {
  uint8_t   capability_length;
  uint8_t   reserved1;
  uint16_t  interface_version;
  /* HCSPARAMS 1 */
  uint8_t   max_slots;
  uint16_t  max_interrupts; // 10 bits (1024)
  uint8_t   max_ports;
  /* HCSPARAMS 2 / 3 */
  uint32_t  hcs_params2;
  uint32_t  hcs_params3;
  uint32_t  capability_params1;
  uint32_t  doorbell_offset;
  uint32_t  runtime_registers_offset;
  uint32_t  capability_params2;
  /* Extended capabilites */
  uint32_t  extended_capabilities[8];
} __attribute__((packed));


struct XhciOperationalRegisters {
  uint32_t  usb_command;
  uint32_t  usb_status;
  uint32_t  page_size;
  uint32_t  reserved1[2];
  uint32_t  device_notification_control;
  union {
    struct {
      uint32_t  command_ring_control_low;
      uint32_t  command_ring_control_high;
    };
    uint64_t    command_ring_control;
  };
  uint32_t  reserved2[4];
  union {
    struct {
      uint32_t  context_base_array_pointer_low;
      uint32_t  context_base_array_pointer_high;
    };
    uint64_t    context_base_array_pointer;
  };
  uint32_t  configure;
} __attribute__((packed));


struct XhciPortRegisters {
  uint32_t  status_control;
  uint32_t  pm_status_control;
  uint32_t  link_info;
  uint32_t  reserved;
} __attribute__((packed));

struct XhciEventRingSegment {
    uint64_t start;
    uint32_t size;
    uint32_t reserved;
} __attribute__((packed));

struct XhciInterruptRegisters {
  uint32_t  management;
  uint32_t  moderation;
  uint32_t  event_ring_table_size;
  uint32_t  reserved;
  union {
    struct {
      uint32_t  event_ring_table_base_low;
      uint32_t  event_ring_table_base_high;
    };
    uint64_t    event_ring_table_base;
  };
  union {
    struct {
      uint32_t  event_ring_dequeue_pointer_low;
      uint32_t  event_ring_dequeue_pointer_high;
    };
    uint64_t    event_ring_dequeue_pointer;
  };
  /* User defined state variables */
  XhciEventRingSegment event_ring_segment;
  uint64_t  event_ring_enqueue_index;
  bool      producer_cycle_bit;
} __attribute__((packed));


struct XhciRuntimeRegisters {
  uint32_t  microframe_index;
  uint32_t  reserved[7];
} __attribute__((packed));

struct XhciTransferRequestBlock {
  uint64_t  parameter;
  uint32_t  status;
  uint32_t  control;
  /* User defined state variables */
  uint64_t  address;
  bool      cycle_bit;
} __attribute__((packed));


enum {
  PLS_U0              =  0,
  PLS_U1              =  1,
  PLS_U2              =  2,
  PLS_U3              =  3,
  PLS_DISABLED        =  4,
  PLS_RX_DETECT       =  5,
  PLS_INACTIVE        =  6,
  PLS_POLLING         =  7,
  PLS_RECOVERY        =  8,
  PLS_HOT_RESET       =  9,
  PLS_COMPILANCE_MODE = 10,
  PLS_TEST_MODE       = 11,
  PLS_RESUME          = 15,
};

enum EPType {
  ET_INVALID = 0,
  ET_ISO_OUT,
  ET_BULK_OUT,
  ET_INTR_OUT,
  ET_CONTROL,
  ET_ISO_IN,
  ET_BULK_IN,
  ET_INTR_IN,
};

enum TRBType {
  TRB_RESERVED = 0,
  TR_NORMAL,
  TR_SETUP,
  TR_DATA,
  TR_STATUS,
  TR_ISOCH,
  TR_LINK,
  TR_EVDATA,
  TR_NOOP,
  CR_ENABLE_SLOT,
  CR_DISABLE_SLOT,
  CR_ADDRESS_DEVICE,
  CR_CONFIGURE_ENDPOINT,
  CR_EVALUATE_CONTEXT,
  CR_RESET_ENDPOINT,
  CR_STOP_ENDPOINT,
  CR_SET_TR_DEQUEUE,
  CR_RESET_DEVICE,
  CR_FORCE_EVENT,
  CR_NEGOTIATE_BW,
  CR_SET_LATENCY_TOLERANCE,
  CR_GET_PORT_BANDWIDTH,
  CR_FORCE_HEADER,
  CR_NOOP,
  ER_TRANSFER = 32,
  ER_COMMAND_COMPLETE,
  ER_PORT_STATUS_CHANGE,
  ER_BANDWIDTH_REQUEST,
  ER_DOORBELL,
  ER_HOST_CONTROLLER,
  ER_DEVICE_NOTIFICATION,
  ER_MFINDEX_WRAP,
  /* vendor specific bits */
  CR_VENDOR_NEC_FIRMWARE_REVISION  = 49,
  CR_VENDOR_NEC_CHALLENGE_RESPONSE = 50,
};

enum TRBCCode {
  CC_INVALID = 0,
  CC_SUCCESS,
  CC_DATA_BUFFER_ERROR,
  CC_BABBLE_DETECTED,
  CC_USB_TRANSACTION_ERROR,
  CC_TRB_ERROR,
  CC_STALL_ERROR,
  CC_RESOURCE_ERROR,
  CC_BANDWIDTH_ERROR,
  CC_NO_SLOTS_ERROR,
  CC_INVALID_STREAM_TYPE_ERROR,
  CC_SLOT_NOT_ENABLED_ERROR,
  CC_EP_NOT_ENABLED_ERROR,
  CC_SHORT_PACKET,
  CC_RING_UNDERRUN,
  CC_RING_OVERRUN,
  CC_VF_ER_FULL,
  CC_PARAMETER_ERROR,
  CC_BANDWIDTH_OVERRUN,
  CC_CONTEXT_STATE_ERROR,
  CC_NO_PING_RESPONSE_ERROR,
  CC_EVENT_RING_FULL_ERROR,
  CC_INCOMPATIBLE_DEVICE_ERROR,
  CC_MISSED_SERVICE_ERROR,
  CC_COMMAND_RING_STOPPED,
  CC_COMMAND_ABORTED,
  CC_STOPPED,
  CC_STOPPED_LENGTH_INVALID,
  CC_MAX_EXIT_LATENCY_TOO_LARGE_ERROR = 29,
  CC_ISOCH_BUFFER_OVERRUN = 31,
  CC_EVENT_LOST_ERROR,
  CC_UNDEFINED_ERROR,
  CC_INVALID_STREAM_ID_ERROR,
  CC_SECONDARY_BANDWIDTH_ERROR,
  CC_SPLIT_TRANSACTION_ERROR
};


/* bit definitions */
#define USBCMD_RS       (1<<0)
#define USBCMD_HCRST    (1<<1)
#define USBCMD_INTE     (1<<2)
#define USBCMD_HSEE     (1<<3)
#define USBCMD_LHCRST   (1<<7)
#define USBCMD_CSS      (1<<8)
#define USBCMD_CRS      (1<<9)
#define USBCMD_EWE      (1<<10)
#define USBCMD_EU3S     (1<<11)

#define USBSTS_HCH      (1<<0)
#define USBSTS_HSE      (1<<2)
#define USBSTS_EINT     (1<<3)
#define USBSTS_PCD      (1<<4)
#define USBSTS_SSS      (1<<8)
#define USBSTS_RSS      (1<<9)
#define USBSTS_SRE      (1<<10)
#define USBSTS_CNR      (1<<11)
#define USBSTS_HCE      (1<<12)


#define PORTSC_CCS          (1<<0)
#define PORTSC_PED          (1<<1)
#define PORTSC_OCA          (1<<3)
#define PORTSC_PR           (1<<4)
#define PORTSC_PLS_SHIFT        5
#define PORTSC_PLS_MASK     0xf
#define PORTSC_PP           (1<<9)
#define PORTSC_SPEED_SHIFT      10
#define PORTSC_SPEED_MASK   0xf
#define PORTSC_SPEED_FULL   (1<<10)
#define PORTSC_SPEED_LOW    (2<<10)
#define PORTSC_SPEED_HIGH   (3<<10)
#define PORTSC_SPEED_SUPER  (4<<10)
#define PORTSC_PIC_SHIFT        14
#define PORTSC_PIC_MASK     0x3
#define PORTSC_LWS          (1<<16)
#define PORTSC_CSC          (1<<17)
#define PORTSC_PEC          (1<<18)
#define PORTSC_WRC          (1<<19)
#define PORTSC_OCC          (1<<20)
#define PORTSC_PRC          (1<<21)
#define PORTSC_PLC          (1<<22)
#define PORTSC_CEC          (1<<23)
#define PORTSC_CAS          (1<<24)
#define PORTSC_WCE          (1<<25)
#define PORTSC_WDE          (1<<26)
#define PORTSC_WOE          (1<<27)
#define PORTSC_DR           (1<<30)
#define PORTSC_WPR          (1<<31)

#define CRCR_RCS        (1<<0)
#define CRCR_CS         (1<<1)
#define CRCR_CA         (1<<2)
#define CRCR_CRR        (1<<3)

#define IMAN_IP         (1<<0)
#define IMAN_IE         (1<<1)

#define ERDP_EHB        (1<<3)

#define TRB_SIZE 16

#define TRB_C               (1<<0)
#define TRB_TYPE_SHIFT          10
#define TRB_TYPE_MASK       0x3f
#define TRB_TYPE(t)         (((t).control >> TRB_TYPE_SHIFT) & TRB_TYPE_MASK)

#define TRB_EV_ED           (1<<2)

#define TRB_TR_ENT          (1<<1)
#define TRB_TR_ISP          (1<<2)
#define TRB_TR_NS           (1<<3)
#define TRB_TR_CH           (1<<4)
#define TRB_TR_IOC          (1<<5)
#define TRB_TR_IDT          (1<<6)
#define TRB_TR_TBC_SHIFT        7
#define TRB_TR_TBC_MASK     0x3
#define TRB_TR_BEI          (1<<9)
#define TRB_TR_TLBPC_SHIFT      16
#define TRB_TR_TLBPC_MASK   0xf
#define TRB_TR_FRAMEID_SHIFT    20
#define TRB_TR_FRAMEID_MASK 0x7ff
#define TRB_TR_SIA          (1<<31)

#define TRB_TR_DIR          (1<<16)

#define TRB_CR_SLOTID_SHIFT     24
#define TRB_CR_SLOTID_MASK  0xff
#define TRB_CR_EPID_SHIFT       16
#define TRB_CR_EPID_MASK    0x1f

#define TRB_CR_BSR          (1<<9)
#define TRB_CR_DC           (1<<9)

#define TRB_LK_TC           (1<<1)

#define TRB_INTR_SHIFT          22
#define TRB_INTR_MASK       0x3ff
#define TRB_INTR(t)         (((t).status >> TRB_INTR_SHIFT) & TRB_INTR_MASK)

#define EP_TYPE_MASK        0x7
#define EP_TYPE_SHIFT           3

#define EP_STATE_MASK       0x7
#define EP_DISABLED         (0<<0)
#define EP_RUNNING          (1<<0)
#define EP_HALTED           (2<<0)
#define EP_STOPPED          (3<<0)
#define EP_ERROR            (4<<0)

#define SLOT_STATE_MASK     0x1f
#define SLOT_STATE_SHIFT        27
#define SLOT_STATE(s)       (((s)>>SLOT_STATE_SHIFT)&SLOT_STATE_MASK)
#define SLOT_ENABLED        0
#define SLOT_DEFAULT        1
#define SLOT_ADDRESSED      2
#define SLOT_CONFIGURED     3

#define SLOT_CONTEXT_ENTRIES_MASK 0x1f
#define SLOT_CONTEXT_ENTRIES_SHIFT 27

#define get_field(data, field)                  \
  (((data) >> field##_SHIFT) & field##_MASK)

#define set_field(data, newval, field) do {                     \
    uint32_t val = *data;                                   \
    val &= ~(field##_MASK << field##_SHIFT);                \
    val |= ((newval) & field##_MASK) << field##_SHIFT;      \
    *data = val;                                            \
  } while (0)


#endif // _MVISOR_DEVICES_USB_XHCI_INTERNAL_H

```

`devices/vfio/meson.build`:

```build
mvisor_sources += files(
  'vfio_pci.cc',
  'vfio_pci.h'
)

```

`devices/vfio/vfio_pci.cc`:

```cc
/* 
 * MVisor VFIO for vGPU
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "vfio_pci.h"
#include <cstdlib>
#include <cstring>
#include <unistd.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <sys/prctl.h>
#include <sys/mman.h>
#include <sys/eventfd.h>
#include "device_manager.h"
#include "logger.h"

VfioPci::VfioPci() {
  for (auto &interrupt : interrupts_) {
    interrupt.event_fd = -1;
    interrupt.gsi = -1;
  }
}

VfioPci::~VfioPci() {

}

void VfioPci::Connect() {
  PciDevice::Connect();

  if (!has_key("sysfs")) {
    MV_PANIC("Please specify 'sysfs' for vfio-pci, like '/sys/bus/mdev/devices/xxx'");
  }
  sysfs_path_ = std::get<std::string>(key_values_["sysfs"]);

  SetupVfioGroup();
  SetupVfioContainer();
  SetupVfioDevice();
  SetupPciConfiguration();
  SetupGfxPlane();
  SetupDmaMaps();
  SetupMigraionInfo();
}

void VfioPci::Disconnect() {
  auto machine = manager_->machine();
  if (memory_listener_) {
    machine->memory_manager()->UnregisterMemoryListener(&memory_listener_);
  }
  if (dirty_memory_listener_) {
    machine->memory_manager()->UnregisterDirtyMemoryListener(&dirty_memory_listener_);
  }
  if (state_change_listener_) {
    machine->UnregisterStateChangeListener(&state_change_listener_);
  }

  for (auto &interrupt : interrupts_) {
    if (interrupt.gsi > 0) {
      manager_->UpdateMsiRoute(interrupt.gsi, 0, 0, -1);
    }
    if (interrupt.event_fd > 0) {
      // If we use IRQFD, we don't use polling to handle interrupts
      // StopPolling(interrupt.event_fd);
      safe_close(&interrupt.event_fd);
    }
  }

  manager_->UnregisterVfioGroup(group_fd_);

  safe_close(&device_fd_);
  safe_close(&container_fd_);
  safe_close(&group_fd_);
  PciDevice::Disconnect();
}

void VfioPci::Reset() {
  /* disable IO / MMIO / bus master and INTX */
  uint16_t command = pci_header_.command & ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER | PCI_COMMAND_INTX_DISABLE);
  WritePciConfigSpace(offsetof(PciConfigHeader, command), (uint8_t*)&command, 2);

  /* reset vfio device */
  if (device_fd_ > 0 && (device_info_.flags & VFIO_DEVICE_FLAGS_RESET)) {
    if (ioctl(device_fd_, VFIO_DEVICE_RESET) < 0) {
      MV_PANIC("failed to reset device %s", name_);
    }
  }

  PciDevice::Reset();
}

void VfioPci::SetupPciConfiguration() {
  /* Read PCI configuration from device */
  auto &config_region = regions_[VFIO_PCI_CONFIG_REGION_INDEX];
  size_t config_size = PCI_DEVICE_CONFIG_SIZE;
  MV_ASSERT(config_region.size >= config_size);
  auto ret = pread(device_fd_, pci_header_.data, config_size, config_region.offset);
  if (ret < (int)config_size) {
    MV_PANIC("failed to read device config space, ret=%d", ret);
  }
  /* Multifunction is not supported yet */
  pci_header_.header_type &= ~PCI_MULTI_FUNCTION;
  MV_ASSERT(pci_header_.header_type == PCI_HEADER_TYPE_NORMAL);

  /* Setup bars */
  for (uint8_t i = 0; i < VFIO_PCI_ROM_REGION_INDEX; i++) {
    auto &bar_region = regions_[i];
    if (!bar_region.size)
      continue;
    auto bar = pci_header_.bars[i];
    if (bar & PCI_BASE_ADDRESS_SPACE_IO) {
      AddPciBar(i, bar_region.size, kIoResourceTypePio);
    } else {
      /* 64bit bar is not supported yet */
      if (bar & PCI_BASE_ADDRESS_MEM_TYPE_64) {
        bar &= ~PCI_BASE_ADDRESS_MEM_TYPE_64;
      }
      AddPciBar(i, bar_region.size, kIoResourceTypeMmio);
    }
  }

  /* Setup capabilites */
  if (pci_header_.status & PCI_STATUS_CAP_LIST) {
    uint pos = pci_header_.capability & ~3;
    while (pos) {
      auto cap = (PciCapabilityHeader*)(pci_header_.data + pos);
      switch (cap->type)
      {
      case PCI_CAP_ID_MSI: {
        uint16_t control = *(uint16_t*)&cap[1];
        MV_ASSERT(!(control & PCI_MSI_FLAGS_MASKBIT));
        msi_config_.is_64bit = control & PCI_MSI_FLAGS_64BIT;
        msi_config_.offset = pos;
        msi_config_.is_msix = false;
        if (msi_config_.is_64bit) {
          msi_config_.msi64 = (MsiCapability64*)cap;
          msi_config_.length = sizeof(MsiCapability64);
          msi_config_.enabled = msi_config_.msi64->control & PCI_MSI_FLAGS_ENABLE;
        } else {
          msi_config_.msi32 = (MsiCapability32*)cap;
          msi_config_.length = sizeof(MsiCapability32);
          msi_config_.enabled = msi_config_.msi32->control & PCI_MSI_FLAGS_ENABLE;
        }
        break;
      }
      case PCI_CAP_ID_MSIX: {
        uint16_t control = *(uint16_t*)&cap[1];
        MV_ASSERT(!(control & PCI_MSIX_FLAGS_MASKALL));
        msi_config_.is_64bit = true;
        msi_config_.is_msix = true;
        msi_config_.offset = pos;
        msi_config_.msix = (MsiXCapability*)cap;
        msi_config_.length = sizeof(MsiXCapability);
        msi_config_.enabled = msi_config_.msix->control & PCI_MSIX_FLAGS_ENABLE;
        msi_config_.msix_table_size = (control & PCI_MSIX_FLAGS_QSIZE) + 1;
        msi_config_.msix_space_size = sizeof(msi_config_.msix_table);
        msi_config_.msix_space_offset = msi_config_.msix->table_offset & PCI_MSIX_TABLE_OFFSET;
        msi_config_.msix_bar = msi_config_.msix->table_offset & PCI_MSIX_TABLE_BIR;
        MV_ASSERT(msi_config_.msix_bar < sizeof(pci_header_.bars) / sizeof(uint32_t));
        break;
      }
      case PCI_CAP_ID_VNDR:
        /* ignore vendor specific data */
        break;
      case PCI_CAP_ID_EXP:
        is_pcie_ = true;
        MV_HEXDUMP("unsupported PCI Express", pci_header_.data, PCI_DEVICE_CONFIG_SIZE);
        break;
      default:
        MV_ERROR("unhandled capability=0x%x", cap->type);
        break;
      }
      pos = cap->next;
    }
  }
}

void VfioPci::SetupGfxPlane() {
  vfio_device_gfx_plane_info gfx_plane_info;
  bzero(&gfx_plane_info, sizeof(gfx_plane_info));
  gfx_plane_info.argsz = sizeof(gfx_plane_info);
  gfx_plane_info.flags = VFIO_GFX_PLANE_TYPE_PROBE | VFIO_GFX_PLANE_TYPE_REGION;

  auto ret = ioctl(device_fd_, VFIO_DEVICE_QUERY_GFX_PLANE, &gfx_plane_info);
  if (ret == 0) {
    /* Register GFX plane */
  }
}

void VfioPci::MapDmaPages(const MemorySlot* slot) {
  vfio_iommu_type1_dma_map dma_map = {
    .argsz = sizeof(dma_map),
    .flags = VFIO_DMA_MAP_FLAG_READ | VFIO_DMA_MAP_FLAG_WRITE,
    .vaddr = slot->hva,
    .iova = slot->begin,
    .size = slot->end - slot->begin
  };
  if (ioctl(container_fd_, VFIO_IOMMU_MAP_DMA, &dma_map) < 0) {
    MV_PANIC("failed to map vaddr=0x%lx size=0x%lx", dma_map.iova, dma_map.size);
  }

  // record dma map for network migration
  iommu_dma_maps_[slot] = dma_map;
}

void VfioPci::UnmapDmaPages(const MemorySlot* slot) {
  vfio_iommu_type1_dma_unmap dma_ummap = {
    .argsz = sizeof(dma_ummap),
    .flags = 0,
    .iova = slot->begin,
    .size = slot->end - slot->begin
  };
  if (ioctl(container_fd_, VFIO_IOMMU_UNMAP_DMA, &dma_ummap) < 0) {
    MV_PANIC("failed to unmap vaddr=0x%lx size=0x%lx", dma_ummap.iova, dma_ummap.size);
  }
  iommu_dma_maps_.erase(slot);
}

void VfioPci::SetupDmaMaps() {
  auto mm = manager_->machine()->memory_manager();

  /* Map all current slots */
  for (auto slot : mm->GetMemoryFlatView()) {
    if (slot->type == kMemoryTypeRam && 0 == strcmp("System", slot->region->name)) {
      MapDmaPages(slot);
    }
  }

  /* Add memory listener to keep DMA maps synchronized */
  memory_listener_ = mm->RegisterMemoryListener([this](auto slot, bool unmap) {
    if (slot->type == kMemoryTypeRam && 0 == strcmp("System", slot->region->name)) {
      if (unmap) {
        UnmapDmaPages(slot);
      } else {
        MapDmaPages(slot);
      }
    }
  });

  /* Add dirty memory listener to track memory in DMA */
  dirty_memory_listener_ = mm->RegisterDirtyMemoryListener([this](const DirtyMemoryCommand command) {
    std::vector<struct DirtyMemoryBitmap> bitmaps;
    switch (command) {
      case kGetDirtyMemoryBitmap: {
        auto dirty_buffer_size = sizeof(vfio_iommu_type1_dirty_bitmap) + sizeof(vfio_iommu_type1_dirty_bitmap_get);
        uint8_t dirty_buffer[dirty_buffer_size];

        auto dirty_bitmap = (struct vfio_iommu_type1_dirty_bitmap*)dirty_buffer;
        auto dirty_bitmap_get = (struct vfio_iommu_type1_dirty_bitmap_get*)dirty_bitmap->data;

        dirty_bitmap->argsz = dirty_buffer_size;
        dirty_bitmap->flags = VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP;

        for (auto it = iommu_dma_maps_.begin(); it != iommu_dma_maps_.end(); ++it) {
          size_t bitmap_size = ALIGN(it->second.size / PAGE_SIZE, 64) / 8;
          std::string bitmap(bitmap_size, '\0');

          // get dirty memory bitmap for this iommu region from vfio
          dirty_bitmap_get->iova = it->second.iova;
          dirty_bitmap_get->size = it->second.size;
          dirty_bitmap_get->bitmap = {
            .pgsize = PAGE_SIZE,
            .size = bitmap_size,
            .data = (__u64*)bitmap.data()
          };
          MV_ASSERT(ioctl(container_fd_, VFIO_IOMMU_DIRTY_PAGES, dirty_bitmap) == 0);

          // save it to return for network migration
          bitmaps.push_back({
            .region = {
              .hva = it->second.vaddr,
              .begin = it->second.iova,
              .end = it->second.iova + it->second.size
            },
            .data = std::move(bitmap)
          });
        }
        break;
      }
      case kStopTrackingDirtyMemory:
      case kStartTrackingDirtyMemory: {
        struct vfio_iommu_type1_dirty_bitmap dirty_bitmap = {
          .argsz = sizeof(dirty_bitmap),
          .flags = (uint32_t)(command == kStartTrackingDirtyMemory ? 
            VFIO_IOMMU_DIRTY_PAGES_FLAG_START : VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP)
        };
        MV_ASSERT(ioctl(container_fd_, VFIO_IOMMU_DIRTY_PAGES, &dirty_bitmap) == 0);
        break;
      }
      default:
        MV_PANIC("unknown command");
        break;
    }
    return bitmaps;
  });
}

void VfioPci::SetupVfioGroup() {
  /* Get VFIO group id from device path */
  char path[1024];
  auto len = readlink((sysfs_path_ + "/iommu_group").c_str(), path, 1024);
  if (len < 0) {
    MV_PANIC("failed to read iommu_group");
  }
  path[len] = 0;
  if (sscanf(basename(path), "%d", &group_id_) != 1) {
    MV_PANIC("failed to get group id from %s", path);
  }
  
  /* Open group */
  sprintf(path, "/dev/vfio/%d", group_id_);
  group_fd_ = open(path, O_RDWR);
  if (group_fd_ < 0) {
    MV_PANIC("failed to open %s", path);
  }

  /* Check if it is OK */
  vfio_group_status status = { .argsz = sizeof(status), .flags = 0 };
  MV_ASSERT(ioctl(group_fd_, VFIO_GROUP_GET_STATUS, &status) == 0);
  if (!(status.flags & VFIO_GROUP_FLAGS_VIABLE)) {
    MV_PANIC("VFIO group %d is not viable", group_id_);
  }
}

void VfioPci::SetupVfioContainer() {
  /* Create container */
  container_fd_ = open("/dev/vfio/vfio", O_RDWR);
  if (container_fd_ < 0) {
    MV_PANIC("failed to open /dev/vfio/vfio");
  }

  /* Here use type1 iommu */
  MV_ASSERT(ioctl(container_fd_, VFIO_GET_API_VERSION) == VFIO_API_VERSION);
  MV_ASSERT(ioctl(container_fd_, VFIO_CHECK_EXTENSION, VFIO_TYPE1v2_IOMMU));
  MV_ASSERT(ioctl(group_fd_, VFIO_GROUP_SET_CONTAINER, &container_fd_) == 0);
  MV_ASSERT(ioctl(container_fd_, VFIO_SET_IOMMU, VFIO_TYPE1v2_IOMMU) == 0);
  
  /* Get IOMMU type1 info */
  size_t argsz = sizeof(vfio_iommu_type1_info);
  auto info = (vfio_iommu_type1_info*)malloc(argsz);
  info->argsz = argsz;
  MV_ASSERT(ioctl(container_fd_, VFIO_IOMMU_GET_INFO, info) == 0);
  if (info->argsz != argsz) {
    info = (vfio_iommu_type1_info*)realloc(info, info->argsz);
    MV_ASSERT(ioctl(container_fd_, VFIO_IOMMU_GET_INFO, info) == 0);
  }

  /* Enumerate capabilities, currently migration capability */
  if (info->flags & VFIO_IOMMU_INFO_CAPS && info->cap_offset) {
    uint8_t* ptr = (uint8_t*)info;
    auto cap_header = (vfio_info_cap_header*)(ptr + info->cap_offset);
    while (true) {
      if (cap_header->id == VFIO_IOMMU_TYPE1_INFO_CAP_MIGRATION) {
        auto cap_migration = (vfio_iommu_type1_info_cap_migration*)cap_header;
        /* page size should support 4KB */
        MV_ASSERT(cap_migration->pgsize_bitmap & PAGE_SIZE);
      }
      if (cap_header->next) {
        cap_header = (vfio_info_cap_header*)(ptr + cap_header->next);
      } else {
        break;
      }
    }
  }
  free(info);
  
  /* Add iommu group to KVM */
  manager_->RegisterVfioGroup(group_fd_);
}

void VfioPci::SetupVfioDevice() {
  device_name_ = basename(sysfs_path_.c_str());
  device_fd_ = ioctl(group_fd_, VFIO_GROUP_GET_DEVICE_FD, device_name_.c_str());
 
  /* get device info */
  bzero(&device_info_, sizeof(device_info_));
  device_info_.argsz = sizeof(device_info_);
  MV_ASSERT(ioctl(device_fd_, VFIO_DEVICE_GET_INFO, &device_info_) == 0);
  
  MV_ASSERT(device_info_.flags & VFIO_DEVICE_FLAGS_RESET);
  MV_ASSERT(device_info_.flags & VFIO_DEVICE_FLAGS_PCI);
  MV_ASSERT(device_info_.num_regions > VFIO_PCI_CONFIG_REGION_INDEX);
  MV_ASSERT(device_info_.num_irqs > VFIO_PCI_MSIX_IRQ_INDEX);

  /* find vfio regions */
  bzero(&regions_, sizeof(regions_));
  for (uint index = VFIO_PCI_BAR0_REGION_INDEX; index < device_info_.num_regions; index++) {
    auto argsz = sizeof(vfio_region_info);
    auto region_info = (vfio_region_info*)malloc(argsz);
    bzero(region_info, argsz);
    region_info->argsz = argsz;
    region_info->index = index;

    MV_ASSERT(ioctl(device_fd_, VFIO_DEVICE_GET_REGION_INFO, region_info) == 0);
    if (region_info->argsz != argsz) {
      region_info = (vfio_region_info*)realloc(region_info, region_info->argsz);
      MV_ASSERT(ioctl(device_fd_, VFIO_DEVICE_GET_REGION_INFO, region_info) == 0);
    }
    if (!region_info->size) {
      free(region_info);
      continue;
    }
    if (region_info->index >= MAX_VFIO_REGIONS) {
      free(region_info);
      continue;
    }
    
    auto &region = regions_[region_info->index];
    region.index = region_info->index;
    region.flags = region_info->flags;
    region.offset = region_info->offset;
    region.size = region_info->size;

    if ((region_info->flags & VFIO_REGION_INFO_FLAG_CAPS) && region_info->cap_offset) {
      auto ptr = (uint8_t*)region_info;
      auto cap_header = (vfio_info_cap_header*)(ptr + region_info->cap_offset);
      while (true) {
        if (cap_header->id == VFIO_REGION_INFO_CAP_SPARSE_MMAP) {
          auto cap_mmap = (vfio_region_info_cap_sparse_mmap*)cap_header;
          for (uint j = 0; j < cap_mmap->nr_areas; j++) {
            region.mmap_areas.push_back({
              .offset = cap_mmap->areas[j].offset,
              .size = cap_mmap->areas[j].size,
              .mmap = nullptr
            });
          }
        } else if (cap_header->id == VFIO_REGION_INFO_CAP_TYPE) {
          auto cap_type = (vfio_region_info_cap_type*)cap_header;
          region.type = cap_type->type;
          region.subtype = cap_type->subtype;
        }
        if (cap_header->next) {
          cap_header = (vfio_info_cap_header*)(ptr + cap_header->next);
        } else {
          break;
        }
      }
    }
    if (debug_) {
      MV_LOG("region index=%u flags=0x%x size=0x%lx type=%d subtype=%d sparse=%lu",
        region.index, region.flags, region.size, region.type, region.subtype, region.mmap_areas.size());
    }
    free(region_info);
  }

  /* find vfio interrupts */
  for (auto &interrupt : interrupts_) {
    interrupt.event_fd = -1;
  }
  for (uint index = 0; index < device_info_.num_irqs; index++) {
    vfio_irq_info irq_info;
    bzero(&irq_info, sizeof(irq_info));
    irq_info.argsz = sizeof(irq_info);
    irq_info.index = index;
    auto ret = ioctl(device_fd_, VFIO_DEVICE_GET_IRQ_INFO, &irq_info);
    if (debug_) {
      MV_LOG("irq index=%d size=%u flags=%x count=%d ret=%d", index,
        irq_info.argsz, irq_info.flags, irq_info.count, ret);
    }

    /* FIXME: currently my mdev only uses one IRQ */
    if (index == VFIO_PCI_MSI_IRQ_INDEX) {
      MV_ASSERT(irq_info.flags & VFIO_IRQ_INFO_EVENTFD);
      MV_ASSERT(irq_info.count == 1 || irq_info.count == 3);
    } else if (index == VFIO_PCI_MSIX_IRQ_INDEX) {
      MV_ASSERT(irq_info.flags & VFIO_IRQ_INFO_EVENTFD);
      MV_ASSERT(irq_info.count == 1 || irq_info.count == 3);
    }
  }
}

void VfioPci::SetupMigraionInfo() {
  bzero(&migration_, sizeof(migration_));
  auto index = FindRegion(VFIO_REGION_TYPE_MIGRATION, VFIO_REGION_SUBTYPE_MIGRATION);
  if (index < 0) {
    return;
  }
  migration_.enabled = true;
  migration_.region = &regions_[index];
  MV_ASSERT(migration_.region->mmap_areas.size() == 1);

  auto machine = manager_->machine();
  state_change_listener_ = machine->RegisterStateChangeListener([=]() {
    if (machine->IsPaused()) {
      SetMigrationDeviceState(VFIO_DEVICE_STATE_STOP);
    } else {
      SetMigrationDeviceState(VFIO_DEVICE_STATE_RUNNING);
    }
  });
}

void VfioPci::MapBarRegion(uint8_t index) {
  auto &bar = pci_bars_[index];
  auto &region = regions_[index];
  int protect = 0;
  if (region.flags & VFIO_REGION_INFO_FLAG_READ)
    protect |= PROT_READ;
  if (region.flags & VFIO_REGION_INFO_FLAG_WRITE)
    protect |= PROT_WRITE;
  if (region.mmap_areas.empty()) {
    bar.host_memory = mmap(nullptr, region.size, protect, MAP_SHARED, device_fd_, region.offset);
    AddIoResource(kIoResourceTypeRam, bar.address, bar.size, "VFIO BAR RAM", bar.host_memory);
  } else {
    /* The MMIO region is overlapped by the mmap areas */
    AddIoResource(kIoResourceTypeMmio, bar.address, bar.size, "VFIO BAR MMIO");
    for (auto &area : region.mmap_areas) {
      area.mmap = mmap(nullptr, area.size, protect, MAP_SHARED, device_fd_, region.offset + area.offset);
      if (area.mmap == MAP_FAILED) {
        MV_PANIC("failed to map region %d, area offset=0x%lx size=0x%lx", index, area.offset, area.size);
      }
      AddIoResource(kIoResourceTypeRam, bar.address + area.offset, area.size, "VFIO BAR RAM", area.mmap);
    }
  }
}

void VfioPci::UnmapBarRegion(uint8_t index) {
  auto &bar = pci_bars_[index];
  auto &region = regions_[index];
  if (region.mmap_areas.empty()) {
    RemoveIoResource(kIoResourceTypeRam, bar.address);
    munmap(bar.host_memory, region.size);
  } else {
    for (auto &area : region.mmap_areas) {
      RemoveIoResource(kIoResourceTypeRam, bar.address + area.offset);
      munmap(area.mmap, area.size);
    }
    RemoveIoResource(kIoResourceTypeMmio, bar.address);
  }
}

bool VfioPci::ActivatePciBar(uint8_t index) {
  auto &bar = pci_bars_[index];
  auto &region = regions_[index];
  if (region.flags & VFIO_REGION_INFO_FLAG_MMAP) {
    MV_ASSERT(!bar.active && bar.type == kIoResourceTypeMmio);
    MapBarRegion(index);
    bar.active = true;
    return true;
  }
  return PciDevice::ActivatePciBar(index);
}

bool VfioPci::DeactivatePciBar(uint8_t index) {
  auto &bar = pci_bars_[index];
  auto &region = regions_[index];
  if (region.flags & VFIO_REGION_INFO_FLAG_MMAP) {
    MV_ASSERT(bar.active && bar.type == kIoResourceTypeMmio);
    UnmapBarRegion(index);
    bar.active = false;
    return true;
  }
  return PciDevice::DeactivatePciBar(index);
}

ssize_t VfioPci::ReadRegion(uint8_t index, uint64_t offset, void* data, uint32_t length) {
  MV_ASSERT(index < MAX_VFIO_REGIONS);
  auto &region = regions_[index];
  return pread(device_fd_, data, length, region.offset + offset);
}

ssize_t VfioPci::WriteRegion(uint8_t index, uint64_t offset, void* data, uint32_t length) {
  MV_ASSERT(index < MAX_VFIO_REGIONS);
  auto &region = regions_[index];
  return pwrite(device_fd_, data, length, region.offset + offset);
}

int VfioPci::FindRegion(uint32_t type, uint32_t subtype) {
  for (uint8_t i = 0; i < regions_.size(); i++) {
    if (regions_[i].type == type && regions_[i].subtype == subtype) {
      return i;
    }
  }
  return -ENOENT;
}

void VfioPci::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    if (pci_bars_[i].address == resource->base) {
      WriteRegion(i, offset, data, size);
      if (msi_config_.is_msix && i == msi_config_.msix_bar) {
        // we need to continue to set msix table
        break;
      } 

      // just return
      return;
    }
  }
  PciDevice::Write(resource, offset, data, size);
}

void VfioPci::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    if (pci_bars_[i].address == resource->base) {
      ReadRegion(i, offset, data, size);
      return;
    }
  }
  PciDevice::Read(resource, offset, data, size);
}

void VfioPci::EnableIRQ(uint32_t index, uint32_t vector, int *fds, uint8_t count) {
  uint8_t buffer[sizeof(vfio_irq_set) + sizeof(int) * count];
  auto irq_set = (vfio_irq_set *)buffer;
  irq_set->argsz = sizeof(vfio_irq_set) + sizeof(int) * count;
  irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER;
  irq_set->index = index;
  irq_set->start = vector;
  irq_set->count = count;
  memcpy(irq_set->data, fds, sizeof(int) * count);
  MV_ASSERT(ioctl(device_fd_, VFIO_DEVICE_SET_IRQS, irq_set) == 0);
}

void VfioPci::UpdateMsiRoutes() {
  uint nr_vectors = 0;
  uint16_t control = 0;
  if (msi_config_.is_msix) {
    control = msi_config_.msix->control;
    nr_vectors = msi_config_.msix_table_size;
    msi_config_.enabled = control & PCI_MSIX_FLAGS_ENABLE;
  } else {
    control =  msi_config_.is_64bit ? msi_config_.msi64->control : msi_config_.msi32->control;
    nr_vectors = 1 << ((control & PCI_MSI_FLAGS_QSIZE) >> 4);
    msi_config_.enabled = control & PCI_MSI_FLAGS_ENABLE;
  }

  if (msi_config_.enabled) {
    int fds[nr_vectors];
    memset(fds, -1, sizeof(fds));
    EnableIRQ(msi_config_.is_msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX, 0, fds, nr_vectors);
  }

  for (uint vector = 0; vector < nr_vectors; vector++) {
    auto &interrupt = interrupts_[vector];
    if (interrupt.event_fd == -1) {
      interrupt.event_fd = eventfd(0, 0);
    }
  
    uint64_t msi_address;
    uint32_t msi_data;
    if (msi_config_.is_msix) {
      msi_address = ((uint64_t)msi_config_.msix_table[vector].message.address_hi << 32) | msi_config_.msix_table[vector].message.address_lo;
      msi_data = msi_config_.msix_table[vector].message.data;
    } else if (msi_config_.is_64bit) {
      msi_address = ((uint64_t)msi_config_.msi64->address1 << 32) | msi_config_.msi64->address0;
      msi_data = msi_config_.msi64->data;
    } else {
      msi_address = msi_config_.msi32->address;
      msi_data = msi_config_.msi32->data;
    }

    if (debug_) {
      MV_LOG("msi_address=0x%lx msi_data=%d vector=%d", msi_address, msi_data, vector);
    }

    if (msi_config_.enabled && msi_address) {
      if (interrupt.gsi == -1) {
        interrupt.gsi = manager_->AddMsiRoute(msi_address, msi_data, interrupt.event_fd);

        // set irq with KVM_IRQFD
        EnableIRQ(msi_config_.is_msix ? VFIO_PCI_MSIX_IRQ_INDEX : VFIO_PCI_MSI_IRQ_INDEX, vector, &interrupt.event_fd, 1);
      } else {
        manager_->UpdateMsiRoute(interrupt.gsi, msi_address, msi_data, interrupt.event_fd);
      }
    } else {
      if (interrupt.gsi != -1) {
        manager_->UpdateMsiRoute(interrupt.gsi, 0, 0, interrupt.event_fd);
        interrupt.gsi = -1;
      }
    }
  }
}

void VfioPci::WritePciCommand(uint16_t new_command) {
  int toggle_io = (pci_header_.command ^ new_command) & PCI_COMMAND_IO;
  int toggle_mem = (pci_header_.command ^ new_command) & PCI_COMMAND_MEMORY;

  for (int i = 0; i < PCI_BAR_NUMS; i++) {
    auto &bar = pci_bars_[i];
    if (!bar.address || bar.active) {
      continue;
    }

    // DeactivatePciBar only can be called in vfio-pci Disconnect routine
    if (toggle_io && bar.type == kIoResourceTypePio && (new_command & PCI_COMMAND_IO)) {
      ActivatePciBar(i);
    } else if (toggle_mem && bar.type != kIoResourceTypePio && (new_command & PCI_COMMAND_MEMORY)) {
      ActivatePciBar(i);
    }
  }
  pci_header_.command = new_command;
}

void VfioPci::WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
  MV_ASSERT(length <= 4);
  MV_ASSERT(offset + length <= PCIE_DEVICE_CONFIG_SIZE);
  auto &config_region = regions_[VFIO_PCI_CONFIG_REGION_INDEX];

  /* write the VFIO device, check if msi */
  auto ret = pwrite(device_fd_, data, length, config_region.offset + offset);
  if (ret != (ssize_t)length) {
    MV_PANIC("failed to write VFIO device, offset=0x%x length=0x%x data=0x%x ret=%d",
      offset, length, *(uint32_t*)data, ret);
  }

  /* the default bahavior detects BAR activate/deactivate */
  PciDevice::WritePciConfigSpace(offset, data, length);

  /* update interrupts if needed */
  if (ranges_overlap(offset, length, msi_config_.offset + PCI_MSI_FLAGS, 1)) {
    UpdateMsiRoutes();
  }
}

void VfioPci::ReadPciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length) {
  MV_ASSERT(offset + length <= PCIE_DEVICE_CONFIG_SIZE);

  /* read from VFIO device */
  auto &config_region = regions_[VFIO_PCI_CONFIG_REGION_INDEX];
  auto ret = pread(device_fd_, pci_header_.data + offset, length, config_region.offset + offset);
  MV_ASSERT(ret == (ssize_t)length);

  PciDevice::ReadPciConfigSpace(offset, data, length);
}

void VfioPci::SetMigrationDeviceState(uint32_t device_state) {
  MV_ASSERT(migration_.enabled);
  pwrite(device_fd_, &device_state, sizeof(device_state), migration_.region->offset);
}

bool VfioPci::SaveState(MigrationWriter* writer) {
  if (!migration_.enabled) {
    MV_LOG("%s:%s blocked migration", name_, device_name_.c_str());
    return false;
  }

  /* Map buffer for saving */
  auto& area = migration_.region->mmap_areas.front();
  void* buffer = mmap(nullptr, area.size, PROT_READ | PROT_WRITE, MAP_SHARED,
    device_fd_, migration_.region->offset + area.offset);
  if (buffer == MAP_FAILED) {
    MV_PANIC("failed to map area offset=0x%lx size=0x%lx", area.offset, area.size);
  }

  SetMigrationDeviceState(VFIO_DEVICE_STATE_SAVING);
  int fd = writer->BeginWrite("DATA");
  bool success = false;

  while (true) {
    uint64_t pending_bytes;
    auto ret = pread(device_fd_, &pending_bytes, sizeof(pending_bytes),
      migration_.region->offset + offsetof(vfio_device_migration_info, pending_bytes));
    if (ret < 0)
      break;

    if (pending_bytes == 0) {
      success = true;
      break;
    } else if (pending_bytes > area.size) {
      pending_bytes = area.size;
    }

    uint64_t data_offset = 0;
    pread(device_fd_, &data_offset, sizeof(data_offset),
      migration_.region->offset + offsetof(vfio_device_migration_info, data_offset));
    uint64_t data_size = 0;
    pread(device_fd_, &data_size, sizeof(data_size),
      migration_.region->offset + offsetof(vfio_device_migration_info, data_size));
    MV_ASSERT(data_offset == area.offset);
    MV_ASSERT(data_size <= area.size);

    /* nVidia vGPU migration fixes */
    if (data_size == 0)
      data_size = pending_bytes;
    
    if (dynamic_cast<MigrationNetworkWriter*>(writer)) {
      if (writer->WriteRaw("VFIO_DATA", buffer, data_size)) {
        ret = data_size;
      } else {
        MV_ERROR("send vfio data error");
        break;
      }
    } else {
      ret = write(fd, buffer, data_size);
    }
    MV_ASSERT(ret == (ssize_t)data_size);
  }

  writer->EndWrite("DATA");
  SetMigrationDeviceState(VFIO_DEVICE_STATE_STOP);
  
  munmap(buffer, area.size);
  return success && PciDevice::SaveState(writer);
}

bool VfioPci::LoadState(MigrationReader* reader) {
  bool success = false;
  if (!PciDevice::LoadState(reader)) {
    return success;
  }

  /* Restore the PCI config space to VFIO device */
  auto &config_region = regions_[VFIO_PCI_CONFIG_REGION_INDEX];
  for (uint i = 0; i < pci_config_size(); i += 2) {
    pwrite(device_fd_, &pci_header_.data[i], 2, config_region.offset + i);
  }

  /* Update MSI routes */
  UpdateMsiRoutes();

  /* Map buffer for restoring */
  auto& area = migration_.region->mmap_areas.front();
  void* buffer = mmap(nullptr, area.size, PROT_READ | PROT_WRITE, MAP_SHARED,
    device_fd_, migration_.region->offset + area.offset);
  if (buffer == MAP_FAILED) {
    MV_PANIC("failed to map area offset=0x%lx size=0x%lx", area.offset, area.size);
  }

  SetMigrationDeviceState(VFIO_DEVICE_STATE_RESUMING);
  int fd = reader->BeginRead("DATA");

  while (true) {
    uint64_t data_offset = 0;
    pread(device_fd_, &data_offset, sizeof(data_offset),
      migration_.region->offset + offsetof(vfio_device_migration_info, data_offset));
    if (data_offset != area.offset) {
      MV_ERROR("failed to read vfio, data_offset=0x%lx area.offset=0x%lx", data_offset, area.offset);
      break;
    }
    
    ssize_t ret;
    if (dynamic_cast<MigrationNetworkReader*>(reader)) {
      ret = reader->ReadRawWithLimit("VFIO_DATA", buffer, area.size);
    } else {
      ret = read(fd, buffer, area.size);
    }

    if (ret > 0) {
      pwrite(device_fd_, &ret, sizeof(ret),
        migration_.region->offset + offsetof(vfio_device_migration_info, data_size));
    }
    if (ret < (ssize_t)area.size) {
      success = true;
      break;
    }
  }

  reader->EndRead("DATA");
  SetMigrationDeviceState(VFIO_DEVICE_STATE_STOP);
  
  munmap(buffer, area.size);
  return success;
}

DECLARE_DEVICE(VfioPci);

```

`devices/vfio/vfio_pci.h`:

```h
/* 
 * MVisor VFIO for vGPU
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_VFIO_VFIO_PCI_H
#define _MVISOR_DEVICES_VFIO_VFIO_PCI_H

#include <cstdint>
#include <string>
#include "linuz/vfio.h"
#include "pci_device.h"
#include "memory_manager.h"
#include "machine.h"

#define MAX_VFIO_REGIONS      (12)
#define MAX_VFIO_INTERRUPTS   (PCI_MAX_MSIX_ENTRIES)

struct VfioMmapArea {
  uint64_t  offset;
  uint64_t  size;
  void*     mmap;
};

struct VfioRegion {
  uint32_t  index;
  uint32_t  flags;
  uint64_t  offset;
  uint64_t  size;
  uint32_t  type;
  uint32_t  subtype;
  std::vector<VfioMmapArea> mmap_areas;
};

struct VfioInterrupt {
  int       event_fd;
  int       gsi;
};

struct VfioMigration {
  bool        enabled;
  VfioRegion* region;
};

class VfioPci : public PciDevice {
 public:
  VfioPci();
  virtual ~VfioPci();
  virtual void Connect();
  virtual void Disconnect();
  virtual void Reset();
  virtual bool ActivatePciBar(uint8_t index);
  virtual bool DeactivatePciBar(uint8_t index);
  
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length);
  virtual void ReadPciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length);
  virtual void WritePciCommand(uint16_t new_command);

  /* VFIO migration */
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

 protected:
  void SetupVfioGroup();
  void SetupVfioDevice();
  void SetupVfioContainer();
  void SetupPciConfiguration();
  void SetupPciInterrupts();
  void SetupGfxPlane();
  void SetupDmaMaps();
  void SetupMigraionInfo();

  void UpdateMsiRoutes();
  void MapDmaPages(const MemorySlot* slot);
  void UnmapDmaPages(const MemorySlot* slot);
  void MapBarRegion(uint8_t index);
  void UnmapBarRegion(uint8_t index);
  ssize_t ReadRegion(uint8_t index, uint64_t offset, void* data, uint32_t length);
  ssize_t WriteRegion(uint8_t index, uint64_t offset, void* data, uint32_t length);
  int     FindRegion(uint32_t type, uint32_t subtype);
  void SetMigrationDeviceState(uint32_t device_state);
  void EnableIRQ(uint32_t index, uint32_t vector, int* fds, uint8_t count);

 private:
  std::string   sysfs_path_;
  std::string   device_name_;
  int           container_fd_ = -1;
  int           group_id_ = -1;
  int           group_fd_ = -1;
  int           device_fd_ = -1;
  vfio_device_info                                      device_info_;
  std::array<VfioRegion, MAX_VFIO_REGIONS>              regions_;
  std::array<VfioInterrupt, MAX_VFIO_INTERRUPTS>        interrupts_;
  VfioMigration                                         migration_;
  const MemoryListener*                                 memory_listener_ = nullptr;
  const DirtyMemoryListener*                            dirty_memory_listener_ = nullptr;
  const StateChangeListener*                            state_change_listener_ = nullptr;
  std::map<const MemorySlot*, vfio_iommu_type1_dma_map> iommu_dma_maps_;
};

#endif // _MVISOR_DEVICES_VFIO_VFIO_PCI_H

```

`devices/virtio/fuse/fuse.cc`:

```cc
/*
 * MVisor
 * fuse.cc is based on libfuse3
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "fuse.h"

Fuse::Fuse(std::string& mount_path, uint64_t disk_size_limit, uint64_t inode_count_limit) {
  // start fuse init process
  user_config_.timeout = 1.0;

  // set mount path from config
  user_config_.source = new char[mount_path.length() + 1];
  strcpy(user_config_.source, mount_path.c_str());

  // check mount path must be director
  struct stat stat;
  MV_ASSERT(lstat(user_config_.source, &stat) != -1);
  MV_ASSERT(S_ISDIR(stat.st_mode));

  // new root dir
  user_config_.root = new Inode;
  MV_ASSERT(user_config_.root != nullptr);

  // in case vm start from snapshot
  user_config_.root->refcount = 2;
  user_config_.root->ino = stat.st_ino;
  user_config_.root->dev = stat.st_dev;
  user_config_.root->fd = open(user_config_.source, O_PATH);
  MV_ASSERT(user_config_.root->fd != -1);
  inode_list_.push_front(user_config_.root);

  // init disk size
  disk_info_.size_limit = disk_size_limit;
  disk_info_.inode_limit = inode_count_limit;
  UpdateDiskInfo();
  MV_ASSERT(disk_info_.size_limit >= disk_info_.size_used && disk_info_.inode_limit >= disk_info_.inode_count);
}

Fuse::~Fuse() {
  if (user_config_.source) {
    delete[] user_config_.source;
  }
  
  ClearInodeList(true);
}

void Fuse::UpdateDiskInfo() {
  disk_info_.size_used = 0;
  disk_info_.inode_count = 0;
  for (auto& entry : std::filesystem::recursive_directory_iterator(user_config_.source)) {
    if (entry.is_regular_file()) {
      disk_info_.size_used += entry.file_size();
    }
    disk_info_.inode_count++;
  }
}

struct Inode* Fuse::GetInode(fuse_ino_t inode) {
  if (inode == FUSE_ROOT_ID) {
    return user_config_.root;
  }
  auto iter = std::find(inode_list_.begin(), inode_list_.end(), (struct Inode*)(uintptr_t)inode);
  if (iter != inode_list_.end()) {
    return *iter;
  } else {
    return nullptr;
  }
}

int Fuse::GetFdFromInode(fuse_ino_t ino) {
  Inode* inode = GetInode(ino);
  if (inode == nullptr) {
    return -1;
  }
  return inode->fd;
}

Inode* Fuse::GetInodeFromFd(int fd) {
  auto inode = std::find_if(inode_list_.begin(), inode_list_.end(), [=](struct Inode* inode) -> bool {
    return inode->fd == fd;
  });

  if (inode == inode_list_.end()) {
    return nullptr;
  } else {
    return *inode;
  }
}

struct Inode* Fuse::GetInodeFromStat(struct stat* stat) {
  auto inode = std::find_if(inode_list_.begin(), inode_list_.end(), [=](struct Inode* inode) -> bool {
    return inode->dev == stat->st_dev && inode->ino == stat->st_ino;
  });

  if (inode == inode_list_.end()) {
    return nullptr;
  } else {
    return *inode;
  }
}

void Fuse::ModifyDiskInformationToVm(struct statvfs* new_stat_vfs) {
  // we need to update disk info in case that the host files in mount path was updated
  UpdateDiskInfo();

  // the host can write in the mount path shared with vm
  if (disk_info_.size_used > disk_info_.size_limit) {
    disk_info_.size_limit = disk_info_.size_used;
  }
  if (disk_info_.inode_count > disk_info_.inode_limit) {
    disk_info_.inode_limit = disk_info_.inode_count;
  }

  new_stat_vfs->f_files = disk_info_.inode_limit;
  new_stat_vfs->f_blocks = disk_info_.size_limit / BLOCK_SIZE;
  new_stat_vfs->f_bfree = new_stat_vfs->f_bavail = (disk_info_.size_limit - disk_info_.size_used) / BLOCK_SIZE;
  new_stat_vfs->f_ffree = new_stat_vfs->f_favail = disk_info_.inode_limit - inode_list_.size();
}

void Fuse::ClearInodeList(bool clear_root) {
  for (auto it = inode_list_.begin(); it != inode_list_.end();) {
    if(!clear_root && (*it)->fd == user_config_.root->fd) {
      it++;
    } else {
      close((*it)->fd);
      delete *it;
      it = inode_list_.erase(it);
    }
  }
}

bool Fuse::FilePathSafeCheck(int fd) {
  // get fd file path
  char file_path[PATH_MAX] = {0};
  auto fd_path = "/proc/self/fd/" + std::to_string(fd);
  auto len = readlink(fd_path.c_str(), file_path, PATH_MAX);
  if (len == -1) {
    MV_ERROR("readlink failed fd=%d errno=%d", fd, -errno);
    return false;
  }

  std::string mount_path = user_config_.source;
  auto compare_len = mount_path.size();
  if (len < (ssize_t)compare_len) {
    MV_ERROR("file path too short len=%d", len);
    return false;
  }

  // fd path must start with mount_path_
  std::string file_path_str = file_path;
  if (0 != file_path_str.compare(0, compare_len, mount_path, 0, compare_len)) {
    MV_PANIC("guest attempt to get out of share root path=%s", file_path);
    return false;
  }

  return true;
}

Inode* Fuse::CreateInodeFromFd(int fd, struct stat* stat, int refcount) {
  if (!FilePathSafeCheck(fd)) {
    return nullptr;
  }

  Inode* inode = new Inode{
    .fd = fd,
    .refcount = refcount,
    .ino = stat->st_ino,
    .dev = stat->st_dev
  };
  MV_ASSERT(inode != nullptr);
  inode_list_.push_front(inode);
  return inode;
}

bool Fuse::Lookup(fuse_ino_t parent, const char* name, struct fuse_entry_param* entry_param) {
  entry_param->generation = 0;
  entry_param->attr_timeout = user_config_.timeout;
  entry_param->entry_timeout = user_config_.timeout;

  auto parent_fd = GetFdFromInode(parent);
  MV_ASSERT(parent_fd != -1);
  
  auto ret = fstatat(parent_fd, name, &entry_param->attr, 0);
  if (ret != 0) {
    return false;
  }

  auto inode = GetInodeFromStat(&entry_param->attr);
  if (inode) {
    inode->refcount++;
  } else {
    auto open_flags = S_ISREG(entry_param->attr.st_mode) ? O_RDWR : O_PATH | O_NOFOLLOW;
    auto new_fd = openat(parent_fd, name, open_flags);
    if (new_fd == -1) {
      MV_ERROR("lookup openat err name=%s open_flags=%d", name, open_flags);
      return false;
    }

    inode = CreateInodeFromFd(new_fd, &entry_param->attr, 1);
    MV_ASSERT(inode != nullptr);
  }
  
  entry_param->ino = (fuse_ino_t)inode;
  return true;
}

void Fuse::ConvertStatToFuseAttr(const struct stat* stbuf, struct fuse_attr* attr) {
  attr->ino = stbuf->st_ino;
  attr->mode = stbuf->st_mode;
  attr->nlink = stbuf->st_nlink;
  attr->uid = stbuf->st_uid;
  attr->gid = stbuf->st_gid;
  attr->rdev = stbuf->st_rdev;
  attr->size = stbuf->st_size;
  attr->blksize = stbuf->st_blksize;
  attr->blocks = stbuf->st_blocks;
  attr->atime = stbuf->st_atime;
  attr->mtime = stbuf->st_mtime;
  attr->ctime = stbuf->st_ctime;
  attr->atimensec = 0;
  attr->mtimensec = 0;
  attr->ctimensec = 0;
}

void Fuse::CopyStatFs(const struct statvfs* stbuf, struct fuse_kstatfs* kstatfs) {
  kstatfs->bsize = stbuf->f_bsize;
  kstatfs->frsize = stbuf->f_frsize;
  kstatfs->blocks = stbuf->f_blocks;
  kstatfs->bfree = stbuf->f_bfree;
  kstatfs->bavail = stbuf->f_bavail;
  kstatfs->files = stbuf->f_files;
  kstatfs->ffree = stbuf->f_ffree;
  kstatfs->namelen = stbuf->f_namemax;
}

void Fuse::UnrefInode(struct Inode* inode, uint64_t refcount) {
  inode->refcount -= refcount;
  MV_ASSERT(inode->refcount >= 0);

  if (inode->refcount == 0) {
    close(inode->fd);
    inode_list_.remove(inode);
    delete inode;
  }
}

size_t Fuse::AddDirentryPlus(char* buf, size_t buf_size, const char* name,
                                 const struct fuse_entry_param* entry_param, off_t off) {
  size_t name_length = strlen(name);
  size_t entry_length = FUSE_NAME_OFFSET_DIRENTPLUS + name_length;
  size_t entry_length_padded = FUSE_DIRENT_ALIGN(entry_length);
  if (entry_length_padded > buf_size) {
    return 0;
  }

  struct fuse_direntplus* dp = (struct fuse_direntplus*)buf;
  bzero(&dp->entry_out, sizeof(dp->entry_out));
  
  dp->entry_out.nodeid = entry_param->ino;
  dp->entry_out.generation = entry_param->generation;
  dp->entry_out.entry_valid = CalcTimeoutSecond(entry_param->entry_timeout);
  dp->entry_out.entry_valid_nsec = CalcTimeoutNsecond(entry_param->entry_timeout);
  dp->entry_out.attr_valid = CalcTimeoutSecond(entry_param->attr_timeout);
  dp->entry_out.attr_valid_nsec = CalcTimeoutNsecond(entry_param->attr_timeout);
  ConvertStatToFuseAttr(&entry_param->attr, &dp->entry_out.attr);

  dp->dirent.ino = entry_param->attr.st_ino;
  dp->dirent.off = off;
  dp->dirent.namelen = name_length;
  dp->dirent.type = (entry_param->attr.st_mode & S_IFMT) >> 12;
  memcpy(dp->dirent.name, name, name_length);
  bzero(dp->dirent.name + name_length, entry_length_padded - entry_length);
  return entry_length_padded;
}

size_t Fuse::AddDirentry(char* buf, size_t buf_size, const char* name, const struct stat* stat, off_t off) {
  size_t name_length = strlen(name);
  size_t entry_length = FUSE_NAME_OFFSET + name_length;
  size_t enttry_length_padded = FUSE_DIRENT_ALIGN(entry_length);
  if (enttry_length_padded > buf_size) {
    return 0;
  }

  struct fuse_dirent* dirent;
  dirent = (struct fuse_dirent*)buf;
  dirent->ino = stat->st_ino;
  dirent->off = off;
  dirent->namelen = name_length;
  dirent->type = (stat->st_mode & S_IFMT) >> 12;
  memcpy(dirent->name, name, name_length);
  bzero(dirent->name + name_length, enttry_length_padded - entry_length);
  return enttry_length_padded;
}

bool Fuse::ReadDirectory(fuse_read_in* read_in, uint64_t nodeid, char* result_buf, uint32_t* result_buf_len, bool is_plus) {
  auto dirp = (Directory*)read_in->fh;
  if (read_in->offset != (uint64_t)dirp->offset) {
    seekdir(dirp->dp, read_in->offset);
    dirp->entry = nullptr;
  }

  // get result in loop
  bool lookup_err = false;
  auto remain_buf_len = read_in->size;
  auto result_buf_pointer = result_buf;
  while (true) {
    if (!dirp->entry) {
      dirp->entry = readdir(dirp->dp);
      if (!dirp->entry) {
        break;
      }
    }

    fuse_ino_t entry_ino = 0;
    struct fuse_entry_param entry_param;
    bzero(&entry_param, sizeof(entry_param));

    auto name = dirp->entry->d_name;
    auto next_off = dirp->entry->d_off;
    if (!is_plus || IsDotOrDotdot(name)) {
      entry_param.attr.st_ino = dirp->entry->d_ino;
      entry_param.attr.st_mode = dirp->entry->d_type << 12;
    } else {
      if (!Lookup(nodeid, name, &entry_param)) {
          lookup_err = true;
          break;
      }
      entry_ino = entry_param.ino;
    }

    size_t entry_size;
    if (is_plus) {
      entry_size = AddDirentryPlus(result_buf_pointer, remain_buf_len, name, &entry_param, next_off);
    } else {
      entry_size = AddDirentry(result_buf_pointer, remain_buf_len, name, &entry_param.attr, next_off);
    }

    if (!entry_size) {
      if (entry_ino) {
        UnrefInode((Inode*)entry_ino, 1);
      }
      MV_ERROR("FuseAddDirentry/FuseAddDirentryPlus error name=%s is_plus=%d errno=%d", name, is_plus, -errno);
      lookup_err = true;
      break;
    }

    MV_ASSERT(remain_buf_len > entry_size);
    remain_buf_len -= entry_size;
    result_buf_pointer += entry_size;
    dirp->entry = nullptr;
  }

  *result_buf_len = read_in->size - remain_buf_len;
  return !lookup_err;
}

DataBuffer Fuse::GetDataBufferFromIovec(std::deque<struct iovec>& iovec, size_t size) {
  // get request from guest
  MV_ASSERT(!iovec.empty());

  auto& front = iovec.front();
  MV_ASSERT(front.iov_len >= size);

  DataBuffer buffer = {
    .address = front.iov_base,
    .size = size == 0 ? front.iov_len : size
  };

  if(buffer.size == front.iov_len) {
    // run out of this iov
    iovec.pop_front();
  } else {
    front.iov_len -= buffer.size;
    front.iov_base = (uint8_t*)front.iov_base + buffer.size;
  }

  return buffer;
}
```

`devices/virtio/fuse/fuse.h`:

```h
/*
 * MVisor
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_FUSE_H
#define _MVISOR_FUSE_H

#include <dirent.h>

#include <cmath>
#include <cstddef>
#include <cstring>
#include <filesystem>
#include <thread>

#define FUSE_USE_VERSION 34

#include <dirent.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <deque>
#include <algorithm>
#include <climits>
#include <list>

#include "fuse_kernel.h"
#include "fuse_lowlevel.h"
#include "logger.h"

#define MAX_PATH 260
#define BLOCK_SIZE 4096

struct Inode {
  int fd;
  int refcount;
  ino_t ino;
  dev_t dev;
};

struct UserConfig {
  char* source;
  double timeout;
  struct Inode* root;
};

struct Directory {
  DIR* dp;
  struct dirent* entry;
  off_t offset;
};

struct DataBuffer {
  void* address;
  size_t   size;
};

struct DiskInfo {
  uint64_t size_used;
  uint64_t size_limit;
  uint64_t inode_count;
  uint64_t inode_limit;
};

class Fuse {
 private:
  struct UserConfig user_config_;
  std::list<Inode*> inode_list_;
  DiskInfo disk_info_;

  bool FilePathSafeCheck(int fd);

  Inode* CreateInodeFromFd(int fd, struct stat* stat, int refcount);

  void UpdateDiskInfo();

  size_t AddDirentry(char* buf, size_t buf_size, const char* name, const struct stat* stbuf, off_t off);
  size_t AddDirentryPlus(char* buf, size_t buf_size, const char* name, const struct fuse_entry_param* entry_param, off_t off);

  inline bool IsDotOrDotdot(const char* name) {
    return name[0] == '.' && (name[1] == '\0' || (name[1] == '.' && name[2] == '\0'));
  }

 public:
  Fuse(std::string& mount_path, uint64_t disk_size_limit, uint64_t inode_count_limit);
  virtual ~Fuse();

  int GetFdFromInode(fuse_ino_t ino);

  void ClearInodeList(bool clear_root);
  void UnrefInode(struct Inode* inode, uint64_t refcount);
  void CopyStatFs(const struct statvfs* stbuf, struct fuse_kstatfs* kstatfs);
  void ConvertStatToFuseAttr(const struct stat* stbuf, struct fuse_attr* attr);
  void ModifyDiskInformationToVm(struct statvfs* new_stat_vfs);

  bool Lookup(fuse_ino_t parent, const char* name, struct fuse_entry_param* entry_param);
  bool ReadDirectory(fuse_read_in* read_in, uint64_t nodeid, char* result_buf, uint32_t* result_buf_len, bool is_plus);
  
  Inode* GetInode(fuse_ino_t inode);
  Inode* GetInodeFromFd(int fd);
  Inode* GetInodeFromStat(struct stat* stat);

  DataBuffer GetDataBufferFromIovec(std::deque<struct iovec>& iovec, size_t size);

  inline struct UserConfig user_config() const { return user_config_; }

  inline bool IsDiskSpaceLeftEnough(uint64_t size) { return disk_info_.size_used + size <= disk_info_.size_limit; }

  inline bool IsInodeListFull() { return inode_list_.size() > disk_info_.inode_limit; }

  inline void CostDiskSpace(uint64_t size) { disk_info_.size_used += size; }

  inline void ReleaseDiskSpace(uint64_t size) { 
    if (disk_info_.size_used < size) {
      // the host can write in the mount path shared with vm
      UpdateDiskInfo();
    } else {
      disk_info_.size_used -= size;
    }
  }

  inline unsigned long CalcTimeoutSecond(double t) {
    if (t > (double)ULONG_MAX) {
      return ULONG_MAX;
    } else if (t < 0.0) {
      return 0;
    } else {
      return (unsigned long)t;
    }
  }

  inline unsigned int CalcTimeoutNsecond(double t) {
    double f = t - (double)CalcTimeoutSecond(t);
    if (f < 0.0) {
      return 0;
    } else if (f >= 0.999999999) {
      return 999999999;
    } else {
      return (unsigned int)(f * 1.0e9);
    }
  }

  inline void MakeResponse(fuse_out_header* response, uint32_t len, int32_t error, uint64_t unique) {
    MV_ASSERT(response != nullptr);
    response->error = error;
    response->unique = unique;
    response->len = sizeof(fuse_out_header) + len;
  }
};

#endif  // _MVISOR_FUSE_H

```

`devices/virtio/fuse/fuse_common.h`:

```h
/*  
  modify from libfuse3
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU LGPLv2.
  See the file COPYING.LIB.
*/

/** @file */

#ifndef FUSE_COMMON_H_
#define FUSE_COMMON_H_

#include <stdint.h>
#include <sys/types.h>

/** Major version of FUSE library interface */
#define FUSE_MAJOR_VERSION 3

/** Minor version of FUSE library interface */
#define FUSE_MINOR_VERSION 10

#define FUSE_MAKE_VERSION(maj, min) ((maj)*100 + (min))
#define FUSE_VERSION FUSE_MAKE_VERSION(FUSE_MAJOR_VERSION, FUSE_MINOR_VERSION)

/**
 * Information about an open file.
 *
 * File Handles are created by the open, opendir, and create methods and closed
 * by the release and releasedir methods.  Multiple file handles may be
 * concurrently open for the same file.  Generally, a client will create one
 * file handle per file descriptor, though in some cases multiple file
 * descriptors can share a single file handle.
 */
struct fuse_file_info {
  /** Open flags.	 Available in open() and release() */
  int flags;

  /** In case of a write operation indicates if this was caused
      by a delayed write from the page cache. If so, then the
      context's pid, uid, and gid fields will not be valid, and
      the *fh* value may not match the *fh* value that would
      have been sent with the corresponding individual write
      requests if write caching had been disabled. */
  unsigned int writepage : 1;

  /** Can be filled in by open, to use direct I/O on this file. */
  unsigned int direct_io : 1;

  /** Can be filled in by open. It signals the kernel that any
      currently cached file data (ie., data that the filesystem
      provided the last time the file was open) need not be
      invalidated. Has no effect when set in other contexts (in
      particular it does nothing when set by opendir()). */
  unsigned int keep_cache : 1;

  /** Indicates a flush operation.  Set in flush operation, also
      maybe set in highlevel lock operation and lowlevel release
      operation. */
  unsigned int flush : 1;

  /** Can be filled in by open, to indicate that the file is not
      seekable. */
  unsigned int nonseekable : 1;

  /* Indicates that flock locks for this file should be
     released.  If set, lock_owner shall contain a valid value.
     May only be set in ->release(). */
  unsigned int flock_release : 1;

  /** Can be filled in by opendir. It signals the kernel to
      enable caching of entries returned by readdir().  Has no
      effect when set in other contexts (in particular it does
      nothing when set by open()). */
  unsigned int cache_readdir : 1;

  /** Can be filled in by open, to indicate that flush is not needed
      on close. */
  unsigned int noflush : 1;

  /** Padding.  Reserved for future use*/
  unsigned int padding : 24;
  unsigned int padding2 : 32;

  /** File handle id.  May be filled in by filesystem in create,
   * open, and opendir().  Available in most other file operations on the
   * same file handle. */
  uint64_t fh;

  /** Lock owner id.  Available in locking operations and flush */
  uint64_t lock_owner;

  /** Requested poll events.  Available in ->poll.  Only set on kernels
      which support it.  If unsupported, this field is set to zero. */
  uint32_t poll_events;
};

/**
 * Configuration parameters passed to fuse_session_loop_mt() and
 * fuse_loop_mt().
 */
struct fuse_loop_config {
  /**
   * whether to use separate device fds for each thread
   * (may increase performance)
   */
  int clone_fd;

  /**
   * The maximum number of available worker threads before they
   * start to get deleted when they become idle. If not
   * specified, the default is 10.
   *
   * Adjusting this has performance implications; a very small number
   * of threads in the pool will cause a lot of thread creation and
   * deletion overhead and performance may suffer. When set to 0, a new
   * thread will be created to service every operation.
   */
  unsigned int max_idle_threads;
};

/**************************************************************************
 * Capability bits for 'fuse_conn_info.capable' and 'fuse_conn_info.want' *
 **************************************************************************/

/**
 * Indicates that the filesystem supports asynchronous read requests.
 *
 * If this capability is not requested/available, the kernel will
 * ensure that there is at most one pending read request per
 * file-handle at any time, and will attempt to order read requests by
 * increasing offset.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_ASYNC_READ (1 << 0)

/**
 * Indicates that the filesystem supports "remote" locking.
 *
 * This feature is enabled by default when supported by the kernel,
 * and if getlk() and setlk() handlers are implemented.
 */
#define FUSE_CAP_POSIX_LOCKS (1 << 1)

/**
 * Indicates that the filesystem supports the O_TRUNC open flag.  If
 * disabled, and an application specifies O_TRUNC, fuse first calls
 * truncate() and then open() with O_TRUNC filtered out.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_ATOMIC_O_TRUNC (1 << 3)

/**
 * Indicates that the filesystem supports lookups of "." and "..".
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_EXPORT_SUPPORT (1 << 4)

/**
 * Indicates that the kernel should not apply the umask to the
 * file mode on create operations.
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_DONT_MASK (1 << 6)

/**
 * Indicates that libfuse should try to use splice() when writing to
 * the fuse device. This may improve performance.
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_SPLICE_WRITE (1 << 7)

/**
 * Indicates that libfuse should try to move pages instead of copying when
 * writing to / reading from the fuse device. This may improve performance.
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_SPLICE_MOVE (1 << 8)

/**
 * Indicates that libfuse should try to use splice() when reading from
 * the fuse device. This may improve performance.
 *
 * This feature is enabled by default when supported by the kernel and
 * if the filesystem implements a write_buf() handler.
 */
#define FUSE_CAP_SPLICE_READ (1 << 9)

/**
 * If set, the calls to flock(2) will be emulated using POSIX locks and must
 * then be handled by the filesystem's setlock() handler.
 *
 * If not set, flock(2) calls will be handled by the FUSE kernel module
 * internally (so any access that does not go through the kernel cannot be taken
 * into account).
 *
 * This feature is enabled by default when supported by the kernel and
 * if the filesystem implements a flock() handler.
 */
#define FUSE_CAP_FLOCK_LOCKS (1 << 10)

/**
 * Indicates that the filesystem supports ioctl's on directories.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_IOCTL_DIR (1 << 11)

/**
 * Traditionally, while a file is open the FUSE kernel module only
 * asks the filesystem for an update of the file's attributes when a
 * client attempts to read beyond EOF. This is unsuitable for
 * e.g. network filesystems, where the file contents may change
 * without the kernel knowing about it.
 *
 * If this flag is set, FUSE will check the validity of the attributes
 * on every read. If the attributes are no longer valid (i.e., if the
 * *attr_timeout* passed to fuse_reply_attr() or set in `struct
 * fuse_entry_param` has passed), it will first issue a `getattr`
 * request. If the new mtime differs from the previous value, any
 * cached file *contents* will be invalidated as well.
 *
 * This flag should always be set when available. If all file changes
 * go through the kernel, *attr_timeout* should be set to a very large
 * number to avoid unnecessary getattr() calls.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_AUTO_INVAL_DATA (1 << 12)

/**
 * Indicates that the filesystem supports readdirplus.
 *
 * This feature is enabled by default when supported by the kernel and if the
 * filesystem implements a readdirplus() handler.
 */
#define FUSE_CAP_READDIRPLUS (1 << 13)

/**
 * Indicates that the filesystem supports adaptive readdirplus.
 *
 * If FUSE_CAP_READDIRPLUS is not set, this flag has no effect.
 *
 * If FUSE_CAP_READDIRPLUS is set and this flag is not set, the kernel
 * will always issue readdirplus() requests to retrieve directory
 * contents.
 *
 * If FUSE_CAP_READDIRPLUS is set and this flag is set, the kernel
 * will issue both readdir() and readdirplus() requests, depending on
 * how much information is expected to be required.
 *
 * As of Linux 4.20, the algorithm is as follows: when userspace
 * starts to read directory entries, issue a READDIRPLUS request to
 * the filesystem. If any entry attributes have been looked up by the
 * time userspace requests the next batch of entries continue with
 * READDIRPLUS, otherwise switch to plain READDIR.  This will reasult
 * in eg plain "ls" triggering READDIRPLUS first then READDIR after
 * that because it doesn't do lookups.  "ls -l" should result in all
 * READDIRPLUS, except if dentries are already cached.
 *
 * This feature is enabled by default when supported by the kernel and
 * if the filesystem implements both a readdirplus() and a readdir()
 * handler.
 */
#define FUSE_CAP_READDIRPLUS_AUTO (1 << 14)

/**
 * Indicates that the filesystem supports asynchronous direct I/O submission.
 *
 * If this capability is not requested/available, the kernel will ensure that
 * there is at most one pending read and one pending write request per direct
 * I/O file-handle at any time.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_ASYNC_DIO (1 << 15)

/**
 * Indicates that writeback caching should be enabled. This means that
 * individual write request may be buffered and merged in the kernel
 * before they are send to the filesystem.
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_WRITEBACK_CACHE (1 << 16)

/**
 * Indicates support for zero-message opens. If this flag is set in
 * the `capable` field of the `fuse_conn_info` structure, then the
 * filesystem may return `ENOSYS` from the open() handler to indicate
 * success. Further attempts to open files will be handled in the
 * kernel. (If this flag is not set, returning ENOSYS will be treated
 * as an error and signaled to the caller).
 *
 * Setting (or unsetting) this flag in the `want` field has *no
 * effect*.
 */
#define FUSE_CAP_NO_OPEN_SUPPORT (1 << 17)

/**
 * Indicates support for parallel directory operations. If this flag
 * is unset, the FUSE kernel module will ensure that lookup() and
 * readdir() requests are never issued concurrently for the same
 * directory.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_PARALLEL_DIROPS (1 << 18)

/**
 * Indicates support for POSIX ACLs.
 *
 * If this feature is enabled, the kernel will cache and have
 * responsibility for enforcing ACLs. ACL will be stored as xattrs and
 * passed to userspace, which is responsible for updating the ACLs in
 * the filesystem, keeping the file mode in sync with the ACL, and
 * ensuring inheritance of default ACLs when new filesystem nodes are
 * created. Note that this requires that the file system is able to
 * parse and interpret the xattr representation of ACLs.
 *
 * Enabling this feature implicitly turns on the
 * ``default_permissions`` mount option (even if it was not passed to
 * mount(2)).
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_POSIX_ACL (1 << 19)

/**
 * Indicates that the filesystem is responsible for unsetting
 * setuid and setgid bits when a file is written, truncated, or
 * its owner is changed.
 *
 * This feature is enabled by default when supported by the kernel.
 */
#define FUSE_CAP_HANDLE_KILLPRIV (1 << 20)

/**
 * Indicates that the kernel supports caching symlinks in its page cache.
 *
 * When this feature is enabled, symlink targets are saved in the page cache.
 * You can invalidate a cached link by calling:
 * `fuse_lowlevel_notify_inval_inode(se, ino, 0, 0);`
 *
 * This feature is disabled by default.
 * If the kernel supports it (>= 4.20), you can enable this feature by
 * setting this flag in the `want` field of the `fuse_conn_info` structure.
 */
#define FUSE_CAP_CACHE_SYMLINKS (1 << 23)

/**
 * Indicates support for zero-message opendirs. If this flag is set in
 * the `capable` field of the `fuse_conn_info` structure, then the filesystem
 * may return `ENOSYS` from the opendir() handler to indicate success. Further
 * opendir and releasedir messages will be handled in the kernel. (If this
 * flag is not set, returning ENOSYS will be treated as an error and signalled
 * to the caller.)
 *
 * Setting (or unsetting) this flag in the `want` field has *no effect*.
 */
#define FUSE_CAP_NO_OPENDIR_SUPPORT (1 << 24)

/**
 * Indicates support for invalidating cached pages only on explicit request.
 *
 * If this flag is set in the `capable` field of the `fuse_conn_info` structure,
 * then the FUSE kernel module supports invalidating cached pages only on
 * explicit request by the filesystem through fuse_lowlevel_notify_inval_inode()
 * or fuse_invalidate_path().
 *
 * By setting this flag in the `want` field of the `fuse_conn_info` structure,
 * the filesystem is responsible for invalidating cached pages through explicit
 * requests to the kernel.
 *
 * Note that setting this flag does not prevent the cached pages from being
 * flushed by OS itself and/or through user actions.
 *
 * Note that if both FUSE_CAP_EXPLICIT_INVAL_DATA and FUSE_CAP_AUTO_INVAL_DATA
 * are set in the `capable` field of the `fuse_conn_info` structure then
 * FUSE_CAP_AUTO_INVAL_DATA takes precedence.
 *
 * This feature is disabled by default.
 */
#define FUSE_CAP_EXPLICIT_INVAL_DATA (1 << 25)

/**
 * Ioctl flags
 *
 * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
 * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
 * FUSE_IOCTL_RETRY: retry with new iovecs
 * FUSE_IOCTL_DIR: is a directory
 *
 * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
 */
#define FUSE_IOCTL_COMPAT (1 << 0)
#define FUSE_IOCTL_UNRESTRICTED (1 << 1)
#define FUSE_IOCTL_RETRY (1 << 2)
#define FUSE_IOCTL_DIR (1 << 4)

#define FUSE_IOCTL_MAX_IOV 256

/**
 * Connection information, passed to the ->init() method
 *
 * Some of the elements are read-write, these can be changed to
 * indicate the value requested by the filesystem.  The requested
 * value must usually be smaller than the indicated value.
 */
struct fuse_conn_info {
  /**
   * Major version of the protocol (read-only)
   */
  unsigned proto_major;

  /**
   * Minor version of the protocol (read-only)
   */
  unsigned proto_minor;

  /**
   * Maximum size of the write buffer
   */
  unsigned max_write;

  /**
   * Maximum size of read requests. A value of zero indicates no
   * limit. However, even if the filesystem does not specify a
   * limit, the maximum size of read requests will still be
   * limited by the kernel.
   *
   * NOTE: For the time being, the maximum size of read requests
   * must be set both here *and* passed to fuse_session_new()
   * using the ``-o max_read=<n>`` mount option. At some point
   * in the future, specifying the mount option will no longer
   * be necessary.
   */
  unsigned max_read;

  /**
   * Maximum readahead
   */
  unsigned max_readahead;

  /**
   * Capability flags that the kernel supports (read-only)
   */
  unsigned capable;

  /**
   * Capability flags that the filesystem wants to enable.
   *
   * libfuse attempts to initialize this field with
   * reasonable default values before calling the init() handler.
   */
  unsigned want;

  /**
   * Maximum number of pending "background" requests. A
   * background request is any type of request for which the
   * total number is not limited by other means. As of kernel
   * 4.8, only two types of requests fall into this category:
   *
   *   1. Read-ahead requests
   *   2. Asynchronous direct I/O requests
   *
   * Read-ahead requests are generated (if max_readahead is
   * non-zero) by the kernel to preemptively fill its caches
   * when it anticipates that userspace will soon read more
   * data.
   *
   * Asynchronous direct I/O requests are generated if
   * FUSE_CAP_ASYNC_DIO is enabled and userspace submits a large
   * direct I/O request. In this case the kernel will internally
   * split it up into multiple smaller requests and submit them
   * to the filesystem concurrently.
   *
   * Note that the following requests are *not* background
   * requests: writeback requests (limited by the kernel's
   * flusher algorithm), regular (i.e., synchronous and
   * buffered) userspace read/write requests (limited to one per
   * thread), asynchronous read requests (Linux's io_submit(2)
   * call actually blocks, so these are also limited to one per
   * thread).
   */
  unsigned max_background;

  /**
   * Kernel congestion threshold parameter. If the number of pending
   * background requests exceeds this number, the FUSE kernel module will
   * mark the filesystem as "congested". This instructs the kernel to
   * expect that queued requests will take some time to complete, and to
   * adjust its algorithms accordingly (e.g. by putting a waiting thread
   * to sleep instead of using a busy-loop).
   */
  unsigned congestion_threshold;

  /**
   * When FUSE_CAP_WRITEBACK_CACHE is enabled, the kernel is responsible
   * for updating mtime and ctime when write requests are received. The
   * updated values are passed to the filesystem with setattr() requests.
   * However, if the filesystem does not support the full resolution of
   * the kernel timestamps (nanoseconds), the mtime and ctime values used
   * by kernel and filesystem will differ (and result in an apparent
   * change of times after a cache flush).
   *
   * To prevent this problem, this variable can be used to inform the
   * kernel about the timestamp granularity supported by the file-system.
   * The value should be power of 10.  The default is 1, i.e. full
   * nano-second resolution. Filesystems supporting only second resolution
   * should set this to 1000000000.
   */
  unsigned time_gran;

  /**
   * For future use.
   */
  unsigned reserved[22];
};

/* ----------------------------------------------------------- *
 * Data buffer						       *
 * ----------------------------------------------------------- */

/**
 * Buffer flags
 */
enum fuse_buf_flags {
  /**
   * Buffer contains a file descriptor
   *
   * If this flag is set, the .fd field is valid, otherwise the
   * .mem fields is valid.
   */
  FUSE_BUF_IS_FD = (1 << 1),

  /**
   * Seek on the file descriptor
   *
   * If this flag is set then the .pos field is valid and is
   * used to seek to the given offset before performing
   * operation on file descriptor.
   */
  FUSE_BUF_FD_SEEK = (1 << 2),

  /**
   * Retry operation on file descriptor
   *
   * If this flag is set then retry operation on file descriptor
   * until .size bytes have been copied or an error or EOF is
   * detected.
   */
  FUSE_BUF_FD_RETRY = (1 << 3)
};

/**
 * Buffer copy flags
 */
enum fuse_buf_copy_flags {
  /**
   * Don't use splice(2)
   *
   * Always fall back to using read and write instead of
   * splice(2) to copy data from one file descriptor to another.
   *
   * If this flag is not set, then only fall back if splice is
   * unavailable.
   */
  FUSE_BUF_NO_SPLICE = (1 << 1),

  /**
   * Force splice
   *
   * Always use splice(2) to copy data from one file descriptor
   * to another.  If splice is not available, return -EINVAL.
   */
  FUSE_BUF_FORCE_SPLICE = (1 << 2),

  /**
   * Try to move data with splice.
   *
   * If splice is used, try to move pages from the source to the
   * destination instead of copying.  See documentation of
   * SPLICE_F_MOVE in splice(2) man page.
   */
  FUSE_BUF_SPLICE_MOVE = (1 << 3),

  /**
   * Don't block on the pipe when copying data with splice
   *
   * Makes the operations on the pipe non-blocking (if the pipe
   * is full or empty).  See SPLICE_F_NONBLOCK in the splice(2)
   * man page.
   */
  FUSE_BUF_SPLICE_NONBLOCK = (1 << 4)
};

/**
 * Single data buffer
 *
 * Generic data buffer for I/O, extended attributes, etc...  Data may
 * be supplied as a memory pointer or as a file descriptor
 */
struct fuse_buf {
  /**
   * Size of data in bytes
   */
  size_t size;

  /**
   * Buffer flags
   */
  enum fuse_buf_flags flags;

  /**
   * Memory pointer
   *
   * Used unless FUSE_BUF_IS_FD flag is set.
   */
  void *mem;

  /**
   * File descriptor
   *
   * Used if FUSE_BUF_IS_FD flag is set.
   */
  int fd;

  /**
   * File position
   *
   * Used if FUSE_BUF_FD_SEEK flag is set.
   */
  off_t pos;
};

/**
 * Data buffer vector
 *
 * An array of data buffers, each containing a memory pointer or a
 * file descriptor.
 *
 * Allocate dynamically to add more than one buffer.
 */
struct fuse_bufvec {
  /**
   * Number of buffers in the array
   */
  size_t count;

  /**
   * Index of current buffer within the array
   */
  size_t idx;

  /**
   * Current offset within the current buffer
   */
  size_t off;

  /**
   * Array of buffers
   */
  struct fuse_buf buf[1];
};

/* Initialize bufvec with a single buffer of given size */
#define FUSE_BUFVEC_INIT(size__)                                                         \
  ((struct fuse_bufvec){/* .count= */ 1, /* .idx =  */ 0, /* .off =  */ 0, /* .buf =  */ \
                        {/* [0] = */ {                                                   \
                            /* .size =  */ (size__),                                     \
                            /* .flags = */ (enum fuse_buf_flags)0,                       \
                            /* .mem =   */ NULL,                                         \
                            /* .fd =    */ -1,                                           \
                            /* .pos =   */ 0,                                            \
                        }}})

#endif
```

`devices/virtio/fuse/fuse_kernel.h`:

```h
/* SPDX-License-Identifier: ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause) */
/*
    This file defines the kernel interface of FUSE
    Copyright (C) 2001-2008  Miklos Szeredi <miklos@szeredi.hu>

    This program can be distributed under the terms of the GNU GPL.
    See the file COPYING.

    This -- and only this -- header file may also be distributed under
    the terms of the BSD Licence as follows:

    Copyright (C) 2001-2007 Miklos Szeredi. All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:
    1. Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

    THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND
    ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
    ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
    FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
    DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
    OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
    HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
    OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
    SUCH DAMAGE.
*/

/*
 * This file defines the kernel interface of FUSE
 *
 * Protocol changelog:
 *
 * 7.1:
 *  - add the following messages:
 *      FUSE_SETATTR, FUSE_SYMLINK, FUSE_MKNOD, FUSE_MKDIR, FUSE_UNLINK,
 *      FUSE_RMDIR, FUSE_RENAME, FUSE_LINK, FUSE_OPEN, FUSE_READ, FUSE_WRITE,
 *      FUSE_RELEASE, FUSE_FSYNC, FUSE_FLUSH, FUSE_SETXATTR, FUSE_GETXATTR,
 *      FUSE_LISTXATTR, FUSE_REMOVEXATTR, FUSE_OPENDIR, FUSE_READDIR,
 *      FUSE_RELEASEDIR
 *  - add padding to messages to accommodate 32-bit servers on 64-bit kernels
 *
 * 7.2:
 *  - add FOPEN_DIRECT_IO and FOPEN_KEEP_CACHE flags
 *  - add FUSE_FSYNCDIR message
 *
 * 7.3:
 *  - add FUSE_ACCESS message
 *  - add FUSE_CREATE message
 *  - add filehandle to fuse_setattr_in
 *
 * 7.4:
 *  - add frsize to fuse_kstatfs
 *  - clean up request size limit checking
 *
 * 7.5:
 *  - add flags and max_write to fuse_init_out
 *
 * 7.6:
 *  - add max_readahead to fuse_init_in and fuse_init_out
 *
 * 7.7:
 *  - add FUSE_INTERRUPT message
 *  - add POSIX file lock support
 *
 * 7.8:
 *  - add lock_owner and flags fields to fuse_release_in
 *  - add FUSE_BMAP message
 *  - add FUSE_DESTROY message
 *
 * 7.9:
 *  - new fuse_getattr_in input argument of GETATTR
 *  - add lk_flags in fuse_lk_in
 *  - add lock_owner field to fuse_setattr_in, fuse_read_in and fuse_write_in
 *  - add blksize field to fuse_attr
 *  - add file flags field to fuse_read_in and fuse_write_in
 *  - Add ATIME_NOW and MTIME_NOW flags to fuse_setattr_in
 *
 * 7.10
 *  - add nonseekable open flag
 *
 * 7.11
 *  - add IOCTL message
 *  - add unsolicited notification support
 *  - add POLL message and NOTIFY_POLL notification
 *
 * 7.12
 *  - add umask flag to input argument of create, mknod and mkdir
 *  - add notification messages for invalidation of inodes and
 *    directory entries
 *
 * 7.13
 *  - make max number of background requests and congestion threshold
 *    tunables
 *
 * 7.14
 *  - add splice support to fuse device
 *
 * 7.15
 *  - add store notify
 *  - add retrieve notify
 *
 * 7.16
 *  - add BATCH_FORGET request
 *  - FUSE_IOCTL_UNRESTRICTED shall now return with array of 'struct
 *    fuse_ioctl_iovec' instead of ambiguous 'struct iovec'
 *  - add FUSE_IOCTL_32BIT flag
 *
 * 7.17
 *  - add FUSE_FLOCK_LOCKS and FUSE_RELEASE_FLOCK_UNLOCK
 *
 * 7.18
 *  - add FUSE_IOCTL_DIR flag
 *  - add FUSE_NOTIFY_DELETE
 *
 * 7.19
 *  - add FUSE_FALLOCATE
 *
 * 7.20
 *  - add FUSE_AUTO_INVAL_DATA
 *
 * 7.21
 *  - add FUSE_READDIRPLUS
 *  - send the requested events in POLL request
 *
 * 7.22
 *  - add FUSE_ASYNC_DIO
 *
 * 7.23
 *  - add FUSE_WRITEBACK_CACHE
 *  - add time_gran to fuse_init_out
 *  - add reserved space to fuse_init_out
 *  - add FATTR_CTIME
 *  - add ctime and ctimensec to fuse_setattr_in
 *  - add FUSE_RENAME2 request
 *  - add FUSE_NO_OPEN_SUPPORT flag
 *
 *  7.24
 *  - add FUSE_LSEEK for SEEK_HOLE and SEEK_DATA support
 *
 *  7.25
 *  - add FUSE_PARALLEL_DIROPS
 *
 *  7.26
 *  - add FUSE_HANDLE_KILLPRIV
 *  - add FUSE_POSIX_ACL
 *
 *  7.27
 *  - add FUSE_ABORT_ERROR
 *
 *  7.28
 *  - add FUSE_COPY_FILE_RANGE
 *  - add FOPEN_CACHE_DIR
 *  - add FUSE_MAX_PAGES, add max_pages to init_out
 *  - add FUSE_CACHE_SYMLINKS
 *
 *  7.29
 *  - add FUSE_NO_OPENDIR_SUPPORT flag
 *
 *  7.30
 *  - add FUSE_EXPLICIT_INVAL_DATA
 *  - add FUSE_IOCTL_COMPAT_X32
 *
 *  7.31
 *  - add FUSE_WRITE_KILL_PRIV flag
 *  - add FUSE_SETUPMAPPING and FUSE_REMOVEMAPPING
 *  - add map_alignment to fuse_init_out, add FUSE_MAP_ALIGNMENT flag
 */

#ifndef _LINUX_FUSE_H
#define _LINUX_FUSE_H

/*
 * Version negotiation:
 *
 * Both the kernel and userspace send the version they support in the
 * INIT request and reply respectively.
 *
 * If the major versions match then both shall use the smallest
 * of the two minor versions for communication.
 *
 * If the kernel supports a larger major version, then userspace shall
 * reply with the major version it supports, ignore the rest of the
 * INIT message and expect a new INIT message from the kernel with a
 * matching major version.
 *
 * If the library supports a larger major version, then it shall fall
 * back to the major protocol version sent by the kernel for
 * communication and reply with that major version (and an arbitrary
 * supported minor version).
 */

/** Version number of this interface */
#define FUSE_KERNEL_VERSION 7

/** Minor version number of this interface */
#define FUSE_KERNEL_MINOR_VERSION 31

/** The node ID of the root inode */
#define FUSE_ROOT_ID 1

/* Make sure all structures are padded to 64bit boundary, so 32bit
   userspace works under 64bit kernels */

struct fuse_attr {
    uint64_t    ino;
    uint64_t    size;
    uint64_t    blocks;
    uint64_t    atime;
    uint64_t    mtime;
    uint64_t    ctime;
    uint32_t    atimensec;
    uint32_t    mtimensec;
    uint32_t    ctimensec;
    uint32_t    mode;
    uint32_t    nlink;
    uint32_t    uid;
    uint32_t    gid;
    uint32_t    rdev;
    uint32_t    blksize;
    uint32_t    padding;
};

struct fuse_kstatfs {
    uint64_t    blocks;
    uint64_t    bfree;
    uint64_t    bavail;
    uint64_t    files;
    uint64_t    ffree;
    uint32_t    bsize;
    uint32_t    namelen;
    uint32_t    frsize;
    uint32_t    padding;
    uint32_t    spare[6];
};

struct fuse_file_lock {
    uint64_t    start;
    uint64_t    end;
    uint32_t    type;
    uint32_t    pid; /* tgid */
};

/**
 * Bitmasks for fuse_setattr_in.valid
 */
#define FATTR_MODE      (1 << 0)
#define FATTR_UID       (1 << 1)
#define FATTR_GID       (1 << 2)
#define FATTR_SIZE      (1 << 3)
#define FATTR_ATIME     (1 << 4)
#define FATTR_MTIME     (1 << 5)
#define FATTR_FH        (1 << 6)
#define FATTR_ATIME_NOW (1 << 7)
#define FATTR_MTIME_NOW (1 << 8)
#define FATTR_LOCKOWNER (1 << 9)
#define FATTR_CTIME     (1 << 10)

/**
 * Flags returned by the OPEN request
 *
 * FOPEN_DIRECT_IO: bypass page cache for this open file
 * FOPEN_KEEP_CACHE: don't invalidate the data cache on open
 * FOPEN_NONSEEKABLE: the file is not seekable
 * FOPEN_CACHE_DIR: allow caching this directory
 * FOPEN_STREAM: the file is stream-like (no file position at all)
 */
#define FOPEN_DIRECT_IO     (1 << 0)
#define FOPEN_KEEP_CACHE    (1 << 1)
#define FOPEN_NONSEEKABLE   (1 << 2)
#define FOPEN_CACHE_DIR     (1 << 3)
#define FOPEN_STREAM        (1 << 4)

/**
 * INIT request/reply flags
 *
 * FUSE_ASYNC_READ: asynchronous read requests
 * FUSE_POSIX_LOCKS: remote locking for POSIX file locks
 * FUSE_FILE_OPS: kernel sends file handle for fstat, etc... (not yet supported)
 * FUSE_ATOMIC_O_TRUNC: handles the O_TRUNC open flag in the filesystem
 * FUSE_EXPORT_SUPPORT: filesystem handles lookups of "." and ".."
 * FUSE_BIG_WRITES: filesystem can handle write size larger than 4kB
 * FUSE_DONT_MASK: don't apply umask to file mode on create operations
 * FUSE_SPLICE_WRITE: kernel supports splice write on the device
 * FUSE_SPLICE_MOVE: kernel supports splice move on the device
 * FUSE_SPLICE_READ: kernel supports splice read on the device
 * FUSE_FLOCK_LOCKS: remote locking for BSD style file locks
 * FUSE_HAS_IOCTL_DIR: kernel supports ioctl on directories
 * FUSE_AUTO_INVAL_DATA: automatically invalidate cached pages
 * FUSE_DO_READDIRPLUS: do READDIRPLUS (READDIR+LOOKUP in one)
 * FUSE_READDIRPLUS_AUTO: adaptive readdirplus
 * FUSE_ASYNC_DIO: asynchronous direct I/O submission
 * FUSE_WRITEBACK_CACHE: use writeback cache for buffered writes
 * FUSE_NO_OPEN_SUPPORT: kernel supports zero-message opens
 * FUSE_PARALLEL_DIROPS: allow parallel lookups and readdir
 * FUSE_HANDLE_KILLPRIV: fs handles killing suid/sgid/cap on write/chown/trunc
 * FUSE_POSIX_ACL: filesystem supports posix acls
 * FUSE_ABORT_ERROR: reading the device after abort returns ECONNABORTED
 * FUSE_MAX_PAGES: init_out.max_pages contains the max number of req pages
 * FUSE_CACHE_SYMLINKS: cache READLINK responses
 * FUSE_NO_OPENDIR_SUPPORT: kernel supports zero-message opendir
 * FUSE_EXPLICIT_INVAL_DATA: only invalidate cached pages on explicit request
 * FUSE_MAP_ALIGNMENT: map_alignment field is valid
 */
#define FUSE_ASYNC_READ          (1 << 0)
#define FUSE_POSIX_LOCKS         (1 << 1)
#define FUSE_FILE_OPS            (1 << 2)
#define FUSE_ATOMIC_O_TRUNC      (1 << 3)
#define FUSE_EXPORT_SUPPORT      (1 << 4)
#define FUSE_BIG_WRITES          (1 << 5)
#define FUSE_DONT_MASK           (1 << 6)
#define FUSE_SPLICE_WRITE        (1 << 7)
#define FUSE_SPLICE_MOVE         (1 << 8)
#define FUSE_SPLICE_READ         (1 << 9)
#define FUSE_FLOCK_LOCKS         (1 << 10)
#define FUSE_HAS_IOCTL_DIR       (1 << 11)
#define FUSE_AUTO_INVAL_DATA     (1 << 12)
#define FUSE_DO_READDIRPLUS      (1 << 13)
#define FUSE_READDIRPLUS_AUTO    (1 << 14)
#define FUSE_ASYNC_DIO           (1 << 15)
#define FUSE_WRITEBACK_CACHE     (1 << 16)
#define FUSE_NO_OPEN_SUPPORT     (1 << 17)
#define FUSE_PARALLEL_DIROPS     (1 << 18)
#define FUSE_HANDLE_KILLPRIV     (1 << 19)
#define FUSE_POSIX_ACL           (1 << 20)
#define FUSE_ABORT_ERROR         (1 << 21)
#define FUSE_MAX_PAGES           (1 << 22)
#define FUSE_CACHE_SYMLINKS      (1 << 23)
#define FUSE_NO_OPENDIR_SUPPORT  (1 << 24)
#define FUSE_EXPLICIT_INVAL_DATA (1 << 25)
#define FUSE_MAP_ALIGNMENT       (1 << 26)

/**
 * CUSE INIT request/reply flags
 *
 * CUSE_UNRESTRICTED_IOCTL:  use unrestricted ioctl
 */
#define CUSE_UNRESTRICTED_IOCTL (1 << 0)

/**
 * Release flags
 */
#define FUSE_RELEASE_FLUSH          (1 << 0)
#define FUSE_RELEASE_FLOCK_UNLOCK   (1 << 1)

/**
 * Getattr flags
 */
#define FUSE_GETATTR_FH (1 << 0)

/**
 * Lock flags
 */
#define FUSE_LK_FLOCK   (1 << 0)

/**
 * WRITE flags
 *
 * FUSE_WRITE_CACHE: delayed write from page cache, file handle is guessed
 * FUSE_WRITE_LOCKOWNER: lock_owner field is valid
 * FUSE_WRITE_KILL_PRIV: kill suid and sgid bits
 */
#define FUSE_WRITE_CACHE        (1 << 0)
#define FUSE_WRITE_LOCKOWNER    (1 << 1)
#define FUSE_WRITE_KILL_PRIV    (1 << 2)

/**
 * Read flags
 */
#define FUSE_READ_LOCKOWNER     (1 << 1)

/**
 * Ioctl flags
 *
 * FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine
 * FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed
 * FUSE_IOCTL_RETRY: retry with new iovecs
 * FUSE_IOCTL_32BIT: 32bit ioctl
 * FUSE_IOCTL_DIR: is a directory
 * FUSE_IOCTL_COMPAT_X32: x32 compat ioctl on 64bit machine (64bit time_t)
 *
 * FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs
 */
#define FUSE_IOCTL_COMPAT       (1 << 0)
#define FUSE_IOCTL_UNRESTRICTED (1 << 1)
#define FUSE_IOCTL_RETRY        (1 << 2)
#define FUSE_IOCTL_32BIT        (1 << 3)
#define FUSE_IOCTL_DIR          (1 << 4)
#define FUSE_IOCTL_COMPAT_X32   (1 << 5)

#define FUSE_IOCTL_MAX_IOV      256

/**
 * Poll flags
 *
 * FUSE_POLL_SCHEDULE_NOTIFY: request poll notify
 */
#define FUSE_POLL_SCHEDULE_NOTIFY (1 << 0)

/**
 * Fsync flags
 *
 * FUSE_FSYNC_FDATASYNC: Sync data only, not metadata
 */
#define FUSE_FSYNC_FDATASYNC    (1 << 0)

enum fuse_opcode {
    FUSE_LOOKUP             = 1,
    FUSE_FORGET             = 2,  /* no reply */
    FUSE_GETATTR            = 3,
    FUSE_SETATTR            = 4,
    FUSE_READLINK           = 5,
    FUSE_SYMLINK            = 6,
    FUSE_MKNOD              = 8,
    FUSE_MKDIR              = 9,
    FUSE_UNLINK             = 10,
    FUSE_RMDIR              = 11,
    FUSE_RENAME             = 12,
    FUSE_LINK               = 13,
    FUSE_OPEN               = 14,
    FUSE_READ               = 15,
    FUSE_WRITE              = 16,
    FUSE_STATFS             = 17,
    FUSE_RELEASE            = 18,
    FUSE_FSYNC              = 20,
    FUSE_SETXATTR           = 21,
    FUSE_GETXATTR           = 22,
    FUSE_LISTXATTR          = 23,
    FUSE_REMOVEXATTR        = 24,
    FUSE_FLUSH              = 25,
    FUSE_INIT               = 26,
    FUSE_OPENDIR            = 27,
    FUSE_READDIR            = 28,
    FUSE_RELEASEDIR         = 29,
    FUSE_FSYNCDIR           = 30,
    FUSE_GETLK              = 31,
    FUSE_SETLK              = 32,
    FUSE_SETLKW             = 33,
    FUSE_ACCESS             = 34,
    FUSE_CREATE             = 35,
    FUSE_INTERRUPT          = 36,
    FUSE_BMAP               = 37,
    FUSE_DESTROY            = 38,
    FUSE_IOCTL              = 39,
    FUSE_POLL               = 40,
    FUSE_NOTIFY_REPLY       = 41,
    FUSE_BATCH_FORGET       = 42,
    FUSE_FALLOCATE          = 43,
    FUSE_READDIRPLUS        = 44,
    FUSE_RENAME2            = 45,
    FUSE_LSEEK              = 46,
    FUSE_COPY_FILE_RANGE    = 47,
    FUSE_SETUPMAPPING       = 48,
    FUSE_REMOVEMAPPING      = 49,

    /* CUSE specific operations */
    CUSE_INIT               = 4096,

    /* Reserved opcodes: helpful to detect structure endian-ness */
    CUSE_INIT_BSWAP_RESERVED    = 1048576,      /* CUSE_INIT << 8 */
    FUSE_INIT_BSWAP_RESERVED    = 436207616,    /* FUSE_INIT << 24 */
};

enum fuse_notify_code {
    FUSE_NOTIFY_POLL = 1,
    FUSE_NOTIFY_INVAL_INODE = 2,
    FUSE_NOTIFY_INVAL_ENTRY = 3,
    FUSE_NOTIFY_STORE = 4,
    FUSE_NOTIFY_RETRIEVE = 5,
    FUSE_NOTIFY_DELETE = 6,
    FUSE_NOTIFY_CODE_MAX,
};

/* The read buffer is required to be at least 8k, but may be much larger */
#define FUSE_MIN_READ_BUFFER 8192

#define FUSE_COMPAT_ENTRY_OUT_SIZE 120

struct fuse_entry_out {
    uint64_t    nodeid;         /* Inode ID */
    uint64_t    generation;     /* Inode generation: nodeid:gen must
                                   be unique for the fs's lifetime */
    uint64_t    entry_valid;    /* Cache timeout for the name */
    uint64_t    attr_valid;     /* Cache timeout for the attributes */
    uint32_t    entry_valid_nsec;
    uint32_t    attr_valid_nsec;
    struct fuse_attr attr;
};

struct fuse_forget_in {
    uint64_t    nlookup;
};

struct fuse_forget_one {
    uint64_t    nodeid;
    uint64_t    nlookup;
};

struct fuse_batch_forget_in {
    uint32_t    count;
    uint32_t    dummy;
};

struct fuse_getattr_in {
    uint32_t    getattr_flags;
    uint32_t    dummy;
    uint64_t    fh;
};

#define FUSE_COMPAT_ATTR_OUT_SIZE 96

struct fuse_attr_out {
    uint64_t    attr_valid;    /* Cache timeout for the attributes */
    uint32_t    attr_valid_nsec;
    uint32_t    dummy;
    struct fuse_attr attr;
};

#define FUSE_COMPAT_MKNOD_IN_SIZE 8

struct fuse_mknod_in {
    uint32_t    mode;
    uint32_t    rdev;
    uint32_t    umask;
    uint32_t    padding;
};

struct fuse_mkdir_in {
    uint32_t    mode;
    uint32_t    umask;
};

struct fuse_rename_in {
    uint64_t    newdir;
};

struct fuse_rename2_in {
    uint64_t    newdir;
    uint32_t    flags;
    uint32_t    padding;
};

struct fuse_link_in {
    uint64_t    oldnodeid;
};

struct fuse_setattr_in {
    uint32_t    valid;
    uint32_t    padding;
    uint64_t    fh;
    uint64_t    size;
    uint64_t    lock_owner;
    uint64_t    atime;
    uint64_t    mtime;
    uint64_t    ctime;
    uint32_t    atimensec;
    uint32_t    mtimensec;
    uint32_t    ctimensec;
    uint32_t    mode;
    uint32_t    unused4;
    uint32_t    uid;
    uint32_t    gid;
    uint32_t    unused5;
};

struct fuse_open_in {
    uint32_t    flags;
    uint32_t    unused;
};

struct fuse_create_in {
    uint32_t    flags;
    uint32_t    mode;
    uint32_t    umask;
    uint32_t    padding;
};

struct fuse_open_out {
    uint64_t    fh;
    uint32_t    open_flags;
    uint32_t    padding;
};

struct fuse_release_in {
    uint64_t    fh;
    uint32_t    flags;
    uint32_t    release_flags;
    uint64_t    lock_owner;
};

struct fuse_flush_in {
    uint64_t    fh;
    uint32_t    unused;
    uint32_t    padding;
    uint64_t    lock_owner;
};

struct fuse_read_in {
    uint64_t    fh;
    uint64_t    offset;
    uint32_t    size;
    uint32_t    read_flags;
    uint64_t    lock_owner;
    uint32_t    flags;
    uint32_t    padding;
};

#define FUSE_COMPAT_WRITE_IN_SIZE 24

struct fuse_write_in {
    uint64_t    fh;
    uint64_t    offset;
    uint32_t    size;
    uint32_t    write_flags;
    uint64_t    lock_owner;
    uint32_t    flags;
    uint32_t    padding;
};

struct fuse_write_out {
    uint32_t    size;
    uint32_t    padding;
};

#define FUSE_COMPAT_STATFS_SIZE 48

struct fuse_statfs_out {
    struct fuse_kstatfs st;
};

struct fuse_fsync_in {
    uint64_t    fh;
    uint32_t    fsync_flags;
    uint32_t    padding;
};

struct fuse_setxattr_in {
    uint32_t    size;
    uint32_t    flags;
};

struct fuse_getxattr_in {
    uint32_t    size;
    uint32_t    padding;
};

struct fuse_getxattr_out {
    uint32_t    size;
    uint32_t    padding;
};

struct fuse_lk_in {
    uint64_t    fh;
    uint64_t    owner;
    struct fuse_file_lock lk;
    uint32_t    lk_flags;
    uint32_t    padding;
};

struct fuse_lk_out {
    struct fuse_file_lock lk;
};

struct fuse_access_in {
    uint32_t    mask;
    uint32_t    padding;
};

struct fuse_init_in {
    uint32_t    major;
    uint32_t    minor;
    uint32_t    max_readahead;
    uint32_t    flags;
};

#define FUSE_COMPAT_INIT_OUT_SIZE 8
#define FUSE_COMPAT_22_INIT_OUT_SIZE 24

struct fuse_init_out {
    uint32_t    major;
    uint32_t    minor;
    uint32_t    max_readahead;
    uint32_t    flags;
    uint16_t    max_background;
    uint16_t    congestion_threshold;
    uint32_t    max_write;
    uint32_t    time_gran;
    uint16_t    max_pages;
    uint16_t    map_alignment;
    uint32_t    unused[8];
};

#define CUSE_INIT_INFO_MAX 4096

struct cuse_init_in {
    uint32_t    major;
    uint32_t    minor;
    uint32_t    unused;
    uint32_t    flags;
};

struct cuse_init_out {
    uint32_t    major;
    uint32_t    minor;
    uint32_t    unused;
    uint32_t    flags;
    uint32_t    max_read;
    uint32_t    max_write;
    uint32_t    dev_major;        /* chardev major */
    uint32_t    dev_minor;        /* chardev minor */
    uint32_t    spare[10];
};

struct fuse_interrupt_in {
    uint64_t    unique;
};

struct fuse_bmap_in {
    uint64_t    block;
    uint32_t    blocksize;
    uint32_t    padding;
};

struct fuse_bmap_out {
    uint64_t    block;
};

struct fuse_ioctl_in {
    uint64_t    fh;
    uint32_t    flags;
    uint32_t    cmd;
    uint64_t    arg;
    uint32_t    in_size;
    uint32_t    out_size;
};

struct fuse_ioctl_iovec {
    uint64_t    base;
    uint64_t    len;
};

struct fuse_ioctl_out {
    int32_t        result;
    uint32_t    flags;
    uint32_t    in_iovs;
    uint32_t    out_iovs;
};

struct fuse_poll_in {
    uint64_t    fh;
    uint64_t    kh;
    uint32_t    flags;
    uint32_t    events;
};

struct fuse_poll_out {
    uint32_t    revents;
    uint32_t    padding;
};

struct fuse_notify_poll_wakeup_out {
    uint64_t    kh;
};

struct fuse_fallocate_in {
    uint64_t    fh;
    uint64_t    offset;
    uint64_t    length;
    uint32_t    mode;
    uint32_t    padding;
};

struct fuse_in_header {
    uint32_t    len;
    uint32_t    opcode;
    uint64_t    unique;
    uint64_t    nodeid;
    uint32_t    uid;
    uint32_t    gid;
    uint32_t    pid;
    uint32_t    padding;
};

struct fuse_out_header {
    uint32_t    len;
    int32_t     error;
    uint64_t    unique;
};

struct fuse_dirent {
    uint64_t    ino;
    uint64_t    off;
    uint32_t    namelen;
    uint32_t    type;
    char        name[];
};

#define FUSE_NAME_OFFSET offsetof(struct fuse_dirent, name)
#define FUSE_DIRENT_ALIGN(x) \
    (((x) + sizeof(uint64_t) - 1) & ~(sizeof(uint64_t) - 1))
#define FUSE_DIRENT_SIZE(d) \
    FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET + (d)->namelen)

struct fuse_direntplus {
    struct fuse_entry_out entry_out;
    struct fuse_dirent dirent;
};

#define FUSE_NAME_OFFSET_DIRENTPLUS \
    offsetof(struct fuse_direntplus, dirent.name)
#define FUSE_DIRENTPLUS_SIZE(d) \
    FUSE_DIRENT_ALIGN(FUSE_NAME_OFFSET_DIRENTPLUS + (d)->dirent.namelen)

struct fuse_notify_inval_inode_out {
    uint64_t    ino;
    int64_t     off;
    int64_t     len;
};

struct fuse_notify_inval_entry_out {
    uint64_t    parent;
    uint32_t    namelen;
    uint32_t    padding;
};

struct fuse_notify_delete_out {
    uint64_t    parent;
    uint64_t    child;
    uint32_t    namelen;
    uint32_t    padding;
};

struct fuse_notify_store_out {
    uint64_t    nodeid;
    uint64_t    offset;
    uint32_t    size;
    uint32_t    padding;
};

struct fuse_notify_retrieve_out {
    uint64_t    notify_unique;
    uint64_t    nodeid;
    uint64_t    offset;
    uint32_t    size;
    uint32_t    padding;
};

/* Matches the size of fuse_write_in */
struct fuse_notify_retrieve_in {
    uint64_t    dummy1;
    uint64_t    offset;
    uint32_t    size;
    uint32_t    dummy2;
    uint64_t    dummy3;
    uint64_t    dummy4;
};

/* Device ioctls: */
#define FUSE_DEV_IOC_CLONE    _IOR(229, 0, uint32_t)

struct fuse_lseek_in {
    uint64_t    fh;
    uint64_t    offset;
    uint32_t    whence;
    uint32_t    padding;
};

struct fuse_lseek_out {
    uint64_t    offset;
};

struct fuse_copy_file_range_in {
    uint64_t    fh_in;
    uint64_t    off_in;
    uint64_t    nodeid_out;
    uint64_t    fh_out;
    uint64_t    off_out;
    uint64_t    len;
    uint64_t    flags;
};

#endif /* _LINUX_FUSE_H */

```

`devices/virtio/fuse/fuse_lowlevel.h`:

```h
/*
  FUSE: Filesystem in Userspace
  Copyright (C) 2001-2007  Miklos Szeredi <miklos@szeredi.hu>

  This program can be distributed under the terms of the GNU LGPLv2.
  See the file COPYING.LIB.
*/

#ifndef FUSE_LOWLEVEL_H_
#define FUSE_LOWLEVEL_H_

/** @file
 *
 * Low level API
 *
 * IMPORTANT: you should define FUSE_USE_VERSION before including this
 * header.  To use the newest API define it to 35 (recommended for any
 * new application).
 */

#ifndef FUSE_USE_VERSION
#error FUSE_USE_VERSION not defined
#endif

#include "fuse_common.h"

#include <utime.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/statvfs.h>
#include <sys/uio.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ----------------------------------------------------------- *
 * Miscellaneous definitions				       *
 * ----------------------------------------------------------- */

/** The node ID of the root inode */
#define FUSE_ROOT_ID 1

/** Inode number type */
typedef uint64_t fuse_ino_t;

/** Request pointer type */
typedef struct fuse_req *fuse_req_t;

/**
 * Session
 *
 * This provides hooks for processing requests, and exiting
 */
struct fuse_session;

/** Directory entry parameters supplied to fuse_reply_entry() */
struct fuse_entry_param {
	/** Unique inode number
	 *
	 * In lookup, zero means negative entry (from version 2.5)
	 * Returning ENOENT also means negative entry, but by setting zero
	 * ino the kernel may cache negative entries for entry_timeout
	 * seconds.
	 */
	fuse_ino_t ino;

	/** Generation number for this entry.
	 *
	 * If the file system will be exported over NFS, the
	 * ino/generation pairs need to be unique over the file
	 * system's lifetime (rather than just the mount time). So if
	 * the file system reuses an inode after it has been deleted,
	 * it must assign a new, previously unused generation number
	 * to the inode at the same time.
	 *
	 */
	uint64_t generation;

	/** Inode attributes.
	 *
	 * Even if attr_timeout == 0, attr must be correct. For example,
	 * for open(), FUSE uses attr.st_size from lookup() to determine
	 * how many bytes to request. If this value is not correct,
	 * incorrect data will be returned.
	 */
	struct stat attr;

	/** Validity timeout (in seconds) for inode attributes. If
	    attributes only change as a result of requests that come
	    through the kernel, this should be set to a very large
	    value. */
	double attr_timeout;

	/** Validity timeout (in seconds) for the name. If directory
	    entries are changed/deleted only as a result of requests
	    that come through the kernel, this should be set to a very
	    large value. */
	double entry_timeout;
};

/**
 * Additional context associated with requests.
 *
 * Note that the reported client uid, gid and pid may be zero in some
 * situations. For example, if the FUSE file system is running in a
 * PID or user namespace but then accessed from outside the namespace,
 * there is no valid uid/pid/gid that could be reported.
 */
struct fuse_ctx {
	/** User ID of the calling process */
	uid_t uid;

	/** Group ID of the calling process */
	gid_t gid;

	/** Thread ID of the calling process */
	pid_t pid;

	/** Umask of the calling process */
	mode_t umask;
};

struct fuse_forget_data {
	fuse_ino_t ino;
	uint64_t nlookup;
};

/* 'to_set' flags in setattr */
#define FUSE_SET_ATTR_MODE	(1 << 0)
#define FUSE_SET_ATTR_UID	(1 << 1)
#define FUSE_SET_ATTR_GID	(1 << 2)
#define FUSE_SET_ATTR_SIZE	(1 << 3)
#define FUSE_SET_ATTR_ATIME	(1 << 4)
#define FUSE_SET_ATTR_MTIME	(1 << 5)
#define FUSE_SET_ATTR_ATIME_NOW	(1 << 7)
#define FUSE_SET_ATTR_MTIME_NOW	(1 << 8)
#define FUSE_SET_ATTR_CTIME	(1 << 10)

/* ----------------------------------------------------------- *
 * Request methods and replies				       *
 * ----------------------------------------------------------- */

/**
 * Low level filesystem operations
 *
 * Most of the methods (with the exception of init and destroy)
 * receive a request handle (fuse_req_t) as their first argument.
 * This handle must be passed to one of the specified reply functions.
 *
 * This may be done inside the method invocation, or after the call
 * has returned.  The request handle is valid until one of the reply
 * functions is called.
 *
 * Other pointer arguments (name, fuse_file_info, etc) are not valid
 * after the call has returned, so if they are needed later, their
 * contents have to be copied.
 *
 * In general, all methods are expected to perform any necessary
 * permission checking. However, a filesystem may delegate this task
 * to the kernel by passing the `default_permissions` mount option to
 * `fuse_session_new()`. In this case, methods will only be called if
 * the kernel's permission check has succeeded.
 *
 * The filesystem sometimes needs to handle a return value of -ENOENT
 * from the reply function, which means, that the request was
 * interrupted, and the reply discarded.  For example if
 * fuse_reply_open() return -ENOENT means, that the release method for
 * this file will not be called.
 */
struct fuse_lowlevel_ops {
	/**
	 * Initialize filesystem
	 *
	 * This function is called when libfuse establishes
	 * communication with the FUSE kernel module. The file system
	 * should use this module to inspect and/or modify the
	 * connection parameters provided in the `conn` structure.
	 *
	 * Note that some parameters may be overwritten by options
	 * passed to fuse_session_new() which take precedence over the
	 * values set in this handler.
	 *
	 * There's no reply to this function
	 *
	 * @param userdata the user data passed to fuse_session_new()
	 */
	void (*init) (void *userdata, struct fuse_conn_info *conn);

	/**
	 * Clean up filesystem.
	 *
	 * Called on filesystem exit. When this method is called, the
	 * connection to the kernel may be gone already, so that eg. calls
	 * to fuse_lowlevel_notify_* will fail.
	 *
	 * There's no reply to this function
	 *
	 * @param userdata the user data passed to fuse_session_new()
	 */
	void (*destroy) (void *userdata);

	/**
	 * Look up a directory entry by name and get its attributes.
	 *
	 * Valid replies:
	 *   fuse_reply_entry
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name the name to look up
	 */
	void (*lookup) (fuse_req_t req, fuse_ino_t parent, const char *name);

	/**
	 * Forget about an inode
	 *
	 * This function is called when the kernel removes an inode
	 * from its internal caches.
	 *
	 * The inode's lookup count increases by one for every call to
	 * fuse_reply_entry and fuse_reply_create. The nlookup parameter
	 * indicates by how much the lookup count should be decreased.
	 *
	 * Inodes with a non-zero lookup count may receive request from
	 * the kernel even after calls to unlink, rmdir or (when
	 * overwriting an existing file) rename. Filesystems must handle
	 * such requests properly and it is recommended to defer removal
	 * of the inode until the lookup count reaches zero. Calls to
	 * unlink, rmdir or rename will be followed closely by forget
	 * unless the file or directory is open, in which case the
	 * kernel issues forget only after the release or releasedir
	 * calls.
	 *
	 * Note that if a file system will be exported over NFS the
	 * inodes lifetime must extend even beyond forget. See the
	 * generation field in struct fuse_entry_param above.
	 *
	 * On unmount the lookup count for all inodes implicitly drops
	 * to zero. It is not guaranteed that the file system will
	 * receive corresponding forget messages for the affected
	 * inodes.
	 *
	 * Valid replies:
	 *   fuse_reply_none
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param nlookup the number of lookups to forget
	 */
	void (*forget) (fuse_req_t req, fuse_ino_t ino, uint64_t nlookup);

	/**
	 * Get file attributes.
	 *
	 * If writeback caching is enabled, the kernel may have a
	 * better idea of a file's length than the FUSE file system
	 * (eg if there has been a write that extended the file size,
	 * but that has not yet been passed to the filesystem.n
	 *
	 * In this case, the st_size value provided by the file system
	 * will be ignored.
	 *
	 * Valid replies:
	 *   fuse_reply_attr
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi for future use, currently always NULL
	 */
	void (*getattr) (fuse_req_t req, fuse_ino_t ino,
			 struct fuse_file_info *fi);

	/**
	 * Set file attributes
	 *
	 * In the 'attr' argument only members indicated by the 'to_set'
	 * bitmask contain valid values.  Other members contain undefined
	 * values.
	 *
	 * Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
	 * expected to reset the setuid and setgid bits if the file
	 * size or owner is being changed.
	 *
	 * If the setattr was invoked from the ftruncate() system call
	 * under Linux kernel versions 2.6.15 or later, the fi->fh will
	 * contain the value set by the open method or will be undefined
	 * if the open method didn't set any value.  Otherwise (not
	 * ftruncate call, or kernel version earlier than 2.6.15) the fi
	 * parameter will be NULL.
	 *
	 * Valid replies:
	 *   fuse_reply_attr
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param attr the attributes
	 * @param to_set bit mask of attributes which should be set
	 * @param fi file information, or NULL
	 */
	void (*setattr) (fuse_req_t req, fuse_ino_t ino, struct stat *attr,
			 int to_set, struct fuse_file_info *fi);

	/**
	 * Read symbolic link
	 *
	 * Valid replies:
	 *   fuse_reply_readlink
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 */
	void (*readlink) (fuse_req_t req, fuse_ino_t ino);

	/**
	 * Create file node
	 *
	 * Create a regular file, character device, block device, fifo or
	 * socket node.
	 *
	 * Valid replies:
	 *   fuse_reply_entry
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name to create
	 * @param mode file type and mode with which to create the new file
	 * @param rdev the device number (only valid if created file is a device)
	 */
	void (*mknod) (fuse_req_t req, fuse_ino_t parent, const char *name,
		       mode_t mode, dev_t rdev);

	/**
	 * Create a directory
	 *
	 * Valid replies:
	 *   fuse_reply_entry
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name to create
	 * @param mode with which to create the new file
	 */
	void (*mkdir) (fuse_req_t req, fuse_ino_t parent, const char *name,
		       mode_t mode);

	/**
	 * Remove a file
	 *
	 * If the file's inode's lookup count is non-zero, the file
	 * system is expected to postpone any removal of the inode
	 * until the lookup count reaches zero (see description of the
	 * forget function).
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name to remove
	 */
	void (*unlink) (fuse_req_t req, fuse_ino_t parent, const char *name);

	/**
	 * Remove a directory
	 *
	 * If the directory's inode's lookup count is non-zero, the
	 * file system is expected to postpone any removal of the
	 * inode until the lookup count reaches zero (see description
	 * of the forget function).
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name to remove
	 */
	void (*rmdir) (fuse_req_t req, fuse_ino_t parent, const char *name);

	/**
	 * Create a symbolic link
	 *
	 * Valid replies:
	 *   fuse_reply_entry
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param link the contents of the symbolic link
	 * @param parent inode number of the parent directory
	 * @param name to create
	 */
	void (*symlink) (fuse_req_t req, const char *link, fuse_ino_t parent,
			 const char *name);

	/** Rename a file
	 *
	 * If the target exists it should be atomically replaced. If
	 * the target's inode's lookup count is non-zero, the file
	 * system is expected to postpone any removal of the inode
	 * until the lookup count reaches zero (see description of the
	 * forget function).
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EINVAL, i.e. all
	 * future bmap requests will fail with EINVAL without being
	 * send to the filesystem process.
	 *
	 * *flags* may be `RENAME_EXCHANGE` or `RENAME_NOREPLACE`. If
	 * RENAME_NOREPLACE is specified, the filesystem must not
	 * overwrite *newname* if it exists and return an error
	 * instead. If `RENAME_EXCHANGE` is specified, the filesystem
	 * must atomically exchange the two files, i.e. both must
	 * exist and neither may be deleted.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the old parent directory
	 * @param name old name
	 * @param newparent inode number of the new parent directory
	 * @param newname new name
	 */
	void (*rename) (fuse_req_t req, fuse_ino_t parent, const char *name,
			fuse_ino_t newparent, const char *newname,
			unsigned int flags);

	/**
	 * Create a hard link
	 *
	 * Valid replies:
	 *   fuse_reply_entry
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the old inode number
	 * @param newparent inode number of the new parent directory
	 * @param newname new name to create
	 */
	void (*link) (fuse_req_t req, fuse_ino_t ino, fuse_ino_t newparent,
		      const char *newname);

	/**
	 * Open a file
	 *
	 * Open flags are available in fi->flags. The following rules
	 * apply.
	 *
	 *  - Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be
	 *    filtered out / handled by the kernel.
	 *
	 *  - Access modes (O_RDONLY, O_WRONLY, O_RDWR) should be used
	 *    by the filesystem to check if the operation is
	 *    permitted.  If the ``-o default_permissions`` mount
	 *    option is given, this check is already done by the
	 *    kernel before calling open() and may thus be omitted by
	 *    the filesystem.
	 *
	 *  - When writeback caching is enabled, the kernel may send
	 *    read requests even for files opened with O_WRONLY. The
	 *    filesystem should be prepared to handle this.
	 *
	 *  - When writeback caching is disabled, the filesystem is
	 *    expected to properly handle the O_APPEND flag and ensure
	 *    that each write is appending to the end of the file.
	 * 
         *  - When writeback caching is enabled, the kernel will
	 *    handle O_APPEND. However, unless all changes to the file
	 *    come through the kernel this will not work reliably. The
	 *    filesystem should thus either ignore the O_APPEND flag
	 *    (and let the kernel handle it), or return an error
	 *    (indicating that reliably O_APPEND is not available).
	 *
	 * Filesystem may store an arbitrary file handle (pointer,
	 * index, etc) in fi->fh, and use this in other all other file
	 * operations (read, write, flush, release, fsync).
	 *
	 * Filesystem may also implement stateless file I/O and not store
	 * anything in fi->fh.
	 *
	 * There are also some flags (direct_io, keep_cache) which the
	 * filesystem may set in fi, to change the way the file is opened.
	 * See fuse_file_info structure in <fuse_common.h> for more details.
	 *
	 * If this request is answered with an error code of ENOSYS
	 * and FUSE_CAP_NO_OPEN_SUPPORT is set in
	 * `fuse_conn_info.capable`, this is treated as success and
	 * future calls to open and release will also succeed without being
	 * sent to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_open
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 */
	void (*open) (fuse_req_t req, fuse_ino_t ino,
		      struct fuse_file_info *fi);

	/**
	 * Read data
	 *
	 * Read should send exactly the number of bytes requested except
	 * on EOF or error, otherwise the rest of the data will be
	 * substituted with zeroes.  An exception to this is when the file
	 * has been opened in 'direct_io' mode, in which case the return
	 * value of the read system call will reflect the return value of
	 * this operation.
	 *
	 * fi->fh will contain the value set by the open method, or will
	 * be undefined if the open method didn't set any value.
	 *
	 * Valid replies:
	 *   fuse_reply_buf
	 *   fuse_reply_iov
	 *   fuse_reply_data
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param size number of bytes to read
	 * @param off offset to read from
	 * @param fi file information
	 */
	void (*read) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
		      struct fuse_file_info *fi);

	/**
	 * Write data
	 *
	 * Write should return exactly the number of bytes requested
	 * except on error.  An exception to this is when the file has
	 * been opened in 'direct_io' mode, in which case the return value
	 * of the write system call will reflect the return value of this
	 * operation.
	 *
	 * Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
	 * expected to reset the setuid and setgid bits.
	 *
	 * fi->fh will contain the value set by the open method, or will
	 * be undefined if the open method didn't set any value.
	 *
	 * Valid replies:
	 *   fuse_reply_write
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param buf data to write
	 * @param size number of bytes to write
	 * @param off offset to write to
	 * @param fi file information
	 */
	void (*write) (fuse_req_t req, fuse_ino_t ino, const char *buf,
		       size_t size, off_t off, struct fuse_file_info *fi);

	/**
	 * Flush method
	 *
	 * This is called on each close() of the opened file.
	 *
	 * Since file descriptors can be duplicated (dup, dup2, fork), for
	 * one open call there may be many flush calls.
	 *
	 * Filesystems shouldn't assume that flush will always be called
	 * after some writes, or that if will be called at all.
	 *
	 * fi->fh will contain the value set by the open method, or will
	 * be undefined if the open method didn't set any value.
	 *
	 * NOTE: the name of the method is misleading, since (unlike
	 * fsync) the filesystem is not forced to flush pending writes.
	 * One reason to flush data is if the filesystem wants to return
	 * write errors during close.  However, such use is non-portable
	 * because POSIX does not require [close] to wait for delayed I/O to
	 * complete.
	 *
	 * If the filesystem supports file locking operations (setlk,
	 * getlk) it should remove all locks belonging to 'fi->owner'.
	 *
	 * If this request is answered with an error code of ENOSYS,
	 * this is treated as success and future calls to flush() will
	 * succeed automatically without being send to the filesystem
	 * process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 *
	 * [close]: http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html
	 */
	void (*flush) (fuse_req_t req, fuse_ino_t ino,
		       struct fuse_file_info *fi);

	/**
	 * Release an open file
	 *
	 * Release is called when there are no more references to an open
	 * file: all file descriptors are closed and all memory mappings
	 * are unmapped.
	 *
	 * For every open call there will be exactly one release call (unless
	 * the filesystem is force-unmounted).
	 *
	 * The filesystem may reply with an error, but error values are
	 * not returned to close() or munmap() which triggered the
	 * release.
	 *
	 * fi->fh will contain the value set by the open method, or will
	 * be undefined if the open method didn't set any value.
	 * fi->flags will contain the same flags as for open.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 */
	void (*release) (fuse_req_t req, fuse_ino_t ino,
			 struct fuse_file_info *fi);

	/**
	 * Synchronize file contents
	 *
	 * If the datasync parameter is non-zero, then only the user data
	 * should be flushed, not the meta data.
	 *
	 * If this request is answered with an error code of ENOSYS,
	 * this is treated as success and future calls to fsync() will
	 * succeed automatically without being send to the filesystem
	 * process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param datasync flag indicating if only data should be flushed
	 * @param fi file information
	 */
	void (*fsync) (fuse_req_t req, fuse_ino_t ino, int datasync,
		       struct fuse_file_info *fi);

	/**
	 * Open a directory
	 *
	 * Filesystem may store an arbitrary file handle (pointer, index,
	 * etc) in fi->fh, and use this in other all other directory
	 * stream operations (readdir, releasedir, fsyncdir).
	 *
	 * If this request is answered with an error code of ENOSYS and
	 * FUSE_CAP_NO_OPENDIR_SUPPORT is set in `fuse_conn_info.capable`,
	 * this is treated as success and future calls to opendir and
	 * releasedir will also succeed without being sent to the filesystem
	 * process. In addition, the kernel will cache readdir results
	 * as if opendir returned FOPEN_KEEP_CACHE | FOPEN_CACHE_DIR.
	 *
	 * Valid replies:
	 *   fuse_reply_open
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 */
	void (*opendir) (fuse_req_t req, fuse_ino_t ino,
			 struct fuse_file_info *fi);

	/**
	 * Read directory
	 *
	 * Send a buffer filled using fuse_add_direntry(), with size not
	 * exceeding the requested size.  Send an empty buffer on end of
	 * stream.
	 *
	 * fi->fh will contain the value set by the opendir method, or
	 * will be undefined if the opendir method didn't set any value.
	 *
	 * Returning a directory entry from readdir() does not affect
	 * its lookup count.
	 *
         * If off_t is non-zero, then it will correspond to one of the off_t
	 * values that was previously returned by readdir() for the same
	 * directory handle. In this case, readdir() should skip over entries
	 * coming before the position defined by the off_t value. If entries
	 * are added or removed while the directory handle is open, the filesystem
	 * may still include the entries that have been removed, and may not
	 * report the entries that have been created. However, addition or
	 * removal of entries must never cause readdir() to skip over unrelated
	 * entries or to report them more than once. This means
	 * that off_t can not be a simple index that enumerates the entries
	 * that have been returned but must contain sufficient information to
	 * uniquely determine the next directory entry to return even when the
	 * set of entries is changing.
	 *
	 * The function does not have to report the '.' and '..'
	 * entries, but is allowed to do so. Note that, if readdir does
	 * not return '.' or '..', they will not be implicitly returned,
	 * and this behavior is observable by the caller.
	 *
	 * Valid replies:
	 *   fuse_reply_buf
	 *   fuse_reply_data
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param size maximum number of bytes to send
	 * @param off offset to continue reading the directory stream
	 * @param fi file information
	 */
	void (*readdir) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
			 struct fuse_file_info *fi);

	/**
	 * Release an open directory
	 *
	 * For every opendir call there will be exactly one releasedir
	 * call (unless the filesystem is force-unmounted).
	 *
	 * fi->fh will contain the value set by the opendir method, or
	 * will be undefined if the opendir method didn't set any value.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 */
	void (*releasedir) (fuse_req_t req, fuse_ino_t ino,
			    struct fuse_file_info *fi);

	/**
	 * Synchronize directory contents
	 *
	 * If the datasync parameter is non-zero, then only the directory
	 * contents should be flushed, not the meta data.
	 *
	 * fi->fh will contain the value set by the opendir method, or
	 * will be undefined if the opendir method didn't set any value.
	 *
	 * If this request is answered with an error code of ENOSYS,
	 * this is treated as success and future calls to fsyncdir() will
	 * succeed automatically without being send to the filesystem
	 * process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param datasync flag indicating if only data should be flushed
	 * @param fi file information
	 */
	void (*fsyncdir) (fuse_req_t req, fuse_ino_t ino, int datasync,
			  struct fuse_file_info *fi);

	/**
	 * Get file system statistics
	 *
	 * Valid replies:
	 *   fuse_reply_statfs
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number, zero means "undefined"
	 */
	void (*statfs) (fuse_req_t req, fuse_ino_t ino);

	/**
	 * Set an extended attribute
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future setxattr() requests will fail with EOPNOTSUPP without being
	 * send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 */
	void (*setxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
			  const char *value, size_t size, int flags);

	/**
	 * Get an extended attribute
	 *
	 * If size is zero, the size of the value should be sent with
	 * fuse_reply_xattr.
	 *
	 * If the size is non-zero, and the value fits in the buffer, the
	 * value should be sent with fuse_reply_buf.
	 *
	 * If the size is too small for the value, the ERANGE error should
	 * be sent.
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future getxattr() requests will fail with EOPNOTSUPP without being
	 * send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_buf
	 *   fuse_reply_data
	 *   fuse_reply_xattr
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param name of the extended attribute
	 * @param size maximum size of the value to send
	 */
	void (*getxattr) (fuse_req_t req, fuse_ino_t ino, const char *name,
			  size_t size);

	/**
	 * List extended attribute names
	 *
	 * If size is zero, the total size of the attribute list should be
	 * sent with fuse_reply_xattr.
	 *
	 * If the size is non-zero, and the null character separated
	 * attribute list fits in the buffer, the list should be sent with
	 * fuse_reply_buf.
	 *
	 * If the size is too small for the list, the ERANGE error should
	 * be sent.
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future listxattr() requests will fail with EOPNOTSUPP without being
	 * send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_buf
	 *   fuse_reply_data
	 *   fuse_reply_xattr
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param size maximum size of the list to send
	 */
	void (*listxattr) (fuse_req_t req, fuse_ino_t ino, size_t size);

	/**
	 * Remove an extended attribute
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future removexattr() requests will fail with EOPNOTSUPP without being
	 * send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param name of the extended attribute
	 */
	void (*removexattr) (fuse_req_t req, fuse_ino_t ino, const char *name);

	/**
	 * Check file access permissions
	 *
	 * This will be called for the access() and chdir() system
	 * calls.  If the 'default_permissions' mount option is given,
	 * this method is not called.
	 *
	 * This method is not called under Linux kernel versions 2.4.x
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent success, i.e. this and all future access()
	 * requests will succeed without being send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param mask requested access mode
	 */
	void (*access) (fuse_req_t req, fuse_ino_t ino, int mask);

	/**
	 * Create and open a file
	 *
	 * If the file does not exist, first create it with the specified
	 * mode, and then open it.
	 *
	 * See the description of the open handler for more
	 * information.
	 *
	 * If this method is not implemented or under Linux kernel
	 * versions earlier than 2.6.15, the mknod() and open() methods
	 * will be called instead.
	 *
	 * If this request is answered with an error code of ENOSYS, the handler
	 * is treated as not implemented (i.e., for this and future requests the
	 * mknod() and open() handlers will be called instead).
	 *
	 * Valid replies:
	 *   fuse_reply_create
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param parent inode number of the parent directory
	 * @param name to create
	 * @param mode file type and mode with which to create the new file
	 * @param fi file information
	 */
	void (*create) (fuse_req_t req, fuse_ino_t parent, const char *name,
			mode_t mode, struct fuse_file_info *fi);

	/**
	 * Test for a POSIX file lock
	 *
	 * Valid replies:
	 *   fuse_reply_lock
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 * @param lock the region/type to test
	 */
	void (*getlk) (fuse_req_t req, fuse_ino_t ino,
		       struct fuse_file_info *fi, struct flock *lock);

	/**
	 * Acquire, modify or release a POSIX file lock
	 *
	 * For POSIX threads (NPTL) there's a 1-1 relation between pid and
	 * owner, but otherwise this is not always the case.  For checking
	 * lock ownership, 'fi->owner' must be used.  The l_pid field in
	 * 'struct flock' should only be used to fill in this field in
	 * getlk().
	 *
	 * Note: if the locking methods are not implemented, the kernel
	 * will still allow file locking to work locally.  Hence these are
	 * only interesting for network filesystems and similar.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 * @param lock the region/type to set
	 * @param sleep locking operation may sleep
	 */
	void (*setlk) (fuse_req_t req, fuse_ino_t ino,
		       struct fuse_file_info *fi,
		       struct flock *lock, int sleep);

	/**
	 * Map block index within file to block index within device
	 *
	 * Note: This makes sense only for block device backed filesystems
	 * mounted with the 'blkdev' option
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure, i.e. all future bmap() requests will
	 * fail with the same error code without being send to the filesystem
	 * process.
	 *
	 * Valid replies:
	 *   fuse_reply_bmap
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param blocksize unit of block index
	 * @param idx block index within file
	 */
	void (*bmap) (fuse_req_t req, fuse_ino_t ino, size_t blocksize,
		      uint64_t idx);

#if FUSE_USE_VERSION < 35
	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, int cmd,
		       void *arg, struct fuse_file_info *fi, unsigned flags,
		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
#else
	/**
	 * Ioctl
	 *
	 * Note: For unrestricted ioctls (not allowed for FUSE
	 * servers), data in and out areas can be discovered by giving
	 * iovs and setting FUSE_IOCTL_RETRY in *flags*.  For
	 * restricted ioctls, kernel prepares in/out data area
	 * according to the information encoded in cmd.
	 *
	 * Valid replies:
	 *   fuse_reply_ioctl_retry
	 *   fuse_reply_ioctl
	 *   fuse_reply_ioctl_iov
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param cmd ioctl command
	 * @param arg ioctl argument
	 * @param fi file information
	 * @param flags for FUSE_IOCTL_* flags
	 * @param in_buf data fetched from the caller
	 * @param in_bufsz number of fetched bytes
	 * @param out_bufsz maximum size of output data
	 *
	 * Note : the unsigned long request submitted by the application
	 * is truncated to 32 bits.
	 */
	void (*ioctl) (fuse_req_t req, fuse_ino_t ino, unsigned int cmd,
		       void *arg, struct fuse_file_info *fi, unsigned flags,
		       const void *in_buf, size_t in_bufsz, size_t out_bufsz);
#endif

	/**
	 * Poll for IO readiness
	 *
	 * Note: If ph is non-NULL, the client should notify
	 * when IO readiness events occur by calling
	 * fuse_lowlevel_notify_poll() with the specified ph.
	 *
	 * Regardless of the number of times poll with a non-NULL ph
	 * is received, single notification is enough to clear all.
	 * Notifying more times incurs overhead but doesn't harm
	 * correctness.
	 *
	 * The callee is responsible for destroying ph with
	 * fuse_pollhandle_destroy() when no longer in use.
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as success (with a kernel-defined default poll-mask) and
	 * future calls to pull() will succeed the same way without being send
	 * to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_poll
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 * @param ph poll handle to be used for notification
	 */
	void (*poll) (fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,
		      struct fuse_pollhandle *ph);

	/**
	 * Write data made available in a buffer
	 *
	 * This is a more generic version of the ->write() method.  If
	 * FUSE_CAP_SPLICE_READ is set in fuse_conn_info.want and the
	 * kernel supports splicing from the fuse device, then the
	 * data will be made available in pipe for supporting zero
	 * copy data transfer.
	 *
	 * buf->count is guaranteed to be one (and thus buf->idx is
	 * always zero). The write_buf handler must ensure that
	 * bufv->off is correctly updated (reflecting the number of
	 * bytes read from bufv->buf[0]).
	 *
	 * Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is
	 * expected to reset the setuid and setgid bits.
	 *
	 * Valid replies:
	 *   fuse_reply_write
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param bufv buffer containing the data
	 * @param off offset to write to
	 * @param fi file information
	 */
	void (*write_buf) (fuse_req_t req, fuse_ino_t ino,
			   struct fuse_bufvec *bufv, off_t off,
			   struct fuse_file_info *fi);

	/**
	 * Callback function for the retrieve request
	 *
	 * Valid replies:
	 *	fuse_reply_none
	 *
	 * @param req request handle
	 * @param cookie user data supplied to fuse_lowlevel_notify_retrieve()
	 * @param ino the inode number supplied to fuse_lowlevel_notify_retrieve()
	 * @param offset the offset supplied to fuse_lowlevel_notify_retrieve()
	 * @param bufv the buffer containing the returned data
	 */
	void (*retrieve_reply) (fuse_req_t req, void *cookie, fuse_ino_t ino,
				off_t offset, struct fuse_bufvec *bufv);

	/**
	 * Forget about multiple inodes
	 *
	 * See description of the forget function for more
	 * information.
	 *
	 * Valid replies:
	 *   fuse_reply_none
	 *
	 * @param req request handle
	 */
	void (*forget_multi) (fuse_req_t req, size_t count,
			      struct fuse_forget_data *forgets);

	/**
	 * Acquire, modify or release a BSD file lock
	 *
	 * Note: if the locking methods are not implemented, the kernel
	 * will still allow file locking to work locally.  Hence these are
	 * only interesting for network filesystems and similar.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param fi file information
	 * @param op the locking operation, see flock(2)
	 */
	void (*flock) (fuse_req_t req, fuse_ino_t ino,
		       struct fuse_file_info *fi, int op);

	/**
	 * Allocate requested space. If this function returns success then
	 * subsequent writes to the specified range shall not fail due to the lack
	 * of free space on the file system storage media.
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future fallocate() requests will fail with EOPNOTSUPP without being
	 * send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param offset starting point for allocated region
	 * @param length size of allocated region
	 * @param mode determines the operation to be performed on the given range,
	 *             see fallocate(2)
	 */
	void (*fallocate) (fuse_req_t req, fuse_ino_t ino, int mode,
		       off_t offset, off_t length, struct fuse_file_info *fi);

	/**
	 * Read directory with attributes
	 *
	 * Send a buffer filled using fuse_add_direntry_plus(), with size not
	 * exceeding the requested size.  Send an empty buffer on end of
	 * stream.
	 *
	 * fi->fh will contain the value set by the opendir method, or
	 * will be undefined if the opendir method didn't set any value.
	 *
	 * In contrast to readdir() (which does not affect the lookup counts),
	 * the lookup count of every entry returned by readdirplus(), except "."
	 * and "..", is incremented by one.
	 *
	 * Valid replies:
	 *   fuse_reply_buf
	 *   fuse_reply_data
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param size maximum number of bytes to send
	 * @param off offset to continue reading the directory stream
	 * @param fi file information
	 */
	void (*readdirplus) (fuse_req_t req, fuse_ino_t ino, size_t size, off_t off,
			 struct fuse_file_info *fi);

	/**
	 * Copy a range of data from one file to another
	 *
	 * Performs an optimized copy between two file descriptors without the
	 * additional cost of transferring data through the FUSE kernel module
	 * to user space (glibc) and then back into the FUSE filesystem again.
	 *
	 * In case this method is not implemented, glibc falls back to reading
	 * data from the source and writing to the destination. Effectively
	 * doing an inefficient copy of the data.
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure with error code EOPNOTSUPP, i.e. all
	 * future copy_file_range() requests will fail with EOPNOTSUPP without
	 * being send to the filesystem process.
	 *
	 * Valid replies:
	 *   fuse_reply_write
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino_in the inode number or the source file
	 * @param off_in starting point from were the data should be read
	 * @param fi_in file information of the source file
	 * @param ino_out the inode number or the destination file
	 * @param off_out starting point where the data should be written
	 * @param fi_out file information of the destination file
	 * @param len maximum size of the data to copy
	 * @param flags passed along with the copy_file_range() syscall
	 */
	void (*copy_file_range) (fuse_req_t req, fuse_ino_t ino_in,
				 off_t off_in, struct fuse_file_info *fi_in,
				 fuse_ino_t ino_out, off_t off_out,
				 struct fuse_file_info *fi_out, size_t len,
				 int flags);

	/**
	 * Find next data or hole after the specified offset
	 *
	 * If this request is answered with an error code of ENOSYS, this is
	 * treated as a permanent failure, i.e. all future lseek() requests will
	 * fail with the same error code without being send to the filesystem
	 * process.
	 *
	 * Valid replies:
	 *   fuse_reply_lseek
	 *   fuse_reply_err
	 *
	 * @param req request handle
	 * @param ino the inode number
	 * @param off offset to start search from
	 * @param whence either SEEK_DATA or SEEK_HOLE
	 * @param fi file information
	 */
	void (*lseek) (fuse_req_t req, fuse_ino_t ino, off_t off, int whence,
		       struct fuse_file_info *fi);
};

/**
 * Reply with an error code or success.
 *
 * Possible requests:
 *   all except forget, forget_multi, retrieve_reply
 *
 * Wherever possible, error codes should be chosen from the list of
 * documented error conditions in the corresponding system calls
 * manpage.
 *
 * An error code of ENOSYS is sometimes treated specially. This is
 * indicated in the documentation of the affected handler functions.
 *
 * The following requests may be answered with a zero error code:
 * unlink, rmdir, rename, flush, release, fsync, fsyncdir, setxattr,
 * removexattr, setlk.
 *
 * @param req request handle
 * @param err the positive error value, or zero for success
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_err(fuse_req_t req, int err);

/**
 * Don't send reply
 *
 * Possible requests:
 *   forget
 *   forget_multi
 *   retrieve_reply
 *
 * @param req request handle
 */
void fuse_reply_none(fuse_req_t req);

/**
 * Reply with a directory entry
 *
 * Possible requests:
 *   lookup, mknod, mkdir, symlink, link
 *
 * Side effects:
 *   increments the lookup count on success
 *
 * @param req request handle
 * @param e the entry parameters
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e);

/**
 * Reply with a directory entry and open parameters
 *
 * currently the following members of 'fi' are used:
 *   fh, direct_io, keep_cache
 *
 * Possible requests:
 *   create
 *
 * Side effects:
 *   increments the lookup count on success
 *
 * @param req request handle
 * @param e the entry parameters
 * @param fi file information
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,
		      const struct fuse_file_info *fi);

/**
 * Reply with attributes
 *
 * Possible requests:
 *   getattr, setattr
 *
 * @param req request handle
 * @param attr the attributes
 * @param attr_timeout	validity timeout (in seconds) for the attributes
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_attr(fuse_req_t req, const struct stat *attr,
		    double attr_timeout);

/**
 * Reply with the contents of a symbolic link
 *
 * Possible requests:
 *   readlink
 *
 * @param req request handle
 * @param link symbolic link contents
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_readlink(fuse_req_t req, const char *link);

/**
 * Reply with open parameters
 *
 * currently the following members of 'fi' are used:
 *   fh, direct_io, keep_cache
 *
 * Possible requests:
 *   open, opendir
 *
 * @param req request handle
 * @param fi file information
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *fi);

/**
 * Reply with number of bytes written
 *
 * Possible requests:
 *   write
 *
 * @param req request handle
 * @param count the number of bytes written
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_write(fuse_req_t req, size_t count);

/**
 * Reply with data
 *
 * Possible requests:
 *   read, readdir, getxattr, listxattr
 *
 * @param req request handle
 * @param buf buffer containing data
 * @param size the size of data in bytes
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size);

/**
 * Reply with data copied/moved from buffer(s)
 *
 * Zero copy data transfer ("splicing") will be used under
 * the following circumstances:
 *
 * 1. FUSE_CAP_SPLICE_WRITE is set in fuse_conn_info.want, and
 * 2. the kernel supports splicing from the fuse device
 *    (FUSE_CAP_SPLICE_WRITE is set in fuse_conn_info.capable), and
 * 3. *flags* does not contain FUSE_BUF_NO_SPLICE
 * 4. The amount of data that is provided in file-descriptor backed
 *    buffers (i.e., buffers for which bufv[n].flags == FUSE_BUF_FD)
 *    is at least twice the page size.
 *
 * In order for SPLICE_F_MOVE to be used, the following additional
 * conditions have to be fulfilled:
 *
 * 1. FUSE_CAP_SPLICE_MOVE is set in fuse_conn_info.want, and
 * 2. the kernel supports it (i.e, FUSE_CAP_SPLICE_MOVE is set in
      fuse_conn_info.capable), and
 * 3. *flags* contains FUSE_BUF_SPLICE_MOVE
 *
 * Note that, if splice is used, the data is actually spliced twice:
 * once into a temporary pipe (to prepend header data), and then again
 * into the kernel. If some of the provided buffers are memory-backed,
 * the data in them is copied in step one and spliced in step two.
 *
 * The FUSE_BUF_SPLICE_FORCE_SPLICE and FUSE_BUF_SPLICE_NONBLOCK flags
 * are silently ignored.
 *
 * Possible requests:
 *   read, readdir, getxattr, listxattr
 *
 * Side effects:
 *   when used to return data from a readdirplus() (but not readdir())
 *   call, increments the lookup count of each returned entry by one
 *   on success.
 *
 * @param req request handle
 * @param bufv buffer vector
 * @param flags flags controlling the copy
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv,
		    enum fuse_buf_copy_flags flags);

/**
 * Reply with data vector
 *
 * Possible requests:
 *   read, readdir, getxattr, listxattr
 *
 * @param req request handle
 * @param iov the vector containing the data
 * @param count the size of vector
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_iov(fuse_req_t req, const struct iovec *iov, int count);

/**
 * Reply with filesystem statistics
 *
 * Possible requests:
 *   statfs
 *
 * @param req request handle
 * @param stbuf filesystem statistics
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf);

/**
 * Reply with needed buffer size
 *
 * Possible requests:
 *   getxattr, listxattr
 *
 * @param req request handle
 * @param count the buffer size needed in bytes
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_xattr(fuse_req_t req, size_t count);

/**
 * Reply with file lock information
 *
 * Possible requests:
 *   getlk
 *
 * @param req request handle
 * @param lock the lock information
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_lock(fuse_req_t req, const struct flock *lock);

/**
 * Reply with block index
 *
 * Possible requests:
 *   bmap
 *
 * @param req request handle
 * @param idx block index within device
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_bmap(fuse_req_t req, uint64_t idx);

/* ----------------------------------------------------------- *
 * Filling a buffer in readdir				       *
 * ----------------------------------------------------------- */

/**
 * Add a directory entry to the buffer
 *
 * Buffer needs to be large enough to hold the entry.  If it's not,
 * then the entry is not filled in but the size of the entry is still
 * returned.  The caller can check this by comparing the bufsize
 * parameter with the returned entry size.  If the entry size is
 * larger than the buffer size, the operation failed.
 *
 * From the 'stbuf' argument the st_ino field and bits 12-15 of the
 * st_mode field are used.  The other fields are ignored.
 *
 * *off* should be any non-zero value that the filesystem can use to
 * identify the current point in the directory stream. It does not
 * need to be the actual physical position. A value of zero is
 * reserved to mean "from the beginning", and should therefore never
 * be used (the first call to fuse_add_direntry should be passed the
 * offset of the second directory entry).
 *
 * @param req request handle
 * @param buf the point where the new entry will be added to the buffer
 * @param bufsize remaining size of the buffer
 * @param name the name of the entry
 * @param stbuf the file attributes
 * @param off the offset of the next entry
 * @return the space needed for the entry
 */
size_t fuse_add_direntry(fuse_req_t req, char *buf, size_t bufsize,
			 const char *name, const struct stat *stbuf,
			 off_t off);

/**
 * Add a directory entry to the buffer with the attributes
 *
 * See documentation of `fuse_add_direntry()` for more details.
 *
 * @param req request handle
 * @param buf the point where the new entry will be added to the buffer
 * @param bufsize remaining size of the buffer
 * @param name the name of the entry
 * @param e the directory entry
 * @param off the offset of the next entry
 * @return the space needed for the entry
 */
size_t fuse_add_direntry_plus(fuse_req_t req, char *buf, size_t bufsize,
			      const char *name,
			      const struct fuse_entry_param *e, off_t off);

/**
 * Reply to ask for data fetch and output buffer preparation.  ioctl
 * will be retried with the specified input data fetched and output
 * buffer prepared.
 *
 * Possible requests:
 *   ioctl
 *
 * @param req request handle
 * @param in_iov iovec specifying data to fetch from the caller
 * @param in_count number of entries in in_iov
 * @param out_iov iovec specifying addresses to write output to
 * @param out_count number of entries in out_iov
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_ioctl_retry(fuse_req_t req,
			   const struct iovec *in_iov, size_t in_count,
			   const struct iovec *out_iov, size_t out_count);

/**
 * Reply to finish ioctl
 *
 * Possible requests:
 *   ioctl
 *
 * @param req request handle
 * @param result result to be passed to the caller
 * @param buf buffer containing output data
 * @param size length of output data
 */
int fuse_reply_ioctl(fuse_req_t req, int result, const void *buf, size_t size);

/**
 * Reply to finish ioctl with iov buffer
 *
 * Possible requests:
 *   ioctl
 *
 * @param req request handle
 * @param result result to be passed to the caller
 * @param iov the vector containing the data
 * @param count the size of vector
 */
int fuse_reply_ioctl_iov(fuse_req_t req, int result, const struct iovec *iov,
			 int count);

/**
 * Reply with poll result event mask
 *
 * @param req request handle
 * @param revents poll result event mask
 */
int fuse_reply_poll(fuse_req_t req, unsigned revents);

/**
 * Reply with offset
 *
 * Possible requests:
 *   lseek
 *
 * @param req request handle
 * @param off offset of next data or hole
 * @return zero for success, -errno for failure to send reply
 */
int fuse_reply_lseek(fuse_req_t req, off_t off);

/* ----------------------------------------------------------- *
 * Notification						       *
 * ----------------------------------------------------------- */

/**
 * Notify IO readiness event
 *
 * For more information, please read comment for poll operation.
 *
 * @param ph poll handle to notify IO readiness event for
 */
int fuse_lowlevel_notify_poll(struct fuse_pollhandle *ph);

/**
 * Notify to invalidate cache for an inode.
 *
 * Added in FUSE protocol version 7.12. If the kernel does not support
 * this (or a newer) version, the function will return -ENOSYS and do
 * nothing.
 *
 * If the filesystem has writeback caching enabled, invalidating an
 * inode will first trigger a writeback of all dirty pages. The call
 * will block until all writeback requests have completed and the
 * inode has been invalidated. It will, however, not wait for
 * completion of pending writeback requests that have been issued
 * before.
 *
 * If there are no dirty pages, this function will never block.
 *
 * @param se the session object
 * @param ino the inode number
 * @param off the offset in the inode where to start invalidating
 *            or negative to invalidate attributes only
 * @param len the amount of cache to invalidate or 0 for all
 * @return zero for success, -errno for failure
 */
int fuse_lowlevel_notify_inval_inode(struct fuse_session *se, fuse_ino_t ino,
				     off_t off, off_t len);

/**
 * Notify to invalidate parent attributes and the dentry matching
 * parent/name
 *
 * To avoid a deadlock this function must not be called in the
 * execution path of a related filesytem operation or within any code
 * that could hold a lock that could be needed to execute such an
 * operation. As of kernel 4.18, a "related operation" is a lookup(),
 * symlink(), mknod(), mkdir(), unlink(), rename(), link() or create()
 * request for the parent, and a setattr(), unlink(), rmdir(),
 * rename(), setxattr(), removexattr(), readdir() or readdirplus()
 * request for the inode itself.
 *
 * When called correctly, this function will never block.
 *
 * Added in FUSE protocol version 7.12. If the kernel does not support
 * this (or a newer) version, the function will return -ENOSYS and do
 * nothing.
 *
 * @param se the session object
 * @param parent inode number
 * @param name file name
 * @param namelen strlen() of file name
 * @return zero for success, -errno for failure
 */
int fuse_lowlevel_notify_inval_entry(struct fuse_session *se, fuse_ino_t parent,
				     const char *name, size_t namelen);

/**
 * This function behaves like fuse_lowlevel_notify_inval_entry() with
 * the following additional effect (at least as of Linux kernel 4.8):
 *
 * If the provided *child* inode matches the inode that is currently
 * associated with the cached dentry, and if there are any inotify
 * watches registered for the dentry, then the watchers are informed
 * that the dentry has been deleted.
 *
 * To avoid a deadlock this function must not be called while
 * executing a related filesytem operation or while holding a lock
 * that could be needed to execute such an operation (see the
 * description of fuse_lowlevel_notify_inval_entry() for more
 * details).
 *
 * When called correctly, this function will never block.
 *
 * Added in FUSE protocol version 7.18. If the kernel does not support
 * this (or a newer) version, the function will return -ENOSYS and do
 * nothing.
 *
 * @param se the session object
 * @param parent inode number
 * @param child inode number
 * @param name file name
 * @param namelen strlen() of file name
 * @return zero for success, -errno for failure
 */
int fuse_lowlevel_notify_delete(struct fuse_session *se,
				fuse_ino_t parent, fuse_ino_t child,
				const char *name, size_t namelen);

/**
 * Store data to the kernel buffers
 *
 * Synchronously store data in the kernel buffers belonging to the
 * given inode.  The stored data is marked up-to-date (no read will be
 * performed against it, unless it's invalidated or evicted from the
 * cache).
 *
 * If the stored data overflows the current file size, then the size
 * is extended, similarly to a write(2) on the filesystem.
 *
 * If this function returns an error, then the store wasn't fully
 * completed, but it may have been partially completed.
 *
 * Added in FUSE protocol version 7.15. If the kernel does not support
 * this (or a newer) version, the function will return -ENOSYS and do
 * nothing.
 *
 * @param se the session object
 * @param ino the inode number
 * @param offset the starting offset into the file to store to
 * @param bufv buffer vector
 * @param flags flags controlling the copy
 * @return zero for success, -errno for failure
 */
int fuse_lowlevel_notify_store(struct fuse_session *se, fuse_ino_t ino,
			       off_t offset, struct fuse_bufvec *bufv,
			       enum fuse_buf_copy_flags flags);
/**
 * Retrieve data from the kernel buffers
 *
 * Retrieve data in the kernel buffers belonging to the given inode.
 * If successful then the retrieve_reply() method will be called with
 * the returned data.
 *
 * Only present pages are returned in the retrieve reply.  Retrieving
 * stops when it finds a non-present page and only data prior to that
 * is returned.
 *
 * If this function returns an error, then the retrieve will not be
 * completed and no reply will be sent.
 *
 * This function doesn't change the dirty state of pages in the kernel
 * buffer.  For dirty pages the write() method will be called
 * regardless of having been retrieved previously.
 *
 * Added in FUSE protocol version 7.15. If the kernel does not support
 * this (or a newer) version, the function will return -ENOSYS and do
 * nothing.
 *
 * @param se the session object
 * @param ino the inode number
 * @param size the number of bytes to retrieve
 * @param offset the starting offset into the file to retrieve from
 * @param cookie user data to supply to the reply callback
 * @return zero for success, -errno for failure
 */
int fuse_lowlevel_notify_retrieve(struct fuse_session *se, fuse_ino_t ino,
				  size_t size, off_t offset, void *cookie);


/* ----------------------------------------------------------- *
 * Utility functions					       *
 * ----------------------------------------------------------- */

/**
 * Get the userdata from the request
 *
 * @param req request handle
 * @return the user data passed to fuse_session_new()
 */
void *fuse_req_userdata(fuse_req_t req);

/**
 * Get the context from the request
 *
 * The pointer returned by this function will only be valid for the
 * request's lifetime
 *
 * @param req request handle
 * @return the context structure
 */
const struct fuse_ctx *fuse_req_ctx(fuse_req_t req);

/**
 * Get the current supplementary group IDs for the specified request
 *
 * Similar to the getgroups(2) system call, except the return value is
 * always the total number of group IDs, even if it is larger than the
 * specified size.
 *
 * The current fuse kernel module in linux (as of 2.6.30) doesn't pass
 * the group list to userspace, hence this function needs to parse
 * "/proc/$TID/task/$TID/status" to get the group IDs.
 *
 * This feature may not be supported on all operating systems.  In
 * such a case this function will return -ENOSYS.
 *
 * @param req request handle
 * @param size size of given array
 * @param list array of group IDs to be filled in
 * @return the total number of supplementary group IDs or -errno on failure
 */
int fuse_req_getgroups(fuse_req_t req, int size, gid_t list[]);

/**
 * Callback function for an interrupt
 *
 * @param req interrupted request
 * @param data user data
 */
typedef void (*fuse_interrupt_func_t)(fuse_req_t req, void *data);

/**
 * Register/unregister callback for an interrupt
 *
 * If an interrupt has already happened, then the callback function is
 * called from within this function, hence it's not possible for
 * interrupts to be lost.
 *
 * @param req request handle
 * @param func the callback function or NULL for unregister
 * @param data user data passed to the callback function
 */
void fuse_req_interrupt_func(fuse_req_t req, fuse_interrupt_func_t func,
			     void *data);

/**
 * Check if a request has already been interrupted
 *
 * @param req request handle
 * @return 1 if the request has been interrupted, 0 otherwise
 */
int fuse_req_interrupted(fuse_req_t req);


/* ----------------------------------------------------------- *
 * Inquiry functions                                           *
 * ----------------------------------------------------------- */

/**
 * Print low-level version information to stdout.
 */
void fuse_lowlevel_version(void);

/**
 * Print available low-level options to stdout. This is not an
 * exhaustive list, but includes only those options that may be of
 * interest to an end-user of a file system.
 */
void fuse_lowlevel_help(void);

/**
 * Print available options for `fuse_parse_cmdline()`.
 */
void fuse_cmdline_help(void);

/* ----------------------------------------------------------- *
 * Filesystem setup & teardown                                 *
 * ----------------------------------------------------------- */

struct fuse_cmdline_opts {
	int singlethread;
	int foreground;
	int debug;
	int nodefault_subtype;
	char *mountpoint;
	int show_version;
	int show_help;
	int clone_fd;
	unsigned int max_idle_threads;
};

/**
 * Utility function to parse common options for simple file systems
 * using the low-level API. A help text that describes the available
 * options can be printed with `fuse_cmdline_help`. A single
 * non-option argument is treated as the mountpoint. Multiple
 * non-option arguments will result in an error.
 *
 * If neither -o subtype= or -o fsname= options are given, a new
 * subtype option will be added and set to the basename of the program
 * (the fsname will remain unset, and then defaults to "fuse").
 *
 * Known options will be removed from *args*, unknown options will
 * remain.
 *
 * @param args argument vector (input+output)
 * @param opts output argument for parsed options
 * @return 0 on success, -1 on failure
 */
int fuse_parse_cmdline(struct fuse_args *args,
		       struct fuse_cmdline_opts *opts);

/**
 * Create a low level session.
 *
 * Returns a session structure suitable for passing to
 * fuse_session_mount() and fuse_session_loop().
 *
 * This function accepts most file-system independent mount options
 * (like context, nodev, ro - see mount(8)), as well as the general
 * fuse mount options listed in mount.fuse(8) (e.g. -o allow_root and
 * -o default_permissions, but not ``-o use_ino``).  Instead of `-o
 * debug`, debugging may also enabled with `-d` or `--debug`.
 *
 * If not all options are known, an error message is written to stderr
 * and the function returns NULL.
 *
 * Option parsing skips argv[0], which is assumed to contain the
 * program name. To prevent accidentally passing an option in
 * argv[0], this element must always be present (even if no options
 * are specified). It may be set to the empty string ('\0') if no
 * reasonable value can be provided.
 *
 * @param args argument vector
 * @param op the (low-level) filesystem operations
 * @param op_size sizeof(struct fuse_lowlevel_ops)
 * @param userdata user data
 *
 * @return the fuse session on success, NULL on failure
 **/
struct fuse_session *fuse_session_new(struct fuse_args *args,
				      const struct fuse_lowlevel_ops *op,
				      size_t op_size, void *userdata);

/**
 * Mount a FUSE file system.
 *
 * @param mountpoint the mount point path
 * @param se session object
 *
 * @return 0 on success, -1 on failure.
 **/
int fuse_session_mount(struct fuse_session *se, const char *mountpoint);

/**
 * Enter a single threaded, blocking event loop.
 *
 * When the event loop terminates because the connection to the FUSE
 * kernel module has been closed, this function returns zero. This
 * happens when the filesystem is unmounted regularly (by the
 * filesystem owner or root running the umount(8) or fusermount(1)
 * command), or if connection is explicitly severed by writing ``1``
 * to the``abort`` file in ``/sys/fs/fuse/connections/NNN``. The only
 * way to distinguish between these two conditions is to check if the
 * filesystem is still mounted after the session loop returns.
 *
 * When some error occurs during request processing, the function
 * returns a negated errno(3) value.
 *
 * If the loop has been terminated because of a signal handler
 * installed by fuse_set_signal_handlers(), this function returns the
 * (positive) signal value that triggered the exit.
 *
 * @param se the session
 * @return 0, -errno, or a signal value
 */
int fuse_session_loop(struct fuse_session *se);

#if FUSE_USE_VERSION < 32
int fuse_session_loop_mt_31(struct fuse_session *se, int clone_fd);
#define fuse_session_loop_mt(se, clone_fd) fuse_session_loop_mt_31(se, clone_fd)
#else
#if (!defined(__UCLIBC__) && !defined(__APPLE__))
/**
 * Enter a multi-threaded event loop.
 *
 * For a description of the return value and the conditions when the
 * event loop exits, refer to the documentation of
 * fuse_session_loop().
 *
 * @param se the session
 * @param config session loop configuration 
 * @return see fuse_session_loop()
 */
int fuse_session_loop_mt(struct fuse_session *se, struct fuse_loop_config *config);
#else
int fuse_session_loop_mt_32(struct fuse_session *se, struct fuse_loop_config *config);
#define fuse_session_loop_mt(se, config) fuse_session_loop_mt_32(se, config)
#endif
#endif

/**
 * Flag a session as terminated.
 *
 * This function is invoked by the POSIX signal handlers, when
 * registered using fuse_set_signal_handlers(). It will cause any
 * running event loops to terminate on the next opportunity.
 *
 * @param se the session
 */
void fuse_session_exit(struct fuse_session *se);

/**
 * Reset the terminated flag of a session
 *
 * @param se the session
 */
void fuse_session_reset(struct fuse_session *se);

/**
 * Query the terminated flag of a session
 *
 * @param se the session
 * @return 1 if exited, 0 if not exited
 */
int fuse_session_exited(struct fuse_session *se);

/**
 * Ensure that file system is unmounted.
 *
 * In regular operation, the file system is typically unmounted by the
 * user calling umount(8) or fusermount(1), which then terminates the
 * FUSE session loop. However, the session loop may also terminate as
 * a result of an explicit call to fuse_session_exit() (e.g. by a
 * signal handler installed by fuse_set_signal_handler()). In this
 * case the filesystem remains mounted, but any attempt to access it
 * will block (while the filesystem process is still running) or give
 * an ESHUTDOWN error (after the filesystem process has terminated).
 *
 * If the communication channel with the FUSE kernel module is still
 * open (i.e., if the session loop was terminated by an explicit call
 * to fuse_session_exit()), this function will close it and unmount
 * the filesystem. If the communication channel has been closed by the
 * kernel, this method will do (almost) nothing.
 *
 * NOTE: The above semantics mean that if the connection to the kernel
 * is terminated via the ``/sys/fs/fuse/connections/NNN/abort`` file,
 * this method will *not* unmount the filesystem.
 *
 * @param se the session
 */
void fuse_session_unmount(struct fuse_session *se);

/**
 * Destroy a session
 *
 * @param se the session
 */
void fuse_session_destroy(struct fuse_session *se);

/* ----------------------------------------------------------- *
 * Custom event loop support                                   *
 * ----------------------------------------------------------- */

/**
 * Return file descriptor for communication with kernel.
 *
 * The file selector can be used to integrate FUSE with a custom event
 * loop. Whenever data is available for reading on the provided fd,
 * the event loop should call `fuse_session_receive_buf` followed by
 * `fuse_session_process_buf` to process the request.
 *
 * The returned file descriptor is valid until `fuse_session_unmount`
 * is called.
 *
 * @param se the session
 * @return a file descriptor
 */
int fuse_session_fd(struct fuse_session *se);

/**
 * Process a raw request supplied in a generic buffer
 *
 * The fuse_buf may contain a memory buffer or a pipe file descriptor.
 *
 * @param se the session
 * @param buf the fuse_buf containing the request
 */
void fuse_session_process_buf(struct fuse_session *se,
			      const struct fuse_buf *buf);

/**
 * Read a raw request from the kernel into the supplied buffer.
 *
 * Depending on file system options, system capabilities, and request
 * size the request is either read into a memory buffer or spliced
 * into a temporary pipe.
 *
 * @param se the session
 * @param buf the fuse_buf to store the request in
 * @return the actual size of the raw request, or -errno on error
 */
int fuse_session_receive_buf(struct fuse_session *se, struct fuse_buf *buf);

#ifdef __cplusplus
}
#endif

#endif /* FUSE_LOWLEVEL_H_ */

```

`devices/virtio/fuse/meson.build`:

```build

mvisor_sources += files(
  'fuse.cc',
  'fuse.h',
  'fuse_common.h',
  'fuse_kernel.h',
  'fuse_lowlevel.h'
)

```

`devices/virtio/meson.build`:

```build
mvisor_sources += files(
  'virtio_block.cc',
  'virtio_console.cc',
  'virtio_fs.cc',
  'virtio_network.cc',
  'virtio_pci.cc',
  'virtio_pci.h'
)

proto_sources += proto_gen.process(
  'virtio_console.proto',
  'virtio_pci.proto',
)

if get_option('vgpu')
  mvisor_sources += files(
    'virtio_vgpu.cc'
  )

  proto_sources += proto_gen.process(
    'virtio_vgpu.proto'
  )

  mvisor_deps += [
    dependency('virglrenderer')
  ]
endif

subdir('fuse')

```

`devices/virtio/virtio_block.cc`:

```cc
/* 
 * MVisor VirtIO Block Device
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "virtio_pci.h"
#include <cstring>
#include <cmath>
#include "linuz/virtio_blk.h"
#include "logger.h"
#include "disk_image.h"
#include "qcow2.h"
#include "machine.h"

#define DEFAULT_QUEUE_SIZE 256

class VirtioBlock : public VirtioPci {
 private:
  virtio_blk_config block_config_;
  DiskImage* image_ = nullptr;

 public:
  VirtioBlock() {
    pci_header_.class_code = 0x010000;
    pci_header_.device_id = 0x1001;
    pci_header_.subsys_id = 0x0002;
    
    AddPciBar(1, 0x1000, kIoResourceTypeMmio);
    AddMsiXCapability(1, 2, 0, 0x1000);

    device_features_ |= (1UL << VIRTIO_BLK_F_SEG_MAX) |
      // (1UL << VIRTIO_BLK_F_GEOMETRY) |
      (1UL << VIRTIO_BLK_F_BLK_SIZE) |
      (1UL << VIRTIO_BLK_F_FLUSH) |
      // (1UL << VIRTIO_BLK_F_TOPOLOGY) |
      (1UL << VIRTIO_BLK_F_WCE) |
      (1UL << VIRTIO_BLK_F_MQ);
    bzero(&block_config_, sizeof(block_config_));
  }

  virtual void Disconnect() {
    if (image_) {
      VirtioPci::Disconnect();
      delete image_;
      image_ = nullptr;
    }
  }

  virtual void Connect() {
    /* Connect to backend image */
    bool readonly = has_key("readonly") && std::get<bool>(key_values_["readonly"]);
    bool snapshot = has_key("snapshot") && std::get<bool>(key_values_["snapshot"]);
    if (has_key("image")) {
      std::string path = std::get<std::string>(key_values_["image"]);
      image_ = DiskImage::Create(this, path, readonly, snapshot);

      /* Qcow2 supports disacard & write zeros */
      if (path.find(".qcow2") != std::string::npos) {
        device_features_ |=  (1UL << VIRTIO_BLK_F_DISCARD) | (1UL << VIRTIO_BLK_F_WRITE_ZEROES);
      }
    }
    if (image_) {
      VirtioPci::Connect();

      InitializeGeometry();
      if (readonly) {
        device_features_ |= VIRTIO_BLK_F_RO;
      }
    }
  }

  virtual bool LoadState(MigrationReader* reader) {
    if (!VirtioPci::LoadState(reader)) {
      return false;
    }

    // Reset image file for network migration
    if (dynamic_cast<MigrationNetworkReader*>(reader)) {
      auto image = dynamic_cast<Qcow2Image*>(image_);
      if (image) {
        image->Reset();
      }
    }
    return true;
  }

  void InitializeGeometry() {
    auto information = image_->information();
    block_config_.capacity = information.total_blocks;
    block_config_.blk_size = information.block_size;

    block_config_.num_queues = manager_->machine()->num_vcpus();
    block_config_.seg_max = DEFAULT_QUEUE_SIZE - 2;
    block_config_.wce = 1; // write back (enable cache)
    block_config_.max_discard_sectors = __INT_MAX__ / block_config_.blk_size;
    block_config_.max_discard_seg = 1;
    block_config_.discard_sector_alignment = 1;
    block_config_.max_write_zeroes_sectors = block_config_.max_discard_sectors;
    block_config_.max_write_zeroes_seg = block_config_.max_discard_seg;
    block_config_.write_zeroes_may_unmap = 1;
  }

  void Reset() {
    /* Reset all queues */
    VirtioPci::Reset();
  
    for (int i = 0; i < block_config_.num_queues; ++i) {
      AddQueue(DEFAULT_QUEUE_SIZE, std::bind(&VirtioBlock::OnOutput, this, i));
    }
  }

  void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(block_config_));
    memcpy(data, (uint8_t*)&block_config_ + offset, size);
  }

  void OnOutput(int queue_index) {
    auto &vq = queues_[queue_index];

    while (auto element = PopQueue(vq)) {
      HandleCommand(vq, element, [=, &vq]() {
        PushQueue(vq, element);
        NotifyQueue(vq);
      });
    }
  }

  void BlockIoAsync(VirtElement* element, size_t position, bool is_write, IoCallback callback) {
    auto vector(element->vector);
    for (auto &iov : vector) {
      void* buffer = iov.iov_base;
      size_t length = iov.iov_len;

      auto io_complete = [element, position, length, is_write, callback](auto ret) {
        if (!is_write && ret != (ssize_t)length) {
          MV_PANIC("failed IO ret=%lx pos=%lx length=%lx", ret, position, length);
        }
        if (!is_write) {
          element->length += length;
        }
        element->vector.pop_back();
        if (element->vector.empty()) {
          callback(ret == (ssize_t)length ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR);
        }
      };
      if (debug_) {
        MV_LOG("%s pos=0x%lx len=0x%lx ", is_write ? "write" : "read", position, length);
      }

      ImageIoRequest r = {
        .type = is_write ? kImageIoWrite : kImageIoRead,
        .position = position,
        .length = length
      };
      r.vector.emplace_back(iovec {
        .iov_base = buffer,
        .iov_len = length
      });
      image_->QueueIoRequest(r, std::move(io_complete));
      position += length;
    }
  }

  void HandleCommand(VirtQueue& vq, VirtElement* element, VoidCallback callback) {
    MV_UNUSED(vq);

    auto &vector = element->vector;
    /* Read block header */
    virtio_blk_outhdr* request = (virtio_blk_outhdr*)vector.front().iov_base;
    vector.pop_front();

    /* Get status header at the end of vector, currently only 1 byte */
    uint8_t* status = (uint8_t*)vector.back().iov_base;
    MV_ASSERT(vector.back().iov_len == 1);
    vector.pop_back();

    /* Set the vring data length to bytes returned */
    element->length = sizeof(*status);

    switch (request->type)
    {
    case VIRTIO_BLK_T_IN:
    case VIRTIO_BLK_T_OUT: {
      size_t position = request->sector * block_config_.blk_size;
      bool is_write = request->type == VIRTIO_BLK_T_OUT;
      BlockIoAsync(element, position, is_write, [callback = std::move(callback), status](auto ret) {
        *status = ret;
        callback();
      });
      break;
    }
    case VIRTIO_BLK_T_FLUSH: {
      ImageIoRequest r = {
        .type = kImageIoFlush
      };
      image_->QueueIoRequest(r, [callback = std::move(callback), status](ssize_t ret) {
        *status = ret == 0 ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR;
        callback();
      });
      break;
    }
    case VIRTIO_BLK_T_GET_ID: {
      auto &iov = vector.front();
      void* buffer = iov.iov_base;
      MV_ASSERT(iov.iov_len >= 20);

      strcpy((char*)buffer, "virtio-block");
      element->length += iov.iov_len;
      *status = VIRTIO_BLK_S_OK;
      callback();
      break;
    }
    case VIRTIO_BLK_T_WRITE_ZEROES:
    case VIRTIO_BLK_T_DISCARD: {
      auto &iov = vector.front();
      auto discard = (virtio_blk_discard_write_zeroes*)iov.iov_base;
      MV_ASSERT(iov.iov_len == sizeof(*discard));
      size_t position = discard->sector * block_config_.blk_size;
      size_t length = discard->num_sectors * block_config_.blk_size;

      ImageIoRequest r = {
        .type = request->type == VIRTIO_BLK_T_WRITE_ZEROES ? kImageIoWriteZeros : kImageIoDiscard,
        .position = position,
        .length = length
      };
      image_->QueueIoRequest(r, [status, callback = std::move(callback), length](auto ret) {
        *status = ret == (ssize_t)length ? VIRTIO_BLK_S_OK : VIRTIO_BLK_S_IOERR;
        callback();
      });
      break;
    }
    default:
      MV_PANIC("unhandled command type=0x%x", request->type);
      break;
    }
  }
};

DECLARE_DEVICE(VirtioBlock);

```

`devices/virtio/virtio_console.cc`:

```cc
/* 
 * MVisor VirtIO Console Device
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstring>
#include <array>
#include <functional>
#include <linux/virtio_console.h>

#include "device_interface.h"
#include "logger.h"
#include "device_manager.h"
#include "virtio_pci.h"
#include "virtio_console.pb.h"

class VirtioConsole : public VirtioPci, public SerialDeviceInterface {
 private:
  virtio_console_config             console_config_;
  std::vector<SerialPortInterface*> console_ports_;

 public:
  VirtioConsole() {
    pci_header_.class_code = 0x078000;
    pci_header_.device_id = 0x1003;
    pci_header_.subsys_id = 0x0003;
    
    AddPciBar(1, 0x1000, kIoResourceTypeMmio);
    AddMsiXCapability(1, 2, 0, 0x1000);

    /* Device specific features */
    device_features_ |= (1UL << VIRTIO_CONSOLE_F_MULTIPORT);

    bzero(&console_config_, sizeof(console_config_));
    console_config_.max_nr_ports = 1;
  }

  void Connect() {
    VirtioPci::Connect();

    for (auto object : children_) {
      SerialPortInterface* port = dynamic_cast<SerialPortInterface*>(object);
      if (port) {
        port->Initialize(this, console_ports_.size() + 1);
        console_ports_.push_back(port);
        ++console_config_.max_nr_ports;
      } else {
        MV_PANIC("%s is not a port object", object->name());
      }
    }
  }

  void Reset() {
    /* stop console port activities */
    for (auto &port: console_ports_) {
      port->set_ready(false);
    }
  
    /* Reset all queues */
    VirtioPci::Reset();
  
    CreateQueuesForPorts();
  }

  bool SaveState(MigrationWriter* writer) {
    VirtioConsoleState state;
    for (auto console_port : console_ports_) {
      auto port = state.add_ports();
      port->set_id(console_port->port_id());
      port->set_ready(console_port->ready());
    }
    writer->WriteProtobuf("VIRTIO_CONSOLE", state);
    return VirtioPci::SaveState(writer);
  }

  bool LoadState(MigrationReader* reader) {
    if (!VirtioPci::LoadState(reader)) {
      return false;
    }
    VirtioConsoleState state;
    if (!reader->ReadProtobuf("VIRTIO_CONSOLE", state)) {
      return false;
    }
    for (int i = 0; i < state.ports_size(); i++) {
      auto& port = state.ports(i);
      for (auto console_port : console_ports_) {
        if (console_port->port_id() == port.id()) {
          console_port->set_ready(port.ready());
        }
      }
    }
    return true;
  }

  void CreateQueuesForPorts() {
    AddQueue(128, std::bind(&VirtioConsole::OnPortInput, this, 0));
    AddQueue(128, std::bind(&VirtioConsole::OnPortOutput, this, 0));
    
    AddQueue(32, std::bind(&VirtioConsole::OnControlInput, this));
    AddQueue(32, std::bind(&VirtioConsole::OnControlOutput, this));

    for (uint i = 1; i < console_config_.max_nr_ports; i++) {
      AddQueue(128, std::bind(&VirtioConsole::OnPortInput, this, i));
      AddQueue(128, std::bind(&VirtioConsole::OnPortOutput, this, i));
    }
  }

  void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(console_config_));
    memcpy(data, (uint8_t*)&console_config_ + offset, size);
  }

  void OnPortInput(uint32_t id) {
    auto port = FindPortById(id);
    port->OnWritable();
  }

  void OnPortOutput(uint32_t id) {
    auto port = FindPortById(id);
    auto &vq = queues_[3 + id * 2];
  
    while (auto element = PopQueue(vq)) {
      for (auto &iov : element->vector) {
        port->OnMessage((uint8_t*)iov.iov_base, iov.iov_len);
      }
      PushQueue(vq, element);
      NotifyQueue(vq);
    }
  }

  void SendMessage(SerialPortInterface* port, uint8_t* data, size_t size) {
    auto &vq = queues_[2 + port->port_id() * 2];
    WriteBuffer(vq, data, size);
  }

  void OnControlInput() {
    /* Guest confirm control input */
  }

  void OnControlOutput() {
    auto &vq = queues_[3];
  
    while (auto element = PopQueue(vq)) {
      for (auto &iov : element->vector) {
        virtio_console_control* vcc = (virtio_console_control*)iov.iov_base;
        HandleConsoleControl(vcc);
      }
      PushQueue(vq, element);
    }
    NotifyQueue(vq);
  }

  void WriteBuffer(VirtQueue& vq, void* buffer, size_t size) {
    size_t offset = 0;
    while (offset < size) {
      auto element = PopQueue(vq);
      if (!element) {
        break;
      }
      size_t remain_bytes = size - offset;
      for (auto &iov : element->vector) {
        size_t bytes = iov.iov_len < remain_bytes ? iov.iov_len : remain_bytes;
        memcpy(iov.iov_base, (uint8_t*)buffer + offset, bytes);
        offset += bytes;
        remain_bytes -= bytes;
        element->length += bytes;
      }

      PushQueue(vq, element);
      NotifyQueue(vq);
    }
  }

  void SendControlEvent(SerialPortInterface* port, uint16_t event, uint16_t value) {
    virtio_console_control vcc = {
      .id = port->port_id(),
      .event = event,
      .value = value
    };
    WriteBuffer(queues_[2], &vcc, sizeof(vcc));
  }

  SerialPortInterface* FindPortById(uint32_t id) {
    for (auto &port: console_ports_) {
      if (port->port_id() == id) {
        return port;
      }
    }
    return nullptr;
  }

  void SendPortName(SerialPortInterface* port) {
    virtio_console_control vcc = {
      .id = port->port_id(),
      .event = VIRTIO_CONSOLE_PORT_NAME,
      .value = 1
    };
    char buffer[200] = { 0 };
    memcpy(buffer, &vcc, sizeof(vcc));
    memcpy(buffer + sizeof(vcc), port->port_name(), strlen(port->port_name()));
    WriteBuffer(queues_[2], buffer, sizeof(vcc) + strlen(port->port_name()) + 1);
  }

  void HandleConsoleControl(virtio_console_control* vcc) {
    if (vcc->event == VIRTIO_CONSOLE_DEVICE_READY) {
      if (vcc->value != 1) { /* 1 means success */
        MV_LOG("failed to initialize virtio console ret=0x%x", vcc->value);
        return;
      }
      
      for (auto &port : console_ports_) {
        SendControlEvent(port, VIRTIO_CONSOLE_PORT_ADD, 1);
      }
      return;
    }

    if (vcc->id < 1 || vcc->id > console_ports_.size()) {
      MV_LOG("invalid vcc id=%d", vcc->id);
      return;
    }
    auto port = FindPortById(vcc->id);
    switch (vcc->event)
    {
    case VIRTIO_CONSOLE_PORT_READY:
      MV_ASSERT(vcc->value == 1); /* 1 means success */
      SendPortName(port);
      SendControlEvent(port, VIRTIO_CONSOLE_PORT_OPEN, 1);
      break;
    
    case VIRTIO_CONSOLE_PORT_OPEN:
      port->set_ready(vcc->value);
      break;
    default:
      MV_PANIC("port=%d event=%d", vcc->id, vcc->event);
      break;
    }
  }
};

DECLARE_DEVICE(VirtioConsole)

```

`devices/virtio/virtio_console.proto`:

```proto
syntax = "proto3";

message VirtioConsoleState {
  message Port {
    uint32  id    = 1;
    bool    ready = 2;
  }

  repeated Port ports = 1;
}

```

`devices/virtio/virtio_fs.cc`:

```cc
/*
 * MVisor VirtIO-FS Device
 * based on libfuse3 passthrough_ll.c
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <linux/virtio_fs.h>
#include <sys/stat.h>
#include <sys/xattr.h>

#include <filesystem>

#include "device_interface.h"
#include "fuse/fuse.h"
#include "logger.h"
#include "virtio_pci.h"

// size < 1024 may cause fuse copy file crash
// https://github.com/virtio-win/kvm-guest-drivers-windows/issues/760
#define DEFAULT_QUEUE_SIZE 1024

class VirtioFs : public VirtioPci, public VirtioFsInterface {
 private:
  Fuse* fuse_ = nullptr;
  std::string mount_path_;
  virtio_fs_config fs_config_;
  std::unordered_set<uint64_t> dirp_pointer_set_;
  std::vector<VirtioFsListener> virtio_fs_listeners_;

 public:
  VirtioFs() {
    pci_header_.class_code = 0x018000;
    pci_header_.vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.device_id = 0x105A;
    pci_header_.revision_id = 0x01;

    AddPciBar(1, 0x1000, kIoResourceTypeMmio);
    device_features_ |= 0;

    // set fs config, num_request_queues > 1 cause windows vm crash
    bzero(&fs_config_, sizeof(fs_config_));
    fs_config_.num_request_queues = 1;

    AddMsiXCapability(1, fs_config_.num_request_queues + 2, 0, 0x1000);
  }

  virtual void Disconnect() {
    Reset();

    // free dir handle
    ClearDirectoryPointerSet();

    // delete Fuse object
    if (fuse_) {
      delete fuse_;
      fuse_ = nullptr;
    }

    VirtioPci::Disconnect();
  }

  virtual void Connect() {
    if (has_key("path")) {
      // init fuse
      mount_path_ = std::get<std::string>(key_values_["path"]);
      MV_ASSERT(std::filesystem::exists(mount_path_));
      MV_ASSERT(std::filesystem::is_directory(mount_path_));

      // set disk space
      auto disk_size_limit = (uint64_t)2 * 1024 * 1024 * 1024;
      if (has_key("disk_size")) {
        std::string disk_size = std::get<std::string>(key_values_["disk_size"]);
        if (disk_size.back() != 'G') {
          MV_PANIC("disk size must be aligned with 1GB");
        }
        long value = atol(disk_size.substr(0, disk_size.length() - 1).c_str());
        disk_size_limit = (1UL << 30) * value;
      }

      // set inode count limit
      uint64_t inode_count_limit = 200;
      if (has_key("inode_count")) {
        inode_count_limit = std::get<uint64_t>(key_values_["inode_count"]);
      }

      fuse_ = new Fuse(mount_path_, disk_size_limit, inode_count_limit);
      MV_ASSERT(fuse_ != nullptr);

      if (has_key("disk_name")) {
        std::string name = std::get<std::string>(key_values_["disk_name"]);
        MV_ASSERT(name.length() < sizeof(fs_config_.tag));
        strcpy((char*)fs_config_.tag, name.c_str());
      } 

      // connect
      VirtioPci::Connect();
    }
  }

  void RegisterVirtioFsListener(VirtioFsListener callback) { 
    virtio_fs_listeners_.push_back(callback); 
  }

  void NotifyVirtioFs() {
    // notify host to refresh share dir
    for (auto& callback : virtio_fs_listeners_) {
      callback();
    }
  }

  void Reset() {
    /* Reset all queues */
    VirtioPci::Reset();

    for (uint32_t i = 0; i < 1 + fs_config_.num_request_queues; ++i) {
      AddQueue(DEFAULT_QUEUE_SIZE, std::bind(&VirtioFs::OnOutput, this, i));
    }
  }

  void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(fs_config_));
    memcpy(data, (uint8_t*)&fs_config_ + offset, size);
  }

  void OnOutput(int queue_index) {
    if (fuse_ == nullptr) {
      return;
    }

    auto& vq = queues_[queue_index];
    while (auto element = PopQueue(vq)) {
      HandleCommand(element);
      PushQueue(vq, element);
    }
    NotifyQueue(vq);
  }

  void ClearDirectoryPointerSet() {
    for (auto dirp_pointer : dirp_pointer_set_) {
      closedir(((Directory*)dirp_pointer)->dp);
      delete (Directory*)dirp_pointer;
    }
    dirp_pointer_set_.clear();
  }

  void FuseInit(VirtElement* element, fuse_in_header* request) {
    fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_init_in));
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_init_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_init_out)).address;

    // set out params
    out->major = FUSE_KERNEL_VERSION;
    out->minor = FUSE_KERNEL_MINOR_VERSION;
    out->flags = FUSE_BIG_WRITES | FUSE_DO_READDIRPLUS;
    out->max_readahead = UINT32_MAX;
    out->max_write = UINT32_MAX;
    fuse_->MakeResponse(response, sizeof(fuse_init_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseStatFs(VirtElement* element, fuse_in_header* request) {
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_statfs_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_statfs_out)).address;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);

    struct statvfs new_stat_vfs;
    MV_ASSERT(fstatvfs(fd, &new_stat_vfs) != -1);

    // modify disk information to vm
    fuse_->ModifyDiskInformationToVm(&new_stat_vfs);

    fuse_->CopyStatFs(&new_stat_vfs, &out->st);
    fuse_->MakeResponse(response, sizeof(fuse_statfs_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseLookup(VirtElement* element, fuse_in_header* request) {
    auto name = (const char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_entry_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_entry_out)).address;

    struct fuse_entry_param entry_param;
    if (!fuse_->Lookup(request->nodeid, name, &entry_param)) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    } 

    out->nodeid = entry_param.ino;
    out->generation = entry_param.generation;
    out->entry_valid = fuse_->CalcTimeoutSecond(entry_param.entry_timeout);
    out->entry_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.entry_timeout);
    out->attr_valid = fuse_->CalcTimeoutSecond(entry_param.attr_timeout);
    out->attr_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.attr_timeout);
    fuse_->ConvertStatToFuseAttr(&entry_param.attr, &out->attr);
    fuse_->MakeResponse(response, sizeof(fuse_entry_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseOpen(VirtElement* element, fuse_in_header* request) {
    fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_open_in));
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_open_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_open_out)).address;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    if (fd == -1) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    out->fh = fd;
    fuse_->MakeResponse(response, sizeof(fuse_open_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseReadLink(VirtElement* element, fuse_in_header* request) {
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out_len = request->len - sizeof(fuse_in_header);
    auto out = (char*)fuse_->GetDataBufferFromIovec(element->vector, out_len).address;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);

    auto ret = readlinkat(fd, "", out, out_len);
    MV_ASSERT(ret != -1);
    fuse_->MakeResponse(response, ret, 0, request->unique);
    element->length = response->len;
  }

  void FuseRelease(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_release_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_release_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto inode = fuse_->GetInodeFromFd(in->fh);
    fuse_->MakeResponse(response, 0, inode != nullptr ? 0 : -2, request->unique);
    element->length = response->len;
  }

  void FuseOpenDir(VirtElement* element, fuse_in_header* request) {
    fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_open_in));
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_open_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_open_out)).address;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    if (fd == -1) {
      fuse_->MakeResponse(response, 0, -2, request->unique);
      element->length = response->len;
      return;
    }

    // the fd from node list is opened with flag "O_PATH" which can not be used in read dir
    auto fd_copy = openat(fd, ".", O_RDONLY);
    if (fd_copy == -1) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    // we need to remember directory pointer to release in FuseReleaseDir
    auto dirp = new Directory{ 
      .dp = fdopendir(fd_copy),
      .entry = nullptr,
      .offset = 0
    };
    MV_ASSERT(dirp != nullptr && dirp->dp != nullptr);
    dirp_pointer_set_.insert((uint64_t)dirp);

    out->fh = (uint64_t)dirp;
    fuse_->MakeResponse(response, sizeof(fuse_open_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseReleaseDir(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_release_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_release_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    if (dirp_pointer_set_.erase(in->fh)) {
      auto dirp = (Directory*)in->fh;
      closedir(dirp->dp);
      delete dirp;
    }

    fuse_->MakeResponse(response, 0, 0, request->unique);
    element->length = response->len;
  }

  void FuseReadDir(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_read_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_read_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    std::string result_buf(in->size, '\0');

    // get result buf length
    uint32_t result_buf_len = 0;

    // set result_buf_pointer to the head of result_buf
    auto result_buf_pointer = result_buf.data();

    if (!fuse_->ReadDirectory(in, request->nodeid, result_buf_pointer, &result_buf_len, request->opcode == FUSE_READDIRPLUS)) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    // init out header base size
    bzero(response, sizeof(fuse_out_header));
    response->unique = request->unique;
    response->len = sizeof(fuse_out_header);

    // loop
    while (result_buf_len > 0) {
      auto buffer = fuse_->GetDataBufferFromIovec(element->vector, 0);
      if (result_buf_len > buffer.size) {
        memcpy(buffer.address, result_buf_pointer, buffer.size);
        result_buf_len -= buffer.size;
        response->len += buffer.size;
        result_buf_pointer += buffer.size;
      } else {
        memcpy(buffer.address, result_buf_pointer, result_buf_len);
        response->len += result_buf_len;
        break;
      }
    }

    element->length = response->len;
  }

  void FuseUnlink(VirtElement* element, fuse_in_header* request) {
    auto name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    auto parent_fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(parent_fd != -1);

    // get file information
    struct stat stat;
    MV_ASSERT(fstatat(parent_fd, name, &stat, 0) != -1);

    // release inode
    auto ret = -1;
    auto inode = fuse_->GetInodeFromStat(&stat);
    if(inode) {
      ret = unlinkat(parent_fd, name, 0);
    }

    // update disk info
    if (!ret) {
      fuse_->ReleaseDiskSpace(stat.st_size);
    }
    fuse_->MakeResponse(response, 0, (ret == 0 ? 0 : -errno), request->unique);
    element->length = response->len;
  }

  /*
  * The inode's lookup count increases by one for every call to lookup. 
  * The nlookup parameter indicates by how much the lookup count should be decreased.
  */
  void FuseForget(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_forget_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_forget_in)).address;
    auto inode = fuse_->GetInode(request->nodeid);
    if(inode) {
      fuse_->UnrefInode(inode, in->nlookup);
      if (debug_) {
        MV_LOG("call forget fd=%d refcount=%d nlookup=%d", inode->fd, inode->refcount, in->nlookup);
      }
    } else {
      MV_ERROR("can't find inode nodeid=%d", request->nodeid);
    }
  }

  void FuseFlush(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_flush_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_flush_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    MV_ASSERT(fuse_->GetInodeFromFd(in->fh) != nullptr);
    fuse_->MakeResponse(response, 0, close(dup(in->fh)) == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }

  void FuseWrite(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_write_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_write_in)).address;

    // check disk space
    if (!fuse_->IsDiskSpaceLeftEnough(in->size)) {
      auto response = (fuse_out_header*)element->vector.back().iov_base;
      fuse_->MakeResponse(response, 0, -28, request->unique);
      element->length = response->len;
      return;
    }

    // check the fd from vm is valid
    auto inode = fuse_->GetInodeFromFd(in->fh);
    if (inode == nullptr) {
      auto response = (fuse_out_header*)element->vector.back().iov_base;
      fuse_->MakeResponse(response, 0, -2, request->unique);
      element->length = response->len;
      return;
    }
    
    auto remain = in->size;
    off_t offset = in->offset;
    while (remain > 0) {
      auto write_in_data_buffer = fuse_->GetDataBufferFromIovec(element->vector, 0);
      auto write_size = std::min((size_t)remain, write_in_data_buffer.size);

      auto ret = pwrite(in->fh, write_in_data_buffer.address, write_size, offset);
      if (ret != (ssize_t )write_size) {
        MV_PANIC("failed to write count=%lu ret=%d", write_size, ret);
      }

      remain -= ret;
      offset += ret;
    }
    
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_write_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_write_out)).address;

    bzero(out, sizeof(fuse_write_out));
    out->size = in->size - remain;
    fuse_->CostDiskSpace(out->size);
    fuse_->MakeResponse(response, sizeof(fuse_write_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseRead(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_read_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_read_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    fuse_->MakeResponse(response, 0, 0, request->unique);

    auto remain = in->size;
    off_t offset = in->offset;
    while (remain > 0) {
      auto read_in_data_buffer = fuse_->GetDataBufferFromIovec(element->vector, 0);
      auto read_size = std::min((size_t)remain, read_in_data_buffer.size);

      auto ret = pread(in->fh, read_in_data_buffer.address, read_size, offset);
      if (ret < 0) {
        response->error = -errno;
        MV_ERROR("failed to read count=%lu error=%d", read_size, -errno);
        break;
      } else {
        remain -= ret;
        offset += ret;
        if (ret < (ssize_t)read_size) {
          // read finish
          break;
        }
      }
    }

    response->len += in->size - remain;
    element->length = response->len;
  }

  void FuseSetAttribute(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_setattr_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_setattr_in)).address;

    struct stat stat;
    bzero(&stat, sizeof(stat));
    stat.st_mode = in->mode;
    stat.st_uid = in->uid;
    stat.st_gid = in->gid;
    stat.st_size = in->size;
    stat.st_atim.tv_sec = in->atime;
    stat.st_mtim.tv_sec = in->mtime;
    stat.st_ctim.tv_sec = in->ctime;
    stat.st_atim.tv_nsec = in->atimensec;
    stat.st_mtim.tv_nsec = in->mtimensec;
    stat.st_ctim.tv_nsec = in->ctimensec;

    if (in->valid & FATTR_FH) {
      in->valid &= ~FATTR_FH;
    }
    in->valid &= FUSE_SET_ATTR_MODE | FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID | FUSE_SET_ATTR_SIZE | FUSE_SET_ATTR_ATIME |
                 FUSE_SET_ATTR_MTIME | FUSE_SET_ATTR_ATIME_NOW | FUSE_SET_ATTR_MTIME_NOW | FUSE_SET_ATTR_CTIME;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);

    int ret = -1;
    char procname[64] = {0};
    if (in->valid & FUSE_SET_ATTR_MODE) {
      if (in->fh) {
        ret = fchmod(in->fh, stat.st_mode);
      } else {
        sprintf(procname, "/proc/self/fd/%i", fd);
        ret = chmod(procname, stat.st_mode);
      }
      MV_ASSERT(ret != -1);
    }
    if (in->valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {
      uid_t uid = (in->valid & FUSE_SET_ATTR_UID) ? stat.st_uid : (uid_t)-1;
      gid_t gid = (in->valid & FUSE_SET_ATTR_GID) ? stat.st_gid : (gid_t)-1;

      ret = fchownat(fd, "", uid, gid, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);
      MV_ASSERT(ret != -1);
    }
    if (in->valid & FUSE_SET_ATTR_SIZE) {
      if (in->fh) {
        ret = ftruncate(in->fh, stat.st_size);
      } else {
        sprintf(procname, "/proc/self/fd/%i", fd);
        ret = truncate(procname, stat.st_size);
      }
      MV_ASSERT(ret != -1);
    }
    if (in->valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {
      struct timespec tv[2];
      tv[0].tv_sec = 0;
      tv[1].tv_sec = 0;
      tv[0].tv_nsec = UTIME_OMIT;
      tv[1].tv_nsec = UTIME_OMIT;

      if (in->valid & FUSE_SET_ATTR_ATIME_NOW)
        tv[0].tv_nsec = UTIME_NOW;
      else if (in->valid & FUSE_SET_ATTR_ATIME)
        tv[0] = stat.st_atim;

      if (in->valid & FUSE_SET_ATTR_MTIME_NOW)
        tv[1].tv_nsec = UTIME_NOW;
      else if (in->valid & FUSE_SET_ATTR_MTIME)
        tv[1] = stat.st_mtim;

      if (in->fh) {
        ret = futimens(in->fh, tv);
      } else {
        sprintf(procname, "/proc/self/fd/%i", fd);
        ret = utimensat(AT_FDCWD, procname, tv, 0);
      }
      MV_ASSERT(ret != -1);
    }
  }

  void FuseGetAttribute(VirtElement* element, fuse_in_header* request) {
    if(request->opcode == FUSE_GETATTR) {
      fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_getattr_in));
    }
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_attr_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_attr_out)).address;

    int fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);

    struct stat stat;
    MV_ASSERT(fstatat(fd, "", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW) != -1);

    auto user_config = fuse_->user_config();
    out->attr_valid = fuse_->CalcTimeoutSecond(user_config.timeout);
    out->attr_valid_nsec = fuse_->CalcTimeoutNsecond(user_config.timeout);
    fuse_->ConvertStatToFuseAttr(&stat, &out->attr);
    fuse_->MakeResponse(response, sizeof(fuse_attr_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseFallocate(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_fallocate_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_fallocate_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto ret = fallocate(in->fh, FALLOC_FL_KEEP_SIZE, in->offset, in->length);
    fuse_->MakeResponse(response, 0, ret == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }

  void FuseCreate(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_create_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_create_in)).address;
    auto name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header) - sizeof(fuse_create_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto entry_out_arg = (fuse_entry_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_entry_out)).address;
    auto open_out_arg = (fuse_open_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_open_out)).address;

    if (fuse_->IsInodeListFull()) {
      MV_ERROR("inode list is full");
      fuse_->MakeResponse(response, 0, -24, request->unique);
      element->length = response->len;
      return;
    }

    auto parent_fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(parent_fd != -1);

    // create new empty file
    int fd = openat(parent_fd, name, (in->flags | O_CREAT) & ~O_NOFOLLOW, in->mode);
    if (fd == -1) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    // close fd after new empty file is created
    close(fd);

    // create new inode
    struct fuse_entry_param entry_param;
    if (!fuse_->Lookup(request->nodeid, name, &entry_param)) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    entry_out_arg->nodeid = (uintptr_t)entry_param.ino;
    entry_out_arg->generation = entry_param.generation;
    entry_out_arg->entry_valid = fuse_->CalcTimeoutSecond(entry_param.entry_timeout);
    entry_out_arg->entry_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.entry_timeout);
    entry_out_arg->attr_valid = fuse_->CalcTimeoutSecond(entry_param.attr_timeout);
    entry_out_arg->attr_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.attr_timeout);
    fuse_->ConvertStatToFuseAttr(&entry_param.attr, &entry_out_arg->attr);

    auto out_fd = fuse_->GetFdFromInode(entry_param.ino);
    MV_ASSERT(out_fd != -1);
    open_out_arg->fh = out_fd;

    fuse_->MakeResponse(response, sizeof(fuse_entry_out) + sizeof(fuse_open_out), 0, request->unique);
    element->length = response->len;
  }

  void FuseRemoveDir(VirtElement* element, fuse_in_header* request) {
    auto name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    auto parent_fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(parent_fd != -1);

    struct stat stat;
    MV_ASSERT(fstatat(parent_fd, name, &stat, 0) != -1);

    auto ret = unlinkat(parent_fd, name, AT_REMOVEDIR);
    fuse_->MakeResponse(response, 0, ret == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }

  void FuseGetXAttr(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_getxattr_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_getxattr_in)).address;
    auto name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header) - sizeof(fuse_getxattr_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_getxattr_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_getxattr_out)).address;

    char procname[64] = {0};
    auto fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);
    sprintf(procname, "/proc/self/fd/%i", fd);

    ssize_t ret = 0;
    if (in->size) {
      auto out_buf = fuse_->GetDataBufferFromIovec(element->vector, 0);
      ret = getxattr(procname, name, out_buf.address, out_buf.size);
    } else {
      ret = getxattr(procname, name, nullptr, 0);
    }
    
    if(ret == -1) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
    } else {
      out->size = ret;
      out->padding = 0;
      fuse_->MakeResponse(response, ret + sizeof(fuse_getxattr_out), 0, request->unique);
    }
    element->length = response->len;
  } 

  void FuseSetXAttr(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_setxattr_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_setxattr_in)).address;
    auto name_value = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header) - sizeof(fuse_setxattr_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

	  char procname[64] = {0};
    auto fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(fd != -1);
    sprintf(procname, "/proc/self/fd/%i", fd);

    auto name = name_value;
    auto value = name_value + strlen(name) + 1;
	  auto ret = setxattr(procname, name, value, in->size, in->flags);
    fuse_->MakeResponse(response, 0, ret == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }
  
  void FuseFSync(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_fsync_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_fsync_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    int ret = -1;
    if(in->fsync_flags & 1) {
      ret = fdatasync(in->fh);
    } else {
      ret = fsync(in->fh);
    }

    fuse_->MakeResponse(response, 0, ret == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }

  void FuseRename2(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_rename2_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_rename2_in)).address;
    auto old_name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header) - sizeof(fuse_rename2_in)).address;
    auto new_name = old_name + strlen(old_name) + 1;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    auto old_fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(old_fd != -1);
    auto new_fd = fuse_->GetFdFromInode(in->newdir);
    MV_ASSERT(new_fd != -1);

    auto ret = renameat(old_fd, old_name, new_fd, new_name);
    fuse_->MakeResponse(response, 0, ret == -1 ? -errno : 0, request->unique);
    element->length = response->len;
  }

  void FuseDestroy(VirtElement* element, fuse_in_header* request) {
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;

    // free dir handle
    ClearDirectoryPointerSet();

    // free inode list
    fuse_->ClearInodeList(false);

    fuse_->MakeResponse(response, 0, 0, request->unique);
    element->length = response->len;
  }

  void FuseMakeDir(VirtElement* element, fuse_in_header* request) {
    auto in = (fuse_mkdir_in*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_mkdir_in)).address;
    auto name = (char*)fuse_->GetDataBufferFromIovec(element->vector, request->len - sizeof(fuse_in_header) - sizeof(fuse_mkdir_in)).address;
    auto response = (fuse_out_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_out_header)).address;
    auto out = (fuse_entry_out*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_entry_out)).address;

    if (fuse_->IsInodeListFull()) {
      MV_ERROR("inode list is full");
      fuse_->MakeResponse(response, 0, -24, request->unique);
      element->length = response->len;
      return;
    }

    struct fuse_entry_param entry_param;
    auto parent_fd = fuse_->GetFdFromInode(request->nodeid);
    MV_ASSERT(parent_fd != -1);

    auto ret = mkdirat(parent_fd, name, S_IFDIR | in->mode);
    if (ret != 0 || !fuse_->Lookup(request->nodeid, name, &entry_param)) {
      fuse_->MakeResponse(response, 0, -errno, request->unique);
      element->length = response->len;
      return;
    }

    bzero(out, sizeof(fuse_entry_out));
    out->nodeid = entry_param.ino;
    out->generation = entry_param.generation;
    out->entry_valid = fuse_->CalcTimeoutSecond(entry_param.entry_timeout);
    out->entry_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.entry_timeout);
    out->attr_valid = fuse_->CalcTimeoutSecond(entry_param.attr_timeout);
    out->attr_valid_nsec = fuse_->CalcTimeoutNsecond(entry_param.attr_timeout);
    fuse_->ConvertStatToFuseAttr(&entry_param.attr, &out->attr);
    fuse_->MakeResponse(response, sizeof(fuse_entry_out), 0, request->unique);
    element->length = response->len;
  }

  void HandleCommand(VirtElement* element) {
    auto request = (fuse_in_header*)fuse_->GetDataBufferFromIovec(element->vector, sizeof(fuse_in_header)).address;

    if (debug_) {
      MV_LOG(
          "HandleCommand len=%d gid=%d opcode=%d padding=%d pid=%d uid=%d nodeid=%d unique=%d",
          request->len, request->gid, request->opcode, request->padding, request->pid, request->uid,
          request->nodeid, request->unique);
    }

    // handle command
    switch (request->opcode) {
      case FUSE_INIT:
        FuseInit(element, request);
        break;
      case FUSE_STATFS:
        FuseStatFs(element, request);
        break;
      case FUSE_LOOKUP:
        FuseLookup(element, request);
        break;
      case FUSE_READLINK:
        FuseReadLink(element, request);
        break;
      case FUSE_OPEN:
        FuseOpen(element, request);
        break;
      case FUSE_RELEASE:
        FuseRelease(element, request);
        break;
      case FUSE_OPENDIR:
        FuseOpenDir(element, request);
        break;
      case FUSE_RELEASEDIR:
        FuseReleaseDir(element, request);
        break;
      case FUSE_READDIR:
      case FUSE_READDIRPLUS:
        FuseReadDir(element, request);
        break;
      case FUSE_READ:
        FuseRead(element, request);
        break;
      case FUSE_UNLINK:
        FuseUnlink(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_FORGET:
        FuseForget(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_FLUSH:
        FuseFlush(element, request);
        break;
      case FUSE_WRITE:
        FuseWrite(element, request);
        break;
      case FUSE_SETATTR:
        FuseSetAttribute(element, request);
        NotifyVirtioFs();
        // fall through
      case FUSE_GETATTR:
        FuseGetAttribute(element, request);
        break;
      case FUSE_FALLOCATE:
        FuseFallocate(element, request);
        break;
      case FUSE_CREATE:
        FuseCreate(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_RMDIR:
        FuseRemoveDir(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_RENAME:
      case FUSE_RENAME2:
        FuseRename2(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_MKDIR:
        FuseMakeDir(element, request);
        NotifyVirtioFs();
        break;
      case FUSE_GETXATTR:
        FuseGetXAttr(element, request);
        break;
      case FUSE_SETXATTR:
        FuseSetXAttr(element, request);
        break;
      case FUSE_FSYNC:
        FuseFSync(element, request);
        break;
      case FUSE_DESTROY:
        FuseDestroy(element, request);
        break;
      default:
        MV_ERROR("no implement opcode=%d", request->opcode);
        auto response = (fuse_out_header*)element->vector.front().iov_base;
        fuse_->MakeResponse(response, 0, -EACCES, request->unique);
        element->length = response->len;
        break;
    }
  }
};

DECLARE_DEVICE(VirtioFs);

```

`devices/virtio/virtio_network.cc`:

```cc
/* 
 * MVisor VirtIO Network Device
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "virtio_pci.h"
#include <cstring>
#include <cstdlib>
#include <set>
#include "linuz/virtio_net.h"
#include "device_interface.h"
#include "logger.h"


class VirtioNetwork : public VirtioPci, public NetworkDeviceInterface {
 private:
  virtio_net_config         net_config_;
  std::set<MacAddress>      mac_table_;
  NetworkBackendInterface*  backend_ = nullptr;

 public:
  VirtioNetwork() {
    pci_header_.class_code = 0x020000;
    pci_header_.device_id = 0x1000;
    pci_header_.subsys_id = 0x0001;
    
    AddPciBar(1, 0x1000, kIoResourceTypeMmio);
    AddMsiXCapability(1, 4, 0, 0x1000);
    
    device_features_ |=
      (1UL << VIRTIO_NET_F_MTU) |
      (1UL << VIRTIO_NET_F_MAC) |
      (1UL << VIRTIO_NET_F_STATUS) |
      (1UL << VIRTIO_NET_F_CTRL_VQ) |
      // (1UL << VIRTIO_F_ANY_LAYOUT) |
      (1UL << VIRTIO_NET_F_SPEED_DUPLEX) |
      (1UL << VIRTIO_NET_F_GUEST_ANNOUNCE);

    bzero(&net_config_, sizeof(net_config_));
    GenerateRandomMac(net_config_.mac);
    net_config_.status = VIRTIO_NET_S_LINK_UP;
    net_config_.duplex = 1;
    net_config_.speed = 1000;

    /* use big packet */
    net_config_.mtu = 4080;
  }

  void GenerateRandomMac(uint8_t mac[6]) {
    mac[0] = 0x00;
    mac[1] = 0x50;
    mac[2] = 0x00;
    for (int i = 3; i < 6; i++) {
      mac[i] = rand() & 0xFF;
    }
  }

  virtual void Disconnect() {
    if (backend_) {
      delete dynamic_cast<Object*>(backend_);
      backend_ = nullptr;
    }
    VirtioPci::Disconnect();
  }

  virtual void Connect() {
    VirtioPci::Connect();

    /* Configurable MAC address */
    if (has_key("mac")) {
      uint32_t mac[6];
      std::string mac_string = std::get<std::string>(key_values_["mac"]);
      sscanf(mac_string.c_str(), "%02x:%02x:%02x:%02x:%02x:%02x", &mac[0], &mac[1], &mac[2],
        &mac[3], &mac[4], &mac[5]);
      for (int i = 0; i < 6; i++)
        net_config_.mac[i] = mac[i];
    }
    /* Check user network or tap network */
    if (has_key("backend")) {
      std::string network_type = std::get<std::string>(key_values_["backend"]);
      backend_ = dynamic_cast<NetworkBackendInterface*>(Object::Create(network_type.c_str()));
      MV_ASSERT(backend_);
      MacAddress mac;
      memcpy(mac.data, net_config_.mac, sizeof(mac.data));
      backend_->Initialize(this, mac);
      backend_->SetMtu(net_config_.mtu);
    } else {
      MV_PANIC("network backend is not set");
    }
  }

  void Reset() {
    /* Reset all queues */
    VirtioPci::Reset();
  
    /* MQ is not supported yet */
    AddQueue(512, std::bind(&VirtioNetwork::OnReceive, this, 0));
    AddQueue(256, std::bind(&VirtioNetwork::OnTransmit, this, 1));
    AddQueue(64, std::bind(&VirtioNetwork::OnControl, this, 2));

    backend_->Reset();
  }

  void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(net_config_));
    memcpy(data, (uint8_t*)&net_config_ + offset, size);
  }

  void WriteDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(net_config_));
    memcpy((uint8_t*)&net_config_ + offset, data, size);
  }

  void EnableQueue(uint16_t queue_index) {
    VirtioPci::EnableQueue(queue_index);

    /* Some low verison driver doesn't support MTU configuration, set it to normal value */
    if (!(driver_features_ & (1UL << VIRTIO_NET_F_MTU))) {
      net_config_.mtu = 1518;
      backend_->SetMtu(net_config_.mtu);
    }
  }

  void OnReceive(int queue_index) {
    MV_UNUSED(queue_index);
    if (backend_) {
      backend_->OnReceiveAvailable();
    }
  }

  void OnTransmit(int queue_index) {
    auto &vq = queues_[queue_index];
  
    while (auto element = PopQueue(vq)) {
      HandleTransmit(vq, element);
      PushQueue(vq, element);
    }
    NotifyQueue(vq);
  }

  void OnControl(int queue_index) {
    auto &vq = queues_[queue_index];
  
    while (auto element = PopQueue(vq)) {
      HandleControl(vq, element);
      PushQueue(vq, element);
    }
    NotifyQueue(vq);
  }


  virtual bool WriteBuffer(void* buffer, size_t size) {
    VirtQueue& vq = queues_[0];
    if (!vq.enabled) {
      /* Drop all packets if device is not ready */
      return true;
    }

    std::vector<VirtElement*> elements;

    virtio_net_hdr_v1* net_header = nullptr;
    size_t net_header_length = sizeof(*net_header);
  
    size_t offset = 0;
    while (offset < size) {
      auto element = PopQueue(vq);
      if (!element) {
        if (debug_) {
          MV_ERROR("network queue is full, queue size=%d", vq.size);
        }
        return false;
      }
      element->length = 0;

      if (offset == 0) {
        /* Prepend virtio net header to the buffer vector*/
        auto &iov = element->vector.front();
        net_header = (virtio_net_hdr_v1*)iov.iov_base;
        bzero(net_header, net_header_length);
        element->length += net_header_length;

        /* Big packet mode has standalone buffer for virtio net header */ 
        if (iov.iov_len == net_header_length) {
          element->vector.pop_front();
        } else {
          iov.iov_base = (uint8_t*)iov.iov_base + net_header_length;
          iov.iov_len -= net_header_length;
        }
      }

      size_t remain_bytes = size - offset;
      for (auto &iov : element->vector) {
        size_t bytes = iov.iov_len < remain_bytes ? iov.iov_len : remain_bytes;
        memcpy(iov.iov_base, (uint8_t*)buffer + offset, bytes);
        offset += bytes;
        remain_bytes -= bytes;
        element->length += bytes;
      }

      elements.push_back(element);
      if (offset < size) {
        MV_ERROR("mergeable rxbuf mode is not supported yet. offset=%lu size=%lu mtu=%u",
          offset, size, net_config_.mtu);
      }
    }

    net_header->num_buffers = elements.size();
    PushQueueMultiple(vq, elements);
    NotifyQueue(vq);
    return true;
  }

  void HandleTransmit(VirtQueue& vq, VirtElement* element) {
    MV_UNUSED(vq);

    auto &vector = element->vector;
    MV_ASSERT(vector.size() >= 1);
    auto &front = vector.front();
    virtio_net_hdr_v1* header = (virtio_net_hdr_v1*)front.iov_base;
    MV_ASSERT(header->gso_type == VIRTIO_NET_HDR_GSO_NONE);

    if (front.iov_len == sizeof(*header)) {
      vector.pop_front();
    } else {
      front.iov_base = &header[1];
      front.iov_len -= sizeof(*header);
    }
    backend_->OnFrameFromGuest(vector);
  }

  void HandleControl(VirtQueue& vq, VirtElement* element) {
    MV_UNUSED(vq);

    auto &vector = element->vector;
    MV_ASSERT(vector.size() >= 3);

    virtio_net_ctrl_hdr* control = (virtio_net_ctrl_hdr*)vector.front().iov_base;
    vector.pop_front();

    if (debug_) {
      MV_LOG("control cls=0x%x cmd=0x%x vector size=%d", control->cls, control->cmd, vector.size());
    }

    uint8_t* status = (uint8_t*)vector.back().iov_base;
    MV_ASSERT(vector.back().iov_len == 1);
    vector.pop_back();

    element->length = sizeof(*status);
    auto &iov = vector.front();

    switch (control->cls)
    {
    case VIRTIO_NET_CTRL_RX_NOBCAST:
      if (debug_) {
        MV_LOG("no broadcast");
      }
      *status = VIRTIO_NET_OK;
      break;
    default:
      *status = VIRTIO_NET_ERR;
      MV_HEXDUMP("control packet", iov.iov_base, iov.iov_len);
      MV_PANIC("unhandled control class=0x%x command=0x%x", control->cls, control->cmd);
      break;
    }
  }
};

DECLARE_DEVICE(VirtioNetwork);

```

`devices/virtio/virtio_pci.cc`:

```cc
/* 
 * MVisor VirtIO PCI class
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "virtio_pci.h"

#include <cstring>
#include <linux/virtio_config.h>

#include "logger.h"
#include "device_manager.h"
#include "virtio_pci.pb.h"

VirtioPci::VirtioPci() {
    pci_header_.vendor_id = 0x1AF4;
    pci_header_.subsys_vendor_id = 0x1AF4;
    pci_header_.command = PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER;
    pci_header_.irq_pin = 1;

    AddPciBar(0, 0x40, kIoResourceTypePio);
    AddPciBar(4, 0x4000, kIoResourceTypeMmio);

    uint8_t cap_common_config[] = {
      0x10, 0x01, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00
    };
    uint8_t cap_isr_status[] = {
      0x10, 0x03, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x10, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00
    };
    uint8_t cap_device_config[] = {
      0x10, 0x04, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x20, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00
    };
    uint8_t cap_notification[] = {
      0x14, 0x02, 0x04, 0x00, 0x00, 0x00,
      0x00, 0x30, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,
      0x04, 0x00, 0x00, 0x00
    };
    uint8_t cap_pci_config_access[] = {
      0x14, 0x05, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00
    };
    AddCapability(0x09, cap_common_config, sizeof(cap_common_config));
    AddCapability(0x09, cap_isr_status, sizeof(cap_isr_status));
    AddCapability(0x09, cap_device_config, sizeof(cap_device_config));
    AddCapability(0x09, cap_notification, sizeof(cap_notification));
    AddCapability(0x09, cap_pci_config_access, sizeof(cap_pci_config_access));

    bzero(&common_config_, sizeof(common_config_));
    /* Device common features */
    device_features_ = (1UL << VIRTIO_RING_F_INDIRECT_DESC) | (1UL << VIRTIO_RING_F_EVENT_IDX) | \
      (1UL << VIRTIO_F_VERSION_1);
    driver_features_ = 0;

    common_config_.num_queues = queues_.size();
    use_ioevent_ = true;
}

void VirtioPci::Disconnect() {
  if (use_ioevent_) {
    for (uint index = 0; index < queues_.size(); index++) {
      if (queues_[index].enabled) {
        uint64_t notify_address = pci_bars_[4].address + 0x3000 + index * 4;
        manager_->UnregisterIoEvent(this, kIoResourceTypeMmio, notify_address);
      }
    }
  }
  PciDevice::Disconnect();
}

void VirtioPci::Reset() {
  PciDevice::Reset();
  isr_status_ = 0;
  for (uint index = 0; index < queues_.size(); index++) {
    queues_[index].index = index;
    if (queues_[index].enabled && use_ioevent_) {
      uint64_t notify_address = pci_bars_[4].address + 0x3000 + index * 4;
      manager_->UnregisterIoEvent(this, kIoResourceTypeMmio, notify_address);
    }
    queues_[index].enabled = false;
    queues_[index].size = 0;
  }
}

bool VirtioPci::SaveState(MigrationWriter* writer) {
  VirtioPciState state;
  auto common = state.mutable_common_config();
  common->set_guest_feature(driver_features_);
  common->set_msix_config(common_config_.msix_config);
  common->set_device_status(common_config_.device_status);
  common->set_queue_select(common_config_.queue_select);

  for (uint index = 0; index < queues_.size(); index++) {
    auto q = state.add_queues();
    q->set_enabled(queues_[index].enabled);
    q->set_msix_vector(queues_[index].msix_vector);
    q->set_size(queues_[index].size);
    q->set_last_available_index(queues_[index].last_available_index);
    q->set_descriptor_table_address(queues_[index].descriptor_table_address);
    q->set_available_ring_address(queues_[index].available_ring_address);
    q->set_used_ring_address(queues_[index].used_ring_address);

    if (dynamic_cast<MigrationNetworkWriter*>(writer)) {
      manager_->AddDirtyMemory(queues_[index].used_ring_address, sizeof(VRingUsed) + queues_[index].size * sizeof(VRingUsedElement));
    }
  }
  state.set_isr_status(isr_status_);
  writer->WriteProtobuf("VIRTIO_PCI", state);
  return PciDevice::SaveState(writer);
}

bool VirtioPci::LoadState(MigrationReader* reader) {
  if (!PciDevice::LoadState(reader)) {
    return false;
  }
  VirtioPciState state;
  if (!reader->ReadProtobuf("VIRTIO_PCI", state)) {
    return false;
  }
  auto& common = state.common_config();
  driver_features_ = common.guest_feature();
  common_config_.msix_config = common.msix_config();
  common_config_.device_status = common.device_status();
  common_config_.queue_select = common.queue_select();
  
  for (uint index = 0; index < queues_.size(); index++) {
    auto& q = state.queues(index);
    queues_[index].msix_vector = q.msix_vector();
    queues_[index].size = q.size();
    queues_[index].last_available_index = q.last_available_index();
    queues_[index].descriptor_table_address = q.descriptor_table_address();
    queues_[index].available_ring_address = q.available_ring_address();
    queues_[index].used_ring_address = q.used_ring_address();
    if (q.enabled()) {
      EnableQueue(index);
    }
  }
  isr_status_ = state.isr_status();
  return true;
}

void VirtioPci::PrintQueue(VirtQueue& vq) {
  MV_LOG("queue index=%d size=%d descriptors: ", vq.index, vq.size);
  for (int i = 0; i < vq.size; i++) {
    auto descriptor = &vq.descriptor_table[i];
    MV_LOG("descriptor address=0x%lx length=%x flags=%x next=%x", descriptor->address,
      descriptor->length, descriptor->flags, descriptor->next);
  }
  MV_LOG("avalable flags=%x index=%x: ", vq.available_ring->flags, vq.available_ring->index);
  for (int i = 0; i < vq.size; i++) {
    auto element = vq.available_ring->items[i];
    MV_LOG("avalable ring[%d]=%u", i, element);
  }
  MV_LOG("used flags=%x index=%x: ", vq.used_ring->flags, vq.used_ring->index);
  for (int i = 0; i < vq.size; i++) {
    auto &element = vq.used_ring->items[i];
    MV_LOG("used ring[%d] id=%u length=%u", i, element.id, element.length);
  }
}

void VirtioPci::AddDescriptorToElement(VirtElement& element,  VRingDescriptor* descriptor) {
  void* host = manager_->TranslateGuestMemory(descriptor->address);
  element.vector.push_back(iovec {
    .iov_base = host,
    .iov_len = descriptor->length
  });
  element.size += descriptor->length;

  if (descriptor->flags & VRING_DESC_F_WRITE) {
    manager_->AddDirtyMemory(descriptor->address, descriptor->length);
  }
}

void VirtioPci::ReadIndirectDescriptorTable(VirtElement& element, VRingDescriptor* table) {
  VRingDescriptor* descriptor = &table[0];
  while (true) {
    AddDescriptorToElement(element, descriptor);
    if ((descriptor->flags & VRING_DESC_F_NEXT) == 0) {
      break;
    }
    descriptor = &table[descriptor->next];
  }
}

VirtElement* VirtioPci::PopQueue(VirtQueue& vq) {
  if (vq.available_ring->index == vq.last_available_index) {
    return nullptr;
  }
  asm volatile ("mfence": : :"memory");

  auto element = new VirtElement;
  element->Initialize();

  auto item = vq.available_ring->items[vq.last_available_index++ % vq.size];
  if (driver_features_ & (1 << VIRTIO_RING_F_EVENT_IDX)) {
    void* end = &vq.used_ring->items[vq.size];
    *(uint16_t*)end = vq.last_available_index;
  }

  VRingDescriptor* descriptor = &vq.descriptor_table[item];
  while (true) {
    if (descriptor->flags & VRING_DESC_F_INDIRECT) {
      VRingDescriptor* table = (VRingDescriptor*)manager_->TranslateGuestMemory(descriptor->address);
      ReadIndirectDescriptorTable(*element, table);
    } else {
      AddDescriptorToElement(*element, descriptor);
    }
    if ((descriptor->flags & VRING_DESC_F_NEXT) == 0) {
      break;
    }
    descriptor = &vq.descriptor_table[descriptor->next];
  }

  element->id = item;
  element->length = 0;
  return element;
}

void VirtioPci::PushQueue(VirtQueue& vq, VirtElement* element) {
  auto &item = vq.used_ring->items[vq.used_ring->index % vq.size];
  item.id = element->id;
  item.length = element->length;
  delete element;

  /* Make sure other vCPU could see the buffer before we update index. */
  asm volatile ("sfence": : :"memory");

  ++vq.used_ring->index;
}

void VirtioPci::PushQueueMultiple(VirtQueue& vq, std::vector<VirtElement*>& elements) {
  auto index = vq.used_ring->index;
  for (auto element : elements) {
    auto &item = vq.used_ring->items[index++ % vq.size];
    item.id = element->id;
    item.length = element->length;
    delete element;
  }

  /* Make sure other vCPU could see the buffer before we update index. */
  asm volatile ("sfence": : :"memory");

  vq.used_ring->index = index;
}

void VirtioPci::NotifyQueue(VirtQueue& vq) {
  asm volatile ("mfence": : :"memory");

  if (driver_features_ & (1 << VIRTIO_RING_F_EVENT_IDX)) {
    /* Carefully handle the overflow */
    uint16_t compare = vq.used_ring->index - vq.available_ring->items[vq.size];
    if (compare != 1) {
      return;
    }
  } else if (vq.available_ring->flags & VRING_AVAIL_F_NO_INTERRUPT) {
    return;
  }

  /* Set queue interrupt bit */
  isr_status_ = 1;
  /* Make sure MSI X Enabled */
  if (vq.msix_vector == VIRTIO_MSI_NO_VECTOR) {
    return;
  }
  if (msi_config_.enabled) {
    SignalMsi(vq.msix_vector);
  } else if (pci_header_.irq_pin) {
    SetIrq(isr_status_ & 1);
  }
}

void VirtioPci::AddQueue(uint16_t queue_size, VoidCallback callback) {
  for (auto &vq : queues_) {
    if (vq.size != 0)
      continue;
    vq.size = queue_size;
    vq.notification_callback = callback;
    vq.descriptor_table = nullptr;
    vq.available_ring = nullptr;
    vq.used_ring = nullptr;
    vq.enabled = false;
    vq.last_available_index = 0;
    return;
  }
  MV_PANIC("exceeded queue size");
}

void VirtioPci::EnableQueue(uint16_t queue_index) {
  auto &vq = queues_[queue_index];
  MV_ASSERT(!vq.enabled);
  vq.descriptor_table = (VRingDescriptor*)manager_->TranslateGuestMemory(vq.descriptor_table_address);
  vq.available_ring = (VRingAvailable*)manager_->TranslateGuestMemory(vq.available_ring_address);
  vq.used_ring = (VRingUsed*)manager_->TranslateGuestMemory(vq.used_ring_address);
  MV_ASSERT(vq.descriptor_table && vq.available_ring && vq.used_ring);

  if (use_ioevent_) {
    uint64_t notify_address = pci_bars_[4].address + 0x3000 + queue_index * 4;
    manager_->RegisterIoEvent(this, kIoResourceTypeMmio, notify_address);
  }

  vq.enabled = true;
}

void VirtioPci::WriteCommonConfig(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_ASSERT(offset + size <= sizeof(common_config_));
  memcpy((uint8_t*)&common_config_ + offset, data, size);
  switch (offset)
  {
  case VIRTIO_PCI_COMMON_STATUS:
    if (!common_config_.device_status) {
      Reset();
    }
    break;
  case VIRTIO_PCI_COMMON_GF:
    if (common_config_.guest_feature_select == 0) {
      uint32_t value = *(uint32_t*)data;
      driver_features_ = (driver_features_ & ~0xFFFFFFFFULL) | value;
    } else {
      uint32_t value = *(uint32_t*)data;
      driver_features_ = (driver_features_ & 0xFFFFFFFFULL) | (uint64_t(value) << 32);
    }
    break;
  }

  if (offset >= VIRTIO_PCI_COMMON_Q_SIZE) {
    auto& vq = queues_[common_config_.queue_select];
    switch (offset)
    {
    case VIRTIO_PCI_COMMON_Q_SIZE:
      vq.size = *(uint32_t*)data;
      break;
    case VIRTIO_PCI_COMMON_Q_AVAILHI:
    case VIRTIO_PCI_COMMON_Q_AVAILLO:
      vq.available_ring_address = ((uint64_t)common_config_.queue_avail_hi << 32) | common_config_.queue_avail_lo;
      break;
    case VIRTIO_PCI_COMMON_Q_USEDHI:
    case VIRTIO_PCI_COMMON_Q_USEDLO:
      vq.used_ring_address = ((uint64_t)common_config_.queue_used_hi << 32) | common_config_.queue_used_lo;
      break;
    case VIRTIO_PCI_COMMON_Q_DESCHI:
    case VIRTIO_PCI_COMMON_Q_DESCLO:
      vq.descriptor_table_address = ((uint64_t)common_config_.queue_desc_hi << 32) | common_config_.queue_desc_lo;
      break;
    case VIRTIO_PCI_COMMON_Q_MSIX: 
      vq.msix_vector = common_config_.queue_msix_vector;
      break;
    case VIRTIO_PCI_COMMON_Q_ENABLE:
      if (common_config_.queue_enable == 1) {
        EnableQueue(common_config_.queue_select);
      } else {
        MV_PANIC("%s not implemented disable queue %d", name_, common_config_.queue_select);
      }
      break;
    }
  }
}

void VirtioPci::ReadCommonConfig(uint64_t offset, uint8_t* data, uint32_t size) {
  uint64_t value = 0;
  switch (offset)
  {
  case VIRTIO_PCI_COMMON_DF:
    if (common_config_.device_feature_select == 0) {
      value = (uint32_t)device_features_;
    } else {
      value = (uint32_t)(device_features_ >> 32);
    }
    break;
  case VIRTIO_PCI_COMMON_MSIX:
    value = common_config_.msix_config;
    break;
  case VIRTIO_PCI_COMMON_STATUS:
    value = common_config_.device_status;
    break;
  case VIRTIO_PCI_COMMON_CFGGENERATION:
    value = common_config_.config_generation;
    break;
  case VIRTIO_PCI_COMMON_NUMQ:
    value = common_config_.num_queues;
    break;
  case VIRTIO_PCI_COMMON_Q_NOFF:
    value = common_config_.queue_select;
    break;
  case VIRTIO_PCI_COMMON_Q_SIZE:
    value = queues_[common_config_.queue_select].size;
    break;
  case VIRTIO_PCI_COMMON_Q_MSIX:
    value = queues_[common_config_.queue_select].msix_vector;
    break;
  case VIRTIO_PCI_COMMON_Q_ENABLE:
    value = queues_[common_config_.queue_select].enabled;
    break;
  default:
    MV_PANIC("unhandled read offset=0x%lx size=%x", offset, size);
    break;
  }
  memcpy(data, &value, size);
}

void VirtioPci::ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_UNUSED(data);
  MV_PANIC("%s not implemented read device offset=0x%lx size=%d",
    name_, offset, size);
}

void VirtioPci::WriteDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_PANIC("%s not implemented write device offset=0x%lx data=0x%lx size=%d",
    name_, offset, *(uint64_t*)data, size);
}

void VirtioPci::WriteNotification(uint64_t offset, uint8_t* data, uint32_t size) {
  MV_UNUSED(data);
  MV_UNUSED(size);

  uint16_t queue = offset / 4;
  MV_ASSERT(queue < queues_.size());
  auto &vq = queues_[queue];
  if (vq.enabled) {
    if (use_ioevent_) {
      vq.notification_callback();
    } else {
      Schedule(vq.notification_callback);
    }
  } else {
    MV_LOG("%s queue %u is not enabled", name_, queue);
  }
}

void VirtioPci::Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[4].address) {
    if (offset < 0x1000) { /* Common config */
      WriteCommonConfig(offset, data, size);
    } else if (offset < 0x2000) { /* ISR Status */
    } else if (offset < 0x3000) { /* Device config */
      WriteDeviceConfig(offset - 0x2000, data, size);
    } else if (offset < 0x4000) { /* Notification */
      WriteNotification(offset - 0x3000, data, size);
    }
  } else if (resource->base == pci_bars_[0].address) {
    /* ignore legacy driver writes */
  } else {
    PciDevice::Write(resource, offset, data, size);
  }
}

void VirtioPci::Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size) {
  if (resource->base == pci_bars_[4].address) {
    if (offset < 0x1000) { /* Common config */
      ReadCommonConfig(offset, data, size);
    } else if (offset < 0x2000) { /* ISR Status */
      *data = isr_status_;
      isr_status_ = 0;
      SetIrq(0);
    } else if (offset < 0x3000) { /* Device config */
      ReadDeviceConfig(offset - 0x2000, data, size);
    } else if (offset < 0x4000) { /* Notification */
    }
  } else if (resource->base == pci_bars_[0].address) {
    /* let legacy driver fail */
    bzero(data, size);
  } else {
    PciDevice::Read(resource, offset, data, size);
  }
}


```

`devices/virtio/virtio_pci.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_VIRTIO_PCI_H
#define _MVISOR_DEVICES_VIRTIO_PCI_H

#include "pci_device.h"

#include <linux/virtio_pci.h>
#include <sys/uio.h>
#include <deque>

/* We support indirect buffer descriptors */
#define VIRTIO_RING_F_INDIRECT_DESC  28

/* The Guest publishes the used index for which it expects an interrupt
 * at the end of the avail ring. Host should ignore the avail->flags field. */
/* The Host publishes the avail index for which it expects a kick
 * at the end of the used ring. Guest should ignore the used->flags field. */
#define VIRTIO_RING_F_EVENT_IDX      29


/* Virtio ring descriptors: 16 bytes.  These can chain together via "next". */
struct VRingDescriptor {
  /* Address (guest-physical). */
  uint64_t address;
  /* Length. */
  uint32_t length;

/* This marks a buffer as continuing via the next field. */
#define VRING_DESC_F_NEXT  1
/* This marks a buffer as write-only (otherwise read-only). */
#define VRING_DESC_F_WRITE  2
/* This means the buffer contains a list of buffer descriptors. */
#define VRING_DESC_F_INDIRECT  4
  /* The flags as indicated above. */
  uint16_t flags;
  /* We chain unused descriptors via this, too */
  uint16_t next;
} __attribute__((packed));

struct VRingAvailable {
/* The Guest uses this in avail->flags to advise the Host: don't interrupt me
 * when you consume a buffer.  It's unreliable, so it's simply an
 * optimization.  */
#define VRING_AVAIL_F_NO_INTERRUPT  1
  uint16_t flags;
  uint16_t index;
  uint16_t items[];
} __attribute__((packed));

/* u32 is used here for ids for padding reasons. */
struct VRingUsedElement {
  /* Index of start of used descriptor chain. */
  uint32_t id;
  /* Total length of the descriptor chain which was used (written to) */
  uint32_t length;
} __attribute__((packed));

struct VRingUsed {
/* The Host uses this in used->flags to advise the Guest: don't kick me when
 * you add a buffer.  It's unreliable, so it's simply an optimization.  Guest
 * will still kick if it's out of buffers. */
#define VRING_USED_F_NO_NOTIFY  1
  uint16_t flags;
  uint16_t index;
  struct VRingUsedElement items[];
} __attribute__((packed));


typedef std::function<void (void)> VoidCallback;
struct VirtQueue {
  bool              enabled = false;
  int               msix_vector;
  VoidCallback      notification_callback;
  
  int               index;
  int               size;
  VRingDescriptor*  descriptor_table;
  VRingAvailable*   available_ring;
  VRingUsed*        used_ring;
  uint16_t          last_available_index;
  uint64_t          descriptor_table_address;
  uint64_t          available_ring_address;
  uint64_t          used_ring_address;
};

struct VirtElement {
  int                       id;
  uint32_t                  length;
  std::deque<struct iovec>  vector;
  size_t                    size;

  void Initialize() {
    id = length = size = 0;
    vector.clear();
  }

 private:
  /* disallow const copy */
  const VirtElement& operator=(const VirtElement&);
};

class VirtioPci : public PciDevice {
 public:
  VirtioPci();
  virtual void Disconnect();
  virtual void Reset();
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

 private:
  void ReadIndirectDescriptorTable(VirtElement& element, VRingDescriptor* table);
  void AddDescriptorToElement(VirtElement& element,  VRingDescriptor* descriptor);
  void ReadCommonConfig(uint64_t offset, uint8_t* data, uint32_t size);
  void WriteCommonConfig(uint64_t offset, uint8_t* data, uint32_t size);
  void WriteNotification(uint64_t offset, uint8_t* data, uint32_t size);
  void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);

 protected: 
  void PrintQueue(VirtQueue& vq);
  VirtElement* PopQueue(VirtQueue& vq);
  void PushQueue(VirtQueue& vq, VirtElement* element);
  void PushQueueMultiple(VirtQueue& vq, std::vector<VirtElement*>& elements);
  void NotifyQueue(VirtQueue& vq);
  void AddQueue(uint16_t queue_size, VoidCallback callback);
  virtual void EnableQueue(uint16_t queue_index);
  virtual void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size);
  virtual void WriteDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size);

  virtio_pci_common_cfg       common_config_;
  uint64_t                    device_features_;
  uint64_t                    driver_features_;
  std::array<VirtQueue, 64>   queues_;
  uint8_t                     isr_status_;
  bool                        use_ioevent_ = false;
};

#endif // _MVISOR_DEVICES_VIRTIO_PCI_H

```

`devices/virtio/virtio_pci.proto`:

```proto
syntax = "proto3";

message VirtioPciState {
  message CommonConfig {
    uint64  guest_feature         = 4;
    uint32  msix_config           = 5;
    uint32  device_status         = 7;
    uint32  queue_select          = 10;
  }

  message Queue {
    bool    enabled                   = 1;
    int32   msix_vector               = 2;
    int32   size                      = 4;
    uint32  last_available_index      = 5;
    uint64  descriptor_table_address  = 6;
    uint64  available_ring_address    = 7;
    uint64  used_ring_address         = 8;
  }

  CommonConfig      common_config     = 1;
  repeated Queue    queues            = 2;
  uint32            isr_status        = 3;
}

```

`devices/virtio/virtio_vgpu.cc`:

```cc
/*
 * MVisor VirtIO-VGPU Device
 * It delivers virgl3d commands from guest to host libvirglrenderer.so,
 * but it doesn't display anything for guest vm.
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "logger.h"
#include <sys/mman.h>
#include <fcntl.h>
#include <filesystem>
#include "virtio_pci.h"
#include "virtio_vgpu.h"
#include "machine.h"
#include "memory_manager.h"
#include "device_manager.h"
#include "virtio_vgpu.pb.h"

#ifdef __cplusplus
extern "C" {
  #include <virglrenderer.h>
}
#endif

struct VgpuCommand {
  uint64_t      fence_id;
  VirtQueue     &vq;
  VirtElement   *element;
};

struct VirglResource {
  uint64_t  gpa;
  size_t    size;
  struct virgl_renderer_resource_create_args args;
};

static struct virgl_renderer_callbacks vgpu_cbs = {
  .version      = 2,
  .write_fence  = virgl_write_fence,
  .get_drm_fd = virgl_get_drm_fd
};

class VirtioVgpu : public VirtioPci {
 private:
  struct vgpu_config vgpu_config_;
  IoTimer* fence_poll_timer_;
  bool initialized_;
  bool reset_;

  std::list<VgpuCommand> commands_;
  // <virgl_context_id, <virgl_resource_id, virgl_resource>>
  std::map<uint32_t, std::map<uint32_t, VirglResource>> virgl_resources_;
  // <virgl_context_id, virgl_cmd>
  std::map<uint32_t, std::vector<std::string>> virgl_cmds_;

  // base address for blob resource mapping
  uint64_t blob_memory_gpa_base_;
  // <virgl_context_id, <virgl_resource_id, MemoryRegion*>>
  std::map<uint32_t, std::map<uint32_t, const MemoryRegion*>> blob_memory_regions_;
  
 public:
  VirtioVgpu() {
    pci_header_.vendor_id = 0x1AF4;
    pci_header_.subsys_id = 0x1100;
    pci_header_.device_id = 0x105B;
    pci_header_.revision_id = 0x01;
    device_features_ |= 0;

    reset_ = false;
    initialized_ = false;

    // blob resource memory region base address
    blob_memory_gpa_base_ = 256LL << 30;

    // only support 2 queues now, one for command and another one for control
    vgpu_config_.num_queues = 2;
    // vgpu memory size must be smaller than system ram size
    vgpu_config_.memory_size = 1LL << 30;
    vgpu_config_.capabilities = VIRTGPU_PARAM_3D_FEATURES |
                                VIRTGPU_PARAM_CAPSET_QUERY_FIX |
                                VIRTGPU_PARAM_CONTEXT_INIT |
                                VIRTGPU_PARAM_SUPPORTED_CAPSET_IDs;
    // use staging to control the type of resource memory allocation
    vgpu_config_.staging = false;

    // one msi item for one queue
    MV_ASSERT(vgpu_config_.num_queues <= 4);

    AddPciBar(1, 0x1000, kIoResourceTypeMmio);
    AddMsiXCapability(1, 4, 0, 0x1000);
  }

  virtual void Disconnect() {
    VirtioPci::Disconnect();

    if (fence_poll_timer_) {
      RemoveTimer(fence_poll_timer_);
      fence_poll_timer_ = nullptr;
    }
    
    // FIXME: virgl cleanup may cause crash when the guest didn't destroy all virgl contexts in AMD gpu
    virgl_renderer_cleanup(this);
  }

  virtual void Connect() {
    if (has_key("memory")) { 
      std::string memory = std::get<std::string>(key_values_["memory"]);
      if (memory.back() != 'G') {
        MV_PANIC("memory size must be aligned with 1GB");
      }
      auto value = atol(memory.substr(0, memory.length() - 1).c_str());
      vgpu_config_.memory_size = (1UL << 30) * value;
    }

    if (has_key("blob") && std::get<bool>(key_values_["blob"])) {
      // add experimental feature blob support
      vgpu_config_.capabilities |= VIRTGPU_PARAM_RESOURCE_BLOB | VIRTGPU_PARAM_HOST_VISIBLE;
    }

    if (has_key("staging")) {
      vgpu_config_.staging = std::get<bool>(key_values_["staging"]);
    }

    // get num_capsets from virglrenderer
    uint32_t capset2_max_ver = 0, capset2_max_size = 0;
    virgl_renderer_get_cap_set(VIRTIO_GPU_CAPSET_VIRGL2, &capset2_max_ver, &capset2_max_size);
    vgpu_config_.num_capsets = capset2_max_ver > 0 ? 2 : 1;

    // check fences and call write_fence callback
    fence_poll_timer_ = AddTimer(1, true, [this]() {
      if (!commands_.empty()) {
        virgl_renderer_poll();
      }
    });

    VirtioPci::Connect();
  }

  void WriteFence(uint32_t fence_id) {
    for (auto it = commands_.begin(); it != commands_.end();) {
      if (it->fence_id > fence_id) {
        it++;
      } else {
        PushQueue(it->vq, it->element);
        NotifyQueue(it->vq);
        it = commands_.erase(it);
      }
    }
  }

  int GetDrmFd() {
    std::string node;
    if (has_key("node")) { 
      node = std::get<std::string>(key_values_["node"]);
    } else {
      std::vector<std::string> render_nodes;
      for (auto& entry : std::filesystem::directory_iterator("/dev/dri")) {
        if (entry.is_directory()) {
          continue;
        }

        auto filename = entry.path().filename().string();
        if (filename.length() > 8 && filename.substr(0, 7) == "renderD") {
          render_nodes.push_back(entry.path().string());
        }
      }
      MV_ASSERT(render_nodes.size() > 0);
      node = render_nodes[getpid() % render_nodes.size()];
    }

    auto fd = open(node.c_str(), O_RDWR | O_CLOEXEC | O_NOCTTY | O_NONBLOCK);
    if (fd < 0) {
      MV_PANIC("open render node=%s failed", node.c_str());
    }
    return fd;
  }

  void Reset() {
    VirtioPci::Reset();

    for (uint32_t i = 0; i < vgpu_config_.num_queues; ++i) {
      // mesa->virglrederer need a large queue to produce/consume commands 
      AddQueue(1024 * 32, std::bind(&VirtioVgpu::OnOutput, this, i));
    }
    reset_ = true;
  }

  void ReadDeviceConfig(uint64_t offset, uint8_t* data, uint32_t size) {
    MV_ASSERT(offset + size <= sizeof(vgpu_config_));
    memcpy(data, (uint8_t*)&vgpu_config_ + offset, size);
  }

  void OnOutput(int queue_index) {
    bool notify = false;
    auto& vq = queues_[queue_index];

    while (auto element = PopQueue(vq)) {
      auto fence_id = HandleCommand(element);
      if (fence_id == 0) {
        PushQueue(vq, element);
        notify = true;
      } else {
        commands_.emplace_back(VgpuCommand {
          .fence_id = fence_id,
          .vq = vq,
          .element = element
        });
      }
    }

    if (notify) {
      NotifyQueue(vq);
    }
  }

  void HandleVirglCommand(void* buf, size_t size, VirglCommandCallback callback) {
    uint32_t index = 0;
    uint32_t *cmd_buf = (uint32_t*)buf;
    uint32_t cmd_count = size / sizeof(uint32_t);
    while (index < cmd_count) {
      uint32_t *cmd = &cmd_buf[index];
      uint32_t len = cmd[0] >> 16;
      callback(cmd);
      index += len + 1;
    }
  }

  inline bool VirglResourceExist(uint32_t context_id, uint32_t res_handle) {
    if (virgl_resources_[context_id].find(res_handle) != virgl_resources_[context_id].end()) {
      return true;
    }
    return false;
  }

  bool SaveState(MigrationWriter* writer) {
    // no command left
    MV_ASSERT(commands_.empty());

    if (vgpu_config_.capabilities & (VIRTGPU_PARAM_RESOURCE_BLOB | VIRTGPU_PARAM_HOST_VISIBLE)) {
      MV_PANIC("host blob resource was not supported in migration");
    }

    if (vgpu_config_.capabilities & VIRTGPU_PARAM_CAPSET_QUERY_FIX) {
      // migrate guest with staging=true may cause resource data loss
      MV_ASSERT(!vgpu_config_.staging);
    }

    VirtioVgpuState state;
    size_t valid_cmd_size = 0, total_cmd_size = 0;
    for (auto iter = virgl_resources_.begin(); iter != virgl_resources_.end(); iter++) {
      auto& context_id = iter->first;
      auto& virgl_resource_map = iter->second;

      // save virgl context id
      auto context = state.add_virgl_contexts();
      context->set_context_id(context_id);

      // save virgl resource for current virgl context
      for (auto iter1 = virgl_resource_map.begin(); iter1 != virgl_resource_map.end(); iter1++) {
        auto& resource = iter1->second;
        auto item = context->add_virgl_resources();
        item->set_gpa(resource.gpa);
        item->set_size(resource.size);
        item->set_resource_args(&resource.args, sizeof(resource.args));
      }

      // save virgl cmds for current virgl context
      // iterate through cmds to get invalid information first
      std::unordered_set<uint32_t> invalid_object_handles;
      std::unordered_set<uint32_t> invalid_sub_context_ids;
      for (auto iter1 = virgl_cmds_[context_id].begin(); iter1 != virgl_cmds_[context_id].end(); iter1++) {
        HandleVirglCommand(iter1->data(), iter1->size(), [&](uint32_t* cmd) {
          uint32_t cmd_index = cmd[0] & 0xff;
          switch (cmd_index) {
            case VIRGL_CCMD_DESTROY_OBJECT:
              invalid_object_handles.insert(cmd[VIRGL_OBJ_DESTROY_HANDLE]);
              break;
            case VIRGL_CCMD_DESTROY_SUB_CTX:
              invalid_sub_context_ids.insert(cmd[1]);
            default:
              break;
          }
        });
      }

      // iterate through cmds to get valid cmds second
      for (auto iter1 = virgl_cmds_[context_id].begin(); iter1 != virgl_cmds_[context_id].end();) {
        std::string valid_cmds_str;
        total_cmd_size += iter1->size();

        // iterate
        HandleVirglCommand(iter1->data(), iter1->size(), [&, this](uint32_t* cmd) {
          bool valid = true;
          uint32_t length = cmd[0] >> 16;
          uint32_t cmd_index = cmd[0] & 0xff;
          switch (cmd_index) {
            case VIRGL_CCMD_CREATE_OBJECT: {
              uint32_t create_handle = cmd[VIRGL_OBJ_CREATE_HANDLE];
              if (invalid_object_handles.find(create_handle) != invalid_object_handles.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_BIND_OBJECT: {
              uint32_t bind_handle = cmd[VIRGL_OBJ_BIND_HANDLE];
              if (invalid_object_handles.find(bind_handle) != invalid_object_handles.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_SAMPLER_VIEWS: {
              uint32_t invalid_num = 0;
              uint32_t sampler_views_num = length - 2;
              for (size_t i = 0; i < sampler_views_num; i++) {
                if (invalid_object_handles.find(cmd[VIRGL_SET_SAMPLER_VIEWS_V0_HANDLE + i]) != invalid_object_handles.end()) {
                  cmd[VIRGL_SET_SAMPLER_VIEWS_V0_HANDLE + i] = 0;
                  invalid_num++;
                }
              }
              if (invalid_num == sampler_views_num) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_FRAMEBUFFER_STATE: {
              uint32_t zsurface_handle = cmd[VIRGL_SET_FRAMEBUFFER_STATE_NR_ZSURF_HANDLE];
              if (zsurface_handle > 0 && invalid_object_handles.find(zsurface_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }

              uint32_t invalid_count = 0;
              uint32_t surface_handle_num = cmd[VIRGL_SET_FRAMEBUFFER_STATE_NR_CBUFS];
              for (size_t i = 0; i < surface_handle_num; i++) {
                uint32_t surface_handle = cmd[VIRGL_SET_FRAMEBUFFER_STATE_CBUF_HANDLE(i)];
                if (surface_handle > 0 && invalid_object_handles.find(surface_handle) != invalid_object_handles.end()) {
                  invalid_count++;
                }
              }
              if (invalid_count == surface_handle_num) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_TRANSFER3D: {
              uint32_t res_handle = cmd[VIRGL_RESOURCE_IW_RES_HANDLE];
              if (!VirglResourceExist(context_id, res_handle)) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_BLIT: {
              uint32_t src_res_handle = cmd[VIRGL_CMD_BLIT_SRC_RES_HANDLE];
              if (!VirglResourceExist(context_id, src_res_handle)) {
                valid = false;
                break;
              }

              uint32_t dst_res_handle = cmd[VIRGL_CMD_BLIT_DST_RES_HANDLE];
              if (!VirglResourceExist(context_id, dst_res_handle)) {
                valid = false;
                break;
              }
              break;
            }
            case VIRGL_CCMD_BEGIN_QUERY: {
              uint32_t begin_query_handle = cmd[VIRGL_QUERY_BEGIN_HANDLE];
              if (invalid_object_handles.find(begin_query_handle) != invalid_object_handles.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_END_QUERY: {
              uint32_t end_query_handle = cmd[VIRGL_QUERY_END_HANDLE];
              if (invalid_object_handles.find(end_query_handle) != invalid_object_handles.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_BIND_SHADER: {
              uint32_t bind_shader_handle = cmd[VIRGL_BIND_SHADER_HANDLE];
              if (invalid_object_handles.find(bind_shader_handle) != invalid_object_handles.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_SHADER_BUFFERS: {
              uint32_t invalid_count = 0;
              uint32_t shader_buffers_num = (length - 2) / VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE;
              for (size_t i = 0; i < shader_buffers_num; i++) {
                uint32_t res_handle = cmd[VIRGL_SET_SHADER_BUFFER_RES_HANDLE(i)];
                if (!VirglResourceExist(context_id, res_handle)) {
                  invalid_count++;
                }
              }
              if (invalid_count == shader_buffers_num) {
                 valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_SHADER_IMAGES: {
              uint32_t invalid_count = 0;
              uint32_t shader_images_num = (length - 2) / VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE;
              for (size_t i = 0; i < shader_images_num; i++) {
                uint32_t res_handle = cmd[VIRGL_SET_SHADER_IMAGE_RES_HANDLE(i)];
                if (!VirglResourceExist(context_id, res_handle)) {
                  invalid_count++;
                }
              }
              if (invalid_count == shader_images_num) {
                 valid = false;
              }
              break;
            }
            case VIRGL_CCMD_LINK_SHADER: {
              uint32_t vertex_shader_handle = cmd[VIRGL_LINK_SHADER_VERTEX_HANDLE];
              if (vertex_shader_handle > 0 && invalid_object_handles.find(vertex_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }
              uint32_t fragment_shader_handle = cmd[VIRGL_LINK_SHADER_FRAGMENT_HANDLE];
              if (fragment_shader_handle > 0 && invalid_object_handles.find(fragment_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }
              uint32_t geometry_shader_handle = cmd[VIRGL_LINK_SHADER_GEOMETRY_HANDLE];
              if (geometry_shader_handle > 0 && invalid_object_handles.find(geometry_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }
              uint32_t tess_ctrl_shader_handle = cmd[VIRGL_LINK_SHADER_TESS_CTRL_HANDLE];
              if (tess_ctrl_shader_handle > 0 && invalid_object_handles.find(tess_ctrl_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }
              uint32_t tess_eval_shader_handle = cmd[VIRGL_LINK_SHADER_TESS_EVAL_HANDLE];
              if (tess_eval_shader_handle > 0 && invalid_object_handles.find(tess_eval_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              }
              uint32_t compute_shader_handle = cmd[VIRGL_LINK_SHADER_COMPUTE_HANDLE];
              if (compute_shader_handle > 0 && invalid_object_handles.find(compute_shader_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              } 
              break;
            }
            case VIRGL_CCMD_COPY_TRANSFER3D: {
              MV_PANIC("VIRGL_CCMD_COPY_TRANSFER3D was not supported in migration");
              break;
            }
            case VIRGL_CCMD_SET_RENDER_CONDITION: {
              uint32_t render_condition_handle = cmd[VIRGL_RENDER_CONDITION_HANDLE];
              if (render_condition_handle > 0 && invalid_object_handles.find(render_condition_handle) != invalid_object_handles.end()) {
                valid = false;
                break;
              } 
              break;
            }
            case VIRGL_CCMD_SET_STREAMOUT_TARGETS: {
              uint32_t targets_num = length - 1;
              if (targets_num == 0) {
                break;
              }
              uint32_t invalid_count = 0;
              for (size_t i = 0; i < targets_num; i++) {
                uint32_t target_handle = cmd[VIRGL_SET_STREAMOUT_TARGETS_H0 + i];
                if (invalid_object_handles.find(target_handle) != invalid_object_handles.end()) {
                  invalid_count++;
                }
              }
              if (invalid_count == targets_num) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_RESOURCE_COPY_REGION: {
              uint32_t src_res_handle = cmd[VIRGL_CMD_RCR_SRC_RES_HANDLE];
              if (!VirglResourceExist(context_id, src_res_handle)) {
                valid = false;
                break;
              }

              uint32_t dst_res_handle = cmd[VIRGL_CMD_RCR_DST_RES_HANDLE];
              if (!VirglResourceExist(context_id, dst_res_handle)) {
                valid = false;
                break;
              }
              break;
            }
            case VIRGL_CCMD_BIND_SAMPLER_STATES: {
              uint32_t invalid_count = 0;
              uint32_t sampler_states_num = length - 2;
              uint32_t* handles = &cmd[VIRGL_BIND_SAMPLER_STATES_S0_HANDLE];
              for (size_t i = 0; i < sampler_states_num; i++) {
                if (handles[i] > 0 && invalid_object_handles.find(handles[i]) != invalid_object_handles.end()) {
                  invalid_count++;
                }
              }
              if (invalid_count == sampler_states_num) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_INDEX_BUFFER: {
              uint32_t index_buffer_handle = cmd[VIRGL_SET_INDEX_BUFFER_HANDLE];
              if (index_buffer_handle > 0 && !VirglResourceExist(context_id, index_buffer_handle)) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_RESOURCE_INLINE_WRITE: {
              uint32_t dst_res_handle = cmd[VIRGL_RESOURCE_IW_RES_HANDLE];
              if (!VirglResourceExist(context_id, dst_res_handle)) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_UNIFORM_BUFFER: {
              uint32_t res_handle = cmd[VIRGL_SET_UNIFORM_BUFFER_RES_HANDLE];
              if (!VirglResourceExist(context_id, res_handle)) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_VERTEX_BUFFERS: {
              uint32_t invalid_count = 0;
              uint32_t vertex_buffers_num = length / 3;
              for (size_t i = 0; i < vertex_buffers_num; i++) {
                uint32_t res_handle = cmd[VIRGL_SET_VERTEX_BUFFER_HANDLE(i)];
                if (res_handle > 0 && !VirglResourceExist(context_id, res_handle)) {
                  invalid_count++;
                }
              }
              if (invalid_count == vertex_buffers_num) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_DRAW_VBO: {
              if (length != VIRGL_DRAW_VBO_SIZE_INDIRECT) {
                break;
              }
              uint32_t vbo_indirect_handle = cmd[VIRGL_DRAW_VBO_INDIRECT_HANDLE];
              if (vbo_indirect_handle > 0 && !VirglResourceExist(context_id, vbo_indirect_handle)) {
                valid = false;
                break;
              }
              uint32_t vbo_indirect_draw_count_handle = cmd[VIRGL_DRAW_VBO_INDIRECT_DRAW_COUNT_HANDLE];
              if (vbo_indirect_draw_count_handle > 0 && !VirglResourceExist(context_id, vbo_indirect_draw_count_handle)) {
                valid = false;
                break;
              }
              break;
            }
            case VIRGL_CCMD_CLEAR_TEXTURE: {
              uint32_t texture_handle = cmd[VIRGL_TEXTURE_HANDLE];
              if (!VirglResourceExist(context_id, texture_handle)) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_SET_SUB_CTX:
            case VIRGL_CCMD_CREATE_SUB_CTX: {
              uint32_t sub_context_id = cmd[1];
              if (invalid_sub_context_ids.find(sub_context_id) != invalid_sub_context_ids.end()) {
                valid = false;
              }
              break;
            }
            case VIRGL_CCMD_PIPE_RESOURCE_CREATE:
            case VIRGL_CCMD_DESTROY_OBJECT:
            case VIRGL_CCMD_DESTROY_SUB_CTX:
            case VIRGL_CCMD_GET_MEMORY_INFO:
            case VIRGL_CCMD_GET_QUERY_RESULT:
            case VIRGL_CCMD_GET_QUERY_RESULT_QBO:
            case VIRGL_CCMD_END_TRANSFERS:
            case VIRGL_CCMD_NOP:
              valid = false;
              break;
            default:
              break;
          }

          if (valid) {
            std::string cmd_str((char*)cmd, (length + 1) * sizeof(uint32_t));
            valid_cmds_str += cmd_str;
          }
        });

        // save valid virgl cmds
        if (valid_cmds_str.empty()) {
          iter1 = virgl_cmds_[context_id].erase(iter1);
        } else {
          context->add_virgl_cmds(valid_cmds_str.data(), valid_cmds_str.size());
          valid_cmd_size += valid_cmds_str.size();

          // update virgl cmd buffer saved
          *iter1 = std::move(valid_cmds_str);
          iter1++;
        }
      }
    }
    MV_LOG("save virgl cmd total_cmd_size=%dKB valid_cmd_size=%dKB", total_cmd_size >> 10, valid_cmd_size >> 10);

    writer->WriteProtobuf("VGPU", state);
    return VirtioPci::SaveState(writer);
  } 

  bool LoadState(MigrationReader* reader) {
    if (!VirtioPci::LoadState(reader)) {
      return false;
    }

    VirtioVgpuState state;
    if (!reader->ReadProtobuf("VGPU", state)) {
      return false;
    }

    // use staging now to accelerate guest vgpu
    vgpu_config_.staging = true;

    Schedule([this, state]() {
      if (virgl_renderer_init(this, VIRGL_RENDERER_USE_GLX, &vgpu_cbs) != 0) {
        if (virgl_renderer_init(this, VIRGL_RENDERER_USE_EGL | VIRGL_RENDERER_USE_GLES, &vgpu_cbs) != 0) {
          MV_PANIC("init virgl render failed");
        }
      }
      initialized_ = true;

      virgl_renderer_reset();
      reset_ = false;

      size_t total_cmd_size = 0;
      for (int i = 0; i < state.virgl_contexts_size(); i++) {
        auto& virgl_context = state.virgl_contexts(i);

        // create virgl context
        auto ret = virgl_renderer_context_create(virgl_context.context_id(), 0, nullptr);
        if (ret != 0) {
          MV_PANIC("create virgl context=%d failed", virgl_context.context_id());
        }

        // create virgl resources for current virgl context
        for (int j = 0; j < virgl_context.virgl_resources_size(); j++) {
          auto& resource = virgl_context.virgl_resources(j);
          auto args = (struct virgl_renderer_resource_create_args*)resource.resource_args().data();
          
          ret = virgl_renderer_resource_create(args, NULL, 0);
          if (ret != 0) {
            MV_PANIC("create virgl resource=%d failed", args->handle);
          }

          if (resource.size() > 0) {
            auto iov = new iovec {
              .iov_base = manager_->TranslateGuestMemory(resource.gpa()),
              .iov_len = resource.size()
            };

            ret = virgl_renderer_resource_attach_iov(args->handle, iov, 1);
            if (ret != 0) {
              MV_PANIC("attach virgl resource=%d iov=[0x%lx, %ld] failed", args->handle, iov->iov_base, iov->iov_len);
            }
          }

          // bind virgl resource to virgl context
          virgl_renderer_ctx_attach_resource(virgl_context.context_id(), args->handle);
        }

        // replay virgl commands
        for (auto& cmd : virgl_context.virgl_cmds()) {
          auto ret = virgl_renderer_submit_cmd((void*)cmd.data(), virgl_context.context_id(), cmd.size() / 4);
          if (ret) {
            MV_PANIC("submit command err=%d ctx_id=%d size=%d\n", ret, virgl_context.context_id(), cmd.size());
          }
          total_cmd_size += cmd.size();
        }
      }

      MV_LOG("load virgl cmd size=%dKB", total_cmd_size >> 10);
    });
    return true;
  }

  // get information struct from iovec by custom size
  void* EatIovec(std::deque<struct iovec>& iovec, size_t size) {
    MV_ASSERT(!iovec.empty());
    auto& front = iovec.front();
    void* ptr = front.iov_base;

    if (front.iov_len > size) {
      front.iov_len -= size;
      front.iov_base = (uint8_t*)front.iov_base + size;
    } else if (front.iov_len == size) {
      iovec.pop_front();
    } else {
      MV_PANIC("single data struct would never be split into different iovs size=%d front.iov_len=%d back.iov_len=%d iovec_size=%d", 
        size, front.iov_len, iovec.back().iov_len, iovec.size());
    }
    return ptr;
  }

  void GetCapsetInfo(VirtElement* element) {
    auto cmd = (struct virtio_gpu_get_capset_info*)EatIovec(element->vector, sizeof(struct virtio_gpu_get_capset_info));
    auto resp = (struct virtio_gpu_resp_capset_info*)EatIovec(element->vector, sizeof(struct virtio_gpu_resp_capset_info));
    memset(resp, 0, sizeof(*resp));

    switch (cmd->capset_index)
    {
    case 0:
      resp->capset_id = VIRTIO_GPU_CAPSET_VIRGL;
      break;
    case 1:
      resp->capset_id = VIRTIO_GPU_CAPSET_VIRGL2;
      break;
    default:
      MV_PANIC("unknown capset index=%d", cmd->capset_index);
      break;
    }
    virgl_renderer_get_cap_set(resp->capset_id, &resp->capset_max_version, &resp->capset_max_size);

    resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET_INFO;
    element->length = sizeof(struct virtio_gpu_resp_capset_info);
  }

  void GetCapset(VirtElement* element) {
    auto cmd = (struct virtio_gpu_get_capset*)EatIovec(element->vector, sizeof(struct virtio_gpu_get_capset));
    auto resp = (struct virtio_gpu_resp_capset*)EatIovec(element->vector, sizeof(struct virtio_gpu_resp_capset));
    
    uint32_t max_ver, max_size;
    virgl_renderer_get_cap_set(cmd->capset_id, &max_ver, &max_size);
    if (!max_size) {
        resp->hdr.type = VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER;
        return;
    }

    // make sure that buffer of resp is big enough to save caps from virgl
    memset(resp, 0, sizeof(*resp) + max_size);
    virgl_renderer_fill_caps(cmd->capset_id, cmd->capset_version, (void*)resp->capset_data);

    resp->hdr.type = VIRTIO_GPU_RESP_OK_CAPSET;
    element->length = sizeof(*resp) + max_size;
  }

  void CreateVirglContext(VirtElement* element) {
    auto cmd = (struct virtio_gpu_ctx_create*)EatIovec(element->vector, sizeof(struct virtio_gpu_ctx_create));
    auto ret = virgl_renderer_context_create_with_flags(cmd->hdr.ctx_id, cmd->context_init, cmd->nlen, cmd->debug_name);
    if (ret) {
      MV_ERROR("create virgl context failed id=%d debug_name=%s", cmd->hdr.ctx_id, cmd->debug_name);
    }
  }

  void DestroyVirglContext(VirtElement* element) {
    auto cmd = (struct virtio_gpu_ctx_destroy*)EatIovec(element->vector, sizeof(struct virtio_gpu_ctx_destroy));
    virgl_renderer_context_destroy(cmd->hdr.ctx_id);

    // unmap blob regions from this virgl context
    auto iter = blob_memory_regions_.find(cmd->hdr.ctx_id);
    if (iter != blob_memory_regions_.end()) {
      for (auto iter1 = iter->second.begin(); iter1 != iter->second.end(); iter1++) {
        manager_->machine()->memory_manager()->Unmap(&(iter1->second));
        iter->second.erase(iter1);
      }
      blob_memory_regions_.erase(iter);
    }

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }
    
    virgl_resources_.erase(cmd->hdr.ctx_id);
  }

  void Create2dResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_create_2d*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_create_2d));

    struct virgl_renderer_resource_create_args args = {
      .handle = cmd->resource_id,
      .target = 2,
      .format = cmd->format,
      .bind = 2,
      .width = cmd->width,
      .height = cmd->height,
      .depth = 1,
      .array_size = 1,
      .last_level = 0,
      .nr_samples = 0,
      .flags = VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP
    };

    auto ret = virgl_renderer_resource_create(&args, NULL, 0);
    if (ret) {
      MV_ERROR("create virgl 2d resource failed id=%d format=%d ret=%d ", cmd->resource_id, cmd->format, ret);
      return;
    }

    // bind virgl resource to virgl context
    virgl_renderer_ctx_attach_resource(cmd->hdr.ctx_id, cmd->resource_id);

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }

    virgl_resources_[cmd->hdr.ctx_id][cmd->resource_id] = {
      .gpa = 0,
      .size = 0,
      .args = std::move(args)
    };
  }

  void Create3dResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_create_3d*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_create_3d));
    
    struct virgl_renderer_resource_create_args args = {
      .handle = cmd->resource_id,
      .target = cmd->target,
      .format = cmd->format,
      .bind = cmd->bind,
      .width = cmd->width,
      .height = cmd->height,
      .depth = cmd->depth,
      .array_size = cmd->array_size,
      .last_level = cmd->last_level,
      .nr_samples = cmd->nr_samples,
      .flags = cmd->flags
    };
    
    auto ret = virgl_renderer_resource_create(&args, NULL, 0);
    if (ret) {
      MV_ERROR("create virgl 3d resource failed id=%d ret=%d", cmd->resource_id, ret);
      return;
    }

    // bind virgl resource to virgl context
    virgl_renderer_ctx_attach_resource(cmd->hdr.ctx_id, cmd->resource_id);

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }

    virgl_resources_[cmd->hdr.ctx_id][cmd->resource_id] = {
      .gpa = 0,
      .size = 0,
      .args = std::move(args)
    };
  }

  void CreateBlobResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_create_blob*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_create_blob));
    
    // make up pipe resource command to virgl
    uint32_t blob_command[VIRGL_PIPE_RES_CREATE_SIZE + 1] = {0};
    blob_command[0] = VIRGL_CMD0(VIRGL_CCMD_PIPE_RESOURCE_CREATE, 0, VIRGL_PIPE_RES_CREATE_SIZE);
    blob_command[VIRGL_PIPE_RES_CREATE_FORMAT] = cmd->format;
    blob_command[VIRGL_PIPE_RES_CREATE_BIND] = cmd->bind;
    blob_command[VIRGL_PIPE_RES_CREATE_TARGET] = cmd->target;
    blob_command[VIRGL_PIPE_RES_CREATE_WIDTH] = cmd->width;
    blob_command[VIRGL_PIPE_RES_CREATE_HEIGHT] = cmd->height;
    blob_command[VIRGL_PIPE_RES_CREATE_DEPTH] = cmd->depth;
    blob_command[VIRGL_PIPE_RES_CREATE_ARRAY_SIZE] = cmd->array_size;
    blob_command[VIRGL_PIPE_RES_CREATE_LAST_LEVEL] = cmd->last_level;
    blob_command[VIRGL_PIPE_RES_CREATE_NR_SAMPLES] = cmd->nr_samples;
    blob_command[VIRGL_PIPE_RES_CREATE_FLAGS] = cmd->flags;
    blob_command[VIRGL_PIPE_RES_CREATE_BLOB_ID] = cmd->blob_id;

    auto ret = virgl_renderer_submit_cmd(blob_command, cmd->hdr.ctx_id, VIRGL_PIPE_RES_CREATE_SIZE + 1);
    if (ret) {
      MV_ERROR("create pipe resource failed err=%d ctx_id=%d\n", ret, cmd->hdr.ctx_id);
      return;
    }

    struct virgl_renderer_resource_create_blob_args args = {
      .res_handle = cmd->resource_id,
      .ctx_id = cmd->hdr.ctx_id,
      .blob_mem = cmd->blob_mem,
      .blob_flags = cmd->blob_flags,
      .blob_id = cmd->blob_id,
      .size = cmd->size,
      .iovecs = nullptr,
      .num_iovs = 0,
    };

    ret = virgl_renderer_resource_create_blob(&args);
    if (ret) {
      MV_ERROR("create virgl blob resource failed id=%d ret=%d", cmd->resource_id, ret);
      return;
    }
    
    // bind virgl resource to virgl context
    virgl_renderer_ctx_attach_resource(cmd->hdr.ctx_id, cmd->resource_id);
  }

  void MapBlobResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_map_blob*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_map_blob));
    auto resp = (struct virtio_gpu_resp_map_info*)EatIovec(element->vector, sizeof(struct virtio_gpu_resp_map_info));
    
    void* map;
    size_t size;
    auto ret = virgl_renderer_resource_map(cmd->resource_id, &map, &size);
    if (ret) {
      MV_ERROR("map virgl blob resource failed id=%d ret=%d", cmd->resource_id, ret);
      return;
    }

    resp->gpa = blob_memory_gpa_base_;
    resp->size = size;
    resp->hdr.type = VIRTIO_GPU_RESP_OK_MAP_INFO;
    virgl_renderer_resource_get_map_info(cmd->resource_id, &resp->map_info);
    
    // map the blob memory from gpu to guest
    auto region = manager_->machine()->memory_manager()->Map(resp->gpa, resp->size, map, kMemoryTypeRam, "VGPU");
    blob_memory_regions_[cmd->hdr.ctx_id][cmd->resource_id] = region;
    blob_memory_gpa_base_ += size;
  }

  void UnmapBlobResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_unmap_blob*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_unmap_blob));
    
    auto ret = virgl_renderer_resource_unmap(cmd->resource_id);
    if (ret) {
      MV_ERROR("unmap virgl blob resource failed id=%d ret=%d", cmd->resource_id, ret);
      return;
    }

    auto iter = blob_memory_regions_[cmd->hdr.ctx_id].find(cmd->resource_id);
    if (iter != blob_memory_regions_[cmd->hdr.ctx_id].end()) {
      // unmap the blob memory mapped from gpu
      manager_->machine()->memory_manager()->Unmap(&(iter->second));
      blob_memory_regions_[cmd->hdr.ctx_id].erase(iter);
    }
  }

  void SubmitCommand(VirtElement* element) {
    auto cmd = (struct virtio_gpu_cmd_submit*)EatIovec(element->vector, sizeof(struct virtio_gpu_cmd_submit));

    // we use contiguous physical memory
    MV_ASSERT(element->vector.size() == 1);

    auto& vector = element->vector.front();
    element->vector.pop_front();

    auto ret = virgl_renderer_submit_cmd(vector.iov_base, cmd->hdr.ctx_id, cmd->size / 4);
    if (ret) {
      MV_ERROR("submit command err=%d ctx_id=%d size=%d\n", ret, cmd->hdr.ctx_id, cmd->size / 4);
      return;
    }

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }

    std::string cmd_buf((char*)vector.iov_base, cmd->size);
    virgl_cmds_[cmd->hdr.ctx_id].emplace_back(std::move(cmd_buf));
  }

  void AttachBackingResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_attach_backing*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_attach_backing));

    auto iov = new iovec {
      .iov_base = manager_->TranslateGuestMemory(cmd->gpa),
      .iov_len = cmd->size
    };

    auto ret = virgl_renderer_resource_attach_iov(cmd->resource_id, iov, 1);
    if (ret) {
      MV_ERROR("attach backing virgl resource id=%d ret=%d", cmd->resource_id, ret);
      return;
    }

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }

    auto& resource = virgl_resources_[cmd->hdr.ctx_id][cmd->resource_id];
    resource.gpa = cmd->gpa;
    resource.size = cmd->size;
  }

  void DetachBackingResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_detach_backing*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_detach_backing));

    int num = 0;
    struct iovec* iov = nullptr;
    virgl_renderer_resource_detach_iov(cmd->resource_id, &iov, &num);
    if (iov != nullptr && num == 1) {
      delete iov;
    } else {
      MV_ERROR("something wrong with resource create/delete iov=0x%lx num=%d", iov, num);
    }
  }

  void AttachResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_ctx_resource*)EatIovec(element->vector, sizeof(struct virtio_gpu_ctx_resource));
    virgl_renderer_ctx_attach_resource(cmd->hdr.ctx_id, cmd->resource_id);
  }

  void DetachResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_ctx_resource*)EatIovec(element->vector, sizeof(struct virtio_gpu_ctx_resource));
    virgl_renderer_ctx_detach_resource(cmd->hdr.ctx_id, cmd->resource_id);
  }

  void UnrefResource(VirtElement* element) {
    auto cmd = (struct virtio_gpu_resource_unref*)EatIovec(element->vector, sizeof(struct virtio_gpu_resource_unref));
    virgl_renderer_ctx_detach_resource(cmd->hdr.ctx_id, cmd->resource_id);
    virgl_renderer_resource_unref(cmd->resource_id);

    // guest didn't support migration when staging=true
    if (vgpu_config_.staging) {
      return;
    }
    
    auto iter = virgl_resources_[cmd->hdr.ctx_id].find(cmd->resource_id);
    if (iter != virgl_resources_[cmd->hdr.ctx_id].end()) {
      virgl_resources_[cmd->hdr.ctx_id].erase(iter);
    }
  }

  void TransferHost3d(VirtElement* element, bool to_host) {
    auto cmd = (struct virtio_gpu_transfer_host_3d*)EatIovec(element->vector, sizeof(struct virtio_gpu_transfer_host_3d));
    
    int ret;
    if (to_host) {
      ret = virgl_renderer_transfer_write_iov(cmd->resource_id, cmd->hdr.ctx_id, 
              cmd->level, cmd->stride, cmd->layer_stride, (struct virgl_box *)&cmd->box, cmd->offset, NULL, 0);
    } else {
      ret = virgl_renderer_transfer_read_iov(cmd->resource_id, cmd->hdr.ctx_id, 
              cmd->level, cmd->stride, cmd->layer_stride, (struct virgl_box *)&cmd->box, cmd->offset, NULL, 0);
    }

    if (ret) {
      MV_ERROR("call TransferHost 3d err=%d direct=%d resource_id=%d\n", ret, to_host, cmd->resource_id);
    }
  }

  void TransferHost2d(VirtElement* element) {
    auto cmd = (struct virtio_gpu_transfer_to_host_2d*)EatIovec(element->vector, sizeof(struct virtio_gpu_transfer_to_host_2d));
    
    struct virtio_gpu_box box = {
      .x = cmd->r.x,
      .y = cmd->r.y,
      .z = 0,
      .w = cmd->r.width,
      .h = cmd->r.height,
      .d = 1
    };

    auto ret = virgl_renderer_transfer_write_iov(cmd->resource_id, cmd->hdr.ctx_id, 0, 0, 0, (struct virgl_box *)&box, cmd->offset, NULL, 0);
    if (ret) {
      MV_ERROR("call TransferHost 2d err=%d res_id=%d w=%d h=%d\n", ret, cmd->resource_id, box.w, box.h);
    }
  }

  uint64_t HandleCommand(VirtElement* element) {
    auto cmd_header = (struct virtio_gpu_ctrl_hdr*)element->vector[0].iov_base;
    
    if (!initialized_) {
      if (virgl_renderer_init(this, VIRGL_RENDERER_USE_GLX, &vgpu_cbs) != 0) {
        if (virgl_renderer_init(this, VIRGL_RENDERER_USE_EGL | VIRGL_RENDERER_USE_GLES, &vgpu_cbs) != 0) {
          MV_PANIC("init virgl render failed");
        }
      }
      initialized_ = true;
    }

    if (reset_) {
      virgl_renderer_reset();
      reset_ = false;
    }

    switch (cmd_header->type) {
      case VIRTIO_GPU_CMD_GET_CAPSET_INFO:
        GetCapsetInfo(element);
        break;
      case VIRTIO_GPU_CMD_GET_CAPSET:
        GetCapset(element);
        break;
      case VIRTIO_GPU_CMD_CTX_CREATE:
        CreateVirglContext(element);
        break;
      case VIRTIO_GPU_CMD_CTX_DESTROY:
        DestroyVirglContext(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:
        Create2dResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_CREATE_3D:
        Create3dResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:
        AttachBackingResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING:
        DetachBackingResource(element);
        break;
      case VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE:
        AttachResource(element);
        break;
      case VIRTIO_GPU_CMD_SUBMIT_3D:
        SubmitCommand(element);
        break;
      case VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE:
        DetachResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_UNREF:
        UnrefResource(element);
        break;
      case VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D:
        TransferHost3d(element, false);
        break;
      case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D:
        TransferHost3d(element, true);
        break;
      case VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D:
        TransferHost2d(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB:
        CreateBlobResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB:
        MapBlobResource(element);
        break;
      case VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB:
        UnmapBlobResource(element);
        break;
      default:
        MV_PANIC("unimplement cmd type=%d", cmd_header->type);
        break;
    }

    if (cmd_header->flags & VIRTIO_GPU_FLAG_FENCE) {
      auto ret = virgl_renderer_create_fence(cmd_header->fence_id, cmd_header->ctx_id);
      if (ret != 0) {
        MV_PANIC("virgl_renderer_create_fence failed ret=%d", ret);
      }
      return cmd_header->fence_id;
    }
    return 0;
  }
};

// Why did libvirglrenderer define fence as 32bit, not 64bit?
// libvirglrenderer/ctx0_fence_retire: ctx0 fence_id is created from uint32_t but stored internally as uint64_t,
// so casting back to uint32_t doesn't result in data loss.
static void virgl_write_fence(void *opaque, uint32_t fence) {
  auto vgpu = (VirtioVgpu*)opaque;
  vgpu->WriteFence(fence);
}

static int virgl_get_drm_fd(void *opaque) {
  auto vgpu = (VirtioVgpu*)opaque;
  return vgpu->GetDrmFd();
}

DECLARE_DEVICE(VirtioVgpu);

```

`devices/virtio/virtio_vgpu.h`:

```h
/*
 * MVisor
 * Copyright (C) 2023 cair <rui.cai@tenclass.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICES_VIRTIO_VGPU_H
#define _MVISOR_DEVICES_VIRTIO_VGPU_H

#include "linux/types.h"
#include "linuz/virgl_protocol.h"

#define VIRTIO_GPU_CAPSET_VIRGL     1
#define VIRTIO_GPU_CAPSET_VIRGL2    2
#define VIRTIO_GPU_FLAG_FENCE       (1 << 0)

#define VIRTGPU_PARAM_3D_FEATURES           1 << 0 /* do we have 3D features in the hw */
#define VIRTGPU_PARAM_CAPSET_QUERY_FIX      1 << 1 /* do we have the capset fix */
#define VIRTGPU_PARAM_RESOURCE_BLOB         1 << 2 /* DRM_VIRTGPU_RESOURCE_CREATE_BLOB */
#define VIRTGPU_PARAM_HOST_VISIBLE          1 << 3 /* Host blob resources are mappable */
#define VIRTGPU_PARAM_CROSS_DEVICE          1 << 4 /* Cross virtio-device resource sharing  */
#define VIRTGPU_PARAM_CONTEXT_INIT          1 << 5 /* DRM_VIRTGPU_CONTEXT_INIT */
#define VIRTGPU_PARAM_SUPPORTED_CAPSET_IDs  1 << 6 /* Bitmask of supported capability set ids */

static int virgl_get_drm_fd(void *opaque);
static void virgl_write_fence(void *opaque, uint32_t fence);

typedef std::function<void(uint32_t *cmd)> VirglCommandCallback;

enum virtio_gpu_ctrl_type {
  VIRTIO_GPU_UNDEFINED = 0,

  /* 2d commands */
  VIRTIO_GPU_CMD_GET_DISPLAY_INFO = 0x0100,
  VIRTIO_GPU_CMD_RESOURCE_CREATE_2D,
  VIRTIO_GPU_CMD_RESOURCE_UNREF,
  VIRTIO_GPU_CMD_SET_SCANOUT,
  VIRTIO_GPU_CMD_RESOURCE_FLUSH,
  VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D,
  VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING,
  VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING,
  VIRTIO_GPU_CMD_GET_CAPSET_INFO,
  VIRTIO_GPU_CMD_GET_CAPSET,
  VIRTIO_GPU_CMD_GET_EDID,
  VIRTIO_GPU_CMD_RESOURCE_ASSIGN_UUID,
  VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB,
  VIRTIO_GPU_CMD_SET_SCANOUT_BLOB,

  /* 3d commands */
  VIRTIO_GPU_CMD_CTX_CREATE = 0x0200,
  VIRTIO_GPU_CMD_CTX_DESTROY,
  VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE,
  VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE,
  VIRTIO_GPU_CMD_RESOURCE_CREATE_3D,
  VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D,
  VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D,
  VIRTIO_GPU_CMD_SUBMIT_3D,
  VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB,
  VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB,

  /* cursor commands */
  VIRTIO_GPU_CMD_UPDATE_CURSOR = 0x0300,
  VIRTIO_GPU_CMD_MOVE_CURSOR,

  /* success responses */
  VIRTIO_GPU_RESP_OK_NODATA = 0x1100,
  VIRTIO_GPU_RESP_OK_DISPLAY_INFO,
  VIRTIO_GPU_RESP_OK_CAPSET_INFO,
  VIRTIO_GPU_RESP_OK_CAPSET,
  VIRTIO_GPU_RESP_OK_EDID,
  VIRTIO_GPU_RESP_OK_RESOURCE_UUID,
  VIRTIO_GPU_RESP_OK_MAP_INFO,

  /* error responses */
  VIRTIO_GPU_RESP_ERR_UNSPEC = 0x1200,
  VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY,
  VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID,
  VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID,
  VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID,
  VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER,
};

struct vgpu_config {
  __u8 staging;
  __u8 num_queues;
  __u32 num_capsets;
  __u64 memory_size;
  __u64 capabilities;
} __attribute__((packed));

struct virtio_gpu_ctrl_hdr {
  __le32 type;
  __le32 flags;
  __le64 fence_id;
  __le32 ctx_id;
  __u8 ring_idx;
  __u8 padding[3];
} __attribute__((packed));

/* VIRTIO_GPU_CMD_GET_CAPSET_INFO */
struct virtio_gpu_get_capset_info {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 capset_index;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_RESP_OK_CAPSET_INFO */
struct virtio_gpu_resp_capset_info {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 capset_id;
  __le32 capset_max_version;
  __le32 capset_max_size;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_CTX_CREATE */
#define VIRTIO_GPU_CONTEXT_INIT_CAPSET_ID_MASK 0x000000ff
struct virtio_gpu_ctx_create {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 nlen;
  __le32 context_init;
  char debug_name[64];
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_CREATE_3D */
#define VIRTIO_GPU_RESOURCE_FLAG_Y_0_TOP (1 << 0)
struct virtio_gpu_resource_create_3d {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 target;
  __le32 format;
  __le32 bind;
  __le32 width;
  __le32 height;
  __le32 depth;
  __le32 array_size;
  __le32 last_level;
  __le32 nr_samples;
  __le32 flags;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_CREATE_2D: create a 2d resource with a format */
struct virtio_gpu_resource_create_2d {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 format;
  __le32 width;
  __le32 height;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING */
struct virtio_gpu_resource_attach_backing {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 nr_entries;
  __le64 gpa;
  __le32 size;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING */
struct virtio_gpu_resource_detach_backing {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_CTX_ATTACH_RESOURCE, VIRTIO_GPU_CMD_CTX_DETACH_RESOURCE */
struct virtio_gpu_ctx_resource {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_UNREF */
struct virtio_gpu_resource_unref {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_CTX_DESTROY */
struct virtio_gpu_ctx_destroy {
  struct virtio_gpu_ctrl_hdr hdr;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_GET_CAPSET */
struct virtio_gpu_get_capset {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 capset_id;
  __le32 capset_version;
} __attribute__((packed));

/* VIRTIO_GPU_RESP_OK_CAPSET */
struct virtio_gpu_resp_capset {
  struct virtio_gpu_ctrl_hdr hdr;
  __u8 capset_data[];
} __attribute__((packed));

struct virtio_gpu_box {
  __le32 x, y, z;
  __le32 w, h, d;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_TRANSFER_TO_HOST_3D, VIRTIO_GPU_CMD_TRANSFER_FROM_HOST_3D */
struct virtio_gpu_transfer_host_3d {
  struct virtio_gpu_ctrl_hdr hdr;
  struct virtio_gpu_box box;
  __le64 offset;
  __le32 resource_id;
  __le32 level;
  __le32 stride;
  __le32 layer_stride;
} __attribute__((packed));

struct virtio_gpu_rect {
  __le32 x;
  __le32 y;
  __le32 width;
  __le32 height;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D: simple transfer to_host */
struct virtio_gpu_transfer_to_host_2d {
  struct virtio_gpu_ctrl_hdr hdr;
  struct virtio_gpu_rect r;
  __le64 offset;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_SUBMIT_3D */
struct virtio_gpu_cmd_submit {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 size;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_CREATE_BLOB */
struct virtio_gpu_resource_create_blob {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
#define VIRTIO_GPU_BLOB_MEM_GUEST 0x0001
#define VIRTIO_GPU_BLOB_MEM_HOST3D 0x0002
#define VIRTIO_GPU_BLOB_MEM_HOST3D_GUEST 0x0003

#define VIRTIO_GPU_BLOB_FLAG_USE_MAPPABLE 0x0001
#define VIRTIO_GPU_BLOB_FLAG_USE_SHAREABLE 0x0002
#define VIRTIO_GPU_BLOB_FLAG_USE_CROSS_DEVICE 0x0004
  /* zero is invalid blob mem */
  __le32 blob_mem;
  __le32 blob_flags;
  __le32 nr_entries;
  __le64 blob_id;
  __le64 size;

  /* from cmd */
  __le32 format;
  __le32 bind;
  __le32 target;
  __le32 width;
  __le32 height;
  __le32 depth;
  __le32 array_size;
  __le32 last_level;
  __le32 nr_samples;
  __le32 flags;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_MAP_BLOB */
struct virtio_gpu_resource_map_blob {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_RESP_OK_MAP_INFO */
#define VIRTIO_GPU_MAP_CACHE_MASK 0x0f
#define VIRTIO_GPU_MAP_CACHE_NONE 0x00
#define VIRTIO_GPU_MAP_CACHE_CACHED 0x01
#define VIRTIO_GPU_MAP_CACHE_UNCACHED 0x02
#define VIRTIO_GPU_MAP_CACHE_WC 0x03
struct virtio_gpu_resp_map_info {
  struct virtio_gpu_ctrl_hdr hdr;
  __u32 map_info;
  __le64 gpa;
  __le64 size;
  __u32 padding;
} __attribute__((packed));

/* VIRTIO_GPU_CMD_RESOURCE_UNMAP_BLOB */
struct virtio_gpu_resource_unmap_blob {
  struct virtio_gpu_ctrl_hdr hdr;
  __le32 resource_id;
  __le32 padding;
} __attribute__((packed));

#endif
```

`devices/virtio/virtio_vgpu.proto`:

```proto
syntax = "proto3";

message VirtioVgpuState {
  message VirglContext {
    message VirglResource {
      uint64 gpa = 1;
      uint32 size = 2;
      bytes  resource_args = 3;
    }
    
    uint32 context_id = 1;
    repeated VirglResource virgl_resources = 2;
    repeated bytes virgl_cmds = 3;
  }

  repeated VirglContext virgl_contexts = 1;
}
```

`docs/cpuids/icelake`:

```
vCPU 0 function=0x0 index=0 flags=0x00000000 eax=0x0000001b ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
vCPU 0 function=0x1 index=0 flags=0x00000000 eax=0x000606a6 ebx=0x82800800 ecx=0x76fab223 edx=0x0f8bfbff
vCPU 0 function=0x2 index=0 flags=0x00000000 eax=0x00feff01 ebx=0x000000f0 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x3 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x4 index=0 flags=0x00000001 eax=0xfc004121 ebx=0x02c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=1 flags=0x00000001 eax=0xfc004122 ebx=0x01c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=2 flags=0x00000001 eax=0xfc004143 ebx=0x04c0003f ecx=0x000003ff edx=0x00000000
vCPU 0 function=0x4 index=3 flags=0x00000001 eax=0xfc1fc163 ebx=0x02c0003f ecx=0x0000ffff edx=0x00000004
vCPU 0 function=0x4 index=4 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x5 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x6 index=0 flags=0x00000000 eax=0x00000004 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x7 index=0 flags=0x00000001 eax=0x00000000 ebx=0xf1bf07af ecx=0x40415f4e edx=0xac000410
vCPU 0 function=0x8 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x9 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xa index=0 flags=0x00000000 eax=0x08300802 ebx=0x00000000 ecx=0x00000000 edx=0x00008603
vCPU 0 function=0xb index=0 flags=0x00000001 eax=0x00000001 ebx=0x00000002 ecx=0x00000100 edx=0x00000082
vCPU 0 function=0xb index=1 flags=0x00000001 eax=0x00000007 ebx=0x00000040 ecx=0x00000201 edx=0x00000082
vCPU 0 function=0xb index=2 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000002 edx=0x00000082
vCPU 0 function=0xc index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=0 flags=0x00000001 eax=0x000002e7 ebx=0x00000a88 ecx=0x00000a88 edx=0x00000000
vCPU 0 function=0xd index=1 flags=0x00000001 eax=0x0000000f ebx=0x00000988 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=2 flags=0x00000001 eax=0x00000100 ebx=0x00000240 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=5 flags=0x00000001 eax=0x00000040 ebx=0x00000440 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=6 flags=0x00000001 eax=0x00000200 ebx=0x00000480 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=7 flags=0x00000001 eax=0x00000400 ebx=0x00000680 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=9 flags=0x00000001 eax=0x00000008 ebx=0x00000a80 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xe index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xf index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x10 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x11 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x12 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x12 index=1 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x13 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x14 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x15 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x16 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x17 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x18 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x19 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x1a index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x1b index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000000 index=0 flags=0x00000000 eax=0x80000008 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000001 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000121 edx=0x2c100800
vCPU 0 function=0x80000002 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000003 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000004 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000005 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000006 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x01006040 edx=0x00000000
vCPU 0 function=0x80000007 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000100
vCPU 0 function=0x80000008 index=0 flags=0x00000000 eax=0x0000392e ebx=0x0100d200 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000000 index=0 flags=0x00000000 eax=0x40000001 ebx=0x4b4d564b ecx=0x564b4d56 edx=0x0000004d
vCPU 0 function=0x40000001 index=0 flags=0x00000000 eax=0x01007efb ebx=0x00000000 ecx=0x00000000 edx=0x00000000
```

`docs/cpuids/icelake-mvisor`:

```
vCPU 0 function=0x0 index=0 flags=0x00000000 eax=0x0000000d ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
vCPU 0 function=0x1 index=0 flags=0x00000000 eax=0x000606a6 ebx=0x03000800 ecx=0xf7fa3223 edx=0x078bfbff
vCPU 0 function=0x2 index=0 flags=0x00000000 eax=0x00feff01 ebx=0x000000f0 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x4 index=0 flags=0x00000001 eax=0xfc004121 ebx=0x02c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=1 flags=0x00000001 eax=0xfc004122 ebx=0x01c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=2 flags=0x00000001 eax=0xfc004143 ebx=0x04c0003f ecx=0x000003ff edx=0x00000000
vCPU 0 function=0x4 index=3 flags=0x00000001 eax=0xfc1fc163 ebx=0x02c0003f ecx=0x0000ffff edx=0x00000004
vCPU 0 function=0x4 index=4 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x7 index=0 flags=0x00000001 eax=0x00000000 ebx=0xd19f07a9 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xb index=0 flags=0x00000001 eax=0x00000001 ebx=0x00000002 ecx=0x00000100 edx=0x00000003
vCPU 0 function=0xb index=1 flags=0x00000001 eax=0x00000007 ebx=0x00000040 ecx=0x00000201 edx=0x00000003
vCPU 0 function=0xb index=2 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000002 edx=0x00000003
vCPU 0 function=0xd index=0 flags=0x00000001 eax=0x000002e7 ebx=0x00000a88 ecx=0x00000a88 edx=0x00000000
vCPU 0 function=0xd index=1 flags=0x00000001 eax=0x0000000f ebx=0x00000988 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=2 flags=0x00000001 eax=0x00000100 ebx=0x00000240 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=5 flags=0x00000001 eax=0x00000040 ebx=0x00000440 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=6 flags=0x00000001 eax=0x00000200 ebx=0x00000480 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=7 flags=0x00000001 eax=0x00000400 ebx=0x00000680 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=9 flags=0x00000001 eax=0x00000008 ebx=0x00000a80 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000000 index=0 flags=0x00000000 eax=0x80000008 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000001 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000121 edx=0x2c100800
vCPU 0 function=0x80000002 index=0 flags=0x00000000 eax=0x65746e49 ebx=0x6558206c ecx=0x50206e6f edx=0x65636f72
vCPU 0 function=0x80000003 index=0 flags=0x00000000 eax=0x726f7373 ebx=0x6b532820 ecx=0x6b616c79 edx=0x65532d65
vCPU 0 function=0x80000004 index=0 flags=0x00000000 eax=0x72657672 ebx=0x00000029 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000006 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x01006040 edx=0x00000000
vCPU 0 function=0x80000008 index=0 flags=0x00000000 eax=0x0000392e ebx=0x0100d200 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000100 index=0 flags=0x00000000 eax=0x40000001 ebx=0x4b4d564b ecx=0x564b4d56 edx=0x0000004d
vCPU 0 function=0x40000101 index=0 flags=0x00000000 eax=0x01007efb ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000000 index=0 flags=0x00000000 eax=0x40000005 ebx=0x7263694d ecx=0x666f736f edx=0x76482074
vCPU 0 function=0x40000001 index=0 flags=0x00000000 eax=0x31237648 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000002 index=0 flags=0x00000000 eax=0x00003839 ebx=0x000a0000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000003 index=0 flags=0x00000000 eax=0x0000027f ebx=0x00000030 ecx=0x00000000 edx=0x00000008
vCPU 0 function=0x40000004 index=0 flags=0x00000000 eax=0x0000042c ebx=0x00000fff ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000005 index=0 flags=0x00000000 eax=0x00000800 ebx=0x00000040 ecx=0x00000000 edx=0x00000000

```

`docs/cpuids/skylake`:

```
vCPU 0 function=0x0 index=0 flags=0x00000000 eax=0x00000016 ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
vCPU 0 function=0x1 index=0 flags=0x00000000 eax=0x00050654 ebx=0x70400800 ecx=0x76fab223 edx=0x0f8bfbff
vCPU 0 function=0x2 index=0 flags=0x00000000 eax=0x76036301 ebx=0x00f0b5ff ecx=0x00000000 edx=0x00c30000
vCPU 0 function=0x3 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x4 index=0 flags=0x00000001 eax=0x7c004121 ebx=0x01c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=1 flags=0x00000001 eax=0x7c004122 ebx=0x01c0003f ecx=0x0000003f edx=0x00000000
vCPU 0 function=0x4 index=2 flags=0x00000001 eax=0x7c004143 ebx=0x03c0003f ecx=0x000003ff edx=0x00000000
vCPU 0 function=0x4 index=3 flags=0x00000001 eax=0x7c0fc163 ebx=0x0280003f ecx=0x0000bfff edx=0x00000004
vCPU 0 function=0x4 index=4 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x5 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x6 index=0 flags=0x00000000 eax=0x00000004 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x7 index=0 flags=0x00000001 eax=0x00000000 ebx=0xd19f4fbb ecx=0x0000000c edx=0xac000400
vCPU 0 function=0x8 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x9 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xa index=0 flags=0x00000000 eax=0x07300402 ebx=0x00000000 ecx=0x00000000 edx=0x00008603
vCPU 0 function=0xb index=0 flags=0x00000001 eax=0x00000001 ebx=0x00000002 ecx=0x00000100 edx=0x00000070
vCPU 0 function=0xb index=1 flags=0x00000001 eax=0x00000006 ebx=0x00000030 ecx=0x00000201 edx=0x00000070
vCPU 0 function=0xb index=2 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000002 edx=0x00000070
vCPU 0 function=0xc index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=0 flags=0x00000001 eax=0x000002ff ebx=0x00000a88 ecx=0x00000a88 edx=0x00000000
vCPU 0 function=0xd index=1 flags=0x00000001 eax=0x0000000f ebx=0x00000a08 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=2 flags=0x00000001 eax=0x00000100 ebx=0x00000240 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=3 flags=0x00000001 eax=0x00000040 ebx=0x000003c0 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=4 flags=0x00000001 eax=0x00000040 ebx=0x00000400 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=5 flags=0x00000001 eax=0x00000040 ebx=0x00000440 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=6 flags=0x00000001 eax=0x00000200 ebx=0x00000480 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=7 flags=0x00000001 eax=0x00000400 ebx=0x00000680 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=9 flags=0x00000001 eax=0x00000008 ebx=0x00000a80 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xe index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xf index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x10 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x11 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x12 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x13 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x14 index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x15 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x16 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000000 index=0 flags=0x00000000 eax=0x80000008 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000001 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000121 edx=0x2c100800
vCPU 0 function=0x80000002 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000003 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000004 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000005 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000006 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x01006040 edx=0x00000000
vCPU 0 function=0x80000007 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000100
vCPU 0 function=0x80000008 index=0 flags=0x00000000 eax=0x0000302e ebx=0x0100d000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000000 index=0 flags=0x00000000 eax=0x40000001 ebx=0x4b4d564b ecx=0x564b4d56 edx=0x0000004d
vCPU 0 function=0x40000001 index=0 flags=0x00000000 eax=0x01007efb ebx=0x00000000 ecx=0x00000000 edx=0x00000000

```

`docs/cpuids/skylake-qemu`:

```
vCPU 0 function=0x0 index=0 flags=0x00000000 eax=0x0000000d ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
vCPU 0 function=0x1 index=0 flags=0x00000000 eax=0x00050654 ebx=0x03000800 ecx=0xf7fa3203 edx=0x078bfbff
vCPU 0 function=0x2 index=0 flags=0x00000006 eax=0x00000001 ebx=0x00000000 ecx=0x0000004d edx=0x002c307d
vCPU 0 function=0x4 index=0 flags=0x00000001 eax=0x00000121 ebx=0x01c0003f ecx=0x0000003f edx=0x00000001
vCPU 0 function=0x4 index=1 flags=0x00000001 eax=0x00000122 ebx=0x01c0003f ecx=0x0000003f edx=0x00000001
vCPU 0 function=0x4 index=2 flags=0x00000001 eax=0x00000143 ebx=0x03c0003f ecx=0x00000fff edx=0x00000001
vCPU 0 function=0x4 index=3 flags=0x00000001 eax=0x00000163 ebx=0x03c0003f ecx=0x00003fff edx=0x00000006
vCPU 0 function=0x4 index=4 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x5 index=0 flags=0x00000000 eax=0x00000000 ebx=0x00000000 ecx=0x00000003 edx=0x00000000
vCPU 0 function=0x6 index=0 flags=0x00000000 eax=0x00000004 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x7 index=0 flags=0x00000001 eax=0x00000000 ebx=0xd19f07a9 ecx=0x00000008 edx=0x00000000
vCPU 0 function=0xb index=0 flags=0x00000001 eax=0x00000000 ebx=0x00000001 ecx=0x00000100 edx=0x00000003
vCPU 0 function=0xb index=1 flags=0x00000001 eax=0x00000000 ebx=0x00000001 ecx=0x00000201 edx=0x00000003
vCPU 0 function=0xb index=2 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000002 edx=0x00000003
vCPU 0 function=0xd index=0 flags=0x00000001 eax=0x000002e7 ebx=0x00000a88 ecx=0x00000a88 edx=0x00000000
vCPU 0 function=0xd index=1 flags=0x00000001 eax=0x00000007 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=2 flags=0x00000001 eax=0x00000100 ebx=0x00000240 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=5 flags=0x00000001 eax=0x00000040 ebx=0x00000440 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=6 flags=0x00000001 eax=0x00000200 ebx=0x00000480 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=7 flags=0x00000001 eax=0x00000400 ebx=0x00000680 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=9 flags=0x00000001 eax=0x00000008 ebx=0x00000a80 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0xd index=63 flags=0x00000001 eax=0x00000000 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x80000000 index=0 flags=0x00000000 eax=0x80000008 ebx=0x756e6547 ecx=0x6c65746e edx=0x49656e69
vCPU 0 function=0x80000001 index=0 flags=0x00000000 eax=0x00050654 ebx=0x00000000 ecx=0x00000121 edx=0x2c100800
vCPU 0 function=0x80000002 index=0 flags=0x00000000 eax=0x65746e49 ebx=0x6558206c ecx=0x50206e6f edx=0x65636f72
vCPU 0 function=0x80000003 index=0 flags=0x00000000 eax=0x726f7373 ebx=0x6b532820 ecx=0x6b616c79 edx=0x00002965
vCPU 0 function=0x80000005 index=0 flags=0x00000000 eax=0x01ff01ff ebx=0x01ff01ff ecx=0x40020140 edx=0x40020140
vCPU 0 function=0x80000006 index=0 flags=0x00000000 eax=0x00000000 ebx=0x42004200 ecx=0x02008140 edx=0x00808140
vCPU 0 function=0x80000008 index=0 flags=0x00000000 eax=0x00003028 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000000 index=0 flags=0x00000000 eax=0x40000005 ebx=0x7263694d ecx=0x666f736f edx=0x76482074
vCPU 0 function=0x40000001 index=0 flags=0x00000000 eax=0x31237648 ebx=0x00000000 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000002 index=0 flags=0x00000000 eax=0x00001bbc ebx=0x00060001 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000003 index=0 flags=0x00000000 eax=0x0000027f ebx=0x00000000 ecx=0x00000000 edx=0x00000008
vCPU 0 function=0x40000004 index=0 flags=0x00000000 eax=0x00000028 ebx=0x00000fff ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000005 index=0 flags=0x00000000 eax=0xffffffff ebx=0x00000040 ecx=0x00000000 edx=0x00000000
vCPU 0 function=0x40000100 index=0 flags=0x00000000 eax=0x40000101 ebx=0x4b4d564b ecx=0x564b4d56 edx=0x0000004d
vCPU 0 function=0x40000101 index=0 flags=0x00000000 eax=0x0100007b ebx=0x00000000 ecx=0x00000000 edx=0x00000000


```

`docs/qemu_migration`:

```
('timer', 0)
('slirp', 0)
('cpu_common', 0)
('cpu', 0)
('kvm-tpr-opt', 0)
('apic', 0)
('cpu_common', 1)
('cpu', 1)
('apic', 1)
('cpu_common', 2)
('cpu', 2)
('apic', 2)
('cpu_common', 3)
('cpu', 3)
('apic', 3)
('cpu_common', 4)
('cpu', 4)
('apic', 4)
('cpu_common', 5)
('cpu', 5)
('apic', 5)
('cpu_common', 6)
('cpu', 6)
('apic', 6)
('cpu_common', 7)
('cpu', 7)
('apic', 7)
('kvmclock', 0)
('fw_cfg', 0)
('0000:00:00.0/mch', 0)
('PCIHost', 0)
('PCIBUS', 0)
('0000:00:1f.0/ICH9LPC', 0)
('i8259', 0)
('i8259', 1)
('ioapic', 0)
('mc146818rtc', 0)
('i8254', 0)
('pcspk', 0)
('dma', 0)
('dma', 1)
('ps2kbd', 0)
('ps2mouse', 0)
('pckbd', 0)
('port92', 0)
('0000:00:1f.2/ich9_ahci', 0)
('i2c_bus', 0)
('0000:00:1f.3/ich9_smb', 0)
('0000:00:01.0/virtio-net', 0)
('0000:00:02.0/vfio', 0)
('0000:00:03.0/intel-hda', 0)
('hda-audio', 0)
('0000:00:04.0/virtio-console', 0)
('0000:00:05.0/virtio-balloon', 0)
('0000:00:06.0/virtio-blk', 0)
('acpi_build', 0)
('globalstate', 0)
{
    "page_size": 4096,
    "devices": [
        {
            "name": "timer",
            "instance_id": 0,
            "vmsd_name": "timer",
            "version": 2,
            "fields": [
                {
                    "name": "cpu_ticks_offset",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "unused",
                    "type": "unused_buffer",
                    "size": 8
                },
                {
                    "name": "cpu_clock_offset",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "slirp",
            "instance_id": 0,
            "size": 263110,
            "fields": [
                {
                    "name": "data",
                    "size": 263110,
                    "type": "buffer"
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 0,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 0,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                },
                {
                    "vmsd_name": "cpu/msr_smi_count",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.msr_smi_count",
                            "type": "uint64",
                            "size": 8
                        }
                    ]
                },
                {
                    "vmsd_name": "cpu/spec_ctrl",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.spec_ctrl",
                            "type": "uint64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "kvm-tpr-opt",
            "instance_id": 0,
            "vmsd_name": "kvm-tpr-opt",
            "version": 1,
            "fields": [
                {
                    "name": "rom_state",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "kvmvapic-guest-rom",
                        "version": 1,
                        "fields": [
                            {
                                "name": "unused",
                                "type": "unused_buffer",
                                "size": 8
                            },
                            {
                                "name": "vaddr",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "fixup_start",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "fixup_end",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "vapic_vaddr",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "vapic_size",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "vcpu_shift",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "real_tpr_addr",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "up",
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "kvmvapic-handlers",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "set_tpr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "set_tpr_eax",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "get_tpr",
                                            "array_len": 8,
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "get_tpr_stack",
                                            "type": "uint32",
                                            "size": 4
                                        }
                                    ]
                                },
                                "size": 44
                            },
                            {
                                "name": "mp",
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "kvmvapic-handlers",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "set_tpr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "set_tpr_eax",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "get_tpr",
                                            "array_len": 8,
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "get_tpr_stack",
                                            "type": "uint32",
                                            "size": 4
                                        }
                                    ]
                                },
                                "size": 44
                            }
                        ]
                    },
                    "size": 124
                },
                {
                    "name": "state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "real_tpr_addr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rom_state_vaddr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "vapic_paddr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rom_state_paddr",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 0,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 1,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 1,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 1,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 2,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 2,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 2,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 3,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 3,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 3,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 4,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 4,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 4,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 5,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 5,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 5,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 6,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 6,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 6,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "cpu_common",
            "instance_id": 7,
            "vmsd_name": "cpu_common",
            "version": 1,
            "fields": [
                {
                    "name": "halted",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "interrupt_request",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "cpu",
            "instance_id": 7,
            "vmsd_name": "cpu",
            "version": 12,
            "fields": [
                {
                    "name": "env.regs",
                    "array_len": 16,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.eflags",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.fpuc",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpus_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fptag_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs_format_vmstate",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.fpregs",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "fpreg",
                        "version": 0,
                        "fields": [
                            {
                                "name": "tmp",
                                "type": "tmp",
                                "vmsd_name": "fpreg_tmp",
                                "version": 0,
                                "fields": [
                                    {
                                        "name": "tmp_mant",
                                        "type": "uint64",
                                        "size": 8
                                    },
                                    {
                                        "name": "tmp_exp",
                                        "type": "uint16",
                                        "size": 2
                                    }
                                ],
                                "size": 10
                            }
                        ]
                    },
                    "size": 10
                },
                {
                    "name": "env.segs",
                    "array_len": 6,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.ldt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.tr",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.gdt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.idt",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "segment",
                        "version": 1,
                        "fields": [
                            {
                                "name": "selector",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "limit",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "flags",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 20
                },
                {
                    "name": "env.sysenter_cs",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.sysenter_esp",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.sysenter_eip",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[0]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[2]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[3]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cr[4]",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.dr",
                    "array_len": 8,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.a20_mask",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mxcsr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.xmm_regs[0]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "xmm_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[0]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[1]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.efer",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.star",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.lstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.cstar",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.fmask",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.kernelgsbase",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.smbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.pat",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.hflags2",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.vm_hsave",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.vm_vmcb",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_offset",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.intercept_cr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_cr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_read",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_dr_write",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "env.intercept_exceptions",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.v_tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.mtrr_fixed",
                    "array_len": 11,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_deftype",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mtrr_var",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "mtrr_var",
                        "version": 1,
                        "fields": [
                            {
                                "name": "base",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "mask",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                },
                {
                    "name": "env.interrupt_injected",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.mp_state",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.tsc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.exception_nr",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "env.soft_interrupt",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_injected",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.nmi_pending",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.has_error_code",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "env.sipi_vector",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "env.mcg_cap",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_status",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mcg_ctl",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.mce_banks",
                    "array_len": 40,
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.tsc_aux",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.system_time_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.wall_clock_msr",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xcr0",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xstate_bv",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "env.xmm_regs[1]",
                    "array_len": 16,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ymmh_reg",
                        "version": 1,
                        "fields": [
                            {
                                "name": "_q_ZMMReg[2]",
                                "type": "uint64",
                                "size": 8
                            },
                            {
                                "name": "_q_ZMMReg[3]",
                                "type": "uint64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 16
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "cpu/tsc_khz",
                    "version": 1,
                    "fields": [
                        {
                            "name": "env.tsc_khz",
                            "type": "int64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "apic",
            "instance_id": 7,
            "vmsd_name": "apic",
            "version": 3,
            "fields": [
                {
                    "name": "apicbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "arb_id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "tpr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "spurious_vec",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "log_dest",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dest_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "tmr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "array_len": 8,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "lvt",
                    "array_len": 6,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "esr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icr",
                    "array_len": 2,
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "divide_conf",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "count_shift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "initial_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "initial_count_load_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "next_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "timer_expiry",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "kvmclock",
            "instance_id": 0,
            "vmsd_name": "kvmclock",
            "version": 1,
            "fields": [
                {
                    "name": "clock",
                    "type": "uint64",
                    "size": 8
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "kvmclock/clock_is_reliable",
                    "version": 1,
                    "fields": [
                        {
                            "name": "clock_is_reliable",
                            "type": "bool",
                            "size": 1
                        }
                    ]
                }
            ]
        },
        {
            "name": "fw_cfg",
            "instance_id": 0,
            "vmsd_name": "fw_cfg",
            "version": 2,
            "fields": [
                {
                    "name": "cur_entry",
                    "type": "uint16",
                    "size": 2
                },
                {
                    "name": "cur_offset[1]",
                    "type": "uint32",
                    "size": 4
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "fw_cfg/dma",
                    "version": 0,
                    "fields": [
                        {
                            "name": "dma_addr",
                            "type": "uint64",
                            "size": 8
                        }
                    ]
                },
                {
                    "vmsd_name": "fw_cfg/acpi_mr",
                    "version": 1,
                    "fields": [
                        {
                            "name": "table_mr_size",
                            "type": "uint64",
                            "size": 8
                        },
                        {
                            "name": "linker_mr_size",
                            "type": "uint64",
                            "size": 8
                        },
                        {
                            "name": "rsdp_mr_size",
                            "type": "uint64",
                            "size": 8
                        }
                    ]
                }
            ]
        },
        {
            "name": "0000:00:00.0/mch",
            "instance_id": 0,
            "vmsd_name": "mch",
            "version": 1,
            "fields": [
                {
                    "name": "parent_obj",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PCIDevice",
                        "version": 2,
                        "fields": [
                            {
                                "name": "version_id",
                                "type": "int32 le",
                                "size": 4
                            },
                            {
                                "name": "config[0]",
                                "type": "pci config",
                                "size": 256
                            },
                            {
                                "name": "irq_state",
                                "type": "pci irq state",
                                "size": 16
                            }
                        ]
                    },
                    "size": 276
                },
                {
                    "name": "unused",
                    "type": "unused_buffer",
                    "size": 1
                }
            ]
        },
        {
            "name": "PCIHost",
            "instance_id": 0,
            "vmsd_name": "PCIHost",
            "version": 1,
            "fields": [
                {
                    "name": "config_reg",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "PCIBUS",
            "instance_id": 0,
            "vmsd_name": "PCIBUS",
            "version": 1,
            "fields": [
                {
                    "name": "nirq",
                    "type": "int32 equal",
                    "size": 4
                },
                {
                    "name": "irq_count",
                    "array_len": 8,
                    "type": "int32",
                    "size": 4
                }
            ]
        },
        {
            "name": "0000:00:1f.0/ICH9LPC",
            "instance_id": 0,
            "vmsd_name": "ICH9LPC",
            "version": 1,
            "fields": [
                {
                    "name": "d",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PCIDevice",
                        "version": 2,
                        "fields": [
                            {
                                "name": "version_id",
                                "type": "int32 le",
                                "size": 4
                            },
                            {
                                "name": "config[0]",
                                "type": "pci config",
                                "size": 256
                            },
                            {
                                "name": "irq_state",
                                "type": "pci irq state",
                                "size": 16
                            }
                        ]
                    },
                    "size": 276
                },
                {
                    "name": "apm",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "APM State",
                        "version": 1,
                        "fields": [
                            {
                                "name": "apmc",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "apms",
                                "type": "uint8",
                                "size": 1
                            }
                        ]
                    },
                    "size": 2
                },
                {
                    "name": "pm",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ich9_pm",
                        "version": 1,
                        "fields": [
                            {
                                "name": "acpi_regs.pm1.evt.sts",
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "acpi_regs.pm1.evt.en",
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "acpi_regs.pm1.cnt.cnt",
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "acpi_regs.tmr.timer",
                                "type": "timer",
                                "size": 8
                            },
                            {
                                "name": "acpi_regs.tmr.overflow_time",
                                "type": "int64",
                                "size": 8
                            },
                            {
                                "name": "acpi_regs.gpe.sts",
                                "array_len": 16,
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "acpi_regs.gpe.en",
                                "array_len": 16,
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smi_en",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "smi_sts",
                                "type": "uint32",
                                "size": 4
                            }
                        ],
                        "subsections": [
                            {
                                "vmsd_name": "ich9_pm/memhp",
                                "version": 1,
                                "fields": [
                                    {
                                        "name": "acpi_memory_hotplug",
                                        "type": "struct",
                                        "struct": {
                                            "vmsd_name": "memory hotplug state",
                                            "version": 1,
                                            "fields": [
                                                {
                                                    "name": "selector",
                                                    "type": "uint32",
                                                    "size": 4
                                                }
                                            ]
                                        },
                                        "size": 4
                                    }
                                ]
                            },
                            {
                                "vmsd_name": "ich9_pm/tco",
                                "version": 1,
                                "fields": [
                                    {
                                        "name": "tco_regs",
                                        "type": "struct",
                                        "struct": {
                                            "vmsd_name": "tco io device status",
                                            "version": 1,
                                            "fields": [
                                                {
                                                    "name": "tco.rld",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "tco.din",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco.dout",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco.sts1",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "tco.sts2",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "tco.cnt1",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "tco.cnt2",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "tco.msg1",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco.msg2",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco.wdcnt",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco.tmr",
                                                    "type": "uint16",
                                                    "size": 2
                                                },
                                                {
                                                    "name": "sw_irq_gen",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "tco_timer",
                                                    "type": "timer",
                                                    "size": 8
                                                },
                                                {
                                                    "name": "expire_time",
                                                    "type": "int64",
                                                    "size": 8
                                                },
                                                {
                                                    "name": "timeouts_no",
                                                    "type": "uint8",
                                                    "size": 1
                                                }
                                            ]
                                        },
                                        "size": 35
                                    }
                                ]
                            },
                            {
                                "vmsd_name": "ich9_pm/cpuhp",
                                "version": 1,
                                "fields": [
                                    {
                                        "name": "cpuhp_state",
                                        "type": "struct",
                                        "struct": {
                                            "vmsd_name": "CPU hotplug state",
                                            "version": 1,
                                            "fields": [
                                                {
                                                    "name": "selector",
                                                    "type": "uint32",
                                                    "size": 4
                                                },
                                                {
                                                    "name": "command",
                                                    "type": "uint8",
                                                    "size": 1
                                                },
                                                {
                                                    "name": "devs",
                                                    "array_len": 8,
                                                    "type": "struct",
                                                    "struct": {
                                                        "vmsd_name": "CPU hotplug device state",
                                                        "version": 1,
                                                        "fields": [
                                                            {
                                                                "name": "is_inserting",
                                                                "type": "bool",
                                                                "size": 1
                                                            },
                                                            {
                                                                "name": "is_removing",
                                                                "type": "bool",
                                                                "size": 1
                                                            },
                                                            {
                                                                "name": "ost_event",
                                                                "type": "uint32",
                                                                "size": 4
                                                            },
                                                            {
                                                                "name": "ost_status",
                                                                "type": "uint32",
                                                                "size": 4
                                                            }
                                                        ]
                                                    },
                                                    "size": 10
                                                }
                                            ]
                                        },
                                        "size": 85
                                    }
                                ]
                            }
                        ]
                    },
                    "size": 241
                },
                {
                    "name": "chip_config",
                    "array_len": 16384,
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "sci_level",
                    "type": "uint32",
                    "size": 4
                }
            ]
        },
        {
            "name": "i8259",
            "instance_id": 0,
            "vmsd_name": "i8259",
            "version": 1,
            "fields": [
                {
                    "name": "last_irr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "irr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "imr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "priority_add",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "irq_base",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "read_reg_select",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "poll",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "special_mask",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "init_state",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "auto_eoi",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "rotate_on_auto_eoi",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "special_fully_nested_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "init4",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "single_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "elcr",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "i8259",
            "instance_id": 1,
            "vmsd_name": "i8259",
            "version": 1,
            "fields": [
                {
                    "name": "last_irr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "irr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "imr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "isr",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "priority_add",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "irq_base",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "read_reg_select",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "poll",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "special_mask",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "init_state",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "auto_eoi",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "rotate_on_auto_eoi",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "special_fully_nested_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "init4",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "single_mode",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "elcr",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "ioapic",
            "instance_id": 0,
            "vmsd_name": "ioapic",
            "version": 3,
            "fields": [
                {
                    "name": "id",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "ioregsel",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "unused",
                    "type": "unused_buffer",
                    "size": 8
                },
                {
                    "name": "irr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "ioredtbl",
                    "array_len": 24,
                    "type": "uint64",
                    "size": 8
                }
            ]
        },
        {
            "name": "mc146818rtc",
            "instance_id": 0,
            "vmsd_name": "mc146818rtc",
            "version": 3,
            "fields": [
                {
                    "name": "cmos_data",
                    "type": "buffer",
                    "size": 128
                },
                {
                    "name": "cmos_index",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "unused[0]",
                    "type": "unused_buffer",
                    "size": 28
                },
                {
                    "name": "periodic_timer",
                    "type": "timer",
                    "size": 8
                },
                {
                    "name": "next_periodic_time",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "unused[1]",
                    "type": "unused_buffer",
                    "size": 24
                },
                {
                    "name": "irq_coalesced",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "period",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "base_rtc",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "last_update",
                    "type": "uint64",
                    "size": 8
                },
                {
                    "name": "offset",
                    "type": "int64",
                    "size": 8
                },
                {
                    "name": "update_timer",
                    "type": "timer",
                    "size": 8
                },
                {
                    "name": "next_alarm_time",
                    "type": "uint64",
                    "size": 8
                }
            ]
        },
        {
            "name": "i8254",
            "instance_id": 0,
            "vmsd_name": "i8254",
            "version": 3,
            "fields": [
                {
                    "name": "channels[0].irq_disabled",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "channels",
                    "array_len": 3,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "pit channel",
                        "version": 2,
                        "fields": [
                            {
                                "name": "count",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "latched_count",
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "count_latched",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "status_latched",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "status",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "read_state",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "write_state",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "write_latch",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "rw_mode",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "mode",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "bcd",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "gate",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "count_load_time",
                                "type": "int64",
                                "size": 8
                            },
                            {
                                "name": "next_transition_time",
                                "type": "int64",
                                "size": 8
                            }
                        ]
                    },
                    "size": 32
                },
                {
                    "name": "channels[0].next_transition_time",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "pcspk",
            "instance_id": 0,
            "vmsd_name": "pcspk",
            "version": 1,
            "fields": [
                {
                    "name": "data_on",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dummy_refresh_clock",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "dma",
            "instance_id": 0,
            "vmsd_name": "dma",
            "version": 1,
            "fields": [
                {
                    "name": "command",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mask",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "flip_flop",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dshift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "regs",
                    "array_len": 4,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "dma_regs",
                        "version": 1,
                        "fields": [
                            {
                                "name": "now",
                                "array_len": 2,
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "array_len": 2,
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "mode",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "page",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "pageh",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "dack",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "eop",
                                "type": "uint8",
                                "size": 1
                            }
                        ]
                    },
                    "size": 17
                }
            ]
        },
        {
            "name": "dma",
            "instance_id": 1,
            "vmsd_name": "dma",
            "version": 1,
            "fields": [
                {
                    "name": "command",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mask",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "flip_flop",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "dshift",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "regs",
                    "array_len": 4,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "dma_regs",
                        "version": 1,
                        "fields": [
                            {
                                "name": "now",
                                "array_len": 2,
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "base",
                                "array_len": 2,
                                "type": "uint16",
                                "size": 2
                            },
                            {
                                "name": "mode",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "page",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "pageh",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "dack",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "eop",
                                "type": "uint8",
                                "size": 1
                            }
                        ]
                    },
                    "size": 17
                }
            ]
        },
        {
            "name": "ps2kbd",
            "instance_id": 0,
            "vmsd_name": "ps2kbd",
            "version": 3,
            "fields": [
                {
                    "name": "common",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PS2 Common State",
                        "version": 3,
                        "fields": [
                            {
                                "name": "write_cmd",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.rptr",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.wptr",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.count",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.data",
                                "type": "buffer",
                                "size": 256
                            }
                        ]
                    },
                    "size": 272
                },
                {
                    "name": "scan_enabled",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "translate",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "scancode_set",
                    "type": "int32",
                    "size": 4
                }
            ],
            "subsections": [
                {
                    "vmsd_name": "ps2kbd/ledstate",
                    "version": 3,
                    "fields": [
                        {
                            "name": "ledstate",
                            "type": "int32",
                            "size": 4
                        }
                    ]
                }
            ]
        },
        {
            "name": "ps2mouse",
            "instance_id": 0,
            "vmsd_name": "ps2mouse",
            "version": 2,
            "fields": [
                {
                    "name": "common",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PS2 Common State",
                        "version": 3,
                        "fields": [
                            {
                                "name": "write_cmd",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.rptr",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.wptr",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.count",
                                "type": "int32",
                                "size": 4
                            },
                            {
                                "name": "queue.data",
                                "type": "buffer",
                                "size": 256
                            }
                        ]
                    },
                    "size": 272
                },
                {
                    "name": "mouse_status",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_resolution",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_sample_rate",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_wrap",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_type",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_detect_state",
                    "type": "uint8",
                    "size": 1
                },
                {
                    "name": "mouse_dx",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "mouse_dy",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "mouse_dz",
                    "type": "int32",
                    "size": 4
                },
                {
                    "name": "mouse_buttons",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "pckbd",
            "instance_id": 0,
            "vmsd_name": "pckbd",
            "version": 3,
            "fields": [
                {
                    "name": "kbd",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "pckbd",
                        "version": 3,
                        "fields": [
                            {
                                "name": "write_cmd",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "status",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "mode",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "pending",
                                "type": "uint8",
                                "size": 1
                            }
                        ]
                    },
                    "size": 4
                }
            ]
        },
        {
            "name": "port92",
            "instance_id": 0,
            "vmsd_name": "port92",
            "version": 1,
            "fields": [
                {
                    "name": "outport",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "0000:00:1f.2/ich9_ahci",
            "instance_id": 0,
            "vmsd_name": "ich9_ahci",
            "version": 1,
            "fields": [
                {
                    "name": "parent_obj",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PCIDevice",
                        "version": 2,
                        "fields": [
                            {
                                "name": "version_id",
                                "type": "int32 le",
                                "size": 4
                            },
                            {
                                "name": "config[0]",
                                "type": "pci config",
                                "size": 256
                            },
                            {
                                "name": "irq_state",
                                "type": "pci irq state",
                                "size": 16
                            }
                        ]
                    },
                    "size": 276
                },
                {
                    "name": "ahci",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "ahci",
                        "version": 1,
                        "fields": [
                            {
                                "name": "dev",
                                "index": 0,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "dev",
                                "index": 1,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "dev",
                                "index": 2,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "dev",
                                "index": 3,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "dev",
                                "index": 4,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "dev",
                                "index": 5,
                                "type": "struct",
                                "struct": {
                                    "vmsd_name": "ahci port",
                                    "version": 1,
                                    "fields": [
                                        {
                                            "name": "port",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_bus",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "unit",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 2
                                        },
                                        {
                                            "name": "port.ifs[0]",
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ide_drive",
                                                "version": 3,
                                                "fields": [
                                                    {
                                                        "name": "mult_sectors",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "identify_set",
                                                        "type": "int32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "error",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "nsector",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_feature",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_sector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_nsector",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_lcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "hob_hcyl",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "select",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "status",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "lba48",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "sense_key",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "asc",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cdrom_changed",
                                                        "type": "uint8",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 28
                                        },
                                        {
                                            "name": "port_state",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "finished",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.lst_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.fis_addr_hi",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.irq_mask",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.tfdata",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.sig",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_stat",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_ctl",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_err",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.scr_act",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "port_regs.cmd_issue",
                                            "type": "uint32",
                                            "size": 4
                                        },
                                        {
                                            "name": "done_first_drq",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "busy_slot",
                                            "type": "int32",
                                            "size": 4
                                        },
                                        {
                                            "name": "init_d2h_sent",
                                            "type": "bool",
                                            "size": 1
                                        },
                                        {
                                            "name": "ncq_tfs",
                                            "array_len": 32,
                                            "type": "struct",
                                            "struct": {
                                                "vmsd_name": "ncq state",
                                                "version": 1,
                                                "fields": [
                                                    {
                                                        "name": "sector_count",
                                                        "type": "uint32",
                                                        "size": 4
                                                    },
                                                    {
                                                        "name": "lba",
                                                        "type": "uint64",
                                                        "size": 8
                                                    },
                                                    {
                                                        "name": "tag",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "cmd",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "slot",
                                                        "type": "uint8",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "used",
                                                        "type": "bool",
                                                        "size": 1
                                                    },
                                                    {
                                                        "name": "halt",
                                                        "type": "bool",
                                                        "size": 1
                                                    }
                                                ]
                                            },
                                            "size": 17
                                        }
                                    ]
                                },
                                "size": 644
                            },
                            {
                                "name": "control_regs.cap",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "control_regs.ghc",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "control_regs.irqstatus",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "control_regs.impl",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "control_regs.version",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "idp_index",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "ports",
                                "type": "int32 equal",
                                "size": 4
                            }
                        ]
                    },
                    "size": 3892
                }
            ]
        },
        {
            "name": "i2c_bus",
            "instance_id": 0,
            "vmsd_name": "i2c_bus",
            "version": 1,
            "fields": [
                {
                    "name": "saved_address",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "0000:00:1f.3/ich9_smb",
            "instance_id": 0,
            "vmsd_name": "ich9_smb",
            "version": 1,
            "fields": [
                {
                    "name": "dev",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PCIDevice",
                        "version": 2,
                        "fields": [
                            {
                                "name": "version_id",
                                "type": "int32 le",
                                "size": 4
                            },
                            {
                                "name": "config[0]",
                                "type": "pci config",
                                "size": 256
                            },
                            {
                                "name": "irq_state",
                                "type": "pci irq state",
                                "size": 16
                            }
                        ]
                    },
                    "size": 276
                },
                {
                    "name": "irq_enabled",
                    "type": "bool",
                    "size": 1
                },
                {
                    "name": "smb",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "pmsmb",
                        "version": 1,
                        "fields": [
                            {
                                "name": "smb_stat",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_ctl",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_cmd",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_addr",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_data0",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_data1",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_index",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "smb_data",
                                "array_len": 32,
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_auxctl",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "smb_blkdata",
                                "type": "uint8",
                                "size": 1
                            },
                            {
                                "name": "i2c_enable",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "op_done",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "in_i2c_block_read",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "start_transaction_on_status_read",
                                "type": "bool",
                                "size": 1
                            }
                        ]
                    },
                    "size": 48
                }
            ]
        },
        {
            "name": "0000:00:01.0/virtio-net",
            "instance_id": 0,
            "vmsd_name": "virtio-net",
            "version": 11,
            "fields": [
                {
                    "name": "virtio",
                    "type": "virtio",
                    "size": 46091
                }
            ]
        },
        {
            "name": "0000:00:02.0/vfio",
            "instance_id": 0,
            "size": 4132,
            "fields": [
                {
                    "name": "data",
                    "size": 4132,
                    "type": "buffer"
                }
            ]
        },
        {
            "name": "0000:00:03.0/intel-hda",
            "instance_id": 0,
            "vmsd_name": "intel-hda",
            "version": 1,
            "fields": [
                {
                    "name": "pci",
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "PCIDevice",
                        "version": 2,
                        "fields": [
                            {
                                "name": "version_id",
                                "type": "int32 le",
                                "size": 4
                            },
                            {
                                "name": "config[0]",
                                "type": "pci config",
                                "size": 256
                            },
                            {
                                "name": "irq_state",
                                "type": "pci irq state",
                                "size": 16
                            }
                        ]
                    },
                    "size": 276
                },
                {
                    "name": "g_ctl",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "wake_en",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "state_sts",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "int_ctl",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "int_sts",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "wall_clk",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_lbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_ubase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_rp",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_wp",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_ctl",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_sts",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "corb_size",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_lbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_ubase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_wp",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_cnt",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_ctl",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_sts",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "rirb_size",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "dp_lbase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "dp_ubase",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "icw",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "irr",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "ics",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "st",
                    "array_len": 8,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "intel-hda-stream",
                        "version": 1,
                        "fields": [
                            {
                                "name": "ctl",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "lpib",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "cbl",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "lvi",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "fmt",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "bdlp_lbase",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "bdlp_ubase",
                                "type": "uint32",
                                "size": 4
                            }
                        ]
                    },
                    "size": 28
                },
                {
                    "name": "rirb_count",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "wall_base_ns",
                    "type": "int64",
                    "size": 8
                }
            ]
        },
        {
            "name": "hda-audio",
            "instance_id": 0,
            "vmsd_name": "hda-audio",
            "version": 2,
            "fields": [
                {
                    "name": "st",
                    "index": 0,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "hda-audio-stream",
                        "version": 1,
                        "fields": [
                            {
                                "name": "stream",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "channel",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "format",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_left",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_right",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "mute_left",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "mute_right",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "compat_bpos",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "compat_buf",
                                "type": "buffer",
                                "size": 256
                            }
                        ],
                        "subsections": [
                            {
                                "vmsd_name": "hda-audio-stream/buffer",
                                "version": 1,
                                "fields": [
                                    {
                                        "name": "buf",
                                        "type": "buffer",
                                        "size": 8192
                                    },
                                    {
                                        "name": "rpos",
                                        "type": "int64",
                                        "size": 8
                                    },
                                    {
                                        "name": "wpos",
                                        "type": "int64",
                                        "size": 8
                                    },
                                    {
                                        "name": "buft",
                                        "type": "timer",
                                        "size": 8
                                    },
                                    {
                                        "name": "buft_start",
                                        "type": "int64",
                                        "size": 8
                                    }
                                ]
                            }
                        ]
                    },
                    "size": 8535
                },
                {
                    "name": "st",
                    "index": 1,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "hda-audio-stream",
                        "version": 1,
                        "fields": [
                            {
                                "name": "stream",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "channel",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "format",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_left",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_right",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "mute_left",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "mute_right",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "compat_bpos",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "compat_buf",
                                "type": "buffer",
                                "size": 256
                            }
                        ],
                        "subsections": [
                            {
                                "vmsd_name": "hda-audio-stream/buffer",
                                "version": 1,
                                "fields": [
                                    {
                                        "name": "buf",
                                        "type": "buffer",
                                        "size": 8192
                                    },
                                    {
                                        "name": "rpos",
                                        "type": "int64",
                                        "size": 8
                                    },
                                    {
                                        "name": "wpos",
                                        "type": "int64",
                                        "size": 8
                                    },
                                    {
                                        "name": "buft",
                                        "type": "timer",
                                        "size": 8
                                    },
                                    {
                                        "name": "buft_start",
                                        "type": "int64",
                                        "size": 8
                                    }
                                ]
                            }
                        ]
                    },
                    "size": 8535
                },
                {
                    "name": "st",
                    "index": 2,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "hda-audio-stream",
                        "version": 1,
                        "fields": [
                            {
                                "name": "stream",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "channel",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "format",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_left",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_right",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "mute_left",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "mute_right",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "compat_bpos",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "compat_buf",
                                "type": "buffer",
                                "size": 256
                            }
                        ]
                    },
                    "size": 282
                },
                {
                    "name": "st",
                    "index": 3,
                    "type": "struct",
                    "struct": {
                        "vmsd_name": "hda-audio-stream",
                        "version": 1,
                        "fields": [
                            {
                                "name": "stream",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "channel",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "format",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_left",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "gain_right",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "mute_left",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "mute_right",
                                "type": "bool",
                                "size": 1
                            },
                            {
                                "name": "compat_bpos",
                                "type": "uint32",
                                "size": 4
                            },
                            {
                                "name": "compat_buf",
                                "type": "buffer",
                                "size": 256
                            }
                        ]
                    },
                    "size": 282
                },
                {
                    "name": "running_compat",
                    "array_len": 16,
                    "type": "bool",
                    "size": 1
                },
                {
                    "name": "running_real",
                    "array_len": 32,
                    "type": "bool",
                    "size": 1
                }
            ]
        },
        {
            "name": "0000:00:04.0/virtio-console",
            "instance_id": 0,
            "vmsd_name": "virtio-console",
            "version": 3,
            "fields": [
                {
                    "name": "virtio",
                    "type": "virtio",
                    "size": 46613
                }
            ]
        },
        {
            "name": "0000:00:05.0/virtio-balloon",
            "instance_id": 0,
            "vmsd_name": "virtio-balloon",
            "version": 1,
            "fields": [
                {
                    "name": "virtio",
                    "type": "virtio",
                    "size": 45562
                }
            ]
        },
        {
            "name": "0000:00:06.0/virtio-blk",
            "instance_id": 0,
            "vmsd_name": "virtio-blk",
            "version": 2,
            "fields": [
                {
                    "name": "virtio",
                    "type": "virtio",
                    "size": 45830
                }
            ]
        },
        {
            "name": "acpi_build",
            "instance_id": 0,
            "vmsd_name": "acpi_build",
            "version": 1,
            "fields": [
                {
                    "name": "patched",
                    "type": "uint8",
                    "size": 1
                }
            ]
        },
        {
            "name": "globalstate",
            "instance_id": 0,
            "vmsd_name": "globalstate",
            "version": 1,
            "fields": [
                {
                    "name": "size",
                    "type": "uint32",
                    "size": 4
                },
                {
                    "name": "runstate",
                    "type": "buffer",
                    "size": 100
                }
            ]
        }
    ]
}

```

`docs/stdvga_set_mode.txt`:

```txt
cc -I./include -I/usr/include -Wall -Werror -fno-exceptions -O2 -g -c -o ../build/viewer.o viewer.cc
cc -o ../build/mvisor ../build/viewer.o ../build/main.o ../build/arch/cpuid.o ../build/core/vcpu.o ../build/core/device_manager.o ../build/core/memory_manager.o ../build/core/machine.o ../build/images/raw.o ../build/images/image.o ../build/utils/logger.o ../build/devices/dummy.o ../build/devices/isa_dma.o ../build/devices/device.o ../build/devices/floppy.o ../build/devices/firmware_config.o ../build/devices/ide/ide_harddisk.o ../build/devices/ide/ide_controller.o ../build/devices/ide/ide_port.o ../build/devices/ide/ide_cdrom.o ../build/devices/ide/ide_storage.o ../build/devices/pci/pci_device.o ../build/devices/pci/ich9_lpc.o ../build/devices/pci/pci_host.o ../build/devices/char/serial_port.o ../build/devices/char/ps2.o ../build/devices/char/debug_console.o ../build/devices/ahci/ahci_port.o ../build/devices/ahci/ahci_host.o ../build/devices/rtc/cmos.o ../build/devices/display/vga.o ../build/keymap.o -lstdc++ -lpthread -lSDL
../build/mvisor
[2021-11-11 03:18:52] core/memory_manager.cc:21 InitializeSystemRam() ram size: 8192 MB
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() firmware-config register pio 0x00000510-0x00000511
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() firmware-config register pio 0x00000514-0x0000051b
[2021-11-11 03:18:52] devices/device.cc:35 Connect() root <= firmware-config
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() debugcon register pio 0x00000402-0x00000402
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= debugcon
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() rtc register pio 0x00000070-0x00000071
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= rtc
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ps2 register pio 0x00000092-0x00000092
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ps2 register pio 0x00000060-0x00000061
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ps2 register pio 0x00000064-0x00000065
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= ps2
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000020-0x00000021
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000040-0x00000043
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000000a0-0x000000a1
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000000ed-0x000000ed
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000000f0-0x000000f1
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000001e8-0x000001ef
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000168-0x0000016f
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000278-0x0000027a
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000002f2-0x000002f7
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000378-0x0000037a
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x000006f2-0x000006f9
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x00000a20-0x00000a24
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register pio 0x0000ae0c-0x0000ae1f
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() dummy register mmio 0xfed00000-0xfed003ff
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= dummy
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() serial-port register pio 0x000003f8-0x000003ff
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() serial-port register pio 0x000002f8-0x000002ff
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() serial-port register pio 0x000003e8-0x000003ef
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() serial-port register pio 0x000002e8-0x000002ef
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= serial-port
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() isa-dma register pio 0x00000000-0x0000000f
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() isa-dma register pio 0x000000c0-0x000000de
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() isa-dma register pio 0x00000080-0x0000008b
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ich9-lpc <= isa-dma
[2021-11-11 03:18:52] devices/device.cc:35 Connect() pci-host-bridge <= ich9-lpc
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register pio 0x000003c0-0x000003df
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register pio 0x000001ce-0x000001cf
[2021-11-11 03:18:52] devices/device.cc:35 Connect() pci-host-bridge <= vga
[2021-11-11 03:18:52] devices/device.cc:35 Connect() ide-controller <= ide-cdrom
[2021-11-11 03:18:52] devices/device.cc:35 Connect() pci-host-bridge <= ide-controller
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() pci-host-bridge register pio 0x00000cf8-0x00000cfb
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() pci-host-bridge register pio 0x00000cfc-0x00000cff
[2021-11-11 03:18:52] devices/device.cc:35 Connect() root <= pci-host-bridge
[2021-11-11 03:18:52] core/machine.cc:139 Run() ok
[2021-11-11 03:18:52] core/vcpu.cc:100 Process() vcpu-0 started
SeaBIOS (version rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org)
BUILD: gcc: (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39) binutils: version 2.27-43.base.el7_8.1
No Xen hypervisor found.
Running on QEMU (q35)
Running on KVM
[2021-11-11 03:18:52] devices/firmware_config.cc:141 Write() select entry 0
Found QEMU fw_cfg
[2021-11-11 03:18:52] devices/firmware_config.cc:141 Write() select entry 1
QEMU fw_cfg DMA interface supported
[2021-11-11 03:18:52] devices/firmware_config.cc:141 Write() select entry 34
qemu/e820: addr 0x0000000000000000 len 0x0000000080000000 [RAM]
qemu/e820: addr 0x0000000100000000 len 0x0000000180000000 [RAM]
Relocating init from 0x000d4bf0 to 0x7ffa9460 (size 92944)
[2021-11-11 03:18:52] devices/firmware_config.cc:197 DmaTransfer() config entry not found 0x8000
[2021-11-11 03:18:52] devices/firmware_config.cc:197 DmaTransfer() config entry not found 0x8001
kvmclock: at 0xeae20 (msr 0x4b564d01)
kvmclock: stable tsc, 2494 MHz
CPU Mhz=2494 (kvmclock)
=== PCI bus & bridge init ===
PCI: pci_bios_init_bus_rec bus = 0x0
=== PCI device probing ===
Found 4 PCI devices (max PCI bus is 00)
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() pci-host-bridge register mmio 0xb0000000-0xbfffffff
PCIe: using q35 mmconfig at 0xb0000000
=== PCI new allocation pass #1 ===
PCI: check devices
=== PCI new allocation pass #2 ===
PCI: IO: c000 - c037
PCI: 32: 00000000c0000000 - 00000000fec00000
PCI: map device bdf=00:02.0  bar 3, addr 0000c000, size 00000020 [io]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register pio 0x0000c000-0x0000c01f
PCI: map device bdf=00:01.0  bar 0, addr 0000c020, size 00000008 [io]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x0000c020-0x0000c027
PCI: map device bdf=00:01.0  bar 2, addr 0000c028, size 00000008 [io]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x0000c028-0x0000c02f
PCI: map device bdf=00:01.0  bar 1, addr 0000c030, size 00000004 [io]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x0000c030-0x0000c033
PCI: map device bdf=00:01.0  bar 3, addr 0000c034, size 00000004 [io]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x0000c034-0x0000c037
PCI: map device bdf=00:02.0  bar 0, addr e0000000, size 18000000 [mem]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register mmio 0xe0000000-0xf7ffffff
PCI: map device bdf=00:02.0  bar 1, addr f8000000, size 00800000 [mem]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register mmio 0xf8000000-0xf87fffff
PCI: map device bdf=00:02.0  bar 6, addr f8800000, size 0000a000 [mem]
PCI: map device bdf=00:02.0  bar 2, addr f880a000, size 00002000 [mem]
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() vga register mmio 0xf880a000-0xf880bfff
PCI: init bdf=00:00.0 id=8086:29c0
PCI: init bdf=00:01.0 id=8848:dede
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x000001f0-0x000001f7
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x000003f4-0x000003f7
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x00000170-0x00000177
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ide-controller register pio 0x00000374-0x00000377
PCI: init bdf=00:02.0 id=1b36:0100
PCI: init bdf=00:1f.0 id=8086:2918
Q35 LPC init: elcr=00 0c
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ich9-lpc register pio 0x0000b000-0x0000b07f
[2021-11-11 03:18:52] core/device_manager.cc:138 RegisterIoHandler() ich9-lpc register mmio 0xfed1c000-0xfed1ffff
PCI: Using 00:02.0 for primary VGA
Found 1 cpu(s) max supported 1 cpu(s)
Copying PIR from 0x7ffbfc8c to 0x000f5b90
Copying MPTABLE from 0x00006d30/7ffa0ae0 to 0x000f5aa0
Copying SMBIOS entry point from 0x00006c65 to 0x000f5950
[2021-11-11 03:18:52] devices/firmware_config.cc:141 Write() select entry 13
ACPI DSDT=0x7fffe4b0
Copying ACPI RSDP from 0x00006c10 to 0x000f5930
Scan for VGA option rom
Running option rom at c000:0003
Start SeaVGABIOS (version rel-1.14.0-0-g155821a1990b-prebuilt.qemu.org)
VGABUILD: gcc: (GCC) 4.8.5 20150623 (Red Hat 4.8.5-39) binutils: version 2.27-43.base.el7_8.1
enter vga_post:
   a=00000010  b=0000ffff  c=00000000  d=0000ffff ds=0000 es=f000 ss=0000
  si=00000000 di=00005f60 bp=00000000 sp=00006ca6 cs=f000 ip=d07a  f=0000

// SeaVGABIOS Initialization (2021/11/11 Terrence)
// w1: write one byte to port
// w2: write two bytes to port, for VGA ports normally the lower 8 bits is index
//     and the higher 8 bits is data
// r1 and r2 mean reading the byte(s) as above
// useful website to know registers:
// http://osdever.net/FreeVGA/vga/portidx.htm
// https://wiki.osdev.org/VGA_Hardware

// 3cx to 3dx are VGA ports and 1ce 1cf are VBE ports
// switch to color mode and enable CPU access 480 lines
[vga] w1 0x3c2=0xc3

// more than 64k 3C4/04
[vga] w2 0x3c4=0x204

// write VBE version
[vga] w2 0x1ce=0x0
[vga] w2 0x1cf=0xb0c0

// read the written version value, if they are the same, VBE is supported
[vga] w2 0x1ce=0x0
[vga] r2 0x1cf=0xb0c0

// write the VBE version we use
[vga] w2 0x1ce=0x0
[vga] w2 0x1cf=0xb0c5

VBE DISPI: bdf 00:02.0, bar 0

// get VRAM size
[vga] w2 0x1ce=0xa
[vga] r2 0x1cf=0x400
VBE DISPI: lfb_addr=e0000000, size 64 MB

// get VBE enable status
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x0

// set VBE caps reading mode
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x2
[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 0 to 2 0x0 bpp=0

// get maximum width (only in reading mode or the real width value will be read)
[vga] w2 0x1ce=0x1
[vga] r2 0x1cf=0x3e80

// get maximum bpp
[vga] w2 0x1ce=0x3
[vga] r2 0x1cf=0x20

// disable caps reading mode
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x0
[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 2 to 0 0x0 bpp=0
Attempting to allocate 512 bytes lowmem via pmm call to f000:d137
pmm call arg1=0
VGA stack allocated at eac20
Turning on vga text mode console
set VGA mode 3

// VGA mode set procedure
// VGA mode 3 is a text mode.
// Characters and attributes of screen texts are located at memory 0x000B8000
// disable VBE mode (actually not enabled yet, do nothing here)
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x0
[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 0 to 0 0x0 bpp=0

// palette mask, should always be 0xff for us
[vga] w1 0x3c6=0xff

// update palettes
// set palette index to 0
[vga] w1 0x3c8=0x0

// 192 lines of palette values 
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
// 192 lines of palettes end (64 rgb values)

// VGA always update all the palette values everytime
// reset the following (256-64) rgb values
[vga] w1 0x3c8=0x40
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x41
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x42
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x43
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x44
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x45
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x46
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x47
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x48
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x49
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x4f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x50
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x51
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x52
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x53
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x54
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x55
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x56
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x57
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x58
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x59
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x5f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x60
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x61
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x62
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x63
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x64
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x65
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x66
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x67
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x68
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x69
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x6f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x70
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x71
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x72
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x73
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x74
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x75
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x76
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x77
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x78
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x79
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x7f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x80
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x81
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x82
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x83
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x84
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x85
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x86
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x87
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x88
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x89
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x8f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x90
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x91
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x92
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x93
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x94
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x95
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x96
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x97
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x98
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x99
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9b
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9d
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9e
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0x9f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xa9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xaa
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xab
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xac
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xad
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xae
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xaf
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xb9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xba
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xbb
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xbc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xbd
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xbe
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xbf
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xc9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xca
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xcb
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xcc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xcd
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xce
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xcf
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xd9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xda
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xdb
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xdc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xdd
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xde
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xdf
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xe9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xea
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xeb
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xec
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xed
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xee
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xef
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf1
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf2
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf3
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf5
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf6
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xf9
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xfa
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xfb
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xfc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xfd
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xfe
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c8=0xff
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
// palette ends

// write VGA attributes 
// because writing the index and data with the same port, we don't know what the current reading state is
// thus for every attribute,
// 1. read 3da to reset attribute index reading mode
// 2. read 3c0 to get the old index
// 3. write the attribute index to 3c0
// 4. write the attribute value to 3c0
// 5. set the old index back to 3c0
// every 5 lines an attribute is updated.
// 20 attributes are updated here
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x1
[vga] w1 0x3c0=0x1
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x2
[vga] w1 0x3c0=0x2
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x3
[vga] w1 0x3c0=0x3
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x4
[vga] w1 0x3c0=0x4
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x5
[vga] w1 0x3c0=0x5
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x6
[vga] w1 0x3c0=0x14
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x7
[vga] w1 0x3c0=0x7
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x8
[vga] w1 0x3c0=0x38
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x9
[vga] w1 0x3c0=0x39
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xa
[vga] w1 0x3c0=0x3a
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xb
[vga] w1 0x3c0=0x3b
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xc
[vga] w1 0x3c0=0x3c
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xd
[vga] w1 0x3c0=0x3d
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xe
[vga] w1 0x3c0=0x3e
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0xf
[vga] w1 0x3c0=0x3f
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x10
[vga] w1 0x3c0=0xc
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x11
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x12
[vga] w1 0x3c0=0xf
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x13
[vga] w1 0x3c0=0x8
[vga] w1 0x3c0=0x0

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x0
[vga] w1 0x3c0=0x14
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x0

// attributes end

// set 5 seqneuncer registers
[vga] w2 0x3c4=0x300
[vga] w2 0x3c4=0x1
[vga] w2 0x3c4=0x302
[vga] w2 0x3c4=0x3
[vga] w2 0x3c4=0x204

// set 9 graphics controller registers
[vga] w2 0x3ce=0x0
[vga] w2 0x3ce=0x1
[vga] w2 0x3ce=0x2
[vga] w2 0x3ce=0x3
[vga] w2 0x3ce=0x4
[vga] w2 0x3ce=0x1005
[vga] w2 0x3ce=0xe06
[vga] w2 0x3ce=0xf07
[vga] w2 0x3ce=0xff08

// disable crtc write protection
[vga] w2 0x3d4=0x11

// set 24 crtc registers
[vga] w2 0x3d4=0x5f00
[vga] w2 0x3d4=0x4f01
[vga] w2 0x3d4=0x5002
[vga] w2 0x3d4=0x8203
[vga] w2 0x3d4=0x5504
[vga] w2 0x3d4=0x8105
[vga] w2 0x3d4=0xbf06
[vga] w2 0x3d4=0x1f07
[vga] w2 0x3d4=0x8
[vga] w2 0x3d4=0x4f09
[vga] w2 0x3d4=0xd0a
[vga] w2 0x3d4=0xe0b
[vga] w2 0x3d4=0xc
[vga] w2 0x3d4=0xd
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf
[vga] w2 0x3d4=0x9c10
[vga] w2 0x3d4=0x8e11
[vga] w2 0x3d4=0x8f12
[vga] w2 0x3d4=0x2813
[vga] w2 0x3d4=0x1f14
[vga] w2 0x3d4=0x9615
[vga] w2 0x3d4=0xb916
[vga] w2 0x3d4=0xa317
[vga] w2 0x3d4=0xff18

// set misc register
[vga] w1 0x3c2=0x67

// set attributes index to 0x20 which causes the VGA renderer refresh
[vga] r1 0x3da=0x0
[vga] w1 0x3c0=0x20

// load fonts into memory plane 2
// 4 lines to update seqneuncer and 3 lines to update graphics controller
// to get font access
[vga] w2 0x3c4=0x100
[vga] w2 0x3c4=0x402
[vga] w2 0x3c4=0x704
[vga] w2 0x3c4=0x300

[vga] w2 0x3ce=0x204
[vga] w2 0x3ce=0x5
[vga] w2 0x3ce=0x406

// to release font access
[vga] w2 0x3c4=0x100
[vga] w2 0x3c4=0x302
[vga] w2 0x3c4=0x304
[vga] w2 0x3c4=0x300

// the graphics controller registers are updated in different order
// read misc register and test the first bit
[vga] r1 0x3cc=0x67
[vga] w2 0x3ce=0xe06

[vga] w2 0x3ce=0x4
[vga] w2 0x3ce=0x1005
[vga] r1 0x3cc=0x67
// here VGA mode set finished

// the following are moving cursor functions
// read the misc register to check whether use 3bx or 3dx ports 
// then update the vertical location to a crtc controller register at index 0xe
// the horizontal location to index 0xf
// next, jump to the VBE mode set section

S[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x10f

e[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x20f

a[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x30f

B[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x40f

I[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x50f

O[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x60f
S[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x70f
 [vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x80f
([vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x90f
v[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xa0f
e[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xb0f
r[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xc0f
s[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xd0f
i[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xe0f
o[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf0f
n[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x100f
 [vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x110f
r[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x120f
e[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x130f
l[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x140f
-[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x150f
1[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x160f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x170f
1[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x180f
4[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x190f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1a0f
0[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1b0f
-[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1c0f
0[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1d0f
-[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1e0f
g[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x1f0f
1[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x200f
5[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x210f
5[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x220f
8[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x230f
2[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x240f
1[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x250f
a[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x260f
1[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x270f
9[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x280f
9[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x290f
0[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2a0f
b[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2b0f
-[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2c0f
p[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2d0f
r[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2e0f
e[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x2f0f
b[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x300f
u[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x310f
i[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x320f
l[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x330f
t[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x340f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x350f
q[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x360f
e[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x370f
m[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x380f
u[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x390f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x3a0f
o[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x3b0f
r[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x3c0f
g[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x3d0f
)[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x3e0f

[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x500f
ATA controller 1 at 1f0/3f4/0 (irq 14 dev 8)
ATA controller 2 at 170/374/0 (irq 14 dev 8)
Searching bootorder for: HALT
[2021-11-11 03:18:52] devices/dummy.cc:56 Write() pio ignore Parallel LPT2 write base=0x378 offset=0x2 size=1
[2021-11-11 03:18:52] devices/dummy.cc:56 Write() pio ignore Parallel LPT2 write base=0x378 offset=0x0 size=1
[2021-11-11 03:18:52] devices/dummy.cc:56 Write() pio ignore Parallel LPT1 write base=0x278 offset=0x2 size=1
[2021-11-11 03:18:52] devices/dummy.cc:56 Write() pio ignore Parallel LPT1 write base=0x278 offset=0x0 size=1
Found 0 lpt ports
[2021-11-11 03:18:52] devices/char/serial_port.cc:15 Write() serial-port ignore base=0x3f8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:20 Read() serial-port ignore base=0x3f8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:15 Write() serial-port ignore base=0x2f8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:20 Read() serial-port ignore base=0x2f8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:15 Write() serial-port ignore base=0x3e8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:20 Read() serial-port ignore base=0x3e8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:15 Write() serial-port ignore base=0x2e8 offset=0x1 size=1
[2021-11-11 03:18:52] devices/char/serial_port.cc:20 Read() serial-port ignore base=0x2e8 offset=0x1 size=1
Found 0 serial ports
[2021-11-11 03:18:52] devices/char/ps2.cc:273 ps2_command() unknown command 0x2
PS2 keyboard initialized
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa1
DVD/CD [ata0-0: DVD-ROM ATAPI-4 DVD/CD]
Searching bootorder for: /pci@i0cf8/*@1/drive@0/disk@0
Searching bios-geometry for: /pci@i0cf8/*@1/drive@0/disk@0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x11(0x8800) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x10(0x8000) count=0x1 total_read=0MB
All threads complete.
Scan for option roms
Searching bootorder for: HALT
Space available for UMB: ca000-ea000, f5410-f5890
Returned 253952 bytes of ZoneHigh
e820 map has 10 items:
  0: 0000000000000000 - 000000000009fc00 = 1 RAM
  1: 000000000009fc00 - 00000000000a0000 = 2 RESERVED
  2: 00000000000f0000 - 0000000000100000 = 2 RESERVED
  3: 0000000000100000 - 000000007fffe000 = 1 RAM
  4: 000000007fffe000 - 0000000080000000 = 2 RESERVED
  5: 00000000b0000000 - 00000000c0000000 = 2 RESERVED
  6: 00000000fed1c000 - 00000000fed20000 = 2 RESERVED
  7: 00000000feffc000 - 00000000ff000000 = 2 RESERVED
  8: 00000000fffc0000 - 0000000100000000 = 2 RESERVED
  9: 0000000100000000 - 0000000280000000 = 1 RAM
enter handle_19:
  NULL
B[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x510f
o[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x520f
o[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x530f
t[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x540f
i[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x550f
n[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x560f
g[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x570f
 [vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x580f
f[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x590f
r[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5a0f
o[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5b0f
m[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5c0f
 [vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5d0f
D[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5e0f
V[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x5f0f
D[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x600f
/[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x610f
C[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x620f
D[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x630f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x640f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x650f
.[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x660f

[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x500f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xa00f
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x11(0x8800) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x13(0x9800) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x1a(0xd000) count=0x1 total_read=0MB
Booting from 0000:7c00
VBE mode info request: 100
VBE mode info request: 101
VBE mode info request: 102
VBE mode info request: 103
VBE mode info request: 104
VBE mode info request: 105
VBE mode info request: 106
VBE mode info request: 107
VBE mode info request: 10d
VBE mode info request: 10e
VBE mode info request: 10f
VBE mode info request: 110
VBE mode info request: 111
VBE mode info request: 112
VBE mode info request: 113
VBE mode info request: 114
VBE mode info request: 115
VBE mode info request: 116
VBE mode info request: 117
VBE mode info request: 118
VBE mode info request: 119
VBE mode info request: 11a
VBE mode info request: 11b
VBE mode info request: 11c
VBE mode info request: 11d
VBE mode info request: 11e
VBE mode info request: 11f
VBE mode info request: 140
VBE mode info request: 141
VBE mode info request: 142
VBE mode info request: 143
VBE mode info request: 144
VBE mode info request: 145
VBE mode info request: 146
VBE mode info request: 147
VBE mode info request: 148
VBE mode info request: 149
VBE mode info request: 14a
VBE mode info request: 14b
VBE mode info request: 14c
VBE mode info request: 175
VBE mode info request: 176
VBE mode info request: 177
VBE mode info request: 178
VBE mode info request: 179
VBE mode info request: 17a
VBE mode info request: 17b
VBE mode info request: 17c
VBE mode info request: 17d
VBE mode info request: 17e
VBE mode info request: 17f
VBE mode info request: 180
VBE mode info request: 181
VBE mode info request: 182
VBE mode info request: 183
VBE mode info request: 184
VBE mode info request: 185
VBE mode info request: 186
VBE mode info request: 187
VBE mode info request: 188
VBE mode info request: 189
VBE mode info request: 18a
VBE mode info request: 18b
VBE mode info request: 18c
VBE mode info request: 18d
VBE mode info request: 18e
VBE mode info request: 18f
VBE mode info request: 190
VBE mode info request: 191
VBE mode info request: 192
VBE mode info request: 193
VBE mode info request: 194
VBE mode info request: 195
VBE mode info request: 196
VBE mode info request: 197
VBE mode info request: 198
VBE mode info request: 0
VBE mode info request: 1
VBE mode info request: 2
VBE mode info request: 3
VBE mode info request: 4
VBE mode info request: 5
VBE mode info request: 6
VBE mode info request: 7
VBE mode info request: d
VBE mode info request: e
VBE mode info request: f
VBE mode info request: 10
VBE mode info request: 11
VBE mode info request: 12
VBE mode info request: 13
VBE mode info request: 6a

// here moving cursors too
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xa00f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf00f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf10f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf20f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf30f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf40f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf50f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf60f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf70f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf80f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf90f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xfa0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xfb0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xfc0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xfd0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xfe0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xff0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0xf
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x10f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x20f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x30f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x40f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x50f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x60f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x70f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x80f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf00f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x400f
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x10(0x8000) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x18(0xc000) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x19(0xc800) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x17d3(0xbe9800) count=0x13 total_read=0MB
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x410f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x420f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x430f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x440f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x450f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x460f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x470f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x480f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x490f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x4a0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x4b0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x4c0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0x10e
[vga] w2 0x3d4=0x4d0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x10f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x20f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x30f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x40f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x50f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x60f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x70f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x80f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x90f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xa0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xb0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xc0f
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x10(0x8000) count=0x1 total_read=0MB
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xd0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xe0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf0f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x100f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x110f
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0xf
[vga] r1 0x3cc=0x67
[vga] w2 0x3d4=0xe
[vga] w2 0x3d4=0x500f
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x18(0xc000) count=0x1 total_read=0MB
VBE mode info request: 100
VBE mode info request: 101
ps2 mouse irq but no mouse data.
ps2 mouse irq but no mouse data.
VBE mode set: 101
set VGA mode 101

// VBE mode set begins
// mode 101: 640x480x8 (a SVGA mode)
// disable VBE mode first
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x0

[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 0 to 0 0x0 bpp=0

// update palettes
// reset the palette index to 0
[vga] w1 0x3c8=0x0

// then update 256 rgb values (256 * 3 lines here)
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x5
[vga] w1 0x3c9=0x5
[vga] w1 0x3c9=0x5
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x32
[vga] w1 0x3c9=0x32
[vga] w1 0x3c9=0x32
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x7
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x15
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x4
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xe
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x8
[vga] w1 0x3c9=0xa
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xf
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xd
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0xb
[vga] w1 0x3c9=0xc
[vga] w1 0x3c9=0x10
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
// palettes end

// set the video bpp to 8
[vga] w2 0x1ce=0x3
[vga] w2 0x1cf=0x8

// set width to 640
[vga] w2 0x1ce=0x1
[vga] w2 0x1cf=0x280

// set height to 480
[vga] w2 0x1ce=0x2
[vga] w2 0x1cf=0x1e0

// VBE bank offset
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0

// enable VBE mode
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x1

[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 0 to 1 640x480 bpp=8

// write crtc register index 0x11 to 0 (disable crtc registers protection)
[vga] w2 0x3d4=0x11

// crtc 0x01 to 0x4f (width / 8 - 1)
[vga] w2 0x3d4=0x4f01

// read misc to get crtc address
[vga] r1 0x3cc=0x67

// set scanline size (width / 8)
[vga] w2 0x3d4=0x5013

// set vertical lines, a little completed (so better get the video size by VBE registers)
[vga] w2 0x3d4=0xdf12
[vga] w1 0x3d4=0x7
[vga] r1 0x3d5=0x1f
[vga] w1 0x3d5=0x1f

// crtc: maximum scanline register
[vga] w2 0x3d4=0x9

// crtc: mode control
// sync enable: 1
// address wrap select: 1
// memory display address 14: 1
// memory display address 13: 1
[vga] w1 0x3d4=0x17
[vga] r1 0x3d5=0xa3
[vga] w1 0x3d5=0xa3

// reset attribute registers index
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20

// set index to 0x10
[vga] w1 0x3c0=0x10

// get the value at 0x10
[vga] r1 0x3c1=0x0

// set graphics enable to 1
[vga] w1 0x3c0=0x1

// restore the previous index value
[vga] w1 0x3c0=0x20

// set graphics controller index 0x6 to 0x5
// disable alphanumeric mode and select memory map 0xA0000 to 0xAFFFF (64KB)
[vga] w2 0x3ce=0x506

// enable all 4 memory planes to write
[vga] w2 0x3c4=0xf02

// if not planar mode, turn double word addressing on
[vga] w1 0x3d4=0x14
[vga] r1 0x3d5=0x1f
[vga] w1 0x3d5=0x5f

// turn on 8 bit mode
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x10
[vga] r1 0x3c1=0x0
[vga] w1 0x3c0=0x40
[vga] w1 0x3c0=0x20

// set seqneuncer index 0x4, eanble chain 4
[vga] w1 0x3c4=0x4
[vga] r1 0x3c5=0x3
[vga] w1 0x3c5=0xb

// horizontal retrace skew : don't know what to do yet
[vga] w1 0x3ce=0x5
[vga] r1 0x3cf=0x10
[vga] w1 0x3cf=0x50

// set attribute register index to 0x20
[vga] r1 0x3da=0x8
[vga] w1 0x3c0=0x20

[vga] r1 0x3cc=0x67
// VBE mode set is done now

// test VBE enable 
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1

// set bank offset to 0 (map 0xA0000 to VRAM 0)
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1

[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1

// set bank to 1 (map 0xA0000 to VRAM 0x10000) 
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1

[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1

// set bank to 2 ...
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x2
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x2
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1


[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x20

[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x1
[vga] w1 0x3c0=0x1
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x2
[vga] w1 0x3c0=0x2
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x3
[vga] w1 0x3c0=0x3
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x4
[vga] w1 0x3c0=0x4
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x5
[vga] w1 0x3c0=0x5
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x6
[vga] w1 0x3c0=0x6
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x7
[vga] w1 0x3c0=0x7
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x8
[vga] w1 0x3c0=0x8
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x9
[vga] w1 0x3c0=0x9
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xa
[vga] w1 0x3c0=0xa
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xb
[vga] w1 0x3c0=0xb
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xc
[vga] w1 0x3c0=0xc
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xd
[vga] w1 0x3c0=0xd
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xe
[vga] w1 0x3c0=0xe
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x8
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0xf
[vga] w1 0x3c0=0xf
[vga] w1 0x3c0=0x20
[vga] r1 0x3da=0x0
[vga] r1 0x3c0=0x20
[vga] w1 0x3c0=0x11
[vga] w1 0x3c0=0x0
[vga] w1 0x3c0=0x20

// update palettes
[vga] w1 0x3c8=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x19(0xc800) count=0x1 total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x1b(0xd800) count=0x1 total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] w2 0x1cf=0x1
[2021-11-11 03:18:52] devices/display/vga.cc:102 VbeIoWriteData() set vbe enable 1 to 1 640x480 bpp=8
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w1 0x3c8=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x3c
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x3c
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x1f
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x3c
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x2c
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2e
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x2c
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3c
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x1b
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x1b
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3a
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x3c
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x1b
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x28
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x27
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x29
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x19
[vga] w1 0x3c9=0x19
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x39
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x17
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x35
[vga] w1 0x3c9=0x1a
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x32
[vga] w1 0x3c9=0x20
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x37
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x31
[vga] w1 0x3c9=0x2d
[vga] w1 0x3c9=0x2f
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x18
[vga] w1 0x3c9=0x19
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x24
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x21
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x17
[vga] w1 0x3c9=0x16
[vga] w1 0x3c9=0x34
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x38
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x26
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x1b
[vga] w1 0x3c9=0x1b
[vga] w1 0x3c9=0x36
[vga] w1 0x3c9=0x22
[vga] w1 0x3c9=0x23
[vga] w1 0x3c9=0x3e
[vga] w1 0x3c9=0x17
[vga] w1 0x3c9=0x1c
[vga] w1 0x3c9=0x30
[vga] w1 0x3c9=0x13
[vga] w1 0x3c9=0x12
[vga] w1 0x3c9=0x32
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x1d
[vga] w1 0x3c9=0x3b
[vga] w1 0x3c9=0x13
[vga] w1 0x3c9=0x17
[vga] w1 0x3c9=0x2b
[vga] w1 0x3c9=0x11
[vga] w1 0x3c9=0x14
[vga] w1 0x3c9=0x2a
[vga] w1 0x3c9=0x1e
[vga] w1 0x3c9=0x25
[vga] w1 0x3c9=0x3d
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x33
[vga] w1 0x3c9=0x3f
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0
[vga] w1 0x3c9=0x0


[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x1c(0xe000) count=0x1a total_read=0MB
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x36(0x1b000) count=0x1a total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x50(0x28000) count=0x1a total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x2
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x2
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x6a(0x35000) count=0x1a total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x84(0x42000) count=0x1a total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:118 StartCommand() CDROM start command=0xa0
[2021-11-11 03:18:52] devices/ide/ide_cdrom.cc:143 ParseCommandPacket() #############PACKET command=0x28
[2021-11-11 03:18:52] images/raw.cc:16 Read() read at sector=0x9e(0x4f000) count=0x14 total_read=0MB
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x4
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x4
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x0
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x0
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x2
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x2
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
[vga] w2 0x1ce=0x5
[vga] w2 0x1cf=0x3
[vga] w2 0x1ce=0x5
[vga] r2 0x1cf=0x3
[vga] w2 0x1ce=0x4
[vga] r2 0x1cf=0x1
ps2 mouse irq but no mouse data.
ps2 mouse irq but no mouse data.

```

`gui/sdl/keymap.c`:

```c
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <stddef.h>
#include "keymap.h"

/* This key codes are same as QEMU's */
typedef enum QKeyCode {
  Q_KEY_CODE_UNMAPPED,
  Q_KEY_CODE_SHIFT,
  Q_KEY_CODE_SHIFT_R,
  Q_KEY_CODE_ALT,
  Q_KEY_CODE_ALT_R,
  Q_KEY_CODE_CTRL,
  Q_KEY_CODE_CTRL_R,
  Q_KEY_CODE_MENU,
  Q_KEY_CODE_ESC,
  Q_KEY_CODE_1,
  Q_KEY_CODE_2,
  Q_KEY_CODE_3,
  Q_KEY_CODE_4,
  Q_KEY_CODE_5,
  Q_KEY_CODE_6,
  Q_KEY_CODE_7,
  Q_KEY_CODE_8,
  Q_KEY_CODE_9,
  Q_KEY_CODE_0,
  Q_KEY_CODE_MINUS,
  Q_KEY_CODE_EQUAL,
  Q_KEY_CODE_BACKSPACE,
  Q_KEY_CODE_TAB,
  Q_KEY_CODE_Q,
  Q_KEY_CODE_W,
  Q_KEY_CODE_E,
  Q_KEY_CODE_R,
  Q_KEY_CODE_T,
  Q_KEY_CODE_Y,
  Q_KEY_CODE_U,
  Q_KEY_CODE_I,
  Q_KEY_CODE_O,
  Q_KEY_CODE_P,
  Q_KEY_CODE_BRACKET_LEFT,
  Q_KEY_CODE_BRACKET_RIGHT,
  Q_KEY_CODE_RET,
  Q_KEY_CODE_A,
  Q_KEY_CODE_S,
  Q_KEY_CODE_D,
  Q_KEY_CODE_F,
  Q_KEY_CODE_G,
  Q_KEY_CODE_H,
  Q_KEY_CODE_J,
  Q_KEY_CODE_K,
  Q_KEY_CODE_L,
  Q_KEY_CODE_SEMICOLON,
  Q_KEY_CODE_APOSTROPHE,
  Q_KEY_CODE_GRAVE_ACCENT,
  Q_KEY_CODE_BACKSLASH,
  Q_KEY_CODE_Z,
  Q_KEY_CODE_X,
  Q_KEY_CODE_C,
  Q_KEY_CODE_V,
  Q_KEY_CODE_B,
  Q_KEY_CODE_N,
  Q_KEY_CODE_M,
  Q_KEY_CODE_COMMA,
  Q_KEY_CODE_DOT,
  Q_KEY_CODE_SLASH,
  Q_KEY_CODE_ASTERISK,
  Q_KEY_CODE_SPC,
  Q_KEY_CODE_CAPS_LOCK,
  Q_KEY_CODE_F1,
  Q_KEY_CODE_F2,
  Q_KEY_CODE_F3,
  Q_KEY_CODE_F4,
  Q_KEY_CODE_F5,
  Q_KEY_CODE_F6,
  Q_KEY_CODE_F7,
  Q_KEY_CODE_F8,
  Q_KEY_CODE_F9,
  Q_KEY_CODE_F10,
  Q_KEY_CODE_NUM_LOCK,
  Q_KEY_CODE_SCROLL_LOCK,
  Q_KEY_CODE_KP_DIVIDE,
  Q_KEY_CODE_KP_MULTIPLY,
  Q_KEY_CODE_KP_SUBTRACT,
  Q_KEY_CODE_KP_ADD,
  Q_KEY_CODE_KP_ENTER,
  Q_KEY_CODE_KP_DECIMAL,
  Q_KEY_CODE_SYSRQ,
  Q_KEY_CODE_KP_0,
  Q_KEY_CODE_KP_1,
  Q_KEY_CODE_KP_2,
  Q_KEY_CODE_KP_3,
  Q_KEY_CODE_KP_4,
  Q_KEY_CODE_KP_5,
  Q_KEY_CODE_KP_6,
  Q_KEY_CODE_KP_7,
  Q_KEY_CODE_KP_8,
  Q_KEY_CODE_KP_9,
  Q_KEY_CODE_LESS,
  Q_KEY_CODE_F11,
  Q_KEY_CODE_F12,
  Q_KEY_CODE_PRINT,
  Q_KEY_CODE_HOME,
  Q_KEY_CODE_PGUP,
  Q_KEY_CODE_PGDN,
  Q_KEY_CODE_END,
  Q_KEY_CODE_LEFT,
  Q_KEY_CODE_UP,
  Q_KEY_CODE_DOWN,
  Q_KEY_CODE_RIGHT,
  Q_KEY_CODE_INSERT,
  Q_KEY_CODE_DELETE,
  Q_KEY_CODE_STOP,
  Q_KEY_CODE_AGAIN,
  Q_KEY_CODE_PROPS,
  Q_KEY_CODE_UNDO,
  Q_KEY_CODE_FRONT,
  Q_KEY_CODE_COPY,
  Q_KEY_CODE_OPEN,
  Q_KEY_CODE_PASTE,
  Q_KEY_CODE_FIND,
  Q_KEY_CODE_CUT,
  Q_KEY_CODE_LF,
  Q_KEY_CODE_HELP,
  Q_KEY_CODE_META_L,
  Q_KEY_CODE_META_R,
  Q_KEY_CODE_COMPOSE,
  Q_KEY_CODE_PAUSE,
  Q_KEY_CODE_RO,
  Q_KEY_CODE_HIRAGANA,
  Q_KEY_CODE_HENKAN,
  Q_KEY_CODE_YEN,
  Q_KEY_CODE_MUHENKAN,
  Q_KEY_CODE_KATAKANAHIRAGANA,
  Q_KEY_CODE_KP_COMMA,
  Q_KEY_CODE_KP_EQUALS,
  Q_KEY_CODE_POWER,
  Q_KEY_CODE_SLEEP,
  Q_KEY_CODE_WAKE,
  Q_KEY_CODE_AUDIONEXT,
  Q_KEY_CODE_AUDIOPREV,
  Q_KEY_CODE_AUDIOSTOP,
  Q_KEY_CODE_AUDIOPLAY,
  Q_KEY_CODE_AUDIOMUTE,
  Q_KEY_CODE_VOLUMEUP,
  Q_KEY_CODE_VOLUMEDOWN,
  Q_KEY_CODE_MEDIASELECT,
  Q_KEY_CODE_MAIL,
  Q_KEY_CODE_CALCULATOR,
  Q_KEY_CODE_COMPUTER,
  Q_KEY_CODE_AC_HOME,
  Q_KEY_CODE_AC_BACK,
  Q_KEY_CODE_AC_FORWARD,
  Q_KEY_CODE_AC_REFRESH,
  Q_KEY_CODE_AC_BOOKMARKS,
  Q_KEY_CODE__MAX,
} QKeyCode;

/* The following keymaps are auto-generated by QEMU scripts */

const uint16_t qemu_input_map_usb_to_qcode[252] = {
  [0x4] = Q_KEY_CODE_A, /* usb:4 -> linux:30 (KEY_A) -> qcode:Q_KEY_CODE_A (a) */
  [0x5] = Q_KEY_CODE_B, /* usb:5 -> linux:48 (KEY_B) -> qcode:Q_KEY_CODE_B (b) */
  [0x6] = Q_KEY_CODE_C, /* usb:6 -> linux:46 (KEY_C) -> qcode:Q_KEY_CODE_C (c) */
  [0x7] = Q_KEY_CODE_D, /* usb:7 -> linux:32 (KEY_D) -> qcode:Q_KEY_CODE_D (d) */
  [0x8] = Q_KEY_CODE_E, /* usb:8 -> linux:18 (KEY_E) -> qcode:Q_KEY_CODE_E (e) */
  [0x9] = Q_KEY_CODE_F, /* usb:9 -> linux:33 (KEY_F) -> qcode:Q_KEY_CODE_F (f) */
  [0xa] = Q_KEY_CODE_G, /* usb:10 -> linux:34 (KEY_G) -> qcode:Q_KEY_CODE_G (g) */
  [0xb] = Q_KEY_CODE_H, /* usb:11 -> linux:35 (KEY_H) -> qcode:Q_KEY_CODE_H (h) */
  [0xc] = Q_KEY_CODE_I, /* usb:12 -> linux:23 (KEY_I) -> qcode:Q_KEY_CODE_I (i) */
  [0xd] = Q_KEY_CODE_J, /* usb:13 -> linux:36 (KEY_J) -> qcode:Q_KEY_CODE_J (j) */
  [0xe] = Q_KEY_CODE_K, /* usb:14 -> linux:37 (KEY_K) -> qcode:Q_KEY_CODE_K (k) */
  [0xf] = Q_KEY_CODE_L, /* usb:15 -> linux:38 (KEY_L) -> qcode:Q_KEY_CODE_L (l) */
  [0x10] = Q_KEY_CODE_M, /* usb:16 -> linux:50 (KEY_M) -> qcode:Q_KEY_CODE_M (m) */
  [0x11] = Q_KEY_CODE_N, /* usb:17 -> linux:49 (KEY_N) -> qcode:Q_KEY_CODE_N (n) */
  [0x12] = Q_KEY_CODE_O, /* usb:18 -> linux:24 (KEY_O) -> qcode:Q_KEY_CODE_O (o) */
  [0x13] = Q_KEY_CODE_P, /* usb:19 -> linux:25 (KEY_P) -> qcode:Q_KEY_CODE_P (p) */
  [0x14] = Q_KEY_CODE_Q, /* usb:20 -> linux:16 (KEY_Q) -> qcode:Q_KEY_CODE_Q (q) */
  [0x15] = Q_KEY_CODE_R, /* usb:21 -> linux:19 (KEY_R) -> qcode:Q_KEY_CODE_R (r) */
  [0x16] = Q_KEY_CODE_S, /* usb:22 -> linux:31 (KEY_S) -> qcode:Q_KEY_CODE_S (s) */
  [0x17] = Q_KEY_CODE_T, /* usb:23 -> linux:20 (KEY_T) -> qcode:Q_KEY_CODE_T (t) */
  [0x18] = Q_KEY_CODE_U, /* usb:24 -> linux:22 (KEY_U) -> qcode:Q_KEY_CODE_U (u) */
  [0x19] = Q_KEY_CODE_V, /* usb:25 -> linux:47 (KEY_V) -> qcode:Q_KEY_CODE_V (v) */
  [0x1a] = Q_KEY_CODE_W, /* usb:26 -> linux:17 (KEY_W) -> qcode:Q_KEY_CODE_W (w) */
  [0x1b] = Q_KEY_CODE_X, /* usb:27 -> linux:45 (KEY_X) -> qcode:Q_KEY_CODE_X (x) */
  [0x1c] = Q_KEY_CODE_Y, /* usb:28 -> linux:21 (KEY_Y) -> qcode:Q_KEY_CODE_Y (y) */
  [0x1d] = Q_KEY_CODE_Z, /* usb:29 -> linux:44 (KEY_Z) -> qcode:Q_KEY_CODE_Z (z) */
  [0x1e] = Q_KEY_CODE_1, /* usb:30 -> linux:2 (KEY_1) -> qcode:Q_KEY_CODE_1 (1) */
  [0x1f] = Q_KEY_CODE_2, /* usb:31 -> linux:3 (KEY_2) -> qcode:Q_KEY_CODE_2 (2) */
  [0x20] = Q_KEY_CODE_3, /* usb:32 -> linux:4 (KEY_3) -> qcode:Q_KEY_CODE_3 (3) */
  [0x21] = Q_KEY_CODE_4, /* usb:33 -> linux:5 (KEY_4) -> qcode:Q_KEY_CODE_4 (4) */
  [0x22] = Q_KEY_CODE_5, /* usb:34 -> linux:6 (KEY_5) -> qcode:Q_KEY_CODE_5 (5) */
  [0x23] = Q_KEY_CODE_6, /* usb:35 -> linux:7 (KEY_6) -> qcode:Q_KEY_CODE_6 (6) */
  [0x24] = Q_KEY_CODE_7, /* usb:36 -> linux:8 (KEY_7) -> qcode:Q_KEY_CODE_7 (7) */
  [0x25] = Q_KEY_CODE_8, /* usb:37 -> linux:9 (KEY_8) -> qcode:Q_KEY_CODE_8 (8) */
  [0x26] = Q_KEY_CODE_9, /* usb:38 -> linux:10 (KEY_9) -> qcode:Q_KEY_CODE_9 (9) */
  [0x27] = Q_KEY_CODE_0, /* usb:39 -> linux:11 (KEY_0) -> qcode:Q_KEY_CODE_0 (0) */
  [0x28] = Q_KEY_CODE_RET, /* usb:40 -> linux:28 (KEY_ENTER) -> qcode:Q_KEY_CODE_RET (ret) */
  [0x29] = Q_KEY_CODE_ESC, /* usb:41 -> linux:1 (KEY_ESC) -> qcode:Q_KEY_CODE_ESC (esc) */
  [0x2a] = Q_KEY_CODE_BACKSPACE, /* usb:42 -> linux:14 (KEY_BACKSPACE) -> qcode:Q_KEY_CODE_BACKSPACE (backspace) */
  [0x2b] = Q_KEY_CODE_TAB, /* usb:43 -> linux:15 (KEY_TAB) -> qcode:Q_KEY_CODE_TAB (tab) */
  [0x2c] = Q_KEY_CODE_SPC, /* usb:44 -> linux:57 (KEY_SPACE) -> qcode:Q_KEY_CODE_SPC (spc) */
  [0x2d] = Q_KEY_CODE_MINUS, /* usb:45 -> linux:12 (KEY_MINUS) -> qcode:Q_KEY_CODE_MINUS (minus) */
  [0x2e] = Q_KEY_CODE_EQUAL, /* usb:46 -> linux:13 (KEY_EQUAL) -> qcode:Q_KEY_CODE_EQUAL (equal) */
  [0x2f] = Q_KEY_CODE_BRACKET_LEFT, /* usb:47 -> linux:26 (KEY_LEFTBRACE) -> qcode:Q_KEY_CODE_BRACKET_LEFT (bracket_left) */
  [0x30] = Q_KEY_CODE_BRACKET_RIGHT, /* usb:48 -> linux:27 (KEY_RIGHTBRACE) -> qcode:Q_KEY_CODE_BRACKET_RIGHT (bracket_right) */
  [0x31] = Q_KEY_CODE_BACKSLASH, /* usb:49 -> linux:43 (KEY_BACKSLASH) -> qcode:Q_KEY_CODE_BACKSLASH (backslash) */
  [0x32] = Q_KEY_CODE_BACKSLASH, /* usb:50 -> linux:43 (KEY_BACKSLASH) -> qcode:Q_KEY_CODE_BACKSLASH (backslash) */
  [0x33] = Q_KEY_CODE_SEMICOLON, /* usb:51 -> linux:39 (KEY_SEMICOLON) -> qcode:Q_KEY_CODE_SEMICOLON (semicolon) */
  [0x34] = Q_KEY_CODE_APOSTROPHE, /* usb:52 -> linux:40 (KEY_APOSTROPHE) -> qcode:Q_KEY_CODE_APOSTROPHE (apostrophe) */
  [0x35] = Q_KEY_CODE_GRAVE_ACCENT, /* usb:53 -> linux:41 (KEY_GRAVE) -> qcode:Q_KEY_CODE_GRAVE_ACCENT (grave_accent) */
  [0x36] = Q_KEY_CODE_COMMA, /* usb:54 -> linux:51 (KEY_COMMA) -> qcode:Q_KEY_CODE_COMMA (comma) */
  [0x37] = Q_KEY_CODE_DOT, /* usb:55 -> linux:52 (KEY_DOT) -> qcode:Q_KEY_CODE_DOT (dot) */
  [0x38] = Q_KEY_CODE_SLASH, /* usb:56 -> linux:53 (KEY_SLASH) -> qcode:Q_KEY_CODE_SLASH (slash) */
  [0x39] = Q_KEY_CODE_CAPS_LOCK, /* usb:57 -> linux:58 (KEY_CAPSLOCK) -> qcode:Q_KEY_CODE_CAPS_LOCK (caps_lock) */
  [0x3a] = Q_KEY_CODE_F1, /* usb:58 -> linux:59 (KEY_F1) -> qcode:Q_KEY_CODE_F1 (f1) */
  [0x3b] = Q_KEY_CODE_F2, /* usb:59 -> linux:60 (KEY_F2) -> qcode:Q_KEY_CODE_F2 (f2) */
  [0x3c] = Q_KEY_CODE_F3, /* usb:60 -> linux:61 (KEY_F3) -> qcode:Q_KEY_CODE_F3 (f3) */
  [0x3d] = Q_KEY_CODE_F4, /* usb:61 -> linux:62 (KEY_F4) -> qcode:Q_KEY_CODE_F4 (f4) */
  [0x3e] = Q_KEY_CODE_F5, /* usb:62 -> linux:63 (KEY_F5) -> qcode:Q_KEY_CODE_F5 (f5) */
  [0x3f] = Q_KEY_CODE_F6, /* usb:63 -> linux:64 (KEY_F6) -> qcode:Q_KEY_CODE_F6 (f6) */
  [0x40] = Q_KEY_CODE_F7, /* usb:64 -> linux:65 (KEY_F7) -> qcode:Q_KEY_CODE_F7 (f7) */
  [0x41] = Q_KEY_CODE_F8, /* usb:65 -> linux:66 (KEY_F8) -> qcode:Q_KEY_CODE_F8 (f8) */
  [0x42] = Q_KEY_CODE_F9, /* usb:66 -> linux:67 (KEY_F9) -> qcode:Q_KEY_CODE_F9 (f9) */
  [0x43] = Q_KEY_CODE_F10, /* usb:67 -> linux:68 (KEY_F10) -> qcode:Q_KEY_CODE_F10 (f10) */
  [0x44] = Q_KEY_CODE_F11, /* usb:68 -> linux:87 (KEY_F11) -> qcode:Q_KEY_CODE_F11 (f11) */
  [0x45] = Q_KEY_CODE_F12, /* usb:69 -> linux:88 (KEY_F12) -> qcode:Q_KEY_CODE_F12 (f12) */
  [0x46] = Q_KEY_CODE_SYSRQ, /* usb:70 -> linux:99 (KEY_SYSRQ) -> qcode:Q_KEY_CODE_SYSRQ (sysrq) */
  [0x47] = Q_KEY_CODE_SCROLL_LOCK, /* usb:71 -> linux:70 (KEY_SCROLLLOCK) -> qcode:Q_KEY_CODE_SCROLL_LOCK (scroll_lock) */
  [0x48] = Q_KEY_CODE_PAUSE, /* usb:72 -> linux:119 (KEY_PAUSE) -> qcode:Q_KEY_CODE_PAUSE (pause) */
  [0x49] = Q_KEY_CODE_INSERT, /* usb:73 -> linux:110 (KEY_INSERT) -> qcode:Q_KEY_CODE_INSERT (insert) */
  [0x4a] = Q_KEY_CODE_HOME, /* usb:74 -> linux:102 (KEY_HOME) -> qcode:Q_KEY_CODE_HOME (home) */
  [0x4b] = Q_KEY_CODE_PGUP, /* usb:75 -> linux:104 (KEY_PAGEUP) -> qcode:Q_KEY_CODE_PGUP (pgup) */
  [0x4c] = Q_KEY_CODE_DELETE, /* usb:76 -> linux:111 (KEY_DELETE) -> qcode:Q_KEY_CODE_DELETE (delete) */
  [0x4d] = Q_KEY_CODE_END, /* usb:77 -> linux:107 (KEY_END) -> qcode:Q_KEY_CODE_END (end) */
  [0x4e] = Q_KEY_CODE_PGDN, /* usb:78 -> linux:109 (KEY_PAGEDOWN) -> qcode:Q_KEY_CODE_PGDN (pgdn) */
  [0x4f] = Q_KEY_CODE_RIGHT, /* usb:79 -> linux:106 (KEY_RIGHT) -> qcode:Q_KEY_CODE_RIGHT (right) */
  [0x50] = Q_KEY_CODE_LEFT, /* usb:80 -> linux:105 (KEY_LEFT) -> qcode:Q_KEY_CODE_LEFT (left) */
  [0x51] = Q_KEY_CODE_DOWN, /* usb:81 -> linux:108 (KEY_DOWN) -> qcode:Q_KEY_CODE_DOWN (down) */
  [0x52] = Q_KEY_CODE_UP, /* usb:82 -> linux:103 (KEY_UP) -> qcode:Q_KEY_CODE_UP (up) */
  [0x53] = Q_KEY_CODE_NUM_LOCK, /* usb:83 -> linux:69 (KEY_NUMLOCK) -> qcode:Q_KEY_CODE_NUM_LOCK (num_lock) */
  [0x54] = Q_KEY_CODE_KP_DIVIDE, /* usb:84 -> linux:98 (KEY_KPSLASH) -> qcode:Q_KEY_CODE_KP_DIVIDE (kp_divide) */
  [0x55] = Q_KEY_CODE_KP_MULTIPLY, /* usb:85 -> linux:55 (KEY_KPASTERISK) -> qcode:Q_KEY_CODE_KP_MULTIPLY (kp_multiply) */
  [0x56] = Q_KEY_CODE_KP_SUBTRACT, /* usb:86 -> linux:74 (KEY_KPMINUS) -> qcode:Q_KEY_CODE_KP_SUBTRACT (kp_subtract) */
  [0x57] = Q_KEY_CODE_KP_ADD, /* usb:87 -> linux:78 (KEY_KPPLUS) -> qcode:Q_KEY_CODE_KP_ADD (kp_add) */
  [0x58] = Q_KEY_CODE_KP_ENTER, /* usb:88 -> linux:96 (KEY_KPENTER) -> qcode:Q_KEY_CODE_KP_ENTER (kp_enter) */
  [0x59] = Q_KEY_CODE_KP_1, /* usb:89 -> linux:79 (KEY_KP1) -> qcode:Q_KEY_CODE_KP_1 (kp_1) */
  [0x5a] = Q_KEY_CODE_KP_2, /* usb:90 -> linux:80 (KEY_KP2) -> qcode:Q_KEY_CODE_KP_2 (kp_2) */
  [0x5b] = Q_KEY_CODE_KP_3, /* usb:91 -> linux:81 (KEY_KP3) -> qcode:Q_KEY_CODE_KP_3 (kp_3) */
  [0x5c] = Q_KEY_CODE_KP_4, /* usb:92 -> linux:75 (KEY_KP4) -> qcode:Q_KEY_CODE_KP_4 (kp_4) */
  [0x5d] = Q_KEY_CODE_KP_5, /* usb:93 -> linux:76 (KEY_KP5) -> qcode:Q_KEY_CODE_KP_5 (kp_5) */
  [0x5e] = Q_KEY_CODE_KP_6, /* usb:94 -> linux:77 (KEY_KP6) -> qcode:Q_KEY_CODE_KP_6 (kp_6) */
  [0x5f] = Q_KEY_CODE_KP_7, /* usb:95 -> linux:71 (KEY_KP7) -> qcode:Q_KEY_CODE_KP_7 (kp_7) */
  [0x60] = Q_KEY_CODE_KP_8, /* usb:96 -> linux:72 (KEY_KP8) -> qcode:Q_KEY_CODE_KP_8 (kp_8) */
  [0x61] = Q_KEY_CODE_KP_9, /* usb:97 -> linux:73 (KEY_KP9) -> qcode:Q_KEY_CODE_KP_9 (kp_9) */
  [0x62] = Q_KEY_CODE_KP_0, /* usb:98 -> linux:82 (KEY_KP0) -> qcode:Q_KEY_CODE_KP_0 (kp_0) */
  [0x63] = Q_KEY_CODE_KP_DECIMAL, /* usb:99 -> linux:83 (KEY_KPDOT) -> qcode:Q_KEY_CODE_KP_DECIMAL (kp_decimal) */
  [0x64] = Q_KEY_CODE_LESS, /* usb:100 -> linux:86 (KEY_102ND) -> qcode:Q_KEY_CODE_LESS (less) */
  [0x65] = Q_KEY_CODE_COMPOSE, /* usb:101 -> linux:127 (KEY_COMPOSE) -> qcode:Q_KEY_CODE_COMPOSE (compose) */
  [0x66] = Q_KEY_CODE_POWER, /* usb:102 -> linux:116 (KEY_POWER) -> qcode:Q_KEY_CODE_POWER (power) */
  [0x67] = Q_KEY_CODE_KP_EQUALS, /* usb:103 -> linux:117 (KEY_KPEQUAL) -> qcode:Q_KEY_CODE_KP_EQUALS (kp_equals) */
  [0x68] = Q_KEY_CODE_UNMAPPED, /* usb:104 -> linux:183 (KEY_F13) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x69] = Q_KEY_CODE_UNMAPPED, /* usb:105 -> linux:184 (KEY_F14) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6a] = Q_KEY_CODE_UNMAPPED, /* usb:106 -> linux:185 (KEY_F15) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6b] = Q_KEY_CODE_UNMAPPED, /* usb:107 -> linux:186 (KEY_F16) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6c] = Q_KEY_CODE_UNMAPPED, /* usb:108 -> linux:187 (KEY_F17) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6d] = Q_KEY_CODE_UNMAPPED, /* usb:109 -> linux:188 (KEY_F18) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6e] = Q_KEY_CODE_UNMAPPED, /* usb:110 -> linux:189 (KEY_F19) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x6f] = Q_KEY_CODE_UNMAPPED, /* usb:111 -> linux:190 (KEY_F20) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x70] = Q_KEY_CODE_UNMAPPED, /* usb:112 -> linux:191 (KEY_F21) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x71] = Q_KEY_CODE_UNMAPPED, /* usb:113 -> linux:192 (KEY_F22) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x72] = Q_KEY_CODE_UNMAPPED, /* usb:114 -> linux:193 (KEY_F23) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x73] = Q_KEY_CODE_UNMAPPED, /* usb:115 -> linux:194 (KEY_F24) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x74] = Q_KEY_CODE_OPEN, /* usb:116 -> linux:134 (KEY_OPEN) -> qcode:Q_KEY_CODE_OPEN (open) */
  [0x75] = Q_KEY_CODE_HELP, /* usb:117 -> linux:138 (KEY_HELP) -> qcode:Q_KEY_CODE_HELP (help) */
  [0x76] = Q_KEY_CODE_MENU, /* usb:118 -> linux:139 (KEY_MENU) -> qcode:Q_KEY_CODE_MENU (menu) */
  [0x77] = Q_KEY_CODE_FRONT, /* usb:119 -> linux:132 (KEY_FRONT) -> qcode:Q_KEY_CODE_FRONT (front) */
  [0x78] = Q_KEY_CODE_STOP, /* usb:120 -> linux:128 (KEY_STOP) -> qcode:Q_KEY_CODE_STOP (stop) */
  [0x79] = Q_KEY_CODE_AGAIN, /* usb:121 -> linux:129 (KEY_AGAIN) -> qcode:Q_KEY_CODE_AGAIN (again) */
  [0x7a] = Q_KEY_CODE_UNDO, /* usb:122 -> linux:131 (KEY_UNDO) -> qcode:Q_KEY_CODE_UNDO (undo) */
  [0x7b] = Q_KEY_CODE_CUT, /* usb:123 -> linux:137 (KEY_CUT) -> qcode:Q_KEY_CODE_CUT (cut) */
  [0x7c] = Q_KEY_CODE_COPY, /* usb:124 -> linux:133 (KEY_COPY) -> qcode:Q_KEY_CODE_COPY (copy) */
  [0x7d] = Q_KEY_CODE_PASTE, /* usb:125 -> linux:135 (KEY_PASTE) -> qcode:Q_KEY_CODE_PASTE (paste) */
  [0x7e] = Q_KEY_CODE_FIND, /* usb:126 -> linux:136 (KEY_FIND) -> qcode:Q_KEY_CODE_FIND (find) */
  [0x7f] = Q_KEY_CODE_AUDIOMUTE, /* usb:127 -> linux:113 (KEY_MUTE) -> qcode:Q_KEY_CODE_AUDIOMUTE (audiomute) */
  [0x80] = Q_KEY_CODE_VOLUMEUP, /* usb:128 -> linux:115 (KEY_VOLUMEUP) -> qcode:Q_KEY_CODE_VOLUMEUP (volumeup) */
  [0x81] = Q_KEY_CODE_VOLUMEDOWN, /* usb:129 -> linux:114 (KEY_VOLUMEDOWN) -> qcode:Q_KEY_CODE_VOLUMEDOWN (volumedown) */
  [0x85] = Q_KEY_CODE_KP_COMMA, /* usb:133 -> linux:121 (KEY_KPCOMMA) -> qcode:Q_KEY_CODE_KP_COMMA (kp_comma) */
  [0x87] = Q_KEY_CODE_RO, /* usb:135 -> linux:89 (KEY_RO) -> qcode:Q_KEY_CODE_RO (ro) */
  [0x88] = Q_KEY_CODE_KATAKANAHIRAGANA, /* usb:136 -> linux:93 (KEY_KATAKANAHIRAGANA) -> qcode:Q_KEY_CODE_KATAKANAHIRAGANA (katakanahiragana) */
  [0x89] = Q_KEY_CODE_YEN, /* usb:137 -> linux:124 (KEY_YEN) -> qcode:Q_KEY_CODE_YEN (yen) */
  [0x8a] = Q_KEY_CODE_HENKAN, /* usb:138 -> linux:92 (KEY_HENKAN) -> qcode:Q_KEY_CODE_HENKAN (henkan) */
  [0x8b] = Q_KEY_CODE_MUHENKAN, /* usb:139 -> linux:94 (KEY_MUHENKAN) -> qcode:Q_KEY_CODE_MUHENKAN (muhenkan) */
  [0x8c] = Q_KEY_CODE_UNMAPPED, /* usb:140 -> linux:95 (KEY_KPJPCOMMA) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x90] = Q_KEY_CODE_UNMAPPED, /* usb:144 -> linux:122 (KEY_HANGEUL) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x91] = Q_KEY_CODE_UNMAPPED, /* usb:145 -> linux:123 (KEY_HANJA) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x92] = Q_KEY_CODE_UNMAPPED, /* usb:146 -> linux:90 (KEY_KATAKANA) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0x93] = Q_KEY_CODE_HIRAGANA, /* usb:147 -> linux:91 (KEY_HIRAGANA) -> qcode:Q_KEY_CODE_HIRAGANA (hiragana) */
  [0x94] = Q_KEY_CODE_UNMAPPED, /* usb:148 -> linux:85 (KEY_ZENKAKUHANKAKU) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xb6] = Q_KEY_CODE_UNMAPPED, /* usb:182 -> linux:179 (KEY_KPLEFTPAREN) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xb7] = Q_KEY_CODE_UNMAPPED, /* usb:183 -> linux:180 (KEY_KPRIGHTPAREN) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xe0] = Q_KEY_CODE_CTRL, /* usb:224 -> linux:29 (KEY_LEFTCTRL) -> qcode:Q_KEY_CODE_CTRL (ctrl) */
  [0xe1] = Q_KEY_CODE_SHIFT, /* usb:225 -> linux:42 (KEY_LEFTSHIFT) -> qcode:Q_KEY_CODE_SHIFT (shift) */
  [0xe2] = Q_KEY_CODE_ALT, /* usb:226 -> linux:56 (KEY_LEFTALT) -> qcode:Q_KEY_CODE_ALT (alt) */
  [0xe3] = Q_KEY_CODE_META_L, /* usb:227 -> linux:125 (KEY_LEFTMETA) -> qcode:Q_KEY_CODE_META_L (meta_l) */
  [0xe4] = Q_KEY_CODE_CTRL_R, /* usb:228 -> linux:97 (KEY_RIGHTCTRL) -> qcode:Q_KEY_CODE_CTRL_R (ctrl_r) */
  [0xe5] = Q_KEY_CODE_SHIFT_R, /* usb:229 -> linux:54 (KEY_RIGHTSHIFT) -> qcode:Q_KEY_CODE_SHIFT_R (shift_r) */
  [0xe6] = Q_KEY_CODE_ALT_R, /* usb:230 -> linux:100 (KEY_RIGHTALT) -> qcode:Q_KEY_CODE_ALT_R (alt_r) */
  [0xe7] = Q_KEY_CODE_META_R, /* usb:231 -> linux:126 (KEY_RIGHTMETA) -> qcode:Q_KEY_CODE_META_R (meta_r) */
  [0xe8] = Q_KEY_CODE_AUDIOPLAY, /* usb:232 -> linux:164 (KEY_PLAYPAUSE) -> qcode:Q_KEY_CODE_AUDIOPLAY (audioplay) */
  [0xe9] = Q_KEY_CODE_AUDIOSTOP, /* usb:233 -> linux:166 (KEY_STOPCD) -> qcode:Q_KEY_CODE_AUDIOSTOP (audiostop) */
  [0xea] = Q_KEY_CODE_AUDIOPREV, /* usb:234 -> linux:165 (KEY_PREVIOUSSONG) -> qcode:Q_KEY_CODE_AUDIOPREV (audioprev) */
  [0xeb] = Q_KEY_CODE_AUDIONEXT, /* usb:235 -> linux:163 (KEY_NEXTSONG) -> qcode:Q_KEY_CODE_AUDIONEXT (audionext) */
  [0xec] = Q_KEY_CODE_UNMAPPED, /* usb:236 -> linux:161 (KEY_EJECTCD) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xed] = Q_KEY_CODE_VOLUMEUP, /* usb:237 -> linux:115 (KEY_VOLUMEUP) -> qcode:Q_KEY_CODE_VOLUMEUP (volumeup) */
  [0xee] = Q_KEY_CODE_VOLUMEDOWN, /* usb:238 -> linux:114 (KEY_VOLUMEDOWN) -> qcode:Q_KEY_CODE_VOLUMEDOWN (volumedown) */
  [0xef] = Q_KEY_CODE_AUDIOMUTE, /* usb:239 -> linux:113 (KEY_MUTE) -> qcode:Q_KEY_CODE_AUDIOMUTE (audiomute) */
  [0xf0] = Q_KEY_CODE_UNMAPPED, /* usb:240 -> linux:150 (KEY_WWW) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xf1] = Q_KEY_CODE_AC_BACK, /* usb:241 -> linux:158 (KEY_BACK) -> qcode:Q_KEY_CODE_AC_BACK (ac_back) */
  [0xf2] = Q_KEY_CODE_AC_FORWARD, /* usb:242 -> linux:159 (KEY_FORWARD) -> qcode:Q_KEY_CODE_AC_FORWARD (ac_forward) */
  [0xf3] = Q_KEY_CODE_STOP, /* usb:243 -> linux:128 (KEY_STOP) -> qcode:Q_KEY_CODE_STOP (stop) */
  [0xf4] = Q_KEY_CODE_FIND, /* usb:244 -> linux:136 (KEY_FIND) -> qcode:Q_KEY_CODE_FIND (find) */
  [0xf5] = Q_KEY_CODE_UNMAPPED, /* usb:245 -> linux:177 (KEY_SCROLLUP) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xf6] = Q_KEY_CODE_UNMAPPED, /* usb:246 -> linux:178 (KEY_SCROLLDOWN) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xf7] = Q_KEY_CODE_UNMAPPED, /* usb:247 -> linux:176 (KEY_EDIT) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xf8] = Q_KEY_CODE_SLEEP, /* usb:248 -> linux:142 (KEY_SLEEP) -> qcode:Q_KEY_CODE_SLEEP (sleep) */
  [0xf9] = Q_KEY_CODE_UNMAPPED, /* usb:249 -> linux:152 (KEY_SCREENLOCK) -> qcode:Q_KEY_CODE_UNMAPPED (unnamed) */
  [0xfa] = Q_KEY_CODE_AC_REFRESH, /* usb:250 -> linux:173 (KEY_REFRESH) -> qcode:Q_KEY_CODE_AC_REFRESH (ac_refresh) */
  [0xfb] = Q_KEY_CODE_CALCULATOR, /* usb:251 -> linux:140 (KEY_CALC) -> qcode:Q_KEY_CODE_CALCULATOR (calculator) */
};
const size_t qemu_input_map_usb_to_qcode_len = sizeof(qemu_input_map_usb_to_qcode)/sizeof(qemu_input_map_usb_to_qcode[0]);

const uint16_t qemu_input_map_qcode_to_atset1[Q_KEY_CODE__MAX] = {
  [Q_KEY_CODE_0] = 0xb, /* qcode:Q_KEY_CODE_0 (0) -> linux:11 (KEY_0) -> atset1:11 */
  [Q_KEY_CODE_1] = 0x2, /* qcode:Q_KEY_CODE_1 (1) -> linux:2 (KEY_1) -> atset1:2 */
  [Q_KEY_CODE_2] = 0x3, /* qcode:Q_KEY_CODE_2 (2) -> linux:3 (KEY_2) -> atset1:3 */
  [Q_KEY_CODE_3] = 0x4, /* qcode:Q_KEY_CODE_3 (3) -> linux:4 (KEY_3) -> atset1:4 */
  [Q_KEY_CODE_4] = 0x5, /* qcode:Q_KEY_CODE_4 (4) -> linux:5 (KEY_4) -> atset1:5 */
  [Q_KEY_CODE_5] = 0x6, /* qcode:Q_KEY_CODE_5 (5) -> linux:6 (KEY_5) -> atset1:6 */
  [Q_KEY_CODE_6] = 0x7, /* qcode:Q_KEY_CODE_6 (6) -> linux:7 (KEY_6) -> atset1:7 */
  [Q_KEY_CODE_7] = 0x8, /* qcode:Q_KEY_CODE_7 (7) -> linux:8 (KEY_7) -> atset1:8 */
  [Q_KEY_CODE_8] = 0x9, /* qcode:Q_KEY_CODE_8 (8) -> linux:9 (KEY_8) -> atset1:9 */
  [Q_KEY_CODE_9] = 0xa, /* qcode:Q_KEY_CODE_9 (9) -> linux:10 (KEY_9) -> atset1:10 */
  [Q_KEY_CODE_A] = 0x1e, /* qcode:Q_KEY_CODE_A (a) -> linux:30 (KEY_A) -> atset1:30 */
  [Q_KEY_CODE_AC_BACK] = 0xe06a, /* qcode:Q_KEY_CODE_AC_BACK (ac_back) -> linux:158 (KEY_BACK) -> atset1:57450 */
  [Q_KEY_CODE_AC_BOOKMARKS] = 0xe066, /* qcode:Q_KEY_CODE_AC_BOOKMARKS (ac_bookmarks) -> linux:156 (KEY_BOOKMARKS) -> atset1:57446 */
  [Q_KEY_CODE_AC_FORWARD] = 0xe069, /* qcode:Q_KEY_CODE_AC_FORWARD (ac_forward) -> linux:159 (KEY_FORWARD) -> atset1:57449 */
  [Q_KEY_CODE_AC_HOME] = 0xe032, /* qcode:Q_KEY_CODE_AC_HOME (ac_home) -> linux:172 (KEY_HOMEPAGE) -> atset1:57394 */
  [Q_KEY_CODE_AC_REFRESH] = 0xe067, /* qcode:Q_KEY_CODE_AC_REFRESH (ac_refresh) -> linux:173 (KEY_REFRESH) -> atset1:57447 */
  [Q_KEY_CODE_AGAIN] = 0xe005, /* qcode:Q_KEY_CODE_AGAIN (again) -> linux:129 (KEY_AGAIN) -> atset1:57349 */
  [Q_KEY_CODE_ALT] = 0x38, /* qcode:Q_KEY_CODE_ALT (alt) -> linux:56 (KEY_LEFTALT) -> atset1:56 */
  [Q_KEY_CODE_ALT_R] = 0xe038, /* qcode:Q_KEY_CODE_ALT_R (alt_r) -> linux:100 (KEY_RIGHTALT) -> atset1:57400 */
  [Q_KEY_CODE_APOSTROPHE] = 0x28, /* qcode:Q_KEY_CODE_APOSTROPHE (apostrophe) -> linux:40 (KEY_APOSTROPHE) -> atset1:40 */
  [Q_KEY_CODE_ASTERISK] = 0x37, /* qcode:Q_KEY_CODE_ASTERISK (kp_multiply) -> linux:55 (KEY_KPASTERISK) -> atset1:55 */
  [Q_KEY_CODE_AUDIOMUTE] = 0xe020, /* qcode:Q_KEY_CODE_AUDIOMUTE (audiomute) -> linux:113 (KEY_MUTE) -> atset1:57376 */
  [Q_KEY_CODE_AUDIONEXT] = 0xe019, /* qcode:Q_KEY_CODE_AUDIONEXT (audionext) -> linux:163 (KEY_NEXTSONG) -> atset1:57369 */
  [Q_KEY_CODE_AUDIOPLAY] = 0xe022, /* qcode:Q_KEY_CODE_AUDIOPLAY (audioplay) -> linux:164 (KEY_PLAYPAUSE) -> atset1:57378 */
  [Q_KEY_CODE_AUDIOPREV] = 0xe010, /* qcode:Q_KEY_CODE_AUDIOPREV (audioprev) -> linux:165 (KEY_PREVIOUSSONG) -> atset1:57360 */
  [Q_KEY_CODE_AUDIOSTOP] = 0xe024, /* qcode:Q_KEY_CODE_AUDIOSTOP (audiostop) -> linux:166 (KEY_STOPCD) -> atset1:57380 */
  [Q_KEY_CODE_B] = 0x30, /* qcode:Q_KEY_CODE_B (b) -> linux:48 (KEY_B) -> atset1:48 */
  [Q_KEY_CODE_BACKSLASH] = 0x2b, /* qcode:Q_KEY_CODE_BACKSLASH (backslash) -> linux:43 (KEY_BACKSLASH) -> atset1:43 */
  [Q_KEY_CODE_BACKSPACE] = 0xe, /* qcode:Q_KEY_CODE_BACKSPACE (backspace) -> linux:14 (KEY_BACKSPACE) -> atset1:14 */
  [Q_KEY_CODE_BRACKET_LEFT] = 0x1a, /* qcode:Q_KEY_CODE_BRACKET_LEFT (bracket_left) -> linux:26 (KEY_LEFTBRACE) -> atset1:26 */
  [Q_KEY_CODE_BRACKET_RIGHT] = 0x1b, /* qcode:Q_KEY_CODE_BRACKET_RIGHT (bracket_right) -> linux:27 (KEY_RIGHTBRACE) -> atset1:27 */
  [Q_KEY_CODE_C] = 0x2e, /* qcode:Q_KEY_CODE_C (c) -> linux:46 (KEY_C) -> atset1:46 */
  [Q_KEY_CODE_CALCULATOR] = 0xe021, /* qcode:Q_KEY_CODE_CALCULATOR (calculator) -> linux:140 (KEY_CALC) -> atset1:57377 */
  [Q_KEY_CODE_CAPS_LOCK] = 0x3a, /* qcode:Q_KEY_CODE_CAPS_LOCK (caps_lock) -> linux:58 (KEY_CAPSLOCK) -> atset1:58 */
  [Q_KEY_CODE_COMMA] = 0x33, /* qcode:Q_KEY_CODE_COMMA (comma) -> linux:51 (KEY_COMMA) -> atset1:51 */
  [Q_KEY_CODE_COMPOSE] = 0xe05d, /* qcode:Q_KEY_CODE_COMPOSE (compose) -> linux:127 (KEY_COMPOSE) -> atset1:57437 */
  [Q_KEY_CODE_COMPUTER] = 0xe06b, /* qcode:Q_KEY_CODE_COMPUTER (computer) -> linux:157 (KEY_COMPUTER) -> atset1:57451 */
  [Q_KEY_CODE_COPY] = 0xe078, /* qcode:Q_KEY_CODE_COPY (copy) -> linux:133 (KEY_COPY) -> atset1:57464 */
  [Q_KEY_CODE_CTRL] = 0x1d, /* qcode:Q_KEY_CODE_CTRL (ctrl) -> linux:29 (KEY_LEFTCTRL) -> atset1:29 */
  [Q_KEY_CODE_CTRL_R] = 0xe01d, /* qcode:Q_KEY_CODE_CTRL_R (ctrl_r) -> linux:97 (KEY_RIGHTCTRL) -> atset1:57373 */
  [Q_KEY_CODE_CUT] = 0xe03c, /* qcode:Q_KEY_CODE_CUT (cut) -> linux:137 (KEY_CUT) -> atset1:57404 */
  [Q_KEY_CODE_D] = 0x20, /* qcode:Q_KEY_CODE_D (d) -> linux:32 (KEY_D) -> atset1:32 */
  [Q_KEY_CODE_DELETE] = 0xe053, /* qcode:Q_KEY_CODE_DELETE (delete) -> linux:111 (KEY_DELETE) -> atset1:57427 */
  [Q_KEY_CODE_DOT] = 0x34, /* qcode:Q_KEY_CODE_DOT (dot) -> linux:52 (KEY_DOT) -> atset1:52 */
  [Q_KEY_CODE_DOWN] = 0xe050, /* qcode:Q_KEY_CODE_DOWN (down) -> linux:108 (KEY_DOWN) -> atset1:57424 */
  [Q_KEY_CODE_E] = 0x12, /* qcode:Q_KEY_CODE_E (e) -> linux:18 (KEY_E) -> atset1:18 */
  [Q_KEY_CODE_END] = 0xe04f, /* qcode:Q_KEY_CODE_END (end) -> linux:107 (KEY_END) -> atset1:57423 */
  [Q_KEY_CODE_EQUAL] = 0xd, /* qcode:Q_KEY_CODE_EQUAL (equal) -> linux:13 (KEY_EQUAL) -> atset1:13 */
  [Q_KEY_CODE_ESC] = 0x1, /* qcode:Q_KEY_CODE_ESC (esc) -> linux:1 (KEY_ESC) -> atset1:1 */
  [Q_KEY_CODE_F] = 0x21, /* qcode:Q_KEY_CODE_F (f) -> linux:33 (KEY_F) -> atset1:33 */
  [Q_KEY_CODE_F1] = 0x3b, /* qcode:Q_KEY_CODE_F1 (f1) -> linux:59 (KEY_F1) -> atset1:59 */
  [Q_KEY_CODE_F10] = 0x44, /* qcode:Q_KEY_CODE_F10 (f10) -> linux:68 (KEY_F10) -> atset1:68 */
  [Q_KEY_CODE_F11] = 0x57, /* qcode:Q_KEY_CODE_F11 (f11) -> linux:87 (KEY_F11) -> atset1:87 */
  [Q_KEY_CODE_F12] = 0x58, /* qcode:Q_KEY_CODE_F12 (f12) -> linux:88 (KEY_F12) -> atset1:88 */
  [Q_KEY_CODE_F2] = 0x3c, /* qcode:Q_KEY_CODE_F2 (f2) -> linux:60 (KEY_F2) -> atset1:60 */
  [Q_KEY_CODE_F3] = 0x3d, /* qcode:Q_KEY_CODE_F3 (f3) -> linux:61 (KEY_F3) -> atset1:61 */
  [Q_KEY_CODE_F4] = 0x3e, /* qcode:Q_KEY_CODE_F4 (f4) -> linux:62 (KEY_F4) -> atset1:62 */
  [Q_KEY_CODE_F5] = 0x3f, /* qcode:Q_KEY_CODE_F5 (f5) -> linux:63 (KEY_F5) -> atset1:63 */
  [Q_KEY_CODE_F6] = 0x40, /* qcode:Q_KEY_CODE_F6 (f6) -> linux:64 (KEY_F6) -> atset1:64 */
  [Q_KEY_CODE_F7] = 0x41, /* qcode:Q_KEY_CODE_F7 (f7) -> linux:65 (KEY_F7) -> atset1:65 */
  [Q_KEY_CODE_F8] = 0x42, /* qcode:Q_KEY_CODE_F8 (f8) -> linux:66 (KEY_F8) -> atset1:66 */
  [Q_KEY_CODE_F9] = 0x43, /* qcode:Q_KEY_CODE_F9 (f9) -> linux:67 (KEY_F9) -> atset1:67 */
  [Q_KEY_CODE_FIND] = 0xe041, /* qcode:Q_KEY_CODE_FIND (find) -> linux:136 (KEY_FIND) -> atset1:57409 */
  [Q_KEY_CODE_FRONT] = 0xe00c, /* qcode:Q_KEY_CODE_FRONT (front) -> linux:132 (KEY_FRONT) -> atset1:57356 */
  [Q_KEY_CODE_G] = 0x22, /* qcode:Q_KEY_CODE_G (g) -> linux:34 (KEY_G) -> atset1:34 */
  [Q_KEY_CODE_GRAVE_ACCENT] = 0x29, /* qcode:Q_KEY_CODE_GRAVE_ACCENT (grave_accent) -> linux:41 (KEY_GRAVE) -> atset1:41 */
  [Q_KEY_CODE_H] = 0x23, /* qcode:Q_KEY_CODE_H (h) -> linux:35 (KEY_H) -> atset1:35 */
  [Q_KEY_CODE_HELP] = 0xe075, /* qcode:Q_KEY_CODE_HELP (help) -> linux:138 (KEY_HELP) -> atset1:57461 */
  [Q_KEY_CODE_HENKAN] = 0x79, /* qcode:Q_KEY_CODE_HENKAN (henkan) -> linux:92 (KEY_HENKAN) -> atset1:121 */
  [Q_KEY_CODE_HIRAGANA] = 0x77, /* qcode:Q_KEY_CODE_HIRAGANA (hiragana) -> linux:91 (KEY_HIRAGANA) -> atset1:119 */
  [Q_KEY_CODE_HOME] = 0xe047, /* qcode:Q_KEY_CODE_HOME (home) -> linux:102 (KEY_HOME) -> atset1:57415 */
  [Q_KEY_CODE_I] = 0x17, /* qcode:Q_KEY_CODE_I (i) -> linux:23 (KEY_I) -> atset1:23 */
  [Q_KEY_CODE_INSERT] = 0xe052, /* qcode:Q_KEY_CODE_INSERT (insert) -> linux:110 (KEY_INSERT) -> atset1:57426 */
  [Q_KEY_CODE_J] = 0x24, /* qcode:Q_KEY_CODE_J (j) -> linux:36 (KEY_J) -> atset1:36 */
  [Q_KEY_CODE_K] = 0x25, /* qcode:Q_KEY_CODE_K (k) -> linux:37 (KEY_K) -> atset1:37 */
  [Q_KEY_CODE_KATAKANAHIRAGANA] = 0x70, /* qcode:Q_KEY_CODE_KATAKANAHIRAGANA (katakanahiragana) -> linux:93 (KEY_KATAKANAHIRAGANA) -> atset1:112 */
  [Q_KEY_CODE_KP_0] = 0x52, /* qcode:Q_KEY_CODE_KP_0 (kp_0) -> linux:82 (KEY_KP0) -> atset1:82 */
  [Q_KEY_CODE_KP_1] = 0x4f, /* qcode:Q_KEY_CODE_KP_1 (kp_1) -> linux:79 (KEY_KP1) -> atset1:79 */
  [Q_KEY_CODE_KP_2] = 0x50, /* qcode:Q_KEY_CODE_KP_2 (kp_2) -> linux:80 (KEY_KP2) -> atset1:80 */
  [Q_KEY_CODE_KP_3] = 0x51, /* qcode:Q_KEY_CODE_KP_3 (kp_3) -> linux:81 (KEY_KP3) -> atset1:81 */
  [Q_KEY_CODE_KP_4] = 0x4b, /* qcode:Q_KEY_CODE_KP_4 (kp_4) -> linux:75 (KEY_KP4) -> atset1:75 */
  [Q_KEY_CODE_KP_5] = 0x4c, /* qcode:Q_KEY_CODE_KP_5 (kp_5) -> linux:76 (KEY_KP5) -> atset1:76 */
  [Q_KEY_CODE_KP_6] = 0x4d, /* qcode:Q_KEY_CODE_KP_6 (kp_6) -> linux:77 (KEY_KP6) -> atset1:77 */
  [Q_KEY_CODE_KP_7] = 0x47, /* qcode:Q_KEY_CODE_KP_7 (kp_7) -> linux:71 (KEY_KP7) -> atset1:71 */
  [Q_KEY_CODE_KP_8] = 0x48, /* qcode:Q_KEY_CODE_KP_8 (kp_8) -> linux:72 (KEY_KP8) -> atset1:72 */
  [Q_KEY_CODE_KP_9] = 0x49, /* qcode:Q_KEY_CODE_KP_9 (kp_9) -> linux:73 (KEY_KP9) -> atset1:73 */
  [Q_KEY_CODE_KP_ADD] = 0x4e, /* qcode:Q_KEY_CODE_KP_ADD (kp_add) -> linux:78 (KEY_KPPLUS) -> atset1:78 */
  [Q_KEY_CODE_KP_COMMA] = 0x7e, /* qcode:Q_KEY_CODE_KP_COMMA (kp_comma) -> linux:121 (KEY_KPCOMMA) -> atset1:126 */
  [Q_KEY_CODE_KP_DECIMAL] = 0x53, /* qcode:Q_KEY_CODE_KP_DECIMAL (kp_decimal) -> linux:83 (KEY_KPDOT) -> atset1:83 */
  [Q_KEY_CODE_KP_DIVIDE] = 0xe035, /* qcode:Q_KEY_CODE_KP_DIVIDE (kp_divide) -> linux:98 (KEY_KPSLASH) -> atset1:57397 */
  [Q_KEY_CODE_KP_ENTER] = 0xe01c, /* qcode:Q_KEY_CODE_KP_ENTER (kp_enter) -> linux:96 (KEY_KPENTER) -> atset1:57372 */
  [Q_KEY_CODE_KP_EQUALS] = 0x59, /* qcode:Q_KEY_CODE_KP_EQUALS (kp_equals) -> linux:117 (KEY_KPEQUAL) -> atset1:89 */
  [Q_KEY_CODE_KP_MULTIPLY] = 0x37, /* qcode:Q_KEY_CODE_KP_MULTIPLY (kp_multiply) -> linux:55 (KEY_KPASTERISK) -> atset1:55 */
  [Q_KEY_CODE_KP_SUBTRACT] = 0x4a, /* qcode:Q_KEY_CODE_KP_SUBTRACT (kp_subtract) -> linux:74 (KEY_KPMINUS) -> atset1:74 */
  [Q_KEY_CODE_L] = 0x26, /* qcode:Q_KEY_CODE_L (l) -> linux:38 (KEY_L) -> atset1:38 */
  [Q_KEY_CODE_LEFT] = 0xe04b, /* qcode:Q_KEY_CODE_LEFT (left) -> linux:105 (KEY_LEFT) -> atset1:57419 */
  [Q_KEY_CODE_LESS] = 0x56, /* qcode:Q_KEY_CODE_LESS (less) -> linux:86 (KEY_102ND) -> atset1:86 */
  [Q_KEY_CODE_LF] = 0x5b, /* qcode:Q_KEY_CODE_LF (lf) -> linux:101 (KEY_LINEFEED) -> atset1:91 */
  [Q_KEY_CODE_M] = 0x32, /* qcode:Q_KEY_CODE_M (m) -> linux:50 (KEY_M) -> atset1:50 */
  [Q_KEY_CODE_MAIL] = 0xe06c, /* qcode:Q_KEY_CODE_MAIL (mail) -> linux:155 (KEY_MAIL) -> atset1:57452 */
  [Q_KEY_CODE_MEDIASELECT] = 0xe06d, /* qcode:Q_KEY_CODE_MEDIASELECT (mediaselect) -> linux:226 (KEY_MEDIA) -> atset1:57453 */
  [Q_KEY_CODE_MENU] = 0xe01e, /* qcode:Q_KEY_CODE_MENU (menu) -> linux:139 (KEY_MENU) -> atset1:57374 */
  [Q_KEY_CODE_META_L] = 0xe05b, /* qcode:Q_KEY_CODE_META_L (meta_l) -> linux:125 (KEY_LEFTMETA) -> atset1:57435 */
  [Q_KEY_CODE_META_R] = 0xe05c, /* qcode:Q_KEY_CODE_META_R (meta_r) -> linux:126 (KEY_RIGHTMETA) -> atset1:57436 */
  [Q_KEY_CODE_MINUS] = 0xc, /* qcode:Q_KEY_CODE_MINUS (minus) -> linux:12 (KEY_MINUS) -> atset1:12 */
  [Q_KEY_CODE_MUHENKAN] = 0x7b, /* qcode:Q_KEY_CODE_MUHENKAN (muhenkan) -> linux:94 (KEY_MUHENKAN) -> atset1:123 */
  [Q_KEY_CODE_N] = 0x31, /* qcode:Q_KEY_CODE_N (n) -> linux:49 (KEY_N) -> atset1:49 */
  [Q_KEY_CODE_NUM_LOCK] = 0x45, /* qcode:Q_KEY_CODE_NUM_LOCK (num_lock) -> linux:69 (KEY_NUMLOCK) -> atset1:69 */
  [Q_KEY_CODE_O] = 0x18, /* qcode:Q_KEY_CODE_O (o) -> linux:24 (KEY_O) -> atset1:24 */
  [Q_KEY_CODE_OPEN] = 0x64, /* qcode:Q_KEY_CODE_OPEN (open) -> linux:134 (KEY_OPEN) -> atset1:100 */
  [Q_KEY_CODE_P] = 0x19, /* qcode:Q_KEY_CODE_P (p) -> linux:25 (KEY_P) -> atset1:25 */
  [Q_KEY_CODE_PASTE] = 0x65, /* qcode:Q_KEY_CODE_PASTE (paste) -> linux:135 (KEY_PASTE) -> atset1:101 */
  [Q_KEY_CODE_PAUSE] = 0xe046, /* qcode:Q_KEY_CODE_PAUSE (pause) -> linux:119 (KEY_PAUSE) -> atset1:57414 */
  [Q_KEY_CODE_PGDN] = 0xe051, /* qcode:Q_KEY_CODE_PGDN (pgdn) -> linux:109 (KEY_PAGEDOWN) -> atset1:57425 */
  [Q_KEY_CODE_PGUP] = 0xe049, /* qcode:Q_KEY_CODE_PGUP (pgup) -> linux:104 (KEY_PAGEUP) -> atset1:57417 */
  [Q_KEY_CODE_POWER] = 0xe05e, /* qcode:Q_KEY_CODE_POWER (power) -> linux:116 (KEY_POWER) -> atset1:57438 */
  [Q_KEY_CODE_PRINT] = 0x54, /* qcode:Q_KEY_CODE_PRINT (sysrq) -> linux:99 (KEY_SYSRQ) -> atset1:84 */
  [Q_KEY_CODE_PROPS] = 0xe006, /* qcode:Q_KEY_CODE_PROPS (props) -> linux:130 (KEY_PROPS) -> atset1:57350 */
  [Q_KEY_CODE_Q] = 0x10, /* qcode:Q_KEY_CODE_Q (q) -> linux:16 (KEY_Q) -> atset1:16 */
  [Q_KEY_CODE_R] = 0x13, /* qcode:Q_KEY_CODE_R (r) -> linux:19 (KEY_R) -> atset1:19 */
  [Q_KEY_CODE_RET] = 0x1c, /* qcode:Q_KEY_CODE_RET (ret) -> linux:28 (KEY_ENTER) -> atset1:28 */
  [Q_KEY_CODE_RIGHT] = 0xe04d, /* qcode:Q_KEY_CODE_RIGHT (right) -> linux:106 (KEY_RIGHT) -> atset1:57421 */
  [Q_KEY_CODE_RO] = 0x73, /* qcode:Q_KEY_CODE_RO (ro) -> linux:89 (KEY_RO) -> atset1:115 */
  [Q_KEY_CODE_S] = 0x1f, /* qcode:Q_KEY_CODE_S (s) -> linux:31 (KEY_S) -> atset1:31 */
  [Q_KEY_CODE_SCROLL_LOCK] = 0x46, /* qcode:Q_KEY_CODE_SCROLL_LOCK (scroll_lock) -> linux:70 (KEY_SCROLLLOCK) -> atset1:70 */
  [Q_KEY_CODE_SEMICOLON] = 0x27, /* qcode:Q_KEY_CODE_SEMICOLON (semicolon) -> linux:39 (KEY_SEMICOLON) -> atset1:39 */
  [Q_KEY_CODE_SHIFT] = 0x2a, /* qcode:Q_KEY_CODE_SHIFT (shift) -> linux:42 (KEY_LEFTSHIFT) -> atset1:42 */
  [Q_KEY_CODE_SHIFT_R] = 0x36, /* qcode:Q_KEY_CODE_SHIFT_R (shift_r) -> linux:54 (KEY_RIGHTSHIFT) -> atset1:54 */
  [Q_KEY_CODE_SLASH] = 0x35, /* qcode:Q_KEY_CODE_SLASH (slash) -> linux:53 (KEY_SLASH) -> atset1:53 */
  [Q_KEY_CODE_SLEEP] = 0xe05f, /* qcode:Q_KEY_CODE_SLEEP (sleep) -> linux:142 (KEY_SLEEP) -> atset1:57439 */
  [Q_KEY_CODE_SPC] = 0x39, /* qcode:Q_KEY_CODE_SPC (spc) -> linux:57 (KEY_SPACE) -> atset1:57 */
  [Q_KEY_CODE_STOP] = 0xe068, /* qcode:Q_KEY_CODE_STOP (stop) -> linux:128 (KEY_STOP) -> atset1:57448 */
  [Q_KEY_CODE_SYSRQ] = 0x54, /* qcode:Q_KEY_CODE_SYSRQ (sysrq) -> linux:99 (KEY_SYSRQ) -> atset1:84 */
  [Q_KEY_CODE_T] = 0x14, /* qcode:Q_KEY_CODE_T (t) -> linux:20 (KEY_T) -> atset1:20 */
  [Q_KEY_CODE_TAB] = 0xf, /* qcode:Q_KEY_CODE_TAB (tab) -> linux:15 (KEY_TAB) -> atset1:15 */
  [Q_KEY_CODE_U] = 0x16, /* qcode:Q_KEY_CODE_U (u) -> linux:22 (KEY_U) -> atset1:22 */
  [Q_KEY_CODE_UNDO] = 0xe007, /* qcode:Q_KEY_CODE_UNDO (undo) -> linux:131 (KEY_UNDO) -> atset1:57351 */
  [Q_KEY_CODE_UP] = 0xe048, /* qcode:Q_KEY_CODE_UP (up) -> linux:103 (KEY_UP) -> atset1:57416 */
  [Q_KEY_CODE_V] = 0x2f, /* qcode:Q_KEY_CODE_V (v) -> linux:47 (KEY_V) -> atset1:47 */
  [Q_KEY_CODE_VOLUMEDOWN] = 0xe02e, /* qcode:Q_KEY_CODE_VOLUMEDOWN (volumedown) -> linux:114 (KEY_VOLUMEDOWN) -> atset1:57390 */
  [Q_KEY_CODE_VOLUMEUP] = 0xe030, /* qcode:Q_KEY_CODE_VOLUMEUP (volumeup) -> linux:115 (KEY_VOLUMEUP) -> atset1:57392 */
  [Q_KEY_CODE_W] = 0x11, /* qcode:Q_KEY_CODE_W (w) -> linux:17 (KEY_W) -> atset1:17 */
  [Q_KEY_CODE_WAKE] = 0xe063, /* qcode:Q_KEY_CODE_WAKE (wake) -> linux:143 (KEY_WAKEUP) -> atset1:57443 */
  [Q_KEY_CODE_X] = 0x2d, /* qcode:Q_KEY_CODE_X (x) -> linux:45 (KEY_X) -> atset1:45 */
  [Q_KEY_CODE_Y] = 0x15, /* qcode:Q_KEY_CODE_Y (y) -> linux:21 (KEY_Y) -> atset1:21 */
  [Q_KEY_CODE_YEN] = 0x7d, /* qcode:Q_KEY_CODE_YEN (yen) -> linux:124 (KEY_YEN) -> atset1:125 */
  [Q_KEY_CODE_Z] = 0x2c, /* qcode:Q_KEY_CODE_Z (z) -> linux:44 (KEY_Z) -> atset1:44 */
};

const size_t qemu_input_map_qcode_to_atset1_len = sizeof(qemu_input_map_qcode_to_atset1)/sizeof(qemu_input_map_qcode_to_atset1[0]);

/* This function first translate the current user input to QEMU keycode,
 * then translate to the PS2 scancode.
 * The output `transcoded` might have more than one byte.
 */
int TranslateScancode(uint8_t scancode, int pressed, uint8_t transcoded[10]) {
  if (scancode >= qemu_input_map_usb_to_qcode_len) {
    return 0;
  }
  uint16_t qcode = qemu_input_map_usb_to_qcode[scancode];
  if (qcode >= qemu_input_map_qcode_to_atset1_len) {
    return 0;
  }
  int transcoded_size = 0;
  uint16_t keycode = qemu_input_map_qcode_to_atset1[qcode];
  if (keycode & 0xff00) {
    transcoded[transcoded_size++] = keycode >> 8;
  }
  if (!pressed) {
    keycode |= 0x80;
  }
  if (keycode & 0xff) {
    transcoded[transcoded_size++] = keycode;
  }
  return transcoded_size;
}

```

`gui/sdl/keymap.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVSIOR_KEY_MAP_H
#define _MVSIOR_KEY_MAP_H

#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif
int TranslateScancode(uint8_t scancode, int pressed, uint8_t transcoded_size[10]);
#ifdef __cplusplus
}
#endif

#endif // _MVSIOR_KEY_MAP_H
 
```

`gui/sdl/meson.build`:

```build
mvisor_sources += files(
  'keymap.c',
  'keymap.h',
  'viewer.cc',
  'viewer.h'
)

mvisor_deps += [
  dependency('alsa'),
  dependency('SDL2')
]

```

`gui/sdl/viewer.cc`:

```cc
/* 
 * MVisor - SDL Viewer
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "viewer.h"
#include <unistd.h>
#include <chrono>
#include "logger.h"
#include "keymap.h"
#include "spice/enums.h"
#include "spice/vd_agent.h"

Viewer::Viewer(Machine* machine) : machine_(machine) {
  bzero(&pointer_state_, sizeof(pointer_state_));

  SDL_Init(SDL_INIT_VIDEO);
  LookupDevices();
}

Viewer::~Viewer() {
  DestroyWindow();
  SDL_Quit();
}

void Viewer::DestroyWindow() {
  if (screen_surface_) {
    if (palette_) {
      SDL_FreePalette(palette_);
      palette_ = nullptr;
    }
    if (cursor_) {
      SDL_FreeCursor(cursor_);
      cursor_ = nullptr;
    }
    SDL_FreeSurface(screen_surface_);
    SDL_DestroyRenderer(renderer_);
    SDL_DestroyWindow(window_);
    screen_surface_ = nullptr;
    renderer_ = nullptr;
    window_ = nullptr;
  }
}

void Viewer::CreateWindow() {
  display_->GetDisplayMode(&width_, &height_, &bpp_, &stride_);
  MV_ASSERT(width_ && height_ && bpp_ && stride_);
  pointer_state_.screen_width = width_;
  pointer_state_.screen_height = height_;

  int x = SDL_WINDOWPOS_UNDEFINED, y = SDL_WINDOWPOS_UNDEFINED;
  window_ = SDL_CreateWindow("MVisor", x, y, width_, height_, SDL_WINDOW_RESIZABLE);
  renderer_ = SDL_CreateRenderer(window_, -1, 0);
  MV_ASSERT(renderer_);

  screen_surface_ = SDL_CreateRGBSurfaceWithFormat(0, width_, height_, 32, SDL_PIXELFORMAT_BGRA32);
  MV_ASSERT(screen_surface_);
  SDL_SetSurfaceBlendMode(screen_surface_, SDL_BLENDMODE_NONE);

  if (bpp_ == 8) {
    palette_ = SDL_AllocPalette(256);
  }
  UpdateCaption();
}

void Viewer::UpdateCaption() {
  char title[100];
  sprintf(title, "MVisor - A mini x86 hypervisor - %dx%dx%d", width_, height_, bpp_);
  SDL_SetWindowTitle(window_, title);
}

void Viewer::RenderSurface(const DisplayPartialBitmap* partial) {
  uint format = SDL_PIXELFORMAT_UNKNOWN;
  switch (partial->bpp)
  {
  case 32:
    format = SDL_PIXELFORMAT_BGRA32;
    break;
  case 24:
    format = SDL_PIXELFORMAT_BGR24;
    break;
  case 16:
    format = SDL_PIXELFORMAT_RGB565;
    break;
  case 8:
    format = SDL_PIXELFORMAT_INDEX8;
    break;
  default:
    MV_PANIC("unsupported video bpp=%d", bpp_);
  }

  SDL_Surface* surface = SDL_CreateRGBSurfaceWithFormatFrom(partial->data,
      partial->width, partial->height, partial->bpp, partial->stride, format);

  if (partial->bpp == 8) {
    SDL_Color colors[256];
    const uint8_t* p;
    int count;
    display_->GetPalette(&p, &count);
    for (int i = 0; i < count; i++) {
      colors[i].r = *p++ << 2;
      colors[i].g = *p++ << 2;
      colors[i].b = *p++ << 2;
    }
    SDL_SetPaletteColors(palette_, colors, 0, 256);
    SDL_SetSurfacePalette(surface, palette_);
  }

  SDL_SetSurfaceBlendMode(surface, SDL_BLENDMODE_NONE);
  auto dest_rect = SDL_Rect {
    .x = partial->x,
    .y = partial->y,
    .w = partial->width,
    .h = partial->height
  };

  SDL_BlitSurface(surface, NULL, screen_surface_, &dest_rect);
  SDL_FreeSurface(surface);
}

void Viewer::RenderCursor(const DisplayMouseCursor* cursor_update) {
  if (cursor_update->visible) {
    if (!cursor_visible_) {
      SDL_ShowCursor(SDL_ENABLE);
      cursor_visible_ = true;
    }
    if (cursor_update->shape.id == cursor_shape_id_) {
      return;
    }
    if (cursor_) {
      SDL_FreeCursor(cursor_);
      cursor_ = nullptr;
    }
    auto& shape = cursor_update->shape;
    uint32_t stride = SPICE_ALIGN(shape.width, 8) >> 3;

    if (shape.type == SPICE_CURSOR_TYPE_MONO) {
      uint8_t mask[4 * 100] = { 0 };
      cursor_ = SDL_CreateCursor((const uint8_t*)shape.data.data() + stride * shape.height,
        mask, shape.width, shape.height, shape.hotspot_x, shape.hotspot_y);
      SDL_SetCursor(cursor_);
    } else {
      auto surface = SDL_CreateRGBSurfaceWithFormatFrom((void*)shape.data.data(),
        shape.width, shape.height, 32, shape.width * 4, SDL_PIXELFORMAT_BGRA32);
      cursor_ = SDL_CreateColorCursor(surface, shape.hotspot_x, shape.hotspot_y);
      SDL_SetCursor(cursor_);
      SDL_FreeSurface(surface);
    }
    cursor_shape_id_ = shape.id;
  } else {
    if (cursor_visible_) {
      cursor_visible_ = false;
      SDL_ShowCursor(SDL_DISABLE);
    }
  }
}

/* Only use mutex with dequee, since we don't want to block the IoThread */
void Viewer::Render() {
  DisplayUpdate update;
  if (display_->AcquireUpdate(update, false)) {
    RenderCursor(&update.cursor);

    for (auto& partial : update.partials) {
      if (partial.bpp == bpp_ && partial.x + partial.width <= width_ && partial.y + partial.height <= height_) {
        RenderSurface(&partial);
      }
    }
    display_->ReleaseUpdate();
  }

  if (!update.partials.empty()) {
    auto screen_texture = SDL_CreateTextureFromSurface(renderer_, screen_surface_);
    SDL_RenderCopy(renderer_, screen_texture, nullptr, nullptr);
    SDL_RenderPresent(renderer_);
    SDL_DestroyTexture(screen_texture);
  }
}


PointerInputInterface* Viewer::GetActivePointer() {
  if (machine_->IsPaused())
    return nullptr;
  for (auto pointer : pointers_) {
    if (pointer->InputAcceptable()) {
      return pointer;
    }
  }
  return nullptr;
}

void Viewer::OnPlayback(PlaybackState state, const std::string& data) {
  if (pcm_playback_error_) {
    return;
  }
  switch (state)
  {
  case kPlaybackStart: {
    playback_->GetPlaybackFormat(&playback_format_.format, &playback_format_.channels,
      &playback_format_.frequency, &playback_format_.interval_ms);
    break;
  }
  case kPlaybackStop: {
    if (!pcm_playback_)
      break;
    snd_pcm_drain(pcm_playback_);
    snd_pcm_close(pcm_playback_);
    pcm_playback_ = nullptr;
    break;
  }
  case kPlaybackData: {
    if (!pcm_playback_) {
      if (!playback_format_.frequency || !playback_format_.channels) {
        break;
      }

      int err;
      MV_ASSERT(pcm_playback_ == nullptr);
      if ((err = snd_pcm_open(&pcm_playback_, "default", SND_PCM_STREAM_PLAYBACK, SND_PCM_NONBLOCK)) < 0) {
        MV_LOG("snd_pcm_open error: %s", snd_strerror(err));
        pcm_playback_error_ = true;
        break;
      }
      /* set the latency to multiple times of interval to buffer some more data */
      err = snd_pcm_set_params(pcm_playback_, SND_PCM_FORMAT_S16_LE, SND_PCM_ACCESS_RW_INTERLEAVED,
        playback_format_.channels, playback_format_.frequency, 1, playback_format_.interval_ms * 1000 * 50);
      if (err < 0) {
        MV_PANIC("snd_pcm_set_params error: %s\n", snd_strerror(err));
      }
    }
    /* assume format is s16le */
    auto frames = snd_pcm_writei(pcm_playback_, data.data(), data.size() / playback_format_.channels / 2);
    if (frames < 0) {
      MV_LOG("snd_pcm_writei failed: %s\n", snd_strerror(frames));
    }
    if (frames < 0)
      frames = snd_pcm_recover(pcm_playback_, frames, 0);
    if (frames < 0) {
      MV_LOG("snd_pcm_writei failed: %s\n", snd_strerror(frames));
    }
    break;
  }
  }
}

void Viewer::LookupDevices() {
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<KeyboardInputInterface*>(o); })) {
    keyboard_ = dynamic_cast<KeyboardInputInterface*>(o);
  }
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<DisplayInterface*>(o); })) {
    display_ = dynamic_cast<DisplayInterface*>(o);
  }
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<PlaybackInterface*>(o); })) {
    playback_ = dynamic_cast<PlaybackInterface*>(o);
  }
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<PointerInputInterface*>(o); })) {
    pointers_.push_back(dynamic_cast<PointerInputInterface*>(o));
  }
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<DisplayResizeInterface*>(o); })) {
    resizers_.push_back(dynamic_cast<DisplayResizeInterface*>(o));
  }
  for (auto o : machine_->LookupObjects([](auto o) { return dynamic_cast<SerialPortInterface*>(o); })) {
    auto port = dynamic_cast<SerialPortInterface*>(o);
    auto port_name = std::string(port->port_name());
    if (port_name == "com.redhat.spice.0") {
      clipboard_ = dynamic_cast<ClipboardInterface*>(o);
    }
    port->set_callback([this, port](SerialPortEvent event, uint8_t* data, size_t size) {
      Schedule([this, port, event, data = std::string((const char*)data, size)] () {
        OnSerialPortEvent(port, event, data);
      });
    });
  }
  /* At least one display device is required for SDL viewer */
  MV_ASSERT(display_);

  display_->RegisterDisplayModeChangeListener([this]() {
    Schedule([this]() {
      DestroyWindow();
      CreateWindow();
    });
  });
  display_->RegisterDisplayUpdateListener([this]() {
    Schedule([this]() {
      Render();
    });
  });
  if (playback_) {
    playback_->RegisterPlaybackListener([this](PlaybackState state, struct iovec iov) {
      Schedule([this, state, data = std::string((const char*)iov.iov_base, iov.iov_len)] () {
        OnPlayback(state, data);
      });
    });
  }
  if(clipboard_) {
    clipboard_->RegisterClipboardListener([this](const ClipboardData clipboard_data) {
      /* std::move don't copy data, but replace data reference */
      Schedule([this, clipboard_data = std::move(clipboard_data)] () {
        OnClipboardFromGuest(clipboard_data);
      });
    });
  }
}

void Viewer::OnSerialPortEvent(SerialPortInterface* port, SerialPortEvent event, const std::string& data) {
  MV_UNUSED(data);

  switch (event)
  {
  case kSerialPortStatusChanged:
    if (strcmp(port->port_name(), "com.redhat.spice.0") == 0) {
      /* Set screen size when VDAgent is ready */
      SendResizerEvent();
    }
    break;
  case kSerialPortData:
    /* Handle Qemu guest agent data here */
    break;
  }
}

void Viewer::OnClipboardFromGuest(const ClipboardData& clipboard_data) {
  switch (clipboard_data.type)
  {
  case VD_AGENT_CLIPBOARD_NONE:
    clipboard_data_ = "";
    SDL_SetClipboardText("");
    break;
  case VD_AGENT_CLIPBOARD_UTF8_TEXT:
    clipboard_data_ = clipboard_data.data;
    SDL_SetClipboardText(clipboard_data_.c_str());
    break;
  default:
    MV_ERROR("Unhandled clipboard type=0x%x", clipboard_data.type);
    break;
  }
}

/* Use viewer UI thread to handle tasks */
void Viewer::Schedule(VoidCallback callback) {
  mutex_.lock();
  tasks_.emplace_back(std::move(callback));
  mutex_.unlock();
  SDL_Event event = { .type = SDL_USEREVENT };
  SDL_PushEvent(&event);
}

/* Reference about SDL-2:
 * https://wiki.libsdl.org/APIByCategory
 */
int Viewer::MainLoop() {
  SetThreadName("mvisor-viewer");

  // Loop until all vcpu exits
  SDL_Event event;
  while (machine_->IsValid()) {
    auto frame_start_time = std::chrono::steady_clock::now();
    auto ret = SDL_WaitEventTimeout(&event, 300);
    if (ret == 1) {
      HandleEvent(event);
    }

    /* Check viewer window resize */
    if (pending_resize_.triggered && frame_start_time - pending_resize_.time >= std::chrono::milliseconds(200)) {
      pending_resize_.triggered = false;
      SendResizerEvent();
    }
  }
  return 0;
}

void Viewer::SendResizerEvent() {
  if (!pending_resize_.width || !pending_resize_.height) {
    return;
  }
  for (auto resizer : resizers_) {
    if (resizer->Resize(pending_resize_.width, pending_resize_.height)) {
      if (machine_->debug()) {
        MV_LOG("%s resize to %dx%d", dynamic_cast<Object*>(resizer)->name(),
          pending_resize_.width, pending_resize_.height);
      }
      break;
    }
  }
}

void Viewer::SendPointerEvent() {
  auto pointer = GetActivePointer();
  if (pointer && window_) {
    int x, y, w, h;
    SDL_GetMouseState(&x, &y);
    SDL_GetWindowSize(window_, &w, &h);
    /* Check if window is scaled */
    x = x * width_ / w;
    y = y * height_ / h;
    pointer_state_.x = x;
    pointer_state_.y = y;
    pointer->QueuePointerEvent(pointer_state_);
  }
}

void Viewer::HandleEvent(const SDL_Event& event) {
  uint8_t transcoded[10] = { 0 };

  switch (event.type)
  {
  case SDL_USEREVENT: {
    std::unique_lock<std::mutex> lock(mutex_);
    while (!tasks_.empty()) {
      auto& task = tasks_.front();
      lock.unlock();
      task();
      lock.lock();
      tasks_.pop_front();
    }
    break;
  }
  case SDL_KEYDOWN:
    if (event.key.keysym.sym == SDLK_F11) {
      if (machine_->IsPaused()) {
        MV_LOG("Resume");
        machine_->Resume();
      } else {
        MV_LOG("Pause");
        machine_->Pause();
      }
      return;
    } else if (event.key.keysym.sym == SDLK_F2) {
      MV_LOG("Save");
      machine_->Pause();
      machine_->Save("/tmp/save");
      return;
    } else if (event.key.keysym.sym == SDLK_F3) {
      MV_LOG("Migration");
      std::thread([this]() {
        MV_ASSERT(machine_->Save("127.0.0.1", 9979));
      }).detach();
      return;
    } else if (event.key.keysym.sym == SDLK_F4) {
      MV_LOG("Migration Post");
      MV_ASSERT(machine_->PostSave());
      return;
    } else if (event.key.keysym.sym == SDLK_F12) {
      if (machine_->IsPaused()) {
        MV_LOG("Reset");
        machine_->Resume();
        machine_->Reset();
      } else {
        MV_LOG("Shutdown");
        machine_->Shutdown();
      }
      return;
    }
    // fall through
  case SDL_KEYUP:
    if (keyboard_ && TranslateScancode(event.key.keysym.scancode, event.type == SDL_KEYDOWN, transcoded)) {
      auto mod = SDL_GetModState();
      uint8_t modifiers = ((mod & KMOD_NUM) ? 2: 0) | ((mod & KMOD_CAPS) ? 4 : 0);
      keyboard_->QueueKeyboardEvent(transcoded, modifiers);
    }
    break;
  case SDL_MOUSEWHEEL:
    pointer_state_.z = event.wheel.y;
    SendPointerEvent();
    pointer_state_.z = 0;
    break;
  case SDL_MOUSEBUTTONDOWN:
  case SDL_MOUSEBUTTONUP:
    if (event.button.state) {
      pointer_state_.buttons |= (1 << event.button.button);
    } else {
      pointer_state_.buttons &= ~(1 << event.button.button);
    }
    SendPointerEvent();
    break;
  case SDL_MOUSEMOTION:
    /* if we dont check the pointer changes, it would have 1000 pointer events per second */
    if (event.motion.x != pointer_state_.x || event.motion.y != pointer_state_.y) {
      SendPointerEvent();
    }
    break;
  case SDL_WINDOWEVENT:
    switch (event.window.event)
    {
    case SDL_WINDOWEVENT_RESIZED:
      pending_resize_.triggered = true;
      pending_resize_.width = event.window.data1;
      pending_resize_.height = event.window.data2;
      pending_resize_.time = std::chrono::steady_clock::now();
      break;
    case SDL_WINDOWEVENT_FOCUS_GAINED:
      /* When viewer got focused, check clipboard if changed */
      if (SDL_HasClipboardText() && clipboard_data_ != SDL_GetClipboardText()) {
        clipboard_data_ = SDL_GetClipboardText();
        if (clipboard_) {
          clipboard_->ClipboardDataToGuest(VD_AGENT_CLIPBOARD_UTF8_TEXT, clipboard_data_);
        }
      }
      break;
    }
    break;
  case SDL_QUIT:
    machine_->Quit();
    break;
  }
}

```

`gui/sdl/viewer.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_VIEWER_H
#define _MVISOR_VIEWER_H

#include <SDL2/SDL.h>
#include <alsa/asoundlib.h>

#include <mutex>
#include <deque>

#include "machine.h"
#include "device_manager.h"
#include "device_interface.h"


struct PendingResize {
  bool triggered = false;
  int  width = 0;
  int  height = 0;
  std::chrono::steady_clock::time_point time;
};

class Viewer {
 public:
  Viewer(Machine* machine);
  ~Viewer();
  int MainLoop();

 private:
  void LookupDevices();
  void DestroyWindow();
  void Render();
  void CreateWindow();
  void UpdateCaption();
  void RenderSurface(const DisplayPartialBitmap* partial);
  void RenderCursor(const DisplayMouseCursor* cursor_update);
  void HandleEvent(const SDL_Event& event);
  PointerInputInterface* GetActivePointer();
  void SendPointerEvent();
  void SendResizerEvent();
  void OnPlayback(PlaybackState state, const std::string& data);
  void OnClipboardFromGuest(const ClipboardData& clipboard_data);
  void OnSerialPortEvent(SerialPortInterface* port, SerialPortEvent event, const std::string& data);
  void Schedule(VoidCallback callback);

  Machine* machine_;
  ClipboardInterface* clipboard_;
  std::string clipboard_data_;
  DisplayInterface* display_;
  PlaybackInterface* playback_;
  KeyboardInputInterface* keyboard_;
  std::vector<PointerInputInterface*> pointers_;
  std::vector<DisplayResizeInterface*> resizers_;
  PlaybackFormat playback_format_;

  SDL_Window* window_ = nullptr;
  SDL_Renderer* renderer_ = nullptr;
  SDL_Surface* screen_surface_ = nullptr;
  SDL_Palette* palette_ = nullptr;
  SDL_Cursor* cursor_ = nullptr;

  std::mutex mutex_;
  std::deque<VoidCallback> tasks_;
  bool cursor_visible_ = false;
  uint64_t cursor_shape_id_ = 0;

  int width_, height_, bpp_, stride_;

  PointerEvent pointer_state_;
  PendingResize pending_resize_;

  bool pcm_playback_error_ = false;
  snd_pcm_t* pcm_playback_ = nullptr;
};

#endif // _MVISOR_VIEWER_H

```

`images/image.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "disk_image.h"

#include "logger.h"
#include "utilities.h"
#include "device_manager.h"
#include "pci_device.h"
#include "qcow2.h"


DiskImage::DiskImage() {
}

DiskImage::~DiskImage()
{
  if (!finalized_) {
    Finalize();
  }
}

DiskImage* DiskImage::Create(Device* device, std::string path, bool readonly, bool snapshot) {
  DiskImage* image;
  if (path.find(".qcow2") != std::string::npos) {
    image = dynamic_cast<Qcow2Image*>(Object::Create("qcow2-image"));
  } else {
    image = dynamic_cast<DiskImage*>(Object::Create("raw-image"));
  }
  MV_ASSERT(image);
  image->filepath_ = path;
  image->readonly_ = readonly;
  image->snapshot_ = snapshot;
  image->device_ = device;
  image->host_device_ = dynamic_cast<Device*>((Object*)device->parent());
  MV_ASSERT(image->host_device_);
  image->Initialize();
  
  image->io_ = device->manager()->io();
  image->worker_thread_ = std::thread(&DiskImage::WorkerProcess, image);
  return image;
}

void DiskImage::Finalize() {
  finalized_ = true;

  if (worker_thread_.joinable()) {
    worker_cv_.notify_all();
    worker_thread_.join();
  }
}

void DiskImage::WorkerProcess() {
  SetThreadName("mvisor-disk");
  
  io_->RegisterDiskImage(this);

  while (!finalized_) {
    std::unique_lock<std::mutex> lock(worker_mutex_);
    worker_cv_.wait(lock, [this]() {
      return !worker_queue_.empty() || finalized_;
    });

    if (finalized_) {
      break;
    }

    auto& callback = worker_queue_.front();
    lock.unlock();
  
    callback();

    /* Only remove item after job is done.
     * Remember to lock mutex again when operating on worker_queue_
     */
    lock.lock();
    worker_queue_.pop_front();
  }
  
  io_->UnregisterDiskImage(this);
}


void DiskImage::QueueIoRequest(ImageIoRequest request, IoCallback callback) {
  worker_mutex_.lock();
  worker_queue_.emplace_back([this, request = std::move(request), callback = std::move(callback)]() {
    auto ret = HandleIoRequest(std::move(request));
    std::lock_guard<std::recursive_mutex> device_lock(host_device_->mutex());
    callback(ret);
  });

  worker_mutex_.unlock();
  worker_cv_.notify_all();
}

void DiskImage::QueueMultipleIoRequests(std::vector<ImageIoRequest> requests, IoCallback callback) {
  worker_mutex_.lock();
  worker_queue_.emplace_back([this, requests = std::move(requests), callback = std::move(callback)]() {
    long ret, total = 0;
    for (auto &req: requests) {
      ret = HandleIoRequest(std::move(req));
      if (ret < 0) {
        total = ret;
        break;
      }
      total += ret;
    }

    std::lock_guard<std::recursive_mutex> device_lock(host_device_->mutex());
    callback(total);
  });

  worker_mutex_.unlock();
  worker_cv_.notify_all();
}

bool DiskImage::busy() {
  std::lock_guard<std::mutex> lock(worker_mutex_);
  return !worker_queue_.empty();
}

```

`images/meson.build`:

```build
mvisor_sources += files(
  'image.cc',
  'qcow2_create.cc',
  'qcow2.cc',
  'raw.cc'
)

```

`images/qcow2.cc`:

```cc
/* 
 * MVisor QCOW2 Disk Image
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "qcow2.h"
#include <unistd.h>
#include <fcntl.h>
#include <unistd.h>
#include <libgen.h>
#include <sys/stat.h>
#include <ctime>
#include <cstring>
#include <vector>
#include <filesystem>
#include "logger.h"

#define REFCOUNT_CACHE_ITEMS        128
#define L2_CACHE_ITEMS              128
#define CLUSTER_CACHE_ITEMS         128

Qcow2Image::~Qcow2Image() {
  ReleaseImage(true);
}

void Qcow2Image::ReleaseImage(bool remove_file) {
  /* Flush caches if dirty */
  l2_cache_.Clear();
  rfb_cache_.Clear();
  cluster_cache_.Clear();

  if (fd_ != -1) {
    FlushAll();
    safe_close(&fd_);
  }

  if (remove_file && snapshot_) {
    remove(filepath_.c_str());
  }

  if (copied_cluster_) {
    delete[] copied_cluster_;
  }

  if (backing_file_) {
    delete backing_file_;
  }
}

// only could be called when vm was paused
void Qcow2Image::Reset() {
  // release current image object, but don't remove the image file
  ReleaseImage(false);

  // re-initialize current image object, but don't create another snapshot again
  auto snapshot = snapshot_;
  snapshot_ = false;
  Initialize();
  snapshot_ = snapshot;
}

// only could be called when vm was paused
bool Qcow2Image::CreateSnapshot() {
  /* Migrate data from qcow2 file starts at QCOW2_MIGRATE_DATA_OFFSET */
  if (image_header_.refcount_table_offset != QCOW2_MIGRATE_DATA_OFFSET) {
    return false;
  }

  // release current image object, but don't remove the image file
  ReleaseImage(false);

  // make current image as a snapshot image
  snapshot_ = true;
  Initialize();
  return true;
}

void Qcow2Image::Initialize() {
  int oflags = readonly_ ? O_RDONLY : O_RDWR;
  if (snapshot_) {
    auto backing_filepath = filepath_;

    // make new temp qcow2 file at current image path
    auto path = std::filesystem::path(filepath_);
    std::string temp = path.parent_path() / "snapshot_XXXXXX.qcow2";
    close(mkstemps(temp.data(), 6));

    filepath_ = temp;
    Qcow2Image::CreateImageWithBackingFile(filepath_, backing_filepath);
  }

  fd_ = open(filepath_.c_str(), oflags);
  if (fd_ < 0)
    MV_PANIC("failed to open disk file: %s", filepath_.c_str());

  struct stat st;
  fstat(fd_, &st);
  image_size_ = st.st_size;

  InitializeQcow2Header();
  InitializeL1Table();
  InitializeRefcountTable();
  InitializeLruCache();
  
  /* Setup backing file READONLY if valid */
  if (image_header_.backing_file_offset && image_header_.backing_file_size < 1024) {
    char filename[1024] = { 0 };
    ReadFile(filename, image_header_.backing_file_size, image_header_.backing_file_offset);
    if (filename[0] == '/') {
      backing_filepath_ = filename;
    } else {
      char temp[1024] = {  0 };
      strncpy(temp, filepath_.c_str(), sizeof(temp) - 1);
      backing_filepath_ = std::string(dirname(temp)) + "/" + filename;
    }
    backing_file_ = new Qcow2Image();
    backing_file_->is_backing_file_ = true;
    backing_file_->readonly_ = true;
    backing_file_->filepath_ = backing_filepath_;
    backing_file_->Initialize();
  }
  // MV_LOG("open qcow2 %s file size=%ld", path.c_str(), image_size_);
}

void Qcow2Image::InitializeQcow2Header() {
  bzero(&image_header_, sizeof(image_header_));
  /* Read the image header at offset 0 */
  ReadFile(&image_header_, sizeof(image_header_), 0);
  /* Bigendian to host */
  be32_to_cpus(&image_header_.magic);
  be32_to_cpus(&image_header_.version);
  be64_to_cpus(&image_header_.backing_file_offset);
  be32_to_cpus(&image_header_.backing_file_size);
  be32_to_cpus(&image_header_.cluster_bits);
  be64_to_cpus(&image_header_.size);
  be32_to_cpus(&image_header_.crypt_method);
  be32_to_cpus(&image_header_.l1_size);
  be64_to_cpus(&image_header_.l1_table_offset);
  be64_to_cpus(&image_header_.refcount_table_offset);
  be32_to_cpus(&image_header_.refcount_table_clusters);
  be32_to_cpus(&image_header_.nb_snapshots);
  be64_to_cpus(&image_header_.snapshots_offset);
  /* Version 3 features */
  be64_to_cpus(&image_header_.incompatible_features);
  be64_to_cpus(&image_header_.compatible_features);
  be64_to_cpus(&image_header_.autoclear_features);
  be32_to_cpus(&image_header_.refcount_order);
  be32_to_cpus(&image_header_.header_length);

  if (image_header_.magic != 0x514649FB) {
    MV_PANIC("File %s is not QCOW2 format", filepath_.c_str());
  }
  if (image_header_.version > 3) {
    MV_PANIC("Qcow2 file version=0x%x not supported", image_header_.version);
  }

  total_blocks_ = image_header_.size >> block_size_shift_;
  cluster_bits_ = image_header_.cluster_bits;
  cluster_size_ = 1 << cluster_bits_;
  l2_entries_ = cluster_size_ / sizeof(uint64_t);
  copied_cluster_ = new uint8_t[cluster_size_];

  /* For version 2, refcount bits is always 16 */
  refcount_bits_ = 16;
  rfb_entries_ = cluster_size_ * 8 / refcount_bits_;

  /* If there is no snapshot, we assume all refcounts <= 1 */
  if (image_header_.nb_snapshots) {
    MV_PANIC("Qcow2 file with snapshots is not supported yet");
  }
  if (image_header_.version == 3 && image_header_.compression_type > 1) {
    MV_PANIC("Unsupportted compression type=%d", image_header_.compression_type);
  }
}

/* FIXME: should we call pwrite for multiple times to write all data ??? */
ssize_t Qcow2Image::WriteFile(void* buffer, size_t length, off_t offset) {
  if (offset >= (ssize_t)image_header_.size) {
    MV_LOG("write overflow length=0x%lx, offset=0x%lx", length, offset);
    return 0;
  }
  ssize_t ret = pwrite(fd_, buffer, length, offset);
  MV_ASSERT(ret == (ssize_t)length);
  return ret;
}

/* FIXME: should we call pread for multiple times to read all data ??? */
ssize_t Qcow2Image::ReadFile(void* buffer, size_t length, off_t offset) {
  ssize_t ret = pread(fd_, buffer, length, offset);
  return ret;
}

void Qcow2Image::InitializeL1Table() {
  l1_table_.resize(image_header_.l1_size);
  bzero(l1_table_.data(), sizeof(uint64_t) * image_header_.l1_size);
  ReadFile(l1_table_.data(), sizeof(uint64_t) * image_header_.l1_size,
    image_header_.l1_table_offset
  );
}

void Qcow2Image::InitializeRefcountTable() {
  size_t refcount_bytes = image_header_.refcount_table_clusters * cluster_size_;
  refcount_table_.resize(refcount_bytes  / sizeof(uint64_t));
  bzero(refcount_table_.data(), refcount_bytes);
  ReadFile(refcount_table_.data(), refcount_bytes, image_header_.refcount_table_offset);
}

void Qcow2Image::WriteL1Table() {
  WriteFile(l1_table_.data(), l1_table_.size() * sizeof(uint64_t),
    image_header_.l1_table_offset);
  l1_table_dirty_ = false;
}

void Qcow2Image::WriteRefcountTable() {
  WriteFile(refcount_table_.data(), refcount_table_.size() * sizeof(uint64_t),
    image_header_.refcount_table_offset);
  refcount_table_dirty_ = false;
}

void Qcow2Image::WriteL2Table(L2Table* l2_table) {
  WriteFile(l2_table->entries, l2_entries_ * sizeof(uint64_t),
    l2_table->offset_in_file);
  l2_table->dirty = false;
}

void Qcow2Image::WriteRefcountBlock(RefcountBlock* rfb) {
  WriteFile(rfb->entries, rfb_entries_ * sizeof(uint16_t), rfb->offset_in_file);
  rfb->dirty = false;
}

void Qcow2Image::InitializeLruCache() {
  rfb_cache_.Initialize(REFCOUNT_CACHE_ITEMS, [this](auto offset_in_file, auto rfb) {
    MV_UNUSED(offset_in_file);
    if (rfb->dirty) {
      WriteRefcountBlock(rfb);
    }
    // MV_LOG("free rfb 0x%lx", rfb->offset_in_file);
    free(rfb);
  });
  l2_cache_.Initialize(L2_CACHE_ITEMS, [this](auto offset_in_file, auto l2_table) {
    MV_UNUSED(offset_in_file);
    if (l2_table->dirty) {
      WriteL2Table(l2_table);
    }
    // MV_LOG("free l2_table 0x%lx", l2_table->offset_in_file);
    free(l2_table);
  });
  cluster_cache_.Initialize(CLUSTER_CACHE_ITEMS, [this](auto offset_in_file, auto data) {
    MV_UNUSED(offset_in_file);
    delete data;
  });
}

RefcountBlock* Qcow2Image::NewRefcountBlock(uint64_t block_offset) {
  size_t size = sizeof(RefcountBlock) + rfb_entries_ * sizeof(uint16_t);
  RefcountBlock* block = (RefcountBlock*)malloc(size);
  bzero(block, size);
  block->dirty = false;
  block->offset_in_file = block_offset;
  return block;
}

RefcountBlock* Qcow2Image::GetRefcountBlock(uint64_t cluster_index, uint64_t* rfb_index, bool allocate) {
  uint64_t rft_index = cluster_index / rfb_entries_;
  *rfb_index = cluster_index % rfb_entries_;
  
  if (rft_index >= refcount_table_.size()) {
    return nullptr;
  }
  RefcountBlock* rfb;
  uint64_t block_offset = be64toh(refcount_table_[rft_index]);
  if (!block_offset) {
    /* If refcount block is not allocated, this cluster must be free and will be used
      * as a refcount block. Right???
      */
    if (!allocate) {
      return nullptr;
    }
    block_offset = cluster_index << cluster_bits_;
    rfb = NewRefcountBlock(block_offset);
    rfb_cache_.Put(block_offset, rfb);
    rfb->entries[*rfb_index] = htobe16(1);
    rfb->dirty = true;

    refcount_table_[rft_index] = htobe64(block_offset);
    refcount_table_dirty_ = true;
    return rfb;
  } else {
    if (rfb_cache_.Get(block_offset, rfb)) {
      return rfb;
    }

    rfb = NewRefcountBlock(block_offset);
    ReadFile(rfb->entries, rfb_entries_ * sizeof(uint16_t), rfb->offset_in_file);
    rfb_cache_.Put(rfb->offset_in_file, rfb);
    return rfb;
  }
}

void Qcow2Image::FreeCluster(uint64_t start) {
  uint64_t rfb_index;
  uint64_t cluster_index = start >> cluster_bits_;
  RefcountBlock* rfb = GetRefcountBlock(cluster_index, &rfb_index, false);
  if (rfb == nullptr) {
    MV_PANIC("Try to free an unallocated cluster 0x%lx", start);
    return;
  }

  rfb->entries[rfb_index] = htobe16(be16toh(rfb->entries[rfb_index]) - 1);
  rfb->dirty = true;
  if (rfb->entries[rfb_index] == 0 && cluster_index < free_cluster_index_) {
    free_cluster_index_ = cluster_index;
  }
}

/* free_cluster_index_ is initialized to zero and record last position. */
uint64_t Qcow2Image::AllocateCluster() {
  uint64_t rfb_index;
  uint64_t cluster_index = free_cluster_index_++;
  RefcountBlock* rfb = GetRefcountBlock(cluster_index, &rfb_index, true);
  while (true) {
    if (rfb == nullptr) {
      return 0; // Error occurred
    }
    uint16_t refcount = be16toh(rfb->entries[rfb_index]);
    if (refcount == 0) {
      break;
    }
    cluster_index = free_cluster_index_++;
    if (++rfb_index >= rfb_entries_) {
      rfb = GetRefcountBlock(cluster_index, &rfb_index, true);
    }
  }

  // update refcount and set dirty
  rfb->entries[rfb_index] = htobe16(be16toh(rfb->entries[rfb_index]) + 1);
  rfb->dirty = true;
  return cluster_index << cluster_bits_;
}

L2Table* Qcow2Image::NewL2Table(uint64_t l2_offset) {
  size_t size = sizeof(L2Table) + l2_entries_ * sizeof(uint64_t);
  L2Table* table = (L2Table*)malloc(size);
  bzero(table, size);
  table->dirty = false;
  table->offset_in_file = l2_offset;
  return table;
}

L2Table* Qcow2Image::ReadL2Table(uint64_t l2_offset) {
  L2Table* table;
  if (l2_cache_.Get(l2_offset, table)) {
    return table;
  }

  table = NewL2Table(l2_offset);
  ReadFile(table->entries, l2_entries_ * sizeof(uint64_t), table->offset_in_file);

  l2_cache_.Put(table->offset_in_file, table);
  return table;
}

L2Table* Qcow2Image::GetL2Table(bool is_write, off_t pos, uint64_t* offset_in_cluster, uint64_t* l2_index, size_t* length) {
  *offset_in_cluster = pos % cluster_size_;
  if (*length > cluster_size_ - *offset_in_cluster) {
    *length = cluster_size_ - *offset_in_cluster;
  }

  uint64_t cluster_index = pos >> cluster_bits_;
  uint64_t l1_index = cluster_index / l2_entries_;
  *l2_index = cluster_index % l2_entries_;
  
  uint64_t l2_offset = be64toh(l1_table_[l1_index]);
  if (l2_offset & QCOW2_OFLAG_COPIED) { /* L2 already allocated, read from current file */
    l2_offset &= ~QCOW2_OFLAG_COPIED;
    if (!l2_offset) { /* copied l1 entry must be valid */
      MV_PANIC("l2_offset is not valid");
    }
    return ReadL2Table(l2_offset);
  } else if (is_write) { /* L2 not allocated, but is a write operation */
    MV_ASSERT(l2_offset == 0); /* @XX: l2_offset != 0 if nb_snapshots > 0 ??? */
    l2_offset = AllocateCluster();
    MV_ASSERT(l2_offset);
    
    L2Table* l2_table = NewL2Table(l2_offset);
    bzero(l2_table->entries, l2_entries_ * sizeof(uint64_t));
    l2_cache_.Put(l2_offset, l2_table);
    l2_table->dirty = true;

    l1_table_[l1_index] = htobe64(l2_offset | QCOW2_OFLAG_COPIED);
    l1_table_dirty_ = true;
    return l2_table;
  } else { /* L2 not allocated, but should read from backing file if possible */
    return nullptr;
  }
  return nullptr;
}

/* The return value is always less than or equal to cluster size */
ssize_t Qcow2Image::ReadCluster(void* buffer, off_t pos, size_t length, bool no_zero) {
  uint64_t offset_in_cluster, l2_index;
  auto l2_table = GetL2Table(false, pos, &offset_in_cluster, &l2_index, &length);
  if (l2_table == nullptr || !l2_table->entries[l2_index]) {
    if (backing_file_ == nullptr) { /* Reading at unallocated space always return zero??? */
      if (no_zero)
        return -2;
      bzero(buffer, length);
      return length;
    }
    return backing_file_->ReadCluster(buffer, pos, length);
  }

  uint64_t l2_entry = be64toh(l2_table->entries[l2_index]);
  uint64_t cluster_descriptor = l2_entry & QCOW2_DESCRIPTOR_MASK;

  if (l2_entry & QCOW2_OFLAG_COMPRESSED) { /* Compressed descriptor */
    MV_ASSERT(image_header_.compression_type == kCompressionTypeZstd);

    uint64_t x = (62 - (cluster_bits_ - 8));
    uint64_t mask = (1ULL << (cluster_bits_ - 8)) - 1;
    uint64_t sectors = ((cluster_descriptor >> x) & mask) + 1;
    uint64_t compressed_length = sectors * QCOW2_COMPRESSED_SECTOR_SIZE -
      (cluster_descriptor & ~QCOW2_COMPRESSED_SECTOR_MASK);
    uint64_t host_offset = cluster_descriptor & ((1ULL << x) - 1);

    uint8_t* decompressed = nullptr;
    if (!cluster_cache_.Get(host_offset, decompressed)) {
      if (compressed_.size() < compressed_length)
        compressed_.resize(compressed_length);
      ssize_t bytes_read = ReadFile(compressed_.data(), compressed_length, host_offset);
      if (bytes_read < 0) {
        return bytes_read;
      }

      decompressed = new uint8_t[cluster_size_];
      auto ret = zstd_decompress(compressed_.data(), compressed_length, decompressed, cluster_size_);
      if (ret < 0) {
        delete[] decompressed;
        MV_ERROR("failed to decompressed length=0x%x ret=%d", compressed_length, ret);
        return ret;
      }
      cluster_cache_.Put(host_offset, decompressed);
    }
    memcpy(buffer, decompressed + offset_in_cluster, length);
  } else { /* Standard descriptor */
    if (cluster_descriptor & 1) { // Bit 0 means zero
      bzero(buffer, length);
      return length;
    }

    uint64_t host_offset = cluster_descriptor & QCOW2_STANDARD_OFFSET_MASK;

    ssize_t bytes_read = ReadFile(buffer, length, host_offset + offset_in_cluster);
    if (bytes_read < 0) {
      return bytes_read;
    }
    if ((size_t)bytes_read < length) {
      /* Reach the end of file??? */
      bzero((uint8_t*)buffer + bytes_read, length - bytes_read);
    }
  }
  return length;
}

/* The return value is always less than or equal to cluster size */
ssize_t Qcow2Image::WriteCluster(void* buffer, off_t pos, size_t length) {
  uint64_t offset_in_cluster, l2_index;
  L2Table* l2_table = GetL2Table(true, pos, &offset_in_cluster, &l2_index, &length);
  MV_ASSERT(l2_table);

  uint64_t l2_entry = be64toh(l2_table->entries[l2_index]);
  uint64_t cluster_descriptor = l2_entry & QCOW2_DESCRIPTOR_MASK;

  /* Writing compressed cluster is not supported */
  MV_ASSERT(!(l2_entry & QCOW2_OFLAG_COMPRESSED));
  uint64_t host_offset = cluster_descriptor & QCOW2_STANDARD_OFFSET_MASK;

  if (l2_entry & QCOW2_OFLAG_COPIED) {
    if (WriteFile(buffer, length, host_offset + offset_in_cluster) != (ssize_t)length) {
      return -1;
    }
  } else {
    if (host_offset) {
      MV_PANIC("writing to images with snapshots is not supported yet");
    }
    host_offset = AllocateCluster();
    if (host_offset == 0) {
      MV_ERROR("failed to allocate cluster");
      return -1;
    }

    l2_table->entries[l2_index] = htobe64(host_offset | QCOW2_OFLAG_COPIED);
    l2_table->dirty = true;

    /* If not writing the whole cluster, we should read the original data from the backing file
      * Always read the whole cluster without zeroing data if cluster exists in backing file
      */
    if (backing_file_ && !(offset_in_cluster == 0 && length == cluster_size_)) {
      auto bytes = backing_file_->ReadCluster(copied_cluster_, pos - offset_in_cluster, cluster_size_, true);
      if (bytes > 0) { // Check if exists
        MV_ASSERT(bytes == (ssize_t)cluster_size_); // Make sure we have a whole cluster
        memcpy(copied_cluster_ + offset_in_cluster, buffer, length);
        if (WriteFile(copied_cluster_, cluster_size_, host_offset) != (ssize_t)cluster_size_) {
          MV_PANIC("failed to copy cluster at pos=0x%lx length=0x%lx", pos, length);
        }
        return length; // Always return length of dirty data
      }
    }

    if (WriteFile(buffer, length, host_offset + offset_in_cluster) != (ssize_t)length) {
      MV_PANIC("failed to write image file pos=0x%lx host_offset=0x%lx offset=0x%lx length=0x%lx",
        pos, host_offset, offset_in_cluster, length);
      return -1;
    }
  }

  return length;
}

/* The OS use DISCARD command to inform us some disk regions are freed
  * To recycle these regions, clear the L2 table entry, and set the refcount to 0
  * The return value is always less than or equal to cluster size */
ssize_t Qcow2Image::DiscardCluster(off_t pos, size_t length) {
  uint64_t offset_in_cluster, l2_index;
  auto l2_table = GetL2Table(false, pos, &offset_in_cluster, &l2_index, &length);
  if (l2_table == nullptr) {
    return length;
  }

  if (offset_in_cluster > 0 || length < cluster_size_) {
    // MV_LOG("do nothing, not aligned to 64k pos=0x%lx length=0x%lx", pos, length);
    return length;
  }

  uint64_t l2_entry = be64toh(l2_table->entries[l2_index]);
  uint64_t cluster_descriptor = l2_entry & QCOW2_DESCRIPTOR_MASK;

  /* Writing compressed cluster is not supported */
  MV_ASSERT(!(l2_entry & QCOW2_OFLAG_COMPRESSED));
  uint64_t host_offset = cluster_descriptor & QCOW2_STANDARD_OFFSET_MASK;

  if ((cluster_descriptor & 1) || host_offset == 0) {
    return length;
  }

  FreeCluster(host_offset);
  l2_table->entries[l2_index] = be64toh(0);
  l2_table->dirty = true;
  return length;
}

ssize_t Qcow2Image::BlockIo(void *buffer, off_t position, size_t length, ImageIoType type) {
  size_t offset = 0;
  uint8_t *ptr = (uint8_t*)buffer;

  while (offset < length) {
    if ((uint64_t)position >= image_header_.size) {
      return offset;
    }

    ssize_t ret;
    switch (type) {
    case kImageIoRead:
      ret = ReadCluster(ptr, position, length - offset);
      break;
    case kImageIoWrite:
      ret = WriteCluster(ptr, position, length - offset);
      break;
    case kImageIoDiscard:
    case kImageIoWriteZeros:
      ret = DiscardCluster(position, length - offset);
      break;
    default:
      ret = -EINVAL;
      MV_PANIC("invalid type=%d", type);
    }
    if (ret <= 0) {
      return ret;
    }

    offset += ret;
    ptr += ret;
    position += ret;
  }
  return offset;
}

void Qcow2Image::FlushL2Tables () {
  int l2_table_dirty_count = 0;
  auto map = l2_cache_.map();
  for (auto it = map.begin(); it != map.end(); it++) {
    auto l2_table = it->second->second;
    if (l2_table->dirty) {
      WriteL2Table(l2_table);
      ++l2_table_dirty_count;
    }
  }
}

void Qcow2Image::FlushRefcountBlocks() {
  int refcount_block_dirty_count = 0;
  auto map = rfb_cache_.map();
  for (auto it = map.begin(); it != map.end(); it++) {
    auto rfb = it->second->second;
    if (rfb->dirty) {
      WriteRefcountBlock(rfb);
      ++refcount_block_dirty_count;
    }
  }
}

long Qcow2Image::HandleIoRequest(ImageIoRequest request) {
  long ret = -1;
  switch (request.type)
  {
  case kImageIoRead:
  case kImageIoWrite: {
    size_t rw_total = 0, pos = request.position;
    for (auto &iov : request.vector) {
      ret = BlockIo(iov.iov_base, pos, iov.iov_len, request.type);
      if (ret <= 0) {
        return ret;
      }
      rw_total += ret;
      pos += ret;
    }
    ret = rw_total;
    break;
  }
  case kImageIoDiscard:
  case kImageIoWriteZeros:
    ret = BlockIo(nullptr, request.position, request.length, request.type);
    break;
  case kImageIoFlush:
    ret = FlushAll();
    break;
  default:
    MV_ERROR("unhandled io request %d", request.type);
    break;
  }
  return ret;
}

ssize_t Qcow2Image::FlushAll() {
  if (readonly_) {
    return 0;
  }

  FlushL2Tables();
  FlushRefcountBlocks();
  if (l1_table_dirty_) {
    WriteL1Table();
  }
  if (refcount_table_dirty_) {
    WriteRefcountTable();
  }

  return fsync(fd_);
}

DECLARE_DISK_IMAGE(Qcow2Image);

```

`images/qcow2_create.cc`:

```cc
/* 
 * MVisor QCOW2 Disk Image
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "qcow2.h"
#include <cstdio>
#include <cstring>
#include "logger.h"

struct HeaderExtension {
  uint32_t  type;
  uint32_t  length;
  uint8_t   data[0];
} __attribute__((packed));

struct FeatureName {
  uint8_t   type;
  uint8_t   bit;
  char      name[46];
} __attribute__((packed));

static FeatureName default_features[] = {
  { 0, 0, "dirty bit" },
  { 0, 1, "corrupt bit" },
  { 0, 2, "external data file" },
  { 0, 3, "compression type" },
  { 0, 4, "extended L2 entries" },
  { 1, 0, "lazy refcounts" },
  { 2, 0, "bitmaps" },
  { 2, 1, "raw external data" }
};


void Qcow2Image::CreateEmptyImage(std::string path, size_t disk_size) {
  uint cluster_bits = 0x10;
  size_t cluster_size = 1 << cluster_bits;
  FILE* fp = fopen(path.c_str(), "wb");
  if (fp == nullptr) {
    MV_PANIC("failed to create image file: %s", path.c_str());
  }

  /* Build header */
  Qcow2Header header;
  bzero(&header, sizeof(header));
  header.magic = htobe32(0x514649FB);
  header.version = htobe32(3);
  header.cluster_bits = htobe32(cluster_bits);
  header.size = htobe64(disk_size);
  header.l1_size = htobe32(disk_size / cluster_size / (cluster_size / sizeof(uint64_t)));
  header.l1_table_offset = htobe64(cluster_size * 3);
  header.refcount_table_offset = htobe64(cluster_size * 1);
  header.refcount_table_clusters = htobe32(1);
  header.refcount_order = htobe32(4);
  header.header_length = htobe32(0x70);
  fwrite(&header, sizeof(header), 1, fp);

  /* Seek to extensions */
  fseek(fp, 0x70, SEEK_SET);

  HeaderExtension feature_extension;
  feature_extension.type = htobe32(0x6803F857);
  feature_extension.length = htobe32(sizeof(default_features));

  fwrite(&feature_extension, sizeof(feature_extension), 1, fp);
  fwrite(default_features, sizeof(default_features), 1, fp);

  /* Seek to refcount table */
  fseek(fp, cluster_size * 1, SEEK_SET);
  uint64_t refcount_table_entry = htobe64(cluster_size * 2);
  fwrite(&refcount_table_entry, sizeof(refcount_table_entry), 1, fp);

  /* Seek to refcount block */
  fseek(fp, cluster_size * 2, SEEK_SET);
  /* We have allocated 4 clusters */
  for (int i = 0; i < 4; i++) {
    uint16_t refcount_block_entry = htobe16(1);
    fwrite(&refcount_block_entry, sizeof(refcount_block_entry), 1, fp);
  }

  /* Seek to L1 table */
  fseek(fp, cluster_size * 3, SEEK_SET);

  /* Done */
  fclose(fp);
}

void Qcow2Image::CreateImageWithBackingFile(std::string path, std::string backing_path) {
  FILE* fin = fopen(backing_path.c_str(), "rb");
  if (fin == nullptr) {
    MV_PANIC("failed to open QCOW2 file: %s", backing_path.c_str());
  }
  FILE* fout = fopen(path.c_str(), "wb");
  if (fout == nullptr) {
    MV_PANIC("failed to create QCOW2 file: %s", path.c_str());
  }

  /* Read header */
  Qcow2Header backing_header;
  fread(&backing_header, sizeof(Qcow2Header), 1, fin);
  if (be32toh(backing_header.version) != 3) {
    MV_PANIC("file %s version %u is not supported", backing_path.c_str(), be32toh(backing_header.version));
  }
  uint32_t header_length = be32toh(backing_header.header_length);
  uint32_t cluster_size = 1 << be32toh(backing_header.cluster_bits);

  /* Copy header extensions */
  fseek(fin, header_length, SEEK_SET);
  fseek(fout, header_length, SEEK_SET);
  bool wrote_backing_format = false;
  while (true) {
    HeaderExtension extension;
    fread(&extension, sizeof(extension), 1, fin);
    if (extension.type == 0)
      break;
    fwrite(&extension, sizeof(extension), 1, fout);
    uint32_t data_length = be32toh(extension.length);
    if (data_length & 7)
      data_length += 8 - (data_length & 7);
    uint8_t data[data_length];
    fread(data, data_length, 1, fin);
    fwrite(data, data_length, 1, fout);
    if (be32toh(extension.type) == 0xE2792ACA) {
      wrote_backing_format = true;
    }
  }

  if (!wrote_backing_format) {
    struct {
      HeaderExtension extension;
      char data[8];
    } ext;
    bzero(&ext, sizeof(ext));
    ext.extension.type = htobe32(0xE2792ACA),
    ext.extension.length = htobe32(5);

    strcpy(ext.data, "qcow2");
    fwrite(&ext, sizeof(ext), 1, fout);
  }

  /* Write backing file path */
  off_t pos = ftell(fout);
  if (pos & 0xF) {
    pos += 16 - (pos & 0xF);
  }
  fseek(fout, pos, SEEK_SET);
  fwrite(backing_path.data(), backing_path.length(), 1, fout);
  
  /* Write image header */
  uint8_t buffer[header_length];
  fseek(fin, 0, SEEK_SET);
  fseek(fout, 0, SEEK_SET);
  fread(buffer, header_length, 1, fin);
  auto header = (Qcow2Header*)buffer;
  header->backing_file_offset = htobe64(pos);
  header->backing_file_size = htobe32(backing_path.length());
  fwrite(buffer, header_length, 1, fout);

  /* Seek to refcount table */
  fseek(fout, cluster_size * 1, SEEK_SET);
  uint64_t refcount_table_entry = htobe64(cluster_size * 2);
  fwrite(&refcount_table_entry, sizeof(refcount_table_entry), 1, fout);

  /* Seek to refcount block */
  fseek(fout, cluster_size * 2, SEEK_SET);
  /* We have allocated 4 clusters */
  for (int i = 0; i < 4; i++) {
    uint16_t refcount_block_entry = htobe16(1);
    fwrite(&refcount_block_entry, sizeof(refcount_block_entry), 1, fout);
  }

  /* Seek to L1 table */
  fseek(fout, cluster_size * 3, SEEK_SET);

  /* Done */
  fclose(fin);
  fclose(fout);
}

```

`images/raw.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "disk_image.h"

#include <unistd.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <filesystem>

#include "logger.h"
#include "device_manager.h"

class RawImage : public DiskImage {
 private:
  int fd_ = -1;
  size_t block_size_ = 512;
  size_t total_blocks_ = 0;

  ImageInformation information() {
    return ImageInformation {
      .block_size = block_size_,
      .total_blocks = total_blocks_
    };
  }

  virtual ~RawImage() {
    if (fd_ != -1) {
      FlushAll();
      safe_close(&fd_);
    }

    if (snapshot_) {
      remove(filepath_.c_str());
    }
  }

  void Initialize() {
    int oflags = readonly_ ? O_RDONLY : O_RDWR;
    if (snapshot_) {
      char temp[] = "/tmp/snapshot_XXXXXX.img";
      close(mkstemps(temp, 4));
      std::filesystem::copy_file(filepath_, temp, std::filesystem::copy_options::overwrite_existing);
      filepath_ = temp;
    }
    
    fd_ = open(filepath_.c_str(), oflags);
    if (fd_ < 0)
      MV_PANIC("disk file not found: %s", filepath_.c_str());

    struct stat st;
    fstat(fd_, &st);
    block_size_ = 512;
    total_blocks_ = st.st_size / block_size_;
  }

  long HandleIoRequest(ImageIoRequest request) {
    long ret = -1;

    switch (request.type)
    {
    case kImageIoRead:
    case kImageIoWrite: {
      size_t rw_total = 0, pos = request.position;
      for (auto &iov : request.vector) {
        if (request.type == kImageIoRead) {
          ret = pread(fd_, iov.iov_base, iov.iov_len, pos);
        } else {
          ret = pwrite(fd_, iov.iov_base, iov.iov_len, pos);
        }
        if (ret <= 0) {
          return ret;
        }
        rw_total += ret;
        pos += ret;
      }
      ret = rw_total;
      break;
    }
    case kImageIoFlush:
      ret = FlushAll();
      break;
    default:
      MV_ERROR("unhandled io request %d", request.type);
      break;
    }
    return ret;
  }

  ssize_t FlushAll() {
    if (readonly_) {
      return 0;
    } else {
      return fsync(fd_);
    }
  }

};

DECLARE_DISK_IMAGE(RawImage);

```

`include/configuration.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_CONFIG_H
#define _MVISOR_CONFIG_H

#include <string>
#include <map>
#include <set>
#include <cstdio>
#include <yaml-cpp/yaml.h>
#include "object.h"

class Device;
class Machine;
class Configuration {
 public:
  Configuration(Machine* machine);
  bool Load(std::string path);
  bool Save(std::string path);
  std::string FindPath(std::string path) const;

  inline const std::string& path() const { return path_; }
  inline const std::string& bios_path() const { return bios_path_; }

 private:
  void InitializePaths();
  bool LoadFile(std::string path);
  void LoadMachine(const YAML::Node& node);
  void LoadObjects(const YAML::Node& node);
  void SaveMachine(YAML::Node& node);
  void SetObjectKeyValue(Object* object, std::string key, const YAML::Node& value);
  Object* CreateObject(std::string class_name, std::string name = "");
  Object* GetOrCreateObject(std::string class_name, std::string name);
  std::string GenerateObjectName(std::string class_name);
  void CreateParents(Object* object);

  Machine*    machine_;
  std::set<std::string> directories_;
  std::string path_;
  std::string bios_path_;
};

#endif // _MVISOR_CONFIG_H

```

`include/device.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICE_H
#define _MVISOR_DEVICE_H


#include <string>
#include <list>
#include <mutex>

#include "utilities.h"
#include "object.h"
#include "vcpu.h"
#include "io_thread.h"
#include "migration.h"


enum IoResourceType {
  kIoResourceTypePio,
  kIoResourceTypeMmio,
  kIoResourceTypeRam
};

enum IoResourceFlag {
  kIoResourceFlagNone = 0,
  kIoResourceFlagCoalescingMmio = 1
};

struct MemoryRegion;
struct IoResource {
  IoResourceType      type;
  uint64_t            base;
  uint64_t            length;
  const char*         name;
  bool                enabled;
  void*               host_memory;
  const MemoryRegion* mapped_region;
  IoResourceFlag      flags;
};

class DeviceManager;
class Device : public Object {
 public:
  Device();
  virtual ~Device();

  virtual void Connect();
  virtual void Disconnect();
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Reset();

  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);

  /* Map to IoThread methods, and you don't need to pass the device object */
  IoTimer* AddTimer(int64_t interval_ns, bool permanent, VoidCallback callback);
  void ModifyTimer(IoTimer* timer, int64_t interval_ns);
  void RemoveTimer(IoTimer* timer);
  void Schedule(VoidCallback callback);
  void StartPolling(int fd, uint poll_mask, IoCallback callback);
  void StopPolling(int fd);

  inline const std::list<IoResource*>& io_resources() const { return io_resources_; }
  inline DeviceManager* manager() { return manager_; }
  inline std::recursive_mutex& mutex() { return mutex_; }

 protected:
  void AddIoResource(IoResourceType type, uint64_t base, uint64_t length, const char* name);
  void AddIoResource(IoResourceType type, uint64_t base, uint64_t length, const char* name, void* host_memory, IoResourceFlag flags = kIoResourceFlagNone);
  void RemoveIoResource(IoResourceType type, const char* name);
  void RemoveIoResource(IoResourceType type, uint64_t base);
  void SetIoResourceEnabled(IoResource* resource, bool enabled);

  friend class IoThread;
  friend class DeviceManager;
  DeviceManager* manager_;

  bool                    connected_ = false;
  std::list<IoResource*>  io_resources_;
  std::recursive_mutex    mutex_;
};

#endif // _MVISOR_DEVICE_H

```

`include/device_interface.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICE_INTERFACES_H
#define _MVISOR_DEVICE_INTERFACES_H

#include <functional>
#include <vector>
#include <cstring>
#include <string>
#include <deque>
#include <sys/uio.h>

class KeyboardInputInterface {
 public:
  virtual ~KeyboardInputInterface() = default;
  virtual bool QueueKeyboardEvent(uint8_t scancode[10], uint8_t modifiers) = 0;
  virtual bool QueueMouseEvent(uint button_state, int rel_x, int rel_y, int rel_z) = 0;
  virtual bool InputAcceptable() = 0;
};

struct PointerEvent {
  uint  buttons;
  int   x;
  int   y;
  int   z;
  uint  screen_width;
  uint  screen_height;
};

class PointerInputInterface {
 public:
  virtual ~PointerInputInterface() = default;
  virtual bool QueuePointerEvent(PointerEvent event) = 0;
  virtual bool InputAcceptable() = 0;
};

struct MidiEvent {
  uint8_t cable_code_index;
  uint8_t midi_0;
  uint8_t midi_1;
  uint8_t midi_2;
};

class MidiInputInterface {
 public:
  virtual ~MidiInputInterface() = default;
  virtual bool QueueMidiEvent(MidiEvent event) = 0;
  virtual bool InputAcceptable() = 0;
  virtual void Start() = 0;
  virtual void Stop() = 0;
};

struct WacomEvent {
  double x;
  double y;
  double pressure;
  uint32_t buttons;
  uint32_t tilt_x;
  uint32_t tilt_y;
};

class WacomInputInterface {
 public:
  virtual ~WacomInputInterface() = default;
  virtual bool QueueWacomEvent(WacomEvent event) = 0;
  virtual bool InputAcceptable() = 0;
  virtual void Start() = 0;
  virtual void Stop() = 0;
};

class DisplayResizeInterface {
 public:
  virtual ~DisplayResizeInterface() = default;
  virtual bool Resize(int width, int height) = 0;
};

typedef std::function <void()> VirtioFsListener;
class VirtioFsInterface {
 public:
  virtual ~VirtioFsInterface() = default;
  virtual void RegisterVirtioFsListener(VirtioFsListener callback) = 0;
};

struct ClipboardData {
  uint32_t        type;
  std::string     data;
  std::string     file_name;
};

typedef std::function <void(const ClipboardData clipboard_data)> ClipboardListener;
class ClipboardInterface {
 public:
  virtual ~ClipboardInterface() = default;
  virtual void RegisterClipboardListener(ClipboardListener callback) = 0;
  virtual bool ClipboardDataToGuest(uint type, const std::string& data) = 0;
};


struct DisplayPartialBitmap {
  int           bpp;
  int           width;
  int           height;
  int           stride;
  int           x;
  int           y;
  uint8_t*      data;
  uint8_t*      palette;
};
struct DisplayMouseCursor {
  uint8_t       visible;
  int           x;
  int           y;
  uint64_t      update_timestamp;
  struct {
    uint64_t    id;
    int16_t     type;
    int16_t     width;
    int16_t     height;
    int16_t     hotspot_x;
    int16_t     hotspot_y;
    std::string data;
  } shape;
};
struct DisplayUpdate {
  std::vector<DisplayPartialBitmap>  partials;
  DisplayMouseCursor                 cursor;
};

typedef std::function <void(void)> DisplayModeChangeListener;
typedef std::function <void(void)> DisplayUpdateListener;
class DisplayInterface {
 public:
  virtual ~DisplayInterface() = default;
  virtual void GetDisplayMode(int* w, int* h, int* bpp, int* stride) = 0;
  virtual void GetPalette(const uint8_t** palette, int* count) = 0;
  virtual bool AcquireUpdate(DisplayUpdate& update, bool redraw) = 0;
  virtual void ReleaseUpdate() = 0;
  virtual void RegisterDisplayModeChangeListener(DisplayModeChangeListener callback) = 0;
  virtual void RegisterDisplayUpdateListener(DisplayUpdateListener callback) = 0;
};


struct PlaybackFormat {
  uint format;
  uint channels;
  uint frequency;
  uint interval_ms;
};

enum PlaybackState {
  kPlaybackStart,
  kPlaybackStop,
  kPlaybackData
};

typedef std::function <void(PlaybackState state, struct iovec iov)> PlaybackListener;
class PlaybackInterface {
 public:
  virtual ~PlaybackInterface() = default;
  virtual void GetPlaybackFormat(uint* format, uint* channels, uint* frequency, uint* interval_ms) = 0;
  virtual void RegisterPlaybackListener(PlaybackListener callback) = 0;
};

struct RecordFormat {
  int frequency = 48000;
  int channels = 2;
};

enum RecordState {
  kRecordStart,
  kRecordStop
};

typedef std::function <void(RecordState state)>   RecordListener;
class RecordInterface {
  public:
  virtual ~RecordInterface() = default;
  virtual void WriteRecordDataToDevice(const std::string& record_data) = 0;
  virtual void RegisterRecordListener(RecordListener callback) = 0;
};


class SerialPortInterface;
class SerialDeviceInterface {
 public:
  virtual ~SerialDeviceInterface() = default;
  virtual void SendMessage(SerialPortInterface* port, uint8_t* data, size_t size) = 0;
};

enum SerialPortEvent {
  kSerialPortStatusChanged,
  kSerialPortData
};

class SerialPortInterface {
 public:
  virtual ~SerialPortInterface() = default;
  virtual void OnMessage(uint8_t* data, size_t size) {
    if (callback_)
      callback_(kSerialPortData, data, size);
  }
  virtual void OnWritable() {
    writable_ = true;
  }
  virtual void SendMessage(uint8_t* data, size_t size) {
    device_->SendMessage(this, data, size);
  }

  void Initialize(SerialDeviceInterface* device, uint32_t id) {
    device_ = device;
    port_id_ = id;
  }

  virtual void set_ready(bool ready) {
    ready_ = ready;
    if (callback_) {
      callback_(kSerialPortStatusChanged, nullptr, 0);
    }
  }

  virtual void set_callback(std::function<void(SerialPortEvent, uint8_t*, size_t)> callback) {
    callback_ = callback;
  }

  inline uint32_t     port_id() const { return port_id_; }
  inline const char*  port_name() const { return port_name_; }
  inline bool         ready() const { return ready_; }

 protected:
  SerialDeviceInterface* device_;
  std::function<void(SerialPortEvent, uint8_t*, size_t)> callback_;
  uint32_t  port_id_;
  char      port_name_[100];
  bool      ready_ = false;
  bool      writable_ = false;

};

struct RedirectRule {
  uint        protocol;
  uint32_t    match_ip;
  uint16_t    match_port;
  uint32_t    target_ip;
  uint16_t    target_port;
};

struct MapRule {
  uint        protocol;
  uint32_t    listen_ip;
  uint16_t    listen_port;
  uint32_t    target_ip;
  uint16_t    target_port;
};

struct MacAddress {
  union {
    uint8_t   data[6];
    uint64_t  value : 48;
  };
  bool operator < (const MacAddress& a) const {
    return memcmp(data, a.data, 6) < 0;
  }
};

class NetworkDeviceInterface {
 public:
  virtual ~NetworkDeviceInterface() = default;
  virtual bool WriteBuffer(void* buffer, size_t size) = 0;
};

struct Ipv4Packet;
class NetworkBackendInterface {
 public:
  virtual ~NetworkBackendInterface() = default;
  virtual void Initialize(NetworkDeviceInterface* device, MacAddress& mac) = 0;
  virtual void SetMtu(int mtu) = 0;
  virtual void Reset() = 0;
  virtual void OnFrameFromGuest(std::deque<iovec>& vector) = 0;
  virtual bool OnPacketFromHost(Ipv4Packet* packet) = 0;
  virtual Ipv4Packet* AllocatePacket(bool urgent) = 0;
  virtual void OnReceiveAvailable() = 0;

  inline NetworkDeviceInterface* device() { return device_; }
  inline MacAddress& router_mac() { return router_mac_; }
  inline uint32_t router_ip() { return router_ip_; }
  inline uint32_t router_subnet_mask() { return router_subnet_mask_; }
  inline uint32_t guest_ip() { return guest_ip_; }
  inline const std::vector<RedirectRule>& redirect_rules() const { return redirect_rules_; }
  inline const std::vector<MapRule>& map_rules() const { return map_rules_; }

 protected:
  NetworkDeviceInterface*   device_;
  MacAddress                guest_mac_;
  MacAddress                router_mac_;
  uint32_t                  router_ip_;
  uint32_t                  router_subnet_mask_;
  uint32_t                  guest_ip_;
  std::vector<RedirectRule> redirect_rules_;
  std::vector<MapRule>      map_rules_;
};


class PowerDownInterface {
 public:
  virtual ~PowerDownInterface() = default;
  virtual void PowerDown() = 0;
};

class CmosDataInterface {
 public:
  virtual ~CmosDataInterface() = default;
  virtual void SetData(uint8_t index, uint8_t data) = 0;
};

#endif // _MVISOR_DEVICE_INTERFACES_H

```

`include/device_manager.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_DEVICE_MANAGER_H
#define _MVISOR_DEVICE_MANAGER_H

#include <set>
#include <string>
#include <deque>
#include <mutex>
#include <vector>
#include <thread>
#include "pci_device.h"
#include "device.h"
#include "io_thread.h"

struct MemoryRegion;
struct IoHandler {
  const IoResource*   resource;
  Device*             device;
  const MemoryRegion* memory_region;
};

typedef std::function<void()> VoidCallback;
typedef std::function<uint (uint, uint, uint)> PciIrqTranslator; 

enum IoEventType {
  kIoEventPio,
  kIoEventMmio,
  kIoEventFd
};

struct IoEvent {
  IoEventType     type;
  Device*         device;
  uint64_t        address;
  uint32_t        length;
  uint64_t        datamatch;
  uint32_t        flags;
  int             fd;
};

struct IoAccounting {
  IoTimePoint     last_print_time;
  uint            total_pio = 0;
  uint            total_mmio = 0;
};

struct DirtyMemoryRegion {
  uint64_t hva;
  uint64_t begin;
  uint64_t end;
};

struct DirtyMemoryBitmap {
  struct DirtyMemoryRegion region;
  std::string data;
};

class Machine;
class DeviceManager {
 public:
  DeviceManager(Machine* machine, Device* root);
  ~DeviceManager();

  void RegisterDevice(Device* device);
  void UnregisterDevice(Device* device);
  void ResetDevices();
  void RegisterVfioGroup(int group_fd);
  void UnregisterVfioGroup(int group_fd);

  void RegisterIoHandler(Device* device, const IoResource* resource);
  void UnregisterIoHandler(Device* device, const IoResource* resource);
  IoEvent* RegisterIoEvent(Device* device, IoResourceType type, uint64_t address);
  IoEvent* RegisterIoEvent(Device* device, IoResourceType type, uint64_t address, uint32_t length, uint64_t datamatch);
  void UnregisterIoEvent(Device* device, IoResourceType type, uint64_t address);
  void UnregisterIoEvent(IoEvent* event);
  void SetupCoalescingMmioRing(kvm_coalesced_mmio_ring* ring);
  void FlushCoalescingMmioBuffer();

  void PrintDevices();
  Device* LookupDeviceByClass(const std::string class_name);
  PciDevice* LookupPciDevice(uint16_t bus, uint8_t slot, uint8_t function);

  /* call by machine */
  void HandleIo(uint16_t port, uint8_t* data, uint16_t size, int is_write, uint32_t count, bool ioeventfd = false);
  void HandleMmio(uint64_t addr, uint8_t* data, uint16_t size, int is_write, bool ioeventfd = false);

  void* TranslateGuestMemory(uint64_t gpa);
  void AddDirtyMemory(uint64_t gpa, size_t size = 0);
  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);
  
  /* IRQ / MSIs all are GSIs */
  void SetGsiLevel(uint gsi, uint level);
  void SetPciIrqLevel(PciDevice* pci, uint level);
  void SignalMsi(uint64_t address, uint32_t data);
  int AddMsiRoute(uint64_t address, uint32_t data, int trigger_fd = -1);
  void UpdateMsiRoute(int gsi, uint64_t address, uint32_t data, int trigger_fd = -1);

  /* Called by PIIX3 or ICH9 LPC */
  void set_pci_irq_translator(PciIrqTranslator translator) { pci_irq_translator_ = translator; }

  inline Machine* machine() { return machine_; }
  inline Device* root() { return root_; }
  IoThread* io();

 private:
  void SetupIrqChip();
  void SetupGsiRoutingTable();
  void UpdateGsiRoutingTable();

 private:
  Machine*                            machine_;
  Device*                             root_;
  std::set<Device*>                   registered_devices_;
  std::deque<IoHandler*>              mmio_handlers_;
  std::deque<IoHandler*>              pio_handlers_;
  std::set<IoEvent*>                  ioevents_;
  std::recursive_mutex                mutex_;
  std::vector<kvm_irq_routing_entry>  gsi_routing_table_;
  int                                 next_gsi_ = 0;
  IoAccounting                        io_accounting_;
  int                                 vfio_kvm_device_fd_ = -1;
  kvm_coalesced_mmio_ring*            coalesced_mmio_ring_ = nullptr;
  std::recursive_mutex                coalesced_mmio_ring_mutex_;
  PciIrqTranslator                    pci_irq_translator_;
  std::unordered_set<uint>            pci_irq_raised_[32];
};

#endif // _MVISOR_DEVICE_MANAGER_H

```

`include/disk_image.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_IMAGE_H
#define _MVISOR_IMAGE_H

#include <string>
#include <functional>
#include <thread>
#include <mutex>
#include <deque>
#include <condition_variable>

#include "utilities.h"
#include "object.h"
#include "io_thread.h"

typedef std::function<void(ssize_t ret)> IoCallback;

enum ImageIoType {
  kImageIoInformation,
  kImageIoRead,
  kImageIoWrite,
  kImageIoFlush,
  kImageIoDiscard,
  kImageIoWriteZeros
};

struct ImageIoRequest {
  ImageIoType         type;
  size_t              position;
  size_t              length;
  std::vector<iovec>  vector;
};

struct ImageInformation {
  /* Disk size is block_size * total_blocks */
  size_t block_size;
  size_t total_blocks;
};

class Device;
class DiskImage : public Object {
 public:
  static DiskImage* Create(Device* device, std::string path, bool readonly, bool snapshot);

  DiskImage();
  virtual ~DiskImage();

  bool busy();
  inline bool readonly() { return readonly_; }
  inline const std::string& filepath() const { return filepath_; }
  inline Device* deivce() { return device_; }
  inline bool snapshot() { return snapshot_; }

  /* Always use this static method to create a DiskImage */

  /* Interface for a image format to implement */
  virtual ImageInformation information() = 0;
  virtual long HandleIoRequest(ImageIoRequest request) = 0;

  /* Interface for user */
  virtual void QueueIoRequest(ImageIoRequest request, IoCallback callback);
  virtual void QueueMultipleIoRequests(std::vector<ImageIoRequest> requests, IoCallback callback);

 protected:
  bool        readonly_ = false;
  bool        snapshot_ = false;
  Device*     device_ = nullptr;
  Device*     host_device_ = nullptr;
  IoThread*   io_ = nullptr;
  std::string filepath_;

  virtual void Initialize() = 0;
  virtual void Finalize();

 private:
  /* Worker thread to implemente Async IO */
  std::thread               worker_thread_;
  std::mutex                worker_mutex_;
  std::condition_variable   worker_cv_;
  std::deque<VoidCallback>  worker_queue_;
  bool                      finalized_ = false;

  void WorkerProcess();
};


#endif // _MVISOR_DISK_IMAGE_H

```

`include/hyperv/cpuid.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MVISOR_CPUID_H
#define MVISOR_CPUID_H

#define CPUID_TOPOLOGY_LEVEL_SMT      (1U << 8)
#define CPUID_TOPOLOGY_LEVEL_CORE     (2U << 8)
#define CPUID_TOPOLOGY_LEVEL_INVALID  (0U << 8)

#define MSR_IA32_TSC                  0x10
#define MSR_IA32_UCODE_REV            0x8B
#define MSR_IA32_PERF_CAPABILITIES    0x345


/* cpuid_features bits */
#define CPUID_FP87 (1U << 0)
#define CPUID_VME  (1U << 1)
#define CPUID_DE   (1U << 2)
#define CPUID_PSE  (1U << 3)
#define CPUID_TSC  (1U << 4)
#define CPUID_MSR  (1U << 5)
#define CPUID_PAE  (1U << 6)
#define CPUID_MCE  (1U << 7)
#define CPUID_CX8  (1U << 8)
#define CPUID_APIC (1U << 9)
#define CPUID_SEP  (1U << 11) /* sysenter/sysexit */
#define CPUID_MTRR (1U << 12)
#define CPUID_PGE  (1U << 13)
#define CPUID_MCA  (1U << 14)
#define CPUID_CMOV (1U << 15)
#define CPUID_PAT  (1U << 16)
#define CPUID_PSE36   (1U << 17)
#define CPUID_PN   (1U << 18)
#define CPUID_CLFLUSH (1U << 19)
#define CPUID_DTS (1U << 21)
#define CPUID_ACPI (1U << 22)
#define CPUID_MMX  (1U << 23)
#define CPUID_FXSR (1U << 24)
#define CPUID_SSE  (1U << 25)
#define CPUID_SSE2 (1U << 26)
#define CPUID_SS (1U << 27)
#define CPUID_HT (1U << 28)
#define CPUID_TM (1U << 29)
#define CPUID_IA64 (1U << 30)
#define CPUID_PBE (1U << 31)

#define CPUID_EXT_SSE3     (1U << 0)
#define CPUID_EXT_PCLMULQDQ (1U << 1)
#define CPUID_EXT_DTES64   (1U << 2)
#define CPUID_EXT_MONITOR  (1U << 3)
#define CPUID_EXT_DSCPL    (1U << 4)
#define CPUID_EXT_VMX      (1U << 5)
#define CPUID_EXT_SMX      (1U << 6)
#define CPUID_EXT_EST      (1U << 7)
#define CPUID_EXT_TM2      (1U << 8)
#define CPUID_EXT_SSSE3    (1U << 9)
#define CPUID_EXT_CID      (1U << 10)
#define CPUID_EXT_FMA      (1U << 12)
#define CPUID_EXT_CX16     (1U << 13)
#define CPUID_EXT_XTPR     (1U << 14)
#define CPUID_EXT_PDCM     (1U << 15)
#define CPUID_EXT_PCID     (1U << 17)
#define CPUID_EXT_DCA      (1U << 18)
#define CPUID_EXT_SSE41    (1U << 19)
#define CPUID_EXT_SSE42    (1U << 20)
#define CPUID_EXT_X2APIC   (1U << 21)
#define CPUID_EXT_MOVBE    (1U << 22)
#define CPUID_EXT_POPCNT   (1U << 23)
#define CPUID_EXT_TSC_DEADLINE_TIMER (1U << 24)
#define CPUID_EXT_AES      (1U << 25)
#define CPUID_EXT_XSAVE    (1U << 26)
#define CPUID_EXT_OSXSAVE  (1U << 27)
#define CPUID_EXT_AVX      (1U << 28)
#define CPUID_EXT_F16C     (1U << 29)
#define CPUID_EXT_RDRAND   (1U << 30)
#define CPUID_EXT_HYPERVISOR  (1U << 31)

#define CPUID_EXT2_FPU     (1U << 0)
#define CPUID_EXT2_VME     (1U << 1)
#define CPUID_EXT2_DE      (1U << 2)
#define CPUID_EXT2_PSE     (1U << 3)
#define CPUID_EXT2_TSC     (1U << 4)
#define CPUID_EXT2_MSR     (1U << 5)
#define CPUID_EXT2_PAE     (1U << 6)
#define CPUID_EXT2_MCE     (1U << 7)
#define CPUID_EXT2_CX8     (1U << 8)
#define CPUID_EXT2_APIC    (1U << 9)
#define CPUID_EXT2_SYSCALL (1U << 11)
#define CPUID_EXT2_MTRR    (1U << 12)
#define CPUID_EXT2_PGE     (1U << 13)
#define CPUID_EXT2_MCA     (1U << 14)
#define CPUID_EXT2_CMOV    (1U << 15)
#define CPUID_EXT2_PAT     (1U << 16)
#define CPUID_EXT2_PSE36   (1U << 17)
#define CPUID_EXT2_MP      (1U << 19)
#define CPUID_EXT2_NX      (1U << 20)
#define CPUID_EXT2_MMXEXT  (1U << 22)
#define CPUID_EXT2_MMX     (1U << 23)
#define CPUID_EXT2_FXSR    (1U << 24)
#define CPUID_EXT2_FFXSR   (1U << 25)
#define CPUID_EXT2_PDPE1GB (1U << 26)
#define CPUID_EXT2_RDTSCP  (1U << 27)
#define CPUID_EXT2_LM      (1U << 29)
#define CPUID_EXT2_3DNOWEXT (1U << 30)
#define CPUID_EXT2_3DNOW   (1U << 31)


/* Support RDFSBASE/RDGSBASE/WRFSBASE/WRGSBASE */
#define CPUID_7_0_EBX_FSGSBASE          (1U << 0)
/* Support SGX */
#define CPUID_7_0_EBX_TSC_ADJUST_MSR    (1U << 1)
/* Support SGX */
#define CPUID_7_0_EBX_SGX               (1U << 2)
/* 1st Group of Advanced Bit Manipulation Extensions */
#define CPUID_7_0_EBX_BMI1              (1U << 3)
/* Hardware Lock Elision */
#define CPUID_7_0_EBX_HLE               (1U << 4)
/* Intel Advanced Vector Extensions 2 */
#define CPUID_7_0_EBX_AVX2              (1U << 5)
/* Supervisor-mode Execution Prevention */
#define CPUID_7_0_EBX_SMEP              (1U << 7)
/* 2nd Group of Advanced Bit Manipulation Extensions */
#define CPUID_7_0_EBX_BMI2              (1U << 8)
/* Enhanced REP MOVSB/STOSB */
#define CPUID_7_0_EBX_ERMS              (1U << 9)
/* Invalidate Process-Context Identifier */
#define CPUID_7_0_EBX_INVPCID           (1U << 10)
/* Restricted Transactional Memory */
#define CPUID_7_0_EBX_RTM               (1U << 11)
/* Memory Protection Extension */
#define CPUID_7_0_EBX_MPX               (1U << 14)
/* AVX-512 Foundation */
#define CPUID_7_0_EBX_AVX512F           (1U << 16)
/* AVX-512 Doubleword & Quadword Instruction */
#define CPUID_7_0_EBX_AVX512DQ          (1U << 17)
/* Read Random SEED */
#define CPUID_7_0_EBX_RDSEED            (1U << 18)
/* ADCX and ADOX instructions */
#define CPUID_7_0_EBX_ADX               (1U << 19)
/* Supervisor Mode Access Prevention */
#define CPUID_7_0_EBX_SMAP              (1U << 20)
/* AVX-512 Integer Fused Multiply Add */
#define CPUID_7_0_EBX_AVX512IFMA        (1U << 21)
/* Persistent Commit */
#define CPUID_7_0_EBX_PCOMMIT           (1U << 22)
/* Flush a Cache Line Optimized */
#define CPUID_7_0_EBX_CLFLUSHOPT        (1U << 23)
/* Cache Line Write Back */
#define CPUID_7_0_EBX_CLWB              (1U << 24)
/* Intel Processor Trace */
#define CPUID_7_0_EBX_INTEL_PT          (1U << 25)
/* AVX-512 Prefetch */
#define CPUID_7_0_EBX_AVX512PF          (1U << 26)
/* AVX-512 Exponential and Reciprocal */
#define CPUID_7_0_EBX_AVX512ER          (1U << 27)
/* AVX-512 Conflict Detection */
#define CPUID_7_0_EBX_AVX512CD          (1U << 28)
/* SHA1/SHA256 Instruction Extensions */
#define CPUID_7_0_EBX_SHA_NI            (1U << 29)
/* AVX-512 Byte and Word Instructions */
#define CPUID_7_0_EBX_AVX512BW          (1U << 30)
/* AVX-512 Vector Length Extensions */
#define CPUID_7_0_EBX_AVX512VL          (1U << 31)

/* AVX-512 Vector Byte Manipulation Instruction */
#define CPUID_7_0_ECX_AVX512_VBMI       (1U << 1)
/* User-Mode Instruction Prevention */
#define CPUID_7_0_ECX_UMIP              (1U << 2)
/* Protection Keys for User-mode Pages */
#define CPUID_7_0_ECX_PKU               (1U << 3)
/* OS Enable Protection Keys */
#define CPUID_7_0_ECX_OSPKE             (1U << 4)
/* UMONITOR/UMWAIT/TPAUSE Instructions */
#define CPUID_7_0_ECX_WAITPKG           (1U << 5)
/* Additional AVX-512 Vector Byte Manipulation Instruction */
#define CPUID_7_0_ECX_AVX512_VBMI2      (1U << 6)
/* Galois Field New Instructions */
#define CPUID_7_0_ECX_GFNI              (1U << 8)
/* Vector AES Instructions */
#define CPUID_7_0_ECX_VAES              (1U << 9)
/* Carry-Less Multiplication Quadword */
#define CPUID_7_0_ECX_VPCLMULQDQ        (1U << 10)
/* Vector Neural Network Instructions */
#define CPUID_7_0_ECX_AVX512VNNI        (1U << 11)
/* Support for VPOPCNT[B,W] and VPSHUFBITQMB */
#define CPUID_7_0_ECX_AVX512BITALG      (1U << 12)
/* POPCNT for vectors of DW/QW */
#define CPUID_7_0_ECX_AVX512_VPOPCNTDQ  (1U << 14)
/* 5-level Page Tables */
#define CPUID_7_0_ECX_LA57              (1U << 16)
/* Read Processor ID */
#define CPUID_7_0_ECX_RDPID             (1U << 22)
/* Bus Lock Debug Exception */
#define CPUID_7_0_ECX_BUS_LOCK_DETECT   (1U << 24)
/* Cache Line Demote Instruction */
#define CPUID_7_0_ECX_CLDEMOTE          (1U << 25)
/* Move Doubleword as Direct Store Instruction */
#define CPUID_7_0_ECX_MOVDIRI           (1U << 27)
/* Move 64 Bytes as Direct Store Instruction */
#define CPUID_7_0_ECX_MOVDIR64B         (1U << 28)
/* Support SGX Launch Control */
#define CPUID_7_0_ECX_SGX_LC            (1U << 30)
/* Protection Keys for Supervisor-mode Pages */
#define CPUID_7_0_ECX_PKS               (1U << 31)

/* AVX512 Neural Network Instructions */
#define CPUID_7_0_EDX_AVX512_4VNNIW     (1U << 2)
/* AVX512 Multiply Accumulation Single Precision */
#define CPUID_7_0_EDX_AVX512_4FMAPS     (1U << 3)
/* Fast Short Rep Mov */
#define CPUID_7_0_EDX_FSRM              (1U << 4)
/* AVX512 Vector Pair Intersection to a Pair of Mask Registers */
#define CPUID_7_0_EDX_AVX512_VP2INTERSECT (1U << 8)
/* SERIALIZE instruction */
#define CPUID_7_0_EDX_SERIALIZE         (1U << 14)
/* TSX Suspend Load Address Tracking instruction */
#define CPUID_7_0_EDX_TSX_LDTRK         (1U << 16)
/* AVX512_FP16 instruction */
#define CPUID_7_0_EDX_AVX512_FP16       (1U << 23)
/* Speculation Control */
#define CPUID_7_0_EDX_SPEC_CTRL         (1U << 26)
/* Single Thread Indirect Branch Predictors */
#define CPUID_7_0_EDX_STIBP             (1U << 27)
/* Arch Capabilities */
#define CPUID_7_0_EDX_ARCH_CAPABILITIES (1U << 29)
/* Core Capability */
#define CPUID_7_0_EDX_CORE_CAPABILITY   (1U << 30)
/* Speculative Store Bypass Disable */
#define CPUID_7_0_EDX_SPEC_CTRL_SSBD    (1U << 31)

/* AVX VNNI Instruction */
#define CPUID_7_1_EAX_AVX_VNNI          (1U << 4)
/* AVX512 BFloat16 Instruction */
#define CPUID_7_1_EAX_AVX512_BF16       (1U << 5)

/* XCR0 */
#define XSTATE_FP_BIT                   0
#define XSTATE_SSE_BIT                  1
#define XSTATE_YMM_BIT                  2
#define XSTATE_BNDREGS_BIT              3
#define XSTATE_BNDCSR_BIT               4
#define XSTATE_OPMASK_BIT               5
#define XSTATE_ZMM_Hi256_BIT            6
#define XSTATE_Hi16_ZMM_BIT             7
#define XSTATE_PKRU_BIT                 9

#define XSTATE_FP_MASK                  (1ULL << XSTATE_FP_BIT)
#define XSTATE_SSE_MASK                 (1ULL << XSTATE_SSE_BIT)
#define XSTATE_YMM_MASK                 (1ULL << XSTATE_YMM_BIT)
#define XSTATE_BNDREGS_MASK             (1ULL << XSTATE_BNDREGS_BIT)
#define XSTATE_BNDCSR_MASK              (1ULL << XSTATE_BNDCSR_BIT)
#define XSTATE_OPMASK_MASK              (1ULL << XSTATE_OPMASK_BIT)
#define XSTATE_ZMM_Hi256_MASK           (1ULL << XSTATE_ZMM_Hi256_BIT)
#define XSTATE_Hi16_ZMM_MASK            (1ULL << XSTATE_Hi16_ZMM_BIT)
#define XSTATE_PKRU_MASK                (1ULL << XSTATE_PKRU_BIT)


#define ALTER_FEATURE(ecx, bit, on) \
  if (on) { \
    ecx |= bit; \
  } else { \
    ecx &= ~bit; \
  }

#endif // MVISOR_CPUID_H

```

`include/hyperv/hypercall.h`:

```h
/*
 * Definitions for Hyper-V guest/hypervisor interaction
 *
 * Copyright (c) 2017-2018 Virtuozzo International GmbH.
 *
 * This work is licensed under the terms of the GNU GPL, version 2 or later.
 * See the COPYING file in the top-level directory.
 */

#ifndef MVISOR_HYPERV_HYPERCALL_H
#define MVISOR_HYPERV_HYPERCALL_H

#include <cstdint>

#define BITS_PER_BYTE               8
#define DIV_ROUND_UP(n, d)          (((n) + (d) - 1) / (d))
#define BITS_TO_LONGS(nr)           DIV_ROUND_UP(nr, BITS_PER_BYTE * sizeof(long))
#define DECLARE_BITMAP(name, bits)  unsigned long name[BITS_TO_LONGS(bits)]

/*
 * Hypercall status code
 */
#define HV_STATUS_SUCCESS                     0
#define HV_STATUS_INVALID_HYPERCALL_CODE      2
#define HV_STATUS_INVALID_HYPERCALL_INPUT     3
#define HV_STATUS_INVALID_ALIGNMENT           4
#define HV_STATUS_INVALID_PARAMETER           5
#define HV_STATUS_INSUFFICIENT_MEMORY         11
#define HV_STATUS_INVALID_PORT_ID             17
#define HV_STATUS_INVALID_CONNECTION_ID       18
#define HV_STATUS_INSUFFICIENT_BUFFERS        19

/*
 * Hypercall numbers
 */
#define HV_POST_MESSAGE                       0x005c
#define HV_SIGNAL_EVENT                       0x005d
#define HV_HYPERCALL_FAST                     (1u << 16)

/*
 * Message size
 */
#define HV_MESSAGE_PAYLOAD_SIZE               240

/*
 * Message types
 */
#define HV_MESSAGE_NONE                       0x00000000
#define HV_MESSAGE_VMBUS                      0x00000001
#define HV_MESSAGE_UNMAPPED_GPA               0x80000000
#define HV_MESSAGE_GPA_INTERCEPT              0x80000001
#define HV_MESSAGE_TIMER_EXPIRED              0x80000010
#define HV_MESSAGE_INVALID_VP_REGISTER_VALUE  0x80000020
#define HV_MESSAGE_UNRECOVERABLE_EXCEPTION    0x80000021
#define HV_MESSAGE_UNSUPPORTED_FEATURE        0x80000022
#define HV_MESSAGE_EVENTLOG_BUFFERCOMPLETE    0x80000040
#define HV_MESSAGE_X64_IOPORT_INTERCEPT       0x80010000
#define HV_MESSAGE_X64_MSR_INTERCEPT          0x80010001
#define HV_MESSAGE_X64_CPUID_INTERCEPT        0x80010002
#define HV_MESSAGE_X64_EXCEPTION_INTERCEPT    0x80010003
#define HV_MESSAGE_X64_APIC_EOI               0x80010004
#define HV_MESSAGE_X64_LEGACY_FP_ERROR        0x80010005

/*
 * Message flags
 */
#define HV_MESSAGE_FLAG_PENDING               0x1

/*
 * Number of synthetic interrupts
 */
#define HV_SINT_COUNT                         16

/*
 * Event flags number per SINT
 */
#define HV_EVENT_FLAGS_COUNT                  (256 * 8)

/*
 * Connection id valid bits
 */
#define HV_CONNECTION_ID_MASK                 0x00ffffff

/*
 * Input structure for POST_MESSAGE hypercall
 */
struct hyperv_post_message_input {
    uint32_t connection_id;
    uint32_t _reserved;
    uint32_t message_type;
    uint32_t payload_size;
    uint8_t  payload[HV_MESSAGE_PAYLOAD_SIZE];
};

/*
 * Input structure for SIGNAL_EVENT hypercall
 */
struct hyperv_signal_event_input {
    uint32_t connection_id;
    uint16_t flag_number;
    uint16_t _reserved_zero;
};

/*
 * SynIC message structures
 */
struct hyperv_message_header {
    uint32_t message_type;
    uint8_t  payload_size;
    uint8_t  message_flags; /* HV_MESSAGE_FLAG_XX */
    uint8_t  _reserved[2];
    uint64_t sender;
};

struct hyperv_message {
    struct hyperv_message_header header;
    uint8_t payload[HV_MESSAGE_PAYLOAD_SIZE];
};

struct hyperv_message_page {
    struct hyperv_message slot[HV_SINT_COUNT];
};

/*
 * SynIC event flags structures
 */
struct hyperv_event_flags {
    DECLARE_BITMAP(flags, HV_EVENT_FLAGS_COUNT);
};

struct hyperv_event_flags_page {
    struct hyperv_event_flags slot[HV_SINT_COUNT];
};

#endif // MVISOR_HYPERV_HYPERCALL_H

```

`include/hyperv/hyperv.h`:

```h
/*
 * Definitions for Hyper-V guest/hypervisor interaction
 *
 * Copyright (c) 2017-2018 Virtuozzo International GmbH.
 *
 * This work is licensed under the terms of the GNU GPL, version 2 or later.
 * See the COPYING file in the top-level directory.
 */

#ifndef MVISOR_HYPERV_H
#define MVISOR_HYPERV_H

#include "hypercall.h"

#define HV_CPUID_VENDOR_AND_MAX_FUNCTIONS     0x40000000
#define HV_CPUID_INTERFACE                    0x40000001
#define HV_CPUID_VERSION                      0x40000002
#define HV_CPUID_FEATURES                     0x40000003
#define HV_CPUID_ENLIGHTMENT_INFO             0x40000004
#define HV_CPUID_IMPLEMENT_LIMITS             0x40000005
#define HV_CPUID_NESTED_FEATURES              0x4000000A
#define HV_CPUID_MIN                          0x40000005
#define HV_CPUID_MAX                          0x4000ffff
#define HV_HYPERVISOR_PRESENT_BIT             0x80000000

/*
 * HV_CPUID_FEATURES.EAX bits
 */
#define HV_VP_RUNTIME_AVAILABLE      (1u << 0)
#define HV_TIME_REF_COUNT_AVAILABLE  (1u << 1)
#define HV_SYNIC_AVAILABLE           (1u << 2)
#define HV_SYNTIMERS_AVAILABLE       (1u << 3)
#define HV_APIC_ACCESS_AVAILABLE     (1u << 4)
#define HV_HYPERCALL_AVAILABLE       (1u << 5)
#define HV_VP_INDEX_AVAILABLE        (1u << 6)
#define HV_RESET_AVAILABLE           (1u << 7)
#define HV_REFERENCE_TSC_AVAILABLE   (1u << 9)
#define HV_ACCESS_FREQUENCY_MSRS     (1u << 11)
#define HV_ACCESS_REENLIGHTENMENTS_CONTROL  (1u << 13)

/*
 * HV_CPUID_FEATURES.EBX bits
 */
#define HV_POST_MESSAGES             (1u << 4)
#define HV_SIGNAL_EVENTS             (1u << 5)

/*
 * HV_CPUID_FEATURES.EDX bits
 */
#define HV_MWAIT_AVAILABLE                      (1u << 0)
#define HV_GUEST_DEBUGGING_AVAILABLE            (1u << 1)
#define HV_PERF_MONITOR_AVAILABLE               (1u << 2)
#define HV_CPU_DYNAMIC_PARTITIONING_AVAILABLE   (1u << 3)
#define HV_HYPERCALL_PARAMS_XMM_AVAILABLE       (1u << 4)
#define HV_GUEST_IDLE_STATE_AVAILABLE           (1u << 5)
#define HV_FREQUENCY_MSRS_AVAILABLE             (1u << 8)
#define HV_GUEST_CRASH_MSR_AVAILABLE            (1u << 10)
#define HV_STIMER_DIRECT_MODE_AVAILABLE         (1u << 19)

/*
 * HV_CPUID_ENLIGHTMENT_INFO.EAX bits
 */
#define HV_AS_SWITCH_RECOMMENDED            (1u << 0)
#define HV_LOCAL_TLB_FLUSH_RECOMMENDED      (1u << 1)
#define HV_REMOTE_TLB_FLUSH_RECOMMENDED     (1u << 2)
#define HV_APIC_ACCESS_RECOMMENDED          (1u << 3)
#define HV_SYSTEM_RESET_RECOMMENDED         (1u << 4)
#define HV_RELAXED_TIMING_RECOMMENDED       (1u << 5)
#define HV_DEPRECATING_AEOI_RECOMMENDED     (1u << 9)
#define HV_CLUSTER_IPI_RECOMMENDED          (1u << 10)
#define HV_EX_PROCESSOR_MASKS_RECOMMENDED   (1u << 11)
#define HV_ENLIGHTENED_VMCS_RECOMMENDED     (1u << 14)
#define HV_NO_NONARCH_CORESHARING           (1u << 18)

/*
 * Basic virtualized MSRs
 */
#define HV_X64_MSR_GUEST_OS_ID                0x40000000
#define HV_X64_MSR_HYPERCALL                  0x40000001
#define HV_X64_MSR_VP_INDEX                   0x40000002
#define HV_X64_MSR_RESET                      0x40000003
#define HV_X64_MSR_VP_RUNTIME                 0x40000010
#define HV_X64_MSR_TIME_REF_COUNT             0x40000020
#define HV_X64_MSR_REFERENCE_TSC              0x40000021
#define HV_X64_MSR_TSC_FREQUENCY              0x40000022
#define HV_X64_MSR_APIC_FREQUENCY             0x40000023

/*
 * Virtual APIC MSRs
 */
#define HV_X64_MSR_EOI                        0x40000070
#define HV_X64_MSR_ICR                        0x40000071
#define HV_X64_MSR_TPR                        0x40000072
#define HV_X64_MSR_APIC_ASSIST_PAGE           0x40000073

/*
 * Synthetic interrupt controller MSRs
 */
#define HV_X64_MSR_SCONTROL                   0x40000080
#define HV_X64_MSR_SVERSION                   0x40000081
#define HV_X64_MSR_SIEFP                      0x40000082
#define HV_X64_MSR_SIMP                       0x40000083
#define HV_X64_MSR_EOM                        0x40000084
#define HV_X64_MSR_SINT0                      0x40000090
#define HV_X64_MSR_SINT1                      0x40000091
#define HV_X64_MSR_SINT2                      0x40000092
#define HV_X64_MSR_SINT3                      0x40000093
#define HV_X64_MSR_SINT4                      0x40000094
#define HV_X64_MSR_SINT5                      0x40000095
#define HV_X64_MSR_SINT6                      0x40000096
#define HV_X64_MSR_SINT7                      0x40000097
#define HV_X64_MSR_SINT8                      0x40000098
#define HV_X64_MSR_SINT9                      0x40000099
#define HV_X64_MSR_SINT10                     0x4000009A
#define HV_X64_MSR_SINT11                     0x4000009B
#define HV_X64_MSR_SINT12                     0x4000009C
#define HV_X64_MSR_SINT13                     0x4000009D
#define HV_X64_MSR_SINT14                     0x4000009E
#define HV_X64_MSR_SINT15                     0x4000009F

/*
 * Synthetic timer MSRs
 */
#define HV_X64_MSR_STIMER0_CONFIG               0x400000B0
#define HV_X64_MSR_STIMER0_COUNT                0x400000B1
#define HV_X64_MSR_STIMER1_CONFIG               0x400000B2
#define HV_X64_MSR_STIMER1_COUNT                0x400000B3
#define HV_X64_MSR_STIMER2_CONFIG               0x400000B4
#define HV_X64_MSR_STIMER2_COUNT                0x400000B5
#define HV_X64_MSR_STIMER3_CONFIG               0x400000B6
#define HV_X64_MSR_STIMER3_COUNT                0x400000B7

/*
 * Guest crash notification MSRs
 */
#define HV_X64_MSR_CRASH_P0                     0x40000100
#define HV_X64_MSR_CRASH_P1                     0x40000101
#define HV_X64_MSR_CRASH_P2                     0x40000102
#define HV_X64_MSR_CRASH_P3                     0x40000103
#define HV_X64_MSR_CRASH_P4                     0x40000104
#define HV_CRASH_PARAMS    (HV_X64_MSR_CRASH_P4 - HV_X64_MSR_CRASH_P0 + 1)
#define HV_X64_MSR_CRASH_CTL                    0x40000105
#define HV_CRASH_CTL_NOTIFY                     (1ull << 63)

/*
 * Reenlightenment notification MSRs
 */
#define HV_X64_MSR_REENLIGHTENMENT_CONTROL      0x40000106
#define HV_REENLIGHTENMENT_ENABLE_BIT           (1u << 16)
#define HV_X64_MSR_TSC_EMULATION_CONTROL        0x40000107
#define HV_X64_MSR_TSC_EMULATION_STATUS         0x40000108

/*
 * Hypercall MSR bits
 */
#define HV_HYPERCALL_ENABLE                   (1u << 0)

/*
 * Synthetic interrupt controller definitions
 */
#define HV_SYNIC_VERSION                      1
#define HV_SYNIC_ENABLE                       (1u << 0)
#define HV_SIMP_ENABLE                        (1u << 0)
#define HV_SIEFP_ENABLE                       (1u << 0)
#define HV_SINT_MASKED                        (1u << 16)
#define HV_SINT_AUTO_EOI                      (1u << 17)
#define HV_SINT_VECTOR_MASK                   0xff

#define HV_STIMER_COUNT                       4

#endif // MVISOR_HYPERV_H

```

`include/io_thread.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/* 
 * MVisor Threading Model
 * Every device object is event-driven, so locks are not necessary, except
 * you are coding an interface method which should be called by a UI thread.
 */

#ifndef _MVISOR_IO_THREAD_H
#define _MVISOR_IO_THREAD_H

#include <sys/socket.h>
#include <sys/epoll.h>

#include <deque>
#include <set>
#include <list>
#include <unordered_map>
#include <thread>
#include <functional>
#include <chrono>
#include <mutex>
#include <queue>

#include "migration.h"
#include "image.pb.h"

typedef std::function<void()> VoidCallback;
typedef std::function<void(long)> IoCallback;
typedef std::chrono::steady_clock::time_point IoTimePoint;

#define NS_PER_SECOND (1000000000LL)

class Device;
struct IoTimer {
  bool          permanent;
  int64_t       interval_ns;
  IoTimePoint   next_timepoint;
  VoidCallback  callback;
  bool          removed;
  Device*       device;
};

struct EpollEvent {
  int           fd;
  IoCallback    callback;
  epoll_event   event;
  Device*       device;
};

class Machine;
class DiskImage;
class Qcow2Image;
class MigrationWriter;
class IoThread {
 public:
  IoThread(Machine* machine);
  ~IoThread();
  void Start();
  void Stop();
  void Kick();
  bool IsCurrentThread();

  /* Async event polling */
  EpollEvent* StartPolling(Device* device, int fd, uint poll_mask, IoCallback callback);
  void StopPolling(int fd);

  /* Timer events handled by IO thread */
  IoTimer* AddTimer(Device* device, int64_t interval_ns, bool permanent, VoidCallback callback);
  void RemoveTimer(IoTimer* timer);
  void ModifyTimer(IoTimer* timer, int64_t interval_ns);
  void Schedule(Device* device, VoidCallback callback);

  /* Disk images */
  void RegisterDiskImage(DiskImage* image);
  void UnregisterDiskImage(DiskImage* image);
  void FlushDiskImages();
  bool SaveDiskImage(MigrationWriter* writer);
  bool LoadDiskImage(MigrationNetworkReader* reader);
  bool SaveBackingDiskImage(MigrationNetworkWriter* writer);
  bool LoadBackingDiskImage(MigrationNetworkReader* reader);
  bool CreateQcow2ImageSnapshot();
  uint GetDiskImageCount() { return disk_images_.size(); }

 private:
  void    RunLoop();
  int64_t CheckTimers();
  bool    CanPauseNow();

  std::thread           thread_;
  Machine*              machine_;
  std::recursive_mutex  mutex_;
  int                   event_fd_;
  int                   epoll_fd_;
  std::list<IoTimer*>   timers_;
  std::list<DiskImage*>  disk_images_;
  std::unordered_map<Qcow2Image*, std::queue<std::string>> qcow2_image_backing_files_;
  std::unordered_map<int, EpollEvent*>  epoll_events_;
};

#endif // _MVISOR_IO_THREAD_H

```

`include/linuz/kvm_para.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _ASM_X86_KVM_PARA_H
#define _ASM_X86_KVM_PARA_H

#include <linux/types.h>

/* This CPUID returns the signature 'KVMKVMKVM' in ebx, ecx, and edx.  It
 * should be used to determine that a VM is running under KVM.
 */
#define KVM_CPUID_SIGNATURE	0x40000000

/* This CPUID returns two feature bitmaps in eax, edx. Before enabling
 * a particular paravirtualization, the appropriate feature bit should
 * be checked in eax. The performance hint feature bit should be checked
 * in edx.
 */
#define KVM_CPUID_FEATURES	0x40000001
#define KVM_FEATURE_CLOCKSOURCE		0
#define KVM_FEATURE_NOP_IO_DELAY	1
#define KVM_FEATURE_MMU_OP		2
/* This indicates that the new set of kvmclock msrs
 * are available. The use of 0x11 and 0x12 is deprecated
 */
#define KVM_FEATURE_CLOCKSOURCE2        3
#define KVM_FEATURE_ASYNC_PF		4
#define KVM_FEATURE_STEAL_TIME		5
#define KVM_FEATURE_PV_EOI		6
#define KVM_FEATURE_PV_UNHALT		7
#define KVM_FEATURE_PV_TLB_FLUSH	9
#define KVM_FEATURE_ASYNC_PF_VMEXIT	10
#define KVM_FEATURE_PV_SEND_IPI	11
#define KVM_FEATURE_POLL_CONTROL	12
#define KVM_FEATURE_PV_SCHED_YIELD	13
#define KVM_FEATURE_ASYNC_PF_INT	14
#define KVM_FEATURE_MSI_EXT_DEST_ID	15
#define KVM_FEATURE_HC_MAP_GPA_RANGE	16
#define KVM_FEATURE_MIGRATION_CONTROL	17

#define KVM_HINTS_REALTIME      0

/* The last 8 bits are used to indicate how to interpret the flags field
 * in pvclock structure. If no bits are set, all flags are ignored.
 */
#define KVM_FEATURE_CLOCKSOURCE_STABLE_BIT	24

#define MSR_KVM_WALL_CLOCK  0x11
#define MSR_KVM_SYSTEM_TIME 0x12

#define KVM_MSR_ENABLED 1
/* Custom MSRs falls in the range 0x4b564d00-0x4b564dff */
#define MSR_KVM_WALL_CLOCK_NEW  0x4b564d00
#define MSR_KVM_SYSTEM_TIME_NEW 0x4b564d01
#define MSR_KVM_ASYNC_PF_EN 0x4b564d02
#define MSR_KVM_STEAL_TIME  0x4b564d03
#define MSR_KVM_PV_EOI_EN      0x4b564d04
#define MSR_KVM_POLL_CONTROL	0x4b564d05
#define MSR_KVM_ASYNC_PF_INT	0x4b564d06
#define MSR_KVM_ASYNC_PF_ACK	0x4b564d07
#define MSR_KVM_MIGRATION_CONTROL	0x4b564d08

struct kvm_steal_time {
	uint64_t steal;
	uint32_t version;
	uint32_t flags;
	uint8_t  preempted;
	uint8_t  uint8_t_pad[3];
	uint32_t pad[11];
};

#define KVM_VCPU_PREEMPTED          (1 << 0)
#define KVM_VCPU_FLUSH_TLB          (1 << 1)

#define KVM_CLOCK_PAIRING_WALLCLOCK 0
struct kvm_clock_pairing {
	int64_t sec;
	int64_t nsec;
	uint64_t tsc;
	uint32_t flags;
	uint32_t pad[9];
};

#define KVM_STEAL_ALIGNMENT_BITS 5
#define KVM_STEAL_VALID_BITS ((-1ULL << (KVM_STEAL_ALIGNMENT_BITS + 1)))
#define KVM_STEAL_RESERVED_MASK (((1 << KVM_STEAL_ALIGNMENT_BITS) - 1 ) << 1)

#define KVM_MAX_MMU_OP_BATCH           32

#define KVM_ASYNC_PF_ENABLED			(1 << 0)
#define KVM_ASYNC_PF_SEND_ALWAYS		(1 << 1)
#define KVM_ASYNC_PF_DELIVERY_AS_PF_VMEXIT	(1 << 2)
#define KVM_ASYNC_PF_DELIVERY_AS_INT		(1 << 3)

/* MSR_KVM_ASYNC_PF_INT */
#define KVM_ASYNC_PF_VEC_MASK			GENMASK(7, 0)

/* MSR_KVM_MIGRATION_CONTROL */
#define KVM_MIGRATION_READY		(1 << 0)

/* KVM_HC_MAP_GPA_RANGE */
#define KVM_MAP_GPA_RANGE_PAGE_SZ_4K	0
#define KVM_MAP_GPA_RANGE_PAGE_SZ_2M	(1 << 0)
#define KVM_MAP_GPA_RANGE_PAGE_SZ_1G	(1 << 1)
#define KVM_MAP_GPA_RANGE_ENC_STAT(n)	(n << 4)
#define KVM_MAP_GPA_RANGE_ENCRYPTED	KVM_MAP_GPA_RANGE_ENC_STAT(1)
#define KVM_MAP_GPA_RANGE_DECRYPTED	KVM_MAP_GPA_RANGE_ENC_STAT(0)

/* Operations for KVM_HC_MMU_OP */
#define KVM_MMU_OP_WRITE_PTE            1
#define KVM_MMU_OP_FLUSH_TLB	        2
#define KVM_MMU_OP_RELEASE_PT	        3

/* Payload for KVM_HC_MMU_OP */
struct kvm_mmu_op_header {
	uint32_t op;
	uint32_t pad;
};

struct kvm_mmu_op_write_pte {
	struct kvm_mmu_op_header header;
	uint64_t pte_phys;
	uint64_t pte_val;
};

struct kvm_mmu_op_flush_tlb {
	struct kvm_mmu_op_header header;
};

struct kvm_mmu_op_release_pt {
	struct kvm_mmu_op_header header;
	uint64_t pt_phys;
};

#define KVM_PV_REASON_PAGE_NOT_PRESENT 1
#define KVM_PV_REASON_PAGE_READY 2

struct kvm_vcpu_pv_apf_data {
	/* Used for 'page not present' events delivered via #PF */
	uint32_t flags;

	/* Used for 'page ready' events delivered via interrupt notification */
	uint32_t token;

	uint8_t pad[56];
	uint32_t enabled;
};

#define KVM_PV_EOI_BIT 0
#define KVM_PV_EOI_MASK (0x1 << KVM_PV_EOI_BIT)
#define KVM_PV_EOI_ENABLED KVM_PV_EOI_MASK
#define KVM_PV_EOI_DISABLED 0x0

#endif /* _ASM_X86_KVM_PARA_H */

```

`include/linuz/vfio.h`:

```h
/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
/*
 * VFIO API definition
 *
 * Copyright (C) 2012 Red Hat, Inc.  All rights reserved.
 *     Author: Alex Williamson <alex.williamson@redhat.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#ifndef _UAPIVFIO_H
#define _UAPIVFIO_H

#include <linux/types.h>
#include <linux/ioctl.h>

#define VFIO_API_VERSION           0


/* Kernel & User level defines for VFIO IOCTLs. */

/* Extensions */

#define VFIO_TYPE1_IOMMU           1
#define VFIO_SPAPR_TCE_IOMMU       2
#define VFIO_TYPE1v2_IOMMU         3
/*
 * IOMMU enforces DMA cache coherence (ex. PCIe NoSnoop stripping).  This
 * capability is subject to change as groups are added or removed.
 */
#define VFIO_DMA_CC_IOMMU          4

/* Check if EEH is supported */
#define VFIO_EEH                   5

/* Two-stage IOMMU */
#define VFIO_TYPE1_NESTING_IOMMU   6  /* Implies v2 */

#define VFIO_SPAPR_TCE_v2_IOMMU    7

/*
 * The No-IOMMU IOMMU offers no translation or isolation for devices and
 * supports no ioctls outside of VFIO_CHECK_EXTENSION.  Use of VFIO's No-IOMMU
 * code will taint the host kernel and should be used with extreme caution.
 */
#define VFIO_NOIOMMU_IOMMU         8

/*
 * The IOCTL interface is designed for extensibility by embedding the
 * structure length (argsz) and flags into structures passed between
 * kernel and userspace.  We therefore use the _IO() macro for these
 * defines to avoid implicitly embedding a size into the ioctl request.
 * As structure fields are added, argsz will increase to match and flag
 * bits will be defined to indicate additional fields with valid data.
 * It's *always* the caller's responsibility to indicate the size of
 * the structure passed by setting argsz appropriately.
 */

#define VFIO_TYPE  (';')
#define VFIO_BASE  100

/*
 * For extension of INFO ioctls, VFIO makes use of a capability chain
 * designed after PCI/e capabilities.  A flag bit indicates whether
 * this capability chain is supported and a field defined in the fixed
 * structure defines the offset of the first capability in the chain.
 * This field is only valid when the corresponding bit in the flags
 * bitmap is set.  This offset field is relative to the start of the
 * INFO buffer, as is the next field within each capability header.
 * The id within the header is a shared address space per INFO ioctl,
 * while the version field is specific to the capability id.  The
 * contents following the header are specific to the capability id.
 */
struct vfio_info_cap_header {
  __u16  id;    /* Identifies capability */
  __u16  version;  /* Version specific to the capability ID */
  __u32  next;    /* Offset of next capability */
};

/*
 * Callers of INFO ioctls passing insufficiently sized buffers will see
 * the capability chain flag bit set, a zero value for the first capability
 * offset (if available within the provided argsz), and argsz will be
 * updated to report the necessary buffer size.  For compatibility, the
 * INFO ioctl will not report error in this case, but the capability chain
 * will not be available.
 */

/* -------- IOCTLs for VFIO file descriptor (/dev/vfio/vfio) -------- */

/**
 * VFIO_GET_API_VERSION - _IO(VFIO_TYPE, VFIO_BASE + 0)
 *
 * Report the version of the VFIO API.  This allows us to bump the entire
 * API version should we later need to add or change features in incompatible
 * ways.
 * Return: VFIO_API_VERSION
 * Availability: Always
 */
#define VFIO_GET_API_VERSION    _IO(VFIO_TYPE, VFIO_BASE + 0)

/**
 * VFIO_CHECK_EXTENSION - _IOW(VFIO_TYPE, VFIO_BASE + 1, __u32)
 *
 * Check whether an extension is supported.
 * Return: 0 if not supported, 1 (or some other positive integer) if supported.
 * Availability: Always
 */
#define VFIO_CHECK_EXTENSION    _IO(VFIO_TYPE, VFIO_BASE + 1)

/**
 * VFIO_SET_IOMMU - _IOW(VFIO_TYPE, VFIO_BASE + 2, __s32)
 *
 * Set the iommu to the given type.  The type must be supported by an
 * iommu driver as verified by calling CHECK_EXTENSION using the same
 * type.  A group must be set to this file descriptor before this
 * ioctl is available.  The IOMMU interfaces enabled by this call are
 * specific to the value set.
 * Return: 0 on success, -errno on failure
 * Availability: When VFIO group attached
 */
#define VFIO_SET_IOMMU      _IO(VFIO_TYPE, VFIO_BASE + 2)

/* -------- IOCTLs for GROUP file descriptors (/dev/vfio/$GROUP) -------- */

/**
 * VFIO_GROUP_GET_STATUS - _IOR(VFIO_TYPE, VFIO_BASE + 3,
 *            struct vfio_group_status)
 *
 * Retrieve information about the group.  Fills in provided
 * struct vfio_group_info.  Caller sets argsz.
 * Return: 0 on succes, -errno on failure.
 * Availability: Always
 */
struct vfio_group_status {
  __u32  argsz;
  __u32  flags;
#define VFIO_GROUP_FLAGS_VIABLE    (1 << 0)
#define VFIO_GROUP_FLAGS_CONTAINER_SET  (1 << 1)
};
#define VFIO_GROUP_GET_STATUS    _IO(VFIO_TYPE, VFIO_BASE + 3)

/**
 * VFIO_GROUP_SET_CONTAINER - _IOW(VFIO_TYPE, VFIO_BASE + 4, __s32)
 *
 * Set the container for the VFIO group to the open VFIO file
 * descriptor provided.  Groups may only belong to a single
 * container.  Containers may, at their discretion, support multiple
 * groups.  Only when a container is set are all of the interfaces
 * of the VFIO file descriptor and the VFIO group file descriptor
 * available to the user.
 * Return: 0 on success, -errno on failure.
 * Availability: Always
 */
#define VFIO_GROUP_SET_CONTAINER  _IO(VFIO_TYPE, VFIO_BASE + 4)

/**
 * VFIO_GROUP_UNSET_CONTAINER - _IO(VFIO_TYPE, VFIO_BASE + 5)
 *
 * Remove the group from the attached container.  This is the
 * opposite of the SET_CONTAINER call and returns the group to
 * an initial state.  All device file descriptors must be released
 * prior to calling this interface.  When removing the last group
 * from a container, the IOMMU will be disabled and all state lost,
 * effectively also returning the VFIO file descriptor to an initial
 * state.
 * Return: 0 on success, -errno on failure.
 * Availability: When attached to container
 */
#define VFIO_GROUP_UNSET_CONTAINER  _IO(VFIO_TYPE, VFIO_BASE + 5)

/**
 * VFIO_GROUP_GET_DEVICE_FD - _IOW(VFIO_TYPE, VFIO_BASE + 6, char)
 *
 * Return a new file descriptor for the device object described by
 * the provided string.  The string should match a device listed in
 * the devices subdirectory of the IOMMU group sysfs entry.  The
 * group containing the device must already be added to this context.
 * Return: new file descriptor on success, -errno on failure.
 * Availability: When attached to container
 */
#define VFIO_GROUP_GET_DEVICE_FD  _IO(VFIO_TYPE, VFIO_BASE + 6)

/* --------------- IOCTLs for DEVICE file descriptors --------------- */

/**
 * VFIO_DEVICE_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 7,
 *            struct vfio_device_info)
 *
 * Retrieve information about the device.  Fills in provided
 * struct vfio_device_info.  Caller sets argsz.
 * Return: 0 on success, -errno on failure.
 */
struct vfio_device_info {
  __u32  argsz;
  __u32  flags;
#define VFIO_DEVICE_FLAGS_RESET  (1 << 0)  /* Device supports reset */
#define VFIO_DEVICE_FLAGS_PCI  (1 << 1)  /* vfio-pci device */
#define VFIO_DEVICE_FLAGS_PLATFORM (1 << 2)  /* vfio-platform device */
#define VFIO_DEVICE_FLAGS_AMBA  (1 << 3)  /* vfio-amba device */
#define VFIO_DEVICE_FLAGS_CCW  (1 << 4)  /* vfio-ccw device */
#define VFIO_DEVICE_FLAGS_AP  (1 << 5)  /* vfio-ap device */
  __u32  num_regions;  /* Max region index + 1 */
  __u32  num_irqs;  /* Max IRQ index + 1 */
};
#define VFIO_DEVICE_GET_INFO    _IO(VFIO_TYPE, VFIO_BASE + 7)

/*
 * Vendor driver using Mediated device framework should provide device_api
 * attribute in supported type attribute groups. Device API string should be one
 * of the following corresponding to device flags in vfio_device_info structure.
 */

#define VFIO_DEVICE_API_PCI_STRING    "vfio-pci"
#define VFIO_DEVICE_API_PLATFORM_STRING    "vfio-platform"
#define VFIO_DEVICE_API_AMBA_STRING    "vfio-amba"
#define VFIO_DEVICE_API_CCW_STRING    "vfio-ccw"
#define VFIO_DEVICE_API_AP_STRING    "vfio-ap"

/**
 * VFIO_DEVICE_GET_REGION_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 8,
 *               struct vfio_region_info)
 *
 * Retrieve information about a device region.  Caller provides
 * struct vfio_region_info with index value set.  Caller sets argsz.
 * Implementation of region mapping is bus driver specific.  This is
 * intended to describe MMIO, I/O port, as well as bus specific
 * regions (ex. PCI config space).  Zero sized regions may be used
 * to describe unimplemented regions (ex. unimplemented PCI BARs).
 * Return: 0 on success, -errno on failure.
 */
struct vfio_region_info {
  __u32  argsz;
  __u32  flags;
#define VFIO_REGION_INFO_FLAG_READ  (1 << 0) /* Region supports read */
#define VFIO_REGION_INFO_FLAG_WRITE  (1 << 1) /* Region supports write */
#define VFIO_REGION_INFO_FLAG_MMAP  (1 << 2) /* Region supports mmap */
#define VFIO_REGION_INFO_FLAG_CAPS  (1 << 3) /* Info supports caps */
  __u32  index;    /* Region index */
  __u32  cap_offset;  /* Offset within info struct of first cap */
  __u64  size;    /* Region size (bytes) */
  __u64  offset;    /* Region offset from start of device fd */
};
#define VFIO_DEVICE_GET_REGION_INFO  _IO(VFIO_TYPE, VFIO_BASE + 8)

/*
 * The sparse mmap capability allows finer granularity of specifying areas
 * within a region with mmap support.  When specified, the user should only
 * mmap the offset ranges specified by the areas array.  mmaps outside of the
 * areas specified may fail (such as the range covering a PCI MSI-X table) or
 * may result in improper device behavior.
 *
 * The structures below define version 1 of this capability.
 */
#define VFIO_REGION_INFO_CAP_SPARSE_MMAP  1

struct vfio_region_sparse_mmap_area {
  __u64  offset;  /* Offset of mmap'able area within region */
  __u64  size;  /* Size of mmap'able area */
};

struct vfio_region_info_cap_sparse_mmap {
  struct vfio_info_cap_header header;
  __u32  nr_areas;
  __u32  reserved;
  struct vfio_region_sparse_mmap_area areas[];
};

/*
 * The device specific type capability allows regions unique to a specific
 * device or class of devices to be exposed.  This helps solve the problem for
 * vfio bus drivers of defining which region indexes correspond to which region
 * on the device, without needing to resort to static indexes, as done by
 * vfio-pci.  For instance, if we were to go back in time, we might remove
 * VFIO_PCI_VGA_REGION_INDEX and let vfio-pci simply define that all indexes
 * greater than or equal to VFIO_PCI_NUM_REGIONS are device specific and we'd
 * make a "VGA" device specific type to describe the VGA access space.  This
 * means that non-VGA devices wouldn't need to waste this index, and thus the
 * address space associated with it due to implementation of device file
 * descriptor offsets in vfio-pci.
 *
 * The current implementation is now part of the user ABI, so we can't use this
 * for VGA, but there are other upcoming use cases, such as opregions for Intel
 * IGD devices and framebuffers for vGPU devices.  We missed VGA, but we'll
 * use this for future additions.
 *
 * The structure below defines version 1 of this capability.
 */
#define VFIO_REGION_INFO_CAP_TYPE  2

struct vfio_region_info_cap_type {
  struct vfio_info_cap_header header;
  __u32 type;  /* global per bus driver */
  __u32 subtype;  /* type specific */
};

/*
 * List of region types, global per bus driver.
 * If you introduce a new type, please add it here.
 */

/* PCI region type containing a PCI vendor part */
#define VFIO_REGION_TYPE_PCI_VENDOR_TYPE  (1 << 31)
#define VFIO_REGION_TYPE_PCI_VENDOR_MASK  (0xffff)
#define VFIO_REGION_TYPE_GFX                    (1)
#define VFIO_REGION_TYPE_CCW      (2)
#define VFIO_REGION_TYPE_MIGRATION              (3)

/* sub-types for VFIO_REGION_TYPE_PCI_* */

/* 8086 vendor PCI sub-types */
#define VFIO_REGION_SUBTYPE_INTEL_IGD_OPREGION  (1)
#define VFIO_REGION_SUBTYPE_INTEL_IGD_HOST_CFG  (2)
#define VFIO_REGION_SUBTYPE_INTEL_IGD_LPC_CFG  (3)

/* 10de vendor PCI sub-types */
/*
 * NVIDIA GPU NVlink2 RAM is coherent RAM mapped onto the host address space.
 */
#define VFIO_REGION_SUBTYPE_NVIDIA_NVLINK2_RAM  (1)

/* 1014 vendor PCI sub-types */
/*
 * IBM NPU NVlink2 ATSD (Address Translation Shootdown) register of NPU
 * to do TLB invalidation on a GPU.
 */
#define VFIO_REGION_SUBTYPE_IBM_NVLINK2_ATSD  (1)

/* sub-types for VFIO_REGION_TYPE_GFX */
#define VFIO_REGION_SUBTYPE_GFX_EDID            (1)

/**
 * struct vfio_region_gfx_edid - EDID region layout.
 *
 * Set display link state and EDID blob.
 *
 * The EDID blob has monitor information such as brand, name, serial
 * number, physical size, supported video modes and more.
 *
 * This special region allows userspace (typically qemu) set a virtual
 * EDID for the virtual monitor, which allows a flexible display
 * configuration.
 *
 * For the edid blob spec look here:
 *    https://en.wikipedia.org/wiki/Extended_Display_Identification_Data
 *
 * On linux systems you can find the EDID blob in sysfs:
 *    /sys/class/drm/${card}/${connector}/edid
 *
 * You can use the edid-decode ulility (comes with xorg-x11-utils) to
 * decode the EDID blob.
 *
 * @edid_offset: location of the edid blob, relative to the
 *               start of the region (readonly).
 * @edid_max_size: max size of the edid blob (readonly).
 * @edid_size: actual edid size (read/write).
 * @link_state: display link state (read/write).
 * VFIO_DEVICE_GFX_LINK_STATE_UP: Monitor is turned on.
 * VFIO_DEVICE_GFX_LINK_STATE_DOWN: Monitor is turned off.
 * @max_xres: max display width (0 == no limitation, readonly).
 * @max_yres: max display height (0 == no limitation, readonly).
 *
 * EDID update protocol:
 *   (1) set link-state to down.
 *   (2) update edid blob and size.
 *   (3) set link-state to up.
 */
struct vfio_region_gfx_edid {
  __u32 edid_offset;
  __u32 edid_max_size;
  __u32 edid_size;
  __u32 max_xres;
  __u32 max_yres;
  __u32 link_state;
#define VFIO_DEVICE_GFX_LINK_STATE_UP    1
#define VFIO_DEVICE_GFX_LINK_STATE_DOWN  2
};

/* sub-types for VFIO_REGION_TYPE_CCW */
#define VFIO_REGION_SUBTYPE_CCW_ASYNC_CMD  (1)
#define VFIO_REGION_SUBTYPE_CCW_SCHIB    (2)
#define VFIO_REGION_SUBTYPE_CCW_CRW    (3)

/* sub-types for VFIO_REGION_TYPE_MIGRATION */
#define VFIO_REGION_SUBTYPE_MIGRATION           (1)

/*
 * The structure vfio_device_migration_info is placed at the 0th offset of
 * the VFIO_REGION_SUBTYPE_MIGRATION region to get and set VFIO device related
 * migration information. Field accesses from this structure are only supported
 * at their native width and alignment. Otherwise, the result is undefined and
 * vendor drivers should return an error.
 *
 * device_state: (read/write)
 *      - The user application writes to this field to inform the vendor driver
 *        about the device state to be transitioned to.
 *      - The vendor driver should take the necessary actions to change the
 *        device state. After successful transition to a given state, the
 *        vendor driver should return success on write(device_state, state)
 *        system call. If the device state transition fails, the vendor driver
 *        should return an appropriate -errno for the fault condition.
 *      - On the user application side, if the device state transition fails,
 *    that is, if write(device_state, state) returns an error, read
 *    device_state again to determine the current state of the device from
 *    the vendor driver.
 *      - The vendor driver should return previous state of the device unless
 *        the vendor driver has encountered an internal error, in which case
 *        the vendor driver may report the device_state VFIO_DEVICE_STATE_ERROR.
 *      - The user application must use the device reset ioctl to recover the
 *        device from VFIO_DEVICE_STATE_ERROR state. If the device is
 *        indicated to be in a valid device state by reading device_state, the
 *        user application may attempt to transition the device to any valid
 *        state reachable from the current state or terminate itself.
 *
 *      device_state consists of 3 bits:
 *      - If bit 0 is set, it indicates the _RUNNING state. If bit 0 is clear,
 *        it indicates the _STOP state. When the device state is changed to
 *        _STOP, driver should stop the device before write() returns.
 *      - If bit 1 is set, it indicates the _SAVING state, which means that the
 *        driver should start gathering device state information that will be
 *        provided to the VFIO user application to save the device's state.
 *      - If bit 2 is set, it indicates the _RESUMING state, which means that
 *        the driver should prepare to resume the device. Data provided through
 *        the migration region should be used to resume the device.
 *      Bits 3 - 31 are reserved for future use. To preserve them, the user
 *      application should perform a read-modify-write operation on this
 *      field when modifying the specified bits.
 *
 *  +------- _RESUMING
 *  |+------ _SAVING
 *  ||+----- _RUNNING
 *  |||
 *  000b => Device Stopped, not saving or resuming
 *  001b => Device running, which is the default state
 *  010b => Stop the device & save the device state, stop-and-copy state
 *  011b => Device running and save the device state, pre-copy state
 *  100b => Device stopped and the device state is resuming
 *  101b => Invalid state
 *  110b => Error state
 *  111b => Invalid state
 *
 * State transitions:
 *
 *              _RESUMING  _RUNNING    Pre-copy    Stop-and-copy   _STOP
 *                (100b)     (001b)     (011b)        (010b)       (000b)
 * 0. Running or default state
 *                             |
 *
 * 1. Normal Shutdown (optional)
 *                             |------------------------------------->|
 *
 * 2. Save the state or suspend
 *                             |------------------------->|---------->|
 *
 * 3. Save the state during live migration
 *                             |----------->|------------>|---------->|
 *
 * 4. Resuming
 *                  |<---------|
 *
 * 5. Resumed
 *                  |--------->|
 *
 * 0. Default state of VFIO device is _RUNNNG when the user application starts.
 * 1. During normal shutdown of the user application, the user application may
 *    optionally change the VFIO device state from _RUNNING to _STOP. This
 *    transition is optional. The vendor driver must support this transition but
 *    must not require it.
 * 2. When the user application saves state or suspends the application, the
 *    device state transitions from _RUNNING to stop-and-copy and then to _STOP.
 *    On state transition from _RUNNING to stop-and-copy, driver must stop the
 *    device, save the device state and send it to the application through the
 *    migration region. The sequence to be followed for such transition is given
 *    below.
 * 3. In live migration of user application, the state transitions from _RUNNING
 *    to pre-copy, to stop-and-copy, and to _STOP.
 *    On state transition from _RUNNING to pre-copy, the driver should start
 *    gathering the device state while the application is still running and send
 *    the device state data to application through the migration region.
 *    On state transition from pre-copy to stop-and-copy, the driver must stop
 *    the device, save the device state and send it to the user application
 *    through the migration region.
 *    Vendor drivers must support the pre-copy state even for implementations
 *    where no data is provided to the user before the stop-and-copy state. The
 *    user must not be required to consume all migration data before the device
 *    transitions to a new state, including the stop-and-copy state.
 *    The sequence to be followed for above two transitions is given below.
 * 4. To start the resuming phase, the device state should be transitioned from
 *    the _RUNNING to the _RESUMING state.
 *    In the _RESUMING state, the driver should use the device state data
 *    received through the migration region to resume the device.
 * 5. After providing saved device data to the driver, the application should
 *    change the state from _RESUMING to _RUNNING.
 *
 * reserved:
 *      Reads on this field return zero and writes are ignored.
 *
 * pending_bytes: (read only)
 *      The number of pending bytes still to be migrated from the vendor driver.
 *
 * data_offset: (read only)
 *      The user application should read data_offset field from the migration
 *      region. The user application should read the device data from this
 *      offset within the migration region during the _SAVING state or write
 *      the device data during the _RESUMING state. See below for details of
 *      sequence to be followed.
 *
 * data_size: (read/write)
 *      The user application should read data_size to get the size in bytes of
 *      the data copied in the migration region during the _SAVING state and
 *      write the size in bytes of the data copied in the migration region
 *      during the _RESUMING state.
 *
 * The format of the migration region is as follows:
 *  ------------------------------------------------------------------
 * |vfio_device_migration_info|    data section                      |
 * |                          |     ///////////////////////////////  |
 * ------------------------------------------------------------------
 *   ^                              ^
 *  offset 0-trapped part        data_offset
 *
 * The structure vfio_device_migration_info is always followed by the data
 * section in the region, so data_offset will always be nonzero. The offset
 * from where the data is copied is decided by the kernel driver. The data
 * section can be trapped, mmapped, or partitioned, depending on how the kernel
 * driver defines the data section. The data section partition can be defined
 * as mapped by the sparse mmap capability. If mmapped, data_offset must be
 * page aligned, whereas initial section which contains the
 * vfio_device_migration_info structure, might not end at the offset, which is
 * page aligned. The user is not required to access through mmap regardless
 * of the capabilities of the region mmap.
 * The vendor driver should determine whether and how to partition the data
 * section. The vendor driver should return data_offset accordingly.
 *
 * The sequence to be followed while in pre-copy state and stop-and-copy state
 * is as follows:
 * a. Read pending_bytes, indicating the start of a new iteration to get device
 *    data. Repeated read on pending_bytes at this stage should have no side
 *    effects.
 *    If pending_bytes == 0, the user application should not iterate to get data
 *    for that device.
 *    If pending_bytes > 0, perform the following steps.
 * b. Read data_offset, indicating that the vendor driver should make data
 *    available through the data section. The vendor driver should return this
 *    read operation only after data is available from (region + data_offset)
 *    to (region + data_offset + data_size).
 * c. Read data_size, which is the amount of data in bytes available through
 *    the migration region.
 *    Read on data_offset and data_size should return the offset and size of
 *    the current buffer if the user application reads data_offset and
 *    data_size more than once here.
 * d. Read data_size bytes of data from (region + data_offset) from the
 *    migration region.
 * e. Process the data.
 * f. Read pending_bytes, which indicates that the data from the previous
 *    iteration has been read. If pending_bytes > 0, go to step b.
 *
 * The user application can transition from the _SAVING|_RUNNING
 * (pre-copy state) to the _SAVING (stop-and-copy) state regardless of the
 * number of pending bytes. The user application should iterate in _SAVING
 * (stop-and-copy) until pending_bytes is 0.
 *
 * The sequence to be followed while _RESUMING device state is as follows:
 * While data for this device is available, repeat the following steps:
 * a. Read data_offset from where the user application should write data.
 * b. Write migration data starting at the migration region + data_offset for
 *    the length determined by data_size from the migration source.
 * c. Write data_size, which indicates to the vendor driver that data is
 *    written in the migration region. Vendor driver must return this write
 *    operations on consuming data. Vendor driver should apply the
 *    user-provided migration region data to the device resume state.
 *
 * If an error occurs during the above sequences, the vendor driver can return
 * an error code for next read() or write() operation, which will terminate the
 * loop. The user application should then take the next necessary action, for
 * example, failing migration or terminating the user application.
 *
 * For the user application, data is opaque. The user application should write
 * data in the same order as the data is received and the data should be of
 * same transaction size at the source.
 */

struct vfio_device_migration_info {
  __u32 device_state;         /* VFIO device state */
#define VFIO_DEVICE_STATE_STOP      (0)
#define VFIO_DEVICE_STATE_RUNNING   (1 << 0)
#define VFIO_DEVICE_STATE_SAVING    (1 << 1)
#define VFIO_DEVICE_STATE_RESUMING  (1 << 2)
#define VFIO_DEVICE_STATE_MASK      (VFIO_DEVICE_STATE_RUNNING | \
             VFIO_DEVICE_STATE_SAVING |  \
             VFIO_DEVICE_STATE_RESUMING)

#define VFIO_DEVICE_STATE_VALID(state) \
  (state & VFIO_DEVICE_STATE_RESUMING ? \
  (state & VFIO_DEVICE_STATE_MASK) == VFIO_DEVICE_STATE_RESUMING : 1)

#define VFIO_DEVICE_STATE_IS_ERROR(state) \
  ((state & VFIO_DEVICE_STATE_MASK) == (VFIO_DEVICE_STATE_SAVING | \
                VFIO_DEVICE_STATE_RESUMING))

#define VFIO_DEVICE_STATE_SET_ERROR(state) \
  ((state & ~VFIO_DEVICE_STATE_MASK) | VFIO_DEVICE_SATE_SAVING | \
               VFIO_DEVICE_STATE_RESUMING)

  __u32 reserved;
  __u64 pending_bytes;
  __u64 data_offset;
  __u64 data_size;
  __u64 start_pfn;
  __u64 page_size;
  __u64 total_pfns;
  __u64 copied_pfns;
#define VFIO_DEVICE_DIRTY_PFNS_NONE     (0)
#define VFIO_DEVICE_DIRTY_PFNS_ALL      (~0ULL)
} __attribute__((packed));

/*
 * The MSIX mappable capability informs that MSIX data of a BAR can be mmapped
 * which allows direct access to non-MSIX registers which happened to be within
 * the same system page.
 *
 * Even though the userspace gets direct access to the MSIX data, the existing
 * VFIO_DEVICE_SET_IRQS interface must still be used for MSIX configuration.
 */
#define VFIO_REGION_INFO_CAP_MSIX_MAPPABLE  3

/*
 * Capability with compressed real address (aka SSA - small system address)
 * where GPU RAM is mapped on a system bus. Used by a GPU for DMA routing
 * and by the userspace to associate a NVLink bridge with a GPU.
 */
#define VFIO_REGION_INFO_CAP_NVLINK2_SSATGT  4

struct vfio_region_info_cap_nvlink2_ssatgt {
  struct vfio_info_cap_header header;
  __u64 tgt;
};

/*
 * Capability with an NVLink link speed. The value is read by
 * the NVlink2 bridge driver from the bridge's "ibm,nvlink-speed"
 * property in the device tree. The value is fixed in the hardware
 * and failing to provide the correct value results in the link
 * not working with no indication from the driver why.
 */
#define VFIO_REGION_INFO_CAP_NVLINK2_LNKSPD  5

struct vfio_region_info_cap_nvlink2_lnkspd {
  struct vfio_info_cap_header header;
  __u32 link_speed;
  __u32 __pad;
};

/**
 * VFIO_DEVICE_GET_IRQ_INFO - _IOWR(VFIO_TYPE, VFIO_BASE + 9,
 *            struct vfio_irq_info)
 *
 * Retrieve information about a device IRQ.  Caller provides
 * struct vfio_irq_info with index value set.  Caller sets argsz.
 * Implementation of IRQ mapping is bus driver specific.  Indexes
 * using multiple IRQs are primarily intended to support MSI-like
 * interrupt blocks.  Zero count irq blocks may be used to describe
 * unimplemented interrupt types.
 *
 * The EVENTFD flag indicates the interrupt index supports eventfd based
 * signaling.
 *
 * The MASKABLE flags indicates the index supports MASK and UNMASK
 * actions described below.
 *
 * AUTOMASKED indicates that after signaling, the interrupt line is
 * automatically masked by VFIO and the user needs to unmask the line
 * to receive new interrupts.  This is primarily intended to distinguish
 * level triggered interrupts.
 *
 * The NORESIZE flag indicates that the interrupt lines within the index
 * are setup as a set and new subindexes cannot be enabled without first
 * disabling the entire index.  This is used for interrupts like PCI MSI
 * and MSI-X where the driver may only use a subset of the available
 * indexes, but VFIO needs to enable a specific number of vectors
 * upfront.  In the case of MSI-X, where the user can enable MSI-X and
 * then add and unmask vectors, it's up to userspace to make the decision
 * whether to allocate the maximum supported number of vectors or tear
 * down setup and incrementally increase the vectors as each is enabled.
 */
struct vfio_irq_info {
  __u32  argsz;
  __u32  flags;
#define VFIO_IRQ_INFO_EVENTFD    (1 << 0)
#define VFIO_IRQ_INFO_MASKABLE    (1 << 1)
#define VFIO_IRQ_INFO_AUTOMASKED  (1 << 2)
#define VFIO_IRQ_INFO_NORESIZE    (1 << 3)
  __u32  index;    /* IRQ index */
  __u32  count;    /* Number of IRQs within this index */
};
#define VFIO_DEVICE_GET_IRQ_INFO  _IO(VFIO_TYPE, VFIO_BASE + 9)

/**
 * VFIO_DEVICE_SET_IRQS - _IOW(VFIO_TYPE, VFIO_BASE + 10, struct vfio_irq_set)
 *
 * Set signaling, masking, and unmasking of interrupts.  Caller provides
 * struct vfio_irq_set with all fields set.  'start' and 'count' indicate
 * the range of subindexes being specified.
 *
 * The DATA flags specify the type of data provided.  If DATA_NONE, the
 * operation performs the specified action immediately on the specified
 * interrupt(s).  For example, to unmask AUTOMASKED interrupt [0,0]:
 * flags = (DATA_NONE|ACTION_UNMASK), index = 0, start = 0, count = 1.
 *
 * DATA_BOOL allows sparse support for the same on arrays of interrupts.
 * For example, to mask interrupts [0,1] and [0,3] (but not [0,2]):
 * flags = (DATA_BOOL|ACTION_MASK), index = 0, start = 1, count = 3,
 * data = {1,0,1}
 *
 * DATA_EVENTFD binds the specified ACTION to the provided __s32 eventfd.
 * A value of -1 can be used to either de-assign interrupts if already
 * assigned or skip un-assigned interrupts.  For example, to set an eventfd
 * to be trigger for interrupts [0,0] and [0,2]:
 * flags = (DATA_EVENTFD|ACTION_TRIGGER), index = 0, start = 0, count = 3,
 * data = {fd1, -1, fd2}
 * If index [0,1] is previously set, two count = 1 ioctls calls would be
 * required to set [0,0] and [0,2] without changing [0,1].
 *
 * Once a signaling mechanism is set, DATA_BOOL or DATA_NONE can be used
 * with ACTION_TRIGGER to perform kernel level interrupt loopback testing
 * from userspace (ie. simulate hardware triggering).
 *
 * Setting of an event triggering mechanism to userspace for ACTION_TRIGGER
 * enables the interrupt index for the device.  Individual subindex interrupts
 * can be disabled using the -1 value for DATA_EVENTFD or the index can be
 * disabled as a whole with: flags = (DATA_NONE|ACTION_TRIGGER), count = 0.
 *
 * Note that ACTION_[UN]MASK specify user->kernel signaling (irqfds) while
 * ACTION_TRIGGER specifies kernel->user signaling.
 */
struct vfio_irq_set {
  __u32  argsz;
  __u32  flags;
#define VFIO_IRQ_SET_DATA_NONE    (1 << 0) /* Data not present */
#define VFIO_IRQ_SET_DATA_BOOL    (1 << 1) /* Data is bool (u8) */
#define VFIO_IRQ_SET_DATA_EVENTFD  (1 << 2) /* Data is eventfd (s32) */
#define VFIO_IRQ_SET_ACTION_MASK  (1 << 3) /* Mask interrupt */
#define VFIO_IRQ_SET_ACTION_UNMASK  (1 << 4) /* Unmask interrupt */
#define VFIO_IRQ_SET_ACTION_TRIGGER  (1 << 5) /* Trigger interrupt */
  __u32  index;
  __u32  start;
  __u32  count;
  __u8  data[];
};
#define VFIO_DEVICE_SET_IRQS    _IO(VFIO_TYPE, VFIO_BASE + 10)

#define VFIO_IRQ_SET_DATA_TYPE_MASK  (VFIO_IRQ_SET_DATA_NONE | \
           VFIO_IRQ_SET_DATA_BOOL | \
           VFIO_IRQ_SET_DATA_EVENTFD)
#define VFIO_IRQ_SET_ACTION_TYPE_MASK  (VFIO_IRQ_SET_ACTION_MASK | \
           VFIO_IRQ_SET_ACTION_UNMASK | \
           VFIO_IRQ_SET_ACTION_TRIGGER)
/**
 * VFIO_DEVICE_RESET - _IO(VFIO_TYPE, VFIO_BASE + 11)
 *
 * Reset a device.
 */
#define VFIO_DEVICE_RESET    _IO(VFIO_TYPE, VFIO_BASE + 11)

/*
 * The VFIO-PCI bus driver makes use of the following fixed region and
 * IRQ index mapping.  Unimplemented regions return a size of zero.
 * Unimplemented IRQ types return a count of zero.
 */

enum {
  VFIO_PCI_BAR0_REGION_INDEX,
  VFIO_PCI_BAR1_REGION_INDEX,
  VFIO_PCI_BAR2_REGION_INDEX,
  VFIO_PCI_BAR3_REGION_INDEX,
  VFIO_PCI_BAR4_REGION_INDEX,
  VFIO_PCI_BAR5_REGION_INDEX,
  VFIO_PCI_ROM_REGION_INDEX,
  VFIO_PCI_CONFIG_REGION_INDEX,
  /*
   * Expose VGA regions defined for PCI base class 03, subclass 00.
   * This includes I/O port ranges 0x3b0 to 0x3bb and 0x3c0 to 0x3df
   * as well as the MMIO range 0xa0000 to 0xbffff.  Each implemented
   * range is found at it's identity mapped offset from the region
   * offset, for example 0x3b0 is region_info.offset + 0x3b0.  Areas
   * between described ranges are unimplemented.
   */
  VFIO_PCI_VGA_REGION_INDEX,
  VFIO_PCI_NUM_REGIONS = 9 /* Fixed user ABI, region indexes >=9 use */
         /* device specific cap to define content. */
};

enum {
  VFIO_PCI_INTX_IRQ_INDEX,
  VFIO_PCI_MSI_IRQ_INDEX,
  VFIO_PCI_MSIX_IRQ_INDEX,
  VFIO_PCI_ERR_IRQ_INDEX,
  VFIO_PCI_REQ_IRQ_INDEX,
  VFIO_PCI_NUM_IRQS
};

/*
 * The vfio-ccw bus driver makes use of the following fixed region and
 * IRQ index mapping. Unimplemented regions return a size of zero.
 * Unimplemented IRQ types return a count of zero.
 */

enum {
  VFIO_CCW_CONFIG_REGION_INDEX,
  VFIO_CCW_NUM_REGIONS
};

enum {
  VFIO_CCW_IO_IRQ_INDEX,
  VFIO_CCW_CRW_IRQ_INDEX,
  VFIO_CCW_NUM_IRQS
};

/**
 * VFIO_DEVICE_GET_PCI_HOT_RESET_INFO - _IORW(VFIO_TYPE, VFIO_BASE + 12,
 *                struct vfio_pci_hot_reset_info)
 *
 * Return: 0 on success, -errno on failure:
 *  -enospc = insufficient buffer, -enodev = unsupported for device.
 */
struct vfio_pci_dependent_device {
  __u32  group_id;
  __u16  segment;
  __u8  bus;
  __u8  devfn; /* Use PCI_SLOT/PCI_FUNC */
};

struct vfio_pci_hot_reset_info {
  __u32  argsz;
  __u32  flags;
  __u32  count;
  struct vfio_pci_dependent_device  devices[];
};

#define VFIO_DEVICE_GET_PCI_HOT_RESET_INFO  _IO(VFIO_TYPE, VFIO_BASE + 12)

/**
 * VFIO_DEVICE_PCI_HOT_RESET - _IOW(VFIO_TYPE, VFIO_BASE + 13,
 *            struct vfio_pci_hot_reset)
 *
 * Return: 0 on success, -errno on failure.
 */
struct vfio_pci_hot_reset {
  __u32  argsz;
  __u32  flags;
  __u32  count;
  __s32  group_fds[];
};

#define VFIO_DEVICE_PCI_HOT_RESET  _IO(VFIO_TYPE, VFIO_BASE + 13)

/**
 * VFIO_DEVICE_QUERY_GFX_PLANE - _IOW(VFIO_TYPE, VFIO_BASE + 14,
 *                                    struct vfio_device_query_gfx_plane)
 *
 * Set the drm_plane_type and flags, then retrieve the gfx plane info.
 *
 * flags supported:
 * - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_DMABUF are set
 *   to ask if the mdev supports dma-buf. 0 on support, -EINVAL on no
 *   support for dma-buf.
 * - VFIO_GFX_PLANE_TYPE_PROBE and VFIO_GFX_PLANE_TYPE_REGION are set
 *   to ask if the mdev supports region. 0 on support, -EINVAL on no
 *   support for region.
 * - VFIO_GFX_PLANE_TYPE_DMABUF or VFIO_GFX_PLANE_TYPE_REGION is set
 *   with each call to query the plane info.
 * - Others are invalid and return -EINVAL.
 *
 * Note:
 * 1. Plane could be disabled by guest. In that case, success will be
 *    returned with zero-initialized drm_format, size, width and height
 *    fields.
 * 2. x_hot/y_hot is set to 0xFFFFFFFF if no hotspot information available
 *
 * Return: 0 on success, -errno on other failure.
 */
struct vfio_device_gfx_plane_info {
  __u32 argsz;
  __u32 flags;
#define VFIO_GFX_PLANE_TYPE_PROBE (1 << 0)
#define VFIO_GFX_PLANE_TYPE_DMABUF (1 << 1)
#define VFIO_GFX_PLANE_TYPE_REGION (1 << 2)
  /* in */
  __u32 drm_plane_type;  /* type of plane: DRM_PLANE_TYPE_* */
  /* out */
  __u32 drm_format;  /* drm format of plane */
  __u64 drm_format_mod;   /* tiled mode */
  __u32 width;  /* width of plane */
  __u32 height;  /* height of plane */
  __u32 stride;  /* stride of plane */
  __u32 size;  /* size of plane in bytes, align on page*/
  __u32 x_pos;  /* horizontal position of cursor plane */
  __u32 y_pos;  /* vertical position of cursor plane*/
  __u32 x_hot;    /* horizontal position of cursor hotspot */
  __u32 y_hot;    /* vertical position of cursor hotspot */
  union {
    __u32 region_index;  /* region index */
    __u32 dmabuf_id;  /* dma-buf id */
  };
};

#define VFIO_DEVICE_QUERY_GFX_PLANE _IO(VFIO_TYPE, VFIO_BASE + 14)

/**
 * VFIO_DEVICE_GET_GFX_DMABUF - _IOW(VFIO_TYPE, VFIO_BASE + 15, __u32)
 *
 * Return a new dma-buf file descriptor for an exposed guest framebuffer
 * described by the provided dmabuf_id. The dmabuf_id is returned from VFIO_
 * DEVICE_QUERY_GFX_PLANE as a token of the exposed guest framebuffer.
 */

#define VFIO_DEVICE_GET_GFX_DMABUF _IO(VFIO_TYPE, VFIO_BASE + 15)

/**
 * VFIO_DEVICE_IOEVENTFD - _IOW(VFIO_TYPE, VFIO_BASE + 16,
 *                              struct vfio_device_ioeventfd)
 *
 * Perform a write to the device at the specified device fd offset, with
 * the specified data and width when the provided eventfd is triggered.
 * vfio bus drivers may not support this for all regions, for all widths,
 * or at all.  vfio-pci currently only enables support for BAR regions,
 * excluding the MSI-X vector table.
 *
 * Return: 0 on success, -errno on failure.
 */
struct vfio_device_ioeventfd {
  __u32  argsz;
  __u32  flags;
#define VFIO_DEVICE_IOEVENTFD_8    (1 << 0) /* 1-byte write */
#define VFIO_DEVICE_IOEVENTFD_16  (1 << 1) /* 2-byte write */
#define VFIO_DEVICE_IOEVENTFD_32  (1 << 2) /* 4-byte write */
#define VFIO_DEVICE_IOEVENTFD_64  (1 << 3) /* 8-byte write */
#define VFIO_DEVICE_IOEVENTFD_SIZE_MASK  (0xf)
  __u64  offset;      /* device fd offset of write */
  __u64  data;      /* data to be written */
  __s32  fd;      /* -1 for de-assignment */
};

#define VFIO_DEVICE_IOEVENTFD    _IO(VFIO_TYPE, VFIO_BASE + 16)

/**
 * VFIO_DEVICE_FEATURE - _IORW(VFIO_TYPE, VFIO_BASE + 17,
 *             struct vfio_device_feature)
 *
 * Get, set, or probe feature data of the device.  The feature is selected
 * using the FEATURE_MASK portion of the flags field.  Support for a feature
 * can be probed by setting both the FEATURE_MASK and PROBE bits.  A probe
 * may optionally include the GET and/or SET bits to determine read vs write
 * access of the feature respectively.  Probing a feature will return success
 * if the feature is supported and all of the optionally indicated GET/SET
 * methods are supported.  The format of the data portion of the structure is
 * specific to the given feature.  The data portion is not required for
 * probing.  GET and SET are mutually exclusive, except for use with PROBE.
 *
 * Return 0 on success, -errno on failure.
 */
struct vfio_device_feature {
  __u32  argsz;
  __u32  flags;
#define VFIO_DEVICE_FEATURE_MASK  (0xffff) /* 16-bit feature index */
#define VFIO_DEVICE_FEATURE_GET    (1 << 16) /* Get feature into data[] */
#define VFIO_DEVICE_FEATURE_SET    (1 << 17) /* Set feature from data[] */
#define VFIO_DEVICE_FEATURE_PROBE  (1 << 18) /* Probe feature support */
  __u8  data[];
};

#define VFIO_DEVICE_FEATURE    _IO(VFIO_TYPE, VFIO_BASE + 17)

/*
 * Provide support for setting a PCI VF Token, which is used as a shared
 * secret between PF and VF drivers.  This feature may only be set on a
 * PCI SR-IOV PF when SR-IOV is enabled on the PF and there are no existing
 * open VFs.  Data provided when setting this feature is a 16-byte array
 * (__u8 b[16]), representing a UUID.
 */
#define VFIO_DEVICE_FEATURE_PCI_VF_TOKEN  (0)

/* -------- API for Type1 VFIO IOMMU -------- */

/**
 * VFIO_IOMMU_GET_INFO - _IOR(VFIO_TYPE, VFIO_BASE + 12, struct vfio_iommu_info)
 *
 * Retrieve information about the IOMMU object. Fills in provided
 * struct vfio_iommu_info. Caller sets argsz.
 *
 * XXX Should we do these by CHECK_EXTENSION too?
 */
struct vfio_iommu_type1_info {
  __u32  argsz;
  __u32  flags;
#define VFIO_IOMMU_INFO_PGSIZES (1 << 0)  /* supported page sizes info */
#define VFIO_IOMMU_INFO_CAPS  (1 << 1)  /* Info supports caps */
  __u64  iova_pgsizes;  /* Bitmap of supported page sizes */
  __u32   cap_offset;  /* Offset within info struct of first cap */
};

/*
 * The IOVA capability allows to report the valid IOVA range(s)
 * excluding any non-relaxable reserved regions exposed by
 * devices attached to the container. Any DMA map attempt
 * outside the valid iova range will return error.
 *
 * The structures below define version 1 of this capability.
 */
#define VFIO_IOMMU_TYPE1_INFO_CAP_IOVA_RANGE  1

struct vfio_iova_range {
  __u64  start;
  __u64  end;
};

struct vfio_iommu_type1_info_cap_iova_range {
  struct  vfio_info_cap_header header;
  __u32  nr_iovas;
  __u32  reserved;
  struct  vfio_iova_range iova_ranges[];
};

/*
 * The migration capability allows to report supported features for migration.
 *
 * The structures below define version 1 of this capability.
 *
 * The existence of this capability indicates that IOMMU kernel driver supports
 * dirty page logging.
 *
 * pgsize_bitmap: Kernel driver returns bitmap of supported page sizes for dirty
 * page logging.
 * max_dirty_bitmap_size: Kernel driver returns maximum supported dirty bitmap
 * size in bytes that can be used by user applications when getting the dirty
 * bitmap.
 */
#define VFIO_IOMMU_TYPE1_INFO_CAP_MIGRATION  2

struct vfio_iommu_type1_info_cap_migration {
  struct  vfio_info_cap_header header;
  __u32  flags;
  __u64  pgsize_bitmap;
  __u64  max_dirty_bitmap_size;    /* in bytes */
};

#define VFIO_IOMMU_GET_INFO _IO(VFIO_TYPE, VFIO_BASE + 12)

/**
 * VFIO_IOMMU_MAP_DMA - _IOW(VFIO_TYPE, VFIO_BASE + 13, struct vfio_dma_map)
 *
 * Map process virtual addresses to IO virtual addresses using the
 * provided struct vfio_dma_map. Caller sets argsz. READ &/ WRITE required.
 */
struct vfio_iommu_type1_dma_map {
  __u32  argsz;
  __u32  flags;
#define VFIO_DMA_MAP_FLAG_READ (1 << 0)    /* readable from device */
#define VFIO_DMA_MAP_FLAG_WRITE (1 << 1)  /* writable from device */
  __u64  vaddr;        /* Process virtual address */
  __u64  iova;        /* IO virtual address */
  __u64  size;        /* Size of mapping (bytes) */
};

#define VFIO_IOMMU_MAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 13)

struct vfio_bitmap {
  __u64        pgsize;  /* page size for bitmap in bytes */
  __u64        size;  /* in bytes */
  __u64        *data;  /* one bit per page */
};

/**
 * VFIO_IOMMU_UNMAP_DMA - _IOWR(VFIO_TYPE, VFIO_BASE + 14,
 *              struct vfio_dma_unmap)
 *
 * Unmap IO virtual addresses using the provided struct vfio_dma_unmap.
 * Caller sets argsz.  The actual unmapped size is returned in the size
 * field.  No guarantee is made to the user that arbitrary unmaps of iova
 * or size different from those used in the original mapping call will
 * succeed.
 * VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP should be set to get the dirty bitmap
 * before unmapping IO virtual addresses. When this flag is set, the user must
 * provide a struct vfio_bitmap in data[]. User must provide zero-allocated
 * memory via vfio_bitmap.data and its size in the vfio_bitmap.size field.
 * A bit in the bitmap represents one page, of user provided page size in
 * vfio_bitmap.pgsize field, consecutively starting from iova offset. Bit set
 * indicates that the page at that offset from iova is dirty. A Bitmap of the
 * pages in the range of unmapped size is returned in the user-provided
 * vfio_bitmap.data.
 */
struct vfio_iommu_type1_dma_unmap {
  __u32  argsz;
  __u32  flags;
#define VFIO_DMA_UNMAP_FLAG_GET_DIRTY_BITMAP (1 << 0)
  __u64  iova;        /* IO virtual address */
  __u64  size;        /* Size of mapping (bytes) */
  __u8    data[];
};

#define VFIO_IOMMU_UNMAP_DMA _IO(VFIO_TYPE, VFIO_BASE + 14)

/*
 * IOCTLs to enable/disable IOMMU container usage.
 * No parameters are supported.
 */
#define VFIO_IOMMU_ENABLE  _IO(VFIO_TYPE, VFIO_BASE + 15)
#define VFIO_IOMMU_DISABLE  _IO(VFIO_TYPE, VFIO_BASE + 16)

/**
 * VFIO_IOMMU_DIRTY_PAGES - _IOWR(VFIO_TYPE, VFIO_BASE + 17,
 *                                     struct vfio_iommu_type1_dirty_bitmap)
 * IOCTL is used for dirty pages logging.
 * Caller should set flag depending on which operation to perform, details as
 * below:
 *
 * Calling the IOCTL with VFIO_IOMMU_DIRTY_PAGES_FLAG_START flag set, instructs
 * the IOMMU driver to log pages that are dirtied or potentially dirtied by
 * the device; designed to be used when a migration is in progress. Dirty pages
 * are logged until logging is disabled by user application by calling the IOCTL
 * with VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP flag.
 *
 * Calling the IOCTL with VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP flag set, instructs
 * the IOMMU driver to stop logging dirtied pages.
 *
 * Calling the IOCTL with VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP flag set
 * returns the dirty pages bitmap for IOMMU container for a given IOVA range.
 * The user must specify the IOVA range and the pgsize through the structure
 * vfio_iommu_type1_dirty_bitmap_get in the data[] portion. This interface
 * supports getting a bitmap of the smallest supported pgsize only and can be
 * modified in future to get a bitmap of any specified supported pgsize. The
 * user must provide a zeroed memory area for the bitmap memory and specify its
 * size in bitmap.size. One bit is used to represent one page consecutively
 * starting from iova offset. The user should provide page size in bitmap.pgsize
 * field. A bit set in the bitmap indicates that the page at that offset from
 * iova is dirty. The caller must set argsz to a value including the size of
 * structure vfio_iommu_type1_dirty_bitmap_get, but excluding the size of the
 * actual bitmap. If dirty pages logging is not enabled, an error will be
 * returned.
 *
 * Only one of the flags _START, _STOP and _GET may be specified at a time.
 *
 */
struct vfio_iommu_type1_dirty_bitmap {
  __u32        argsz;
  __u32        flags;
#define VFIO_IOMMU_DIRTY_PAGES_FLAG_START  (1 << 0)
#define VFIO_IOMMU_DIRTY_PAGES_FLAG_STOP  (1 << 1)
#define VFIO_IOMMU_DIRTY_PAGES_FLAG_GET_BITMAP  (1 << 2)
  __u8         data[];
};

struct vfio_iommu_type1_dirty_bitmap_get {
  __u64              iova;  /* IO virtual address */
  __u64              size;  /* Size of iova range */
  struct vfio_bitmap bitmap;
};

#define VFIO_IOMMU_DIRTY_PAGES             _IO(VFIO_TYPE, VFIO_BASE + 17)

/* -------- Additional API for SPAPR TCE (Server POWERPC) IOMMU -------- */

/*
 * The SPAPR TCE DDW info struct provides the information about
 * the details of Dynamic DMA window capability.
 *
 * @pgsizes contains a page size bitmask, 4K/64K/16M are supported.
 * @max_dynamic_windows_supported tells the maximum number of windows
 * which the platform can create.
 * @levels tells the maximum number of levels in multi-level IOMMU tables;
 * this allows splitting a table into smaller chunks which reduces
 * the amount of physically contiguous memory required for the table.
 */
struct vfio_iommu_spapr_tce_ddw_info {
  __u64 pgsizes;      /* Bitmap of supported page sizes */
  __u32 max_dynamic_windows_supported;
  __u32 levels;
};

/*
 * The SPAPR TCE info struct provides the information about the PCI bus
 * address ranges available for DMA, these values are programmed into
 * the hardware so the guest has to know that information.
 *
 * The DMA 32 bit window start is an absolute PCI bus address.
 * The IOVA address passed via map/unmap ioctls are absolute PCI bus
 * addresses too so the window works as a filter rather than an offset
 * for IOVA addresses.
 *
 * Flags supported:
 * - VFIO_IOMMU_SPAPR_INFO_DDW: informs the userspace that dynamic DMA windows
 *   (DDW) support is present. @ddw is only supported when DDW is present.
 */
struct vfio_iommu_spapr_tce_info {
  __u32 argsz;
  __u32 flags;
#define VFIO_IOMMU_SPAPR_INFO_DDW  (1 << 0)  /* DDW supported */
  __u32 dma32_window_start;  /* 32 bit window start (bytes) */
  __u32 dma32_window_size;  /* 32 bit window size (bytes) */
  struct vfio_iommu_spapr_tce_ddw_info ddw;
};

#define VFIO_IOMMU_SPAPR_TCE_GET_INFO  _IO(VFIO_TYPE, VFIO_BASE + 12)

/*
 * EEH PE operation struct provides ways to:
 * - enable/disable EEH functionality;
 * - unfreeze IO/DMA for frozen PE;
 * - read PE state;
 * - reset PE;
 * - configure PE;
 * - inject EEH error.
 */
struct vfio_eeh_pe_err {
  __u32 type;
  __u32 func;
  __u64 addr;
  __u64 mask;
};

struct vfio_eeh_pe_op {
  __u32 argsz;
  __u32 flags;
  __u32 op;
  union {
    struct vfio_eeh_pe_err err;
  };
};

#define VFIO_EEH_PE_DISABLE    0  /* Disable EEH functionality */
#define VFIO_EEH_PE_ENABLE    1  /* Enable EEH functionality  */
#define VFIO_EEH_PE_UNFREEZE_IO    2  /* Enable IO for frozen PE   */
#define VFIO_EEH_PE_UNFREEZE_DMA  3  /* Enable DMA for frozen PE  */
#define VFIO_EEH_PE_GET_STATE    4  /* PE state retrieval        */
#define  VFIO_EEH_PE_STATE_NORMAL  0  /* PE in functional state    */
#define  VFIO_EEH_PE_STATE_RESET  1  /* PE reset in progress      */
#define  VFIO_EEH_PE_STATE_STOPPED  2  /* Stopped DMA and IO        */
#define  VFIO_EEH_PE_STATE_STOPPED_DMA  4  /* Stopped DMA only          */
#define  VFIO_EEH_PE_STATE_UNAVAIL  5  /* State unavailable         */
#define VFIO_EEH_PE_RESET_DEACTIVATE  5  /* Deassert PE reset         */
#define VFIO_EEH_PE_RESET_HOT    6  /* Assert hot reset          */
#define VFIO_EEH_PE_RESET_FUNDAMENTAL  7  /* Assert fundamental reset  */
#define VFIO_EEH_PE_CONFIGURE    8  /* PE configuration          */
#define VFIO_EEH_PE_INJECT_ERR    9  /* Inject EEH error          */

#define VFIO_EEH_PE_OP      _IO(VFIO_TYPE, VFIO_BASE + 21)

/**
 * VFIO_IOMMU_SPAPR_REGISTER_MEMORY - _IOW(VFIO_TYPE, VFIO_BASE + 17, struct vfio_iommu_spapr_register_memory)
 *
 * Registers user space memory where DMA is allowed. It pins
 * user pages and does the locked memory accounting so
 * subsequent VFIO_IOMMU_MAP_DMA/VFIO_IOMMU_UNMAP_DMA calls
 * get faster.
 */
struct vfio_iommu_spapr_register_memory {
  __u32  argsz;
  __u32  flags;
  __u64  vaddr;        /* Process virtual address */
  __u64  size;        /* Size of mapping (bytes) */
};
#define VFIO_IOMMU_SPAPR_REGISTER_MEMORY  _IO(VFIO_TYPE, VFIO_BASE + 17)

/**
 * VFIO_IOMMU_SPAPR_UNREGISTER_MEMORY - _IOW(VFIO_TYPE, VFIO_BASE + 18, struct vfio_iommu_spapr_register_memory)
 *
 * Unregisters user space memory registered with
 * VFIO_IOMMU_SPAPR_REGISTER_MEMORY.
 * Uses vfio_iommu_spapr_register_memory for parameters.
 */
#define VFIO_IOMMU_SPAPR_UNREGISTER_MEMORY  _IO(VFIO_TYPE, VFIO_BASE + 18)

/**
 * VFIO_IOMMU_SPAPR_TCE_CREATE - _IOWR(VFIO_TYPE, VFIO_BASE + 19, struct vfio_iommu_spapr_tce_create)
 *
 * Creates an additional TCE table and programs it (sets a new DMA window)
 * to every IOMMU group in the container. It receives page shift, window
 * size and number of levels in the TCE table being created.
 *
 * It allocates and returns an offset on a PCI bus of the new DMA window.
 */
struct vfio_iommu_spapr_tce_create {
  __u32 argsz;
  __u32 flags;
  /* in */
  __u32 page_shift;
  __u32 __resv1;
  __u64 window_size;
  __u32 levels;
  __u32 __resv2;
  /* out */
  __u64 start_addr;
};
#define VFIO_IOMMU_SPAPR_TCE_CREATE  _IO(VFIO_TYPE, VFIO_BASE + 19)

/**
 * VFIO_IOMMU_SPAPR_TCE_REMOVE - _IOW(VFIO_TYPE, VFIO_BASE + 20, struct vfio_iommu_spapr_tce_remove)
 *
 * Unprograms a TCE table from all groups in the container and destroys it.
 * It receives a PCI bus offset as a window id.
 */
struct vfio_iommu_spapr_tce_remove {
  __u32 argsz;
  __u32 flags;
  /* in */
  __u64 start_addr;
};
#define VFIO_IOMMU_SPAPR_TCE_REMOVE  _IO(VFIO_TYPE, VFIO_BASE + 20)

/* ***************************************************************** */

#endif /* _UAPIVFIO_H */

```

`include/linuz/virgl_protocol.h`:

```h
/*
 * Copyright 2014, 2015 Red Hat.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * on the rights to use, copy, modify, merge, publish, distribute, sub
 * license, and/or sell copies of the Software, and to permit persons to whom
 * the Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice (including the next
 * paragraph) shall be included in all copies or substantial portions of the
 * Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHOR(S) AND/OR THEIR SUPPLIERS BE LIABLE FOR ANY CLAIM,
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
 * USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#ifndef VIRGL_PROTOCOL_H
#define VIRGL_PROTOCOL_H

#include <stdint.h>

#define VIRGL_QUERY_STATE_NEW 0
#define VIRGL_QUERY_STATE_DONE 1
#define VIRGL_QUERY_STATE_WAIT_HOST 2

struct virgl_host_query_state {
  uint32_t query_state;
  uint32_t result_size;
  uint64_t result;
};

struct virgl_memory_info {
  uint32_t total_device_memory;  /**< size of device memory, e.g. VRAM */
  uint32_t avail_device_memory;  /**< free device memory at the moment */
  uint32_t total_staging_memory; /**< size of staging memory, e.g. GART */
  uint32_t avail_staging_memory; /**< free staging memory at the moment */
  uint32_t device_memory_evicted; /**< size of memory evicted (monotonic counter) */
  uint32_t nr_device_memory_evictions; /**< # of evictions (monotonic counter) */
};

enum virgl_object_type {
  VIRGL_OBJECT_NULL,
  VIRGL_OBJECT_BLEND,
  VIRGL_OBJECT_RASTERIZER,
  VIRGL_OBJECT_DSA,
  VIRGL_OBJECT_SHADER,
  VIRGL_OBJECT_VERTEX_ELEMENTS,
  VIRGL_OBJECT_SAMPLER_VIEW,
  VIRGL_OBJECT_SAMPLER_STATE,
  VIRGL_OBJECT_SURFACE,
  VIRGL_OBJECT_QUERY,
  VIRGL_OBJECT_STREAMOUT_TARGET,
  VIRGL_OBJECT_MSAA_SURFACE,
  VIRGL_MAX_OBJECTS,
};

/* context cmds to be encoded in the command stream */
enum virgl_context_cmd {
  VIRGL_CCMD_NOP = 0,
  VIRGL_CCMD_CREATE_OBJECT = 1,
  VIRGL_CCMD_BIND_OBJECT,
  VIRGL_CCMD_DESTROY_OBJECT,
  VIRGL_CCMD_SET_VIEWPORT_STATE,
  VIRGL_CCMD_SET_FRAMEBUFFER_STATE,
  VIRGL_CCMD_SET_VERTEX_BUFFERS,
  VIRGL_CCMD_CLEAR,
  VIRGL_CCMD_DRAW_VBO,
  VIRGL_CCMD_RESOURCE_INLINE_WRITE,
  VIRGL_CCMD_SET_SAMPLER_VIEWS,
  VIRGL_CCMD_SET_INDEX_BUFFER,
  VIRGL_CCMD_SET_CONSTANT_BUFFER,
  VIRGL_CCMD_SET_STENCIL_REF,
  VIRGL_CCMD_SET_BLEND_COLOR,
  VIRGL_CCMD_SET_SCISSOR_STATE,
  VIRGL_CCMD_BLIT,
  VIRGL_CCMD_RESOURCE_COPY_REGION,
  VIRGL_CCMD_BIND_SAMPLER_STATES,
  VIRGL_CCMD_BEGIN_QUERY,
  VIRGL_CCMD_END_QUERY,
  VIRGL_CCMD_GET_QUERY_RESULT,
  VIRGL_CCMD_SET_POLYGON_STIPPLE,
  VIRGL_CCMD_SET_CLIP_STATE,
  VIRGL_CCMD_SET_SAMPLE_MASK,
  VIRGL_CCMD_SET_STREAMOUT_TARGETS,
  VIRGL_CCMD_SET_RENDER_CONDITION,
  VIRGL_CCMD_SET_UNIFORM_BUFFER,

  VIRGL_CCMD_SET_SUB_CTX,
  VIRGL_CCMD_CREATE_SUB_CTX,
  VIRGL_CCMD_DESTROY_SUB_CTX,
  VIRGL_CCMD_BIND_SHADER,
  VIRGL_CCMD_SET_TESS_STATE,
  VIRGL_CCMD_SET_MIN_SAMPLES,
  VIRGL_CCMD_SET_SHADER_BUFFERS,
  VIRGL_CCMD_SET_SHADER_IMAGES,
  VIRGL_CCMD_MEMORY_BARRIER,
  VIRGL_CCMD_LAUNCH_GRID,
  VIRGL_CCMD_SET_FRAMEBUFFER_STATE_NO_ATTACH,
  VIRGL_CCMD_TEXTURE_BARRIER,
  VIRGL_CCMD_SET_ATOMIC_BUFFERS,
  VIRGL_CCMD_SET_DEBUG_FLAGS,
  VIRGL_CCMD_GET_QUERY_RESULT_QBO,
  VIRGL_CCMD_TRANSFER3D,
  VIRGL_CCMD_END_TRANSFERS,
  VIRGL_CCMD_COPY_TRANSFER3D,
  VIRGL_CCMD_SET_TWEAKS,
  VIRGL_CCMD_CLEAR_TEXTURE,
  VIRGL_CCMD_PIPE_RESOURCE_CREATE,
  VIRGL_CCMD_PIPE_RESOURCE_SET_TYPE,
  VIRGL_CCMD_GET_MEMORY_INFO,
  VIRGL_CCMD_SEND_STRING_MARKER,
  VIRGL_CCMD_LINK_SHADER,

  /* video codec */
  VIRGL_CCMD_CREATE_VIDEO_CODEC,
  VIRGL_CCMD_DESTROY_VIDEO_CODEC,
  VIRGL_CCMD_CREATE_VIDEO_BUFFER,
  VIRGL_CCMD_DESTROY_VIDEO_BUFFER,
  VIRGL_CCMD_BEGIN_FRAME,
  VIRGL_CCMD_DECODE_MACROBLOCK,
  VIRGL_CCMD_DECODE_BITSTREAM,
  VIRGL_CCMD_ENCODE_BITSTREAM,
  VIRGL_CCMD_END_FRAME,

  VIRGL_MAX_COMMANDS
};

/*
 8-bit cmd headers
 8-bit object type
 16-bit length
*/

#define VIRGL_CMD0(cmd, obj, len) ((cmd) | ((obj) << 8) | ((len) << 16))
#define VIRGL_CMD0_MAX_DWORDS (((1ULL << 16) - 1) / 4) * 4

/* hw specification */
#define VIRGL_MAX_COLOR_BUFS 8
#define VIRGL_MAX_CLIP_PLANES 8

#define VIRGL_OBJ_CREATE_HEADER 0
#define VIRGL_OBJ_CREATE_HANDLE 1

#define VIRGL_OBJ_BIND_HEADER 0
#define VIRGL_OBJ_BIND_HANDLE 1

#define VIRGL_OBJ_DESTROY_HANDLE 1

/* some of these defines are a specification - not used in the code */
/* bit offsets for blend state object */
#define VIRGL_OBJ_BLEND_SIZE (VIRGL_MAX_COLOR_BUFS + 3)
#define VIRGL_OBJ_BLEND_HANDLE 1
#define VIRGL_OBJ_BLEND_S0 2
#define VIRGL_OBJ_BLEND_S0_INDEPENDENT_BLEND_ENABLE(x) ((x)&0x1 << 0)
#define VIRGL_OBJ_BLEND_S0_LOGICOP_ENABLE(x) (((x)&0x1) << 1)
#define VIRGL_OBJ_BLEND_S0_DITHER(x) (((x)&0x1) << 2)
#define VIRGL_OBJ_BLEND_S0_ALPHA_TO_COVERAGE(x) (((x)&0x1) << 3)
#define VIRGL_OBJ_BLEND_S0_ALPHA_TO_ONE(x) (((x)&0x1) << 4)
#define VIRGL_OBJ_BLEND_S1 3
#define VIRGL_OBJ_BLEND_S1_LOGICOP_FUNC(x) (((x)&0xf) << 0)
/* repeated once per number of cbufs */

#define VIRGL_OBJ_BLEND_S2(cbuf) (4 + (cbuf))
#define VIRGL_OBJ_BLEND_S2_RT_BLEND_ENABLE(x) (((x)&0x1) << 0)
#define VIRGL_OBJ_BLEND_S2_RT_RGB_FUNC(x) (((x)&0x7) << 1)
#define VIRGL_OBJ_BLEND_S2_RT_RGB_SRC_FACTOR(x) (((x)&0x1f) << 4)
#define VIRGL_OBJ_BLEND_S2_RT_RGB_DST_FACTOR(x) (((x)&0x1f) << 9)
#define VIRGL_OBJ_BLEND_S2_RT_ALPHA_FUNC(x) (((x)&0x7) << 14)
#define VIRGL_OBJ_BLEND_S2_RT_ALPHA_SRC_FACTOR(x) (((x)&0x1f) << 17)
#define VIRGL_OBJ_BLEND_S2_RT_ALPHA_DST_FACTOR(x) (((x)&0x1f) << 22)
#define VIRGL_OBJ_BLEND_S2_RT_COLORMASK(x) (((x)&0xf) << 27)

/* bit offsets for DSA state */
#define VIRGL_OBJ_DSA_SIZE 5
#define VIRGL_OBJ_DSA_HANDLE 1
#define VIRGL_OBJ_DSA_S0 2
#define VIRGL_OBJ_DSA_S0_DEPTH_ENABLE(x) (((x)&0x1) << 0)
#define VIRGL_OBJ_DSA_S0_DEPTH_WRITEMASK(x) (((x)&0x1) << 1)
#define VIRGL_OBJ_DSA_S0_DEPTH_FUNC(x) (((x)&0x7) << 2)
#define VIRGL_OBJ_DSA_S0_ALPHA_ENABLED(x) (((x)&0x1) << 8)
#define VIRGL_OBJ_DSA_S0_ALPHA_FUNC(x) (((x)&0x7) << 9)
#define VIRGL_OBJ_DSA_S1 3
#define VIRGL_OBJ_DSA_S2 4
#define VIRGL_OBJ_DSA_S1_STENCIL_ENABLED(x) (((x)&0x1) << 0)
#define VIRGL_OBJ_DSA_S1_STENCIL_FUNC(x) (((x)&0x7) << 1)
#define VIRGL_OBJ_DSA_S1_STENCIL_FAIL_OP(x) (((x)&0x7) << 4)
#define VIRGL_OBJ_DSA_S1_STENCIL_ZPASS_OP(x) (((x)&0x7) << 7)
#define VIRGL_OBJ_DSA_S1_STENCIL_ZFAIL_OP(x) (((x)&0x7) << 10)
#define VIRGL_OBJ_DSA_S1_STENCIL_VALUEMASK(x) (((x)&0xff) << 13)
#define VIRGL_OBJ_DSA_S1_STENCIL_WRITEMASK(x) (((x)&0xff) << 21)
#define VIRGL_OBJ_DSA_ALPHA_REF 5

/* offsets for rasterizer state */
#define VIRGL_OBJ_RS_SIZE 9
#define VIRGL_OBJ_RS_HANDLE 1
#define VIRGL_OBJ_RS_S0 2
#define VIRGL_OBJ_RS_S0_FLATSHADE(x) (((x)&0x1) << 0)
#define VIRGL_OBJ_RS_S0_DEPTH_CLIP(x) (((x)&0x1) << 1)
#define VIRGL_OBJ_RS_S0_CLIP_HALFZ(x) (((x)&0x1) << 2)
#define VIRGL_OBJ_RS_S0_RASTERIZER_DISCARD(x) (((x)&0x1) << 3)
#define VIRGL_OBJ_RS_S0_FLATSHADE_FIRST(x) (((x)&0x1) << 4)
#define VIRGL_OBJ_RS_S0_LIGHT_TWOSIZE(x) (((x)&0x1) << 5)
#define VIRGL_OBJ_RS_S0_SPRITE_COORD_MODE(x) (((x)&0x1) << 6)
#define VIRGL_OBJ_RS_S0_POINT_QUAD_RASTERIZATION(x) (((x)&0x1) << 7)
#define VIRGL_OBJ_RS_S0_CULL_FACE(x) (((x)&0x3) << 8)
#define VIRGL_OBJ_RS_S0_FILL_FRONT(x) (((x)&0x3) << 10)
#define VIRGL_OBJ_RS_S0_FILL_BACK(x) (((x)&0x3) << 12)
#define VIRGL_OBJ_RS_S0_SCISSOR(x) (((x)&0x1) << 14)
#define VIRGL_OBJ_RS_S0_FRONT_CCW(x) (((x)&0x1) << 15)
#define VIRGL_OBJ_RS_S0_CLAMP_VERTEX_COLOR(x) (((x)&0x1) << 16)
#define VIRGL_OBJ_RS_S0_CLAMP_FRAGMENT_COLOR(x) (((x)&0x1) << 17)
#define VIRGL_OBJ_RS_S0_OFFSET_LINE(x) (((x)&0x1) << 18)
#define VIRGL_OBJ_RS_S0_OFFSET_POINT(x) (((x)&0x1) << 19)
#define VIRGL_OBJ_RS_S0_OFFSET_TRI(x) (((x)&0x1) << 20)
#define VIRGL_OBJ_RS_S0_POLY_SMOOTH(x) (((x)&0x1) << 21)
#define VIRGL_OBJ_RS_S0_POLY_STIPPLE_ENABLE(x) (((x)&0x1) << 22)
#define VIRGL_OBJ_RS_S0_POINT_SMOOTH(x) (((x)&0x1) << 23)
#define VIRGL_OBJ_RS_S0_POINT_SIZE_PER_VERTEX(x) (((x)&0x1) << 24)
#define VIRGL_OBJ_RS_S0_MULTISAMPLE(x) (((x)&0x1) << 25)
#define VIRGL_OBJ_RS_S0_LINE_SMOOTH(x) (((x)&0x1) << 26)
#define VIRGL_OBJ_RS_S0_LINE_STIPPLE_ENABLE(x) (((x)&0x1) << 27)
#define VIRGL_OBJ_RS_S0_LINE_LAST_PIXEL(x) (((x)&0x1) << 28)
#define VIRGL_OBJ_RS_S0_HALF_PIXEL_CENTER(x) (((x)&0x1) << 29)
#define VIRGL_OBJ_RS_S0_BOTTOM_EDGE_RULE(x) (((x)&0x1) << 30)
#define VIRGL_OBJ_RS_S0_FORCE_PERSAMPLE_INTERP(x) (((x)&0x1) << 31)

#define VIRGL_OBJ_RS_POINT_SIZE 3
#define VIRGL_OBJ_RS_SPRITE_COORD_ENABLE 4
#define VIRGL_OBJ_RS_S3 5

#define VIRGL_OBJ_RS_S3_LINE_STIPPLE_PATTERN(x) (((x)&0xffff) << 0)
#define VIRGL_OBJ_RS_S3_LINE_STIPPLE_FACTOR(x) (((x)&0xff) << 16)
#define VIRGL_OBJ_RS_S3_CLIP_PLANE_ENABLE(x) (((x)&0xff) << 24)
#define VIRGL_OBJ_RS_LINE_WIDTH 6
#define VIRGL_OBJ_RS_OFFSET_UNITS 7
#define VIRGL_OBJ_RS_OFFSET_SCALE 8
#define VIRGL_OBJ_RS_OFFSET_CLAMP 9

#define VIRGL_OBJ_CLEAR_SIZE 8
#define VIRGL_OBJ_CLEAR_BUFFERS 1
#define VIRGL_OBJ_CLEAR_COLOR_0 2 /* color is 4 * u32/f32/i32 */
#define VIRGL_OBJ_CLEAR_COLOR_1 3
#define VIRGL_OBJ_CLEAR_COLOR_2 4
#define VIRGL_OBJ_CLEAR_COLOR_3 5
#define VIRGL_OBJ_CLEAR_DEPTH_0 6 /* depth is a double precision float */
#define VIRGL_OBJ_CLEAR_DEPTH_1 7
#define VIRGL_OBJ_CLEAR_STENCIL 8

/* shader object */
#define VIRGL_OBJ_SHADER_HDR_SIZE(nso) (5 + ((nso) ? (2 * nso) + 4 : 0))
#define VIRGL_OBJ_SHADER_HANDLE 1
#define VIRGL_OBJ_SHADER_TYPE 2
#define VIRGL_OBJ_SHADER_OFFSET 3
#define VIRGL_OBJ_SHADER_OFFSET_VAL(x) (((x)&0x7fffffff) << 0)
/* start contains full length in VAL - also implies continuations */
/* continuation contains offset in VAL */
#define VIRGL_OBJ_SHADER_OFFSET_CONT (0x1u << 31)
#define VIRGL_OBJ_SHADER_NUM_TOKENS 4
#define VIRGL_OBJ_SHADER_SO_NUM_OUTPUTS 5
#define VIRGL_OBJ_SHADER_SO_STRIDE(x) (6 + (x))
#define VIRGL_OBJ_SHADER_SO_OUTPUT0(x) (10 + (x * 2))
#define VIRGL_OBJ_SHADER_SO_OUTPUT_REGISTER_INDEX(x) (((x)&0xff) << 0)
#define VIRGL_OBJ_SHADER_SO_OUTPUT_START_COMPONENT(x) (((x)&0x3) << 8)
#define VIRGL_OBJ_SHADER_SO_OUTPUT_NUM_COMPONENTS(x) (((x)&0x7) << 10)
#define VIRGL_OBJ_SHADER_SO_OUTPUT_BUFFER(x) (((x)&0x7) << 13)
#define VIRGL_OBJ_SHADER_SO_OUTPUT_DST_OFFSET(x) (((x)&0xffff) << 16)
#define VIRGL_OBJ_SHADER_SO_OUTPUT0_SO(x) (11 + (x * 2))
#define VIRGL_OBJ_SHADER_SO_OUTPUT_STREAM(x) (((x)&0x03) << 0)

/* viewport state */
#define VIRGL_SET_VIEWPORT_STATE_SIZE(num_viewports) ((6 * num_viewports) + 1)
#define VIRGL_SET_VIEWPORT_START_SLOT 1
#define VIRGL_SET_VIEWPORT_STATE_SCALE_0(x) (2 + (x * 6))
#define VIRGL_SET_VIEWPORT_STATE_SCALE_1(x) (3 + (x * 6))
#define VIRGL_SET_VIEWPORT_STATE_SCALE_2(x) (4 + (x * 6))
#define VIRGL_SET_VIEWPORT_STATE_TRANSLATE_0(x) (5 + (x * 6))
#define VIRGL_SET_VIEWPORT_STATE_TRANSLATE_1(x) (6 + (x * 6))
#define VIRGL_SET_VIEWPORT_STATE_TRANSLATE_2(x) (7 + (x * 6))

/* framebuffer state */
#define VIRGL_SET_FRAMEBUFFER_STATE_SIZE(nr_cbufs) (nr_cbufs + 2)
#define VIRGL_SET_FRAMEBUFFER_STATE_NR_CBUFS 1
#define VIRGL_SET_FRAMEBUFFER_STATE_NR_ZSURF_HANDLE 2
#define VIRGL_SET_FRAMEBUFFER_STATE_CBUF_HANDLE(x) ((x) + 3)

/* vertex elements object */
#define VIRGL_OBJ_VERTEX_ELEMENTS_SIZE(num_elements) (((num_elements)*4) + 1)
#define VIRGL_OBJ_VERTEX_ELEMENTS_HANDLE 1
#define VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_OFFSET(x) \
  (((x)*4) + 2) /* repeated per VE */
#define VIRGL_OBJ_VERTEX_ELEMENTS_V0_INSTANCE_DIVISOR(x) (((x)*4) + 3)
#define VIRGL_OBJ_VERTEX_ELEMENTS_V0_VERTEX_BUFFER_INDEX(x) (((x)*4) + 4)
#define VIRGL_OBJ_VERTEX_ELEMENTS_V0_SRC_FORMAT(x) (((x)*4) + 5)

/* vertex buffers */
#define VIRGL_SET_VERTEX_BUFFERS_SIZE(num_buffers) ((num_buffers)*3)
#define VIRGL_SET_VERTEX_BUFFER_STRIDE(x) (((x)*3) + 1)
#define VIRGL_SET_VERTEX_BUFFER_OFFSET(x) (((x)*3) + 2)
#define VIRGL_SET_VERTEX_BUFFER_HANDLE(x) (((x)*3) + 3)

/* index buffer */
#define VIRGL_SET_INDEX_BUFFER_SIZE(ib) (((ib) ? 2 : 0) + 1)
#define VIRGL_SET_INDEX_BUFFER_HANDLE 1
#define VIRGL_SET_INDEX_BUFFER_INDEX_SIZE 2 /* only if sending an IB handle */
#define VIRGL_SET_INDEX_BUFFER_OFFSET 3     /* only if sending an IB handle */

/* constant buffer */
#define VIRGL_SET_CONSTANT_BUFFER_SHADER_TYPE 1
#define VIRGL_SET_CONSTANT_BUFFER_INDEX 2
#define VIRGL_SET_CONSTANT_BUFFER_DATA_START 3

#define VIRGL_SET_UNIFORM_BUFFER_SIZE 5
#define VIRGL_SET_UNIFORM_BUFFER_SHADER_TYPE 1
#define VIRGL_SET_UNIFORM_BUFFER_INDEX 2
#define VIRGL_SET_UNIFORM_BUFFER_OFFSET 3
#define VIRGL_SET_UNIFORM_BUFFER_LENGTH 4
#define VIRGL_SET_UNIFORM_BUFFER_RES_HANDLE 5

/* draw VBO */
#define VIRGL_DRAW_VBO_SIZE 12
#define VIRGL_DRAW_VBO_SIZE_TESS 14
#define VIRGL_DRAW_VBO_SIZE_INDIRECT 20
#define VIRGL_DRAW_VBO_START 1
#define VIRGL_DRAW_VBO_COUNT 2
#define VIRGL_DRAW_VBO_MODE 3
#define VIRGL_DRAW_VBO_INDEXED 4
#define VIRGL_DRAW_VBO_INSTANCE_COUNT 5
#define VIRGL_DRAW_VBO_INDEX_BIAS 6
#define VIRGL_DRAW_VBO_START_INSTANCE 7
#define VIRGL_DRAW_VBO_PRIMITIVE_RESTART 8
#define VIRGL_DRAW_VBO_RESTART_INDEX 9
#define VIRGL_DRAW_VBO_MIN_INDEX 10
#define VIRGL_DRAW_VBO_MAX_INDEX 11
#define VIRGL_DRAW_VBO_COUNT_FROM_SO 12
/* tess packet */
#define VIRGL_DRAW_VBO_VERTICES_PER_PATCH 13
#define VIRGL_DRAW_VBO_DRAWID 14
/* indirect packet */
#define VIRGL_DRAW_VBO_INDIRECT_HANDLE 15
#define VIRGL_DRAW_VBO_INDIRECT_OFFSET 16
#define VIRGL_DRAW_VBO_INDIRECT_STRIDE 17
#define VIRGL_DRAW_VBO_INDIRECT_DRAW_COUNT 18
#define VIRGL_DRAW_VBO_INDIRECT_DRAW_COUNT_OFFSET 19
#define VIRGL_DRAW_VBO_INDIRECT_DRAW_COUNT_HANDLE 20

/* create surface */
#define VIRGL_OBJ_SURFACE_SIZE 5
#define VIRGL_OBJ_SURFACE_HANDLE 1
#define VIRGL_OBJ_SURFACE_RES_HANDLE 2
#define VIRGL_OBJ_SURFACE_FORMAT 3
#define VIRGL_OBJ_SURFACE_BUFFER_FIRST_ELEMENT 4
#define VIRGL_OBJ_SURFACE_BUFFER_LAST_ELEMENT 5
#define VIRGL_OBJ_SURFACE_TEXTURE_LEVEL 4
#define VIRGL_OBJ_SURFACE_TEXTURE_LAYERS 5

/* create surface with implicit MSAA support (for
 * EXT_multisample_render_to_texture) */
#define VIRGL_OBJ_MSAA_SURFACE_SIZE (VIRGL_OBJ_SURFACE_SIZE + 1)
#define VIRGL_OBJ_SURFACE_SAMPLE_COUNT 6

/* create streamout target */
#define VIRGL_OBJ_STREAMOUT_SIZE 4
#define VIRGL_OBJ_STREAMOUT_HANDLE 1
#define VIRGL_OBJ_STREAMOUT_RES_HANDLE 2
#define VIRGL_OBJ_STREAMOUT_BUFFER_OFFSET 3
#define VIRGL_OBJ_STREAMOUT_BUFFER_SIZE 4

/* sampler state */
#define VIRGL_OBJ_SAMPLER_STATE_SIZE 9
#define VIRGL_OBJ_SAMPLER_STATE_HANDLE 1
#define VIRGL_OBJ_SAMPLER_STATE_S0 2
#define VIRGL_OBJ_SAMPLE_STATE_S0_WRAP_S(x) (((x)&0x7) << 0)
#define VIRGL_OBJ_SAMPLE_STATE_S0_WRAP_T(x) (((x)&0x7) << 3)
#define VIRGL_OBJ_SAMPLE_STATE_S0_WRAP_R(x) (((x)&0x7) << 6)
#define VIRGL_OBJ_SAMPLE_STATE_S0_MIN_IMG_FILTER(x) (((x)&0x3) << 9)
#define VIRGL_OBJ_SAMPLE_STATE_S0_MIN_MIP_FILTER(x) (((x)&0x3) << 11)
#define VIRGL_OBJ_SAMPLE_STATE_S0_MAG_IMG_FILTER(x) (((x)&0x3) << 13)
#define VIRGL_OBJ_SAMPLE_STATE_S0_COMPARE_MODE(x) (((x)&0x1) << 15)
#define VIRGL_OBJ_SAMPLE_STATE_S0_COMPARE_FUNC(x) (((x)&0x7) << 16)
#define VIRGL_OBJ_SAMPLE_STATE_S0_SEAMLESS_CUBE_MAP(x) (((x)&0x1) << 19)
#define VIRGL_OBJ_SAMPLE_STATE_S0_MAX_ANISOTROPY(x) (((x & 0x3f)) << 20)

#define VIRGL_OBJ_SAMPLER_STATE_LOD_BIAS 3
#define VIRGL_OBJ_SAMPLER_STATE_MIN_LOD 4
#define VIRGL_OBJ_SAMPLER_STATE_MAX_LOD 5
#define VIRGL_OBJ_SAMPLER_STATE_BORDER_COLOR(x) ((x) + 6) /* 6 - 9 */

/* sampler view */
#define VIRGL_OBJ_SAMPLER_VIEW_SIZE 6
#define VIRGL_OBJ_SAMPLER_VIEW_HANDLE 1
#define VIRGL_OBJ_SAMPLER_VIEW_RES_HANDLE 2
#define VIRGL_OBJ_SAMPLER_VIEW_FORMAT 3
#define VIRGL_OBJ_SAMPLER_VIEW_BUFFER_FIRST_ELEMENT 4
#define VIRGL_OBJ_SAMPLER_VIEW_BUFFER_LAST_ELEMENT 5
#define VIRGL_OBJ_SAMPLER_VIEW_TEXTURE_LAYER 4
#define VIRGL_OBJ_SAMPLER_VIEW_TEXTURE_LEVEL 5
#define VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE 6
#define VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE_R(x) (((x)&0x7) << 0)
#define VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE_G(x) (((x)&0x7) << 3)
#define VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE_B(x) (((x)&0x7) << 6)
#define VIRGL_OBJ_SAMPLER_VIEW_SWIZZLE_A(x) (((x)&0x7) << 9)

/* set sampler views */
#define VIRGL_SET_SAMPLER_VIEWS_SIZE(num_views) ((num_views) + 2)
#define VIRGL_SET_SAMPLER_VIEWS_SHADER_TYPE 1
#define VIRGL_SET_SAMPLER_VIEWS_START_SLOT 2
#define VIRGL_SET_SAMPLER_VIEWS_V0_HANDLE 3

/* bind sampler states */
#define VIRGL_BIND_SAMPLER_STATES(num_states) ((num_states) + 2)
#define VIRGL_BIND_SAMPLER_STATES_SHADER_TYPE 1
#define VIRGL_BIND_SAMPLER_STATES_START_SLOT 2
#define VIRGL_BIND_SAMPLER_STATES_S0_HANDLE 3

/* set stencil reference */
#define VIRGL_SET_STENCIL_REF_SIZE 1
#define VIRGL_SET_STENCIL_REF 1
#define VIRGL_STENCIL_REF_VAL(f, s) ((f & 0xff) | (((s & 0xff) << 8)))

/* set blend color */
#define VIRGL_SET_BLEND_COLOR_SIZE 4
#define VIRGL_SET_BLEND_COLOR(x) ((x) + 1)

/* set scissor state */
#define VIRGL_SET_SCISSOR_STATE_SIZE(x) (1 + 2 * x)
#define VIRGL_SET_SCISSOR_START_SLOT 1
#define VIRGL_SET_SCISSOR_MINX_MINY(x) (2 + (x * 2))
#define VIRGL_SET_SCISSOR_MAXX_MAXY(x) (3 + (x * 2))

/* resource copy region */
#define VIRGL_CMD_RESOURCE_COPY_REGION_SIZE 13
#define VIRGL_CMD_RCR_DST_RES_HANDLE 1
#define VIRGL_CMD_RCR_DST_LEVEL 2
#define VIRGL_CMD_RCR_DST_X 3
#define VIRGL_CMD_RCR_DST_Y 4
#define VIRGL_CMD_RCR_DST_Z 5
#define VIRGL_CMD_RCR_SRC_RES_HANDLE 6
#define VIRGL_CMD_RCR_SRC_LEVEL 7
#define VIRGL_CMD_RCR_SRC_X 8
#define VIRGL_CMD_RCR_SRC_Y 9
#define VIRGL_CMD_RCR_SRC_Z 10
#define VIRGL_CMD_RCR_SRC_W 11
#define VIRGL_CMD_RCR_SRC_H 12
#define VIRGL_CMD_RCR_SRC_D 13

/* blit */
#define VIRGL_CMD_BLIT_SIZE 21
#define VIRGL_CMD_BLIT_S0 1
#define VIRGL_CMD_BLIT_S0_MASK(x) (((x)&0xff) << 0)
#define VIRGL_CMD_BLIT_S0_FILTER(x) (((x)&0x3) << 8)
#define VIRGL_CMD_BLIT_S0_SCISSOR_ENABLE(x) (((x)&0x1) << 10)
#define VIRGL_CMD_BLIT_S0_RENDER_CONDITION_ENABLE(x) (((x)&0x1) << 11)
#define VIRGL_CMD_BLIT_S0_ALPHA_BLEND(x) (((x)&0x1) << 12)
#define VIRGL_CMD_BLIT_SCISSOR_MINX_MINY 2
#define VIRGL_CMD_BLIT_SCISSOR_MAXX_MAXY 3
#define VIRGL_CMD_BLIT_DST_RES_HANDLE 4
#define VIRGL_CMD_BLIT_DST_LEVEL 5
#define VIRGL_CMD_BLIT_DST_FORMAT 6
#define VIRGL_CMD_BLIT_DST_X 7
#define VIRGL_CMD_BLIT_DST_Y 8
#define VIRGL_CMD_BLIT_DST_Z 9
#define VIRGL_CMD_BLIT_DST_W 10
#define VIRGL_CMD_BLIT_DST_H 11
#define VIRGL_CMD_BLIT_DST_D 12
#define VIRGL_CMD_BLIT_SRC_RES_HANDLE 13
#define VIRGL_CMD_BLIT_SRC_LEVEL 14
#define VIRGL_CMD_BLIT_SRC_FORMAT 15
#define VIRGL_CMD_BLIT_SRC_X 16
#define VIRGL_CMD_BLIT_SRC_Y 17
#define VIRGL_CMD_BLIT_SRC_Z 18
#define VIRGL_CMD_BLIT_SRC_W 19
#define VIRGL_CMD_BLIT_SRC_H 20
#define VIRGL_CMD_BLIT_SRC_D 21

/* query object */
#define VIRGL_OBJ_QUERY_SIZE 4
#define VIRGL_OBJ_QUERY_HANDLE 1
#define VIRGL_OBJ_QUERY_TYPE_INDEX 2
#define VIRGL_OBJ_QUERY_TYPE(x) (x & 0xffff)
#define VIRGL_OBJ_QUERY_INDEX(x) ((x & 0xffff) << 16)
#define VIRGL_OBJ_QUERY_OFFSET 3
#define VIRGL_OBJ_QUERY_RES_HANDLE 4

#define VIRGL_QUERY_BEGIN_HANDLE 1

#define VIRGL_QUERY_END_HANDLE 1

#define VIRGL_QUERY_RESULT_SIZE 2
#define VIRGL_QUERY_RESULT_HANDLE 1
#define VIRGL_QUERY_RESULT_WAIT 2

/* render condition */
#define VIRGL_RENDER_CONDITION_SIZE 3
#define VIRGL_RENDER_CONDITION_HANDLE 1
#define VIRGL_RENDER_CONDITION_CONDITION 2
#define VIRGL_RENDER_CONDITION_MODE 3

/* resource inline write */
#define VIRGL_RESOURCE_IW_RES_HANDLE 1
#define VIRGL_RESOURCE_IW_LEVEL 2
#define VIRGL_RESOURCE_IW_USAGE 3
#define VIRGL_RESOURCE_IW_STRIDE 4
#define VIRGL_RESOURCE_IW_LAYER_STRIDE 5
#define VIRGL_RESOURCE_IW_X 6
#define VIRGL_RESOURCE_IW_Y 7
#define VIRGL_RESOURCE_IW_Z 8
#define VIRGL_RESOURCE_IW_W 9
#define VIRGL_RESOURCE_IW_H 10
#define VIRGL_RESOURCE_IW_D 11
#define VIRGL_RESOURCE_IW_DATA_START 12

/* set streamout targets */
#define VIRGL_SET_STREAMOUT_TARGETS_APPEND_BITMASK 1
#define VIRGL_SET_STREAMOUT_TARGETS_H0 2

/* set sample mask */
#define VIRGL_SET_SAMPLE_MASK_SIZE 1
#define VIRGL_SET_SAMPLE_MASK_MASK 1

/* set clip state */
#define VIRGL_SET_CLIP_STATE_SIZE 32
#define VIRGL_SET_CLIP_STATE_C0 1

/* polygon stipple */
#define VIRGL_POLYGON_STIPPLE_SIZE 32
#define VIRGL_POLYGON_STIPPLE_P0 1

#define VIRGL_BIND_SHADER_SIZE 2
#define VIRGL_BIND_SHADER_HANDLE 1
#define VIRGL_BIND_SHADER_TYPE 2

/* tess state */
#define VIRGL_TESS_STATE_SIZE 6

/* set min samples */
#define VIRGL_SET_MIN_SAMPLES_SIZE 1
#define VIRGL_SET_MIN_SAMPLES_MASK 1

/* set shader buffers */
#define VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE 3
#define VIRGL_SET_SHADER_BUFFER_SIZE(x) \
  (VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE * (x)) + 2
#define VIRGL_SET_SHADER_BUFFER_SHADER_TYPE 1
#define VIRGL_SET_SHADER_BUFFER_START_SLOT 2
#define VIRGL_SET_SHADER_BUFFER_OFFSET(x) \
  ((x)*VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE + 3)
#define VIRGL_SET_SHADER_BUFFER_LENGTH(x) \
  ((x)*VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE + 4)
#define VIRGL_SET_SHADER_BUFFER_RES_HANDLE(x) \
  ((x)*VIRGL_SET_SHADER_BUFFER_ELEMENT_SIZE + 5)

/* set shader images */
#define VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE 5
#define VIRGL_SET_SHADER_IMAGE_SIZE(x) \
  (VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE * (x)) + 2
#define VIRGL_SET_SHADER_IMAGE_SHADER_TYPE 1
#define VIRGL_SET_SHADER_IMAGE_START_SLOT 2
#define VIRGL_SET_SHADER_IMAGE_FORMAT(x) \
  ((x)*VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE + 3)
#define VIRGL_SET_SHADER_IMAGE_ACCESS(x) \
  ((x)*VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE + 4)
#define VIRGL_SET_SHADER_IMAGE_LAYER_OFFSET(x) \
  ((x)*VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE + 5)
#define VIRGL_SET_SHADER_IMAGE_LEVEL_SIZE(x) \
  ((x)*VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE + 6)
#define VIRGL_SET_SHADER_IMAGE_RES_HANDLE(x) \
  ((x)*VIRGL_SET_SHADER_IMAGE_ELEMENT_SIZE + 7)

/* memory barrier */
#define VIRGL_MEMORY_BARRIER_SIZE 1
#define VIRGL_MEMORY_BARRIER_FLAGS 1

/* launch grid */
#define VIRGL_LAUNCH_GRID_SIZE 8
#define VIRGL_LAUNCH_BLOCK_X 1
#define VIRGL_LAUNCH_BLOCK_Y 2
#define VIRGL_LAUNCH_BLOCK_Z 3
#define VIRGL_LAUNCH_GRID_X 4
#define VIRGL_LAUNCH_GRID_Y 5
#define VIRGL_LAUNCH_GRID_Z 6
#define VIRGL_LAUNCH_INDIRECT_HANDLE 7
#define VIRGL_LAUNCH_INDIRECT_OFFSET 8

/* framebuffer state no attachment */
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_SIZE 2
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_WIDTH_HEIGHT 1
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_WIDTH(x) (x & 0xffff)
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_HEIGHT(x) ((x >> 16) & 0xffff)
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_LAYERS_SAMPLES 2
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_LAYERS(x) (x & 0xffff)
#define VIRGL_SET_FRAMEBUFFER_STATE_NO_ATTACH_SAMPLES(x) ((x >> 16) & 0xff)

/* texture barrier */
#define VIRGL_TEXTURE_BARRIER_SIZE 1
#define VIRGL_TEXTURE_BARRIER_FLAGS 1

/* hw atomics */
#define VIRGL_SET_ATOMIC_BUFFER_ELEMENT_SIZE 3
#define VIRGL_SET_ATOMIC_BUFFER_SIZE(x) \
  (VIRGL_SET_ATOMIC_BUFFER_ELEMENT_SIZE * (x)) + 1
#define VIRGL_SET_ATOMIC_BUFFER_START_SLOT 1
#define VIRGL_SET_ATOMIC_BUFFER_OFFSET(x) \
  ((x)*VIRGL_SET_ATOMIC_BUFFER_ELEMENT_SIZE + 2)
#define VIRGL_SET_ATOMIC_BUFFER_LENGTH(x) \
  ((x)*VIRGL_SET_ATOMIC_BUFFER_ELEMENT_SIZE + 3)
#define VIRGL_SET_ATOMIC_BUFFER_RES_HANDLE(x) \
  ((x)*VIRGL_SET_ATOMIC_BUFFER_ELEMENT_SIZE + 4)

/* set debug flags */
#define VIRGL_SET_DEBUG_FLAGS_MIN_SIZE 2
#define VIRGL_SET_DEBUG_FLAGSTRING_OFFSET 1

/* query buffer object */
#define VIRGL_QUERY_RESULT_QBO_SIZE 6
#define VIRGL_QUERY_RESULT_QBO_HANDLE 1
#define VIRGL_QUERY_RESULT_QBO_QBO_HANDLE 2
#define VIRGL_QUERY_RESULT_QBO_WAIT 3
#define VIRGL_QUERY_RESULT_QBO_RESULT_TYPE 4
#define VIRGL_QUERY_RESULT_QBO_OFFSET 5
#define VIRGL_QUERY_RESULT_QBO_INDEX 6

#define VIRGL_TRANSFER_TO_HOST 1
#define VIRGL_TRANSFER_FROM_HOST 2

/* Transfer */
#define VIRGL_TRANSFER3D_SIZE 13
/* The first 11 dwords are the same as VIRGL_RESOURCE_IW_*  */
#define VIRGL_TRANSFER3D_DATA_OFFSET 12
#define VIRGL_TRANSFER3D_DIRECTION 13

/* Copy transfer to host and from host*/
#define VIRGL_COPY_TRANSFER3D_SIZE 14
/* The first 11 dwords are the same as VIRGL_RESOURCE_IW_*  */
#define VIRGL_COPY_TRANSFER3D_SRC_RES_HANDLE 12
#define VIRGL_COPY_TRANSFER3D_SRC_RES_OFFSET 13
#define VIRGL_COPY_TRANSFER3D_FLAGS 14
#define VIRGL_COPY_TRANSFER3D_FLAGS_SYNCHRONIZED (1 << 0)
/* 1 << 1 means transfer from host.
   0 << 1 means transfer to host.*/
#define VIRGL_COPY_TRANSFER3D_FLAGS_READ_FROM_HOST (1 << 1)

/* set tweak flags */
#define VIRGL_SET_TWEAKS_SIZE 2
#define VIRGL_SET_TWEAKS_ID 1
#define VIRGL_SET_TWEAKS_VALUE 2

enum vrend_tweak_type {
  virgl_tweak_gles_brga_emulate,
  virgl_tweak_gles_brga_apply_dest_swizzle,
  virgl_tweak_gles_tf3_samples_passes_multiplier,
  virgl_tweak_undefined
};

/* Clear texture */
#define VIRGL_CLEAR_TEXTURE_SIZE 12
#define VIRGL_TEXTURE_HANDLE 1
#define VIRGL_TEXTURE_LEVEL 2
#define VIRGL_TEXTURE_SRC_X 3
#define VIRGL_TEXTURE_SRC_Y 4
#define VIRGL_TEXTURE_SRC_Z 5
#define VIRGL_TEXTURE_SRC_W 6
#define VIRGL_TEXTURE_SRC_H 7
#define VIRGL_TEXTURE_SRC_D 8
#define VIRGL_TEXTURE_ARRAY_A 9
#define VIRGL_TEXTURE_ARRAY_B 10
#define VIRGL_TEXTURE_ARRAY_C 11
#define VIRGL_TEXTURE_ARRAY_D 12

/* virgl create */
#define VIRGL_PIPE_RES_CREATE_SIZE 11
#define VIRGL_PIPE_RES_CREATE_TARGET 1
#define VIRGL_PIPE_RES_CREATE_FORMAT 2
#define VIRGL_PIPE_RES_CREATE_BIND 3
#define VIRGL_PIPE_RES_CREATE_WIDTH 4
#define VIRGL_PIPE_RES_CREATE_HEIGHT 5
#define VIRGL_PIPE_RES_CREATE_DEPTH 6
#define VIRGL_PIPE_RES_CREATE_ARRAY_SIZE 7
#define VIRGL_PIPE_RES_CREATE_LAST_LEVEL 8
#define VIRGL_PIPE_RES_CREATE_NR_SAMPLES 9
#define VIRGL_PIPE_RES_CREATE_FLAGS 10
#define VIRGL_PIPE_RES_CREATE_BLOB_ID 11

/* VIRGL_CCMD_PIPE_RESOURCE_SET_TYPE */
#define VIRGL_PIPE_RES_SET_TYPE_SIZE(nplanes) (8 + (nplanes)*2)
#define VIRGL_PIPE_RES_SET_TYPE_RES_HANDLE 1
#define VIRGL_PIPE_RES_SET_TYPE_FORMAT 2
#define VIRGL_PIPE_RES_SET_TYPE_BIND 3
#define VIRGL_PIPE_RES_SET_TYPE_WIDTH 4
#define VIRGL_PIPE_RES_SET_TYPE_HEIGHT 5
#define VIRGL_PIPE_RES_SET_TYPE_USAGE 6
#define VIRGL_PIPE_RES_SET_TYPE_MODIFIER_LO 7
#define VIRGL_PIPE_RES_SET_TYPE_MODIFIER_HI 8
#define VIRGL_PIPE_RES_SET_TYPE_PLANE_STRIDE(plane) (9 + (plane)*2)
#define VIRGL_PIPE_RES_SET_TYPE_PLANE_OFFSET(plane) (10 + (plane)*2)

/* send string marker */
#define VIRGL_SEND_STRING_MARKER_MIN_SIZE 2
#define VIRGL_SEND_STRING_MARKER_STRING_SIZE 1
#define VIRGL_SEND_STRING_MARKER_OFFSET 2

/* link shader program */
#define VIRGL_LINK_SHADER_SIZE 6
#define VIRGL_LINK_SHADER_VERTEX_HANDLE 1
#define VIRGL_LINK_SHADER_FRAGMENT_HANDLE 2
#define VIRGL_LINK_SHADER_GEOMETRY_HANDLE 3
#define VIRGL_LINK_SHADER_TESS_CTRL_HANDLE 4
#define VIRGL_LINK_SHADER_TESS_EVAL_HANDLE 5
#define VIRGL_LINK_SHADER_COMPUTE_HANDLE 6

/* VIRGL_CCMD_CREATE_VIDEO_CODEC */
#define VIRGL_CREATE_VIDEO_CODEC_MIN_SIZE 7
#define VIRGL_CREATE_VIDEO_CODEC_HANDLE 1
#define VIRGL_CREATE_VIDEO_CODEC_PROFILE 2
#define VIRGL_CREATE_VIDEO_CODEC_ENTRYPOINT 3
#define VIRGL_CREATE_VIDEO_CODEC_CHROMA_FMT 4
#define VIRGL_CREATE_VIDEO_CODEC_LEVEL 5
#define VIRGL_CREATE_VIDEO_CODEC_WIDTH 6
#define VIRGL_CREATE_VIDEO_CODEC_HEIGHT 7
#define VIRGL_CREATE_VIDEO_CODEC_MAX_REF 8

/* VIRGL_CCMD_DESTROY_VIDEO_CODEC */
#define VIRGL_DESTROY_VIDEO_CODEC_MIN_SIZE 1
#define VIRGL_DESTROY_VIDEO_CODEC_HANDLE 1

/* VIRGL_CCMD_CREATE_VIDEO_BUFFER */
#define VIRGL_CREATE_VIDEO_BUFFER_MIN_SIZE 5
#define VIRGL_CREATE_VIDEO_BUFFER_HANDLE 1
#define VIRGL_CREATE_VIDEO_BUFFER_FORMAT 2
#define VIRGL_CREATE_VIDEO_BUFFER_WIDTH 3
#define VIRGL_CREATE_VIDEO_BUFFER_HEIGHT 4
#define VIRGL_CREATE_VIDEO_BUFFER_RES_BASE 5

/* VIRGL_CCMD_DESTROY_VIDEO_BUFFER */
#define VIRGL_DESTROY_VIDEO_BUFFER_MIN_SIZE 1
#define VIRGL_DESTROY_VIDEO_BUFFER_HANDLE 1

/* VIRGL_CCMD_BEGIN_FRAME */
#define VIRGL_BEGIN_FRAME_MIN_SIZE 2
#define VIRGL_BEGIN_FRAME_CDC_HANDLE 1
#define VIRGL_BEGIN_FRAME_TGT_HANDLE 2

/* VIRGL_CCMD_DECODE_MACROBLOCK */

/* VIRGL_CCMD_DECODE_BITSTREAM */
#define VIRGL_DECODE_BS_MIN_SIZE 5
#define VIRGL_DECODE_BS_CDC_HANDLE 1
#define VIRGL_DECODE_BS_TGT_HANDLE 2
#define VIRGL_DECODE_BS_DSC_HANDLE 3
#define VIRGL_DECODE_BS_BUF_HANDLE 4
#define VIRGL_DECODE_BS_BUF_SIZE 5

/* VIRGL_CCMD_ENCODE_BITSTREAM */
#define VIRGL_ENCODE_BS_MIN_SIZE 5
#define VIRGL_ENCODE_BS_CDC_HANDLE 1
#define VIRGL_ENCODE_BS_SRC_HANDLE 2
#define VIRGL_ENCODE_BS_DEST_HANDLE 3
#define VIRGL_ENCODE_BS_DESC_HANDLE 4
#define VIRGL_ENCODE_BS_FEED_HANDLE 5

/* VIRGL_CCMD_END_FRAME */
#define VIRGL_END_FRAME_MIN_SIZE 2
#define VIRGL_END_FRAME_CDC_HANDLE 1
#define VIRGL_END_FRAME_TGT_HANDLE 2

#endif

```

`include/linuz/virtio_blk.h`:

```h
#ifndef _LINUX_VIRTIO_BLK_H
#define _LINUX_VIRTIO_BLK_H
/* This header is BSD licensed so anyone can use the definitions to implement
 * compatible drivers/servers.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of IBM nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE. */
#include <linux/types.h>
#include <linux/virtio_ids.h>
#include <linux/virtio_config.h>
#include <linux/virtio_types.h>

/* Feature bits */
#define VIRTIO_BLK_F_SIZE_MAX	1	/* Indicates maximum segment size */
#define VIRTIO_BLK_F_SEG_MAX	2	/* Indicates maximum # of segments */
#define VIRTIO_BLK_F_GEOMETRY	4	/* Legacy geometry available  */
#define VIRTIO_BLK_F_RO		5	/* Disk is read-only */
#define VIRTIO_BLK_F_BLK_SIZE	6	/* Block size of disk is available*/
#define VIRTIO_BLK_F_TOPOLOGY	10	/* Topology information is available */
#define VIRTIO_BLK_F_MQ		12	/* support more than one vq */
#define VIRTIO_BLK_F_DISCARD	13	/* DISCARD is supported */
#define VIRTIO_BLK_F_WRITE_ZEROES	14	/* WRITE ZEROES is supported */

/* Legacy feature bits */
#ifndef VIRTIO_BLK_NO_LEGACY
#define VIRTIO_BLK_F_BARRIER	0	/* Does host support barriers? */
#define VIRTIO_BLK_F_SCSI	7	/* Supports scsi command passthru */
#define VIRTIO_BLK_F_FLUSH	9	/* Flush command supported */
#define VIRTIO_BLK_F_CONFIG_WCE	11	/* Writeback mode available in config */
/* Old (deprecated) name for VIRTIO_BLK_F_FLUSH. */
#define VIRTIO_BLK_F_WCE VIRTIO_BLK_F_FLUSH
#endif /* !VIRTIO_BLK_NO_LEGACY */

#define VIRTIO_BLK_ID_BYTES	20	/* ID string length */

struct virtio_blk_config {
	/* The capacity (in 512-byte sectors). */
	__u64 capacity;
	/* The maximum segment size (if VIRTIO_BLK_F_SIZE_MAX) */
	__u32 size_max;
	/* The maximum number of segments (if VIRTIO_BLK_F_SEG_MAX) */
	__u32 seg_max;
	/* geometry of the device (if VIRTIO_BLK_F_GEOMETRY) */
	struct virtio_blk_geometry {
		__u16 cylinders;
		__u8 heads;
		__u8 sectors;
	} geometry;

	/* block size of device (if VIRTIO_BLK_F_BLK_SIZE) */
	__u32 blk_size;

	/* the next 4 entries are guarded by VIRTIO_BLK_F_TOPOLOGY  */
	/* exponent for physical block per logical block. */
	__u8 physical_block_exp;
	/* alignment offset in logical blocks. */
	__u8 alignment_offset;
	/* minimum I/O size without performance penalty in logical blocks. */
	__u16 min_io_size;
	/* optimal sustained I/O size in logical blocks. */
	__u32 opt_io_size;

	/* writeback mode (if VIRTIO_BLK_F_CONFIG_WCE) */
	__u8 wce;
	__u8 unused;

	/* number of vqs, only available when VIRTIO_BLK_F_MQ is set */
	__u16 num_queues;

	/* the next 3 entries are guarded by VIRTIO_BLK_F_DISCARD */
	/*
	 * The maximum discard sectors (in 512-byte sectors) for
	 * one segment.
	 */
	__u32 max_discard_sectors;
	/*
	 * The maximum number of discard segments in a
	 * discard command.
	 */
	__u32 max_discard_seg;
	/* Discard commands must be aligned to this number of sectors. */
	__u32 discard_sector_alignment;

	/* the next 3 entries are guarded by VIRTIO_BLK_F_WRITE_ZEROES */
	/*
	 * The maximum number of write zeroes sectors (in 512-byte sectors) in
	 * one segment.
	 */
	__u32 max_write_zeroes_sectors;
	/*
	 * The maximum number of segments in a write zeroes
	 * command.
	 */
	__u32 max_write_zeroes_seg;
	/*
	 * Set if a VIRTIO_BLK_T_WRITE_ZEROES request may result in the
	 * deallocation of one or more of the sectors.
	 */
	__u8 write_zeroes_may_unmap;

	__u8 unused1[3];
} __attribute__((packed));

/*
 * Command types
 *
 * Usage is a bit tricky as some bits are used as flags and some are not.
 *
 * Rules:
 *   VIRTIO_BLK_T_OUT may be combined with VIRTIO_BLK_T_SCSI_CMD or
 *   VIRTIO_BLK_T_BARRIER.  VIRTIO_BLK_T_FLUSH is a command of its own
 *   and may not be combined with any of the other flags.
 */

/* These two define direction. */
#define VIRTIO_BLK_T_IN		0
#define VIRTIO_BLK_T_OUT	1

#ifndef VIRTIO_BLK_NO_LEGACY
/* This bit says it's a scsi command, not an actual read or write. */
#define VIRTIO_BLK_T_SCSI_CMD	2
#endif /* VIRTIO_BLK_NO_LEGACY */

/* Cache flush command */
#define VIRTIO_BLK_T_FLUSH	4

/* Get device ID command */
#define VIRTIO_BLK_T_GET_ID    8

/* Discard command */
#define VIRTIO_BLK_T_DISCARD	11

/* Write zeroes command */
#define VIRTIO_BLK_T_WRITE_ZEROES	13

#ifndef VIRTIO_BLK_NO_LEGACY
/* Barrier before this op. */
#define VIRTIO_BLK_T_BARRIER	0x80000000
#endif /* !VIRTIO_BLK_NO_LEGACY */

/*
 * This comes first in the read scatter-gather list.
 * For legacy virtio, if VIRTIO_F_ANY_LAYOUT is not negotiated,
 * this is the first element of the read scatter-gather list.
 */
struct virtio_blk_outhdr {
	/* VIRTIO_BLK_T* */
	__virtio32 type;
	/* io priority. */
	__virtio32 ioprio;
	/* Sector (ie. 512 byte offset) */
	__virtio64 sector;
};

/* Unmap this range (only valid for write zeroes command) */
#define VIRTIO_BLK_WRITE_ZEROES_FLAG_UNMAP	0x00000001

/* Discard/write zeroes range for each request. */
struct virtio_blk_discard_write_zeroes {
	/* discard/write zeroes start sector */
	__le64 sector;
	/* number of discard/write zeroes sectors */
	__le32 num_sectors;
	/* flags for this range */
	__le32 flags;
};

#ifndef VIRTIO_BLK_NO_LEGACY
struct virtio_scsi_inhdr {
	__virtio32 errors;
	__virtio32 data_len;
	__virtio32 sense_len;
	__virtio32 residual;
};
#endif /* !VIRTIO_BLK_NO_LEGACY */

/* And this is the final byte of the write scatter-gather list. */
#define VIRTIO_BLK_S_OK		0
#define VIRTIO_BLK_S_IOERR	1
#define VIRTIO_BLK_S_UNSUPP	2
#endif /* _LINUX_VIRTIO_BLK_H */

```

`include/linuz/virtio_net.h`:

```h
#ifndef _LINUX_VIRTIO_NET_H
#define _LINUX_VIRTIO_NET_H
/* This header is BSD licensed so anyone can use the definitions to implement
 * compatible drivers/servers.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of IBM nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL IBM OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE. */
#include <linux/types.h>
#include <linux/virtio_ids.h>
#include <linux/virtio_config.h>
#include <linux/virtio_types.h>
#include <linux/if_ether.h>

/* The feature bitmap for virtio net */
#define VIRTIO_NET_F_CSUM	0	/* Host handles pkts w/ partial csum */
#define VIRTIO_NET_F_GUEST_CSUM	1	/* Guest handles pkts w/ partial csum */
#define VIRTIO_NET_F_CTRL_GUEST_OFFLOADS 2 /* Dynamic offload configuration. */
#define VIRTIO_NET_F_MTU	3	/* Initial MTU advice */
#define VIRTIO_NET_F_MAC	5	/* Host has given MAC address. */
#define VIRTIO_NET_F_GUEST_TSO4	7	/* Guest can handle TSOv4 in. */
#define VIRTIO_NET_F_GUEST_TSO6	8	/* Guest can handle TSOv6 in. */
#define VIRTIO_NET_F_GUEST_ECN	9	/* Guest can handle TSO[6] w/ ECN in. */
#define VIRTIO_NET_F_GUEST_UFO	10	/* Guest can handle UFO in. */
#define VIRTIO_NET_F_HOST_TSO4	11	/* Host can handle TSOv4 in. */
#define VIRTIO_NET_F_HOST_TSO6	12	/* Host can handle TSOv6 in. */
#define VIRTIO_NET_F_HOST_ECN	13	/* Host can handle TSO[6] w/ ECN in. */
#define VIRTIO_NET_F_HOST_UFO	14	/* Host can handle UFO in. */
#define VIRTIO_NET_F_MRG_RXBUF	15	/* Host can merge receive buffers. */
#define VIRTIO_NET_F_STATUS	16	/* virtio_net_config.status available */
#define VIRTIO_NET_F_CTRL_VQ	17	/* Control channel available */
#define VIRTIO_NET_F_CTRL_RX	18	/* Control channel RX mode support */
#define VIRTIO_NET_F_CTRL_VLAN	19	/* Control channel VLAN filtering */
#define VIRTIO_NET_F_CTRL_RX_EXTRA 20	/* Extra RX mode control support */
#define VIRTIO_NET_F_GUEST_ANNOUNCE 21	/* Guest can announce device on the
					 * network */
#define VIRTIO_NET_F_MQ	22	/* Device supports Receive Flow
					 * Steering */
#define VIRTIO_NET_F_CTRL_MAC_ADDR 23	/* Set MAC address */

#define VIRTIO_NET_F_STANDBY	  62	/* Act as standby for another device
					 * with the same MAC.
					 */
#define VIRTIO_NET_F_SPEED_DUPLEX 63	/* Device set linkspeed and duplex */

#ifndef VIRTIO_NET_NO_LEGACY
#define VIRTIO_NET_F_GSO	6	/* Host handles pkts w/ any GSO type */
#endif /* VIRTIO_NET_NO_LEGACY */

#define VIRTIO_NET_S_LINK_UP	1	/* Link is up */
#define VIRTIO_NET_S_ANNOUNCE	2	/* Announcement is needed */

struct virtio_net_config {
	/* The config defining mac address (if VIRTIO_NET_F_MAC) */
	__u8 mac[ETH_ALEN];
	/* See VIRTIO_NET_F_STATUS and VIRTIO_NET_S_* above */
	__u16 status;
	/* Maximum number of each of transmit and receive queues;
	 * see VIRTIO_NET_F_MQ and VIRTIO_NET_CTRL_MQ.
	 * Legal values are between 1 and 0x8000
	 */
	__u16 max_virtqueue_pairs;
	/* Default maximum transmit unit advice */
	__u16 mtu;
	/*
	 * speed, in units of 1Mb. All values 0 to INT_MAX are legal.
	 * Any other value stands for unknown.
	 */
	__u32 speed;
	/*
	 * 0x00 - half duplex
	 * 0x01 - full duplex
	 * Any other value stands for unknown.
	 */
	__u8 duplex;
} __attribute__((packed));

/*
 * This header comes first in the scatter-gather list.  If you don't
 * specify GSO or CSUM features, you can simply ignore the header.
 *
 * This is bitwise-equivalent to the legacy struct virtio_net_hdr_mrg_rxbuf,
 * only flattened.
 */
struct virtio_net_hdr_v1 {
#define VIRTIO_NET_HDR_F_NEEDS_CSUM	1	/* Use csum_start, csum_offset */
#define VIRTIO_NET_HDR_F_DATA_VALID	2	/* Csum is valid */
	__u8 flags;
#define VIRTIO_NET_HDR_GSO_NONE		0	/* Not a GSO frame */
#define VIRTIO_NET_HDR_GSO_TCPV4	1	/* GSO frame, IPv4 TCP (TSO) */
#define VIRTIO_NET_HDR_GSO_UDP		3	/* GSO frame, IPv4 UDP (UFO) */
#define VIRTIO_NET_HDR_GSO_TCPV6	4	/* GSO frame, IPv6 TCP */
#define VIRTIO_NET_HDR_GSO_ECN		0x80	/* TCP has ECN set */
	__u8 gso_type;
	__virtio16 hdr_len;	/* Ethernet + IP + tcp/udp hdrs */
	__virtio16 gso_size;	/* Bytes to append to hdr_len per frame */
	__virtio16 csum_start;	/* Position to start checksumming from */
	__virtio16 csum_offset;	/* Offset after that to place checksum */
	__virtio16 num_buffers;	/* Number of merged rx buffers */
};

#ifndef VIRTIO_NET_NO_LEGACY
/* This header comes first in the scatter-gather list.
 * For legacy virtio, if VIRTIO_F_ANY_LAYOUT is not negotiated, it must
 * be the first element of the scatter-gather list.  If you don't
 * specify GSO or CSUM features, you can simply ignore the header. */
struct virtio_net_hdr {
	/* See VIRTIO_NET_HDR_F_* */
	__u8 flags;
	/* See VIRTIO_NET_HDR_GSO_* */
	__u8 gso_type;
	__virtio16 hdr_len;		/* Ethernet + IP + tcp/udp hdrs */
	__virtio16 gso_size;		/* Bytes to append to hdr_len per frame */
	__virtio16 csum_start;	/* Position to start checksumming from */
	__virtio16 csum_offset;	/* Offset after that to place checksum */
};

/* This is the version of the header to use when the MRG_RXBUF
 * feature has been negotiated. */
struct virtio_net_hdr_mrg_rxbuf {
	struct virtio_net_hdr hdr;
	__virtio16 num_buffers;	/* Number of merged rx buffers */
};
#endif /* ...VIRTIO_NET_NO_LEGACY */

/*
 * Control virtqueue data structures
 *
 * The control virtqueue expects a header in the first sg entry
 * and an ack/status response in the last entry.  Data for the
 * command goes in between.
 */
struct virtio_net_ctrl_hdr {
	__u8 cls;
	__u8 cmd;
} __attribute__((packed));

typedef __u8 virtio_net_ctrl_ack;

#define VIRTIO_NET_OK     0
#define VIRTIO_NET_ERR    1

/*
 * Control the RX mode, ie. promisucous, allmulti, etc...
 * All commands require an "out" sg entry containing a 1 byte
 * state value, zero = disable, non-zero = enable.  Commands
 * 0 and 1 are supported with the VIRTIO_NET_F_CTRL_RX feature.
 * Commands 2-5 are added with VIRTIO_NET_F_CTRL_RX_EXTRA.
 */
#define VIRTIO_NET_CTRL_RX    0
 #define VIRTIO_NET_CTRL_RX_PROMISC      0
 #define VIRTIO_NET_CTRL_RX_ALLMULTI     1
 #define VIRTIO_NET_CTRL_RX_ALLUNI       2
 #define VIRTIO_NET_CTRL_RX_NOMULTI      3
 #define VIRTIO_NET_CTRL_RX_NOUNI        4
 #define VIRTIO_NET_CTRL_RX_NOBCAST      5

/*
 * Control the MAC
 *
 * The MAC filter table is managed by the hypervisor, the guest should
 * assume the size is infinite.  Filtering should be considered
 * non-perfect, ie. based on hypervisor resources, the guest may
 * received packets from sources not specified in the filter list.
 *
 * In addition to the class/cmd header, the TABLE_SET command requires
 * two out scatterlists.  Each contains a 4 byte count of entries followed
 * by a concatenated byte stream of the ETH_ALEN MAC addresses.  The
 * first sg list contains unicast addresses, the second is for multicast.
 * This functionality is present if the VIRTIO_NET_F_CTRL_RX feature
 * is available.
 *
 * The ADDR_SET command requests one out scatterlist, it contains a
 * 6 bytes MAC address. This functionality is present if the
 * VIRTIO_NET_F_CTRL_MAC_ADDR feature is available.
 */
struct virtio_net_ctrl_mac {
	__virtio32 entries;
	__u8 macs[][ETH_ALEN];
} __attribute__((packed));

#define VIRTIO_NET_CTRL_MAC    1
 #define VIRTIO_NET_CTRL_MAC_TABLE_SET        0
 #define VIRTIO_NET_CTRL_MAC_ADDR_SET         1

/*
 * Control VLAN filtering
 *
 * The VLAN filter table is controlled via a simple ADD/DEL interface.
 * VLAN IDs not added may be filterd by the hypervisor.  Del is the
 * opposite of add.  Both commands expect an out entry containing a 2
 * byte VLAN ID.  VLAN filterting is available with the
 * VIRTIO_NET_F_CTRL_VLAN feature bit.
 */
#define VIRTIO_NET_CTRL_VLAN       2
 #define VIRTIO_NET_CTRL_VLAN_ADD             0
 #define VIRTIO_NET_CTRL_VLAN_DEL             1

/*
 * Control link announce acknowledgement
 *
 * The command VIRTIO_NET_CTRL_ANNOUNCE_ACK is used to indicate that
 * driver has recevied the notification; device would clear the
 * VIRTIO_NET_S_ANNOUNCE bit in the status field after it receives
 * this command.
 */
#define VIRTIO_NET_CTRL_ANNOUNCE       3
 #define VIRTIO_NET_CTRL_ANNOUNCE_ACK         0

/*
 * Control Receive Flow Steering
 *
 * The command VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET
 * enables Receive Flow Steering, specifying the number of the transmit and
 * receive queues that will be used. After the command is consumed and acked by
 * the device, the device will not steer new packets on receive virtqueues
 * other than specified nor read from transmit virtqueues other than specified.
 * Accordingly, driver should not transmit new packets  on virtqueues other than
 * specified.
 */
struct virtio_net_ctrl_mq {
	__virtio16 virtqueue_pairs;
};

#define VIRTIO_NET_CTRL_MQ   4
 #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_SET        0
 #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MIN        1
 #define VIRTIO_NET_CTRL_MQ_VQ_PAIRS_MAX        0x8000

/*
 * Control network offloads
 *
 * Reconfigures the network offloads that Guest can handle.
 *
 * Available with the VIRTIO_NET_F_CTRL_GUEST_OFFLOADS feature bit.
 *
 * Command data format matches the feature bit mask exactly.
 *
 * See VIRTIO_NET_F_GUEST_* for the list of offloads
 * that can be enabled/disabled.
 */
#define VIRTIO_NET_CTRL_GUEST_OFFLOADS   5
#define VIRTIO_NET_CTRL_GUEST_OFFLOADS_SET        0

#endif /* _LINUX_VIRTIO_NET_H */

```

`include/logger.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MVISOR_LOGGER_H
#define MVISOR_LOGGER_H

#include <stddef.h>

enum LogType {
  kLogTypeDebug,
  kLogTypeWarn,
  kLogTypeError,
  kLogTypePanic
};

#define MV_UNUSED(x) (void)(x)
#define MV_LOG(fmt, ...) Log(kLogTypeDebug, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
#define MV_WARN(fmt, ...) Log(kLogTypeWarn, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
#define MV_ERROR(fmt, ...) Log(kLogTypeError, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
#define MV_PANIC(fmt, ...) Log(kLogTypePanic, __FILE__, __LINE__, __func__, fmt, ##__VA_ARGS__)
#define MV_ASSERT(condition) \
  (__builtin_expect(!!(condition), 1) ? (void)0 : MV_PANIC("Assertion failed, "#condition))

#define MV_HEXDUMP(description, data, size) Log(kLogTypeDebug, __FILE__, __LINE__, __func__, description); \
  DumpHex(data, size);

void Log(LogType type, const char* file, int line, const char* function, const char* format, ...);
void SaveToFile(const char* path, void* data, size_t size);
void DumpHex(const void* data, size_t size);
void PrintRegisters(struct kvm_regs& regs, struct kvm_sregs& sregs);
void SetThreadName(const char* name);

#endif // MVISOR_LOGGER_H

```

`include/lru_cache.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

/*
 * Reference: https://blog.csdn.net/gaixm/article/details/104662991/
 *
 */

#ifndef _MVISOR_LRU_CACHE_H
#define _MVISOR_LRU_CACHE_H

#include <map>
#include <list>
#include <functional>
#include <memory>

template<typename TKey, typename TValue>
class SimpleLRUCache
{
private:
  size_t m_iMaxSize;
  std::list<TKey> m_listLru;
  
  typedef std::pair<typename std::list<TKey>::iterator, TValue> MPair;
  typedef std::shared_ptr<MPair> PairPtr;
  std::map<TKey, PairPtr> m_mapPair;
  std::function<void (TKey&, TValue&)> m_removeCallback;
 
public:
  const std::list<TKey>& list() const { return m_listLru; }
  const std::map<TKey, PairPtr>& map() const { return m_mapPair; }

  SimpleLRUCache(size_t iMaxSize = 128)
  {
    m_iMaxSize = iMaxSize;
  }

  void Initialize(size_t iMaxSize, std::function<void (TKey&, TValue&)> cb) {
    m_iMaxSize = iMaxSize;
    m_removeCallback = cb;
  }

  void Clear() {
    while (m_listLru.begin() != m_listLru.end()) {
      auto key = *m_listLru.begin();
      Remove(key);
    }
  }
 
  bool Contains(TKey& szKey)
  {
    auto iterFind = m_mapPair.find(szKey);
    if (iterFind == m_mapPair.end())
      return false;
    return true;
  }
 
  bool Get(TKey& szKey, TValue &rValue)
  {
    auto iterFind = m_mapPair.find(szKey);
    if (iterFind == m_mapPair.end())
      return false;
 
    rValue = iterFind->second->second;
 
    auto iterList = iterFind->second->first;
    m_listLru.erase(iterList);
    m_listLru.push_front(iterFind->first);
    iterFind->second->first = m_listLru.begin();
 
    return true;
  }
 
  bool Put(TKey& szKey, TValue& szValue)
  {
    if (Contains(szKey))
      return false;
 
    m_listLru.push_front(szKey);
    auto iterFront = m_listLru.begin();
    PairPtr pairPtr = std::make_shared<MPair>(iterFront, szValue);
    m_mapPair.insert(std::make_pair(szKey, pairPtr));
 
    if (m_listLru.size() > m_iMaxSize)
    {
      auto myKey = m_listLru.back();
      Remove(myKey);
    }
 
    return true;
  }
 
  bool Remove(TKey &szKey)
  {
    auto iterFind = m_mapPair.find(szKey);
    if (iterFind == m_mapPair.end())
      return false;
    
    if (m_removeCallback) {
      m_removeCallback(szKey, iterFind->second->second);
    }
    auto iterList = iterFind->second->first;
    m_listLru.erase(iterList);
    m_mapPair.erase(iterFind);
 
    return true;
  }
};


#endif // _MVISOR_LRU_CACHE_H

```

`include/machine.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef MVISOR_MACHINE_H
#define MVISOR_MACHINE_H

#define PAGE_SIZE 4096
#define ALIGN(x, y)  (((x)+(y)-1) & ~((y)-1))

#include <string>
#include <thread>
#include <vector>
#include <set>
#include <mutex>
#include <condition_variable>
#include <map>
#include <signal.h>
#include "object.h"
#include "vcpu.h"
#include "io_thread.h"
#include "memory_manager.h"
#include "device_manager.h"
#include "configuration.h"

struct StateChangeListener {
  VoidCallback callback;
};


/* The Machine class handles all the VM initialization and common operations
 * such as startup, quit, pause, resume */
class Machine {
 public:
  Machine(std::string config_path);
  ~Machine();

  void Quit();
  void Reset();
  void Pause();
  void Resume();
  void Shutdown();
  bool IsValid() { return valid_; }
  bool IsPaused() { return valid_ && paused_; }
  void WaitToResume();
  void Save(const std::string path);
  void Load(const std::string path);
  const char* GetStatus();

  bool Save(const std::string ip, const uint16_t port);
  bool PostSave();
  void Load(uint16_t port);

  Object* LookupObjectByName(std::string name);
  Object* LookupObjectByClass(std::string class_name);
  std::vector<Object*> LookupObjects(std::function<bool (Object*)> compare);
  const StateChangeListener* RegisterStateChangeListener(VoidCallback callback);
  void UnregisterStateChangeListener(const StateChangeListener** plistener);

  inline DeviceManager* device_manager() { return device_manager_; }
  inline MemoryManager* memory_manager() { return memory_manager_; }
  inline const Configuration* configuration() { return config_; }
  inline int num_vcpus() { return num_vcpus_; }
  inline uint64_t ram_size() { return ram_size_; }
  inline bool debug() { return debug_; }
  inline bool hypervisor() { return hypervisor_; }
  inline const std::string& guest_os() const { return guest_os_; }
  inline const std::string& vm_name() const { return vm_name_; }
  inline const std::string& vm_uuid() const { return vm_uuid_; }
  inline void set_guest_os(std::string os) { guest_os_ = os; }
  inline void set_vm_name(std::string name) { vm_name_ = name; }
  inline void set_vm_uuid(std::string uuid) { vm_uuid_ = uuid; }

  inline Vcpu* first_vcpu() { return vcpus_.size() ? vcpus_[0] : nullptr; }
  inline std::vector<Vcpu*> vcpus() { return vcpus_; }
  inline int kvm_fd() { return kvm_fd_; }
  inline int vm_fd() { return vm_fd_; }

 private:
  friend class IoThread;
  friend class Vcpu;
  friend class MemoryManager;
  friend class DeviceManager;
  friend class Configuration;

  void InitializeKvm();
  bool PrepareForSaving();

  bool valid_ = true;
  bool paused_ = true;
  bool pausing_ = false;
  bool loading_ = false;
  bool saving_ = false;

  int kvm_fd_ = -1;
  int kvm_vcpu_mmap_size_ = 0;
  int vm_fd_ = -1;
  
  uint64_t ram_size_ = 0;
  int num_vcpus_ = 0;
  int vcpu_priority_ = 1;
  std::vector<Vcpu*> vcpus_;
  MemoryManager* memory_manager_;
  DeviceManager* device_manager_;
  Configuration* config_;
  IoThread* io_thread_;
  MigrationNetworkWriter* network_writer_ = nullptr;

  std::map<std::string, Object*> objects_;
  bool debug_ = false;
  bool hypervisor_ = false;
  std::string guest_os_;
  std::string vm_name_;
  std::string vm_uuid_;

  std::mutex mutex_;
  std::condition_variable wait_to_resume_;
  std::condition_variable wait_to_pause_condition_;
  uint wait_count_ = 0;
  std::set<const StateChangeListener*> state_change_listeners_;
};

#endif // MVISOR_MACHINE_H

```

`include/memory_manager.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_MM_H
#define _MVISOR_MM_H

#include <map>
#include <set>
#include <vector>
#include <functional>
#include <shared_mutex>
#include <unordered_set>

#include "migration.h"


enum MemoryType {
  kMemoryTypeReserved = 0,
  kMemoryTypeRam = 1,
  kMemoryTypeDevice = 2,
  kMemoryTypeRom = 3
};

struct MemoryRegion {
  uint64_t      gpa;
  void*         host;
  uint64_t      size;
  uint32_t      flags;
  MemoryType    type;
  char          name[20];
};

struct MemorySlot {
  MemoryType    type;
  uint64_t      begin;
  uint64_t      end;
  uint32_t      id;
  uint64_t      hva;
  uint32_t      flags;
  MemoryRegion* region;
};

typedef std::function<void (const MemorySlot* slot, bool unmap)> MemoryListenerCallback;
struct MemoryListener {
  MemoryListenerCallback callback;
};

enum DirtyMemoryCommand {
  kGetDirtyMemoryBitmap = 0,
  kStopTrackingDirtyMemory = 1,
  kStartTrackingDirtyMemory = 2
};

enum DirtyMemoryType {
  kDirtyMemoryTypeKvm = 0,
  kDirtyMemoryTypeListener = 1,
  kDirtyMemoryTypeDma = 2
};

typedef std::function<std::vector<struct DirtyMemoryBitmap> (const DirtyMemoryCommand command)> DirtyMemoryListenerCallback;
struct DirtyMemoryListener {
  DirtyMemoryListenerCallback callback;
};

typedef std::function<bool (size_t offset)> DirtyBitmapCallback;

class Machine;
class MemoryManager {
 public:
  MemoryManager(const Machine* machine);
  ~MemoryManager();

  const MemoryRegion* Map(uint64_t gpa, uint64_t size, void* host, MemoryType type, const char* name);
  void Unmap(const MemoryRegion** region);
  void Reset();

  /* Used for migration */
  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);

  void SetDirtyMemoryRegion(uint64_t gpa, size_t size);
  void StartTrackingDirtyMemory();
  void StopTrackingDirtyMemory();

  bool SaveDirtyMemory(MigrationNetworkWriter* writer, DirtyMemoryType type);
  bool LoadDirtyMemory(MigrationNetworkReader* reader, DirtyMemoryType type);

  const DirtyMemoryListener* RegisterDirtyMemoryListener(DirtyMemoryListenerCallback callback);
  void UnregisterDirtyMemoryListener(const DirtyMemoryListener** plistener);

  void PrintMemoryScope();
  void* GuestToHostAddress(uint64_t gpa);
  uint64_t HostToGuestAddress(void* host);
  std::vector<const MemorySlot*> GetMemoryFlatView();
  const MemoryListener* RegisterMemoryListener(MemoryListenerCallback callback);
  void UnregisterMemoryListener(const MemoryListener** plistener);

  const std::set<MemoryRegion*>& regions() const { return regions_; }

 private:
  void InitializeSystemRam();
  void InitializeReservedMemory();
  void LoadBiosFile();
  void AddMemoryRegion(MemoryRegion* region);
  void UpdateKvmSlot(MemorySlot* slot, bool remove);
  uint AllocateSlotId();
  bool GetDirtyBitmapFromKvm(uint32_t slot, void* bitmap);
  std::vector<MemorySlot> GetSlotsByNames(std::unordered_set<std::string> names);
  bool HandleBitmap(const char* bitmap, size_t size, DirtyBitmapCallback callback);

  const Machine*                  machine_;
  void*                           ram_host_;
  std::set<MemoryRegion*>         regions_;
  std::map<uint64_t, MemorySlot*> kvm_slots_;
  std::set<const MemoryListener*> memory_listeners_;
  std::set<uint>                  free_slots_;
  std::unordered_set<std::string> trace_slot_names_;
  mutable std::shared_mutex       mutex_;
  
  /* BIOS data */
  size_t                          bios_size_;
  void*                           bios_data_ = nullptr;
  void*                           bios_backup_ = nullptr;

  bool                                 track_dirty_memory_ = false;
  std::mutex                           dirty_memory_region_mutex_;
  std::map<uint64_t, size_t>           dirty_memory_regions_;
  std::set<const DirtyMemoryListener*> dirty_memory_listeners_;
};

#endif // _MVISOR_MM_H

```

`include/migration.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_MIGRATION_H
#define _MVISOR_MIGRATION_H

#include <google/protobuf/message.h>

#include <list>
#include <string>
#include <unordered_map>
#include <queue>

using google::protobuf::Message;


enum MigrationDataType {
  kMigrationDataTypeRaw,
  kMigrationDataTypeString,
  kMigrationDataTypeProtobuf
};

enum MigrationSignalType {
  kMigrateBackingImageComplete,
  kMigrateRamComplete,
  kMigrateImageComplete,
  kMigrateDirtyMemoryFromKvmComplete,
  kMigrateDirtyMemoryFromListenerComplete,
  kMigrateDeviceComplete,
  kMigrateDirtyMemoryFromDmaComplete,
  kMigrateVcpuComplete,
  kMigrateComplete
};

struct MigrationNetworkDataHeader {
  char tag[24];
  size_t size;
};

struct MigrationNetworkData {
  MigrationNetworkDataHeader header;
  uint8_t* body;
};

struct MigrationSignal {
  MigrationSignalType type;
};

class MigrationWriter { 
  public:
    MigrationWriter() = default;
    virtual ~MigrationWriter() = default;
    virtual int  BeginWrite(std::string tag) = 0;
    virtual void SetPrefix(std::string prefix) = 0;
    virtual void EndWrite(std::string tag) = 0;
    virtual bool WriteRaw(std::string tag, void* data, size_t size) = 0;
    virtual bool WriteProtobuf(std::string tag, const Message& message) = 0;
    virtual bool WriteMemoryPages(std::string tag, void* pages, size_t size) = 0;
};

class MigrationFileWriter : public MigrationWriter {
 public:
  MigrationFileWriter(std::string base_path);
  virtual ~MigrationFileWriter();

  virtual int  BeginWrite(std::string tag);
  virtual void SetPrefix(std::string prefix);
  virtual void EndWrite(std::string tag);
  virtual bool WriteRaw(std::string tag, void* data, size_t size);
  virtual bool WriteProtobuf(std::string tag, const Message& message);
  virtual bool WriteMemoryPages(std::string tag, void* pages, size_t size);

  inline std::string base_path() { return base_path_; }

 private:
  int         fd_ = -1;
  std::string prefix_;
  std::string base_path_;
};

class MigrationNetworkWriter : public MigrationWriter {
 public:
  MigrationNetworkWriter();
  virtual ~MigrationNetworkWriter();

  virtual int  BeginWrite(std::string tag);
  virtual void SetPrefix(std::string prefix);
  virtual void EndWrite(std::string tag);
  virtual bool WriteRaw(std::string tag, void* data, size_t size);
  virtual bool WriteProtobuf(std::string tag, const Message& message);
  virtual bool WriteMemoryPages(std::string tag, void* pages, size_t size);

  bool Connect(std::string ip, uint16_t port);
  bool WaitForSignal(MigrationSignalType type);
  bool WriteFromFile(std::string tag, std::string path, size_t offset);

 private:
  int         socket_fd_ = -1;

  bool Write(void* data, size_t size);
};

class MigrationReader {
  public: 
    MigrationReader() = default;
    virtual ~MigrationReader() = default;

    virtual int  BeginRead(std::string tag) = 0;
    virtual void SetPrefix(std::string prefix) = 0;
    virtual void EndRead(std::string tag) = 0;
    virtual bool ReadRaw(std::string tag, void* data, size_t size) = 0;
    virtual bool ReadProtobuf(std::string tag, Message& message) = 0;
    virtual bool ReadMemoryPages(std::string tag, void** pages_ptr, size_t size) = 0;
    virtual size_t ReadRawWithLimit(std::string tag, void* data, size_t limit) = 0;
    virtual bool Exists(std::string tag) = 0;
};

class MigrationFileReader : public MigrationReader {
 public:
  MigrationFileReader(std::string base_path);
  virtual ~MigrationFileReader();

  virtual int  BeginRead(std::string tag);
  virtual void SetPrefix(std::string prefix);
  virtual void EndRead(std::string tag);
  virtual bool ReadRaw(std::string tag, void* data, size_t size);
  virtual bool ReadProtobuf(std::string tag, Message& message);
  virtual bool ReadMemoryPages(std::string tag, void** pages_ptr, size_t size);
  virtual size_t ReadRawWithLimit(std::string tag, void* data, size_t limit);
  virtual bool Exists(std::string tag);

 private:
  int         fd_ = -1;
  size_t      file_size_ = 0;
  std::string prefix_;
  std::string base_path_;
};

class MigrationNetworkReader : public MigrationReader {
 public:
  MigrationNetworkReader();
  virtual ~MigrationNetworkReader();

  virtual int  BeginRead(std::string tag);
  virtual void SetPrefix(std::string prefix);
  virtual void EndRead(std::string tag);
  virtual bool ReadRaw(std::string tag, void* data, size_t size);
  virtual bool ReadProtobuf(std::string tag, Message& message);
  virtual bool ReadMemoryPages(std::string tag, void** pages_ptr, size_t size);
  virtual size_t ReadRawWithLimit(std::string tag, void* data, size_t limit);
  virtual bool Exists(std::string tag);

  bool WaitForConnection(uint16_t port);
  void SendSignal(MigrationSignalType type);
  void ReadToFile(std::string tag, std::string path, size_t offset);

 private:
  int socket_fd_ = -1;
  std::unordered_map<std::string, std::queue<MigrationNetworkData*>> cache_map_;

  void Read(void* data, size_t size);
  void FreeCacheData(MigrationNetworkData* data);
  MigrationNetworkDataHeader WaitForDataHeader(std::string tag);
  MigrationNetworkData* ReadFromCache(std::string tag);
};

#endif // _MVISOR_MIGRATION_H

```

`include/object.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_OBJECT_H
#define _MVISOR_OBJECT_H

#include <variant>
#include <vector>
#include <string>
#include <map>

#define OBJECT_MAX_NAME_LENGTH 100

typedef std::variant<bool, uint64_t, std::string> Value;

class Object {
 public:
  static Object* Create(const char* class_name);

  Object();
  virtual ~Object();

  virtual void AddChild(Object* device);
  virtual void RemoveChild(Object* object);

  inline uint id() const { return id_; }
  inline const char* name() const { return name_; }
  inline const char* classname() const { return classname_; }
  inline bool debug() const { return debug_; }
  inline const Object* parent() const { return parent_; }
  inline const char* parent_name() const { return parent_name_; }
  inline const std::vector<std::string>& default_parent_classes() const { return default_parent_classes_; }
  inline const std::vector<Object*>& children() const { return children_; }
  inline bool has_key(std::string key) const { return key_values_.find(key) != key_values_.end(); }
  inline Value& operator[](std::string key) { return key_values_[key]; }
  inline const std::map<std::string, Value>& key_values() const { return key_values_; }

  void set_id(uint id) { id_ = id; }
  void set_debug(bool debug) { debug_ = debug; }
  void set_name(const char* name);
  void set_classname(const char* classname);
  void set_parent_name(const char* parent_name);
  void set_default_parent_class(const char* primary, const char* secondary = nullptr);

 protected:
  uint id_ = 0;
  bool debug_ = false;
  char name_[OBJECT_MAX_NAME_LENGTH];
  char classname_[OBJECT_MAX_NAME_LENGTH];
  char parent_name_[OBJECT_MAX_NAME_LENGTH];
  std::map<std::string, Value> key_values_;

  /* Object topology */
  Object* parent_ = nullptr;
  std::vector<Object*> children_;
  std::vector<std::string> default_parent_classes_;
};

#endif // _MVISOR_OBJECT_H


```

`include/pci_device.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_PCI_DEVICE_H
#define _MVISOR_PCI_DEVICE_H

#include <linux/pci_regs.h>
#include "device.h"
#include "logger.h"

#define PCI_MULTI_FUNCTION    0x80
#define PCI_MAX_MSIX_ENTRIES  32

struct MsiMessage {
  uint32_t address_lo; /* low 32 bits of msi message address */
  uint32_t address_hi; /* high 32 bits of msi message address */
  uint32_t data;       /* 16 bits of msi message data */
} __attribute__((packed));


struct MsiXTableEntry {
  struct MsiMessage message;
  uint32_t control;
} __attribute__((packed));

struct MsiXCapability {
  uint8_t capability;
  uint8_t next;
  uint16_t control;
  uint32_t table_offset;
  uint32_t pba_offset;
} __attribute__((packed));

struct MsiCapability64 {
  uint8_t capability;
  uint8_t next;
  uint16_t control;
  uint32_t address0;
  uint32_t address1;
  uint16_t data;
  uint16_t _align;
  uint32_t mask_bits;
  uint32_t pend_bits;
} __attribute__((packed));

struct MsiCapability32 {
  uint8_t capability;
  uint8_t next;
  uint16_t control;
  uint32_t address;
  uint16_t data;
  uint16_t _align;
  uint32_t mask_bits;
  uint32_t pend_bits;
} __attribute__((packed));

struct PciMsiConfig {
  bool      enabled;
  bool      is_64bit;
  bool      is_msix;
  uint8_t   offset;
  uint8_t   length;
  union {
    MsiCapability32* msi32;
    MsiCapability64* msi64;
    MsiXCapability*  msix;
  };
  /* MSI-X BAR */
  uint8_t        msix_bar;
  uint16_t       msix_table_size;
  uint64_t       msix_space_offset;
  uint64_t       msix_space_size;
  MsiXTableEntry msix_table[PCI_MAX_MSIX_ENTRIES];
};

struct PciCapabilityHeader {
  uint8_t type;
  uint8_t next;
} __attribute__((packed));

union PciConfigAddress {
  struct {
    unsigned reg_offset  : 2;  /* 1  .. 0  */
    unsigned reg_number  : 6;  /* 7  .. 2  */
    unsigned function    : 3;  /* 10 .. 8 */
    unsigned slot        : 5;  /* 15 .. 11 */
    unsigned bus         : 8;  /* 23 .. 16 */
    unsigned reserved    : 7;  /* 30 .. 24 */
    unsigned enabled     : 1;  /* 31       */
  };
  uint8_t   data[4];
  uint32_t  value;
};

#define PCI_BAR_OFFSET(b) (offsetof(struct PciConfigHeader, bars[b]))
#define PCI_DEVICE_CONFIG_SIZE 256
#define PCI_DEVICE_CONFIG_MASK (PCI_DEVICE_CONFIG_SIZE - 1)
#define PCI_BAR_NUMS 6
#define PCIE_DEVICE_CONFIG_SIZE 0x1000

#define Q35_MASK(bit, ms_bit, ls_bit) \
  ((uint##bit##_t)(((1ULL << ((ms_bit) + 1)) - 1) & ~((1ULL << ls_bit) - 1)))

struct PciConfigHeader {
  /* Configuration space, as seen by the guest */
  union {
    struct {
      uint16_t   vendor_id;
      uint16_t   device_id;
      uint16_t   command;
      uint16_t   status;
      unsigned   revision_id  : 8;
      unsigned   class_code   : 24;
      uint8_t    cacheline_size;
      uint8_t    latency_timer;
      uint8_t    header_type;
      uint8_t    bist;
      uint32_t   bars[6];
      uint32_t   card_bus;
      uint16_t   subsys_vendor_id;
      uint16_t   subsys_id;
      uint32_t   rom_bar;
      uint8_t    capability;
      uint8_t    reserved1[3];
      uint32_t   reserved2;
      uint8_t    irq_line;
      uint8_t    irq_pin;
      uint8_t    min_gnt;
      uint8_t    max_lat;
    } __attribute__((packed));
    /* Pad to PCI config space size */
    uint8_t data[PCIE_DEVICE_CONFIG_SIZE];
  };
};

struct PciBarInfo {
  IoResourceType        type;
  uint32_t              size;
  uint32_t              address;
  uint64_t              address_mask;
  uint32_t              special_bits;
  bool                  active;
  void*                 host_memory;
};

struct PciRomBarInfo {
  uint32_t size;
  void* data;
  const MemoryRegion* mapped_region;
};

/* Get last byte of a range from offset + length.
 * Undefined for ranges that wrap around 0. */
static inline uint64_t range_get_last(uint64_t offset, uint64_t len)
{
  MV_ASSERT(len > 0);
  return offset + len - 1;
}

/* Check whether 2 given ranges overlap.
 * Undefined if ranges that wrap around 0. */
static inline int ranges_overlap(uint64_t first1, uint64_t len1,
                                 uint64_t first2, uint64_t len2)
{
  uint64_t last1 = range_get_last(first1, len1);
  uint64_t last2 = range_get_last(first2, len2);

  return !(last2 < first1 || last1 < first2);
}

class PciDevice : public Device {
 public:
  PciDevice();
  virtual ~PciDevice();
  virtual void Disconnect();

  inline uint8_t bus() { return bus_; }
  inline uint8_t slot() { return slot_; }
  inline uint8_t function() { return function_; }
  inline const PciConfigHeader& pci_header() { return pci_header_; }
  inline const PciBarInfo& pci_bar(uint8_t index) { return pci_bars_[index]; }
  inline uint  pci_config_size() { return is_pcie_ ? PCIE_DEVICE_CONFIG_SIZE : PCI_DEVICE_CONFIG_SIZE; }

  virtual void ReadPciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length);
  virtual void WritePciConfigSpace(uint64_t offset, uint8_t* data, uint32_t length);
  virtual void Read(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void Write(const IoResource* resource, uint64_t offset, uint8_t* data, uint32_t size);
  virtual void WritePciCommand(uint16_t command);
  void WritePciBar(uint8_t index, uint32_t value);

  /* PCI devices may override these members to handle bar regsiter events */
  virtual bool ActivatePciBar(uint8_t index);
  virtual bool DeactivatePciBar(uint8_t index);

  /* PCI Migration */
  virtual bool SaveState(MigrationWriter* writer);
  virtual bool LoadState(MigrationReader* reader);
 protected:
  friend class DeviceManager;

  bool ActivatePciBarsWithinRegion(uint32_t base, uint32_t size);
  bool DeactivatePciBarsWithinRegion(uint32_t base, uint32_t size);
  void UpdateRomMapAddress(uint32_t address);
  void LoadRomFile(const char* path);
  void AddPciBar(uint8_t index, uint32_t size, IoResourceType type);
  uint8_t* AddCapability(uint8_t cap, const uint8_t* data, uint8_t length);
  void AddMsiCapability();
  void AddMsiXCapability(uint8_t bar, uint16_t table_size, uint64_t space_offset, uint64_t space_size);
  void SignalMsi(int vector = 0);
  void SetIrq(uint level);

  uint16_t          bus_;
  uint8_t           slot_;
  uint8_t           function_;
  PciConfigHeader   pci_header_;
  PciBarInfo        pci_bars_[PCI_BAR_NUMS];
  PciRomBarInfo     pci_rom_;
  PciMsiConfig      msi_config_;
  uint16_t          next_capability_offset_;
  bool              is_pcie_;
};

#endif // _MVISOR_PCI_DEVICE_H

```

`include/qcow2.h`:

```h
/* 
 * MVisor QCOW2 Disk Image
 * Copyright (C) 2021-2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_IMAGES_QCOW2_H
#define _MVISOR_IMAGES_QCOW2_H

#include "disk_image.h"
#include "lru_cache.h"


#define QCOW2_OFLAG_COPIED            (1UL << 63)
#define QCOW2_OFLAG_COMPRESSED        (1UL << 62)
#define QCOW2_OFLAGS_MASK             (QCOW2_OFLAG_COPIED | QCOW2_OFLAG_COMPRESSED)
#define QCOW2_DESCRIPTOR_MASK         (~QCOW2_OFLAGS_MASK)
#define QCOW2_STANDARD_OFFSET_MASK    (((1LL << 47) - 1LL) << 9)
#define QCOW2_COMPRESSED_SECTOR_SIZE  512
#define QCOW2_COMPRESSED_SECTOR_MASK  (~(QCOW2_COMPRESSED_SECTOR_SIZE - 1LL))
#define QCOW2_MIGRATE_DATA_OFFSET     0x10000

static inline void be32_to_cpus(uint32_t* x) {
  *x = be32toh(*x);
}
static inline void be64_to_cpus(uint64_t* x) {
  *x = be64toh(*x);
}

enum Qcow2CompressionType {
  kCompressionTypeZlib = 0,
  kCompressionTypeZstd = 1
};

struct Qcow2Header {
  uint32_t magic;
  uint32_t version;

  uint64_t backing_file_offset;
  uint32_t backing_file_size;

  uint32_t cluster_bits;
  uint64_t size;
  uint32_t crypt_method;

  uint32_t l1_size;
  uint64_t l1_table_offset;

  uint64_t refcount_table_offset;
  uint32_t refcount_table_clusters;

  uint32_t nb_snapshots;
  uint64_t snapshots_offset;

  /* Version 3 */
  uint64_t incompatible_features;
  uint64_t compatible_features;
  uint64_t autoclear_features;
  uint32_t refcount_order;
  uint32_t header_length;
  uint8_t  compression_type;
} __attribute__ ((packed));

struct L2Table {
  uint64_t    offset_in_file;
  bool        dirty;
  uint64_t    entries[];
};

struct RefcountBlock {
  uint64_t    offset_in_file;
  bool        dirty;
  uint16_t    entries[];
};


/* Reference: https://git.qemu.org/?p=qemu.git;a=blob;f=docs/interop/qcow2.txt
 * All numbers in Qcow2 are stored in Big Endian byte order
 * Take an example created with the following commandline:
 * # qemu-img create -f qcow2 -F qcow2 -b win10.qcow2 hd.qcow2
 * 
 * The file size of hd.qcow2 is 196KB (approximately 3 clsuters)
 * cluster_bits = 16, then cluster_size = 0x10000 (64KB)
 * refcount_table starts at 0x10000
 * The first refcount_block starts at 0x20000
 * l1_table starts at 0x30000
 * 
 * A hex view of the file data at 0x10000 to the end of the newly created file
 * # hexdump -C hd.qcow2  -s 0x10000
 * 00010000  00 00 00 00 00 02 00 00  00 00 00 00 00 00 00 00  |................|
 * 00010010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
 *
 * 00020000  00 01 00 01 00 01 00 01  00 00 00 00 00 00 00 00  |................|
 * 00020010  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
 *
 * 00030780
 * 
 * Assume you are reading at the first sector of the disk:
 * 1. Look for the l1_table at 0x30000 with l1_index = 0, get l1_entry = 0
 * 2. If l1_entry has no COPIED flag, try to read the backing file
 * 3. If l1_entry has COPIED flag, read from current file
 * 
 * refcount_table is used when allocating a cluster for l2_table or refcount block
 * or data cluster 
 */

class Qcow2Image : public DiskImage {
 private:
  int fd_ = -1;
  size_t block_size_shift_ = 9; // block size = 4KB
  size_t total_blocks_ = 0;
  size_t image_size_ = 0;
  size_t cluster_size_;
  size_t cluster_bits_;

  size_t l2_entries_;
  size_t rfb_entries_;
  size_t refcount_bits_;

  uint64_t    free_cluster_index_ = 0;
  uint8_t*    copied_cluster_ = nullptr;
  std::string compressed_;

  std::vector<uint64_t> l1_table_;
  std::vector<uint64_t> refcount_table_;
  bool l1_table_dirty_ = false;
  bool refcount_table_dirty_ = false;

  SimpleLRUCache<uint64_t, L2Table*>        l2_cache_;
  SimpleLRUCache<uint64_t, RefcountBlock*>  rfb_cache_;
  SimpleLRUCache<uint64_t, uint8_t*>        cluster_cache_;

  Qcow2Header image_header_;
  std::string backing_filepath_;
  Qcow2Image* backing_file_ = nullptr;
  bool        is_backing_file_ = false;

 private:
  void InitializeQcow2Header();
  ssize_t WriteFile(void* buffer, size_t length, off_t offset);
  ssize_t ReadFile(void* buffer, size_t length, off_t offset);
  void InitializeL1Table();
  void InitializeRefcountTable ();
  void WriteL1Table();
  void WriteRefcountTable();
  void WriteL2Table(L2Table* l2_table);
  void WriteRefcountBlock(RefcountBlock* rfb);
  void InitializeLruCache();
  RefcountBlock* NewRefcountBlock(uint64_t block_offset);
  RefcountBlock* GetRefcountBlock(uint64_t cluster_index, uint64_t* rfb_index, bool allocate);
  void FreeCluster(uint64_t start);
  uint64_t AllocateCluster();
  L2Table* NewL2Table(uint64_t l2_offset);
  L2Table* ReadL2Table(uint64_t l2_offset);
  L2Table* GetL2Table(bool is_write, off_t pos, uint64_t* offset_in_cluster, uint64_t* l2_index, size_t* length);
  ssize_t ReadCluster(void* buffer, off_t pos, size_t length, bool no_zero = false);
  ssize_t WriteCluster(void* buffer, off_t pos, size_t length);
  ssize_t DiscardCluster(off_t pos, size_t length);
  ssize_t BlockIo(void *buffer, off_t position, size_t length, ImageIoType type);
  ssize_t FlushAll();
  void FlushL2Tables ();
  void FlushRefcountBlocks();
  void ReleaseImage(bool remove_file);


 public:
  virtual ~Qcow2Image();
  virtual void Initialize();
  virtual long HandleIoRequest(ImageIoRequest request);

  virtual ImageInformation information() {
    return ImageInformation {
      .block_size = 1UL << block_size_shift_,
      .total_blocks = total_blocks_
    };
  }
  
  void Reset();
  bool CreateSnapshot();
  
  static void CreateEmptyImage(std::string path, size_t disk_size);
  static void CreateImageWithBackingFile(std::string path, std::string backing_path);
};

#endif // _MVISOR_IMAGES_QCOW2_H

```

`include/spice/barrier.h`:

```h
/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _H_SPICE_BARRIER
#define _H_SPICE_BARRIER

#ifdef __GNUC__

#define spice_mb() __sync_synchronize ()

#else

#ifdef _WIN64
//__asm not supported on _WIN64, so use macro instead.
#define spice_mb MemoryBarrier
#else
#define spice_mb() __asm {lock add [esp], 0}
#endif

#endif

#endif /* _H_SPICE_BARRIER */

```

`include/spice/end-packed.h`:

```h
/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* See start-packed.h for details */

#undef SPICE_ATTR_PACKED
#undef SPICE_ATTR_ALIGNED

#if defined(__MINGW32__) || !defined(__GNUC__)
#pragma pack(pop)
#endif

```

`include/spice/enums.h`:

```h
/* this is a file autogenerated by spice_codegen.py */
/*
   Copyright (C) 2013 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _H_SPICE_ENUMS
#define _H_SPICE_ENUMS

#include <spice/macros.h>

typedef enum SpiceLinkErr {
    SPICE_LINK_ERR_OK,
    SPICE_LINK_ERR_ERROR,
    SPICE_LINK_ERR_INVALID_MAGIC,
    SPICE_LINK_ERR_INVALID_DATA,
    SPICE_LINK_ERR_VERSION_MISMATCH,
    SPICE_LINK_ERR_NEED_SECURED,
    SPICE_LINK_ERR_NEED_UNSECURED,
    SPICE_LINK_ERR_PERMISSION_DENIED,
    SPICE_LINK_ERR_BAD_CONNECTION_ID,
    SPICE_LINK_ERR_CHANNEL_NOT_AVAILABLE,

    SPICE_LINK_ERR_ENUM_END
} SpiceLinkErr;

typedef enum SpiceWarnCode {
    SPICE_WARN_GENERAL,

    SPICE_WARN_CODE_ENUM_END
} SpiceWarnCode;

typedef enum SpiceInfoCode {
    SPICE_INFO_GENERAL,

    SPICE_INFO_CODE_ENUM_END
} SpiceInfoCode;

typedef enum SpiceMigrateFlags {
    SPICE_MIGRATE_NEED_FLUSH = (1 << 0),
    SPICE_MIGRATE_NEED_DATA_TRANSFER = (1 << 1),

    SPICE_MIGRATE_FLAGS_MASK = 0x3
} SpiceMigrateFlags;

typedef enum SpiceCompositeFlags {
    SPICE_COMPOSITE_OP0 = (1 << 0),
    SPICE_COMPOSITE_OP1 = (1 << 1),
    SPICE_COMPOSITE_OP2 = (1 << 2),
    SPICE_COMPOSITE_OP3 = (1 << 3),
    SPICE_COMPOSITE_OP4 = (1 << 4),
    SPICE_COMPOSITE_OP5 = (1 << 5),
    SPICE_COMPOSITE_OP6 = (1 << 6),
    SPICE_COMPOSITE_OP7 = (1 << 7),
    SPICE_COMPOSITE_SRC_FILTER0 = (1 << 8),
    SPICE_COMPOSITE_SRC_FILTER1 = (1 << 9),
    SPICE_COMPOSITE_SRC_FILTER2 = (1 << 10),
    SPICE_COMPOSITE_MASK_FILTER0 = (1 << 11),
    SPICE_COMPOSITE_MASK_FITLER1 = (1 << 12),
    SPICE_COMPOSITE_MASK_FILTER2 = (1 << 13),
    SPICE_COMPOSITE_SRC_REPEAT0 = (1 << 14),
    SPICE_COMPOSITE_SRC_REPEAT1 = (1 << 15),
    SPICE_COMPOSITE_MASK_REPEAT0 = (1 << 16),
    SPICE_COMPOSITE_MASK_REPEAT1 = (1 << 17),
    SPICE_COMPOSITE_COMPONENT_ALPHA = (1 << 18),
    SPICE_COMPOSITE_HAS_MASK = (1 << 19),
    SPICE_COMPOSITE_HAS_SRC_TRANSFORM = (1 << 20),
    SPICE_COMPOSITE_HAS_MASK_TRANSFORM = (1 << 21),
    SPICE_COMPOSITE_SOURCE_OPAQUE = (1 << 22),
    SPICE_COMPOSITE_MASK_OPAQUE = (1 << 23),
    SPICE_COMPOSITE_DEST_OPAQUE = (1 << 24),

    SPICE_COMPOSITE_FLAGS_MASK = 0x1ffffff
} SpiceCompositeFlags;

typedef enum SpiceNotifySeverity {
    SPICE_NOTIFY_SEVERITY_INFO,
    SPICE_NOTIFY_SEVERITY_WARN,
    SPICE_NOTIFY_SEVERITY_ERROR,

    SPICE_NOTIFY_SEVERITY_ENUM_END
} SpiceNotifySeverity;

typedef enum SpiceNotifyVisibility {
    SPICE_NOTIFY_VISIBILITY_LOW,
    SPICE_NOTIFY_VISIBILITY_MEDIUM,
    SPICE_NOTIFY_VISIBILITY_HIGH,

    SPICE_NOTIFY_VISIBILITY_ENUM_END
} SpiceNotifyVisibility;

typedef enum SpiceMouseMode {
    SPICE_MOUSE_MODE_SERVER = (1 << 0),
    SPICE_MOUSE_MODE_CLIENT = (1 << 1),

    SPICE_MOUSE_MODE_MASK = 0x3
} SpiceMouseMode;

typedef enum SpiceDataCompressionType {
    SPICE_DATA_COMPRESSION_TYPE_NONE,
    SPICE_DATA_COMPRESSION_TYPE_LZ4,

    SPICE_DATA_COMPRESSION_TYPE_ENUM_END
} SpiceDataCompressionType;

typedef enum SpiceClipType {
    SPICE_CLIP_TYPE_NONE,
    SPICE_CLIP_TYPE_RECTS,

    SPICE_CLIP_TYPE_ENUM_END
} SpiceClipType;

typedef enum SpicePathFlags {
    SPICE_PATH_BEGIN = (1 << 0),
    SPICE_PATH_END = (1 << 1),
    SPICE_PATH_CLOSE = (1 << 3),
    SPICE_PATH_BEZIER = (1 << 4),

    SPICE_PATH_FLAGS_MASK = 0x1b
} SpicePathFlags;

typedef enum SpiceVideoCodecType {
    SPICE_VIDEO_CODEC_TYPE_MJPEG = 1,
    SPICE_VIDEO_CODEC_TYPE_VP8,
    SPICE_VIDEO_CODEC_TYPE_H264,
    SPICE_VIDEO_CODEC_TYPE_VP9,
    SPICE_VIDEO_CODEC_TYPE_H265,

    SPICE_VIDEO_CODEC_TYPE_ENUM_END
} SpiceVideoCodecType;

typedef enum SpiceStreamFlags {
    SPICE_STREAM_FLAGS_TOP_DOWN = (1 << 0),

    SPICE_STREAM_FLAGS_MASK = 0x1
} SpiceStreamFlags;

typedef enum SpiceBrushType {
    SPICE_BRUSH_TYPE_NONE,
    SPICE_BRUSH_TYPE_SOLID,
    SPICE_BRUSH_TYPE_PATTERN,

    SPICE_BRUSH_TYPE_ENUM_END
} SpiceBrushType;

typedef enum SpiceMaskFlags {
    SPICE_MASK_FLAGS_INVERS = (1 << 0),

    SPICE_MASK_FLAGS_MASK = 0x1
} SpiceMaskFlags;

typedef enum SpiceImageType {
    SPICE_IMAGE_TYPE_BITMAP,
    SPICE_IMAGE_TYPE_QUIC,
    SPICE_IMAGE_TYPE_RESERVED,
    SPICE_IMAGE_TYPE_LZ_PLT = 100,
    SPICE_IMAGE_TYPE_LZ_RGB,
    SPICE_IMAGE_TYPE_GLZ_RGB,
    SPICE_IMAGE_TYPE_FROM_CACHE,
    SPICE_IMAGE_TYPE_SURFACE,
    SPICE_IMAGE_TYPE_JPEG,
    SPICE_IMAGE_TYPE_FROM_CACHE_LOSSLESS,
    SPICE_IMAGE_TYPE_ZLIB_GLZ_RGB,
    SPICE_IMAGE_TYPE_JPEG_ALPHA,
    SPICE_IMAGE_TYPE_LZ4,

    SPICE_IMAGE_TYPE_ENUM_END
} SpiceImageType;

typedef enum SpiceImageCompression {
    SPICE_IMAGE_COMPRESSION_INVALID,
    SPICE_IMAGE_COMPRESSION_OFF,
    SPICE_IMAGE_COMPRESSION_AUTO_GLZ,
    SPICE_IMAGE_COMPRESSION_AUTO_LZ,
    SPICE_IMAGE_COMPRESSION_QUIC,
    SPICE_IMAGE_COMPRESSION_GLZ,
    SPICE_IMAGE_COMPRESSION_LZ,
    SPICE_IMAGE_COMPRESSION_LZ4,

    SPICE_IMAGE_COMPRESSION_ENUM_END
} SpiceImageCompression;

typedef enum SpiceImageFlags {
    SPICE_IMAGE_FLAGS_CACHE_ME = (1 << 0),
    SPICE_IMAGE_FLAGS_HIGH_BITS_SET = (1 << 1),
    SPICE_IMAGE_FLAGS_CACHE_REPLACE_ME = (1 << 2),

    SPICE_IMAGE_FLAGS_MASK = 0x7
} SpiceImageFlags;

typedef enum SpiceBitmapFmt {
    SPICE_BITMAP_FMT_INVALID,
    SPICE_BITMAP_FMT_1BIT_LE,
    SPICE_BITMAP_FMT_1BIT_BE,
    SPICE_BITMAP_FMT_4BIT_LE,
    SPICE_BITMAP_FMT_4BIT_BE,
    SPICE_BITMAP_FMT_8BIT,
    SPICE_BITMAP_FMT_16BIT,
    SPICE_BITMAP_FMT_24BIT,
    SPICE_BITMAP_FMT_32BIT,
    SPICE_BITMAP_FMT_RGBA,
    SPICE_BITMAP_FMT_8BIT_A,

    SPICE_BITMAP_FMT_ENUM_END
} SpiceBitmapFmt;

typedef enum SpiceBitmapFlags {
    SPICE_BITMAP_FLAGS_PAL_CACHE_ME = (1 << 0),
    SPICE_BITMAP_FLAGS_PAL_FROM_CACHE = (1 << 1),
    SPICE_BITMAP_FLAGS_TOP_DOWN = (1 << 2),

    SPICE_BITMAP_FLAGS_MASK = 0x7
} SpiceBitmapFlags;

typedef enum SpiceJpegAlphaFlags {
    SPICE_JPEG_ALPHA_FLAGS_TOP_DOWN = (1 << 0),

    SPICE_JPEG_ALPHA_FLAGS_MASK = 0x1
} SpiceJpegAlphaFlags;

typedef enum SpiceImageScaleMode {
    SPICE_IMAGE_SCALE_MODE_INTERPOLATE,
    SPICE_IMAGE_SCALE_MODE_NEAREST,

    SPICE_IMAGE_SCALE_MODE_ENUM_END
} SpiceImageScaleMode;

typedef enum SpiceRopd {
    SPICE_ROPD_INVERS_SRC = (1 << 0),
    SPICE_ROPD_INVERS_BRUSH = (1 << 1),
    SPICE_ROPD_INVERS_DEST = (1 << 2),
    SPICE_ROPD_OP_PUT = (1 << 3),
    SPICE_ROPD_OP_OR = (1 << 4),
    SPICE_ROPD_OP_AND = (1 << 5),
    SPICE_ROPD_OP_XOR = (1 << 6),
    SPICE_ROPD_OP_BLACKNESS = (1 << 7),
    SPICE_ROPD_OP_WHITENESS = (1 << 8),
    SPICE_ROPD_OP_INVERS = (1 << 9),
    SPICE_ROPD_INVERS_RES = (1 << 10),

    SPICE_ROPD_MASK = 0x7ff
} SpiceRopd;

typedef enum SpiceLineFlags {
    SPICE_LINE_FLAGS_START_WITH_GAP = (1 << 2),
    SPICE_LINE_FLAGS_STYLED = (1 << 3),

    SPICE_LINE_FLAGS_MASK = 0xc
} SpiceLineFlags;

typedef enum SpiceStringFlags {
    SPICE_STRING_FLAGS_RASTER_A1 = (1 << 0),
    SPICE_STRING_FLAGS_RASTER_A4 = (1 << 1),
    SPICE_STRING_FLAGS_RASTER_A8 = (1 << 2),
    SPICE_STRING_FLAGS_RASTER_TOP_DOWN = (1 << 3),

    SPICE_STRING_FLAGS_MASK = 0xf
} SpiceStringFlags;

typedef enum SpiceSurfaceFlags {
    SPICE_SURFACE_FLAGS_PRIMARY = (1 << 0),
    SPICE_SURFACE_FLAGS_STREAMING_MODE = (1 << 1),

    SPICE_SURFACE_FLAGS_MASK = 0x3
} SpiceSurfaceFlags;

typedef enum SpiceSurfaceFmt {
    SPICE_SURFACE_FMT_INVALID,
    SPICE_SURFACE_FMT_1_A,
    SPICE_SURFACE_FMT_8_A = 8,
    SPICE_SURFACE_FMT_16_555 = 16,
    SPICE_SURFACE_FMT_32_xRGB = 32,
    SPICE_SURFACE_FMT_16_565 = 80,
    SPICE_SURFACE_FMT_32_ARGB = 96,

    SPICE_SURFACE_FMT_ENUM_END
} SpiceSurfaceFmt;

typedef enum SpiceAlphaFlags {
    SPICE_ALPHA_FLAGS_DEST_HAS_ALPHA = (1 << 0),
    SPICE_ALPHA_FLAGS_SRC_SURFACE_HAS_ALPHA = (1 << 1),

    SPICE_ALPHA_FLAGS_MASK = 0x3
} SpiceAlphaFlags;

typedef enum SpiceResourceType {
    SPICE_RES_TYPE_INVALID,
    SPICE_RES_TYPE_PIXMAP,

    SPICE_RESOURCE_TYPE_ENUM_END
} SpiceResourceType;

typedef enum SpiceGlScanoutFlags {
    SPICE_GL_SCANOUT_FLAGS_Y0TOP = (1 << 0),

    SPICE_GL_SCANOUT_FLAGS_MASK = 0x1
} SpiceGlScanoutFlags;

typedef enum SpiceKeyboardModifierFlags {
    SPICE_KEYBOARD_MODIFIER_FLAGS_SCROLL_LOCK = (1 << 0),
    SPICE_KEYBOARD_MODIFIER_FLAGS_NUM_LOCK = (1 << 1),
    SPICE_KEYBOARD_MODIFIER_FLAGS_CAPS_LOCK = (1 << 2),

    SPICE_KEYBOARD_MODIFIER_FLAGS_MASK = 0x7
} SpiceKeyboardModifierFlags;

typedef enum SpiceMouseButton {
    SPICE_MOUSE_BUTTON_INVALID,
    SPICE_MOUSE_BUTTON_LEFT,
    SPICE_MOUSE_BUTTON_MIDDLE,
    SPICE_MOUSE_BUTTON_RIGHT,
    SPICE_MOUSE_BUTTON_UP,
    SPICE_MOUSE_BUTTON_DOWN,
    SPICE_MOUSE_BUTTON_SIDE,
    SPICE_MOUSE_BUTTON_EXTRA,

    SPICE_MOUSE_BUTTON_ENUM_END
} SpiceMouseButton;

typedef enum SpiceMouseButtonMask {
    SPICE_MOUSE_BUTTON_MASK_LEFT = (1 << 0),
    SPICE_MOUSE_BUTTON_MASK_MIDDLE = (1 << 1),
    SPICE_MOUSE_BUTTON_MASK_RIGHT = (1 << 2),
    SPICE_MOUSE_BUTTON_MASK_UP = (1 << 3),
    SPICE_MOUSE_BUTTON_MASK_DOWN = (1 << 4),
    SPICE_MOUSE_BUTTON_MASK_SIDE = (1 << 5),
    SPICE_MOUSE_BUTTON_MASK_EXTRA = (1 << 6),

    SPICE_MOUSE_BUTTON_MASK_MASK = 0x7F
} SpiceMouseButtonMask;

typedef enum SpiceCursorType {
    SPICE_CURSOR_TYPE_ALPHA,
    SPICE_CURSOR_TYPE_MONO,
    SPICE_CURSOR_TYPE_COLOR4,
    SPICE_CURSOR_TYPE_COLOR8,
    SPICE_CURSOR_TYPE_COLOR16,
    SPICE_CURSOR_TYPE_COLOR24,
    SPICE_CURSOR_TYPE_COLOR32,

    SPICE_CURSOR_TYPE_ENUM_END
} SpiceCursorType;

typedef enum SpiceCursorFlags {
    SPICE_CURSOR_FLAGS_NONE = (1 << 0),
    SPICE_CURSOR_FLAGS_CACHE_ME = (1 << 1),
    SPICE_CURSOR_FLAGS_FROM_CACHE = (1 << 2),

    SPICE_CURSOR_FLAGS_MASK = 0x7
} SpiceCursorFlags;

typedef enum SpiceAudioDataMode {
    SPICE_AUDIO_DATA_MODE_INVALID,
    SPICE_AUDIO_DATA_MODE_RAW,
    SPICE_AUDIO_DATA_MODE_CELT_0_5_1 SPICE_GNUC_DEPRECATED_ENUMERATOR,
    SPICE_AUDIO_DATA_MODE_OPUS,

    SPICE_AUDIO_DATA_MODE_ENUM_END
} SpiceAudioDataMode;

typedef enum SpiceAudioFmt {
    SPICE_AUDIO_FMT_INVALID,
    SPICE_AUDIO_FMT_S16,

    SPICE_AUDIO_FMT_ENUM_END
} SpiceAudioFmt;

typedef enum SpiceVscMessageType {
    SPICE_VSC_MESSAGE_TYPE_Init = 1,
    SPICE_VSC_MESSAGE_TYPE_Error,
    SPICE_VSC_MESSAGE_TYPE_ReaderAdd,
    SPICE_VSC_MESSAGE_TYPE_ReaderRemove,
    SPICE_VSC_MESSAGE_TYPE_ATR,
    SPICE_VSC_MESSAGE_TYPE_CardRemove,
    SPICE_VSC_MESSAGE_TYPE_APDU,
    SPICE_VSC_MESSAGE_TYPE_Flush,
    SPICE_VSC_MESSAGE_TYPE_FlushComplete,

    SPICE_VSC_MESSAGE_TYPE_ENUM_END
} SpiceVscMessageType;

enum {
    SPICE_CHANNEL_MAIN = 1,
    SPICE_CHANNEL_DISPLAY,
    SPICE_CHANNEL_INPUTS,
    SPICE_CHANNEL_CURSOR,
    SPICE_CHANNEL_PLAYBACK,
    SPICE_CHANNEL_RECORD,
    SPICE_CHANNEL_TUNNEL,
    SPICE_CHANNEL_SMARTCARD,
    SPICE_CHANNEL_USBREDIR,
    SPICE_CHANNEL_PORT,
    SPICE_CHANNEL_WEBDAV,

    SPICE_END_CHANNEL
};

enum {
    SPICE_MSG_MIGRATE = 1,
    SPICE_MSG_MIGRATE_DATA,
    SPICE_MSG_SET_ACK,
    SPICE_MSG_PING,
    SPICE_MSG_WAIT_FOR_CHANNELS,
    SPICE_MSG_DISCONNECTING,
    SPICE_MSG_NOTIFY,
    SPICE_MSG_LIST,
    SPICE_MSG_BASE_LAST = 100,
};

enum {
    SPICE_MSGC_ACK_SYNC = 1,
    SPICE_MSGC_ACK,
    SPICE_MSGC_PONG,
    SPICE_MSGC_MIGRATE_FLUSH_MARK,
    SPICE_MSGC_MIGRATE_DATA,
    SPICE_MSGC_DISCONNECTING,
};

enum {
    SPICE_MSG_MAIN_MIGRATE_BEGIN = 101,
    SPICE_MSG_MAIN_MIGRATE_CANCEL,
    SPICE_MSG_MAIN_INIT,
    SPICE_MSG_MAIN_CHANNELS_LIST,
    SPICE_MSG_MAIN_MOUSE_MODE,
    SPICE_MSG_MAIN_MULTI_MEDIA_TIME,
    SPICE_MSG_MAIN_AGENT_CONNECTED,
    SPICE_MSG_MAIN_AGENT_DISCONNECTED,
    SPICE_MSG_MAIN_AGENT_DATA,
    SPICE_MSG_MAIN_AGENT_TOKEN,
    SPICE_MSG_MAIN_MIGRATE_SWITCH_HOST,
    SPICE_MSG_MAIN_MIGRATE_END,
    SPICE_MSG_MAIN_NAME,
    SPICE_MSG_MAIN_UUID,
    SPICE_MSG_MAIN_AGENT_CONNECTED_TOKENS,
    SPICE_MSG_MAIN_MIGRATE_BEGIN_SEAMLESS,
    SPICE_MSG_MAIN_MIGRATE_DST_SEAMLESS_ACK,
    SPICE_MSG_MAIN_MIGRATE_DST_SEAMLESS_NACK,

    SPICE_MSG_END_MAIN
};

enum {
    SPICE_MSGC_MAIN_CLIENT_INFO = 101,
    SPICE_MSGC_MAIN_MIGRATE_CONNECTED,
    SPICE_MSGC_MAIN_MIGRATE_CONNECT_ERROR,
    SPICE_MSGC_MAIN_ATTACH_CHANNELS,
    SPICE_MSGC_MAIN_MOUSE_MODE_REQUEST,
    SPICE_MSGC_MAIN_AGENT_START,
    SPICE_MSGC_MAIN_AGENT_DATA,
    SPICE_MSGC_MAIN_AGENT_TOKEN,
    SPICE_MSGC_MAIN_MIGRATE_END,
    SPICE_MSGC_MAIN_MIGRATE_DST_DO_SEAMLESS,
    SPICE_MSGC_MAIN_MIGRATE_CONNECTED_SEAMLESS,
    SPICE_MSGC_MAIN_QUALITY_INDICATOR,

    SPICE_MSGC_END_MAIN
};

enum {
    SPICE_MSG_DISPLAY_MODE = 101,
    SPICE_MSG_DISPLAY_MARK,
    SPICE_MSG_DISPLAY_RESET,
    SPICE_MSG_DISPLAY_COPY_BITS,
    SPICE_MSG_DISPLAY_INVAL_LIST,
    SPICE_MSG_DISPLAY_INVAL_ALL_PIXMAPS,
    SPICE_MSG_DISPLAY_INVAL_PALETTE,
    SPICE_MSG_DISPLAY_INVAL_ALL_PALETTES,
    SPICE_MSG_DISPLAY_STREAM_CREATE = 122,
    SPICE_MSG_DISPLAY_STREAM_DATA,
    SPICE_MSG_DISPLAY_STREAM_CLIP,
    SPICE_MSG_DISPLAY_STREAM_DESTROY,
    SPICE_MSG_DISPLAY_STREAM_DESTROY_ALL,
    SPICE_MSG_DISPLAY_DRAW_FILL = 302,
    SPICE_MSG_DISPLAY_DRAW_OPAQUE,
    SPICE_MSG_DISPLAY_DRAW_COPY,
    SPICE_MSG_DISPLAY_DRAW_BLEND,
    SPICE_MSG_DISPLAY_DRAW_BLACKNESS,
    SPICE_MSG_DISPLAY_DRAW_WHITENESS,
    SPICE_MSG_DISPLAY_DRAW_INVERS,
    SPICE_MSG_DISPLAY_DRAW_ROP3,
    SPICE_MSG_DISPLAY_DRAW_STROKE,
    SPICE_MSG_DISPLAY_DRAW_TEXT,
    SPICE_MSG_DISPLAY_DRAW_TRANSPARENT,
    SPICE_MSG_DISPLAY_DRAW_ALPHA_BLEND,
    SPICE_MSG_DISPLAY_SURFACE_CREATE,
    SPICE_MSG_DISPLAY_SURFACE_DESTROY,
    SPICE_MSG_DISPLAY_STREAM_DATA_SIZED,
    SPICE_MSG_DISPLAY_MONITORS_CONFIG,
    SPICE_MSG_DISPLAY_DRAW_COMPOSITE,
    SPICE_MSG_DISPLAY_STREAM_ACTIVATE_REPORT,
    SPICE_MSG_DISPLAY_GL_SCANOUT_UNIX,
    SPICE_MSG_DISPLAY_GL_DRAW,
    SPICE_MSG_DISPLAY_QUALITY_INDICATOR,
    SPICE_MSG_DISPLAY_AVC_DATA = 601,
    SPICE_MSG_DISPLAY_SCREENDUMP = 660,

    SPICE_MSG_END_DISPLAY
};

enum {
    SPICE_MSGC_DISPLAY_INIT = 101,
    SPICE_MSGC_DISPLAY_STREAM_REPORT,
    SPICE_MSGC_DISPLAY_PREFERRED_COMPRESSION,
    SPICE_MSGC_DISPLAY_GL_DRAW_DONE,
    SPICE_MSGC_DISPLAY_PREFERRED_VIDEO_CODEC_TYPE,
    SPICE_MSGC_DISPLAY_AVC_START = 601,
    SPICE_MSGC_DISPLAY_AVC_STOP,
    SPICE_MSGC_DISPLAY_AVC_MODE,
    SPICE_MSGC_DISPLAY_AVC_FORCE_KEYFRAME,
    SPICE_MSGC_DISPLAY_SCREENDUMP = 660,

    SPICE_MSGC_END_DISPLAY
};

enum {
    SPICE_MSG_INPUTS_INIT = 101,
    SPICE_MSG_INPUTS_KEY_MODIFIERS,
    SPICE_MSG_INPUTS_MOUSE_MOTION_ACK = 111,

    SPICE_MSG_END_INPUTS
};

enum {
    SPICE_MSGC_INPUTS_KEY_DOWN = 101,
    SPICE_MSGC_INPUTS_KEY_UP,
    SPICE_MSGC_INPUTS_KEY_MODIFIERS,
    SPICE_MSGC_INPUTS_KEY_SCANCODE,
    SPICE_MSGC_INPUTS_MOUSE_MOTION = 111,
    SPICE_MSGC_INPUTS_MOUSE_POSITION,
    SPICE_MSGC_INPUTS_MOUSE_PRESS,
    SPICE_MSGC_INPUTS_MOUSE_RELEASE,

    SPICE_MSGC_END_INPUTS
};

enum {
    SPICE_MSG_CURSOR_INIT = 101,
    SPICE_MSG_CURSOR_RESET,
    SPICE_MSG_CURSOR_SET,
    SPICE_MSG_CURSOR_MOVE,
    SPICE_MSG_CURSOR_HIDE,
    SPICE_MSG_CURSOR_TRAIL,
    SPICE_MSG_CURSOR_INVAL_ONE,
    SPICE_MSG_CURSOR_INVAL_ALL,

    SPICE_MSG_END_CURSOR
};

enum {
    SPICE_MSG_PLAYBACK_DATA = 101,
    SPICE_MSG_PLAYBACK_MODE,
    SPICE_MSG_PLAYBACK_START,
    SPICE_MSG_PLAYBACK_STOP,
    SPICE_MSG_PLAYBACK_VOLUME,
    SPICE_MSG_PLAYBACK_MUTE,
    SPICE_MSG_PLAYBACK_LATENCY,

    SPICE_MSG_END_PLAYBACK
};

enum {
    SPICE_MSG_RECORD_START = 101,
    SPICE_MSG_RECORD_STOP,
    SPICE_MSG_RECORD_VOLUME,
    SPICE_MSG_RECORD_MUTE,

    SPICE_MSG_END_RECORD
};

enum {
    SPICE_MSGC_RECORD_DATA = 101,
    SPICE_MSGC_RECORD_MODE,
    SPICE_MSGC_RECORD_START_MARK,

    SPICE_MSGC_END_RECORD
};

enum {
    SPICE_MSG_SMARTCARD_DATA = 101,

    SPICE_MSG_END_SMARTCARD
};

enum {
    SPICE_MSGC_SMARTCARD_DATA = 101,
    SPICE_MSGC_SMARTCARD_HEADER = 101,
    SPICE_MSGC_SMARTCARD_ERROR = 101,
    SPICE_MSGC_SMARTCARD_ATR = 101,
    SPICE_MSGC_SMARTCARD_READER_ADD = 101,

    SPICE_MSGC_END_SMARTCARD
};

enum {
    SPICE_MSG_SPICEVMC_DATA = 101,
    SPICE_MSG_SPICEVMC_COMPRESSED_DATA,

    SPICE_MSG_END_SPICEVMC
};

enum {
    SPICE_MSGC_SPICEVMC_DATA = 101,
    SPICE_MSGC_SPICEVMC_COMPRESSED_DATA,

    SPICE_MSGC_END_SPICEVMC
};

enum {
    SPICE_MSG_PORT_INIT = 201,
    SPICE_MSG_PORT_EVENT,

    SPICE_MSG_END_PORT
};

enum {
    SPICE_MSGC_PORT_EVENT = 201,

    SPICE_MSGC_END_PORT
};

#endif /* _H_SPICE_ENUMS */

```

`include/spice/ipc_ring.h`:

```h
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/


#ifndef _H_SPICE_RING
#define _H_SPICE_RING

#include <spice/types.h>

#define _SPICE_MSB_MASK4(x)        \
    (((x) & 0x8) ? 0x8 :    \
     ((x) & 0x4) ? 0x4 :    \
     ((x) & 0x2) ? 0x2 :    \
     ((x) & 0x1) ? 0x1 : 0)

#define _SPICE_MSB_MASK8(x) \
    (((x) & 0xf0) ? _SPICE_MSB_MASK4((x) >> 4) << 4 : _SPICE_MSB_MASK4(x))

#define _SPICE_MSB_MASK16(x) \
    (((x) & 0xff00) ? _SPICE_MSB_MASK8((x) >> 8) << 8 : _SPICE_MSB_MASK8(x))

#define _SPICE_MSB_MASK(x) \
    (((x) & 0xffff0000) ? _SPICE_MSB_MASK16((x) >> 16) << 16 : _SPICE_MSB_MASK16(x))

#define _SPICE_POWER2_ALIGN(x) _SPICE_MSB_MASK((x) * 2 - 1)


#define _SPICE_TOSHIFT_4(x)      \
    (((x) & 0x8) ? 3 :     \
     ((x) & 0x4) ? 2 :     \
     ((x) & 0x2) ? 1 : 0)

#define _SPICE_TOSHIFT_8(x) \
    (((x) & 0xf0) ? _SPICE_TOSHIFT_4((x) >> 4) + 4 : _SPICE_TOSHIFT_4(x))

#define _SPICE_TOSHIFT_16(x) \
    (((x) & 0xff00) ? _SPICE_TOSHIFT_8((x) >> 8) + 8 : _SPICE_TOSHIFT_8(x))

#define _SPICE_POWER2_TO_SHIFT(x) \
    (((x) & 0xffff0000) ? _SPICE_TOSHIFT_16((x) >> 16) + 16 : _SPICE_TOSHIFT_16(x))



#define SPICE_RING_DECLARE(name, el_type, size)               \
typedef struct SPICE_ATTR_PACKED name##_ring_el {       \
    union {                                             \
        el_type el;                                     \
        uint8_t data[_SPICE_POWER2_ALIGN(sizeof(el_type))];      \
    } ;                                                 \
} name##_ring_el;                                       \
                                                        \
typedef struct SPICE_ATTR_PACKED name {                   \
    uint32_t num_items;                                   \
    uint32_t prod;                                        \
    uint32_t notify_on_prod;                              \
    uint32_t cons;                                        \
    uint32_t notify_on_cons;                              \
    name##_ring_el items[_SPICE_POWER2_ALIGN(size)];           \
} name;


#define SPICE_RING_INIT(r)                                                \
    (r)->num_items = sizeof((r)->items) >>                          \
                        _SPICE_POWER2_TO_SHIFT(sizeof((r)->items[0]));     \
    (r)->prod = (r)->cons = 0;                                      \
    (r)->notify_on_prod = 1;                                        \
    (r)->notify_on_cons = 0;


#define SPICE_RING_INDEX_MASK(r) ((r)->num_items - 1)

#define SPICE_RING_IS_PACKED(r) (sizeof((r)->items[0]) == sizeof((r)->items[0]).el)

#define SPICE_RING_IS_EMPTY(r) ((r)->cons == (r)->prod)

#define SPICE_RING_IS_FULL(r) (((r)->prod - (r)->cons) == (r)->num_items)

#define SPICE_RING_PROD_ITEM(r) (&(r)->items[(r)->prod & SPICE_RING_INDEX_MASK(r)].el)

#define SPICE_RING_PROD_WAIT(r, wait)                 \
    if (((wait) = SPICE_RING_IS_FULL(r))) {           \
        (r)->notify_on_cons = (r)->cons + 1;    \
        spice_mb();	                        \
        (wait) = SPICE_RING_IS_FULL(r);               \
    }

#define SPICE_RING_PUSH(r, notify)                    \
    (r)->prod++;                                \
    spice_mb();                                 \
    (notify) = (r)->prod == (r)->notify_on_prod;


#define SPICE_RING_CONS_ITEM(r) (&(r)->items[(r)->cons & SPICE_RING_INDEX_MASK(r)].el)

#define SPICE_RING_CONS_WAIT(r, wait)                 \
    if (((wait) = SPICE_RING_IS_EMPTY(r))) {          \
        (r)->notify_on_prod = (r)->prod + 1;    \
        spice_mb();                             \
        (wait) = SPICE_RING_IS_EMPTY(r);              \
    }

#define SPICE_RING_POP(r, notify)                         \
    (r)->cons++;                                    \
    spice_mb();                                     \
    (notify) = (r)->cons == (r)->notify_on_cons;



#endif /* _H_SPICE_RING */

```

`include/spice/macros.h`:

```h
/* -*- Mode: C; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2010 Red Hat, Inc.

   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU Lesser General Public
   License along with this library; if not, see <http://www.gnu.org/licenses/>.
*/

/* This file is to a large extent based on gmacros.h from glib
 * Which is LGPL and copyright:
 *
 * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
 * file for a list of people on the GLib Team.  See the ChangeLog
 * files for a list of changes.  These files are distributed with
 * GLib at ftp://ftp.gtk.org/pub/gtk/.
 */

#ifndef _H_SPICE_MACROS
#define _H_SPICE_MACROS

/* We include stddef.h to get the system's definition of NULL */
#include <stddef.h>

#include <spice/types.h>

#if    __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 96)
#define SPICE_GNUC_MALLOC __attribute__((__malloc__))
#else
#define SPICE_GNUC_MALLOC
#endif

#ifndef __has_feature
#define __has_feature(x) 0  /* Compatibility with non-clang compilers. */
#endif

#if     (!defined(__clang__) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3))) || \
        (defined(__clang__) && __has_feature(__alloc_size__))
#define SPICE_GNUC_ALLOC_SIZE(x) __attribute__((__alloc_size__(x)))
#define SPICE_GNUC_ALLOC_SIZE2(x,y) __attribute__((__alloc_size__(x,y)))
#else
#define SPICE_GNUC_ALLOC_SIZE(x)
#define SPICE_GNUC_ALLOC_SIZE2(x,y)
#endif

#if     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
#define SPICE_GNUC_PRINTF( format_idx, arg_idx ) __attribute__((__format__ (__printf__, format_idx, arg_idx)))
#define SPICE_GNUC_NORETURN __attribute__((__noreturn__))
#define SPICE_GNUC_UNUSED __attribute__((__unused__))
#else   /* !__GNUC__ */
#define SPICE_GNUC_PRINTF( format_idx, arg_idx )
#define SPICE_GNUC_NORETURN
#define SPICE_GNUC_UNUSED
#endif  /* !__GNUC__ */

#ifdef G_DEPRECATED
#define SPICE_GNUC_DEPRECATED  G_DEPRECATED
#elif  __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1)
#define SPICE_GNUC_DEPRECATED  __attribute__((__deprecated__))
#elif defined(_MSC_VER) && (_MSC_VER >= 1300)
#define SPICE_GNUC_DEPRECATED  __declspec(deprecated)
#else
#define SPICE_GNUC_DEPRECATED
#endif

#if ((defined(__GNUC__) && (__GNUC__ > 6 || (__GNUC__ == 6 && __GNUC_MINOR__ >= 1))) || \
     (defined(__clang_major__) && (__clang_major__ > 3 || \
      (__clang_major__ == 3 && __clang_minor__ >= 0))))
#define SPICE_GNUC_DEPRECATED_ENUMERATOR SPICE_GNUC_DEPRECATED
#else
#define SPICE_GNUC_DEPRECATED_ENUMERATOR
#endif

#if     __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 3)
#  define SPICE_GNUC_MAY_ALIAS __attribute__((may_alias))
#else
#  define SPICE_GNUC_MAY_ALIAS
#endif

#if    __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
#define SPICE_GNUC_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
#define SPICE_GNUC_WARN_UNUSED_RESULT
#endif /* __GNUC__ */


/* Guard C code in headers, while including them from C++ */
#ifdef  __cplusplus
# define SPICE_BEGIN_DECLS  extern "C" {
# define SPICE_END_DECLS    }
#else
# define SPICE_BEGIN_DECLS
# define SPICE_END_DECLS
#endif

#ifndef	FALSE
#define	FALSE	(0)
#endif

#ifndef	TRUE
#define	TRUE	(!FALSE)
#endif

#undef	MAX
#define MAX(a, b)  (((a) > (b)) ? (a) : (b))

#undef	MIN
#define MIN(a, b)  (((a) < (b)) ? (a) : (b))

#undef	ABS
#define ABS(a)     (((a) < 0) ? -(a) : (a))

/* Count the number of elements in an array. The array must be defined
 * as such; using this with a dynamically allocated array will give
 * incorrect results.
 */
#define SPICE_N_ELEMENTS(arr) (sizeof (arr) / sizeof ((arr)[0]))

#define SPICE_ALIGN(a, size) (((a) + ((size) - 1)) & ~((size) - 1))

/* Provide convenience macros for handling structure
 * fields through their offsets.
 */

#if defined(__GNUC__)  && __GNUC__ >= 4
#  define SPICE_OFFSETOF(struct_type, member) \
    ((long) offsetof (struct_type, member))
#else
#  define SPICE_OFFSETOF(struct_type, member)	\
    ((long) ((uint8_t*) &((struct_type*) 0)->member))
#endif

/* The SPICE_USE_SAFER_CONTAINEROF macro is used to avoid
 * compilation breakage with older spice-server releases which
 * triggered some errors without an additional patch.
 */
#if defined(__GNUC__) && defined(SPICE_USE_SAFER_CONTAINEROF) && \
    (__GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4))
#define SPICE_CONTAINEROF(ptr, struct_type, member) ({ \
    const typeof( ((struct_type *)0)->member ) *__mptr = (ptr);    \
    ((struct_type *)(void *)((uint8_t *)(__mptr) - SPICE_OFFSETOF(struct_type, member))); })
#else
#define SPICE_CONTAINEROF(ptr, struct_type, member) \
    ((struct_type *)(void *)((uint8_t *)(ptr) - SPICE_OFFSETOF(struct_type, member)))
#endif

#define SPICE_MEMBER_P(struct_p, struct_offset)   \
    ((gpointer) ((guint8*) (struct_p) + (glong) (struct_offset)))
#define SPICE_MEMBER(member_type, struct_p, struct_offset)   \
    (*(member_type*) SPICE_STRUCT_MEMBER_P ((struct_p), (struct_offset)))

/* Provide simple macro statement wrappers:
 *   SPICE_STMT_START { statements; } SPICE_STMT_END;
 * This can be used as a single statement, like:
 *   if (x) SPICE_STMT_START { ... } SPICE_STMT_END; else ...
 * This intentionally does not use compiler extensions like GCC's '({...})' to
 * avoid portability issue or side effects when compiled with different compilers.
 */
#if !(defined (SPICE_STMT_START) && defined (SPICE_STMT_END))
#  define SPICE_STMT_START  do
#  define SPICE_STMT_END    while (0)
#endif

/*
 * The SPICE_LIKELY and SPICE_UNLIKELY macros let the programmer give hints to
 * the compiler about the expected result of an expression. Some compilers
 * can use this information for optimizations.
 *
 * The _SPICE_BOOLEAN_EXPR macro is intended to trigger a gcc warning when
 * putting assignments in g_return_if_fail ().
 */
#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)
#define _SPICE_BOOLEAN_EXPR(expr)               \
 __extension__ ({                               \
   int _g_boolean_var_;                         \
   if (expr)                                    \
      _g_boolean_var_ = 1;                      \
   else                                         \
      _g_boolean_var_ = 0;                      \
   _g_boolean_var_;                             \
})
#define SPICE_LIKELY(expr) (__builtin_expect (_SPICE_BOOLEAN_EXPR(expr), 1))
#define SPICE_UNLIKELY(expr) (__builtin_expect (_SPICE_BOOLEAN_EXPR(expr), 0))
#else
#define SPICE_LIKELY(expr) (expr)
#define SPICE_UNLIKELY(expr) (expr)
#endif

#ifdef _MSC_VER
#define SPICE_UINT64_CONSTANT(x) (x ## UI64)
#define SPICE_INT64_CONSTANT(x) (x ## I64)
#else
#if LONG_MAX == 2147483647L
#define SPICE_UINT64_CONSTANT(x) (x ## ULL)
#define SPICE_INT64_CONSTANT(x) (x ## LL)
#else
#define SPICE_UINT64_CONSTANT(x) (x ## UL)
#define SPICE_INT64_CONSTANT(x) (x ## L)
#endif
#endif

/* Little/Bit endian byte swapping */

#define SPICE_BYTESWAP16_CONSTANT(val)	((uint16_t) ( \
    (uint16_t) ((uint16_t) (val) >> 8) |	\
    (uint16_t) ((uint16_t) (val) << 8)))

#define SPICE_BYTESWAP32_CONSTANT(val)	((uint32_t) ( \
    (((uint32_t) (val) & (uint32_t) 0x000000ffU) << 24) | \
    (((uint32_t) (val) & (uint32_t) 0x0000ff00U) <<  8) | \
    (((uint32_t) (val) & (uint32_t) 0x00ff0000U) >>  8) | \
    (((uint32_t) (val) & (uint32_t) 0xff000000U) >> 24)))

#define SPICE_BYTESWAP64_CONSTANT(val)	((uint64_t) ( \
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x00000000000000ff)) << 56) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x000000000000ff00)) << 40) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x0000000000ff0000)) << 24) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x00000000ff000000)) <<  8) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x000000ff00000000)) >>  8) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x0000ff0000000000)) >> 24) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0x00ff000000000000)) >> 40) |	\
      (((uint64_t) (val) &						\
	(uint64_t) SPICE_UINT64_CONSTANT(0xff00000000000000)) >> 56)))

/* Arch specific stuff for speed
 */
#if defined (__GNUC__) && (__GNUC__ >= 4) && defined (__OPTIMIZE__)
#  define SPICE_BYTESWAP16(val) __builtin_bswap16(val)
#  define SPICE_BYTESWAP32(val) __builtin_bswap32(val)
#  define SPICE_BYTESWAP64(val) __builtin_bswap64(val)
#elif defined(_MSC_VER)
#  define SPICE_BYTESWAP16(val) _byteswap_ushort(val)
#  define SPICE_BYTESWAP32(val) _byteswap_ulong(val)
#  define SPICE_BYTESWAP64(val) _byteswap_uint64(val)
#else /* generic */
#  define SPICE_BYTESWAP16(val) (SPICE_BYTESWAP16_CONSTANT (val))
#  define SPICE_BYTESWAP32(val) (SPICE_BYTESWAP32_CONSTANT (val))
#  define SPICE_BYTESWAP64(val) (SPICE_BYTESWAP64_CONSTANT (val))
#endif /* generic */


/* detect endianness */
#undef SPICE_ENDIAN
#define SPICE_ENDIAN_LITTLE 4321
#define SPICE_ENDIAN_BIG    1234
#define SPICE_ENDIAN_PDP    2143

/* gcc already defined these, use them */
#if defined(__BYTE_ORDER__) && defined(__ORDER_LITTLE_ENDIAN__) \
    && defined(__ORDER_BIG_ENDIAN__) && defined(__ORDER_PDP_ENDIAN__)
#  if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
#    define SPICE_ENDIAN SPICE_ENDIAN_LITTLE
#  elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
#    define SPICE_ENDIAN SPICE_ENDIAN_BIG
#  elif __BYTE_ORDER__ == __ORDER_PDP_ENDIAN__
#    define SPICE_ENDIAN SPICE_ENDIAN_PDP
#  else
#    error __BYTE_ORDER__ not defined correctly
#  endif
#endif

/* use suggestions at http://sourceforge.net/p/predef/wiki/Endianness/ */
#ifndef SPICE_ENDIAN
#  if defined(__LITTLE_ENDIAN__) || defined(__ARMEL__) \
      || defined(__THUMBEL__) || defined(__AARCH64EL__) \
      || defined(_MIPSEL) || defined(__MIPSEL) || defined(__MIPSEL__) \
      || defined(__amd64__) || defined(__x86_64__) || defined(__i386__) \
      || defined(__e2k__)
#    define SPICE_ENDIAN SPICE_ENDIAN_LITTLE
#  endif
#  if defined(__BIG_ENDIAN__) || defined(__ARMEB__) \
      || defined(__THUMBEB__) || defined(__AARCH64EB__) \
      || defined(_MIPSEB) || defined(__MIPSEB) || defined(__MIPSEB__)
#    ifdef SPICE_ENDIAN
#      error Both little and big endian detected
#    endif
#    define SPICE_ENDIAN SPICE_ENDIAN_BIG
#  endif
#endif

/* MS compiler */
#if !defined(SPICE_ENDIAN) && defined(_MSC_VER)
/* Windows support only little endian arm */
#  if defined(_M_IX86) || defined(_M_AMD64) || defined(_M_X64) \
      || defined(_M_ARM)
#    define SPICE_ENDIAN SPICE_ENDIAN_LITTLE
#  endif
#endif

#if !defined(SPICE_ENDIAN)
#error Unable to detect processor endianness
#endif

#if SPICE_ENDIAN == SPICE_ENDIAN_PDP
#error PDP endianness not supported by Spice
#endif


#if SPICE_ENDIAN == SPICE_ENDIAN_LITTLE
#define SPICE_MAGIC_CONST(s) \
    ((uint32_t)((s[0]&0xffu)|((s[1]&0xffu)<<8)|((s[2]&0xffu)<<16)|((s[3]&0xffu)<<24)))
#else
#define SPICE_MAGIC_CONST(s) \
    ((uint32_t)((s[3]&0xffu)|((s[2]&0xffu)<<8)|((s[1]&0xffu)<<16)|((s[0]&0xffu)<<24)))
#endif

#endif /* _H_SPICE_MACROS */

```

`include/spice/start-packed.h`:

```h
/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/* Ideally this should all have been macros in a common headers, but
 * its not possible to put pragmas into macros, so we have to use
 * include magic.
 *
 * Use it like this:
 *
 * #include <spice/start-packed.h>
 *
 * typedef struct SPICE_ATTR_PACKED {
 *    ...
 * } Type;
 *
 * #include <spice/end-packed.h>
 *
 */

#ifdef __GNUC__

#define SPICE_ATTR_PACKED __attribute__ ((__packed__))
#define SPICE_ATTR_ALIGNED(n) __attribute__ ((__aligned__ (n)))

#ifdef __MINGW32__
#pragma pack(push,1)
#endif

#else

#pragma pack(push)
#pragma pack(1)
#define SPICE_ATTR_PACKED
#define SPICE_ATTR_ALIGNED(n) __declspec (align (n))
#pragma warning(disable:4200)
#pragma warning(disable:4103)

#endif

```

`include/spice/types.h`:

```h
/* -*- Mode: C; tab-width: 4; c-basic-offset: 4; indent-tabs-mode: nil -*- */
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _H_SPICE_TYPES
#define _H_SPICE_TYPES

/* We always want the standard int types
 * If they are not in stdint.h on your system,
 * include the right one here. */
#include <stdint.h>
#include <limits.h>

#endif /* _H_SPICE_TYPES */

```

`include/spice/vd_agent.h`:

```h
/*
   Copyright (C) 2009 Red Hat, Inc.

   Redistribution and use in source and binary forms, with or without
   modification, are permitted provided that the following conditions are
   met:

       * Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.
       * Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.
       * Neither the name of the copyright holder nor the names of its
         contributors may be used to endorse or promote products derived
         from this software without specific prior written permission.

   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER AND CONTRIBUTORS "AS
   IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
   TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
   PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
   HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

#ifndef _H_VD_AGENT
#define _H_VD_AGENT

#include <spice/types.h>

#include <spice/start-packed.h>

enum {
    VDP_CLIENT_PORT = 1,
    VDP_SERVER_PORT,
    VDP_END_PORT
};

typedef struct SPICE_ATTR_PACKED VDIChunkHeader {
    uint32_t port;
    uint32_t size;
} VDIChunkHeader;

typedef struct SPICE_ATTR_PACKED VDAgentMessage {
    /* Should be VD_AGENT_PROTOCOL */
    uint32_t protocol;
    /* One of VD_AGENT_xxx in the enumeration below */
    uint32_t type;
    uint64_t opaque;
    /* Size of data following */
    uint32_t size;
    uint8_t data[0];
} VDAgentMessage;

#define VD_AGENT_PROTOCOL 1
#define VD_AGENT_MAX_DATA_SIZE 2048

/*
 * Messages and types for guest agent.
 * These messages are sent through the virtio port "com.redhat.spice.0"
 * (agent <-> server) or embedded in "agent_data" SPICE protocol message in
 * the "MainChannel" (server <-> client)
 */
enum {
    /* server -> agent
     * See VDAgentMouseState structure.
     */
    VD_AGENT_MOUSE_STATE = 1,
    /* client -> agent|server.
     * Acknowledged by the agent using VD_AGENT_REPLY.
     * See VDAgentMonitorsConfig structure.
     */
    VD_AGENT_MONITORS_CONFIG,
    /* agent -> client.
     * See VDAgentReply structure.
     */
    VD_AGENT_REPLY,
    /* Set clipboard data (both directions).
     * Message comes with type and data.
     * See VDAgentClipboard structure.
     */
    VD_AGENT_CLIPBOARD,
    /* client -> agent.
     * Acknowledged by Windows agent using VD_AGENT_REPLY.
     * See VDAgentDisplayConfig structure.
    */
    VD_AGENT_DISPLAY_CONFIG,
    /* See VDAgentAnnounceCapabilities structure. */
    VD_AGENT_ANNOUNCE_CAPABILITIES,
    /* Asks to listen for clipboard changes (both directions).
     * Remote should empty clipboard and wait for one
     * of the types passed.
     * See VDAgentClipboardGrab structure.
     */
    VD_AGENT_CLIPBOARD_GRAB,
    /* Asks for clipboard data (both directions).
     * Request comes with a specific type.
     * See VDAgentClipboardRequest structure.
     */
    VD_AGENT_CLIPBOARD_REQUEST,
    /* See VDAgentClipboardRelease structure. */
    VD_AGENT_CLIPBOARD_RELEASE,
    /* See VDAgentFileXferStartMessage structure. */
    VD_AGENT_FILE_XFER_START,
    /* See VDAgentFileXferStatusMessage structure. */
    VD_AGENT_FILE_XFER_STATUS,
    /* See VDAgentFileXferDataMessage structure. */
    VD_AGENT_FILE_XFER_DATA,
    /* Empty message */
    VD_AGENT_CLIENT_DISCONNECTED,
    /* See VDAgentMaxClipboard structure. */
    VD_AGENT_MAX_CLIPBOARD,
    /* See VDAgentAudioVolumeSync structure. */
    VD_AGENT_AUDIO_VOLUME_SYNC,
    /* See VDAgentGraphicsDeviceInfo structure. */
    VD_AGENT_GRAPHICS_DEVICE_INFO,
    VD_AGENT_END_MESSAGE,
};

enum {
    VD_AGENT_FILE_XFER_STATUS_CAN_SEND_DATA,
    VD_AGENT_FILE_XFER_STATUS_CANCELLED,
    VD_AGENT_FILE_XFER_STATUS_ERROR,
    VD_AGENT_FILE_XFER_STATUS_SUCCESS,
    VD_AGENT_FILE_XFER_STATUS_NOT_ENOUGH_SPACE,
    VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED,
    VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED,
    VD_AGENT_FILE_XFER_STATUS_DISABLED,
};

typedef struct SPICE_ATTR_PACKED VDAgentFileXferStatusMessage {
    uint32_t id;
    uint32_t result;
    /* Used to send additional data for detailed error messages
     * to clients with VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS capability.
     * Type of data varies with the result:
     * result : data type (NULL if no data)
     * VD_AGENT_FILE_XFER_STATUS_ERROR : VDAgentFileXferStatusError
     * VD_AGENT_FILE_XFER_STATUS_NOT_ENOUGH_SPACE : VDAgentFileXferStatusNotEnoughSpace
     * VD_AGENT_FILE_XFER_STATUS_SESSION_LOCKED : NULL
     * VD_AGENT_FILE_XFER_STATUS_VDAGENT_NOT_CONNECTED : NULL
     * VD_AGENT_FILE_XFER_STATUS_DISABLED : NULL
     */
    uint8_t data[0];
} VDAgentFileXferStatusMessage;

/* Detailed error for VD_AGENT_FILE_XFER_STATUS_NOT_ENOUGH_SPACE.
 * Only present if VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS is
 * negotiated and the size of the message can contain it.
 */
typedef struct SPICE_ATTR_PACKED VDAgentFileXferStatusNotEnoughSpace {
    /* Disk free space in bytes. */
    uint64_t disk_free_space;
} VDAgentFileXferStatusNotEnoughSpace;

enum {
    /* Error number is a G_IO_ERROR_xxx defined in
     * https://developer.gnome.org/gio/stable/gio-GIOError.html
     */
    VD_AGENT_FILE_XFER_STATUS_ERROR_GLIB_IO,
};

/* Detailed error for VD_AGENT_FILE_XFER_STATUS_ERROR.
 * Only present if VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS is
 * negotiated and the size of the message can contain it.
 * Otherwise a generic error should be assumed and reported.
 */
typedef struct SPICE_ATTR_PACKED VDAgentFileXferStatusError {
    /* One of VD_AGENT_FILE_XFER_STATUS_ERROR_xxx enumeration
     */
    uint8_t error_type;
    /* An error code which enumeration depends on error_type
     */
    uint32_t error_code;
} VDAgentFileXferStatusError;

typedef struct SPICE_ATTR_PACKED VDAgentFileXferStartMessage {
    uint32_t id;
    uint8_t data[0];
} VDAgentFileXferStartMessage;

typedef struct SPICE_ATTR_PACKED VDAgentFileXferDataMessage {
    uint32_t id;
    uint64_t size;
    uint8_t data[0];
} VDAgentFileXferDataMessage;

typedef struct SPICE_ATTR_PACKED VDAgentMonConfig {
    /*
     * Note a width and height of 0 can be used to indicate a disabled
     * monitor, this may only be used with agents with the
     * VD_AGENT_CAP_SPARSE_MONITORS_CONFIG capability.
     */
    uint32_t height;
    uint32_t width;
    uint32_t depth;
    int32_t x;
    int32_t y;
} VDAgentMonConfig;

enum {
    VD_AGENT_CONFIG_MONITORS_FLAG_USE_POS = (1 << 0),
    VD_AGENT_CONFIG_MONITORS_FLAG_PHYSICAL_SIZE = (1 << 1),
};

typedef struct SPICE_ATTR_PACKED VDAgentMonitorsConfig {
    uint32_t num_of_monitors;
    uint32_t flags;
    VDAgentMonConfig monitors[0];
    /* only sent if the FLAG_PHYSICAL_SIZE is present: */
    /* VDAgentMonitorMM physical_sizes[0]; */
} VDAgentMonitorsConfig;


/* Physical size of the monitor in millimeters.
 * Having this information, the remote/guest display can configure itself with
 * appropriate font & scaling to maintain readability. */
typedef struct SPICE_ATTR_PACKED VDAgentMonitorMM {
    /*
     * Note a width and height of 0 can be used to indicate a disabled
     * monitor or no size information is present.
     */
    uint16_t height;
    uint16_t width;
} VDAgentMonitorMM;

enum {
    VD_AGENT_DISPLAY_CONFIG_FLAG_DISABLE_WALLPAPER = (1 << 0),
    VD_AGENT_DISPLAY_CONFIG_FLAG_DISABLE_FONT_SMOOTH = (1 << 1),
    VD_AGENT_DISPLAY_CONFIG_FLAG_DISABLE_ANIMATION = (1 << 2),
    VD_AGENT_DISPLAY_CONFIG_FLAG_SET_COLOR_DEPTH = (1 << 3),
};

typedef struct SPICE_ATTR_PACKED VDAgentDisplayConfig {
    uint32_t flags;
    uint32_t depth;
} VDAgentDisplayConfig;

#define VD_AGENT_LBUTTON_MASK (1 << 1)
#define VD_AGENT_MBUTTON_MASK (1 << 2)
#define VD_AGENT_RBUTTON_MASK (1 << 3)
#define VD_AGENT_UBUTTON_MASK (1 << 4)
#define VD_AGENT_DBUTTON_MASK (1 << 5)
#define VD_AGENT_SBUTTON_MASK (1 << 6)
#define VD_AGENT_EBUTTON_MASK (1 << 7)

typedef struct SPICE_ATTR_PACKED VDAgentMouseState {
    uint32_t x;
    uint32_t y;
    uint32_t buttons;
    uint8_t display_id;
} VDAgentMouseState;

typedef struct SPICE_ATTR_PACKED VDAgentReply {
    uint32_t type;
    uint32_t error;
} VDAgentReply;

enum {
    VD_AGENT_SUCCESS = 1,
    VD_AGENT_ERROR,
};

typedef struct SPICE_ATTR_PACKED VDAgentClipboard {
#if 0 /* VD_AGENT_CAP_CLIPBOARD_SELECTION */
    uint8_t selection;
    uint8_t __reserved[sizeof(uint32_t) - 1 * sizeof(uint8_t)];
#endif
    uint32_t type;
    uint8_t data[0];
} VDAgentClipboard;

enum {
    VD_AGENT_CLIPBOARD_NONE = 0,
    VD_AGENT_CLIPBOARD_UTF8_TEXT,
    VD_AGENT_CLIPBOARD_IMAGE_PNG,  /* All clients with image support should support this one */
    VD_AGENT_CLIPBOARD_IMAGE_BMP,  /* optional */
    VD_AGENT_CLIPBOARD_IMAGE_TIFF, /* optional */
    VD_AGENT_CLIPBOARD_IMAGE_JPG,  /* optional */
    /* identifies a list of absolute paths in phodav server
     * that is associated with the "org.spice-space.webdav.0" webdav channel;
     * the items are encoded in UTF-8 and separated by '\0';
     * the first item must be either "copy" or "cut" (without the quotes)
     * to indicate what action should be performed with the files that follow */
    VD_AGENT_CLIPBOARD_FILE_LIST,
};

enum {
    VD_AGENT_CLIPBOARD_SELECTION_CLIPBOARD = 0,
    VD_AGENT_CLIPBOARD_SELECTION_PRIMARY,
    VD_AGENT_CLIPBOARD_SELECTION_SECONDARY,
};

typedef struct SPICE_ATTR_PACKED VDAgentClipboardGrab {
#if 0 /* VD_AGENT_CAP_CLIPBOARD_SELECTION */
    uint8_t selection;
    uint8_t __reserved[sizeof(uint32_t) - 1 * sizeof(uint8_t)];
#endif
#if 0 /* VD_AGENT_CAP_CLIPBOARD_GRAB_SERIAL */
    uint32_t serial;
#endif
    uint32_t types[1];
} VDAgentClipboardGrab;

typedef struct SPICE_ATTR_PACKED VDAgentClipboardRequest {
#if 0 /* VD_AGENT_CAP_CLIPBOARD_SELECTION */
    uint8_t selection;
    uint8_t __reserved[sizeof(uint32_t) - 1 * sizeof(uint8_t)];
#endif
    uint32_t type;
} VDAgentClipboardRequest;

typedef struct SPICE_ATTR_PACKED VDAgentClipboardRelease {
#if 0 /* VD_AGENT_CAP_CLIPBOARD_SELECTION */
    uint8_t selection;
    uint8_t __reserved[sizeof(uint32_t) - 1 * sizeof(uint8_t)];
#endif
    uint8_t dummy_empty_field[0]; /* C/C++ compatibility */
} VDAgentClipboardRelease;

typedef struct SPICE_ATTR_PACKED VDAgentMaxClipboard {
    int32_t max;
} VDAgentMaxClipboard;

typedef struct SPICE_ATTR_PACKED VDAgentAudioVolumeSync {
    uint8_t is_playback;
    uint8_t mute;
    uint8_t nchannels;
    uint16_t volume[0];
} VDAgentAudioVolumeSync;

typedef struct SPICE_ATTR_PACKED VDAgentDeviceDisplayInfo {
    uint32_t channel_id;
    uint32_t monitor_id;
    uint32_t device_display_id;
    uint32_t device_address_len;
    uint8_t device_address[0];  /* a zero-terminated string */
} VDAgentDeviceDisplayInfo;


/* This message contains the mapping of (channel_id, monitor_id) pair to a
 * "physical" (virtualized) device and its monitor identified by device_address
 * and device_display_id.
 *
 * It's used on the vd_agent to identify the guest monitors for the
 * mouse_position and monitors_config messages.
 */
typedef struct SPICE_ATTR_PACKED VDAgentGraphicsDeviceInfo {
    uint32_t count;
#ifdef _MSC_VER
    uint8_t display_info[0];
#else
    VDAgentDeviceDisplayInfo display_info[0];
#endif
} VDAgentGraphicsDeviceInfo;


/* Capabilities definitions
 */
enum {
    VD_AGENT_CAP_MOUSE_STATE = 0,
    VD_AGENT_CAP_MONITORS_CONFIG,
    VD_AGENT_CAP_REPLY,
    VD_AGENT_CAP_CLIPBOARD,
    VD_AGENT_CAP_DISPLAY_CONFIG,
    VD_AGENT_CAP_CLIPBOARD_BY_DEMAND,
    VD_AGENT_CAP_CLIPBOARD_SELECTION,
    VD_AGENT_CAP_SPARSE_MONITORS_CONFIG,
    VD_AGENT_CAP_GUEST_LINEEND_LF,
    VD_AGENT_CAP_GUEST_LINEEND_CRLF,
    VD_AGENT_CAP_MAX_CLIPBOARD,
    VD_AGENT_CAP_AUDIO_VOLUME_SYNC,
    VD_AGENT_CAP_MONITORS_CONFIG_POSITION,
    VD_AGENT_CAP_FILE_XFER_DISABLED,
    VD_AGENT_CAP_FILE_XFER_DETAILED_ERRORS,
    VD_AGENT_CAP_GRAPHICS_DEVICE_INFO,
    VD_AGENT_CAP_CLIPBOARD_NO_RELEASE_ON_REGRAB,
    VD_AGENT_CAP_CLIPBOARD_GRAB_SERIAL,
    VD_AGENT_END_CAP,
};

typedef struct SPICE_ATTR_PACKED VDAgentAnnounceCapabilities {
    uint32_t  request;
    uint32_t caps[1];
} VDAgentAnnounceCapabilities;

#define VD_AGENT_CAPS_SIZE_FROM_MSG_SIZE(msg_size) \
    (((msg_size) - sizeof(VDAgentAnnounceCapabilities)) / sizeof(uint32_t))

#define VD_AGENT_CAPS_SIZE ((VD_AGENT_END_CAP + 31) / 32)

#define VD_AGENT_CAPS_BYTES (((VD_AGENT_END_CAP + 31) / 8) & ~3)

#define VD_AGENT_HAS_CAPABILITY(caps, caps_size, index) \
    ((index) < (caps_size * 32) && ((caps)[(index) / 32] & (1 << ((index) % 32))))

#define VD_AGENT_SET_CAPABILITY(caps, index) \
    { (caps)[(index) / 32] |= (1 << ((index) % 32)); }

#define VD_AGENT_CLEAR_CAPABILITY(caps, index) \
    { (caps)[(index) / 32] &= ~(1 << ((index) % 32)); }

#include <spice/end-packed.h>

#endif /* _H_VD_AGENT */

```

`include/utilities.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_UTILITY_H
#define _MVISOR_UTILITY_H

#include <unistd.h>
#include <stdio.h>
#include <string>

class Object;
typedef Object* (*ClassCreator) (void);

struct ClassItem {
  int class_type;
  const char* class_name;
  const char* class_file;
  ClassCreator create;
};

/* Initialize device classes and add to device management for later use */
void register_class(int type, const char* name, const char* source_path, ClassCreator create);
Object* realize_class(const char* name);
std::string get_class_alias(const char* name);

#define __register_class(cb, type) \
static Object* __create__##cb() { \
  auto o = new cb; \
  return o; \
} \
static void __attribute__ ((constructor)) __init__##cb(void) \
{ \
  register_class(type, #cb, __FILE__, __create__##cb); \
}


/* Use this macro at the end of .cc source file to declare your device */
#define DECLARE_DEVICE(classname)       __register_class(classname, 2)
#define DECLARE_NETWORK(classname)      __register_class(classname, 3)
#define DECLARE_DISK_IMAGE(classname)   __register_class(classname, 4)

/* Close fd and set to -1 */
static inline void safe_close(int *fd) {
  if (*fd == 0) {
    fprintf(stderr, "unable to close stdout\n");
    return;
  } else if (*fd > 0) {
    close(*fd);
    *fd = -1;
  }
}

/* Test if buffer is all zero.
 * buffer must be 256 bytes alignment */
bool test_zero(const void* buffer, size_t length);

/* Z standard compress / decompress
 * https://github.com/facebook/zstd
 */
ssize_t zstd_decompress(const void* src,  size_t src_size, void* dest, size_t dest_size);

#endif // _MVISOR_UTILITY_H

```

`include/vcpu.h`:

```h
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_VCPU_H
#define _MVISOR_VCPU_H

#include <linux/kvm.h>
#include <thread>
#include <deque>
#include <functional>
#include <mutex>

#include "hyperv/hyperv.h"
#include "migration.h"
#include "vcpu.pb.h"

#define SIG_USER_INTERRUPT (SIGRTMIN + 0)

/* https://github.com/torvalds/linux/blob/master/include/linux/sched/prio.h */
#define MAX_NICE	19
#define MIN_NICE	-20

class Machine;

typedef std::function<void(void)> VoidCallback;
struct VcpuTask {
  VoidCallback   callback;
};

struct HyperVSynic {
  bool                      enabled = false;
  uint64_t                  message_address = 0;
  uint64_t                  event_address = 0;
  hyperv_message_page*      message_page = nullptr;
  hyperv_event_flags_page*  event_flags_page = nullptr;
};

class Vcpu {
 public:
  Vcpu(Machine* machine, int vcpu_id);
  ~Vcpu();

  /* Create a vCPU thread and execute in guest VM */
  void Start();
  /* Wakeup a sleeping guest vCPU */
  void Kick();
  /* Inject a function and also signal the vCPU */
  void Schedule(VoidCallback callback);
  /* Reset vCPU registers to default values */
  void Reset();

  /* Used for migration */
  bool SaveState(MigrationWriter* writer);
  bool LoadState(MigrationReader* reader);

  /* Used for debugging */
  void EnableSingleStep();
  void PrintRegisters();

  int fd() { return fd_; }
  int vcpu_id() { return vcpu_id_; }
  std::thread& thread() { return thread_; }
  static Vcpu* current_vcpu() { return current_vcpu_; }
  const char* name() { return name_; }
  uint64_t cpuid_features() { return cpuid_features_; }

 private:
  static void SignalHandler(int signum);
  void PrepareX86Vcpu();
  void SetupSignalHandler();
  void SetupCpuid();
  void SetupMsrIndices();
  void SetupSchedPriority(int priority);
  void SetupHyperV(kvm_cpuid2* cpuid);
  void SetupMachineCheckException();
  void SetupModelSpecificRegisters();
  uint64_t GetSupportedMsrFeature(uint index);
  void SaveDefaultRegisters();
  void Process();
  void ProcessIo();
  void ProcessMmio();
  void ProcessHyperV();
  void ExecuteTasks();
  void SaveStateTo(VcpuState& state);
  void LoadStateFrom(VcpuState& state, bool load_cpuid);

  static __thread Vcpu*     current_vcpu_;

  Machine*                  machine_;
  int                       vcpu_id_ = -1;
  int                       fd_ = -1;
  char                      name_[16];
  kvm_run*                  kvm_run_ = nullptr;
  kvm_coalesced_mmio_ring*  mmio_ring_ = nullptr;
  std::thread               thread_;
  bool                      single_step_ = false;
  VcpuState                 default_state_;
  std::deque<VcpuTask>      tasks_;
  std::mutex                mutex_;
  std::set<uint32_t>        msr_indices_;
  uint32_t                  hyperv_features_ = 0;
  uint64_t                  cpuid_features_ = 0;
  HyperVSynic               hyperv_synic_;
};

#endif // _MVISOR_VCPU_H

```

`main.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <cstdio>
#include <string>
#include <unistd.h>
#include <uuid/uuid.h>
#include <getopt.h>

#include <filesystem>

#include "version.h"
#include "machine.h"


static Machine*     machine = nullptr;

#ifdef HAS_SWEET_SERVER
#include "sweet-server/server.h"
static SweetServer* sweet_server = nullptr;
#endif

#ifdef HAS_SDL
#include "gui/sdl/viewer.h"
static Viewer*      viewer = nullptr;
#endif


/* For vfio mdev, -uuid xxx is necessary */
static void IntializeArguments(int argc, char* argv[]) {
  for (int i = 1; i < argc; i++) {
    if (strcmp(argv[i], "-uuid") == 0) {
      /* Found uuid */
      return;
    }
  }

  char uuid_string[40];
  uuid_t uuid;
  uuid_generate(uuid);
  uuid_unparse(uuid, uuid_string);

  char* new_argv[argc + 3];
  for (int i = 0; i < argc; i++) {
    new_argv[i] = argv[i];
  }
  new_argv[argc] = (char*)"-uuid";
  new_argv[argc + 1] = uuid_string;
  new_argv[argc + 2] = nullptr;
  execv("/proc/self/exe", new_argv);
  perror("Failed to restart process with uuid");
  exit(1);
}

static void PrintHelp() {
  printf("Usage: mvisor [option]\n");
  printf("Options\n");
  printf("  -h, --help            Display this information.\n");
  printf("  -v, --version         Display mvisor version information.\n");
  printf("  -u, --uuid            Specified mvisor uuid information.\n");
  printf("  -n, --name            Specified mvisor name information.\n");
  printf("  -c, --config          Specified mvisor config file path.\n");
  printf("  -s, --sweet           Specified mvisor socket file path.\n");
  printf("  -p, --pidfile         Specified mvisor pid file path.\n");
  printf("  -l, --load            Load mvisor snapshot information.\n");
  printf("  -m, --migration       Start mvisor witn port from migration.\n");
}

static void PrintVersion() {
  printf("MVisor: %s\n", VERSION);
  printf("Copyright (C) 2022 Terrence <terrence@tenclass.com>.\n");
  printf("License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n");
  printf("This is free software: you are free to change and redistribute it.\n");
  printf("There is NO WARRANTY, to the extent permitted by law\n");
}

static struct option long_options[] = {
  {"help", no_argument, 0, 'h'},
  {"uuid", required_argument, 0, 'u'},
  {"name", required_argument, 0, 'n'},
  {"config", required_argument, 0, 'c'},
  {"sweet", required_argument, 0, 's'},
  {"pidfile", required_argument, 0, 'p'},
  {"load", required_argument, 0, 'l'},
  {"migration", required_argument, 0, 'm'},
  {"version", no_argument, 0, 'v'},
  {NULL, 0, 0, 0}
};

int main(int argc, char* argv[]) {
  IntializeArguments(argc, argv);

  std::string config_path = "../config/default.yaml";
  std::string vm_uuid, vm_name;
  std::string sweet_path;
  std::string pid_path;
  std::string load_path;
  std::string migration_port;

  int c, option_index = 0;
  while ((c = getopt_long_only(argc, argv, "hvc:u:n:s:p:l:", long_options, &option_index)) != -1) {
    switch (c)
    {
    case 'h':
      PrintHelp();
      return 0;
    case 'u':
      vm_uuid = optarg;
      break;
    case 'n':
      vm_name = optarg;
      break;
    case 'c':
      config_path = optarg;
      break;
    case 's':
      sweet_path = optarg;
      break;
    case 'p':
      pid_path = optarg;
      break;
    case 'l':
      load_path = optarg;
      break;
    case 'm':
      migration_port = optarg;
      break;
    case 'v':
      PrintVersion();
      return 0;
    case '?':
      PrintHelp();
      return 0;
    }
  }

  /* write pid to file if path specified */
  if (!pid_path.empty()) {
    FILE* fp = fopen(pid_path.c_str(), "wb");
    fprintf(fp, "%d\n", getpid());
    fclose(fp);
  }

  int ret = 0;
  machine = new Machine(config_path);
  machine->set_vm_uuid(vm_uuid);
  machine->set_vm_name(vm_name.empty() ? vm_uuid : vm_name);

#ifdef HAS_SWEET_SERVER
  /* There are two modes to control the virtual machine,
   * the GUI mode is to start a SDL viewwer,
   * and the non-GUI mode is to start a sweet server
   */
  if (!sweet_path.empty()) {
    sweet_server = new SweetServer(machine, sweet_path);
    auto quit_callback = [](int signum) {
      MV_UNUSED(signum);

      machine->Quit();
      sweet_server->Close();
    };
    signal(SIGINT, quit_callback);
    signal(SIGTERM, quit_callback);

    if (!migration_port.empty()) {
      std::thread([&migration_port]() {
        machine->Load(atoi(migration_port.c_str()));
      }).detach();
    } else if (!load_path.empty()) {
      std::thread([&load_path]() {
        machine->Load(load_path);
      }).detach();
    }

    ret = sweet_server->MainLoop();
    delete machine;
    delete sweet_server;
  }
#endif

#ifdef HAS_SDL
  if (sweet_path.empty()) {
    /* SDL handles default signals */
    viewer = new Viewer(machine);

    if (!migration_port.empty()) {
      machine->Load(atoi(migration_port.c_str()));
    } else if (!load_path.empty()) {
      machine->Load(load_path);
    }
    machine->Resume();

    ret = viewer->MainLoop();
    delete machine;
    delete viewer;
  }
#endif

  if (!pid_path.empty()) {
    unlink(pid_path.c_str());
  }
  return ret;
}

```

`meson.build`:

```build
project('mvisor', 'c', 'cpp',
  version: '2.5.2',
  license: 'GPLv3',
  default_options: [
    'buildtype=debug',
    'warning_level=2',
    'cpp_std=c++17',
    'werror=true'
  ]
)

mvisor_version_data = configuration_data()
mvisor_version_data.set_quoted('VERSION', meson.project_version())

add_project_arguments([
  '-Wno-address-of-packed-member',
  '-Wno-missing-field-initializers',
  '-mavx2'
], language: 'cpp')

add_project_link_arguments(['-lstdc++fs'], language: 'cpp')

protoc = find_program('protoc')
proto_gen = generator(protoc,
  output: ['@BASENAME@.pb.cc', '@BASENAME@.pb.h'],
  arguments: ['--proto_path=@CURRENT_SOURCE_DIR@', '--cpp_out=@BUILD_DIR@', '@INPUT@']
)
proto_sources = []

mvisor_include = [include_directories('include')]
mvisor_sources = ['main.cc']

mvisor_deps = [
  dependency('threads'),
  dependency('uuid')
]

subdir('core')
subdir('migration')
subdir('devices')
subdir('images')
subdir('networks/uip')
subdir('utilities')

if get_option('sdl')
  subdir('gui' / 'sdl')
  mvisor_version_data.set('HAS_SDL', true)
endif
if get_option('gtk')
  subdir('gui' / 'gtk')
  mvisor_version_data.set('HAS_GTK', true)
endif

if get_option('sweet-server')
  subdir('sweet-server')
  mvisor_version_data.set('HAS_SWEET_SERVER', true)
endif

proto_interface = declare_dependency(
  sources: proto_sources,
  dependencies: dependency('protobuf')
)

mvisor_deps += proto_interface

mvisor = executable('mvisor',
  sources: mvisor_sources,
  include_directories : mvisor_include,
  dependencies: mvisor_deps,
  install: true,
  install_dir: '/mnt/server/opt/mvisor/build/bin/'
)

configure_file(output: 'version.h',
  configuration: mvisor_version_data
)

summary({
  'sdl': get_option('sdl'),
  'vgpu': get_option('vgpu'),
  'sweet-server': get_option('sweet-server')
}, bool_yn: true, section: 'Options')


run_target('run', command: [mvisor])
run_target('debug', command: ['gdb', '-ex', 'handle SIG34 nostop pass', '-ex', 'run', mvisor])
run_target('load', command: [mvisor, '-config', '/tmp/save/configuration.yaml', '-load', '/tmp/save'])


```

`meson_options.txt`:

```txt
option('sweet-server',
  type: 'boolean',
  value: false,
  description: 'Enable sweet protocol'
)

option('sdl',
  type: 'boolean',
  value: true,
  description: 'Enable SDL GUI'
)

option('gtk',
  type: 'boolean',
  value: true,
  description: 'Enable GTK GUI'
)

option('qxl',
  type: 'boolean',
  value: true,
  description: 'Enable QXL device'
)

option('vgpu',
  type: 'boolean',
  value: false,
  description: 'Enable VGPU device'
)

```

`migration/file_reader.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <filesystem>

#include "logger.h"
#include "machine.h"
#include "migration.h"


MigrationFileReader::MigrationFileReader(std::string base_path) {
  base_path_ = base_path;
}

MigrationFileReader::~MigrationFileReader() {

}

void MigrationFileReader::SetPrefix(std::string prefix) {
  prefix_ = prefix;
}

bool MigrationFileReader::ReadRaw(std::string tag, void* data, size_t size) {
  BeginRead(tag);
  auto ptr = (uint8_t*)data;
  while (size > 0) {
    auto ret = read(fd_, ptr, size);
    if (ret <= 0) {
      MV_PANIC("failed to read fd=%d ret=%ld", fd_, ret);
    }
    ptr += ret;
    size -= ret;
  }
  EndRead(tag);
  return true;
}

bool MigrationFileReader::ReadProtobuf(std::string tag, Message& message) {
  BeginRead(tag);
  message.Clear();
  bool ret = message.ParseFromFileDescriptor(fd_);
  EndRead(tag);
  return ret;
}

bool MigrationFileReader::ReadMemoryPages(std::string tag, void** pages_ptr, size_t size) {
  BeginRead(tag);
  *pages_ptr = mmap(*pages_ptr, size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_NORESERVE | MAP_FIXED, fd_, 0);
  if (*pages_ptr == MAP_FAILED) {
    MV_PANIC("failed to map memory %s", tag.c_str());
  }
  EndRead(tag);

  /* Make memory pages DONTDUMP */
  MV_ASSERT(madvise(*pages_ptr, size, MADV_MERGEABLE) == 0);
  MV_ASSERT(madvise(*pages_ptr, size, MADV_DONTDUMP) == 0);
  return true;
}

int MigrationFileReader::BeginRead(std::string tag) {
  MV_ASSERT(fd_ == -1);
  auto full_path = std::filesystem::path(base_path_) / prefix_ / tag;
  fd_ = open(full_path.c_str(), O_RDONLY);
  if (fd_ == -1) {
    MV_PANIC("failed to read %s", full_path.c_str());
  }

  struct stat st;
  fstat(fd_, &st);
  file_size_ = st.st_size;
  return fd_;
}

void MigrationFileReader::EndRead(std::string tag) {
  MV_UNUSED(tag);
  safe_close(&fd_);
}

size_t MigrationFileReader::ReadRawWithLimit(std::string tag, void* data, size_t limit) {
  MV_UNUSED(tag);
  MV_UNUSED(data);
  MV_UNUSED(limit);
  MV_PANIC("not implemented");
  return 0;
}

bool MigrationFileReader::Exists(std::string tag) {
  auto full_path = std::filesystem::path(base_path_) / prefix_ / tag;
  if (std::filesystem::exists(full_path)) {
    return true;
  }
  return false;
}

```

`migration/file_writer.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include <filesystem>

#include "logger.h"
#include "machine.h"
#include "migration.h"


MigrationFileWriter::MigrationFileWriter(std::string base_path) {
if (std::filesystem::exists(base_path)) {
    std::filesystem::remove_all(base_path);
  }
  std::filesystem::create_directory(base_path);

  base_path_ = base_path;
}

MigrationFileWriter::~MigrationFileWriter() {
  
}

void MigrationFileWriter::SetPrefix(std::string prefix) {
  prefix_ = prefix;
}

bool MigrationFileWriter::WriteRaw(std::string tag, void* data, size_t size) {
  BeginWrite(tag);
  auto ptr = (uint8_t*)data;
  while (size > 0) {
    auto ret = write(fd_, ptr, size);
    if (ret <= 0) {
      MV_PANIC("failed to write fd=%d ret=%ld", fd_, ret);
    }
    ptr += ret;
    size -= ret;
  }
  EndWrite(tag);
  return true;
}

bool MigrationFileWriter::WriteProtobuf(std::string tag, const Message& message) {
  BeginWrite(tag);
  message.SerializePartialToFileDescriptor(fd_);
  EndWrite(tag);
  return true;
}

bool MigrationFileWriter::WriteMemoryPages(std::string tag, void* pages, size_t size) {
  /* Write RAM to sparse file */
  BeginWrite(tag);
  ftruncate(fd_, size);

  auto ptr = (uint8_t*)pages;
  for (size_t pos = 0; pos < size; pos += PAGE_SIZE) {
    if (!test_zero(ptr, PAGE_SIZE)) {
      pwrite(fd_, ptr, PAGE_SIZE, pos);
    }
    ptr += PAGE_SIZE;
  }
  
  EndWrite(tag);
  return true;
}

int MigrationFileWriter::BeginWrite(std::string tag) {
  MV_ASSERT(fd_ == -1);
  auto full_path = std::filesystem::path(base_path_) / prefix_;
  if (!std::filesystem::exists(full_path)) {
    std::filesystem::create_directories(full_path);
  }
  full_path /= tag;

  /* Removing a file is faster than truncating, why ?? */
  if (exists(full_path)) {
    std::filesystem::remove(full_path);
  }

  fd_ = open(full_path.c_str(), O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
  MV_ASSERT(fd_ != -1);
  return fd_;
}

void MigrationFileWriter::EndWrite(std::string tag) {
  MV_UNUSED(tag);
  safe_close(&fd_);
}


```

`migration/meson.build`:

```build
mvisor_sources += files(
  'file_reader.cc',
  'file_writer.cc',
  'network_reader.cc',
  'network_writer.cc',
)

```

`migration/network_reader.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <arpa/inet.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "logger.h"
#include "machine.h"
#include "migration.h"


MigrationNetworkReader::MigrationNetworkReader() {

}

MigrationNetworkReader::~MigrationNetworkReader() {
  MV_ASSERT(cache_map_.empty());
  safe_close(&socket_fd_);
}

bool MigrationNetworkReader::WaitForConnection(uint16_t port) {
  auto server_socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  MV_ASSERT(server_socket != -1);

  int flag = 1;
  MV_ASSERT(setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag)) == 0);

  sockaddr_in server_addr = {
    .sin_family = AF_INET,
    .sin_port = htons(port),
    .sin_addr = {
      .s_addr = htonl(INADDR_ANY)
    },
    .sin_zero = {0}
  };
  MV_ASSERT(bind(server_socket, (sockaddr*)&server_addr, sizeof(server_addr)) == 0);
  MV_ASSERT(listen(server_socket, 1) == 0);

  sockaddr_in client_addr;
  socklen_t addr_len = sizeof(client_addr);

  // wait for connection to source vm
  socket_fd_ = accept(server_socket, (sockaddr*)&client_addr, &addr_len);
  MV_ASSERT(socket_fd_ != -1);

  safe_close(&server_socket);
  return true;
}

int MigrationNetworkReader::BeginRead(std::string tag) {
  MV_UNUSED(tag);
  return 0;
}

void MigrationNetworkReader::SetPrefix(std::string prefix) {
  MV_UNUSED(prefix);
}

void MigrationNetworkReader::EndRead(std::string tag) {
  MV_UNUSED(tag);
}

void MigrationNetworkReader::Read(void* data, size_t size) {
  MV_ASSERT(socket_fd_ != -1);
  auto pos = (uint8_t*)data;
  auto remain_size = size;
  while (remain_size > 0) {
    auto ret = recv(socket_fd_, pos, remain_size, 0);
    if (ret <= 0) {
      MV_PANIC("socket error happened");
      break;
    }
    pos += ret;
    remain_size -= ret;
  }
  MV_ASSERT(remain_size == 0);
}

void MigrationNetworkReader::FreeCacheData(MigrationNetworkData* data) {
  MV_ASSERT(data != nullptr);
  if (data->header.size) {
    MV_ASSERT(data->body != nullptr);
    delete data->body;
  }
  delete data;
}

MigrationNetworkData* MigrationNetworkReader::ReadFromCache(std::string tag)  {
  MigrationNetworkData* data = nullptr;
  auto iter = cache_map_.find(tag);
  if (iter != cache_map_.end()) {
    auto& cache_queue = iter->second;
    MV_ASSERT(!cache_queue.empty());

    // get cache data
    data = cache_queue.front();
    cache_queue.pop();

    if (cache_queue.empty()) {
      cache_map_.erase(tag);
    }
  }
  return data;
}

MigrationNetworkDataHeader MigrationNetworkReader::WaitForDataHeader(std::string tag) {
  MV_ASSERT(socket_fd_ != -1);
  MigrationNetworkDataHeader header;
  while (true) {
    Read(&header, sizeof(header));
    if (0 == strcmp(tag.c_str(), header.tag)) {
      // find the right data header
      break;
    } else {
      // cache header+body when tag was mismatched
      MigrationNetworkData* data = new MigrationNetworkData;
      data->header = header;
      if (header.size != 0) {
        auto body = new uint8_t[header.size];
        Read(body, header.size);
        data->body = body;
      }
      cache_map_[data->header.tag].push(data);
    }
  }
  return header;
}

size_t MigrationNetworkReader::ReadRawWithLimit(std::string tag, void* data, size_t limit) {
  MV_ASSERT(limit > 0);
  size_t size = 0;
  auto cached_data = ReadFromCache(tag);
  if (cached_data) {
    size = std::min(cached_data->header.size, limit);
    if (size) {
      memcpy(data, cached_data->body, size);
    }
    FreeCacheData(cached_data);
  } else {
    size = std::min(WaitForDataHeader(tag).size, limit);
    if (size) {
      Read(data, size);
    }
  }
  return size;
}

bool MigrationNetworkReader::ReadRaw(std::string tag, void* data, size_t size) {
  auto cached_data = ReadFromCache(tag);
  if (cached_data) {
    MV_ASSERT(cached_data->header.size == size);
    if (size) {
      memcpy(data, cached_data->body, size);
    }
    FreeCacheData(cached_data);
  } else {
    MV_ASSERT(size == WaitForDataHeader(tag).size);
    if (size) {
      Read(data, size);
    }
  }
  return true;
}

bool MigrationNetworkReader::ReadProtobuf(std::string tag, Message& message) {
  auto cached_data = ReadFromCache(tag);
  if (cached_data) {
    message.ParsePartialFromArray(cached_data->body, cached_data->header.size);
    FreeCacheData(cached_data);
  } else {
    size_t size = WaitForDataHeader(tag).size;
    auto data = new uint8_t[size];
    Read(data, size);
    message.ParsePartialFromArray(data, size);
    delete data;
  }
  return true;
}

bool MigrationNetworkReader::ReadMemoryPages(std::string tag, void** pages_ptr, size_t size) {
  *pages_ptr = mmap(*pages_ptr, size, PROT_READ | PROT_WRITE,
    MAP_PRIVATE | MAP_ANONYMOUS | MAP_NORESERVE | MAP_FIXED, -1, 0);
  MV_ASSERT(*pages_ptr != MAP_FAILED);

  auto remain_size = size;
  auto ptr = (uint8_t*)*pages_ptr;

  auto cached_data = ReadFromCache(tag);
  if (cached_data) {
    while (true) {
      // handle the cached data first
      if (cached_data->header.size) {
        memcpy(ptr, cached_data->body, PAGE_SIZE);
      }
      FreeCacheData(cached_data);

      // next page
      ptr += PAGE_SIZE;
      remain_size -= PAGE_SIZE;
      if (remain_size == 0) {
        // jump out
        break;
      }

      // get next cached data in list
      cached_data = ReadFromCache(tag);

      // make sure the next cached_data exists
      MV_ASSERT(cached_data != nullptr);
    }
  } else {
    while (remain_size > 0) {
      MigrationNetworkDataHeader header = WaitForDataHeader(tag);
      if (header.size) {
        Read(ptr, PAGE_SIZE);
      }

      // next page
      ptr += PAGE_SIZE;
      remain_size -= PAGE_SIZE;
    }
  }
  MV_ASSERT(remain_size == 0);

  /* Make memory pages DONTDUMP */
  MV_ASSERT(madvise(*pages_ptr, size, MADV_MERGEABLE) == 0);
  MV_ASSERT(madvise(*pages_ptr, size, MADV_DONTDUMP) == 0);
  return true;
}

void MigrationNetworkReader::SendSignal(MigrationSignalType type) {
  MV_ASSERT(socket_fd_ != -1);
  MigrationSignal signal = {
    .type = type
  };
  auto size = sizeof(signal);
  auto pos = (uint8_t*)&signal;
  while (size > 0) {
    auto ret = send(socket_fd_, pos, size, 0);
    MV_ASSERT(ret > 0);
    size -= ret;
    pos += ret;
  }
}

void MigrationNetworkReader::ReadToFile(std::string tag, std::string path, size_t offset) {
  auto fd = open(path.c_str(), O_RDWR);
  MV_ASSERT(fd > 0);

  auto cached_data = ReadFromCache(tag);
  if (cached_data) { 
    auto pos = cached_data->body;
    auto remain_size = cached_data->header.size;
    while (remain_size > 0) {
      auto ret = pwrite(fd, pos, remain_size, offset);
      MV_ASSERT(ret > 0);

      remain_size -= ret;
      offset += ret;
      pos += ret;
    }
    MV_ASSERT(remain_size == 0);
    FreeCacheData(cached_data);
  } else {
    auto header = WaitForDataHeader(tag);
    MV_ASSERT(ftruncate(fd, offset + header.size) == 0);

    auto file_ptr = mmap(nullptr, header.size, PROT_WRITE, MAP_SHARED, fd, offset);
    MV_ASSERT(file_ptr != MAP_FAILED);

    // write to file directly from socket buffer
    Read(file_ptr, header.size);
    munmap(file_ptr, header.size);
  }

  safe_close(&fd);
}

bool MigrationNetworkReader::Exists(std::string tag) {
  MV_UNUSED(tag);
  return true;
}

```

`migration/network_writer.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 cair <rui.cai@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include <arpa/inet.h>
#include <fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#include "logger.h"
#include "machine.h"
#include "migration.h"


MigrationNetworkWriter::MigrationNetworkWriter() {
  
}

MigrationNetworkWriter::~MigrationNetworkWriter() {
  safe_close(&socket_fd_);
}

int MigrationNetworkWriter::BeginWrite(std::string tag) {
  MV_UNUSED(tag);
  return 0;
}

void MigrationNetworkWriter::SetPrefix(std::string prefix) {
  MV_UNUSED(prefix);
}

void MigrationNetworkWriter::EndWrite(std::string tag) {
  MV_UNUSED(tag);
}

bool MigrationNetworkWriter::Connect(std::string ip, uint16_t port) {
  in_addr ip_address;
  if (!inet_aton(ip.c_str(), &ip_address)) {
    MV_ERROR("invalid ip=%s", ip.c_str());
    return false;
  }

  socket_fd_ = socket(AF_INET, SOCK_STREAM, 0);
  if (socket_fd_ == -1) {
    MV_ERROR("create socket error");
    return false;
  }

  sockaddr_in dest_addr = {
    .sin_family = AF_INET,
    .sin_port = htons(port),
    .sin_addr = {
      .s_addr = htonl(ntohl(ip_address.s_addr))
    },
    .sin_zero = {0}
  };
  if (connect(socket_fd_, (sockaddr*)&dest_addr, sizeof(dest_addr)) != 0) {
    MV_ERROR("failed to connect target ip=%s", ip.c_str());
    return false;
  }
  return true;
}

bool MigrationNetworkWriter::Write(void* data, size_t size) {
  auto pos = (uint8_t*)data;
  auto remain_size = size;
  while (remain_size > 0) {
    auto ret = send(socket_fd_, pos, remain_size, 0);
    if (ret <= 0) {
      MV_ERROR("socket error happened");
      return false;
    }
    pos += ret;
    remain_size -= ret;
  }
  return true;
}

bool MigrationNetworkWriter::WriteRaw(std::string tag, void* data, size_t size) {
  // make migration data header
  MigrationNetworkDataHeader header;
  MV_ASSERT(tag.length() < sizeof(header.tag));
  strcpy(header.tag, tag.c_str());
  header.size = size;

  // send data header
  bool ret = Write(&header, sizeof(header));
  if (ret && data && size) {
    // send data body
    ret = Write(data, size);
  }
  return ret;
}

bool MigrationNetworkWriter::WriteProtobuf(std::string tag, const Message& message) {
  auto size = message.ByteSizeLong();
  auto data = new uint8_t[size];
  auto ret = message.SerializePartialToArray(data, size);
  if (ret) {
    ret = WriteRaw(tag, data, size);
  }
  delete data;
  return ret;
}

bool MigrationNetworkWriter::WriteMemoryPages(std::string tag, void* pages, size_t size) {
  bool ret = false;
  auto pos = (uint8_t*)pages;
  auto remain_size = size;
  while (remain_size > 0) {
    if (test_zero(pos, PAGE_SIZE)) {
      ret = WriteRaw(tag, nullptr, 0);
    } else {
      ret = WriteRaw(tag, pos, PAGE_SIZE);
    }

    if (!ret) {
      break;
    }
    pos += PAGE_SIZE;
    remain_size -= PAGE_SIZE;
  }
  return ret;
}

bool MigrationNetworkWriter::WaitForSignal(MigrationSignalType type) {
  MigrationSignal signal;
  auto size = sizeof(signal);
  auto pos = (uint8_t*)&signal;
  while (size > 0) {
    auto ret = recv(socket_fd_, pos, size, 0);
    if (ret <= 0) {
      MV_ERROR("socket error happened");
      return false;
    }
    size -= ret;
    pos += ret;
  }
  return type == signal.type;
}

bool MigrationNetworkWriter::WriteFromFile(std::string tag, std::string path, size_t offset) {
  auto fd = open(path.c_str(), O_RDONLY);
  if (fd <= 0) {
    return false;
  }

  struct stat st;
  MV_ASSERT(fstat(fd, &st) != -1);
  MV_ASSERT(offset < (size_t)st.st_size);

  auto size = st.st_size - offset;
  auto file_ptr = mmap(nullptr, size, PROT_READ, MAP_SHARED, fd, offset);
  MV_ASSERT(file_ptr != MAP_FAILED);

  auto ret = WriteRaw(tag, file_ptr, size);
  munmap(file_ptr, size);
  safe_close(&fd);
  return ret;
}

```

`networks/uip/core.cc`:

```cc
/* 
 * MVisor User Mode TCP/IP Network
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <list>
#include <deque>

#include <netdb.h>
#include <linux/if_arp.h>

#include "object.h"
#include "device.h"
#include "device_interface.h"
#include "device_manager.h"
#include "logger.h"


#define MAX_OPEN_TCP_SOCKETS    1024
#define MAX_OPEN_UDP_SOCKETS    1024
#define MAX_OPEN_ICMP_SOCKETS   128


struct ArpMessage {
  uint16_t    ar_hrd;    /* format of hardware address  */
  uint16_t    ar_pro;    /* format of protocol address  */
  uint8_t     ar_hln;    /* length of hardware address  */
  uint8_t     ar_pln;    /* length of protocol address  */
  uint16_t    ar_op;     /* ARP opcode (command)    */

  /*
  * Ethernet looks like this : This bit is variable sized however...
  */
  uint8_t     ar_sha[ETH_ALEN];  /* sender hardware address  */
  uint32_t    ar_sip;            /* sender IP address    */
  uint8_t     ar_tha[ETH_ALEN];  /* target hardware address  */
  uint32_t    ar_tip;            /* target IP address    */
} __attribute__((packed));


static std::deque<std::string> Split(std::string input, std::string token) {
  std::deque<std::string> result;
  size_t start = 0;
  while (true) {
    auto token_pos = input.find_first_of(token, start);
    result.emplace_back(input.substr(start, token_pos - start));
    if (token_pos == std::string::npos) {
      break;
    } else {
      start = token_pos + token.length();
    }
  }
  return result;
}


class Uip : public Object, public NetworkBackendInterface {
 private:
  std::list<TcpSocket*>     tcp_sockets_;
  std::list<UdpSocket*>     udp_sockets_;
  std::list<IcmpSocket*>    icmp_sockets_;
  IoTimer*                  timer_ = nullptr;
  PciDevice*                real_device_ = nullptr;
  std::vector<Ipv4Packet*>  queued_packets_;
  uint                      mtu_;
  bool                      restrict_ = false;
  std::vector<int>          map_fds_;

 public:
  Uip() {
  }

  virtual ~Uip() {
    if (timer_) {
      real_device_->RemoveTimer(timer_);
    }
    for (auto fd : map_fds_) {
      real_device_->StopPolling(fd);
      safe_close(&fd);
    }
    /* Release all resources */
    Reset();
  }

  /* UIP Router Configuration / Router MAC: 5255C0A80001 */
  virtual void Initialize(NetworkDeviceInterface* device, MacAddress& mac) {
    device_ = device;
    guest_mac_ = mac;
    memcpy(router_mac_.data, "\x52\x55\xC0\xA8\x00\x01", ETH_ALEN);
    mtu_ = 4096 - 16;

    // Default configuration 192.168.128.1/24
    router_subnet_mask_ = 0xFFFFFF00;
    router_ip_ = 0xC0A88001;

    // This function could only be called once
    MV_ASSERT(real_device_ == nullptr);
    real_device_ = dynamic_cast<PciDevice*>(device_);
    timer_ = real_device_->AddTimer(NS_PER_SECOND * 10, true, [this](){
      OnTimer();
    });

    if (real_device_->has_key("restrict")) {
      restrict_ = std::get<bool>((*real_device_)["restrict"]);
    }

    if (real_device_->has_key("router")) {
      auto router = std::get<std::string>((*real_device_)["router"]);
      // Parse 192.168.2.2/24
      auto slash_pos = router.find('/');
      if (slash_pos != std::string::npos) {
        in_addr ip;
        if (inet_aton(router.substr(0, slash_pos).c_str(), &ip)) {
          router_ip_ = ntohl(ip.s_addr);
          auto mask_bits = atoi(router.substr(slash_pos + 1).c_str());
          router_subnet_mask_ = 0xFFFFFFFF << (32 - mask_bits);
        }
      }
    }

    // Generate guest ip after router ip is determined
    for (uint x = 0x64; x <= 0xF0; x++) {
      guest_ip_ = (router_ip_ & router_subnet_mask_) | x;
      if (guest_ip_ != router_ip_)
        break;
    }

    if (real_device_->has_key("redirect")) {
      auto redirect = std::get<std::string>((*real_device_)["redirect"]);
      // Parse tcp:192.168.2.2:7070-127.0.0.1:7070;udp:192.168.2.2:8000-www.test.com:8000
      for (auto rule : Split(redirect, ";")) {
        ParseRedirectRule(rule);
      }
    }

    if (real_device_->has_key("map")) {
      auto map = std::get<std::string>((*real_device_)["map"]);
      for (auto rule : Split(map, ";")) {
        ParseMapRule(rule);
      }
      StartMapServices();
    }
  }

  virtual void SetMtu(int mtu) {
    mtu_ = mtu;
    MV_ASSERT(mtu_ + 16 <= 4096);
  }

  virtual void Reset() {
    for (auto p : queued_packets_) {
      p->Release();
    }
    queued_packets_.clear();
    
    for (auto it = udp_sockets_.begin(); it != udp_sockets_.end(); it++) {
      delete *it;
    }
    udp_sockets_.clear();
    for (auto it = tcp_sockets_.begin(); it != tcp_sockets_.end(); it++) {
      delete *it;
    }
    tcp_sockets_.clear();
    for (auto it = icmp_sockets_.begin(); it != icmp_sockets_.end(); it++) {
      delete *it;
    }
    icmp_sockets_.clear();
  }

  // Parse tcp:192.168.2.2:7070
  bool ParseEndpoint(std::string endpoint, uint8_t* protocol, std::string* address, uint16_t* port) {
    auto parts = Split(endpoint, ":");
    if (parts.size() < 2 || parts.size() > 3) {
      MV_PANIC("Invalid endpoint %s", endpoint.c_str());
      return false;
    }

    *protocol = 0;
    if (parts.size() == 3) {
      if (parts[0] == "tcp") {
        *protocol = 0x06;
      } else if (parts[0] == "udp") {
        *protocol = 0x11;
      } else {
        MV_ERROR("unknown protocol %s", parts[0].c_str());
      }
      parts.pop_front();
    }

    *address = parts[0];
    *port = atoi(parts[1].c_str());
    return true;
  }

  // Parse tcp:192.168.2.2:7070-127.0.0.1:7070
  void ParseRedirectRule(std::string input) {
    auto endpoints = Split(input, "-");
    MV_ASSERT(endpoints.size() == 2);
    
    RedirectRule rule;
    std::string address;
    uint8_t protocol;
    uint16_t port;
    if (!ParseEndpoint(endpoints[0], &protocol, &address, &port)) {
      return;
    }

    rule.protocol = protocol;
    rule.match_ip = ntohl(inet_addr(address.c_str()));
    rule.match_port = port;
    if (!ParseEndpoint(endpoints[1], &protocol, &address, &port)) {
      return;
    }
    auto entry = gethostbyname2(address.c_str(), AF_INET);
    if (!entry) {
      MV_LOG("failed to resolve name %s", address.c_str());
      return;
    }
    rule.target_ip = ntohl(*(in_addr_t*)entry->h_addr_list[0]);
    rule.target_port = port;
    redirect_rules_.push_back(rule);
  }

  // Parse tcp:0.0.0.0:8080-:7070
  void ParseMapRule(std::string input) {
    auto endpoints = Split(input, "-");
    MV_ASSERT(endpoints.size() == 2);

    MapRule rule;
    std::string address;
    uint8_t protocol;
    uint16_t port;
    if (!ParseEndpoint(endpoints[0], &protocol, &address, &port)) {
      return;
    }

    /* Currently only TCP service is allowed */
    MV_ASSERT(protocol == 0x06);
    rule.protocol = protocol;
    if (!address.empty()) {
      rule.listen_ip = ntohl(inet_addr(address.c_str()));
    } else {
      rule.listen_ip = INADDR_ANY;
    }
    rule.listen_port = port;
    if (!ParseEndpoint(endpoints[1], &protocol, &address, &port)) {
      return;
    }
    if (!address.empty()) {
      rule.target_ip = ntohl(inet_addr(address.c_str()));
    } else {
      rule.target_ip = guest_ip_;
    }
    rule.target_port = port;
    map_rules_.push_back(rule);
  }

  void StartMapServices() {
    for (auto& rule : map_rules_) {
      sockaddr_in addr = {
        .sin_family = AF_INET,
        .sin_port = htons(rule.listen_port),
        .sin_addr = {
          .s_addr = htonl(rule.listen_ip)
        },
        .sin_zero = {0}
      };

      int fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
      MV_ASSERT(fd >= 0);

      // Set socket reuse flag
      int flag = 1;
      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &flag, sizeof(flag));
  
      if (bind(fd, (sockaddr*)&addr, sizeof(addr)) != 0) {
        MV_ERROR("failed to bind address %s:%d", inet_ntoa(addr.sin_addr), rule.listen_port);
        safe_close(&fd);
        continue;
      }
      MV_ASSERT(listen(fd, 128) == 0);
      map_fds_.push_back(fd);
      if (real_device_->debug()) {
        MV_LOG("listen ip=0x%x port=%d fd=%d", rule.listen_ip, rule.listen_port, fd);
      }

      real_device_->StartPolling(fd, EPOLLIN, [this, fd, rule](auto events) {
        if (events & EPOLLIN) {
          sockaddr_in addr;
          socklen_t addr_len = sizeof(addr);
          int conn_fd = accept4(fd, (sockaddr*)&addr, &addr_len, SOCK_NONBLOCK);
          if (conn_fd != -1) {
            if (addr.sin_addr.s_addr == htonl(INADDR_LOOPBACK)) {
              addr.sin_addr.s_addr = htonl(router_ip_);
            }
            auto sock = new MapTcpSocket(this, rule.target_ip, ntohl(addr.sin_addr.s_addr),
              rule.target_port, ntohs(addr.sin_port), conn_fd);
            tcp_sockets_.push_back(sock);
          }
        } else {
          MV_LOG("invalid events=0x%x", events);
        }
      });
    }
  }

  void OnTimer() {
    for (auto it = tcp_sockets_.begin(); it != tcp_sockets_.end();) {
      if (!(*it)->active()) {
        delete *it;
        it = tcp_sockets_.erase(it);
      } else {
        it++;
      }
    }
    for (auto it = udp_sockets_.begin(); it != udp_sockets_.end();) {
      if (!(*it)->active()) {
        delete *it;
        it = udp_sockets_.erase(it);
      } else {
        it++;
      }
    }
    for (auto it = icmp_sockets_.begin(); it != icmp_sockets_.end();) {
      if (!(*it)->active()) {
        delete *it;
        it = icmp_sockets_.erase(it);
      } else {
        it++;
      }
    }
    if (real_device_->debug()) {
      MV_LOG("sockets tcp=%lu udp=%lu icmp=%lu", tcp_sockets_.size(), udp_sockets_.size(), icmp_sockets_.size());
    }
  }

  virtual void OnReceiveAvailable() {
    while (!queued_packets_.empty()) {
      auto packet = queued_packets_.back();
      queued_packets_.pop_back();
      if (!OnPacketFromHost(packet)) {
        return;
      }
    }

    for (auto it = tcp_sockets_.begin(); it != tcp_sockets_.end() && queued_packets_.empty(); it++) {
      if ((*it)->active()) {
        (*it)->OnGuestBufferAvaialble();
      }
    }

    for (auto it = udp_sockets_.begin(); it != udp_sockets_.end() && queued_packets_.empty(); it++) {
      if ((*it)->active()) {
        (*it)->OnGuestBufferAvaialble();
      }
    }
  }

  virtual void OnFrameFromGuest(std::deque<iovec>& vector) {
    auto packet = new Ipv4Packet;
    packet->Release = [packet]() {
      delete packet;
    };
    size_t copied = 0;
    for (auto &v : vector) {
      memcpy(packet->buffer + copied, v.iov_base, v.iov_len);
      copied += v.iov_len;
    }

    packet->eth = (ethhdr*)packet->buffer;
    ParseEthPacket(packet);
  }

  bool OnFrameFromHost(uint16_t protocol, void* buffer, size_t size) {
    /* Ethernet header is filled here */
    ethhdr* eth = (ethhdr*)buffer;
    eth->h_proto = htons(protocol);
    memcpy(eth->h_dest, guest_mac_.data, sizeof(eth->h_dest));
    memcpy(eth->h_source, router_mac_.data, sizeof(eth->h_source));

    return device_->WriteBuffer(buffer, size);
  }

  virtual bool OnPacketFromHost(Ipv4Packet* packet) {
    size_t packet_length = sizeof(ethhdr) + ntohs(packet->ip->tot_len);
    if (OnFrameFromHost(ETH_P_IP, packet->buffer, packet_length)) {
      packet->Release();
      return true;
    } else {
      queued_packets_.push_back(packet);
      return false;
    }
  }

  /* when return nullptr, socket should retry later */
  virtual Ipv4Packet* AllocatePacket(bool urgent) {
    if (!urgent && !queued_packets_.empty()) {
      return nullptr;
    }
    Ipv4Packet* packet = new Ipv4Packet;
    MV_ASSERT(packet);
    packet->mtu = mtu_;
    packet->eth = (ethhdr*)packet->buffer;
    packet->ip = (iphdr*)&packet->eth[1];
    packet->data = (void*)&packet->ip[1];
    packet->tcp = nullptr;
    packet->udp = nullptr;
    packet->icmp = nullptr;
    packet->data_length = 0;
    packet->Release = [packet]() {
      delete packet;
    };
    return packet;
  }

  void ParseEthPacket(Ipv4Packet* packet) {
    auto eth = packet->eth;
    if (memcmp(eth->h_dest, router_mac_.data, ETH_ALEN) != 0 &&
      memcmp(eth->h_dest, "\xFF\xFF\xFF\xFF\xFF\xFF", ETH_ALEN) != 0) {
      // ignore packets to other ethernet addresses
      return;
    }
  
    uint16_t protocol = ntohs(eth->h_proto);
    switch (protocol)
    {
    case ETH_P_IP:
      packet->ip = (struct iphdr*)&eth[1];
      ParseIpPacket(packet);
      break;
    case ETH_P_ARP:
      ParseArpPacket(eth, (ArpMessage*)&eth[1]);
      packet->Release();
      break;
    case ETH_P_IPV6:
      if (real_device_->debug()) {
        MV_WARN("ignore IPv6");
      }
      packet->Release();
      break;
    case ETH_P_LLDP:
      if (real_device_->debug()) {
        MV_WARN("ignore LLDP");
      }
      packet->Release();
      break;
    case ETH_P_PPP_DISC:
      if (real_device_->debug()) {
        MV_LOG("ignore PPP_DISC");
      }
      packet->Release();
      break;
    default:
      MV_WARN("Unknown ethernet packet protocol=%x", protocol);
      packet->Release();
      break;
    }
  }

  void ParseArpPacket(ethhdr* eth, ArpMessage* arp) {
    MV_UNUSED(eth);
    if (ntohs(arp->ar_op) == 1) { // ARP request
      uint32_t dip = ntohl(arp->ar_tip);
      if (dip == router_ip_) {
        // ARP reply
        uint8_t buffer[42];
        ArpMessage* reply = (ArpMessage*)&buffer[14];
        reply->ar_hrd = arp->ar_hrd;
        reply->ar_pro = arp->ar_pro;
        reply->ar_hln = arp->ar_hln;
        reply->ar_pln = arp->ar_pln;
        reply->ar_op = htons(2);
        memcpy(reply->ar_tha, arp->ar_sha, ETH_ALEN);
        reply->ar_tip = arp->ar_sip;
        memcpy(reply->ar_sha, router_mac_.data, ETH_ALEN);
        reply->ar_sip = htonl(router_ip_);
        OnFrameFromHost(ETH_P_ARP, buffer, sizeof(buffer));
      }
    } else {
      MV_ERROR("Invalid Arp op=0x%x", arp->ar_op);
    }
  }

  void ParseIpPacket(Ipv4Packet* packet) {
    auto ip = packet->ip;
    switch (ip->protocol)
    {
    case 0x01:  // ICMP
      packet->icmp = (struct icmphdr*)((uint8_t*)ip + ip->ihl * 4);
      if (ParseIcmpPacket(packet)) {
        packet->Release();
      }
      break;
    case 0x06:  // TCP
      packet->tcp = (struct tcphdr*)((uint8_t*)ip + ip->ihl * 4);
      if (ParseTcpPacket(packet)) {
        packet->Release();
      }
      break;
    case 0x11:  // UDP
      packet->udp = (struct udphdr*)((uint8_t*)ip + ip->ihl * 4);
      if (ParseUdpPacket(packet)) {
        packet->Release();
      }
      break;
    default:
      if (real_device_->debug()) {
        MV_LOG("Not UDP or TCP, protocol=%d", ip->protocol);
        MV_HEXDUMP("ip packet", ip, ntohs(ip->tot_len));
      }
      packet->Release();
      break;
    }
  }

  IcmpSocket* LookupIcmpSocket(uint32_t sip, uint32_t dip, uint16_t echo_id) {
    for (auto socket : icmp_sockets_) {
      if (socket->Equals(sip, dip, echo_id)) {
        return socket;
      }
    }
    return nullptr;
  }

  bool ParseIcmpPacket(Ipv4Packet* packet) {
    auto ip = packet->ip;
    auto icmp = packet->icmp;
    auto sip = ntohl(ip->saddr);
    auto dip = ntohl(ip->daddr);

    /* For network security, only PING is supported */
    if (icmp->type != ICMP_ECHO) {
      return true;
    }

    auto echo_id = ntohs(icmp->un.echo.id);
    auto socket = dynamic_cast<RedirectIcmpSocket*>(LookupIcmpSocket(sip, dip, echo_id));
    if (socket == nullptr) {
      /* If restricted and not local network, don't redirect packets */
      if ((dip & router_subnet_mask_) != (router_ip_ & router_subnet_mask_) && restrict_) {
        return true;
      }
      if (icmp_sockets_.size() >= MAX_OPEN_ICMP_SOCKETS) {
        return true;
      }

      auto icmp_socket = new RedirectIcmpSocket(this, sip, dip, echo_id);
      icmp_socket->InitializeRedirect();
      socket = icmp_socket;
      icmp_sockets_.push_back(socket);
    }

    packet->data = icmp;
    packet->data_offset = 0;
    packet->data_length = ntohs(ip->tot_len) - ip->ihl * 4;
    socket->OnPacketFromGuest(packet);
    return false;
  }

  TcpSocket* LookupTcpSocket(uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) {
    for (auto socket : tcp_sockets_) {
      if (socket->Equals(sip, dip, sport, dport)) {
        return socket;
      }
    }
    return nullptr;
  }

  bool ParseTcpPacket(Ipv4Packet* packet) {
    auto ip = packet->ip;
    auto tcp = packet->tcp;
    auto sip = ntohl(ip->saddr);
    auto dip = ntohl(ip->daddr);
    auto sport = ntohs(tcp->source);
    auto dport = ntohs(tcp->dest);
    
    auto socket = dynamic_cast<RedirectTcpSocket*>(LookupTcpSocket(sip, dip, sport, dport));
    if (socket == nullptr) {
      /* If restricted and not local network, don't redirect packets */
      if ((dip & router_subnet_mask_) != (router_ip_ & router_subnet_mask_) && restrict_) {
        return true;
      }
      if (tcp_sockets_.size() >= MAX_OPEN_TCP_SOCKETS) {
        return true;
      }

      socket = new RedirectTcpSocket(this, sip, dip, sport, dport);
      tcp_sockets_.push_back(socket);
    }

    // Guest is trying to start a TCP session
    if (tcp->syn) {
      socket->InitializeRedirect(packet);
      return true;
    }

    // If not connected, other packets will reset the connection
    if (!socket->connected()) {
      if (real_device_->debug()) {
        MV_LOG("Reset TCP %x:%u -> %x:%u syn:%d ack:%d rst:%d fin:%d", sip, sport, dip, dport,
          tcp->syn, tcp->ack, tcp->rst, tcp->fin);
      }
      socket->ReplyReset(packet);
      return true;
    }

    if (tcp->rst) {
      socket->Reset();
      return true;
    }

    // ACK is always set if not SYN or FIN or RST
    if (!tcp->ack) {
      return true;
    }

    // If send window buffer is full, try again when new guest ack comes
    if (!socket->UpdateGuestAck(tcp)) {
      return true;
    }

    // Send out TCP data to remote host
    packet->data = (uint8_t*)tcp + tcp->doff * 4;
    packet->data_offset = 0;
    packet->data_length = ntohs(ip->tot_len) - ip->ihl * 4 - tcp->doff * 4;
    socket->OnPacketFromGuest(packet);
    return false;
  }

  UdpSocket* LookupUdpSocket(uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) {
    for (auto socket : udp_sockets_) {
      if (socket->Equals(sip, dip, sport, dport)) {
        return socket;
      }
    }
    return nullptr;
  }

  bool ParseUdpPacket(Ipv4Packet* packet) {
    auto ip = packet->ip;
    auto udp = packet->udp;
    auto sip = ntohl(ip->saddr);
    auto dip = ntohl(ip->daddr);
    auto sport = ntohs(udp->source);
    auto dport = ntohs(udp->dest);

    auto socket = LookupUdpSocket(sip, dip, sport, dport);
    if (socket == nullptr) {
      if (udp_sockets_.size() >= MAX_OPEN_UDP_SOCKETS) {
        return true;
      }

      // Check if it's UDP broadcast
      if (dport == 67) {
        socket = new DhcpServiceUdpSocket(this, sip, dip, sport, dport);
      } else {
        if ((dip & router_subnet_mask_) != (router_ip_ & router_subnet_mask_) && restrict_) {
          /* If restricted and not local network, don't redirect UDP packets */
          return true;
        }
        auto redirect_udp = new RedirectUdpSocket(this, sip, dip, sport, dport);
        redirect_udp->InitializeRedirect();
        socket = redirect_udp;
      }
      udp_sockets_.push_back(socket);
    }

    packet->data = &udp[1];
    packet->data_offset = 0;
    packet->data_length = ntohs(udp->len) - sizeof(*udp);
    socket->OnPacketFromGuest(packet);
    return false;
  }

};

DECLARE_NETWORK(Uip);

```

`networks/uip/dhcp.cc`:

```cc
/* 
 * MVisor DHCP Server
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <cstring>
#include <arpa/inet.h>

#include "logger.h"


struct DhcpMessage {
  uint8_t message_type;
  uint8_t hardware_type;
  uint8_t hardware_address_length;
  uint8_t hops;
  uint32_t transaction_id;
  uint16_t seconds_elapsed;
  uint16_t bootp_flags;
  uint32_t client_ip;
  uint32_t your_ip;
  uint32_t next_server_ip;
  uint32_t relay_agent_ip;
  uint8_t client_mac[6];
  uint8_t client_pad[10];
  uint8_t server_host_name[64];
  uint8_t boot_filename[128];
  uint32_t magic_cookie;
  uint8_t option[0];
} __attribute__((packed));


DhcpServiceUdpSocket::DhcpServiceUdpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport)
  : UdpSocket(backend, sip, dip, sport, dport)
{
  // Read DNS nameservers from host
  FILE* fp = fopen("/etc/resolv.conf", "r");
  if (fp) {
    while (!feof(fp)) {
      char line[256], key[256], val[256];
      fgets(line, sizeof(line), fp);
      if (memcmp(line, "nameserver ", 11) == 0) {
        if (sscanf(line, "%s %s\n", key, val) != 2)
          continue;
        if (val[0] == '1' && val[1] == '2' && val[2] == '7')
          continue;
        struct in_addr addr;
        if (inet_aton(val, &addr)) {
          nameservers_.push_back(ntohl(addr.s_addr));
        }
      }
    }
    fclose(fp);
  } else {
    MV_WARN("/etc/resolv.conf not found");
  }

  if (nameservers_.empty()) {
    /* DNS server not found, add default */
    nameservers_.push_back(0x08080808);
  }
}

bool DhcpServiceUdpSocket::active() {
  // Kill timedout
  if (time(nullptr) - active_time_ >= REDIRECT_TIMEOUT_SECONDS) {
    return false;
  }
  return true;
}

void DhcpServiceUdpSocket::OnPacketFromGuest(Ipv4Packet* packet) {
  DhcpMessage* dhcp = (DhcpMessage*)packet->data;

  /* Parse options */
  uint32_t option_type = 0, requested_ip = 0;
  std::string hostname, parameters;

  for (uint8_t* p = dhcp->option; p[0] != 0xFF; p += p[1] + 2) {
    switch (p[0])
    {
    case 0x0C: // hostname
      hostname = std::string((char*)&p[2], p[1]);
      break;
    case 0x32: // requested IP
      requested_ip = ntohl(*(uint32_t*)&p[2]);
      break;
    case 0x35: // option type
      option_type = p[2];
      break;
    case 0x37: // parameter list
      parameters = std::string((char*)&p[2], p[1]);
      break;
    case 0x39: // max packet size
      break;
    case 0x3D: // client ID
      break;
    default:
      if (debug_) {
        MV_LOG("ignore DHCP option 0x%x", p[0]);
      }
      break;
    }
  }

  if (debug_) {
    MV_LOG("DHCP option_type=%d requested=0x%x hostname=%s parameters:", option_type, requested_ip, hostname.c_str());
    MV_HEXDUMP("packet", parameters.data(), parameters.size());
  }
  
  /* Handle message [RFC2131] */
  std::string reply;
  if (option_type == 0x01) { // Discover
    reply = CreateDhcpResponse(dhcp, 2);
  } else if (option_type == 0x03) { // Request
    if (requested_ip == 0 || requested_ip == backend_->guest_ip()) {
      reply = CreateDhcpResponse(dhcp, 5);  // ACK
    } else {
      reply = CreateDhcpResponse(dhcp, 6);  // NAK
    }
  } else {
    if (debug_) { // Such as option_type=0x8 on windows 7
      MV_LOG("unhandled dhcp packet option_type=0x%x", option_type);
    }
    packet->Release();
    return;
  }

  // No more use
  packet->Release();

  // Build UDP reply message
  auto reply_packet = AllocatePacket(false);
  if (reply_packet == nullptr) {
    return;
  }

  reply_packet->data_length = reply.size();
  memcpy(reply_packet->data, reply.data(), reply_packet->data_length);

  // DHCP message uses special IPs
  uint32_t sip = sip_, dip = dip_;
  sip_ = 0xFFFFFFFF;
  dip_ = backend_->router_ip();
  OnDataFromHost(reply_packet);
  sip_ = sip;
  dip_ = dip;

  active_time_ = time(nullptr);
}

size_t DhcpServiceUdpSocket::FillDhcpOptions(uint8_t* option, int dhcp_type) {
  uint8_t* p = option;
  // dhcp message type
  *p++ = 53;
  *p++ = 1;
  *p++ = dhcp_type;

  // dhcp server id
  *p++ = 54;
  *p++ = 4;
  *(uint32_t*)p = htonl(backend_->router_ip());
  p += 4;

  // subnet mask
  *p++ = 1;
  *p++ = 4;
  *(uint32_t*)p = htonl(backend_->router_subnet_mask());
  p += 4;

  // router
  *p++ = 3;
  *p++ = 4;
  *(uint32_t*)p = htonl(backend_->router_ip());
  p += 4;

  // nameserver
  *p++ = 6;
  *p++ = nameservers_.size() * 4;
  for (auto ip : nameservers_) {
    *(uint32_t*)p = htonl(ip);
    p += 4;
  }

  *p++ = 0xFF;
  return p - option;
}

std::string DhcpServiceUdpSocket::CreateDhcpResponse(DhcpMessage* request, int dhcp_type) {
  std::string buffer(512, '\0');
  DhcpMessage* response = (DhcpMessage*)buffer.data();
  size_t body_length = sizeof(DhcpMessage);
  // Copy values before option
  memcpy(response, request, body_length);

  // Set message type to Boot Reply
  response->message_type = 2;
  response->client_ip = 0;

  response->your_ip = htonl(backend_->guest_ip());
  response->next_server_ip = 0;
  response->relay_agent_ip = 0;

  size_t option_length = FillDhcpOptions(response->option, dhcp_type);
  size_t padding = (option_length - 2) % 4;
  if (padding != 0) {
    option_length += (4 - padding);
  }
  buffer.resize(body_length + option_length);
  return buffer;
}


```

`networks/uip/icmp.cc`:

```cc
/* 
 * MVisor ICMP
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"


IcmpSocket::IcmpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t echo_id):
  Ipv4Socket(backend, sip, dip) {
  echo_id_ = echo_id;
}

Ipv4Packet* IcmpSocket::AllocatePacket(bool urgent) {
  Ipv4Packet* packet = Ipv4Socket::AllocatePacket(urgent);
  if (packet) {
    packet->icmp = (icmphdr*)packet->data;
  }
  return packet;
}

uint16_t IcmpSocket::CalculateIcmpChecksum(Ipv4Packet* packet) {
  auto icmp = packet->icmp;
  int icmp_len = packet->data_length;
  uint16_t* ptr = (uint16_t*)icmp;
  uint32_t sum = 0;

  while(icmp_len > 1)
  {
    sum += *ptr++;
    icmp_len -= 2; 
  }

  if(icmp_len == 1)
  {  
    uint16_t word = *(uint8_t*)ptr;
    word = (word << 8) & 0xFF;
    sum += word;                
  }
  sum = (sum >> 16) + (sum & 0xFFFF); 
  sum += sum >> 16;  
  return (uint16_t)(~sum);
}

void IcmpSocket::OnDataFromHost(Ipv4Packet* packet) {
  auto icmp = packet->icmp;
  if (icmp->type == ICMP_ECHOREPLY) {
    icmp->un.echo.id = htons(echo_id_);
  }

  auto ip = packet->ip;
  ip->version = 4;
  ip->ihl = 5;
  ip->tos = 0;
  ip->tot_len = htons(sizeof(iphdr) + packet->data_length);
  ip->id = 0;
  ip->frag_off = htons(0x4000);
  ip->ttl = 64;
  ip->protocol = 0x1;
  ip->check = 0;
  ip->saddr = htonl(dip_);
  ip->daddr = htonl(sip_);

  // checksum
  ip->check = CalculateChecksum((uint8_t*)ip, ip->ihl * 4);
  icmp->checksum = 0;
  icmp->checksum = CalculateIcmpChecksum(packet);

  backend_->OnPacketFromHost(packet);
}

```

`networks/uip/ipv4.cc`:

```cc
/* 
 * MVisor Ipv4 Socket
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <arpa/inet.h>

#include "device_manager.h"
#include "logger.h"


Ipv4Socket::Ipv4Socket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip) :
  backend_(backend), sip_(sip), dip_(dip) {
  debug_ = false;
  active_time_ = time(nullptr);

  auto device = dynamic_cast<PciDevice*>(backend_->device());
  device_ = device;
  debug_ = device->debug();
}

Ipv4Packet* Ipv4Socket::AllocatePacket(bool urgent) {
  return backend_->AllocatePacket(urgent);
}

void Ipv4Socket::OnGuestBufferAvaialble() {
}

uint16_t Ipv4Socket::CalculateChecksum(uint8_t* addr, uint16_t count) {
  long sum = 0;

  while (count > 1) {
    sum += *(uint16_t *)addr;
    addr += 2;
    count -= 2;
  }

  if (count > 0)
    sum += *(uint8_t*)addr;

  while (sum >> 16)
    sum = (sum & 0xffff) + (sum >> 16);

  return ~sum;
}

```

`networks/uip/map_tcp.cc`:

```cc
/* 
 * MVisor TCP Port Mapping Service
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include "utilities.h"
#include "logger.h"


MapTcpSocket::MapTcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport, int fd)
  : RedirectTcpSocket(backend, sip, dip, sport, dport)
{
  fd_ = fd;

  device_->StartPolling(fd_, EPOLLIN | EPOLLOUT | EPOLLET, [this](auto events) {
    can_read_ = events & EPOLLIN;
    can_write_ = events & EPOLLOUT;
  
    if (can_write()) {
      StartWriting();
    }
    if (can_read()) {
      StartReading();
    }
  });

  auto packet = AllocatePacket(true);
  if (packet) {
    OnDataFromHost(packet, TCP_FLAG_SYN);
    seq_host_ += 1;
  }
}

void MapTcpSocket::InitializeRedirect(Ipv4Packet* packet) {
  if (debug_) {
    MV_LOG("TCP fd=%d %x:%u -> %x:%u", fd_, dip_, dport_, sip_, sport_);
  }

  SynchronizeTcp(packet->tcp);
  
  // Initialize redirect states
  connected_ = true;
  if (can_write()) {
    StartWriting();
  }
  if (can_read()) {
    StartReading();
  }
}


```

`networks/uip/meson.build`:

```build
mvisor_sources += files(
  'core.cc',
  'dhcp.cc',
  'icmp.cc',
  'ipv4.cc',
  'map_tcp.cc',
  'redirect_icmp.cc',
  'redirect_tcp.cc',
  'redirect_udp.cc',
  'tcp.cc',
  'udp.cc',
  'uip.h'
)


```

`networks/uip/redirect_icmp.cc`:

```cc
/* 
 * MVisor ICMP Redirect
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <fcntl.h>
#include <arpa/inet.h>

#include "logger.h"
#include "utilities.h"

RedirectIcmpSocket::~RedirectIcmpSocket() {
  if (fd_ != -1) {
    device_->StopPolling(fd_);
    safe_close(&fd_);
  }
}

bool RedirectIcmpSocket::active() {
  if (fd_ < 0) {
    return false;
  }
  // Kill timed out
  if (time(nullptr) - active_time_ >= REDIRECT_TIMEOUT_SECONDS) {
    return false;
  }
  return true;
}

void RedirectIcmpSocket::InitializeRedirect() {
  fd_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_ICMP);
  if (fd_ < 0) {
    fd_ = socket(AF_INET, SOCK_RAW, IPPROTO_ICMP);
    if (fd_ < 0) {
      MV_ERROR("ICMP failed to create socket");
      return;
    }
    raw_mode_ = true;
  }

  if (debug_) {
    MV_LOG("ICMP%s fd=%d %x -> %x", raw_mode_ ? "(RAW)" : "", fd_, sip_, dip_);
  }

  // Set non-blocking
  fcntl(fd_, F_SETFL, fcntl(fd_, F_GETFL, 0) | O_NONBLOCK);

  sockaddr_in daddr = {
    .sin_family = AF_INET,
    .sin_port = 0,
    .sin_addr = {
      .s_addr = htonl(dip_)
    },
    .sin_zero = {0}
  };

  auto ret = connect(fd_, (struct sockaddr*)&daddr, sizeof(daddr));
  if (ret < 0) {
    if (debug_) {
      MV_ERROR("ICMP fd=%d failed to connect socket", fd_);
    }
    safe_close(&fd_);
    return;
  }

  device_->StartPolling(fd_, EPOLLIN | EPOLLET, [this](auto events) {
    can_read_ = events & EPOLLIN;
    if (can_read()) {
      StartReading();
    }
  });
}

void RedirectIcmpSocket::StartReading() {
  while (can_read()) {
    auto packet = AllocatePacket(false);
    if (packet == nullptr) {
      if (debug_) {
        MV_ERROR("ICMP fd=%d failed to allocate packet", fd_, this);
      }
      return;
    }

    /* FIXME: Limit packet size for Linux driver */
    auto recv_size = UIP_MAX_UDP_PAYLOAD(packet);

    int ret = recv(fd_, packet->data, recv_size, 0);
    if (ret < 0) {
      packet->Release();
      can_read_ = false;
      return;
    }

    if (raw_mode_) {
      auto ip = (iphdr*)packet->data;
      auto icmp = (uint8_t*)packet->data + ip->ihl * 4;
      packet->data_length = ret - ip->ihl * 4;
      memmove(packet->data, icmp, packet->data_length);
    } else {
      packet->data_length = ret;
    }
    
    OnDataFromHost(packet);
    active_time_ = time(nullptr);
  }
}

void RedirectIcmpSocket::OnPacketFromGuest(Ipv4Packet* packet) {
  if (fd_ < 0) {
    packet->Release();
    return;
  }

  sockaddr_in daddr = {
    .sin_family = AF_INET,
    .sin_port = 0,
    .sin_addr = {
      .s_addr = htonl(dip_)
    },
    .sin_zero = {0}
  };

  int ret = sendto(fd_, packet->data, packet->data_length, 0, (sockaddr*)&daddr, sizeof daddr);
  packet->Release();
  if (ret < 0) {
    return;
  }
  MV_ASSERT(ret == (int)packet->data_length);
  active_time_ = time(nullptr);
}


```

`networks/uip/redirect_tcp.cc`:

```cc
/* 
 * MVisor TCP Redirect
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <arpa/inet.h>
#include <fcntl.h>

#include "logger.h"
#include "utilities.h"

RedirectTcpSocket::RedirectTcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport)
  : TcpSocket(backend, sip, dip, sport, dport)
{
}

RedirectTcpSocket::~RedirectTcpSocket() {
  for (auto packet : send_queue_) {
    packet->Release();
  }

  if (fd_ >= 0) {
    device_->StopPolling(fd_);
    safe_close(&fd_);
  }
}

bool RedirectTcpSocket::active() {
  if (fd_ < 0) {
    return false;
  }
  // Kill half closed
  if (read_done_ || write_done_ || !connected_) {
    if (time(nullptr) - active_time_ >= REDIRECT_TIMEOUT_SECONDS) {
      return false;
    }
  }
  return true;
}

void RedirectTcpSocket::Shutdown(int how) {
  if (fd_ < 0)
    return;

  if (how == SHUT_WR) { // Guest sent FIN
    if (!write_done_) {
      shutdown(fd_, how);
      write_done_ = true;

      ack_host_ += 1;
      auto packet = AllocatePacket(true);
      if (packet) {
        OnDataFromHost(packet, TCP_FLAG_ACK);
      }
    }
  } else if (how == SHUT_RD) {
    if (!read_done_) {
      read_done_ = true;

      auto packet = AllocatePacket(true);
      if (packet) {
        OnDataFromHost(packet, TCP_FLAG_FIN | TCP_FLAG_ACK);
      }
      seq_host_ += 1;
    }
  }

  if (debug_) {
    MV_LOG("TCP fd=%d shutdown %s %x:%u -> %x:%u", fd_, how == SHUT_WR ? "WRITE" : "READ",
      sip_, sport_, dip_, dport_);
  }

  if (read_done_ && write_done_) {
    if (debug_) {
      MV_LOG("TCP fd=%d closed", fd_);
    }
    device_->StopPolling(fd_);
    safe_close(&fd_);
  }
}

void RedirectTcpSocket::ReplyReset(Ipv4Packet* packet) {
  SynchronizeTcp(packet->tcp);
  seq_host_ = ntohl(packet->tcp->ack_seq);

  auto reply = AllocatePacket(true);
  if (reply) {
    OnDataFromHost(reply, TCP_FLAG_RST);
    seq_host_ += 1;
  }
}

void RedirectTcpSocket::Reset() {
  if (fd_ > 0) {
    device_->StopPolling(fd_);
    shutdown(fd_, SHUT_RDWR);
    safe_close(&fd_);
  }
}

void RedirectTcpSocket::InitializeRedirect(Ipv4Packet* packet) {
  if (fd_ > 0) {
    return;
  }

  SynchronizeTcp(packet->tcp);

  // Initialize redirect states
  connected_ = false;
  fd_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
  MV_ASSERT(fd_ > 0);

  if (debug_) {
    MV_LOG("TCP fd=%d %x:%u -> %x:%u", fd_, sip_, sport_, dip_, dport_);
  }

  // Set non-blocking
  MV_ASSERT(fcntl(fd_, F_SETFL, fcntl(fd_, F_GETFL, 0) | O_NONBLOCK) != -1);

  sockaddr_in daddr = {
    .sin_family = AF_INET,
    .sin_port = htons(dport_),
    .sin_addr = {
      .s_addr = htonl(dip_)
    },
    .sin_zero = {0}
  };

  for (auto& rule : backend_->redirect_rules()) {
    if (rule.protocol == 0 || rule.protocol == 0x06) {
      if (rule.match_ip == dip_ && rule.match_port == dport_) {
        daddr.sin_addr.s_addr = htonl(rule.target_ip);
        daddr.sin_port = htons(rule.target_port);
        break;
      }
    }
  }
  
  auto ret = connect(fd_, (sockaddr*)&daddr, sizeof(daddr));
  if (ret < 0 && errno != EINPROGRESS) {
    if (debug_) {
      MV_ERROR("TCP fd=%d failed to connect socket", fd_);
    }
    safe_close(&fd_);
    return;
  }

  device_->StartPolling(fd_, EPOLLOUT | EPOLLIN | EPOLLET, [this](auto events) {
    can_read_ = events & EPOLLIN;
    can_write_ = events & EPOLLOUT;
  
    if (!connected_ && can_write_) {
      OnRemoteConnected();
    }
    if (can_write()) {
      StartWriting();
    }
    if (can_read()) {
      StartReading();
    }
  });
}

void RedirectTcpSocket::OnRemoteConnected() {
  MV_ASSERT(fd_ > 0);
  connected_ = true;
  auto packet = AllocatePacket(true);
  if (packet) {
    OnDataFromHost(packet, TCP_FLAG_SYN | TCP_FLAG_ACK);
    seq_host_ += 1;
  }
}

bool RedirectTcpSocket::UpdateGuestAck(tcphdr* tcp) {
  if (TcpSocket::UpdateGuestAck(tcp)) {
    if (can_read()) {
      StartReading();
    }
    return true;
  }
  return false;
}

void RedirectTcpSocket::OnGuestBufferAvaialble() {
  if (can_read()) {
    StartReading();
  }
}

/* If receive operation is controlled, retry when a guest ACK comes */
void RedirectTcpSocket::StartReading() {
  while (can_read()) {
    /* Check if controlled by TCP window */
    int available = (int)(window_size_ - (seq_host_ - guest_acked_));
    if (available <= 0) {
      return;
    }

    /* Check if virtio buffer is full */
    auto packet = AllocatePacket(false);
    if (packet == nullptr) {
      if (debug_) {
        MV_ERROR("TCP fd=%d failed to allocate packet", fd_);
      }
      return;
    }

    /* FIXME: Limit packet size for Linux driver */
    if (available > UIP_MAX_TCP_PAYLOAD(packet)) {
      available = UIP_MAX_TCP_PAYLOAD(packet);
    }

    int ret = recv(fd_, packet->data, available, 0);
    if (ret <= 0) {
      packet->Release();
      if (ret < 0 && errno == EAGAIN) {
        can_read_ = false;
        return;
      }
      Shutdown(SHUT_RD);
    } else {
      packet->data_length = ret;
      OnDataFromHost(packet, TCP_FLAG_ACK);
      seq_host_ += packet->data_length;
      active_time_ = time(nullptr);
    }
  }
}

void RedirectTcpSocket::StartWriting() {
  while (can_write()) {
    /* Check if no data to send */
    if (send_queue_.empty()) {
      return;
    }

    auto packet = send_queue_.front();
    auto length = packet->data_length - packet->data_offset;
    int ret = send(fd_, (uint8_t*)packet->data + packet->data_offset, length, MSG_NOSIGNAL);
    if (ret < 0) {
      if (errno == EAGAIN) {
        can_write_ = false;
        return;
      }
      if (debug_) {
        MV_LOG("ERROR TCP %d %x:%u -> %x:%u is already closed. length=%d ret=%d",
          fd_, sip_, sport_, dip_, dport_, length, ret);
      }
      Shutdown(SHUT_RD);
      return;
    }
    packet->data_offset += ret;
    if (packet->data_offset == packet->data_length) {
      if (packet->tcp->fin) {
        Shutdown(SHUT_WR);
      }
      packet->Release();
      send_queue_.pop_front();
    }
    active_time_ = time(nullptr);
  }
}

void RedirectTcpSocket::OnPacketFromGuest(Ipv4Packet* packet) {
  if (fd_ < 0 || write_done_) {
    packet->Release();
    return;
  }
  send_queue_.push_back(packet);

  ack_host_ += packet->data_length;

  // If no data length, this ack packet is not necessary, right?
  if (packet->data_length > 0) {
    auto ack_packet = AllocatePacket(true);
    if (ack_packet) {
      OnDataFromHost(ack_packet, TCP_FLAG_ACK);
    }
  }

  if (can_write()) {
    StartWriting();
  }
}

```

`networks/uip/redirect_udp.cc`:

```cc
/* 
 * MVisor UDP Redirect
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <fcntl.h>
#include <arpa/inet.h>

#include "logger.h"
#include "utilities.h"

RedirectUdpSocket::~RedirectUdpSocket() {
  if (fd_ >= 0) {
    device_->StopPolling(fd_);
    safe_close(&fd_);
  }
}

bool RedirectUdpSocket::active() {
  if (fd_ < 0) {
    return false;
  }
  // Kill timed out
  if (time(nullptr) - active_time_ >= REDIRECT_TIMEOUT_SECONDS) {
    return false;
  }
  return true;
}

void RedirectUdpSocket::InitializeRedirect() {
  fd_ = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
  MV_ASSERT(fd_ >= 0);

  if (debug_) {
    MV_LOG("UDP fd=%d %x:%u -> %x:%u", fd_, sip_, sport_, dip_, dport_);
  }

  // Set non-blocking
  fcntl(fd_, F_SETFL, fcntl(fd_, F_GETFL, 0) | O_NONBLOCK);

  sockaddr_in daddr = {
    .sin_family = AF_INET,
    .sin_port = htons(dport_),
    .sin_addr = {
      .s_addr = htonl(dip_)
    },
    .sin_zero = {0}
  };

  for (auto& rule : backend_->redirect_rules()) {
    if (rule.protocol == 0 || rule.protocol == 0x11) {
      if (rule.match_ip == dip_ && rule.match_port == dport_) {
        daddr.sin_addr.s_addr = htonl(rule.target_ip);
        daddr.sin_port = htons(rule.target_port);
        break;
      }
    }
  }

  auto ret = connect(fd_, (struct sockaddr*)&daddr, sizeof(daddr));
  if (ret < 0) {
    if (debug_) {
      MV_ERROR("UDP fd=%d failed to connect socket", fd_);
    }
    safe_close(&fd_);
    return;
  }

  device_->StartPolling(fd_, EPOLLIN | EPOLLET, [this](auto events) {
    can_read_ = events & EPOLLIN;
    if (can_read()) {
      StartReading();
    }
  });
}

void RedirectUdpSocket::OnGuestBufferAvaialble() {
  if (can_read()) {
    StartReading();
  }
}

void RedirectUdpSocket::StartReading() {
  while (can_read()) {
    auto packet = AllocatePacket(false);
    if (packet == nullptr) {
      if (debug_) {
        MV_ERROR("UDP fd=%d failed to allocate packet", fd_, this);
      }
      return;
    }

    /* FIXME: Limit packet size for Linux driver */
    auto recv_size = UIP_MAX_UDP_PAYLOAD(packet);

    int ret = recv(fd_, packet->data, recv_size, 0);
    if (ret < 0) {
      packet->Release();
      can_read_ = false;
      return;
    }
    
    packet->data_length = ret;
    OnDataFromHost(packet);
    active_time_ = time(nullptr);
  }
}

void RedirectUdpSocket::OnPacketFromGuest(Ipv4Packet* packet) {
  if (fd_ < 0) {
    packet->Release();
    return;
  }

  int ret = send(fd_, packet->data, packet->data_length, 0);
  packet->Release();
  if (ret < 0) {
    return;
  }
  MV_ASSERT(ret == (int)packet->data_length);
  active_time_ = time(nullptr);
}


```

`networks/uip/tcp.cc`:

```cc
/* 
 * MVisor TCP Redirect
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <arpa/inet.h>

#include "logger.h"


TcpSocket::TcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) :
  Ipv4Socket(backend, sip, dip), sport_(sport), dport_(dport) {
  mss_ = 1460;
  // setup initial sequence and acknowledge
  seq_host_ = 0x66666666;
}

void TcpSocket::SynchronizeTcp(tcphdr* tcp) {
  window_size_ = ntohs(tcp->window) << window_scale_;
  ack_host_ = ntohl(tcp->seq) + 1;

  if (tcp->ack) {
    guest_acked_ = ntohl(tcp->ack_seq);
  }

  ParseTcpOptions(tcp);
}

void TcpSocket::ParseTcpOptions(tcphdr* tcp) {
  uint8_t* options = (uint8_t*)tcp + sizeof(*tcp);
  uint8_t* tcp_data = (uint8_t*)tcp + (tcp->doff * 4);
  for (uint8_t* p = options; p < tcp_data;) {
    switch (*p++)
    {
    case 0: // END
      p = tcp_data;
      break;
    case 1: // NOP
      break;
    case 2: // MSS
      ++p;
      mss_ = ntohs(*(uint16_t*)p);
      p += 2;
      break;
    case 3: // Window scale
      ++p;
      window_scale_ = *p;
      ++p;
      break;
    case 4: // SACK permitted
      ++p;
      sack_permitted_ = true;
      break;
    default:
      if (debug_) {
        MV_LOG("unknown TCP option %d", *(p - 1));
      }
      p += *p - 1;
      break;
    }
  }
}

void TcpSocket::FillTcpOptions(tcphdr* tcp) {
  uint8_t* options = (uint8_t*)tcp + sizeof(*tcp);
  uint8_t* tcp_data = (uint8_t*)tcp + (tcp->doff * 4);
  bzero(options, tcp_data - options);
  uint8_t* p = options;
  // Window scale = 0
  *p++ = 3;
  *p++ = 3;
  *p++ = 0;
}

bool TcpSocket::UpdateGuestAck(tcphdr* tcp) {
  if (ntohl(tcp->seq) == ack_host_) {
    window_size_ = ntohs(tcp->window) << window_scale_;
    guest_acked_ = ntohl(tcp->ack_seq);
    return true;
  }

  auto packet = AllocatePacket(true);
  if (packet) {
    OnDataFromHost(packet, TCP_FLAG_ACK);
  }
  return false;
}

Ipv4Packet* TcpSocket::AllocatePacket(bool urgent) {
  Ipv4Packet* packet = Ipv4Socket::AllocatePacket(urgent);
  if (packet) {
    packet->tcp = (tcphdr*)packet->data;
    packet->data = (void*)&packet->tcp[1];
  }
  return packet;
}

uint16_t TcpSocket::CalculateTcpChecksum(Ipv4Packet* packet) {
  PseudoHeader hdr;
  auto ip = packet->ip;
  auto tcp = packet->tcp;
  int tcp_len;
  uint8_t *pad;

  ip = packet->ip;
  tcp_len = ntohs(ip->tot_len) - ip->ihl * 4;
  MV_ASSERT(tcp_len <= UIP_MAX_TCP_PAYLOAD(packet) + 20);

  hdr.sip = ip->saddr;
  hdr.dip  = ip->daddr;
  hdr.zero = 0;
  hdr.protocol = ip->protocol;
  hdr.length = htons(tcp_len);

  if (tcp_len % 2) {
    pad = (uint8_t *)tcp + tcp_len;
    *pad = 0;
    memcpy((uint8_t *)tcp + tcp_len + 1, &hdr, sizeof(hdr));
    return CalculateChecksum((uint8_t *)tcp, tcp_len + 1 + sizeof(hdr));
  } else {
    memcpy((uint8_t *)tcp + tcp_len, &hdr, sizeof(hdr));
    return CalculateChecksum((uint8_t *)tcp, tcp_len + sizeof(hdr));
  }
}

void TcpSocket::OnDataFromHost(Ipv4Packet* packet, uint32_t flags) {
  tcphdr* tcp = packet->tcp;
  bzero(packet->tcp, sizeof(tcphdr));
  tcp->source = htons(dport_);
  tcp->dest = htons(sport_);
  tcp->seq = htonl(seq_host_);
  tcp->ack_seq = htonl(ack_host_);

  // clear flags
  ((uint16_t*)tcp)[6] = 0;
  if (flags & TCP_FLAG_ACK) {
    tcp->ack = 1;
  }
  if (flags & TCP_FLAG_FIN) {
    tcp->fin = 1;
  }
  if (flags & TCP_FLAG_RST) {
    tcp->rst = 1;
  }
  if (flags & TCP_FLAG_SYN) {
    tcp->syn = 1;
    tcp->doff = 8;
    // To get peer window scale work, add options
    FillTcpOptions(tcp);
  } else {
    tcp->doff = 5;
  }

  // fixed window size, no more than 64K, window scale = 0
  if (tcp->rst) {
    tcp->window = 0;
  } else {
    tcp->window = htons(UIP_MAX_TCP_PAYLOAD(packet));
  }
  tcp->check = 0;
  tcp->urg_ptr = 0;

  auto ip = packet->ip;
  ip->version = 4;
  ip->ihl = 5;
  ip->tos = 0;
  ip->tot_len = htons(tcp->doff * 4 + sizeof(iphdr) + packet->data_length);
  ip->id = 0;
  ip->frag_off = htons(0x4000);
  ip->ttl = 64;
  ip->protocol = 0x06;
  ip->check = 0;
  ip->saddr = htonl(dip_);
  ip->daddr = htonl(sip_);

  // checksum
  ip->check = CalculateChecksum((uint8_t*)ip, ip->ihl * 4);
  tcp->check = CalculateTcpChecksum(packet);

  backend_->OnPacketFromHost(packet);
}


```

`networks/uip/udp.cc`:

```cc
/* 
 * MVisor UDP Redirect
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "uip.h"

#include <arpa/inet.h>


UdpSocket::UdpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) :
  Ipv4Socket(backend, sip, dip), sport_(sport), dport_(dport)
{
}

Ipv4Packet* UdpSocket::AllocatePacket(bool urgent) {
  Ipv4Packet* packet = Ipv4Socket::AllocatePacket(urgent);
  if (packet) {
    packet->udp = (udphdr*)packet->data;
    packet->data = (void*)&packet->udp[1];
  }
  return packet;
}

uint16_t UdpSocket::CalculateUdpChecksum(Ipv4Packet* packet) {
  PseudoHeader hdr;
  auto ip = packet->ip;
  auto udp = packet->udp;
  int udp_len;
  uint8_t *pad;

  ip = packet->ip;

  hdr.sip = ip->saddr;
  hdr.dip = ip->daddr;
  hdr.zero = 0;
  hdr.protocol = ip->protocol;
  hdr.length = udp->len;

  udp_len = ntohs(udp->len);

  if (udp_len % 2) {
    pad = (uint8_t *)udp + udp_len;
    *pad = 0;
    memcpy((uint8_t *)udp + udp_len + 1, &hdr, sizeof(hdr));
    return CalculateChecksum((uint8_t *)udp, udp_len + 1 + sizeof(hdr));
  } else {
    memcpy((uint8_t *)udp + udp_len, &hdr, sizeof(hdr));
    return CalculateChecksum((uint8_t *)udp, udp_len + sizeof(hdr));
  }
}

void UdpSocket::OnDataFromHost(Ipv4Packet* packet) {
  auto udp = packet->udp;
  udp->check = 0;
  udp->source = htons(dport_);
  udp->dest = htons(sport_);
  udp->len = htons(sizeof(udphdr) + packet->data_length);

  auto ip = packet->ip;
  ip->version = 4;
  ip->ihl = 5;
  ip->tos = 0;
  ip->tot_len = htons(sizeof(udphdr) + sizeof(iphdr) + packet->data_length);
  ip->id = 0;
  ip->frag_off = htons(0x4000);
  ip->ttl = 64;
  ip->protocol = 0x11;
  ip->check = 0;
  ip->saddr = htonl(dip_);
  ip->daddr = htonl(sip_);

  // checksum
  ip->check = CalculateChecksum((uint8_t*)ip, ip->ihl * 4);
  udp->check = CalculateUdpChecksum(packet);

  backend_->OnPacketFromHost(packet);
}

```

`networks/uip/uip.h`:

```h
/* 
 * MVisor User Mode Network
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#ifndef _MVISOR_NETWORKS_USER_H
#define _MVISOR_NETWORKS_USER_H


#include <string>
#include <vector>

#include <linux/if_ether.h>
#include <linux/ip.h>
#include <linux/udp.h>
#include <linux/tcp.h>
#include <linux/icmp.h>
#include <arpa/inet.h>
#include <ctime>

#include "device_interface.h"
#include "pci_device.h"

#define UIP_MAX_BUFFER_SIZE           (4096 - 16)
#define UIP_MAX_UDP_PAYLOAD(packet)   (packet->mtu - 20 - 8)
#define UIP_MAX_TCP_PAYLOAD(packet)   (packet->mtu - 144)

#define REDIRECT_TIMEOUT_SECONDS      (120)

struct PseudoHeader {
  uint32_t sip;
  uint32_t dip;
  uint8_t zero;
  uint8_t protocol;
  uint16_t length;
} __attribute__((packed));


class Ipv4Socket;
struct Ipv4Packet {
  Ipv4Socket*   socket;
  uint8_t       buffer[UIP_MAX_BUFFER_SIZE];
  int           mtu;
  ethhdr*       eth;
  iphdr*        ip;
  udphdr*       udp;
  tcphdr*       tcp;
  icmphdr*      icmp;
  void*         data;
  size_t        data_length;
  size_t        data_offset;
  VoidCallback  Release;
};

class Ipv4Socket {
 public:
  Ipv4Socket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip);

  virtual ~Ipv4Socket() {}
  virtual void OnPacketFromGuest(Ipv4Packet* packet) = 0;
  virtual void OnGuestBufferAvaialble();
  
  virtual bool active() = 0;

 protected:
  virtual Ipv4Packet* AllocatePacket(bool urgent);
  uint16_t CalculateChecksum(uint8_t* addr, uint16_t count);

  NetworkBackendInterface*  backend_;
  uint32_t                  sip_;
  uint32_t                  dip_;
  bool                      closed_;
  time_t                    active_time_;
  bool                      debug_;
  PciDevice*                device_ = nullptr;
};


class TcpSocket : public Ipv4Socket {
 public:
  TcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport);
  bool Equals(uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) {
    return sip_ == sip && dip_ == dip && sport_ == sport && dport_ == dport;
  }
  virtual bool UpdateGuestAck(tcphdr* tcp);

 protected:
  virtual Ipv4Packet* AllocatePacket(bool urgent);
  uint16_t CalculateTcpChecksum(Ipv4Packet* packet);
  void OnDataFromHost(Ipv4Packet* packet, uint32_t tcp_flags);
  void ParseTcpOptions(tcphdr* tcp);
  void FillTcpOptions(tcphdr* tcp);
  void SynchronizeTcp(tcphdr* tcp);

  uint16_t sport_;
  uint16_t dport_;
  uint32_t window_size_ = 0;
  uint32_t guest_acked_ = 0;
  uint32_t ack_host_ = 0;
  uint32_t seq_host_ = 0;
  uint16_t mss_ = 0;
  uint8_t  window_scale_ = 0;
  bool     sack_permitted_ = false;
};

class UdpSocket : public Ipv4Socket {
 public:
  UdpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport);
  bool Equals(uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) {
    return sip_ == sip && dip_ == dip && sport_ == sport && dport_ == dport;
  }

 protected:
  virtual Ipv4Packet* AllocatePacket(bool urgent);
  uint16_t CalculateUdpChecksum(Ipv4Packet* packet);
  void OnDataFromHost(Ipv4Packet* packet);

  uint16_t sport_;
  uint16_t dport_;
};

class RedirectTcpSocket : public TcpSocket {
 public:
  RedirectTcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport);
  virtual ~RedirectTcpSocket();
  virtual void InitializeRedirect(Ipv4Packet* packet);
  virtual void OnGuestBufferAvaialble();
  virtual void OnPacketFromGuest(Ipv4Packet* packet);
  void Shutdown(int how);
  bool UpdateGuestAck(tcphdr* tcp);
  void ReplyReset(Ipv4Packet* packet);
  void Reset();

  bool active();
  bool connected() { return connected_; }

 protected:
  void StartReading();
  void StartWriting();
  void OnRemoteConnected();

  inline bool can_read() { return fd_ != -1 && connected_ && !read_done_ && can_read_; }
  inline bool can_write() { return fd_ != -1 && connected_ && !write_done_ && can_write_; }

  bool write_done_ = false;
  bool read_done_ = false;
  int  fd_ = -1;
  bool can_read_ = false;
  bool can_write_ = false;
  std::deque<Ipv4Packet*> send_queue_;
  bool connected_ = false;
};

class MapTcpSocket : public RedirectTcpSocket {
 public:
  MapTcpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport, int fd);
  virtual void InitializeRedirect(Ipv4Packet* packet);
};

class Device;
class DeviceManager;
class RedirectUdpSocket : public UdpSocket {
 public:
  RedirectUdpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport) :
    UdpSocket(backend, sip, dip, sport, dport) {
  }
  virtual ~RedirectUdpSocket();
  virtual void InitializeRedirect();
  virtual void OnGuestBufferAvaialble();
  virtual void OnPacketFromGuest(Ipv4Packet* packet);
  bool active();

 protected:
  void StartReading();

  inline bool can_read() { return fd_ != -1 && can_read_; }

  int       fd_;
  bool      can_read_ = false;
};

struct DhcpMessage;
class DhcpServiceUdpSocket : public UdpSocket {
 public:
  DhcpServiceUdpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t sport, uint16_t dport);
  void OnPacketFromGuest(Ipv4Packet* packet);
  bool active();

 private:
  std::string CreateDhcpResponse(DhcpMessage* request, int dhcp_type);
  size_t FillDhcpOptions(uint8_t* option, int dhcp_type);

  std::vector<uint32_t> nameservers_;
};

class IcmpSocket : public Ipv4Socket {
 public:
  IcmpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t echo_id);
  bool Equals(uint32_t sip, uint32_t dip, uint16_t echo_id) {
    return sip_ == sip && dip_ == dip && echo_id_ == echo_id;
  }

 protected:
  virtual Ipv4Packet* AllocatePacket(bool urgent);
  uint16_t CalculateIcmpChecksum(Ipv4Packet* packet);
  void OnDataFromHost(Ipv4Packet* packet);

  uint16_t  echo_id_;
};

class RedirectIcmpSocket : public IcmpSocket {
 public:
  RedirectIcmpSocket(NetworkBackendInterface* backend, uint32_t sip, uint32_t dip, uint16_t echo_id) :
    IcmpSocket(backend, sip, dip, echo_id) {
  }
  virtual ~RedirectIcmpSocket();
  virtual void InitializeRedirect();
  virtual void OnPacketFromGuest(Ipv4Packet* packet);
  bool active();

 protected:
  void StartReading();

  inline bool can_read() { return fd_ != -1 && can_read_; }

  int       fd_;
  bool      can_read_ = false;
  bool      raw_mode_ = false;
};

#endif // _MVISOR_NETWORKS_USER_H

```

`scripts/create_vfio.sh`:

```sh
#!/bin/sh
# echo 1 > /sys/bus/mdev/devices/c2e088ba-954f-11ec-8584-525400666f2b/remove
echo "c2e088ba-954f-11ec-8584-525400666f2b" > /sys/class/mdev_bus/0000:3b:00.0/mdev_supported_types/nvidia-231/create

```

`scripts/debug.sh`:

```sh
#!/bin/sh
meson compile -C ../build
gdb -ex 'handle SIG34 nostop pass' -ex 'run' ../build/mvisor


```

`scripts/debug_load.sh`:

```sh
#!/bin/sh
meson compile -C ../build
gdb -ex 'handle SIG34 nostop pass' -ex 'run -c /tmp/save/configuration.yaml --load /tmp/save/' ../build/mvisor

```

`utilities/classes.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "utilities.h"
#include "logger.h"
#include <cstdlib>
#include <string>
#include <cstring>
#include <map>
#include "object.h"

#define MAX_LEVEL 10

static uint last_object_id = 0;
static std::map<std::string, ClassItem*>* classes = nullptr;

/* Alias PciHost to pci-host */
std::string get_class_alias(const char* name) {
  std::string ret;
  for (size_t i = 0; i < strlen(name); i++) {
    if (isupper(name[i])) {
      if (i > 0) {
        ret.push_back('-');
      }
      ret.push_back(tolower(name[i]));
    } else {
      ret.push_back(name[i]);
    }
  }
  return ret;
}

void register_class(int type, const char* name, const char* source_path, ClassCreator create) {
  ClassItem* item = new ClassItem;
  item->class_type = type;
  item->class_name = name;
  item->class_file = source_path;
  item->create = create;

  if (!classes) {
    classes = new std::map<std::string, ClassItem*>;
  }
  MV_ASSERT(classes->find(name) == classes->end());
  (*classes)[name] = item;
  (*classes)[get_class_alias(name)] = item;

  /* Add alias pci-host to q35-host */
  if (strcmp(name, "Q35Host") == 0) {
    (*classes)["pci-host"] = item;
  }
  // MV_LOG("register class %s", name);
}


Object* realize_class(const char* name) {
  auto it = classes->find(name);
  if (it == classes->end()) {
    return nullptr;
  }
  Object* o = it->second->create();
  o->set_id(++last_object_id);
  o->set_classname(it->second->class_name);
  o->set_name(name);
  return o;
}


```

`utilities/logger.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2021 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "logger.h"
#include <cstdarg>
#include <cstdio>
#include <cstring>
#include <ctime>
#include <cerrno>
#include <cstdlib>
#include <cstdint>
#include <chrono>
#include <linux/kvm.h>
#include <sys/prctl.h>
#include <csignal>

void Log(LogType type, const char* file, int line, const char* function, const char* format, ...) {
  char message[512];
  va_list args;
  va_start(args, format);
  vsnprintf(message, 512, format, args);
  va_end(args);

  static auto program_start_time = std::chrono::steady_clock::now();
  auto delta_us = std::chrono::duration_cast<std::chrono::microseconds>(
    std::chrono::steady_clock::now() - program_start_time).count();
  char timestr[100];
  sprintf(timestr, "%.3lf", double(delta_us) / 1000);

  switch (type) {
    case kLogTypeDebug:
      fprintf(stdout, "[%s] %s:%d %s() debug: %s\n", timestr, file, line, function, message);
      fflush(stdout);
      break;
    case kLogTypeWarn:
      fprintf(stderr, "[%s] %s:%d %s() warn: %s\n", timestr, file, line, function, message);
      fflush(stderr);
      break;
    case kLogTypeError:
    case kLogTypePanic:
      if (!errno) {
        fprintf(stderr,"[%s] %s:%d %s() %serror: %s\n", timestr, file, line, function, type == kLogTypePanic ? "panic-" : "", message);
      } else {
        fprintf(stderr,"[%s] %s:%d %s() %serror: %s errno=%d, %s\n", 
          timestr, file, line, function, type == kLogTypePanic ? "panic-" : "", message, errno, strerror(errno));
      }
      fflush(stderr);
      break;
  }

  if (type == kLogTypePanic) {
    std::raise(SIGINT);
    exit(1);
  }
}

void SaveToFile(const char* path, void* data, size_t size) {
  FILE* fp = fopen(path, "wb");
  fwrite(data, size, 1, fp);
  fclose(fp);
}

void DumpHex(const void* data, size_t size) {
  uint8_t* ptr = (uint8_t*)data;
  printf("%08x  ", 0);
  for (size_t i = 0; i < size;) {
    printf("%02x ", ptr[i++]);
    if (i % 16 == 0) {
      printf("\n%08lx  ", i);
    } else if (i % 8 == 0) {
      printf(" ");
    }
  }
  printf("\n");
}

void SetThreadName(const char* name) {
  prctl(PR_SET_NAME, name);
}

static inline void print_dtable(FILE* fp, const char *name, struct kvm_dtable *dtable)
{
  fprintf(fp, " %s                 %016lx  %08hx\n",
    name, (uint64_t) dtable->base, (uint16_t) dtable->limit);
}

static inline void print_segment(FILE* fp, const char *name, struct kvm_segment *seg)
{
  fprintf(fp, " %s       %04hx      %016lx  %08x  %02hhx    %x %x   %x  %x %x %x %x\n",
    name, (uint16_t) seg->selector, (uint64_t) seg->base, (uint32_t) seg->limit,
    (uint8_t) seg->type, seg->present, seg->dpl, seg->db, seg->s, seg->l, seg->g, seg->avl);
}

void PrintRegisters(struct kvm_regs& regs, struct kvm_sregs& sregs) {
  unsigned long cr0, cr2, cr3;
  unsigned long cr4, cr8;
  unsigned long rax, rbx, rcx;
  unsigned long rdx, rsi, rdi;
  unsigned long rbp,  r8,  r9;
  unsigned long r10, r11, r12;
  unsigned long r13, r14, r15;
  unsigned long rip, rsp;
  unsigned long rflags;
  int i;

  rflags = regs.rflags;

  rip = regs.rip; rsp = regs.rsp;
  rax = regs.rax; rbx = regs.rbx; rcx = regs.rcx;
  rdx = regs.rdx; rsi = regs.rsi; rdi = regs.rdi;
  rbp = regs.rbp; r8  = regs.r8;  r9  = regs.r9;
  r10 = regs.r10; r11 = regs.r11; r12 = regs.r12;
  r13 = regs.r13; r14 = regs.r14; r15 = regs.r15;

  FILE* output = stdout;
  fprintf(output, "\n Registers:\n");
  fprintf(output,   " ----------\n");
  fprintf(output, " rip: %016lx   rsp: %016lx flags: %016lx\n", rip, rsp, rflags);
  fprintf(output, " rax: %016lx   rbx: %016lx   rcx: %016lx\n", rax, rbx, rcx);
  fprintf(output, " rdx: %016lx   rsi: %016lx   rdi: %016lx\n", rdx, rsi, rdi);
  fprintf(output, " rbp: %016lx    r8: %016lx    r9: %016lx\n", rbp, r8,  r9);
  fprintf(output, " r10: %016lx   r11: %016lx   r12: %016lx\n", r10, r11, r12);
  fprintf(output, " r13: %016lx   r14: %016lx   r15: %016lx\n", r13, r14, r15);


  cr0 = sregs.cr0; cr2 = sregs.cr2; cr3 = sregs.cr3;
  cr4 = sregs.cr4; cr8 = sregs.cr8;

  fprintf(output, " cr0: %016lx   cr2: %016lx   cr3: %016lx\n", cr0, cr2, cr3);
  fprintf(output, " cr4: %016lx   cr8: %016lx\n", cr4, cr8);
  fprintf(output, "\n Segment registers:\n");
  fprintf(output,   " ------------------\n");
  fprintf(output, " register  selector  base              limit     type  p dpl db s l g avl\n");
  print_segment(output, "cs ", &sregs.cs);
  print_segment(output, "ss ", &sregs.ss);
  print_segment(output, "ds ", &sregs.ds);
  print_segment(output, "es ", &sregs.es);
  print_segment(output, "fs ", &sregs.fs);
  print_segment(output, "gs ", &sregs.gs);
  print_segment(output, "tr ", &sregs.tr);
  print_segment(output, "ldt", &sregs.ldt);
  print_dtable(output, "gdt", &sregs.gdt);
  print_dtable(output, "idt", &sregs.idt);

  fprintf(output, "\n APIC:\n");
  fprintf(output,   " -----\n");
  fprintf(output, " efer: %016lx  apic base: %016lx  nmi: %s\n",
    (uint64_t) sregs.efer, (uint64_t) sregs.apic_base,
    (true ? "disabled" : "enabled"));

  fprintf(output, "\n Interrupt bitmap:\n");
  fprintf(output,   " -----------------\n");
  for (i = 0; i < (KVM_NR_INTERRUPTS + 63) / 64; i++)
    fprintf(output, " %016lx", (uint64_t) sregs.interrupt_bitmap[i]);
  fprintf(output, "\n");
}

```

`utilities/meson.build`:

```build
mvisor_sources += files(
  'classes.cc',
  'logger.cc',
  'zero.cc',
  'zstd.cc'
)

mvisor_deps += [
  dependency('libzstd')
]


```

`utilities/zero.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "utilities.h"

#include <cstdint>
#include "logger.h"


#pragma GCC push_options
#pragma GCC target("avx2")
#include <immintrin.h>

/* input buffer must be 256 bytes alignment */
__attribute__((used))
static bool avx2_test_zero(const void* buffer, size_t length) {
  uint64_t start = (uint64_t)buffer;
  MV_ASSERT(!((start | length) & 0xFF));

  auto *p = (__m256i*)buffer;
  auto *e = (__m256i*)(start + length);
  while (p < e) {
    __builtin_prefetch(p);
    __m256i t = p[0] | p[1] | p[2] | p[3] | p[4] | p[5] | p[6] | p[7];
    if (__builtin_expect(!_mm256_testz_si256(t, t), 0))
      return false;
    p += 8;
  }
  return true;
}

#pragma GCC pop_options

#pragma GCC push_options
#pragma GCC target("avx512f")
#include <immintrin.h>

/* input buffer must be 256 bytes alignment */
__attribute__((used))
static bool avx512_test_zero(const void* buffer, size_t length) {
  uint64_t start = (uint64_t)buffer;
  MV_ASSERT(!((start | length) & 0xFF));

  auto *p = (__m512i*)buffer;
  auto *e = (__m512i*)(start + length);
  while (p < e) {
    __builtin_prefetch(p);
    __m512i t = p[0] | p[1] | p[2] | p[3];
    if (__builtin_expect(!!_mm512_test_epi64_mask(t, t), 0))
      return false;
    p += 4;
  }
  return true;
}

#pragma GCC pop_options

bool test_zero(const void* buffer, size_t length) {
  return avx2_test_zero(buffer, length);
}

```

`utilities/zstd.cc`:

```cc
/* 
 * MVisor
 * Copyright (C) 2022 Terrence <terrence@tenclass.com>
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

#include "utilities.h"

#include <cstdint>
#include <cerrno>
#include <zstd.h>
#include <zstd_errors.h>

#include "logger.h"


ssize_t zstd_decompress(const void* src,  size_t src_size, void* dest, size_t dest_size) {
  size_t zstd_ret = 0;
  ssize_t ret = 0;
  ZSTD_outBuffer output = {
    .dst = dest,
    .size = dest_size,
    .pos = 0
  };
  ZSTD_inBuffer input = {
    .src = src,
    .size = src_size,
    .pos = 0
  };
  ZSTD_DCtx* dctx = ZSTD_createDCtx();
  MV_ASSERT(dctx);

  while (output.pos < output.size) {
    size_t last_in_pos = input.pos;
    size_t last_out_pos = output.pos;
    zstd_ret = ZSTD_decompressStream(dctx, &output, &input);

    if (ZSTD_isError(zstd_ret)) {
      MV_ERROR("ZSTD decompress error inpos=%d outpos=%d: %s", last_in_pos, last_out_pos,
        ZSTD_getErrorString(ZSTD_getErrorCode(zstd_ret)));
      ret = -EIO;
      break;
    }

    /* prevent infinitely waiting for input data */
    if (last_in_pos >= input.pos && last_out_pos >= output.pos) {
      ret = -EIO;
    }
  }
  
  /* make sure no more data pending output */
  if (zstd_ret > 0) {
    ret = -EIO;
  }
  ZSTD_freeDCtx(dctx);
  return ret;
}

```