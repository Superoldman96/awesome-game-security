Project Path: arc_gmh5225_G-Presto-Anti-Cheat-Reverse-Engineered_ulbajh56

Source Tree:

```txt
arc_gmh5225_G-Presto-Anti-Cheat-Reverse-Engineered_ulbajh56
├── CheckCPU.h
├── DexProtection.h
├── EmulatorCheck.h
├── EngineHandler.h
├── Linux.h
├── Main.cpp
├── README.md
├── Utility.h
└── encryption.h

```

`CheckCPU.h`:

```h
//sub_17C3C
void check_cpu_info() {
    signed int cpu_info; // w27
    __int64 current_line; // x0
    char *v4; // x0
    char *v5; // x19
    signed int v8; // w28
    __int64 v9; // x0
    uint8x8_t v10; // d0
    int v11; // w8

    unsigned int possible_cpu_present_cpu_bufff;
    int present_cpu_buff[64];

    byte_579C0 = 1;
    qword_579C8 = 0LL;
    dword_579D0 = 1;
    byte_579D4 = 1;

    FILE file = open("/proc/cpuinfo", 0);
    if ((file & 0x80000000) == 0) {
        FILE tmp_file = file;
        cpu_info = 0;

        while ((DWORD)current_line) {
            while (1) {
                current_line = read(tmp_file, present_cpu_buff, 256);
                if ((current_line & 0x80000000) == 0)
                    break;
                if (*(_DWORD *)__errno(current_line) != 4)
                    break;
            }
            cpu_info += current_line;
        }


        close(tmp_file);

        if ((cpu_info & 0x80000000) == 0) {
            v4 = (char *)malloc(cpu_info);

            if (v4) {
                v5 = v4;
                FILE file_2 = open("/proc/cpuinfo", 0);
                if ((file_2 & 0x80000000) != 0) {
                    //NOTHING?
                }
                v8 = 0;
                while (v8 < cpu_info) {
                    v9 = read(file_2, &v5[v8], cpu_info - v8);
                    if ((v9 & 0x80000000) != 0) {
                        if ( *(_DWORD *)__errno(v9) != 4 )
                        {
                            if (!v8) {
                                close(file_2);
                            }
                            break;
                        }
                    } else {
                        v8 += v9;
                        if (!(_DWORD)v9) {
                            break;
                        }
                    }
                }

                close(file_2);

                if ((v8 & 0x80000000) != 0) {
                     //NOTHING?
                }

                //PROBABLY SOME FILE READ FUNCTION
                sub_17FAC(present_cpu_buff, "/sys/devices/system/cpu/present");
                sub_17FAC(&possible_cpu_present_cpu_bufff, "/sys/devices/system/cpu/possible");

                v10.n64_u64[0] = vcnt_s8((int8x8_t)(present_cpu_buff[0] & possible_cpu_present_cpu_bufff)).n64_u64[0];
                v10.n64_u16[0] = vaddlv_u8(v10);
                v11 = v10.n64_u32[0];
                if ((present_cpu_buff[0] & possible_cpu_present_cpu_bufff) == 0) {
                    v11 = 1;
                }

                dword_579D0 = v11;
                dlerror();
                void *lib_c_handle = dlopen("libc.so", 2);

                if (!lib_c_handle) {
                    dlclose(lib_c_handle);
                }

                void *get_auxval_sym = dlsym(lib_c_handle, "getauxval");

                if (!get_auxval_sym) {
                    dlclose(lib_c_handle);
                } else {
                    int get_auxval = get_auxval_sym(16);

                    dlclose(lib_c_handle);
                    //SET GLOBAL VARIABLES
                    if (get_auxval != nullptr) {
                        if ((get_auxval & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 1;
                        }

                        if ((get_auxval >> 1 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 2;
                        }

                        if ((get_auxval >> 3 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 4;
                        }

                        if ((get_auxval >> 4 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 8;
                        }

                        if ((get_auxval >> 5 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 0x10;
                        }

                        if ((get_auxval >> 6 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 0x20;
                        }

                        if ((get_auxval >> 7 & 1) != 0) {
                            DAT_001579c8 = DAT_001579c8 | 0x40;
                        }
                    }
                }
            }     
        }
    }
}
```

`DexProtection.h`:

```h
//I HAVE ABSOLUTELY NO IDEA WTF THIS THING DOES
//CLEAN THE MISSING THINGS YOURSELF
int InitDex(JNIEnv *jni_env, jobject a2, jobject current_activity, jstring a4, jstring a5, jobject a6) {
    const char *v11; // x23
    unsigned __int64 v12; // x0
    unsigned __int64 v13; // x25
    char *v14; // x26
    unsigned __int64 v15; // x27
    const char *v16; // x0
    const char *v17; // x0
    __int64 v18; // x25
    void *v19; // x26
    char *v20; // x27
    unsigned __int64 v21; // x28
    const char *v22; // x3
    const char *v23; // x3
    __int64 v28; // x0
    const char *v29; // x0
    FILE *v30; // x21
    FILE *v31; // x0
    __int64 v32; // x21
    _BYTE *v33; // x1
    __int64 v34; // x22
    const char *v41; // x1
    __int128 v43; // [xsp+20h] [xbp-620h] BYREF
    void *p; // [xsp+30h] [xbp-610h]
    __int128 v45; // [xsp+40h] [xbp-600h] BYREF
    void *v46; // [xsp+50h] [xbp-5F0h]
    char v47; // [xsp+60h] [xbp-5E0h]
    _BYTE v48[15]; // [xsp+61h] [xbp-5DFh] BYREF
    void *v49; // [xsp+70h] [xbp-5D0h]
    char v50; // [xsp+78h] [xbp-5C8h]
    _BYTE v51[15]; // [xsp+79h] [xbp-5C7h] BYREF
    void *v52; // [xsp+88h] [xbp-5B8h]
    size_t v53[4]; // [xsp+90h] [xbp-5B0h] BYREF
    void *v54; // [xsp+A0h] [xbp-5A0h]
    __int128 v55; // [xsp+A8h] [xbp-598h]
    void *v56; // [xsp+B8h] [xbp-588h]


    char name[260]; // [xsp+C0h] [xbp-580h] BYREF
    char src[260]; // [xsp+1C4h] [xbp-47Ch] BYREF
    char dest[264]; // [xsp+2C8h] [xbp-378h] BYREF
    char v60[260]; // [xsp+3D0h] [xbp-270h] BYREF
    char filename[284]; // [xsp+4D4h] [xbp-16Ch] BYREF

    v11 = JNIEnv::GetStringUTFChars(jni_env, a4, 0);

    memset(filename, 0, 260);
    memset(v60, 0, 260);
    memset(dest, 0, 260);
    memset(src, 0, 260);
    memset(name, 0, 260);
    strcpy(filename, v11);

    *((_QWORD *)&v55 + 1) = 30720LL;
    LOBYTE(v55) = 18;
    v56 = 0LL;
    memset(v53, 0, sizeof(v53));
    strcpy(&filename[strlen(filename)], "/.class.dex");
    *(_QWORD *)((char *)&v55 + 1) = *(_QWORD *)"class.dex";
    v54 = 0LL;
    v12 = strlen(v11);
    v13 = v12;

    if (v12 >= 0x17) {
        v15 = (v12 + 16) & 0xFFFFFFFFFFFFFFF0LL;
        v14 = (char *)operator new(v15);
        *(_QWORD *)&v53[2] = v13;
        v54 = v14;
        *(_QWORD *)v53 = v15 | 1;
        goto LABEL_5;
    }

    v14 = (char *)v53 + 1;
    LOBYTE(v53[0]) = 2 * v12;
    if (v12) {
        LABEL_5:
        memcpy(v14, v11, v13);
    }
    v14[v13] = 0;
    std::operator+<char>((int)v53, "/.dex");
    if ((v53[0] & 1) != 0) {
        v16 = (const char *)v54;
    } else {
        v16 = (char *)v53 + 1;
    }
    mkdir(v16, 448);
    if ((v50 & 1) != 0) {
        v17 = (const char *)v52;
    } else {
        v17 = v51;
    }
    mkdir(v17, 448);

    p = 0;
    v46 = v56;
    v45 = v55;
    v43 = 0uLL;

    if ((v53[0] & 1) == 0) {
        p = v54;
        v43 = *(_OWORD *)v53;
        goto LABEL_21;
    }

    v18 = *(_QWORD *)&v53[2];
    if (*(_QWORD *)&v53[2] >= 0xFFFFFFFFFFFFFFF0LL)
        std::__basic_string_common<true>::__throw_length_error(&v43);
    v19 = v54;

    if (*(_QWORD *)&v53[2] >= 0x17uLL) {
        v21 = (*(_QWORD *)&v53[2] + 16LL) & 0xFFFFFFFFFFFFFFF0LL;
        v20 = (char *)operator new(v21);
        *((_QWORD *)&v43 + 1) = v18;
        p = v20;
        *(_QWORD *)&v43 = v21 | 1;
    } else {
        v20 = (char *)&v43 + 1;
        LOBYTE(v43) = 2 * LOBYTE(v53[2]);
        if ( !*(_QWORD *)&v53[2] )
        goto LABEL_20;
    }

    memcpy(v20, v19, v18);
    LABEL_20:
    v20[v18] = 0;
    LABEL_21:
    copyDexToData(jni_env, a6, &v45, &v43);
    if ((v43 & 1) != 0) {
        operator delete(p);
    }

    if ((v45 & 1) != 0) {
        operator delete(v46);
    }

    if ((v47 & 1) != 0) {
        v22 = (const char *)v49;
    } else {
        v22 = v48;
    }

    LOGI("strDexPath = %s", v22);
    if ((v50 & 1) != 0) {
        v23 = (const char *)v52;
    } else {
        v23 = v51;
    }

    LOGI("strDestDexPath = %s", v23);
    LOGI("strDexout = %s", filename);

    (*(void (__fastcall **)(__int64, __int64, const char *))(*(_QWORD *)jni_env + 1360LL))(jni_env, a4, v11);
    jclass current_activity_class = JNIEnv::GetObjectClass(jni_env, current_activity);
    jmethodID get_package_name_id = JNIEnv::GetObjectMethodID(jni_env, current_activity_class, "getPackageName", &unk_33BE2);
    jstring package_name = _JNIEnv::CallObjectMethod(jni_env, current_activity, get_package_name_id);
    if (package_name) {
        native_package_name = JNIEnv::GetStringUTFChars(jni_env, package_name, 0);
        strcpy(src, native_package_name);
    }

    strcpy(dest, "GPresto_");
    strcat(dest, src);
    v28 = strlen(dest);
    md5_buffer_core(v60, dest, v28);

    if ((v47 & 1) != 0) {
        v29 = (const char *)v49;
    } else {
        v29 = v48;
    }

    v30 = fopen(v29, "rb");
    v31 = fopen(filename, "wb");
    decrypt_stream(v30, v31, v60);
    v32 = JNIEnv::(jni_env, filename);
    if ((v50 & 1) != 0) {
        v33 = v52;
    } else {
        v33 = v51;
    }

    v34 = (*(__int64 (__fastcall **)(__int64, _BYTE *))(*(_QWORD *)jni_env + 1336LL))(jni_env, v33);
    jclass class_loader_class = JNIEnv::FindClass(jni_env, "java/lang/ClassLoader");
    jmethodID system_class_loader_id = JNIEnv::GetStaticMethodID(jni_env, class_loader_class, "getSystemClassLoader", "()Ljava/lang/ClassLoader;");
    jobject system_class_loader = _JNIEnv::CallStaticObjectMethod(jni_env, class_loader_class, system_class_loader_id);

    jclass dex_class_loader_class = JNIEnv::FindClass(jni_env, "dalvik/system/DexClassLoader");
    jmethodID dex_class_loader = JNIEnv::GetObjectMethodID(jni_env, dex_class_loader_class, "<init>", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/ClassLoader;)V");
    jobject new_class_loader = _JNIEnv::NewObject(jni_env, dex_class_loader_class, dex_class_loader, v32, v34, a5, system_class_loader);

    if ((v50 & 1) != 0) {
        v41 = (const char *)v52;
    } else {
        v41 = v51;
    }

    strcpy(name, v41);
    strcpy(&name[strlen(name)], "/.class.dex");
    unlink(filename);
    unlink(name);

    if ((v47 & 1) == 0) {
        if ( (v50 & 1) == 0 )
        goto LABEL_46;
    LABEL_50:
        operator delete(v52);
        if ( (v53[0] & 1) == 0 )
        return new_class_loader;
        goto LABEL_47;
    }
    operator delete(v49);
    if ( (v50 & 1) != 0 )
        goto LABEL_50;
    LABEL_46:
    if ( (v53[0] & 1) != 0 )
    LABEL_47:
        operator delete(v54);
    return new_class_loader;
}

void copyDexToData(JNIEnv *jni_env, void *a2@<X1>, unsigned __int8 *a3@<X2>, int a4@<W3>, _QWORD *a5@<X8>) {
    AAssetManager *v8; // x0
    const char *v9; // x1
    AAsset *v10; // x0
    AAsset *v11; // x20
    unsigned __int64 v12; // x8
    void *v13; // x1
    unsigned __int64 v14; // x2
    __int64 v15; // x0
    __int128 v16; // q0
    off_t Length; // w21
    const char *v18; // x23
    int v19; // w22
    void *v20; // x23
    int v21; // w24
    void *v22; // x8
    __int128 v23; // q0
    const char *v24; // x3
    char v25; // w8
    char v26; // [xsp+8h] [xbp-78h] BYREF
    void *p; // [xsp+18h] [xbp-68h]
    __int128 v28; // [xsp+20h] [xbp-60h] BYREF
    void *v29; // [xsp+30h] [xbp-50h]
    __int64 v30; // [xsp+38h] [xbp-48h]

    v30 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    v8 = AAssetManager_fromJava(jni_env, a2);
    if ( (*a3 & 1) != 0 )
        v9 = (const char *)*((_QWORD *)a3 + 2);
    else
        v9 = (const char *)(a3 + 1);
    v10 = AAssetManager_open(v8, v9, 0);
    if ( v10 )
    {
        v11 = v10;
        std::operator+<char>(a4, "/");
        v12 = *a3;
        if ( (v12 & 1) != 0 )
        v13 = (void *)*((_QWORD *)a3 + 2);
        else
        v13 = a3 + 1;
        if ( (v12 & 1) != 0 )
        v14 = *((_QWORD *)a3 + 1);
        else
        v14 = v12 >> 1;
        v15 = std::string::append((int)&v26, v13, v14);
        v16 = *(_OWORD *)v15;
        v29 = *(void **)(v15 + 16);
        v28 = v16;
        *(_QWORD *)(v15 + 8) = 0LL;
        *(_QWORD *)(v15 + 16) = 0LL;
        *(_QWORD *)v15 = 0LL;
        if ( (v26 & 1) != 0 )
        operator delete(p);
        Length = AAsset_getLength(v11);
        if ( (v28 & 1) != 0 )
        v18 = (const char *)v29;
        else
        v18 = (char *)&v28 + 1;
        v19 = open(v18, 65, 493LL);
        if ( (v19 & 0x80000000) != 0 )
        {
        AAsset_close(v11);
        __android_log_print(6, "<Presto_L>", "Open %s File Error!", v18);
        v25 = v28;
        a5[1] = 0LL;
        a5[2] = 0LL;
        *a5 = 0LL;
        if ( (v25 & 1) != 0 )
            operator delete(v29);
        }
        else
        {
        v20 = (void *)operator new[](0x400uLL);
        if ( Length >= 1 )
        {
            do
            {
            memset(v20, 0, 0x400u);
            v21 = AAsset_read(v11, v20, 0x400u);
            if ( (v21 & 0x80000000) != 0 )
                break;
            write(v19, v20, v21);
            Length -= v21;
            }
            while ( Length > 0 );
        }
        operator delete[](v20);
        AAsset_close(v11);
        close(v19);
        v22 = v29;
        v23 = v28;
        v29 = 0LL;
        v28 = 0uLL;
        a5[2] = v22;
        *(_OWORD *)a5 = v23;
        }
    }
    else
    {
        if ( (*a3 & 1) != 0 )
        v24 = (const char *)*((_QWORD *)a3 + 2);
        else
        v24 = (const char *)(a3 + 1);
        __android_log_print(6, "<Presto_L>", "%s not found in assets!", v24);
        a5[1] = 0LL;
        a5[2] = 0LL;
        *a5 = 0LL;
    }
}
```

`EmulatorCheck.h`:

```h
int isEmulator(JNIEnv *jni_env) {
    //SET GLOBAL VARIABLES TO NULL
    memset(native_brand_buff, 0, 260);
    memset(global_android_model, 0, 260);
    memset(global_android_hardware, 0, 260);
    memset(global_android_bootloader, 0, 260);

    jclass v2 = JNIEnv::FindClass(jni_env, "android/os/Build");
    jfieldID v3 = JNIEnv::GetbjectFieldID(jni_env, v2, "BRAND", "Ljava/lang/String;");
    jstring android_brand = JNIEnv::GetObjectField(jni_env, v2, v3);
    if (android_brand) {
        char *native_brand_str = JNIEnv::GetStringUTFChars(jni_env, android_brand, 0);
        if (native_brand_str) {
            memcpy(native_brand_buff, native_brand_str, (strlen(native_brand_str) + 1));
        }
    }

    jclass build_class = JNIEnv::FindClass(jni_env, "android/os/Build");
    jfieldID android_model_id = JNIEnv::GetbjectFieldID(jni_env, build_class, "MODEL", "Ljava/lang/String;");
    jstring android_model = JNIEnv::GetObjectField(jni_env, build_class, android_model_id);
    if (android_model) {
        char *native_model_str = JNIEnv::GetStringUTFChars(jni_env, android_model, 0);
        if (native_model_str) {
            memcpy(global_android_model, native_model_str, (strlen(native_model_str) + 1));
        }
    }

    jclass build_class = JNIEnv::FindClass(jni_env, "android/os/Build");
    jfieldID android_hardware_id = JNIEnv::GetbjectFieldID(jni_env, build_class, "HARDWARE", "Ljava/lang/String;");
    jstring android_hardware = JNIEnv::GetObjectField(jni_env, build_class, android_hardware_id);
    if (android_hardware) {
        char *native_hardware_str = JNIEnv::GetStringUTFChars(jni_env, android_hardware, 0);
        if (native_hardware_str) {
            memcpy(global_android_hardware, native_hardware_str, (strlen(native_hardware_str) + 1)); //global_android_hardware IS GLOBAL VARIABLE
        }
    }

    jclass build_class = JNIEnv::FindClass(jni_env, "android/os/Build");
    jfieldID android_bootloader_id = JNIEnv::GetbjectFieldID(jni_env, build_class, "BOOTLOADER", "Ljava/lang/String;");
    jstring android_bootloader = JNIEnv::GetObjectField(jni_env, build_class, android_bootloader_id);
    if (android_bootloader) {
        native_bootloader_str = JNIEnv::GetStringUTFChars(jni_env, android_bootloader, 0);
        if (native_bootloader_str) {
            memcpy(global_android_bootloader, native_bootloader_str, (strlen(native_bootloader_str) + 1)); //global_android_bootloader IS GLOABAL VARIABLE
        }
    }
    
    //YANDERE DEV??? LMAO
    if(strcmp(native_brand_buff, "generic")
    && strcmp(native_brand_buff, "sdk")
    && strcmp(native_brand_buff, "Microvirt")
    && strcmp(native_brand_buff, "AMIDuOS")
    && strcmp(native_brand_buff, "TTVM")
    && strcmp(global_android_model, "AMIDuOS")
    && strcmp(global_android_model, "Memu")
    && strcmp(global_android_model, "TiantianVM")
    && strcmp(global_android_model, "Droid4X")
    && strcmp(global_android_hardware, "andy")
    && strcmp(global_android_hardware, "vbox86")
    && strcmp(global_android_hardware, "nox")
    && strcmp(global_android_hardware, "windroye")
    && strcmp(global_android_hardware, "goldfish")
    && strcmp(global_android_hardware, "ttVM_x86")
    && strcmp(global_android_bootloader, "nox")) 
    {
        v30 = open("/system/bin/bstfolderd", 0);
        if ((v30 < 0) {
            v30 = open("/system/bin/bstfolder_ctl", 0);
            if ((v30 < 0) {
                v30 = open("/system/bin/bstsyncfs", 0);
                if ((v30 < 0) {
                    v30 = open("/system/bin/bstshutdown", 0);
                    if ((v30 < 0) {
                        v30 = open("/system/bin/nox", 0);
                        if ((v30 < 0) {
                            v30 = open("/system/bin/noxscreen", 0);
                            if ((v30 < 0) {
                                v30 = open("/system/bin/nemuVM-prop", 0);
                                if ((v30 < 0) {
                                    v30 = open("/system/bin/droid4x", 0);
                                    if ((v30 < 0) {
                                        v30 = open("/system/bin/droid4x-prop", 0);
                                        if ((v30 < 0) {
                                            v30 = open("/fstab.vbox86", 0);
                                            if ((v30 < 0) {
                                                v30 = open("/fstab.android_x86", 0);
                                                if ((v30 < 0) {
                                                    v30 = open("/system/app/EmuCoreService/EmuCoreService.apk", 0);
                                                    if ((v30 < 0) {
                                                        v30 = open("/system/app/EmuInputService/EmuInputService.apk", 0);
                                                        if ((v30 < 0) {
                                                            v30 = open("/system/app/gpLogin/gpLogin.apk", 0);
                                                            if ((v30 < 0) {
                                                                v30 = open("/system/app/Helper/NoxHelp_en.apk", 0);
                                                                if ((v30 < 0) {
                                                                    return opendir("/sdcard/windows/BstSharedFolder") != 0;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        close(v30);
    }
    return 1;
}
```

`EngineHandler.h`:

```h
bool Engine_state() {
  return g_Ehandle != 0;
}

void WorkThread(JNIEnv *jni_env, jobject a2, jobject a3, int a4) {
    int file_len;
    const char *selected_file;
    char file[268];

    m_stillAlive++;
    m_option = a4;
    g_env = jni_env;

    if (g_dataPath == nullptr) {
        getDataDir(jni_env, a3, &g_dataPath);
    }

    if (p_result) {
        free(p_result);
        p_result = nullptr;
    }

    strcpy(file, &g_dataPath);
    *(_WORD *)&file[strlen(file)] = 47;

    switch (family) {
        case 5:
            strcpy(&file[strlen(file)], "ATG_E_x86_64.sec");
            break;
        case 4:
            file_len = strlen(file);
            selected_file = "ATG_E_x64.sec";
            goto LABEL_10;
        case 2:
            file_len = strlen(file);
            selected_file = "ATG_E_x86.sec";

            // SOME WEIRD SHIT
            int jni_env = *(_QWORD *)(selected_file + 6);
            int activity_thread_class = *(_QWORD *)selected_file;
            char *activity_thread_class = &file[file_len];
            *(_QWORD *)(activity_thread_class + 6) = jni_env;
            *(_QWORD *)activity_thread_class = activity_thread_class;
            break;
        default:
            strcpy(&file[strlen(file)], "ATG_E.sec");
            break;
    }

    void *lib_handle = dlopen(file, 1);
    g_Ehandle = (__int64)lib_handle;
    if (lib_handle) {
        if (g_isScanning == 0) {
            void *work_thread_sym = dlsym(lib_handle, "WorkThread");
            if (work_thread_sym) {
                g_isScanning = 1;
                m_infect_cnt = work_thread_sym(jni_env, a3, m_option);
                if (m_infect_cnt < 0) {
                    int *callSendResult(jni_env, a3, 1010);
                    sprintf(&g_result, "* load_error=%d", m_infect_cnt);
                }
            } else {
                int *call_Send_result = callSendResult(jni_env, a3, 1020);
                int *err = errno(call_Send_result);
                char *load_err_str_2 = strerror(*err);
                sprintf(&g_result, "* WorkThread load_error=%s", load_err_str_2);
            }
        }
    } else {
        int *load_error = errno();
        char *load_error_str = strerror(*load_error);
        sprintf(&g_result, "* engine load_error: %s", load_error_str);
        LOGE("%s", &g_result);
    }
    return (*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)jni_env + 1336LL))(jni_env, &g_result);
}

int StopWorkThread(JNIEnv *jni_env, jobject *param_2) {
    code *pcVar1;

    g_isScanning = 0;
    if (g_Ehandle == 0) {
        if (p_result != 0) {
            g_isScanning = 0;
            return 0;
        }
    }
    else {
        pcVar1 = dlsym(g_Ehandle,"StopWorkThread");
        if (pcVar1 != nullptr) {
            (*pcVar1)();
        }
    }
    return 1;
}

int ReLogin(JNIEnv *jni_env, jobject a2, jobject a3, int a4) {
    char file[268];

    g_env = jni_env;
    m_option = a4;
    memset(file, 0, 260);

    if (p_result) {
        free(p_result);
        p_result = 0;
    }

    strcpy(file, &g_dataPath);
    *(_WORD *)&file[strlen(file)] = 47;

    switch (family) {
        case 5:
            strcpy(&file[strlen(file)], "ATG_E_x86_64.sec");
            break;
        case 4:
            file_len = strlen(file);
            file_name = "ATG_E_x64.sec";
            goto LABEL_8;
        case 2:
            file_len = strlen(file);
            file_name = "ATG_E_x86.sec";

            //WEIRD STUFF AGAIN
            __int64 v8 = *(_QWORD *)(file_name + 6);
            __int64 v9 = *(_QWORD *)file_name;
            char *v10 = &file[file_len];
            *(_QWORD *)(v10 + 6) = v8;
            *(_QWORD *)v10 = v9;
            break;
        default:
            strcpy(&file[strlen(file)], "ATG_E.sec");
            break;
    }

    file_handle = dlopen(file, 1);
    g_Ehandle = file_handle;
    if (file_handle) {
        void *ReLogin_sym = dlsym(file_handle, "ReLogin");
        if (ReLogin_sym) {
            m_infect_cnt = ReLogin_sym(jni_env, a3, m_option);
            if (m_infect_cnt < 0) {
                callSendResult(jni_env, a3, 1030);
                sprintf(&g_result, "* load_error=%d", m_infect_cnt);
            }
        } else {
            int call_result = callSendResult(jni_env, a3, 1040);
            int err = errno(call_result);
            char *str_err = strerror(*err);
            sprintf(&g_result, "* WorkThread load_error=%s", str_err);
        }
    } else {
        err_2 = errno(0);
        err_str_2 = strerror(*err_2);
        sprintf(&g_result, "* engine load_error: %s", err_str_2);
        LOGE("%s", &g_result);
    }
    //WEIRD RETURN STUFF
    return; //(*(__int64 (__fastcall **)(__int64, char *))(*(_QWORD *)jni_env + 1336LL))(jni_env, &g_result);
}

void ForkProcess() {
    __int64 result;
    unsigned int v1; 
    pthread_t v2[2];

    v2[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    dword_579B8 = fork();

    if (dword_579B8) {
        return pthread_create(v2, 0, monitor_pid, 0);
    }

    v1 = getppid();
    result = ptrace(PTRACE_ATTACH, v1, 0LL, 0LL);

    if (!result) {
        waitpid(v1, (int *)v2, 0);
        ptrace(PTRACE_CONT, v1, 0, 0);
        ptrace(PTRACE_TRACEME, 0, 0, 0);
        while (1) {
            result = waitpid(v1, (int *)v2, 0);
            if (!(_DWORD)result) {
                break;
            }
            if ((~LODWORD(v2[0]) & 0x7F) != 0) {
                _exit(0);
            }
            ptrace(PTRACE_CONT, v1, 0, 0);
        }
    }
    return result;
}

void _NoReturn monitor_pid(void *a1) {
    int stat_loc; // [xsp+Ch] [xbp-4h] BYREF

    waitpid(dword_579B8, &stat_loc, 0);
    exit(0);
}
```

`Linux.h`:

```h
void pid_cmdline(int pid, char *return_buffer, int lengh) {
    FILE *file;
    char cmdLineBuffer[268];

    sprintf(cmdLineBuffer, "/proc/%d/cmdline", pid);
    return_buffer = 0;

    file = fopen(cmdLineBuffer, "r");
    if (file != nullptr) {
        fgets(return_buffer, lengh, file);
        fclose(file);
    }
    return;
}
```

`Main.cpp`:

```cpp
int g_isScanning;
int p_result;
void *g_Ehandle;
void *g_Uhandle;
char *g_dataPath;
JavaVM *glpVM;
JNIEnv *g_env;
char global_android_bootloader[260];
char global_android_hardware[260];
char global_android_model[260]; 
char native_brand_buff[260];

jint JNI_OnLoad(JavaVM *vm, void *reserved) {
    jint v3; // w19
    void *v4; // x0
    int CpuFamily; // w0
    __int64 v7; // x0
    int v13; // w0
    int v14; // w0
    int v15; // w0
    int v16; // w0
    FILE *v17; // x24
    FILE *v18; // x0
    FILE *v19; // x21
    __int64 v20; // x27
    __int64 v21; // x26
    __int64 v22; // x25
    void *v23; // x22
    void *v24; // x0
    void *v25; // x23
    __int64 v26; // x8
    int v27; // w9
    char v28; // w11
    int v29; // w0
    int v30; // w0
    void (__fastcall *v31)(char *); // x0
    JNIEnv *jni_env;
    __int64 ptr; // [xsp+10h] [xbp-BA0h] BYREF
    char v34[260]; // [xsp+18h] [xbp-B98h] BYREF
    char v35[260]; // [xsp+11Ch] [xbp-A94h] BYREF
    char src[260]; // [xsp+220h] [xbp-990h] BYREF
    char v37[260]; // [xsp+324h] [xbp-88Ch] BYREF
    char name[260]; // [xsp+428h] [xbp-788h] BYREF
    char dest[260]; // [xsp+52Ch] [xbp-684h] BYREF
    char v40[41]; // [xsp+630h] [xbp-580h] BYREF
    __int64 v41; // [xsp+659h] [xbp-557h]
    __int64 v42; // [xsp+661h] [xbp-54Fh]
    __int64 v43; // [xsp+669h] [xbp-547h]
    __int64 v44; // [xsp+671h] [xbp-53Fh]
    __int64 v45; // [xsp+679h] [xbp-537h]
    __int64 v46; // [xsp+681h] [xbp-52Fh]
    __int64 v47; // [xsp+689h] [xbp-527h]
    __int64 v48; // [xsp+691h] [xbp-51Fh]
    __int64 v49; // [xsp+699h] [xbp-517h]
    __int64 v50; // [xsp+6A1h] [xbp-50Fh]
    __int64 v51; // [xsp+6A9h] [xbp-507h]
    __int64 v52; // [xsp+6B1h] [xbp-4FFh]
    __int64 v53; // [xsp+6B9h] [xbp-4F7h]
    __int64 v54; // [xsp+6C1h] [xbp-4EFh]
    __int64 v55; // [xsp+6C9h] [xbp-4E7h]
    __int64 v56; // [xsp+6D1h] [xbp-4DFh]
    __int64 v57; // [xsp+6D9h] [xbp-4D7h]
    __int64 v58; // [xsp+6E1h] [xbp-4CFh]
    __int64 v59; // [xsp+6E9h] [xbp-4C7h]
    __int64 v60; // [xsp+6F1h] [xbp-4BFh]
    __int64 v61; // [xsp+6F9h] [xbp-4B7h]
    __int64 v62; // [xsp+701h] [xbp-4AFh]
    __int64 v63; // [xsp+709h] [xbp-4A7h]
    __int64 v64; // [xsp+711h] [xbp-49Fh]
    __int64 v65; // [xsp+719h] [xbp-497h]
    __int64 v66; // [xsp+721h] [xbp-48Fh]
    __int64 v67; // [xsp+729h] [xbp-487h]
    __int16 v68; // [xsp+731h] [xbp-47Fh]
    char v69; // [xsp+733h] [xbp-47Dh]
    char v70[260]; // [xsp+738h] [xbp-478h] BYREF
    char v71[260]; // [xsp+83Ch] [xbp-374h] BYREF
    char v72[260]; // [xsp+940h] [xbp-270h] BYREF
    char filename[284]; // [xsp+A44h] [xbp-16Ch] BYREF

    v3 = 65542;
    jni_env = 0;
    memset(dest, 0, sizeof(dest));
    memset(name, 0, sizeof(name));
    memset(v37, 0, sizeof(v37));
    memcpy(src, "225B833CFD5F43A729E49BBF8C002480", sizeof(src));
    memcpy(v35, "3ED33E9DF4FDC88E8D79CBD807560972", sizeof(v35));
    v4 = memcpy(v34, "0FF1038D784959AD9070A6E91D73022B", sizeof(v34));
    CpuFamily = android_getCpuFamily(v4);
    v67 = 0LL;
    family = CpuFamily;
    *(_QWORD *)&v40[33] = 0;

    v7 = JNIEnv::NewStringUTF(jni_env, "com/bishopsoft/Presto/SDK/Presto");

    if (!v7) {
        LOGI("Native registration unable to find class(AVMJni)");
        return -1;
    }
    if (JNIEnv::(jni_env, v7, off_50010, 8LL) & 0x80000000) != 0) {
        LOGE("RegisterNatives failed !!!\n");
        return -1;
    }

    jclass activity_thread_class = JNIEnv::FindClass(jni_env, "android/app/ActivityThread");
    jmethodID current_application_id = JNIEnv::GetStaticMethodID(jni_env, activity_thread_class, "currentApplication", "()Landroid/app/Application;");
    jobject current_application = JNIEnv::CallStaticObjectMethod(jni_env, activity_thread_class, current_application_id);

    getDataDir(jni_env, current_application, &g_dataPath);
    getNativeLibraryDir(jni_env, current_application, g_nativePath);

    //SOME AES DECRYPTION
    decrypt_buffer(src, strlen(src));
    decrypt_buffer(v35, strlen(v35));
    decrypt_buffer(v34, strlen(v34));

    strcpy(dest, &g_dataPath);
    strcat(dest, src);
    strcpy(name, &g_dataPath);
    strcat(name, v35);
    strcpy(v37, &g_dataPath);
    strcat(v37, v34);

    if (!access(dest, 0) && !access(name, 0) && !access(v37, 0)) {
        ptr = 0;
        memset(filename, 0, 260);
        memset(v72, 0, 260);
        memset(v71, 0, 260);
        memcpy(v70, "C081CD4C7F549EC7B6F15000E2D92C4C", 260); //ENCRYPTED STRING?
        strcpy(filename, g_nativePath);
        *(_WORD *)&filename[strlen(filename)] = 47;
        strcpy(&filename[strlen(filename)], "libATG_L.so");
        v16 = strlen(v70);
        decrypt_buffer(v70, v16);
        strcpy(v72, &g_dataPath);
        strcpy(&v72[strlen(v72)], "/.");
        strcpy(v71, v70);
        strcat(v72, v71);
        v17 = fopen(filename, "rb");
        v18 = fopen(v72, "wb");

        //SOME WEIRD SHIT
        //NOT SURE WHAT IT'S SUPPOSED TO DO
        if (v17) {
            v19 = v18;
            fseek(v17, -4LL, 2);
            v20 = ftell(v17);
            fread(&ptr, 1u, 8u, v17);
            v21 = ptr;
            v22 = v20 - ptr;
            v23 = calloc((int)v20 - (int)ptr, 1u);
            v24 = calloc(v20, 1u);

            if (v23) {
                v25 = v24;
                if (v24)
                {
                    fseek(v17, 0LL, 0);
                    fread(v25, 1u, v20, v17);
                    fseek(v17, v21, 0);
                    fread(v23, 1u, v22, v17);
                    fclose(v17);
                    if (v22 >= 1) {
                        v26 = 0;
                        v27 = 0;
                        while ( v22 != v26 ) {
                            if (v21 <= v26) {
                                v27 = 0;
                                v28 = *((_BYTE *)v25 + v27++);
                                *((_BYTE *)v23 + v26++) ^= v28;
                            }
                        }
                    }
                    fwrite(v23, 1u, v22, v19);
                    fclose(v19);
                    free(v23);
                    free(v25);
                }
            }
        }

        memset(v72, 0, sizeof(v72));
        memcpy(v71, "6D644316380AF571DA568B7A0F3414D5", sizeof(v71));
        memcpy(v70, "C081CD4C7F549EC7B6F15000E2D92C4C", sizeof(v70));

        v29 = strlen(v70);
        decrypt_buffer(v70, v29);
        strcpy(filename, &g_dataPath);
        strcpy(&filename[strlen(filename)], "/.");
        strcpy(v72, v70);
        strcat(filename, v72);
        g_Uhandle = dlopen(filename, 1);

        if (g_Uhandle) {
            v30 = strlen(v71);
            decrypt_buffer(v71, v30);
            v31 = dlsym(g_Uhandle, v71);
            if (v31) {
                v31(filename);
            }
            LOGE("G-Presto load failed : 1003");
        }
        else
        {
            LOGE("G-Presto load failed : 1001");
        }
        exit(1);
    }
    glpVM = vm;
    return v3;
}

```

`README.md`:

```md
# G-Presto-Anti-Cheat-Reverse-Engineered
G-Presto Anti-Cheat Reverse Engineered.

State: Reverse Engineered 100 / 100%

Progress:
- [x] Reverse critical functions for bypassing
- [x] Reverse utility functions
- [x] Reverse hidden functions
- [x] Reverse encryption

# Summary
This anti cheat is pretty small and there is a lot of java code in this anti cheat that I have not checked because of a really good obfuscation.
Overall the native part of this anti cheat was pretty easy to reverse engineer because the developers decided to not even hide symbols in their lib

# Bypass
I'm not providing bypass. Check out @spooderman's tutorial on polarmods
https://polarmods.com/threads/bypass-g-presto-anti-cheat-engine.2698/

```

`Utility.h`:

```h
int AlertDetect(_JNIEnv *jni_env, jobject *param_2, jobject *param_3, int param_4) {
  callSendResult(jni_env, param_3, param_4);
  return 1;
}

int callSendResult(JNIEnv *jni_env, jobject java_context, int param3) {
    char error_message_buffer[268];

    memset(error_message_buffer, 0, 260);
    sprintf(error_message_buffer,
    "[Error_%d] 3rd party apps that modify game data are not supported. Shutting down in 8 seconds.\n"
    "Please remove all third party \"patcher\" apps before running this application. Protected by Presto", param3);

    main_java_class = JNIEnv::FindClass(jni_env, "com/bishopsoft/Presto/SDK/Presto");
    jstring native_error_string = JNIEnv::NewStringUTF(jni_env, error_message_buffer);
    jmethodID get_scan_result_id = JNIEnv::GetMethodID(jni_env, application_info_id, "Result_Scanning", "(Ljava/lang/String;)V");
    JNIEnv::CallVoidMethod(jni_env, java_context, get_scan_result_id, native_error_string);

    sleep(8);

    jmethodID get_instance_id = JNIEnv::GetStaticMethodID(jni_env, package_manager_class, "getInstance", "()Lcom/bishopsoft/Presto/SDK/Presto;");
    jobject get_instance_object = JNIEnv::CallStaticObjectMethod(jni_env, package_manager_class, get_instance_id);
    jmethodID stop_scan_id = JNIEnv::GetMethodID(jni_env, package_manager_class, "StopScan", "()V");
    JNIEnv::CallVoidMethod(jni_env, get_instance_object, stop_scan_id, 0);

    return 0;
}

void random_str(char *return_val, int lengh) {
    int random;
    ulong lengh_copy;
    char *pcVar1;

    lengh_copy = (ulong)lengh;
    pcVar1 = return_val;
    if (0 < lengh) {
        while (lengh_copy != 0) {
            random = rand();
            lengh_copy = lengh_copy - 1;
            *pcVar1 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
                    [(long)random + (((ulong)(long)random >> 1) / 0x1f) * -0x3e];
            pcVar1 = pcVar1 + 1;
        }
    }
    return_val[lengh] = 0;
    return return_val;
}

int getDataDir(JNIEnv *jni_env, jobject current_activity, char *return_val) {
    jclass package_manager_class = (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)jni_env + 248))(jni_env); //WTF?

    jmethodID application_info_id = (jni_env, package_manager_class, "getApplicationInfo", "()Landroid/content/pm/ApplicationInfo;");
    jobject application_info = _JNIEnv::CallObjectMethod(jni_env, current_activity, application_info_id);
    jfieldID data_dir_id = JNIEnv::FindObjectField(jni_env, application_info, "dataDir", "Ljava/lang/String;");
    jstring data_dir = JNIEnv::GetObjectField(jni_env, application_info, data_dir_id);

    if (data_dir) {
        const char *native_data_dir = JNIEnv::GetStringUTFChars(jni_env, data_dir, 0);
        if (native_data_dir) {
            memcpy(return_val, native_data_dir, (strlen(native_data_dir) + 1));
        }
        JNIEnv::(jni_env, data_dir, native_data_dir); //WUT?
    }
    return 0;
}

int getNativeLibraryDir(JNIEnv *jni_env, jobject current_activity, char *return_val) {
    jclass current_class = JNIEnv::GetObjectClass(jni_env, current_activity);
    jmethodID application_info_id = JNIEnv::GetObjectMethodID(jni_env, current_class, "getApplicationInfo", "()Landroid/content/pm/ApplicationInfo;");
    jobject application_info = _JNIEnv::CallObjectMethod(jni_env, current_activity, application_info_id);

    jclass application_info_class = JNIEnv::(jni_env, application_info);
    jmethodID native_library_dir_id = JNIEnv::(jni_env, application_info_class, "nativeLibraryDir", "Ljava/lang/String;");
    jstring native_library_dir = JNIEnv::GetObjectField(jni_env, application_info, native_library_dir_id);

    if (native_library_dir) {
        const char *native_lib_dir = JNIEnv::GetStringUTFChars(jni_env, native_library_dir, 0);
        if (native_lib_dir) {
            memcpy(return_val, v14, (strlen(native_lib_dir) + 1));
        }
    }
    return 0;
}

void *subNRes(char *a1) { //UNUSED PARAM?
    char encrypted_str_buffer[260];
    char src[260];
    char dest[268];

    memset(src, 0, 260);
    memcpy(encrypted_str_buffer, "C081CD4C7F549EC7B6F15000E2D92C4C", 260);

    decrypt_buffer(encrypted_str_buffer, strlen(encrypted_str_buffer));
    strcpy(dest, &g_dataPath);
    strcpy(&dest[strlen(dest)], "/.");
    strcpy(src, encrypted_str_buffer);
    strcat(dest, src);

    void *handle = dlopen(dest, 1);
    g_Uhandle = handle;

    if (!handle) {
        LOGE("G-Presto load failed : 2001");
        exit(1);
    }
    void *res_sym = dlsym(handle, "Res");

    if (!res_sym) {
        LOGE("G-Presto load failed : 2003");
        exit(1);
    }
    return res_sym;
}

int getBuildProperty(JNIEnv *jni_env, jobject a2, jobject a3, char *return_val) {
    jclass build_class = JNIEnv::FindClass(jni_env, "android/os/Build");
    android_build_prop_id = JNIEnv::GetObjectFieldID(jni_env, build_class, a3, "Ljava/lang/String;");
    android_build_prop = JNIEnv::GetObjectField(jni_env, build_class, android_build_prop_id);

    if (android_build_prop) {
        char *native_build_prop_str = JNIEnv::GetStringUTFChars(jni_env, android_build_prop, 0);
        if (native_build_prop_str) {
            memcpy(return_val, native_build_prop_str, (strlen(native_build_prop_str) + 1));
        }
    }
    return 0;
}

//NOT IMPORTANT
int getDataDir(JNIEnv *env, jobject *param_2, char *return_val) {
  undefined8 uVar1;
  undefined8 uVar2;
  long lVar3;
  char *__s;
  size_t sVar4;
  
  uVar1 = (**(code **)(*(long *)env + 0xf8))();
  uVar1 = (**(code **)(*(long *)env + 0x108))
                    (env,uVar1,"getApplicationInfo","()Landroid/content/pm/ApplicationInfo;");
  uVar1 = _JNIEnv::CallObjectMethod((_jobject *)env,(_jmethodID *)param_2,uVar1);
  uVar2 = (**(code **)(*(long *)env + 0xf8))(env,uVar1);
  uVar2 = (**(code **)(*(long *)env + 0x2f0))(env,uVar2,"dataDir","Ljava/lang/String;");
  lVar3 = (**(code **)(*(long *)env + 0x2f8))(env,uVar1,uVar2);
  if (lVar3 != 0) {
    __s = (char *)(**(code **)(*(long *)env + 0x548))(env,lVar3,0);
    if (__s != (char *)0x0) {
      sVar4 = strlen(__s);
      memcpy(return_val,__s,sVar4 + 1);
    }
    (**(code **)(*(long *)env + 0x550))(env,lVar3,__s);
  }
  return 0;
}

//NOT IMPORTANT
int getNativeLibraryDir(_JNIEnv *param_1,_jobject *param_2, char *return_val) {
  undefined8 uVar1;
  undefined8 uVar2;
  long lVar3;
  char *__s;
  size_t sVar4;
  
  uVar1 = (**(code **)(*(long *)param_1 + 0xf8))();
  uVar1 = (**(code **)(*(long *)param_1 + 0x108))
                    (param_1,uVar1,"getApplicationInfo","()Landroid/content/pm/ApplicationInfo;");
  uVar1 = _JNIEnv::CallObjectMethod((_jobject *)param_1,(_jmethodID *)param_2,uVar1);
  uVar2 = (**(code **)(*(long *)param_1 + 0xf8))(param_1,uVar1);
  uVar2 = (**(code **)(*(long *)param_1 + 0x2f0))
                    (param_1,uVar2,"nativeLibraryDir","Ljava/lang/String;");
  lVar3 = (**(code **)(*(long *)param_1 + 0x2f8))(param_1,uVar1,uVar2);
  if (lVar3 != 0) {
    __s = (char *)(**(code **)(*(long *)param_1 + 0x548))(param_1,lVar3,0);
    if (__s != (char *)0x0) {
      sVar4 = strlen(__s);
      memcpy(return_val,__s,sVar4 + 1);
    }
    (**(code **)(*(long *)param_1 + 0x550))(param_1,lVar3,__s);
  }
  return 0;
}

int android_setCpu(int a1, __int64 a2) {
    unsigned int v2; // w19
    int v3; // w8

    if ((byte_579D4 & 1) != 0) {
        return 0;
    } else {
        v2 = 1;
        byte_579C0 = 1;
        if (a1 <= 1) {
            v3 = 1;
        } else {
            v3 = a1;
        }

        qword_579C8 = a2;
        dword_579D0 = v3;
        pthread_once(&dword_579BC, sub_17F9C);
    }
    return v2;
}

void android_getCpuFeatures() {
    pthread_once(&dword_579BC, &check_cpu_info);
    return qword_579C8;
}

void android_getCpuFamily() {
    pthread_once(&dword_579BC, &check_cpu_info);
    if (byte_579C0) {
        return 4;
    } else {
        return 0;
    }
}

void android_getCpuCount() {
    pthread_once(&dword_579BC, &check_cpu_info);
    return (unsigned int)dword_579D0;
}


```

`encryption.h`:

```h
void decrypt_buffer(char *input_output, int str_lengh) {
    int v5; // w10
    __int64 v6; // x8
    __int64 v7; // x9
    int v8; // w23
    int v9; // w12
    char v10; // w10
    int v11; // w11
    char v12; // w10
    unsigned __int64 tmp_lengh; // x21
    __int64 v14; // x21
    __int128 v15; // q1
    int8x16_t v18; // [xsp+0h] [xbp-14B0h] BYREF
    __int128 v19; // [xsp+10h] [xbp-14A0h]
    __int128 v21; // [xsp+1020h] [xbp-490h]


    char output_buffer[4096];
    char encryption_key[30];


    __int128 v23; // [xsp+1050h] [xbp-460h]
    _QWORD key[130]; // [xsp+1060h] [xbp-450h] BYREF

    //If input lengh is bigger or equal to 0
    if (str_lengh >= 0) {
        v5 = str_lengh;
    } else {
        v5 = str_lengh + 1;
    }

    //Copy hardcoded encryption key into the variable
    memcpy(encryption_key, "e38d99fb4434d3d485794c6b34cd5d1f", 30); //ENCRYPTION KEY!!!

    v21 = xmmword_33DB4;

    //If lengh is smaller than 2
    if (str_lengh < 2) {
        v18 = 0;
        v19 = v21;
        memset(output_buffer, 0, 4096);
        aes_set_key(key, encryption_key, 256);
        tmp_lengh = 0;
    } else {
        v6 = 0;
        v7 = 0;
        v8 = v5 >> 1;

        while ((int)v7 < v8) {
            v9 = (unsigned __int8)input_output[v6];
            v10 = v9 - 48;

            if ((unsigned int)(v9 - 48) >= 0xA) {
                if ((unsigned int)(v9 - 65) > 5)
                break;
                v10 = v9 - 55;
            }
            v11 = (unsigned __int8)input_output[v6 + 1];

            if ((unsigned int)(v11 - 48) > 9) {
                if ((unsigned int)(v11 - 65) > 5) {
                    break;
                }
                v12 = v11 + 16 * v10 - 55;
            } else {
                v12 = v11 - 48 + 16 * v10;
            }
            input_output[v7++] = v12;
            v6 += 2LL;
        }

        v18 = 0;
        v19 = v21;
        memset(output_buffer, 0, 4096);
        aes_set_key(key, encryption_key, 256);
        tmp_lengh = 0;

        if (str_lengh >= 2) {
            v14 = 0;
            while (v14 < v8) {
                v18 = *(int8x16_t *)&input_output[v14];
                v23 = *(_OWORD *)&input_output[v14];
                aes_decrypt(key, &v18, &v18);
                v18 = veorq_s8(v18, (int8x16_t)v19);
                v15 = v23;
                *(int8x16_t *)&output_buffer[v14] = v18;
                v14 += 16;
                v19 = v15;
            }

            tmp_lengh = (v8 + 15) & 4294967280;
        }
    }

    if (tmp_lengh >= str_lengh) {
        str_lengh = tmp_lengh;
    }
    
    memset(&input_output[tmp_lengh], 0, str_lengh - tmp_lengh);

    //Copy decrypted string into input_output
    memcpy(input_output, output_buffer, tmp_lengh);
    return 0;
}
```