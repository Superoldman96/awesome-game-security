Project Path: arc_gmh5225_vm_oxsf_o8f

Source Tree:

```txt
arc_gmh5225_vm_oxsf_o8f
├── asm-test
│   ├── add
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── asmlib
│   │   ├── libmyasm.a
│   │   ├── main.c
│   │   ├── makefile
│   │   └── print_badrer.s
│   ├── cmp
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── cmps
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── cpuid
│   │   ├── cpuid
│   │   ├── cpuid.o
│   │   ├── cpuid.s
│   │   └── makefile
│   ├── func
│   │   ├── main
│   │   ├── main.s
│   │   └── makefile
│   ├── hello
│   │   ├── hello.o
│   │   ├── hello.s
│   │   ├── make-test
│   │   └── makefile
│   ├── inline
│   │   ├── main
│   │   ├── main.c
│   │   └── makefile
│   ├── jxx
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── libc
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── loop
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── makefile
│   ├── movs
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── rep
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── scans
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── stack-func
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   ├── stos
│   │   ├── main
│   │   ├── main.o
│   │   ├── main.s
│   │   └── makefile
│   └── trans-data
│       ├── main
│       ├── main.o
│       ├── main.s
│       └── makefile
├── other-vm
│   ├── SimpleVM
│   │   ├── Lilac-interpreter.py
│   │   ├── bytecode.txt
│   │   ├── interpreter.py
│   │   ├── makefile
│   │   ├── readme.md
│   │   ├── vm.c
│   │   ├── vm.h
│   │   ├── vm.o
│   │   ├── vmtest
│   │   ├── vmtest.c
│   │   ├── vmtest.i64
│   │   └── vmtest.o
│   └── codyebberson-VM
│       ├── LICENSE
│       ├── Makefile
│       ├── README.md
│       ├── vm.c
│       ├── vm.h
│       ├── vmtest
│       └── vmtest.c
├── pdf
│   ├── CSAW2016_How_Triton_can_help_to_reverse_virtual_machine_based_software_protections.pdf
│   ├── KCon2016_VMProtect_by_hxx.pdf
│   └── VMProtect的逆向分析和静态还原.pdf
├── vm-packer
│   ├── ReadMe.txt
│   └── 反汇编
│       ├── 反汇编
│       │   ├── ASM
│       │   │   ├── asmserv.cpp
│       │   │   ├── assembl.cpp
│       │   │   ├── disasm.cpp
│       │   │   └── disasm.h
│       │   ├── CCodeILFactory.cpp
│       │   ├── CCodeILFactory.h
│       │   ├── CLink.cpp
│       │   ├── CLink.h
│       │   ├── CVMFactory.cpp
│       │   ├── CVMFactory.h
│       │   ├── CVirtualMemory.cpp
│       │   ├── CVirtualMemory.h
│       │   ├── InterpretHandler.cpp
│       │   ├── InterpretHandler.h
│       │   ├── PEStructure.cpp
│       │   ├── PEStructure.h
│       │   ├── ReadMe.txt
│       │   ├── VCommand.cpp
│       │   ├── VCommand.h
│       │   ├── comm.cpp
│       │   ├── comm.h
│       │   ├── main.cpp
│       │   ├── stdafx.cpp
│       │   ├── stdafx.h
│       │   ├── vmdisasm.cpp
│       │   ├── vmdisasm.h
│       │   ├── vmserv.cpp
│       │   ├── 反汇编.vcproj
│       │   └── 反汇编.vcproj.BUG.bug.user
│       ├── 反汇编.sln
│       └── 反汇编.suo
└── vm-test
    ├── main
    └── main.c

```

`asm-test/add/main.s`:

```s
.section .text
.globl _start
_start:
    nop
    movl $0,%ebx
    movb $2,%bl
    movb $2,%al
    #addb %al,%bl
    inc %ebx
    dec %ebx
    sal $2,%ebx
    sar $2,%ebx

    jc  jc_here
    movl $1,%eax
    int $0x80

jc_here:
    movl $0,%ebx
    movl $1,%eax
    int $0x80

```

`asm-test/add/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/asmlib/main.c`:

```c
#include <stdio.h>

// int add(int, int);
// int add_inc(int);
// int sub(int, int);
// int sub_dec(int);
int print_badrer(void);

int main(int argc, const char *argv[])
{
    // int ret;

    // ret = add(1989, 711);
    // printf("The add() return is %d.\n", ret);

    // ret = add_inc(1989);
    // printf("The add_inc() return is %d.\n", ret);

    // ret = sub(1989, 711);
    // printf("The sub() return is %d.\n", ret);

    // ret = sub_dec(1989);
    // printf("The sub_dec() return is %d.\n", ret);

    print_badrer();

    return 0;
}
```

`asm-test/asmlib/makefile`:

```
CFLAGS= -Wall -g
ASFLAGS= -gstabs

SRC_BIN=target_bin

SRC_LIB=libmyasm.a

SRC_C=$(wildcard *.c)
SRC_S=$(wildcard *.s)

SRC_COBJ=$(SRC_C:.c=.o)
SRC_SOBJ=$(SRC_S:.s=.o)

SRC_OBJ=$(SRC_COBJ) $(SRC_SOBJ)

all: $(SRC_BIN)

$(SRC_BIN): $(SRC_COBJ) $(SRC_LIB)
	$(CC) -o $@ $(SRC_COBJ) -L./ -lmyasm

$(SRC_LIB) : $(SRC_SOBJ)
	ar rcs $@ $^

clean:
	$(RM) $(SRC_OBJ) $(SRC_BIN) *~
.PHONY:
	all clean
```

`asm-test/asmlib/print_badrer.s`:

```s
.type print_badrer, @function
.section .data
output:
    .ascii "BadRer"
    len = .-output

.section .text
.globl print_badrer
print_badrer:
    movl $len,%edx
    movl $output,%ecx
    movl $1,%ebx
    movl $4,%eax

    int $0x80

    movl $0,%ebx
    movl $1,%eax
    int $0x80

```

`asm-test/cmp/main.s`:

```s
.section .text
.globl _start
_start:
    nop
    movl $11,%eax
    movl $12,%ebx
    cmp %eax,%ebx
    jle jae_here
    movl $1,%eax
    int $0x80

jae_here:
    movl $20,%ebx
    movl $1 ,%eax
    int $0x80
    


```

`asm-test/cmp/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/cmps/main.s`:

```s
.section .data
var1:
    .ascii "Hello123"
var2:
    .ascii "Hello456"
.section .bss
    .lcomm index,8

.section .text
.globl _start
_start:
    nop
    leal var1,%esi
    leal var2,%edi
    movl $8,%ecx

    cld
    rep cmpsb
    je equal

    movl %ecx,%ebx
    movl $1,%eax
    int $0x80

equal:
    movl $0,%ebx
    movl $1,%eax
    int $0x80

```

`asm-test/cmps/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/cpuid/cpuid.s`:

```s
.section .data
output:
    .ascii "The processor Vendor ID is 'XXXXXXXXXXXX'\n"

.section .text
.global _start
_start:
    movl $0,%eax
    cpuid 
    movl $output,%edi
    movl %ebx,28(%edi)
    movl %edx,32(%edi)
    movl %ecx,36(%edi)

    movl $42,%edx
    movl $output,%ecx
    movl $1,%ebx
    movl $4,%eax
    int $0x80

    movl $0,%ebx
    movl $1,%eax
    int $0x80
    
```

`asm-test/cpuid/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := cpuid
SRC := cpuid.o

.PHONY:clean
clean:	*.o
	rm -rf *.o

.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

```

`asm-test/func/main.s`:

```s
.section .data
msg:
    .ascii "This is call\n"
    len = .-msg
.section .text
.globl _start
_start:

    nop
    call call_func

    movl $0,%ebx
    movl $1,%eax
    int $0x80

.code32
call_func:
    pushl %ebp
    movl %esp,%ebp

    #func code here
    movl $len,%edx
    movl $msg,%ecx
    movl $1  ,%ebx
    movl $4  ,%eax  #sys_write
    int $0x80

    movl %ebp,%esp
    popl %ebp
    ret

```

`asm-test/func/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs 


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^  -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/hello/hello.s`:

```s
.section .data

msg:
    .ascii "hello world"
    len = .-msg

.section .text

#.global _start
#_start:

.global _start

_start:
movl $len,%edx
movl $msg,%ecx
movl $1  ,%ebx
movl $4  ,%eax

int $0x80

# exit

movl $0,%ebx
movl $1,%eax

int $0x80

```

`asm-test/hello/makefile`:

```
CFLAGS := --gstabs
OUT := make-test
SRC := hello.o
AS  := as --gstabs
.PHONY:clean
clean:	*.o
	rm -rf *.o

.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

```

`asm-test/inline/main.c`:

```c
#include<stdio.h>
#include<stdlib.h>
#define CAL ({\
    asm("addl $10,result\n\t"\
        "subl $2,result\n\t");\
        })

int result = 10;

int main(int argc,char ** argv){

    CAL;
    printf("The result is %d\n",result);
    return 0;
}

```

`asm-test/inline/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/jxx/main.s`:

```s
.section .text
.globl _start
_start:
    nop
    movl $1,%eax
    jmp jmp_here
    movl $11,%ebx
    int $0x80

jmp_here:
    movl $20,%ebx
    int $0x80
    
```

`asm-test/jxx/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/libc/main.s`:

```s
.section .data
output:
    .ascii "The result is %d.\n"

.section .bss
    .lcomm result,4
.section .text
.globl _start
.code32
_start:
    nop
    movl $0,result
    movl %esp,%ebp

    pushl 8(%ebp)
    call atoi
    movl %eax,result

    pushl 12(%ebp)
    call atoi
    addl %eax,result

    pushl result
    pushl $output
    call printf

    movl $1,%eax
    int $0x80

```

`asm-test/libc/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/loop/main.s`:

```s
.section .text
.globl _start
_start:
    movl $10,%ecx
    movl $0 ,%eax
loop_here:
    addl %ecx,%eax
    loop loop_here

    movl %eax,%ebx
    movl $1  ,%eax
    int $0x80

```

`asm-test/loop/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/movs/main.s`:

```s
.section .data
var:
    .ascii "Hello."
    len = .-var

.section .bss
    .lcomm output,7

.section .text
.globl _start
_start:
    #leal var,%esi
    #leal output,%edi
    movl $var,%esi
    movl $output,%edi
    movl $7,%ecx
loop_strcpy:
    movsb
    loop loop_strcpy

    #movsb
    #movsw
    #movsl

    movl $0,%ebx
    movl $1,%eax

    int $0x80

```

`asm-test/movs/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/rep/main.s`:

```s
.section .data
var:
    .ascii "Hello."
    len = .-var
.section .bss
    .lcomm output,7
.section .text
.globl _start
_start:
    leal var,%esi
    leal output,%edi
    movl $7,%ecx

    cld
    rep movsb

    movl $0,%ebx
    movl $1,%eax
    int $0x80

```

`asm-test/rep/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/scans/main.s`:

```s
.section .data
var:
    .ascii "This is test\n"
    len = .-var

.section .text
.globl _start
_start:
    nop

    leal var,%edi
    movl $0xffff,%ecx
    movb $0,%al

    cld
    repne scasb
    jne not_found

    subw $0xffff,%cx
    neg  %cx
    dec  %cx

    movl %ecx,%ebx
    movl $1,%eax
    int $0x80

not_found:
    movl $0,%ebx
    movl $1,%eax
    int $0x80

```

`asm-test/scans/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/stack-func/main.s`:

```s
.section .data
var:
    .int 100
plus_no:
    .int 8
.section .bss
    .lcomm result ,4

.section .text
.globl _start
.code32
_start:
    nop
    pushl var
    pushl plus_no
    call cal_func

    movl $1,%eax
    int $0x80

cal_func:
    pushl %ebp
    movl %esp,%ebp

    movl $0,%eax
    addl 8(%ebp),%eax
    addl 12(%ebp),%eax
    movl %eax,%ebx

    movl %ebp,%esp
    popl %ebp
    ret
    
```

`asm-test/stack-func/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/stos/main.s`:

```s
.section .data
space:
    .ascii "1"
.section .bss
    .lcomm output,256
.section .text
.globl _start
_start:
    nop
    leal space,%esi
    leal output,%edi
    movl $256,%ecx

    cld
    lodsb #esi -> eax
    rep stosb #

    movl $0,%ebx
    movl $1,%eax
    int $0x80
    
```

`asm-test/stos/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`asm-test/trans-data/main.s`:

```s
.section .data
values:
    .int 10,20,30,40

.section .text
.globl _start
_start:
    nop
    movl values,%eax
    movl $values,%edi
    movl $100,4(%edi)
    movl $1,%edi
    movl $1,%eax
    int $0x80

```

`asm-test/trans-data/makefile`:

```
CFLAGS := --gstabs
AS  := as --gstabs


OUT := main
SRC := main.o



.PHONY:build
build: $(SRC)
	ld  $^ -o $(OUT)

s2o:
	$(AS) -o $<

.PHONY:clean
clean:	*.o
	rm -rf *.o

```

`other-vm/SimpleVM/Lilac-interpreter.py`:

```py
with open("code") as f:
    code = map(ord, f.read())
print code
inst = {
    0: ("exit", 0),
    1: ("push", 4),
    2: ("pop", 0),
    3: ("add", 2),
    4: ("sub", 2),
    5: ("mul", 2, ''),
    6: ("rshift", 2, ''),
    7: ("mov", 2),
    8: ("movs", 2),
    9: ("xor", 2),
    10: ("or", 2)
}

ip = 0
disasm = ''
while True:
    if ip >= len(code):
        break
    opcode = code[ip]
    if not inst.has_key(opcode):
        disasm += "invalid\n"
        continue
    mnem = inst[opcode][0]
    addition = inst[opcode][1]
    if addition == 0:
        oprand = ''
    elif addition == 4:
        num = code[ip+1] + (code[ip+2] << 8) + (code[ip+3] << 16) + (code[ip+4] << 24)
        oprand = hex(num)
    elif addition == 2 and len(inst[opcode]) != 3:
        oprand = "[%d], [%d]" % (code[ip+1], code[ip+2])
    elif addition == 2:
        oprand = "[%d], %d" % (code[ip+1], code[ip+2])

    disasm += "0x%02x: %s %s\n" % (ip, mnem, oprand)
    ip += addition+1
print disasm
```

`other-vm/SimpleVM/bytecode.txt`:

```txt
bytecode

opcode              伪代码                          addr                           高级语言

0x09,0x03           r0 = 3                          0                             // init
0x0D,0x00           d0 = r0 =3                      2                               i = 0
0x09,0x00           r0 = 0                          4                               N = 3
0x0D,0x01           d1 = r0 = 0                     6                               sum = 0
0x09,0x00           r0 = 0                          8
0x0D,0x02           d2 = r0 = 0                     10

0x0B,0x01           r0 = d1 = 0                     12                           while(i<N)
0x0B,0x00           r1 = d0 = 3                     14                          
0x04,               JL                              16                          
0x08,0x23           jmp code-offset 0x23(35)        17                          
0x0B,0x01,          r0 = d1 = 0                     19                           
0x09,0x01,          r1 = 1                          21  
0x01,               r0 = r0+r1 = 1                  23                          i = i + 1
0x0D,0x01,          d1 = r0 = 1                     24
0x0B,0x02,          r0 = d2 = 0                     26
0x0B,0x01,          r1 = d1 = 1                     28
0x01,               r0 = r0 + r1 = 1                30                          sum = sum + i
0x0D,0x02,          d2 = r0 = 1                     31
0x06,0x0C,          jmp 0xc(12)                     33  

0x0B,0x02,          r0 = d2 = ?                     35                          print sum
0x0E,               print r0                        37
0x10,               exit                            38

iconst: r0 = 3
gstore: d0 = r0
iconst: r0 = 0
gstore: d1 = r0
iconst: r0 = 0
gstore: d2 = r0
gload: r0 = d1
gload: r0 = d0
ilt:
brf: jmp 35
gload: r0 = d1
iconst: r0 = 1
iadd: r0 = r0 + r1
gstore: d1 = r0
gload: r0 = d2
gload: r0 = d1
iadd: r0 = r0 + r1
gstore: d2 = r0
br: jmp 12
gload: r0 = d2
print:
halt: exit
```

`other-vm/SimpleVM/interpreter.py`:

```py
#-*-coding:utf-8-*-
code=[0x09,0x03,0x0D,0x00,0x09,0x00,0x0D,0x01,0x09,0x00,0x0D,0x02,0x0B,0x01,0x0B,0x00,0x04,0x08,0x23,0x0B,0x01,0x09,0x01,0x01,0x0D,0x01,0x0B,0x02,0x0B,0x01,0x01,0x0D,0x02,0x06,0x0C,0x0B,0x02,0x0E,0x10]

def interpreter():
    inst = {
    0: "noop",
    1: "iadd",
    2: "isub",
    3: "imul",
    4: "ilt",
    5: "ieq",
    6: "br",
    7: "brt",
    8: "brf",
    9: "iconst",
    10: "load",
    11: "gload",
    12: "store",
    13: "gstore",
    14: "print",
    15: "pop",
    16: "halt",
    }

    index = 0
    while 1:
        op = code[index]
        if inst[op] == "halt" :
            print "%s: exit" % (inst[op])
            break
        if inst[op] == "iadd" :
            print "%s: r0 = r0 + r1" % (inst[op])
            index = index + 1
            continue
        if inst[op] == "print" :
            print "%s: " % (inst[op])
            index = index + 1
            continue
        if inst[op] == "gstore" :
            d_index = code[index+1]
            print "%s: d%d = r0" % (inst[op],d_index)
            index = index + 2
            continue
        if inst[op] == "ilt" :
            print "%s: JL" % (inst[op])
            index = index + 1
            continue
        if inst[op] == "brf" :
            d_index = code[index+1]
            print "%s: jmp %d" % (inst[op],d_index)
            index = index + 2
            continue
        if inst[op] == "br" :
            d_index = code[index+1]
            print "%s: jmp %d" % (inst[op],d_index)
            index = index + 2
            continue
        if inst[op] == "gload" :
            d_index = code[index+1]
            print "%s: r0 = d%d " % (inst[op],d_index)
            index = index + 2
            continue
        if inst[op] == "iconst" :
            d_index = code[index+1]
            print "%s: r0 = %d " % (inst[op],d_index)
            index = index + 2
            continue
        index = index + 1

interpreter()
```

`other-vm/SimpleVM/makefile`:

```
CXXFLAGS = -O0 -Wall
CCFLAGS = -O0 -Wall


OUTPUT = vmtest
OBJECTS = vm.o vmtest.o

all: executable

CC = cc $(CCFLAGS)
CXX = g++ $(CXXFLAGS)

executable: $(OBJECTS)
	$(CC) -o $(OUTPUT) $^

#编译所有的.c 文件为 .o
.c.o: 
	$(CC) -c $<

clean:
	rm -rf *.o
```

`other-vm/SimpleVM/readme.md`:

```md
based on https://github.com/codyebberson/vm

change & add something
```

`other-vm/SimpleVM/vm.c`:

```c

#include <stdio.h>
#include <stdlib.h>

#include "vm.h"

#define DEFAULT_STACK_SIZE 1000
#define FALSE 0
#define TRUE 1

typedef struct {
    char name[8];
    int nargs;
} VM_INSTRUCTION;

VM_INSTRUCTION vm_instructions[] = {
    { "noop",   0 },
    { "iadd",   0 },
    { "isub",   0 },
    { "imul",   0 },
    { "ilt",    0 },
    { "ieq",    0 },
    { "ret",    0 },
    { "br",     1 },
    { "brt",    1 },
    { "brf",    1 },
    { "iconst", 1 },
    { "load",   1 },
    { "gload",  1 },
    { "store",  1 },
    { "gstore", 1 },
    { "print",  0 },
    { "pop",    0 },
    { "halt",   0 }
};

static void vm_print_instr(int *code, int ip);
static void vm_print_stack(int *stack, int count);
static void vm_print_data(int *globals, int count);

void vm_exec(int *code, int count, int startip, int nglobals, int trace)
{
    // registers
    int ip = 0;         // instruction pointer register
    int sp = -1;          // stack pointer register
    int fp = -1;        // frame pointer register

    int opcode = code[ip];
    int a = 0;
    int b = 0;
    int addr = 0;
    int offset = 0;

    // global variable space
    int globals[nglobals];

    // Operand stack, grows upwards
    int stack[DEFAULT_STACK_SIZE];

    while (opcode != HALT && ip < count) {
        if (trace) vm_print_instr(code, ip);
        ip++; //jump to next instruction or to operand
        switch (opcode) {
            case IADD:
                b = stack[sp--];           // 2nd opnd at top of stack
                a = stack[sp--];           // 1st opnd 1 below top
                stack[++sp] = a + b;       // push result
                break;
            case ISUB:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = a - b;
                break;
            case IMUL:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = a * b;
                break;
            case ILT:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = (a < b) ? TRUE : FALSE;
                break;
            case IEQ:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = (a == b) ? TRUE : FALSE;
                break;
            case BR:
                ip = code[ip];
                break;
            case BRT:
                addr = code[ip++];
                if (stack[sp--] == TRUE) ip = addr;
                break;
            case BRF:
                addr = code[ip++];
                if (stack[sp--] == FALSE) ip = addr;
                break;
            case ICONST:
                stack[++sp] = code[ip++];  // push operand
                break;
            case LOAD: // load local or arg; 1st local is fp+1, args are fp-3, fp-4, fp-5, ...
                offset = code[ip++];
                stack[++sp] = stack[fp+offset];
                break;
            case GLOAD: // load from global memory
                addr = code[ip++];
                stack[++sp] = globals[addr];
                break;
            case STORE:
                offset = code[ip++];
                stack[fp+offset] = stack[sp--];
                break;
            case GSTORE:
                addr = code[ip++];
                globals[addr] = stack[sp--];
                break;
            case PRINT:
                printf("%x\n", stack[sp--]);
                break;
            case POP:
                --sp;
                break;
            default:
                printf("invalid opcode: %d at ip=%d\n", opcode, (ip - 1));
                exit(1);
        }
        if (trace) vm_print_stack(stack, sp);
        opcode = code[ip];
    }
    if (trace) vm_print_instr(code, ip);
    if (trace) vm_print_stack(stack, sp);
    if (trace) vm_print_data(globals, nglobals);
}

static void vm_print_instr(int *code, int ip)
{
    int opcode = code[ip];
    VM_INSTRUCTION *inst = &vm_instructions[opcode];
    switch (inst->nargs) {
    case 0:
        printf("%04d:  %-20s", ip, inst->name);
        break;

    case 1:
        printf("%04d:  %-10s%-10d", ip, inst->name, code[ip + 1]);
        break;
    }
}

static void vm_print_stack(int *stack, int count)
{
    printf("stack=[");
    for (int i = 0; i <= count; i++) {
        printf(" %d", stack[i]);
    }
    printf(" ]\n");
}

static void vm_print_data(int *globals, int count)
{
    printf("Data memory:\n");
    for (int i = 0; i < count; i++) {
        printf("%04d: %d\n", i, globals[i]);
    }
}


```

`other-vm/SimpleVM/vm.h`:

```h

#ifndef VM_H_
#define VM_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    NOOP    = 0,
    IADD    = 1,   // int add
    ISUB    = 2,
    IMUL    = 3,
    ILT     = 4,   // int less than
    IEQ     = 5,   // int equal
    BR      = 6,   // branch
    BRT     = 7,   // branch if true
    BRF     = 8,   // branch if false
    ICONST  = 9,   // push constant integer
    LOAD    = 10,  // load from local context
    GLOAD   = 11,  // load from global memory
    STORE   = 12,  // store in local context
    GSTORE  = 13,  // store in global memory
    PRINT   = 14,  // print stack top
    POP     = 15,  // throw away top of stack
    HALT    = 16    //over
} VM_CODE;

void vm_exec(int *code, int count, int startip, int nglobals, int trace);

#ifdef __cplusplus
}
#endif

#endif


```

`other-vm/SimpleVM/vmtest.c`:

```c

#include <stdio.h>
#include <time.h>
#include "vm.h"

int hello[] = {
    ICONST, 1234,
    PRINT,
    HALT
};

int loop[] = {
// .GLOBALS 2; N, I
// N = 10                      ADDRESS
        ICONST, 10,            // 0
        GSTORE, 0,             // 2
// I = 0
        ICONST, 0,             // 4
        GSTORE, 1,             // 6
// WHILE I<N:
// START (8):
        GLOAD, 1,              // 8
        GLOAD, 0,              // 10
        ILT,                   // 12
        BRF, 24,               // 13
//     I = I + 1
        GLOAD, 1,              // 15
        ICONST, 1,             // 17
        IADD,                  // 19
        GSTORE, 1,             // 20
        BR, 8,                 // 22

        GLOAD,1,                //24
        PRINT,                  //26
// DONE (24):
// PRINT "LOOPED "+N+" TIMES."
        HALT                   // 27
};

int calc[] = {
//.GLOBALS ;
// N = 10
        ICONST,10,            //0
        GSTORE,0,               //2
// sum = 0
        ICONST,0,            //4
        GSTORE,1,               //6
// i = 0
        ICONST,0,             //8
        GSTORE,2,               //10
//while i < n
        GLOAD,2,                //14
        GLOAD,0,                //16
        ILT,                    //18
        BRF,37,                   //19

        GLOAD,1,                //21
        GLOAD,2,                //23
        IADD,                   //25
        GSTORE,1,               //26

        GLOAD,2,                //28
        ICONST,1,                //30
        IADD,                   //32
        GSTORE,2,               //33
        BR,14,                   //35

        ICONST,1234,                //37
        PRINT,                  //39

        HALT                    //40

};

int loop2[] = {
// .GLOBALS 2; N, I
// N = 10                      ADDRESS
        ICONST, 3,            // 0
        GSTORE, 0,             // 2
// I = 0
        ICONST, 0,             // 4
        GSTORE, 1,             // 6
// SUM = 0
        ICONST,0,               //8
        GSTORE,2,               //10
// WHILE I<N:
// START (8):
        GLOAD, 1,              // 12
        GLOAD, 0,              // 14
        ILT,                   // 16
        BRF, 35,               // 17
//     I = I + 1
        GLOAD, 1,              // 19
        ICONST, 1,             // 21
        IADD,                  // 23
        GSTORE, 1,             // 24
//sum = sum +i
        GLOAD,2,                //26
        GLOAD,1,                //28
        IADD,                   //30
        GSTORE,2,               //31

        BR, 12,                 // 33
        GLOAD,2,                //35
        PRINT,                  //37
// DONE (24):
// PRINT "LOOPED "+N+" TIMES."
        HALT                   // 28
};

int main(int argc, char *argv[])
{
    //     vm_exec(hello, sizeof(hello), 0, 0, 1);
    vm_exec(loop2, sizeof(loop2), 0, 2, 0);
    return 0;
}


```

`other-vm/codyebberson-VM/LICENSE`:

```
Copyright (c) 2014, Cody Ebberson

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

```

`other-vm/codyebberson-VM/Makefile`:

```

CC = gcc
CFLAGS = -O3 -std=c99 -pedantic -pedantic-errors -fno-exceptions \
 -Wl,-z,relro -Wl,-z,now -fvisibility=hidden -W -Wall \
 -Wno-unused-parameter -Wno-unused-function -Wno-unused-label \
 -Wpointer-arith -Wformat -Wreturn-type -Wsign-compare -Wmultichar \
 -Wformat-nonliteral -Winit-self -Wuninitialized -Wno-deprecated \
 -Wformat-security -Werror -Wformat=2 -Wno-format-nonliteral -Wshadow \
 -Wpointer-arith -Wcast-qual -Wmissing-prototypes -Wno-missing-braces
LINK = gcc
LINKFLAGS = -Wl,-O1 -Wl,--discard-all -Wl,--no-undefined

all: vmtest.exe

vmtest.exe: vm.o vmtest.o
	$(LINK) $(LINKFLAGS) -o $@ $^

%.o: %.c
	$(CC) -c $(CFLAGS) -o $@ $<

clean:
	rm -rf *.exe
	rm -rf *.o

```

`other-vm/codyebberson-VM/README.md`:

```md
vm
==

A simple VM in C

Based on Terence Parr's simple-virtual-machine
https://github.com/parrt/simple-virtual-machine

```

`other-vm/codyebberson-VM/vm.c`:

```c

#include <stdio.h>
#include <stdlib.h>

#include "vm.h"

#define DEFAULT_STACK_SIZE 1000
#define FALSE 0
#define TRUE 1

typedef struct {
    char name[8];
    int nargs;
} VM_INSTRUCTION;

VM_INSTRUCTION vm_instructions[] = {
    { "noop",   0 },
    { "iadd",   0 },
    { "isub",   0 },
    { "imul",   0 },
    { "ilt",    0 },
    { "ieq",    0 },
    { "ret",    0 },
    { "br",     1 },
    { "brt",    1 },
    { "brf",    1 },
    { "iconst", 1 },
    { "load",   1 },
    { "gload",  1 },
    { "store",  1 },
    { "gstore", 1 },
    { "print",  0 },
    { "pop",    0 },
    { "halt",   0 }
};

static void vm_print_instr(int *code, int ip);
static void vm_print_stack(int *stack, int count);
static void vm_print_data(int *globals, int count);

void vm_exec(int *code, int count, int startip, int nglobals, int trace)
{
    // registers
    int ip = 0;         // instruction pointer register
    int sp = -1;          // stack pointer register
    int fp = -1;        // frame pointer register

    int opcode = code[ip];
    int a = 0;
    int b = 0;
    int addr = 0;
    int offset = 0;

    // global variable space
    int globals[nglobals];

    // Operand stack, grows upwards
    int stack[DEFAULT_STACK_SIZE];

    while (opcode != HALT && ip < count) {
        if (trace) vm_print_instr(code, ip);
        ip++; //jump to next instruction or to operand
        switch (opcode) {
            case IADD:
                b = stack[sp--];           // 2nd opnd at top of stack
                a = stack[sp--];           // 1st opnd 1 below top
                stack[++sp] = a + b;       // push result
                break;
            case ISUB:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = a - b;
                break;
            case IMUL:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = a * b;
                break;
            case ILT:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = (a < b) ? TRUE : FALSE;
                break;
            case IEQ:
                b = stack[sp--];
                a = stack[sp--];
                stack[++sp] = (a == b) ? TRUE : FALSE;
                break;
            case BR:
                ip = code[ip];
                break;
            case BRT:
                addr = code[ip++];
                if (stack[sp--] == TRUE) ip = addr;
                break;
            case BRF:
                addr = code[ip++];
                if (stack[sp--] == FALSE) ip = addr;
                break;
            case ICONST:
                stack[++sp] = code[ip++];  // push operand
                break;
            case LOAD: // load local or arg; 1st local is fp+1, args are fp-3, fp-4, fp-5, ...
                offset = code[ip++];
                stack[++sp] = stack[fp+offset];
                break;
            case GLOAD: // load from global memory
                addr = code[ip++];
                stack[++sp] = globals[addr];
                break;
            case STORE:
                offset = code[ip++];
                stack[fp+offset] = stack[sp--];
                break;
            case GSTORE:
                addr = code[ip++];
                globals[addr] = stack[sp--];
                break;
            case PRINT:
                printf("%d\n", stack[sp--]);
                break;
            case POP:
                --sp;
                break;
            default:
                printf("invalid opcode: %d at ip=%d\n", opcode, (ip - 1));
                exit(1);
        }
        if (trace) vm_print_stack(stack, sp);
        opcode = code[ip];
    }
    if (trace) vm_print_instr(code, ip);
    if (trace) vm_print_stack(stack, sp);
    if (trace) vm_print_data(globals, nglobals);
}

static void vm_print_instr(int *code, int ip)
{
    int opcode = code[ip];
    VM_INSTRUCTION *inst = &vm_instructions[opcode];
    switch (inst->nargs) {
    case 0:
        printf("%04d:  %-20s", ip, inst->name);
        break;

    case 1:
        printf("%04d:  %-10s%-10d", ip, inst->name, code[ip + 1]);
        break;
    }
}

static void vm_print_stack(int *stack, int count)
{
    printf("stack=[");
    for (int i = 0; i <= count; i++) {
        printf(" %d", stack[i]);
    }
    printf(" ]\n");
}

static void vm_print_data(int *globals, int count)
{
    printf("Data memory:\n");
    for (int i = 0; i < count; i++) {
        printf("%04d: %d\n", i, globals[i]);
    }
}


```

`other-vm/codyebberson-VM/vm.h`:

```h

#ifndef VM_H_
#define VM_H_

#ifdef __cplusplus
extern "C" {
#endif

typedef enum {
    NOOP    = 0,
    IADD    = 1,   // int add
    ISUB    = 2,
    IMUL    = 3,
    ILT     = 4,   // int less than
    IEQ     = 5,   // int equal
    BR      = 6,   // branch
    BRT     = 7,   // branch if true
    BRF     = 8,   // branch if true
    ICONST  = 9,   // push constant integer
    LOAD    = 10,  // load from local context
    GLOAD   = 11,  // load from global memory
    STORE   = 12,  // store in local context
    GSTORE  = 13,  // store in global memory
    PRINT   = 14,  // print stack top
    POP     = 15,  // throw away top of stack
    HALT    = 16
} VM_CODE;

void vm_exec(int *code, int count, int startip, int nglobals, int trace);

#ifdef __cplusplus
}
#endif

#endif


```

`other-vm/codyebberson-VM/vmtest.c`:

```c

#include <stdio.h>
#include <time.h>
#include "vm.h"

int hello[] = {
    ICONST, 1234,
    PRINT,
    HALT
};

int loop[] = {
// .GLOBALS 2; N, I
// N = 10                      ADDRESS
        ICONST, 10,            // 0
        GSTORE, 0,             // 2
// I = 0
        ICONST, 0,             // 4
        GSTORE, 1,             // 6
// WHILE I<N:
// START (8):
        GLOAD, 1,              // 8
        GLOAD, 0,              // 10
        ILT,                   // 12
        BRF, 24,               // 13
//     I = I + 1
        GLOAD, 1,              // 15
        ICONST, 1,             // 17
        IADD,                  // 19
        GSTORE, 1,             // 20
        BR, 8,                 // 22
// DONE (24):
// PRINT "LOOPED "+N+" TIMES."
        HALT                   // 24
};

int main(int argc, char *argv[])
{
    int t1 = 0;
    int t2 = 0;
    vm_exec(hello, sizeof(hello), 0, 0, 1);

//     t1 = (clock() / (CLOCKS_PER_SEC / 1000));
//     vm_exec(loop, sizeof(loop), 0, 2, 1);
//     t2 = (clock() / (CLOCKS_PER_SEC / 1000));
//     printf("duration = %d ms\n", (t2 - t1));
    return 0;
}


```

`vm-packer/ReadMe.txt`:

```txt
/*-----------------------------------------------------------------------
第20章  虚拟机的设计
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

```

`vm-packer/反汇编/反汇编.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 9.00
# Visual Studio 2005
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "反汇编", "反汇编\反汇编.vcproj", "{D92E9F73-BB13-4978-93FB-28CC7E69996D}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Win32 = Debug|Win32
		Release|Win32 = Release|Win32
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{D92E9F73-BB13-4978-93FB-28CC7E69996D}.Debug|Win32.ActiveCfg = Debug|Win32
		{D92E9F73-BB13-4978-93FB-28CC7E69996D}.Debug|Win32.Build.0 = Debug|Win32
		{D92E9F73-BB13-4978-93FB-28CC7E69996D}.Release|Win32.ActiveCfg = Release|Win32
		{D92E9F73-BB13-4978-93FB-28CC7E69996D}.Release|Win32.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
EndGlobal

```

`vm-packer/反汇编/反汇编/ASM/asmserv.cpp`:

```cpp
// Free Disassembler and Assembler -- Command data and service routines
//
// Copyright (C) 2001 Oleh Yuschuk
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// 05.03.2002: Corrected error, FSTSW AX assembled with data size prefix

#define STRICT

#include "stdafx.h"

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
//#include <dir.h>
#include <math.h>
#include <float.h>
#pragma hdrstop

#pragma   warning(disable:4996)//購液症痕方蕗苧少御

#include "disasm.h"

const char *regname[3][9] = {
  { "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH", "R8"  },
  { "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI", "R16" },
  { "EAX","ECX","EDX","EBX","ESP","EBP","ESI","EDI","R32" } };

const char *segname[8] = {
  "ES","CS","SS","DS","FS","GS","SEG?","SEG?" };

const char *sizename[11] = {
  "(0-BYTE)", "BYTE", "WORD", "(3-BYTE)",
  "DWORD", "(5-BYTE)", "FWORD", "(7-BYTE)",
  "QWORD", "(9-BYTE)", "TBYTE" };

const t_addrdec addr16[8] = {
  { SEG_DS,"BX+SI" }, { SEG_DS,"BX+DI" },
  { SEG_SS,"BP+SI" }, { SEG_SS,"BP+DI" },
  { SEG_DS,"SI" },    { SEG_DS,"DI" },
  { SEG_SS,"BP" },    { SEG_DS,"BX" } };

const t_addrdec addr32[8] = {
  { SEG_DS,"EAX" }, { SEG_DS,"ECX" },
  { SEG_DS,"EDX" }, { SEG_DS,"EBX" },
  { SEG_SS,"" },    { SEG_SS,"EBP" },
  { SEG_DS,"ESI" }, { SEG_DS,"EDI" } };

const char *fpuname[9] = {
  "ST0","ST1","ST2","ST3","ST4","ST5","ST6","ST7","FPU" };

const char *mmxname[9] = {
  "MM0","MM1","MM2","MM3","MM4","MM5","MM6","MM7","MMX" };

const char *crname[9] = {
  "CR0","CR1","CR2","CR3","CR4","CR5","CR6","CR7","CRX" };

const char *drname[9] = {
  "DR0","DR1","DR2","DR3","DR4","DR5","DR6","DR7","DRX" };

// List of available processor commands with decoding, types of parameters and
// other useful information. Last element has field mask=0. If mnemonic begins
// with ampersand ('&'), its mnemonic decodes differently depending on operand
// size (16 or 32 bits). If mnemonic begins with dollar ('$'), this mnemonic
// depends on address size. Semicolon (':') separates 16-bit form from 32-bit,
// asterisk ('*') will be substituted by either W (16), D (32) or none (16/32)
// character. If command is of type C_MMX or C_NOW, or if type contains C_EXPL
// (=0x01), Disassembler must specify explicit size of memory operand.
const t_cmddata cmddata[] = {
  { 0x0000FF, 0x000090, 1,00,  NNN,NNN,NNN, C_CMD+0,        "NOP" },
  { 0x0000FE, 0x00008A, 1,WW,  REG,MRG,NNN, C_CMD+0,        "MOV" },
  { 0x0000F8, 0x000050, 1,00,  RCM,NNN,NNN, C_PSH+0,        "PUSH" },
  { 0x0000FE, 0x000088, 1,WW,  MRG,REG,NNN, C_CMD+0,        "MOV" },
  { 0x0000FF, 0x0000E8, 1,00,  JOW,NNN,NNN, C_CAL+0,        "CALL" },
  { 0x0000FD, 0x000068, 1,SS,  IMM,NNN,NNN, C_PSH+0,        "PUSH" },
  { 0x0000FF, 0x00008D, 1,00,  REG,MMA,NNN, C_CMD+0,        "LEA" },
  { 0x0000FF, 0x000074, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JE,JZ" },
  { 0x0000F8, 0x000058, 1,00,  RCM,NNN,NNN, C_POP+0,        "POP" },
  { 0x0038FC, 0x000080, 1,WS,  MRG,IMM,NNN, C_CMD+1,        "ADD" },
  { 0x0000FF, 0x000075, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JNZ,JNE" },
  { 0x0000FF, 0x0000EB, 1,00,  JOB,NNN,NNN, C_JMP+0,        "JMP" },
  { 0x0000FF, 0x0000E9, 1,00,  JOW,NNN,NNN, C_JMP+0,        "JMP" },
  { 0x0000FE, 0x000084, 1,WW,  MRG,REG,NNN, C_CMD+0,        "TEST" },
  { 0x0038FE, 0x0000C6, 1,WW,  MRG,IMM,NNN, C_CMD+1,        "MOV" },
  { 0x0000FE, 0x000032, 1,WW,  REG,MRG,NNN, C_CMD+0,        "XOR" },
  { 0x0000FE, 0x00003A, 1,WW,  REG,MRG,NNN, C_CMD+0,        "CMP" },
  { 0x0038FC, 0x003880, 1,WS,  MRG,IMM,NNN, C_CMD+1,        "CMP" },
  { 0x0038FF, 0x0010FF, 1,00,  MRJ,NNN,NNN, C_CAL+0,        "CALL" },
  { 0x0000FF, 0x0000C3, 1,00,  PRN,NNN,NNN, C_RET+0,        "RETN,RET" },
  { 0x0000F0, 0x0000B0, 1,W3,  RCM,IMM,NNN, C_CMD+0,        "MOV" },
  { 0x0000FE, 0x0000A0, 1,WW,  RAC,IMA,NNN, C_CMD+0,        "MOV" },
  { 0x00FFFF, 0x00840F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JE,JZ" },
  { 0x0000F8, 0x000040, 1,00,  RCM,NNN,NNN, C_CMD+0,        "INC" },
  { 0x0038FE, 0x0000F6, 1,WW,  MRG,IMU,NNN, C_CMD+1,        "TEST" },
  { 0x0000FE, 0x0000A2, 1,WW,  IMA,RAC,NNN, C_CMD+0,        "MOV" },
  { 0x0000FE, 0x00002A, 1,WW,  REG,MRG,NNN, C_CMD+0,        "SUB" },
  { 0x0000FF, 0x00007E, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JLE,JNG" },
  { 0x00FFFF, 0x00850F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JNZ,JNE" },
  { 0x0000FF, 0x0000C2, 1,00,  IM2,PRN,NNN, C_RET+0,        "RETN" },
  { 0x0038FF, 0x0030FF, 1,00,  MRG,NNN,NNN, C_PSH+1,        "PUSH" },
  { 0x0038FC, 0x000880, 1,WS,  MRG,IMU,NNN, C_CMD+1,        "OR" },
  { 0x0038FC, 0x002880, 1,WS,  MRG,IMM,NNN, C_CMD+1,        "SUB" },
  { 0x0000F8, 0x000048, 1,00,  RCM,NNN,NNN, C_CMD+0,        "DEC" },
  { 0x00FFFF, 0x00BF0F, 2,00,  REG,MR2,NNN, C_CMD+1,        "MOVSX" },
  { 0x0000FF, 0x00007C, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JL,JNGE" },
  { 0x0000FE, 0x000002, 1,WW,  REG,MRG,NNN, C_CMD+0,        "ADD" },
  { 0x0038FC, 0x002080, 1,WS,  MRG,IMU,NNN, C_CMD+1,        "AND" },
  { 0x0000FE, 0x00003C, 1,WW,  RAC,IMM,NNN, C_CMD+0,        "CMP" },
  { 0x0038FF, 0x0020FF, 1,00,  MRJ,NNN,NNN, C_JMP+0,        "JMP" },
  { 0x0038FE, 0x0010F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "NOT" },
  { 0x0038FE, 0x0028C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "SHR" },
  { 0x0000FE, 0x000038, 1,WW,  MRG,REG,NNN, C_CMD+0,        "CMP" },
  { 0x0000FF, 0x00007D, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JGE,JNL" },
  { 0x0000FF, 0x00007F, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JG,JNLE" },
  { 0x0038FE, 0x0020C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "SHL" },
  { 0x0000FE, 0x00001A, 1,WW,  REG,MRG,NNN, C_CMD+0,        "SBB" },
  { 0x0038FE, 0x0018F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "NEG" },
  { 0x0000FF, 0x0000C9, 1,00,  NNN,NNN,NNN, C_CMD+0,        "LEAVE" },
  { 0x0000FF, 0x000060, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "&PUSHA*" },
  { 0x0038FF, 0x00008F, 1,00,  MRG,NNN,NNN, C_POP+1,        "POP" },
  { 0x0000FF, 0x000061, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "&POPA*" },
  { 0x0000F8, 0x000090, 1,00,  RAC,RCM,NNN, C_CMD+0,        "XCHG" },
  { 0x0000FE, 0x000086, 1,WW,  MRG,REG,NNN, C_CMD+0,        "XCHG" },
  { 0x0000FE, 0x000000, 1,WW,  MRG,REG,NNN, C_CMD+0,        "ADD" },
  { 0x0000FE, 0x000010, 1,WW,  MRG,REG,NNN, C_CMD+C_RARE+0, "ADC" },
  { 0x0000FE, 0x000012, 1,WW,  REG,MRG,NNN, C_CMD+C_RARE+0, "ADC" },
  { 0x0000FE, 0x000020, 1,WW,  MRG,REG,NNN, C_CMD+0,        "AND" },
  { 0x0000FE, 0x000022, 1,WW,  REG,MRG,NNN, C_CMD+0,        "AND" },
  { 0x0000FE, 0x000008, 1,WW,  MRG,REG,NNN, C_CMD+0,        "OR" },
  { 0x0000FE, 0x00000A, 1,WW,  REG,MRG,NNN, C_CMD+0,        "OR" },
  { 0x0000FE, 0x000028, 1,WW,  MRG,REG,NNN, C_CMD+0,        "SUB" },
  { 0x0000FE, 0x000018, 1,WW,  MRG,REG,NNN, C_CMD+C_RARE+0, "SBB" },
  { 0x0000FE, 0x000030, 1,WW,  MRG,REG,NNN, C_CMD+0,        "XOR" },
  { 0x0038FC, 0x001080, 1,WS,  MRG,IMM,NNN, C_CMD+C_RARE+1, "ADC" },
  { 0x0038FC, 0x001880, 1,WS,  MRG,IMM,NNN, C_CMD+C_RARE+1, "SBB" },
  { 0x0038FC, 0x003080, 1,WS,  MRG,IMU,NNN, C_CMD+1,        "XOR" },
  { 0x0000FE, 0x000004, 1,WW,  RAC,IMM,NNN, C_CMD+0,        "ADD" },
  { 0x0000FE, 0x000014, 1,WW,  RAC,IMM,NNN, C_CMD+C_RARE+0, "ADC" },
  { 0x0000FE, 0x000024, 1,WW,  RAC,IMU,NNN, C_CMD+0,        "AND" },
  { 0x0000FE, 0x00000C, 1,WW,  RAC,IMU,NNN, C_CMD+0,        "OR" },
  { 0x0000FE, 0x00002C, 1,WW,  RAC,IMM,NNN, C_CMD+0,        "SUB" },
  { 0x0000FE, 0x00001C, 1,WW,  RAC,IMM,NNN, C_CMD+C_RARE+0, "SBB" },
  { 0x0000FE, 0x000034, 1,WW,  RAC,IMU,NNN, C_CMD+0,        "XOR" },
  { 0x0038FE, 0x0000FE, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "INC" },
  { 0x0038FE, 0x0008FE, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "DEC" },
  { 0x0000FE, 0x0000A8, 1,WW,  RAC,IMU,NNN, C_CMD+0,        "TEST" },
  { 0x0038FE, 0x0020F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "MUL" },
  { 0x0038FE, 0x0028F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "IMUL" },
  { 0x00FFFF, 0x00AF0F, 2,00,  REG,MRG,NNN, C_CMD+0,        "IMUL" },
  { 0x0000FF, 0x00006B, 1,00,  REG,MRG,IMX, C_CMD+C_RARE+0, "IMUL" },
  { 0x0000FF, 0x000069, 1,00,  REG,MRG,IMM, C_CMD+C_RARE+0, "IMUL" },
  { 0x0038FE, 0x0030F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "DIV" },
  { 0x0038FE, 0x0038F6, 1,WW,  MRG,NNN,NNN, C_CMD+1,        "IDIV" },
  { 0x0000FF, 0x000098, 1,00,  NNN,NNN,NNN, C_CMD+0,        "&CBW:CWDE" },
  { 0x0000FF, 0x000099, 1,00,  NNN,NNN,NNN, C_CMD+0,        "&CWD:CDQ" },
  { 0x0038FE, 0x0000D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "ROL" },
  { 0x0038FE, 0x0008D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "ROR" },
  { 0x0038FE, 0x0010D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "RCL" },
  { 0x0038FE, 0x0018D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "RCR" },
  { 0x0038FE, 0x0020D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "SHL" },
  { 0x0038FE, 0x0028D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "SHR" },
  { 0x0038FE, 0x0038D0, 1,WW,  MRG,C01,NNN, C_CMD+1,        "SAR" },
  { 0x0038FE, 0x0000D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "ROL" },
  { 0x0038FE, 0x0008D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "ROR" },
  { 0x0038FE, 0x0010D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "RCL" },
  { 0x0038FE, 0x0018D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "RCR" },
  { 0x0038FE, 0x0020D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "SHL" },
  { 0x0038FE, 0x0028D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "SHR" },
  { 0x0038FE, 0x0038D2, 1,WW,  MRG,RCL,NNN, C_CMD+1,        "SAR" },
  { 0x0038FE, 0x0000C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "ROL" },
  { 0x0038FE, 0x0008C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "ROR" },
  { 0x0038FE, 0x0010C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "RCL" },
  { 0x0038FE, 0x0018C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "RCR" },
  { 0x0038FE, 0x0038C0, 1,WW,  MRG,IMS,NNN, C_CMD+1,        "SAR" },
  { 0x0000FF, 0x000070, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JO" },
  { 0x0000FF, 0x000071, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JNO" },
  { 0x0000FF, 0x000072, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JB,JC" },
  { 0x0000FF, 0x000073, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JNB,JNC" },
  { 0x0000FF, 0x000076, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JBE,JNA" },
  { 0x0000FF, 0x000077, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JA,JNBE" },
  { 0x0000FF, 0x000078, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JS" },
  { 0x0000FF, 0x000079, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JNS" },
  { 0x0000FF, 0x00007A, 1,CC,  JOB,NNN,NNN, C_JMC+C_RARE+0, "JPE,JP" },
  { 0x0000FF, 0x00007B, 1,CC,  JOB,NNN,NNN, C_JMC+C_RARE+0, "JPO,JNP" },
  { 0x0000FF, 0x0000E3, 1,00,  JOB,NNN,NNN, C_JMC+C_RARE+0, "$JCXZ:JECXZ" },
  { 0x00FFFF, 0x00800F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JO" },
  { 0x00FFFF, 0x00810F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JNO" },
  { 0x00FFFF, 0x00820F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JB,JC" },
  { 0x00FFFF, 0x00830F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JNB,JNC" },
  { 0x00FFFF, 0x00860F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JBE,JNA" },
  { 0x00FFFF, 0x00870F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JA,JNBE" },
  { 0x00FFFF, 0x00880F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JS" },
  { 0x00FFFF, 0x00890F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JNS" },
  { 0x00FFFF, 0x008A0F, 2,CC,  JOW,NNN,NNN, C_JMC+C_RARE+0, "JPE,JP" },
  { 0x00FFFF, 0x008B0F, 2,CC,  JOW,NNN,NNN, C_JMC+C_RARE+0, "JPO,JNP" },
  { 0x00FFFF, 0x008C0F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JL,JNGE" },
  { 0x00FFFF, 0x008D0F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JGE,JNL" },
  { 0x00FFFF, 0x008E0F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JLE,JNG" },
  { 0x00FFFF, 0x008F0F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JG,JNLE" },
  { 0x0000FF, 0x0000F8, 1,00,  NNN,NNN,NNN, C_CMD+0,        "CLC" },
  { 0x0000FF, 0x0000F9, 1,00,  NNN,NNN,NNN, C_CMD+0,        "STC" },
  { 0x0000FF, 0x0000F5, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "CMC" },
  { 0x0000FF, 0x0000FC, 1,00,  NNN,NNN,NNN, C_CMD+0,        "CLD" },
  { 0x0000FF, 0x0000FD, 1,00,  NNN,NNN,NNN, C_CMD+0,        "STD" },
  { 0x0000FF, 0x0000FA, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "CLI" },
  { 0x0000FF, 0x0000FB, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "STI" },
  { 0x0000FF, 0x00008C, 1,FF,  MRG,SGM,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0x0000FF, 0x00008E, 1,FF,  SGM,MRG,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0x0000FE, 0x0000A6, 1,WW,  MSO,MDE,NNN, C_CMD+1,        "CMPS" },
  { 0x0000FE, 0x0000AC, 1,WW,  MSO,NNN,NNN, C_CMD+1,        "LODS" },
  { 0x0000FE, 0x0000A4, 1,WW,  MDE,MSO,NNN, C_CMD+1,        "MOVS" },
  { 0x0000FE, 0x0000AE, 1,WW,  MDE,PAC,NNN, C_CMD+1,        "SCAS" },
  { 0x0000FE, 0x0000AA, 1,WW,  MDE,PAC,NNN, C_CMD+1,        "STOS" },
  { 0x00FEFF, 0x00A4F3, 1,WW,  MDE,MSO,PCX, C_REP+1,        "REP MOVS" },
  { 0x00FEFF, 0x00ACF3, 1,WW,  MSO,PAC,PCX, C_REP+C_RARE+1, "REP LODS" },
  { 0x00FEFF, 0x00AAF3, 1,WW,  MDE,PAC,PCX, C_REP+1,        "REP STOS" },
  { 0x00FEFF, 0x00A6F3, 1,WW,  MDE,MSO,PCX, C_REP+1,        "REPE CMPS" },
  { 0x00FEFF, 0x00AEF3, 1,WW,  MDE,PAC,PCX, C_REP+1,        "REPE SCAS" },
  { 0x00FEFF, 0x00A6F2, 1,WW,  MDE,MSO,PCX, C_REP+1,        "REPNE CMPS" },
  { 0x00FEFF, 0x00AEF2, 1,WW,  MDE,PAC,PCX, C_REP+1,        "REPNE SCAS" },
  { 0x0000FF, 0x0000EA, 1,00,  JMF,NNN,NNN, C_JMP+C_RARE+0, "JMP" },
  { 0x0038FF, 0x0028FF, 1,00,  MMS,NNN,NNN, C_JMP+C_RARE+1, "JMP" },
  { 0x0000FF, 0x00009A, 1,00,  JMF,NNN,NNN, C_CAL+C_RARE+0, "CALL" },
  { 0x0038FF, 0x0018FF, 1,00,  MMS,NNN,NNN, C_CAL+C_RARE+1, "CALL" },
  { 0x0000FF, 0x0000CB, 1,00,  PRF,NNN,NNN, C_RET+C_RARE+0, "RETF" },
  { 0x0000FF, 0x0000CA, 1,00,  IM2,PRF,NNN, C_RET+C_RARE+0, "RETF" },
  { 0x00FFFF, 0x00A40F, 2,00,  MRG,REG,IMS, C_CMD+0,        "SHLD" },
  { 0x00FFFF, 0x00AC0F, 2,00,  MRG,REG,IMS, C_CMD+0,        "SHRD" },
  { 0x00FFFF, 0x00A50F, 2,00,  MRG,REG,RCL, C_CMD+0,        "SHLD" },
  { 0x00FFFF, 0x00AD0F, 2,00,  MRG,REG,RCL, C_CMD+0,        "SHRD" },
  { 0x00F8FF, 0x00C80F, 2,00,  RCM,NNN,NNN, C_CMD+C_RARE+0, "BSWAP" },
  { 0x00FEFF, 0x00C00F, 2,WW,  MRG,REG,NNN, C_CMD+C_RARE+0, "XADD" },
  { 0x0000FF, 0x0000E2, 1,LL,  JOB,PCX,NNN, C_JMC+0,        "$LOOP*" },
  { 0x0000FF, 0x0000E1, 1,LL,  JOB,PCX,NNN, C_JMC+0,        "$LOOP*E" },
  { 0x0000FF, 0x0000E0, 1,LL,  JOB,PCX,NNN, C_JMC+0,        "$LOOP*NE" },
  { 0x0000FF, 0x0000C8, 1,00,  IM2,IM1,NNN, C_CMD+0,        "ENTER" },
  { 0x0000FE, 0x0000E4, 1,WP,  RAC,IM1,NNN, C_CMD+C_RARE+0, "IN" },
  { 0x0000FE, 0x0000EC, 1,WP,  RAC,RDX,NNN, C_CMD+C_RARE+0, "IN" },
  { 0x0000FE, 0x0000E6, 1,WP,  IM1,RAC,NNN, C_CMD+C_RARE+0, "OUT" },
  { 0x0000FE, 0x0000EE, 1,WP,  RDX,RAC,NNN, C_CMD+C_RARE+0, "OUT" },
  { 0x0000FE, 0x00006C, 1,WP,  MDE,RDX,NNN, C_CMD+C_RARE+1, "INS" },
  { 0x0000FE, 0x00006E, 1,WP,  RDX,MDE,NNN, C_CMD+C_RARE+1, "OUTS" },
  { 0x00FEFF, 0x006CF3, 1,WP,  MDE,RDX,PCX, C_REP+C_RARE+1, "REP INS" },
  { 0x00FEFF, 0x006EF3, 1,WP,  RDX,MDE,PCX, C_REP+C_RARE+1, "REP OUTS" },
  { 0x0000FF, 0x000037, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "AAA" },
  { 0x0000FF, 0x00003F, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "AAS" },
  { 0x00FFFF, 0x000AD4, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "AAM" },
  { 0x0000FF, 0x0000D4, 1,00,  IM1,NNN,NNN, C_CMD+C_RARE+0, "AAM" },
  { 0x00FFFF, 0x000AD5, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "AAD" },
  { 0x0000FF, 0x0000D5, 1,00,  IM1,NNN,NNN, C_CMD+C_RARE+0, "AAD" },
  { 0x0000FF, 0x000027, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "DAA" },
  { 0x0000FF, 0x00002F, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "DAS" },
  { 0x0000FF, 0x0000F4, 1,PR,  NNN,NNN,NNN, C_PRI+C_RARE+0, "HLT" },
  { 0x0000FF, 0x00000E, 1,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x0000FF, 0x000016, 1,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x0000FF, 0x00001E, 1,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x0000FF, 0x000006, 1,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x00FFFF, 0x00A00F, 2,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x00FFFF, 0x00A80F, 2,00,  SCM,NNN,NNN, C_PSH+C_RARE+0, "PUSH" },
  { 0x0000FF, 0x00001F, 1,00,  SCM,NNN,NNN, C_POP+C_RARE+0, "POP" },
  { 0x0000FF, 0x000007, 1,00,  SCM,NNN,NNN, C_POP+C_RARE+0, "POP" },
  { 0x0000FF, 0x000017, 1,00,  SCM,NNN,NNN, C_POP+C_RARE+0, "POP" },
  { 0x00FFFF, 0x00A10F, 2,00,  SCM,NNN,NNN, C_POP+C_RARE+0, "POP" },
  { 0x00FFFF, 0x00A90F, 2,00,  SCM,NNN,NNN, C_POP+C_RARE+0, "POP" },
  { 0x0000FF, 0x0000D7, 1,00,  MXL,NNN,NNN, C_CMD+C_RARE+1, "XLAT" },
  { 0x00FFFF, 0x00BE0F, 2,00,  REG,MR1,NNN, C_CMD+1,        "MOVSX" },
  { 0x00FFFF, 0x00B60F, 2,00,  REG,MR1,NNN, C_CMD+1,        "MOVZX" },
  { 0x00FFFF, 0x00B70F, 2,00,  REG,MR2,NNN, C_CMD+1,        "MOVZX" },
  { 0x0000FF, 0x00009B, 1,00,  NNN,NNN,NNN, C_CMD+0,        "WAIT" },
  { 0x0000FF, 0x00009F, 1,00,  PAH,PFL,NNN, C_CMD+C_RARE+0, "LAHF" },
  { 0x0000FF, 0x00009E, 1,00,  PFL,PAH,NNN, C_CMD+C_RARE+0, "SAHF" },
  { 0x0000FF, 0x00009C, 1,00,  NNN,NNN,NNN, C_PSH+0,        "&PUSHF*" },
  { 0x0000FF, 0x00009D, 1,00,  NNN,NNN,NNN, C_FLG+0,        "&POPF*" },
  { 0x0000FF, 0x0000CD, 1,00,  IM1,NNN,NNN, C_CAL+C_RARE+0, "INT" },
  { 0x0000FF, 0x0000CC, 1,00,  NNN,NNN,NNN, C_CAL+C_RARE+0, "INT3" },
  { 0x0000FF, 0x0000CE, 1,00,  NNN,NNN,NNN, C_CAL+C_RARE+0, "INTO" },
  { 0x0000FF, 0x0000CF, 1,00,  NNN,NNN,NNN, C_RTF+C_RARE+0, "&IRET*" },
  { 0x00FFFF, 0x00900F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETO" },
  { 0x00FFFF, 0x00910F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETNO" },
  { 0x00FFFF, 0x00920F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETB,SETC" },
  { 0x00FFFF, 0x00930F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETNB,SETNC" },
  { 0x00FFFF, 0x00940F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETE,SETZ" },
  { 0x00FFFF, 0x00950F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETNE,SETNZ" },
  { 0x00FFFF, 0x00960F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETBE,SETNA" },
  { 0x00FFFF, 0x00970F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETA,SETNBE" },
  { 0x00FFFF, 0x00980F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETS" },
  { 0x00FFFF, 0x00990F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETNS" },
  { 0x00FFFF, 0x009A0F, 2,CC,  MR1,NNN,NNN, C_CMD+C_RARE+0, "SETPE,SETP" },
  { 0x00FFFF, 0x009B0F, 2,CC,  MR1,NNN,NNN, C_CMD+C_RARE+0, "SETPO,SETNP" },
  { 0x00FFFF, 0x009C0F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETL,SETNGE" },
  { 0x00FFFF, 0x009D0F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETGE,SETNL" },
  { 0x00FFFF, 0x009E0F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETLE,SETNG" },
  { 0x00FFFF, 0x009F0F, 2,CC,  MR1,NNN,NNN, C_CMD+0,        "SETG,SETNLE" },
  { 0x38FFFF, 0x20BA0F, 2,00,  MRG,IM1,NNN, C_CMD+C_RARE+1, "BT" },
  { 0x38FFFF, 0x28BA0F, 2,00,  MRG,IM1,NNN, C_CMD+C_RARE+1, "BTS" },
  { 0x38FFFF, 0x30BA0F, 2,00,  MRG,IM1,NNN, C_CMD+C_RARE+1, "BTR" },
  { 0x38FFFF, 0x38BA0F, 2,00,  MRG,IM1,NNN, C_CMD+C_RARE+1, "BTC" },
  { 0x00FFFF, 0x00A30F, 2,00,  MRG,REG,NNN, C_CMD+C_RARE+1, "BT" },
  { 0x00FFFF, 0x00AB0F, 2,00,  MRG,REG,NNN, C_CMD+C_RARE+1, "BTS" },
  { 0x00FFFF, 0x00B30F, 2,00,  MRG,REG,NNN, C_CMD+C_RARE+1, "BTR" },
  { 0x00FFFF, 0x00BB0F, 2,00,  MRG,REG,NNN, C_CMD+C_RARE+1, "BTC" },
  { 0x0000FF, 0x0000C5, 1,00,  REG,MML,NNN, C_CMD+C_RARE+0, "LDS" },
  { 0x0000FF, 0x0000C4, 1,00,  REG,MML,NNN, C_CMD+C_RARE+0, "LES" },
  { 0x00FFFF, 0x00B40F, 2,00,  REG,MML,NNN, C_CMD+C_RARE+0, "LFS" },
  { 0x00FFFF, 0x00B50F, 2,00,  REG,MML,NNN, C_CMD+C_RARE+0, "LGS" },
  { 0x00FFFF, 0x00B20F, 2,00,  REG,MML,NNN, C_CMD+C_RARE+0, "LSS" },
  { 0x0000FF, 0x000063, 1,00,  MRG,REG,NNN, C_CMD+C_RARE+0, "ARPL" },
  { 0x0000FF, 0x000062, 1,00,  REG,MMB,NNN, C_CMD+C_RARE+0, "BOUND" },
  { 0x00FFFF, 0x00BC0F, 2,00,  REG,MRG,NNN, C_CMD+C_RARE+0, "BSF" },
  { 0x00FFFF, 0x00BD0F, 2,00,  REG,MRG,NNN, C_CMD+C_RARE+0, "BSR" },
  { 0x00FFFF, 0x00060F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "CLTS" },
  { 0x00FFFF, 0x00400F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVO" },
  { 0x00FFFF, 0x00410F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVNO" },
  { 0x00FFFF, 0x00420F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVB,CMOVC" },
  { 0x00FFFF, 0x00430F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVNB,CMOVNC" },
  { 0x00FFFF, 0x00440F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVE,CMOVZ" },
  { 0x00FFFF, 0x00450F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVNE,CMOVNZ" },
  { 0x00FFFF, 0x00460F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVBE,CMOVNA" },
  { 0x00FFFF, 0x00470F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVA,CMOVNBE" },
  { 0x00FFFF, 0x00480F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVS" },
  { 0x00FFFF, 0x00490F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVNS" },
  { 0x00FFFF, 0x004A0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVPE,CMOVP" },
  { 0x00FFFF, 0x004B0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVPO,CMOVNP" },
  { 0x00FFFF, 0x004C0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVL,CMOVNGE" },
  { 0x00FFFF, 0x004D0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVGE,CMOVNL" },
  { 0x00FFFF, 0x004E0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVLE,CMOVNG" },
  { 0x00FFFF, 0x004F0F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVG,CMOVNLE" },
  { 0x00FEFF, 0x00B00F, 2,WW,  MRG,REG,NNN, C_CMD+C_RARE+0, "CMPXCHG" },
  { 0x38FFFF, 0x08C70F, 2,00,  MD8,NNN,NNN, C_CMD+C_RARE+1, "CMPXCHG8B" },
  { 0x00FFFF, 0x00A20F, 2,00,  NNN,NNN,NNN, C_CMD+0,        "CPUID" },
  { 0x00FFFF, 0x00080F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "INVD" },
  { 0x00FFFF, 0x00020F, 2,00,  REG,MRG,NNN, C_CMD+C_RARE+0, "LAR" },
  { 0x00FFFF, 0x00030F, 2,00,  REG,MRG,NNN, C_CMD+C_RARE+0, "LSL" },
  { 0x38FFFF, 0x38010F, 2,PR,  MR1,NNN,NNN, C_CMD+C_RARE+0, "INVLPG" },
  { 0x00FFFF, 0x00090F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "WBINVD" },
  { 0x38FFFF, 0x10010F, 2,PR,  MM6,NNN,NNN, C_CMD+C_RARE+0, "LGDT" },
  { 0x38FFFF, 0x00010F, 2,00,  MM6,NNN,NNN, C_CMD+C_RARE+0, "SGDT" },
  { 0x38FFFF, 0x18010F, 2,PR,  MM6,NNN,NNN, C_CMD+C_RARE+0, "LIDT" },
  { 0x38FFFF, 0x08010F, 2,00,  MM6,NNN,NNN, C_CMD+C_RARE+0, "SIDT" },
  { 0x38FFFF, 0x10000F, 2,PR,  MR2,NNN,NNN, C_CMD+C_RARE+0, "LLDT" },
  { 0x38FFFF, 0x00000F, 2,00,  MR2,NNN,NNN, C_CMD+C_RARE+0, "SLDT" },
  { 0x38FFFF, 0x18000F, 2,PR,  MR2,NNN,NNN, C_CMD+C_RARE+0, "LTR" },
  { 0x38FFFF, 0x08000F, 2,00,  MR2,NNN,NNN, C_CMD+C_RARE+0, "STR" },
  { 0x38FFFF, 0x30010F, 2,PR,  MR2,NNN,NNN, C_CMD+C_RARE+0, "LMSW" },
  { 0x38FFFF, 0x20010F, 2,00,  MR2,NNN,NNN, C_CMD+C_RARE+0, "SMSW" },
  { 0x38FFFF, 0x20000F, 2,00,  MR2,NNN,NNN, C_CMD+C_RARE+0, "VERR" },
  { 0x38FFFF, 0x28000F, 2,00,  MR2,NNN,NNN, C_CMD+C_RARE+0, "VERW" },
  { 0xC0FFFF, 0xC0220F, 2,PR,  CRX,RR4,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0xC0FFFF, 0xC0200F, 2,00,  RR4,CRX,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0xC0FFFF, 0xC0230F, 2,PR,  DRX,RR4,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0xC0FFFF, 0xC0210F, 2,PR,  RR4,DRX,NNN, C_CMD+C_RARE+0, "MOV" },
  { 0x00FFFF, 0x00310F, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "RDTSC" },
  { 0x00FFFF, 0x00320F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "RDMSR" },
  { 0x00FFFF, 0x00300F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "WRMSR" },
  { 0x00FFFF, 0x00330F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "RDPMC" },
  { 0x00FFFF, 0x00AA0F, 2,PR,  NNN,NNN,NNN, C_RTF+C_RARE+0, "RSM" },
  { 0x00FFFF, 0x000B0F, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "UD2" },
  { 0x00FFFF, 0x00340F, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "SYSENTER" },
  { 0x00FFFF, 0x00350F, 2,PR,  NNN,NNN,NNN, C_CMD+C_RARE+0, "SYSEXIT" },
  { 0x0000FF, 0x0000D6, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "SALC" },
  // FPU instructions. Never change the order of instructions!
  { 0x00FFFF, 0x00F0D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "F2XM1" },
  { 0x00FFFF, 0x00E0D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FCHS" },
  { 0x00FFFF, 0x00E1D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FABS" },
  { 0x00FFFF, 0x00E2DB, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FCLEX" },
  { 0x00FFFF, 0x00E3DB, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FINIT" },
  { 0x00FFFF, 0x00F6D9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FDECSTP" },
  { 0x00FFFF, 0x00F7D9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FINCSTP" },
  { 0x00FFFF, 0x00E4D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FTST" },
  { 0x00FFFF, 0x00FAD9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FSQRT" },
  { 0x00FFFF, 0x00FED9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FSIN" },
  { 0x00FFFF, 0x00FFD9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FCOS" },
  { 0x00FFFF, 0x00FBD9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FSINCOS" },
  { 0x00FFFF, 0x00F2D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FPTAN" },
  { 0x00FFFF, 0x00F3D9, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FPATAN" },
  { 0x00FFFF, 0x00F8D9, 2,00,  PS1,PS0,NNN, C_FLT+0,        "FPREM" },
  { 0x00FFFF, 0x00F5D9, 2,00,  PS1,PS0,NNN, C_FLT+0,        "FPREM1" },
  { 0x00FFFF, 0x00F1D9, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FYL2X" },
  { 0x00FFFF, 0x00F9D9, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FYL2XP1" },
  { 0x00FFFF, 0x00FCD9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FRNDINT" },
  { 0x00FFFF, 0x00E8D9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLD1" },
  { 0x00FFFF, 0x00E9D9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDL2T" },
  { 0x00FFFF, 0x00EAD9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDL2E" },
  { 0x00FFFF, 0x00EBD9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDPI" },
  { 0x00FFFF, 0x00ECD9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDLG2" },
  { 0x00FFFF, 0x00EDD9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDLN2" },
  { 0x00FFFF, 0x00EED9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FLDZ" },
  { 0x00FFFF, 0x00FDD9, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FSCALE" },
  { 0x00FFFF, 0x00D0D9, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FNOP" },
  { 0x00FFFF, 0x00E0DF, 2,FF,  RAX,NNN,NNN, C_FLT+0,        "FSTSW" },
  { 0x00FFFF, 0x00E5D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FXAM" },
  { 0x00FFFF, 0x00F4D9, 2,00,  PS0,NNN,NNN, C_FLT+0,        "FXTRACT" },
  { 0x00FFFF, 0x00D9DE, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FCOMPP" },
  { 0x00FFFF, 0x00E9DA, 2,00,  PS0,PS1,NNN, C_FLT+0,        "FUCOMPP" },
  { 0x00F8FF, 0x00C0DD, 2,00,  RST,NNN,NNN, C_FLT+0,        "FFREE" },
  { 0x00F8FF, 0x00C0DA, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVB" },
  { 0x00F8FF, 0x00C8DA, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVE" },
  { 0x00F8FF, 0x00D0DA, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVBE" },
  { 0x00F8FF, 0x00D8DA, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVU" },
  { 0x00F8FF, 0x00C0DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVNB" },
  { 0x00F8FF, 0x00C8DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVNE" },
  { 0x00F8FF, 0x00D0DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVNBE" },
  { 0x00F8FF, 0x00D8DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCMOVNU" },
  { 0x00F8FF, 0x00F0DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCOMI" },
  { 0x00F8FF, 0x00F0DF, 2,00,  RS0,RST,NNN, C_FLT+0,        "FCOMIP" },
  { 0x00F8FF, 0x00E8DB, 2,00,  RS0,RST,NNN, C_FLT+0,        "FUCOMI" },
  { 0x00F8FF, 0x00E8DF, 2,00,  RS0,RST,NNN, C_FLT+0,        "FUCOMIP" },
  { 0x00F8FF, 0x00C0D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FADD" },
  { 0x00F8FF, 0x00C0DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FADD" },
  { 0x00F8FF, 0x00C0DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FADDP" },
  { 0x00F8FF, 0x00E0D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FSUB" },
  { 0x00F8FF, 0x00E8DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FSUB" },
  { 0x00F8FF, 0x00E8DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FSUBP" },
  { 0x00F8FF, 0x00E8D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FSUBR" },
  { 0x00F8FF, 0x00E0DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FSUBR" },
  { 0x00F8FF, 0x00E0DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FSUBRP" },
  { 0x00F8FF, 0x00C8D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FMUL" },
  { 0x00F8FF, 0x00C8DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FMUL" },
  { 0x00F8FF, 0x00C8DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FMULP" },
  { 0x00F8FF, 0x00D0D8, 2,00,  RST,PS0,NNN, C_FLT+0,        "FCOM" },
  { 0x00F8FF, 0x00D8D8, 2,00,  RST,PS0,NNN, C_FLT+0,        "FCOMP" },
  { 0x00F8FF, 0x00E0DD, 2,00,  RST,PS0,NNN, C_FLT+0,        "FUCOM" },
  { 0x00F8FF, 0x00E8DD, 2,00,  RST,PS0,NNN, C_FLT+0,        "FUCOMP" },
  { 0x00F8FF, 0x00F0D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FDIV" },
  { 0x00F8FF, 0x00F8DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FDIV" },
  { 0x00F8FF, 0x00F8DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FDIVP" },
  { 0x00F8FF, 0x00F8D8, 2,00,  RS0,RST,NNN, C_FLT+0,        "FDIVR" },
  { 0x00F8FF, 0x00F0DC, 2,00,  RST,RS0,NNN, C_FLT+0,        "FDIVR" },
  { 0x00F8FF, 0x00F0DE, 2,00,  RST,RS0,NNN, C_FLT+0,        "FDIVRP" },
  { 0x00F8FF, 0x00C0D9, 2,00,  RST,NNN,NNN, C_FLT+0,        "FLD" },
  { 0x00F8FF, 0x00D0DD, 2,00,  RST,PS0,NNN, C_FLT+0,        "FST" },
  { 0x00F8FF, 0x00D8DD, 2,00,  RST,PS0,NNN, C_FLT+0,        "FSTP" },
  { 0x00F8FF, 0x00C8D9, 2,00,  RST,PS0,NNN, C_FLT+0,        "FXCH" },
  { 0x0038FF, 0x0000D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FADD" },
  { 0x0038FF, 0x0000DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FADD" },
  { 0x0038FF, 0x0000DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FIADD" },
  { 0x0038FF, 0x0000DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FIADD" },
  { 0x0038FF, 0x0020D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FSUB" },
  { 0x0038FF, 0x0020DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FSUB" },
  { 0x0038FF, 0x0020DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FISUB" },
  { 0x0038FF, 0x0020DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FISUB" },
  { 0x0038FF, 0x0028D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FSUBR" },
  { 0x0038FF, 0x0028DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FSUBR" },
  { 0x0038FF, 0x0028DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FISUBR" },
  { 0x0038FF, 0x0028DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FISUBR" },
  { 0x0038FF, 0x0008D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FMUL" },
  { 0x0038FF, 0x0008DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FMUL" },
  { 0x0038FF, 0x0008DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FIMUL" },
  { 0x0038FF, 0x0008DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FIMUL" },
  { 0x0038FF, 0x0010D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FCOM" },
  { 0x0038FF, 0x0010DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FCOM" },
  { 0x0038FF, 0x0018D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FCOMP" },
  { 0x0038FF, 0x0018DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FCOMP" },
  { 0x0038FF, 0x0030D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FDIV" },
  { 0x0038FF, 0x0030DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FDIV" },
  { 0x0038FF, 0x0030DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FIDIV" },
  { 0x0038FF, 0x0030DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FIDIV" },
  { 0x0038FF, 0x0038D8, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FDIVR" },
  { 0x0038FF, 0x0038DC, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FDIVR" },
  { 0x0038FF, 0x0038DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FIDIVR" },
  { 0x0038FF, 0x0038DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FIDIVR" },
  { 0x0038FF, 0x0020DF, 1,00,  MDA,NNN,NNN, C_FLT+C_RARE+1, "FBLD" },
  { 0x0038FF, 0x0030DF, 1,00,  MDA,PS0,NNN, C_FLT+C_RARE+1, "FBSTP" },
  { 0x0038FF, 0x0010DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FICOM" },
  { 0x0038FF, 0x0010DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FICOM" },
  { 0x0038FF, 0x0018DE, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FICOMP" },
  { 0x0038FF, 0x0018DA, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FICOMP" },
  { 0x0038FF, 0x0000DF, 1,00,  MD2,NNN,NNN, C_FLT+1,        "FILD" },
  { 0x0038FF, 0x0000DB, 1,00,  MD4,NNN,NNN, C_FLT+1,        "FILD" },
  { 0x0038FF, 0x0028DF, 1,00,  MD8,NNN,NNN, C_FLT+1,        "FILD" },
  { 0x0038FF, 0x0010DF, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FIST" },
  { 0x0038FF, 0x0010DB, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FIST" },
  { 0x0038FF, 0x0018DF, 1,00,  MD2,PS0,NNN, C_FLT+1,        "FISTP" },
  { 0x0038FF, 0x0018DB, 1,00,  MD4,PS0,NNN, C_FLT+1,        "FISTP" },
  { 0x0038FF, 0x0038DF, 1,00,  MD8,PS0,NNN, C_FLT+1,        "FISTP" },
  { 0x0038FF, 0x0000D9, 1,00,  MF4,NNN,NNN, C_FLT+1,        "FLD" },
  { 0x0038FF, 0x0000DD, 1,00,  MF8,NNN,NNN, C_FLT+1,        "FLD" },
  { 0x0038FF, 0x0028DB, 1,00,  MFA,NNN,NNN, C_FLT+1,        "FLD" },
  { 0x0038FF, 0x0010D9, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FST" },
  { 0x0038FF, 0x0010DD, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FST" },
  { 0x0038FF, 0x0018D9, 1,00,  MF4,PS0,NNN, C_FLT+1,        "FSTP" },
  { 0x0038FF, 0x0018DD, 1,00,  MF8,PS0,NNN, C_FLT+1,        "FSTP" },
  { 0x0038FF, 0x0038DB, 1,00,  MFA,PS0,NNN, C_FLT+1,        "FSTP" },
  { 0x0038FF, 0x0028D9, 1,00,  MB2,NNN,NNN, C_FLT+0,        "FLDCW" },
  { 0x0038FF, 0x0038D9, 1,00,  MB2,NNN,NNN, C_FLT+0,        "FSTCW" },
  { 0x0038FF, 0x0020D9, 1,00,  MFE,NNN,NNN, C_FLT+0,        "FLDENV" },
  { 0x0038FF, 0x0030D9, 1,00,  MFE,NNN,NNN, C_FLT+0,        "FSTENV" },
  { 0x0038FF, 0x0020DD, 1,00,  MFS,NNN,NNN, C_FLT+0,        "FRSTOR" },
  { 0x0038FF, 0x0030DD, 1,00,  MFS,NNN,NNN, C_FLT+0,        "FSAVE" },
  { 0x0038FF, 0x0038DD, 1,00,  MB2,NNN,NNN, C_FLT+0,        "FSTSW" },
  { 0x38FFFF, 0x08AE0F, 2,00,  MFX,NNN,NNN, C_FLT+0,        "FXRSTOR" },
  { 0x38FFFF, 0x00AE0F, 2,00,  MFX,NNN,NNN, C_FLT+0,        "FXSAVE" },
  { 0x00FFFF, 0x00E0DB, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FENI" },
  { 0x00FFFF, 0x00E1DB, 2,00,  NNN,NNN,NNN, C_FLT+0,        "FDISI" },
  // MMX instructions. Length of MMX operand fields (in bytes) is added to the
  // type, length of 0 means 8-byte MMX operand.
  { 0x00FFFF, 0x00770F, 2,00,  NNN,NNN,NNN, C_MMX+0,        "EMMS" },
  { 0x00FFFF, 0x006E0F, 2,00,  RMX,MR4,NNN, C_MMX+0,        "MOVD" },
  { 0x00FFFF, 0x007E0F, 2,00,  MR4,RMX,NNN, C_MMX+0,        "MOVD" },
  { 0x00FFFF, 0x006F0F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "MOVQ" },
  { 0x00FFFF, 0x007F0F, 2,00,  MR8,RMX,NNN, C_MMX+0,        "MOVQ" },
  { 0x00FFFF, 0x00630F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PACKSSWB" },
  { 0x00FFFF, 0x006B0F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PACKSSDW" },
  { 0x00FFFF, 0x00670F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PACKUSWB" },
  { 0x00FFFF, 0x00FC0F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PADDB" },
  { 0x00FFFF, 0x00FD0F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PADDW" },
  { 0x00FFFF, 0x00FE0F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PADDD" },
  { 0x00FFFF, 0x00F80F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PSUBB" },
  { 0x00FFFF, 0x00F90F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSUBW" },
  { 0x00FFFF, 0x00FA0F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PSUBD" },
  { 0x00FFFF, 0x00EC0F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PADDSB" },
  { 0x00FFFF, 0x00ED0F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PADDSW" },
  { 0x00FFFF, 0x00E80F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PSUBSB" },
  { 0x00FFFF, 0x00E90F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSUBSW" },
  { 0x00FFFF, 0x00DC0F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PADDUSB" },
  { 0x00FFFF, 0x00DD0F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PADDUSW" },
  { 0x00FFFF, 0x00D80F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PSUBUSB" },
  { 0x00FFFF, 0x00D90F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSUBUSW" },
  { 0x00FFFF, 0x00DB0F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "PAND" },
  { 0x00FFFF, 0x00DF0F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "PANDN" },
  { 0x00FFFF, 0x00740F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PCMPEQB" },
  { 0x00FFFF, 0x00750F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PCMPEQW" },
  { 0x00FFFF, 0x00760F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PCMPEQD" },
  { 0x00FFFF, 0x00640F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PCMPGTB" },
  { 0x00FFFF, 0x00650F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PCMPGTW" },
  { 0x00FFFF, 0x00660F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PCMPGTD" },
  { 0x00FFFF, 0x00F50F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMADDWD" },
  { 0x00FFFF, 0x00E50F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMULHW" },
  { 0x00FFFF, 0x00D50F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMULLW" },
  { 0x00FFFF, 0x00EB0F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "POR" },
  { 0x00FFFF, 0x00F10F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSLLW" },
  { 0x38FFFF, 0x30710F, 2,00,  MR8,IM1,NNN, C_MMX+2,        "PSLLW" },
  { 0x00FFFF, 0x00F20F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PSLLD" },
  { 0x38FFFF, 0x30720F, 2,00,  MR8,IM1,NNN, C_MMX+4,        "PSLLD" },
  { 0x00FFFF, 0x00F30F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "PSLLQ" },
  { 0x38FFFF, 0x30730F, 2,00,  MR8,IM1,NNN, C_MMX+0,        "PSLLQ" },
  { 0x00FFFF, 0x00E10F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSRAW" },
  { 0x38FFFF, 0x20710F, 2,00,  MR8,IM1,NNN, C_MMX+2,        "PSRAW" },
  { 0x00FFFF, 0x00E20F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PSRAD" },
  { 0x38FFFF, 0x20720F, 2,00,  MR8,IM1,NNN, C_MMX+4,        "PSRAD" },
  { 0x00FFFF, 0x00D10F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PSRLW" },
  { 0x38FFFF, 0x10710F, 2,00,  MR8,IM1,NNN, C_MMX+2,        "PSRLW" },
  { 0x00FFFF, 0x00D20F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PSRLD" },
  { 0x38FFFF, 0x10720F, 2,00,  MR8,IM1,NNN, C_MMX+4,        "PSRLD" },
  { 0x00FFFF, 0x00D30F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "PSRLQ" },
  { 0x38FFFF, 0x10730F, 2,00,  MR8,IM1,NNN, C_MMX+0,        "PSRLQ" },
  { 0x00FFFF, 0x00680F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PUNPCKHBW" },
  { 0x00FFFF, 0x00690F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PUNPCKHWD" },
  { 0x00FFFF, 0x006A0F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PUNPCKHDQ" },
  { 0x00FFFF, 0x00600F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PUNPCKLBW" },
  { 0x00FFFF, 0x00610F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PUNPCKLWD" },
  { 0x00FFFF, 0x00620F, 2,00,  RMX,MR8,NNN, C_MMX+4,        "PUNPCKLDQ" },
  { 0x00FFFF, 0x00EF0F, 2,00,  RMX,MR8,NNN, C_MMX+0,        "PXOR" },
  // AMD extentions to MMX command set (including Athlon/PIII extentions).
  { 0x00FFFF, 0x000E0F, 2,00,  NNN,NNN,NNN, C_MMX+0,        "FEMMS" },
  { 0x38FFFF, 0x000D0F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCH" },
  { 0x38FFFF, 0x080D0F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCHW" },
  { 0x00FFFF, 0x00F70F, 2,00,  RMX,RR8,PDI, C_MMX+1,        "MASKMOVQ" },
  { 0x00FFFF, 0x00E70F, 2,00,  MD8,RMX,NNN, C_MMX+0,        "MOVNTQ" },
  { 0x00FFFF, 0x00E00F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PAVGB" },
  { 0x00FFFF, 0x00E30F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PAVGW" },
  { 0x00FFFF, 0x00C50F, 2,00,  RR4,RMX,IM1, C_MMX+2,        "PEXTRW" },
  { 0x00FFFF, 0x00C40F, 2,00,  RMX,MR2,IM1, C_MMX+2,        "PINSRW" },
  { 0x00FFFF, 0x00EE0F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMAXSW" },
  { 0x00FFFF, 0x00DE0F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PMAXUB" },
  { 0x00FFFF, 0x00EA0F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMINSW" },
  { 0x00FFFF, 0x00DA0F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PMINUB" },
  { 0x00FFFF, 0x00D70F, 2,00,  RG4,RR8,NNN, C_MMX+1,        "PMOVMSKB" },
  { 0x00FFFF, 0x00E40F, 2,00,  RMX,MR8,NNN, C_MMX+2,        "PMULHUW" },
  { 0x38FFFF, 0x00180F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCHNTA" },
  { 0x38FFFF, 0x08180F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCHT0" },
  { 0x38FFFF, 0x10180F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCHT1" },
  { 0x38FFFF, 0x18180F, 2,00,  MD8,NNN,NNN, C_MMX+0,        "PREFETCHT2" },
  { 0x00FFFF, 0x00F60F, 2,00,  RMX,MR8,NNN, C_MMX+1,        "PSADBW" },
  { 0x00FFFF, 0x00700F, 2,00,  RMX,MR8,IM1, C_MMX+2,        "PSHUFW" },
  { 0xFFFFFF, 0xF8AE0F, 2,00,  NNN,NNN,NNN, C_MMX+0,        "SFENCE" },
  // AMD 3DNow! instructions (including Athlon extentions).
  { 0x00FFFF, 0xBF0F0F, 2,00,  RMX,MR8,NNN, C_NOW+1,        "PAVGUSB" },
  { 0x00FFFF, 0x9E0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFADD" },
  { 0x00FFFF, 0x9A0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFSUB" },
  { 0x00FFFF, 0xAA0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFSUBR" },
  { 0x00FFFF, 0xAE0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFACC" },
  { 0x00FFFF, 0x900F0F, 2,00,  RMX,MRD,NNN, C_NOW+4,        "PFCMPGE" },
  { 0x00FFFF, 0xA00F0F, 2,00,  RMX,MRD,NNN, C_NOW+4,        "PFCMPGT" },
  { 0x00FFFF, 0xB00F0F, 2,00,  RMX,MRD,NNN, C_NOW+4,        "PFCMPEQ" },
  { 0x00FFFF, 0x940F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFMIN" },
  { 0x00FFFF, 0xA40F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFMAX" },
  { 0x00FFFF, 0x0D0F0F, 2,00,  R3D,MR8,NNN, C_NOW+4,        "PI2FD" },
  { 0x00FFFF, 0x1D0F0F, 2,00,  RMX,MRD,NNN, C_NOW+4,        "PF2ID" },
  { 0x00FFFF, 0x960F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFRCP" },
  { 0x00FFFF, 0x970F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFRSQRT" },
  { 0x00FFFF, 0xB40F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFMUL" },
  { 0x00FFFF, 0xA60F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFRCPIT1" },
  { 0x00FFFF, 0xA70F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFRSQIT1" },
  { 0x00FFFF, 0xB60F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFRCPIT2" },
  { 0x00FFFF, 0xB70F0F, 2,00,  RMX,MR8,NNN, C_NOW+2,        "PMULHRW" },
  { 0x00FFFF, 0x1C0F0F, 2,00,  RMX,MRD,NNN, C_NOW+4,        "PF2IW" },
  { 0x00FFFF, 0x8A0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFNACC" },
  { 0x00FFFF, 0x8E0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PFPNACC" },
  { 0x00FFFF, 0x0C0F0F, 2,00,  R3D,MR8,NNN, C_NOW+4,        "PI2FW" },
  { 0x00FFFF, 0xBB0F0F, 2,00,  R3D,MRD,NNN, C_NOW+4,        "PSWAPD" },
  // Some alternative mnemonics for Assembler, not used by Disassembler (so
  // implicit pseudooperands are not marked).
  { 0x0000FF, 0x0000A6, 1,00,  NNN,NNN,NNN, C_CMD+0,        "CMPSB" },
  { 0x00FFFF, 0x00A766, 2,00,  NNN,NNN,NNN, C_CMD+0,        "CMPSW" },
  { 0x0000FF, 0x0000A7, 1,00,  NNN,NNN,NNN, C_CMD+0,        "CMPSD" },
  { 0x0000FF, 0x0000AC, 1,00,  NNN,NNN,NNN, C_CMD+0,        "LODSB" },
  { 0x00FFFF, 0x00AD66, 2,00,  NNN,NNN,NNN, C_CMD+0,        "LODSW" },
  { 0x0000FF, 0x0000AD, 1,00,  NNN,NNN,NNN, C_CMD+0,        "LODSD" },
  { 0x0000FF, 0x0000A4, 1,00,  NNN,NNN,NNN, C_CMD+0,        "MOVSB" },
  { 0x00FFFF, 0x00A566, 2,00,  NNN,NNN,NNN, C_CMD+0,        "MOVSW" },
  { 0x0000FF, 0x0000A5, 1,00,  NNN,NNN,NNN, C_CMD+0,        "MOVSD" },
  { 0x0000FF, 0x0000AE, 1,00,  NNN,NNN,NNN, C_CMD+0,        "SCASB" },
  { 0x00FFFF, 0x00AF66, 1,00,  NNN,NNN,NNN, C_CMD+0,        "SCASW" },
  { 0x0000FF, 0x0000AF, 1,00,  NNN,NNN,NNN, C_CMD+0,        "SCASD" },
  { 0x0000FF, 0x0000AA, 1,00,  NNN,NNN,NNN, C_CMD+0,        "STOSB" },
  { 0x00FFFF, 0x00AB66, 2,00,  NNN,NNN,NNN, C_CMD+0,        "STOSW" },
  { 0x0000FF, 0x0000AB, 1,00,  NNN,NNN,NNN, C_CMD+0,        "STOSD" },
  { 0x00FFFF, 0x00A4F3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP MOVSB" },
  { 0xFFFFFF, 0xA5F366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REP MOVSW" },
  { 0x00FFFF, 0x00A5F3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP MOVSD" },
  { 0x00FFFF, 0x00ACF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP LODSB" },
  { 0xFFFFFF, 0xADF366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REP LODSW" },
  { 0x00FFFF, 0x00ADF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP LODSD" },
  { 0x00FFFF, 0x00AAF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP STOSB" },
  { 0xFFFFFF, 0xABF366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REP STOSW" },
  { 0x00FFFF, 0x00ABF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP STOSD" },
  { 0x00FFFF, 0x00A6F3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPE CMPSB" },
  { 0xFFFFFF, 0xA7F366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REPE CMPSW" },
  { 0x00FFFF, 0x00A7F3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPE CMPSD" },
  { 0x00FFFF, 0x00AEF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPE SCASB" },
  { 0xFFFFFF, 0xAFF366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REPE SCASW" },
  { 0x00FFFF, 0x00AFF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPE SCASD" },
  { 0x00FFFF, 0x00A6F2, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPNE CMPSB" },
  { 0xFFFFFF, 0xA7F266, 2,00,  NNN,NNN,NNN, C_REP+0,        "REPNE CMPSW" },
  { 0x00FFFF, 0x00A7F2, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPNE CMPSD" },
  { 0x00FFFF, 0x00AEF2, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPNE SCASB" },
  { 0xFFFFFF, 0xAFF266, 2,00,  NNN,NNN,NNN, C_REP+0,        "REPNE SCASW" },
  { 0x00FFFF, 0x00AFF2, 1,00,  NNN,NNN,NNN, C_REP+0,        "REPNE SCASD" },
  { 0x0000FF, 0x00006C, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "INSB" },
  { 0x00FFFF, 0x006D66, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "INSW" },
  { 0x0000FF, 0x00006D, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "INSD" },
  { 0x0000FF, 0x00006E, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "OUTSB" },
  { 0x00FFFF, 0x006F66, 2,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "OUTSW" },
  { 0x0000FF, 0x00006F, 1,00,  NNN,NNN,NNN, C_CMD+C_RARE+0, "OUTSD" },
  { 0x00FFFF, 0x006CF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP INSB" },
  { 0xFFFFFF, 0x6DF366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REP INSW" },
  { 0x00FFFF, 0x006DF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP INSD" },
  { 0x00FFFF, 0x006EF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP OUTSB" },
  { 0xFFFFFF, 0x6FF366, 2,00,  NNN,NNN,NNN, C_REP+0,        "REP OUTSW" },
  { 0x00FFFF, 0x006FF3, 1,00,  NNN,NNN,NNN, C_REP+0,        "REP OUTSD" },
  { 0x0000FF, 0x0000E1, 1,00,  JOB,NNN,NNN, C_JMC+0,        "$LOOP*Z" },
  { 0x0000FF, 0x0000E0, 1,00,  JOB,NNN,NNN, C_JMC+0,        "$LOOP*NZ" },
  { 0x0000FF, 0x00009B, 1,00,  NNN,NNN,NNN, C_CMD+0,        "FWAIT" },
  { 0x0000FF, 0x0000D7, 1,00,  NNN,NNN,NNN, C_CMD+0,        "XLATB" },
  { 0x00FFFF, 0x00C40F, 2,00,  RMX,RR4,IM1, C_MMX+2,        "PINSRW" },
  { 0x00FFFF, 0x0020CD, 2,00,  VXD,NNN,NNN, C_CAL+C_RARE+0, "VxDCall" },
  // Pseudocommands used by Assembler for masked search only.
  { 0x0000F0, 0x000070, 1,CC,  JOB,NNN,NNN, C_JMC+0,        "JCC" },
  { 0x00F0FF, 0x00800F, 2,CC,  JOW,NNN,NNN, C_JMC+0,        "JCC" },
  { 0x00F0FF, 0x00900F, 2,CC,  MR1,NNN,NNN, C_CMD+1,        "SETCC" },
  { 0x00F0FF, 0x00400F, 2,CC,  REG,MRG,NNN, C_CMD+0,        "CMOVCC" },
  // End of command table.
  { 0x000000, 0x000000, 0,00,  NNN,NNN,NNN, C_CMD+0,        "" }
};

const t_cmddata vxdcmd =               // Decoding of VxD calls (Win95/98)
  { 0x00FFFF, 0x0020CD, 2,00,  VXD,NNN,NNN, C_CAL+C_RARE+0, "VxDCall" };

// Bit combinations that can be potentially dangerous when executed:
const t_cmddata dangerous[] = {
  { 0x00FFFF, 0x00DCF7, 0,0,0,0,0,C_DANGER95,
              "Win95/98 may crash when NEG ESP is executed" },
  { 0x00FFFF, 0x00D4F7, 0,0,0,0,0,C_DANGER95,
              "Win95/98 may crash when NOT ESP is executed" },
  { 0x00FFFF, 0x0020CD, 0,0,0,0,0,C_DANGER95,
              "Win95/98 may crash when VxD call is executed in user mode" },
  { 0xF8FFFF, 0xC8C70F, 0,0,0,0,1,C_DANGERLOCK,
              "LOCK CMPXCHG8B may crash some processors when executed" },
  { 0x000000, 0x000000, 0,0,0,0,0,0, "" }
};

// Decodes address into symb (nsymb bytes long, including the terminating zero
// character) and comments its possible meaning. Returns number of bytes in
// symb not including terminating zero.
int Decodeaddress(ulong addr,char *symb,int nsymb,char *comment) 
{
  // Environment-specific routine! Do it yourself!
  return 0;
};

// Decodes and prints 32-bit float f into string s (which must be at least 16
// bytes long). Returns resulting length of the string.
int Printfloat4(char *s,float f) {
  int k;
  if (*(ulong *)&f==0x7F800000L)
    k=sprintf(s,"+INF 7F800000");
  else if (*(ulong *)&f==0xFF800000L)
    k=sprintf(s,"-INF FF800000");
  else if ((*(ulong *)&f & 0xFF800000L)==0x7F800000L)
    k=sprintf(s,"+NAN %08lX",*(ulong *)&f);
  else if ((*(ulong *)&f & 0xFF800000L)==0xFF800000L)
    k=sprintf(s,"-NAN %08lX",*(ulong *)&f);
  else if (f==0.0)                     // By default, 0 is printed without
    k=sprintf(s,"0.0");                // decimal point, which I don't want.
  else
    k=sprintf(s,"%#.7g",f);
  return k;
};

// Decodes and prints 64-bit double d into string s (at least 25 bytes long).
// Returns resulting length of the string.
int Printfloat8(char *s,double d) {
  int k;
  ulong lod,hid;
  lod=((ulong *)&d)[0];
  hid=((ulong *)&d)[1];
  if (lod==0 && hid==0x7F800000L)
    k=sprintf(s,"+INF 7F800000 00000000");
  else if (lod==0 && hid==0xFF800000L)
    k=sprintf(s,"-INF FF800000 00000000");
  else if ((hid & 0xFFF00000L)==0x7FF00000)
    k=sprintf(s,"+NAN %08lX %08lX",hid,lod);
  else if ((hid & 0xFFF00000L)==0xFFF00000)
    k=sprintf(s,"-NAN %08lX %08lX",hid,lod);
  else if (d==0.0)                     // Print 0 with decimal point
    k=sprintf(s,"0.0");
  else
    k=sprintf(s,"%#.16lg",d);
  return k;
};

// Decodes and prints 80-bit long double ext into string s (at least 32 bytes
// long). Procedure correctly displays all, even invalid, numbers without
// arithmetical exceptions. Returns resulting length of the string.
int Printfloat10(char *s,long double ext) {
  int k;
  char *e=(char *)&ext;
  if (*(ulong *)e==0 && *(ushort *)(e+4)==0 && *(ulong *)(e+6)==0x7FFF8000L)
    k=sprintf(s,"+INF 7FFF 80000000 00000000");
  else if (*(ulong *)e==0 && *(ushort *)(e+4)==0 &&
    *(ulong *)(e+6)==0xFFFF8000L)
    k=sprintf(s,"-INF FFFF 80000000 00000000");
  else if ((*(ulong *)(e+6) & 0x7FFF8000L)==0x7FFF8000L)
    k=sprintf(s,"%cNAN %04X %08lX %08lX",(e[9] & 0x80)==0?'+':'-',
    (int)(*(ushort *)(e+8)),*(ulong *)(e+4),*(ulong *)e);
  else if ((*(ulong *)(e+6) & 0x7FFF0000L)==0x7FFF0000L)
    k=sprintf(s,"%c??? %04X %08lX %08lX",(e[9] & 0x80)==0?'+':'-',
    (int)(*(ushort *)(e+8)),*(ulong *)(e+4),*(ulong *)e);
  else if ((*(ulong *)(e+6) & 0x7FFF0000L)!=0 &&
    (*(ulong *)(e+6) & 0x00008000)==0)
    k=sprintf(s,"%cUNORM %04X %08lX %08lX",(e[9] & 0x80)==0?'+':'-',
    (int)(*(ushort *)(e+8)),*(ulong *)(e+4),*(ulong *)e);
  else if (*(ulong *)e==0 && *(ushort *)(e+4)==0 &&
    *(ulong *)(e+6)==0x80000000L)
    k=sprintf(s,"-0.0");               // Negative floating 0.0
  else if (ext==0.0)
    k=sprintf(s,"0.0");                // Print 0 with decimal point
  else if ((ext>=-1.e10 && ext<-1.0) || (ext>1.0 && ext<=1.e10))
    k=sprintf(s,"%#.20Lg",ext);
  else if ((ext>=-1.0 && ext<=-1.e-5) || (ext>=1.e-5 && ext<=1.0))
    k=sprintf(s,"%#.19Lf",ext);
  else
    k=sprintf(s,"%#.19Le",ext);
  return k;
};

// Decodes and prints 64-bit 3DNow! element f into string s (which must be at
// least 30 bytes long). Returns resulting length of the string.
int Print3dnow(char *s,char *f) {
  int n;
  n=Printfloat4(s,*(float *)(f+4));
  n+=sprintf(s+n,", ");
  n+=Printfloat4(s+n,*(float *)f);
  return n;
};

// Function attempts to calculate address of assembler instruction which is n
// lines back in the listing. Maximal stepback is limited to 127. In general,
// this is rather non-trivial task. Proposed solution may cause problems which
// however are not critical here.
ulong Disassembleback(char *block,ulong base,ulong size,ulong ip,int n) {
  int i;
  ulong abuf[131],addr,back,cmdsize;
  char *pdata;
  t_disasm da;
  memset(&da,0,sizeof(t_disasm));
  if (block==NULL) 
	  return 0;           // Error, no code!
  if (n<0) 
	  n=0;
  else 
	  if (n>127)
		  n=127; // Try to correct obvious errors
  if (ip>base+size) 
	  ip=base+size;
  if (n==0) 
	  return ip;                 // Obvious answers
  if (ip<=base+n)
	  return base;
  back=MAXCMDSIZE*(n+3);               // Command length limited to MAXCMDSIZE
  if (ip<base+back) 
	  back=ip-base;
  addr=ip-back;
  pdata=block+(addr-base);
  for (i=0; addr<ip; i++)
  {
    abuf[i%128]=addr;
    cmdsize=Disasm(pdata,back,addr,&da,DISASM_SIZE);
    pdata+=cmdsize;
    addr+=cmdsize;
    back-=cmdsize; };
  if (i<n) return abuf[0];
  else return abuf[(i-n+128)%128];
};

// Function attempts to calculate address of assembler instruction which is n
// lines forward in the listing.
ulong Disassembleforward(char *block,ulong base,ulong size,ulong ip,int n) 
{
  int i;
  ulong cmdsize;
  char *pdata;
  t_disasm da;
  memset(&da,0,sizeof(t_disasm));
  if (block==NULL)
	  return 0;           // Error, no code!
  if (ip<base) 
	  ip=base;                // Try to correct obvious errors
  if (ip>base+size)
	  ip=base+size;
  if (n<=0)
	  return ip;
  pdata=block+(ip-base);
  size-=(ip-base);
  for (i=0; i<n && size>0; i++)
  {
    cmdsize=Disasm(pdata,size,ip,&da,DISASM_SIZE);
    pdata+=cmdsize;
    ip+=cmdsize;
    size-=cmdsize;
  }
  return ip;
}

// Service function, checks whether command at offset addr in data is a valid
// filling command (usually some kind of NOP) used to align code to a specified
// (align=power of 2, 0 means no alignment) border. Returns length of filling
// command in bytes or 0 if command is not a recognized filling.
int Isfilling(ulong addr,char *data,ulong size,ulong align) {
  if (data==NULL) return 0;            // Invalid parameters
  // Convert power of 2 to bitmask.
  align--;
  // Many compilers and assemblers use NOP or INT3 as filling:
  if (addr<size && (data[addr]==NOP || data[addr]==INT3) &&
    (addr & align)!=0)
    return 1;
  // Borland compilers use XCHG EBX,EBX (87,DB) to fill holes. For the sake of
  // completeness, allow any XCHG or MOV of register with self.
  if (addr+1<size &&
    ((data[addr] & 0xFE)==0x86 || (data[addr] & 0xFC)==0x88) &&
    (data[addr+1] & 0xC0)==0xC0 &&
    (((data[addr+1]>>3)^data[addr+1]) & 0x07)==0 &&
    (addr & align)!=0x0F && (addr & align)!=0x00)
    return 2;
  // Some other programs use LEA EAX,[EAX] (8D,40,00). For completeness, allow
  // any register except ESP (here address is constructed differently):
  if (addr+2<size &&
    data[addr]==0x8D && (data[addr+1] & 0xC0)==0x40 && data[addr+2]==0x00 &&
    (data[addr+1] & 0x07)!=REG_ESP &&
    (((data[addr+1]>>3)^data[addr+1]) & 0x07)==0)
    return 3;
  // WATCOM compilers use LEA EAX,[EAX] with SIB and 8-bit zero (8D,44,20,00)
  // and without SIB but with 32-bit immediate zero (8D,80,00,00,00,00) and
  // alike:
  if (addr+3<size &&
    data[addr]==0x8D && (data[addr+1] & 0xC0)==0x40 && data[addr+3]==0x00 &&
    (((data[addr+1]>>3)^data[addr+2]) & 0x07)==0)
    return 4;
  if (addr+5<size && data[addr]==0x8D &&
    (data[addr+1] & 0xC0)==0x80 && *(ulong *)(data+addr+2)==0 &&
    (data[addr+1] & 0x07)!=REG_ESP &&
    (((data[addr+1]>>3)^data[addr+1]) & 0x07)==0)
    return 6;
  // Unable to recognize this code as a valid filling.
  return 0;
};

  
```

`vm-packer/反汇编/反汇编/ASM/assembl.cpp`:

```cpp
// Free Disassembler and Assembler -- Assembler
//
// Copyright (C) 2001 Oleh Yuschuk
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

// 16.01.2002 - corrected error in processing of immediate constants.


#define STRICT

#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
//#include <dir.h>
#include <math.h>
#include <float.h>
#pragma hdrstop

#include "disasm.h"

#pragma   warning(disable:4996)//購液症痕方蕗苧少御
////////////////////////////////////////////////////////////////////////////////
///////////////////////////// ASSEMBLER FUNCTIONS //////////////////////////////

// Scanner modes.
#define SA_NAME        0x0001          // Don't try to decode labels
#define SA_IMPORT      0x0002          // Allow import pseudolabel

// Types of input tokens reported by scanner.
#define SCAN_EOL       0               // End of line
#define SCAN_REG8      1               // 8-bit register
#define SCAN_REG16     2               // 16-bit register
#define SCAN_REG32     3               // 32-bit register
#define SCAN_SEG       4               // Segment register
#define SCAN_FPU       5               // FPU register
#define SCAN_MMX       6               // MMX register
#define SCAN_CR        7               // Control register
#define SCAN_DR        8               // Debug register
#define SCAN_OPSIZE    9               // Operand size modifier
#define SCAN_JMPSIZE   10              // Jump size modifier
#define SCAN_LOCAL     11              // Address on stack in form LOCAL.decimal
#define SCAN_ARG       12              // Address on stack in form ARG.decimal
#define SCAN_PTR       20              // PTR in MASM addressing statements
#define SCAN_REP       21              // REP prefix
#define SCAN_REPE      22              // REPE prefix
#define SCAN_REPNE     23              // REPNE prefix
#define SCAN_LOCK      24              // LOCK prefix
#define SCAN_NAME      25              // Command or label
#define SCAN_ICONST    26              // Hexadecimal constant
#define SCAN_DCONST    27              // Decimal constant
#define SCAN_OFS       28              // Undefined constant
#define SCAN_FCONST    29              // Floating-point constant
#define SCAN_EIP       30              // Register EIP
#define SCAN_SIGNED    31              // Keyword "SIGNED" (in expressions)
#define SCAN_UNSIGNED  32              // Keyword "UNSIGNED" (in expressions)
#define SCAN_CHAR      33              // Keyword "CHAR" (in expressions)
#define SCAN_FLOAT     34              // Keyword "FLOAT" (in expressions)
#define SCAN_DOUBLE    35              // Keyword "DOUBLE" (in expressions)
#define SCAN_FLOAT10   36              // Keyword "FLOAT10" (in expressions)
#define SCAN_STRING    37              // Keyword "STRING" (in expressions)
#define SCAN_UNICODE   38              // Keyword "UNICODE" (in expressions)
#define SCAN_MSG       39              // Pseudovariable MSG (in expressions)

#define SCAN_SYMB      64              // Any other character
#define SCAN_IMPORT    65              // Import pseudolabel
#define SCAN_ERR       255             // Definitely bad item

// Definition used by Assembler to report command matching errors.
#define MA_JMP         0x0001          // Invalid jump size modifier
#define MA_NOP         0x0002          // Wrong number of operands
#define MA_TYP         0x0004          // Bad operand type
#define MA_NOS         0x0008          // Explicit operand size expected
#define MA_SIZ         0x0010          // Bad operand size
#define MA_DIF         0x0020          // Different operand sizes
#define MA_SEG         0x0040          // Invalid segment register
#define MA_RNG         0x0080          // Constant out of expected range

typedef struct t_asmoperand 
{
	int            type;                 // Operand type, see beginning of file
	int            size;                 // Operand size or 0 if yet unknown
	int            index;                // Index or other register
	int            scale;                // Scale
	int            base;                 // Base register if present
	long           offset;               // Immediate value or offset
	int            anyoffset;            // Offset is present but undefined
	int            segment;              // Segment in address if present
	int            jmpmode;              // Specified jump size
} t_asmoperand;

static char      *asmcmd;              // Pointer to 0-terminated source line
static int       scan;                 // Type of last scanned element
static int       prio;                 // Priority of operation (0: highest)
static char      sdata[TEXTLEN];       // Last scanned name (depends on type)
static long      idata;                // Last scanned value
static long      double fdata;         // Floating-point number
static char      *asmerror;            // Explanation of last error, or NULL

// Simple and slightly recursive scanner shared by Assemble(). The scanner is
// straightforward and ineffective, but high speed is not a must here. As
// input, it uses global pointer to source line asmcmd. On exit, it fills in
// global variables scan, prio, sdata, idata and/or fdata. If some error is
// detected, asmerror points to error message, otherwise asmerror remains
// unchanged.
static void Scanasm(int mode) 
{
	int i,j,base,maxdigit;
	long decimal,hex;
	long double floating,divisor;
	char s[TEXTLEN],*pcmd;
	sdata[0]='\0';
	idata=0;
	if (asmcmd==NULL) 
	{
		asmerror="NULL input line";
		scan=SCAN_ERR;
		return; 
	};
	while (*asmcmd==' ' || *asmcmd=='\t')
		asmcmd++;                          // Skip leading spaces
	if (*asmcmd=='\0' || *asmcmd==';') 
	{
		scan=SCAN_EOL; 
		return;
	};          // Empty line
	if (isalpha(*asmcmd) || *asmcmd=='_' || *asmcmd=='@')
	{
		sdata[0]=*asmcmd++; i=1;           // Some keyword or identifier
		while ((isalnum(*asmcmd) || *asmcmd=='_' || *asmcmd=='@') && i<sizeof(sdata))
			sdata[i++]=*asmcmd++;
		if (i>=sizeof(sdata)) 
		{
			asmerror="Too long identifier";
			scan=SCAN_ERR; 
			return;
		};
		sdata[i]='\0';
		while (*asmcmd==' ' || *asmcmd=='\t')
			asmcmd++;                        // Skip trailing spaces
		strcpy(s,sdata); _strupr_s(s);
		for (j=0; j<=8; j++)
		{             // j==8 means "any register"
			if (strcmp(s,regname[0][j])!=0) 
				continue;
			idata=j; 
			scan=SCAN_REG8;         // 8-bit register
			return; 
		};
		for (j=0; j<=8; j++)
		{
			if (strcmp(s,regname[1][j])!=0)
				continue;
			idata=j;
			scan=SCAN_REG16;        // 16-bit register
			return; 
		};
		for (j=0; j<=8; j++)
		{
			if (strcmp(s,regname[2][j])!=0)
				continue;
			idata=j; 
			scan=SCAN_REG32;        // 32-bit register
			return;
		};
		for (j=0; j<6; j++)
		{
			if (strcmp(s,segname[j])!=0)
				continue;
			idata=j; 
			scan=SCAN_SEG;          // Segment register
			while (*asmcmd==' ' || *asmcmd=='\t')
				asmcmd++;                      // Skip trailing spaces
			return;
		};
		if (strcmp(s,"ST")==0)
		{
			pcmd=asmcmd;
			Scanasm(SA_NAME);   // FPU register
			if (scan!=SCAN_SYMB || idata!='(')
			{
				asmcmd=pcmd;                   // Undo last scan
				idata=0; scan=SCAN_FPU; 
				return;
			};
			Scanasm(SA_NAME);
			j=idata;
			if ((scan!=SCAN_ICONST && scan!=SCAN_DCONST) || idata<0 || idata>7)
			{
				asmerror="FPU registers have indexes 0 to 7";
				scan=SCAN_ERR;
				return;
			};
			Scanasm(SA_NAME);
			if (scan!=SCAN_SYMB || idata!=')')
			{
				asmerror="Closing parenthesis expected";
				scan=SCAN_ERR;
				return;
			};
			idata=j; scan=SCAN_FPU;
			return; 
		};
		for (j=0; j<=8; j++)
		{

			if (strcmp(s,fpuname[j])!=0) 
				continue;
			idata=j; 
			scan=SCAN_FPU;          // FPU register (alternative coding)
			return; 
		};
		for (j=0; j<=8; j++)
		{
			if (strcmp(s,mmxname[j])!=0) 
				continue;
			idata=j; scan=SCAN_MMX;          // MMX register
			return;
		};
		for (j=0; j<=8; j++) 
		{
			if (strcmp(s,crname[j])!=0)
				continue;
			idata=j;
			scan=SCAN_CR;           // Control register
			return;
		};
		for (j=0; j<=8; j++) 
		{
			if (strcmp(s,drname[j])!=0) 
				continue;
			idata=j;
			scan=SCAN_DR;           // Debug register
			return;
		};
		for (j=0; j<sizeof(sizename)/sizeof(sizename[0]); j++) 
		{
			if (strcmp(s,sizename[j])!=0) 
				continue;
			pcmd=asmcmd; Scanasm(SA_NAME);
			if (scan!=SCAN_PTR)              // Fetch non-functional "PTR"
				asmcmd=pcmd;
			idata=j;
			scan=SCAN_OPSIZE;       // Operand (data) size in bytes
			return;
		};
		if (strcmp(s,"EIP")==0)
		{          // Register EIP
			scan=SCAN_EIP;
			idata=0; 
			return; 
		};
		if (strcmp(s,"SHORT")==0) 
		{        // Relative jump has 1-byte offset
			scan=SCAN_JMPSIZE; idata=1;
			return;
		};
		if (strcmp(s,"LONG")==0) 
		{         // Relative jump has 4-byte offset
			scan=SCAN_JMPSIZE; idata=2;
			return;
		};
		if (strcmp(s,"NEAR")==0) 
		{         // Jump within same code segment
			scan=SCAN_JMPSIZE; idata=4;
			return; 
		};
		if (strcmp(s,"FAR")==0) 
		{          // Jump to different code segment
			scan=SCAN_JMPSIZE; idata=8;
			return; 
		};
		if (strcmp(s,"LOCAL")==0 && *asmcmd=='.') {
			asmcmd++;
			while (*asmcmd==' ' || *asmcmd=='\t')
				asmcmd++;                      // Skip trailing spaces
			if (!isdigit(*asmcmd))
			{
				asmerror="Integer number expected";
				scan=SCAN_ERR;
				return; 
			};
			while (isdigit(*asmcmd))         // LOCAL index is decimal number!
				idata=idata*10+(*asmcmd++)-'0';
			scan=SCAN_LOCAL;
			return; 
		};
		if (strcmp(s,"ARG")==0 && *asmcmd=='.') 
		{
			asmcmd++;
			while (*asmcmd==' ' || *asmcmd=='\t')
				asmcmd++;                      // Skip trailing spaces
			if (!isdigit(*asmcmd)) 
			{
				asmerror="Integer number expected";
				scan=SCAN_ERR; return; 
			};
			while (isdigit(*asmcmd))         // ARG index is decimal number!
				idata=idata*10+(*asmcmd++)-'0';
			scan=SCAN_ARG; 
			return;
		};
		if (strcmp(s,"REP")==0) 
		{
			scan=SCAN_REP; 
			return; 
		};        // REP prefix
		if (strcmp(s,"REPE")==0 || strcmp(s,"REPZ")==0) 
		{
			scan=SCAN_REPE;
			return;
		};       // REPE prefix
		if (strcmp(s,"REPNE")==0 || strcmp(s,"REPNZ")==0) 
		{
			scan=SCAN_REPNE;
			return;
		};      // REPNE prefix
		if (strcmp(s,"LOCK")==0) 
		{
			scan=SCAN_LOCK; 
			return;
		};       // LOCK prefix
		if (strcmp(s,"PTR")==0)
		{
			scan=SCAN_PTR; 
			return;
		};        // PTR in MASM addressing statements
		if (strcmp(s,"CONST")==0 || strcmp(s,"OFFSET")==0)
		{
			scan=SCAN_OFS;
			return;
		};        // Present but undefined offset/constant
		if (strcmp(s,"SIGNED")==0) 
		{
			scan=SCAN_SIGNED;
			return; 
		};     // Keyword "SIGNED" (in expressions)
		if (strcmp(s,"UNSIGNED")==0) 
		{
			scan=SCAN_UNSIGNED; 
			return;
		};   // Keyword "UNSIGNED" (in expressions)
		if (strcmp(s,"CHAR")==0)
		{
			scan=SCAN_CHAR; return;
		};       // Keyword "CHAR" (in expressions)
		if (strcmp(s,"FLOAT")==0) 
		{
			scan=SCAN_FLOAT; 
			return;
		};      // Keyword "FLOAT" (in expressions)
		if (strcmp(s,"DOUBLE")==0) 
		{
			scan=SCAN_DOUBLE; 
			return; 
		};     // Keyword "DOUBLE" (in expressions)
		if (strcmp(s,"FLOAT10")==0) 
		{
			scan=SCAN_FLOAT10; 
			return;
		};    // Keyword "FLOAT10" (in expressions)
		if (strcmp(s,"STRING")==0) 
		{
			scan=SCAN_STRING; 
			return; 
		};     // Keyword "STRING" (in expressions)
		if (strcmp(s,"UNICODE")==0) 
		{
			scan=SCAN_UNICODE;
			return; 
		};    // Keyword "UNICODE" (in expressions)
		if (strcmp(s,"MSG")==0)
		{
			scan=SCAN_MSG;
			return;
		};        // Pseudovariable MSG (in expressions)
		if (mode & SA_NAME) 
		{
			idata=i;
			scan=SCAN_NAME;         // Don't try to decode symbolic label
			return; 
		}
		asmerror="Unknown identifier";
		scan=SCAN_ERR; 
		return; 
	}
	else if (isdigit(*asmcmd))
	{         // Constant
		base=0; maxdigit=0; decimal=hex=0L; floating=0.0;
		if (asmcmd[0]=='0' && toupper(asmcmd[1])=='X')
		{
			base=16; asmcmd+=2;
		};           // Force hexadecimal number
		while (1) 
		{
			if (isdigit(*asmcmd))
			{
				decimal=decimal*10+(*asmcmd)-'0';
				floating=floating*10.0+(*asmcmd)-'0';
				hex=hex*16+(*asmcmd)-'0';
				if (maxdigit==0)
					maxdigit=9;
				asmcmd++; 
			}
			else if (isxdigit(*asmcmd)) 
			{
				hex=hex*16+toupper(*asmcmd++)-'A'+10;
				maxdigit=15; 
			}
			else
				break; 
		};
		if (maxdigit==0) 
		{
			asmerror="Hexadecimal digits after 0x... expected";
			scan=SCAN_ERR; 
			return;
		};
		if (toupper(*asmcmd)=='H')
		{       // Force hexadecimal number
			if (base==16) 
			{
				asmerror="Please don't mix 0xXXXX and XXXXh forms";
				scan=SCAN_ERR;
				return;
			};
			asmcmd++;
			idata=hex; scan=SCAN_ICONST;
			while (*asmcmd==' ' || *asmcmd=='\t')
				asmcmd++;
			return; 
		};
		if (*asmcmd=='.') 
		{                // Force decimal number
			if (base==16 || maxdigit>9) 
			{
				asmerror="Not a decimal number";
				scan=SCAN_ERR;
				return;
			};
			asmcmd++;
			if (isdigit(*asmcmd) || toupper(*asmcmd)=='E')
			{
				divisor=1.0;
				while (isdigit(*asmcmd)) 
				{     // Floating-point number
					divisor/=10.0;
					floating+=divisor*(*asmcmd-'0');
					asmcmd++; 
				};
				if (toupper(*asmcmd)=='E') 
				{
					asmcmd++;
					if (*asmcmd=='-') 
					{
						base=-1;
						asmcmd++;
					}
					else 
						base=1;
					if (!isdigit(*asmcmd))
					{
						asmerror="Invalid exponent";
						scan=SCAN_ERR; 
						return;
					};
					decimal=0;
					while (isdigit(*asmcmd))
					{
						if (decimal<65536L)
							decimal=decimal*10+(*asmcmd++)-'0';
					};

					floating*=powl(decimal*base,1);
				};
				fdata=floating;
				scan=SCAN_FCONST;
				return; 
			}
			else
			{
				idata=decimal;
				scan=SCAN_DCONST;
				while (*asmcmd==' ' || *asmcmd=='\t') 
					asmcmd++;
				return;
			};
		};
		idata=hex; 
		scan=SCAN_ICONST;       // Default is hexadecimal
		while (*asmcmd==' ' || *asmcmd=='\t') 
			asmcmd++;
		return;
	}
	else if (*asmcmd=='\'') 
	{            // Character constant
		asmcmd++;
		if (*asmcmd=='\0' || (*asmcmd=='\\' && asmcmd[1]=='\0'))
		{
			asmerror="Unterminated character constant"; 
			scan=SCAN_ERR;
			return;
		};
		if (*asmcmd=='\'')
		{
			asmerror="Empty character constant";
			scan=SCAN_ERR; 
			return;
		};
		if (*asmcmd=='\\') 
			asmcmd++;
		idata=*asmcmd++; 
		if (*asmcmd!='\'') 
		{
			asmerror="Unterminated character constant";
			scan=SCAN_ERR; 
			return;
		};
		asmcmd++;
		while (*asmcmd==' ' || *asmcmd=='\t') 
			asmcmd++;
		scan=SCAN_ICONST;
		return;
	}
	else
	{                               // Any other character or combination
		idata=sdata[0]=*asmcmd++; sdata[1]=sdata[2]='\0';
		if (idata=='|' && *asmcmd=='|')
		{
			idata='||'; prio=10;             // '||'
			sdata[1]=*asmcmd++;
		}
		else if (idata=='&' && *asmcmd=='&')
		{
			idata='&&'; prio=9;              // '&&'
			sdata[1]=*asmcmd++;
		}
		else if (idata=='=' && *asmcmd=='=') 
		{
			idata='=='; prio=5;              // '=='
			sdata[1]=*asmcmd++; 
		}
		else if (idata=='!' && *asmcmd=='=')
		{
			idata='!='; prio=5;              // '!='
			sdata[1]=*asmcmd++;
		}
		else if (idata=='<' && *asmcmd=='=')
		{
			idata='<='; prio=4;              // '<='
			sdata[1]=*asmcmd++;
		}
		else if (idata=='>' && *asmcmd=='=') 
		{
			idata='>='; prio=4;              // '>='
			sdata[1]=*asmcmd++;
		}
		else if (idata=='<' && *asmcmd=='<') 
		{
			idata='<<'; prio=3;              // '<<'
			sdata[1]=*asmcmd++; 
		}
		else if (idata=='>' && *asmcmd=='>')
		{
			idata='>>'; prio=3;              // '>>'
			sdata[1]=*asmcmd++; 
		}
		else if (idata=='|') 
			prio=8;       // '|'
		else if (idata=='^') 
			prio=7;       // '^'
		else if (idata=='&') 
			prio=6;       // '&'
		else if (idata=='<')
		{
			if (*asmcmd=='&') 
			{              // Import pseudolabel (for internal use)
				if ((mode & SA_IMPORT)==0)
				{
					asmerror="Syntax error";
					scan=SCAN_ERR; return;
				};
				asmcmd++; i=0;
				while (*asmcmd!='\0' && *asmcmd!='>')
				{
					sdata[i++]=*asmcmd++;
					if (i>=sizeof(sdata))
					{
						asmerror="Too long import name"; 
						scan=SCAN_ERR; 
						return;
					};
				};
				if (*asmcmd!='>') 
				{
					asmerror="Unterminated import name";
					scan=SCAN_ERR; 
					return;
				};
				asmcmd++;
				sdata[i]='\0';
				scan=SCAN_IMPORT; 
				return;
			}
			else prio=4;
		}                   // '<'
		else if (idata=='>')
			prio=4;       // '>'
		else if (idata=='+')
			prio=2;       // '+'
		else if (idata=='-')
			prio=2;       // '-'
		else if (idata=='*') 
			prio=1;       // '*'
		else if (idata=='/')
			prio=1;       // '/'
		else if (idata=='%') 
			prio=1;       // '%'
		else if (idata==']')
		{
			pcmd=asmcmd; 
			Scanasm(SA_NAME);
			if (scan!=SCAN_SYMB || idata!='[')
			{
				idata=']';
				asmcmd=pcmd; 
				prio=0;
			}
			else
			{
				idata='+'; prio=2;             // Translate '][' to '+'
			};
		}
		else 
			prio=0;                       // Any other character
		scan=SCAN_SYMB;
		return;
	};
};

// Fetches one complete operand from the input line and fills in structure op
// with operand's data. Expects that first token of the operand is already
// scanned. Supports operands in generalized form (for example, R32 means any
// of general-purpose 32-bit integer registers).
static void Parseasmoperand(t_asmoperand *op) 
{
	int i,j,bracket,sign,xlataddr;
	int reg,r[9];
	long offset;
	if (scan==SCAN_EOL || scan==SCAN_ERR)
		return;                            // No or bad operand
	// Jump or call address may begin with address size modifier(s) SHORT, LONG,
	// NEAR and/or FAR. Not all combinations are allowed. After operand is
	// completely parsed, this function roughly checks whether modifier is
	// allowed. Exact check is done in Assemble().
	if (scan==SCAN_JMPSIZE) 
	{
		j=0;
		while (scan==SCAN_JMPSIZE)
		{
			j|=idata;                        // Fetch all size modifiers
			Scanasm(0); 
		};
		if (
			((j & 0x03)==0x03) ||            // Mixed SHORT and LONG
			((j & 0x0C)==0x0C) ||            // Mixed NEAR and FAR
			((j & 0x09)==0x09)               // Mixed FAR and SHORT
			) 
		{
			asmerror="Invalid combination of jump address modifiers";
			scan=SCAN_ERR;
			return;
		};
		if ((j & 0x08)==0)
			j|=0x04;        // Force NEAR if not FAR
		op->jmpmode=j; 
	};
	// Simple operands are either register or constant, their processing is
	// obvious and straightforward.
	if (scan==SCAN_REG8 || scan==SCAN_REG16 || scan==SCAN_REG32)
	{
		op->type=REG; 
		op->index=idata;     // Integer general-purpose register
		if (scan==SCAN_REG8)
			op->size=1;
		else if (scan==SCAN_REG16)
			op->size=2;
		else 
			op->size=4;
	}
	else if (scan==SCAN_FPU) 
	{           // FPU register
		op->type=RST; 
		op->index=idata;
	}
	else if (scan==SCAN_MMX) 
	{           // MMX or 3DNow! register
		op->type=RMX; 
		op->index=idata;
	}
	else if (scan==SCAN_CR)
	{            // Control register
		op->type=CRX; 
		op->index=idata;
	}
	else if (scan==SCAN_DR) 
	{            // Debug register
		op->type=DRX;
		op->index=idata;
	}
	else if (scan==SCAN_SYMB && idata=='-')
	{
		Scanasm(0);                        // Negative constant
		if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS)
		{
			asmerror="Integer number expected";
			scan=SCAN_ERR;
			return;
		};
		op->type=IMM; 
		op->offset=-idata;
		if (scan==SCAN_OFS)
			op->anyoffset=1; 
	}
	else if (scan==SCAN_SYMB && idata=='+') 
	{
		Scanasm(0);                        // Positive constant
		if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS)
		{
			asmerror="Integer number expected";
			scan=SCAN_ERR;
			return; 
		};
		op->type=IMM; 
		op->offset=idata;
		if (scan==SCAN_OFS) 
			op->anyoffset=1;
	}
	else if (scan==SCAN_ICONST || scan==SCAN_DCONST || scan==SCAN_OFS) 
	{
		j=idata;
		if (scan==SCAN_OFS) 
			op->anyoffset=1;
		Scanasm(0);
		if (scan==SCAN_SYMB && idata==':')
		{
			Scanasm(0);                      // Absolute long address (seg:offset)
			if (scan!=SCAN_ICONST && scan!=SCAN_DCONST && scan!=SCAN_OFS) 
			{
				asmerror="Integer address expected";
				scan=SCAN_ERR;
				return;
			};
			op->type=JMF; 
			op->offset=idata;
			op->segment=j;
			if (scan==SCAN_OFS) 
				op->anyoffset=1;
		}
		else 
		{
			op->type=IMM; 
			op->offset=j;      // Constant without sign
			return;                          // Next token already scanned
		};
	}
	else if (scan==SCAN_FCONST)
	{
		asmerror="Floating-point numbers are not allowed in command";
		scan=SCAN_ERR;
		return; 
	}
	// Segment register or address.
	else if (scan==SCAN_SEG || scan==SCAN_OPSIZE || (scan==SCAN_SYMB && idata=='[') ) 
	{                                  // Segment register or address
		bracket=0;
		if (scan==SCAN_SEG)
		{
			j=idata; Scanasm(0);
			if (scan!=SCAN_SYMB || idata!=':')
			{
				op->type=SGM; op->index=j;     // Segment register as operand
				return; 
			};                     // Next token already scanned
			op->segment=j; 
			Scanasm(0); 
		};
		// Scan 32-bit address. This parser does not support 16-bit addresses.
		// First of all, get size of operand (optional), segment register (optional)
		// and opening bracket (required).
		while (1)
		{
			if (scan==SCAN_SYMB && idata=='[')
			{
				if (bracket)
				{                 // Bracket
					asmerror="Only one opening bracket allowed";
					scan=SCAN_ERR; return; 
				};
				bracket=1;
			}
			else if (scan==SCAN_OPSIZE)
			{
				if (op->size!=0) 
				{             // Size of operand
					asmerror="Duplicated size modifier";
					scan=SCAN_ERR;
					return; 
				};
				op->size=idata;
			}
			else if (scan==SCAN_SEG)
			{
				if (op->segment!=SEG_UNDEF) 
				{  // Segment register
					asmerror="Duplicated segment register";
					scan=SCAN_ERR; 
					return; 
				};
				op->segment=idata; Scanasm(0);
				if (scan!=SCAN_SYMB || idata!=':') 
				{
					asmerror="Semicolon expected";
					scan=SCAN_ERR; return;
				};
			}
			else if (scan==SCAN_ERR)
				return;
			else 
				break;                      // None of expected address elements
			Scanasm(0);
		};
		if (bracket==0)
		{
			asmerror="Address expression requires brackets";
			scan=SCAN_ERR; 
			return; 
		};
		// Assembling a 32-bit address may be a kind of nigthmare, due to a large
		// number of allowed forms. Parser collects immediate offset in op->offset
		// and count for each register in array r[]. Then it decides whether this
		// combination is valid and determines scale, index and base. Assemble()
		// will use these numbers to select address form (with or without SIB byte,
		// 8- or 32-bit offset, use segment prefix or not). As a useful side effect
		// of this technique, one may specify, for example, [EAX*5] which will
		// correctly assemble to [EAX*4+EAX].
		for (i=0; i<=8; i++) r[i]=0;
		sign='+';                          // Default sign for the first operand
		xlataddr=0;
		while (1) 
		{                        // Get SIB and offset
			if (scan==SCAN_SYMB && (idata=='+' || idata=='-'))
			{
				sign=idata; Scanasm(0);
			};
			if (scan==SCAN_ERR) 
				return;
			if (sign=='?')
			{
				asmerror="Syntax error"; 
				scan=SCAN_ERR;
				return; };
				// Register AL appears as part of operand of (seldom used) command XLAT.
				if (scan==SCAN_REG8 && idata==REG_EAX) 
				{
					if (sign=='-')
					{
						asmerror="Unable to subtract register"; scan=SCAN_ERR;
						return;
					};
					if (xlataddr!=0) 
					{
						asmerror="Too many registers"; 
						scan=SCAN_ERR; 
						return;
					};
					xlataddr=1;
					Scanasm(0);
				}
				else if (scan==SCAN_REG16)
				{
					asmerror="Sorry, 16-bit addressing is not supported";
					scan=SCAN_ERR;
					return;
				}
				else if (scan==SCAN_REG32)
				{
					if (sign=='-') 
					{
						asmerror="Unable to subtract register";
						scan=SCAN_ERR; return;
					};
					reg=idata; Scanasm(0);
					if (scan==SCAN_SYMB && idata=='*')
					{
						Scanasm(0);                  // Try index*scale
						if (scan==SCAN_ERR)
							return;
						if (scan==SCAN_OFS) 
						{
							asmerror="Undefined scale is not allowed"; 
							scan=SCAN_ERR; 
							return; 
						};
						if (scan!=SCAN_ICONST && scan!=SCAN_DCONST) 
						{
							asmerror="Syntax error";
							scan=SCAN_ERR; 
							return; 
						};
						if (idata==6 || idata==7 || idata>9)
						{
							asmerror="Invalid scale";
							scan=SCAN_ERR;
							return;
						};
						r[reg]+=idata;
						Scanasm(0); 
					}
					else 
						r[reg]++; 
				}               // Simple register
				else if (scan==SCAN_LOCAL) 
				{
					r[REG_EBP]++;
					op->offset-=idata*4;
					Scanasm(0);
				}
				else if (scan==SCAN_ARG)
				{
					r[REG_EBP]++;
					op->offset+=(idata+1)*4;
					Scanasm(0);
				}
				else if (scan==SCAN_ICONST || scan==SCAN_DCONST)
				{
					offset=idata; 
					Scanasm(0);
					if (scan==SCAN_SYMB && idata=='*')
					{
						Scanasm(0);                  // Try scale*index
						if (scan==SCAN_ERR)
							return;
						if (sign=='-')
						{
							asmerror="Unable to subtract register"; 
							scan=SCAN_ERR;
							return;
						};
						if (scan==SCAN_REG16) 
						{
							asmerror="Sorry, 16-bit addressing is not supported";
							scan=SCAN_ERR;
							return;
						};
						if (scan!=SCAN_REG32)
						{
							asmerror="Syntax error";
							scan=SCAN_ERR; 
							return;
						};
						if (offset==6 || offset==7 || offset>9)
						{
							asmerror="Invalid scale";
							scan=SCAN_ERR;
							return; 
						};
						r[idata]+=offset;
						Scanasm(0); 
					}
					else 
					{
						if (sign=='-') 
							op->offset-=offset;
						else 
							op->offset+=offset;
					};
				}
				else if (scan==SCAN_OFS) 
				{
					Scanasm(0);
					if (scan==SCAN_SYMB && idata=='*')
					{
						asmerror="Undefined scale is not allowed"; scan=SCAN_ERR; return; }
					else 
					{
						op->anyoffset=1;
					}; 
				}
				else 
					break;                      // None of expected address elements
				if (scan==SCAN_SYMB && idata==']')
					break;
				sign='?';
		};
		if (scan==SCAN_ERR) 
			return;
		if (scan!=SCAN_SYMB || idata!=']') 
		{
			asmerror="Syntax error";
			scan=SCAN_ERR;
			return;
		};
		// Process XLAT address separately.
		if (xlataddr!=0) 
		{                 // XLAT address in form [EBX+AX]
			for (i=0; i<=8; i++) 
			{           // Check which registers used
				if (i==REG_EBX)
					continue;
				if (r[i]!=0) break; 
			};
			if (i<=8 || r[REG_EBX]!=1 || op->offset!=0 || op->anyoffset!=0) 
			{
				asmerror="Invalid address";
				scan=SCAN_ERR;
				return;
			};
			op->type=MXL;
		}
		// Determine scale, index and base.
		else 
		{
			j=0;                             // Number of used registers
			for (i=0; i<=8; i++)
			{
				if (r[i]==0)
					continue;                    // Unused register
				if (r[i]==3 || r[i]==5 || r[i]==9)
				{
					if (op->index>=0 || op->base>=0)
					{
						if (j==0) 
							asmerror="Invalid scale";
						else 
							asmerror="Too many registers";
						scan=SCAN_ERR;
						return;
					};
					op->index=op->base=i;
					op->scale=r[i]-1;
				}
				else if (r[i]==2 || r[i]==4 || r[i]==8)
				{
					if (op->index>=0) 
					{
						if (j<=1) 
							asmerror="Only one register may be scaled";
						else 
							asmerror="Too many registers";
						scan=SCAN_ERR;
						return; 
					};
					op->index=i;
					op->scale=r[i];
				}
				else if (r[i]==1)
				{
					if (op->base<0)
						op->base=i;
					else if (op->index<0)
					{
						op->index=i;
						op->scale=1;
					}
					else
					{
						asmerror="Too many registers";
						scan=SCAN_ERR;
						return;
					};
				}
				else 
				{
					asmerror="Invalid scale";
					scan=SCAN_ERR;
					return;
				};
				j++;
			};
			op->type=MRG;
		}; 
	}
	else 
	{
		asmerror="Unrecognized operand";
		scan=SCAN_ERR; 
		return; };
		// In general, address modifier is allowed only with address expression which
		// is a constant, a far address or a memory expression. More precise check
		// will be done later in Assemble().
		if (op->jmpmode!=0 && op->type!=IMM && op->type!=JMF && op->type!=MRG)
		{
			asmerror="Jump address modifier is not allowed";
			scan=SCAN_ERR; 
			return;
		};
		Scanasm(0);                          // Fetch next token from input line
};

// Function assembles text into 32-bit 80x86 machine code. It supports imprecise
// operands (for example, R32 stays for any general-purpose 32-bit register).
// This allows to search for incomplete commands. Command is precise when all
// significant bytes in model.mask are 0xFF. Some commands have more than one
// decoding. By calling Assemble() with attempt=0,1... and constsize=0,1,2,3 one
// gets also alternative variants (bit 0x1 of constsize is responsible for size
// of address constant and bit 0x2 - for immediate data). However, only one
// address form is generated ([EAX*2], but not [EAX+EAX]; [EBX+EAX] but not
// [EAX+EBX]; [EAX] will not use SIB byte; no DS: prefix and so on). Returns
// number of bytes in assembled code or non-positive number in case of detected
// error. This number is the negation of the offset in the input text where the
// error encountered. Unfortunately, BC 4.52 is unable to compile the switch
// (arg) in this code when any common subexpression optimization is on. The
// next #pragma statement disables all optimizations.

//#pragma option -Od                     // No optimizations, or BC 4.52 crashes

int Assemble(char *cmd,ulong ip,t_asmmodel *model,int attempt,int constsize,char *errtext) 
{
	int i,j,k,namelen,nameok,arg,match,datasize,addrsize,bytesize,minop,maxop;
	int rep,lock,segment,jmpsize,jmpmode,longjump;
	int hasrm,hassib,dispsize,immsize;
	int anydisp,anyimm,anyjmp;
	long l,displacement,immediate,jmpoffset = 0;
	char name[32],*nameend;
	char tcode[MAXCMDSIZE],tmask[MAXCMDSIZE];
	t_asmoperand aop[3],*op;             // Up to 3 operands allowed
	const t_cmddata *pd;
	if (model!=NULL) 
		model->length=0;
	if (cmd==NULL || model==NULL || errtext==NULL) 
	{
		if (errtext!=NULL) 
			strcpy(errtext,"Internal OLLYDBG error");
		return 0; 
	};                       // Error in parameters
	asmcmd=cmd;
	rep=lock=0; errtext[0]='\0';
	Scanasm(SA_NAME);
	if (scan==SCAN_EOL)                  // End of line, nothing to assemble
		return 0;
	while (1) 
	{                          // Fetch all REPxx and LOCK prefixes
		if (scan==SCAN_REP || scan==SCAN_REPE || scan==SCAN_REPNE) 
		{
			if (rep!=0)
			{
				strcpy(errtext,"Duplicated REP prefix"); 
				goto error; 
			};
			rep=scan;
		}
		else if (scan==SCAN_LOCK)
		{
			if (lock!=0) 
			{
				strcpy(errtext,"Duplicated LOCK prefix");
				goto error;
			};
			lock=scan;
		}
		else
			break;                        // No more prefixes
		Scanasm(SA_NAME); 
	};
	if (scan!=SCAN_NAME || idata>16) 
	{
		strcpy(errtext,"Command mnemonic expected");
		goto error;
	};
	nameend=asmcmd;
	strupr(sdata);
	// Prepare full mnemonic (including repeat prefix, if any).
	if (rep==SCAN_REP) 
		sprintf(name,"REP %s",sdata);
	else if (rep==SCAN_REPE)
		sprintf(name,"REPE %s",sdata);
	else if (rep==SCAN_REPNE)
		sprintf(name,"REPNE %s",sdata);
	else 
		strcpy(name,sdata);
	Scanasm(0);
	// Parse command operands (up to 3). Note: jump address is always the first
	// (and only) operand in actual command set.
	for (i=0; i<3; i++) 
	{
		aop[i].type=NNN;                   // No operand
		aop[i].size=0;                     // Undefined size
		aop[i].index=-1;                   // No index
		aop[i].scale=0;                    // No scale
		aop[i].base=-1;                    // No base
		aop[i].offset=0;                   // No offset
		aop[i].anyoffset=0;                // No offset
		aop[i].segment=SEG_UNDEF;          // No segment
		aop[i].jmpmode=0;
	};               // No jump size modifier
	Parseasmoperand(aop+0);
	jmpmode=aop[0].jmpmode;
	if (jmpmode!=0) jmpmode|=0x80;
	if (scan==SCAN_SYMB && idata==',') 
	{
		Scanasm(0);
		Parseasmoperand(aop+1);
		if (scan==SCAN_SYMB && idata==',') 
		{
			Scanasm(0);
			Parseasmoperand(aop+2);
		};
	};
	if (scan==SCAN_ERR)
	{
		strcpy(errtext,asmerror); goto error;
	};
	if (scan!=SCAN_EOL) 
	{
		strcpy(errtext,"Extra input after operand");
		goto error;
	};
	// If jump size is not specified, function tries to use short jump. If
	// attempt fails, it retries with long form.
	longjump=0;                          // Try short jump on the first pass
retrylongjump:
	nameok=0;
	// Some commands allow different number of operands. Variables minop and
	// maxop accumulate their minimal and maximal counts. The numbers are not
	// used in assembly process but allow for better error diagnostics.
	minop=3; maxop=0;
	// Main assembly loop: try to find the command which matches all operands,
	// but do not process operands yet.
	namelen=(int)strlen(name);
	for (pd=cmddata; pd->mask!=0; pd++)
	{
		if (pd->name[0]=='&')
		{            // Mnemonic depends on operand size
			j=1;
			datasize=2;
			addrsize=4;
			while (1) 
			{                      // Try all mnemonics (separated by ':')
				for (i=0; pd->name[j]!='\0' && pd->name[j]!=':'; j++)
				{
					if (pd->name[j]=='*') 
					{
						if (name[i]=='W')
						{
							datasize=2;
							i++;
						}
						else if (name[i]=='D')
						{ 
							datasize=4;
							i++;
						}
						else if (sizesens==0) 
							datasize=2;
						else
							datasize=4;
					}
					else if (pd->name[j]==name[i])
						i++;
					else 
						break;
				};
				if (name[i]=='\0' && (pd->name[j]=='\0' || pd->name[j]==':'))
					break;                       // Bingo!
				while (pd->name[j]!='\0' && pd->name[j]!=':')
					j++;
				if (pd->name[j]==':')
				{
					j++; datasize=4;
				}           // Retry with 32-bit mnenonic
				else 
				{
					i=0; 
					break;                  // Comparison failed
				};
			};
			if (i==0) 
				continue; 
		}
		else if (pd->name[0]=='$')	// Mnemonic depends on address size
		{
			j=1;
			datasize=0;
			addrsize=2;
			while (1)
			{                      // Try all mnemonics (separated by ':')
				for (i=0; pd->name[j]!='\0' && pd->name[j]!=':'; j++)
				{
					if (pd->name[j]=='*')
					{
						if (name[i]=='W')
						{
							addrsize=2;
							i++;
						}
						else if (name[i]=='D') 
						{ addrsize=4; i++;
						}
						else if (sizesens==0) 
							addrsize=2;
						else 
							addrsize=4; 
					}
					else if (pd->name[j]==name[i]) 
						i++;
					else 
						break;
				};
				if (name[i]=='\0' && (pd->name[j]=='\0' || pd->name[j]==':'))
					break;                       // Bingo!
				while (pd->name[j]!='\0' && pd->name[j]!=':')
					j++;
				if (pd->name[j]==':') {
					j++; addrsize=4; }           // Retry with 32-bit mnenonic
				else {
					i=0; break;                  // Comparison failed
				};
			};
			if (i==0)
				continue;
		}
		else 
		{                             // Compare with all synonimes
			j=k=0;
			datasize=0;                      // Default settings
			addrsize=4;
			while (1)
			{
				while (pd->name[j]!=',' && pd->name[j]!='\0') 
					j++;
				if (j-k==namelen && strnicmp(name,pd->name+k,namelen)==0)
					break;
				k=j+1; if (pd->name[j]=='\0') 
					break;
				j=k;
			};
			if (k>j) 
				continue;
		};
		// For error diagnostics it is important to know whether mnemonic exists.
		nameok++;
		if (pd->arg1==NNN || pd->arg1>=PSEUDOOP)
			minop=0;
		else if (pd->arg2==NNN || pd->arg2>=PSEUDOOP)
		{
			if (minop>1) minop=1;
			if (maxop<1) maxop=1;
		}
		else if (pd->arg3==NNN || pd->arg3>=PSEUDOOP)
		{
			if (minop>2) minop=2;
			if (maxop<2) maxop=2;
		}
		else
			maxop=3;
		// Determine default and allowed operand size(s).
		if (pd->bits==FF) 
			datasize=2;      // Forced 16-bit size
		if (pd->bits==WW || pd->bits==WS || pd->bits==W3 || pd->bits==WP)
			bytesize=1;                      // 1-byte size allowed
		else
			bytesize=0;                      // Word/dword size only
		// Check whether command operands match specified. If so, variable match
		// remains zero, otherwise it contains kind of mismatch. This allows for
		// better error diagnostics.
		match=0;
		for (j=0; j<3; j++)
		{              // Up to 3 operands
			op=aop+j;
			if (j==0) 
				arg=pd->arg1;
			else if (j==1)
				arg=pd->arg2;
			else 
				arg=pd->arg3;
			if (arg==NNN || arg>=PSEUDOOP)
			{
				if (op->type!=NNN)             // No more arguments
					match|=MA_NOP;
				break;
			};
			if (op->type==NNN)
			{
				match|=MA_NOP;
				break;
			};       // No corresponding operand
			switch (arg) 
			{
			case REG:                      // Integer register in Reg field
			case RCM:                      // Integer register in command byte
			case RAC:                      // Accumulator (AL/AX/EAX, implicit)
				if (op->type!=REG)
					match|=MA_TYP;
				if (arg==RAC && op->index!=REG_EAX && op->index!=8)
					match|=MA_TYP;
				if (bytesize==0 && op->size==1)
					match|=MA_SIZ;
				if (datasize==0)
					datasize=op->size;
				if (datasize!=op->size) 
					match|=MA_DIF;
				break;
			case RG4:                      // Integer 4-byte register in Reg field
				if (op->type!=REG) 
					match|=MA_TYP;
				if (op->size!=4)
					match|=MA_SIZ;
				if (datasize==0) 
					datasize=op->size;
				if (datasize!=op->size)
					match|=MA_DIF;
				break;
			case RAX:                      // AX (2-byte, implicit)
				if (op->type!=REG || (op->index!=REG_EAX && op->index!=8))
					match|=MA_TYP;
				if (op->size!=2) 
					match|=MA_SIZ;
				if (datasize==0) 
					datasize=op->size;
				if (datasize!=op->size)
					match|=MA_DIF;
				break;
			case RDX:                      // DX (16-bit implicit port address)
				if (op->type!=REG || (op->index!=REG_EDX && op->index!=8))
					match|=MA_TYP;
				if (op->size!=2)
					match|=MA_SIZ; 
				break;
			case RCL:                      // Implicit CL register (for shifts)
				if (op->type!=REG || (op->index!=REG_ECX && op->index!=8))
					match|=MA_TYP;
				if (op->size!=1) 
					match|=MA_SIZ;
				break;
			case RS0:                      // Top of FPU stack (ST(0))
				if (op->type!=RST || (op->index!=0 && op->index!=8))
					match|=MA_TYP;
				break;
			case RST:                      // FPU register (ST(i)) in command byte
				if (op->type!=RST)
					match|=MA_TYP;
				break;
			case RMX:                      // MMX register MMx
			case R3D:                      // 3DNow! register MMx
				if (op->type!=RMX)
					match|=MA_TYP;
				break;
			case MRG:                      // Memory/register in ModRM byte
				if (op->type!=MRG && op->type!=REG) 
					match|=MA_TYP;
				if (bytesize==0 && op->size==1)
					match|=MA_SIZ;
				if (datasize==0) 
					datasize=op->size;
				if (op->size!=0 && op->size!=datasize) 
					match|=MA_DIF;
				break;
			case MR1:                      // 1-byte memory/register in ModRM byte
				if (op->type!=MRG && op->type!=REG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=1)
					match|=MA_SIZ;
				break;
			case MR2:                      // 2-byte memory/register in ModRM byte
				if (op->type!=MRG && op->type!=REG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=2)
					match|=MA_SIZ;
				break;
			case MR4:                      // 4-byte memory/register in ModRM byte
				if (op->type!=MRG && op->type!=REG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=4)
					match|=MA_SIZ;
				break;
			case RR4:                      // 4-byte memory/register (register only)
				if (op->type!=REG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=4)
					match|=MA_SIZ;
				break;
			case MRJ:                      // Memory/reg in ModRM as JUMP target
				if (op->type!=MRG && op->type!=REG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=4) 
					match|=MA_SIZ;
				if ((jmpmode & 0x09)!=0) 
					match|=MA_JMP;
				jmpmode&=0x7F;
				break;
			case MR8:                      // 8-byte memory/MMX register in ModRM
			case MRD:                      // 8-byte memory/3DNow! register in ModRM
				if (op->type!=MRG && op->type!=RMX)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=8) 
					match|=MA_SIZ;
				break;
			case RR8:                      // 8-byte MMX register only in ModRM
			case RRD:                      // 8-byte memory/3DNow! (register only)
				if (op->type!=RMX) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=8) 
					match|=MA_SIZ;
				break;
			case MMA:                      // Memory address in ModRM byte for LEA
				if (op->type!=MRG)
					match|=MA_TYP;
				break;
			case MML:                      // Memory in ModRM byte (for LES)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=6)
					match|=MA_SIZ;
				if (datasize==0)
					datasize=4;
				else if (datasize!=4) 
					match|=MA_DIF;
				break;
			case MMS:                      // Memory in ModRM byte (as SEG:OFFS)
				if (op->type!=MRG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=6)
					match|=MA_SIZ;
				if ((jmpmode & 0x07)!=0) 
					match|=MA_JMP;
				jmpmode&=0x7F;
				break;
			case MM6:                      // Memory in ModRm (6-byte descriptor)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=6)
					match|=MA_SIZ;
				break;
			case MMB:                      // Two adjacent memory locations (BOUND)
				if (op->type!=MRG) 
					match|=MA_TYP;
				k=op->size; 
				if (ideal==0 && k>1) 
					k/=2;
				if (k!=0 && k!=datasize)
					match|=MA_DIF;
				break;
			case MD2:                      // Memory in ModRM byte (16-bit integer)
			case MB2:                      // Memory in ModRM byte (16-bit binary)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=2)
					match|=MA_SIZ;
				break;
			case MD4:                      // Memory in ModRM byte (32-bit integer)
			case MF4:                      // Memory in ModRM byte (32-bit float)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=4) 
					match|=MA_SIZ;
				break;
			case MD8:                      // Memory in ModRM byte (64-bit integer)
			case MF8:                      // Memory in ModRM byte (64-bit float)
				if (op->type!=MRG)
					match|=MA_TYP;
				if (op->size!=0 && op->size!=8)
					match|=MA_SIZ;
				break;
			case MDA:                      // Memory in ModRM byte (80-bit BCD)
			case MFA:                      // Memory in ModRM byte (80-bit float)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0 && op->size!=10)
					match|=MA_SIZ;
				break;
			case MFE:                      // Memory in ModRM byte (FPU environment)
			case MFS:                      // Memory in ModRM byte (FPU state)
			case MFX:                      // Memory in ModRM byte (ext. FPU state)
				if (op->type!=MRG) 
					match|=MA_TYP;
				if (op->size!=0)
					match|=MA_SIZ;
				break;
			case MSO:                      // Source in string operands ([ESI])
				if (op->type!=MRG || op->base!=REG_ESI || op->index!=-1 || op->offset!=0 || op->anyoffset!=0)
					match|=MA_TYP;
				if (datasize==0)
					datasize=op->size;
				if (op->size!=0 && op->size!=datasize) 
					match|=MA_DIF;
				break;
			case MDE:                      // Destination in string operands ([EDI])
				if (op->type!=MRG || op->base!=REG_EDI || op->index!=-1 || op->offset!=0 || op->anyoffset!=0)
					match|=MA_TYP;
				if (op->segment!=SEG_UNDEF && op->segment!=SEG_ES)
					match|=MA_SEG;
				if (datasize==0)
					datasize=op->size;
				if (op->size!=0 && op->size!=datasize)
					match|=MA_DIF;
				break;
			case MXL:                      // XLAT operand ([EBX+AL])
				if (op->type!=MXL) 
					match|=MA_TYP;
				break;
			case IMM:                      // Immediate data (8 or 16/32)
			case IMU:                      // Immediate unsigned data (8 or 16/32)
				if (op->type!=IMM)
					match|=MA_TYP;
				break;
			case VXD:                      // VxD service (32-bit only)
				if (op->type!=IMM)
					match|=MA_TYP;
				if (datasize==0)
					datasize=4;
				if (datasize!=4) 
					match|=MA_SIZ;
				break;
			case JMF:                      // Immediate absolute far jump/call addr
				if (op->type!=JMF) 
					match|=MA_TYP;
				if ((jmpmode & 0x05)!=0)
					match|=MA_JMP;
				jmpmode&=0x7F;
				break;
			case JOB:                      // Immediate byte offset (for jumps)
				if (op->type!=IMM || longjump)
					match|=MA_TYP;
				if ((jmpmode & 0x0A)!=0)
					match|=MA_JMP;
				jmpmode&=0x7F;
				break;
			case JOW:                      // Immediate full offset (for jumps)
				if (op->type!=IMM)
					match|=MA_TYP;
				if ((jmpmode & 0x09)!=0) 
					match|=MA_JMP;
				jmpmode&=0x7F;
				break;
			case IMA:                      // Immediate absolute near data address
				if (op->type!=MRG || op->base>=0 || op->index>=0)
					match|=MA_TYP;
				break;
			case IMX:                      // Immediate sign-extendable byte
				if (op->type!=IMM)
					match|=MA_TYP;
				if (op->offset<-128 || op->offset>127) 
					match|=MA_RNG;
				break;
			case C01:                      // Implicit constant 1 (for shifts)
				if (op->type!=IMM || (op->offset!=1 && op->anyoffset==0))
					match|=MA_TYP;
				break;
			case IMS:                      // Immediate byte (for shifts)
			case IM1:                      // Immediate byte
				if (op->type!=IMM)
					match|=MA_TYP;
				if (op->offset<-128 || op->offset>255)
					match|=MA_RNG;
				break;
			case IM2:                      // Immediate word (ENTER/RET)
				if (op->type!=IMM)
					match|=MA_TYP;
				if (op->offset<0 || op->offset>65535)
					match|=MA_RNG;
				break;
			case SGM:                      // Segment register in ModRM byte
				if (op->type!=SGM)
					match|=MA_TYP;
				if (datasize==0) 
					datasize=2;
				if (datasize!=2) 
					match|=MA_DIF;
				break;
			case SCM:                      // Segment register in command byte
				if (op->type!=SGM)
					match|=MA_TYP;
				break;
			case CRX:                      // Control register CRx
			case DRX:                      // Debug register DRx
				if (op->type!=arg)
					match|=MA_TYP;
				if (datasize==0) 
					datasize=4;
				if (datasize!=4) 
					match|=MA_DIF;
				break;
			case PRN:                      // Near return address (pseudooperand)
			case PRF:                      // Far return address (pseudooperand)
			case PAC:                      // Accumulator (AL/AX/EAX, pseudooperand)
			case PAH:                      // AH (in LAHF/SAHF, pseudooperand)
			case PFL:                      // Lower byte of flags (pseudooperand)
			case PS0:                      // Top of FPU stack (pseudooperand)
			case PS1:                      // ST(1) (pseudooperand)
			case PCX:                      // CX/ECX (pseudooperand)
			case PDI:                      // EDI (pseudooperand in MMX extentions)
				break;
			default:                       // Undefined type of operand
				strcpy(errtext,"Internal Assembler error");
				goto error;
			};                               // End of switch (arg)
			if ((jmpmode & 0x80)!=0)
				match|=MA_JMP;
			if (match!=0) 
				break;             // Some of the operands doesn't match
		};                                 // End of operand matching loop
		if (match==0)
		{                    // Exact match found
			if (attempt>0)
			{
				--attempt;
				nameok=0;
			}         // Well, try to find yet another match
			else
				break;
		};
	};                                   // End of command search loop
	// Check whether some error was detected. If several errors were found
	// similtaneously, report one (roughly in order of significance).
	if (nameok==0) 
	{                     // Mnemonic unavailable
		strcpy(errtext,"Unrecognized command");
		asmcmd=nameend; goto error; 
	};
	if (match!=0)
	{                      // Command not found
		if (minop>0 && aop[minop-1].type==NNN)
			strcpy(errtext,"Too few operands");
		else if (maxop<3 && aop[maxop].type!=NNN)
			strcpy(errtext,"Too many operands");
		else if (nameok>1)                 // More that 1 command
			strcpy(errtext,"Command does not support given operands");
		else if (match & MA_JMP)
			strcpy(errtext,"Invalid jump size modifier");
		else if (match & MA_NOP)
			strcpy(errtext,"Wrong number of operands");
		else if (match & MA_TYP)
			strcpy(errtext,"Command does not support given operands");
		else if (match & MA_NOS)
			strcpy(errtext,"Please specify operand size");
		else if (match & MA_SIZ)
			strcpy(errtext,"Bad operand size");
		else if (match & MA_DIF)
			strcpy(errtext,"Different size of operands");
		else if (match & MA_SEG)
			strcpy(errtext,"Invalid segment register");
		else if (match & MA_RNG)
			strcpy(errtext,"Constant out of expected range");
		else
			strcpy(errtext,"Erroneous command");
		goto error;
	};
	// Exact match found. Now construct the code.
	hasrm=0;                             // Whether command has ModR/M byte
	hassib=0;                            // Whether command has SIB byte
	dispsize=0;                          // Size of displacement (if any)
	immsize=0;                           // Size of immediate data (if any)
	segment=SEG_UNDEF;                   // Necessary segment prefix
	jmpsize=0;                           // No relative jumps
	memset(tcode,0,sizeof(tcode));
	*(ulong *)tcode=pd->code & pd->mask;
	memset(tmask,0,sizeof(tmask));
	*(ulong *)tmask=pd->mask;
	i=pd->len-1;                         // Last byte of command itself
	if (rep) i++;                        // REPxx prefixes count as extra byte
	// In some cases at least one operand must have explicit size declaration (as
	// in MOV [EAX],1). This preliminary check does not include all cases.
	if (pd->bits==WW || pd->bits==WS || pd->bits==WP)
	{
		if (datasize==0) 
		{
			strcpy(errtext,"Please specify operand size");
			goto error; 
		}
		else if (datasize>1)
			tcode[i]|=0x01;                  // WORD or DWORD size of operands
		tmask[i]|=0x01;
	}
	else if (pd->bits==W3) 
	{
		if (datasize==0) 
		{
			strcpy(errtext,"Please specify operand size");
			goto error; 
		}
		else if (datasize>1)
			tcode[i]|=0x08;                  // WORD or DWORD size of operands
		tmask[i]|=0x08;
	};
	// Present suffix of 3DNow! command as immediate byte operand.
	if ((pd->type & C_TYPEMASK)==C_NOW)
	{
		immsize=1;
		immediate=(pd->code>>16) & 0xFF;
	};
	// Process operands again, this time constructing the code.
	anydisp=anyimm=anyjmp=0;
	for (j=0; j<3; j++)
	{                // Up to 3 operands
		op=aop+j;
		if (j==0) 
			arg=pd->arg1;
		else if 
			(j==1) arg=pd->arg2;
		else
			arg=pd->arg3;
		if (arg==NNN)
			break;               // All operands processed
		switch (arg)
		{
		case REG:                        // Integer register in Reg field
		case RG4:                        // Integer 4-byte register in Reg field
		case RMX:                        // MMX register MMx
		case R3D:                        // 3DNow! register MMx
		case CRX:                        // Control register CRx
		case DRX:                        // Debug register DRx
			hasrm=1;
			if (op->index<8) 
			{
				tcode[i+1]|=(char)(op->index<<3); 
				tmask[i+1]|=0x38; 
			};
			break;
		case RCM:                        // Integer register in command byte
		case RST:                        // FPU register (ST(i)) in command byte
			if (op->index<8)
			{
				tcode[i]|=(char)op->index; 
				tmask[i]|=0x07; 
			};
			break;
		case RAC:                        // Accumulator (AL/AX/EAX, implicit)
		case RAX:                        // AX (2-byte, implicit)
		case RDX:                        // DX (16-bit implicit port address)
		case RCL:                        // Implicit CL register (for shifts)
		case RS0:                        // Top of FPU stack (ST(0))
		case MDE:                        // Destination in string op's ([EDI])
		case C01:                        // Implicit constant 1 (for shifts)
			break;                         // Simply skip implicit operands
		case MSO:                        // Source in string op's ([ESI])
		case MXL:                        // XLAT operand ([EBX+AL])
			if (op->segment!=SEG_UNDEF && op->segment!=SEG_DS)
				segment=op->segment;
			break;
		case MRG:                        // Memory/register in ModRM byte
		case MRJ:                        // Memory/reg in ModRM as JUMP target
		case MR1:                        // 1-byte memory/register in ModRM byte
		case MR2:                        // 2-byte memory/register in ModRM byte
		case MR4:                        // 4-byte memory/register in ModRM byte
		case RR4:                        // 4-byte memory/register (register only)
		case MR8:                        // 8-byte memory/MMX register in ModRM
		case RR8:                        // 8-byte MMX register only in ModRM
		case MRD:                        // 8-byte memory/3DNow! register in ModRM
		case RRD:                        // 8-byte memory/3DNow! (register only)
			hasrm=1;
			if (op->type!=MRG) 
			{           // Register in ModRM byte
				tcode[i+1]|=0xC0;
				tmask[i+1]|=0xC0;
				if (op->index<8) 
				{
					tcode[i+1]|=(char)op->index; 
					tmask[i+1]|=0x07; 
				};
				break;
			};                             // Note: NO BREAK, continue with address
		case MMA:                        // Memory address in ModRM byte for LEA
		case MML:                        // Memory in ModRM byte (for LES)
		case MMS:                        // Memory in ModRM byte (as SEG:OFFS)
		case MM6:                        // Memory in ModRm (6-byte descriptor)
		case MMB:                        // Two adjacent memory locations (BOUND)
		case MD2:                        // Memory in ModRM byte (16-bit integer)
		case MB2:                        // Memory in ModRM byte (16-bit binary)
		case MD4:                        // Memory in ModRM byte (32-bit integer)
		case MD8:                        // Memory in ModRM byte (64-bit integer)
		case MDA:                        // Memory in ModRM byte (80-bit BCD)
		case MF4:                        // Memory in ModRM byte (32-bit float)
		case MF8:                        // Memory in ModRM byte (64-bit float)
		case MFA:                        // Memory in ModRM byte (80-bit float)
		case MFE:                        // Memory in ModRM byte (FPU environment)
		case MFS:                        // Memory in ModRM byte (FPU state)
		case MFX:                        // Memory in ModRM byte (ext. FPU state)
			hasrm=1; displacement=op->offset; anydisp=op->anyoffset;
			if (op->base<0 && op->index<0) 
			{
				dispsize=4;                  // Special case of immediate address
				if (op->segment!=SEG_UNDEF && op->segment!=SEG_DS)
					segment=op->segment;
				tcode[i+1]|=0x05;
				tmask[i+1]|=0xC7; }
			else if (op->index<0 && op->base!=REG_ESP) 
			{
				tmask[i+1]|=0xC0;            // SIB byte unnecessary
				if (op->offset==0 && op->anyoffset==0 && op->base!=REG_EBP)
					;                          // [EBP] always requires offset
				else if ((constsize & 1)!=0 && ((op->offset>=-128 && op->offset<128) || op->anyoffset!=0) )
				{
					tcode[i+1]|=0x40;          // Disp8
					dispsize=1;
				}
				else 
				{
					tcode[i+1]|=0x80;          // Disp32
					dispsize=4;
				};
				if (op->base<8)
				{
					if (op->segment!=SEG_UNDEF && op->segment!=addr32[op->base].defseg)
						segment=op->segment;
					tcode[i+1]|= (char)op->base;          // Note that case [ESP] has base<0.
					tmask[i+1]|=0x07;
				}
				else 
					segment=op->segment; 
			}
			else 
			{                         // SIB byte necessary
				hassib=1;
				if (op->base==REG_EBP &&     // EBP as base requires offset, optimize
					op->index>=0 && op->scale==1 && op->offset==0 && op->anyoffset==0)
				{
					op->base=op->index; op->index=REG_EBP;
				};
				if (op->index==REG_ESP &&    // ESP cannot be an index, reorder
					op->scale<=1) 
				{
					op->index=op->base; op->base=REG_ESP; op->scale=1;
				};
				if (op->base<0 &&            // No base means 4-byte offset, optimize
					op->index>=0 && op->scale==2 &&
					op->offset>=-128 && op->offset<128 && op->anyoffset==0)
				{
					op->base=op->index; op->scale=1;
				};
				if (op->index==REG_ESP)
				{    // Reordering was unsuccessfull
					strcpy(errtext,"Invalid indexing mode");
					goto error;
				};
				if (op->base<0) 
				{
					tcode[i+1]|=0x04;
					dispsize=4; 
				}
				else if (op->offset==0 && op->anyoffset==0 && op->base!=REG_EBP)
					tcode[i+1]|=0x04;          // No displacement
				else if ((constsize & 1)!=0 && ((op->offset>=-128 && op->offset<128) || op->anyoffset!=0) )
				{
					tcode[i+1]|=0x44;          // Disp8
					dispsize=1;
				}
				else
				{
					tcode[i+1]|=0x84;          // Disp32
					dispsize=4; };
					tmask[i+1]|=0xC7;            // ModRM completed, proceed with SIB
					if (op->scale==2)
						tcode[i+2]|=0x40;
					else if (op->scale==4)
						tcode[i+2]|=0x80;
					else if (op->scale==8)
						tcode[i+2]|=0xC0;
					tmask[i+2]|=0xC0;
					if (op->index<8) 
					{
						if (op->index<0)
							op->index=0x04;
						tcode[i+2]|=(char)(op->index<<3);
						tmask[i+2]|=0x38;
					};
					if (op->base<8) 
					{
						if (op->base<0)
							op->base=0x05;
						if (op->segment!=SEG_UNDEF && op->segment!=addr32[op->base].defseg)
							segment=op->segment;
						tcode[i+2]|=(char)op->base;
						tmask[i+2]|=0x07;
					}
					else 
						segment=op->segment; 
			};
			break;
		case IMM:                        // Immediate data (8 or 16/32)
		case IMU:                        // Immediate unsigned data (8 or 16/32)
		case VXD:                        // VxD service (32-bit only)
			if (datasize==0 && pd->arg2==NNN && (pd->bits==SS || pd->bits==WS))
				datasize=4;
			if (datasize==0)
			{
				strcpy(errtext,"Please specify operand size");
				goto error;
			};
			immediate=op->offset; anyimm=op->anyoffset;
			if (pd->bits==SS || pd->bits==WS) 
			{
				if (datasize>1 && (constsize & 2)!=0 && ((immediate>=-128 && immediate<128) || op->anyoffset!=0)) 
				{
					immsize=1; tcode[i]|=0x02;
				}
				else
					immsize=datasize;
				tmask[i]|=0x02;
			}
			else
				immsize=datasize;
			break;
		case IMX:                        // Immediate sign-extendable byte
		case IMS:                        // Immediate byte (for shifts)
		case IM1:                        // Immediate byte
			if (immsize==2)                // To accomodate ENTER instruction
				immediate=(immediate & 0xFFFF) | (op->offset<<16);
			else
				immediate=op->offset;
			anyimm|=op->anyoffset;
			immsize++;
			break;
		case IM2:                        // Immediate word (ENTER/RET)
			immediate=op->offset; anyimm=op->anyoffset;
			immsize=2; 
			break;
		case IMA:                        // Immediate absolute near data address
			if (op->segment!=SEG_UNDEF && op->segment!=SEG_DS)
				segment=op->segment;
			displacement=op->offset;
			anydisp=op->anyoffset;
			dispsize=4;
			break;
		case JOB:                        // Immediate byte offset (for jumps)
			jmpoffset=op->offset; 
			anyjmp=op->anyoffset;
			jmpsize=1; 
			break;
		case JOW:                        // Immediate full offset (for jumps)
			jmpoffset=op->offset;
			anyjmp=op->anyoffset;
			jmpsize=4;
			break;
		case JMF:                        // Immediate absolute far jump/call addr
			displacement=op->offset;
			anydisp=op->anyoffset;
			dispsize=4;
			immediate=op->segment;
			anyimm=op->anyoffset; 
			immsize=2;
			break;
		case SGM:                        // Segment register in ModRM byte
			hasrm=1;
			if (op->index<6)
			{
				tcode[i+1]|=(char)(op->index<<3); 
				tmask[i+1]|=0x38;
			};
			break;
		case SCM:                        // Segment register in command byte
			if (op->index==SEG_FS || op->index==SEG_GS) 
			{
				tcode[0]=0x0F; tmask[0]=0xFF;
				i=1;
				if (strcmp(name,"PUSH")==0)
					tcode[i]=(char)((op->index<<3) | 0x80);
				else
					tcode[i]=(char)((op->index<<3) | 0x81);
				tmask[i]=0xFF; 
			}
			else if (op->index<6) 
			{
				if (op->index==SEG_CS && strcmp(name,"POP")==0)
				{
					strcpy(errtext,"Unable to POP CS");
					goto error;
				};
				tcode[i]=(char)((tcode[i] & 0xC7) | (op->index<<3)); }
			else
			{
				tcode[i]&=0xC7;
				tmask[i]&=0xC7;
			};
			break;
		case PRN:                        // Near return address (pseudooperand)
		case PRF:                        // Far return address (pseudooperand)
		case PAC:                        // Accumulator (AL/AX/EAX, pseudooperand)
		case PAH:                        // AH (in LAHF/SAHF, pseudooperand)
		case PFL:                        // Lower byte of flags (pseudooperand)
		case PS0:                        // Top of FPU stack (pseudooperand)
		case PS1:                        // ST(1) (pseudooperand)
		case PCX:                        // CX/ECX (pseudooperand)
		case PDI:                        // EDI (pseudooperand in MMX extentions)
			break;                         // Simply skip preudooperands
		default:                         // Undefined type of operand
			strcpy(errtext,"Internal Assembler error");
			goto error;
		};
	};
	// Gather parts of command together in the complete command.
	j=0;
	if (lock!=0) 
	{                       // Lock prefix specified
		model->code[j]=0xF0;
		model->mask[j]=0xFF; 
		j++;
	};
	if (datasize==2 && pd->bits!=FF)
	{   // Data size prefix necessary
		model->code[j]=0x66;
		model->mask[j]=0xFF; 
		j++; 
	};
	if (addrsize==2)
	{                   // Address size prefix necessary
		model->code[j]=0x67;
		model->mask[j]=0xFF;
		j++;
	};
	if (segment!=SEG_UNDEF) 
	{            // Segment prefix necessary
		if (segment==SEG_ES) 
			model->code[j]=0x26;
		else if (segment==SEG_CS) 
			model->code[j]=0x2E;
		else if (segment==SEG_SS)
			model->code[j]=0x36;
		else if (segment==SEG_DS)
			model->code[j]=0x3E;
		else if (segment==SEG_FS)
			model->code[j]=0x64;
		else if (segment==SEG_GS)
			model->code[j]=0x65;
		else 
		{ 
			strcpy(errtext,"Internal Assembler error");
			goto error;
		};
		model->mask[j]=0xFF; 
		j++; 
	};
	if (dispsize>0)
	{
		memcpy(tcode+i+1+hasrm+hassib,&displacement,dispsize);
		if (anydisp==0) 
			memset(tmask+i+1+hasrm+hassib,0xFF,dispsize);
	};
	if (immsize>0) 
	{
		if (immsize==1)
			l=0xFFFFFF00L;
		else if (immsize==2)
			l=0xFFFF0000L;
		else 
			l=0L;
		if ((immediate & l)!=0 && (immediate & l)!=l)
		{
			strcpy(errtext,"Constant does not fit into operand");
			goto error;
		};
		memcpy(tcode+i+1+hasrm+hassib+dispsize,&immediate,immsize);
		if (anyimm==0)
			memset(tmask+i+1+hasrm+hassib+dispsize,0xFF,immsize);
	};
	i=i+1+hasrm+hassib+dispsize+immsize;
	jmpoffset=jmpoffset-(i+j+jmpsize);
	model->jmpsize=jmpsize;
	model->jmpoffset=jmpoffset;
	model->jmppos=i+j;
	if (jmpsize!=0)
	{
		if (ip!=0)
		{
			jmpoffset=jmpoffset-ip;
			if (jmpsize==1 && anyjmp==0 && (jmpoffset<-128 || jmpoffset>=128))
			{
				if (longjump==0 && (jmpmode & 0x03)==0)
				{
					longjump=1;
					goto retrylongjump;
				};
				sprintf(errtext,"Relative jump out of range, use %s LONG form",name);
				goto error;
			};
			memcpy(tcode+i,&jmpoffset,jmpsize);
		};
		if (anyjmp==0) 
			memset(tmask+i,0xFF,jmpsize);
		i+=jmpsize;
	};
	memcpy(model->code+j,tcode,i);
	memcpy(model->mask+j,tmask,i);
	i+=j;
	model->length=i;
	return i;                            // Positive value: length of code
error:
	model->length=0;
	return (int)(cmd-asmcmd);                   // Negative value: position of error
};

//#pragma option -O.                     // Restore old optimization options

  
```

`vm-packer/反汇编/反汇编/ASM/disasm.cpp`:

```cpp
// Free Disassembler and Assembler -- Disassembler
//
// Copyright (C) 2001 Oleh Yuschuk
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


#define STRICT

#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
//#include <dir.h>
#include <math.h>
#include <float.h>
#pragma hdrstop

#pragma   warning(disable:4996)//关闭旧函数声明警告

#include "disasm.h"

//bughoho. 文件扩展名改为cpp.把外部扩展变量在cpp中添加声明
int       ideal;                // Force IDEAL decoding mode
int       lowercase;            // Force lowercase display
int       tabarguments;         // Tab between mnemonic and arguments
int       extraspace;           // Extra space between arguments
int       putdefseg;            // Display default segments in listing
int       showmemsize;          // Always show memory size
int       shownear;             // Show NEAR modifiers
int       shortstringcmds;      // Use short form of string commands
int       sizesens;             // How to decode size-sensitive mnemonics
int       symbolic;             // Show symbolic addresses in disasm
int       farcalls;             // Accept far calls, returns & addresses
int       decodevxd;            // Decode VxD calls (Win95/98)
int       privileged;           // Accept privileged commands
int       iocommand;            // Accept I/O commands
int       badshift;             // Accept shift out of range 1..31
int       extraprefix;          // Accept superfluous prefixes
int       lockedbus;            // Accept LOCK prefixes
int       stackalign;           // Accept unaligned stack operations
int       iswindowsnt;          // When checking for dangers, assume NT
////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DISASSEMBLER FUNCTIONS ////////////////////////////

// Work variables of disassembler
static ulong     datasize;             // Size of data (1,2,4 bytes)
static ulong     addrsize;             // Size of address (2 or 4 bytes)
static int       segprefix;            // Segment override prefix or SEG_UNDEF
static int       hasrm;                // Command has ModR/M byte
static int       hassib;               // Command has SIB byte
static int       dispsize;             // Size of displacement (if any)
static int       immsize;              // Size of immediate data (if any)
static int       softerror;            // Noncritical disassembler error
static int       ndump;                // Current length of command dump
static int       nresult;              // Current length of disassembly
static int       addcomment;           // Comment value of operand

// Copy of input parameters of function Disasm()
static char      *cmd;                 // Pointer to binary data
static char      *pfixup;              // Pointer to possible fixups or NULL
static ulong     size;                 // Remaining size of the command buffer
static t_disasm  *da;                  // Pointer to disassembly results
static int       mode;                 // Disassembly mode (DISASM_xxx)

// Disassemble name of 1, 2 or 4-byte general-purpose integer register and, if
// requested and available, dump its contents. Parameter type changes decoding
// of contents for some operand types.
//static void DecodeRG(int index,int datasize,int type)
//bughoho void 改为 int 返回解码得到的寄存器索引
static int DecodeRG(int index,int datasize,int type) 
{
	int sizeindex;
	char name[9];
	if (mode<DISASM_DATA) 
		return -1;        // No need to decode

	sprintf_s(da->vm_name,"%s_REG%02d",da->vm_name,datasize*8);
	da->optype[stoperand] = Reg;

	index&=0x07;//得到寄存器索引
	if (datasize==1)
		sizeindex=0;
	else if (datasize==2)
		sizeindex=1;
	else if (datasize==4)
		sizeindex=2;
	else 
	{
		da->error=DAE_INTERN;
		return -1; 
	}
	if (mode>=DISASM_FILE)
	{
		strcpy(name,regname[sizeindex][index]);
		if (lowercase)
			strlwr(name);
		if (type<PSEUDOOP)                 // Not a pseudooperand
			nresult+=sprintf(da->result+nresult,"%s",name);
		//bughoho
		if( sizeindex == 0 && ( index > 3 && index < 7 ) )
		{
			//为高位
			da->highbit[stoperand] = true;
		}
	}

	da->reg[stoperand] = index;
	return index;
}

// Disassemble name of 80-bit floating-point register and, if available, dump
// its contents.
static void DecodeST(int index,int pseudoop) 
{
  int i;
  char s[32];
  if (mode<DISASM_FILE)
	  return;        // No need to decode
  index&=0x07;
  i=sprintf(s,"%s(%i)",(lowercase?"st":"ST"),index);
  if (pseudoop==0)
  {
    strcpy(da->result+nresult,s);
    nresult+=i;
  }
}

// Disassemble name of 64-bit MMX register.
static void DecodeMX(int index)
{
  char *pr;
  if (mode<DISASM_FILE)
	  return;        // No need to decode
  index&=0x07;
  pr=da->result+nresult;
  nresult+=sprintf(pr,"%s%i",(lowercase?"mm":"MM"),index);
}

// Disassemble name of 64-bit 3DNow! register and, if available, dump its
// contents.
static void DecodeNR(int index)
{
  char *pr;
  if (mode<DISASM_FILE)
	  return;        // No need to decode
  index&=0x07;
  pr=da->result+nresult;
  nresult+=sprintf(pr,"%s%i",(lowercase?"mm":"MM"),index);
};

// Service function, adds valid memory adress in MASM or Ideal format to
// disassembled string. Parameters: defseg - default segment for given
// register combination, descr - fully decoded register part of address,
// offset - constant part of address, dsize - data size in bytes. If global
// flag 'symbolic' is set, function also tries to decode offset as name of
// some label.
static void Memadr(int defseg,const char *descr,long offset,int dsize)
{
  int i,n,seg;
  char *pr;
  char s[TEXTLEN];
  if (mode<DISASM_FILE || descr==NULL)
    return;                            // No need or possibility to decode

  char segstr[32] = {0};
  if( da->segment != SEG_UNDEF )
  {
	  if( da->segment == SEG_FS )
		  strcpy(segstr,"FS");
	  else if( da->segment != SEG_UNDEF && da->segment == SEG_GS )
		  strcpy(segstr,"GS");
  }
  sprintf_s(da->vm_name,"%s_%sMEM%02d",da->vm_name,segstr,dsize*8);
  da->optype[stoperand] = Mem;

  pr=da->result+nresult; n=0;
  if (segprefix!=SEG_UNDEF) 
	  seg=segprefix; 
  else seg=defseg;
  if (ideal!=0) 
	  pr[n++]='[';
  // In some cases Disassembler may omit size of memory operand. Namely, flag
  // showmemsize must be 0, type bit C_EXPL must be 0 (this bit namely means
  // that explicit operand size is necessary) and type of command must not be
  // C_MMX or C_NOW (because bit C_EXPL has in these cases different meaning).
  // Otherwise, exact size must be supplied.
  if ( showmemsize!=0 || (da->cmdtype & C_TYPEMASK)==C_MMX ||
    (da->cmdtype & C_TYPEMASK)==C_NOW || (da->cmdtype & C_EXPL)!=0 ) 
  {
    if (dsize<sizeof(sizename)/sizeof(sizename[0]))
      n+=sprintf(pr+n,"%s %s",sizename[dsize],(ideal==0?"PTR ":""));
    else
      n+=sprintf(pr+n,"(%i-BYTE) %s",dsize,(ideal==0?"PTR ":""));
  }
  if ((putdefseg!=0 || seg!=defseg) && seg!=SEG_UNDEF)
    n += sprintf(pr+n,"%s:",segname[seg]);
  if (ideal==0)
	  pr[n++]='[';
  n += sprintf(pr+n,"%s",descr);
  if (lowercase)
	  strlwr(pr);
  if (offset==0L) 
  {
    if (*descr=='\0') pr[n++]='0';
  }
  else
  {
    if (symbolic && mode>=DISASM_CODE)
      i=Decodeaddress(offset,s,TEXTLEN-n-24,NULL);
    else 
		i=0;
    if (i>0)
	{                         // Offset decoded in symbolic form
      if (*descr!='\0') pr[n++]='+';
      strcpy(pr+n,s); n+=i; 
	}
    else if (offset<0 && offset>-16384 && *descr!='\0')
      n+=sprintf(pr+n,"-%lX",-offset);
    else
	{
      if (*descr!='\0') 
		  pr[n++]='+';
      n+=sprintf(pr+n,"%lX",offset);
    };
  };
  pr[n++]=']'; pr[n]='\0';
  nresult+=n;
};

// Disassemble memory/register from the ModRM/SIB bytes and, if available, dump
// address and contents of memory.
static void DecodeMR(int type) 
{
	int j,memonly,inmemory,seg;
	int c,sib;
	ulong dsize,regsize,addr;
	char s[TEXTLEN];
	if (size<2)
	{
		da->error=DAE_CROSS;
		return;
	}    // ModR/M byte outside the memory block
	hasrm=1;
	dsize=regsize=datasize;              // Default size of addressed reg/memory
	memonly=0;                           // Register in ModM field is allowed
	// Size and kind of addressed memory or register in ModM has no influence on
	// the command size, and exact calculations are omitted if only command size
	// is requested. If register is used, optype will be incorrect and we need
	// to correct it later.
	c=cmd[1] & 0xC7;                     // Leave only Mod and M fields
	if (mode>=DISASM_DATA) 
	{
		if ((c & 0xC0)==0xC0)              // Register operand
			inmemory=0;
		else                               // Memory operand
			inmemory=1;
		//判断是内存操作数还是寄存器操作数,并确定长度
		switch (type)
		{
		case MRG:                        // Memory/register in ModRM byte
			if (inmemory) 
			{
				if (datasize==1) 
					da->memtype=DEC_BYTE;
				else if (datasize==2) 
					da->memtype=DEC_WORD;
				else
					da->memtype=DEC_DWORD;
			}
			break;
		case MRJ:                        // Memory/reg in ModRM as JUMP target
			if (datasize!=2 && inmemory)
				da->memtype=DEC_DWORD;
			if (mode>=DISASM_FILE && shownear!=0)
				nresult+=sprintf(da->result+nresult,"%s ",(lowercase?"near":"NEAR"));
			break;
		case MR1:                        // 1-byte memory/register in ModRM byte
			dsize=regsize=1;
			if (inmemory) da->memtype=DEC_BYTE; 
			break;
		case MR2:                        // 2-byte memory/register in ModRM byte
			dsize=regsize=2;
			if (inmemory) da->memtype=DEC_WORD;
			break;
		case MR4:                        // 4-byte memory/register in ModRM byte
		case RR4:                        // 4-byte memory/register (register only)
			dsize=regsize=4;
			if (inmemory) da->memtype=DEC_DWORD;
			break;
		case MR8:                        // 8-byte memory/MMX register in ModRM
		case RR8:                        // 8-byte MMX register only in ModRM
			dsize=8;
			if (inmemory) da->memtype=DEC_QWORD; 
			break;
		case MRD:                        // 8-byte memory/3DNow! register in ModRM
		case RRD:                        // 8-byte memory/3DNow! (register only)
			dsize=8;
			if (inmemory) da->memtype=DEC_3DNOW;
			break;
		case MMA:                        // Memory address in ModRM byte for LEA
			memonly=1; 
			break;
		case MML:                        // Memory in ModRM byte (for LES)
			dsize=datasize+2; memonly=1;
			if (datasize==4 && inmemory)
				da->memtype=DEC_FWORD;
			da->warnings|=DAW_SEGMENT;
			break;
		case MMS:                        // Memory in ModRM byte (as SEG:OFFS)
			dsize=datasize+2; memonly=1;
			if (datasize==4 && inmemory)
				da->memtype=DEC_FWORD;
			if (mode>=DISASM_FILE)
				nresult+=sprintf(da->result+nresult,"%s ",(lowercase?"far":"FAR"));
			break;
		case MM6:                        // Memory in ModRM (6-byte descriptor)
			dsize=6; memonly=1;
			if (inmemory) da->memtype=DEC_FWORD;
			break;
		case MMB:                        // Two adjacent memory locations (BOUND)
			dsize=(ideal?datasize:datasize*2); memonly=1;
			break;
		case MD2:                        // Memory in ModRM byte (16-bit integer)
		case MB2:                        // Memory in ModRM byte (16-bit binary)
			dsize=2; memonly=1;
			if (inmemory) da->memtype=DEC_WORD;
			break;
		case MD4:                        // Memory in ModRM byte (32-bit integer)
			dsize=4; memonly=1;
			if (inmemory) da->memtype=DEC_DWORD;
			break;
		case MD8:                        // Memory in ModRM byte (64-bit integer)
			dsize=8; memonly=1;
			if (inmemory) da->memtype=DEC_QWORD;
			break;
		case MDA:                        // Memory in ModRM byte (80-bit BCD)
			dsize=10; memonly=1;
			if (inmemory) da->memtype=DEC_TBYTE;
			break;
		case MF4:                        // Memory in ModRM byte (32-bit float)
			dsize=4; memonly=1;
			if (inmemory) da->memtype=DEC_FLOAT4;
			break;
		case MF8:                        // Memory in ModRM byte (64-bit float)
			dsize=8; memonly=1;
			if (inmemory) da->memtype=DEC_FLOAT8;
			break;
		case MFA:                        // Memory in ModRM byte (80-bit float)
			dsize=10; memonly=1;
			if (inmemory) da->memtype=DEC_FLOAT10;
			break;
		case MFE:                        // Memory in ModRM byte (FPU environment)
			dsize=28; memonly=1;
			break;
		case MFS:                        // Memory in ModRM byte (FPU state)
			dsize=108; memonly=1;
			break;
		case MFX:                        // Memory in ModRM byte (ext. FPU state)
			dsize=512; memonly=1;
			break;
		default:                         // Operand is not in ModM!
			da->error=DAE_INTERN;
			break;
		};
	};
	addr=0;
	// There are many possibilities to decode ModM/SIB address. The first
	// possibility is register in ModM - general-purpose, MMX or 3DNow!
	//为0xC0时则是寄存器
	if ((c & 0xC0)==0xC0) 
	{              // Decode register operand
		if (type==MR8 || type==RR8)
			DecodeMX(c);                     // MMX register
		else if (type==MRD || type==RRD)
			DecodeNR(c);                     // 3DNow! register
		else
		{
			DecodeRG(c,regsize,type);        // General-purpose register
		}
		if (memonly!=0)
			softerror=DAE_MEMORY;            // Register where only memory allowed
		return; 
	}
	// Next possibility: 16-bit addressing mode, very seldom in 32-bit flat model
	// but still supported by processor. SIB byte is never used here.
	// 下一个可能: 16位地址模式.在32位平坦模式下很少见但是处理器仍然支持
	if (addrsize==2)
	{
		if (c==0x06) 
		{                     // Special case of immediate address
			dispsize=2;
			if (size<4)
				da->error=DAE_CROSS;           // Disp16 outside the memory block
			else if (mode>=DISASM_DATA) 
			{
				da->adrconst=addr=*(ushort *)(cmd+2);
				if (addr==0) da->zeroconst=1;
				seg=SEG_DS;
				Memadr(seg,"",addr,dsize);
			} 
		}
		else 
		{
			da->indexed=1;
			if ((c & 0xC0)==0x40) 
			{          // 8-bit signed displacement
				if (size<3) 
					da->error=DAE_CROSS;
				else
					addr=(signed char)cmd[2] & 0xFFFF;
				dispsize=1;
			}
			else if ((c & 0xC0)==0x80) 
			{     // 16-bit unsigned displacement
				if (size<4) 
					da->error=DAE_CROSS;
				else
					addr=*(ushort *)(cmd+2);
				dispsize=2; 
			}
			if (mode>=DISASM_DATA && da->error==DAE_NOERR)
			{
				da->adrconst=addr;
				if (addr==0)
					da->zeroconst=1;
				seg=addr16[c & 0x07].defseg;
				Memadr(seg,addr16[c & 0x07].descr,addr,dsize);
			}
		}
	}
	// Next possibility: immediate 32-bit address.
	// 下一个可能 : 32位立即数的内存地址
	else if (c==0x05) 
	{                  // Special case of immediate address
		dispsize=4;
		if (size<6)
			da->error=DAE_CROSS;             // Disp32 outside the memory block
		else if (mode>=DISASM_DATA) 
		{
			da->adrconst=addr=*(ulong *)(cmd+2);
			if (pfixup==NULL) 
				pfixup=cmd+2;
			da->fixupsize+=4;
			if (addr==0)
				da->zeroconst=1;
			seg=SEG_DS;
			Memadr(seg,"",addr,dsize);
		}
	}
	// Next possibility: 32-bit address with SIB byte.
	else if ((c & 0x07)==0x04) 
	{         // SIB addresation
		sib=cmd[2]; hassib=1;
		*s='\0';
		if (c==0x04 && (sib & 0x07)==0x05)
		{
			dispsize=4;                      // Immediate address without base
			if (size<7)
				da->error=DAE_CROSS;           // Disp32 outside the memory block
			else 
			{
				da->adrconst=addr=*(ulong *)(cmd+3);
				if (pfixup==NULL) 
					pfixup=cmd+3;
				da->fixupsize+=4;
				if (addr==0) 
					da->zeroconst=1;
				if ((sib & 0x38)!=0x20) 
				{      // Index register present
					da->indexed=1;
					if (type==MRJ)
						da->jmptable=addr; };
					seg=SEG_DS;
			}
		}
		else
		{                             // Base and, eventually, displacement
			if ((c & 0xC0)==0x40)
			{          // 8-bit displacement
				dispsize=1;
				if (size<4) 
					da->error=DAE_CROSS;
				else
				{
					da->adrconst=addr=(signed char)cmd[3];
					if (addr==0) da->zeroconst=1;
				}
			}
			else if ((c & 0xC0)==0x80) 
			{     // 32-bit displacement
				dispsize=4;
				if (size<7)
					da->error=DAE_CROSS;         // Disp32 outside the memory block
				else
				{
					da->adrconst=addr=*(ulong *)(cmd+3);
					if (pfixup==NULL)
						pfixup=cmd+3;
					da->fixupsize+=4;
					if (addr==0)
						da->zeroconst=1;
					// Most compilers use address of type [index*4+displacement] to
					// address jump table (switch). But, for completeness, I allow all
					// cases which include index with scale 1 or 4, base or both.
					if (type==MRJ)
						da->jmptable=addr;
				}
			}
			da->indexed=1;
			j=sib & 0x07;
			if (mode>=DISASM_FILE)
			{
				strcpy(s,regname[2][j]);
				seg=addr32[j].defseg;

				da->addrreg1 = j;//
			}
		}
		if ((sib & 0x38)!=0x20) 
		{          // Scaled index present
			if ((sib & 0xC0)==0x40) 
				da->indexed=2;
			else if ((sib & 0xC0)==0x80)
				da->indexed=4;
			else if ((sib & 0xC0)==0xC0)
				da->indexed=8;
			else
				da->indexed=1;
		};
		if (mode>=DISASM_FILE && da->error==DAE_NOERR) 
		{
			if ((sib & 0x38)!=0x20)
			{        // Scaled index present
				if (*s!='\0') 
					strcat(s,"+");
				strcat(s,addr32[(sib>>3) & 0x07].descr);
				da->regsscale = 1;
				da->addrreg2 = (sib>>3) & 0x07;//第2个寄存器偏移
				if ((sib & 0xC0)==0x40) 
				{
					da->jmptable=0;              // Hardly a switch!
					strcat(s,"*2");
					da->regsscale = 2;
				}
				else if ((sib & 0xC0)==0x80)
				{
					strcat(s,"*4");
					da->regsscale = 4;
				}
				else if ((sib & 0xC0)==0xC0) 
				{
					da->jmptable=0;              // Hardly a switch!
					strcat(s,"*8");
					da->regsscale = 8;
				}
			}
			Memadr(seg,s,addr,dsize);
		};
	}
	// Last possibility: 32-bit address without SIB byte.
	// 最后一个可能: 32位地址
	else
	{                               // No SIB
		if ((c & 0xC0)==0x40)
		{
			dispsize=1;
			if (size<3)
				da->error=DAE_CROSS; // Disp8 outside the memory block
			else 
			{
				da->adrconst=addr=(signed char)cmd[2];
				if (addr==0) 
					da->zeroconst=1;
			}
		}
		else if ((c & 0xC0)==0x80)
		{
			dispsize=4;
			if (size<6)
				da->error=DAE_CROSS;           // Disp32 outside the memory block
			else 
			{
				da->adrconst=addr=*(ulong *)(cmd+2);
				if (pfixup==NULL) 
					pfixup=cmd+2;
				da->fixupsize+=4;
				if (addr==0) 
					da->zeroconst=1;
				if (type==MRJ) 
					da->jmptable=addr;
			}
		}
		da->indexed=1;
		if (mode>=DISASM_FILE && da->error==DAE_NOERR) 
		{
			seg=addr32[c & 0x07].defseg;
			da->addrreg1 = (c & 0x07);
			Memadr(seg,addr32[c & 0x07].descr,addr,dsize);
		}
	}
}

// Disassemble implicit source of string operations and, if available, dump
// address and contents.
//static void DecodeSO(void)
static int DecodeSO(void)
{
	if (mode<DISASM_FILE)
		return -1;        // No need to decode
	if (datasize==1) 
		da->memtype=DEC_BYTE;
	else if (datasize==2)
		da->memtype=DEC_WORD;
	else if (datasize==4)
		da->memtype=DEC_DWORD;
	da->indexed=1;
	Memadr(SEG_DS,regname[addrsize==2?1:2][REG_ESI],0L,datasize);

	da->reg[stoperand] = REG_ESI;
	return REG_ESI;
}

// Disassemble implicit destination of string operations and, if available,
// dump address and contents. Destination always uses segment ES, and this
// setting cannot be overridden.
//static void DecodeDE(void) 
static int DecodeDE(void) 
{
	int seg;
	if (mode<DISASM_FILE) 
		return -1;        // No need to decode
	if (datasize==1)
		da->memtype=DEC_BYTE;
	else if (datasize==2)
		da->memtype=DEC_WORD;
	else if (datasize==4)
		da->memtype=DEC_DWORD;
	da->indexed=1;
	seg = segprefix; 
	segprefix=SEG_ES;     // Fake Memadr by changing segment prefix
	Memadr(SEG_DS,regname[addrsize==2?1:2][REG_EDI],0L,datasize);
	segprefix=seg;                       // Restore segment prefix

	da->reg[stoperand] = REG_EDI;
	return REG_EDI;
};

// Decode XLAT operand and, if available, dump address and contents.
static void DecodeXL(void)
{
  if (mode<DISASM_FILE)
	  return;        // No need to decode
  da->memtype=DEC_BYTE;
  da->indexed=1;
  Memadr(SEG_DS,(addrsize==2?"BX+AL":"EBX+AL"),0L,1);
};

// Decode immediate operand of size constsize. If sxt is non-zero, byte operand
// should be sign-extended to sxt bytes. If type of immediate constant assumes
// this, small negative operands may be displayed as signed negative numbers.
// Note that in most cases immediate operands are not shown in comment window.
static void DecodeIM(int constsize,int sxt,int type) 
{
  int i;
  signed long data;
  ulong l;
  char name[TEXTLEN],comment[TEXTLEN] = {0};
  immsize+=constsize;                    // Allows several immediate operands
  if (mode<DISASM_DATA)
	  return;

  //sprintf_s(da->vm_name,"%s_IMM%02d",da->vm_name,constsize*8);
  sprintf_s(da->vm_name,"%s_IMM32",da->vm_name);//IMM只有32位
  da->optype[stoperand] = Imm;

  l=1+hasrm+hassib+dispsize+(immsize-constsize);
  data=0;
  if (size<l+constsize)
    da->error=DAE_CROSS;
  else if (constsize==1) 
  {
    if (sxt==0) 
		data=(uchar)cmd[l];
    else 
		data=(signed char)cmd[l];
    if (type==IMS && ((data & 0xE0)!=0 || data==0)) 
	{
      da->warnings|=DAW_SHIFT;
      da->cmdtype|=C_RARE;
    }
  }
  else if (constsize==2) 
  {
    if (sxt==0) 
		data=*(ushort *)(cmd+l);
    else 
		data=*(short *)(cmd+l);
  }
  else 
  {
    data=*(long *)(cmd+l);
    if (pfixup==NULL)
		pfixup=cmd+l;
    da->fixupsize+=4;
  }
  if (sxt==2)
	  data&=0x0000FFFF;
  if (data==0 && da->error==0)
	  da->zeroconst=1;
  // Command ENTER, as an exception from Intel's rules, has two immediate
  // constants. As the second constant is rarely used, I exclude it from
  // search if the first constant is non-zero (which is usually the case).
  if (da->immconst==0)
    da->immconst=data;
  if (mode>=DISASM_FILE && da->error==DAE_NOERR) 
  {
    if (mode>=DISASM_CODE && type!=IMU)
      i=Decodeaddress(data,name,TEXTLEN-nresult-24,comment);
    else 
	{
      i=0; comment[0]='\0'; 
	}
    if (i!=0 && symbolic!=0)
	{
      strcpy(da->result+nresult,name); nresult+=i;
	}
    else if (type==IMU || type==IMS || type==IM2 || data>=0 || data<NEGLIMIT)
      nresult+=sprintf(da->result+nresult,"%lX",data);
    else
      nresult+=sprintf(da->result+nresult,"-%lX",-data);
    if (addcomment && comment[0]!='\0')
		strcpy(da->comment,comment);
  }
}

// Decode VxD service name (always 4-byte).
static void DecodeVX(void) 
{
  ulong l,data;
  immsize+=4;                          // Allows several immediate operands
  if (mode<DISASM_DATA) 
	  return;
  l=1+hasrm+hassib+dispsize+(immsize-4);
  if (size<l+4) 
  {
    da->error=DAE_CROSS;
    return;
  }
  data=*(long *)(cmd+l);
  if (data==0 && da->error==0)
	  da->zeroconst=1;
  if (da->immconst==0)
    da->immconst=data;
  if (mode>=DISASM_FILE && da->error==DAE_NOERR)
  {
    if ((data & 0x00008000)!=0 && memicmp("VxDCall",da->result,7)==0)
      memcpy(da->result,lowercase?"vxdjump":"VxDJump",7);
    nresult+=sprintf(da->result+nresult,"%lX",data);
  }
}

// Decode implicit constant 1 (used in shift commands). This operand is so
// insignificant that it is never shown in comment window.
static void DecodeC1(void)
{
  if (mode<DISASM_DATA)
	  return;
  da->immconst=1;
  if (mode>=DISASM_FILE) 
	  nresult+=sprintf(da->result+nresult,"1");
}

// Decode immediate absolute data address. This operand is used in 8080-
// compatible commands which allow to move data from memory to accumulator and
// back. Note that bytes ModRM and SIB never appear in commands with IA operand.
static void DecodeIA(void) 
{
  ulong addr;
  if (size<1+addrsize) 
  {
    da->error=DAE_CROSS; 
	return; 
  };
  dispsize=addrsize;
  if (mode<DISASM_DATA) 
	  return;
  if (datasize==1) 
	  da->memtype=DEC_BYTE;
  else if (datasize==2)
	  da->memtype=DEC_WORD;
  else if (datasize==4)
	  da->memtype=DEC_DWORD;
  if (addrsize==2)
    addr=*(ushort *)(cmd+1);
  else
  {
    addr=*(ulong *)(cmd+1);
    if (pfixup==NULL) 
		pfixup=cmd+1;
    da->fixupsize+=4; 
  }
  da->adrconst=addr;
  if (addr==0)
	  da->zeroconst=1;
  if (mode>=DISASM_FILE)
  {
    Memadr(SEG_DS,"",addr,datasize);
  }
}

// Decodes jump relative to nextip of size offsize.
static void DecodeRJ(ulong offsize,ulong nextip)
{
	sprintf_s(da->vm_name,"%s_IMM%02d",da->vm_name,4*8);//不管长跳短跳都认为是32位地址
	da->optype[stoperand] = Imm;
	int i;
	ulong addr;
	char s[TEXTLEN];
	if (size<offsize+1) 
	{
		da->error=DAE_CROSS; 
		return; 
	}
	dispsize=offsize;                    // Interpret offset as displacement
	if (mode<DISASM_DATA)
		return;
	if (offsize==1)//短跳转
	{
		addr=(signed char)cmd[1]+nextip;
	}
	else if (offsize==2)
		addr=*(signed short *)(cmd+1)+nextip;
	else
		addr=*(ulong *)(cmd+1)+nextip;
	if (datasize==2)
		addr&=0xFFFF;
	da->jmpconst=addr;
	if (addr==0) 
		da->zeroconst=1;
	if (mode>=DISASM_FILE)
	{
		if (offsize==1) 
			nresult+=sprintf(da->result+nresult, "%s ",(lowercase==0?"SHORT":"short"));
		if (mode>=DISASM_CODE)
			i=Decodeaddress(addr,s,TEXTLEN,da->comment);
		else
			i=0;
		if (symbolic==0 || i==0)
			nresult+=sprintf(da->result+nresult,"%08lX",addr);
		else
			nresult+=sprintf(da->result+nresult,"%.*s",TEXTLEN-nresult-25,s);
		if (symbolic==0 && i!=0 && da->comment[0]=='\0')
			strcpy(da->comment,s);
	}
}

// Decode immediate absolute far jump address. In flat model, such addresses
// are not used (mostly because selector is specified directly in the command),
// so I neither decode as symbol nor comment it. To allow search for selector
// by value, I interprete it as an immediate constant.
static void DecodeJF(void)
{
	ulong addr,seg;
	if (size<1+addrsize+2)
	{
		da->error=DAE_CROSS;
		return;
	}
	dispsize=addrsize; immsize=2;        // Non-trivial but allowed interpretation
	if (mode<DISASM_DATA)
		return;
	if (addrsize==2) 
	{
		addr=*(ushort *)(cmd+1);
		seg=*(ushort *)(cmd+3);
	}
	else
	{
		addr=*(ulong *)(cmd+1);
		seg=*(ushort *)(cmd+5);
	}
	da->jmpconst=addr;
	da->immconst=seg;
	if (addr==0 || seg==0)
		da->zeroconst=1;
	if (mode>=DISASM_FILE)
	{
		nresult+=sprintf(da->result+nresult,"%s %04X:%08X",(lowercase==0?"FAR":"far"),seg,addr);
	}
}

// Decode segment register. In flat model, operands of this type are seldom.
static void DecodeSG(int index) 
{
	int i;
	if (mode<DISASM_DATA)
		return;

	index&=0x07;
	if (index>=6) 
		softerror=DAE_BADSEG;  // Undefined segment register

	sprintf_s(da->vm_name,"%s_%s",da->vm_name,segname[index]);
	da->optype[stoperand] = Seg;

	if (mode>=DISASM_FILE) 
	{
		da->segreg = index;
		i=sprintf(da->result+nresult,"%s",segname[index]);
		if (lowercase)
			strlwr(da->result+nresult);
		nresult+=i;
	}
}

// Decode control register addressed in R part of ModRM byte. Operands of
// this type are extremely rare. Contents of control registers are accessible
// only from privilege level 0, so I cannot dump them here.
static void DecodeCR(int index)
{
  hasrm=1;
  if (mode>=DISASM_FILE)
  {
    index=(index>>3) & 0x07;
    nresult+=sprintf(da->result+nresult,"%s",crname[index]);
    if (lowercase)
		strlwr(da->result+nresult);
  }
}

// Decode debug register addressed in R part of ModRM byte. Operands of
// this type are extremely rare. I can dump only those debug registers
// available in CONTEXT structure.
static void DecodeDR(int index) 
{
  int i;
  hasrm=1;
  if (mode>=DISASM_FILE) 
  {
    index=(index>>3) & 0x07;
    i=sprintf(da->result+nresult,"%s",drname[index]);
    if (lowercase)
		strlwr(da->result+nresult);
    nresult+=i;
  }
}

// Skips 3DNow! operands and extracts command suffix. Returns suffix or -1 if
// suffix lies outside the memory block. This subroutine assumes that cmd still
// points to the beginning of 3DNow! command (i.e. to the sequence of two bytes
// 0F, 0F).
static int Get3dnowsuffix(void)
{
  int c,sib;
  ulong offset;
  if (size<3) 
	  return -1;               // Suffix outside the memory block
  offset=3;
  c=cmd[2] & 0xC7;                     // Leave only Mod and M fields
  // Register in ModM - general-purpose, MMX or 3DNow!
  if ((c & 0xC0)==0xC0)
    ;
  // 16-bit addressing mode, SIB byte is never used here.
  else if (addrsize==2)
  {
    if (c==0x06)                       // Special case of immediate address
      offset+=2;
    else if ((c & 0xC0)==0x40)         // 8-bit signed displacement
      offset++;
    else if ((c & 0xC0)==0x80)         // 16-bit unsigned displacement
      offset+=2;
  }
  // Immediate 32-bit address.
  else if (c==0x05)                    // Special case of immediate address
    offset+=4;
  // 32-bit address with SIB byte.
  else if ((c & 0x07)==0x04)
  {         // SIB addresation
    if (size<4) 
		return -1;             // Suffix outside the memory block
    sib=cmd[3]; 
	offset++;
    if (c==0x04 && (sib & 0x07)==0x05)
      offset+=4;                       // Immediate address without base
    else if ((c & 0xC0)==0x40)         // 8-bit displacement
      offset+=1;
    else if ((c & 0xC0)==0x80)         // 32-bit dislacement
      offset+=4;
  }
  // 32-bit address without SIB byte
  else if ((c & 0xC0)==0x40)
    offset+=1;
  else if ((c & 0xC0)==0x80)
    offset+=4;
  if (offset>=size) 
	  return -1;         // Suffix outside the memory block
  return cmd[offset];
}

// Function checks whether 80x86 flags meet condition set in the command.
// Returns 1 if condition is met, 0 if not and -1 in case of error (which is
// not possible).
int Checkcondition(int code,ulong flags)
{
  ulong cond,temp;
  switch (code & 0x0E) 
  {
    case 0:                            // If overflow
      cond=flags & 0x0800;
	  break;
    case 2:                            // If below
      cond=flags & 0x0001;
	  break;
    case 4:                            // If equal
      cond=flags & 0x0040;
	  break;
    case 6:                            // If below or equal
      cond=flags & 0x0041; 
	  break;
    case 8:                            // If sign
      cond=flags & 0x0080; 
	  break;
    case 10:                           // If parity
      cond=flags & 0x0004;
	  break;
    case 12:                           // If less
      temp=flags & 0x0880;
      cond=(temp==0x0800 || temp==0x0080); 
	  break;
    case 14:                           // If less or equal
      temp=flags & 0x0880;
      cond=(temp==0x0800 || temp==0x0080 || (flags & 0x0040)!=0);
	  break;
    default:
		return -1;                // Internal error, not possible!
  }
  if ((code & 0x01)==0)
	  return (cond!=0);
  else
	  return (cond==0);               // Invert condition
}


//bughoho
int stoperand = 0;
ulong Disasm(char *src,ulong srcsize,ulong srcip,t_disasm *disasm,int disasmmode) 
{
  int i,j,isprefix,is3dnow,repeated,operand,mnemosize,arg = 0;
  ulong u,code;
  int lockprefix;                      // Non-zero if lock prefix present
  int repprefix;                       // REPxxx prefix or 0
  int cxsize;
  char name[TEXTLEN],*pname;
  const t_cmddata *pd,*pdan;
  // Prepare disassembler variables and initialize structure disasm.
  //初始化结构和变量
  datasize=addrsize=4;                 // 32-bit code and data segments only!
  segprefix=SEG_UNDEF;
  hasrm=hassib=0; dispsize=immsize=0;
  lockprefix=0; repprefix=0;
  ndump=0; nresult=0;
  cmd=src; size=srcsize; pfixup=NULL;
  softerror=0; is3dnow=0;
  da=disasm;
  da->ip=srcip;
  da->comment[0]='\0';
  da->cmdtype=C_BAD; da->nprefix=0;
  da->memtype=DEC_UNKNOWN; da->indexed=0;
  da->jmpconst=0; da->jmptable=0;
  da->adrconst=0; da->immconst=0;
  da->zeroconst=0;
  da->fixupoffset=0; da->fixupsize=0;
  da->warnings=0;
  da->error=DAE_NOERR;
  mode=disasmmode;                     // No need to use register contents

  da->optype[0] = da->optype[1] = da->optype[2] = -1;
  da->reg[0] = da->reg[1] = da->reg[2] = -1;
  da->segreg = -1;
  da->addrreg1 = da->addrreg2 = -1;
  da->regsscale = 1;
  memset(da->hexcode,0,TEXTLEN);
  da->codelen = 0;
  da->highbit[0] = da->highbit[1] = da->highbit[2] = false;
  // Correct 80x86 command may theoretically contain up to 4 prefixes belonging
  // to different prefix groups. This limits maximal possible size of the
  // command to MAXCMDSIZE=16 bytes. In order to maintain this limit, if
  // Disasm() detects second prefix from the same group, it flushes first
  // prefix in the sequence as a pseudocommand.
  u=0; repeated=0;
  while (size>0)
  {
	  isprefix=1;                        // Assume that there is some prefix
	  switch (*cmd)
	  {
	  case 0x26:
		  if (segprefix==SEG_UNDEF)
			  segprefix=SEG_ES;
		  else repeated=1;
		  break;
	  case 0x2E: 
		  if (segprefix==SEG_UNDEF)
			  segprefix=SEG_CS;
		  else repeated=1; 
		  break;
	  case 0x36:
		  if (segprefix==SEG_UNDEF)
			  segprefix=SEG_SS;
		  else repeated=1;
		  break;
	  case 0x3E: 
		  if (segprefix==SEG_UNDEF) 
			  segprefix=SEG_DS;
		  else repeated=1;
		  break;
	  case 0x64:
		  if (segprefix==SEG_UNDEF) 
			  segprefix=SEG_FS;
		  else repeated=1; 
		  break;
	  case 0x65: 
		  if (segprefix==SEG_UNDEF)
			  segprefix=SEG_GS;
		  else repeated=1;
		  break;
	  case 0x66:
		  if (datasize==4) 
			  datasize=2;
		  else repeated=1; 
		  break;
	  case 0x67: 
		  if (addrsize==4) 
			  addrsize=2;
		  else repeated=1;
		  break;
	  case 0xF0: 
		  if (lockprefix==0)
			  lockprefix=0xF0;
		  else repeated=1; 
		  break;
	  case 0xF2:
		  if (repprefix==0) 
			  repprefix=0xF2;
		  else repeated=1;
		  break;
	  case 0xF3: 
		  if (repprefix==0) 
			  repprefix=0xF3;
		  else repeated=1;
		  break;
	  default: 
		  isprefix=0;
		  break;
	  }
	  if (isprefix==0 || repeated!=0)
		  break;                           // No more prefixes or duplicated prefix
	  if (mode>=DISASM_FILE)
	  {
		  ndump+=sprintf(da->dump+ndump,"%02X:",*cmd);
		  da->hexcode[da->codelen++] = *cmd;
	  }
	  da->nprefix++;
	  cmd++; srcip++; size--; u++; 
  }
  //bughoho
  da->segment = segprefix;//得到段寄存器
  // We do have repeated prefix. Flush first prefix from the sequence.
  if (repeated)
  {
	  if (mode>=DISASM_FILE) 
	  {
		  da->dump[3]='\0';                // Leave only first dumped prefix
		  da->nprefix=1;
		  switch (cmd[-(long)u])//cmd++ 且 u++;这里是得到cmd[0]
		  {
		  case 0x26: pname=(char *)(segname[SEG_ES]); 
			  break;
		  case 0x2E: pname=(char *)(segname[SEG_CS]);
			  break;
		  case 0x36: pname=(char *)(segname[SEG_SS]);
			  break;
		  case 0x3E: pname=(char *)(segname[SEG_DS]);
			  break;
		  case 0x64: pname=(char *)(segname[SEG_FS]);
			  break;
		  case 0x65: pname=(char *)(segname[SEG_GS]); 
			  break;
		  case 0x66: pname="DATASIZE";
			  break;
		  case 0x67: pname="ADDRSIZE";
			  break;
		  case 0xF0: pname="LOCK";
			  break;
		  case 0xF2: pname="REPNE";
			  break;
		  case 0xF3: pname="REPE";
			  break;
		  default: pname="?";
			  break; 
		  }
		  nresult+=sprintf(da->result+nresult,"PREFIX %s:",pname);
		  if (lowercase)
			  strlwr(da->result);
		  if (extraprefix==0) 
			  strcpy(da->comment,"Superfluous prefix");
	  }
	  da->warnings |= DAW_PREFIX;
	  if (lockprefix)
		  da->warnings |= DAW_LOCK;
	  da->cmdtype=C_RARE;
	  return 1;                          // Any prefix is 1 byte long
  }
  // If lock prefix available, display it and forget, because it has no
  // influence on decoding of rest of the command.
  if (lockprefix!=0) 
  {
	  if (mode>=DISASM_FILE) 
		  nresult+=sprintf(da->result+nresult,"LOCK ");
	  da->warnings |= DAW_LOCK;
  }
  // Fetch (if available) first 3 bytes of the command, add repeat prefix and
  // find command in the command table.
  //取得命令的头三个字节
  code=0;
  if (size>0) 
	  *(((char *)&code)+0)=cmd[0];
  if (size>1)
	  *(((char *)&code)+1)=cmd[1];
  if (size>2) 
	  *(((char *)&code)+2)=cmd[2];
  if (repprefix!=0)                    // RER/REPE/REPNE is considered to be
	  code=(code<<8) | repprefix;        // part of command.
  if (decodevxd && (code & 0xFFFF)==0x20CD)
	  pd=&vxdcmd;                        // Decode VxD call (Win95/98)
  else
  {
	  for (pd=cmddata; pd->mask!=0; pd++) //从指令表中搜索
	  {
		  if (((code^pd->code) & pd->mask)!=0)
			  continue;
		  if (mode>=DISASM_FILE && shortstringcmds &&								//如果是反汇编模式,并且Use short form of string commands
			  (pd->arg1==MSO || pd->arg1==MDE || pd->arg2==MSO || pd->arg2==MDE))     //如果寄存器是ESI或EDI
			  continue;                      // Search short form of string command
		  break;
	  }
  }
  if ( (pd->type & C_TYPEMASK) == C_NOW) //如果是3DNow指令
  {
	  // 3DNow! commands require additional search.
	  is3dnow=1;
	  j=Get3dnowsuffix();
	  if (j<0)
		  da->error=DAE_CROSS;
	  else 
	  {
		  for( ; pd->mask!=0; pd++)
		  {
			  if (((code^pd->code) & pd->mask)!=0)
				  continue;
			  if (((uchar *)&(pd->code))[2]==j) 
				  break;
		  }
	  }
  }

  //bughoho 
  da->is3dnow = is3dnow;//是否是3DNow!指令

  if (pd->mask==0)    //命令未找到
  {                   // Command not found
	  da->cmdtype=C_BAD;
	  if (size<2) 
		  da->error=DAE_CROSS;
	  else 
		  da->error=DAE_BADCMD; 
  }
  else//命令经过认证
  {                               // Command recognized, decode it
	  da->cmdtype=pd->type;//命令类型(附加信息)
	  cxsize=datasize;                 // Default size of ECX used as counter //ECX记数器的默认长度
	  if (segprefix==SEG_FS || segprefix==SEG_GS || lockprefix!=0)
		  da->cmdtype|=C_RARE;             // These prefixes are rare //出现很少的命令
	  if (pd->bits==PR)//特权指令
		  da->warnings|=DAW_PRIV;          // Privileged command (ring 0)
	  else if (pd->bits==WP)//IO命令
		  da->warnings|=DAW_IO;            // I/O command
	  // Win32 programs usually try to keep stack dword-aligned, so INC ESP
	  // (44) and DEC ESP (4C) usually don't appear in real code. Also check for
	  // ADD ESP,imm and SUB ESP,imm (81,C4,imm32; 83,C4,imm8; 81,EC,imm32;
	  // 83,EC,imm8).
	  //WIN32程序通常会保持栈的四字节对齐,所以inc esp,dec esp一般不会出现在平常的代码中,
	  //同样检测add esp,imm 和 sub esp,imm.
	  if (	cmd[0]==0x44 || cmd[0]==0x4C ||
		  (size>=3 && (cmd[0]==0x81 || cmd[0]==0x83) &&
		  (cmd[1]==0xC4 || cmd[1]==0xEC) && (cmd[2] & 0x03)!=0) )
	  {
		  da->warnings|=DAW_STACK;//栈警告
		  da->cmdtype|=C_RARE;	  //不常出现的指令
	  }
	  // Warn also on MOV SEG,... (8E...). Win32 works in flat mode.
	  //警告 mov seg,xxx 操作,因为Win32工作在平坦模式
	  if (cmd[0]==0x8E)
		  da->warnings|=DAW_SEGMENT;
	  // If opcode is 2-byte, adjust command.
	  //如果操作码是2字节的则调整命令
	  if (pd->len==2) 
	  {
		  if (size==0)
			  da->error=DAE_CROSS;
		  else 
		  {
			  if (mode>=DISASM_FILE)
			  {
				  ndump+=sprintf(da->dump+ndump,"%02X",*cmd);
				  da->hexcode[da->codelen++] = *cmd;
			  }
			  cmd++; 
			  srcip++;
			  size--;
		  }
	  }
	  if (size==0) 
		  da->error=DAE_CROSS;
	  // Some commands either feature non-standard data size or have bit which
	  // allowes to select data size.
	  //一些命令的数据长度不是标准的,可以改变长度大小
	  if ((pd->bits & WW)!=0 && (*cmd & WW)==0)
		  datasize=1;                      // Bit W in command set to 0
	  else if ((pd->bits & W3)!=0 && (*cmd & W3)==0)
		  datasize=1;                      // Another position of bit W
	  else if ((pd->bits & FF)!=0)
		  datasize=2;                      // Forced word (2-byte) size
	  // Some commands either have mnemonics which depend on data size (8/16 bits
	  // or 32 bits, like CWD/CDQ), or have several different mnemonics (like
	  // JNZ/JNE). First case is marked by either '&' (mnemonic depends on
	  // operand size) or '$' (depends on address size). In the second case,
	  // there is no special marker and disassembler selects main mnemonic.
	  if (mode>=DISASM_FILE) 
	  {
		  if (pd->name[0]=='&')
			  mnemosize=datasize;
		  else if (pd->name[0]=='$')
			  mnemosize=addrsize;
		  else mnemosize=0;
		  if (mnemosize!=0)
		  {
			  for (i=0,j=1; pd->name[j]!='\0'; j++) 
			  {
				  if (pd->name[j]==':')
				  {      // Separator between 16/32 mnemonics
					  if (mnemosize==4) 
						  i=0;
					  else break;
				  }
				  else if (pd->name[j]=='*') 
				  { // Substitute by 'W', 'D' or none
					  if (mnemosize==4 && sizesens!=2)
						  name[i++]='D';
					  else if (mnemosize!=4 && sizesens!=0)
						  name[i++]='W';
				  }
				  else 
					  name[i++]=pd->name[j];
			  }
			  name[i]='\0'; 
		  }
		  else
		  {
			  strcpy(name,pd->name);
			  for (i=0; name[i]!='\0'; i++)
			  {
				  if (name[i]==',') 
				  {          // Use main mnemonic
					  name[i]='\0';
					  break;
				  }
			  }
		  }
		  if (repprefix!=0 && tabarguments) 
		  {
			  for (i=0; name[i]!='\0' && name[i]!=' '; i++)
				  da->result[nresult++]=name[i];
			  if (name[i]==' ') 
			  {
				  da->result[nresult++]=' '; i++; 
			  }
			  while(nresult<8) 
				  da->result[nresult++]=' ';
			  for ( ; name[i]!='\0'; i++)
				  da->result[nresult++]=name[i];
		  }
		  else
			  nresult+=sprintf(da->result+nresult,"%s",name);
		  if (lowercase) 
			  strlwr(da->result);
		  sprintf_s(da->vm_name,"V%s",name);
	  }
	  // Decode operands (explicit - encoded in command, implicit - present in
	  // mmemonic or assumed - used or modified by command). Assumed operands
	  // must stay after all explicit and implicit operands. Up to 3 operands
	  // are allowed.
	  for (operand=0; operand<3; operand++)
	  {
		  stoperand = operand;
		  if (da->error)
			  break;            // Error - no sense to continue
		  //If command contains both source and destination, one usually must not
		  //decode destination to comment because it will be overwritten on the
		  //next step. Global addcomment takes care of this. Decoding routines,
		  //however, may ignore this flag.
		  if (operand==0 && pd->arg2!=NNN && pd->arg2<PSEUDOOP)
			  addcomment=0;
		  else
			  addcomment=1;
		  // Get type of next argument.
		  if (operand==0)
			  arg=pd->arg1;
		  else if (operand==1)
			  arg=pd->arg2;
		  else 
			  arg=pd->arg3;
		  if (arg==NNN) 
			  break;             //没有更多的操作数了 No more operands
		  // Arguments with arg>=PSEUDOOP are assumed operands and are not
		  // displayed in disassembled result, so they require no delimiter.
		  if ((mode>=DISASM_FILE) && arg<PSEUDOOP)//添加间隔
		  {
			  if (operand==0)//如果是命令
			  {
				  da->result[nresult++]=' ';
				  if (tabarguments)
				  {
					  while (nresult<8) da->result[nresult++]=' ';
				  }
			  }
			  else//如果是操作数
			  {
				  da->result[nresult++]=',';
				  if (extraspace) da->result[nresult++]=' ';
			  }
		  }
		  // Decode, analyse and comment next operand of the command.
		  //解码,分析和注释命令的下一个操作数
		  switch (arg) 
		  {
		  case REG:                      // Integer register in Reg field
			  if (size<2)
				  da->error=DAE_CROSS;
			  else
			  {
				  DecodeRG(cmd[1]>>3,datasize,REG);
			  }
			  hasrm=1; 
			  break;
		  case RCM:                      // Integer register in command byte
			  DecodeRG(cmd[0],datasize,RCM);
			  break;
		  case RG4:                      // Integer 4-byte register in Reg field
			  if (size<2)
				  da->error=DAE_CROSS;
			  else
			  {
				  DecodeRG(cmd[1]>>3,4,RG4);
			  }
			  hasrm=1;
			  break;
		  case RAC:                      // Accumulator (AL/AX/EAX, implicit)
			  DecodeRG(REG_EAX,datasize,RAC);
			  break;
		  case RAX:                      // AX (2-byte, implicit)
			  DecodeRG(REG_EAX,2,RAX); 
			  break;
		  case RDX:                      // DX (16-bit implicit port address)
			  DecodeRG(REG_EDX,2,RDX); 
			  break;
		  case RCL:                      // Implicit CL register (for shifts)
			  DecodeRG(REG_ECX,1,RCL);
			  break;
		  case RS0:                      // Top of FPU stack (ST(0))
			  DecodeST(0,0);//未解决
			  break;
		  case RST:                      // FPU register (ST(i)) in command byte
			  DecodeST(cmd[0],0);//未解决
			  break;
		  case RMX:                      // MMX register MMx
			  if (size<2)
				  da->error=DAE_CROSS;
			  else 
				  DecodeMX(cmd[1]>>3);//未解决
			  hasrm=1;
			  break;
		  case R3D:                      // 3DNow! register MMx
			  if (size<2) 
				  da->error=DAE_CROSS;
			  else 
				  DecodeNR(cmd[1]>>3);//未解决
			  hasrm=1; 
			  break;
		  case MRG:                      // Memory/register in ModRM byte
		  case MRJ:                      // Memory/reg in ModRM as JUMP target
		  case MR1:                      // 1-byte memory/register in ModRM byte
		  case MR2:                      // 2-byte memory/register in ModRM byte
		  case MR4:                      // 4-byte memory/register in ModRM byte
		  case MR8:                      // 8-byte memory/MMX register in ModRM
		  case MRD:                      // 8-byte memory/3DNow! register in ModRM
		  case MMA:                      // Memory address in ModRM byte for LEA
		  case MML:                      // Memory in ModRM byte (for LES)
		  case MM6:                      // Memory in ModRm (6-byte descriptor)
		  case MMB:                      // Two adjacent memory locations (BOUND)
		  case MD2:                      // Memory in ModRM byte (16-bit integer)
		  case MB2:                      // Memory in ModRM byte (16-bit binary)
		  case MD4:                      // Memory in ModRM byte (32-bit integer)
		  case MD8:                      // Memory in ModRM byte (64-bit integer)
		  case MDA:                      // Memory in ModRM byte (80-bit BCD)
		  case MF4:                      // Memory in ModRM byte (32-bit float)
		  case MF8:                      // Memory in ModRM byte (64-bit float)
		  case MFA:                      // Memory in ModRM byte (80-bit float)
		  case MFE:                      // Memory in ModRM byte (FPU environment)
		  case MFS:                      // Memory in ModRM byte (FPU state)
		  case MFX:                      // Memory in ModRM byte (ext. FPU state)
			  DecodeMR(arg);
			  break;
		  case MMS:                      // Memory in ModRM byte (as SEG:OFFS)
			  DecodeMR(arg);
			  da->warnings|=DAW_FARADDR; 
			  break;
		  case RR4:                      // 4-byte memory/register (register only)
		  case RR8:                      // 8-byte MMX register only in ModRM
		  case RRD:                      // 8-byte memory/3DNow! (register only)
			  if ((cmd[1] & 0xC0)!=0xC0) 
				  softerror=DAE_REGISTER;
			  DecodeMR(arg);
			  break;
		  case MSO:                      // Source in string op's ([ESI])
			  DecodeSO();
			  break;
		  case MDE:                      // Destination in string op's ([EDI])
			  DecodeDE();
			  break;
		  case MXL:                      // XLAT operand ([EBX+AL])
			  DecodeXL();//未解决
			  break;
		  case IMM:                      // Immediate data (8 or 16/32)
		  case IMU:                      // Immediate unsigned data (8 or 16/32)
			  if ((pd->bits & SS)!=0 && (*cmd & 0x02)!=0)
				  DecodeIM(1,datasize,arg);
			  else
				  DecodeIM(datasize,0,arg);
			  break;
		  case VXD:                      // VxD service (32-bit only)
			  DecodeVX();//未解决
			  break;
		  case IMX:                      // Immediate sign-extendable byte
			  DecodeIM(1,datasize,arg);
			  break;
		  case C01:                      // Implicit constant 1 (for shifts)
			  DecodeC1();//未解决
			  break;
		  case IMS:                      // Immediate byte (for shifts)
		  case IM1:                      // Immediate byte
			  DecodeIM(1,0,arg);
			  break;
		  case IM2:                      // Immediate word (ENTER/RET)
			  DecodeIM(2,0,arg);
			  if ((da->immconst & 0x03)!=0)
				  da->warnings|=DAW_STACK;
			  break;
		  case IMA:                      // Immediate absolute near data address
			  DecodeIA();				   //[imm] ok
			  break;
		  case JOB:                      // Immediate byte offset (for jumps)
			  DecodeRJ(1,srcip+2);//无须解决jmpconst则是
			  break;
		  case JOW:                      // Immediate full offset (for jumps)
			  DecodeRJ(datasize,srcip+datasize+1);//无须解决jmpconst则是 
			  break;
		  case JMF:                      // Immediate absolute far jump/call addr
			  DecodeJF();//未解决
			  da->warnings|=DAW_FARADDR;
			  break;
		  case SGM:                      // Segment register in ModRM byte
			  if (size<2) 
				  da->error=DAE_CROSS;
			  DecodeSG(cmd[1]>>3);
			  hasrm=1;
			  break;
		  case SCM:                      // Segment register in command byte
			  DecodeSG(cmd[0]>>3);
			  if ((da->cmdtype & C_TYPEMASK)==C_POP)
				  da->warnings|=DAW_SEGMENT;
			  break;
		  case CRX:                      // Control register CRx
			  if ((cmd[1] & 0xC0)!=0xC0) 
				  da->error=DAE_REGISTER;
			  DecodeCR(cmd[1]);//未解决
			  break;
		  case DRX:                      // Debug register DRx
			  if ((cmd[1] & 0xC0)!=0xC0)
				  da->error=DAE_REGISTER;
			  DecodeDR(cmd[1]);//未解决
			  break;
		  case PRN:                      // Near return address (pseudooperand)
			  break;
		  case PRF:                      // Far return address (pseudooperand)
			  da->warnings|=DAW_FARADDR;
			  break;
		  case PAC:                      // Accumulator (AL/AX/EAX, pseudooperand)
			  DecodeRG(REG_EAX,datasize,PAC);
			  break;
		  case PAH:                      // AH (in LAHF/SAHF, pseudooperand)
		  case PFL:                      // Lower byte of flags (pseudooperand)
			  break;
		  case PS0:                      // Top of FPU stack (pseudooperand)
			  DecodeST(0,1);//未解决
			  break;
		  case PS1:                      // ST(1) (pseudooperand)
			  DecodeST(1,1);//未解决
			  break;
		  case PCX:                      // CX/ECX (pseudooperand)
			  DecodeRG(REG_ECX,cxsize,PCX); 
			  break;
		  case PDI:                      // EDI (pseudooperand in MMX extentions)
			  DecodeRG(REG_EDI,4,PDI);
			  break;
		  default:
			  da->error=DAE_INTERN;        // Unknown argument type
			  break;
		  }
		  da->memsize[operand] = datasize;
	  }
    // Check whether command may possibly contain fixups.
    if (pfixup!=NULL && da->fixupsize>0)
      da->fixupoffset=(int)(pfixup-src);
    // Segment prefix and address size prefix are superfluous for command which
    // does not access memory. If this the case, mark command as rare to help
    // in analysis.
    if (da->memtype==DEC_UNKNOWN &&
      (segprefix!=SEG_UNDEF || (addrsize!=4 && pd->name[0]!='$'))
    ) 
	{
      da->warnings|=DAW_PREFIX;
      da->cmdtype|=C_RARE; 
	}
    // 16-bit addressing is rare in 32-bit programs. If this is the case,
    // mark command as rare to help in analysis.
	//16位的寻址在32位程序中是少见的,如果是这种情况,在在命令中加上标志
    if (addrsize!=4)
		da->cmdtype|=C_RARE;
  }
  // Suffix of 3DNow! command is accounted best by assuming it immediate byte
  // constant.
  if (is3dnow) 
  {
    if (immsize!=0) 
		da->error=DAE_BADCMD;
    else immsize=1;
  }
  // Right or wrong, command decoded. Now dump it.
  if (da->error!=0) //如果命令有错误
  {                  // Hard error in command detected
    if (mode>=DISASM_FILE)
      nresult=sprintf(da->result,"???");
    if (da->error==DAE_BADCMD && (*cmd==0x0F || *cmd==0xFF) && size>0 )
	{
      if (mode>=DISASM_FILE)
	  {
		  ndump+=sprintf(da->dump+ndump,"%02X",*cmd);
		  da->hexcode[da->codelen++] = *cmd;
	  }
      cmd++; 
	  size--;
	}
    if (size>0)
	{
      if (mode>=DISASM_FILE)
	  {
		  ndump+=sprintf(da->dump+ndump,"%02X",*cmd);
		  da->hexcode[da->codelen++] = *cmd;
	  }
      cmd++; 
	  size--;
    }
  }
  else
  { //如果没有错误,dump命令         // No hard error, dump command
    if (mode>=DISASM_FILE) 
	{
		ndump+=sprintf(da->dump+ndump,"%02X",*cmd++);
		da->hexcode[da->codelen++] = *(cmd-1);

      if (hasrm)
	  {
		  ndump+=sprintf(da->dump+ndump,"%02X",*cmd++);
		  da->hexcode[da->codelen++] = *(cmd-1);
	  }
      if (hassib)
	  {
		  ndump+=sprintf(da->dump+ndump,"%02X",*cmd++);
		  da->hexcode[da->codelen++] = *(cmd-1);
	  }
      if (dispsize!=0) 
	  {
        da->dump[ndump++]=' ';
        for (i=0; i<dispsize; i++)
		{
			ndump+=sprintf(da->dump+ndump,"%02X",*cmd++);
			da->hexcode[da->codelen++] = *(cmd-1);
        }
      }
      if (immsize!=0) 
	  {
        da->dump[ndump++]=' ';
        for (i=0; i<immsize; i++)
		{
			ndump+=sprintf(da->dump+ndump,"%02X",*cmd++);
			da->hexcode[da->codelen++] = *(cmd-1);
        }
      }
    }
    else
      cmd+=1+hasrm+hassib+dispsize+immsize;
    size-=1+hasrm+hassib+dispsize+immsize;
  }
  // Check that command is not a dangerous one.
  //检查命令是否是危险的
  if (mode>=DISASM_DATA) 
  {
    for (pdan=dangerous; pdan->mask!=0; pdan++)
	{
      if (((code^pdan->code) & pdan->mask)!=0)
        continue;
      if (pdan->type==C_DANGERLOCK && lockprefix==0)
        break;                         // Command harmless without LOCK prefix
      if (iswindowsnt && pdan->type==C_DANGER95)
        break;                         // Command harmless under Windows NT
      // Dangerous command!
      if (pdan->type==C_DANGER95)
		  da->warnings|=DAW_DANGER95;
      else
		  da->warnings|=DAW_DANGEROUS;
      break;
    }
  }
  if (da->error==0 && softerror!=0)
    da->error=softerror;               // Error, but still display command
  if (mode>=DISASM_FILE)
  {
    if (da->error!=DAE_NOERR)
	{
		switch (da->error)
		{
		case DAE_CROSS:
			strcpy(da->comment,"Command crosses end of memory block");
			break;
		case DAE_BADCMD:
			strcpy(da->comment,"Unknown command");
			break;
		case DAE_BADSEG:
			strcpy(da->comment,"Undefined segment register");
			break;
		case DAE_MEMORY:
			strcpy(da->comment,"Illegal use of register");
			break;
		case DAE_REGISTER:
			strcpy(da->comment,"Memory address not allowed");
			break;
		case DAE_INTERN:
			strcpy(da->comment,"Internal OLLYDBG error");
			break;
		default:
			strcpy(da->comment,"Unknown error");
			break;
		}
	}
    else if ((da->warnings & DAW_PRIV)!=0 && privileged==0)
      strcpy(da->comment,"Privileged command");
    else if ((da->warnings & DAW_IO)!=0 && iocommand==0)
      strcpy(da->comment,"I/O command");
    else if ((da->warnings & DAW_FARADDR)!=0 && farcalls==0)
	{
      if ((da->cmdtype & C_TYPEMASK)==C_JMP)
        strcpy(da->comment,"Far jump");
      else if ((da->cmdtype & C_TYPEMASK)==C_CAL)
        strcpy(da->comment,"Far call");
      else if ((da->cmdtype & C_TYPEMASK)==C_RET)
        strcpy(da->comment,"Far return");
	}
    else if ((da->warnings & DAW_SEGMENT)!=0 && farcalls==0)
      strcpy(da->comment,"Modification of segment register");
    else if ((da->warnings & DAW_SHIFT)!=0 && badshift==0)
      strcpy(da->comment,"Shift constant out of range 1..31");
    else if ((da->warnings & DAW_PREFIX)!=0 && extraprefix==0)
      strcpy(da->comment,"Superfluous prefix");
    else if ((da->warnings & DAW_LOCK)!=0 && lockedbus==0)
      strcpy(da->comment,"LOCK prefix");
    else if ((da->warnings & DAW_STACK)!=0 && stackalign==0)
      strcpy(da->comment,"Unaligned stack operation");
  }
  return (srcsize-size);               // Returns number of recognized bytes
}
  
```

`vm-packer/反汇编/反汇编/ASM/disasm.h`:

```h
// Free Disassembler and Assembler -- Header file
//
// Copyright (C) 2001 Oleh Yuschuk
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#pragma once

#ifndef MAINPROG
#define odunique extern
#else
#define odunique
#endif

#pragma   warning(disable:4309)//关闭截断常数值警告

// If you prefere Borland, this will force necessary setting (but, as a side
// effect, may cause plenty of warnings if other include files will be compiled
// with different options):

#ifdef __BORLANDC__
#pragma option -K                      // Unsigned char
#endif
//
//#if (char)0xFF != 255
//#error Please set default char type to unsigned
//#endif


#define NEGLIMIT       (-16384)        // Limit to display constans as signed
#define PSEUDOOP       128             // Base for pseudooperands
#define TEXTLEN        256             // Maximal length of text string

// Special command features.
#define WW             0x01            // Bit W (size of operand)
#define SS             0x02            // Bit S (sign extention of immediate)
#define WS             0x03            // Bits W and S
#define W3             0x08            // Bit W at position 3
#define CC             0x10            // Conditional jump
#define FF             0x20            // Forced 16-bit size
#define LL             0x40            // Conditional loop
#define PR             0x80            // Protected command
#define WP             0x81            // I/O command with bit W

// All possible types of operands in 80x86. A bit more than you expected, he?
#define NNN            0               // No operand \\无操作
#define REG            1               // Integer register in Reg field             \\积存器结构中的寄存器
#define RCM            2               // Integer register in command byte          \\命令字节中的寄存器
#define RG4            3               // Integer 4-byte register in Reg field      \\用不到PMOVMSKB指令
#define RAC            4               // Accumulator (AL/AX/EAX, implicit)         \\暗示累加器?
#define RAX            5               // AX (2-byte, implicit)						\\暗示AX
#define RDX            6               // DX (16-bit implicit port address)
#define RCL            7               // Implicit CL register (for shifts)         \\暗示CL寄存器
#define RS0            8               // Top of FPU stack (ST(0), implicit)
#define RST            9               // FPU register (ST(i)) in command byte
#define RMX            10              // MMX register MMx
#define R3D            11              // 3DNow! register MMx
#define MRG            12              // Memory/register in ModRM byte
#define MR1            13              // 1-byte memory/register in ModRM byte
#define MR2            14              // 2-byte memory/register in ModRM byte
#define MR4            15              // 4-byte memory/register in ModRM byte
#define RR4            16              // 4-byte memory/register (register only)
#define MR8            17              // 8-byte memory/MMX register in ModRM
#define RR8            18              // 8-byte MMX register only in ModRM
#define MRD            19              // 8-byte memory/3DNow! register in ModRM
#define RRD            20              // 8-byte memory/3DNow! (register only)
#define MRJ            21              // Memory/reg in ModRM as JUMP target
#define MMA            22              // Memory address in ModRM byte for LEA
#define MML            23              // Memory in ModRM byte (for LES)
#define MMS            24              // Memory in ModRM byte (as SEG:OFFS)
#define MM6            25              // Memory in ModRm (6-byte descriptor)
#define MMB            26              // Two adjacent memory locations (BOUND)
#define MD2            27              // Memory in ModRM (16-bit integer)
#define MB2            28              // Memory in ModRM (16-bit binary)
#define MD4            29              // Memory in ModRM byte (32-bit integer)
#define MD8            30              // Memory in ModRM byte (64-bit integer)
#define MDA            31              // Memory in ModRM byte (80-bit BCD)
#define MF4            32              // Memory in ModRM byte (32-bit float)
#define MF8            33              // Memory in ModRM byte (64-bit float)
#define MFA            34              // Memory in ModRM byte (80-bit float)
#define MFE            35              // Memory in ModRM byte (FPU environment)
#define MFS            36              // Memory in ModRM byte (FPU state)
#define MFX            37              // Memory in ModRM byte (ext. FPU state)
#define MSO            38              // Source in string op's ([ESI])
#define MDE            39              // Destination in string op's ([EDI])
#define MXL            40              // XLAT operand ([EBX+AL])
#define IMM            41              // Immediate data (8 or 16/32)
#define IMU            42              // Immediate unsigned data (8 or 16/32)
#define VXD            43              // VxD service
#define IMX            44              // Immediate sign-extendable byte
#define C01            45              // Implicit constant 1 (for shifts)
#define IMS            46              // Immediate byte (for shifts)
#define IM1            47              // Immediate byte
#define IM2            48              // Immediate word (ENTER/RET)
#define IMA            49              // Immediate absolute near data address
#define JOB            50              // Immediate byte offset (for jumps)
#define JOW            51              // Immediate full offset (for jumps)
#define JMF            52              // Immediate absolute far jump/call addr
#define SGM            53              // Segment register in ModRM byte
#define SCM            54              // 段寄存器      Segment register in command byte
#define CRX            55              // CRx控制寄存器 Control register CRx
#define DRX            56              // DRx调试寄存器 Debug register DRx
// Pseudooperands (implicit operands, never appear in assembler commands). Must
// have index equal to or exceeding PSEUDOOP.
#define PRN            (PSEUDOOP+0)    // Near return address
#define PRF            (PSEUDOOP+1)    // Far return address
#define PAC            (PSEUDOOP+2)    // Accumulator (AL/AX/EAX)
#define PAH            (PSEUDOOP+3)    // AH (in LAHF/SAHF commands)
#define PFL            (PSEUDOOP+4)    // Lower byte of flags (in LAHF/SAHF)
#define PS0            (PSEUDOOP+5)    // Top of FPU stack (ST(0))
#define PS1            (PSEUDOOP+6)    // ST(1)
#define PCX            (PSEUDOOP+7)    // CX/ECX
#define PDI            (PSEUDOOP+8)    // EDI (in MMX extentions)

// Errors detected during command disassembling.
#define DAE_NOERR      0               // No error
#define DAE_BADCMD     1               // Unrecognized command
#define DAE_CROSS      2               // Command crosses end of memory block
#define DAE_BADSEG     3               // Undefined segment register
#define DAE_MEMORY     4               // Register where only memory allowed
#define DAE_REGISTER   5               // Memory where only register allowed
#define DAE_INTERN     6               // Internal error

typedef unsigned char  uchar;          // Unsigned character (byte)
typedef unsigned short ushort;         // Unsigned short
typedef unsigned int   uint;           // Unsigned integer
typedef unsigned long  ulong;          // Unsigned long

typedef struct t_addrdec
{
	int            defseg;
	char           *descr;
} t_addrdec;
//命令数据
typedef struct t_cmddata
{
	ulong          mask;                 // Mask for first 4 bytes of the command
	ulong          code;                 // Compare masked bytes with this
	char           len;                  // Length of the main command code
	char           bits;                 // Special bits within the command
	char           arg1,arg2,arg3;       // Types of possible arguments
	char           type;                 // C_xxx + additional information
	char           *name;                // Symbolic name for this command
} t_cmddata;

// Initialized constant data structures used by all programs from assembler
// package. Contain names of register, register combinations or commands and
// their properties.
extern const char      *regname[3][9];
extern const char      *segname[8];
extern const char      *sizename[11];
extern const t_addrdec addr16[8];
extern const t_addrdec addr32[8];
extern const char      *fpuname[9];
extern const char      *mmxname[9];
extern const char      *crname[9];
extern const char      *drname[9];
extern const char      *condition[16];
extern const t_cmddata cmddata[];//可用结构数组
extern const t_cmddata vxdcmd;
extern const t_cmddata dangerous[];

////////////////////////////////////////////////////////////////////////////////
//////////////////// ASSEMBLER, DISASSEMBLER AND EXPRESSIONS ///////////////////

#define MAXCMDSIZE     16              // Maximal length of 80x86 command
#define MAXCALSIZE     8               // Max length of CALL without prefixes
#define NMODELS        8               // Number of assembler search models

#define INT3           0xCC            // Code of 1-byte breakpoint
#define NOP            0x90            // Code of 1-byte NOP command
#define TRAPFLAG       0x00000100      // Trap flag in CPU flag register

#define REG_EAX        0               // Indexes of general-purpose registers
#define REG_ECX        1               // in t_reg.
#define REG_EDX        2
#define REG_EBX        3
#define REG_ESP        4
#define REG_EBP        5
#define REG_ESI        6
#define REG_EDI        7

#define SEG_UNDEF     -1			   //没有段寄存器
#define SEG_ES         0               // Indexes of segment/selector registers
#define SEG_CS         1
#define SEG_SS         2
#define SEG_DS         3
#define SEG_FS         4
#define SEG_GS         5

#define C_TYPEMASK     0xF0            // Mask for command type
#define   C_CMD        0x00            // Ordinary instruction
#define   C_PSH        0x10            // 1-word PUSH instruction
#define   C_POP        0x20            // 1-word POP instruction
#define   C_MMX        0x30            // MMX instruction
#define   C_FLT        0x40            // FPU instruction
#define   C_JMP        0x50            // JUMP instruction
#define   C_JMC        0x60            // Conditional JUMP instruction
#define   C_CAL        0x70            // CALL instruction
#define   C_RET        0x80            // RET instruction
#define   C_FLG        0x90            // Changes system flags
#define   C_RTF        0xA0            // C_JMP and C_FLG simultaneously
#define   C_REP        0xB0            // Instruction with REPxx prefix
#define   C_PRI        0xC0            // Privileged instruction
#define   C_DAT        0xD0            // Data (address) doubleword
#define   C_NOW        0xE0            // 3DNow! instruction
#define   C_BAD        0xF0            // Unrecognized command
#define C_RARE         0x08            // Rare command, seldom used in programs
#define C_SIZEMASK     0x07            // MMX data size or special flag
#define   C_EXPL       0x01            // (non-MMX) Specify explicit memory size

#define C_DANGER95     0x01            // Command is dangerous under Win95/98
#define C_DANGER       0x03            // Command is dangerous everywhere
#define C_DANGERLOCK   0x07            // Dangerous with LOCK prefix

#define DEC_TYPEMASK   0x1F            // Type of memory byte
#define   DEC_UNKNOWN  0x00            // Unknown type
#define   DEC_BYTE     0x01            // Accessed as byte
#define   DEC_WORD     0x02            // Accessed as short
#define   DEC_NEXTDATA 0x03            // Subsequent byte of code or data
#define   DEC_DWORD    0x04            // Accessed as long
#define   DEC_FLOAT4   0x05            // Accessed as float
#define   DEC_FWORD    0x06            // Accessed as descriptor/long pointer
#define   DEC_FLOAT8   0x07            // Accessed as double
#define   DEC_QWORD    0x08            // Accessed as 8-byte integer
#define   DEC_FLOAT10  0x09            // Accessed as long double
#define   DEC_TBYTE    0x0A            // Accessed as 10-byte integer
#define   DEC_STRING   0x0B            // Zero-terminated ASCII string
#define   DEC_UNICODE  0x0C            // Zero-terminated UNICODE string
#define   DEC_3DNOW    0x0D            // Accessed as 3Dnow operand
#define   DEC_BYTESW   0x11            // Accessed as byte index to switch
#define   DEC_NEXTCODE 0x13            // Subsequent byte of command
#define   DEC_COMMAND  0x1D            // First byte of command
#define   DEC_JMPDEST  0x1E            // Jump destination
#define   DEC_CALLDEST 0x1F            // Call (and maybe jump) destination
#define DEC_PROCMASK   0x60            // Procedure analysis
#define   DEC_PROC     0x20            // Start of procedure
#define   DEC_PBODY    0x40            // Body of procedure
#define   DEC_PEND     0x60            // End of procedure
#define DEC_CHECKED    0x80            // Byte was analysed

#define DECR_TYPEMASK  0x3F            // Type of register or memory
#define   DECR_BYTE    0x21            // Byte register
#define   DECR_WORD    0x22            // Short integer register
#define   DECR_DWORD   0x24            // Long integer register
#define   DECR_QWORD   0x28            // MMX register
#define   DECR_FLOAT10 0x29            // Floating-point register
#define   DECR_SEG     0x2A            // Segment register
#define   DECR_3DNOW   0x2D            // 3Dnow! register
#define DECR_ISREG     0x20            // Mask to check that operand is register

#define DISASM_SIZE    0               // Determine command size only
#define DISASM_DATA    1               // Determine size and analysis data
#define DISASM_FILE    3               // Disassembly, no symbols
#define DISASM_CODE    4               // Full disassembly

// Warnings issued by Disasm():
#define DAW_FARADDR    0x0001          // Command is a far jump, call or return
#define DAW_SEGMENT    0x0002          // Command loads segment register
#define DAW_PRIV       0x0004          // Privileged command
#define DAW_IO         0x0008          // I/O command
#define DAW_SHIFT      0x0010          // Shift constant out of range 1..31
#define DAW_PREFIX     0x0020          // Superfluous prefix
#define DAW_LOCK       0x0040          // Command has LOCK prefix
#define DAW_STACK      0x0080          // Unaligned stack operation
#define DAW_DANGER95   0x1000          // May mess up Win95 if executed
#define DAW_DANGEROUS  0x3000          // May mess up any OS if executed
//bughoho 操作数类型
enum Optype
{
	Imm,
	Reg,
	Mem,
	Seg,
};
typedef struct t_disasm
{              // Results of disassembling
	ulong          ip;                   // Instrucion pointer
	char           dump[TEXTLEN];        // Hexadecimal dump of the command
	char           result[TEXTLEN];      // Disassembled command
	char           comment[TEXTLEN];     // Brief comment
	int            cmdtype;              // One of C_xxx
	int            memtype;              // Type of addressed variable in memory
	int            nprefix;              // Number of prefixes
	int            indexed;              // Address contains register(s)
	ulong          jmpconst;             // Constant jump address
	ulong          jmptable;             // Possible address of switch table
	ulong          adrconst;             // [edx+100] '100' 地址部分的常量 Constant part of address
	ulong          immconst;             // Immediate constant
	int            zeroconst;            // Whether contains zero constant
	int            fixupoffset;          // Possible offset of 32-bit fixups
	int            fixupsize;            // Possible total size of fixups or 0
	int            error;                // Error while disassembling command
	int            warnings;             // Combination of DAW_xxx

	//bughoho new
	BYTE		   hexcode[TEXTLEN];	 //2进制码
	int			   codelen;				 //长度

	int			   optype[3];				 // 操作数类型
	char		   vm_name[TEXTLEN];	 // 声称VM对应的Handler名称
	int			   is3dnow;				 // 3dnow函数
	int			   segment;				 // 段前缀
	int			   reg[3];				 // 3寄存器(假设操作数为寄存器)
	int			   segreg;				 // 段寄存器(假设操作数为段寄存器)
	int			   addrreg1;			 // 内存地址部分的第1个不带比例的寄存器
	int			   addrreg2;			 // 内存地址部分的第2个带比例的寄存器
	int			   regsscale;			 // 比例:1,2,4,8
	//还有一个adrconst已经定义,根据正负号来定义加减
	int			   memsize[3];			 // 操作数长度
	bool		   highbit[3];			 // 当是8位指令时并且为高位时(ah bh ch dh)为1
} t_disasm;

//汇编Code命令结构
struct CodeNode
{
	t_disasm	disasm;
	BOOL		IsJmcBeSideType;//跳到外部的指令
	BOOL		IsJmcUndefineType;//跳到代码内不明确的地址
	BOOL		IsJmcDynamicType;//动态跳转类型
	BOOL		IsJmcType;//跳转
	BOOL		IsJmcFromType;//从其他地方跳转过来的代码
	BOOL		IsJmcNextType;//JMC和CALL之后的代码
	BOOL		IsCallType;//调用子函数
	CodeNode()
	{
		memset(this,0,sizeof(CodeNode));
	}
};

typedef struct t_asmmodel
{            // Model to search for assembler command
	char           code[MAXCMDSIZE];     // Binary code
	char           mask[MAXCMDSIZE];     // Mask for binary code (0: bit ignored)
	int            length;               // Length of code, bytes (0: empty)
	int            jmpsize;              // Offset size if relative jump
	int            jmpoffset;            // Offset relative to IP
	int            jmppos;               // Position of jump offset in command
} t_asmmodel;

odunique int       ideal;                // Force IDEAL decoding mode
odunique int       lowercase;            // Force lowercase display
odunique int       tabarguments;         // Tab between mnemonic and arguments
odunique int       extraspace;           // Extra space between arguments
odunique int       putdefseg;            // Display default segments in listing
odunique int       showmemsize;          // Always show memory size
odunique int       shownear;             // Show NEAR modifiers
odunique int       shortstringcmds;      // Use short form of string commands
odunique int       sizesens;             // How to decode size-sensitive mnemonics
odunique int       symbolic;             // Show symbolic addresses in disasm
odunique int       farcalls;             // Accept far calls, returns & addresses
odunique int       decodevxd;            // Decode VxD calls (Win95/98)
odunique int       privileged;           // Accept privileged commands
odunique int       iocommand;            // Accept I/O commands
odunique int       badshift;             // Accept shift out of range 1..31
odunique int       extraprefix;          // Accept superfluous prefixes
odunique int       lockedbus;            // Accept LOCK prefixes
odunique int       stackalign;           // Accept unaligned stack operations
odunique int       iswindowsnt;          // When checking for dangers, assume NT
//bughoho
odunique int	   stoperand;			 //当前的循环

int    Assemble(char *cmd,ulong ip,t_asmmodel *model,int attempt,
				int constsize,char *errtext);
int    Checkcondition(int code,ulong flags);
int    Decodeaddress(ulong addr,char *symb,int nsymb,char *comment);
ulong  Disasm(char *src,ulong srcsize,ulong srcip,
			  t_disasm *disasm,int disasmmode);
ulong  Disassembleback(char *block,ulong base,ulong size,ulong ip,int n);
ulong  Disassembleforward(char *block,ulong base,ulong size,ulong ip,int n);
int    Isfilling(ulong addr,char *data,ulong size,ulong align);
int    Print3dnow(char *s,char *f);
int    Printfloat10(char *s,long double ext);
int    Printfloat4(char *s,float f);
int    Printfloat8(char *s,double d);
  
```

`vm-packer/反汇编/反汇编/CCodeILFactory.cpp`:

```cpp
/*-----------------------------------------------------------------------
第20章  虚拟机的设计
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

// VMPackLib

#include "stdafx.h"
#include "CCodeILFactory.h"

CCodeILFactory::CCodeILFactory()
{
}


void CCodeILFactory::Init(DWORD VirtualAddress)
{
	int nJumpTableAddr	= VirtualAddress;
	int nCodeEngineAddr = nJumpTableAddr  + JumpTableLen;
	int nEnterStubAddr	= nCodeEngineAddr + CodeEngineLen;
	int mVMEnterStubCodeAddr = nEnterStubAddr  + EnterStubAddrLen;
	int nVMCodeAddr		= mVMEnterStubCodeAddr  + VMEnterCodeLen;

	m_JumpTable.CreateVirtualMemory(nJumpTableAddr,JumpTableLen);
	m_CodeEngine.CreateVirtualMemory(nCodeEngineAddr,CodeEngineLen);
	m_EnterStub.CreateVirtualMemory(nEnterStubAddr,EnterStubAddrLen);
	m_VMEnterStubCode.CreateVirtualMemory(mVMEnterStubCodeAddr,VMEnterCodeLen);
	m_VMCode.CreateVirtualMemory(nVMCodeAddr,VMCodeLen);

	VMFactory.SetupVirtualMemory(&m_JumpTable,&m_CodeEngine,&m_EnterStub,&m_VMEnterStubCode,&m_VMCode);

	VMFactory.InitVM();
}
// 反汇编代码,识别出函数结束的地方.添加到提供的链表中
// CodeList : 输出汇编链表
// base_addr: 2进制代码
// VirtualAddress : 虚拟地址
void CCodeILFactory::DisasmFunction(list<CodeNode*> *CodeList,char* base_addr,DWORD VirtualAddress)
{
	DWORD Start_VirtualAddress = VirtualAddress;//第一个地址
	DWORD End_VirtualAddress = 0;//最后一句的地址

	t_disasm da;
	CodeNode* code = NULL;
	int len =0;
	int KeepNum = 0;
	//计算出函数的结尾
	while( TRUE )
	{
		code = new CodeNode;
		len = Disasm(base_addr,MAXCMDSIZE,VirtualAddress,&da,DISASM_CODE);

		memcpy(&code->disasm,&da,sizeof(t_disasm));
		//CodeList->AddTail(code);
		CodeList->push_back(code);

		if( KeepNum >= len && KeepNum != 0 )
			KeepNum -= len;

		if( IsJumpCmd(&da) )//是跳转指令
		{
			if( da.jmpconst && da.jmpconst > VirtualAddress )
			{
				KeepNum = da.jmpconst - VirtualAddress;
			}
		}
		if( _stricmp(da.result,"int3") == 0 )//如果找到int3
		{
			break;
		}
		if( _stricmp(da.result,"retn") == 0 )//如果找到返回指令
		{
			if( KeepNum - len <= 0 )//如果没有字节了.则返回
				break;
		}
		base_addr+=len;
		VirtualAddress+=len;
	}
	End_VirtualAddress = VirtualAddress;

	//计算出各语句的用处
	BOOL NextJMCALL = FALSE;
	//T_Link* pos = CodeList->GetLink();
	list<CodeNode*>::iterator itr;
	for( itr = CodeList->begin(); itr != CodeList->end(); itr++ )
	{
		CodeNode* code = *itr;
		t_disasm t_da ;
		memcpy(&t_da,&code->disasm,sizeof(t_disasm));
		if(code)
		{
			if( NextJMCALL )
			{
				NextJMCALL = FALSE;
				code->IsJmcNextType = TRUE;
			}
			if( IsJumpCmd(&t_da) )//是跳转指令
			{
				NextJMCALL = TRUE;
				if( t_da.jmpconst )
				{
					if( t_da.jmpconst > Start_VirtualAddress && t_da.jmpconst < End_VirtualAddress )//在LIST里
					{
						CodeNode* tmpNode = SearchAddrAsList(CodeList,code);//搜索链表
						if( tmpNode )
						{
							tmpNode->IsJmcFromType = TRUE;//标明这一句为从其他地方跳转过来的代码
						}
					}
					else
					{
						code->IsJmcBeSideType = TRUE;//为跳到外部的指令
					}
				}
				else//没有跳转地址,就是动态跳转
				{
					code->IsJmcDynamicType = TRUE;
				}
			}
			else if( IsCallCmd(&t_da) )//是函数调用指令
			{
				NextJMCALL = TRUE;
				code->IsCallType = TRUE;
			}
		}
	}
}

// 是否是跳转指令
BOOL CCodeILFactory::IsJumpCmd(t_disasm* da)
{
	if(  ( da->cmdtype & C_CAL ) == C_CAL )//CALL不算
	{
		return FALSE;
	}
	if( ( da->cmdtype & C_JMP ) == C_JMP )
	{
		return TRUE;
	}
	if( ( da->cmdtype & C_JMC ) == C_JMC )
	{
		return TRUE;
	}
	return FALSE;
}

// 是否是函数调用指令
BOOL CCodeILFactory::IsCallCmd(t_disasm* da)
{
	if( ( da->cmdtype & C_CAL ) == C_CAL )
	{
		return TRUE;
	}
	return FALSE;
}
BOOL CCodeILFactory::IsRetnCmd(t_disasm* da)
{
	char strretn[32] = "RETN\0";
	_strlwr_s(da->result,TEXTLEN);
	_strlwr_s(strretn,32);
	if( strstr(strretn,da->result) )
	{
		return TRUE;
	}
	return FALSE;
}
//从链表中搜索一个地址的节点
CodeNode* CCodeILFactory::SearchAddrAsList( list<CodeNode*> *List,CodeNode* node )
{
	DWORD GotoAddr = node->disasm.jmpconst;
	DWORD LastAddr = 0;
	list<CodeNode*>::iterator itr;
	for( itr = List->begin(); itr != List->end(); itr++ )
	{
		CodeNode* code = *itr;
		t_disasm t_da ;
		memcpy(&t_da,&code->disasm,sizeof(t_disasm));
		if( GotoAddr == t_da.ip )//找到了
		{
			node->IsJmcType = TRUE;//正常跳转
			return code;
		}
		else if( GotoAddr > t_da.ip )
		{
			LastAddr = t_da.ip;
		}
		else if( GotoAddr < t_da.ip )
		{
			if( LastAddr )
			{
				node->IsJmcUndefineType = TRUE;//跳到了不明确的地址
			}
		}
	}
	return NULL;
}

// 编译汇编代码为VM字节码,返回成功失败
//BOOL CCodeILFactory::BuildCode(CLink* CodeList,char* ErrText)
BOOL CCodeILFactory::BuildCode(char* baseaddr,list<CodeNode*>* CodeList,char* ErrText)
{
	return VMFactory.BuildVMCode(baseaddr,CodeList,ErrText);
}
 
```

`vm-packer/反汇编/反汇编/CCodeILFactory.h`:

```h
// VMPackLib


#ifndef __CCODEILFACTORY__
#define __CCODEILFACTORY__

// Include files

#include <Windows.h>
#include <stdio.h>
#include "CVirtualMemory.h"
#include "CVMFactory.h"
#include "asm\disasm.h"


// 将汇编代码编译为ByteCode,添加到新节内存
class CCodeILFactory
{
public:
	CVirtualMemory m_JumpTable;						//JMP表
	CVirtualMemory m_CodeEngine;					//VM指令引擎
	CVirtualMemory m_EnterStub;						//重新进入vm的代码
	CVirtualMemory m_VMEnterStubCode;				//重新进入的vmcode
	CVirtualMemory m_VMCode;						//通常的vmcode
public:
	// 虚拟机工厂
	CVMFactory VMFactory;
public:
	CCodeILFactory();
public:
	void	Init(DWORD VirtualAddress);
public:
	// 编译汇编代码为VM字节码,返回成功失败
	BOOL	BuildCode(char* baseaddr,list<CodeNode*> *CodeList,char* ErrText);
public:

	// 反汇编代码,识别出函数结束的地方.添加到提供的链表中
	// CodeList : 输出汇编链表
	// base_addr: 2进制代码
	// VirtualAddress : 虚拟地址
	void	DisasmFunction(list<CodeNode*> *CodeList,char* base_addr, DWORD VirtualAddress);


private:
	// 是否是跳转指令
	BOOL	IsJumpCmd(t_disasm* da);
	// 是否是函数调用指令
	BOOL	IsCallCmd(t_disasm* da);
	// 是否是返回指令
	BOOL	IsRetnCmd(t_disasm* da);
	//从链表中搜索一个地址的节点
	CodeNode*	SearchAddrAsList( list<CodeNode*>* List,CodeNode* node );

};// END CLASS DEFINITION CCodeILFactory

#endif // __CCODEILFACTORY__
 
```

`vm-packer/反汇编/反汇编/CLink.cpp`:

```cpp
// Link.cpp: implementation of the CLink class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <Windows.h>
#include "CLink.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLink::CLink()
{
	m_head = NULL;
	m_last = NULL;
	m_curpos = NULL;
	m_prepos = NULL;
}

CLink::~CLink()
{
	RemoveAll();
}

T_Link* CLink::GetHead()
{
	return m_head;
}

T_Link* CLink::GetLast()
{
	return m_last;
}

T_Link* CLink::GetCurPos()
{
	return m_curpos;
}

void CLink::AddTail(void* data)
{
	T_Link	*nextl = new T_Link;
	memset(nextl,0,sizeof(T_Link));//确保为0

	//nextl->npc = new NPC;
	nextl->next = NULL;
	if(m_head == NULL)
	{
		m_head = nextl;
		m_last = nextl;
		nextl->data = data;
		//memcpy(nextl->npc, npc, sizeof(NPC));
	}
	else
	{
		m_last->next = nextl;
		m_last = nextl;
		nextl->data = data;
		//memcpy(nextl->npc, npc, sizeof(NPC));
	}
}

void CLink::RemoveAll()
{
	T_Link *pos = m_head;
	
	m_head = NULL;
	m_last = NULL;
	m_curpos = NULL;
	m_prepos = NULL;

	if(pos == NULL)
		return;
	do
	{
		delete pos->data;
		T_Link *tmp = pos->next;
		delete pos;
		pos = tmp;
	}
	while(pos != NULL);
}

void CLink::Remove()
{
	if(m_curpos != NULL)
	{
		if(m_curpos == m_head)	//删除头指针
		{
			m_head = m_curpos->next;
			delete m_curpos->data;
			if(m_head == NULL)
			{
				m_last = NULL;
				m_curpos = NULL;
				m_prepos = NULL;				
			}
		}
		else if(m_curpos == m_last)//删除尾指针
		{
			m_last = m_prepos;
			m_last->next = NULL;
			//delete m_curpos->data;
		}
		else	//删除
		{
			m_prepos->next = m_curpos->next;
			delete m_curpos->data;
			GetNext();//删除后让当前链等于下一个
			delete m_prepos;//然后释放自己链(GetNext里保存的)
		}
	}
}

T_Link* CLink::GetNext()
{
	m_prepos = m_curpos;
	if(m_curpos != NULL)
		m_curpos = m_curpos->next;

	return m_curpos;
}

T_Link* CLink::GetLink()
{
	m_curpos = m_head;
	m_prepos = m_curpos;

	return m_curpos;
}
  
```

`vm-packer/反汇编/反汇编/CLink.h`:

```h
// Link.h: interface for the CLink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINK_H__C2CCD87E_3E0B_44EC_8DDD_92F8E52C37A7__INCLUDED_)
#define AFX_LINK_H__C2CCD87E_3E0B_44EC_8DDD_92F8E52C37A7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//#include "GameBase.h"

typedef struct T_Link
{
	void *data;
	struct T_Link *next;
}T_Link;

class CLink  
{
public:
	T_Link* GetLink();
	T_Link* GetNext();
	void Remove();
	void RemoveAll();
	T_Link* GetCurPos();
	T_Link* GetHead();
	T_Link* GetLast();
	void AddTail(void *data);
	CLink();
	virtual ~CLink();

private:
	T_Link* m_prepos;
	T_Link* m_curpos;
	T_Link* m_last;
	T_Link* m_head;
};

#endif // !defined(AFX_LINK_H__C2CCD87E_3E0B_44EC_8DDD_92F8E52C37A7__INCLUDED_)

```

`vm-packer/反汇编/反汇编/CVMFactory.cpp`:

```cpp
// VMPackLib

#include "stdafx.h"
#include "CVMFactory.h"
#include "asm/disasm.h"

CVMFactory::CVMFactory()
{
	m_curvhandidx = 0;
	m_curtableidx = 0;
}

CVMFactory::~CVMFactory()
{
	
}

//获得func_stub指向的地址(jmp xxxx)
HandlerFunc CVMFactory::GetFunctionRVA(HandlerFunc Func)
{
	return (HandlerFunc)((DWORD)Func+*(DWORD*)((DWORD)Func+1)+5);
}
//获得函数长度
int CVMFactory::GetFunctionSize(HandlerFunc FuncName)
{
	int FuncLen = 0;//函数长度
	char* pBody = (char*)GetFunctionRVA(FuncName);//得到jmp xxxx的指向的地址,优化后的代码则不需要这一句
	BOOL NotEnd = TRUE;//未结束
	int i = 0;
	while( NotEnd )
	{
		if( memcmp(pBody+i,"VMEND",5) == 0 )//找到结束标志
		{
			FuncLen = (int)(pBody + i - pBody);
			NotEnd = FALSE;
			break;
		}
		i++;
	}
	return FuncLen;
}

// 获得虚拟内存类
void CVMFactory::SetupVirtualMemory(CVirtualMemory *JumpTable,
									  CVirtualMemory *CodeEngine,
									  CVirtualMemory *EnterStub,
									  CVirtualMemory *VMEnterStub,
									  CVirtualMemory *VMCode)
{
	m_JumpTable = JumpTable;
	m_CodeEngine = CodeEngine;
	m_EnterStub = EnterStub;
	m_VMCode = VMCode;
	m_VMEnterStubCode = VMEnterStub;
}

// 通过名称获得Handler结构
VHandler* CVMFactory::GetHandler(char* vmname)
{
	for(int i = 0; i < m_curvhandidx; i++)
	{
		if( strcmp(m_vhandler[i].VMInstrName,"") == 0 )
			return NULL;
		if( strcmp(m_vhandler[i].VMInstrName,vmname) == 0 )
		{
			return &m_vhandler[i];
		}
	}
	return NULL;
}
// 添加一个Handler名称到Handler索引表
BOOL CVMFactory::AddVHandlerName(char* vmname)
{
	if( m_curtableidx > HANDLERMAXLEN )
		return FALSE;
	strcpy_s(m_RandomTable[m_curtableidx].VMInstrName,VMNAMELEN,vmname);
	m_RandomTable[m_curtableidx].idx = m_HandlerIdx[m_curtableidx];
	m_curtableidx++;
	return TRUE;
}
// 初始化VM环境.
// 1.初始化寄存器位置
// 2.初始化核心宏代码(将代码拷贝到结构体中)..
// 3.将Handler写入对应新节的内存地址.
// 4.得到Handler所在的虚拟地址后,修复相互间的跳转.设置汇编代码中固定的一些值.
void CVMFactory::InitVM()
{
	InterpretHandler.Init();//初始化

	RandListIdx(m_HandlerIdx,HANDLERMAXLEN);//打乱Handler索引

	InitCoreMacro();//初始化核心宏的特殊Handler
}
// 编译代码
BOOL CVMFactory::CompileCode(DWORD VirtualAddr,char* asmtext,char *code,int *len)
{
	t_asmmodel am;
	char errtext[TEXTLEN] = {0};

	char linestr[TEXTLEN] = {0};//得到一行的汇编代码字符串
	int lastk = 0;
	int asmlen = (int)strlen(asmtext)+1;
	int codelen = 0;
	for(int k = 0; k < asmlen; k++)
	{
		if( asmtext[k] == '\n' || asmtext[k] == '\0' )
		{
			memset(linestr,0,TEXTLEN);
			memcpy(linestr,&asmtext[lastk],k - lastk );
			lastk = k+1;
			int j=Assemble(linestr,VirtualAddr,&am,0,4,errtext);//编译为2进制代码
			VirtualAddr += j;
			if( strcmp(errtext,"") != 0 )
			{
				OutputDebugStringA("编译出错\n");
				OutputDebugStringA(errtext);
				return FALSE;
			}
			memcpy(&code[codelen],am.code,am.length);
			codelen += am.length;
		}
	}
	*len = codelen;

	return TRUE;
}
// 修复StartVM
void CVMFactory::FixStartVM()
{
	VHandler* vhandler = GetHandler("VStartVM");
	if( !vhandler )
		return;
	vhandler->VirtualAddress = m_CodeEngine->GetCurrentVirtualAddress();

	char code[16] = {0};
	int  len = 0;
	char text[TEXTLEN] = {0};

	sprintf_s( text,TEXTLEN,"jmp [eax*4+%08x]",m_JumpTable->m_VirtualBaseAddress );
	if( !CompileCode(vhandler->VirtualAddress+vhandler->CodeLen,text,code,&len) )
		return;
	memcpy(vhandler->AssembleCode+vhandler->CodeLen,code,len);
	vhandler->CodeLen += len;
	m_CodeEngine->WriteData( vhandler->AssembleCode,vhandler->CodeLen );
}
// 修复DCheckESP
void CVMFactory::FixCheckESP()
{
	VHandler* vhandler = GetHandler("DCheckESP");
	if( !vhandler )
		return;
	vhandler->VirtualAddress = m_CodeEngine->GetCurrentVirtualAddress();

	char code[16] = {0};
	int  len = 0;
	char text[TEXTLEN] = {0};

	sprintf_s( text,TEXTLEN,"jl %08x",GetHandler("VStartVM")->VirtualAddress+JMPOFFSET );
	if( !CompileCode(vhandler->VirtualAddress+STACKOFFSET,text,code,&len) )
		return;
	memcpy(vhandler->AssembleCode+STACKOFFSET,code,len);

	sprintf_s( text,TEXTLEN,"jmp %08x",GetHandler("VStartVM")->VirtualAddress+JMPOFFSET );
	if( !CompileCode(vhandler->VirtualAddress+vhandler->CodeLen,text,code,&len) )
		return;
	memcpy(vhandler->AssembleCode+vhandler->CodeLen,code,len);
	vhandler->CodeLen += len;
	m_CodeEngine->WriteData( vhandler->AssembleCode,vhandler->CodeLen );
}
// 先放置Handler
void CVMFactory::PlaceHandler()
{
	for(int i = 0; i < m_curvhandidx; i++)
	{
		if( strcmp(m_vhandler[i].VMInstrName,"") == 0 )
			break;
		if( strcmp(m_vhandler[i].VMInstrName,"VStartVM") != 0 && 
			strcmp(m_vhandler[i].VMInstrName,"DCheckESP") != 0 )
		{
			m_vhandler[i].VirtualAddress = m_CodeEngine->GetCurrentVirtualAddress();//当前内存地址
			
			char code[16] = {0};
			int  len = 0;
			char text[TEXTLEN] = {0};

			sprintf_s(text,TEXTLEN,"jmp %08x",GetHandler("DCheckESP")->VirtualAddress);
			if( !CompileCode(m_vhandler[i].VirtualAddress+m_vhandler[i].CodeLen,text,code,&len) )
				return;
			memcpy( &m_vhandler[i].AssembleCode[ m_vhandler[i].CodeLen ],code,len);

			m_vhandler[i].CodeLen += len;

			m_CodeEngine->WriteData(m_vhandler[i].AssembleCode,m_vhandler[i].CodeLen);//写进去

			int idx = GetIdxFromVMName(m_vhandler[i].VMInstrName);
			*(DWORD*)((DWORD)m_HandlerTable+idx*4) = m_vhandler[i].VirtualAddress;
		}
	}

	m_JumpTable->WriteData((char*)&m_HandlerTable,sizeof(DWORD)*HANDLERMAXLEN);
}
// 初始化核心宏和Handler
BOOL CVMFactory::InitCoreMacro()
{
	int binit1 = InitCoreManualHandler(); //初始化手动Handler
	int binit2 = InitCoreVMTableHandler();//初始化VM描述表的Handler

	//变动.放到VM指令分析后放置
	//PlaceHandler();//放置Handler,生成JUMP表
	FixStartVM();
	FixCheckESP();

	return (binit1 && binit2);
}
BOOL CVMFactory::InitCoreVMTableHandler()
{
	char asmtext[ASMTEXTLEN] = {0};
	//循环生成汇编码
	for(int i = 0; i < 5; i++ )//编译前5个重要指令
	{
		if( !InterpretHandler.InterpretASMStr(&vmtable[i],asmtext,1024) )
			break;
		if( !CompileHandler(vmtable[i].VMInstrName,asmtext) )//编译这个Handler
			return FALSE;
	}
	return TRUE;
}
BOOL CVMFactory::InitCoreManualHandler()
{
	m_curvhandidx = 0;
	while(TRUE)
	{
		if( strcmp(vm_dname[m_curvhandidx].vm_dname,"") == 0 || vm_dname[m_curvhandidx].FuncAddr == NULL )
			break;
		if( m_curvhandidx >= HANDLERMAXLEN )
		{
			OutputDebugString("超过Handler最大容量");
			return FALSE;
		}
		strcpy_s(m_vhandler[m_curvhandidx].VMInstrName,VMNAMELEN,vm_dname[m_curvhandidx].vm_dname);
		m_vhandler[m_curvhandidx].CodeLen = GetFunctionSize(vm_dname[m_curvhandidx].FuncAddr);
		memcpy(m_vhandler[m_curvhandidx].AssembleCode,GetFunctionRVA(vm_dname[m_curvhandidx].FuncAddr),m_vhandler[m_curvhandidx].CodeLen);
		
		//修复手工的代码没有写的地方,如handler间的相互跳转

		if( !AddVHandlerName(m_vhandler[m_curvhandidx].VMInstrName) )
			return FALSE;

		m_curvhandidx++;
	}
	return TRUE;
}
// 编译生成的Handler代码并添加到Handler
BOOL CVMFactory::CompileHandler(char* handlername,char* asmtext)
{
	if( handlername == NULL || asmtext == NULL )
		return FALSE;

	char Code[CODEMAXLEN] = {0};
	int  codelen = 0;

	t_asmmodel am;
	char errtext[TEXTLEN] = {0};

	char linestr[TEXTLEN] = {0};//得到一行的汇编代码字符串
	int lastk = 0;
	int len = (int)strlen(asmtext);
	for(int k = 0; k < len; k++)
	{
		if( asmtext[k] == '\n' || asmtext[k] == '\0' )
		{
			memset(linestr,0,TEXTLEN);
			memcpy(linestr,&asmtext[lastk],k - lastk );
			lastk = k+1;
			int j=Assemble(linestr,0,&am,0,4,errtext);//编译为2进制代码
			if( strcmp(errtext,"") != 0 )
			{
				OutputDebugStringA("编译出错\n");
				OutputDebugStringA(errtext);
				return FALSE;
			}
			memcpy(&Code[codelen],am.code,am.length);
			codelen += am.length;
		}
	}
	if( codelen == 0 )
	{
		OutputDebugStringA("这个Handler没有代码");
		return FALSE;
	}

	strcpy_s(m_vhandler[m_curvhandidx].VMInstrName,VMNAMELEN,handlername);
	memcpy(m_vhandler[m_curvhandidx].AssembleCode,Code,codelen);
	m_vhandler[m_curvhandidx].CodeLen = codelen;
	
	if( !AddVHandlerName(m_vhandler[m_curvhandidx].VMInstrName) )
		return FALSE;

	m_curvhandidx++;
	return TRUE;
}

//如果是V(自动生成的)指令,返回结构,否则返回NULL
VMTable* CVMFactory::SearchForVMTable(char* vmname)
{
	if( !vmname )
		return NULL;

	for( int i = 0; i < VMTABLEMAXLEN; i++ )
	{
		if( _stricmp(vmtable[i].VMInstrName,"") == 0  ) 
			return NULL;
		if( _stricmp(vmtable[i].VMInstrName,vmname) == 0 )
			return &vmtable[i];
	}
	return NULL;
}

//从VMTABLE中寻找一个VM命令并加载
VMTable* CVMFactory::GetVMTableForAlready(char* vmname)
{
	char asmtext[ASMTEXTLEN] = {0};
	VMTable* table = SearchForVMTable(vmname);
	if( !table )//找不到
	{
		return NULL;
	}
	if( GetHandler(vmname) )//如果已经编译
		return table;
	//找到了则编译在返回
	if( !InterpretHandler.InterpretASMStr(table,asmtext,1024) )
		return NULL;
	if( !CompileHandler(table->VMInstrName,asmtext) )//编译这个Handler
		return NULL;
	return table;
}
// 通过VM指令名称获得索引
int CVMFactory::GetIdxFromVMName(char* vmname)
{
	if( !vmname )
		return -1;
	GetVMTableForAlready(vmname);
	for( int i = 0; i < m_curtableidx; i++ )
	{
		if( _stricmp(m_RandomTable[i].VMInstrName,vmname) == 0 )
			return m_RandomTable[i].idx;
	}
	return -1;
}


void CVMFactory::ClearList()
{
	list<VCodeNode*>::iterator itr;
	for( itr = vmlist.begin(); itr != vmlist.end(); itr++ )
	{
		VCodeNode* tmpnode = *itr;
		delete tmpnode;
	}
	vmlist.clear();
}

// 修改链表中的一些数据(如跳转)
void CVMFactory::FixVCodeList()
{	
	list<VCodeNode*>::iterator itr;
	VCodeNode* lastcode = NULL;
	VCodeNode* vcode = NULL;
	for( itr = vmlist.begin(); itr != vmlist.end(); itr++ )
	{
		vcode = *itr;
		if( vcode )
		{
			if( strstr(vcode->VMInstrName,"LOOP") || vcode->VMInstrName[1] == 'J' )//跳转指令
			{
				lastcode->immconst[0] = (int)GetVMAddrFromVirtualAddress(lastcode->immconst[0]);
				CompileVMCode(lastcode,m_VMCode);//覆盖
			}
		}
		lastcode = vcode;
	}
}
// 编译代码为字节码
BOOL CVMFactory::BuildVMCode(char* baseaddr,list<CodeNode*>* CodeList,char* ErrText)
{
	list<CodeNode*>::iterator itr;
	CodeNode* code;

	ClearList();//清空VM链表

	AddBeginHanlder(&vmlist,m_VMCode);//添加第一句恢复堆栈的VM指令
	for( itr = CodeList->begin(); itr != CodeList->end(); itr++ )
	{
		code = *itr;
		if( code )
		{
			//转换并添加到vm列表
			if( !TranslateVM(code) )
				return FALSE;
		}
	}
	PlaceHandler();//放置Handler,生成JUMP表

	FixVCodeList();
	return TRUE;
}
// 转换为VM结构并加入链表(非编译为字节码)
BOOL CVMFactory::TranslateVM(CodeNode* code)
{
	t_disasm disasm;
	memcpy( &disasm,&code->disasm,sizeof(t_disasm) );
	
	//检测是否为段寄存器
	for(int opidx = 2; opidx > 0; opidx--)
	{
		if( disasm.optype[opidx] == Seg )//为段积存器,暂时不支持
		{
			MessageBox(NULL,"[segment] 对不起,暂时不支持一些操作数.","错误",MB_OK);
			return FALSE;
		}
	}
	VMTable* table = GetVMTableForAlready(disasm.vm_name);
	if( !table )//如果没有收录,则把这句代码放到现实场景中执行.并将当前指令改成指向现实场景的地方
	{
		//执行.....跳转
		CompileUndeclared(&disasm);
		return TRUE;
	}
	for(int opidx = 2; opidx >= 0; opidx--)
	{
		switch(disasm.optype[opidx])
		{
		case Imm://立即数
			{
				AddDPushIMM(opidx,&disasm,m_VMCode);
			}
			break;
		case Reg://寄存器
			{
				AddDPushREG(opidx,&disasm,m_VMCode);
			}
			break;
		case Mem://内存数
			{
				AddDPushMem(opidx,&disasm,m_VMCode);
			}
			break;
		}
	}
	AddVMHandler(&disasm,m_VMCode);//添加真正执行代码的vm指令
	//如果不是跳转指令
	if( !strstr(table->strInstruction,"LOOP") && table->strInstruction[0] != 'J' && table->strInstruction[0] != 'j' &&
		!strstr(table->strInstruction,"CALL") )
	{
			for(int opidx = 0; opidx < 2; opidx++)
			{
				//弹出由辅助指令压入的值
				if( opidx == 0 || table->Reg2Esp )//如果是第1个寄存器或者要求保存第2个寄存器
				{
					switch(disasm.optype[opidx])
					{
					case Imm://立即数
					case Mem://内存数
						{
							AddDFree(opidx,&disasm,m_VMCode);
						}
						break;
					case Reg://寄存器
						{
							AddDPopReg(opidx,&disasm,m_VMCode);
						}
						break;
					}
				}
				else//不是第1个寄存器且不保存第2个寄存器
				{
					AddDFree(opidx,&disasm,m_VMCode);
				}
			}
	}
	if( disasm.reg[0] == RT_Esp )
		AddDRestoreEsp(0,&disasm,m_VMCode);//将VM的ESP的值恢复到EBP
	else
		AddDSaveEsp(0,&disasm,m_VMCode);//将EBP的值保存到VM的ESP

	return TRUE;
}
// 编译未声明的指令
void CVMFactory::CompileUndeclared(t_disasm *disasm)
{
	CompileToRealCode(disasm);
	CompileReEnterStubCode(disasm);
	CompileVMEnterStubCode();
}

// 编译退出并跳转到真实环境执行的代码
void CVMFactory::CompileToRealCode(t_disasm *disasm)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	vcodenode->immconst[0] = m_EnterStub->GetCurrentVirtualAddress();
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"VTOREAL");//添加真正执行的VM指令
	CompileVMCode(vcodenode,m_VMCode);
	vmlist.push_back(vcodenode);
}

// 编译从代码中进入虚拟机的汇编代码片段
void CVMFactory::CompileEnterStubCode(char* baseaddr,DWORD VirtualAddress,int len)
{
	char entercode[100] = {0};
	int enterlen = 0;
	char asmtext[TEXTLEN] = {0};
	sprintf_s(asmtext,TEXTLEN,"%spush %x\n",asmtext,m_VMCode->GetCurrentVirtualAddress());//进入的VMCODE片段
	sprintf_s(asmtext,TEXTLEN,"%sjmp  %x\n",asmtext,GetHandler("VStartVM")->VirtualAddress);

	if( !CompileCode(VirtualAddress,asmtext,entercode,&enterlen) )
	{
		MessageBox(0,"编译stub代码出现错误","错误",MB_OK);
		return;
	}
	memset(baseaddr,0xCC,len);//写成CC
	memcpy(baseaddr,entercode,enterlen);//进入VM的代码
}
// 编译重新进入虚拟机的汇编代码片段
DWORD CVMFactory::CompileReEnterStubCode(t_disasm *disasm)
{
	char code[100] = {0};
	int  codelen = 0;
	char entercode[100] = {0};
	int len = 0;
	char asmtext[TEXTLEN] = {0};
	int hexlen = 0;
	sprintf_s(asmtext,TEXTLEN,"%spush %x\n",asmtext,m_VMEnterStubCode->GetCurrentVirtualAddress());//VM重新进入的VMCODE片段
	sprintf_s(asmtext,TEXTLEN,"%sjmp  %x\n",asmtext,GetHandler("VStartVM")->VirtualAddress);

	if( disasm )
	{
		hexlen = disasm->codelen;
	}
	if( !CompileCode(m_EnterStub->GetCurrentVirtualAddress()+hexlen,asmtext,entercode,&len) )
	{
		MessageBox(0,"编译stub代码出现错误","错误",MB_OK);
		return 0;
	}
	if( disasm )
	{
		memcpy(&code[codelen],disasm->hexcode,disasm->codelen);
		codelen += disasm->codelen;
	}
	memcpy(&code[codelen],entercode,len);
	codelen += len;
	int start = m_EnterStub->WriteData(code,codelen);

	return start;
}

// 编译重新进入虚拟机的VM代码片段
void CVMFactory::CompileVMEnterStubCode()
{
	list<VCodeNode*> revmlist;
	AddBeginHanlder(&revmlist,m_VMEnterStubCode);//添加第一句恢复堆栈的VM指令

	VCodeNode* vcodenode = new VCodeNode();
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	vcodenode->OperandNum = 1;
	vcodenode->immconst[0] = m_VMCode->GetCurrentVirtualAddress();
	CompileVMCode(vcodenode,m_VMEnterStubCode);

	vcodenode = new VCodeNode();
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"VJMP_IMM32");
	vcodenode->OperandNum = 0;
	CompileVMCode(vcodenode,m_VMEnterStubCode);

	delete vcodenode;vcodenode = NULL;
}

// 通过汇编语句所在的虚拟地址找出VM语句所在的地址
DWORD CVMFactory::GetVMAddrFromVirtualAddress(DWORD VirtualAddress)
{
	list<VCodeNode*>::iterator itr;
	VCodeNode* code;
	if( !VirtualAddress )
		return 0;
	for( itr = vmlist.begin(); itr != vmlist.end(); itr++ )
	{
		code = *itr;
		if( code )
		{
			if( VirtualAddress == code->InAddress)
			{
				return code->VMAddress;
			}
		}
	}
	return 0;
}
// 进入VM后执行的第一条恢复指令
void CVMFactory::AddBeginHanlder(list<VCodeNode*>* vlist,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = 0;
	vcodenode->OperandNum = 0;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"VBEGIN");//添加真正执行的VM指令
	CompileVMCode(vcodenode,sect);
	vlist->push_back(vcodenode);
}
//添加handler到链表中
void CVMFactory::AddVMHandler(t_disasm *disasm,CVirtualMemory* sect)
{

	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,disasm->vm_name);//添加真正执行的VM指令
	if( strstr(disasm->vm_name,"VCALL") )//如果是CALL调用
	{
		vcodenode->OperandNum = 1;
		vcodenode->immconst[0] = CompileReEnterStubCode(NULL);//跳到CALL返回的地方
		AddVMHandlerEx(vcodenode,disasm,sect);
		CompileVMEnterStubCode();//跟上一句前后顺序不能变
	}
	else
	{
		vcodenode->OperandNum = 0;
		AddVMHandlerEx(vcodenode,disasm,sect);
	}
}
//非CALL
void CVMFactory::AddVMHandlerEx(VCodeNode* vcodenode,t_disasm *disasm,CVirtualMemory* sect)
{
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
// 辅助VM指令
void CVMFactory::AddDPushIMM(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	if( ( disasm->cmdtype & C_JMC ) == C_JMC || disasm->vm_name[1] == 'J' )
	{
		//MessageBox(0,"hi.上次不是没解决这里的问题么。","hi.",MB_OK);
		vcodenode->immconst[0] = disasm->jmpconst;
	}
	else
	{
		vcodenode->immconst[0] = disasm->immconst;
	}
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}

void CVMFactory::AddDPushREG(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	//asm的regname偏移和RT_REG是一样的
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushReg32");
	
	int regoffset = disasm->reg[idx];
	//push pop应该不会有8位的,一般不成立
	if( disasm->highbit[idx] )//如果是高位
		regoffset++;//取高位
	vcodenode->immconst[0] = InterpretHandler.GetRegisterOffset(regoffset);//寄存器偏移

	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
void CVMFactory::AddDPushMem(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	vcodenode->immconst[0] = disasm->adrconst;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	CompileVMCode(vcodenode,sect);//压入MEM中的常数
	vmlist.push_back(vcodenode);

	vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	vcodenode->immconst[0] = disasm->regsscale;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	CompileVMCode(vcodenode,sect);//压入第2个寄存器的比例
	vmlist.push_back(vcodenode);

	vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	vcodenode->immconst[0] = InterpretHandler.GetRegisterOffset(disasm->addrreg2);
	CompileVMCode(vcodenode,sect);//第2寄存器偏移
	vmlist.push_back(vcodenode);

	vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushImm32");
	vcodenode->immconst[0] = InterpretHandler.GetRegisterOffset(disasm->addrreg1);
	CompileVMCode(vcodenode,sect);//第1寄存器偏移
	vmlist.push_back(vcodenode);
	
	vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 0;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPushMem32");//这个handler会自动平栈再压操作数
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}

void CVMFactory::AddDPopReg(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 1;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DPopReg32");//这个handler会自动平栈再压操作数

	int regoffset = disasm->reg[idx];
	//push pop应该不会有8位的,一般不成立
	if( disasm->highbit[idx] )//如果是高位
		regoffset++;//取高位
	vcodenode->immconst[0] = InterpretHandler.GetRegisterOffset(regoffset);//寄存器偏移

	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
void CVMFactory::AddDFree(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 0;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"DFree");//这个handler会自动平栈再压操作数
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
//保存堆栈
void CVMFactory::AddDSaveEsp(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 0;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"VSAVEESP");//这个handler会自动平栈再压操作数
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
//恢复堆栈
void CVMFactory::AddDRestoreEsp(int idx,t_disasm *disasm,CVirtualMemory* sect)
{
	VCodeNode* vcodenode = new VCodeNode();
	vcodenode->InAddress = disasm->ip;
	vcodenode->OperandNum = 0;
	strcpy_s(vcodenode->VMInstrName,VMNAMELEN,"VRESTOREESP");//这个handler会自动平栈再压操作数
	CompileVMCode(vcodenode,sect);
	vmlist.push_back(vcodenode);
}
// 编译
void CVMFactory::CompileVMCode(VCodeNode* vcodenode,CVirtualMemory* sect)
{
	DWORD aleadyAddr = FALSE;
	if( vcodenode->VMAddress )
	{
		aleadyAddr = TRUE;//已经有地址了
	}
	else
	{
		vcodenode->VMAddress = sect->GetCurrentVirtualAddress();
	}
	BYTE handleidx = (BYTE)GetIdxFromVMName(vcodenode->VMInstrName);
	vcodenode->HexCode[0] = handleidx;
	vcodenode->HexLen = 1;
	for(int i = 0;i < vcodenode->OperandNum;i++)
	{
		*(DWORD*)&vcodenode->HexCode[i+1] = (DWORD)vcodenode->immconst[i];
		vcodenode->HexLen+=4;
	}
	if( aleadyAddr )//已经有地址了则直接覆盖
	{
		sect->WriteData(vcodenode->VMAddress,(char*)vcodenode->HexCode,vcodenode->HexLen);
	}
	else
	{
		sect->WriteData((char*)vcodenode->HexCode,vcodenode->HexLen);
	}
} 
```

`vm-packer/反汇编/反汇编/CVMFactory.h`:

```h
// VMPackLib


#ifndef __CVMFACTORY__
#define __CVMFACTORY__
#include "InterpretHandler.h"
#include "VCommand.h"
#include "CLink.h"
#include "CVirtualMemory.h"
#include "asm\disasm.h"

#pragma   warning(disable:4311)//关闭类型转换警告
#pragma   warning(disable:4312)//关闭类型转换警告

//vstartvm
//Jcc:																		;当流程改变时跳到这里
//mov		ebx,esi															;把伪代码base_addr做key
#define		JCCOFFSET			23
//movzx   eax, byte ptr [esi] 不需要更换密钥时直接跳到这里
#define		JMPOFFSET			25

//DCheckESP跳到vstartvm的偏移
#define		STACKOFFSET			8


// 处理VM的一些事项,填充Handler,生成字节码
class CVMFactory
{

private:
	CVirtualMemory *m_JumpTable;				//JMP表
	CVirtualMemory *m_CodeEngine;				//VM指令引擎
	CVirtualMemory *m_EnterStub;				//重新进入vm的汇编代码
	CVirtualMemory *m_VMEnterStubCode;			//重新进入的vmcode
	CVirtualMemory *m_VMCode;					//通常的vmcode

private:
	CInterpretHandler InterpretHandler;
public:

	CVMFactory();

	~CVMFactory();
private:
	list<VCodeNode*> vmlist;//主要代码链表
	void ClearList();
public:
	// 通过汇编语句所在的虚拟地址找出VM语句所在的地址
	DWORD	GetVMAddrFromVirtualAddress(DWORD VirtualAddress);
	// 编译从代码中进入虚拟机的汇编代码片段
	void	CompileEnterStubCode(char* baseaddr,DWORD VirtualAddress,int len);
	// 编译代码为字节码
	BOOL	BuildVMCode(char* baseaddr,list<CodeNode*> *CodeList,char* ErrText);
	// 转换为VM结构并加入链表(非编译为字节码)
	BOOL	TranslateVM(CodeNode* code);
	// 修改链表中的一些数据(如跳转)
	void	FixVCodeList();

	//添加handler到链表中
	void	AddVMHandler(t_disasm *disasm,CVirtualMemory* sect);
	//非CALL
	void	AddVMHandlerEx(VCodeNode* vcodenode,t_disasm *disasm,CVirtualMemory* sect);
	// 辅助VM指令
	//idx = 第几个操作数
	void	AddDPushIMM(int idx,t_disasm *disasm,CVirtualMemory* sect);
	void	AddDPushREG(int idx,t_disasm *disasm,CVirtualMemory* sect);
	void	AddDPushMem(int idx,t_disasm *disasm,CVirtualMemory* sect);

	void	AddDPopReg(int idx,t_disasm *disasm,CVirtualMemory* sect);
	void	AddDFree(int idx,t_disasm *disasm,CVirtualMemory* sect);
	void	AddDSaveEsp(int idx,t_disasm *disasm,CVirtualMemory* sect);
	void	AddDRestoreEsp(int idx,t_disasm *disasm,CVirtualMemory* sect);

	// 进入VM后执行的第一条恢复指令
	void	AddBeginHanlder(list<VCodeNode*>* vlist,CVirtualMemory* sect);
	// 编译
	// vcodenode = VM结构
	// sect = 所在的内存段
	void	CompileVMCode(VCodeNode* vcodenode,CVirtualMemory* sect);

	// 编译未声明的指令
	void	CompileUndeclared(t_disasm *disasm);
	// 编译重新进入虚拟机的汇编代码片段
	DWORD	CompileReEnterStubCode(t_disasm *disasm);
	// 编译退出并跳转到真实环境执行的代码
	void	CompileToRealCode(t_disasm *disasm);
	// 编译重新进入虚拟机的VM代码片段
	void	CompileVMEnterStubCode();
public:
	// 获得虚拟内存类
	void	SetupVirtualMemory(CVirtualMemory *JumpTable,
								CVirtualMemory *CodeEngine,
								CVirtualMemory *EnterStub,
								CVirtualMemory *VMEnterStub,
								CVirtualMemory *VMCode);
	// 初始化VM环境.
	// 1.初始化寄存器位置
	// 2.初始化核心宏代码(将代码拷贝到结构体中).
	// 3.将Handler写入对应新节的内存地址.
	// 4.得到Handler所在的虚拟地址后,修复相互间的跳转.设置汇编代码中固定的一些值.
	void	InitVM();
private:
	// 初始化核心宏和Handler
	BOOL	InitCoreMacro();
	// 初始化手动Handler
	BOOL    InitCoreManualHandler();
	// 初始化VM描述表的Handler
	BOOL	InitCoreVMTableHandler();
	// 编译生成的Handler代码并添加到Handler
	BOOL	CompileHandler(char* handlername,char* asmtext);
	// 放置Handler
	void	PlaceHandler();
	// 修复StartVM
	void	FixStartVM();
	// 修复DCheckESP
	void	FixCheckESP();
private://service
	// 编译代码
	BOOL	CompileCode(DWORD VirtualAddr,char* asmtext,char *code,int *len);
	// 通过名称获得Handler结构
	VHandler* GetHandler(char* vmname);
	// 添加一个Handler名称到Handler索引表
	BOOL	AddVHandlerName(char* vmname);
	//如果是V(自动生成的)指令,返回结构,否则返回NULL
	VMTable	*SearchForVMTable(char* vmname);
	//从已经加载的指令中搜索,有的话则返回VMTABLE描述表
	VMTable* GetVMTableForAlready(char* vmname);
	// 获得func_stub指向的地址(jmp xxxx)
	HandlerFunc GetFunctionRVA(HandlerFunc Func);
	// 获得函数长度
	int GetFunctionSize(HandlerFunc FuncName);
private:
	// 通过VM指令名称获得索引
	int GetIdxFromVMName(char* vmname);
private:
	// 伪指令数组
	VHandler	m_vhandler[HANDLERMAXLEN];
	int			m_curvhandidx;
private:
	// Handler所对应的随机序列
	VM_RandomTable	m_RandomTable[HANDLERMAXLEN];
	// 当前用到的序号
	int			m_curtableidx;
	// 初始化一个Handler乱序表,然后每添加一个Handler就从中获取一个索引
	int			m_HandlerIdx[HANDLERMAXLEN];
private:
	// Handler地址跳转表
	DWORD		m_HandlerTable[HANDLERMAXLEN];

};// END CLASS DEFINITION CVMFactory

#endif // __CVMFACTORY__
 
```

`vm-packer/反汇编/反汇编/CVirtualMemory.cpp`:

```cpp
// VMPackLib

#include "stdafx.h"
#include "CVirtualMemory.h"

CVirtualMemory::CVirtualMemory()
{
		m_BaseAddr = NULL;
		m_addrlen  = 0;
		m_VirtualBaseAddress = 0;
		CurrentAddress = NULL;
}

CVirtualMemory::CVirtualMemory(DWORD VirtualAddress,
							   int len)
{
		m_BaseAddr = NULL;
		m_addrlen  = 0;
		m_VirtualBaseAddress = 0;
		CurrentAddress = NULL;
		CreateVirtualMemory(VirtualAddress,len);
}

CVirtualMemory::~CVirtualMemory()
{
	if( m_BaseAddr ) delete[] m_BaseAddr;m_BaseAddr = NULL;
}

// 创建一片对应虚拟地址的内存空间
void CVirtualMemory::CreateVirtualMemory(DWORD VirtualAddress,
										 int len)
{
		if( m_BaseAddr ) delete[] m_BaseAddr;m_BaseAddr = NULL;
		m_BaseAddr = new char[len];
		memset(m_BaseAddr,0,len);
		m_addrlen  = len;
		m_VirtualBaseAddress = VirtualAddress;
		CurrentAddress = m_BaseAddr;
}

// 根据内存地址换算出虚拟线性地址
DWORD CVirtualMemory::GetVirtualAddress(char* addr)
{
		if( addr < m_BaseAddr )
			return -1;
		return m_VirtualBaseAddress + (DWORD)(addr - m_BaseAddr);
}

// 根据虚拟地址计算出内存空间地址
char* CVirtualMemory::GetAddrOfVirtualAddr(DWORD VirtualAddress)
{
	return m_BaseAddr + VirtualAddress - m_VirtualBaseAddress;
}

// 复制数据到虚拟内存,返回数据的起始虚拟地址.
DWORD CVirtualMemory::WriteData(char* src,
								   int len)
{
	if( !src || !len )
	{
		MessageBox(0,"内部错误","err",MB_OK);
		return 0;
	}
	if( m_addrlen - (CurrentAddress - m_BaseAddr) < len )//空间不够
	{
		MessageBox(0,"[memory to small]内部错误","err",MB_OK);
		return 0;
	}
	DWORD StartVirtualAddress = 0;
	memcpy(CurrentAddress,src,len);
	StartVirtualAddress = m_VirtualBaseAddress + (DWORD)(CurrentAddress - m_BaseAddr);
	CurrentAddress += len;
	return StartVirtualAddress;
}
//复制数据到指令虚拟内存地址
DWORD CVirtualMemory::WriteData(DWORD VirtualCode,char* src,int len)
{
	if( !src || !len )
		return 0;
	if( m_BaseAddr + m_addrlen - CurrentAddress < len )//空间不够
		return 0;
	DWORD StartVirtualAddress = 0;
	memcpy(GetAddrOfVirtualAddr(VirtualCode),src,len);
	return VirtualCode;
}
// 清空内存
void CVirtualMemory::ClearMemory()
{
	memset(m_BaseAddr,0,m_addrlen);
	CurrentAddress = m_BaseAddr;
}
// 获得还未使用的空间
char* CVirtualMemory::GetCurrentAddr(void)
{
	return CurrentAddress;
}
// 获得当前可用的虚拟地质
DWORD CVirtualMemory::GetCurrentVirtualAddress(void)
{
	return GetVirtualAddress(CurrentAddress);
} 
```

`vm-packer/反汇编/反汇编/CVirtualMemory.h`:

```h
// VMPackLib


#ifndef __CVIRTUALMEMORY__
#define __CVIRTUALMEMORY__


// 虚拟地址内存类
class CVirtualMemory
{

public:
	// 虚拟地址所对应的内存.
	char* m_BaseAddr;
	// 内存的空间大小
	int m_addrlen;
	//虚拟内存地址
	DWORD m_VirtualBaseAddress;
private:
	// 还未使用的起始地址
	char* CurrentAddress;
public:

	CVirtualMemory();

	CVirtualMemory(DWORD VirtualAddress,
			   int len);

	~CVirtualMemory();

	// 创建一片对应虚拟地址的内存空间
	void	CreateVirtualMemory(DWORD VirtualAddress,
						  int len);

	// 根据内存地址换算出虚拟线性地址
	DWORD	GetVirtualAddress(char* addr);

	// 根据虚拟地址计算出内存空间地址
	char*	GetAddrOfVirtualAddr(DWORD VirtualAddress);

	// 复制数据到虚拟内存,返回数据的起始虚拟地址.
	DWORD	WriteData(char* src,int len);
	//复制数据到指令虚拟内存地址
	DWORD	WriteData(DWORD VirtualCode,char* src,int len);
	// 清空内存
	void	ClearMemory();

	// 获得当前可用空间
	char*	GetCurrentAddr(void);
	// 获得当前可用的虚拟地质
	DWORD	GetCurrentVirtualAddress(void);
};// END CLASS DEFINITION CVirtualMemory

#endif // __CVIRTUALMEMORY__

```

`vm-packer/反汇编/反汇编/InterpretHandler.cpp`:

```cpp
#include "StdAfx.h"
#include "InterpretHandler.h"
#include "asm/disasm.h"

CInterpretHandler::CInterpretHandler(void)
{
}

CInterpretHandler::~CInterpretHandler(void)
{
}
// 获得寄存器的偏移
// 16和32位和8位低字节均使用32位enum，8位高字节使用20以上的数
int CInterpretHandler::GetRegisterOffset(int RegType)
{
	if( RegType < 0 )
		return RegType;
	int offset = m_RegisterIdx[RegType]*4;
	if ( RegType >= 20 )
		offset++;//8位高字节的地方
	return offset;
}
//初始化
BOOL CInterpretHandler::Init()
{
	RandListIdx(m_RegisterIdx,REGCOUNT);	//打乱寄存器偏移的索引

	return TRUE;
}

//设置参数
void CInterpretHandler::SetArg(VMTable* table,char* asmtext,int len)
{
	for(int i = 0; i < 3; i++)
	{
		if( i >= table->OperandNum )
			break;
		sprintf_s(asmtext,len,"%smov %s,[esp+%02x]\n",asmtext,ArgReg[i],i*4);//将堆栈中的数据交给参数寄存器
	}
}
//恢复参数
void CInterpretHandler::RestoreArg(VMTable* table,char* asmtext,int len)
{
	//将结果保存回堆栈
	for(int i = 0; i < 3; i++)
	{
		if( i >= table->OperandNum )
			break;
		sprintf_s(asmtext,len,"%smov [esp+%02x],%s\n",asmtext,i*4,ArgReg[i]);
	}
}
//恢复标志
void CInterpretHandler::RestoreFlag(char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%sPush [edi+0x%02x]\nPopfd\n",asmtext,GetRegisterOffset(RT_EFlag));//恢复标志
}
//保存标志
void CInterpretHandler::SaveFlag(char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%sPushfd\nPop [edi+0x%02x]\n",asmtext,GetRegisterOffset(RT_EFlag));//保存标志
}
//根据结构声称ASM字符串
BOOL CInterpretHandler::InterpretASMStr(VMTable* table,char* asmtext,int len)
{
	if( strcmp(table->VMInstrName,"") == 0 || asmtext == NULL ) return FALSE;

	memset(asmtext,0,len);

	SetArg(table,asmtext,len);//设置参数

	//恢复需要的寄存器
	for(int i = 0; i < 4; i++)
	{
		if( table->NeedReg[i] != NONE && table->NeedReg[i] < 14 )
		{
			sprintf_s(asmtext,len,"%smov %s,[edi+0x%02x]\n",asmtext,
				vregname[2][table->NeedReg[i]],GetRegisterOffset(table->NeedReg[i]));
		}
	}

	BOOL After = FALSE;
	if( _stricmp(table->strInstruction,"vBegin") == 0 )
	{
		After = InterpretvBegin(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"vtoReal") == 0 )
	{
		After = InterpretvtoReal(table,asmtext,len);
	}
///////////////////////////////////////////////////////////////////////////////
	else if( _stricmp(table->strInstruction,"push") == 0 )
	{
		After = InterpretPush(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"pop") == 0 )
	{
		After = InterpretPop(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"pushfd") == 0 )
	{
		After = InterpretPushfd(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"popfd") == 0 )
	{
		After = InterpretPopfd(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"pushad") == 0 )
	{
		After = InterpretPushad(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"popad") == 0 )
	{
		After = InterpretPopad(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"enter") == 0 )
	{
		After = InterpretEnter(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"leave") == 0 )
	{
		After = InterpretLeave(table,asmtext,len);
	}
/////////////////////////////////////////////////////////////////////////////////
	else if( _stricmp(table->strInstruction,"jcxz") == 0 )
	{
		RestoreFlag(asmtext,len);
		After = InterpretJCXZ(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"jmp") == 0 )
	{
		After = InterpretJMP(table,asmtext,len);
	}
	else if( table->strInstruction[0] == 'J' || table->strInstruction[0] == 'j' )//不是jcxz和jmp,就是条件跳转了
	{
		RestoreFlag(asmtext,len);
		After = InterpretJCC(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"loope") == 0 )
	{
		RestoreFlag(asmtext,len);
		After = InterpretLoope(table,asmtext,len);
		SaveFlag(asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"retn") == 0 )
	{
		After = InterpretRetn(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"call") == 0 )
	{
		After = InterpretCall(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"SaveEsp") == 0 )
	{
		After = InterpretSaveEsp(table,asmtext,len);
	}
	else if( _stricmp(table->strInstruction,"RestoreEsp") == 0 )
	{
		After = InterpretRestoreEsp(table,asmtext,len);
	}
	else
	{
		After = CommonInstruction(table,asmtext,len);
	}

	//sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址
	//保存寄存器的值
	for(int i = 0; i < 3; i++)
	{
		if( table->SaveReg[i] != NONE )
		{
			sprintf_s(asmtext,len,"%smov [edi+0x%02x],%s\n",asmtext,
				GetRegisterOffset(table->NeedReg[i]),vregname[2][table->NeedReg[i]]);
		}
	}

	if( After )
	{
		RestoreArg(table,asmtext,len);
	}

	_strupr_s(asmtext,ASMTEXTLEN);
	return TRUE;
}
int GetScalestr(int bit,OUT char* scalestr)
{
	int sizeidx = 0;
	if( bit == 8 )
	{
		sizeidx = 0;
		strcpy_s(scalestr,6,"byte");
	}
	else if( bit == 16 )
	{
		sizeidx = 1;
		strcpy_s(scalestr,6,"word");
	}
	else if( bit == 32 )
	{
		sizeidx = 2;
		strcpy_s(scalestr,6,"dword");
	}
	return sizeidx;
}

BOOL CInterpretHandler::CommonInstruction(VMTable* table,char* asmtext,int len)
{
	char scalestr[6] = {0};
	int sizeidx = 0;

	char stroperand[1024] = {0};
	for(int i = 0; i < 3; i++)
	{
		if( i >= table->OperandNum )
			break;
		sizeidx = GetScalestr(table->bitnum[i],scalestr);
		if( table->optype[i] == MEMTYPE )//内存数
		{	//操作数顺序eax,ecx,edx
			sprintf_s(stroperand,1024,"%s%s ptr %s[%s],",stroperand,scalestr,GetSegStr(table->Segment),vregname[2][i]);//得到参数
		}
		else//立即数和寄存器
		{
			sprintf_s(stroperand,1024,"%s%s,",stroperand,vregname[sizeidx][i]);//得到参数
		}
	}
	if( table->OperandNum > 0)
		stroperand[strlen(stroperand)-1] = '\0';//去掉逗号

	RestoreFlag(asmtext,len);
	sprintf_s(asmtext,len,"%s%s %s\n",asmtext,table->strInstruction,stroperand);//真正执行的指令
	SaveFlag(asmtext,len);
	return TRUE;
}

// 获得段前缀
char* CInterpretHandler::GetSegStr(int Segment)
{
	static char segstr[10] = "";
	memset(segstr,0,10);
	if( Segment == SEG_FS )
		strcpy_s(segstr,10,"fs:");
	else if( Segment == SEG_GS )
		strcpy_s(segstr,10,"gs:");
	return segstr;
}
// 首先执行的指令
BOOL CInterpretHandler::InterpretvBegin(VMTable* table,char* asmtext,int len)
{
	//popfd
	//pop ebp
	//pop edi
	//pop esi
	//pop edx
	//pop ecx
	//pop eax
	int s_reg[8] = {RT_EFlag,RT_Ebp,RT_Edi,RT_Esi,RT_Edx,RT_Ecx,RT_Ebx,RT_Eax};

	// 弹出寄存器
	for(int i = 0; i < 8;i++)
	{
		sprintf_s(asmtext,len,"%smov eax,dword ptr [ebp]\n",asmtext);
		sprintf_s(asmtext,len,"%smov [edi+%02X],eax\n",asmtext,GetRegisterOffset(s_reg[i]));
		
		sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);
	}
	// 释放伪地址堆栈
	sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);
	sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址

	return FALSE;
}

// 跳转到真实指令
BOOL CInterpretHandler::InterpretvtoReal(VMTable* table,char* asmtext,int len)
{
	int s_reg[9] = {RT_Esp,RT_EFlag,RT_Ebp,RT_Edi,RT_Esi,RT_Edx,RT_Ecx,RT_Ebx,RT_Eax};
	//之前有一个pushimm32 xxxx地址

	//把这个值放如真实堆栈
	sprintf_s(asmtext,len,"%smov eax,dword ptr [esi]\n",asmtext);//释放4字节堆栈
	sprintf_s(asmtext,len,"%sadd esi,4\n",asmtext);
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);
	sprintf_s(asmtext,len,"%smov dword ptr [ebp],eax\n",asmtext);//eax,第1个参数

	sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址

	// 弹出寄存器
	for(int i = 0; i < 9;i++)
	{
		sprintf_s(asmtext,len,"%spush [edi+%02X]\n",asmtext,GetRegisterOffset(s_reg[i]));
	}
	sprintf_s(asmtext,len,"%spop eax\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebx\n",asmtext);
	sprintf_s(asmtext,len,"%spop ecx\n",asmtext);
	sprintf_s(asmtext,len,"%spop edx\n",asmtext);
	sprintf_s(asmtext,len,"%spop esi\n",asmtext);
	sprintf_s(asmtext,len,"%spop edi\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebp\n",asmtext);
	sprintf_s(asmtext,len,"%spopfd\n",asmtext);
	sprintf_s(asmtext,len,"%spop esp\n",asmtext);
	//返回
	sprintf_s(asmtext,len,"%sretn\n",asmtext);
	return FALSE;
}
//		mov		eax,dword ptr [esp]
//		sub		ebp,4
//		mov		eax,[eax]
//		mov		word ptr [ebp],ax
//解释push
BOOL CInterpretHandler::InterpretPush(VMTable* table,char* asmtext,int len)
{
	char scalestr[6] = {0};
	int sizeidx = 0;
	if( table->bitnum[0] == 8 )
	{
		sizeidx = 0;
		strcpy_s(scalestr,6,"byte");
	}
	else if( table->bitnum[0] == 16 )
	{
		sizeidx = 1;
		strcpy_s(scalestr,6,"word");
	}
	else if( table->bitnum[0] == 32 )
	{
		sizeidx = 2;
		strcpy_s(scalestr,6,"dword");
	}

	sprintf_s(asmtext,len,"%ssub ebp,%d\n",asmtext,table->bitnum[0] / 8);//从堆栈中腾出空间
	if( table->optype[0] == MEMTYPE )
	{
		sprintf_s(asmtext,len,"%smov %s,%s ptr %s[eax]\n",asmtext,vregname[sizeidx][RT_Eax],scalestr,GetSegStr(table->Segment));//得到内存数的值
	}
	sprintf_s(asmtext,len,"%smov %s ptr [ebp],%s\n",asmtext,scalestr,vregname[sizeidx][RT_Eax]);
	return TRUE;
}
//		mov		eax,dword ptr [ebp]
//		add		ebp,4
//		mov		eax,[eax]
//解释pop
BOOL CInterpretHandler::InterpretPop(VMTable* table,char* asmtext,int len)
{
	char scalestr[6] = {0};
	int sizeidx = 0;
	if( table->bitnum[0] == 8 )
	{
		sizeidx = 0;
		strcpy_s(scalestr,6,"byte");
	}
	else if( table->bitnum[0] == 16 )
	{
		sizeidx = 1;
		strcpy_s(scalestr,6,"word");
	}
	else if( table->bitnum[0] == 32 )
	{
		sizeidx = 2;
		strcpy_s(scalestr,6,"dword");
	}
	sprintf_s(asmtext,len,"%smov %s,%s ptr [ebp]\n",asmtext,vregname[sizeidx][RT_Ecx],scalestr);//得到堆栈的值
	sprintf_s(asmtext,len,"%sadd ebp,%d\n",asmtext,table->bitnum[0] / 8);//释放4字节堆栈
	if( table->optype[0] == MEMTYPE )
	{
		sprintf_s(asmtext,len,"%smov %s,%s ptr %s[eax]\n",asmtext,vregname[sizeidx][RT_Eax],scalestr,GetSegStr(table->Segment));//得到内存数的值
	}
	sprintf_s(asmtext,len,"%smov eax,ecx\n",asmtext);//将值给mem(只有mem，因为无论是reg还是mem在vm中都是内存地址)
	return TRUE;
}

//解释pushfd
BOOL CInterpretHandler::InterpretPushfd(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//从堆栈中取得参数
	sprintf_s(asmtext,len,"%smov eax,[edi+%02x]\n",asmtext,GetRegisterOffset(RT_EFlag));//得到EFL
	sprintf_s(asmtext,len,"%smov dword ptr [ebp],eax\n",asmtext);//赋值EFL寄存器
	return TRUE;
}
//解释popfd
BOOL CInterpretHandler::InterpretPopfd(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%smov eax,dword ptr [ebp]\n",asmtext);//赋值EFL寄存器
	sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);//释放堆栈
	sprintf_s(asmtext,len,"%smov [edi+%02x],eax\n",asmtext,GetRegisterOffset(RT_EFlag));//设置EFL
	return TRUE;
}


// 解释pushad
BOOL CInterpretHandler::InterpretPushad(VMTable* table,char* asmtext,int len)
{
	for(int i = 0 ; i < 8;i++)
	{
		sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//从堆栈中取得参数
		sprintf_s(asmtext,len,"%smov eax,[edi+%02x]\n",asmtext,GetRegisterOffset(i));//i = enum RegType
		sprintf_s(asmtext,len,"%smov dword ptr [ebp],eax\n",asmtext);//push
	}
	return TRUE;
}

// 解释popad
BOOL CInterpretHandler::InterpretPopad(VMTable* table,char* asmtext,int len)
{
	for(int i = 8 ; i > 0;i--)
	{
		sprintf_s(asmtext,len,"%smov eax,dword ptr [ebp]\n",asmtext);//
		sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);//释放堆栈
		sprintf_s(asmtext,len,"%smov [edi+%02x],eax\n",asmtext,GetRegisterOffset(i));//i = enum RegType
	}
	return TRUE;
}

// 解释enter
//push ebp
//mov ebp,esp
//sub esp,(L - 1) * 4 ; L > 0才有这步操作，用来存储嵌套的L - 1个子过程的栈框架指针（注意是指针）
//push ebp ; 当前过程的栈框架指针
//sub esp,N
BOOL CInterpretHandler::InterpretEnter(VMTable* table,char* asmtext,int len)
{
	//push ebp
	sprintf_s(asmtext,len,"%smov edx,[edi+%02x]\n",asmtext,GetRegisterOffset(RT_Ebp));//
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//
	sprintf_s(asmtext,len,"%smov dword ptr [ebp],edx\n",asmtext);//push ebp

	//mov ebp,esp
	sprintf_s(asmtext,len,"%smov edx,ebp\n",asmtext);//
	sprintf_s(asmtext,len,"%smov [edi+%02x],edx\n",asmtext,GetRegisterOffset(RT_Esp));//
	
	//sub esp,(L - 1) * 4 ; L > 0才有这步操作
	sprintf_s(asmtext,len,"%smov edx,ebp\n",asmtext);//
	sprintf_s(asmtext,len,"%slea ecx,[ecx*4]\n",asmtext);//ecx = 第2个参数
	sprintf_s(asmtext,len,"%ssub edx,ecx\n",asmtext);//不管是不是0都减去
	sprintf_s(asmtext,len,"%ssub edx,4\n",asmtext);//再减1个4
	sprintf_s(asmtext,len,"%stest ecx,ecx\n",asmtext);//测试是否为0
	sprintf_s(asmtext,len,"%scmovne ebp,edx\n",asmtext);//如果不为0就赋值减去后的结果

	//push ebp
	sprintf_s(asmtext,len,"%smov edx,[edi+%02x]\n",asmtext,GetRegisterOffset(RT_Ebp));//
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//
	sprintf_s(asmtext,len,"%smov dword ptr [ebp],edx\n",asmtext);//push ebp

	//sub esp,N
	sprintf_s(asmtext,len,"%ssub ebp,eax\n",asmtext);//eax,第1个参数
	return TRUE;
}

// 解释leave
// mov ebp,esp
// pop ebp
BOOL CInterpretHandler::InterpretLeave(VMTable* table,char* asmtext,int len)
{
	//mov ebp,esp
	sprintf_s(asmtext,len,"%smov edx,ebp\n",asmtext);//
	sprintf_s(asmtext,len,"%smov [edi+%02x],edx\n",asmtext,GetRegisterOffset(RT_Esp));//
	//pop ebp
	sprintf_s(asmtext,len,"%smov eax,[ebp]\n",asmtext);//
	sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);//释放堆栈
	sprintf_s(asmtext,len,"%smov [edi+%02x],eax\n",asmtext,GetRegisterOffset(RT_Ebp));//
	return TRUE;
}
///////////////////////////////////////////////////
// 解释jmp
BOOL CInterpretHandler::InterpretJMP(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%smov esi,eax\n",asmtext);//
	sprintf_s(asmtext,len,"%sadd esp,4\n",asmtext);//
	return FALSE;
}
// 解释jcxz\jecxz
BOOL CInterpretHandler::InterpretJCXZ(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%stest ecx,ecx\n",asmtext);//
	sprintf_s(asmtext,len,"%sCMOVZ esi,eax\n",asmtext);//eax为第1个参数
	sprintf_s(asmtext,len,"%sadd esp,4\n",asmtext);//
	return FALSE;
}	
// 解释jcc
BOOL CInterpretHandler::InterpretJCC(VMTable* table,char* asmtext,int len)
{
	char strPostfix[16] = {0};//条件后缀
	strcpy_s(strPostfix,16,&table->strInstruction[1]);
	sprintf_s(asmtext,len,"%scmov%s esi,[esp]\n",asmtext,strPostfix);//
	sprintf_s(asmtext,len,"%sadd esp,4\n",asmtext);//
	return FALSE;
}
// 解释loope
BOOL CInterpretHandler::InterpretLoope(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%spushfd\n",asmtext);//
	sprintf_s(asmtext,len,"%stest ecx,ecx\n",asmtext);//
	sprintf_s(asmtext,len,"%scmovne edx,eax\n",asmtext);//eax为第1个参数
	sprintf_s(asmtext,len,"%spopfd\n",asmtext);//
	sprintf_s(asmtext,len,"%scmovne edx, esi\n",asmtext);//
	sprintf_s(asmtext,len,"%scmove edx,eax\n",asmtext);//eax为第1个参数
	sprintf_s(asmtext,len,"%sadd ebp,4\n",asmtext);//释放堆栈
	return FALSE;
}


// 解释返回
BOOL CInterpretHandler::InterpretRetn(VMTable* table,char* asmtext,int len)
{
	int s_reg[9] = {RT_Esp,RT_EFlag,RT_Ebp,RT_Edi,RT_Esi,RT_Edx,RT_Ecx,RT_Ebx,RT_Eax};

	if( table->OperandNum == 1 )//retn xxx
	{
		sprintf_s(asmtext,len,"%smov edx,ebp\n",asmtext);
		sprintf_s(asmtext,len,"%sadd ebp,eax\n",asmtext);//retn xx,先放上去
		sprintf_s(asmtext,len,"%smov [ebp],edx\n",asmtext);//再PUSH进retn地址
		sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址
	}
	// 弹出寄存器
	for(int i = 0; i < 9;i++)
	{
		sprintf_s(asmtext,len,"%spush [edi+%02X]\n",asmtext,GetRegisterOffset(s_reg[i]));
	}
	sprintf_s(asmtext,len,"%spop eax\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebx\n",asmtext);
	sprintf_s(asmtext,len,"%spop ecx\n",asmtext);
	sprintf_s(asmtext,len,"%spop edx\n",asmtext);
	sprintf_s(asmtext,len,"%spop esi\n",asmtext);
	sprintf_s(asmtext,len,"%spop edi\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebp\n",asmtext);
	sprintf_s(asmtext,len,"%spopfd\n",asmtext);
	sprintf_s(asmtext,len,"%spop esp\n",asmtext);

	//返回
	sprintf_s(asmtext,len,"%sretn\n",asmtext);
	return FALSE;
}
// 解释子调用
BOOL CInterpretHandler::InterpretCall(VMTable* table,char* asmtext,int len)
{
	int s_reg[9] = {RT_Esp,RT_EFlag,RT_Ebp,RT_Edi,RT_Esi,RT_Edx,RT_Ecx,RT_Ebx,RT_Eax};
	
	sprintf_s(asmtext,len,"%smov edx,[esi]\n",asmtext);
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//4字节空间
	sprintf_s(asmtext,len,"%smov [ebp],edx\n",asmtext);//返回地址
	sprintf_s(asmtext,len,"%ssub ebp,4\n",asmtext);//4字节空间
	if( table->optype[0] == MEMTYPE )
	{
		sprintf_s(asmtext,len,"%smov eax,dword ptr [eax]\n",asmtext);//得到内存数的值
	}
	sprintf_s(asmtext,len,"%smov [ebp],eax\n",asmtext);//CALL的地址 eax = 第一个操作数

	sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址

	// 弹出寄存器
	for(int i = 0; i < 9;i++)
	{
		sprintf_s(asmtext,len,"%spush [edi+%02X]\n",asmtext,GetRegisterOffset(s_reg[i]));
	}
	sprintf_s(asmtext,len,"%spop eax\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebx\n",asmtext);
	sprintf_s(asmtext,len,"%spop ecx\n",asmtext);
	sprintf_s(asmtext,len,"%spop edx\n",asmtext);
	sprintf_s(asmtext,len,"%spop esi\n",asmtext);
	sprintf_s(asmtext,len,"%spop edi\n",asmtext);
	sprintf_s(asmtext,len,"%spop ebp\n",asmtext);
	sprintf_s(asmtext,len,"%spopfd\n",asmtext);
	sprintf_s(asmtext,len,"%spop esp\n",asmtext);

	//返回
	sprintf_s(asmtext,len,"%sretn\n",asmtext);

	return FALSE;//不恢复了
}
// 解释保护堆栈Handler
BOOL CInterpretHandler::InterpretSaveEsp(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%smov [edi+%02x],ebp\n",asmtext,GetRegisterOffset(RT_Esp));//将ebp(即真正esp)保存到esp的地址
	return FALSE;
}
// 解释恢复堆栈Handler
BOOL CInterpretHandler::InterpretRestoreEsp(VMTable* table,char* asmtext,int len)
{
	sprintf_s(asmtext,len,"%smov ebp,[edi+%02x]\n",asmtext,GetRegisterOffset(RT_Esp));//将vmesp的值恢复到ebp(即真正esp)
	return FALSE;
}  
```

`vm-packer/反汇编/反汇编/InterpretHandler.h`:

```h
#pragma once
#include "vmdisasm.h"

class CInterpretHandler
{
public:
	CInterpretHandler(void);
public:
	~CInterpretHandler(void);
private:
	// 寄存器数组索引
	int			m_RegisterIdx[STACKLEN];
public:
	// 初始化
	BOOL Init();
public:
	// 获得寄存器的偏移
	int GetRegisterOffset(int RegType);
	// 获得段前缀
	char* GetSegStr(int Segment);
	// 根据结构声称ASM字符串
	BOOL	InterpretASMStr(VMTable* table,char* asmtext,int len);
private:
	//设置参数
	void SetArg(VMTable* table,char* asmtext,int len);
	//恢复参数
	void RestoreArg(VMTable* table,char* asmtext,int len);
	//恢复标志
	void RestoreFlag(char* asmtext,int len);
	//保存标志
	void SaveFlag(char* asmtext,int len);
private:
	// 首先执行的指令
	BOOL	InterpretvBegin(VMTable* table,char* asmtext,int len);
	// 跳转到真实指令
	BOOL	InterpretvtoReal(VMTable* table,char* asmtext,int len);
	// *********************堆栈类********************************* //
	// 解释push
	BOOL	InterpretPush(VMTable* table,char* asmtext,int len);
	// 解释pop
	BOOL	InterpretPop(VMTable* table,char* asmtext,int len);
	// 解释pushfd
	BOOL	InterpretPushfd(VMTable* table,char* asmtext,int len);
	// 解释popfd
	BOOL	InterpretPopfd(VMTable* table,char* asmtext,int len);
	// 解释pushad
	BOOL	InterpretPushad(VMTable* table,char* asmtext,int len);
	// 解释popad
	BOOL	InterpretPopad(VMTable* table,char* asmtext,int len);
	// 解释enter
	BOOL	InterpretEnter(VMTable* table,char* asmtext,int len);
	// 解释leave
	BOOL	InterpretLeave(VMTable* table,char* asmtext,int len);
	// *********************流程类********************************* //
	// 解释jmp
	BOOL	InterpretJMP(VMTable* table,char* asmtext,int len);
	// 解释jcxz\jecxz
	BOOL	InterpretJCXZ(VMTable* table,char* asmtext,int len);
	// 解释jcc
	BOOL	InterpretJCC(VMTable* table,char* asmtext,int len);
	// 解释loope
	BOOL InterpretLoope(VMTable* table,char* asmtext,int len);

	// 解释返回
	BOOL InterpretRetn(VMTable* table,char* asmtext,int len);
	// 解释子调用
	BOOL InterpretCall(VMTable* table,char* asmtext,int len);

	// 普通指令
	BOOL CommonInstruction(VMTable* table,char* asmtext,int len);
	// 解释保护堆栈Handler
	BOOL InterpretSaveEsp(VMTable* table,char* asmtext,int len);
	// 解释恢复堆栈Handler
	BOOL InterpretRestoreEsp(VMTable* table,char* asmtext,int len);
};
  
```

`vm-packer/反汇编/反汇编/PEStructure.cpp`:

```cpp
#include "StdAfx.h"
#include ".\pestructure.h"

#include <ImageHlp.h>
#pragma comment(lib, "ImageHlp")	// 链接到ImageHlp.lib

CPEStructure::CPEStructure(void)
{
	Init();
}

CPEStructure::~CPEStructure(void)
{
	Free();
}
BOOL CPEStructure::OpenFileName(char* FileName)
{
	DWORD dwBytesRead = 0;

	Free();

	hFile=CreateFileA(FileName,
		GENERIC_READ,
		FILE_SHARE_WRITE | FILE_SHARE_READ,
		NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		MsgBox("打开文件失败",MB_ICONERROR);
		return FALSE;
	}
	dwFsize=GetFileSize( hFile, 0 );
	if(dwFsize == 0)
	{
		CloseHandle( hFile );
		MsgBox("错误的文件长度",MB_ICONERROR);
		return FALSE;
	}
	strcpy_s(m_FileName,256,FileName);
	dwOutPutSize = dwFsize + PackerCode_Size + ALIGN_CORRECTION;
	pMem=(char*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,dwOutPutSize);
	if(pMem == NULL)
	{
		CloseHandle( hFile );
		MsgBox("申请内存出错",MB_ICONERROR);
		return FALSE;
	}
	ReadFile( hFile, pMem, dwFsize, &dwBytesRead, NULL );
	CloseHandle( hFile );

	CopyMemory(&image_dos_header, pMem, sizeof(IMAGE_DOS_HEADER));

	if( image_dos_header.e_magic != IMAGE_DOS_SIGNATURE )
	{
		MsgBox("不是一个有效的PE文件",MB_ICONERROR);
		return FALSE;
	}
	ReservedHeaderRO= sizeof(IMAGE_DOS_HEADER);

	ReservedHeaderSize= image_dos_header.e_lfanew - sizeof(IMAGE_DOS_HEADER);
	reservedheader=new char[ReservedHeaderSize];

	CopyMemory(&image_nt_headers,
		pMem+image_dos_header.e_lfanew,
		sizeof(IMAGE_NT_HEADERS));
	dwRO_first_section=image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
	UpdateHeadersSections(TRUE);
	//-------------------------------------------------
	return TRUE;
}
//----------------------------------------------------------------
void CPEStructure::UpdateHeaders(BOOL bSaveAndValidate)
{
	DWORD SectionNum = image_nt_headers.FileHeader.NumberOfSections;

	if( bSaveAndValidate )//TRUE = 保存数据
	{
		CopyMemory(&image_dos_header,pMem,sizeof(IMAGE_DOS_HEADER));
		ReservedHeaderSize=image_dos_header.e_lfanew - sizeof(IMAGE_DOS_HEADER);
		if( ( ReservedHeaderSize & 0x80000000 ) == 0x00000000)
		{
			CopyMemory(reservedheader, pMem+ReservedHeaderRO, ReservedHeaderSize);
		}
		CopyMemory(&image_nt_headers,
			pMem+image_dos_header.e_lfanew,
			sizeof(IMAGE_NT_HEADERS));
		dwRO_first_section = image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
		CopyMemory(&image_section_header, pMem+dwRO_first_section, SectionNum * sizeof(IMAGE_SECTION_HEADER));
	}
	else				//FALSE = 恢复数据
	{
		CopyMemory(pMem, &image_dos_header, sizeof(IMAGE_DOS_HEADER));
		ReservedHeaderSize=image_dos_header.e_lfanew - sizeof(IMAGE_DOS_HEADER);
		if( (ReservedHeaderSize & 0x80000000) == 0x00000000)
		{
			CopyMemory(pMem+ReservedHeaderRO,reservedheader,ReservedHeaderSize);
		}
		CopyMemory(pMem+image_dos_header.e_lfanew,
			&image_nt_headers,
			sizeof(IMAGE_NT_HEADERS));
		dwRO_first_section=image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
		CopyMemory(pMem+dwRO_first_section, &image_section_header, SectionNum * sizeof(IMAGE_SECTION_HEADER));
	}
}
//----------------------------------------------------------------
void CPEStructure::UpdateHeadersSections(BOOL bSaveAndValidate)
{
	DWORD i = 0;
	DWORD SectionNum = image_nt_headers.FileHeader.NumberOfSections;
	if(bSaveAndValidate)//TRUE = data is being retrieved
	{
		CopyMemory(&image_dos_header, pMem, sizeof(IMAGE_DOS_HEADER));
		ReservedHeaderSize=image_dos_header.e_lfanew - sizeof(IMAGE_DOS_HEADER);
		if(( ReservedHeaderSize & 0x80000000 ) == 0x00000000)
		{
			CopyMemory(reservedheader, pMem + ReservedHeaderRO, ReservedHeaderSize);
		}
		CopyMemory(&image_nt_headers,
			pMem+image_dos_header.e_lfanew,
			sizeof(IMAGE_NT_HEADERS));
		dwRO_first_section = image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
		CopyMemory(&image_section_header, pMem + dwRO_first_section, SectionNum * sizeof(IMAGE_SECTION_HEADER));
		for( i = 0; i < SectionNum; i++ )
		{
			image_section[i]=(char*)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
				PEAlign(image_section_header[i].SizeOfRawData,
				image_nt_headers.OptionalHeader.FileAlignment));
			CopyMemory(image_section[i],
				pMem+image_section_header[i].PointerToRawData,
				image_section_header[i].SizeOfRawData);
		}
		SectionAssigned = TRUE;//已分配空间
	}
	else				//FALSE = data is being initialized 
	{
		CopyMemory(pMem, &image_dos_header, sizeof(IMAGE_DOS_HEADER));
		ReservedHeaderSize = image_dos_header.e_lfanew - sizeof(IMAGE_DOS_HEADER);
		if( ( ReservedHeaderSize & 0x80000000 ) == 0x00000000 )
		{
			CopyMemory(pMem + ReservedHeaderRO, reservedheader, ReservedHeaderSize);
		}
		CopyMemory(pMem+image_dos_header.e_lfanew,
			&image_nt_headers,
			sizeof(IMAGE_NT_HEADERS));
		dwRO_first_section = image_dos_header.e_lfanew + sizeof(IMAGE_NT_HEADERS);
		CopyMemory(pMem + dwRO_first_section, &image_section_header, SectionNum * sizeof(IMAGE_SECTION_HEADER));
		for( i = 0; i < SectionNum; i++ )
		{
			CopyMemory(pMem+image_section_header[i].PointerToRawData,
				image_section[i],
				image_section_header[i].SizeOfRawData);
		}
	}
}
//----------------------------------------------------------------
DWORD CPEStructure::PEAlign(DWORD dwTarNum,DWORD dwAlignTo)
{	
	DWORD dwtemp;
	dwtemp=dwTarNum/dwAlignTo;
	if((dwTarNum%dwAlignTo)!=0)
	{
		dwtemp++;
	}
	dwtemp=dwtemp*dwAlignTo;
	return(dwtemp);
}
//分割得到段和偏移
BOOL CPEStructure::GetFileAddr(char* StrAddress,int* Segment,int* FileOffset)
{
	if( !StrAddress || !Segment || !FileOffset )
		return FALSE;
	char StrSegment[4+1] = {0};
	char StrOffset[8+1] = {0};
	memcpy(StrSegment,StrAddress,4);
	memcpy(StrOffset,StrAddress+5,8);
	*Segment = StringToHex(StrSegment);
	*FileOffset = StringToHex(StrOffset);
	return TRUE;
}

void CPEStructure::LoadMap(char* pmapfilename) 
{
	if( !pmapfilename )
		return;
	FILE* mapfile = NULL;
	mapfile = fopen(pmapfilename,"r+"); //打开MAP FILE处理
	if( !mapfile )
		return;

	FreeMapVector();

	char linestr[512] = {0};            //行数据
	int  readcnt = 0;                   //读的行数
	BOOL bBegin = FALSE;                //开始
	while(!feof(mapfile))
	{
		memset(linestr,0,512);
		if(fgets(linestr,512,mapfile) == NULL) //读一行，最多读512个字节
		{
			break;
		}
		readcnt++; //计算读了多少行
		if( strstr(linestr,"entry point at") != NULL )
		{
			continue;
		}
		if( strstr(linestr,"Line numbers for") != NULL )//行号就不看了
		{
			break;
		}
		if( ( strstr(linestr,"Publics by Value") != NULL && strstr(linestr,"Rva+Base") != NULL ) ||
			( strstr(linestr,"Static symbols") != NULL ) )//开始搜索符号
		{
			bBegin = TRUE;
			continue;
		}
		char StrLine[512] = {0};
		if( !Trim(linestr,StrLine) )//是空行读下一行
		{
			continue;
		}
		if( bBegin )//开始处理
		{
			char StrAddress[16] = {0};//段:偏移
			char StrSymbol[512] = {0};//符号名
			char StrVirtualAddr[16] = {0};//线性地址
			char StrLibObject[512] = {0};//输入文件名
			int Segment = 0;
			int FileOffset = 0;

			memcpy(StrAddress,StrLine,13);
			int nstrlen = strlen(StrLine);
			memmove(StrLine,StrLine+13,nstrlen - 13 + 1);//跳过段偏移

			GetFileAddr(StrAddress,&Segment,&FileOffset);//得到段和偏移
			if( Segment == 0 )//段为0不算
				continue;

			Trim(StrLine,StrLine);
			strcpy_s(StrSymbol,512,StrLine);
			*strchr(StrSymbol,' ') = '\0';                          
			int nlen = strlen(StrSymbol);
			nstrlen = strlen(StrLine);
			memmove(StrLine,StrLine+nlen,strlen(StrLine)-nlen+1);//跳过符号名

			Trim(StrLine,StrLine);

			memcpy(StrVirtualAddr,StrLine,strchr(StrLine,' ')-StrLine);

			nstrlen = strlen(StrLine);
			memmove(StrLine,StrLine+8,nstrlen-8+1);//跳过VirtualAddress

			nstrlen = strlen(StrLine);
			memmove(StrLine,StrLine+5,nstrlen-5+1);//跳过f i ...
			strcpy(StrLibObject,StrLine);
			MapStructrue *mapstruct = new MapStructrue;
			mapstruct->Segment = Segment;                            //段
			mapstruct->Offset = FileOffset;                          //偏移
			strcpy(mapstruct->SymbleName,StrSymbol);                 //符号名
			mapstruct->VirtualAddress = StringToHex(StrVirtualAddr); //线性地址
			strcpy(mapstruct->LibObject,StrLibObject);               //输入文件名

			MapVector.push_back(mapstruct);
		}
	}

	fclose(mapfile);
	mapfile = NULL;

	for( vector<MapStructrue*>::iterator itr = MapVector.begin(); itr != MapVector.end(); itr++ )
	{
		MapStructrue *stu = *itr;
		int a = stu->Segment;
		int b = stu->Offset;
		int nlen = strlen("__ehhandler$");
		if( strstr(stu->SymbleName,"__ehhandler$") )//去掉标记
			memmove(stu->SymbleName,stu->SymbleName+nlen,strlen(stu->SymbleName) - nlen + 1);

		if (!UnDecorateSymbolName(stu->SymbleName, stu->SymbleName, 512, 0xFFF))//no UNDNAME_COMPLETE
		{
			// UnDecorateSymbolName failed
			DWORD error = GetLastError();
			char strerr[255] = {0};
			sprintf(strerr,"解析符号名时出现错误 %d\n", error);
			MsgBox(strerr,MB_ICONERROR);
			break;
		}
		//OutPutStr("%04X:%08X %s %08X %s\n",stu->Segment,stu->Offset,stu->SymbleName,stu->VirtualAddress,stu->LibObject);
		OutPutStr("%s %08X %s\n",stu->SymbleName,stu->VirtualAddress,stu->LibObject);
	}
}

MapStructrue* CPEStructure::GetMap(char* funcname)
{
	for( vector<MapStructrue*>::iterator itr = MapVector.begin(); itr != MapVector.end(); itr++ )
	{
		MapStructrue *stu = *itr;
		if( _stricmp(stu->SymbleName,funcname) == 0)
			return stu;
	}
	return NULL;
}
DWORD CPEStructure::GetNewSection()
{
	DWORD SectionNum = image_nt_headers.FileHeader.NumberOfSections;//得到节数
	return PEAlign( image_section_header[SectionNum-1].VirtualAddress + image_section_header[SectionNum-1].Misc.VirtualSize,
			image_nt_headers.OptionalHeader.SectionAlignment);
}
//----------------------------------------------------------------
// return values:
// 0 - no room for a new section
// 1 - file already encrypted
// else: returns a pointer to the IMAGE_SECTION_HEADER struct of the new section
PIMAGE_SECTION_HEADER CPEStructure::AddSection(char* Base,int len,char* SectionName)
{
	DWORD newSectionOffset;
	DWORD SectionNum = image_nt_headers.FileHeader.NumberOfSections;//得到节数
	newSectionOffset = dwRO_first_section + image_nt_headers.FileHeader.NumberOfSections*sizeof(IMAGE_SECTION_HEADER);

	// check whether there's room for a new section
	if( image_nt_headers.OptionalHeader.SizeOfHeaders < ( newSectionOffset + sizeof(IMAGE_SECTION_HEADER) ) )
	{
		return NULL;
	}

	// create a new section

	// go to the last section
	for(DWORD i=0;i<(SectionNum-1);i++)
	{
		image_section_header[i].Characteristics |= IMAGE_SCN_MEM_WRITE;//可写属性
	}

	// 开始建立一个新节
	CopyMemory(&image_section_header[SectionNum],&image_section_header[SectionNum-1],sizeof(IMAGE_SECTION_HEADER));

	//新节的虚拟地址
	image_section_header[SectionNum].VirtualAddress = PEAlign(image_section_header[SectionNum-1].VirtualAddress+
		image_section_header[SectionNum-1].Misc.VirtualSize,image_nt_headers.OptionalHeader.SectionAlignment);

	image_section_header[SectionNum].Misc.VirtualSize = len;//0x4000;//段长度

	// RawSize..
	//image_section_header[SectionNum].SizeOfRawData = image_section_header[SectionNum-1].PointerToRawData + image_section_header[SectionNum-1].SizeOfRawData;//bughoho
	image_section_header[SectionNum].SizeOfRawData = PEAlign(image_section_header[SectionNum].Misc.VirtualSize,
													 image_nt_headers.OptionalHeader.FileAlignment);//bughoho
	dwOutPutSize += image_section_header[SectionNum].SizeOfRawData;
	// Section name
	int l=(int)strlen(SectionName);
	FillMemory(image_section_header[SectionNum].Name,8,0x00);
	CopyMemory(image_section_header[SectionNum].Name,SectionName,l);
	
	// Characteristics
	image_section_header[SectionNum].Characteristics = IMAGE_SCN_MEM_EXECUTE |
													IMAGE_SCN_MEM_WRITE | 
													IMAGE_SCN_MEM_READ |
													IMAGE_SCN_MEM_EXECUTE |
													IMAGE_SCN_CNT_UNINITIALIZED_DATA |
													IMAGE_SCN_CNT_INITIALIZED_DATA |
													IMAGE_SCN_CNT_CODE;

	// RawOffset
	image_section_header[SectionNum].PointerToRawData = PEAlign(image_section_header[SectionNum-1].PointerToRawData
														+ image_section_header[SectionNum-1].SizeOfRawData,
														image_nt_headers.OptionalHeader.FileAlignment);
	// update the PE header
	image_nt_headers.FileHeader.NumberOfSections++;
	// newsection -> will be returned

	image_nt_headers.OptionalHeader.SizeOfImage = image_section_header[SectionNum].VirtualAddress +
												  image_section_header[SectionNum].Misc.VirtualSize;

	memcpy(pMem + image_section_header[SectionNum].PointerToRawData,Base,len);
	return ((PIMAGE_SECTION_HEADER)&image_section_header[SectionNum]);
}
//----------------------------------------------------------------
void CPEStructure::Init()
{
	SectionAssigned       = FALSE;
	reservedheader        = NULL;
	ReservedHeaderSize    = 0;
	ReservedHeaderRO      = 0;
	hFile                 = 0;
	dwFsize               = 0;
	dwOutPutSize          = 0;
	memset(m_FileName,0,255);
	memset(m_MapFileName,0,255);
}

void CPEStructure::FreeMapVector()
{
	for( vector<MapStructrue*>::iterator itr = MapVector.begin(); itr != MapVector.end(); itr++ )
	{
		MapStructrue* stu = *itr;
		if( stu )
		{
			delete stu;
		}
	}
	MapVector.clear();
}
//----------------------------------------------------------------
void CPEStructure::Free()
{
	if( reservedheader )
	{
		delete[] reservedheader;
		reservedheader = NULL;
	}
	if( !SectionAssigned )
		return;
	DWORD SectionNum = image_nt_headers.FileHeader.NumberOfSections;
	for(DWORD i = 0 ;i < SectionNum;i++)
	{
		GlobalFree(image_section[i]);
		image_section[i] = NULL;
	}
	Init();
}
//制造一个PE
void CPEStructure::MakePE(char* filename,int len)
{
	HANDLE handle;
	DWORD Num;
	handle= ::CreateFileA(filename,GENERIC_READ|GENERIC_WRITE,0,NULL,OPEN_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
	if(INVALID_HANDLE_VALUE== handle )
	{
		MessageBox(0,"打开文件失败!","错误",MB_OK);
		return;
	}
	::SetFilePointer(handle,0,0,FILE_BEGIN);
	::WriteFile(handle,pMem,dwOutPutSize,&Num,NULL);
	::CloseHandle(handle);
}  
```

`vm-packer/反汇编/反汇编/PEStructure.h`:

```h
#pragma once
#include "comm.h"

#include <math.h>

#include <vector>
using namespace std;

#define MAX_SECTION_NUM 20
const DWORD PackerCode_Size = 0;//壳代码最大长度
const DWORD ALIGN_CORRECTION = 0;//文件对齐

class CPEStructure
{
public:
	CPEStructure(void);
	~CPEStructure(void);
private:
	DWORD   ReservedHeaderSize;//保留头长度
	DWORD   ReservedHeaderRO;  //DOS头长度

	BOOL    SectionAssigned;//是否已分配
	HANDLE  hFile;//PE文件句柄
	DWORD   dwFsize;//PE文件长度
	DWORD   dwOutPutSize;//PE文件输出长度
	char    *pMem;//PE文件缓冲区
private:
	char    m_FileName[256];//文件名
	char    m_MapFileName[256];//map文件名
public://映射文件
	vector<MapStructrue*> MapVector;
	void LoadMap(char* pmapfilename);//载入分析map文件
	BOOL GetFileAddr(char* StrAddress,int* Segment,int* FileOffset);//分割得到段和偏移
public:
	MapStructrue* GetMap(char* funcname);
public:
	DWORD					dwRO_first_section;
	IMAGE_DOS_HEADER		image_dos_header;
	char					*reservedheader;
	IMAGE_NT_HEADERS		image_nt_headers;
	IMAGE_SECTION_HEADER	image_section_header[MAX_SECTION_NUM];
	char					*image_section[MAX_SECTION_NUM];
	BOOL OpenFileName(char* FileName);
	void UpdateHeaders(BOOL bSaveAndValidate);							   //更新PE头
	void UpdateHeadersSections(BOOL bSaveAndValidate);					   //更新PE节
	DWORD PEAlign(DWORD dwTarNum,DWORD dwAlignTo);						   //PE节对齐
	PIMAGE_SECTION_HEADER AddSection(char* Base,int len,char* SectionName);//添加节
	DWORD GetNewSection();												   //获得新节的VirtualAddress地址
	void Init();
	void Free();
	void FreeMapVector();
	void MakePE(char* filename,int len);//制造一个PE
};

```

`vm-packer/反汇编/反汇编/ReadMe.txt`:

```txt
========================================================================
控制台应用程序：反汇编 项目概述
========================================================================

应用程序向导已为您创建了此 反汇编 应用程序。  

本文件概要介绍组成 反汇编 应用程序的每个文件的内容。


反汇编.vcproj
这是使用应用程序向导生成的 VC++ 项目的主项目文件。 
它包含生成该文件的 Visual C++ 的版本信息，以及有关使用应用程序向导选择的平台、配置和项目功能的信息。

反汇编.cpp
这是主应用程序源文件。

/////////////////////////////////////////////////////////////////////////////
其他标准文件：

StdAfx.h, StdAfx.cpp
这些文件用于生成名为 反汇编.pch 的预编译头 (PCH) 文件和名为 StdAfx.obj 的预编译类型文件。

/////////////////////////////////////////////////////////////////////////////
其他注释：

应用程序向导使用“TODO:”指示应添加或自定义的源代码部分。

/////////////////////////////////////////////////////////////////////////////
```

`vm-packer/反汇编/反汇编/VCommand.cpp`:

```cpp
#include "stdafx.h"
#include "VCommand.h"

//一些需要死写的伪指令


// 进入虚拟机函数
void _declspec(naked) VStartVM()
{
	_asm
	{
		// 将寄存器压入堆栈,由伪指令取出存放到VMReg中
		push eax
		push ebx
		push ecx
		push edx
		push esi
		push edi
		push ebp
		pushfd
		mov		esi,[esp+0x20]												;参数..伪代码开始的地址
		mov     ebp,esp														;ebp就是堆栈了
		sub		esp,0x200
		mov     edi,esp														;edi就是基地址
		sub		esp,0x40													;这时的esp就是vm用的堆栈了
//Jcc:																		;当流程改变时跳到这里
		mov		ebx,esi														;把伪代码base_addr做key
//Exec:																		;段内的伪代码从这里执行

		movzx	eax,byte ptr [esi]											;获得bytecode
		lea		esi,[esi+1]													;跳过这个字节
		//INT3																;解密al
		//jmp   dword ptr [eax*4+JUMPADDR]									;跳到Handler执行处
		VM_END																;VM结束标记
	}
}

//检测堆栈是否覆盖
void _declspec(naked) DCheckESP()
{
	_asm
	{
		lea     eax, dword ptr [edi+0x100]										;得到当前堆栈位置
		cmp     eax,ebp															;比较
		//jl goto...															;小于则继续执行
		nop
		nop																		;否则
		mov     edx, edi
		mov     ecx, esp
		sub     ecx, edx
		push	esi															;保存IP指针
		mov		esi,esp
		sub		esp, 0x60
		mov		edi,esp
		push	edi															;保存新的edi基地址
		sub		esp, 0x40
		cld
		rep movsb															;复制过去
		pop edi
		pop esi
		VM_END																;VM结束标记
	}
}

void _declspec(naked) DPushReg32()
{
	_asm
	{
		mov		eax,dword ptr [esi]											;得到reg偏移
		//INT3
		add		esi,4
		mov		eax,dword ptr [edi+eax]										;得到寄存器的值
		push	eax															;压入寄存器
		VM_END																;VM结束标记
	}
}
void _declspec(naked) DPushImm32()
{
	_asm
	{
		mov		eax,dword ptr [esi]
		//INT3
		add		esi,4
		push	eax
		VM_END																;VM结束标记
	}
}
void _declspec(naked) DPushMem32()
{
	_asm
	{
		mov		edx,0
		mov		ecx,0
		mov		eax,dword ptr [esp]				//第1个寄存器偏移
		test 	eax,eax
		cmovge	edx,dword ptr [edi+eax]			//如果不是负数则赋值
		mov		eax,dword ptr [esp+4]			//第2个寄存器偏移
		test 	eax,eax
		cmovge	ecx,dword ptr [edi+eax]			//如果不是负数则赋值
		imul	ecx,dword ptr [esp+8]			//第2个寄存器的乘积
		add		ecx,dword ptr [esp+0x0C]		//第三个为常量
		add		edx,ecx
		add		esp,0x10//释放参数
		push	edx//插入参数
		VM_END																;VM结束标记
	}
}
//弹回寄存器
void _declspec(naked) DPopReg32()
{
	_asm
	{
		mov		eax,dword ptr [esi]											;得到reg偏移
		add		esi,4
		//INT3
		pop		dword ptr [edi+eax]											;弹回寄存器
		VM_END																;VM结束标记
	}
}

//释放堆栈
void _declspec(naked) DFree()
{
	_asm
	{
		add esp,4
		VM_END																;VM结束标记
	}
}

////push cx
//void VPushReg16()
//{
//	_asm
//	{
//		mov		eax,dword ptr [esp]
//		sub		ebp,2
//		mov		word ptr [ebp],ax
//	}
//}

//void VAdd_Reg32_Imm32()
//{
//	_asm
//	{
//		mov eax,[esp]
//		mov ecx,[esp+4]
//		add eax,ecx
//		mov [esp],eax
//		mov [esp+4],ecx
//	}
//}
//void VAdd_Reg16_Imm16
//{
//	_asm
//	{
//		mov eax,[esp]
//		mov ecx,[esp+4]
//		add	ax,cx
//		mov [esp],eax
//		mov [esp+4],ecx
//	}
//};  
```

`vm-packer/反汇编/反汇编/VCommand.h`:

```h
//"VMEND"结束标记
#define		VM_END								__asm		push    esi \
												__asm		dec     ebp \
												__asm		inc     ebp \
												__asm		dec     esi \
												__asm		inc     esp

#define		INTCC								__asm		_emit	0xCC
// 进入虚拟机
void VStartVM();
//检测堆栈是否覆盖
void DCheckESP();

//带D的为内部Handler
//内部push pop只做32位操作,段寄存器也当寄存器处理
void DPushReg32();
void DPushImm32();
void DPushMem32();

void DPopReg32();//弹回寄存器
void DFree();//释放堆栈

```

`vm-packer/反汇编/反汇编/comm.cpp`:

```cpp
/*-----------------------------------------------------------------------
第20章  虚拟机的设计
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

#include "stdafx.h"
#include "comm.h"
//MessageBox
void MsgBox( char* content, UINT nType )
{
	if( !content )
		return;
	MessageBoxA(NULL,content,VMPACKERTITLE,nType);
}
//去掉换行符和空格
//返回值,当没有内容时返回NULL;
BOOL Trim( char* pstr,char* str )
{
	int i,j = 0;

	if( !pstr || !str )
		return FALSE;

	strcpy(str,pstr);

	j = strlen(str);
	i = 0;
	for(i = 0; i < j; i ++)//去除换行符
	{
		if((str[i] == 0x0a) || (str[i] == 0x0d))
		{
			str[i] = 0;
		}
	}
	j = strlen(str);
	i = 0;
	while(str[i] == ' ')i++;//去掉头步空格
	if(i >= j) //全部空格，不处理
	{
		return FALSE;
	}
	memmove(str,str+i,j-i+1);
	j = strlen(str);
	i = 0;
	while(str[i] == ' ')i--;//去掉尾部空格
	if( i ) str[i] = '\0';
	if(i >= j) //全部空格，不处理
	{
		return FALSE;
	}
	return TRUE;
}
//字符串转16进制数
DWORD StringToHex(char* strSource)
{ 
	DWORD nTemp=0;
	char strTemp[64];

	if( strSource == NULL )
		return -1;
	strcpy(strTemp,strSource);

	for(char cc='G',dd='g';cc<='Z',dd<='z';  cc++,dd++)    //判断输入的字符串是否合法
	{
		if( strchr(strTemp,cc) != NULL || strchr(strTemp,dd) != NULL )
		{
			//::MessageBox(NULL,"请输入正确的16进制字符串!","输入错误",MB_ICONEXCLAMATION);
			return -1;
		}
	}

	for(int i = 0;  i<(int)::strlen(strSource);  i++)
	{
		int nDecNum;
		switch(strSource[i])
		{
		case 'a':
		case 'A':
			nDecNum = 10;
			break;
		case 'b':
		case 'B':
			nDecNum = 11;
			break;
		case 'c':
		case 'C':
			nDecNum = 12;
			break;
		case 'd':
		case 'D':
			nDecNum = 13;
			break;
		case 'e':
		case 'E':
			nDecNum = 14;
			break;
		case 'f':
		case 'F':
			nDecNum = 15;
			break;
		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			nDecNum = strSource[i] - '0';
			break;
		default:
			return 0;   
		}
		nTemp += (DWORD)nDecNum * (long double)pow((long double)16,(int)(strlen(strSource)-i-1));
	}
	return nTemp;
}
void OutPutStr(char *str, ...)
{
	//#if _DEBUG
	char strbuf[1024]; 

	va_list	vl;
	va_start( vl, str );
	vsprintf( strbuf, str, vl );
	va_end( vl);

	OutputDebugString(strbuf);
	//#endif
}  
```

`vm-packer/反汇编/反汇编/comm.h`:

```h

//#include "..\ByteCode\ByteCode\CodeAnalyse.h"

#define VMPACKERTITLE             "VMPacker"

//MessageBox
void MsgBox( char* content, UINT nType = MB_OK );

//去掉换行符和空格
//返回值,当没有内容时返回NULL;
BOOL Trim( char* pstr,char* str );

//字符串转16进制数
DWORD StringToHex(char* strSource);
void OutPutStr(char *str, ...);

struct MapStructrue
{
	WORD  Segment;                   //PE段
	DWORD Offset;                    //偏移
	char  SymbleName[512];           //符号名称
	DWORD VirtualAddress;            //虚拟地址
	char  LibObject[512];            //输入文件名称
	//CLink Codelink;					 //代码链
	MapStructrue()
	{
		Segment = 0;
		Offset = 0;
		VirtualAddress = 0;
		memset(SymbleName,0,512);
		memset(LibObject,0,512);
		//Codelink.RemoveAll();
	}
};
```

`vm-packer/反汇编/反汇编/main.cpp`:

```cpp
/*-----------------------------------------------------------------------
第20章  虚拟机的设计
《加密与解密（第四版）》
(c)  看雪学院 www.kanxue.com 2000-2018
-----------------------------------------------------------------------*/

#include "stdafx.h"
#include "CCodeILFactory.h"
#include ".\pestructure.h"

int main()
{

	CPEStructure pestruct;
	CCodeILFactory codefactory;
	//CLink CodeList;
	list<CodeNode*> CodeList;
	list<CodeNode*> CodeList1;
	pestruct.OpenFileName("G:\\项目\\VMPacker\\ConvertCrackMe\\Release\\ConvertCrackMe.exe");
	pestruct.LoadMap("G:\\项目\\VMPacker\\ConvertCrackMe\\Release\\ConvertCrackMe.map");
	getchar();
	codefactory.Init(0x400000+pestruct.GetNewSection());//创建虚拟内存段

	//MapStructrue* stu = pestruct.GetMap("CmpThread(void *)");

	MapStructrue* stu = pestruct.GetMap("CrackMe(struct HWND__ *)");


	if( !stu )
		return 0;
	char * Base_Addr = pestruct.image_section[stu->Segment-1] + stu->Offset;//得到基地址


	codefactory.DisasmFunction(&CodeList,Base_Addr,stu->VirtualAddress);
	list<CodeNode*>::iterator itr;

	//for( itr = CodeList.begin(); itr != CodeList.end(); itr++ )
	//{
	//	CodeNode* code = *itr;
	//	if( code )
	//	{
	//		char str[255] = "";
	//		sprintf_s(str,255,"vcode:%s\n",code->disasm.vm_name);
	//		OutputDebugStringA(str);
	//		printf("%-24s  %-24s   (MASM)\n",code->disasm.dump,code->disasm.result);
	//	}
	//}

	itr = CodeList.begin();
	CodeNode* code = *itr;
	itr = CodeList.end();
	itr--;
	CodeNode* endcode = *itr;
	int asmlen = endcode->disasm.ip+endcode->disasm.codelen - code->disasm.ip;
	codefactory.VMFactory.CompileEnterStubCode(Base_Addr,code->disasm.ip,asmlen);
	pestruct.UpdateHeadersSections(FALSE);

	char errtext[255] = {0};
	codefactory.BuildCode(Base_Addr,&CodeList,errtext);

	int len = codefactory.m_JumpTable.m_addrlen + codefactory.m_CodeEngine.m_addrlen +
				codefactory.m_EnterStub.m_addrlen + codefactory.m_VMEnterStubCode.m_addrlen + 
				codefactory.m_VMCode.m_addrlen;
	char *newdata = new char[len];
	char *p = newdata;
	memcpy( p,codefactory.m_JumpTable.m_BaseAddr,codefactory.m_JumpTable.m_addrlen );
	p += codefactory.m_JumpTable.m_addrlen;
	memcpy( p,codefactory.m_CodeEngine.m_BaseAddr,codefactory.m_CodeEngine.m_addrlen );
	p += codefactory.m_CodeEngine.m_addrlen;
	memcpy( p,codefactory.m_EnterStub.m_BaseAddr,codefactory.m_EnterStub.m_addrlen );
	p += codefactory.m_EnterStub.m_addrlen;
	memcpy( p,codefactory.m_VMEnterStubCode.m_BaseAddr,codefactory.m_VMEnterStubCode.m_addrlen );
	p += codefactory.m_VMEnterStubCode.m_addrlen;
	memcpy( p,codefactory.m_VMCode.m_BaseAddr,codefactory.m_VMCode.m_addrlen );
	p += codefactory.m_VMCode.m_addrlen;

	pestruct.AddSection(newdata,len,".bug");
	pestruct.UpdateHeaders(FALSE);
	pestruct.UpdateHeadersSections(TRUE);
	pestruct.UpdateHeadersSections(FALSE);
	pestruct.MakePE("G:\\项目\\VMPacker\\ConvertCrackMe\\Release\\ConvertCrackMe.vm.exe",len);

	//#include "asm\disasm.h"
	//ulong l = 0;
	//t_disasm da;
	//char errtext[TEXTLEN] = {0};

	//memset(&da,0,sizeof(t_disasm));
	//// Demonstration of Disassembler.
	//printf("Disassembler:\n");
	//ideal=0; lowercase=1; putdefseg=0;
	//l=Disasm("\xCC",
	//	MAXCMDSIZE,0x400000,&da,DISASM_CODE);
	//printf("%3i  %-24s  %-24s   (MASM)\n",l,da.dump,da.result);
	//getchar();

	return 0;
}
```

`vm-packer/反汇编/反汇编/stdafx.cpp`:

```cpp
// stdafx.cpp : 只包括标准包含文件的源文件
// 反汇编.pch 将作为预编译头
// stdafx.obj 将包含预编译类型信息

#include "stdafx.h"

// TODO: 在 STDAFX.H 中
// 引用任何所需的附加头文件，而不是在此文件中引用

```

`vm-packer/反汇编/反汇编/stdafx.h`:

```h
// stdafx.h : 标准系统包含文件的包含文件，
// 或是经常使用但不常更改的
// 特定于项目的包含文件

#pragma once


#define WIN32_LEAN_AND_MEAN		// 从 Windows 头中排除极少使用的资料

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
//#include <dir.h>
#include <math.h>
#include <float.h>
#include <stdlib.h>
#include <time.h>
#pragma hdrstop

#include <iostream>
#include <list>

using namespace std;

// TODO: 在此处引用程序需要的其他头文件

```

`vm-packer/反汇编/反汇编/vmdisasm.cpp`:

```cpp
#include "stdafx.h"
#include "asm/disasm.h"
#include "vmdisasm.h"

// 为一个索引数组随机排序.
void RandListIdx(int* idx,int cout)
{
	BOOL* IsUsed = new BOOL[cout];
	memset(IsUsed,FALSE,sizeof(BOOL)*cout);
	srand((unsigned)time(NULL));
	while(TRUE)
	{
		BOOL NotComplete = FALSE;
		for(int i = 0; i < cout; i++ )
		{
			if( !IsUsed[i] )
			{
				NotComplete = TRUE;
				break;
			}
		}
		if( !NotComplete )//全部完成
			return;
		int nrand = rand() % cout;
		//if( nrand == 0)//6.9.不能为0,0留给一个NULL的空间
		//	break;
		BOOL NoSame = FALSE;//默认为没有相同的
		for( int i = 0; i < cout; i++ )
		{
			if( IsUsed[i] && nrand == idx[i] )//如果分配了并且生成的数相等
			{
				NoSame = TRUE;
				break;
			}
		}
		if( NoSame )//如果有相同的
			continue;
		for( int i = 0; i < cout; i++ )
		{
			if( !IsUsed[i]  )//如果没有分配
			{
				idx[i] = nrand;
				IsUsed[i] = TRUE;//设为已分配
				break;
			}
		}
	}
	delete[] IsUsed;IsUsed = NULL;
}

```

`vm-packer/反汇编/反汇编/vmdisasm.h`:

```h

////////////////////////////////////////////////////////////////////////////////////
//新段各部分空间的长度

#define JumpTableLen		(HANDLERMAXLEN*4)
#define CodeEngineLen		(4096*4)					//空间存放引擎代码
#define EnterStubAddrLen	(4096)						//重新进入VM的Stub，长度1024字节
#define VMEnterCodeLen		(4096*2)					//空间存放重新进入的vmcode

#define VMCodeLen			(10240*2)					//2K的空间存放VMCode
#define ASMTEXTLEN			1024						//汇编文本长度
////////////////////////////////////////////////////////////////////////////////////

//8086指令字符串长度
#define X86NAMELEN					32
//Handler命令字符串长度
#define VMNAMELEN					32
//Handler的最大Handler长度
#define CODEMAXLEN					512
//最上面存放寄存器,后来的一些就当vm堆栈用了
#define STACKLEN					0x200
//寄存器最大个数
#define REGCOUNT					15
//命令Handler最大个数
#define HANDLERMAXLEN				0xFF
//VMTABEL表的个数
#define VMTABLEMAXLEN				0x400
//核心伪指令个数
#define COREHANDLERLEN				10

//没有用到寄存器
#define NONE	-1

//寄存器
enum RegType
{
	RT_Eax,
	RT_Ecx,
	RT_Edx,
	RT_Ebx,
	RT_Esp,
	RT_Ebp,
	RT_Esi,
	RT_Edi,
	RT_CS,
	RT_DS,
	RT_ES,
	RT_FS,
	RT_GS,
	RT_SS,

	RT_EFlag,//必须是最后一个(为什么?我忘了)
	//
	RT_AH = 20,
	RT_CH,
	RT_DH,
	RT_BH,
};

enum optype
{
	NONETYPE,
	IMMTYPE,
	REGTYPE,
	MEMTYPE,
	CSTYPE,
	DSTYPE,
	ESTYPE,
	SSTYPE,
	FSTYPE,
	GSTYPE,
};

//用来生成handler的汇编代码的结构
struct VMTable
{
	char	VMInstrName[VMNAMELEN];		//VM命令名称
	char	strInstruction[16];			//相对的汇编指令
	int		OperandNum;					//操作数个数
	int		Segment;					//段前缀
	int		optype[2];					//操作类型(寄存器,立即数,内存数)
	int		bitnum[2];					//位数

	int		NeedReg[4];					//执行命令前要使用的寄存器
	int		SaveReg[4];					//执行命令后要保存的指令
	BOOL	Reg2Esp;					//第2个寄存器是否恢复,一般为0不恢复
};
//存放handler的汇编代码,VirtualAddress存放排序后在内存中的地址
struct VHandler
{
	char	VMInstrName[VMNAMELEN];			//VM命令名称
	DWORD	VirtualAddress;				//虚拟地址
	char    AssembleCode[CODEMAXLEN];	//汇编代码
	int     CodeLen;					//函数长度
	VHandler()
	{
		memset(this,0,sizeof(VHandler));
	}
};

//函数定义
typedef void (*HandlerFunc)();
//核心的一些手工VM函数名称和对应的函数
struct VM_DName
{
	char		vm_dname[VMNAMELEN];
	HandlerFunc	FuncAddr;
};

extern VM_DName	vm_dname[COREHANDLERLEN];

//描述一些标准Handler的行为表
extern VMTable	vmtable[VMTABLEMAXLEN];
//寄存器对应表
extern const char *vregname[3][14];
extern const char ArgReg[3][4];

struct VM_RandomTable
{
	char	VMInstrName[VMNAMELEN];			//VM命令名称
	int		idx;							//对应的索引
};

//伪指令宏链表(即字节码的伪代码)
struct VCodeNode 
{
	DWORD	InAddress;					//原来所在的地址
	DWORD	VMAddress;					//VM指令所在的地址
	char	VMInstrName[VMNAMELEN];		//VM命令名称
	BYTE	HexCode[32];				//字节码
	int		HexLen;						//字节码长度
	int		OperandNum;					//操作数个数

	int		immconst[2];				//立即数(寄存器,立即数,内存数)
	int		bitnum[2];					//位数
	VCodeNode()
	{
		InAddress = 0;
		VMAddress = 0;
		memset(VMInstrName,0,VMNAMELEN);
		memset(HexCode,0,32);
		HexLen = 0;
		OperandNum = 0;
		immconst[0] = immconst[1] = bitnum[0] = bitnum[1] = 0;
	}
};

// 为一个索引数组随机排序.
void	RandListIdx(int* idx,int cout);
  
```

`vm-packer/反汇编/反汇编/vmserv.cpp`:

```cpp
#include "stdafx.h"
#include "VCommand.h"
#include "asm\disasm.h"
#include "vmdisasm.h"

const char *vregname[3][14] = 
{
	{ "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH", "CS","DS","ES","FS","GS","SS"  },
	{ "AX", "CX", "DX", "BX", "SP", "BP", "SI", "DI", "CS","DS","ES","FS","GS","SS" },
	{ "EAX","ECX","EDX","EBX","ESP","EBP","ESI","EDI","CS","DS","ES","FS","GS","SS" } 
};
const char ArgReg[3][4] = {"EAX","ECX","EDX"};
//核心的需要手动填充的特殊命令
VM_DName	vm_dname[COREHANDLERLEN] = 
{
	{"VStartVM",VStartVM},//启动函数
	{"DCheckESP",DCheckESP},  //检查ESP是否重复

	{"DPushReg32",DPushReg32},//dpush eax
	{"DPushImm32",DPushImm32},//dpush 1234
	{"DPushMem32",DPushMem32},//dpush 1234
	{"DPopReg32",DPopReg32},  //dpop  ebx
	{"DFree",DFree},    //daddesp 4
	{"",NULL},

	{"",NULL},
};

//用来生成handler的汇编代码
VMTable vmtable[VMTABLEMAXLEN] = 
{
	// 首先要做的事情
	{"VBEGIN","vBegin",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTOREAL","vtoReal",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRETN","RETN",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRETNIMM32","RETN",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAVEESP","SAVEESP",0, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },//保存堆栈
	{"VRESTOREESP","RESTOREESP",0, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },//恢复堆栈

	//堆栈指令。。。要特写

	{"VPUSH_IMM32","PUSH",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_REG16","PUSH",1, SEG_UNDEF, REGTYPE, NONETYPE,16,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_REG32","PUSH",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_MEM16","PUSH",1, SEG_UNDEF, MEMTYPE, NONETYPE,16,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_MEM32","PUSH",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_FSMEM16","PUSH",1, SEG_FS, MEMTYPE, NONETYPE,16,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_FSMEM32","PUSH",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_GSMEM16","PUSH",1, SEG_GS, MEMTYPE, NONETYPE,16,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPUSH_GSMEM32","PUSH",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	
	//少一对push seg

	{"VPOP_REG16","POP",1, SEG_UNDEF, REGTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_REG32","POP",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_MEM16","POP",1, SEG_UNDEF, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_MEM32","POP",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_FSMEM16","POP",1, SEG_FS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_FSMEM32","POP",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_GSMEM16","POP",1, SEG_GS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOP_GSMEM32","POP",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	//少一对pop seg

	{"VPUSHF","PUSHFD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOPF","POPFD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	
	{"VPUSHA","PUSHAD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VPOPA","POPAD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	//ENTER有点不好弄,先忽略
	//{"VENTER_IMM32_IMM32","ENTER",2, SEG_GS, IMMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEAVE",			  "LEAVE",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//流程指令。。。要特写

	{"VCALL_IMM32","CALL",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCALL_REG32","CALL",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCALL_MEM32","CALL",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCALL_FSMEM32","CALL",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCALL_GSMEM32","CALL",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	
	{"VJMP_IMM32","JMP",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJMP_REG32","JMP",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJMP_MEM32","JMP",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJMP_FSMEM32","JMP",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJMP_GSMEM32","JMP",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//有条件转移。。特写

	{"VJA_IMM32","JA",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJAE_IMM32","JNB",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },//=JNB
	{"VJB_IMM32","JB",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJBE_IMM32","JBE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJC_IMM32","JC",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJE_IMM32","JE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJG_IMM32","JG",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJGE_IMM32","JGE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJL_IMM32","JL",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJLE_IMM32","JLE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNA_IMM32","JNA",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNAE_IMM32","JB",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },//=JB
	{"VJNB_IMM32","JNB",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNBE_IMM32","JNBE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNC_IMM32","JNC",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNE_IMM32","JNE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNG_IMM32","JNG",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNGE_IMM32","JNGE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNL_IMM32","JNL",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNLE_IMM32","JNLE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNO_IMM32","JNO",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNP_IMM32","JNP",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNS_IMM32","JNS",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJNZ_IMM32","JNZ",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJO_IMM32","JO",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJP_IMM32","JP",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJPE_IMM32","JPE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJPO_IMM32","JPO",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJS_IMM32","JS",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VJZ_IMM32","JZ",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//条件跳的特例

	{"VJCXZ_IMM32","JCXZ",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, RT_Ecx,NONE,NONE,NONE,		RT_Ecx,NONE,NONE,NONE },

	//条件循环指令。。特写
	//{"VLOOP_IMM32","LOOP",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0, NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLOOPE_IMM32","LOOPE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	//{"VLOOPNE_IMM32","LOOPNE",1, SEG_UNDEF, IMMTYPE, NONETYPE,32,0,NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//无操作数
	{"VAAA","AAA",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VAAD","AAD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VAAM","AAM",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VAAS","AAS",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VCBW","CBW",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VCDQ","CDQ",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Edx,RT_Eax,NONE,NONE,	RT_Edx,RT_Eax,NONE,NONE },
	{"VCLD","CLD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCLI","CLI",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCLTS","CLTS",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMC","CMC",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCPUID","CPUID",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0, RT_Eax,RT_Ebx,RT_Ecx,RT_Edx,	RT_Eax,RT_Ebx,RT_Ecx,RT_Edx },
	{"VCWD","CWD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	{"VCWDE","CWDE",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VDAS","DAS",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },
	{"VNOP","NOP",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSTC","STC",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSTD","STD",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSTI","STI",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLAHF","LAHF",0, SEG_UNDEF, NONETYPE, NONETYPE,0,0,  	RT_Eax,NONE,NONE,NONE,		RT_Eax,NONE,NONE,NONE },

	//1操作数
	{"VINC_REG08","INC",1, SEG_UNDEF, REGTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_REG16","INC",1, SEG_UNDEF, REGTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_REG32","INC",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_MEM08","INC",1, SEG_UNDEF, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_MEM16","INC",1, SEG_UNDEF, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_MEM32","INC",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_FSMEM08","INC",1, SEG_FS, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_FSMEM16","INC",1, SEG_FS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_FSMEM32","INC",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_GSMEM08","INC",1, SEG_GS, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_GSMEM16","INC",1, SEG_GS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VINC_GSMEM32","INC",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	{"VDEC_REG08","DEC",1, SEG_UNDEF, REGTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_REG16","DEC",1, SEG_UNDEF, REGTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_REG32","DEC",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_MEM08","DEC",1, SEG_UNDEF, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_MEM16","DEC",1, SEG_UNDEF, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_MEM32","DEC",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_FSMEM08","DEC",1, SEG_FS, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_FSMEM16","DEC",1, SEG_FS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_FSMEM32","DEC",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_GSMEM08","DEC",1, SEG_GS, MEMTYPE, NONETYPE,8,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_GSMEM16","DEC",1, SEG_GS, MEMTYPE, NONETYPE,16,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VDEC_GSMEM32","DEC",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//乘除指令涉及到参数寄存器和需要寄存器的冲突,暂时忽略.
	//{"VMUL_REG08","MUL",1, SEG_UNDEF, REGTYPE, NONETYPE,8,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_REG16","MUL",1, SEG_UNDEF, REGTYPE, NONETYPE,16,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_REG32","MUL",1, SEG_UNDEF, REGTYPE, NONETYPE,32,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_MEM08","MUL",1, SEG_UNDEF, MEMTYPE, NONETYPE,8,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_MEM16","MUL",1, SEG_UNDEF, MEMTYPE, NONETYPE,16,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_MEM32","MUL",1, SEG_UNDEF, MEMTYPE, NONETYPE,32,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_FSMEM08","MUL",1, SEG_FS, MEMTYPE, NONETYPE,8,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_FSMEM16","MUL",1, SEG_FS, MEMTYPE, NONETYPE,16,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_FSMEM32","MUL",1, SEG_FS, MEMTYPE, NONETYPE,32,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_GSMEM08","MUL",1, SEG_GS, MEMTYPE, NONETYPE,8,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_GSMEM16","MUL",1, SEG_GS, MEMTYPE, NONETYPE,16,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },
	//{"VMUL_GSMEM32","MUL",1, SEG_GS, MEMTYPE, NONETYPE,32,0,  	RT_Edx,RT_Eax,NONE,NONE,		RT_Edx,RT_Eax,NONE,NONE },

	{"VNEG","NEG",1, SEG_UNDEF, IMMTYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VNOT","NOT",1, SEG_UNDEF, IMMTYPE, NONETYPE,0,0,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//2操作数
	//adc
	{"VADC_REG08_REG08","ADC",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG16_REG16","ADC",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG32_REG32","ADC",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG08_IMM32","ADC",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG16_IMM32","ADC",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG32_IMM32","ADC",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG08_MEM08","ADC",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG16_MEM16","ADC",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG32_MEM32","ADC",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM08_REG08","ADC",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM16_REG16","ADC",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM32_REG32","ADC",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM08_IMM32","ADC",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM16_IMM32","ADC",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_MEM32_IMM32","ADC",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM08_IMM32","ADC",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM16_IMM32","ADC",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM32_IMM32","ADC",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM08_IMM32","ADC",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM16_IMM32","ADC",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM32_IMM32","ADC",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG08_FSMEM08","ADC",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG16_FSMEM16","ADC",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG32_FSMEM32","ADC",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG08_GSMEM08","ADC",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG16_GSMEM16","ADC",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_REG32_GSMEM32","ADC",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM08_REG08","ADC",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM16_REG16","ADC",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_FSMEM32_REG32","ADC",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM08_REG08","ADC",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM16_REG16","ADC",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADC_GSMEM32_REG32","ADC",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//add
	{"VADD_REG08_REG08","ADD",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG16_REG16","ADD",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG32_REG32","ADD",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG08_IMM32","ADD",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG16_IMM32","ADD",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG32_IMM32","ADD",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG08_MEM08","ADD",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG16_MEM16","ADD",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG32_MEM32","ADD",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM08_REG08","ADD",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM16_REG16","ADD",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM32_REG32","ADD",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM08_IMM32","ADD",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM16_IMM32","ADD",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_MEM32_IMM32","ADD",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM08_IMM32","ADD",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM16_IMM32","ADD",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM32_IMM32","ADD",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM08_IMM32","ADD",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM16_IMM32","ADD",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM32_IMM32","ADD",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG08_FSMEM08","ADD",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG16_FSMEM16","ADD",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG32_FSMEM32","ADD",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG08_GSMEM08","ADD",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG16_GSMEM16","ADD",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_REG32_GSMEM32","ADD",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM08_REG08","ADD",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM16_REG16","ADD",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_FSMEM32_REG32","ADD",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM08_REG08","ADD",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM16_REG16","ADD",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VADD_GSMEM32_REG32","ADD",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//and
	{"VAND_REG08_REG08","AND",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG16_REG16","AND",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG32_REG32","AND",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG08_IMM32","AND",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG16_IMM32","AND",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG32_IMM32","AND",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG08_MEM08","AND",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG16_MEM16","AND",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG32_MEM32","AND",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG08_FSMEM08","AND",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG16_FSMEM16","AND",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG32_FSMEM32","AND",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG08_GSMEM08","AND",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG16_GSMEM16","AND",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_REG32_GSMEM32","AND",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM08_REG08","AND",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM16_REG16","AND",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM32_REG32","AND",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM08_IMM32","AND",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM16_IMM32","AND",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_MEM32_IMM32","AND",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM08_IMM32","AND",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM16_IMM32","AND",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM32_IMM32","AND",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM08_IMM32","AND",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM16_IMM32","AND",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM32_IMM32","AND",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM08_REG08","AND",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM16_REG16","AND",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_FSMEM32_REG32","AND",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM08_REG08","AND",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM16_REG16","AND",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VAND_GSMEM32_REG32","AND",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//MOV
	{"VMOV_REG08_REG08","MOV",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG16_REG16","MOV",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG32_REG32","MOV",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG08_IMM32","MOV",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG16_IMM32","MOV",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG32_IMM32","MOV",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG08_MEM08","MOV",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG16_MEM16","MOV",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG32_MEM32","MOV",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM08_REG08","MOV",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM16_REG16","MOV",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM32_REG32","MOV",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM08_IMM32","MOV",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM16_IMM32","MOV",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_MEM32_IMM32","MOV",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM08_IMM32","MOV",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM16_IMM32","MOV",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM32_IMM32","MOV",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM08_IMM32","MOV",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM16_IMM32","MOV",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM32_IMM32","MOV",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG08_FSMEM08","MOV",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG16_FSMEM16","MOV",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG32_FSMEM32","MOV",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG08_GSMEM08","MOV",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG16_GSMEM16","MOV",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_REG32_GSMEM32","MOV",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM08_REG08","MOV",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM16_REG16","MOV",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_FSMEM32_REG32","MOV",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM08_REG08","MOV",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM16_REG16","MOV",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOV_GSMEM32_REG32","MOV",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//OR
	{"VOR_REG08_IMM32","OR",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG16_IMM32","OR",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG32_IMM32","OR",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG08_REG08","OR",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG16_REG16","OR",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG32_REG32","OR",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG08_MEM08","OR",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG16_MEM16","OR",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG32_MEM32","OR",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG08_FSMEM08","OR",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG16_FSMEM16","OR",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG32_FSMEM32","OR",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG08_GSMEM08","OR",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG16_GSMEM16","OR",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_REG32_GSMEM32","OR",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM08_REG08","OR",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM16_REG16","OR",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM32_REG32","OR",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM08_REG08","OR",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM16_REG16","OR",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM32_REG32","OR",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_GSMEM08_REG08","OR",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_GSMEM16_REG16","OR",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM08_IMM32","OR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM16_IMM32","OR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_MEM32_IMM32","OR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM08_IMM32","OR",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM16_IMM32","OR",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_FSMEM32_IMM32","OR",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_GSMEM08_IMM32","OR",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_GSMEM16_IMM32","OR",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VOR_GSMEM32_IMM32","OR",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//RCL
	{"VRCL_REG08_IMM32","RCL",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_REG16_IMM32","RCL",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_REG32_IMM32","RCL",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_REG08_REG08","RCL",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_REG16_REG08","RCL",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_REG32_REG08","RCL",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM08_REG08","RCL",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM16_REG08","RCL",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM32_REG08","RCL",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM08_REG08","RCL",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM16_REG08","RCL",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM32_REG08","RCL",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM08_REG08","RCL",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM16_REG08","RCL",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM32_REG08","RCL",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM08_IMM32","RCL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM16_IMM32","RCL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_MEM32_IMM32","RCL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM08_IMM32","RCL",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM16_IMM32","RCL",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_FSMEM32_IMM32","RCL",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM08_IMM32","RCL",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM16_IMM32","RCL",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCL_GSMEM32_IMM32","RCL",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	//RCR
	{"VRCR_REG08_IMM32","RCR",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_REG16_IMM32","RCR",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_REG32_IMM32","RCR",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_REG08_REG08","RCR",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_REG16_REG08","RCR",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_REG32_REG08","RCR",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM08_REG08","RCR",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM16_REG08","RCR",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM32_REG08","RCR",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM08_REG08","RCR",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM16_REG08","RCR",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM32_REG08","RCR",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM08_REG08","RCR",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM16_REG08","RCR",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM32_REG08","RCR",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM08_IMM32","RCR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM16_IMM32","RCR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_MEM32_IMM32","RCR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM08_IMM32","RCR",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM16_IMM32","RCR",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_FSMEM32_IMM32","RCR",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM08_IMM32","RCR",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM16_IMM32","RCR",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VRCR_GSMEM32_IMM32","RCR",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	//ROL
	{"VROL_REG08_IMM32","ROL",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_REG16_IMM32","ROL",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_REG32_IMM32","ROL",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_REG08_REG08","ROL",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_REG16_REG08","ROL",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_REG32_REG08","ROL",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM08_REG08","ROL",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM16_REG08","ROL",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM32_REG08","ROL",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM08_REG08","ROL",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM16_REG08","ROL",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM32_REG08","ROL",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM08_REG08","ROL",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM16_REG08","ROL",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM32_REG08","ROL",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM08_IMM32","ROL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM16_IMM32","ROL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_MEM32_IMM32","ROL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM08_IMM32","ROL",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM16_IMM32","ROL",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_FSMEM32_IMM32","ROL",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM08_IMM32","ROL",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM16_IMM32","ROL",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VROL_GSMEM32_IMM32","ROL",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SAL
	{"VSAL_REG08_IMM32","SAL",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_REG16_IMM32","SAL",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_REG32_IMM32","SAL",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_REG08_REG08","SAL",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_REG16_REG08","SAL",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_REG32_REG08","SAL",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM08_REG08","SAL",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM16_REG08","SAL",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM32_REG08","SAL",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM08_REG08","SAL",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM16_REG08","SAL",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM32_REG08","SAL",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM08_REG08","SAL",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM16_REG08","SAL",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM32_REG08","SAL",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM08_IMM32","SAL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM16_IMM32","SAL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_MEM32_IMM32","SAL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM08_IMM32","SAL",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM16_IMM32","SAL",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_FSMEM32_IMM32","SAL",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM08_IMM32","SAL",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM16_IMM32","SAL",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAL_GSMEM32_IMM32","SAL",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SAR
	{"VSAR_REG08_IMM32","SAR",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_REG16_IMM32","SAR",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_REG32_IMM32","SAR",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_REG08_REG08","SAR",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_REG16_REG08","SAR",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_REG32_REG08","SAR",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM08_REG08","SAR",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM16_REG08","SAR",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM32_REG08","SAR",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM08_REG08","SAR",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM16_REG08","SAR",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM32_REG08","SAR",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM08_REG08","SAR",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM16_REG08","SAR",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM32_REG08","SAR",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM08_IMM32","SAR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM16_IMM32","SAR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_MEM32_IMM32","SAR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM08_IMM32","SAR",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM16_IMM32","SAR",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_FSMEM32_IMM32","SAR",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM08_IMM32","SAR",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM16_IMM32","SAR",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSAR_GSMEM32_IMM32","SAR",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SHL
	{"VSHL_REG08_IMM32","SHL",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_REG16_IMM32","SHL",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_REG32_IMM32","SHL",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_REG08_REG08","SHL",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_REG16_REG08","SHL",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_REG32_REG08","SHL",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM08_REG08","SHL",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM16_REG08","SHL",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM32_REG08","SHL",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM08_REG08","SHL",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM16_REG08","SHL",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM32_REG08","SHL",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM08_REG08","SHL",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM16_REG08","SHL",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM32_REG08","SHL",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM08_IMM32","SHL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM16_IMM32","SHL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_MEM32_IMM32","SHL",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM08_IMM32","SHL",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM16_IMM32","SHL",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_FSMEM32_IMM32","SHL",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM08_IMM32","SHL",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM16_IMM32","SHL",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHL_GSMEM32_IMM32","SHL",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SHR
	{"VSHR_REG08_IMM32","SHR",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_REG16_IMM32","SHR",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_REG32_IMM32","SHR",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_REG08_REG08","SHR",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_REG16_REG08","SHR",2, SEG_UNDEF, REGTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_REG32_REG08","SHR",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM08_REG08","SHR",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM16_REG08","SHR",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM32_REG08","SHR",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM08_REG08","SHR",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM16_REG08","SHR",2, SEG_FS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM32_REG08","SHR",2, SEG_FS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM08_REG08","SHR",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM16_REG08","SHR",2, SEG_GS, MEMTYPE, REGTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM32_REG08","SHR",2, SEG_GS, MEMTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM08_IMM32","SHR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM16_IMM32","SHR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_MEM32_IMM32","SHR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM08_IMM32","SHR",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM16_IMM32","SHR",2, SEG_FS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_FSMEM32_IMM32","SHR",2, SEG_FS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM08_IMM32","SHR",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM16_IMM32","SHR",2, SEG_GS, MEMTYPE, IMMTYPE,16,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSHR_GSMEM32_IMM32","SHR",2, SEG_GS, MEMTYPE, IMMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SBB
	{"VSBB_REG08_REG08","SBB",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG16_REG16","SBB",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG32_REG32","SBB",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG08_IMM32","SBB",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG16_IMM32","SBB",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG32_IMM32","SBB",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG08_MEM08","SBB",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG16_MEM16","SBB",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG32_MEM32","SBB",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM08_REG08","SBB",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM16_REG16","SBB",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM32_REG32","SBB",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM08_IMM32","SBB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM16_IMM32","SBB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_MEM32_IMM32","SBB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM08_IMM32","SBB",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM16_IMM32","SBB",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM32_IMM32","SBB",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM08_IMM32","SBB",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM16_IMM32","SBB",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM32_IMM32","SBB",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG08_FSMEM08","SBB",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG16_FSMEM16","SBB",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG32_FSMEM32","SBB",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG08_GSMEM08","SBB",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG16_GSMEM16","SBB",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_REG32_GSMEM32","SBB",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM08_REG08","SBB",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM16_REG16","SBB",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_FSMEM32_REG32","SBB",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM08_REG08","SBB",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM16_REG16","SBB",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSBB_GSMEM32_REG32","SBB",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//SUB
	{"VSUB_REG08_REG08","SUB",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG16_REG16","SUB",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG32_REG32","SUB",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG08_IMM32","SUB",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG16_IMM32","SUB",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG32_IMM32","SUB",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG08_MEM08","SUB",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG16_MEM16","SUB",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG32_MEM32","SUB",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM08_REG08","SUB",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM16_REG16","SUB",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM32_REG32","SUB",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM08_IMM32","SUB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM16_IMM32","SUB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_MEM32_IMM32","SUB",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM08_IMM32","SUB",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM16_IMM32","SUB",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM32_IMM32","SUB",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM08_IMM32","SUB",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM16_IMM32","SUB",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM32_IMM32","SUB",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG08_FSMEM08","SUB",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG16_FSMEM16","SUB",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG32_FSMEM32","SUB",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG08_GSMEM08","SUB",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG16_GSMEM16","SUB",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_REG32_GSMEM32","SUB",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM08_REG08","SUB",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM16_REG16","SUB",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_FSMEM32_REG32","SUB",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM08_REG08","SUB",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM16_REG16","SUB",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VSUB_GSMEM32_REG32","SUB",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//TEST
	{"VTEST_REG08_REG08","TEST",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG16_REG16","TEST",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG32_REG32","TEST",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG08_IMM32","TEST",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG16_IMM32","TEST",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG32_IMM32","TEST",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG08_MEM08","TEST",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG16_MEM16","TEST",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG32_MEM32","TEST",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM08_REG08","TEST",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM16_REG16","TEST",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM32_REG32","TEST",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM08_IMM32","TEST",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM16_IMM32","TEST",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_MEM32_IMM32","TEST",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM08_IMM32","TEST",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM16_IMM32","TEST",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM32_IMM32","TEST",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM08_IMM32","TEST",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM16_IMM32","TEST",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM32_IMM32","TEST",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG08_FSMEM08","TEST",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG16_FSMEM16","TEST",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG32_FSMEM32","TEST",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG08_GSMEM08","TEST",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG16_GSMEM16","TEST",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_REG32_GSMEM32","TEST",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM08_REG08","TEST",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM16_REG16","TEST",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_FSMEM32_REG32","TEST",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM08_REG08","TEST",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM16_REG16","TEST",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VTEST_GSMEM32_REG32","TEST",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//XOR
	{"VXOR_REG08_REG08","XOR",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG16_REG16","XOR",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG32_REG32","XOR",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG08_IMM32","XOR",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG16_IMM32","XOR",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG32_IMM32","XOR",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG08_MEM08","XOR",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG16_MEM16","XOR",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG32_MEM32","XOR",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM08_REG08","XOR",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM16_REG16","XOR",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM32_REG32","XOR",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM08_IMM32","XOR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM16_IMM32","XOR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_MEM32_IMM32","XOR",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM08_IMM32","XOR",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM16_IMM32","XOR",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM32_IMM32","XOR",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM08_IMM32","XOR",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM16_IMM32","XOR",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM32_IMM32","XOR",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG08_FSMEM08","XOR",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG16_FSMEM16","XOR",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG32_FSMEM32","XOR",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG08_GSMEM08","XOR",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG16_GSMEM16","XOR",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_REG32_GSMEM32","XOR",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM08_REG08","XOR",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM16_REG16","XOR",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_FSMEM32_REG32","XOR",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM08_REG08","XOR",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM16_REG16","XOR",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VXOR_GSMEM32_REG32","XOR",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	
	//XCHG
	{"VXCHG_REG08_REG08","XCHG",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG16_REG16","XCHG",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG32_REG32","XCHG",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG08_MEM08","XCHG",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG16_MEM16","XCHG",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG32_MEM32","XCHG",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_MEM08_REG08","XCHG",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_MEM16_REG16","XCHG",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_MEM32_REG32","XCHG",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG08_FSMEM08","XCHG",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG16_FSMEM16","XCHG",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG32_FSMEM32","XCHG",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG08_GSMEM08","XCHG",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG16_GSMEM16","XCHG",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_REG32_GSMEM32","XCHG",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_FSMEM08_REG08","XCHG",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_FSMEM16_REG16","XCHG",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_FSMEM32_REG32","XCHG",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_GSMEM08_REG08","XCHG",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_GSMEM16_REG16","XCHG",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},
	{"VXCHG_GSMEM32_REG32","XCHG",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE ,TRUE},

	//CMP
	{"VCMP_REG08_REG08","CMP",2, SEG_UNDEF, REGTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG16_REG16","CMP",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG32_REG32","CMP",2, SEG_UNDEF, REGTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG08_IMM32","CMP",2, SEG_UNDEF, REGTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG16_IMM32","CMP",2, SEG_UNDEF, REGTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG32_IMM32","CMP",2, SEG_UNDEF, REGTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG08_MEM08","CMP",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG16_MEM16","CMP",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG32_MEM32","CMP",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM08_REG08","CMP",2, SEG_UNDEF, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM16_REG16","CMP",2, SEG_UNDEF, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM32_REG32","CMP",2, SEG_UNDEF, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM08_IMM32","CMP",2, SEG_UNDEF, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM16_IMM32","CMP",2, SEG_UNDEF, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_MEM32_IMM32","CMP",2, SEG_UNDEF, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM08_IMM32","CMP",2, SEG_FS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM16_IMM32","CMP",2, SEG_FS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM32_IMM32","CMP",2, SEG_FS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM08_IMM32","CMP",2, SEG_GS, MEMTYPE, IMMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM16_IMM32","CMP",2, SEG_GS, MEMTYPE, IMMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM32_IMM32","CMP",2, SEG_GS, MEMTYPE, IMMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG08_FSMEM08","CMP",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG16_FSMEM16","CMP",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG32_FSMEM32","CMP",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG08_GSMEM08","CMP",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG16_GSMEM16","CMP",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_REG32_GSMEM32","CMP",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM08_REG08","CMP",2, SEG_FS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM16_REG16","CMP",2, SEG_FS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_FSMEM32_REG32","CMP",2, SEG_FS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM08_REG08","CMP",2, SEG_GS, MEMTYPE, REGTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM16_REG16","CMP",2, SEG_GS, MEMTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VCMP_GSMEM32_REG32","CMP",2, SEG_GS, MEMTYPE, REGTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//LEA
	{"VLEA_REG08_MEM08","LEA",2, SEG_UNDEF, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG16_MEM16","LEA",2, SEG_UNDEF, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG32_MEM32","LEA",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG08_FSMEM08","LEA",2, SEG_FS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG16_FSMEM16","LEA",2, SEG_FS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG32_FSMEM32","LEA",2, SEG_FS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG08_GSMEM08","LEA",2, SEG_GS, REGTYPE, MEMTYPE,8,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG16_GSMEM16","LEA",2, SEG_GS, REGTYPE, MEMTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VLEA_REG32_GSMEM32","LEA",2, SEG_GS, REGTYPE, MEMTYPE,32,32,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//MOVSX
	{"VMOVSX_REG16_REG16","MOVSX",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_REG08","MOVSX",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_REG16","MOVSX",2, SEG_UNDEF, REGTYPE, REGTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_MEM08","MOVSX",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_MEM16","MOVSX",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_FSMEM08","MOVSX",2, SEG_FS, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_FSMEM16","MOVSX",2, SEG_FS, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_GSMEM08","MOVSX",2, SEG_GS, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVSX_REG32_GSMEM16","MOVSX",2, SEG_GS, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },

	//MOVZX
	{"VMOVZX_REG16_REG16","MOVZX",2, SEG_UNDEF, REGTYPE, REGTYPE,16,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_REG08","MOVZX",2, SEG_UNDEF, REGTYPE, REGTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_REG16","MOVZX",2, SEG_UNDEF, REGTYPE, REGTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_MEM08","MOVZX",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_MEM16","MOVZX",2, SEG_UNDEF, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_FSMEM08","MOVZX",2, SEG_FS, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_FSMEM16","MOVZX",2, SEG_FS, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_GSMEM08","MOVZX",2, SEG_GS, REGTYPE, MEMTYPE,32,8,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
	{"VMOVZX_REG32_GSMEM16","MOVZX",2, SEG_GS, REGTYPE, MEMTYPE,32,16,  	NONE,NONE,NONE,NONE,		NONE,NONE,NONE,NONE },
};
  
```

`vm-packer/反汇编/反汇编/反汇编.vcproj`:

```vcproj
<?xml version="1.0" encoding="gb2312"?>
<VisualStudioProject
	ProjectType="Visual C++"
	Version="8.00"
	Name="反汇编"
	ProjectGUID="{D92E9F73-BB13-4978-93FB-28CC7E69996D}"
	RootNamespace="反汇编"
	Keyword="Win32Proj"
	>
	<Platforms>
		<Platform
			Name="Win32"
		/>
	</Platforms>
	<ToolFiles>
	</ToolFiles>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="0"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				Optimization="0"
				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE"
				MinimalRebuild="true"
				BasicRuntimeChecks="3"
				RuntimeLibrary="3"
				DefaultCharIsUnsigned="true"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="4"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="2"
				GenerateDebugInformation="true"
				SubSystem="1"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			OutputDirectory="$(SolutionDir)$(ConfigurationName)"
			IntermediateDirectory="$(ConfigurationName)"
			ConfigurationType="1"
			CharacterSet="1"
			WholeProgramOptimization="1"
			>
			<Tool
				Name="VCPreBuildEventTool"
			/>
			<Tool
				Name="VCCustomBuildTool"
			/>
			<Tool
				Name="VCXMLDataGeneratorTool"
			/>
			<Tool
				Name="VCWebServiceProxyGeneratorTool"
			/>
			<Tool
				Name="VCMIDLTool"
			/>
			<Tool
				Name="VCCLCompilerTool"
				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE"
				RuntimeLibrary="2"
				UsePrecompiledHeader="2"
				WarningLevel="3"
				Detect64BitPortabilityProblems="true"
				DebugInformationFormat="3"
			/>
			<Tool
				Name="VCManagedResourceCompilerTool"
			/>
			<Tool
				Name="VCResourceCompilerTool"
			/>
			<Tool
				Name="VCPreLinkEventTool"
			/>
			<Tool
				Name="VCLinkerTool"
				LinkIncremental="1"
				GenerateDebugInformation="true"
				SubSystem="1"
				OptimizeReferences="2"
				EnableCOMDATFolding="2"
				TargetMachine="1"
			/>
			<Tool
				Name="VCALinkTool"
			/>
			<Tool
				Name="VCManifestTool"
			/>
			<Tool
				Name="VCXDCMakeTool"
			/>
			<Tool
				Name="VCBscMakeTool"
			/>
			<Tool
				Name="VCFxCopTool"
			/>
			<Tool
				Name="VCAppVerifierTool"
			/>
			<Tool
				Name="VCWebDeploymentTool"
			/>
			<Tool
				Name="VCPostBuildEventTool"
			/>
		</Configuration>
	</Configurations>
	<References>
	</References>
	<Files>
		<Filter
			Name="源文件"
			Filter="cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx"
			UniqueIdentifier="{4FC737F1-C7A5-4376-A066-2A32D752A2FF}"
			>
			<File
				RelativePath=".\CCodeILFactory.cpp"
				>
			</File>
			<File
				RelativePath=".\CLink.cpp"
				>
			</File>
			<File
				RelativePath=".\comm.cpp"
				>
			</File>
			<File
				RelativePath=".\CVirtualMemory.cpp"
				>
			</File>
			<File
				RelativePath=".\CVMFactory.cpp"
				>
			</File>
			<File
				RelativePath=".\InterpretHandler.cpp"
				>
			</File>
			<File
				RelativePath=".\main.cpp"
				>
			</File>
			<File
				RelativePath=".\PEStructure.cpp"
				>
			</File>
			<File
				RelativePath=".\stdafx.cpp"
				>
				<FileConfiguration
					Name="Debug|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
				<FileConfiguration
					Name="Release|Win32"
					>
					<Tool
						Name="VCCLCompilerTool"
						UsePrecompiledHeader="1"
					/>
				</FileConfiguration>
			</File>
			<File
				RelativePath=".\VCommand.cpp"
				>
			</File>
			<File
				RelativePath=".\vmdisasm.cpp"
				>
			</File>
			<File
				RelativePath=".\vmserv.cpp"
				>
			</File>
		</Filter>
		<Filter
			Name="头文件"
			Filter="h;hpp;hxx;hm;inl;inc;xsd"
			UniqueIdentifier="{93995380-89BD-4b04-88EB-625FBE52EBFB}"
			>
			<File
				RelativePath=".\CCodeILFactory.h"
				>
			</File>
			<File
				RelativePath=".\CLink.h"
				>
			</File>
			<File
				RelativePath=".\comm.h"
				>
			</File>
			<File
				RelativePath=".\CVirtualMemory.h"
				>
			</File>
			<File
				RelativePath=".\CVMFactory.h"
				>
			</File>
			<File
				RelativePath=".\InterpretHandler.h"
				>
			</File>
			<File
				RelativePath=".\PEStructure.h"
				>
			</File>
			<File
				RelativePath=".\stdafx.h"
				>
			</File>
			<File
				RelativePath=".\VCommand.h"
				>
			</File>
			<File
				RelativePath=".\vmdisasm.h"
				>
			</File>
		</Filter>
		<Filter
			Name="资源文件"
			Filter="rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav"
			UniqueIdentifier="{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}"
			>
		</Filter>
		<Filter
			Name="ASM"
			>
			<File
				RelativePath=".\ASM\asmserv.cpp"
				>
			</File>
			<File
				RelativePath=".\ASM\assembl.cpp"
				>
			</File>
			<File
				RelativePath=".\ASM\disasm.cpp"
				>
			</File>
			<File
				RelativePath=".\ASM\disasm.h"
				>
			</File>
		</Filter>
		<File
			RelativePath=".\ReadMe.txt"
			>
		</File>
	</Files>
	<Globals>
	</Globals>
</VisualStudioProject>
```

`vm-packer/反汇编/反汇编/反汇编.vcproj.BUG.bug.user`:

```user
<?xml version="1.0" encoding="gb2312"?>
<VisualStudioUserFile
	ProjectType="Visual C++"
	Version="8.00"
	ShowAllFiles="false"
	>
	<Configurations>
		<Configuration
			Name="Debug|Win32"
			>
			<DebugSettings
				Command="$(TargetPath)"
				WorkingDirectory=""
				CommandArguments=""
				Attach="false"
				DebuggerType="3"
				Remote="1"
				RemoteMachine="BUG"
				RemoteCommand=""
				HttpUrl=""
				PDBPath=""
				SQLDebugging=""
				Environment=""
				EnvironmentMerge="true"
				DebuggerFlavor=""
				MPIRunCommand=""
				MPIRunArguments=""
				MPIRunWorkingDirectory=""
				ApplicationCommand=""
				ApplicationArguments=""
				ShimCommand=""
				MPIAcceptMode=""
				MPIAcceptFilter=""
			/>
		</Configuration>
		<Configuration
			Name="Release|Win32"
			>
			<DebugSettings
				Command="$(TargetPath)"
				WorkingDirectory=""
				CommandArguments=""
				Attach="false"
				DebuggerType="3"
				Remote="1"
				RemoteMachine="BUG"
				RemoteCommand=""
				HttpUrl=""
				PDBPath=""
				SQLDebugging=""
				Environment=""
				EnvironmentMerge="true"
				DebuggerFlavor=""
				MPIRunCommand=""
				MPIRunArguments=""
				MPIRunWorkingDirectory=""
				ApplicationCommand=""
				ApplicationArguments=""
				ShimCommand=""
				MPIAcceptMode=""
				MPIAcceptFilter=""
			/>
		</Configuration>
	</Configurations>
</VisualStudioUserFile>

```

`vm-test/main.c`:

```c
#include<stdio.h>
#include<stdint.h>
#include<stdlib.h>
#include<stdbool.h>
#include<string.h>

char flag[8];
uint8_t code[] = {
    2,0,1,
    2,1,1,
    2,2,1,
    2,3,1,
    2,4,1,
    2,5,1,
    2,6,1
};
int getStr(char *buffer,int maxLen){
    char c;  // 读取到的一个字符
    int len = 0;  // 当前输入的字符串的长度
    // 一次读取一个字符，保存到buffer
    // 直到遇到换行符(\n)，或者长度超过maxLen时，停止读取
    while( (c=getchar()) != '\n' ){
        buffer[len++]=c;  // 将读取到的字符保存到buffer
        if(len>=maxLen){
            break;
        }
    }
    buffer[len]='\0';  // 读取结束，在末尾手动添加字符串结束标志
    fflush(stdin);  // 刷新输入缓冲区
    return len;
}

uint8_t vm_start(){
    uint8_t i = 0;
    uint8_t v0,v3,result = 0;
    for(i=0;i<=21;i+=3){
        v0 = code[i];
        v3 = code[i+2];
        result = v0;
        switch( v0 ){
            case 1:
                result = code[i+1];
                flag[result] += v3;
                break;
            case 2:
                result = code[i+1];
                flag[result] -= v3;
                break;
            case 3:
                result = code[i+1];
                flag[result] ^= v3;
                break;
            case 4:
                result = code[i+1];
                flag[result] *= v3;
                break;
            case 5:
                result = code[i+1];
                flag[result] ^= flag[v3];
                break;
            default:
                continue;

        }

    }
    return result;
}
/*
op+index+data
code{
    2,0,1,
    2,1,1,
    2,2,1,
    2,3,1,
    2,4,1,
    2,5,1,
    2,6,1
}

*/
uint8_t result_cmp[] = {49,50,51,52,53,54,55};//2345678
int main(int argc,char ** argv){

    bool succeed = true;
    uint8_t i = 0;
    getStr(flag,7);
    uint8_t len = 0;

    len = strlen(flag);
    printf("%d\n",len);
    vm_start();

    if ( strlen(flag) != 7 )
        succeed = 0;

    for ( i = 0; i <= 6; ++i )
    {
        if ( flag[i] != result_cmp[i] )
        succeed = 0;
    }
    if ( succeed ){
        puts("correct");
    } else{
        puts("wrong");
    }    

    return 0;
}
    
```