Project Path: arc_gmh5225_WDACTools_rpf87ils

Source Tree:

```txt
arc_gmh5225_WDACTools_rpf87ils
├── AppSpecificPolicies
│   └── AppSpecificPolicyTemplate.xml
├── BasePolicies
├── BuildAndDeployPolicies.psm1
├── BuildArtifacts
├── CIPolicyParser.psm1
├── Examples
│   └── ExamplePolicyBuilder.ps1
├── LICENSE
├── Readme.md
├── SupplementalPolicies
├── WDACAuditing.psm1
└── WDACTools.psd1

```

`AppSpecificPolicies/AppSpecificPolicyTemplate.xml`:

```xml
<?xml version="1.0" encoding="utf-8"?>
<SiPolicy xmlns="urn:schemas-microsoft-com:sipolicy" PolicyType="Supplemental Policy">
  <VersionEx>1.0.0.0</VersionEx>
  <BasePolicyID>{FEEDACDC-BEEF-CACE-F00D-FEEDACDCF00D}</BasePolicyID>
  <PolicyID>{817C8595-ADB5-481B-88E9-ADE1D2A4896D}</PolicyID>
  <PlatformID>{2E07F7E4-194C-4D20-B7C9-6F44A6C5A234}</PlatformID>
  <Rules />
  <EKUs />
  <FileRules />
  <Signers />
  <SigningScenarios>
    <SigningScenario Value="131" ID="ID_SIGNINGSCENARIO_DRIVERS_1" >
      <ProductSigners />
    </SigningScenario>
    <SigningScenario Value="12" ID="ID_SIGNINGSCENARIO_WINDOWS" >
      <ProductSigners />
    </SigningScenario>
  </SigningScenarios>
  <UpdatePolicySigners />
  <CiSigners />
  <Settings>
    <Setting Provider="PolicyInfo" Key="Information" ValueName="Name">
      <Value>
        <String>REPLACEME</String>
      </Value>
    </Setting>
    <Setting Provider="PolicyInfo" Key="Information" ValueName="Id">
      <Value>
        <String>REPLACEME</String>
      </Value>
    </Setting>
  </Settings>
</SiPolicy>
```

`BuildAndDeployPolicies.psm1`:

```psm1
function ConvertTo-WDACPolicyRuleValue {
<#
.SYNOPSIS

A helper function to convert Windows Defender Application Control (WDAC) policy rule options to numeric values which are required for the Set-RuleOption cmdlet.

.DESCRIPTION

ConvertTo-WDACPolicyRuleValue converts human-readable WDAC policy rule options to numeric values for use by the Set-RuleOption cmdlet. Due to the poor design of Set-RuleOption, you cannot supply these string values and must supply integeter values which is not intuitive or user-friendly. This function makes calling Set-RuleOption more intuitive.

This function is not designed to be exposed to users. Functions with parameters that support policy rules options should support tab-completion for the human-readble values.

Author: Matthew Graeber

.PARAMETER PolicyOptionStrings

Specifies an array of human-readble policy rule options that want to be set.

.EXAMPLE

ConvertTo-WDACPolicyRuleValue -PolicyOptionStrings 'Enabled:UMCI', 'Enabled:Boot Menu Protection', 'Enabled:Audit Mode'

Returns an array of integer values representing the requested policy rule options. These values can then be more easily supplied to a subsequent call to Set-RuleOption.
#>

    [OutputType([Int[]])]
    [CmdletBinding()]
    param (
        [Parameter(Mandatory, Position = 0)]
        [ValidateSet('Enabled:UMCI',
                     'Enabled:Boot Menu Protection',
                     'Required:WHQL',
                     'Enabled:Audit Mode',
                     'Disabled:Flight Signing',
                     'Enabled:Inherit Default Policy',
                     'Enabled:Unsigned System Integrity Policy',
                     'Allowed:Debug Policy Augmented',
                     'Required:EV Signers',
                     'Enabled:Advanced Boot Options Menu',
                     'Enabled:Boot Audit On Failure',
                     'Disabled:Script Enforcement',
                     'Required:Enforce Store Applications',
                     'Enabled:Managed Installer',
                     'Enabled:Intelligent Security Graph Authorization',
                     'Enabled:Invalidate EAs on Reboot',
                     'Enabled:Update Policy No Reboot',
                     'Enabled:Allow Supplemental Policies',
                     'Disabled:Runtime FilePath Rule Protection',
                     'Enabled:Dynamic Code Security',
                     'Enabled:Revoked Expired As Unsigned')]
        [String[]] $PolicyOptionStrings
    )

    $RuleOptionMapping = @{
        'Enabled:UMCI' = 0
        'Enabled:Boot Menu Protection' = 1
        'Required:WHQL' = 2
        'Enabled:Audit Mode' = 3
        'Disabled:Flight Signing' = 4
        'Enabled:Inherit Default Policy' = 5
        'Enabled:Unsigned System Integrity Policy' = 6
        'Allowed:Debug Policy Augmented' = 7
        'Required:EV Signers' = 8
        'Enabled:Advanced Boot Options Menu' = 9
        'Enabled:Boot Audit On Failure' = 10
        'Disabled:Script Enforcement' = 11
        'Required:Enforce Store Applications' = 12
        'Enabled:Managed Installer' = 13
        'Enabled:Intelligent Security Graph Authorization' = 14
        'Enabled:Invalidate EAs on Reboot' = 15
        'Enabled:Update Policy No Reboot' = 16
        'Enabled:Allow Supplemental Policies' = 17
        'Disabled:Runtime FilePath Rule Protection' = 18
        'Enabled:Dynamic Code Security' = 19
        'Enabled:Revoked Expired As Unsigned' = 20
    }

    foreach ($PolicyOptionString in $PolicyOptionStrings) {
        $RuleOptionMapping[$PolicyOptionString]
    }
}

function New-WDACPolicyConfiguration {
<#
.SYNOPSIS

A helper function used to specify a code integrity policy configuration.

.DESCRIPTION

New-WDACPolicyConfiguration is used as a helper function to generate code integrity policy configuration options and to supply them to the Invoke-WDACCodeIntegrityPolicyBuild function.

The objects output by New-WDACPolicyConfiguration are intended to be supplied as arguments to the following parameters in Invoke-WDACCodeIntegrityPolicyBuild: -BasePolicyConfiguration, -SupplementalPolicyConfiguration, -MergedPolicyConfiguration

Author: Matthew Graeber

.PARAMETER BasePolicy

Specifies that a base policy is to be configured and built. Base policies must reside in the "BasePolicies" directory.

When this switch is specified, the object output is supplied to the -BasePolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.

.PARAMETER SupplementalPolicy

Specifies that a supplemental policy is to be configured and built. Supplemental policies must reside in the "SupplementalPolicies" directory.

When this switch is specified, the object output is supplied to the -SupplementalPolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.

.PARAMETER MergedPolicy

Specifies that a supplemental policy is to be configured and built by merging multiple policies together. Supplemental policies designed for merging must reside in the "AppSpecificPolicies" directory.

When this switch is specified, the object output is supplied to the -MergedPolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.

.PARAMETER FileName

Specifies the filename of the XML policy file. This parameter only applies when the -BasePolicy or -SupplementalPolicy switches are supplied.

.PARAMETER PolicyName

Specifies the name of the policy. Upon deployment of your policy, this policy name will be surfaced in the event log.

.PARAMETER PolicyRuleOptions

Specifies the policy rule options that you want to supply to the specified policy. This parameter supports tab-completion.

.PARAMETER BasePolicyToSupplement

Specifies the base policy that the merged, application-specific policy is a supplement to. This parameter is mandatory when -MergedPolicy is specified.

.EXAMPLE

$BaseDriverPolicy = New-WDACPolicyConfiguration -BasePolicy -FileName 'BaseDriverPolicy.xml' -PolicyName 'BaseDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'

Specifies configuration options for a base policy. The object output would then be supplied to the -BasePolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.

.EXAMPLE

$SupplementalSurfacePolicy = New-WDACPolicyConfiguration -SupplementalPolicy -FileName 'MicrosoftSurfaceDriverPolicy.xml' -PolicyName '3rdPartyDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'

Specifies configuration options for a supplemental policy. The object output would then be supplied to the -SupplementalPolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.

.EXAMPLE

$MergedPolicyConfiguration = New-WDACPolicyConfiguration -MergedPolicy -PolicyName 'Merged3rdPartySoftwareRuleset' -BasePolicyToSupplement 'BaseUserModeRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'

Specifies configuration options for a merged supplemental policy (i.e. the policies that reside in the "AppSpecificPolicies" directory). The object output would then be supplied to the -MergedPolicyConfiguration parameter in Invoke-WDACCodeIntegrityPolicyBuild.
#>

    [CmdletBinding(DefaultParameterSetName = 'Base')]
    param (
        [Parameter(Mandatory, ParameterSetName = 'Base')]
        [Switch]
        $BasePolicy,

        [Parameter(Mandatory, ParameterSetName = 'Supplemental')]
        [Switch]
        $SupplementalPolicy,

        [Parameter(Mandatory, ParameterSetName = 'Merged')]
        [Switch]
        $MergedPolicy,

        [Parameter(Mandatory, ParameterSetName = 'Merged')]
        [String]
        [ValidateNotNullOrEmpty()]
        $BasePolicyToSupplement,

        [Parameter(Mandatory, ParameterSetName = 'Base')]
        [Parameter(Mandatory, ParameterSetName = 'Supplemental')]
        [String]
        $FileName,

        [Parameter(Mandatory)]
        [String]
        $PolicyName,

        [String[]]
        [ValidateSet('Enabled:UMCI',
                     'Enabled:Boot Menu Protection',
                     'Required:WHQL',
                     'Enabled:Audit Mode',
                     'Disabled:Flight Signing',
                     'Enabled:Inherit Default Policy',
                     'Enabled:Unsigned System Integrity Policy',
                     'Allowed:Debug Policy Augmented',
                     'Required:EV Signers',
                     'Enabled:Advanced Boot Options Menu',
                     'Enabled:Boot Audit On Failure',
                     'Disabled:Script Enforcement',
                     'Required:Enforce Store Applications',
                     'Enabled:Managed Installer',
                     'Enabled:Intelligent Security Graph Authorization',
                     'Enabled:Invalidate EAs on Reboot',
                     'Enabled:Update Policy No Reboot',
                     'Enabled:Allow Supplemental Policies',
                     'Disabled:Runtime FilePath Rule Protection',
                     'Enabled:Dynamic Code Security',
                     'Enabled:Revoked Expired As Unsigned')]
        $PolicyRuleOptions
    )

    if ($BasePolicy) {
        $ConfigurationProperties = [Ordered] @{
            PSTypeName        = 'WDACBasePolicyConfiguration'
            FileName          = $FileName
            PolicyName        = $PolicyName
            PolicyRuleOptions = $PolicyRuleOptions
        }
    }

    if ($SupplementalPolicy) {
        $ConfigurationProperties = [Ordered] @{
            PSTypeName        = 'WDACSupplementalPolicyConfiguration'
            FileName          = $FileName
            PolicyName        = $PolicyName
            PolicyRuleOptions = $PolicyRuleOptions
        }
    }

    if ($MergedPolicy) {
        $ConfigurationProperties = [Ordered] @{
            PSTypeName        = 'WDACMergedPolicyConfiguration'
            PolicyName        = $PolicyName
            PolicyRuleOptions = $PolicyRuleOptions
            BasePolicyToSupplement = $BasePolicyToSupplement
        }
    }

    New-Object -TypeName PSObject -Property $ConfigurationProperties
}

function Invoke-WDACCodeIntegrityPolicyBuild {
<#
.SYNOPSIS

Facilitates building and deploying multiple base and supplemental code integrity policies.

.DESCRIPTION

Invoke-WDACCodeIntegrityPolicyBuild builds and, optionally, deploys and refreshes code integrity policies locally.

Author: Matthew Graeber

.PARAMETER CommonBasePolicyRuleOptions

Specifies a set of policy rule options to apply to all generated policy files. This parameter was designed to facilitate consistency

.PARAMETER BasePolicyConfiguration

Specifies one or more base policy configurations that were generated by New-WDACPolicyConfiguration.

.PARAMETER SupplementalPolicyConfiguration

Specifies one or more supplemental policy configurations that were generated by New-WDACPolicyConfiguration.

.PARAMETER MergedPolicyConfiguration

Specifies a merged supplemental policy configuration that was generated by New-WDACPolicyConfiguration.

.PARAMETER ArtifactPath

By default, generated artifacts (code integrity policy XML and binary code integrity policy .cip files) are written to the "BuildArtifacts" directory. This parameter allows you to specify an alternate build artifact directory. The directory must already exist.

.PARAMETER Deploy

Copies generated binary policy files to %windir%\System32\CodeIntegrity\CiPolicies\Active. If this option is selected, the policy won't be updated until the next reboot.

.PARAMETER DeployAndUpdate

Copies generated binary policy files to %windir%\System32\CodeIntegrity\CiPolicies\Active and refreshes the rules so that policy changes take effect immediately.

.EXAMPLE

$CommonBasePolicyRuleOptions = @(
    'Enabled:Unsigned System Integrity Policy',
    'Enabled:Advanced Boot Options Menu',
    'Enabled:Update Policy No Reboot',
    'Enabled:Allow Supplemental Policies',
    'Disabled:Flight Signing',
    'Required:WHQL',
    'Enabled:Boot Audit On Failure'
)

$BasePolicyConfigurations = @(
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'BaseDriverPolicy.xml' -PolicyName 'BaseDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'),
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'BaseUserPolicy.xml' -PolicyName 'BaseUserModeRuleset' -PolicyRuleOptions 'Disabled:Script Enforcement', 'Enabled:UMCI', 'Enabled:Audit Mode'),
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'MicrosoftRecommendedBlockRules.xml' -PolicyName 'MicrosoftRecommendedBlockRuleset' -PolicyRuleOptions 'Disabled:Script Enforcement', 'Enabled:UMCI', 'Enabled:Audit Mode')
)

$SupplementalPolicyConfigurations = @(
    (New-WDACPolicyConfiguration -SupplementalPolicy -FileName 'MicrosoftSurfaceDriverPolicy.xml' -PolicyName '3rdPartyDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode')
)

$MergedPolicyConfiguration = New-WDACPolicyConfiguration -MergedPolicy -PolicyName 'Merged3rdPartySoftwareRuleset' -BasePolicyToSupplement 'BaseUserModeRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'

$CodeIntegrityPoliciesArgs = @{
    CommonBasePolicyRuleOptions     = $CommonBasePolicyRuleOptions
    BasePolicyConfiguration         = $BasePolicyConfigurations
    SupplementalPolicyConfiguration = $SupplementalPolicyConfigurations
    MergedPolicyConfiguration       = $MergedPolicyConfiguration
}

Invoke-WDACCodeIntegrityPolicyBuild @CodeIntegrityPoliciesArgs

This code specifies several policy configurations, converts them to binary form, and saves the resulting binary policy files to the "BuildArtifacts" directory.
#>

    [CmdletBinding(DefaultParameterSetName = 'Deploy')]
    param (
        [Parameter()]
        [ValidateSet('Enabled:UMCI',
                     'Enabled:Boot Menu Protection',
                     'Required:WHQL',
                     'Enabled:Audit Mode',
                     'Disabled:Flight Signing',
                     'Enabled:Inherit Default Policy',
                     'Enabled:Unsigned System Integrity Policy',
                     'Allowed:Debug Policy Augmented',
                     'Required:EV Signers',
                     'Enabled:Advanced Boot Options Menu',
                     'Enabled:Boot Audit On Failure',
                     'Disabled:Script Enforcement',
                     'Required:Enforce Store Applications',
                     'Enabled:Managed Installer',
                     'Enabled:Intelligent Security Graph Authorization',
                     'Enabled:Invalidate EAs on Reboot',
                     'Enabled:Update Policy No Reboot',
                     'Enabled:Allow Supplemental Policies',
                     'Disabled:Runtime FilePath Rule Protection',
                     'Enabled:Dynamic Code Security',
                     'Enabled:Revoked Expired As Unsigned')]
        [String[]]
        $CommonBasePolicyRuleOptions,

        [Parameter(Mandatory)]
        [PSTypeName('WDACBasePolicyConfiguration')]
        [PSObject[]]
        $BasePolicyConfiguration,

        [PSTypeName('WDACSupplementalPolicyConfiguration')]
        [PSObject[]]
        $SupplementalPolicyConfiguration,

        [PSTypeName('WDACMergedPolicyConfiguration')]
        [PSObject]
        $MergedPolicyConfiguration,

        [String]
        [ValidateScript({Test-Path -Path $_ -PathType Container})]
        $ArtifactPath,

        [Parameter(ParameterSetName = 'Deploy')]
        [Switch]
        $Deploy,

        [Parameter(ParameterSetName = 'DeployAndUpdate')]
        [Switch]
        $DeployAndUpdate
    )

    # Policy ID will be set to the day's date.
    $DateString = (Get-Date).ToString('MM_dd_yyyy')

    $CommonBasePolicyRuleOptionValues = ConvertTo-WDACPolicyRuleValue -PolicyOptionStrings $CommonBasePolicyRuleOptions

    $ArtifactBasePath = "$PSScriptRoot\BuildArtifacts"

    $MergedPolicy = $null

    if ($ArtifactPath) {
        $ArtifactBasePath = $ArtifactPath
    }

    # Configure and build base policies
    $BasePolicies = foreach ($BaseConfig in $BasePolicyConfiguration) {
        $BasePolicyPath = "$PSScriptRoot\BasePolicies\$($BaseConfig.FileName)"

        # Each base template policy will be copied to this location prior to configuration.
        $BasePolicyBuildPath = "$ArtifactBasePath\$($BaseConfig.FileName)"

        [Xml] $PolicyXml = Get-Content -Path $BasePolicyPath -Raw

        $PolicyID = $PolicyXml.SiPolicy.PolicyID
        # $BasePolicyID = $PolicyXml.SiPolicy.BasePolicyID

        Copy-Item -Path $BasePolicyPath -Destination $BasePolicyBuildPath

        if ($CommonBasePolicyRuleOptionValues) {
            foreach ($CommonBaseRuleOptionValue in $CommonBasePolicyRuleOptionValues) {
                Set-RuleOption -FilePath $BasePolicyBuildPath -Option $CommonBaseRuleOptionValue
            }
        }

        $BaseConfigurationPolicyRuleOptionValues = $null

        if ($BaseConfig.PolicyRuleOptions) {
            $BaseConfigurationPolicyRuleOptionValues = ConvertTo-WDACPolicyRuleValue -PolicyOptionStrings $BaseConfig.PolicyRuleOptions
        }

        foreach ($RuleOption in $BaseConfigurationPolicyRuleOptionValues) {
            Set-RuleOption -FilePath $BasePolicyBuildPath -Option $RuleOption
        }

        Set-CIPolicyIdInfo -FilePath $BasePolicyBuildPath -PolicyName $BaseConfig.PolicyName -PolicyId $DateString -WarningAction SilentlyContinue

        [Xml] $BuiltPolicyXml = Get-Content -Path $BasePolicyBuildPath -Raw

        ConvertFrom-CIPolicy -XmlFilePath $BasePolicyBuildPath -BinaryFilePath "$ArtifactBasePath\$PolicyID.cip" | ForEach-Object {
            # ConvertFrom-CIPolicy returns a string consisting of the binary CI policy file. Resolve the path.
            $FileInfo = Get-Item -Path $_
            $XmlFileInfo = Get-Item -Path $BasePolicyBuildPath

            $PolicyProperties = [Ordered] @{
                PolicyType = 'Base'
                XmlFileInfo = $XmlFileInfo
                BinaryFileInfo = $FileInfo
                PolicyID = $BuiltPolicyXml.SiPolicy.PolicyID
                BasePolicyID = $BuiltPolicyXml.SiPolicy.BasePolicyID
                PolicyInfoName = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Name' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
                PolicyInfoID = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Id' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
            }

            New-Object -TypeName PSObject -Property $PolicyProperties
        }
    }

    # Configure and build supplemental policies
    if ($SupplementalPolicyConfiguration)
    {
        $SupplementalPolicies = foreach ($SupplementalConfig in $SupplementalPolicyConfiguration) {
            $SupplementalPolicyPath = "$PSScriptRoot\SupplementalPolicies\$($SupplementalConfig.FileName)"

            # Each base template policy will be copied to this location prior to configuration.
            $SupplementalPolicyBuildPath = "$ArtifactBasePath\$($SupplementalConfig.FileName)"

            [Xml] $PolicyXml = Get-Content -Path $SupplementalPolicyPath -Raw

            $PolicyID = $PolicyXml.SiPolicy.PolicyID

            Copy-Item -Path $SupplementalPolicyPath -Destination $SupplementalPolicyBuildPath

            if ($CommonBasePolicyRuleOptions) {
                foreach ($CommonBaseRuleOption in $CommonBasePolicyRuleOptionValues) {
                    Set-RuleOption -FilePath $SupplementalPolicyBuildPath -Option $CommonBaseRuleOption
                }
            }

            $SupplementalConfigurationPolicyRuleOptionValues = $null

            if ($SupplementalConfig.PolicyRuleOptions) {
                $SupplementalConfigurationPolicyRuleOptionValues = ConvertTo-WDACPolicyRuleValue -PolicyOptionStrings $SupplementalConfig.PolicyRuleOptions
            }

            foreach ($RuleOption in $SupplementalConfigurationPolicyRuleOptionValues) {
                Set-RuleOption -FilePath $SupplementalPolicyBuildPath -Option $RuleOption
            }

            # Delete the "Enabled:Allow Supplemental Policies" if it was specified in the common policy rule option config.
            Set-RuleOption -FilePath $SupplementalPolicyBuildPath -Option 17 -Delete

            Set-CIPolicyIdInfo -FilePath $SupplementalPolicyBuildPath -PolicyName $SupplementalConfig.PolicyName -PolicyId $DateString -WarningAction SilentlyContinue

            [Xml] $BuiltPolicyXml = Get-Content -Path $SupplementalPolicyBuildPath -Raw

            ConvertFrom-CIPolicy -XmlFilePath $SupplementalPolicyBuildPath -BinaryFilePath "$ArtifactBasePath\$PolicyID.cip" | ForEach-Object {
                # ConvertFrom-CIPolicy returns a string consisting of the binary CI policy file. Resolve the path.
                $FileInfo = Get-Item -Path $_
                $XmlFileInfo = Get-Item -Path $SupplementalPolicyBuildPath

                $PolicyProperties = [Ordered] @{
                    PolicyType = 'Supplemental'
                    XmlFileInfo = $XmlFileInfo
                    BinaryFileInfo = $FileInfo
                    PolicyID = $BuiltPolicyXml.SiPolicy.PolicyID
                    BasePolicyID = $BuiltPolicyXml.SiPolicy.BasePolicyID
                    PolicyInfoName = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Name' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
                    PolicyInfoID = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Id' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
                }

                New-Object -TypeName PSObject -Property $PolicyProperties
            }
        }
    }

    # Build the app-specific policy
    if ($MergedPolicyConfiguration) {
        if (-not ($BasePolicies | Where-Object { $_.PolicyInfoName -eq $MergedPolicyConfiguration.BasePolicyToSupplement })) {
            Write-Error "The merged, application-specific supplemental policy is expected to supplement the following base policy that was not supplied: $($MergedPolicyConfiguration.BasePolicyToSupplement)"
            return
        }

        $BasePolicyID = $BasePolicies | Where-Object { $_.PolicyInfoName -eq $MergedPolicyConfiguration.BasePolicyToSupplement } | Select-Object -ExpandProperty BasePolicyId

        $CopiedAppTemplateDestination = "$ArtifactBasePath\AppSpecificPolicyTemplate.xml"

        # Copy the application-specific template policy to the artifacts directory.
        # This is done because the BasePolicyID element is going to be updated in the XML.
        # Assign the application-specific supplemental policy base policy ID to the base policy name specified.

        # I'd love to use the supported cmdlet for this but I really don't like that you can't avoid
        # Having the PolicyID reset.
        # Set-CIPolicyIdInfo -FilePath $CopiedAppTemplateDestination -SupplementsBasePolicyID $BasePolicyID

        $XmlString = Get-Content -Path "$PSScriptRoot\AppSpecificPolicies\AppSpecificPolicyTemplate.xml" -Raw

        $BasePolicyIdToReplace = [Xml] $XmlString | Select-Object -ExpandProperty SiPolicy | Select-Object -ExpandProperty BasePolicyId

        $ReplacedXmlString = $XmlString -replace "<BasePolicyID>$BasePolicyIdToReplace</BasePolicyID>", "<BasePolicyID>$BasePolicyID</BasePolicyID>"

        Out-File -FilePath $CopiedAppTemplateDestination -InputObject $ReplacedXmlString -Encoding utf8 -ErrorAction Stop

        # AppSpecificPolicyTemplate.xml is used for maintaining file rule options.
        # Note: AppSpecificPolicyTemplate.xml must be the first policy file specified as this is what Merge-CIPolicy takes policy options from.
        $AppSpecificPolicyFiles = New-Object -TypeName String[](0)

        $AppSpecificPolicyFiles += $CopiedAppTemplateDestination
        Get-ChildItem "$PSScriptRoot\AppSpecificPolicies\*.xml" -Exclude 'AppSpecificPolicyTemplate.xml' |
            Select-Object -ExpandProperty FullName |
            ForEach-Object { $AppSpecificPolicyFiles += $_ }

        $MergedPolicyPath = "$ArtifactBasePath\MergedPolicy.xml"

        $null = Merge-CIPolicy -OutputFilePath $MergedPolicyPath -PolicyPaths ([String[]] $AppSpecificPolicyFiles)

        [Xml] $PolicyXml = Get-Content -Path $MergedPolicyPath -Raw

        $PolicyID = $PolicyXml.SiPolicy.PolicyID

        if ($CommonBasePolicyRuleOptions)
        {
            foreach ($CommonBaseRuleOption in $CommonBasePolicyRuleOptionValues) {
                Set-RuleOption -FilePath $MergedPolicyPath -Option $CommonBaseRuleOption
            }
        }

        $MergedConfigurationPolicyRuleOptionValues = $null

        if ($MergedPolicyConfiguration.PolicyRuleOptions) {
            $MergedConfigurationPolicyRuleOptionValues = ConvertTo-WDACPolicyRuleValue -PolicyOptionStrings $MergedPolicyConfiguration.PolicyRuleOptions
        }

        foreach ($RuleOption in $MergedConfigurationPolicyRuleOptionValues) {
            Set-RuleOption -FilePath $MergedPolicyPath -Option $RuleOption
        }

        # Delete the "Enabled:Allow Supplemental Policies" if it was specified in the common policy rule option config.
        Set-RuleOption -FilePath $MergedPolicyPath -Option 17 -Delete

        Set-CIPolicyIdInfo -FilePath $MergedPolicyPath -PolicyName $MergedPolicyConfiguration.PolicyName -PolicyId $DateString -WarningAction SilentlyContinue

        [Xml] $BuiltPolicyXml = Get-Content -Path $MergedPolicyPath -Raw

        ConvertFrom-CIPolicy -XmlFilePath $MergedPolicyPath -BinaryFilePath "$ArtifactBasePath\$PolicyID.cip" | ForEach-Object {
            # ConvertFrom-CIPolicy returns a string consisting of the binary CI policy file. Resolve the path.
            $FileInfo = Get-Item -Path $_
            $XmlFileInfo = Get-Item -Path $MergedPolicyPath

            $PolicyProperties = [Ordered] @{
                PolicyType = 'MergedSupplemental'
                XmlFileInfo = $XmlFileInfo
                BinaryFileInfo = $FileInfo
                PolicyID = $BuiltPolicyXml.SiPolicy.PolicyID
                BasePolicyID = $BuiltPolicyXml.SiPolicy.BasePolicyID
                PolicyInfoName = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Name' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
                PolicyInfoID = ($BuiltPolicyXml.SiPolicy.Settings.Setting | Where-Object { $_.ValueName -eq 'Id' } | Select-Object -ExpandProperty Value | Select-Object -ExpandProperty String)
            }

            $MergedPolicy = New-Object -TypeName PSObject -Property $PolicyProperties
        }
    }

    # Build a list of the generated binary policy files so that only those files are deployed
    # when -Deploy or -DeployAndUpdate are specified.
    $BinaryPolicyFiles = New-Object -TypeName String[](0)

    if ($BasePolicies) {
        $BasePolicies
        $BasePolicies | ForEach-Object { $BinaryPolicyFiles += $_.BinaryFileInfo }
    }

    if ($SupplementalPolicies) {
        $SupplementalPolicies
        $SupplementalPolicies | ForEach-Object { $BinaryPolicyFiles += $_.BinaryFileInfo }
    }

    if ($MergedPolicy) {
        $MergedPolicy
        $BinaryPolicyFiles += $MergedPolicy.BinaryFileInfo
    }

    # Copy all binary policy files to the relevant WDAC CI policy directory.
    if ($Deploy -or $DeployAndUpdate) {
        $BinaryPolicyFiles | Get-ChildItem | ForEach-Object {
            $DestinationDir = "$Env:windir\System32\CodeIntegrity\CiPolicies\Active"

            Write-Verbose "Copying $($_.FullName) to $DestinationDir."
            $_ | Copy-Item -Destination $DestinationDir -PassThru
        }
    }

    # Refresh all active code integrity policies so that the changes can take effect immediately without needing to reboot.
    if ($DeployAndUpdate) {
        Get-ChildItem -Path "$Env:windir\System32\CodeIntegrity\CiPolicies\Active\*.cip" | ForEach-Object {
            Write-Verbose "Applying the following policy: $($_.FullName)"

            $Result = Invoke-CimMethod -Namespace root\Microsoft\Windows\CI -ClassName PS_UpdateAndCompareCIPolicy -MethodName Update -Arguments @{ FilePath = $_.FullName }
            if ($Result.ReturnValue -ne 0) {
                Write-Error "The following policy failed to refresh: $($_.FullName). Return value: $($Result.ReturnValue)"
            }
        }
    }
}

filter Update-WDACBinaryCodeIntegrityPolicy {
<#
.SYNOPSIS

Refreshes a binary code integrity policy without requiring a reboot.

.DESCRIPTION

Update-WDACBinaryCodeIntegrityPolicy is used to explicitly refresh one or more binary code integrity policies without requiring a reboot. In order to support this scenario, your base policy must be configured with the "Enabled:Update Policy No Reboot" option.

Author: Matthew Graeber

.PARAMETER Path

Specifies the path to a binary code integrity file that you would like to explicitly update without rebooting. A binary code integrity policy will have a file extension of .p7b or .cip in a multi-policy scenario.

.EXAMPLE

Update-WDACBinaryPolicy -Path C:\Windows\System32\CodeIntegrity\SIPolicy.p7b

Updating a single policy.

.EXAMPLE

Get-ChildItem -Path "$Env:windir\System32\CodeIntegrity\CiPolicies\Active\*.cip" | Update-WDACBinaryCodeIntegrityPolicy

Updating all policies in a multi-policy scenario.
#>

    [CmdletBinding()]
    param (
        [Parameter(Mandatory, ValueFromPipeline, ValueFromPipelineByPropertyName)]
        [String]
        [ValidateNotNullOrEmpty()]
        [Alias('FullName')]
        $Path
    )

    $FullPath = Resolve-Path $Path

    $Result = Invoke-CimMethod -Namespace root\Microsoft\Windows\CI -ClassName PS_UpdateAndCompareCIPolicy -MethodName Update -Arguments @{ FilePath = $FullPath.Path }

    if ($Result.ReturnValue -ne 0) {
        Write-Error "The following policy failed to refresh: $($FullPath.Path). Return value: $($Result.ReturnValue)"
    }
}

function Disable-WDACDeployedPolicy {
<#
.SYNOPSIS

Disables the currently deployed code integrity policy. Note: this does not delete deployed policy files in %windir%\System32\CodeIntegrity. Those should be removed manually, if desired.

.EXAMPLE

Disable-WDACDeployedPolicy
#>

    Invoke-CimMethod -Namespace root\Microsoft\Windows\CI -ClassName PS_UpdateAndCompareCIPolicy -MethodName Delete
}
```

`CIPolicyParser.psm1`:

```psm1
function ConvertTo-WDACCodeIntegrityPolicy {
<#
.SYNOPSIS

Converts a binary file that contains a Code Integrity policy into XML format.

Author: Matthew Graeber (@mattifestation)
Contributors: James Forshaw (@tiraniddo) - thanks for the major bug fixes!
License: BSD 3-Clause

Modified to add propert PKCS#7 support and the new DG policy header version.

.DESCRIPTION

ConvertTo-WDACCodeIntegrityPolicy converts a binary file that contains a Code Integrity policy into XML format. This function is used to audit deployed Code Integrity policies for which the original XML is not present. It can also be used to compare deployed rules against a reference XML file.

Note: the process of converting an XML file to a binary policy is lossy. ID, Name, and FriendlyName attributes are all lost in the process. ConvertTo-WDACCodeIntegrityPolicy auto-generates ID and Name properties when necessary.

ConvertTo-WDACCodeIntegrityPolicy supports both signed and unsigned policies.

.PARAMETER BinaryFilePath

Specifies the path of the binary policy file that this cmdlet converts. Deployed binary policy files are located in %SystemRoot%\System32\CodeIntegrity\SIPolicy.p7b.

.PARAMETER XmlFilePath

Specifies the path for the output converted policy XML file.

.EXAMPLE

ConvertTo-WDACCodeIntegrityPolicy -BinaryFilePath C:\Windows\System32\CodeIntegrity\SIPolicy.p7b -XmlFilePath recovered_policy.xml

.OUTPUTS

System.IO.FileInfo

Outputs a recovered Code Integrity policy XML file.
#>

    [CmdletBinding(SupportsShouldProcess)]
    [OutputType([System.IO.FileInfo])]
    param (
        [Parameter(Position = 0, Mandatory)]
        [String]
        [ValidateScript({ [IO.File]::Exists((Resolve-Path $_).Path) })]
        $BinaryFilePath,

        [Parameter(Position = 1, Mandatory)]
        [String]
        [ValidateNotNullOrEmpty()]
        $XmlFilePath
    )

    Set-StrictMode -Version Latest

    $CorruptPolicyErr = 'The CI policy may be corrupt.'

    $HeaderLengthMax = 0x44
    $GuidLength = 0x10

    # Generated code that enables CI policy XML serialization.
    $TypeDef = @'
    using System.Xml.Serialization;

    namespace CodeIntegrity {
        [System.FlagsAttribute()]
        public enum PolicyRules {
            EnabledUMCI =                                     0x00000004,
            EnabledBootMenuProtection =                       0x00000008,
            EnabledIntelligentSecurityGraphAuthorization =    0x00000010,
            EnabledInvalidateEAsonReboot =                    0x00000020,
            EnabledWindowsLockdownTrialMode =                 0x00000040,
            RequiredWHQL =                                    0x00000080,
            EnabledDeveloperModeDynamicCodeTrust =            0x00000100,
            EnabledAllowSupplementalPolicies =                0x00000400,
            DisabledRuntimeFilePathRuleProtection =           0x00000800,
            EnabledRevokedExpiredAsUnsigned =                 0x00002000,
            EnabledAuditMode =                                0x00010000,
            DisabledFlightSigning =                           0x00020000,
            EnabledInheritDefaultPolicy =                     0x00040000,
            EnabledUnsignedSystemIntegrityPolicy =            0x00080000,
            EnabledDynamicCodeSecurity =                      0x00100000,
            RequiredEVSigners =                               0x00200000,
            EnabledBootAuditOnFailure =                       0x00400000,
            EnabledAdvancedBootOptionsMenu =                  0x00800000,
            DisabledScriptEnforcement =                       0x01000000,
            RequiredEnforceStoreApplications =                0x02000000,
            EnabledSecureSettingPolicy =                      0x04000000,
            EnabledManagedInstaller =                         0x08000000,
            EnabledUpdatePolicyNoReboot =                     0x10000000,
            EnabledConditionalWindowsLockdownPolicy =         0x20000000
        }

        // The following code was generated with: xsd.exe C:\Windows\schemas\CodeIntegrity\cipolicy.xsd /classes /namespace:CodeIntegrity

        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Macros {

            private MacrosMacro[] macroField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Macro")]
            public MacrosMacro[] Macro {
                get {
                    return this.macroField;
                }
                set {
                    this.macroField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        public partial class MacrosMacro {

            private string idField;

            private string valueField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Id {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:sipolicy")]
        public partial class RuleType {

            private OptionType itemField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Option")]
            public OptionType Item {
                get {
                    return this.itemField;
                }
                set {
                    this.itemField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:sipolicy")]
        public enum OptionType {

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:UMCI")]
            EnabledUMCI,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Boot Menu Protection")]
            EnabledBootMenuProtection,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Intelligent Security Graph Authorization")]
            EnabledIntelligentSecurityGraphAuthorization,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Invalidate EAs on Reboot")]
            EnabledInvalidateEAsonReboot,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Windows Lockdown Trial Mode")]
            EnabledWindowsLockdownTrialMode,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Required:WHQL")]
            RequiredWHQL,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Developer Mode Dynamic Code Trust")]
            EnabledDeveloperModeDynamicCodeTrust,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Allow Supplemental Policies")]
            EnabledAllowSupplementalPolicies,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Disabled:Runtime FilePath Rule Protection")]
            DisabledRuntimeFilePathRuleProtection,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Revoked Expired As Unsigned")]
            EnabledRevokedExpiredAsUnsigned,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Audit Mode")]
            EnabledAuditMode,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Disabled:Flight Signing")]
            DisabledFlightSigning,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Inherit Default Policy")]
            EnabledInheritDefaultPolicy,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Unsigned System Integrity Policy")]
            EnabledUnsignedSystemIntegrityPolicy,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Dynamic Code Security")]
            EnabledDynamicCodeSecurity,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Required:EV Signers")]
            RequiredEVSigners,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Boot Audit On Failure")]
            EnabledBootAuditOnFailure,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Advanced Boot Options Menu")]
            EnabledAdvancedBootOptionsMenu,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Disabled:Script Enforcement")]
            DisabledScriptEnforcement,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Required:Enforce Store Applications")]
            RequiredEnforceStoreApplications,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Secure Setting Policy")]
            EnabledSecureSettingPolicy,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Managed Installer")]
            EnabledManagedInstaller,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Update Policy No Reboot")]
            EnabledUpdatePolicyNoReboot,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Enabled:Conditional Windows Lockdown Policy")]
            EnabledConditionalWindowsLockdownPolicy,
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:sipolicy")]
        public partial class SettingValueType {

            private object itemField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Binary", typeof(byte[]), DataType="hexBinary")]
            [System.Xml.Serialization.XmlElementAttribute("Boolean", typeof(bool))]
            [System.Xml.Serialization.XmlElementAttribute("DWord", typeof(uint))]
            [System.Xml.Serialization.XmlElementAttribute("String", typeof(string))]
            public object Item {
                get {
                    return this.itemField;
                }
                set {
                    this.itemField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Setting {

            private SettingValueType valueField;

            private string providerField;

            private string keyField;

            private string valueNameField;

            /// <remarks/>
            public SettingValueType Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Provider {
                get {
                    return this.providerField;
                }
                set {
                    this.providerField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Key {
                get {
                    return this.keyField;
                }
                set {
                    this.keyField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ValueName {
                get {
                    return this.valueNameField;
                }
                set {
                    this.valueNameField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Settings {

            private Setting[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Setting")]
            public Setting[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CertEKU {

            private string idField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CertOemID {

            private string valueField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CertPublisher {

            private string valueField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CertIssuer {

            private string valueField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CertRoot {

            private CertEnumType typeField;

            private byte[] valueField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public CertEnumType Type {
                get {
                    return this.typeField;
                }
                set {
                    this.typeField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute(DataType="hexBinary")]
            public byte[] Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:sipolicy")]
        public enum CertEnumType {

            /// <remarks/>
            TBS,

            /// <remarks/>
            Wellknown,
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class ProductSigners {

            private AllowedSigners allowedSignersField;

            private DeniedSigners deniedSignersField;

            private FileRulesRef fileRulesRefField;

            /// <remarks/>
            public AllowedSigners AllowedSigners {
                get {
                    return this.allowedSignersField;
                }
                set {
                    this.allowedSignersField = value;
                }
            }

            /// <remarks/>
            public DeniedSigners DeniedSigners {
                get {
                    return this.deniedSignersField;
                }
                set {
                    this.deniedSignersField = value;
                }
            }

            /// <remarks/>
            public FileRulesRef FileRulesRef {
                get {
                    return this.fileRulesRefField;
                }
                set {
                    this.fileRulesRefField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class AllowedSigners {

            private AllowedSigner[] allowedSignerField;

            private string workaroundField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("AllowedSigner")]
            public AllowedSigner[] AllowedSigner {
                get {
                    return this.allowedSignerField;
                }
                set {
                    this.allowedSignerField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Workaround {
                get {
                    return this.workaroundField;
                }
                set {
                    this.workaroundField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class AllowedSigner {

            private ExceptDenyRule[] exceptDenyRuleField;

            private string signerIdField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("ExceptDenyRule")]
            public ExceptDenyRule[] ExceptDenyRule {
                get {
                    return this.exceptDenyRuleField;
                }
                set {
                    this.exceptDenyRuleField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string SignerId {
                get {
                    return this.signerIdField;
                }
                set {
                    this.signerIdField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class ExceptDenyRule {

            private string denyRuleIDField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string DenyRuleID {
                get {
                    return this.denyRuleIDField;
                }
                set {
                    this.denyRuleIDField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class DeniedSigners {

            private DeniedSigner[] deniedSignerField;

            private string workaroundField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("DeniedSigner")]
            public DeniedSigner[] DeniedSigner {
                get {
                    return this.deniedSignerField;
                }
                set {
                    this.deniedSignerField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Workaround {
                get {
                    return this.workaroundField;
                }
                set {
                    this.workaroundField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class DeniedSigner {

            private ExceptAllowRule[] exceptAllowRuleField;

            private string signerIdField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("ExceptAllowRule")]
            public ExceptAllowRule[] ExceptAllowRule {
                get {
                    return this.exceptAllowRuleField;
                }
                set {
                    this.exceptAllowRuleField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string SignerId {
                get {
                    return this.signerIdField;
                }
                set {
                    this.signerIdField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class ExceptAllowRule {

            private string allowRuleIDField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string AllowRuleID {
                get {
                    return this.allowRuleIDField;
                }
                set {
                    this.allowRuleIDField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class FileRulesRef {

            private FileRuleRef[] fileRuleRefField;

            private string workaroundField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("FileRuleRef")]
            public FileRuleRef[] FileRuleRef {
                get {
                    return this.fileRuleRefField;
                }
                set {
                    this.fileRuleRefField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Workaround {
                get {
                    return this.workaroundField;
                }
                set {
                    this.workaroundField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class FileRuleRef {

            private string ruleIDField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string RuleID {
                get {
                    return this.ruleIDField;
                }
                set {
                    this.ruleIDField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class TestSigners {

            private AllowedSigners allowedSignersField;

            private DeniedSigners deniedSignersField;

            private FileRulesRef fileRulesRefField;

            /// <remarks/>
            public AllowedSigners AllowedSigners {
                get {
                    return this.allowedSignersField;
                }
                set {
                    this.allowedSignersField = value;
                }
            }

            /// <remarks/>
            public DeniedSigners DeniedSigners {
                get {
                    return this.deniedSignersField;
                }
                set {
                    this.deniedSignersField = value;
                }
            }

            /// <remarks/>
            public FileRulesRef FileRulesRef {
                get {
                    return this.fileRulesRefField;
                }
                set {
                    this.fileRulesRefField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class TestSigningSigners {

            private AllowedSigners allowedSignersField;

            private DeniedSigners deniedSignersField;

            private FileRulesRef fileRulesRefField;

            /// <remarks/>
            public AllowedSigners AllowedSigners {
                get {
                    return this.allowedSignersField;
                }
                set {
                    this.allowedSignersField = value;
                }
            }

            /// <remarks/>
            public DeniedSigners DeniedSigners {
                get {
                    return this.deniedSignersField;
                }
                set {
                    this.deniedSignersField = value;
                }
            }

            /// <remarks/>
            public FileRulesRef FileRulesRef {
                get {
                    return this.fileRulesRefField;
                }
                set {
                    this.fileRulesRefField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class FileAttribRef {

            private string ruleIDField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string RuleID {
                get {
                    return this.ruleIDField;
                }
                set {
                    this.ruleIDField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class EKUs {

            private EKU[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("EKU")]
            public EKU[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class EKU {

            private string idField;

            private byte[] valueField;

            private string friendlyNameField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute(DataType="hexBinary")]
            public byte[] Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class FileRules {

            private object[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Allow", typeof(Allow))]
            [System.Xml.Serialization.XmlElementAttribute("Deny", typeof(Deny))]
            [System.Xml.Serialization.XmlElementAttribute("FileAttrib", typeof(FileAttrib))]
            public object[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Allow {

            private string idField;

            private string friendlyNameField;

            private string fileNameField;

            private string internalNameField;

            private string fileDescriptionField;

            private string productNameField;

            private string packageFamilyNameField;

            private string packageVersionField;

            private string minimumFileVersionField;

            private string maximumFileVersionField;

            private byte[] hashField;

            private string appIDsField;

            private string filePathField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileName {
                get {
                    return this.fileNameField;
                }
                set {
                    this.fileNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string InternalName {
                get {
                    return this.internalNameField;
                }
                set {
                    this.internalNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileDescription {
                get {
                    return this.fileDescriptionField;
                }
                set {
                    this.fileDescriptionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ProductName {
                get {
                    return this.productNameField;
                }
                set {
                    this.productNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageFamilyName {
                get {
                    return this.packageFamilyNameField;
                }
                set {
                    this.packageFamilyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageVersion {
                get {
                    return this.packageVersionField;
                }
                set {
                    this.packageVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MinimumFileVersion {
                get {
                    return this.minimumFileVersionField;
                }
                set {
                    this.minimumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MaximumFileVersion {
                get {
                    return this.maximumFileVersionField;
                }
                set {
                    this.maximumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute(DataType="hexBinary")]
            public byte[] Hash {
                get {
                    return this.hashField;
                }
                set {
                    this.hashField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string AppIDs {
                get {
                    return this.appIDsField;
                }
                set {
                    this.appIDsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FilePath {
                get {
                    return this.filePathField;
                }
                set {
                    this.filePathField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Deny {

            private string idField;

            private string friendlyNameField;

            private string fileNameField;

            private string internalNameField;

            private string fileDescriptionField;

            private string productNameField;

            private string packageFamilyNameField;

            private string packageVersionField;

            private string minimumFileVersionField;

            private string maximumFileVersionField;

            private byte[] hashField;

            private string appIDsField;

            private string filePathField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileName {
                get {
                    return this.fileNameField;
                }
                set {
                    this.fileNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string InternalName {
                get {
                    return this.internalNameField;
                }
                set {
                    this.internalNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileDescription {
                get {
                    return this.fileDescriptionField;
                }
                set {
                    this.fileDescriptionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ProductName {
                get {
                    return this.productNameField;
                }
                set {
                    this.productNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageFamilyName {
                get {
                    return this.packageFamilyNameField;
                }
                set {
                    this.packageFamilyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageVersion {
                get {
                    return this.packageVersionField;
                }
                set {
                    this.packageVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MinimumFileVersion {
                get {
                    return this.minimumFileVersionField;
                }
                set {
                    this.minimumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MaximumFileVersion {
                get {
                    return this.maximumFileVersionField;
                }
                set {
                    this.maximumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute(DataType="hexBinary")]
            public byte[] Hash {
                get {
                    return this.hashField;
                }
                set {
                    this.hashField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string AppIDs {
                get {
                    return this.appIDsField;
                }
                set {
                    this.appIDsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FilePath {
                get {
                    return this.filePathField;
                }
                set {
                    this.filePathField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class FileAttrib {

            private string idField;

            private string friendlyNameField;

            private string fileNameField;

            private string internalNameField;

            private string fileDescriptionField;

            private string productNameField;

            private string packageFamilyNameField;

            private string packageVersionField;

            private string minimumFileVersionField;

            private string maximumFileVersionField;

            private byte[] hashField;

            private string appIDsField;

            private string filePathField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileName {
                get {
                    return this.fileNameField;
                }
                set {
                    this.fileNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string InternalName {
                get {
                    return this.internalNameField;
                }
                set {
                    this.internalNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FileDescription {
                get {
                    return this.fileDescriptionField;
                }
                set {
                    this.fileDescriptionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ProductName {
                get {
                    return this.productNameField;
                }
                set {
                    this.productNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageFamilyName {
                get {
                    return this.packageFamilyNameField;
                }
                set {
                    this.packageFamilyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string PackageVersion {
                get {
                    return this.packageVersionField;
                }
                set {
                    this.packageVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MinimumFileVersion {
                get {
                    return this.minimumFileVersionField;
                }
                set {
                    this.minimumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string MaximumFileVersion {
                get {
                    return this.maximumFileVersionField;
                }
                set {
                    this.maximumFileVersionField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute(DataType="hexBinary")]
            public byte[] Hash {
                get {
                    return this.hashField;
                }
                set {
                    this.hashField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string AppIDs {
                get {
                    return this.appIDsField;
                }
                set {
                    this.appIDsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FilePath {
                get {
                    return this.filePathField;
                }
                set {
                    this.filePathField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class UpdatePolicySigner {

            private string signerIdField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string SignerId {
                get {
                    return this.signerIdField;
                }
                set {
                    this.signerIdField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class UpdatePolicySigners {

            private UpdatePolicySigner[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("UpdatePolicySigner")]
            public UpdatePolicySigner[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class SupplementalPolicySigner {

            private string signerIdField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string SignerId {
                get {
                    return this.signerIdField;
                }
                set {
                    this.signerIdField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class SupplementalPolicySigners {

            private SupplementalPolicySigner[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("SupplementalPolicySigner")]
            public SupplementalPolicySigner[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CiSigner {

            private string signerIdField;

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string SignerId {
                get {
                    return this.signerIdField;
                }
                set {
                    this.signerIdField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class CiSigners {

            private CiSigner[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("CiSigner")]
            public CiSigner[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Signers {

            private Signer[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("Signer")]
            public Signer[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class Signer {

            private CertRoot certRootField;

            private CertEKU[] certEKUField;

            private CertIssuer certIssuerField;

            private CertPublisher certPublisherField;

            private CertOemID certOemIDField;

            private FileAttribRef[] fileAttribRefField;

            private string nameField;

            private string idField;

            private System.DateTime signTimeAfterField;

            private bool signTimeAfterFieldSpecified;

            /// <remarks/>
            public CertRoot CertRoot {
                get {
                    return this.certRootField;
                }
                set {
                    this.certRootField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("CertEKU")]
            public CertEKU[] CertEKU {
                get {
                    return this.certEKUField;
                }
                set {
                    this.certEKUField = value;
                }
            }

            /// <remarks/>
            public CertIssuer CertIssuer {
                get {
                    return this.certIssuerField;
                }
                set {
                    this.certIssuerField = value;
                }
            }

            /// <remarks/>
            public CertPublisher CertPublisher {
                get {
                    return this.certPublisherField;
                }
                set {
                    this.certPublisherField = value;
                }
            }

            /// <remarks/>
            public CertOemID CertOemID {
                get {
                    return this.certOemIDField;
                }
                set {
                    this.certOemIDField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("FileAttribRef")]
            public FileAttribRef[] FileAttribRef {
                get {
                    return this.fileAttribRefField;
                }
                set {
                    this.fileAttribRefField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string Name {
                get {
                    return this.nameField;
                }
                set {
                    this.nameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public System.DateTime SignTimeAfter {
                get {
                    return this.signTimeAfterField;
                }
                set {
                    this.signTimeAfterField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlIgnoreAttribute()]
            public bool SignTimeAfterSpecified {
                get {
                    return this.signTimeAfterFieldSpecified;
                }
                set {
                    this.signTimeAfterFieldSpecified = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class SigningScenarios {

            private SigningScenario[] itemsField;

            /// <remarks/>
            [System.Xml.Serialization.XmlElementAttribute("SigningScenario")]
            public SigningScenario[] Items {
                get {
                    return this.itemsField;
                }
                set {
                    this.itemsField = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class SigningScenario {

            private ProductSigners productSignersField;

            private TestSigners testSignersField;

            private TestSigningSigners testSigningSignersField;

            private string idField;

            private string friendlyNameField;

            private byte valueField;

            private string inheritedScenariosField;

            private ushort minimumHashAlgorithmField;

            private bool minimumHashAlgorithmFieldSpecified;

            /// <remarks/>
            public ProductSigners ProductSigners {
                get {
                    return this.productSignersField;
                }
                set {
                    this.productSignersField = value;
                }
            }

            /// <remarks/>
            public TestSigners TestSigners {
                get {
                    return this.testSignersField;
                }
                set {
                    this.testSignersField = value;
                }
            }

            /// <remarks/>
            public TestSigningSigners TestSigningSigners {
                get {
                    return this.testSigningSignersField;
                }
                set {
                    this.testSigningSignersField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string ID {
                get {
                    return this.idField;
                }
                set {
                    this.idField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public byte Value {
                get {
                    return this.valueField;
                }
                set {
                    this.valueField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string InheritedScenarios {
                get {
                    return this.inheritedScenariosField;
                }
                set {
                    this.inheritedScenariosField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public ushort MinimumHashAlgorithm {
                get {
                    return this.minimumHashAlgorithmField;
                }
                set {
                    this.minimumHashAlgorithmField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlIgnoreAttribute()]
            public bool MinimumHashAlgorithmSpecified {
                get {
                    return this.minimumHashAlgorithmFieldSpecified;
                }
                set {
                    this.minimumHashAlgorithmFieldSpecified = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Diagnostics.DebuggerStepThroughAttribute()]
        [System.ComponentModel.DesignerCategoryAttribute("code")]
        [System.Xml.Serialization.XmlTypeAttribute(AnonymousType=true, Namespace="urn:schemas-microsoft-com:sipolicy")]
        [System.Xml.Serialization.XmlRootAttribute(Namespace="urn:schemas-microsoft-com:sipolicy", IsNullable=false)]
        public partial class SiPolicy {

            private string versionExField;

            private string policyTypeIDField;

            private string platformIDField;

            private string policyIDField;

            private string basePolicyIDField;

            private RuleType[] rulesField;

            private EKU[] eKUsField;

            private object[] fileRulesField;

            private Signer[] signersField;

            private SigningScenario[] signingScenariosField;

            private UpdatePolicySigner[] updatePolicySignersField;

            private CiSigner[] ciSignersField;

            private uint hvciOptionsField;

            private bool hvciOptionsFieldSpecified;

            private Setting[] settingsField;

            private MacrosMacro[] macrosField;

            private SupplementalPolicySigner[] supplementalPolicySignersField;

            private string friendlyNameField;

            private PolicyType policyTypeField;

            private bool policyTypeFieldSpecified;

            /// <remarks/>
            public string VersionEx {
                get {
                    return this.versionExField;
                }
                set {
                    this.versionExField = value;
                }
            }

            /// <remarks/>
            public string PolicyTypeID {
                get {
                    return this.policyTypeIDField;
                }
                set {
                    this.policyTypeIDField = value;
                }
            }

            /// <remarks/>
            public string PlatformID {
                get {
                    return this.platformIDField;
                }
                set {
                    this.platformIDField = value;
                }
            }

            /// <remarks/>
            public string PolicyID {
                get {
                    return this.policyIDField;
                }
                set {
                    this.policyIDField = value;
                }
            }

            /// <remarks/>
            public string BasePolicyID {
                get {
                    return this.basePolicyIDField;
                }
                set {
                    this.basePolicyIDField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("Rule", IsNullable=false)]
            public RuleType[] Rules {
                get {
                    return this.rulesField;
                }
                set {
                    this.rulesField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("EKU", IsNullable=false)]
            public EKU[] EKUs {
                get {
                    return this.eKUsField;
                }
                set {
                    this.eKUsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("Allow", typeof(Allow), IsNullable=false)]
            [System.Xml.Serialization.XmlArrayItemAttribute("Deny", typeof(Deny), IsNullable=false)]
            [System.Xml.Serialization.XmlArrayItemAttribute("FileAttrib", typeof(FileAttrib), IsNullable=false)]
            public object[] FileRules {
                get {
                    return this.fileRulesField;
                }
                set {
                    this.fileRulesField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("Signer", IsNullable=false)]
            public Signer[] Signers {
                get {
                    return this.signersField;
                }
                set {
                    this.signersField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("SigningScenario", IsNullable=false)]
            public SigningScenario[] SigningScenarios {
                get {
                    return this.signingScenariosField;
                }
                set {
                    this.signingScenariosField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("UpdatePolicySigner", IsNullable=false)]
            public UpdatePolicySigner[] UpdatePolicySigners {
                get {
                    return this.updatePolicySignersField;
                }
                set {
                    this.updatePolicySignersField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("CiSigner", IsNullable=false)]
            public CiSigner[] CiSigners {
                get {
                    return this.ciSignersField;
                }
                set {
                    this.ciSignersField = value;
                }
            }

            /// <remarks/>
            public uint HvciOptions {
                get {
                    return this.hvciOptionsField;
                }
                set {
                    this.hvciOptionsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlIgnoreAttribute()]
            public bool HvciOptionsSpecified {
                get {
                    return this.hvciOptionsFieldSpecified;
                }
                set {
                    this.hvciOptionsFieldSpecified = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("Setting", IsNullable=false)]
            public Setting[] Settings {
                get {
                    return this.settingsField;
                }
                set {
                    this.settingsField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("Macro", IsNullable=false)]
            public MacrosMacro[] Macros {
                get {
                    return this.macrosField;
                }
                set {
                    this.macrosField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlArrayItemAttribute("SupplementalPolicySigner", IsNullable=false)]
            public SupplementalPolicySigner[] SupplementalPolicySigners {
                get {
                    return this.supplementalPolicySignersField;
                }
                set {
                    this.supplementalPolicySignersField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public string FriendlyName {
                get {
                    return this.friendlyNameField;
                }
                set {
                    this.friendlyNameField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlAttributeAttribute()]
            public PolicyType PolicyType {
                get {
                    return this.policyTypeField;
                }
                set {
                    this.policyTypeField = value;
                }
            }

            /// <remarks/>
            [System.Xml.Serialization.XmlIgnoreAttribute()]
            public bool PolicyTypeSpecified {
                get {
                    return this.policyTypeFieldSpecified;
                }
                set {
                    this.policyTypeFieldSpecified = value;
                }
            }
        }

        /// <remarks/>
        [System.CodeDom.Compiler.GeneratedCodeAttribute("xsd", "4.8.3698.0")]
        [System.SerializableAttribute()]
        [System.Xml.Serialization.XmlTypeAttribute(Namespace="urn:schemas-microsoft-com:sipolicy")]
        public enum PolicyType {

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Base Policy")]
            BasePolicy,

            /// <remarks/>
            [System.Xml.Serialization.XmlEnumAttribute("Supplemental Policy")]
            SupplementalPolicy,
        }
    }
'@

    if (-not ('CodeIntegrity.SIPolicy' -as [Type])) {
        Add-Type -TypeDefinition $TypeDef -ReferencedAssemblies 'System.Xml'
    }

    function ConvertTo-Oid {
    <#
    .SYNOPSIS

    Decodes a DER encoded ASN.1 object identifier (OID)

    .DESCRIPTION

    ConvertTo-Oid decodes a DER encoded ASN.1 object identifier (OID). This can be used as a helper function for binary certificate parsers.

    .PARAMETER EncodedOIDBytes

    Specifies the bytes of an absolute (starts with 6), encoded OID.

    .EXAMPLE

    ConvertTo-Oid -EncodedOIDBytes @(0x06, 0x0A, 0x2B, 0x06, 0x01, 0x04, 0x01, 0x82, 0x37, 0x0A, 0x03, 0x05)

    .OUTPUTS

    System.Security.Cryptography.Oid

    ConvertTo-Oid outputs an OID object representing the decoded OID.
    #>

        [OutputType([System.Security.Cryptography.Oid])]
        param (
            [Parameter(Mandatory = $True, Position = 0)]
            [Byte[]]
            [ValidateNotNullOrEmpty()]
            $EncodedOIDBytes
        )

        # This only handles absolute encoded OIDs - those that start with 6.
        # [Security.Cryptography.CryptoConfig]::EncodeOID only handles absolute OIDs.

        # This article describes the OID encoding/decoding process:
        # https://msdn.microsoft.com/en-us/library/windows/desktop/bb540809(v=vs.85).aspx

        if (($EncodedOIDBytes.Length -lt 2) -or ($EncodedOIDBytes[1] -ne ($EncodedOIDBytes.Length - 2))) {
            throw 'Invalid encoded EKU OID value.'
        }

        $OIDComponents = New-Object -TypeName 'System.Collections.Generic.List[Int]'

        $SecondComponent = $EncodedOIDBytes[2] % 40
        $FirstComponent = ($EncodedOIDBytes[2] - $SecondComponent) / 40

        $OIDComponents.Add($FirstComponent)
        $OIDComponents.Add($SecondComponent)

        $i = 3

        while ($i -lt $EncodedOIDBytes.Length) {
            if (-not ($EncodedOIDBytes[$i] -band 0x80)) {
                # It is just singlebyte encoded
                $OIDComponents.Add($EncodedOIDBytes[$i])
                $i++
            } else {
                # It is either two or three byte encoded
                $Byte1 = ($EncodedOIDBytes[$i] -shl 1) -shr 1 # Strip the high bit
                $Byte2 = $EncodedOIDBytes[$i+1]

                if ($Byte2 -band 0x80) {
                    # three byte encoded
                    $Byte3 = $EncodedOIDBytes[$i+2]
                    $i += 3

                    $Byte2 = $Byte2 -band 0x7F
                    if ($Byte2 -band 1) { $Byte3 = $Byte3 -bor 0x80 }
                    if ($Byte1 -band 1) { $Byte2 = $Byte2 -bor 0x80 }
                    $Byte2 = $Byte2 -shr 1
                    $Byte1 = $Byte1 -shr 1
                    if ($Byte2 -band 1) { $Byte2 = $Byte2 -bor 0x80 }
                    $Byte1 = $Byte1 -shr 1

                    $OIDComponents.Add([BitConverter]::ToInt32(@($Byte3, $Byte2, $Byte1, 0), 0))
                } else {
                    # two byte encoded
                    $i +=2

                    # "Shift" the low bit from the high byte to the high bit of the low byte
                    if ($Byte1 -band 1) { $Byte2 -bor 0x80 }
                    $Byte1 = $Byte1 -shr 1

                    $OIDComponents.Add([BitConverter]::ToInt16(@($Byte2, $Byte1), 0))
                }
            }
        }

        [Security.Cryptography.Oid] ($OIDComponents -join '.')
    }

    # Helper function to read strings from the binary
    function Get-BinaryString {
        [OutputType('String')]
        param (
            [Parameter(Mandatory)]
            [IO.BinaryReader]
            [ValidateNotNullOrEmpty()]
            $BinaryReader
        )

        $StringLength = $BinaryReader.ReadUInt32()

        if ($StringLength) {
            $PaddingBytes = 4 - $StringLength % 4 -band 3

            $StringBytes = $BinaryReader.ReadBytes($StringLength)
            $null = $BinaryReader.ReadBytes($PaddingBytes)

            [Text.Encoding]::Unicode.GetString($StringBytes)
        }

        $null = $BinaryReader.ReadInt32()
    }

    # Obtain the full path to the policy file if a relative path was provided.
    $BinPath = Resolve-Path $BinaryFilePath

    $XmlPathDir = Split-Path -Path $XmlFilePath -Parent
    $XmlPathFile = Split-Path -Path $XmlFilePath -Leaf

    if (-not $XmlPathDir) {
        $XmlPathDir = $PWD
    }

    $ResolvedDir = Resolve-Path -Path $XmlPathDir

    if (-not [System.IO.Directory]::Exists($ResolvedDir.Path)) {
        throw "Cannot find path '$ResolvedDir' because it does not exist."
        return
    }

    $FullXmlPath = Join-Path -Path $ResolvedDir -ChildPath $XmlPathFile

    try {
        $CIPolicyBytes = [IO.File]::ReadAllBytes($BinPath.Path)

        try {
            try {
                $ContentType = [Security.Cryptography.Pkcs.ContentInfo]::GetContentType($CIPolicyBytes)
            } catch {
                $ContentType = $null
            }

            # Check for PKCS#7 ASN.1 SignedData type
            if ($ContentType -and $ContentType.Value -eq '1.2.840.113549.1.7.2') {
              $Cms = New-Object System.Security.Cryptography.Pkcs.SignedCms
              $Cms.Decode($CIPolicyBytes)
              $CIPolicyBytes = $Cms.ContentInfo.Content
              if ($CIPolicyBytes[0] -eq 4) {
                # Policy is stored as an OCTET STRING
                $PolicySize = $CIPolicyBytes[1]
                $BaseIndex = 2
                if (($PolicySize -band 0x80) -eq 0x80) {
                    $SizeCount = $PolicySize -band 0x7F
                    $BaseIndex += $SizeCount
                    $PolicySize = 0
                    for ($i = 0; $i -lt $SizeCount; $i++) {
                        $PolicySize = $PolicySize -shl 8
                        $PolicySize = $PolicySize -bor $CIPolicyBytes[2 + $i]
                    }
                }

                $CIPolicyBytes = $CIPolicyBytes[$BaseIndex..($BaseIndex + $PolicySize - 1)]
              }
            }
        } catch {
            Write-Output $_
        }

        $MemoryStream = New-Object -TypeName IO.MemoryStream -ArgumentList @(,$CIPolicyBytes)
        $BinaryReader = New-Object -TypeName System.IO.BinaryReader -ArgumentList $MemoryStream, ([Text.Encoding]::Unicode)
    } catch {
        throw $_
        return
    }

    $SIPolicy = New-Object -TypeName CodeIntegrity.SIPolicy

    try {
        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): CI Policy Format Version"

        # Validate binary CI policy header
        # This header value indicates likely indicates the schema version that was used.
        # This script will only support whatever the latest schema version was at the time of last update, in this case, 7.
        $CIPolicyFormatVersion = $BinaryReader.ReadInt32()

        # My inference is that the binary format will terminate with a UInt32 value that is $CIPolicyFormatVersion + 1.
        # For example, if $CIPolicyFormatVersion is 7, the binary policy is expected to be terminated with 0x00000008.
        # This way, should the following warning be presented, should a format version of 8 be introduced, I will know that
        # there will be binary data in need of parsing beyond 0x00000008.

        if ($CIPolicyFormatVersion -gt 7) {
            Write-Warning "$BinPath has an invalid or unsupported binary CI policy format version value: 0x$($CIPolicyFormatVersion.ToString('X8')). If you are sure that you are dealing with a binary code integrity policy, there is a high liklihood that Microsoft updated the binary file for mat to support new schema elements and that this code will likely need to be updated."
        }

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): PolicyTypeID"

        $PolicyTypeID = [Guid][Byte[]] $BinaryReader.ReadBytes($GuidLength)

        # The policy type ID can be used to determine the intended purpose of the CI policy
        switch ($PolicyTypeID.Guid) {
            'a244370e-44c9-4c06-b551-f6016e563076' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - Enterprise Code Integrity Policy (SiPolicy.p7b or UpdateSiPolicy.p7b)" }
            '2a5a0136-f09f-498e-99cc-51099011157c' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - Windows Revoke Code Integrity Policy (RvkSiPolicy.p7b or UpdateRvkSiPolicy.p7b)" }
            '976d12c8-cb9f-4730-be52-54600843238e' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - SKU Code Integrity Policy (SkuSiPolicy.p7b or UpdateSkuSiPolicy.p7b)" }
            '5951a96a-e0b5-4d3d-8fb8-3e5b61030784' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - Windows Lockdown (S-Mode) Code Integrity Policy (WinSiPolicy.p7b or UpdateWinSiPolicy.p7b)" }
            '4e61c68c-97f6-430b-9cd7-9b1004706770' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - Advanced Threat Protection Code Integrity Policy (ATPSiPolicy.p7b or UpdateATPSiPolicy.p7b)" }
            'd2bda982-ccf6-4344-ac5b-0b44427b6816' { Write-Verbose "PolicyTypeID: {$PolicyTypeID} - Driver Code Integrity Policy (DriverSiPolicy.p7b or UpdateDriverSiPolicy.p7b)" }
        }

        $SetPolicyTypeID = $True

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): PlatformID"

        [Byte[]] $PlatformIDBytes = $BinaryReader.ReadBytes($GuidLength)
        $PlatformID = [Guid] $PlatformIDBytes

        $SIPolicy.PlatformID = "{$($PlatformID.ToString().ToUpper())}"

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Option Flags"

        $OptionFlags = $BinaryReader.ReadInt32()

        # Validate that the high bit is set - i.e. mask it off with 0x80000000
        if ($OptionFlags -band ([Int32]::MinValue) -ne [Int32]::MinValue) {
            throw "Invalid policy options flag. $CorruptPolicyErr"
            return
        }

        if (($OptionFlags -band 0x40000000) -eq 0x40000000) {
            Write-Verbose 'Policy option flags indicate that the code integrity policy was built from supplmental policies.'
        }

        # Obtain the policy rules but first remove the upper two high bits -
        # i.e. anding it with 0x3FFFFFFF first
        $PolicyRules = [CodeIntegrity.PolicyRules] ($OptionFlags -band 0x3FFFFFFF)

        $PolicyRulesArray = $PolicyRules -split ', '

        $Rules = New-Object -TypeName CodeIntegrity.RuleType[]($PolicyRulesArray.Length)

        for ($i = 0; $i -lt $Rules.Length; $i++) {
            $RuleType = New-Object -TypeName CodeIntegrity.RuleType -Property @{ Item = $PolicyRulesArray[$i] }
            $Rules[$i] = $RuleType
        }

        $SIPolicy.Rules = $Rules

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): EKU Rule Count"
        $EKURuleEntryCount = $BinaryReader.ReadInt32()

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): File Rule Count"
        $FileRuleEntryCount = $BinaryReader.ReadInt32()

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Signer Rule Count"
        $SignerRuleEntryCount = $BinaryReader.ReadInt32()

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Signer Scenario Rule Count"
        $SignerScenarioEntryCount = $BinaryReader.ReadInt32()

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): VersionEx"
        $Revis = $BinaryReader.ReadUInt16()
        $Build = $BinaryReader.ReadUInt16()
        $Minor = $BinaryReader.ReadUInt16()
        $Major = $BinaryReader.ReadUInt16()

        $PolicyVersion = New-Object -TypeName Version -ArgumentList $Major, $Minor, $Build, $Revis

        $SIPolicy.VersionEx = $PolicyVersion

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Header Length"
        # Validate that the fixed header length was written to the end of the header
        $HeaderLength = $BinaryReader.ReadInt32()

        if ($HeaderLength -ne ($HeaderLengthMax - 4)) {
            Write-Warning "$BinPath has an invalid header footer: 0x$($HeaderLength.ToString('X8')). $CorruptPolicyErr"
        }

        if ($EKURuleEntryCount) {
            $EKUArray = New-Object -TypeName CodeIntegrity.EKU[]($EKURuleEntryCount)

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): EKU Rules"

            for ($i = 0; $i -lt $EKURuleEntryCount; $i++) {
                # Length of the encoded EKU OID value
                $EkuValueLen = $BinaryReader.ReadUInt32()

                # Length of the encoded EKU OID value padded out to 4 bytes
                $PaddingBytes = 4 - $EkuValueLen % 4 -band 3

                $EKUValueBytes = $BinaryReader.ReadBytes($EkuValueLen)
                $null = $BinaryReader.ReadBytes($PaddingBytes)

                $EKUValueBytesCopy = $EKUValueBytes
                #$EKUValueBytesCopy[0] = 6

                $OID = ConvertTo-Oid -EncodedOIDBytes $EKUValueBytesCopy

                $Properties = @{
                    Value = $EKUValueBytes
                    ID = "ID_EKU_E_$(($i + 1).ToString('X4'))"
                }

                # Reconstruct the original FriendlyName that would have been lost
                # in the process of converting to binary form.
                if ($OID) {
                    if ($OID.FriendlyName) {
                        $Properties['FriendlyName'] = $OID.FriendlyName
                    } elseif ($OID.Value) {
                        $Properties['FriendlyName'] = $OID.Value
                    }
                }

                $EKUArray[$i] = New-Object -TypeName CodeIntegrity.EKU -Property $Properties
            }

            $SIPolicy.EKUs = $EKUArray
        }

        if ($FileRuleEntryCount) {
            # The XMl serializer won't validate unless
            # I use a generic collection vs. a System.Object[].
            $Script:FileRulesArray = New-Object -TypeName 'System.Collections.Generic.List[Object]'

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): File Rules"

            for ($i = 0; $i -lt $FileRuleEntryCount; $i++) {
                $FileRuleTypeValue = $BinaryReader.ReadInt32()

                switch ($FileRuleTypeValue) {
                    0 {
                        $TypeName = 'CodeIntegrity.Deny'
                        $ID = "ID_DENY_D_$(($i + 1).ToString('X4'))"
                    }

                    1 {
                        $TypeName = 'CodeIntegrity.Allow'
                        $ID = "ID_ALLOW_A_$(($i + 1).ToString('X4'))"
                    }

                    2 {
                        $TypeName = 'CodeIntegrity.FileAttrib'
                        $ID = "ID_FILEATTRIB_F_$(($i + 1).ToString('X4'))"
                    }

                    default { throw "Invalid file rule type: 0x$($FileRuleTypeValue.ToString('X8'))" }
                }

                $FileRule = New-Object -TypeName $TypeName -Property @{ ID = $ID }

                $FileName = Get-BinaryString -BinaryReader $BinaryReader

                if ($FileName) {
                    $FileRule.FileName = $FileName
                }

                $Revis = $BinaryReader.ReadUInt16()
                $Build = $BinaryReader.ReadUInt16()
                $Minor = $BinaryReader.ReadUInt16()
                $Major = $BinaryReader.ReadUInt16()

                $MinimumVersion = New-Object -TypeName Version -ArgumentList $Major, $Minor, $Build, $Revis

                # If it's a deny rule and MaximumFileVersion is null, the version will be set to 65535.65535.65535.65535
                # Otherwise, if MinimumFileVersion is non-zero, then a MinimumFileVersion was specified.
                if (!(($FileRuleTypeValue -eq 0) -and ($MinimumVersion -eq '65535.65535.65535.65535')) -and ($MinimumVersion -ne '0.0.0.0')) {
                    $FileRule.MinimumFileVersion = $MinimumVersion
                }

                $HashLen = $BinaryReader.ReadUInt32()

                if ($HashLen) {
                    $PaddingBytes = 4 - $HashLen % 4 -band 3

                    $HashBytes = $BinaryReader.ReadBytes($HashLen)
                    $null = $BinaryReader.ReadBytes($PaddingBytes)

                    $FileRule.Hash = $HashBytes
                }

                $Script:FileRulesArray.Add($FileRule)
            }

            $SIPolicy.FileRules = $Script:FileRulesArray
        }

        if ($SignerRuleEntryCount) {
            $Script:SignersArray = New-Object -TypeName CodeIntegrity.Signer[]($SignerRuleEntryCount)

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Signer Rules"

            for ($i = 0; $i -lt $SignerRuleEntryCount; $i++) {
                $CertRootTypeValue = $BinaryReader.ReadInt32()

                $Signer = New-Object -TypeName CodeIntegrity.Signer -Property @{
                    ID = "ID_SIGNER_S_$(($i + 1).ToString('X4'))"
                    Name = "Signer $($i + 1)"
                }

                switch ($CertRootTypeValue) {
                    0 { $CertRootType = [CodeIntegrity.CertEnumType] 'TBS' } # TBS - To Be Signed
                    1 { $CertRootType = [CodeIntegrity.CertEnumType] 'WellKnown' }
                    default { throw "Invalid certificate root type: 0x$($CertRooTypeValue.ToString('X8'))" }
                }

                if ($CertRootType -eq 'TBS') {
                    $CertRootLength = $BinaryReader.ReadUInt32()

                    if ($CertRootLength) {
                        $PaddingBytes = 4 - $CertRootLength % 4 -band 3

                        # This is a hash of the ToBeSigned data blob.
                        # The hashing algorithm used is dictated by the algorithm specified in the certificate.
                        [Byte[]] $CertRootBytes = $BinaryReader.ReadBytes($CertRootLength)

                        $null = $BinaryReader.ReadBytes($PaddingBytes)
                    }
                } else {
                    # WellKnown type

                    # I'd like to know what these map to. I assume there's a mapped list of common
                    # Microsoft root certificates.
                    # It doesn't appear as though the ConfigCI cmdlets can generate a well known root type.
                    [Byte[]] $CertRootBytes = @(($BinaryReader.ReadUInt32() -band 0xFF))
                }

                $CertRootObject = New-Object -TypeName CodeIntegrity.CertRoot -Property @{ Type = $CertRootType; Value = $CertRootBytes }

                $Signer.CertRoot = $CertRootObject

                $CertEKULength = $BinaryReader.ReadUInt32()

                if ($CertEKULength) {
                    $CertEKUArray = New-Object -TypeName CodeIntegrity.CertEKU[]($CertEKULength)

                    for ($j = 0; $j -lt $CertEKULength; $j++) {
                        $EKUIndex = $BinaryReader.ReadUInt32()
                        $CertEKUArray[$j] = New-Object -TypeName CodeIntegrity.CertEKU -Property @{ ID = $SIPolicy.EKUs[$EKUIndex].ID }
                    }

                    $Signer.CertEKU = $CertEKUArray
                }

                $CertIssuer = Get-BinaryString -BinaryReader $BinaryReader

                if ($CertIssuer) {
                    $Signer.CertIssuer = New-Object -TypeName CodeIntegrity.CertIssuer -Property @{ Value = $CertIssuer }
                }

                $CertPublisher = Get-BinaryString -BinaryReader $BinaryReader

                if ($CertPublisher) {
                    $Signer.CertPublisher = New-Object -TypeName CodeIntegrity.CertPublisher -Property @{ Value = $CertPublisher }
                }

                $CertOemID = Get-BinaryString -BinaryReader $BinaryReader

                if ($CertOemID) {
                    $Signer.CertOemID = New-Object -TypeName CodeIntegrity.CertOemID -Property @{ Value = $CertOemID }
                }

                $FileAttribRefLength = $BinaryReader.ReadUInt32()

                if ($FileAttribRefLength) {
                    $FileAttribRefArray = New-Object -TypeName CodeIntegrity.FileAttribRef[]($FileAttribRefLength)

                    for ($j = 0; $j -lt $FileAttribRefLength; $j++) {
                        $FileAttribRefIndex = $BinaryReader.ReadUInt32()
                        $FileAttribRefArray[$j] = New-Object -TypeName CodeIntegrity.FileAttribRef -Property @{ RuleID = $SIPolicy.FileRules[$FileAttribRefIndex].ID }
                    }

                    $Signer.FileAttribRef = $FileAttribRefArray
                }

                $Script:SignersArray[$i] = $Signer
            }

            $SIPolicy.Signers = $Script:SignersArray
        }

        $UpdatePolicySignersLength = $BinaryReader.ReadUInt32()

        if ($UpdatePolicySignersLength) {
            $UpdatePolicySigners = New-Object -TypeName CodeIntegrity.UpdatePolicySigner[]($UpdatePolicySignersLength)

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Update Policy Signers"

            for ($i = 0; $i -lt $UpdatePolicySignersLength; $i++) {
                $UpdatePolicySignersIndex = $BinaryReader.ReadUInt32()
                $UpdatePolicySigners[$i] = New-Object -TypeName CodeIntegrity.UpdatePolicySigner -Property @{ SignerId = $SIPolicy.Signers[$UpdatePolicySignersIndex].ID }
            }

            $SIPolicy.UpdatePolicySigners = $UpdatePolicySigners
        }

        $CISignersLength = $BinaryReader.ReadUInt32()

        if ($CISignersLength) {
            $CISigners = New-Object -TypeName CodeIntegrity.CiSigner[]($CISignersLength)

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): CI Signers"

            for ($i = 0; $i -lt $CISignersLength; $i++) {
                $CISignersIndex = $BinaryReader.ReadUInt32()
                $CISigners[$i] = New-Object -TypeName CodeIntegrity.CiSigner -Property @{ SignerId = $SIPolicy.Signers[$CISignersIndex].ID }
            }

            $SIPolicy.CiSigners = $CISigners
        }

        if ($SignerScenarioEntryCount) {
            $SignerScenarioArray = New-Object -TypeName CodeIntegrity.SigningScenario[]($SignerScenarioEntryCount)

            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Signer Scenarios"

            for ($i = 0; $i -lt $SignerScenarioEntryCount; $i++) {
                [Byte] $SigningScenarioValue = $BinaryReader.ReadUInt32() -band 0xFF

                $DriverSigningScenarioCount = 1
                $WindowsSigningScenarioCount = 0

                switch ($SigningScenarioValue) {
                    131 {
                        $ID = "ID_SIGNINGSCENARIO_DRIVERS_$($DriverSigningScenarioCount.ToString('X'))"
                        $DriverSigningScenarioCount++
                    }

                    12 {
                        $ID = 'ID_SIGNINGSCENARIO_WINDOWS'

                        # It is unlikely that there would ever be more than one windows
                        # (i.e. user mode) signing scenario but handle it just in case.
                        if ($WindowsSigningScenarioCount) {
                            $ID += "_$(($WindowsSigningScenarioCount + 1).ToString('X'))"
                        }

                        $WindowsSigningScenarioCount++
                    }

                    default {
                        # It is unlikely that there would ever be a value other than
                        # 131 or 12 but account for it anyway.
                        $ID = "ID_SIGNINGSCENARIO_S_$(($i + 1).ToString('X4'))"
                    }
                }

                $SigningScenario = New-Object -TypeName CodeIntegrity.SigningScenario -Property @{ ID = $ID; Value = $SigningScenarioValue }

                # The ability to inherit from another signing scenario is not formally documented
                # other than in the SIPolicy schema.
                $InheritedScenarios = $null

                $InheritedScenarioLength = $BinaryReader.ReadUInt32()

                if ($InheritedScenarioLength) {
                    $InheritedScenarios = New-Object UInt32[]($InheritedScenarioLength)

                    for ($j = 0; $j -lt $InheritedScenarioLength; $j++) {
                        $InheritedScenarios[$j] = $BinaryReader.ReadUInt32()
                    }

                    # To-do: Make sure I resolve the indices later on!
                    $InheritedScenariosString = $InheritedScenarios -join ','
                    $SigningScenario.InheritedScenarios = $InheritedScenariosString
                }

                [UInt16] $MinimumHashValueValue = $BinaryReader.ReadUInt32() -band [UInt16]::MaxValue

                # 0x800C refers to the absense of a minimum hash algorithm.
                if ($MinimumHashValueValue -ne 0x800C) {
                    $MinimumHashValue = $MinimumHashValueValue

                    $SigningScenario.MinimumHashAlgorithmSpecified = $True
                    $SigningScenario.MinimumHashAlgorithm = $MinimumHashValue
                } else {
                    $SigningScenario.MinimumHashAlgorithmSpecified = $False
                }

                # Loop over product signers, test signers, and test signing signers
                1..3 | ForEach-Object {
                    $AllowedSignersCount = $BinaryReader.ReadUInt32()
                    $AllowSignersObject = $null

                    if ($AllowedSignersCount) {
                        $AllowSignersObject = New-Object -TypeName CodeIntegrity.AllowedSigners
                        $AllowSignerArray = New-Object -TypeName CodeIntegrity.AllowedSigner[]($AllowedSignersCount)

                        for ($j = 0; $j -lt $AllowedSignersCount; $j++) {
                            $AllowedSignerIndex = $BinaryReader.ReadUInt32()

                            $ExceptDenyRuleLength = $BinaryReader.ReadUInt32()

                            $ExceptDenyRulesArray = $null

                            if ($ExceptDenyRuleLength) {
                                $ExceptDenyRulesArray = New-Object -TypeName CodeIntegrity.ExceptDenyRule[]($ExceptDenyRuleLength)

                                for ($k = 0; $k -lt $ExceptDenyRuleLength; $k++) {
                                    $ExceptDenyRuleIndex = $BinaryReader.ReadUInt32()
                                    $ExceptDenyRulesArray[$k] = New-Object -TypeName CodeIntegrity.ExceptDenyRule -Property @{ DenyRuleID = $SIPolicy.FileRules[$ExceptDenyRuleIndex].ID }
                                }
                            }

                            $AllowSignerArray[$j] = New-Object -TypeName CodeIntegrity.AllowedSigner -Property @{ SignerId = $SIPolicy.Signers[$AllowedSignerIndex].ID }
                            $AllowSignerArray[$j].ExceptDenyRule = $ExceptDenyRulesArray
                        }

                        $AllowSignersObject.AllowedSigner = $AllowSignerArray
                    }

                    $DeniedSignersCount = $BinaryReader.ReadUInt32()
                    $DeniedSignersObject = $null

                    if ($DeniedSignersCount) {
                        $DeniedSignersObject = New-Object -TypeName CodeIntegrity.DeniedSigners
                        $DeniedSignerArray = New-Object -TypeName CodeIntegrity.DeniedSigner[]($DeniedSignersCount)

                        for ($j = 0; $j -lt $DeniedSignersCount; $j++) {
                            $DeniedSignerIndex = $BinaryReader.ReadUInt32()

                            $ExceptAllowRuleLength = $BinaryReader.ReadUInt32()

                            $ExceptAllowRulesArray = $null

                            if ($ExceptAllowRuleLength) {
                                $ExceptAllowRulesArray = New-Object -TypeName CodeIntegrity.ExceptAllowRule[]($ExceptAllowRuleLength)

                                for ($k = 0; $k -lt $ExceptAllowRuleLength; $k++) {
                                    $ExceptAllowRuleIndex = $BinaryReader.ReadUInt32()
                                    $ExceptAllowRulesArray[$k] = New-Object -TypeName CodeIntegrity.ExceptAllowRule -Property @{ AllowRuleID = $SIPolicy.FileRules[$ExceptAllowRuleIndex].ID }
                                }
                            }

                            $DeniedSignerArray[$j] = New-Object -TypeName CodeIntegrity.DeniedSigner -Property @{ SignerId = $SIPolicy.Signers[$DeniedSignerIndex].ID }
                            $DeniedSignerArray[$j].ExceptAllowRule = $ExceptAllowRulesArray
                        }

                        $DeniedSignersObject.DeniedSigner = $DeniedSignerArray
                    }

                    $FileRulesRefCount = $BinaryReader.ReadUInt32()
                    $FileRulesRefObject = $null

                    if ($FileRulesRefCount) {
                        $FileRulesRefObject = New-Object -TypeName CodeIntegrity.FileRulesRef
                        $FileRuleRefArray = New-Object -TypeName CodeIntegrity.FileRuleRef[]($FileRulesRefCount)

                        for ($j = 0; $j -lt $FileRulesRefCount; $j++) {
                            $FileRulesRefIndex = $BinaryReader.ReadUInt32()

                            $FileRuleRefArray[$j] = New-Object -TypeName CodeIntegrity.FileRuleRef -Property @{ RuleID = $SIPolicy.FileRules[$FileRulesRefIndex].ID }
                        }

                        $FileRulesRefObject.FileRuleRef = $FileRuleRefArray
                    }

                    $NullSigner = $False

                    # Don't populate the relevant object if it wasn't present in the binary.
                    # Even setting a property to null in an object that can be serialized
                    # with XML can result in the creation of empty XML element/attributes.
                    if (($AllowedSignersCount -eq 0) -and ($DeniedSignersCount -eq 0) -and ($FileRulesRefCount -eq 0)) {
                        $NullSigner = $True
                    }

                    switch ($_) {
                        1 { # Product signers
                            if (-not $NullSigner) {
                                $ProductSigner = New-Object -TypeName CodeIntegrity.ProductSigners

                                if ($AllowSignersObject) { $ProductSigner.AllowedSigners = $AllowSignersObject }
                                if ($DeniedSignersObject) { $ProductSigner.DeniedSigners = $DeniedSignersObject }
                                if ($FileRulesRefObject) { $ProductSigner.FileRulesRef = $FileRulesRefObject }

                                $SigningScenario.ProductSigners = $ProductSigner
                            } else {
                                $SigningScenario.ProductSigners = New-Object -TypeName CodeIntegrity.ProductSigners
                            }
                        }

                        2 { # Test signers
                            if (-not $NullSigner) {
                                $TestSigner = New-Object -TypeName CodeIntegrity.TestSigners

                                if ($AllowSignersObject) { $TestSigner.AllowedSigners = $AllowSignersObject }
                                if ($DeniedSignersObject) { $TestSigner.DeniedSigners = $DeniedSignersObject }
                                if ($FileRulesRefObject) { $TestSigner.FileRulesRef = $FileRulesRefObject }

                                $SigningScenario.TestSigners = $TestSigner
                            } else {
                                $SigningScenario.TestSigners = New-Object -TypeName CodeIntegrity.TestSigners
                            }
                        }

                        3 { # Test signing signers
                            if (-not $NullSigner) {
                                $TestSigningSigner = New-Object -TypeName CodeIntegrity.TestSigningSigners

                                if ($AllowSignersObject) { $TestSigningSigner.AllowedSigners = $AllowSignersObject }
                                if ($DeniedSignersObject) { $TestSigningSigner.DeniedSigners = $DeniedSignersObject }
                                if ($FileRulesRefObject) { $TestSigningSigner.FileRulesRef = $FileRulesRefObject }

                                $SigningScenario.TestSigningSigners = $TestSigningSigner
                            } else {
                                $SigningScenario.TestSigningSigners = New-Object -TypeName CodeIntegrity.TestSigningSigners
                            }
                        }
                    }
                }

                $SignerScenarioArray[$i] = $SigningScenario
            }

            # Resolve inherited scenario IDs now that they've all been parsed.
            for ($i = 0; $i -lt $SignerScenarioEntryCount; $i++) {
                if ($SignerScenarioArray[$i].InheritedScenarios) {
                    [Int[]] $ScenarioIndices = $SignerScenarioArray[$i].InheritedScenarios -split ','

                    $SignerScenarioArray[$i].InheritedScenarios = ($ScenarioIndices | ForEach-Object { $SignerScenarioArray[$_].ID }) -join ','
                }
            }

            $SIPolicy.SigningScenarios = $SignerScenarioArray
        }

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): HVCI Options"
        # Maybe I could parse this out
        $HVCIOptions = $BinaryReader.ReadUInt32()

        if ($HVCIOptions) {
            $SIPolicy.HvciOptions = $HVCIOptions
            $SIPolicy.HvciOptionsSpecified = $True
        } else {
            $SIPolicy.HvciOptionsSpecified = $False
        }

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Secure Settings"
        $SecureSettingsLength = $BinaryReader.ReadUInt32()

        if ($SecureSettingsLength) {

            $SecureSettings = New-Object CodeIntegrity.Setting[]($SecureSettingsLength)

            for ($i = 0; $i -lt $SecureSettingsLength; $i++) {
                Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Secure Settings [$i]"

                $Provider = Get-BinaryString -BinaryReader $BinaryReader
                $Key = Get-BinaryString -BinaryReader $BinaryReader
                $ValueName = Get-BinaryString -BinaryReader $BinaryReader

                $ValueType = $BinaryReader.ReadUInt32()

                switch ($ValueType) {
                    0 { # Boolean type
                        [Bool] $Value = $BinaryReader.ReadUInt32()
                    }

                    1 { # Unsigned int type
                        [UInt32] $Value = $BinaryReader.ReadUInt32()
                    }

                    2 { # Byte array type
                        # Length of the byte array
                        $ByteArrayLen = $BinaryReader.ReadUInt32()

                        # Length of the byte array padded out to 4 bytes
                        $PaddingBytes = 4 - $ByteArrayLen % 4 -band 3

                        $ValueBytes = $BinaryReader.ReadBytes($ByteArrayLen)
                        $null = $BinaryReader.ReadBytes($PaddingBytes)

                        [Byte[]] $Value = $ValueBytes
                    }

                    3 { # String type
                        [String] $Value = Get-BinaryString -BinaryReader $BinaryReader
                    }
                }

                $SecureSetting = New-Object CodeIntegrity.Setting
                $SettingValueType = New-Object CodeIntegrity.SettingValueType
                $SettingValueType.Item = $Value

                $SecureSetting.Provider = $Provider
                $SecureSetting.Key = $Key
                $SecureSetting.ValueName = $ValueName
                $SecureSetting.Value = $SettingValueType

                $SecureSettings[$i] = $SecureSetting
            }

            $SIPolicy.Settings = $SecureSettings
        }

        $V3RuleSupport = $BinaryReader.ReadUInt32()

        if ($V3RuleSupport -eq 3 -and $CIPolicyFormatVersion -ge 3) {

            Write-Verbose 'Processing binary format v3 rules: file rule maximum versions and macro rules'

            if ($FileRuleEntryCount) {

                Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): File Rules Macros"

                for ($i = 0; $i -lt $FileRuleEntryCount; $i++) {
                    $Revis = $BinaryReader.ReadUInt16()
                    $Build = $BinaryReader.ReadUInt16()
                    $Minor = $BinaryReader.ReadUInt16()
                    $Major = $BinaryReader.ReadUInt16()

                    $MaximumVersion = New-Object -TypeName Version -ArgumentList $Major, $Minor, $Build, $Revis

                    if ($MaximumVersion -ne ([Version] '0.0.0.0')) {
                        $Script:FileRulesArray[$i].MaximumFileVersion = $MaximumVersion
                    }

                    $MacroStringCount = $BinaryReader.ReadUInt32()

                    # Note: macro names are not stored in a binary policy (only values) so no effort will be made to infer macro names.
                    if ($MacroStringCount) {
                        if ($MacroStringCount -eq 1) {
                            $MacroString = Get-BinaryString -BinaryReader $BinaryReader

                            $Script:FileRulesArray[$i].AppIDs = $MacroString
                        } else {
                            $MacroStrings = (1..$MacroStringCount | ForEach-Object { Get-BinaryString -BinaryReader $BinaryReader }) -join ''

                            $Script:FileRulesArray[$i].AppIDs = $MacroStrings
                        }
                    }
                }
            }

            if ($SignerRuleEntryCount) {

                Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Signer Rules Macro"

                for ($i = 0; $i -lt $SignerRuleEntryCount; $i++) {
                    $SignTimeAfterValue = $BinaryReader.ReadInt64()

                    if ($SignTimeAfterValue -ne 0) {
                        $Script:SignersArray[$i].SignTimeAfter = [DateTime]::FromFileTime($SignTimeAfterValue)
                    }
                }
            }

            $V4RuleSupport = $BinaryReader.ReadUInt32()

            if ($V4RuleSupport -eq 4 -and $CIPolicyFormatVersion -ge 4) {
                Write-Verbose 'Processing binary format v4 rules: file metadata - InternalName, FileDescription, ProductName'

                if ($FileRuleEntryCount) {

                    Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): File Rules File Metadata"

                    for ($i = 0; $i -lt $FileRuleEntryCount; $i++) {
                        $InternalName = Get-BinaryString -BinaryReader $BinaryReader
                        $FileDescription = Get-BinaryString -BinaryReader $BinaryReader
                        $ProductName = Get-BinaryString -BinaryReader $BinaryReader

                        if ($InternalName) { $Script:FileRulesArray[$i].InternalName = $InternalName }
                        if ($FileDescription) { $Script:FileRulesArray[$i].FileDescription = $FileDescription }
                        if ($ProductName) { $Script:FileRulesArray[$i].ProductName = $ProductName }
                    }
                }

                $V5RuleSupport = $BinaryReader.ReadUInt32()

                if ($V5RuleSupport -eq 5 -and $CIPolicyFormatVersion -ge 5) {
                    Write-Verbose 'Processing binary format v5 rules: PackageFamilyName and PackageVersion'

                    if ($FileRuleEntryCount) {

                        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): File Rules Package Metadata"

                        for ($i = 0; $i -lt $FileRuleEntryCount; $i++) {
                            $PackageFamilyName = Get-BinaryString -BinaryReader $BinaryReader

                            $Revis = $BinaryReader.ReadUInt16()
                            $Build = $BinaryReader.ReadUInt16()
                            $Minor = $BinaryReader.ReadUInt16()
                            $Major = $BinaryReader.ReadUInt16()

                            $PackageVersion = New-Object -TypeName Version -ArgumentList $Major, $Minor, $Build, $Revis

                            if ($PackageFamilyName) { $Script:FileRulesArray[$i].PackageFamilyName = $PackageFamilyName }

                            if ($PackageVersion -ne ([Version] '0.0.0.0')) {
                                $Script:FileRulesArray[$i].PackageVersion = $PackageVersion
                            }
                        }
                    }

                    $V6RuleSupport = $BinaryReader.ReadUInt32()

                    if ($V6RuleSupport -eq 6 -and $CIPolicyFormatVersion -ge 6) {

                        Write-Verbose 'Processing binary format v6 rules: Supplemental policy information - BasePolicyID, PolicyID, and supplemental signers'

                        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): BasePolicyID and PolicyID GUID"

                        # The CI policy has the new BasePolicyID and PolicyID elements versus the older PolicyTypeID element.

                        $PolicyID = [Guid][Byte[]] $BinaryReader.ReadBytes($GuidLength)

                        $SIPolicy.PolicyID = "{$($PolicyID.ToString().ToUpper())}"

                        $BasePolicyID = [Guid][Byte[]] $BinaryReader.ReadBytes($GuidLength)

                        $SIPolicy.BasePolicyID = "{$($BasePolicyID.ToString().ToUpper())}"

                        $SIPolicy.PolicyTypeSpecified = $True

                        if ($SIPolicy.PolicyID -eq $SIPolicy.BasePolicyID) {
                            $SIPolicy.PolicyType = 'BasePolicy'
                        } else {
                            $SIPolicy.PolicyType = 'SupplementalPolicy'
                        }

                        $SetPolicyTypeID = $False

                        $SupplementalSignerRuleEntryCount = $BinaryReader.ReadUInt32()

                        if ($SupplementalSignerRuleEntryCount) {
                            $SupplementalSigners = New-Object -TypeName CodeIntegrity.SupplementalPolicySigner[]($SupplementalSignerRuleEntryCount)

                            Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): Supplemental Signers"

                            for ($i = 0; $i -lt $SupplementalSignerRuleEntryCount; $i++) {
                                $SupplemetalSignersIndex = $BinaryReader.ReadUInt32()
                                $SupplementalSigners[$i] = New-Object -TypeName CodeIntegrity.SupplementalPolicySigner -Property @{ SignerId = $SIPolicy.Signers[$SupplemetalSignersIndex].ID }
                            }

                            $SIPolicy.SupplementalPolicySigners = $SupplementalSigners
                        }

                        $V7RuleSupport = $BinaryReader.ReadUInt32()

                        if ($V7RuleSupport -eq 7 -and $CIPolicyFormatVersion -ge 7) {
                            Write-Verbose 'Processing binary format v7 rules: FilePath rules'

                            if ($FileRuleEntryCount) {

                                Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): FilePath Rules"

                                for ($i = 0; $i -lt $FileRuleEntryCount; $i++) {
                                    $FilePath = Get-BinaryString -BinaryReader $BinaryReader

                                    if ($FilePath) { $Script:FileRulesArray[$i].FilePath = $FilePath }
                                }
                            }

                            $V8RuleSupport = $BinaryReader.ReadUInt32()

                            # To-do: What follows will need to be updated when a new CI policy schema is released.
                            if ($V8RuleSupport -ne 8) {
                                Write-Warning 'A parsing error may have occurred. The CI policy should end with 0x00000008.'
                            }
                        }
                    }
                }
            }

            if ($FileRuleEntryCount) { $SIPolicy.FileRules = $Script:FileRulesArray }
            if ($SignerRuleEntryCount) { $SIPolicy.Signers = $Script:SignersArray }
        }

        Write-Verbose "Position 0x$($BinaryReader.BaseStream.Position.ToString('X8')): End of Policy"

    } catch {
        $BinaryReader.Close()
        $MemoryStream.Close()

        throw $_
        return
    }

    if ($SetPolicyTypeID) { $SIPolicy.PolicyTypeID = "{$($PolicyTypeID.ToString().ToUpper())}" }

    $BinaryReader.Close()
    $MemoryStream.Close()

    $XmlOutputSuccess = $False

    try {
        $XmlTextWriter = New-Object -TypeName Xml.XmlTextWriter -ArgumentList $FullXmlPath, $null
        $XmlTextWriter.Formatting = 'Indented'

        $XmlSerializer = New-Object -TypeName Xml.Serialization.XmlSerializer -ArgumentList ([CodeIntegrity.SIPolicy])

        $XmlSerializer.Serialize($XmlTextWriter, $SIPolicy)
        $XmlTextWriter.Close()
        $XmlOutputSuccess = $True
    } catch {
        throw $_
        return
    }

    if ($XmlOutputSuccess) {
        Get-Item -Path $FullXmlPath
    }
}

function Get-WDACCodeIntegrityBinaryPolicyCertificate {
<#
.SYNOPSIS

Extracts the signer information from a signed, binary code integrity policy.

Author: Matthew Graeber (@mattifestation)
Contributors: James Forshaw (@tiraniddo) - thanks for the major bug fixes!
License: BSD 3-Clause

.DESCRIPTION

Get-WDACCodeIntegrityBinaryPolicyCertificate obtains signer information from a signed, binary code integrity policy. This function was developed as the result of Get-AuthenticodeSignature not supporting signed, binary code integrity policies. Signed policies are represented as PKCS#7 ASN.1 SignedData (szOID_RSA_signedData - 1.2.840.113549.1.7.2).

.PARAMETER BinaryFilePath

Specifies the path of a signed, binary code interity policy. Deployed binary policy files are located in %SystemRoot%\System32\CodeIntegrity\SIPolicy.p7b.

.EXAMPLE

Get-WDACCodeIntegrityBinaryPolicyCertificate -BinaryFilePath C:\Windows\System32\CodeIntegrity\SIPolicy.p7b

.OUTPUTS

System.Security.Cryptography.X509Certificates.X509Certificate2

If the binary code integrity is signed, Get-WDACCodeIntegrityBinaryPolicyCertificate will output a list of X509Certificate2 objects.
#>

    [CmdletBinding()]
    [OutputType([System.Security.Cryptography.X509Certificates.X509Certificate2])]
    param (
        [Parameter(Position = 0, Mandatory)]
        [String]
        [ValidateScript({ [IO.File]::Exists((Resolve-Path $_).Path) })]
        $BinaryFilePath
    )

    # Obtain the full path to the policy file if a relative path was provided.
    $BinPath = Resolve-Path $BinaryFilePath
    try {
        $Cms = New-Object System.Security.Cryptography.Pkcs.SignedCms
        $Cms.Decode([IO.File]::ReadAllBytes($BinPath))
        $Cms.Certificates
    } catch {
        throw "$BinPath is not a signed binary code integrity policy."
    }
}

```

`Examples/ExamplePolicyBuilder.ps1`:

```ps1
# These are the policy rule options that will be applied to all built policies.
$CommonBasePolicyRuleOptions = @(
    'Enabled:Inherit Default Policy',
    'Enabled:Unsigned System Integrity Policy',
    'Enabled:Advanced Boot Options Menu',
    'Enabled:Update Policy No Reboot',
    'Enabled:Allow Supplemental Policies',
    'Disabled:Flight Signing',
    'Required:WHQL',
    'Enabled:Boot Audit On Failure'
)

# The following specified policies are expected to reside in the "BasePolicies" directory.
$BasePolicyConfigurations = @(
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'BaseDriverPolicy.xml' -PolicyName 'BaseDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'),
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'BaseUserPolicy.xml' -PolicyName 'BaseUserModeRuleset' -PolicyRuleOptions 'Disabled:Script Enforcement', 'Enabled:UMCI', 'Enabled:Audit Mode'),
    (New-WDACPolicyConfiguration -BasePolicy -FileName 'MicrosoftRecommendedBlockRules.xml' -PolicyName 'MicrosoftRecommendedBlockRuleset' -PolicyRuleOptions 'Disabled:Script Enforcement', 'Enabled:UMCI', 'Enabled:Audit Mode')
)

# The following specified policies are expected to reside in the "SupplementalPolicies" directory.
$SupplementalPolicyConfigurations = @(
    (New-WDACPolicyConfiguration -SupplementalPolicy -FileName 'MicrosoftSurfaceDriverPolicy.xml' -PolicyName '3rdPartyDriverRuleset' -PolicyRuleOptions 'Enabled:Audit Mode')
)

# The following configuration implies that the "AppSpecificPolicies" directory is populated with policy XML files that are to be merged.
$MergedPolicyConfiguration = New-WDACPolicyConfiguration -MergedPolicy -PolicyName 'Merged3rdPartySoftwareRuleset' -BasePolicyToSupplement 'BaseUserModeRuleset' -PolicyRuleOptions 'Enabled:Audit Mode'

$CodeIntegrityPoliciesArgs = @{
    CommonBasePolicyRuleOptions     = $CommonBasePolicyRuleOptions
    BasePolicyConfiguration         = $BasePolicyConfigurations
    SupplementalPolicyConfiguration = $SupplementalPolicyConfigurations
    MergedPolicyConfiguration       = $MergedPolicyConfiguration
}

# Upon running this, all generated policy XML and binary .cip files will be stored in the "BuildArtifacts" directory.
Invoke-WDACCodeIntegrityPolicyBuild @CodeIntegrityPoliciesArgs

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2021, Matt Graeber
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`Readme.md`:

```md
The `WDACTools` PowerShell module comprises everything that should be needed to build, configure, deploy, and audit [Windows Defender Application Control](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/windows-defender-application-control) (WDAC) policies.

Despite the relative complexity of this repository, the goal is to minimize policy deployment, maintenance, and auditing overhead. `WDACTools` requires Windows 10 1903+ Enterprise in order to build multiple policies. Once policies are built, Enterprise SKUs of Windows 10 1903+ are not required for deployment as long as the `Enabled:Inherit Default Policy` [policy rule option](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/select-types-of-rules-to-create) is specified.

# Motivations

The feature of WDAC that motivated me to develop this module was, beginning in Windows 10 1903, the ability to deploy [multiple base and supplemental policies](https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/deploy-multiple-windows-defender-application-control-policies). In particular, this offers the following unique advantages:

1. Mixed-mode policy enforcement: Upon properly tuning a policy, I can place one or more policies into enforcement mode. Then, as new tuning/maintenance requirements arise, I can have one or more policies in audit mode that will permit execution while tuning while keeping well-establised rules in enforcement mode. Additionally, there may be scenarios where it is unrealistic to block execution of certain binaries but you would like to have optics into when they're loaded with an audit mode policy side by side with enforcement policies.
2. Maintaining multiple policies that are scoped to a specific set of software and/or signers is far easier to maintain than a single, massive, difficult to audit policy.
3. When code integrity (CI) events are logged, the corresponding policy that generated the CI event is logged.

# Problems

1. The advantage that having many policies offers also creates its own maintenance headache where maintaining policy rule option consistency across many policies. I have been bitten by accidentally prematurely placing a policy intended for audit mode in enforcement mode, resulting in an unstable OS, a [problem which is painful and challenging to debug](https://posts.specterops.io/adventures-in-extremely-strict-device-guard-policy-configuration-part-1-device-drivers-fd1a281b35a8).
2. As rich as the logging is, it remains difficult to contextualize what all fields mean across many related events.
3. The existing WDAC cmdlets available in the [ConfigCI PowerShell module](https://docs.microsoft.com/en-us/powershell/module/configci/?view=win10-ps) remain difficult to work with and do not output relevant objects that would enable tests to be written. Additionally, there is no cmdlet available to recover an XML policy from a binary .p7b/.cip policy.

This module aims to address all of the above problems. While the auditing functionality of this module facilitates building code integrity policies, this module does not aim to automate application control policy configuration methodology. **Use of this module assumes you are already comfortable building WDAC code integrity policies.**

# Available Module Functions

### Usage

Method 1: Import the module manifest directly

```powershell
Import-Module WDACTools.psd1

# View available exported functions
Get-Command -Module WDACTools
```

Method 2: Place the `WDACTools` directory into a desired module path. Upon doing so, module autoloading will automatically load `WDACTools` when one of its functions is executed. The following command will show the available module paths:

```powershell
$Env:PSModulePath -split ';'
```

## New-WDACPolicyConfiguration

Supports: `Configuration`

`New-WDACPolicyConfiguration` is used as a helper function to generate code integrity policy configuration options and to supply them to the `Invoke-WDACCodeIntegrityPolicyBuild` function.

## Invoke-WDACCodeIntegrityPolicyBuild

Supports: `Build`, `Deployment`

`Invoke-WDACCodeIntegrityPolicyBuild` builds and, optionally, deploys and refreshes code integrity policies locally.

## Get-WDACCodeIntegrityEvent

Supports: `Auditing`

`Get-WDACCodeIntegrityEvent` retrieves and parses `Microsoft-Windows-CodeIntegrity/Operational` PE audit and enforcement events into a format that is more human-readable. This function is designed to facilitate regular code integrity policy baselining.

## Get-WDACApplockerScriptMsiEvent

Supports: `Auditing`

`Get-WDACApplockerScriptMsiEvent` retrieves and parses `Microsoft-Windows-AppLocker/MSI and Script` audit and enforcement events into a format that is more human-readable. This function is designed to facilitate regular code integrity policy baselining. Non-PE code that is subject to code integrity enforcement is logged to the `Microsoft-Windows-AppLocker/MSI and Script` log.

## ConvertTo-WDACCodeIntegrityPolicy

Supports: `Auditing`

`ConvertTo-WDACCodeIntegrityPolicy` converts a binary file that contains a Code Integrity policy into XML format. This function is used to audit deployed Code Integrity policies for which the original XML is not present. It can also be used to compare deployed rules against a reference XML file. This function is [`ConvertFrom-CIPolicy`](https://docs.microsoft.com/en-us/powershell/module/configci/convertfrom-cipolicy?view=win10-ps) in reverse.

## Get-WDACCodeIntegrityBinaryPolicyCertificate

Supports: `Auditing`

`Get-WDACCodeIntegrityBinaryPolicyCertificate` obtains signer information from a signed, binary code integrity policy. This function was developed as the result of Get-AuthenticodeSignature not supporting signed, binary code integrity policies. Signed policies are represented as PKCS#7 ASN.1 SignedData (szOID_RSA_signedData - 1.2.840.113549.1.7.2).

# Expected CI Policy Locations

`Invoke-WDACCodeIntegrityPolicyBuild` expects your policies to reside in specific directories included in this repository.

## `BasePolicies` Directory

These are base policies that should rarely change with the exception of relevant policy rule modification (e.g. switching from audit to enforcement mode) and the occasional updating of deny rules in MicrosoftRecommendedBlockRules.xml. Intuitively, deny rules would live as supplemental rules but [deny rules are not honored in supplemental rules](https://web.archive.org/web/20190904022759/https://www.microsoft.com/security/blog/2019/07/01/delivering-major-enhancements-in-windows-defender-application-control-with-the-windows-10-may-2019-update/).

## `SupplementalPolicies` Directory

This is where optional supplemental policies reside. These policies are intended to be updated more frequently whereas the base policies should rarely change.

## `AppSpecificPolicies` Directory

This is where all optional application/vendor-specific policies should reside. For example, if your goal is to allow Google products to execute, a dedicated Google policy should reside here. Having software/vendor-specific policies in here will drastically alleviate the maintenance burden across a complex software landscape. A question that would be expected to arise is, "why can't I just have a ton of app-specific policies as independent supplemental policies?" That's because [Microsoft only supports 32 active CI policies](https://twitter.com/j3ffr3y1974/status/1189235744008802309).

The policies in this directory will be merged together to form `MergedPolicy.xml` in the `BuildArtifacts` directory.

# Recommended CI Policy Format

As the `WDACTools` module was designed to facilitate consistency across all of your policies, it is recommended that your policies have the following characteristics:

1. Each policy have an empty policy rule option element. This would take on the following form:

```xml
<Rules />
```

`WDACTools` is designed to permit supplying policy rule options via code so that consistency is ensured and so that generated policies can be easily tested against expected policy rule options.

2. Policy settings Name and ID fields should be named `REPLACEME`. Doing so, allows you to specify policy names via code. `Invoke-WDACCodeIntegrityPolicyBuild` populates each policy ID with the build date (format: `MM_DD_YYYY`) as a way to simplify auditing.

```xml
<Settings>
  <Setting Provider="PolicyInfo" Key="Information" ValueName="Name">
    <Value>
      <String>REPLACEME</String>
    </Value>
  </Setting>
  <Setting Provider="PolicyInfo" Key="Information" ValueName="Id">
    <Value>
      <String>REPLACEME</String>
    </Value>
  </Setting>
</Settings>
```

# Generated Build Artifacts

When policies are built with `Invoke-WDACCodeIntegrityPolicyBuild`, all generated XML and binary policies are saved to the `BuildArtifacts` directory. `Invoke-WDACCodeIntegrityPolicyBuild` supports an optional `-ArtifactPath` parameter though that allows you to specify an alternate build artifact path.

```

`WDACAuditing.psm1`:

```psm1
# File paths are often in the format of device path (e.g. \Device\HarddiskVolumeN\).
# Get-Partition is used to map the volume number to a partition so that file paths can be normalized.
$Script:PartitionMapping = @{}

Get-Partition | Where-Object { $_.DriveLetter } | ForEach-Object { $PartitionMapping[$_.PartitionNumber.ToString()] = $_.DriveLetter }

# Try again. Get-Partition is flakey for some reason but it seems to work if tried a second time.
if ($PartitionMapping.Count -eq 0) {
    Get-Partition | Where-Object { $_.DriveLetter } | ForEach-Object { $PartitionMapping[$_.PartitionNumber.ToString()] = $_.DriveLetter }
}

# Resolve user names from SIDs
$Script:UserMapping = @{}

$Script:Providers = @{
    'Microsoft-Windows-AppLocker'     = (Get-WinEvent -ListProvider Microsoft-Windows-AppLocker)
    'Microsoft-Windows-CodeIntegrity' = (Get-WinEvent -ListProvider Microsoft-Windows-CodeIntegrity)
}

# Hash to cache event templates
$Script:EventTemplates = @{}

# This hashtable is used to resolve RequestedSigningLevel and ValidatedSigningLevel fields into human-readable properties
# For more context around signing levels, Alex Ionescu (@aionescu) has a great resource on them:
# http://www.alex-ionescu.com/?p=146
# They are also officially documented here: https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-tag-explanations#validatedsigninglevel
$Script:SigningLevelMapping = @{
    [Byte] 0x0 = 'Not Checked'
    [Byte] 0x1 = 'Unsigned'
    [Byte] 0x2 = 'WDAC Code Integrity Policy'
    [Byte] 0x3 = 'Developer-Signed'
    [Byte] 0x4 = 'Authenticode-Signed'
    [Byte] 0x5 = 'Microsoft Store-Signed PPL'
    [Byte] 0x6 = 'Microsoft Store-Signed'
    [Byte] 0x7 = 'Antimalware PPL'
    [Byte] 0x8 = 'Microsoft-Signed'
    [Byte] 0x9 = 'Custom4'
    [Byte] 0xA = 'Custom5'
    [Byte] 0xB = '.NET NGEN Signer'
    [Byte] 0xC = 'Windows'
    [Byte] 0xD = 'Windows PPL'
    [Byte] 0xE = 'Windows TCB'
    [Byte] 0xF = 'Custom6'
}

# These are documented here: https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-tag-explanations#signaturetype
$Script:SignatureTypeMapping = @{
    [Byte] 0 = 'Unsigned'
    [Byte] 1 = 'Embedded Authenticode Signature'
    [Byte] 2 = 'Cached CI Extended Attribute Signature'
    [Byte] 3 = 'Cached Catalog Signature'
    [Byte] 4 = 'Catalog Signature'
    [Byte] 5 = 'Cached CI Extended Attribute Hint'
    [Byte] 6 = 'Appx or MSIX Package Catalog Verified'
    [Byte] 7 = 'File was Verified'
}

# These are documented here: https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-application-control/event-tag-explanations#verificationerror
$Script:VerificationErrorMapping = @{
    [Byte] 0 = 'Successfully verified signature'
    [Byte] 1 = 'File has an invalid hash'
    [Byte] 2 = 'File contains shared writable sections'
    [Byte] 3 = 'File is not signed'
    [Byte] 4 = 'Revoked signature'
    [Byte] 5 = 'Expired signature'
    [Byte] 6 = 'File is signed using a weak hashing algorithm which does not meet the minimum policy'
    [Byte] 7 = 'Invalid root certificate'
    [Byte] 8 = 'Signature was unable to be validated; generic error'
    [Byte] 9 = 'Signing time not trusted'
    [Byte] 10 = 'The file must be signed using page hashes for this scenario'
    [Byte] 11 = 'Page hash mismatch'
    [Byte] 12 = 'Not valid for a PPL (Protected Process Light)'
    [Byte] 13 = 'Not valid for a PP (Protected Process)'
    [Byte] 14 = 'The signature is missing the required ARM EKU'
    [Byte] 15 = 'Failed WHQL check'
    [Byte] 16 = 'Default policy signing level not met'
    [Byte] 17 = "Custom policy signing level not met; returned when signature doesn't validate against an SBCP-defined set of certs"
    [Byte] 18 = 'Custom signing level not met; returned if signature fails to match CISigners in UMCI'
    [Byte] 19 = 'Binary is revoked by file hash'
    [Byte] 20 = "SHA1 cert hash's timestamp is missing or after valid cutoff as defined by Weak Crypto Policy"
    [Byte] 21 = 'Failed to pass WDAC policy'
    [Byte] 22 = 'Not IUM (Isolated User Mode) signed; indicates trying to load a non-trustlet binary into a trustlet'
    [Byte] 23 = 'Invalid image hash'
    [Byte] 24 = 'Flight root not allowed; indicates trying to run flight-signed code on production OS'
    [Byte] 25 = 'Anti-cheat policy violation'
    [Byte] 26 = 'Explicitly denied by WDAC policy'
    [Byte] 27 = 'The signing chain appears to be tampered/invalid'
    [Byte] 28 = 'Resource page hash mismatch'
}

function Get-UserMapping {
    [CmdletBinding()]
    param (
        # Security identifier of the account to look up
        [Parameter(Mandatory)]
        [System.Security.Principal.SecurityIdentifier]$SID
    )

    if (-not ($UserMapping[$SID.Value])) {
        $Account = Get-CimInstance Win32_Account -Property SID, Caption -Filter ('SID="{0}"' -f $SID.Value)
        # Revert to the SID if a user name cannot be resolved
        $UserMapping[$SID.Value] = if ($Account.Caption) {$Account.Caption} else {$SID.Value}
    }
    $UserMapping[$SID.Value]
}

function Get-WDACPolicyRefreshEventFilter {
    <#
    .SYNOPSIS
    Returns a filter to use to get only events that occured since last policy refresh

    .DESCRIPTION
    Get-WDACPolicyRefreshEventFilter retrieves the latestMicrosoft-Windows-CodeIntegrity/Operational policy refresh event (id 3099) and generates a string to insert in "FilterXPath" filters to only search for events generated after the latest policy refresh

    .EXAMPLE
    Get-WDACPolicyRefreshEventFilter

    Looks for the latest policy refresh event and returns a filter string such as " and TimeCreated[@SystemTime >= '2020-10-05T08:11:22.7969367+02:00']"
    #>

    [CmdletBinding()]
    param()

    # Only consider failed audit events that occured after the last CI policy update (event ID 3099)
    $LastPolicyUpdateEvent = Get-WinEvent -FilterHashtable @{ LogName = 'Microsoft-Windows-CodeIntegrity/Operational'; Id = 3099 } -MaxEvents 1 -ErrorAction Ignore

    # Sometimes this event will not be present - e.g. if the log rolled since the last update.
    if ($LastPolicyUpdateEvent) {
        $DateTimeAfter = [Xml.XmlConvert]::ToString($LastPolicyUpdateEvent.TimeCreated.ToUniversalTime(), 'O')

        " and TimeCreated[@SystemTime >= '$DateTimeAfter']"
    } else {
        Write-Verbose "No policy update event was present in the event log. Ignoring the -SinceLastPolicyRefresh switch."
        ''
    }
}

function Get-WinEventData {
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [Diagnostics.Eventing.Reader.EventLogRecord] $EventRecord
    )

    process {
        $Provider = $Providers[$EventRecord.ProviderName]

        if ($Provider.Events.Id -contains $EventRecord.Id) {
            $EventTemplateName = $EventRecord.ProviderName, $EventRecord.Id, $EventRecord.Version -join '_'

            if (-not $EventTemplates[$EventTemplateName]) {
                $EventTemplates[$EventTemplateName] = ($Provider.Events | Where-Object { $_.Id -eq $EventRecord.Id -and $_.Version -eq $EventRecord.Version }).Template
            }

            [Xml] $XmlTemplate = $EventTemplates[$EventTemplateName]

            $EventData = @{}

            for ($i = 0; $i -lt $EventRecord.Properties.Count; $i++) {
                $Name = $XmlTemplate.template.data.name[$i] -replace ' ', ''
                $Value = $EventRecord.Properties[$i].Value

                $EventData[$Name] = $Value
            }

            $EventData
        }
        else {
            $EventRecord.Properties.Value
        }
    }
}

function Get-WDACApplockerScriptMsiEvent {
<#
.SYNOPSIS

Returns script/MSI event log audit/enforcement events in a more human-readable fashion.

.DESCRIPTION

Get-WDACApplockerScriptMsiEvent retrieves and parses Microsoft-Windows-AppLocker/MSI and Script audit and enforcement events into a format that is more human-readable. This function is designed to facilitate regular code integrity policy baselining. Non-PE code that is subject to code integrity enforcement is logged to the Microsoft-Windows-AppLocker/MSI and Script log.

Author: Matthew Graeber
License: BSD 3-Clause

.PARAMETER SignerInformation

Specifies that correlated signer information should be collected. Note: When there are many CodeIntegrity events present in the event log, collection of signature events can be time consuming.

.PARAMETER ShowAllowedEvents

Specifies that Get-WDACApplockerScriptMsiEvent should also return scripts that were allowed to execute (via 8037 events)

.PARAMETER SinceLastPolicyRefresh

Specifies that events should only be returned since the last time the code integrity policy was refreshed. This option is useful for baselining purposes.

.PARAMETER MaxEvents

Specifies the maximum number of events that Get-WDACCodeIntegrityEvent returns. The default is to return all the events.

.EXAMPLE

Get-WDACApplockerScriptMsiEvent

Return all user-mode code integrity events (audit/enforcement) since the last code intgrity policy refresh.

.EXAMPLE

Get-WDACApplockerScriptMsiEvent -MaxEvents 5

Return the most recent 5 script/MSI code integrity events.

.EXAMPLE

Get-WDACApplockerScriptMsiEvent -SinceLastPolicyRefresh

Return all script/MSI code integrity events since the last code intgrity policy refresh.

.EXAMPLE

Get-WDACApplockerScriptMsiEvent -SignerInformation
#>

    [CmdletBinding()]
    param (
        [Switch]
        $SignerInformation,

        [Switch]
        $ShowAllowedEvents,

        [Switch]
        $SinceLastPolicyRefresh,

        [Int64]
        $MaxEvents
    )

    $MaxEventArg = @{}

    # Pass -MaxEvents through to Get-WinEvent
    if ($MaxEvents) { $MaxEventArg = @{ MaxEvents = $MaxEvents } }

    $PolicyRefreshFilter = ''

    if ($SinceLastPolicyRefresh) {
        $PolicyRefreshFilter = Get-WDACPolicyRefreshEventFilter -Verbose:$False
    }

    if ($ShowAllowedEvents) {
        $Filter = "*[System[(EventID = 8028 or EventID = 8029 or EventID = 8037)$($PolicyRefreshFilter)]]"
    } else {
        $Filter = "*[System[(EventID = 8028 or EventID = 8029)$($PolicyRefreshFilter)]]"
    }

    Write-Verbose "XPath Filter: $Filter"

    $EventIdMapping = @{
        8028 = 'Audit'
        8029 = 'Enforce'
        8037 = 'Allowed'
    }

    Get-WinEvent -LogName 'Microsoft-Windows-AppLocker/MSI and Script' -FilterXPath $Filter @MaxEventArg -ErrorAction Ignore | ForEach-Object {
        $ResolvedSigners = $null
        $SigningStatus = $null

        # 8037 (Allow) events do not populate signer information so don't attempt to retrieve
        if ($SignerInformation -and ($_.Id -ne 8037)) {
            $SigningStatus = 'Unsigned'

            # Retrieve correlated signer info (event ID 8038)
            # Note: there may be more than one correlated signer event in the case of the file having multiple signers.
            $Signer = Get-WinEvent -LogName 'Microsoft-Windows-AppLocker/MSI and Script' -FilterXPath "*[System[EventID = 8038 and Correlation[@ActivityID = '$($_.ActivityId.Guid)']]]" -MaxEvents 1 -ErrorAction Ignore

            # Unsigned scripts will often generate bogus 8038 events. Don't process them
            if ($Signer.Properties.Count -gt 0) {

                if ($Signer.Properties[0].Value -gt 1) {
                    $Signer = Get-WinEvent -LogName 'Microsoft-Windows-AppLocker/MSI and Script' -FilterXPath "*[System[EventID = 8038 and Correlation[@ActivityID = '$($_.ActivityId.Guid)']]]" -MaxEvents ($Signer.Properties[0].Value) -ErrorAction Ignore
                }

                $ResolvedSigners = $Signer | ForEach-Object {
                    $SignerData = Get-WinEventData -EventRecord $_

                    if (-not (($SignerData.PublisherNameLength -eq 0) -and ($SignerData.IssuerNameLength -eq 0) -and ($SignerData.PublisherTBSHashSize -eq 0) -and ($SignerData.IssuerTBSHashSize -eq 0))) {
                        $SigningStatus = 'Signed'

                        $PublisherTBSHash = $null
                        if ($SignerData.PublisherTBSHash) { $PublisherTBSHash = [BitConverter]::ToString($SignerData.PublisherTBSHash).Replace('-','') }

                        $IssuerTBSHash = $null
                        if ($SignerData.IssuerTBSHash) { $IssuerTBSHash = [BitConverter]::ToString($SignerData.IssuerTBSHash).Replace('-','') }

                        New-Object -TypeName PSObject -Property ([Ordered] @{
                            SignatureIndex = $SignerData.Signature
                            PublisherName = $SignerData.PublisherName
                            IssuerName = $SignerData.IssuerName
                            PublisherTBSHash = $PublisherTBSHash
                            IssuerTBSHash = $IssuerTBSHash
                        })
                    }
                }
            }
        }

        $EventData = Get-WinEventData -EventRecord $_

        $UserName = Get-UserMapping $_.UserId.Value

        $SHA1FileHash = $null
        if ($EventData.Sha1Hash) { $SHA1FileHash = [BitConverter]::ToString($EventData.Sha1Hash).Replace('-','') }

        $SHA256FileHash = $null
        if ($EventData.Sha256CatalogHash) { $SHA256FileHash = [BitConverter]::ToString($EventData.Sha256CatalogHash).Replace('-','') }

        $SHA256AuthenticodeHash = $null
        if ($EventData.Sha256Hash) { $SHA256AuthenticodeHash = [BitConverter]::ToString($EventData.Sha256Hash).Replace('-','') }

        $ObjectArgs = [Ordered] @{
            TimeCreated = $_.TimeCreated
            ProcessID = $_.ProcessId
            User = $UserName
            EventType = $EventIdMapping[$_.Id]
            FilePath = $EventData.FilePath
            SHA1FileHash = $SHA1FileHash
            SHA256FileHash = $SHA256FileHash
            SHA256AuthenticodeHash = $SHA256AuthenticodeHash
            UserWriteable = $EventData.UserWriteable
            Signed = $SigningStatus
            SignerInfo = ($ResolvedSigners | Sort-Object -Property SignatureIndex)
        }

        New-Object -TypeName PSObject -Property $ObjectArgs
    }
}

function Get-WDACCodeIntegrityEvent {
<#
.SYNOPSIS

Returns code integrity event log audit/enforcement events in a more human-readable fashion.

.DESCRIPTION

Get-WDACCodeIntegrityEvent retrieves and parses Microsoft-Windows-CodeIntegrity/Operational PE audit and enforcement events into a format that is more human-readable. This function is designed to facilitate regular code integrity policy baselining.

Author: Matthew Graeber
License: BSD 3-Clause

.PARAMETER User

Specifies that only user-mode events should be returned. If neither -User nor -Kernel is specified, user and kernel events are returned.

.PARAMETER Kernel

Specifies that only kernel-mode events should be returned. If neither -User nor -Kernel is specified, user and kernel events are returned.

.PARAMETER Audit

Specifies that only audit events (event ID 3076) should be returned. If neither -Audit nor -Enforce is specified, audit and enforcement events are returned.

.PARAMETER Enforce

Specifies that only enforcement events (event ID 3077) should be returned. If neither -Audit nor -Enforce is specified, audit and enforcement events are returned.

.PARAMETER SinceLastPolicyRefresh

Specifies that events should only be returned since the last time the code integrity policy was refreshed. This option is useful for baselining purposes.

.PARAMETER SignerInformation

Specifies that correlated signer information should be collected. Note: When there are many CodeIntegrity events present in the event log, collection of signature events can be time consuming.

.PARAMETER CheckWhqlStatus

Specifies that correlated WHQL events should be collected. Supplying this switch will populate the returned FailedWHQL property.

.PARAMETER IgnoreNativeImagesDLLs

Specifies that events where ResolvedFilePath is like "$env:SystemRoot\assembly\NativeImages*.dll" should be skipped. Useful to suppress events caused by auto-generated "NativeImages DLLs"

.PARAMETER IgnoreDenyEvents

Specifies that only events will be returned that are not explicitly blocked by policy. This switch only works when -SignerInformation is also specified. This switch is available to help reduce noise and prevent inadvertantly creating allow rules for explicitly denied executables.

.PARAMETER MaxEvents

Specifies the maximum number of events that Get-WDACCodeIntegrityEvent returns. The default is to return all the events.

.EXAMPLE

Get-WDACCodeIntegrityEvent -SinceLastPolicyRefresh

Return all code integrity events (user/kernel/audit/enforcement) since the last code intgrity policy refresh.

.EXAMPLE

Get-WDACCodeIntegrityEvent -User -SinceLastPolicyRefresh

Return all user-mode code integrity events (audit/enforcement) since the last code intgrity policy refresh.

.EXAMPLE

Get-WDACCodeIntegrityEvent -Kernel -MaxEvents 5

Return the most recent 5 kernel mode code integrity events.

.EXAMPLE

Get-WDACCodeIntegrityEvent -Kernel -Enforce

Return all kernel mode enforcement events.
#>

    [CmdletBinding(DefaultParameterSetName = 'NoSignerCheck')]
    param (
        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $User,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $Kernel,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $Audit,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $Enforce,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $SinceLastPolicyRefresh,

        [Parameter(Mandatory, ParameterSetName = 'SignerCheck')]
        [Switch]
        $SignerInformation,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $CheckWhqlStatus,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $IgnoreNativeImagesDLLs,

        [Parameter(ParameterSetName = 'SignerCheck')]
        [Switch]
        $IgnoreDenyEvents,

        [Parameter(ParameterSetName = 'NoSignerCheck')]
        [Parameter(ParameterSetName = 'SignerCheck')]
        [Int64]
        $MaxEvents
    )

    # If neither -User nor -Kernel are supplied, do not filter based on signing scenario
    # If -User and -Kernel are supplied, do not filter based on signing scenario
    # Only filter in a mutually exclusive scenario.
    $ScenarioFilter = ''

    if ($User -and !$Kernel) {
        # 1 == A user-mode rule triggered
        $ScenarioFilter = " and EventData[Data[@Name='SI Signing Scenario'] = 1]"
    } elseif ($Kernel -and !$User) {
        # 2 == A kernel-mode rule triggered
        $ScenarioFilter = " and EventData[Data[@Name='SI Signing Scenario'] = 0]"
    }

    # If neither -Audit nor -Enforce are supplied, do not filter based on event ID
    # If -Audit and -Enforce are supplied, do not filter based on event ID
    # Only filter in a mutually exclusive scenario.
    $ModeFilter = '(EventID = 3076 or EventID = 3077)'

    if ($Audit -and !$Enforce) {
        # Event ID 3076 == an audit event
        $ModeFilter = "EventID = 3076"
    } elseif ($Enforce -and !$Audit) {
        # Event ID 3077 == an enforcement event
        $ModeFilter = "EventID = 3077"
    }

    $PolicyRefreshFilter = ''

    if ($SinceLastPolicyRefresh) {
        $PolicyRefreshFilter = Get-WDACPolicyRefreshEventFilter -Verbose:$False
    }

    $Filter = "*[System[$($ModeFilter)$($PolicyRefreshFilter)]$ScenarioFilter]"

    Write-Verbose "XPath Filter: $Filter"

    $EventIdMapping = @{
        3076 = 'Audit'
        3077 = 'Enforce'
    }

    $SigningScenarioMapping = @{
        [UInt32] 0 = 'Driver'
        [UInt32] 1 = 'UserMode'
    }

    $MaxEventArg = @{}

    # Pass -MaxEvents through to Get-WinEvent
    if ($MaxEvents) { $MaxEventArg = @{ MaxEvents = $MaxEvents } }

    Get-WinEvent -LogName 'Microsoft-Windows-CodeIntegrity/Operational' -FilterXPath $Filter @MaxEventArg -ErrorAction Ignore | ForEach-Object {
        $EventData = Get-WinEventData -EventRecord $_

        $WHQLFailed = $null

        if ($CheckWhqlStatus) {
            $WHQLFailed = $False

            # A correlated 3082 event indicates that WHQL verification failed
            $WHQLEvent = Get-WinEvent -LogName 'Microsoft-Windows-CodeIntegrity/Operational' -FilterXPath "*[System[EventID = 3082 and Correlation[@ActivityID = '$($_.ActivityId.Guid)']]]" -MaxEvents 1 -ErrorAction Ignore

            if ($WHQLEvent) { $WHQLFailed = $True }
        }

        $ResolvedSigners = $null
        $ExplicitlyDeniedSigner = $False

        if ($SignerInformation) {
            # Retrieve correlated signer info (event ID 3089)
            # Note: there may be more than one correlated signer event in the case of the file having multiple signers.
            $Signer = Get-WinEvent -LogName 'Microsoft-Windows-CodeIntegrity/Operational' -FilterXPath "*[System[EventID = 3089 and Correlation[@ActivityID = '$($_.ActivityId.Guid)']]]" -MaxEvents 1 -ErrorAction Ignore

            if ($Signer -and $Signer.Properties -and ($Signer.Properties[0].Value -gt 1)) {
                $Signer = Get-WinEvent -LogName 'Microsoft-Windows-CodeIntegrity/Operational' -FilterXPath "*[System[EventID = 3089 and Correlation[@ActivityID = '$($_.ActivityId.Guid)']]]" -MaxEvents ($Signer.Properties[0].Value) -ErrorAction Ignore
            }

            $ResolvedSigners = $Signer | ForEach-Object {
                $SignerData = Get-WinEventData -EventRecord $_

                $SignatureType = $SignatureTypeMapping[$SignerData.SignatureType]

                $VerificationError = $VerificationErrorMapping[$SignerData.VerificationError]

                if ($IgnoreDenyEvents -and ($VerificationError -eq 'Explicitly denied by WDAC policy')) { $ExplicitlyDeniedSigner = $True }

                $Hash = $null
                if ($SignerData.Hash) { $Hash = [BitConverter]::ToString($SignerData.Hash).Replace('-','') }

                $PublisherTBSHash = $null
                if ($SignerData.PublisherTBSHash) { $PublisherTBSHash = [BitConverter]::ToString($SignerData.PublisherTBSHash).Replace('-','') }

                $IssuerTBSHash = $null
                if ($SignerData.IssuerTBSHash) { $IssuerTBSHash = [BitConverter]::ToString($SignerData.IssuerTBSHash).Replace('-','') }

                New-Object -TypeName PSObject -Property ([Ordered] @{
                    SignatureIndex = $SignerData.Signature
                    Hash = $Hash
                    PageHash = $SignerData.PageHash
                    SignatureType = $SignatureType
                    ValidatedSigningLevel = $SigningLevelMapping[$SignerData.ValidatedSigningLevel]
                    VerificationError = $VerificationError
                    Flags = $SignerData.Flags
                    PolicyBits = $SignerData.PolicyBits
                    NotValidBefore = $SignerData.NotValidBefore
                    NotValidAfter = $SignerData.NotValidAfter
                    PublisherName = $SignerData.PublisherName
                    IssuerName = $SignerData.IssuerName
                    PublisherTBSHash = $PublisherTBSHash
                    IssuerTBSHash = $IssuerTBSHash
                })
            }
        }

        if (-not $ExplicitlyDeniedSigner) {
            $UnresolvedFilePath = $EventData.FileName

            $ResolvedFilePath = $null
            # Make a best effort to resolve the device path to a normal path.
            if ($UnresolvedFilePath -match '(?<Prefix>^\\Device\\HarddiskVolume(?<VolumeNumber>\d)\\)') {
                $ResolvedFilePath = $UnresolvedFilePath.Replace($Matches['Prefix'], "$($PartitionMapping[$Matches['VolumeNumber']]):\")
            } elseif ($UnresolvedFilePath.ToLower().StartsWith('system32')) {
                $ResolvedFilePath = "$($Env:windir)\System32$($UnresolvedFilePath.Substring(8))"
            }

            # If all else fails regarding path resolution, show a warning.
            if ($ResolvedFilePath -and !(Test-Path -Path $ResolvedFilePath)) {
                Write-Warning "The following file path was either not resolved properly or was not present on disk: $ResolvedFilePath"
            }

            $ResolvedProcessName = $null
            $ProcessName = $EventData.ProcessName
            # Make a best effort to resolve the process path to a normal path.
            if ($ProcessName -match '(?<Prefix>^\\Device\\HarddiskVolume(?<VolumeNumber>\d)\\)') {
                $ResolvedProcessName = $ProcessName.Replace($Matches['Prefix'], "$($PartitionMapping[$Matches['VolumeNumber']]):\")
            } elseif ($ProcessName.ToLower().StartsWith('system32')) {
                $ResolvedProcessName = "$($Env:windir)\System32$($ProcessName.Substring(8))"
            }

            # If all else fails regarding path resolution, show a warning.
            if ($ResolvedProcessName -and !(Test-Path -Path $ResolvedProcessName)) {
                Write-Warning "The following process file path was either not resolved properly or was not present on disk: $ResolvedProcessName"
            }

            $UserName = Get-UserMapping $_.UserId.Value

            $SHA1FileHash = $null
            if ($EventData.SHA1FlatHash) { $SHA1FileHash = [BitConverter]::ToString($EventData.SHA1FlatHash[0..19]).Replace('-','') }

            $SHA1AuthenticodeHash = $null
            if ($EventData.SHA1Hash) { $SHA1AuthenticodeHash = [BitConverter]::ToString($EventData.SHA1Hash).Replace('-','') }
            
            $SHA256FileHash = $null
            if ($EventData.SHA256FlatHash) { $SHA256FileHash = [BitConverter]::ToString($EventData.SHA256FlatHash[0..31]).Replace('-','') }

            $SHA256AuthenticodeHash = $null
            if ($EventData.SHA256Hash) { $SHA256AuthenticodeHash = [BitConverter]::ToString($EventData.SHA256Hash).Replace('-','') }

            $PolicyGuid = $null
            if ($EventData.PolicyGUID) { $PolicyGuid = $EventData.PolicyGUID.Guid.ToUpper() }

            $PolicyHash = $null
            if ($EventData.PolicyHash) { $PolicyHash = [BitConverter]::ToString($EventData.PolicyHash).Replace('-','') }

            $CIEventProperties = [Ordered] @{
                TimeCreated = $_.TimeCreated
                ProcessID = $_.ProcessId
                User = $UserName
                EventType = $EventIdMapping[$_.Id]
                SigningScenario = $SigningScenarioMapping[$EventData.SISigningScenario]
                UnresolvedFilePath = $UnresolvedFilePath
                FilePath = $ResolvedFilePath
                SHA1FileHash = $SHA1FileHash
                SHA1AuthenticodeHash = $SHA1AuthenticodeHash
                SHA256FileHash = $SHA256FileHash
                SHA256AuthenticodeHash = $SHA256AuthenticodeHash
                UnresolvedProcessName = $EventData.ProcessName
                ProcessName = $ResolvedProcessName
                RequestedSigningLevel = $SigningLevelMapping[$EventData.RequestedSigningLevel]
                ValidatedSigningLevel = $SigningLevelMapping[$EventData.ValidatedSigningLevel]
                PolicyName = $EventData.PolicyName
                PolicyID = $EventData.PolicyId
                PolicyGUID = $PolicyGuid
                PolicyHash = $PolicyHash
                OriginalFileName = $EventData.OriginalFileName
                InternalName = $EventData.InternalName
                FileDescription = $EventData.FileDescription
                ProductName = $EventData.ProductName
                FileVersion = $EventData.FileVersion
                PackageFamilyName = $EventData.PackageFamilyName
                UserWriteable = $EventData.UserWriteable
                FailedWHQL = $WHQLFailed
                SignerInfo = ($ResolvedSigners | Sort-Object -Property SignatureIndex)
            }

            if (-not $IgnoreNativeImagesDLLs -or ($IgnoreNativeImagesDLLs -and $CIEventProperties.ResolvedFilePath -notlike "$env:SystemRoot\assembly\NativeImages*.dll")) {
                New-Object -TypeName PSObject -Property $CIEventProperties
            }
        }
    }
}

function Copy-WDACEventFile {
<#
.SYNOPSIS

Copies files returned by the Get-WDACApplockerScriptMsiEvent or Get-WDACCodeIntegrityEvent functions to a destination directory.

.DESCRIPTION

Copy-WDACEventFile copies files returned by the Get-WDACApplockerScriptMsiEvent or Get-WDACCodeIntegrityEvent functions to a destination directory. When developing targeted code integrity policies, it is ideal to consolidate all the relevant files in a dedicated directory that are not intermingled with files not to be added per policy. Copy-WDACEventFile copies files in a targeted fashion such that Get-SystemDriver will scan a specific path containing only the relevant file.

Author: Matthew Graeber
License: BSD 3-Clause

.PARAMETER FilePath

Specifies the filepath of the executable or script to be copied.

.PARAMETER Destination

Specifies the destination directory where all files will be copied.

.EXAMPLE

Get-WDACCodeIntegrityEvent | Copy-WDACEventFile -Destination .\FilesToAllow

.EXAMPLE

Get-WDACApplockerScriptMsiEvent | Copy-WDACEventFile -Destination .\FilesToAllow

.INPUTS

PSObject

Copy-WDACEventFile accepts the output of Get-WDACApplockerScriptMsiEvent and Get-WDACCodeIntegrityEvent.

.OUTPUTS

System.IO.FileInfo

Copy-WDACEventFile outputs a FileInfo object representing the new file that was copied to its destination.
#>

    [CmdletBinding()]
    param (
        [Parameter(Mandatory, Position = 1)]
        [String]
        [ValidateScript({ Test-Path -Path $_ -PathType Container })]
        $Destination,

        [Parameter(Mandatory, ValueFromPipelineByPropertyName, Position = 0)]
        [String[]]
        [ValidateNotNullOrEmpty()]
        $FilePath
    )

    BEGIN {
        $ResolvedDestination = Resolve-Path $Destination
    }

    PROCESS {
        foreach ($Path in $FilePath) {
            $FileName = Split-Path -Path $Path -Leaf
            $ChildDestinationDirectory = (Split-Path -Path $Path -Parent).Substring(2)

            $DestinationDirectory = Join-Path -Path $ResolvedDestination -ChildPath $ChildDestinationDirectory
            $DestinationFilePath = Join-Path -Path $DestinationDirectory -ChildPath $FileName

            # If the destination directory doesn't exist, create it
            if (-not (Test-Path -Path $DestinationDirectory -PathType Container)) {
                $null = mkdir -Path $DestinationDirectory -Force
            }

            Copy-Item -Path $Path -Destination $DestinationFilePath -PassThru
        }
    }
}
```

`WDACTools.psd1`:

```psd1
@{

# Script module or binary module file associated with this manifest.
# RootModule = ''

# Version number of this module.
ModuleVersion = '2.0.1.0'

# Supported PSEditions
# CompatiblePSEditions = @()

# ID used to uniquely identify this module
GUID = '2aa9f041-3cbf-4904-9c1f-c19fe6675789'

# Author of this module
Author = 'Matthew Graeber'

# Copyright statement for this module
Copyright = 'BSD 3-Clause'

# Description of the functionality provided by this module
Description = 'A module to facilitate building, deploying, and auditing WDAC policies.'

# Minimum version of the Windows PowerShell engine required by this module
PowerShellVersion = '5.0'

# Name of the Windows PowerShell host required by this module
# PowerShellHostName = ''

# Minimum version of the Windows PowerShell host required by this module
# PowerShellHostVersion = ''

# Minimum version of Microsoft .NET Framework required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# DotNetFrameworkVersion = ''

# Minimum version of the common language runtime (CLR) required by this module. This prerequisite is valid for the PowerShell Desktop edition only.
# CLRVersion = ''

# Processor architecture (None, X86, Amd64) required by this module
# ProcessorArchitecture = ''

# Modules that must be imported into the global environment prior to importing this module
# RequiredModules = @()

# Assemblies that must be loaded prior to importing this module
RequiredAssemblies = 'System.Security'

# Script files (.ps1) that are run in the caller's environment prior to importing this module.
# ScriptsToProcess = @()

# Type files (.ps1xml) to be loaded when importing this module
# TypesToProcess = @()

# Format files (.ps1xml) to be loaded when importing this module
# FormatsToProcess = @()

# Modules to import as nested modules of the module specified in RootModule/ModuleToProcess
NestedModules = @('BuildAndDeployPolicies.psm1',
               'CIPolicyParser.psm1',
               'WDACAuditing.psm1')

# Functions to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no functions to export.
FunctionsToExport = 'New-WDACPolicyConfiguration',
                    'Invoke-WDACCodeIntegrityPolicyBuild',
                    'Get-WDACCodeIntegrityEvent',
                    'Get-WDACApplockerScriptMsiEvent',
                    'ConvertTo-WDACCodeIntegrityPolicy',
                    'Get-WDACCodeIntegrityBinaryPolicyCertificate',
                    'Update-WDACBinaryCodeIntegrityPolicy',
                    'Copy-WDACEventFile',
                    'Disable-WDACDeployedPolicy'

# Cmdlets to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no cmdlets to export.
# CmdletsToExport = '*'

# Variables to export from this module
# VariablesToExport = '*'

# Aliases to export from this module, for best performance, do not use wildcards and do not delete the entry, use an empty array if there are no aliases to export.
# AliasesToExport = '*'

# DSC resources to export from this module
# DscResourcesToExport = @()

# List of all modules packaged with this module
# ModuleList = @()

# List of all files packaged with this module
# FileList = @()

# Private data to pass to the module specified in RootModule/ModuleToProcess. This may also contain a PSData hashtable with additional module metadata used by PowerShell.
PrivateData = @{

    PSData = @{

        # Tags applied to this module. These help with module discovery in online galleries.
        # Tags = @()

        # A URL to the license for this module.
        # LicenseUri = ''

        # A URL to the main website for this project.
        # ProjectUri = ''

        # A URL to an icon representing this module.
        # IconUri = ''

        # ReleaseNotes of this module
        # ReleaseNotes = ''

    } # End of PSData hashtable

} # End of PrivateData hashtable

# HelpInfo URI of this module
# HelpInfoURI = ''

# Default prefix for commands exported from this module. Override the default prefix using Import-Module -Prefix.
# DefaultCommandPrefix = ''

}


```