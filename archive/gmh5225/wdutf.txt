Project Path: arc_gmh5225_wdutf_mn15klnj

Source Tree:

```txt
arc_gmh5225_wdutf_mn15klnj
├── CONTRIBUTING.md
├── LICENSE
├── MAINTAINERS.md
├── README.md
├── WDUTF.sln
├── config
│   ├── Application.props
│   ├── Driver.Application.props
│   ├── Driver.UnitTest.props
│   └── Driver.props
├── detours
├── doc
│   └── design.md
├── examples
│   ├── BasicDriver
│   │   ├── Basic.cpp
│   │   ├── BasicDriver.rc
│   │   ├── BasicDriver.vcxproj
│   │   ├── BasicDriver.vcxproj.filters
│   │   ├── DcsBasic.cdf
│   │   ├── DcsBasic.inf
│   │   ├── Trace.h
│   │   └── resource.h
│   └── BasicDriverUnitTest
│       ├── BasicDriverUnitTest.vcxproj
│       ├── BasicDriverUnitTest.vcxproj.filters
│       ├── DcsBasic.def
│       ├── Test.cpp
│       ├── Test.h
│       ├── stdafx.cpp
│       ├── stdafx.h
│       └── targetver.h
├── inc
│   ├── TraceDbg.h
│   ├── TraceDefs.h
│   ├── TraceWpp.h
│   ├── UnitTest.h
│   ├── ddk
│   │   ├── ddkhdr.h
│   │   ├── ntddk.h
│   │   ├── ntddk_defs.h
│   │   ├── ntdef.h
│   │   ├── ntdef_defs.h
│   │   ├── ntifs.h
│   │   ├── ntstatus.h
│   │   ├── ntstrsafe.h
│   │   ├── wdm.h
│   │   ├── wdmhdr.h
│   │   ├── winnt.h
│   │   └── winnt_defs.h
│   ├── ddk.h
│   └── ddklib.h
├── src
│   ├── Ddk.rc
│   ├── Ddk.vcxproj
│   ├── Ddk.vcxproj.filters
│   ├── alloc.cpp
│   ├── bcrypt.cpp
│   ├── bitmap.cpp
│   ├── cpu.cpp
│   ├── crt.cpp
│   ├── data.cpp
│   ├── data.h
│   ├── dbg.cpp
│   ├── ddk.cpp
│   ├── ddk.def
│   ├── defs.h
│   ├── detours.cpp
│   ├── detours_x64.asm
│   ├── device.cpp
│   ├── dpc.cpp
│   ├── driver.cpp
│   ├── event.cpp
│   ├── exception.cpp
│   ├── executive.cpp
│   ├── file.cpp
│   ├── init.cpp
│   ├── inline.c
│   ├── interlocked.cpp
│   ├── irp.cpp
│   ├── irql.cpp
│   ├── list.cpp
│   ├── load.cpp
│   ├── local.cpp
│   ├── log.cpp
│   ├── mdl.cpp
│   ├── memory.cpp
│   ├── mutex.cpp
│   ├── name.cpp
│   ├── object.cpp
│   ├── object.h
│   ├── pnp.cpp
│   ├── registry.cpp
│   ├── resource.h
│   ├── rtl.cpp
│   ├── semaphore.cpp
│   ├── shared.cpp
│   ├── slist.cpp
│   ├── spinlock.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   ├── stdddk.cpp
│   ├── stdddk.h
│   ├── string.cpp
│   ├── symlink.cpp
│   ├── thread.cpp
│   ├── time.cpp
│   ├── timer.cpp
│   ├── unicode.cpp
│   ├── unittest.cpp
│   ├── wait.cpp
│   ├── wmi.cpp
│   └── workitem.cpp
├── test
│   ├── AfxHeaderTest.cpp
│   ├── BitMapTest.cpp
│   ├── CpuTest.cpp
│   ├── DdkUnitTest.vcxproj
│   ├── DdkUnitTest.vcxproj.filters
│   ├── DetoursTest.cpp
│   ├── DeviceTest.cpp
│   ├── DpcTest.cpp
│   ├── DriverTest.cpp
│   ├── EventTest.cpp
│   ├── FileTest.cpp
│   ├── HeaderTest.cpp
│   ├── InlineTest.cpp
│   ├── IrpTest.cpp
│   ├── IrqlTest.cpp
│   ├── MdlTest.cpp
│   ├── MemoryTest.cpp
│   ├── MutexTest.cpp
│   ├── ObjectTest.cpp
│   ├── RegistryTest.cpp
│   ├── RtlTest.cpp
│   ├── SListTest.cpp
│   ├── SemaphoreTest.cpp
│   ├── SpinLockTest.cpp
│   ├── StringTest.cpp
│   ├── SymLinkTest.cpp
│   ├── Test.cpp
│   ├── Test.h
│   ├── ThreadTest.cpp
│   ├── TimeTest.cpp
│   ├── TimerTest.cpp
│   ├── UnicodeTest.cpp
│   ├── WaitTest.cpp
│   ├── WinHeaderTest.cpp
│   ├── WorkItemTest.cpp
│   ├── stdafx.cpp
│   ├── stdafx.h
│   └── targetver.h
└── tools
    └── bin
        └── README.md

```

`CONTRIBUTING.md`:

```md
# Contributing

Contributions are welcome. In these initial stages of the project, please email the [maintainers](https://github.com/wpdk/wdutf/blob/main/MAINTAINERS.md) directly.

```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`MAINTAINERS.md`:

```md
# Windows Driver Unit Test Framework Maintainers

The intention of this file is to provide a set of names that can be relied upon
for help in patch reviews and questions.

Descriptions of section entries:

	M: Maintainer's Full Name <address@domain>
	T: Git tree location.

## Main Branch

    M: Nick Connolly <Nick.Connolly@datacore.com>
    T: git://github.com/wpdk/wdutf

    M: Robert Bassett <Robert.Bassett@datacore.com>
    T: git://github.com/wpdk/wdutf

```

`README.md`:

```md
# Windows Driver Unit Test Framework

The Windows Driver Unit Test Framework (WDUTF) enables the unit testing of Windows kernel drivers using the [Microsoft Unit Testing Framework for C++](https://learn.microsoft.com/en-us/visualstudio/test/how-to-use-microsoft-test-framework-for-cpp?view=vs-2022), which runs in user space.

The project grew out of work being done by [DataCore](https://datacore.com/) to develop and test a world class, high-performance, storage stack running on Windows.

Runing unit tests against code written for the Windows Kernel environment is hard. There have been a few projects that try to embed a unit test framework in the kernel, but they suffer from the compexity of having to load a driver, collect the output and handle crashes. We wanted to do something better; to create a user space environment where kernel code can run unmodified and tests can be examined using the Visual Studio debugger.

The initial version of the project consisted of a user space library implementing portions of the kernel infrastructure. This has now been extended to allow binary code built for the kernel to be loaded into the unit test environment and executed. Much of the kernel functionality is stubbed out, but the framework is sufficient to allow credible tests to be performed.

DataCore's experience has been that bringing the simplicity and flexibility of user space development to kernel drivers can significantly reduce development time and improve project outcomes. The project is being contributed to the [Windows Platform Development Kit](https://wpdk.github.io/) to enable others to benefit from it.

# In this ReadMe

* [Documentation](#documentation)
* [Source Code](#source)
* [Getting Started](#start)
* [Runtime Prerequisites](#prereq)
* [Current Status](#status)
* [Limitations](#limitations)
* [Known Issues](#issues)
* [Unit Tests](#unit)
* [Examples](#examples)
* [Contributing](#contrib)
* [Dependencies](#depend)
* [Acknowledgements](#acknowledge)
* [Core Maintainers](#core)

<a id="documentation"></a>
## Documentation

Further information about the [design and implementation](https://github.com/wpdk/wdutf/blob/main/doc/design.md)
can be found in the [project documentation](https://github.com/wpdk/wdutf/blob/main/doc). This is still a work in progress.

Sample code demonstrating the use of the unit test framework will be added in the near future.

<a id="source"></a>
## Source Code

The source code can be obtained using:
~~~{.sh}
git clone --recurse-submodules https://github.com/wpdk/wdutf

~~~

<a id="start"></a>
## Getting Started

The project is designed to be used in conjunction with [Visual Studio](https://visualstudio.microsoft.com/)
and the [Windows Driver Kit](https://learn.microsoft.com/en-us/windows-hardware/drivers/download-the-wdk).

Build the Detours library by opening a Developer Command Prompt for Visual Studio:

~~~{.sh}
cd detours\src
nmake
~~~

The project can then be built using the Visual Studio solution WDUTF.sln.

<a id="prereq"></a>
## Runtime Prerequisites

The Windows Driver Unit Test Framework has been tested with:

* Visual Studio 2019
* Windows Driver Kit (10.0.22000.1)
* Windows SDK (10.0.22000.1)

It is also known to work with earlier versions of the Windows Driver Kit and Visual Studio.

In order to build the example projects, a couple of executables need to be copied into tools\bin. The [README](https://github.com/wpdk/wdutf/blob/main/tools/bin/README.md) contains details.

<a id="status"></a>
## Current Status

The project has been in use at [DataCore](https://datacore.com/) for many years. It is considered to be stable, but is currently limited to the kernel features required by DataCore's own driver stack.

<a id="limitations"></a>
## Limitations

The scope of the project is currently limited to supporting the kernel features used by [DataCore](https://datacore.com/) drivers, but it is being made available to the community as a resource that can be developed and further extended.

In particular:

* Minimal support for the Kernel Mode Driver Framework.

* Currently only x64 builds are supported.

<a id="issues"></a>
## Known Issues

* None.

<a id="unit"></a>
## Unit Tests

The Windows Driver Unit Test Framework includes a set of unit test to validate the framework. These can be found in [test](https://github.com/wpdk/wdutf/blob/main/test).

<a id="contrib"></a>
## Contributing

Contributions are welcome and needed! In these initial stages of the project, please email the [maintainers](https://github.com/wpdk/wpdk/blob/master/MAINTAINERS.md) directly.

<a id="depend"></a>
## Dependencies

There are currently no external dependencies.

<a id="acknowledge"></a>
## Acknowledments
The Windows Driver Unit Test Framework has been developed and contributed by [DataCore](https://datacore.com/).

<a id="core"></a>
## Core Maintainers

The [core maintainers](https://github.com/wpdk/wdutf/blob/main/MAINTAINERS.md) primary responsibility is to provide technical oversight for the WDUTF Project. The current list includes:
* [Nick Connolly](https://github.com/nconnolly1), [DataCore](https://datacore.com/)
* [Robert Bassett](https://github.com/datacore-rbassett), [DataCore](https://datacore.com/)

```

`WDUTF.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.32929.386
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Ddk", "src\Ddk.vcxproj", "{12FAF1AE-B4C9-449F-A188-F03CBA835662}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DdkUnitTest", "test\DdkUnitTest.vcxproj", "{EC884926-BF4A-42EF-8168-107EDB958B9E}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BasicDriver", "examples\BasicDriver\BasicDriver.vcxproj", "{7C257DEE-2E49-4343-A624-3FFF722BE00A}"
EndProject
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "BasicDriverUnitTest", "examples\BasicDriverUnitTest\BasicDriverUnitTest.vcxproj", "{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}"
	ProjectSection(ProjectDependencies) = postProject
		{12FAF1AE-B4C9-449F-A188-F03CBA835662} = {12FAF1AE-B4C9-449F-A188-F03CBA835662}
		{7C257DEE-2E49-4343-A624-3FFF722BE00A} = {7C257DEE-2E49-4343-A624-3FFF722BE00A}
	EndProjectSection
EndProject
Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Examples", "Examples", "{F1E46BFF-13B9-4DF1-A6C1-8DD3305A911B}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Release|x64 = Release|x64
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{12FAF1AE-B4C9-449F-A188-F03CBA835662}.Debug|x64.ActiveCfg = Debug|x64
		{12FAF1AE-B4C9-449F-A188-F03CBA835662}.Debug|x64.Build.0 = Debug|x64
		{12FAF1AE-B4C9-449F-A188-F03CBA835662}.Release|x64.ActiveCfg = Release|x64
		{12FAF1AE-B4C9-449F-A188-F03CBA835662}.Release|x64.Build.0 = Release|x64
		{EC884926-BF4A-42EF-8168-107EDB958B9E}.Debug|x64.ActiveCfg = Debug|x64
		{EC884926-BF4A-42EF-8168-107EDB958B9E}.Debug|x64.Build.0 = Debug|x64
		{EC884926-BF4A-42EF-8168-107EDB958B9E}.Release|x64.ActiveCfg = Release|x64
		{EC884926-BF4A-42EF-8168-107EDB958B9E}.Release|x64.Build.0 = Release|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Debug|x64.ActiveCfg = Debug|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Debug|x64.Build.0 = Debug|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Debug|x64.Deploy.0 = Debug|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Release|x64.ActiveCfg = Release|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Release|x64.Build.0 = Release|x64
		{7C257DEE-2E49-4343-A624-3FFF722BE00A}.Release|x64.Deploy.0 = Release|x64
		{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}.Debug|x64.ActiveCfg = Debug|x64
		{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}.Debug|x64.Build.0 = Debug|x64
		{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}.Release|x64.ActiveCfg = Release|x64
		{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}.Release|x64.Build.0 = Release|x64
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(NestedProjects) = preSolution
		{7C257DEE-2E49-4343-A624-3FFF722BE00A} = {F1E46BFF-13B9-4DF1-A6C1-8DD3305A911B}
		{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473} = {F1E46BFF-13B9-4DF1-A6C1-8DD3305A911B}
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {5E28E2AA-B3DF-4D39-BD2E-43438C98FF89}
	EndGlobalSection
EndGlobal

```

`config/Application.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <CpuType>$(Platform.ToLower().Replace('x64','amd64').Replace('win32','i386'))</CpuType>
    <BuildType>$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($(Configuration.ToLower()), '.*debug.*', 'Debug')), '.*release.*', 'Release'))</BuildType>
    <BaseDir>$([System.Io.Path]::GetFullPath("$(MsBuildThisFileDirectory)..\"))</BaseDir>
    <CoreDir>$(BaseDir)</CoreDir>
    <CommonDir>$(CoreDir)inc\</CommonDir>
    <DetoursDir>$(BaseDir)Detours\</DetoursDir>
    <BinDir>$(BaseDir)Tools\Bin\</BinDir>
    <SedCmd>$(BinDir)sed.exe</SedCmd>
    <DbhCmd>$(BinDir)dbh.exe</DbhCmd>
  </PropertyGroup>
  <PropertyGroup>
    <OutDir>$(BaseDir)build\Target\$(BuildType)-$(CpuType)\</OutDir>
    <IntDir>$(BaseDir)build\Intermediate\$(BuildType)-$(CpuType)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup>
    <CustomBuildAfterTargets>
    </CustomBuildAfterTargets>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <MinimalRebuild>false</MinimalRebuild>
      <TreatWarningAsError>true</TreatWarningAsError>
      <BrowseInformation>false</BrowseInformation>
      <WarningLevel>Level4</WarningLevel>
    </ClCompile>
    <Link>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <LinkTimeCodeGeneration>Default</LinkTimeCodeGeneration>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/Zo %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <BuildMacro Include="CpuType">
      <Value>$(CpuType)</Value>
    </BuildMacro>
    <BuildMacro Include="BuildType">
      <Value>$(BuildType)</Value>
    </BuildMacro>
    <BuildMacro Include="BaseDir">
      <Value>$(BaseDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CoreDir">
      <Value>$(CoreDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CommonDir">
      <Value>$(CommonDir)</Value>
    </BuildMacro>
    <BuildMacro Include="DetoursDir">
      <Value>$(DetoursDir)</Value>
    </BuildMacro>
    <BuildMacro Include="BinDir">
      <Value>$(BinDir)</Value>
    </BuildMacro>
    <BuildMacro Include="SedCmd">
      <Value>$(SedCmd)</Value>
    </BuildMacro>
    <BuildMacro Include="DbhCmd">
      <Value>$(DbhCmd)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>
```

`config/Driver.Application.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <CpuType>$(Platform.ToLower().Replace('x64','amd64').Replace('win32','i386'))</CpuType>
    <BuildType>$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($(Configuration.ToLower()), '.*debug.*', 'Debug')), '.*release.*', 'Release'))</BuildType>
    <BaseDir>$([System.Io.Path]::GetFullPath("$(MsBuildThisFileDirectory)..\"))</BaseDir>
    <CoreDir>$(BaseDir)</CoreDir>
    <CommonDir>$(CoreDir)inc\</CommonDir>
    <BinDir>$(BaseDir)Tools\Bin\</BinDir>
    <SedCmd>$(BinDir)sed.exe</SedCmd>
    <DbhCmd>$(BinDir)dbh.exe</DbhCmd>
  </PropertyGroup>
  <PropertyGroup>
    <OutDir>$(BaseDir)build\Target\$(BuildType)-$(CpuType)\</OutDir>
    <IntDir>$(BaseDir)build\Intermediate\$(BuildType)-$(CpuType)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup>
    <LinkIncremental>false</LinkIncremental>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
    <SupportsPackaging>false</SupportsPackaging>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(CommonDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>W2K;WIN2K;WXP;WNET;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <TreatWChar_tAsBuiltInType>false</TreatWChar_tAsBuiltInType>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <WarningVersion>18</WarningVersion>
    </ClCompile>
    <PostBuildEvent>
      <Command>powershell.exe -NonInteractive -NoProfile -ExecutionPolicy ByPass -File "$(FixupScript)" "$(TargetPath)"</Command>
      <Message>Extracting Symbols...</Message>
    </PostBuildEvent>
    <Link>
      <IgnoreSpecificDefaultLibraries>libcmt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(IntDir);$(OutDir);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <Ctrpp>
      <HeaderFileNameForProvider>$(IntDir)%(Filename)_perf.h</HeaderFileNameForProvider>
    </Ctrpp>
    <Ctrpp>
      <GenerateResourceSourceFile>true</GenerateResourceSourceFile>
      <ResourceFileName>$(IntDir)%(Filename)_perf.rc</ResourceFileName>
      <HeaderFileNameForCounter>$(IntDir)%(Filename)_counters.h</HeaderFileNameForCounter>
    </Ctrpp>
    <PostBuildEvent>
      <Command>if exist ctrpp.*.tlog move /y ctrpp.*.tlog "$(IntDir)"  &gt;nul: 2&gt;&amp;1</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Cleanup log files...</Message>
    </PostBuildEvent>
    <MessageCompile>
      <SetCustomerbit>true</SetCustomerbit>
    </MessageCompile>
    <CustomBuild>
      <Outputs>$(TargetDir)%(Filename)%(Extension);%(Outputs)</Outputs>
      <Message>Copying %(Filename)%(Extension)</Message>
      <Command>copy "%(FullPath)" "$(TargetDir)" &gt;nul:</Command>
      <LinkObjects>false</LinkObjects>
    </CustomBuild>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/Zo %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BUILD_NUMBER)'!=''">
    <ClCompile>
      <PreprocessorDefinitions>_DCSVERSION_=$(BUILD_NUMBER);%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemGroup>
    <BuildMacro Include="CpuType">
      <Value>$(CpuType)</Value>
    </BuildMacro>
    <BuildMacro Include="BuildType">
      <Value>$(BuildType)</Value>
    </BuildMacro>
    <BuildMacro Include="BaseDir">
      <Value>$(BaseDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CoreDir">
      <Value>$(CoreDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CommonDir">
      <Value>$(CommonDir)</Value>
    </BuildMacro>
    <BuildMacro Include="BinDir">
      <Value>$(BinDir)</Value>
    </BuildMacro>
    <BuildMacro Include="SedCmd">
      <Value>$(SedCmd)</Value>
    </BuildMacro>
    <BuildMacro Include="DbhCmd">
      <Value>$(DbhCmd)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>
```

`config/Driver.UnitTest.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <CpuType>$(Platform.ToLower().Replace('x64','amd64').Replace('win32','i386'))</CpuType>
    <BuildType>$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($(Configuration.ToLower()), '.*debug.*', 'Debug')), '.*release.*', 'Release'))</BuildType>
    <BaseDir>$([System.Io.Path]::GetFullPath("$(MsBuildThisFileDirectory)..\"))</BaseDir>
    <CoreDir>$(BaseDir)</CoreDir>
    <CommonDir>$(CoreDir)inc\</CommonDir>
    <BinDir>$(BaseDir)Tools\Bin\</BinDir>
    <SedCmd>$(BinDir)sed.exe</SedCmd>
    <DbhCmd>$(BinDir)dbh.exe</DbhCmd>
  </PropertyGroup>
  <PropertyGroup>
    <OutDir>$(BaseDir)build\Target\$(BuildType)-$(CpuType)\vsTest\</OutDir>
    <IntDir>$(BaseDir)build\Intermediate\$(BuildType)-$(CpuType)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup>
    <LinkIncremental>false</LinkIncremental>
    <SupportsPackaging>false</SupportsPackaging>
    <CustomBuildBeforeTargets>
    </CustomBuildBeforeTargets>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir);$(IntDir);$(CommonDir);$(OutDir)\..;$(VCInstallDir)UnitTest\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <TreatWChar_tAsBuiltInType>false</TreatWChar_tAsBuiltInType>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <DisableSpecificWarnings>4201;4316;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <WarningVersion>18</WarningVersion>
    </ClCompile>
    <Link>
      <IgnoreSpecificDefaultLibraries>libcmt;%(IgnoreSpecificDefaultLibraries)</IgnoreSpecificDefaultLibraries>
      <AdditionalLibraryDirectories>$(OutDir);$(OutDir)\..;$(VCInstallDir)UnitTest\lib;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalOptions>/ignore:4199 %(AdditionalOptions)</AdditionalOptions>
      <DelayLoadDLLs>
      </DelayLoadDLLs>
    </Link>
    <Ctrpp>
      <HeaderFileNameForProvider>$(IntDir)%(Filename)_perf.h</HeaderFileNameForProvider>
    </Ctrpp>
    <Ctrpp>
      <GenerateResourceSourceFile>true</GenerateResourceSourceFile>
      <ResourceFileName>$(IntDir)%(Filename)_perf.rc</ResourceFileName>
      <HeaderFileNameForCounter>$(IntDir)%(Filename)_counters.h</HeaderFileNameForCounter>
    </Ctrpp>
    <PostBuildEvent>
      <Command>if exist ctrpp.*.tlog move /y ctrpp.*.tlog "$(IntDir)"  &gt;nul: 2&gt;&amp;1</Command>
    </PostBuildEvent>
    <PostBuildEvent>
      <Message>Cleanup log files...</Message>
    </PostBuildEvent>
    <MessageCompile>
      <SetCustomerbit>true</SetCustomerbit>
    </MessageCompile>
    <CustomBuild>
      <Command>$(DbhCmd) "$(TargetDir)..\%(Filename).sys" obj | $(SedCmd) -n -e"/[\/\\]Intermediate[\/\\]/Ip" -e"/^Dcs.*sys/Is/.sys/.lib/Ip" &gt; "$(IntDir)depends.tlog"
link.exe "%(TargetDir)ddkinline.obj" @"$(IntDir)depends.tlog" ddkcrt.lib ddk.lib /DEF:%(Identity) /OUT:"$(TargetDir)%(Filename).sys" /PDB:"$(TargetDir)%(Filename).pdb" /IMPLIB:"$(TargetDir)%(Filename).lib" /LIBPATH:"$(OutDir).." /INCREMENTAL:NO /NOLOGO /WX /NODEFAULTLIB /MANIFEST:NO /DEBUG /DLL /OPT:REF /OPT:ICF /ENTRY:"DriverEntry" /RELEASE /MERGE:"_TEXT=.text;_PAGE=PAGE" /PROFILE /SECTION:.rsrc,!D /IGNORE:4198,4010,4037,4039,4065,4070,4078,4087,4089,4221,4108,4088,4218,4218,4235 /pdbcompress /debugtype:pdata</Command>
      <Outputs>$(TargetDir)%(Filename).sys;%(Outputs)</Outputs>
      <Message>Relinking %(Filename).sys...</Message>
      <AdditionalInputs>$(TargetDir)..\%(Filename).sys;%(AdditionalInputs)</AdditionalInputs>
    </CustomBuild>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/Zc:sizedDealloc- /Zo %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>/Zc:sizedDealloc- %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
    <Link>
      <SupportUnloadOfDelayLoadedDLL>true</SupportUnloadOfDelayLoadedDLL>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <BuildMacro Include="CpuType">
      <Value>$(CpuType)</Value>
    </BuildMacro>
    <BuildMacro Include="BuildType">
      <Value>$(BuildType)</Value>
    </BuildMacro>
    <BuildMacro Include="BaseDir">
      <Value>$(BaseDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CoreDir">
      <Value>$(CoreDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CommonDir">
      <Value>$(CommonDir)</Value>
    </BuildMacro>
    <BuildMacro Include="BinDir">
      <Value>$(BinDir)</Value>
    </BuildMacro>
    <BuildMacro Include="SedCmd">
      <Value>$(SedCmd)</Value>
    </BuildMacro>
    <BuildMacro Include="DbhCmd">
      <Value>$(DbhCmd)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>
```

`config/Driver.props`:

```props
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ImportGroup Label="PropertySheets" />
  <PropertyGroup Label="UserMacros">
    <BuildNumber>$(BUILD_NUMBER)</BuildNumber>
    <CpuType>$(Platform.ToLower().Replace('x64','amd64').Replace('win32','i386'))</CpuType>
    <BuildType>$([System.Text.RegularExpressions.Regex]::Replace($([System.Text.RegularExpressions.Regex]::Replace($(Configuration.ToLower()), '.*debug.*', 'Debug')), '.*release.*', 'Release'))</BuildType>
    <BaseDir>$([System.Io.Path]::GetFullPath("$(MsBuildThisFileDirectory)..\"))</BaseDir>
    <CoreDir>$(BaseDir)</CoreDir>
    <CommonDir>$(CoreDir)inc\</CommonDir>
    <BinDir>$(BaseDir)Tools\Bin\</BinDir>
    <SedCmd>$(BinDir)sed.exe</SedCmd>
    <DbhCmd>$(BinDir)dbh.exe</DbhCmd>
    <NoSizedDealloc Condition="'$(PlatformToolsetVersion)'!='120'">/Zc:sizedDealloc-</NoSizedDealloc>
  </PropertyGroup>
  <PropertyGroup>
    <OutDir>$(BaseDir)build\Target\$(BuildType)-$(CpuType)\</OutDir>
    <IntDir>$(BaseDir)build\Intermediate\$(BuildType)-$(CpuType)\$(ProjectName)\</IntDir>
  </PropertyGroup>
  <PropertyGroup>
    <CustomBuildAfterTargets>
    </CustomBuildAfterTargets>
    <PostBuildEventUseInBuild>true</PostBuildEventUseInBuild>
    <TargetName>Dcs$(TargetName.Replace('Driver',''))</TargetName>
    <SignMode>Off</SignMode>
    <SupportsPackaging>false</SupportsPackaging>
    <EnableInf2cat>false</EnableInf2cat>
  </PropertyGroup>
  <ItemDefinitionGroup>
    <ClCompile>
      <AdditionalIncludeDirectories>$(ProjectDir);$(CommonDir);$(OutDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>POOL_NX_OPTIN=1;_DCS_KERNEL_;RUN_WPP;WPP_NO_HEADER_FILES;_WIN64;_AMD64_;AMD64;W2K;WIN2K;WXP;WNET;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <DisableSpecificWarnings>4201;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <ForceConformanceInForLoopScope>true</ForceConformanceInForLoopScope>
      <BufferSecurityCheck>false</BufferSecurityCheck>
      <WppKernelMode>true</WppKernelMode>
      <WppModuleName>$(TargetName)</WppModuleName>
      <WppScanConfigurationData>$(CommonDir)TraceWpp.h</WppScanConfigurationData>
      <WppDllMacro>true</WppDllMacro>
      <WppEnabled>true</WppEnabled>
      <WarningVersion>18</WarningVersion>
    </ClCompile>
    <CustomBuildStep>
      <Command>
      </Command>
    </CustomBuildStep>
    <CustomBuildStep>
      <Message>
      </Message>
    </CustomBuildStep>
    <CustomBuild>
      <Command>copy "%(FullPath)" "$(TargetDir)" &gt;nul:</Command>
    </CustomBuild>
    <CustomBuild>
      <Message>Copying %(Filename)%(Extension)</Message>
    </CustomBuild>
    <CustomBuild>
      <LinkObjects>false</LinkObjects>
      <Outputs>$(TargetDir)%(Filename)%(Extension);%(Outputs)</Outputs>
    </CustomBuild>
    <Link>
      <AdditionalLibraryDirectories>$(IntDir);$(OutDir)</AdditionalLibraryDirectories>
      <AdditionalOptions>/SECTION:.rsrc,!D %(AdditionalOptions)</AdditionalOptions>
      <EntryPointSymbol>DriverEntry</EntryPointSymbol>
    </Link>
    <Mofcomp>
      <WmiSyntaxCheck>true</WmiSyntaxCheck>
    </Mofcomp>
    <MessageCompile>
      <SetCustomerbit>true</SetCustomerbit>
    </MessageCompile>
    <Ctrpp>
      <HeaderFileNameForProvider>$(IntDir)%(Filename)_perf.h</HeaderFileNameForProvider>
    </Ctrpp>
    <Ctrpp>
      <GenerateResourceSourceFile>true</GenerateResourceSourceFile>
      <ResourceFileName>$(IntDir)%(Filename)_perf.rc</ResourceFileName>
      <HeaderFileNameForCounter>$(IntDir)%(Filename)_counters.h</HeaderFileNameForCounter>
    </Ctrpp>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>$(NoSizedDealloc) /Zo %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BuildType)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>_WIN64;_AMD64_;AMD64;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <AdditionalOptions>$(NoSizedDealloc) %(AdditionalOptions)</AdditionalOptions>
    </ClCompile>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(BUILD_NUMBER)'!=''">
    <ClCompile>
      <PreprocessorDefinitions>_DCSVERSION_=$(BUILD_NUMBER);%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Inf>
      <TimeStamp>$(BUILD_NUMBER)</TimeStamp>
    </Inf>
  </ItemDefinitionGroup>
  <ItemGroup>
    <BuildMacro Include="BuildNumber">
      <Value>$(BuildNumber)</Value>
    </BuildMacro>
    <BuildMacro Include="CpuType">
      <Value>$(CpuType)</Value>
    </BuildMacro>
    <BuildMacro Include="BuildType">
      <Value>$(BuildType)</Value>
    </BuildMacro>
    <BuildMacro Include="BaseDir">
      <Value>$(BaseDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CoreDir">
      <Value>$(CoreDir)</Value>
    </BuildMacro>
    <BuildMacro Include="CommonDir">
      <Value>$(CommonDir)</Value>
    </BuildMacro>
    <BuildMacro Include="BinDir">
      <Value>$(BinDir)</Value>
    </BuildMacro>
    <BuildMacro Include="SedCmd">
      <Value>$(SedCmd)</Value>
    </BuildMacro>
    <BuildMacro Include="DbhCmd">
      <Value>$(DbhCmd)</Value>
    </BuildMacro>
    <BuildMacro Include="NoSizedDealloc">
      <Value>$(NoSizedDealloc)</Value>
    </BuildMacro>
  </ItemGroup>
</Project>
```

`doc/design.md`:

```md
# Design and Implementation

## Design Principles

The project conforms to the following design principles:

* A lightweight layer that runs as native Windows code, that can be tested independently.
* The primary focus is to enable unit testing of Windows kernel drivers in user space.

## Overview

The initial version of the project consisted of a user space library implementing portions of the kernel infrastructure. This allows existing kernel code to be compiled using the unit test framework and then tested.

This works well, but we wanted to do something better; we wanted to create a user space environment where the binary driver that is going to be used in production could be loaded, tested and examined with the Visual Studio debugger.

There are three major challenges associated with implementing a unit test framework like this:

* Providing the required definitions and symbols
* Handling low level implementation details
* Providing access to code in the driver under test

## Definitions and Symbols

The unit test framework depends upon the Windows Driver kit include files to provide definitions. Include paths are changed using _#pragma include_alias_ to redirect to a wrapper around each header file. This ensures that the correct definitions are used, without the need to copy or duplicate content. It also allows the code under test to work with the exact same binary structures that the kernel would provide (e.g. DEVICE and DRIVER objects).

One downside of this approach is that each release of the Windows Driver Kit may require updates to the wrappers, but in practice only minor adjustments have been necessary.

Kernel functionality has been implemented based on the Windows Driver Kit documentation.

## Low level Details

Windows device drivers are .sys files which cannot be loaded directly into a user space application. The framework includes a _load_ operation that will copy the driver, rename it to a _.dll_ and make minor changes in order for it to be loadable.

Various operations, such as privileged instructions, are then resolved at run-time through the use of exception handling. Fortunately, these tend to occur at low frequency.

## Access to Code

In general, a Windows driver has no externally visible symbols. This creates challenges accessing the code to be unit tested. This issue can be overcome in the following ways:

1. Compile and link the code as part of building the unit tests. This ensures that all symbols are available, but doesn't allow testing of the production images.
2. Relink the driver with an new _.def_ file to export the symbols required for unit testing. The unit tests can then be linked directly against this using _delay load_ to create an external reference that will be satisfied when the framework loads the driver.
3. Use the Microsoft Detours library to provide access to the private symbols of the driver under test. The macros TEST_FIND_FUNCTION, TEST_FIND_METHOD and TEST_FIND_VARIABLE defined in UnitTest.h implement this.

The Microsoft Detours library also allows the behaviour of functions in the driver to be changed by intercepting calls on a per-thread basis. The macro definitions for TEST_DEFINE_MOCK_* in UnitTest.h and test\DetoursTest.cpp provide examples.

```

`examples/BasicDriver/Basic.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 */

#include <ddk.h>

#define WPPFILE "Basic.tmh"
#include "Trace.h"

extern "C" {
NTSTATUS DriverEntry (PDRIVER_OBJECT, PUNICODE_STRING);
NTSTATUS BasicCreateClose(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
LONG BasicTestFunction(LONG v);
}


NTSTATUS
DriverEntry(
    IN OUT PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING      RegistryPath
    )
{
	ExInitializeDriverRuntime(DrvRtPoolNxOptIn);

	WPP_INIT_TRACING(DriverObject, RegistryPath);

	DriverObject->MajorFunction[IRP_MJ_CREATE] = BasicCreateClose;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = BasicCreateClose;
	
	return STATUS_SUCCESS;
}


NTSTATUS
BasicCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
	UNREFERENCED_PARAMETER(DeviceObject); 

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
}


LONG
BasicTestFunction(LONG v)
{
    return v + 1;
}


LONG
BasicTestFunction2(LONG v)
{
    return v + 2;
}

```

`examples/BasicDriver/BasicDriver.rc`:

```rc
// Microsoft Visual C++ generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "winres.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (United States) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE 
BEGIN
    "#include ""winres.h""\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x2L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "CompanyName", "DataCore Software Corporation"
            VALUE "FileDescription", "DcsBasic"
            VALUE "FileVersion", "1, 0, 0, 1"
            VALUE "InternalName", "DcsBasic"
            VALUE "LegalCopyright", "Copyright © 1999 DataCore Software Corporation"
            VALUE "OriginalFilename", "DcsBasic.sys"
            VALUE "ProductName", "DcsBasic"
            VALUE "ProductVersion", "1, 0, 0, 1"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // English (United States) resources
/////////////////////////////////////////////////////////////////////////////



```

`examples/BasicDriver/BasicDriver.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{7C257DEE-2E49-4343-A624-3FFF722BE00A}</ProjectGuid>
    <TemplateGuid>{dd38f7fc-d7bd-488b-9242-7d8754cde80d}</TemplateGuid>
    <TargetFrameworkVersion>v4.6.1</TargetFrameworkVersion>
    <MinimumVisualStudioVersion>11.0</MinimumVisualStudioVersion>
    <Configuration>Debug</Configuration>
    <Platform Condition="'$(Platform)' == ''">x64</Platform>
    <RootNamespace>BasicDriver</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <TargetVersion>Windows7</TargetVersion>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsKernelModeDriver10.0</PlatformToolset>
    <ConfigurationType>Driver</ConfigurationType>
    <DriverType>WDM</DriverType>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="..\..\Config\Driver.props" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="..\..\Config\Driver.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>DcsBasic</TargetName>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <DebuggerFlavor>DbgengKernelDebugger</DebuggerFlavor>
    <TargetName>DcsBasic</TargetName>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PreprocessorDefinitions>POLLER_SERVER;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PreprocessorDefinitions>POLLER_SERVER;%(PreprocessorDefinitions)</PreprocessorDefinitions>
    </ClCompile>
    <Link />
  </ItemDefinitionGroup>
  <ItemGroup>
    <Inf Include="DcsBasic.inf">
      <FileType>Document</FileType>
    </Inf>
  </ItemGroup>
  <ItemGroup>
    <FilesToPackage Include="$(TargetPath)" />
    <FilesToPackage Include="@(Inf->'%(CopyOutput)')" Condition="'@(Inf)'!=''" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Basic.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="resource.h" />
    <ClInclude Include="Trace.h" />
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="DcsBasic.cdf">
      <FileType>Document</FileType>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="BasicDriver.rc" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/BasicDriver/BasicDriver.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{061B2AE2-9021-4E00-8381-194E8239A056}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{524F6C63-4B04-4020-BC26-9B5F10529330}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{FC2FFE21-87E7-47EF-A8C0-72C2D9387C1E}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
    <Filter Include="Driver Files">
      <UniqueIdentifier>{CFF853AD-51DF-4661-8B14-E9344EFC1A5C}</UniqueIdentifier>
      <Extensions>inf;inv;inx;mof;mc;</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Basic.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Trace.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="BasicDriver.rc">
      <Filter>Resource Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="DcsBasic.cdf">
      <Filter>Driver Files</Filter>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <Inf Include="DcsBasic.inf">
      <Filter>Driver Files</Filter>
    </Inf>
  </ItemGroup>
</Project>
```

`examples/BasicDriver/DcsBasic.cdf`:

```cdf
[CatalogHeader]
Name=DcsBasic.cat

[CatalogFiles]
<hash>DcsBasic.sys=DcsBasic.sys
<hash>DcsBasic.inf=DcsBasic.inf

```

`examples/BasicDriver/DcsBasic.inf`:

```inf
; DcsBasic.inf
;
;  SPDX-License-Identifier: BSD-3-Clause
;
;  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
;

[Version]
Signature="$Windows NT$"
Provider=%DataCore%
Class = System
ClassGuid = {4d36e97d-e325-11ce-bfc1-08002be10318} 
CatalogFile=DcsBasic.cat
DriverVer=01/16/2001, 4.0.0

[DestinationDirs]
DefaultDestDir   = 12

;
; Driver information
;

[Manufacturer]
%DataCore%   = DataCore.Mfg,NTx86,NTamd64

[DataCore.Mfg.NTx86]
%DataCore.DeviceDesc0% = DcsBasic, Basic

[DataCore.Mfg.NTamd64]
%DataCore.DeviceDesc0% = DcsBasic, Basic

;
; General installation section
;

[DcsBasic]
AddReg=DcsBasic.AddReg
CopyFiles=DcsBasic.Driver

[DcsBasic.AddReg]


;
; File sections
;

[DcsBasic.Driver]
DcsBasic.sys,,,0x00004000


;
; Service Installation
;

[DcsBasic.Services]
AddService = DcsBasic, 0x00000002 , DcsBasic_Service_Inst, DcsBasic_EventLog_Inst

[DcsBasic_Service_Inst]
DisplayName		= %DcsBasic.SvcDesc%
ServiceType		= 1                  ; SERVICE_KERNEL_DRIVER
StartType		= 0                  ; SERVICE_BOOT_START
ErrorControl	= 0                  ; SERVICE_ERROR_IGNORE
LoadOrderGroup	= DcsGroupONE
ServiceBinary	= %12%\DcsBasic.sys
AddReg			= DcsBasic_Service_AddReg

[DcsBasic_Service_AddReg]
HKR, , Tag, %REG_DWORD%, 0x2

[DcsBasic_EventLog_Inst]
AddReg = DcsBasic_EventLog_AddReg

[DcsBasic_EventLog_AddReg]
HKR,,EventMessageFile,0x00020000,"%%SystemRoot%%\System32\DcsMsg.dll;%%SystemRoot%%\System32\drivers\DcsBasic.sys;%%SystemRoot%%\System32\IoLogMsg.dll"
HKR,,TypesSupported,0x00010001,7


;
; Source file information
;

[SourceDisksNames]
1 = %DiskId1%,,,""

[SourceDisksFiles]
; Files for disk DataCore Software Corporation Installation Disk #1 (Poller)
DcsBasic.sys = 1,,


[Strings]

;
; Non-Localizable Strings
;

REG_SZ         = 0x00000000
REG_MULTI_SZ   = 0x00010000
REG_EXPAND_SZ  = 0x00020000
REG_BINARY     = 0x00000001
REG_DWORD      = 0x00010001
SERVICEROOT    = "System\CurrentControlSet\Services"

;
; Localizable Strings
;

DataCore.DeviceDesc0 = "DataCore Basic Driver"
DiskId1 = "DataCore Software Corporation Installation Disk #1 (Basic)"
DataCore = "DataCore Software Corporation"
DcsBasic.SvcDesc="DataCore Basic Driver"

```

`examples/BasicDriver/Trace.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 */

/*
 * Trace definitions.
 */

#ifndef _BASIC_TRACE_H_
#define _BASIC_TRACE_H_

/*
 * Define Trace constants
 */

#define WPPNAME		DcsBasic
#define WPPGUID		4DC7A0CC,3C78,45A6,91B4,99690CB74954

#include <TraceDefs.h>

/*
 * Define Trace Flags
 */

#define WPP_CONTROL_GUIDS                                              \
    WPP_DEFINE_CONTROL_GUID(                                           \
        WPPNAME, (WPPGUID),		                                       \
        WPP_DEFINE_DEFAULT_BITS                                        \
        )

// WPP is always initialised.
#define WPP_CHECK_INIT

#endif /* _BASIC_TRACE_H_ */

#include <TraceWpp.h>

```

`examples/BasicDriver/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BasicDriver.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`examples/BasicDriverUnitTest/BasicDriverUnitTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{E0DC6EF7-B977-4CB1-B7AC-FD63F8833473}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>BasicDriverUnitTest</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Config\Driver.UnitTest.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\..\Config\Driver.UnitTest.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>dcsbasic.sys;%(DelayLoadDLLs)</DelayLoadDLLs>
      <AdditionalDependencies>DcsBasic.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <DelayLoadDLLs>dcsbasic.sys;%(DelayLoadDLLs)</DelayLoadDLLs>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <AdditionalDependencies>DcsBasic.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="Test.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="Test.cpp" />
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="DcsBasic.def" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`examples/BasicDriverUnitTest/BasicDriverUnitTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{3853EBC9-8A82-43E7-B66F-E925EEB6F641}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{61722BB8-4A8F-4B94-ACAE-4873C4DA3FD1}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{DBD96620-9951-4223-A355-87F7A4002E26}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Test.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Test.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="DcsBasic.def" />
  </ItemGroup>
</Project>
```

`examples/BasicDriverUnitTest/DcsBasic.def`:

```def
EXPORTS
	BasicTestFunction
	?BasicTestFunction2@@YAJJ@Z

```

`examples/BasicDriverUnitTest/Test.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 */

/*
 *	BasicDriver Unit Test Initialization
 */

#include "stdafx.h"

extern "C" LONG BasicTestFunction(LONG v);

extern LONG BasicTestFunction2(LONG v);


namespace BasicDriverUnitTest
{		
	TEST_MODULE_INITIALIZE(BasicDriverUnitTestInit)
	{
		TEST_MODULE_START(BasicDriverUnitTestCleanup);
		DdkLoadDriver("DcsBasic");
	}

	TEST_MODULE_CLEANUP(BasicDriverUnitTestCleanup)
	{
		TEST_MODULE_END();
		DdkUnloadDriver("DcsBasic");
	}

	TEST_CLASS(BasicDriverUnitTest)
	{
		TEST_METHOD(BasicDriverLoad)
		{
		}

		TEST_METHOD(BasicDriverTest)
		{
			LONG v = BasicTestFunction(10);

			Assert::IsTrue(v == 11);
		}

		TEST_METHOD(BasicDriverTest2)
		{
			LONG v = BasicTestFunction2(10);

			Assert::IsTrue(v == 12);
		}
	};
}

```

`examples/BasicDriverUnitTest/Test.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 */


```

`examples/BasicDriverUnitTest/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// BasicDriverUnitTest.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`examples/BasicDriverUnitTest/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <ddk.h>
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <memory.h>
#include <time.h>
#include <errno.h>

#include "targetver.h"
#include "UnitTest.h"

```

`examples/BasicDriverUnitTest/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`inc/TraceDbg.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2015, DataCore Software Corporation. All rights reserved.
 */

/*
 * DbgPrint support for WPP tracing.
 */

#ifndef _DCS_TRACEDBG_H_
#define _DCS_TRACEDBG_H_


/*
 * CDbgPrintTrace - Expand trace output
 */

class CDbgPrintTrace {
	static const size_t len = 512;
	char out[len + 1];
	size_t i;

	const char *pInfo;
	bool passive;

public:
	CDbgPrintTrace(const char *s) : pInfo(s), i(0) {
		passive = isPassive();
		out[0] = 0;
	}

	char *Append(const char *s, size_t n = len) {
		if (!s) return Append("(null)");
		if (i && n && *s == '\n' && out[i-1] == '\n') i--;
		if (n > len - i) n = len - i;
		while (n-- && *s) out[i++] = *s++;
		out[i] = 0;
		return out;
	}

	char *Append(const wchar_t *s, size_t n = len) {
		if (!s) return Append("(null)");
		if (i && n && *s == '\n' && out[i-1] == '\n') i--;
		if (n > len - i) n = len - i;
		for (; n-- && *s; s++) out[i++] = (*s <= 0x7f) ? (char)*s : '?';
		out[i] = 0;
		return out;
	}

	char *Append(const char *&cp, va_list &ap) {
		bool wpp = (*++cp == '!' && *cp);
		const char *ep = (wpp) ? strchr(cp + 1, '!') : strpbrk(cp, "cCdiouxXnpsSZ%");
		size_t n = (ep) ? (++ep) - cp + 1 - (wpp ? 3 : 0) : 0;
		char arg[40];

		if (!n || n >= sizeof(arg)) return out;

		strncpy(arg, ep - n - (wpp ? 1 : 0), n);
		arg[n] = 0;

		if (!wpp && strspn(arg, "cCdiouxXnpsSZ%lwIh.*0123456789+-# ") != n)
			return out;

		cp = ep;
		return (wpp) ? Expand(arg, ap) : Format(arg, ap);
	}

	static bool isPassive() {
#ifdef _DCS_KERNEL_
		return (KeGetCurrentIrql() == PASSIVE_LEVEL);
#else
		return true;
#endif
	}

private:
	char *Expand(const char *arg, va_list &ap);
	char *ExpandProject(const char *arg, va_list &ap);
	char *ExpandCustom(const char *arg, va_list &ap);

	char *Format(const char *arg, va_list &ap) {
		PrintArg(arg, ap);
		NextArg(arg, ap);
		return out;
	}

	char *Print(const char *fmt, ...) {
		va_list ap;
		va_start(ap, fmt);
		PrintArg(fmt, ap);
		va_end(ap);
		return out;
	}

	char *PrintArg(const char *fmt, va_list ap) {
#ifdef _DCS_KERNEL_
		const char *ep;
		if (!passive && *fmt == '%' && (ep = strpbrk(fmt + 1, "cCdiouxXnpsSZ%!")) != NULL) {
			if (*ep == 'Z' && ep[-1] == 'w') {
				UNICODE_STRING *u = va_arg(ap, UNICODE_STRING *);
				return (u) ? Append(u->Buffer, u->Length / sizeof(wchar_t)) : Append("(null)");
			}

			if (*ep == 'S' || (*ep == 's' && (ep[-1] == 'w' || ep[-1] == 'l')))
				return Append(va_arg(ap, wchar_t *));

			if (*ep == 'C' || (*ep == 'c' && (ep[-1] == 'w' || ep[-1] == 'l'))) {
				wchar_t c = va_arg(ap, wchar_t);
				return Append(&c, 1);
			}
		}
#endif
		size_t rc = _vsnprintf(out + i, len - i, fmt, ap);
		i = (rc == -1) ? len : i + rc;
		out[i] = 0;
		return out;
	}

	#define va_next(ap,type) (void)va_arg(ap,type)

	void NextArg(const char *s, va_list &ap) {
		const char *xp;
		if (s[0] != '%' || s[1] == '%') return;

		for (xp = s; (xp = strchr(xp, '*')) != NULL; xp++)
			va_next(ap, int);

		if (strpbrk(s, "npsSZ")) va_next(ap, void *);

		else if (strpbrk(s, "cC")) {
			if (strpbrk(s, "lwC")) va_next(ap, wchar_t);
			else va_next(ap, char);
		}

		else if ((xp = strchr(s, 'I')) != NULL) {
			if (!strncmp(xp, "I64", 3)) va_next(ap, __int64);
			else if (!strncmp(xp, "I32", 3)) va_next(ap, __int32);
			else va_next(ap, size_t);
		}

		else if ((xp = strchr(s, 'h')) != NULL) {
			if (xp[1] == 'h') va_next(ap, char);
			else va_next(ap, short);
		}

		else if ((xp = strchr(s, 'l')) != NULL) {
			if (xp[1] == 'l') va_next(ap, long long);
			else va_next(ap, long);
		}

		else va_next(ap, int);
	}

	#undef va_next

	int GetTimeUnit(__int64 &t, int units) {
		int v = (int)((t < 0 ? (-t) : t) % units);
		t /= units;
		return v;
	}

	const char *GetInfo(int n) {
		const char *cp = pInfo;

		for (int i = 0; cp && *cp && i < n; i++)
			cp += strlen(cp) + 1;

		return (cp && *cp) ? cp : "(null)";
	}

	static const char *strpbrk(const char *cp, const char *list) {
		for (const char *xp = cp; *xp; xp++)
			if (strchr(list, *xp)) return xp;
		return NULL;
	}
};


/*
 * Type definition macros
 */

#define WPP_DEFINE_ALIAS(name,defn) \
	if (!strcmp(arg, #name)) { return Expand(#defn, ap); }

#define WPP_DEFINE_TYPE(name,type,fmt) \
	if (!strcmp(arg, #name)) { return Print(#fmt, va_arg(ap, type)); }


/*
 * List definition macros
 */

#define WPP_DEFINE_LIST(name,type,fmt,...) \
	if (!strcmp(arg, #name)) { \
		type value = va_arg(ap, type); \
		const char *pHead = "", *pTail = ""; \
		switch (value) { __VA_ARGS__ default: Print(#fmt, value); } \
		return out; \
	}

#define WPP_DEFINE_STATUS(name,type,fmt,...) \
	if (!strcmp(arg, #name)) { \
		type value = va_arg(ap, type); \
		const char *pHead = "(", *pTail = ")"; \
		Print(#fmt, value); \
		switch (value) { __VA_ARGS__ } \
		return out; \
	}

#define WPP_DEFINE_VALUE(value,name) \
	case value : Print("%s%s%s", pHead, #name, pTail); break;


/*
 * Define default WPP types
 */

__inline char *CDbgPrintTrace::Expand(const char *arg, va_list &ap)
{
	if (ExpandCustom(arg, ap))
		return out;

	switch ((arg[0] << 8) | arg[1]) {
	case 'AN':
		WPP_DEFINE_TYPE(ANSTR, void *, %Z)
		break;

	case 'AR':
		WPP_DEFINE_TYPE(ARSTR, void *, %s)
		WPP_DEFINE_TYPE(ARWSTR, void *, %S)
		break;

	case 'AS':
		WPP_DEFINE_TYPE(ASTR, void *, %s)
		break;

	case 'bo':
		WPP_DEFINE_ALIAS(bool, BOOLEAN)
		WPP_DEFINE_ALIAS(bool8, BOOLEAN)
		WPP_DEFINE_LIST(bool16, unsigned short, %hu,
			WPP_DEFINE_VALUE(0, FALSE)
			WPP_DEFINE_VALUE(1, TRUE)
		)
		break;

	case 'BO':
		WPP_DEFINE_LIST(BOOLEAN, unsigned char, %hhu,
			WPP_DEFINE_VALUE(0, FALSE)
			WPP_DEFINE_VALUE(1, TRUE)
		)
		break;

	case 'CL':
		WPP_DEFINE_ALIAS(CLSID, GUID)
		break;

	case 'CS':
		WPP_DEFINE_TYPE(CSTR, void *, %Z)
		break;

	case 'da':
		WPP_DEFINE_ALIAS(datetime, TIMESTAMP)
		break;

	case 'DA':
		WPP_DEFINE_ALIAS(DATE, TIMESTAMP)
		break;

	case 'de':
		if (!strcmp(arg, "delta")) {
			__int64 t = va_arg(ap, __int64) / (10 * 1000);
			const char *sign = (t < 0) ? "-" : "";

			int msecs = GetTimeUnit(t, 1000);
			int seconds = GetTimeUnit(t, 60);
			if (!t) return Print("%s%d.%03ds", sign, seconds, msecs);

			int minutes = GetTimeUnit(t, 60);
			if (!t) return Print("%s%d:%02d.%03ds", sign, minutes, seconds, msecs);

			int hours = GetTimeUnit(t, 24);
			if (!t) return Print("%s%d:%02d:%02d.%03ds", sign, hours, minutes, seconds, msecs);

			int days = (int)((t < 0) ? (-t) : t);
			return Print("%s%d~%d:%02d:%02d.%03ds", sign, days, hours, minutes, seconds, msecs);
		}
		break;

	case 'du':
		WPP_DEFINE_ALIAS(due, TIMESTAMP)
		break;

	case 'FI':
		if (!strcmp(arg, "FILE"))
			return Append(GetInfo(0));
		break;

	case 'FL':
		if (!strcmp(arg, "FLAGS"))
			return Append(GetInfo(3));
		break;

	case 'FU':
		if (!strcmp(arg, "FUNC"))
			return Append(GetInfo(2));
		break;

	case 'gu':
		WPP_DEFINE_ALIAS(guid, GUID)
		break;

	case 'GU':
		if (!strcmp(arg, "GUID")) {
			GUID *pGuid = va_arg(ap, GUID *);

			if (!pGuid) return Append("(null)");

			return Print("%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
				pGuid->Data1, pGuid->Data2, pGuid->Data3, pGuid->Data4[0],
				pGuid->Data4[1], pGuid->Data4[2], pGuid->Data4[3], pGuid->Data4[4],
				pGuid->Data4[5], pGuid->Data4[6], pGuid->Data4[7]);
		}
		break;

	case 'HA':
		WPP_DEFINE_TYPE(HANDLE, void *, %p)
		break;

	case 'HE':
		if (!strcmp(arg, "HEXDUMP")) {
			TraceData v = va_arg(ap, TraceData);
			unsigned char *pData = (unsigned char *)v.data;
			short len = v.len;

			if (!pData || !len)
				return Append(len ? "(null)" : "<NULL>");

			for (short i = 0; i < len; i += 16) {
				char x[40], c[20];

				for (short j = 0; j < 16; j++) {
					sprintf(&x[j*2+j/4], (i+j < len) ? "%02x " : "   ", pData[i+j]);
					c[j] = (i+j >= len) ? '\0' : isprint(pData[i+j]) ? pData[i+j] : '.';
				}

				Print("\n\t%04x  %s  %.16s", i, x, c);
			}

			return Append("\n");
		}
		break;

	case 'hr':
		WPP_DEFINE_ALIAS(hresult, HRESULT)
		break;

	case 'HR':
		WPP_DEFINE_TYPE(HRESULT, int, %#010x)
		break;

	case 'II':
		WPP_DEFINE_ALIAS(IID, GUID)
		break;

	case 'ip':
		WPP_DEFINE_ALIAS(ipaddr, IPADDR)
		break;

	case 'IP':
		if (!strcmp(arg, "IPADDR")) {
			unsigned long ip = va_arg(ap, unsigned long);
			return Print("%d.%d.%d.%d", ip & 0xff,
				(ip >> 8) & 0xff, (ip >> 16) & 0xff, (ip >> 24) & 0xff);
		}
		break;

	case 'ir':
		WPP_DEFINE_LIST(irql, unsigned char, %hhu,
			WPP_DEFINE_VALUE(0, Low)
			WPP_DEFINE_VALUE(1, APC)
			WPP_DEFINE_VALUE(2, DPC)
			)
		break;

	case 'LE':
		if (!strcmp(arg, "LEVEL"))
			return Append(GetInfo(4));
		break;

	case 'LI':
		if (!strcmp(arg, "LINE"))
			return Append(GetInfo(1));

		WPP_DEFINE_ALIAS(LIBID, GUID)
		break;

	case 'ND':
		WPP_DEFINE_TYPE(NDIS_STATUS, int, %#010x)
		break;

	case 'NT':
		WPP_DEFINE_ALIAS(NTerror, WINERROR)
		break;

	case 'OB':
		WPP_DEFINE_TYPE(OBYTE, unsigned char, %#hho)
		break;

	case 'OI':
		WPP_DEFINE_TYPE(OINT, int, %#o)
		WPP_DEFINE_TYPE(OINT64, __int64, %#I64o)
		break;

	case 'OL':
		WPP_DEFINE_TYPE(OLONG, long, %#lo)
		WPP_DEFINE_TYPE(OLONGPTR, LONG_PTR, %#Io)
		break;

	case 'OS':
		WPP_DEFINE_TYPE(OSHORT, unsigned short, %#ho)
		break;

	case 'pn':
		WPP_DEFINE_LIST(pnpmj, unsigned char, %hhu,
			WPP_DEFINE_VALUE(0, IRP_MJ_CREATE)
			WPP_DEFINE_VALUE(1, IRP_MJ_CREATE_NAMED_PIPE)
			WPP_DEFINE_VALUE(2, IRP_MJ_CLOSE)
			WPP_DEFINE_VALUE(3, IRP_MJ_READ)
			WPP_DEFINE_VALUE(4, IRP_MJ_WRITE)
			WPP_DEFINE_VALUE(5, IRP_MJ_QUERY_INFORMATION)
			WPP_DEFINE_VALUE(6, IRP_MJ_SET_INFORMATION)
			WPP_DEFINE_VALUE(7, IRP_MJ_QUERY_EA)
			WPP_DEFINE_VALUE(8, IRP_MJ_SET_EA)
			WPP_DEFINE_VALUE(9, IRP_MJ_FLUSH_BUFFERS)
			WPP_DEFINE_VALUE(10, IRP_MJ_QUERY_VOLUME_INFORMATION)
			WPP_DEFINE_VALUE(11, IRP_MJ_SET_VOLUME_INFORMATION)
			WPP_DEFINE_VALUE(12, IRP_MJ_DIRECTORY_CONTROL)
			WPP_DEFINE_VALUE(13, IRP_MJ_FILE_SYSTEM_CONTROL)
			WPP_DEFINE_VALUE(14, IRP_MJ_DEVICE_CONTROL)
			WPP_DEFINE_VALUE(15, IRP_MJ_INTERNAL_DEVICE_CONTROL)
			WPP_DEFINE_VALUE(16, IRP_MJ_SHUTDOWN)
			WPP_DEFINE_VALUE(17, IRP_MJ_LOCK_CONTROL)
			WPP_DEFINE_VALUE(18, IRP_MJ_CLEANUP)
			WPP_DEFINE_VALUE(19, IRP_MJ_CREATE_MAILSLOT)
			WPP_DEFINE_VALUE(20, IRP_MJ_QUERY_SECURITY)
			WPP_DEFINE_VALUE(21, IRP_MJ_SET_SECURITY)
			WPP_DEFINE_VALUE(22, IRP_MJ_POWER)
			WPP_DEFINE_VALUE(23, IRP_MJ_SYSTEM_CONTROL)
			WPP_DEFINE_VALUE(24, IRP_MJ_DEVICE_CHANGE)
			WPP_DEFINE_VALUE(25, IRP_MJ_QUERY_QUOTA)
			WPP_DEFINE_VALUE(26, IRP_MJ_SET_QUOTA)
			WPP_DEFINE_VALUE(27, IRP_MJ_PNP)
			)

		WPP_DEFINE_LIST(pnpmn, unsigned char, %hhu,
			WPP_DEFINE_VALUE(0, IRP_MN_START_DEVICE)
			WPP_DEFINE_VALUE(1, IRP_MN_QUERY_REMOVE_DEVICE)
			WPP_DEFINE_VALUE(2, IRP_MN_REMOVE_DEVICE)
			WPP_DEFINE_VALUE(3, IRP_MN_CANCEL_REMOVE_DEVICE)
			WPP_DEFINE_VALUE(4, IRP_MN_STOP_DEVICE)
			WPP_DEFINE_VALUE(5, IRP_MN_QUERY_STOP_DEVICE)
			WPP_DEFINE_VALUE(6, IRP_MN_CANCEL_STOP_DEVICE)
			WPP_DEFINE_VALUE(7, IRP_MN_QUERY_DEVICE_RELATIONS)
			WPP_DEFINE_VALUE(8, IRP_MN_QUERY_INTERFACE)
			WPP_DEFINE_VALUE(9, IRP_MN_QUERY_CAPABILITIES)
			WPP_DEFINE_VALUE(10, IRP_MN_QUERY_RESOURCES)
			WPP_DEFINE_VALUE(11, IRP_MN_QUERY_RESOURCE_REQUIREMENTS)
			WPP_DEFINE_VALUE(12, IRP_MN_QUERY_DEVICE_TEXT)
			WPP_DEFINE_VALUE(13, IRP_MN_FILTER_RESOURCE_REQUIREMENTS)
			WPP_DEFINE_VALUE(14, IRP_MN_PNP_14)
			WPP_DEFINE_VALUE(15, IRP_MN_READ_CONFIG)
			WPP_DEFINE_VALUE(16, IRP_MN_WRITE_CONFIG)
			WPP_DEFINE_VALUE(17, IRP_MN_EJECT)
			WPP_DEFINE_VALUE(18, IRP_MN_SET_LOCK)
			WPP_DEFINE_VALUE(19, IRP_MN_QUERY_ID)
			WPP_DEFINE_VALUE(20, IRP_MN_QUERY_PNP_DEVICE_STATE)
			WPP_DEFINE_VALUE(21, IRP_MN_QUERY_BUS_INFORMATION)
			WPP_DEFINE_VALUE(22, IRP_MN_DEVICE_USAGE_NOTIFICATION)
			WPP_DEFINE_VALUE(23, IRP_MN_SURPRISE_REMOVAL)
			)
		break;

	case 'po':
		WPP_DEFINE_ALIAS(port, PORT)
		break;

	case 'PO':
		WPP_DEFINE_TYPE(PORT, unsigned short, %hu)
		break;

	case 'PT':
		WPP_DEFINE_TYPE(PTR, void *, %p)
		break;

	case 'SB':
		WPP_DEFINE_TYPE(SBYTE, signed char, %hhd)
		break;

	case 'SC':
		WPP_DEFINE_TYPE(SCHAR, unsigned char, %c)
		break;

	case 'SI':
		WPP_DEFINE_TYPE(SINT, int, %d)
		WPP_DEFINE_TYPE(SINT64, __int64, %I64d)
		break;

	case 'SL':
		WPP_DEFINE_TYPE(SLONG, long, %ld)
		WPP_DEFINE_TYPE(SLONGPTR, LONG_PTR, %Id)
		break;

	case 'SP':
		if (!strcmp(arg, "SPACE")) 
			return Append(" ");
		break;

	case 'SS':
		WPP_DEFINE_TYPE(SSHORT, short, %hd)
		break;

	case 'st':
		WPP_DEFINE_ALIAS(status, STATUS)
		break;

	case 'ST':
		WPP_DEFINE_STATUS(STATUS, unsigned long, %#010x,
			WPP_DEFINE_VALUE(0, STATUS_SUCCESS)
			WPP_DEFINE_VALUE(0x80L, STATUS_ABANDONED)
			WPP_DEFINE_VALUE(0x101L, STATUS_ALERTED)
			WPP_DEFINE_VALUE(0x102L, STATUS_TIMEOUT)
			WPP_DEFINE_VALUE(0x103L, STATUS_PENDING)
			WPP_DEFINE_VALUE(0x104L, STATUS_REPARSE)
			WPP_DEFINE_VALUE(0x105L, STATUS_MORE_ENTRIES)
			WPP_DEFINE_VALUE(0x106L, STATUS_SOME_NOT_MAPPED)
			WPP_DEFINE_VALUE(0x117L, STATUS_BUFFER_ALL_ZEROS)
			WPP_DEFINE_VALUE(0x40000000L, STATUS_OBJECT_NAME_EXISTS)
			WPP_DEFINE_VALUE(0x80000005L, STATUS_BUFFER_OVERFLOW)
			WPP_DEFINE_VALUE(0x80000006L, STATUS_NO_MORE_FILES)
			WPP_DEFINE_VALUE(0x8000000DL, STATUS_PARTIAL_COPY)
			WPP_DEFINE_VALUE(0x80000010L, STATUS_DEVICE_OFF_LINE)
			WPP_DEFINE_VALUE(0x80000011L, STATUS_DEVICE_BUSY)
			WPP_DEFINE_VALUE(0x8000001AL, STATUS_NO_MORE_ENTRIES)
			WPP_DEFINE_VALUE(0x8000001CL, STATUS_MEDIA_CHANGED)
			WPP_DEFINE_VALUE(0x8000001DL, STATUS_BUS_RESET)
			WPP_DEFINE_VALUE(0x8000001EL, STATUS_END_OF_MEDIA)
			WPP_DEFINE_VALUE(0x8000001FL, STATUS_BEGINNING_OF_MEDIA)
			WPP_DEFINE_VALUE(0x80000022L, STATUS_NO_DATA_DETECTED)
			WPP_DEFINE_VALUE(0xC0000001L, STATUS_UNSUCCESSFUL)
			WPP_DEFINE_VALUE(0xC0000002L, STATUS_NOT_IMPLEMENTED)
			WPP_DEFINE_VALUE(0xC0000004L, STATUS_INFO_LENGTH_MISMATCH)
			WPP_DEFINE_VALUE(0xC0000005L, STATUS_ACCESS_VIOLATION)
			WPP_DEFINE_VALUE(0xC0000008L, STATUS_INVALID_HANDLE)
			WPP_DEFINE_VALUE(0xC000000DL, STATUS_INVALID_PARAMETER)
			WPP_DEFINE_VALUE(0xC000000EL, STATUS_NO_SUCH_DEVICE)
			WPP_DEFINE_VALUE(0xC000000FL, STATUS_NO_SUCH_FILE)
			WPP_DEFINE_VALUE(0xC0000010L, STATUS_INVALID_DEVICE_REQUEST)
			WPP_DEFINE_VALUE(0xC0000011L, STATUS_END_OF_FILE)
			WPP_DEFINE_VALUE(0xC0000012L, STATUS_WRONG_VOLUME)
			WPP_DEFINE_VALUE(0xC0000013L, STATUS_NO_MEDIA_IN_DEVICE)
			WPP_DEFINE_VALUE(0xC0000014L, STATUS_UNRECOGNIZED_MEDIA)
			WPP_DEFINE_VALUE(0xC0000015L, STATUS_NONEXISTENT_SECTOR)
			WPP_DEFINE_VALUE(0xC0000016L, STATUS_MORE_PROCESSING_REQUIRED)
			WPP_DEFINE_VALUE(0xC0000017L, STATUS_NO_MEMORY)
			WPP_DEFINE_VALUE(0xC0000018L, STATUS_CONFLICTING_ADDRESSES)
			WPP_DEFINE_VALUE(0xC0000022L, STATUS_ACCESS_DENIED)
			WPP_DEFINE_VALUE(0xC0000023L, STATUS_BUFFER_TOO_SMALL)
			WPP_DEFINE_VALUE(0xC0000024L, STATUS_OBJECT_TYPE_MISMATCH)
			WPP_DEFINE_VALUE(0xC000002AL, STATUS_NOT_LOCKED)
			WPP_DEFINE_VALUE(0xC0000030L, STATUS_INVALID_PARAMETER_MIX)
			WPP_DEFINE_VALUE(0xC0000033L, STATUS_OBJECT_NAME_INVALID)
			WPP_DEFINE_VALUE(0xC0000034L, STATUS_OBJECT_NAME_NOT_FOUND)
			WPP_DEFINE_VALUE(0xC0000035L, STATUS_OBJECT_NAME_COLLISION)
			WPP_DEFINE_VALUE(0xC0000037L, STATUS_PORT_DISCONNECTED)
			WPP_DEFINE_VALUE(0xC0000038L, STATUS_DEVICE_ALREADY_ATTACHED)
			WPP_DEFINE_VALUE(0xC0000039L, STATUS_OBJECT_PATH_INVALID)
			WPP_DEFINE_VALUE(0xC000003AL, STATUS_OBJECT_PATH_NOT_FOUND)
			WPP_DEFINE_VALUE(0xC000003CL, STATUS_DATA_OVERRUN)
			WPP_DEFINE_VALUE(0xC000003EL, STATUS_DATA_ERROR)
			WPP_DEFINE_VALUE(0xC0000043L, STATUS_SHARING_VIOLATION)
			WPP_DEFINE_VALUE(0xC0000044L, STATUS_QUOTA_EXCEEDED)
			WPP_DEFINE_VALUE(0xC000007FL, STATUS_DISK_FULL)
			WPP_DEFINE_VALUE(0xC0000098L, STATUS_FILE_INVALID)
			WPP_DEFINE_VALUE(0xC000009AL, STATUS_INSUFFICIENT_RESOURCES)
			WPP_DEFINE_VALUE(0xC000009CL, STATUS_DEVICE_DATA_ERROR)
			WPP_DEFINE_VALUE(0xC000009DL, STATUS_DEVICE_NOT_CONNECTED)
			WPP_DEFINE_VALUE(0xC000009EL, STATUS_DEVICE_POWER_FAILURE)
			WPP_DEFINE_VALUE(0xC00000A0L, STATUS_MEMORY_NOT_ALLOCATED)
			WPP_DEFINE_VALUE(0xC00000A2L, STATUS_MEDIA_WRITE_PROTECTED)
			WPP_DEFINE_VALUE(0xC00000A3L, STATUS_DEVICE_NOT_READY)
			WPP_DEFINE_VALUE(0xC00000AEL, STATUS_PIPE_BUSY)
			WPP_DEFINE_VALUE(0xC00000AFL, STATUS_ILLEGAL_FUNCTION)
			WPP_DEFINE_VALUE(0xC00000B5L, STATUS_IO_TIMEOUT)
			WPP_DEFINE_VALUE(0xC00000BBL, STATUS_NOT_SUPPORTED)
			WPP_DEFINE_VALUE(0xC00000C0L, STATUS_DEVICE_DOES_NOT_EXIST)
			WPP_DEFINE_VALUE(0xC00000C2L, STATUS_ADAPTER_HARDWARE_ERROR)
			WPP_DEFINE_VALUE(0xC00000D0L, STATUS_REQUEST_NOT_ACCEPTED)
			WPP_DEFINE_VALUE(0xC00000E5L, STATUS_INTERNAL_ERROR)
			WPP_DEFINE_VALUE(0xC00000E9L, STATUS_UNEXPECTED_IO_ERROR)
			WPP_DEFINE_VALUE(0xC00000EFL, STATUS_INVALID_PARAMETER_1)
			WPP_DEFINE_VALUE(0xC00000F0L, STATUS_INVALID_PARAMETER_2)
			WPP_DEFINE_VALUE(0xC00000F1L, STATUS_INVALID_PARAMETER_3)
			WPP_DEFINE_VALUE(0xC00000F2L, STATUS_INVALID_PARAMETER_4)
			WPP_DEFINE_VALUE(0xC00000F3L, STATUS_INVALID_PARAMETER_5)
			WPP_DEFINE_VALUE(0xC00000F4L, STATUS_INVALID_PARAMETER_6)
			WPP_DEFINE_VALUE(0xC00000F5L, STATUS_INVALID_PARAMETER_7)
			WPP_DEFINE_VALUE(0xC00000F6L, STATUS_INVALID_PARAMETER_8)
			WPP_DEFINE_VALUE(0xC00000F7L, STATUS_INVALID_PARAMETER_9)
			WPP_DEFINE_VALUE(0xC00000F8L, STATUS_INVALID_PARAMETER_10)
			WPP_DEFINE_VALUE(0xC0000101L, STATUS_DIRECTORY_NOT_EMPTY)
			WPP_DEFINE_VALUE(0xC0000120L, STATUS_CANCELLED)
			WPP_DEFINE_VALUE(0xC0000173L, STATUS_DEVICE_NOT_PARTITIONED)
			WPP_DEFINE_VALUE(0xC0000178L, STATUS_NO_MEDIA)
			WPP_DEFINE_VALUE(0xC0000182L, STATUS_DEVICE_CONFIGURATION_ERROR)
			WPP_DEFINE_VALUE(0xC0000183L, STATUS_DRIVER_INTERNAL_ERROR)
			WPP_DEFINE_VALUE(0xC0000184L, STATUS_INVALID_DEVICE_STATE)
			WPP_DEFINE_VALUE(0xC0000185L, STATUS_IO_DEVICE_ERROR)
			WPP_DEFINE_VALUE(0xC0000186L, STATUS_DEVICE_PROTOCOL_ERROR)
			WPP_DEFINE_VALUE(0xC0000188L, STATUS_LOG_FILE_FULL)
			WPP_DEFINE_VALUE(0xC0000194L, STATUS_POSSIBLE_DEADLOCK)
			WPP_DEFINE_VALUE(0xC0000206L, STATUS_INVALID_BUFFER_SIZE)
			WPP_DEFINE_VALUE(0xC000020DL, STATUS_CONNECTION_RESET)
			WPP_DEFINE_VALUE(0xC0000225L, STATUS_NOT_FOUND)
			WPP_DEFINE_VALUE(0xC000022DL, STATUS_RETRY)
			WPP_DEFINE_VALUE(0xC0000237L, STATUS_GRACEFUL_DISCONNECT)
			)
		break;

	case 'sy':
		WPP_DEFINE_LIST(sysctrl, unsigned char, %hhu,
			WPP_DEFINE_VALUE(0, IRP_MN_QUERY_ALL_DATA)
			WPP_DEFINE_VALUE(1, IRP_MN_QUERY_SINGLE_INSTANCE)
			WPP_DEFINE_VALUE(2, IRP_MN_CHANGE_SINGLE_INSTANCE)
			WPP_DEFINE_VALUE(3, IRP_MN_CHANGE_SINGLE_ITEM)
			WPP_DEFINE_VALUE(4, IRP_MN_ENABLE_EVENTS)
			WPP_DEFINE_VALUE(5, IRP_MN_DISABLE_EVENTS)
			WPP_DEFINE_VALUE(6, IRP_MN_ENABLE_COLLECTION)
			WPP_DEFINE_VALUE(7, IRP_MN_DISABLE_COLLECTION)
			WPP_DEFINE_VALUE(8, IRP_MN_REGINFO)
			WPP_DEFINE_VALUE(9, IRP_MN_EXECUTE_METHOD)
			WPP_DEFINE_VALUE(10, IRP_MN_Reserved_0a)
			WPP_DEFINE_VALUE(11, IRP_MN_REGINFO_EX)
			)
		break;

	case 'ti':
		WPP_DEFINE_ALIAS(time, TIMESTAMP)
		break;

	case 'TI':
		if (!strcmp(arg, "TIMESTAMP")) {
#ifdef _DCS_KERNEL_
			LARGE_INTEGER v;
			TIME_FIELDS t;

			v.QuadPart = va_arg(ap, unsigned __int64);
			RtlTimeToTimeFields(&v, &t);

			return Print("%02hu/%02hu/%04hu-%02hu:%02hu:%02hu.%03hu",
				t.Month, t.Day, t.Year, t.Hour, t.Minute, t.Second, t.Milliseconds);
#else
			unsigned __int64 stamp = va_arg(ap, unsigned __int64);
			SYSTEMTIME t;
			FILETIME v;

			v.dwLowDateTime = (DWORD)(stamp & 0xFFFFFFFF);
			v.dwHighDateTime = (DWORD)(stamp >> 32);

			if (!FileTimeToSystemTime(&v, &t))
				return Print("%#I64x", stamp);
		
			return Print("%02hu/%02hu/%04hu-%02hu:%02hu:%02hu.%03hu",
				t.wMonth, t.wDay, t.wYear, t.wHour, t.wMinute, t.wSecond, t.wMilliseconds);
#endif
		}

		WPP_DEFINE_ALIAS(TIME, TIMESTAMP)
		break;

	case 'UB':
		WPP_DEFINE_TYPE(UBYTE, unsigned char, %hhu)
		break;

	case 'UC':
		WPP_DEFINE_TYPE(UCHAR, unsigned char, %c)
		break;

	case 'UI':
		WPP_DEFINE_TYPE(UINT, unsigned int, %u)
		WPP_DEFINE_TYPE(UINT64, unsigned __int64, %I64u)
		break;

	case 'UL':
		WPP_DEFINE_TYPE(ULONG, unsigned long, %lu)
		WPP_DEFINE_TYPE(ULONGPTR, ULONG_PTR, %Iu)
		break;

	case 'US':
		WPP_DEFINE_TYPE(USTR, void *, %wZ)
		WPP_DEFINE_TYPE(USHORT, unsigned short, %hu)
		break;

	case 'WA':
		WPP_DEFINE_ALIAS(WAITTIME, TIMESTAMP)
		break;

	case 'wi':
		WPP_DEFINE_ALIAS(winerr, WINERROR)
		break;

	case 'WI':
		WPP_DEFINE_TYPE(WINERROR, unsigned int, %d)
		break;

	case 'WS':
		WPP_DEFINE_TYPE(WSTR, void *, %S)
		break;

	case 'XB':
		WPP_DEFINE_TYPE(XBYTE, unsigned char, %#04hhx)
		break;

	case 'XI':
		WPP_DEFINE_TYPE(XINT, int, %#010x)
		WPP_DEFINE_TYPE(XINT64, __int64, %#I64x)
		break;

	case 'XL':
		WPP_DEFINE_TYPE(XLONG, long, %#010lx)
		WPP_DEFINE_TYPE(XLONGPTR, LONG_PTR, %#Ix)
		break;

	case 'XS':
		WPP_DEFINE_TYPE(XSHORT, unsigned short, %#06hx)
		break;

	case 'XX':
		WPP_DEFINE_TYPE(XXINT64, __int64, %#I64X)
		break;
	}

	return Print("%#x", va_arg(ap, int));
}


/*
 * DbgPrintTrace info string
 */

#ifndef __GNUC__
#define WPPTRACEINFO(lv,flg) \
	(__FILE__ "\0" _DCS_TRACE_STR(__LINE__) "\0" __FUNCTION__ "\0" #flg "\0" #lv "\0")
#else
#define WPPTRACEINFO(lv,flg) \
	(__FILE__ "\0" _DCS_TRACE_STR(__LINE__) "\0")
#endif


/*
 * DbgPrintTraceMsg - Tracing output.
 */

__inline void DbgPrintTraceMsg(unsigned long level,	const char *info, const char *fmt, ...)
{
	if (DbgQueryDebugFilterState(DPFLTR_DEFAULT_ID, level) != TRUE || !fmt)
		return;

	va_list ap;
	va_start(ap, fmt);

	const char *cp = CDbgPrintTrace::isPassive() ? fmt : "%!";

	for (; (cp = strchr(cp, '!')) != NULL; cp++)
		if (cp != fmt && cp[-1] == '%') {
			CDbgPrintTrace out(info);
			const char *ip = fmt;

			for (const char *xp; (xp = strchr(ip, '%')) != NULL; ip = xp) {
				if (xp != ip) out.Append(ip, xp - ip);
				out.Append(xp, ap);
			}

			DbgPrintEx(DPFLTR_DEFAULT_ID, level, "%s", out.Append(ip));
			return (void)va_end(ap);
		}

	vDbgPrintEx(DPFLTR_DEFAULT_ID, level, fmt, ap);
	va_end(ap);
}


#endif	/* _DCS_TRACEDBG_H_ */

```

`inc/TraceDefs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 */

/*
 * Trace definitions.
 */

#ifndef _DCS_TRACEDEFS_H_
#define _DCS_TRACEDEFS_H_

#include <stdarg.h>

#ifdef __cplusplus
namespace Tracing {
#endif


/*
 * Determine type of tracing
 */

#if defined(WPP) || defined(RUN_WPP)
#define _DCS_TRACE_WPP_
#endif

#ifdef _DCS_TRACE_WPP_
#undef _DCS_TRACE_DBG_
#endif

#if !defined(_DCS_TRACE_WPP_) && defined(_DCS_KERNEL_) && defined(_DEBUG)
#define _DCS_TRACE_DBG_
#endif

#if defined(_DCS_TRACE_DBG_) || (defined(_DCS_TRACE_WPP_) && defined(_DEBUG))
#define _DCS_EXPAND_WPP_
#endif


/*
 * Define name
 */

#ifndef WPPNAME
#error WPPNAME must be defined before including TraceDefs.h
#endif

#define _DCS_TRACE_QUOTE(s)		#s
#define _DCS_TRACE_STR(s)		_DCS_TRACE_QUOTE(s)

#define WPPNAMESTR				_DCS_TRACE_STR(WPPNAME)
#define WPPDBGPREFIX			WPPNAMESTR ": "


/*
 * Define WPP Trace levels
 */

#undef TRACE_LEVEL_FATAL
#undef TRACE_LEVEL_ERROR
#undef TRACE_LEVEL_WARNING
#undef TRACE_LEVEL_INFORMATION
#undef TRACE_LEVEL_VERBOSE
#undef TRACE_LEVEL_NOISY

static const int TRACE_LEVEL_FATAL			= 1;
static const int TRACE_LEVEL_ERROR			= 2;
static const int TRACE_LEVEL_WARNING		= 3;
static const int TRACE_LEVEL_INFORMATION	= 4;
static const int TRACE_LEVEL_VERBOSE		= 5;
static const int TRACE_LEVEL_NOISY			= 8;

static const int TRACE_FATAL		= TRACE_LEVEL_FATAL;
static const int TRACE_ERROR		= TRACE_LEVEL_ERROR;
static const int TRACE_WARNING		= TRACE_LEVEL_WARNING;
static const int TRACE_INFO			= TRACE_LEVEL_INFORMATION;
static const int TRACE_VERBOSE		= TRACE_LEVEL_VERBOSE;
static const int TRACE_NOISY		= TRACE_LEVEL_NOISY;


/*
 * Define DbgPrint levels
 */

#ifndef DPFLTR_ERROR_LEVEL
#define DPFLTR_ERROR_LEVEL			0
#define DPFLTR_WARNING_LEVEL		1
#define DPFLTR_TRACE_LEVEL			2
#define DPFLTR_INFO_LEVEL			3
#endif

#define DPFLTR_VERBOSE_LEVEL		4
#define DPFLTR_NOISY_LEVEL			8


/*
 * Define Level and Flag filters.
 */

#ifndef WPPLEVEL
#define WPPLEVEL	TRACE_LEVEL_INFORMATION
#endif

#ifndef WPPFLAGS
#define WPPFLAGS	0xffffffff
#endif


/*
 * Defines for WPP initialisation
 */

#ifndef _DCS_TRACE_WPP_
#undef WPP_DEFINE_BIT
#define WPP_DEFINE_BIT(x) WPP_##x,

#undef WPP_DEFINE_CONTROL_GUID
#define WPP_DEFINE_CONTROL_GUID(name,guid,...) enum { __VA_ARGS__ };

#undef WPP_INIT_TRACING
#define WPP_INIT_TRACING(...)	((void)(0, __VA_ARGS__))

#undef WPP_CLEANUP
#define WPP_CLEANUP(...)	((void)(0, __VA_ARGS__))
#endif

#undef WPP_DEFINE_DEFAULT_BITS
#define WPP_DEFINE_DEFAULT_BITS                                        \
        WPP_DEFINE_BIT(MYDRIVER_ALL_INFO)                              \
        WPP_DEFINE_BIT(TRACE_KDPRINT)                                  \
        WPP_DEFINE_BIT(DEFAULT_TRACE_LEVEL)


/*
 * Map WPP levels to DbgPrint levels
 */

__inline unsigned long TraceLevelToDbg(unsigned long v) {
	return	v <= TRACE_LEVEL_FATAL ? DPFLTR_ERROR_LEVEL :
			v == TRACE_LEVEL_ERROR ? DPFLTR_ERROR_LEVEL :
			v == TRACE_LEVEL_WARNING ? DPFLTR_WARNING_LEVEL :
			v == TRACE_LEVEL_INFORMATION ? DPFLTR_INFO_LEVEL :
			v == TRACE_LEVEL_VERBOSE ? DPFLTR_VERBOSE_LEVEL :
			v == TRACE_LEVEL_NOISY ? DPFLTR_NOISY_LEVEL : DPFLTR_TRACE_LEVEL;
}

__inline unsigned long DbgLevelToTrace(unsigned long v) {
	return	v == DPFLTR_ERROR_LEVEL ? TRACE_LEVEL_ERROR :
			v == DPFLTR_WARNING_LEVEL ? TRACE_LEVEL_WARNING :
			v == DPFLTR_TRACE_LEVEL ? TRACE_LEVEL_INFORMATION :
			v == DPFLTR_INFO_LEVEL ? TRACE_LEVEL_INFORMATION :
			v == DPFLTR_VERBOSE_LEVEL ? TRACE_LEVEL_VERBOSE :
			v == DPFLTR_NOISY_LEVEL ? TRACE_LEVEL_NOISY : TRACE_LEVEL_VERBOSE;
}


/*
 * Define trace types
 */

struct TraceData {
   const void *data;
   short len;
   TraceData(const void *d, size_t l) : data(d), len((short)l) { }
   template<class T> TraceData(const T *d) : data(d), len((short)sizeof(T)) { }
};

#define WPP_LOGDATA(data,len)	TraceData(data,len)


/*
 * User Level compatibility
 */

#ifndef _DCS_KERNEL_
#ifdef _DCS_TRACE_DBG_
#define DbgPrint(fmt,...) (printf(fmt, __VA_ARGS__), 0)
#define DbgPrintEx(id,level,fmt,...) \
	(((level) <= TraceLevelToDbg(WPPLEVEL)) ? (printf(fmt, __VA_ARGS__), 0) : 0)
#define vDbgPrintEx(id,level,fmt,ap) \
	(((level) <= TraceLevelToDbg(WPPLEVEL)) ? (vprintf(fmt, ap), 0) : 0)
#define DbgQueryDebugFilterState(id,level) ((level) <= TraceLevelToDbg(WPPLEVEL))
#else
#define DbgPrint(...) (0)
#define DbgPrintEx(...) (0)
#define vDbgPrintEx(...) (0)
#define vDbgPrintExWithPrefix(...) (0)
#define DbgQueryDebugFilterState(...) (0)
#endif
#undef KdPrint
#define KdPrint(x) DbgPrint x
#undef KdPrintEx
#define KdPrintEx(x) DbgPrintEx x
#endif


/*
 * Convert Trace to DbgPrint
 */

#ifndef _DCS_TRACE_WPP_
#ifdef _DCS_TRACE_DBG_
#define TraceEvents(level,flag,fmt,...) ((WPPFLAGS & (1 << (WPP_##flag))) ? \
	DbgPrintTraceMsg(TraceLevelToDbg(level), WPPTRACEINFO(level,flag), WPPDBGPREFIX fmt "\n", __VA_ARGS__) : (void)0)

#define Trace(level,fmt,...) \
	TraceEvents(level, MYDRIVER_ALL_INFO, fmt, __VA_ARGS__)

#define TraceEventsWithData(level,flag,data,len,fmt,...) ((WPPFLAGS & (1 << (WPP_##flag))) ? \
	DbgPrintTraceMsg(TraceLevelToDbg(level), WPPTRACEINFO(level,flag), WPPDBGPREFIX fmt " Data: %!HEXDUMP!\n", __VA_ARGS__, \
		WPP_LOGDATA(data,len)) : (void)0)

#define TraceWithData(level,data,len,fmt,...) \
	TraceEventsWithData(level, MYDRIVER_ALL_INFO, data, len, fmt, __VA_ARGS__)
#else
__inline void Trace(...) { }
__inline void TraceEvents(...) { }
__inline void TraceWithData(...) { }
__inline void TraceEventsWithData(...) { }
#endif
#endif


/*
 * SendTrace definitions
 */

#ifndef _DCS_TRACE_WPP_
#define SendTraceEvents(flags, msgid, level, msg, ...) \
	SendEvent(flags, msgid, __VA_ARGS__), \
	TraceEvents(level, flags, msg, __VA_ARGS__)

#define SendTrace(msgid, level, msg, ...) \
	SendTraceEvents(DEFAULT_TRACE_LEVEL, msgid, level, msg, __VA_ARGS__)

#define SendTraceEventsWithData(flags, msgid, level, data, len, msg, ...) \
	SendEventWithData(flags, msgid, data, len, __VA_ARGS__), \
	TraceEventsWithData(level, flags, data, len, msg, __VA_ARGS__)

#define SendTraceWithData(msgid, level, data, len, msg,...) \
	SendTraceEventsWithData(DEFAULT_TRACE_LEVEL, msgid, level, data, len, msg, __VA_ARGS__)
#endif


/*
 * DbgPrint functions
 */

__inline void DbgPrintDebugMsg(unsigned long level, int, char *fmt, ...)
{
	(void)level;
	va_list ap;
	va_start(ap, fmt);
	vDbgPrintEx(DPFLTR_DEFAULT_ID, level, fmt, ap);
	va_end(ap);
}


/*
 * DbgPrintTrace functions
 */

#if defined(_DCS_EXPAND_WPP_)
#include <TraceDbg.h>
#else
#define DbgPrintTraceMsg	DbgPrintDebugMsg
#endif


/*
 * Kernel compatibility
 */

#ifdef _DCS_KERNEL_
#define printf(fmt,...) KdPrint((fmt,__VA_ARGS__))
#endif


/*
 * Namespace compatibility
 */

#ifdef __cplusplus
}
using namespace Tracing;
#endif

#endif	/* _DCS_TRACEDEFS_H_ */


```

`inc/TraceWpp.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 */

/*
 * Trace definitions for WPP.
 */

#ifdef __cplusplus
namespace Tracing {
#endif

#ifndef _DCS_TRACEWPP_H_
#define _DCS_TRACEWPP_H_


#define WPPNULLFUNC(...)	(0)

#ifndef WPPTRACEINFO
#define WPPTRACEINFO(level,flag)	(0)
#endif

#define WPPNULLDATA(...)
#define WPPTRACEDATA(data,len)		,WPP_LOGDATA(data,len)


/*
 * Trace() definitions
 */

#define WPP_EX_FLAG_LEVEL(flag, level) \
	TraceLevelToDbg(level), WPPNULLFUNC, 0, 0, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flag), WPPNULLDATA, 0, 0, WPPDBGPREFIX, "\n"

#define WPP_FLAG_LEVEL_LOGGER(flag, level) \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_LEVEL_ENABLED(flag, lvl) \
    (WPP_LEVEL_ENABLED(flag) && WPP_CONTROL(WPP_BIT_ ## flag).Level >= lvl)

#define WPP_RECORDER_FLAG_LEVEL_ARGS(flag, lvl) \
	WPP_CONTROL(WPP_BIT_ ## flag).AutoLogContext, lvl, WPP_BIT_ ## flag

#define WPP_RECORDER_FLAG_LEVEL_FILTER(flag, lvl) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flag).AutoLogVerboseEnabled)


/*
 * TraceEvents() definitions
 */

#define WPP_EX_LEVEL_FLAGS(level, flags) \
	TraceLevelToDbg(level), WPPNULLFUNC, 0, 0, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flags), WPPNULLDATA, 0, 0, WPPDBGPREFIX, "\n"

#define WPP_LEVEL_FLAGS_LOGGER(lvl, flags) \
    WPP_LEVEL_LOGGER(flags)
               
#define WPP_LEVEL_FLAGS_ENABLED(lvl, flags) \
    (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

#define WPP_RECORDER_LEVEL_FLAGS_ARGS(lvl, flags) \
	WPP_CONTROL(WPP_BIT_ ## flags).AutoLogContext, lvl, WPP_BIT_ ## flags

#define WPP_RECORDER_LEVEL_FLAGS_FILTER(lvl, flags) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flags).AutoLogVerboseEnabled)


/*
 * TraceWithData() definitions
 */

#define WPP_EX_FLAG_LEVEL_DATA_LEN(flag, level, data, len) \
	TraceLevelToDbg(level), WPPNULLFUNC, 0, 0, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flag), WPPTRACEDATA, data, len, WPPDBGPREFIX, " Data: %!HEXDUMP!\n"

#define WPP_FLAG_LEVEL_DATA_LEN_LOGGER(flag, level, data, len) \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_LEVEL_DATA_LEN_ENABLED(flag, lvl, data, len) \
    (WPP_LEVEL_ENABLED(flag) && WPP_CONTROL(WPP_BIT_ ## flag).Level >= lvl)

#define WPP_RECORDER_FLAG_LEVEL_DATA_LEN_ARGS(flag, lvl, data, len) \
	WPP_CONTROL(WPP_BIT_ ## flag).AutoLogContext, lvl, WPP_BIT_ ## flag

#define WPP_RECORDER_FLAG_LEVEL_DATA_LEN_FILTER(flag, lvl, data, len) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flag).AutoLogVerboseEnabled)


/*
 * TraceEventsWithData() definitions
 */

#define WPP_EX_LEVEL_FLAGS_DATA_LEN(level, flags, data, len) \
	TraceLevelToDbg(level), WPPNULLFUNC, 0, 0, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flags), WPPTRACEDATA, data, len, WPPDBGPREFIX, " Data: %!HEXDUMP!\n"

#define WPP_LEVEL_FLAGS_DATA_LEN_LOGGER(lvl, flags, data, len) \
    WPP_LEVEL_LOGGER(flags)
               
#define WPP_LEVEL_FLAGS_DATA_LEN_ENABLED(lvl, flags, data, len) \
    (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

#define WPP_RECORDER_LEVEL_FLAGS_DATA_LEN_ARGS(lvl, flags, data, len) \
	WPP_CONTROL(WPP_BIT_ ## flags).AutoLogContext, lvl, WPP_BIT_ ## flags

#define WPP_RECORDER_LEVEL_FLAGS_DATA_LEN_FILTER(lvl, flags, data, len) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flags).AutoLogVerboseEnabled)


/*
 * SendTrace() definitions
 */

#define WPP_EX_FLAG_MSGID_LEVEL(flag, msgid, level) \
	TraceLevelToDbg(level), SendEventWithData, flag, msgid, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flag), WPPNULLDATA, 0, 0, WPPDBGPREFIX, "\n"

#define WPP_FLAG_MSGID_LEVEL_LOGGER(flag, msgid, level) \
    WPP_LEVEL_LOGGER(flag)
               
#define WPP_FLAG_MSGID_LEVEL_ENABLED(flag, msgid, lvl) \
    (WPP_LEVEL_ENABLED(flag) && WPP_CONTROL(WPP_BIT_ ## flag).Level >= lvl)

#define WPP_RECORDER_FLAG_MSGID_LEVEL_ARGS(flag, msgid, lvl) \
	WPP_CONTROL(WPP_BIT_ ## flag).AutoLogContext, lvl, WPP_BIT_ ## flag

#define WPP_RECORDER_FLAG_MSGID_LEVEL_FILTER(flag, msgid, lvl) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flag).AutoLogVerboseEnabled)


/*
 * SendTraceEvents() definitions
 */

#define WPP_EX_FLAGS_MSGID_LEVEL(flags, msgid, level) \
	TraceLevelToDbg(level), SendEventWithData, flags, msgid, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flags), WPPNULLDATA, 0, 0, WPPDBGPREFIX, "\n"

#define WPP_FLAGS_MSGID_LEVEL_LOGGER(flags, msgid, level) \
    WPP_LEVEL_LOGGER(flags)

#define WPP_FLAGS_MSGID_LEVEL_ENABLED(flags, msgid, lvl) \
    (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

#define WPP_RECORDER_FLAGS_MSGID_LEVEL_ARGS(lvl, flags, data, len) \
	WPP_CONTROL(WPP_BIT_ ## flags).AutoLogContext, lvl, WPP_BIT_ ## flags

#define WPP_RECORDER_FLAGS_MSGID_LEVEL_FILTER(lvl, flags, data, len) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flags).AutoLogVerboseEnabled)


/*
 * SendTraceWithData() definitions
 */

#define WPP_EX_FLAG_MSGID_LEVEL_DATA_LEN(flag, msgid, level, data, len) \
	TraceLevelToDbg(level), SendEventWithData, flag, msgid, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flag), WPPTRACEDATA, data, len, WPPDBGPREFIX, " Data: %!HEXDUMP!\n"

#define WPP_FLAG_MSGID_LEVEL_DATA_LEN_LOGGER(flag, msgid, level, data, len) \
    WPP_LEVEL_LOGGER(flag)

#define WPP_FLAG_MSGID_LEVEL_DATA_LEN_ENABLED(flag, msgid, lvl, data, len) \
    (WPP_LEVEL_ENABLED(flag) && WPP_CONTROL(WPP_BIT_ ## flag).Level >= lvl)

#define WPP_RECORDER_FLAG_MSGID_LEVEL_DATA_LEN_ARGS(flag, msgid, lvl, data, len) \
	WPP_CONTROL(WPP_BIT_ ## flag).AutoLogContext, lvl, WPP_BIT_ ## flag

#define WPP_RECORDER_FLAG_MSGID_LEVEL_DATA_LEN_FILTER(flag, msgid, lvl, data, len) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flag).AutoLogVerboseEnabled)


/*
 * SendTraceEventsWithData() definitions
 */

#define WPP_EX_FLAGS_MSGID_LEVEL_DATA_LEN(flags, msgid, level, data, len) \
	TraceLevelToDbg(level), SendEventWithData, flags, msgid, DbgPrintTraceMsg, \
	WPPTRACEINFO(level,flags), WPPTRACEDATA, data, len, WPPDBGPREFIX, " Data: %!HEXDUMP!\n"

#define WPP_FLAGS_MSGID_LEVEL_DATA_LEN_LOGGER(flags, msgid, level, data, len) \
    WPP_LEVEL_LOGGER(flags)
               
#define WPP_FLAGS_MSGID_LEVEL_DATA_LEN_ENABLED(flags, msgid, lvl, data, len) \
    (WPP_LEVEL_ENABLED(flags) && WPP_CONTROL(WPP_BIT_ ## flags).Level >= lvl)

#define WPP_RECORDER_FLAGS_MSGID_LEVEL_DATA_LEN_ARGS(flags, msgid, lvl, data, len) \
	WPP_CONTROL(WPP_BIT_ ## flags).AutoLogContext, lvl, WPP_BIT_ ## flags

#define WPP_RECORDER_FLAGS_MSGID_LEVEL_DATA_LEN_FILTER(flags, msgid, lvl, data, len) \
	(lvl < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flags).AutoLogVerboseEnabled)


/*
 * DbgPrint() definitions
 */

#define WPP_EX_DBGFLAG_ID_LEVEL(flag, id, level) \
	level, WPPNULLFUNC, 0, 0, DbgPrintDebugMsg, 0, WPPNULLDATA, 0, 0, "", ""

#define WPP_DBGFLAG_ID_LEVEL_LOGGER(flag, id, level) \
    WPP_LEVEL_LOGGER(flag)

#define WPP_DBGFLAG_ID_LEVEL_ENABLED(flag, id, level) \
    (WPP_LEVEL_ENABLED(flag) && \
     WPP_CONTROL(WPP_BIT_ ## flag).Level >= DbgLevelToTrace(level))

#define WPP_RECORDER_DBGFLAG_ID_LEVEL_ARGS(flag, id, level) \
	WPP_CONTROL(WPP_BIT_ ## flag).AutoLogContext, (UCHAR)DbgLevelToTrace(level), WPP_BIT_ ## flag

#define WPP_RECORDER_DBGFLAG_ID_LEVEL_FILTER(flag, id, level) \
	(DbgLevelToTrace(level) < TRACE_LEVEL_VERBOSE || WPP_CONTROL(WPP_BIT_ ## flag).AutoLogVerboseEnabled)


/*
 * Log Always definitions
 */

#if defined(_DEBUG)
#define WPP_LOG_ALWAYS_TRACE_CALL(level, ProxyMsg, flags, msgid, \
		PrintMsg, info, DataArg, data, len, prefix, tail, fmt, ...) \
	ProxyMsg(flags, msgid, (PVOID)data, (ULONG)len, __VA_ARGS__), \
	PrintMsg(level, info, prefix fmt tail, __VA_ARGS__ DataArg(data, len))
#else
#define WPP_LOG_ALWAYS_TRACE_CALL(level, ProxyMsg, flags, msgid, \
		PrintMsg, info, PrintData, data, len, prefix, tail, fmt, ...) \
	ProxyMsg(flags, msgid, data, len, __VA_ARGS__)
#endif

#define WPP_LOG_ALWAYS_TRACE(x)	WPP_LOG_ALWAYS_TRACE_CALL x
#define WPP_LOG_ALWAYS(EX, ...)	WPP_LOG_ALWAYS_TRACE((EX, __VA_ARGS__)),


/*
 * DbgPrint definitions
 */

#ifndef _DCS_TRACE_WPP_
WPP_CONTROL_GUIDS
#endif


/*
 * WPP custom types
 */

//
// begin_wpp config
// DEFINE_FLAVOR(VDISKID, GUID,,);
// DEFINE_FLAVOR(VDISKU, USTR,,);
// DEFINE_FLAVOR(VDISKW, WSTR,,);
// DEFINE_FLAVOR(VDISK, ASTR,,);
// DEFINE_FLAVOR(LDISKID, GUID,,);
// DEFINE_FLAVOR(LDISKU, USTR,,);
// DEFINE_FLAVOR(LDISKW, WSTR,,);
// DEFINE_FLAVOR(LDISK, ASTR,,);
// DEFINE_FLAVOR(VBLOCK, XINT64,,);
// DEFINE_FLAVOR(VBLOCKLEN, XINT,,);
// DEFINE_FLAVOR(VBLOCKEXT, XINT64,,);
// end_wpp
//

#if defined(WPP_DEFINE_TYPE)

__inline char *CDbgPrintTrace::ExpandCustom(const char *arg, va_list &ap)
{
#if defined(WPP_EXPAND_PROJECT)
	if (ExpandProject(arg, ap))
		return out;
#endif

	switch ((arg[0] << 8) | arg[1]) {
	case 'LD':
		WPP_DEFINE_ALIAS(LDISKID, GUID)
		WPP_DEFINE_ALIAS(LDISKU, USTR)
		WPP_DEFINE_ALIAS(LDISKW, WSTR)
		WPP_DEFINE_ALIAS(LDISK, ASTR)
		break;

	case 'VB':
		WPP_DEFINE_ALIAS(VBLOCK, XINT64)
		WPP_DEFINE_ALIAS(VBLOCKLEN, XINT)
		WPP_DEFINE_ALIAS(VBLOCKEXT, XINT64)
		break;

	case 'VD':
		WPP_DEFINE_ALIAS(VDISKID, GUID)
		WPP_DEFINE_ALIAS(VDISKU, USTR)
		WPP_DEFINE_ALIAS(VDISKW, WSTR)
		WPP_DEFINE_ALIAS(VDISK, ASTR)
		break;
	}

	return NULL;
}

#endif	/* WPP_DEFINE_TYPE */


/*
 * WPP complex types
 */

//
// begin_wpp config
// DEFINE_CPLX_TYPE(HEXDUMP, WPP_LOGHEXDUMP, const TraceData&, ItemHEXDump, "s", _HEX_, 0, 2);
// WPP_FLAGS(-DWPP_LOGHEXDUMP(x) WPP_LOGPAIR(2,&(x).len) WPP_LOGPAIR((x).len, (x).data));
// end_wpp
//


/*
 * Define trace functions
 */

//
// begin_wpp config
// FUNC Trace{FLAG=MYDRIVER_ALL_INFO}(LEVEL, MSG, ...);
// FUNC TraceEvents(LEVEL, FLAGS, MSG, ...);
// FUNC TraceWithData{FLAG=MYDRIVER_ALL_INFO}(LEVEL, DATA, LEN, MSG, ...);
// FUNC TraceEventsWithData(LEVEL, FLAGS, DATA, LEN, MSG, ...);
// FUNC SendTrace{FLAG=DEFAULT_TRACE_LEVEL}(MSGID, LEVEL, MSG, ...);
// FUNC SendTraceEvents(FLAGS, MSGID, LEVEL, MSG, ...);
// FUNC SendTraceWithData{FLAG=DEFAULT_TRACE_LEVEL}(MSGID, LEVEL, DATA, LEN, MSG, ...);
// FUNC SendTraceEventsWithData(FLAGS, MSGID, LEVEL, DATA, LEN, MSG, ...);
// WPP_FLAGS(-public:SendTrace);
// WPP_FLAGS(-public:SendTraceEvents);
// WPP_FLAGS(-public:SendTraceWithData);
// WPP_FLAGS(-public:SendTraceEventsWithData);
// USEPREFIX(SendTrace, "[MsgId 0x%08x]\040 ", (unsigned long)MSGID);
// USEPREFIX(SendTraceEvents, "[MsgId 0x%08x]\040", (unsigned long)MSGID);
// USEPREFIX(SendTraceWithData, "[MsgId 0x%08x]\040", (unsigned long)MSGID);
// USEPREFIX(SendTraceEventsWithData, "[MsgId 0x%08x]\040", (unsigned long)MSGID);
// USESUFFIX(TraceWithData, " Data: %!HEXDUMP!", WPP_LOGDATA(DATA,LEN));
// USESUFFIX(TraceEventsWithData, " Data: %!HEXDUMP!", WPP_LOGDATA(DATA,LEN));
// USESUFFIX(SendTraceWithData, " Data: %!HEXDUMP!", WPP_LOGDATA(DATA,LEN));
// USESUFFIX(SendTraceEventsWithData, " Data: %!HEXDUMP!", WPP_LOGDATA(DATA,LEN));
// FUNC DbgPrint{DBGFLAG=TRACE_KDPRINT, ID=DPFLTR_DEFAULT_ID, LEVEL=DPFLTR_INFO_LEVEL}(MSG, ...);
// FUNC DbgPrintEx{DBGFLAG=TRACE_KDPRINT}(ID, LEVEL, MSG,...);
// FUNC KdPrint{DBGFLAG=TRACE_KDPRINT, ID=DPFLTR_DEFAULT_ID, LEVEL=DPFLTR_INFO_LEVEL}((MSG, ...));
// FUNC KdPrintEx{DBGFLAG=TRACE_KDPRINT}((ID, LEVEL, MSG,...));
// end_wpp
//

#endif /* _DCS_TRACEWPP_H_ */


/*
 * Include WPP pre-processed file
 */

#if defined(_DCS_TRACE_WPP_) && defined(WPPFILE)
#undef KdPrint
#define KdPrint(x)
#undef PAGED_CODE
#define PAGED_CODE()
#undef ALLOC_PRAGMA
extern "C" {
#include WPPFILE
}
#endif

#undef WPPFILE

#ifdef __cplusplus
}
#endif

```

`inc/UnitTest.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	CPP Unit Test Definitions
 */

#ifndef _UNITTEST_H_
#define _UNITTEST_H_

#include <stdarg.h>
#include <winnt.h>

#include <CppUnitTest.h>
using namespace Microsoft::VisualStudio::CppUnitTestFramework;


/*
 *	TEST_MODULE_START(cleanupMethod)
 *		Start of module tests. If Visual Studio starts a new set
 *		of tests on the same thread, cleanup will be called first.
 *
 *	TEST_MODULE_END(cleanupMethod)
 *		End of module tests. If cleanup has already been called
 *		the macro will return.
 */

#define TEST_MODULE_START(cleanupMethod) \
	extern void CALLING_CONVENTION cleanupMethod(); \
	DdkModuleStart(#cleanupMethod, cleanupMethod)

#define TEST_MODULE_END() \
	if (!DdkModuleEnd(__FUNCTION__)) return


/*
 *	TEST_METHOD_ASYNC(methodName)
 *		Define a method that can run asychronously during a test.
 *		The method can use TEST_IS_ASYNC to determine it has been
 *		invoked asynchronously.
 *
 *	TEST_ASYNC_START(instanceId, methodName)
 *		Start the asynchronous method and wait until it is running.
 *
 *	TEST_ASYNC_INIT(instanceId, methodName)
 *		Start the asynchronous method and wait until it is ready.
 *		TEST_ASYNC_RUN must be called to allow it to execute.
 *
 *	TEST_ASYNC_RUN(instanceId)
 *		Allow the asynchronous instance to start executing.
 *
 *	TEST_ASYNC_TIMEOUT(instanceId, secs)
 *		Change the timeout value to use when waiting for the asynchronous
 *		instance to complete.
 *
 *	TEST_ASYNC_WAIT(instanceId)
 *		Wait for the asynchronous method to complete and report any
 *		errors. A wait will automatically occur as soon as instanceId
 *		goes out of scope.
 */

#define TEST_METHOD_ASYNC(methodName) \
	static void _##methodName(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work) { \
		((CUnitTestAsync *)Context)->Invoke(&__##methodName); } \
	void __##methodName(bool async) { CrtHandlersSetter setter; methodName(async); } \
	void methodName(bool TEST_IS_ASYNC = false)

#define TEST_ASYNC_START(instanceId, methodName) \
	CUnitTestAsync instanceId(this, _##methodName, true)

#define TEST_ASYNC_INIT(instanceId, methodName) \
	CUnitTestAsync instanceId(this, _##methodName, false)

#define TEST_ASYNC_RUN(instanceId) instanceId.Run()
#define TEST_ASYNC_TIMEOUT(instanceId, secs) instanceId.Timeout(secs)
#define TEST_ASYNC_WAIT(instanceId) instanceId.Wait()


/*
 *	TEST_ASYNC_INIT_VEC(instanceIdVec, methodName, instanceCount)
 *		Prepare for a set of asynchronous methods. Each individual
 *		method is identified with instanceIdVec[i].
 *
 *	TEST_ASYNC_START_VEC(instanceIdVec, methodName, instanceCount)
 *		Prepare for a set of asynchronous methods. Each individual
 *		method is identified with instanceIdVec[i].
 *
 *	TEST_ASYNC_TIMEOUT_VEC(instanceId, secs)
 *		Change the timeout value to use when waiting for the set of
 *		asynchronous methods to complete.
 *
 *	TEST_ASYNC_WAIT_VEC(instanceId)
 *		Wait for the set of asynchronous methods to complete.
 */

#define TEST_ASYNC_START_VEC(instanceIdVec, methodName, instanceCount) \
	CUnitTestAsync instanceIdVec[(instanceCount)]; \
	for (int i = 0; i < (instanceCount); i++) instanceIdVec[i].InitAsync(this, _##methodName, false); \
	for (int i = 0; i < (instanceCount); i++) instanceIdVec[i].Run()

#define TEST_ASYNC_INIT_VEC(instanceIdVec, methodName, instanceCount) \
	CUnitTestAsync instanceIdVec[(instanceCount)]; \
	for (int i = 0; i < (instanceCount); i++) instanceIdVec[i].InitAsync(this, _##methodName, false)

#define TEST_ASYNC_TIMEOUT_VEC(instanceIdVec, secs) \
	for (int i = 0; i < (sizeof(instanceIdVec) / sizeof(CUnitTestAsync)); i++) instanceIdVec[i].Timeout(secs)

#define TEST_ASYNC_WAIT_VEC(instanceIdVec) \
	for (int i = 0; i < (sizeof(instanceIdVec) / sizeof(CUnitTestAsync)); i++) instanceIdVec[i].Wait()


/*
 *	TEST_METHOD_CALLBACK(methodName, ...)
 *		Define a method to be used as a callback function.
 *		There must be a Context argument which is the instanceId
 *		of the current callback. The remaining arguments are not
 *		passed to the callback method.
 *
 *	TEST_METHOD_CMD_CALLBACK(methodName, CStorageCmd *pCmd)
 *		Define a method to be used as a CStorageCmd callback.
 *
 *	TEST_METHOD_IRP_CALLBACK(methodName, IRP *pIrp)
 *		Define a method to be used as an IRP callback.
 *
 *	TEST_CALLBACK_INIT(instanceId)
 *		Prepare for an asynchronous callback.
 *
 *	TEST_CALLBACK_STARTED(instanceId)
 *		Notification that the callback has been started and should be
 *		waited for. Notification is optional if TEST_CALLBACK_WAIT is
 *		the next call.
 *
 *	TEST_CALLBACK_CANCELLED(instanceId)
 *		Notification that the callback has been cancelled. It is
 *		important to ensure that the callback cannot subsequently occur.
 *
 *	TEST_CALLBACK_TIMEOUT(instanceId, secs)
 *		Change the timeout value to use when waiting for the callback
 *		to complete.
 *
 *	TEST_CALLBACK_WAIT(instanceId)
 *		Wait for the callback to complete. Any errors will be reported.
 *		A wait will automatically occur as soon as instanceId goes
 *		out of scope. For a recurring callback, multiple calls to
 *		TEST_ASYNC_WAIT can be made. However, it is important to ensure
 *		that all callbacks have completed before instanceId goes out of
 *		scope.
 */

#define TEST_METHOD_CALLBACK(methodName, ...) \
	static void methodName(__VA_ARGS__) { \
		((CUnitTestAsync *)Context)->Invoke(&_##methodName); } \
	void _##methodName(bool async) { CrtHandlersSetter setter; __##methodName(async); } \
	void __##methodName(bool)

#define TEST_METHOD_CMD_CALLBACK(methodName, ...) \
	static void methodName(CStorageCmd *pCmd) { \
		((CUnitTestAsync *)(pCmd->getExtension()))->Invoke(&_##methodName, pCmd); } \
	void _##methodName(CStorageCmd *pCmd) { CrtHandlersSetter setter; __##methodName(pCmd); } \
	void __##methodName(__VA_ARGS__)

#define TEST_METHOD_IRP_CALLBACK(methodName, ...) \
	static NTSTATUS methodName(DEVICE_OBJECT *, IRP *pIrp, PVOID Context) { \
		((CUnitTestAsync *)Context)->Invoke(&_##methodName, pIrp); \
		return STATUS_MORE_PROCESSING_REQUIRED; } \
	void _##methodName(IRP *pIrp) { CrtHandlersSetter setter; __##methodName(pIrp); } \
	void __##methodName(__VA_ARGS__)

#define TEST_CALLBACK_INIT(instanceId) CUnitTestAsync instanceId(this)
#define TEST_CALLBACK_STARTED(instanceId) instanceId.Started()
#define TEST_CALLBACK_CANCELLED(instanceId) instanceId.Cancelled()
#define TEST_CALLBACK_TIMEOUT(instanceId, secs) instanceId.Timeout(secs)
#define TEST_CALLBACK_WAIT(instanceId) (instanceId.Started(), instanceId.Wait())


/*
 *	TEST_CALLBACK_INIT_VEC(instanceIdVec, instanceCount)
 *		Prepare for a set of asynchronous callbacks. Each individual
 *		callback is identified with instanceIdVec[i]. Note that
 *		TEST_CALLBACK_STARTED must be called individually for each
 *		instanceId once it has been started.
 *
 *	TEST_CALLBACK_TIMEOUT_VEC(instanceId, secs)
 *		Change the timeout value to use when waiting for the set of
 *		callbacks to complete.
 *
 *	TEST_CALLBACK_WAIT_VEC(instanceId, instanceCount)
 *		Wait for the set of callbacks to complete.
 */

#define TEST_CALLBACK_INIT_VEC(instanceIdVec, instanceCount) \
	CUnitTestAsync instanceIdVec[(instanceCount)]; \
	for (int i = 0; i < (instanceCount); i++) instanceIdVec[i].SetTest(this)

#define TEST_CALLBACK_TIMEOUT_VEC(instanceIdVec, secs) \
	for (int i = 0; i < (sizeof(instanceIdVec) / sizeof(CUnitTestAsync)); i++) instanceIdVec[i].Timeout(secs)

#define TEST_CALLBACK_WAIT_VEC(instanceIdVec) \
	for (int i = 0; i < (sizeof(instanceIdVec) / sizeof(CUnitTestAsync)); i++) instanceIdVec[i].Wait()


/*
 *	CUnitTestAsync
 */

class CUnitTestAsync {
	PVOID			pTest;					// Test object
	TP_WORK			*pWork;					// Work Item
	HANDLE			ready;					// Ready
	HANDLE			run;					// Run
	HANDLE			done;					// Done
	DWORD			started;				// Start time
	DWORD			timeout;				// Timeout in msecs
	volatile LONG	failed;					// Failed
	volatile LONG	waitdone;				// Wait done
	wchar_t			*pMessage;				// Message
	__LineInfo		*pLine;					// Line info
	__LineInfo		line;					// LineInfo Copy

	void Init(PVOID test, bool runflag) {
		pTest = test;
		pWork = 0;
		pLine = 0;
		started = 0;
		timeout = 10 * 1000;
		ready = run = done;
		failed = waitdone = 0;
		pMessage = L"Failure in Async Test or Callback";
		ready = CreateEvent(NULL, TRUE, FALSE, NULL);
		run = CreateEvent(NULL, TRUE, (runflag) ? TRUE : FALSE, NULL);
		done = CreateEvent(NULL, FALSE, FALSE, NULL);
		Assert::IsTrue(ready && run && done);
	}

	bool StartInvoke(volatile int &once) {
		if (once++) return false;
		DdkThreadInit();
		SetEvent(ready);
		InterlockedExchange(&waitdone, 0);
		WaitForSingleObject(run, INFINITE);
		return true;
	}

public:
	void InitAsync(PVOID test, PTP_WORK_CALLBACK func, bool runflag) {
		Init(test, runflag);
		pWork = CreateThreadpoolWork(func, this, NULL);
		Assert::IsNotNull(pWork);
		started = GetTickCount();
		SubmitThreadpoolWork(pWork);
		WaitForSingleObject(ready, INFINITE);
	}

	CUnitTestAsync() : line(0,0,0) { Init(0, true); }
	CUnitTestAsync(PVOID test) : line(0,0,0) { Init(test, true); }

	CUnitTestAsync(PVOID test, PTP_WORK_CALLBACK func, bool runflag)
		: line(0,0,0) { InitAsync(test, func, runflag); }
	
	~CUnitTestAsync() {
		WaitForCompletion();
		if (pWork) CloseThreadpoolWork(pWork);
		if (ready) CloseHandle(ready);
		if (run) CloseHandle(run);
		if (done) CloseHandle(done);
	}

	template <class T>
	void Invoke(void (T::*fn)(bool)) {
		volatile int once = 0;
		CONTEXT ctx;
		RtlCaptureContext(&ctx);
		if (StartInvoke(once)) {
			__try { ((T *)pTest->*fn)(true); }
			__except (Exception(GetExceptionInformation())) { RtlRestoreContext(&ctx, NULL); }
		}
		SetEvent(done);
	}

	template <class T, class C>
	void Invoke(void (T::*fn)(C *), C *c) {
		volatile int once = 0;
		CONTEXT ctx;
		RtlCaptureContext(&ctx);
		if (StartInvoke(once)) {
			__try { ((T *)pTest->*fn)(c); }
			__except (Exception(GetExceptionInformation())) { RtlRestoreContext(&ctx, NULL); }
		}
		SetEvent(done);
	}

	void SetTest(PVOID test) { pTest = test; }

	template <class T>
	T *GetTest(void (T::*fn)(bool)) { return (T *)pTest; }

	void Run() { SetEvent(run); }
	void Started() { started = GetTickCount(); }
	void Cancelled() { SetEvent(done); }
	void Timeout(int secs) { timeout = secs * 1000; }

	void Wait() {
		InterlockedExchange(&waitdone, 0);
		WaitForCompletion();
	}

	void WaitForCompletion() {
		if (started && !waitdone && done) {
			DWORD running = GetTickCount() - started;
			DWORD delay = (running < timeout) ? (timeout - running) : 0;
			DWORD rc = WaitForSingleObject(done, (IsDebuggerPresent() ? INFINITE : delay));
			InterlockedExchange(&waitdone, 1);
			if (rc == WAIT_TIMEOUT) {
				pWork = NULL;
				if (!__uncaught_exception())
					Assert::Fail(L"Timeout waiting for Async Test or Callback");
			}
		}
		if (pWork) WaitForThreadpoolWorkCallbacks(pWork, FALSE);
		if (InterlockedExchange(&failed, 0) && !__uncaught_exception())
			Assert::Fail(pMessage, pLine);
	}

	operator PVOID() { return this; }
	operator ULONG_PTR() { return (ULONG_PTR)this; }

private:
	int Exception(EXCEPTION_POINTERS *xp) {
		if (xp->ExceptionRecord->ExceptionCode == ERROR_ASSERT_FAILED
				&& xp->ExceptionRecord->NumberParameters == 2) {
			if (xp->ExceptionRecord->ExceptionInformation[0])
				pMessage = (wchar_t *)xp->ExceptionRecord->ExceptionInformation[0];
			if (xp->ExceptionRecord->ExceptionInformation[1]) {
				line = *(__LineInfo *)xp->ExceptionRecord->ExceptionInformation[1];
				pLine = &line;
			}
			InterlockedExchange(&failed, 1);
			return EXCEPTION_EXECUTE_HANDLER;
		}

		SetEvent(done);
		return EXCEPTION_CONTINUE_SEARCH;
	}
};


/*
 *	TEST_EXPECT_ASSERT(exp)
 *		Evaluate the expression and expect an assertion to occur.
 */

#define TEST_EXPECT_ASSERT(exp) { \
	bool _ok_ = false; __try { exp; } \
	__except(GetExceptionCode() == 0xe3530001 ? EXCEPTION_EXECUTE_HANDLER : \
		EXCEPTION_CONTINUE_SEARCH) { _ok_ = true; } \
	Assert::IsTrue(_ok_, L"Expected failure did not occur"); \
}


/*
 *	CUnitTestPointer
 */

template<typename T = PVOID, bool code = true>
class CUnitTestPointer {
	const char *name = 0;			// Defined with symbol
	PVOID value = 0;				// Defined with value
	PVOID pointer = 0;				// Resolved pointer value

public:
	CUnitTestPointer(void *addr) : value(addr) { }
	CUnitTestPointer(void **pAddr) : value(*pAddr) { }
	CUnitTestPointer(const char *sym) : name(sym) { }
	CUnitTestPointer(const T func) : value(*(PVOID *)&func) { }
	CUnitTestPointer(const T *pFunc) : value(*(PVOID *)pFunc) { }

	bool IsValid() {
		return !name || value || (value = DdkFindFunction(name));
	}

	PVOID GetPointer() {
		if (!IsValid())	Assert::Fail(L"Unable to find symbol");

		if (!pointer)
			pointer = (code) ? DdkCodeFromPointer(value) : value;

		return pointer;
	}

	operator T() {
		PVOID v = GetPointer();
		return *(T *)&v;
	}
};


/*
 *	TEST_FIND_FUNCTION(name, returntype, function, declaration)
 *		Create a pointer with the appropriate type from the address of
 *		the function, or a fully-qualified string representation of
 *		its name.
 *
 *	TEST_FIND_METHOD(name, classname, returntype, method, declaration)
 *		Create a pointer with the appropriate type from the address of
 *		the method, or a fully-qualified string representation of its
 *		name.
 *
 *	TEST_FIND_VARIABLE(name, type, variable)
 *		Create a pointer with the appropriate type from the address of
 *		the variable, or a fully-qualified string representation of its
 *		name.
 */

#define TEST_FIND_FUNCTION(name,ret,func,decl) \
	class CUnitTestPointer<ret (*) decl> name(func)

#define TEST_FIND_METHOD(name,cls,ret,func,decl) \
	class CUnitTestPointer<ret (cls::*) decl> name(func)

#define TEST_FIND_VARIABLE(name,type,var) \
	class CUnitTestPointer<type *, false> name(var)


/*
 *	Logger::PrintMessage
 *		Write a printf formatted string to the test logger.
 */

class CUnitTestLogger : public Logger {
	static void Print(char *fmt, va_list ap) {
		char msg[1024];
		vsnprintf(msg, sizeof(msg)-1, fmt, ap);
		msg[sizeof(msg)-1] = 0;
		Logger::WriteMessage(msg);
	}

public:
	static void PrintMessage(char *fmt, ...) {
		va_list ap;
		va_start(ap, fmt);
		Print(fmt, ap);
		va_end(ap);
	}

	static void PrintVerbose(bool verbose, char *fmt, ...) {
		if (verbose) {
			va_list ap;
			va_start(ap, fmt);
			Print(fmt, ap);
			va_end(ap);
		}
	}
};

#define Logger CUnitTestLogger


/*
 *	CUnitTestDetour
 */

template<typename NM, typename T>
struct CUnitTestDetour {
	CUnitTestPointer<T> pointer;

	CUnitTestDetour(CUnitTestPointer<T> p) : pointer(p) { }
	~CUnitTestDetour() { DetachDetour(NULL); }

	void AttachDetour(PVOID pThread = DdkGetCurrentThread()) {
		AttachInstance(NULL, pThread);
	}

	void DetachDetour(PVOID pThread = DdkGetCurrentThread()) {
		DetachInstance(this, pThread);
	}

	void AttachInstance(PVOID pInstance, PVOID pThread = DdkGetCurrentThread()) {
		auto v = &NM::Intercept;
		NTSTATUS status = DdkAttachIntercept(
			pointer.GetPointer(), *(PVOID *)&v, this, pInstance, pThread);
		Assert::AreEqual(STATUS_SUCCESS, status);
	}

	void DetachInstance(PVOID pInstance, PVOID pThread = DdkGetCurrentThread()) {
		NTSTATUS status = DdkDetachIntercept(pInstance, pThread);
		Assert::AreEqual(STATUS_SUCCESS, status);
	}

	operator T() { return *pointer; }
};


/*
 *	CUnitTestRealPointer
 */

template<typename T>
class CUnitTestRealPointer {
	PVOID v;
public:
	CUnitTestRealPointer() : v(DdkGetRealPointer()) { }
	operator T() { return *(T *)&v; }
};


/*
 *	CUnitTestDetourInstance
 */

template<typename D>
class CUnitTestDetourInstance {
	D& detour;
public:
	CUnitTestDetourInstance(D& v, PVOID pThread = DdkGetCurrentThread())
		: detour(v) { detour.AttachInstance(this, pThread);	}
	~CUnitTestDetourInstance() { detour.DetachInstance(this, NULL); }
};


/*
 *	TEST_DEFINE_MOCK_FUNCTION(name, returntype, function, declaration)
 *		Define a mock for 'function' which has the given return type and
 *		argument declaration.
 *
 *	TEST_DEFINE_MOCK_METHOD(name, classname, returntype, method, declaration)
 *		Define a mock for 'method' which has the given return type and
 *		argument declaration.
 *
 *	TEST_REAL_FUNCTION(name)
 *		Call the real function from within the mock.
 * 
 *	TEST_REAL_METHOD(name)
 *		Call the real method from within the mock.
 *
 *	TEST_END_MOCK
 *		Complete the mock definition.
 *
 *	TEST_USING_MOCK(name, [thread])
 *		Enable the mock for the thread for the duration of the current scope.
 *
 *	TEST_ENABLE_MOCK(name, [thread])
 *		Enable the mock for the thread.
 *
 *	TEST_DISABLE_MOCK(name, [thread])
 *		Disable the mock for the thread.
 */

#define TEST_DEFINE_MOCK_FUNCTION(_name_,_ret_,_func_,_decl_) \
	struct _name_##_s; \
	CUnitTestDetour<struct _name_##_s, _ret_(*)_decl_> _name_ = { _func_ }; \
	struct _name_##_s { static _ret_ Intercept _decl_ { \
		CUnitTestRealPointer<_ret_(*)_decl_> _real_pointer_;

#define TEST_DEFINE_MOCK_METHOD(_name_,_cls_,_ret_,_func_,_decl_) \
	struct _name_##_s; \
	CUnitTestDetour<struct _name_##_s, _ret_(_cls_::*)_decl_> _name_ = { _func_ }; \
	struct _name_##_s : public _cls_ { _ret_ Intercept _decl_ { \
		CUnitTestRealPointer<_ret_(_cls_::*)_decl_> _real_pointer_;

#define TEST_REAL_FUNCTION	(*_real_pointer_)
#define TEST_REAL_METHOD	(this->*_real_pointer_)
#define TEST_END_MOCK		}};

#define TEST_USING_MOCK(name,...) \
	CUnitTestDetourInstance<decltype(name)> name##_i(name, ## __VA_ARGS__)

#define TEST_ALL_THREADS				NULL
#define TEST_ENABLE_MOCK(name,...)		name.AttachDetour(__VA_ARGS__)
#define TEST_DISABLE_MOCK(name,...)		name.DetachDetour(__VA_ARGS__)


/*
 *	Redefine DdkLoadDriver so that imports are pre-loaded for Detours.
 *	The local instance of __HrLoadAllImportsForDll has to be used, so
 *	pass it as a pointer. Redefine DdkUnloadDriver to discard the imports
 *	because the driver could be reloaded at a different address.
 */

#pragma comment(lib, "delayimp.lib")

extern "C" HRESULT WINAPI __HrLoadAllImportsForDll(LPCSTR szDll);
extern "C" BOOL WINAPI __FUnloadDelayLoadedDLL2(LPCSTR szDll);

#define DdkLoadDriver(pFile) \
	Ddk##LoadDriver(pFile, &__HrLoadAllImportsForDll);

#define DdkUnloadDriver(pName)	\
	Ddk##UnloadDriver(pName, &__FUnloadDelayLoadedDLL2)


#if _MSC_VER < 1920
/*
 *	Add specializations of basic types for equality asserts in test code.
 */

namespace Microsoft { namespace VisualStudio { namespace CppUnitTestFramework 
{
	template<> static std::wstring ToString<long long>    (const long long& t)    { RETURN_WIDE_STRING(t); }
	template<> static std::wstring ToString<long long>    (const long long* t)    { RETURN_WIDE_STRING(t); }
	template<> static std::wstring ToString<long long>    (long long* t)          { RETURN_WIDE_STRING(t); }
}}}
#endif


#endif /* _UNITTEST_H_ */

```

`inc/ddk.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Interface to platform DDK.
 */

#ifdef _DEBUG
#define DBG 1
#endif

#if !defined(_DCS_KERNEL_) && !defined(_DDKSTUB_)
#pragma include_alias(<ntddk.h>,<ddklib.h>)
#endif

#if defined(_DCSNODECL_)
#define __declspec(x)
#endif

#ifdef __cplusplus
extern "C" {
#endif
#include <ntddk.h>
#ifdef _DDK_DRIVER_
/*
** PFD: include the safe string definitions but - for now - silence the deprecated warning for:
**    ustring.h (*) : warning C4995: '_snwprintf': name was marked as #pragma deprecated
**    dcsdefs.h(550) : warning C4996: 'RtlConvertLongToLargeInteger': was declared deprecated
*/
#include <Ntstrsafe.h>
#pragma warning(disable : 4995)
#pragma warning(disable : 4996)

#endif
#ifdef __cplusplus
}
#endif


// Redefine ASSERT and ASSERTMSG as NT_ASSERT and NT_ASSERTMSG
// ASSERT does not cause the system to crash in Win 2008 when the assertion is false.
// NT_ASSERT does.

#if defined(_IA64_) || defined(_AMD64_)

#ifdef ASSERT
#undef ASSERT
#define ASSERT(exp)	NT_ASSERT(exp)
#endif

#ifdef ASSERTMSG
#undef ASSERTMSG
#define ASSERTMSG(msg, exp)  NT_ASSERTMSG(msg,exp)
#endif

#endif

```

`inc/ddk/ddkhdr.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Wrapper for DDK header.
 */

#ifdef __cplusplus
extern "C" {
#endif

#include <ntstatus.h>
#include <ntdef.h>

/*
 *	Check character set
 */

#ifdef UNICODE
#error "The project property 'Use Multi-Byte Character Set' is required"
#endif

#ifndef _WINNT_

#ifndef _DDKHDR_H_
#define _DDKHDR_H_


/*
 *	Remove conflicts
 */

#undef DEVICE_TYPE
#undef DEVICE_TYPE_FROM_CTL_CODE
#undef METHOD_FROM_CTL_CODE


// Use consistent PROCESS and THREAD definitions
#define _EPROCESS _KPROCESS
#define _ETHREAD _KTHREAD

#ifdef _DDKLIBBUILD_
#define dllimport dllexport
#endif

// Adjust data definitions
#ifdef _DDKLIBBUILD_
#include "data.h"
#endif

#include <_ddkhdr_>
#undef dllimport

// Ensure that winnt.h is included
#undef NT_INCLUDED

// Defines from devioctl.h are done
#define _DEVIOCTL_


/*
 *	Fixup residual issues
 */

#ifndef _DDKINLINE_
#undef KI_USER_SHARED_DATA
#define KI_USER_SHARED_DATA 0x7FFE0000UI64
#endif


#undef _DDKHDR_H_
#else
#include <_ddkhdr_>
#endif

#else

/*
 *	Windows headers have been included
 */

#include "ntddk_defs.h"
#endif
	

#ifdef __cplusplus
};
#endif

```

`inc/ddk/ntddk.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Device Driver Definitions.
 */

#ifndef _DDK_NTDDK_H_
#define _DDK_NTDDK_H_


#pragma include_alias(<_ddkhdr_>,<../km/ntddk.h>)
#include <ddk/ddkhdr.h>


#endif /* _DDK_NTDDK_H_ */

```

`inc/ddk/ntddk_defs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	DDK Definitions.
 */

#ifndef _DDK_NTDDK_DEFS_H_
#define _DDK_NTDDK_DEFS_H_

#ifdef __cplusplus
extern "C" {
#endif


/*
 *	Basic Types (must match DDK)
 */

typedef LONG KPRIORITY;
typedef CCHAR KPROCESSOR_MODE;
typedef unsigned char KIRQL, *PKIRQL;
typedef ULONG_PTR KSPIN_LOCK, *PKSPIN_LOCK;
typedef volatile LONG EX_SPIN_LOCK, *PEX_SPIN_LOCK;
typedef struct _OBJECT_TYPE OBJECT_TYPE, *POBJECT_TYPE;


/*
 *	Enumeration Definitions (must match DDK)
 */

typedef enum { WaitAll, WaitAny } WAIT_TYPE;
typedef enum { NotificationEvent, SynchronizationEvent } EVENT_TYPE;
typedef enum { NotificationTimer, SynchronizationTimer } TIMER_TYPE;
typedef enum { LowImportance, MediumImportance, HighImportance, MediumHighImportance } KDPC_IMPORTANCE;
typedef enum { CriticalWorkQueue, DelayedWorkQueue, HyperCriticalWorkQueue, MaximumWorkQueue } WORK_QUEUE_TYPE;
typedef enum { Executive, Suspended = 5, UserRequest, } KWAIT_REASON;
typedef enum { NonPagedPool, PagedPool } POOL_TYPE;
typedef enum { LowPoolPriority, NormalPoolPriority = 16 } EX_POOL_PRIORITY;
typedef enum { KernelMode, UserMode } MODE;
typedef enum { MmNonCached = FALSE, MmCached = TRUE } MEMORY_CACHING_TYPE;


/*
 *	Structure Declarations
 */

typedef struct _IRP IRP, *PIRP;
typedef struct _MDL MDL, *PMDL;
typedef struct _IO_STACK_LOCATION IO_STACK_LOCATION, *PIO_STACK_LOCATION;
typedef struct _KDPC KDPC, *PKDPC, *PRKDPC;
typedef struct _KEVENT KEVENT, *PKEVENT, *PRKEVENT;
typedef struct _KMUTANT KMUTANT, *PKMUTANT, *PRKMUTANT, KMUTEX, *PKMUTEX, *PRKMUTEX;
typedef struct _KSEMAPHORE KSEMAPHORE, *PKSEMAPHORE, *PRKSEMAPHORE;
typedef struct _KWAIT_BLOCK KWAIT_BLOCK, *PKWAIT_BLOCK, *PRKWAIT_BLOCK;
typedef struct _CLIENT_ID CLIENT_ID, *PCLIENT_ID;
typedef struct _KTIMER KTIMER, *PKTIMER, *PRKTIMER;
typedef struct _DEVICE_OBJECT DEVICE_OBJECT, *PDEVICE_OBJECT;
typedef struct _DRIVER_OBJECT DRIVER_OBJECT, *PDRIVER_OBJECT;
typedef struct _FILE_OBJECT FILE_OBJECT, *PFILE_OBJECT;
typedef struct _IO_WORKITEM IO_WORKITEM, *PIO_WORKITEM;
typedef struct _KLOCK_QUEUE_HANDLE KLOCK_QUEUE_HANDLE, *PKLOCK_QUEUE_HANDLE;
typedef struct _KTHREAD *PETHREAD, *PKTHREAD, *PRKTHREAD;
typedef struct _KPROCESS *PKPROCESS, *PRKPROCESS, *PEPROCESS;
typedef struct _OBJECT_ATTRIBUTES OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES, *PCOBJECT_ATTRIBUTES;
typedef struct _OBJECT_HANDLE_INFORMATION OBJECT_HANDLE_INFORMATION, *POBJECT_HANDLE_INFORMATION;
typedef struct _KEY_VALUE_PARTIAL_INFORMATION KEY_VALUE_PARTIAL_INFORMATION, *PKEY_VALUE_PARTIAL_INFORMATION;
typedef struct _PCI_COMMON_CONFIG PCI_COMMON_CONFIG, *PPCI_COMMON_CONFIG;
typedef struct _CM_RESOURCE_LIST CM_RESOURCE_LIST, *PCM_RESOURCE_LIST;


/*
 *	Callback Declarations (must match DDK)
 */

typedef VOID KSTART_ROUTINE(PVOID);
typedef KSTART_ROUTINE *PKSTART_ROUTINE;
typedef VOID KDEFERRED_ROUTINE(KDPC *, PVOID, PVOID, PVOID);
typedef KDEFERRED_ROUTINE *PKDEFERRED_ROUTINE;
typedef VOID IO_WORKITEM_ROUTINE(PDEVICE_OBJECT, PVOID);
typedef IO_WORKITEM_ROUTINE *PIO_WORKITEM_ROUTINE;
typedef VOID IO_WORKITEM_ROUTINE_EX(PVOID, PVOID, PIO_WORKITEM);
typedef IO_WORKITEM_ROUTINE_EX *PIO_WORKITEM_ROUTINE_EX;
typedef NTSTATUS DRIVER_INITIALIZE(PDRIVER_OBJECT, PUNICODE_STRING);
typedef DRIVER_INITIALIZE *PDRIVER_INITIALIZE;


/*
 *	Macro Definitions (must match DDK)
 */

#define IO_NO_INCREMENT 0

#define KeWaitForMutexObject KeWaitForSingleObject


/*
 *	Function Declarations
 */

DDKAPI KIRQL KeGetCurrentIrql();
DDKAPI VOID KeRaiseIrql(KIRQL NewIrql, PKIRQL OldIrql);
DDKAPI VOID KeLowerIrql(KIRQL NewIrql);

DDKAPI NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes,
    HANDLE ProcessHandle, PCLIENT_ID ClientId, PKSTART_ROUTINE StartRoutine, PVOID StartContext);
DDKAPI NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus);

DDKAPI LONG RtlCompareUnicodeString(PCUNICODE_STRING u1, PCUNICODE_STRING u2, BOOLEAN ign);
DDKAPI VOID RtlCopyUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString);
DDKAPI NTSTATUS RtlIntegerToUnicodeString(ULONG Value, ULONG Base, PUNICODE_STRING String);
DDKAPI BOOLEAN RtlEqualUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
DDKAPI NTSTATUS RtlStringFromGUID(REFGUID Guid, PUNICODE_STRING GuidString);
DDKAPI NTSTATUS RtlUpcaseUnicodeString(PUNICODE_STRING DestinationString, PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString);

DDKAPI NTSTATUS KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason, 
	KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout);
DDKAPI NTSTATUS KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType,
	KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout,
	PKWAIT_BLOCK WaitBlockArray);

DDKAPI PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
DDKAPI PVOID ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes);
DDKAPI PVOID ExAllocatePoolWithTagPriority(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag, EX_POOL_PRIORITY Priority);
DDKAPI VOID ExFreePoolWithTag(PVOID P, ULONG Tag);
DDKAPI VOID ExFreePool(PVOID P);

DDKAPI VOID KeInitializeSpinLock(PKSPIN_LOCK SpinLock);
DDKAPI VOID KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock);
DDKAPI VOID KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql);
DDKAPI VOID KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock);
DDKAPI VOID KeInitializeMutex(PRKMUTEX Mutex, ULONG Level);
DDKAPI LONG KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait);

DDKAPI VOID KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
DDKAPI VOID KeClearEvent(PRKEVENT Event);
DDKAPI LONG KeReadStateEvent(PRKEVENT Event);
DDKAPI LONG KeResetEvent(PRKEVENT Event);
DDKAPI LONG KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);

DDKAPI VOID KeInitializeTimer(PKTIMER Timer);
DDKAPI VOID KeInitializeTimerEx(PKTIMER Timer, TIMER_TYPE Type);
DDKAPI BOOLEAN KeCancelTimer(PKTIMER Timer);
DDKAPI BOOLEAN KeReadStateTimer(PKTIMER Timer);
DDKAPI BOOLEAN KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc);
DDKAPI BOOLEAN KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc);

DDKAPI VOID KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
DDKAPI VOID KeInitializeThreadedDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext);
DDKAPI BOOLEAN KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2);
DDKAPI BOOLEAN KeRemoveQueueDpc(PRKDPC Dpc);
DDKAPI VOID KeFlushQueuedDpcs(VOID);

DDKAPI NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
DDKAPI KPRIORITY KeSetPriorityThread(PKTHREAD Thread, KPRIORITY Priority);
DDKAPI KPRIORITY KeQueryPriorityThread(PKTHREAD Thread);

DDKAPI LONG_PTR ObReferenceObject(PVOID Object);
DDKAPI LONG_PTR ObReferenceObjectWithTag(PVOID Object, ULONG Tag);
DDKAPI LONG_PTR ObDereferenceObject(PVOID Object);
DDKAPI LONG_PTR ObDereferenceObjectWithTag(PVOID Object, ULONG Tag);

DDKAPI VOID KeBugCheck(ULONG BugCheckCode);


#ifdef __cplusplus
};
#endif

#endif /*_DDK_NTDDK_DEFS_H_ */

```

`inc/ddk/ntdef.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Basic Type Definitions.
 */

#ifndef _DDK_NTDEF_H_
#define _DDK_NTDEF_H_


#ifndef _WINNT_

// Use path to bypass include alias
#include <../shared/ntdef.h>

// Ensure that winnt.h is included
#undef NT_INCLUDED

#else

/*
 *	Windows headers have been included
 */

#define _DDK_DRIVER_

// Add some missing definitions
#include <intsafe.h>
#include <winternl.h>
#include <ddk/ntdef_defs.h>

#endif


#endif /* _DDK_NTDEF_H_ */

```

`inc/ddk/ntdef_defs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
*	DDK Basic Types.
*/

#ifndef _DDK_NTDEF_DEFS_H_
#define _DDK_NTDEF_DEFS_H_

#ifdef __cplusplus
extern "C" {
#endif


/*
 *	Basic Types (must match DDK)
 */

typedef LARGE_INTEGER PHYSICAL_ADDRESS, *PPHYSICAL_ADDRESS;
typedef ULONG LOGICAL, *PLOGICAL;
typedef short CSHORT;


/*
 *	Time conversion routines (must match DDK)
 */

typedef struct _TIME_FIELDS {
    CSHORT Year;
    CSHORT Month;
    CSHORT Day;
    CSHORT Hour;
    CSHORT Minute;
    CSHORT Second;
    CSHORT Milliseconds;
    CSHORT Weekday;
} TIME_FIELDS, *PTIME_FIELDS;


#ifdef __cplusplus
};
#endif

#endif /* _DDK_NTDEF_DEFS_H_ */

```

`inc/ddk/ntifs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Device Driver Definitions.
 */

#ifndef _DDK_NTIFS_H_
#define _DDK_NTIFS_H_


#pragma include_alias(<_ddkhdr_>,<../km/ntifs.h>)
#include <ddk/ddkhdr.h>


#endif /* _DDK_NTIFS_H_ */

```

`inc/ddk/ntstatus.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Define NTSTATUS Codes.
 */

#ifndef _DDK_NTSTATUS_H_
#define _DDK_NTSTATUS_H_


// Ensure definition occurs

#undef _NTSTATUS_
#undef WIN32_NO_STATUS

// Ignore redefinition warnings

#pragma warning(push)
#pragma warning(disable:4005)

// Use path to bypass include alias

#include <../shared/ntstatus.h>

// Re-enable warnings

#pragma warning(pop)

// Prevent redefinitions

#define WIN32_NO_STATUS


#endif /* _DDK_NTSTATUS_H_ */
```

`inc/ddk/ntstrsafe.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Define NTSTATUS Codes.
 */

#ifndef _DDK_NTSTRSAFE_H_
#define _DDK_NTSTRSAFE_H_

// Ignore Code Analysis warnings

#pragma warning(push)
#pragma warning(disable:6102)

#include <../km/ntstrsafe.h>

// Re-enable warnings

#pragma warning(pop)

#endif /* _DDK_NTSTRSAFE_H_ */
```

`inc/ddk/wdm.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Device Driver Definitions.
 */

#ifndef _DDK_WDM_H_
#define _DDK_WDM_H_


#ifdef _DDKINLINE_
#pragma include_alias(<_ddkhdr_>,<../km/wdm.h>)
#else
#pragma include_alias(<_ddkhdr_>,<ddk/wdmhdr.h>)
#endif

#include <ddk/ddkhdr.h>


#endif /* _DDK_WDM_H_ */

```

`inc/ddk/wdmhdr.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	WDM header.
 */

#ifndef _WDMHDR_H_
#define _WDMHDR_H_

#include <ntdef.h>


/*
 *	Disable some inlining
 */

#define KeGetCurrentThread _KeGetCurrentThread
#define PsGetCurrentThread _PsGetCurrentThread
#define KeGetCurrentIrql _KeGetCurrentIrql
#ifndef NTDDI_WINBLUE
#define KeLowerIrql _KeLowerIrql
#define KfRaiseIrql _KfRaiseIrql
#endif


#include <../km/wdm.h>


/*
 *	Disable PAGED_CODE()
 */

#undef PAGED_CODE
#define PAGED_CODE()


/*
 *	Define Annotations
 */

#ifndef _IRQL_requires_max_
#define _IRQL_requires_max_(x) __drv_maxIRQL(x)
#endif

#ifndef _IRQL_raises_
#define _IRQL_raises_(x) __drv_raisesIRQL(x)
#endif

#ifndef _IRQL_saves_
#define _IRQL_saves_ __drv_savesIRQL
#endif

#ifndef _Notliteral_
#define _Notliteral_ __drv_nonConstant 
#endif

#ifndef _IRQL_restores_
#define _IRQL_restores_ __drv_restoresIRQL
#endif


/*
 *	Non-inlined Declarations
 */

#undef KeGetCurrentThread
#undef PsGetCurrentThread
#undef KeGetCurrentIrql
#undef KeLowerIrql
#undef KfRaiseIrql

NTSYSAPI PKTHREAD NTAPI KeGetCurrentThread(VOID);
_IRQL_requires_max_(DISPATCH_LEVEL) NTSYSAPI PETHREAD PsGetCurrentThread(VOID);
_IRQL_requires_max_(HIGH_LEVEL) _IRQL_saves_ NTSYSAPI KIRQL NTAPI KeGetCurrentIrql(VOID);
_IRQL_requires_max_(HIGH_LEVEL) NTSYSAPI VOID KeLowerIrql(_In_ _Notliteral_ _IRQL_restores_ KIRQL NewIrql);
_IRQL_requires_max_(HIGH_LEVEL) _IRQL_raises_(NewIrql) _IRQL_saves_ NTSYSAPI KIRQL KfRaiseIrql(_In_ KIRQL NewIrql);

#define KeRaiseIrql(a,b) *(b) = KfRaiseIrql(a)

#endif	/* _WDMHDR_H_ */

```

`inc/ddk/winnt.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Basic Type Definitions.
 */

#ifndef _DDK_WINNT_H_
#define _DDK_WINNT_H_


#ifndef _NTDEF_

// Use path to bypass include alias
#include <../um/winnt.h>

#else

/*
 *	DDK headers have been included
 */

#include <minwindef.h>
#include <intsafe.h>
#include <ntifs.h>
#include <ddk/winnt_defs.h>
#include <errhandlingapi.h>

#endif


#endif /* _DDK_WINNT_H_ */
```

`inc/ddk/winnt_defs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Windows Type Definitions.
 */

#ifndef _DDK_WINNT_DEFS_H_
#define _DDK_WINNT_DEFS_H_

#ifdef __cplusplus
extern "C" {
#endif


/*
 *	Basic Types
 */

typedef DWORD TP_WAIT_RESULT;


/*
 *	Structure Declarations
 */

typedef struct _RTL_SRWLOCK RTL_SRWLOCK, *PRTL_SRWLOCK;
typedef struct _RTL_CONDITION_VARIABLE RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;
typedef struct _RTL_BARRIER RTL_BARRIER, *PRTL_BARRIER;
typedef struct _RTL_CRITICAL_SECTION_DEBUG RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG;
typedef struct _HEAP_INFORMATION_CLASS HEAP_INFORMATION_CLASS, *PHEAP_INFORMATION_CLASS;
typedef struct _MEMORY_BASIC_INFORMATION MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
typedef struct _JOB_SET_ARRAY JOB_SET_ARRAY, *PJOB_SET_ARRAY;
typedef struct _PERFORMANCE_DATA PERFORMANCE_DATA, *PPERFORMANCE_DATA;
typedef struct _WOW64_CONTEXT WOW64_CONTEXT, *PWOW64_CONTEXT;
typedef struct _WOW64_LDT_ENTRY WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;
typedef struct _TP_IO TP_IO, *PTP_IO;
typedef struct _TP_POOL TP_POOL, *PTP_POOL;
typedef struct _TP_WORK TP_WORK, *PTP_WORK;
typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;
typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;
typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;
typedef struct _TP_POOL_STACK_INFORMATION TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;
typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;
typedef struct _TP_CALLBACK_ENVIRON TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;
typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION,
	*PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;
typedef struct _IMAGE_DOS_HEADER IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
typedef struct _RTL_CRITICAL_SECTION { __int64 x[5]; } RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;
typedef struct _CFG_CALL_TARGET_INFO CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;
typedef struct MEM_EXTENDED_PARAMETER MEM_EXTENDED_PARAMETER, *PMEM_EXTENDED_PARAMETER;
typedef struct _PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE PROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE,
	* PPROCESS_DYNAMIC_ENFORCED_ADDRESS_RANGE;


/*
 *	Enumeration Declarations
 */

typedef enum _TP_CALLBACK_PRIORITY TP_CALLBACK_PRIORITY;
typedef enum _FIRMWARE_TYPE FIRMWARE_TYPE, *PFIRMWARE_TYPE;
typedef enum _JOBOBJECTINFOCLASS JOBOBJECTINFOCLASS;
typedef enum _ACL_INFORMATION_CLASS ACL_INFORMATION_CLASS;
typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;
typedef enum _RTL_UMS_SCHEDULER_REASON RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;


/*
 *	Macro Definitions
 */

#define DLL_PROCESS_ATTACH   1
#define DLL_PROCESS_DETACH   0


/*
 *	Callback Declarations
 */

typedef VOID(*PTP_SIMPLE_CALLBACK)(PTP_CALLBACK_INSTANCE, PVOID);
typedef VOID(*WAITORTIMERCALLBACK)(PVOID, BOOLEAN);
typedef VOID(*PAPCFUNC)(ULONG_PTR);
typedef LONG(*PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS *);
typedef VOID(*PFLS_CALLBACK_FUNCTION)(PVOID);
typedef VOID(*PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(PVOID, PVOID);
typedef VOID(*PTP_WORK_CALLBACK)(PTP_CALLBACK_INSTANCE, PVOID, PTP_WORK);
typedef VOID(*PTP_TIMER_CALLBACK)(PTP_CALLBACK_INSTANCE, PVOID, PTP_TIMER);
typedef VOID(*PTP_WAIT_CALLBACK)(PTP_CALLBACK_INSTANCE, PVOID, PTP_WAIT, TP_WAIT_RESULT);
typedef BOOLEAN(*PSECURE_MEMORY_CACHE_CALLBACK)(PVOID, SIZE_T);
typedef VOID RTL_UMS_SCHEDULER_ENTRY_POINT(RTL_UMS_SCHEDULER_REASON, ULONG_PTR, PVOID);
typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
typedef LONG (*PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS *);


/*
 *	Function Declarations
 */

VOID TpSetCallbackThreadpool(PTP_CALLBACK_ENVIRON, PTP_POOL);
VOID TpSetCallbackCleanupGroup(PTP_CALLBACK_ENVIRON, PTP_CLEANUP_GROUP, PTP_CLEANUP_GROUP_CANCEL_CALLBACK);
VOID TpInitializeCallbackEnviron(PTP_CALLBACK_ENVIRON);
VOID TpSetCallbackLongFunction(PTP_CALLBACK_ENVIRON);
VOID TpSetCallbackRaceWithDll(PTP_CALLBACK_ENVIRON, PVOID);
VOID TpSetCallbackFinalizationCallback(PTP_CALLBACK_ENVIRON, PTP_SIMPLE_CALLBACK);
VOID TpSetCallbackPriority(PTP_CALLBACK_ENVIRON, TP_CALLBACK_PRIORITY);
VOID TpSetCallbackPersistent(PTP_CALLBACK_ENVIRON);
VOID TpDestroyCallbackEnviron(PTP_CALLBACK_ENVIRON);

VOID RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD *ExceptionRecord);


#ifdef __cplusplus
};
#endif

#endif /* _DDK_WINNT_DEFS_H_ */

```

`inc/ddklib.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * DDK Library.
 */

#ifndef _DDKLIB_H_
#define _DDKLIB_H_

#define _DDKLIB_
#define _KERNEL_
#define _DCS_KERNEL_
#define _KERNEL_MODE


/*
 *	Ensure the Target is defined
 */

#if defined(_M_AMD64) && !defined(_AMD64_)
#define _AMD64_
#endif


/*
 *	Set the DDK definitions
 */

#define W2K
#define WIN2K
#define WXP
#define WNET


/*
 *	Define include files
 */

#pragma include_alias(<wdm.h>,<ddk/wdm.h>)
#pragma include_alias("wdm.h","ddk/wdm.h")
#pragma include_alias(<ntifs.h>,<ddk/ntifs.h>)
#pragma include_alias("ntifs.h","ddk/ntifs.h")
#pragma include_alias(<ntdef.h>,<ddk/ntdef.h>)
#pragma include_alias("ntdef.h","ddk/ntdef.h")
#pragma include_alias(<ntstatus.h>,<ddk/ntstatus.h>)
#pragma include_alias("ntstatus.h","ddk/ntstatus.h")
#pragma include_alias(<winnt.h>,<ddk/winnt.h>)
#pragma include_alias("winnt.h","ddk/winnt.h")


/*
 *	Set up include paths
 */

#pragma include_alias(<mce.h>,<../km/mce.h>)
#pragma include_alias(<ntnls.h>,<../km/ntnls.h>)
#pragma include_alias(<Ntstrsafe.h>,<ddk/ntstrsafe.h>)
#pragma include_alias(<wmilib.h>,<../km/wmilib.h>)
#pragma include_alias("wmilib.h","../km/wmilib.h")
#pragma include_alias(<mountdev.h>, <../km/mountdev.h>)
#pragma include_alias("mountdev.h", "../km/mountdev.h")
#pragma include_alias(<mountmgr.h>, <../km/mountmgr.h>)
#pragma include_alias("mountmgr.h", "../km/mountmgr.h")
#pragma include_alias(<tdikrnl.h>, <../km/tdikrnl.h>)
#pragma include_alias("tdikrnl.h", "../km/tdikrnl.h")
#pragma include_alias(<netpnp.h>, <../km/netpnp.h>)
#pragma include_alias("netpnp.h", "../km/netpnp.h")
#pragma include_alias(<ntddft.h>,<ntdskreg.h>)
#pragma include_alias("ntddft.h","ntdskreg.h")


/*
 *	Setup Linkage Definition
 */

#ifdef _DDKLIBBUILD_
#define DDKAPI __declspec(dllexport)
#else
#define DDKAPI __declspec(dllimport)
#endif

#define DDKAPI_NODECL DDKAPI


/*
 *	Include DDK header
 */

#include <ddk/ntddk.h>


/*
 *	External Definitions
 */

extern "C" {
DDKAPI NTSTATUS DdkLoadDriver(char *pFile, HRESULT (*pLoad)(const char *) = NULL);
DDKAPI NTSTATUS DdkInitDriver(char *pName, PDRIVER_INITIALIZE DriverInit);
DDKAPI VOID DdkUnloadDriver(char *pName, INT (*pUnload)(const char *) = NULL);
DDKAPI VOID DdkThreadInit();
DDKAPI VOID DdkThreadDeinit();
DDKAPI VOID DdkModuleStart(char *pName, void (*cleanup)());
DDKAPI BOOLEAN DdkModuleEnd(char *pName);
DDKAPI PKTHREAD DdkGetCurrentThread();
DDKAPI PVOID DdkFindFunction(const char *pName);
DDKAPI PVOID DdkCodeFromPointer(PVOID pAddr);
DDKAPI NTSTATUS DdkAttachIntercept(PVOID pFunction,
	PVOID pIntercept, PVOID pIdentity, PVOID pInstance, PVOID pThread);
DDKAPI NTSTATUS DdkDetachIntercept(PVOID pId, PVOID pThread);
DDKAPI PVOID DdkGetRealPointer();
DDKAPI void DdkCreateRegistryKey(ULONG RelativeTo, PWSTR Path);
DDKAPI void DdkDeleteRegistryKey(ULONG RelativeTo, PWSTR Path);
};


/*
 *	Load the library
 */

#ifndef _DDKLIBBUILD_
#pragma comment(lib,"ddk.lib")
#endif

#endif /* _DDKLIB_H_ */

```

`src/Ddk.rc`:

```rc
//Microsoft Developer Studio generated resource script.
//
#include "resource.h"

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include "windows.h"

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.K.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENG)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    "resource.h\0"
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    "#include ""afxres.h""\r\n"
    "\0"
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    "\r\n"
    "\0"
END

#endif    // APSTUDIO_INVOKED


#ifndef _MAC
/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x40004L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "040904b0"
        BEGIN
            VALUE "Comments", "\0"
            VALUE "CompanyName", "DataCore Software Corporation\0"
            VALUE "FileDescription", "Ddk\0"
            VALUE "FileVersion", "1, 0, 0, 1\0"
            VALUE "InternalName", "Ddk\0"
            VALUE "LegalCopyright", "Copyright © 1999 DataCore Software Corporation\0"
            VALUE "LegalTrademarks", "\0"
            VALUE "OriginalFilename", "Ddk.dll\0"
            VALUE "PrivateBuild", "\0"
            VALUE "ProductName", "Ddk\0"
            VALUE "ProductVersion", "1, 0, 0, 1\0"
            VALUE "SpecialBuild", "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x409, 1200
    END
END

#endif    // !_MAC

#endif    // English (U.K.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED


```

`src/Ddk.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{12FAF1AE-B4C9-449F-A188-F03CBA835662}</ProjectGuid>
    <RootNamespace>Ddk</RootNamespace>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseOfMfc>false</UseOfMfc>
    <CharacterSet>MultiByte</CharacterSet>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
    <Import Project="..\Config\Application.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="$(VCTargetsPath)Microsoft.CPP.UpgradeFromVC60.props" />
    <Import Project="..\Config\Application.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup>
    <_ProjectFileVersion>10.0.30319.1</_ProjectFileVersion>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkIncremental>
    <LinkIncremental Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkIncremental>
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
    <CodeAnalysisRuleSet Condition="'$(Configuration)|$(Platform)'=='Release|x64'">AllRules.ruleset</CodeAnalysisRuleSet>
    <CodeAnalysisRules Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
    <CodeAnalysisRuleAssemblies Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <TargetName>ddk</TargetName>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <TargetName>ddk</TargetName>
    <TargetExt>.dll</TargetExt>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>$(OutDir)Ddk.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>Disabled</Optimization>
      <AdditionalIncludeDirectories>../inc;$(DetoursDir)include;$(OutDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DDKLIBBUILD_;_DEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)Win.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <BrowseInformation>
      </BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <DisableSpecificWarnings>4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
      <ControlFlowGuard>false</ControlFlowGuard>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0809</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>detours.lib;Ws2_32.lib;legacy_stdio_definitions.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)ddk.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)ddk.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
      <ModuleDefinitionFile>ddk.def</ModuleDefinitionFile>
      <AdditionalOptions>/ignore:4087 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalLibraryDirectories>$(DetoursDir)lib.$(Platform);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)Ddk.bsc</OutputFile>
    </Bscmake>
    <PostBuildEvent>
      <Command>%(Command)
mkdir "$(OutDir)vsTest" 2&gt;nul:
copy "$(OutDir)ddk.dll" "$(OutDir)vsTest" &gt;nul:
copy "$(OutDir)ddk.pdb" "$(OutDir)vsTest" &gt;nul:</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Midl>
      <TargetEnvironment>X64</TargetEnvironment>
      <TypeLibraryName>$(OutDir)Ddk.tlb</TypeLibraryName>
      <HeaderFileName>
      </HeaderFileName>
    </Midl>
    <ClCompile>
      <Optimization>MaxSpeed</Optimization>
      <InlineFunctionExpansion>OnlyExplicitInline</InlineFunctionExpansion>
      <AdditionalIncludeDirectories>../inc;$(DetoursDir)include;$(OutDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
      <PreprocessorDefinitions>WIN32;_DDKLIBBUILD_;NDEBUG;_CONSOLE;_CRT_SECURE_NO_WARNINGS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <StringPooling>true</StringPooling>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <PrecompiledHeaderFile>stdafx.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile>$(IntDir)Win.pch</PrecompiledHeaderOutputFile>
      <AssemblerListingLocation>$(IntDir)</AssemblerListingLocation>
      <ObjectFileName>$(IntDir)</ObjectFileName>
      <ProgramDataBaseFileName>$(IntDir)</ProgramDataBaseFileName>
      <BrowseInformation>
      </BrowseInformation>
      <WarningLevel>Level3</WarningLevel>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>
      <DisableSpecificWarnings>4996;%(DisableSpecificWarnings)</DisableSpecificWarnings>
    </ClCompile>
    <ResourceCompile>
      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <Culture>0x0809</Culture>
      <AdditionalIncludeDirectories>$(IntDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ResourceCompile>
    <Link>
      <AdditionalDependencies>detours.lib;Ws2_32.lib;legacy_stdio_definitions.lib;%(AdditionalDependencies)</AdditionalDependencies>
      <OutputFile>$(OutDir)ddk.dll</OutputFile>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <ProgramDatabaseFile>$(OutDir)ddk.pdb</ProgramDatabaseFile>
      <SubSystem>Console</SubSystem>
      <RandomizedBaseAddress>false</RandomizedBaseAddress>
      <DataExecutionPrevention>
      </DataExecutionPrevention>
      <TargetMachine>MachineX64</TargetMachine>
      <ModuleDefinitionFile>ddk.def</ModuleDefinitionFile>
      <AdditionalOptions>/ignore:4087 %(AdditionalOptions)</AdditionalOptions>
      <AdditionalLibraryDirectories>$(DetoursDir)lib.$(Platform);%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
    </Link>
    <Bscmake>
      <SuppressStartupBanner>true</SuppressStartupBanner>
      <OutputFile>$(OutDir)Ddk.bsc</OutputFile>
    </Bscmake>
    <PostBuildEvent>
      <Command>%(Command)
mkdir "$(OutDir)vsTest" 2&gt;nul:
copy "$(OutDir)ddk.dll" "$(OutDir)vsTest" &gt;nul:
copy "$(OutDir)ddk.pdb" "$(OutDir)vsTest" &gt;nul:</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="alloc.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="bcrypt.cpp" />
    <ClCompile Include="bitmap.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="cpu.cpp" />
    <ClCompile Include="crt.cpp" />
    <ClCompile Include="data.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="dbg.cpp" />
    <ClCompile Include="detours.cpp" />
    <ClCompile Include="device.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="dpc.cpp" />
    <ClCompile Include="driver.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="event.cpp" />
    <ClCompile Include="exception.cpp" />
    <ClCompile Include="executive.cpp" />
    <ClCompile Include="file.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="init.cpp" />
    <CustomBuild Include="inline.c">
      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">cl /c /nologo /Os /Ox /Gm- /Fo"$(TargetDir)ddkinline.obj" %(Identity)</Command>
      <Message Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Creating ddkinline.obj...</Message>
      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">cl /c /nologo /Os /Ox /Gm- /Fo"$(TargetDir)ddkinline.obj" %(Identity)</Command>
      <Message Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Creating ddkinline.obj...</Message>
      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(TargetDir)ddkinline.obj;%(Outputs)</Outputs>
      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(TargetDir)ddkinline.obj;%(Outputs)</Outputs>
      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkObjects>
      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkObjects>
    </CustomBuild>
    <ClCompile Include="interlocked.cpp" />
    <ClCompile Include="irp.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="irql.cpp" />
    <ClCompile Include="list.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="load.cpp" />
    <ClCompile Include="local.cpp" />
    <ClCompile Include="log.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="mdl.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="name.cpp" />
    <ClCompile Include="object.cpp" />
    <ClCompile Include="pnp.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="registry.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="shared.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="spinlock.cpp" />
    <ClCompile Include="mutex.cpp" />
    <ClCompile Include="semaphore.cpp" />
    <ClCompile Include="slist.cpp" />
    <ClCompile Include="rtl.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="stdddk.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="string.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="symlink.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="thread.cpp" />
    <ClCompile Include="time.cpp" />
    <ClCompile Include="timer.cpp" />
    <ClCompile Include="unicode.cpp">
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="unittest.cpp" />
    <ClCompile Include="wait.cpp" />
    <ClCompile Include="ddk.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="wmi.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
      <PrecompiledHeaderFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">stdddk.h</PrecompiledHeaderFile>
      <PrecompiledHeaderOutputFile Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(IntDir)Ddk.pch</PrecompiledHeaderOutputFile>
    </ClCompile>
    <ClCompile Include="workitem.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\ddk.h" />
    <ClInclude Include="..\inc\ddklib.h" />
    <ClInclude Include="..\inc\ddk\ntddk.h" />
    <ClInclude Include="..\inc\ddk\ntddk_defs.h" />
    <ClInclude Include="..\inc\ddk\ddkhdr.h" />
    <ClInclude Include="..\inc\ddk\ntdef.h" />
    <ClInclude Include="..\inc\ddk\ntdef_defs.h" />
    <ClInclude Include="..\inc\ddk\ntifs.h" />
    <ClInclude Include="..\inc\ddk\ntstatus.h" />
    <ClInclude Include="..\inc\ddk\ntstrsafe.h" />
    <ClInclude Include="..\inc\ddk\wdm.h" />
    <ClInclude Include="..\inc\ddk\wdmhdr.h" />
    <ClInclude Include="..\inc\ddk\winnt.h" />
    <ClInclude Include="..\inc\ddk\winnt_defs.h" />
    <ClInclude Include="data.h" />
    <ClInclude Include="defs.h" />
    <ClInclude Include="object.h" />
    <ClInclude Include="resource.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="stdddk.h" />
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="ddk.def">
      <Command Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">lib.exe /NOLOGO /OUT:"$(TargetDir)ddkcrt.lib" "$(FrameworkSdkDir)\lib\win7\km\x64\BufferOverflowK.lib" "$(FrameworkSdkDir)\lib\win7\km\x64\ntoskrnl.lib" /REMOVE:ntoskrnl.exe /ignore:4221,4006</Command>
      <Message Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Creating ddkcrt.lib...</Message>
      <Outputs Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">$(TargetDir)ddkcrt.lib;%(Outputs)</Outputs>
      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</LinkObjects>
      <Command Condition="'$(Configuration)|$(Platform)'=='Release|x64'">lib.exe /NOLOGO /OUT:"$(TargetDir)ddkcrt.lib" "$(FrameworkSdkDir)\lib\win7\km\x64\BufferOverflowK.lib" "$(FrameworkSdkDir)\lib\win7\km\x64\ntoskrnl.lib" /REMOVE:ntoskrnl.exe /ignore:4221,4006</Command>
      <Message Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Creating ddkcrt.lib...</Message>
      <Outputs Condition="'$(Configuration)|$(Platform)'=='Release|x64'">$(TargetDir)ddkcrt.lib;%(Outputs)</Outputs>
      <LinkObjects Condition="'$(Configuration)|$(Platform)'=='Release|x64'">false</LinkObjects>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Ddk.rc" />
  </ItemGroup>
  <ItemGroup>
    <MASM Include="detours_x64.asm" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`src/Ddk.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{6535AC32-D6C1-4017-8795-A5F9B0B13A58}</UniqueIdentifier>
      <Extensions>cpp;c;cxx;rc;def;r;odl;idl;hpj;bat</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{A4567765-E816-4D44-8234-F13A30C25A71}</UniqueIdentifier>
      <Extensions>h;hpp;hxx;hm;inl</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="event.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mutex.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wait.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="slist.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="time.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="thread.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="timer.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="semaphore.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dpc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="workitem.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="irql.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="spinlock.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="object.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="interlocked.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="mdl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="irp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="memory.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="list.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="device.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="alloc.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ddk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="driver.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="name.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="rtl.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="file.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="symlink.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="log.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="load.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="data.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="init.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="shared.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="exception.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="cpu.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="wmi.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="crt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdddk.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bitmap.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="string.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unicode.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="unittest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="executive.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="pnp.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="dbg.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bcrypt.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="detours.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="registry.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="local.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="object.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddklib.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="data.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ddkhdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\wdmhdr.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\wdm.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntddk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntstatus.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\winnt_defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntifs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\winnt.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntdef.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntddk_defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntdef_defs.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdddk.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\ddk\ntstrsafe.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="resource.h">
      <Filter>Source Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ResourceCompile Include="Ddk.rc">
      <Filter>Source Files</Filter>
    </ResourceCompile>
  </ItemGroup>
  <ItemGroup>
    <CustomBuild Include="ddk.def" />
    <CustomBuild Include="inline.c">
      <Filter>Source Files</Filter>
    </CustomBuild>
  </ItemGroup>
  <ItemGroup>
    <MASM Include="detours_x64.asm">
      <Filter>Source Files</Filter>
    </MASM>
  </ItemGroup>
</Project>
```

`src/alloc.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Allocation Routines
 */

#include "stdddk.h"


#undef ExFreePool
#undef ExInitializeNPagedLookasideList


DDKAPI
PVOID ExAllocatePoolWithTag(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag)
{
	return _aligned_malloc(NumberOfBytes, (NumberOfBytes < PAGE_SIZE) ? 16 : PAGE_SIZE);
}


DDKAPI
PVOID ExAllocatePool(POOL_TYPE PoolType, SIZE_T NumberOfBytes)
{
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 0);
}


DDKAPI
PVOID ExAllocatePoolWithTagPriority(POOL_TYPE PoolType, SIZE_T NumberOfBytes,
    ULONG Tag, EX_POOL_PRIORITY Priority)
{
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, 0);
}


DDKAPI
VOID ExFreePoolWithTag(PVOID P, ULONG Tag)
{
	_aligned_free(P);
}


DDKAPI
VOID ExFreePool(PVOID P)
{
	ExFreePoolWithTag(P, 0);
}


DDKAPI
VOID ExInitializePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside,
	PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth)
{
	memset(Lookaside, 0, sizeof(PAGED_LOOKASIDE_LIST));
	ExInitializeSListHead(&Lookaside->L.ListHead);
	Lookaside->L.Allocate = Allocate ? Allocate : ExAllocatePoolWithTag;
	Lookaside->L.Free = Free ? Free : ExFreePool;
	Lookaside->L.Size = (ULONG)Size;
	Lookaside->L.Tag = Tag;
	Lookaside->L.Depth = Depth;
	Lookaside->L.Type = PagedPool;
}


DDKAPI
VOID ExDeletePagedLookasideList(PPAGED_LOOKASIDE_LIST Lookaside)
{
	PVOID Entry;
	while ((Entry = (PVOID)InterlockedPopEntrySList(&Lookaside->L.ListHead)) != 0)
		(Lookaside->L.Free)(Entry);
}


DDKAPI
VOID ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside,
	PALLOCATE_FUNCTION Allocate, PFREE_FUNCTION Free, ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth)
{
	memset(Lookaside, 0, sizeof(NPAGED_LOOKASIDE_LIST));
	ExInitializeSListHead(&Lookaside->L.ListHead);
	Lookaside->L.Allocate = Allocate ? Allocate : ExAllocatePoolWithTag;
	Lookaside->L.Free = Free ? Free : ExFreePool;
	Lookaside->L.Size = (ULONG)Size;
	Lookaside->L.Tag = Tag;
	Lookaside->L.Depth = Depth;
	Lookaside->L.Type = NonPagedPool;
}


DDKAPI
VOID ExDeleteNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside)
{
	PVOID Entry;
	while ((Entry = (PVOID)InterlockedPopEntrySList(&Lookaside->L.ListHead)) != 0)
		(Lookaside->L.Free)(Entry);
}


static
PVOID DdkAllocateEx(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag, PLOOKASIDE_LIST_EX Lookaside)
{
	UNREFERENCED_PARAMETER(Lookaside);
	return ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);
}


static
VOID DdkFreeEx(PVOID P, PLOOKASIDE_LIST_EX Lookaside)
{
	UNREFERENCED_PARAMETER(Lookaside);
	ExFreePoolWithTag(P, 0);
}


DDKAPI
NTSTATUS ExInitializeLookasideListEx(PLOOKASIDE_LIST_EX Lookaside,
    PALLOCATE_FUNCTION_EX Allocate, PFREE_FUNCTION_EX Free, POOL_TYPE PoolType,
	ULONG Flags, SIZE_T Size, ULONG Tag, USHORT Depth)
{
	memset(Lookaside, 0, sizeof(PLOOKASIDE_LIST_EX));
	ExInitializeSListHead(&Lookaside->L.ListHead);
	Lookaside->L.AllocateEx = Allocate ? Allocate : DdkAllocateEx;
	Lookaside->L.FreeEx = Free ? Free : DdkFreeEx;
	Lookaside->L.Type = PoolType;
	Lookaside->L.Size = (ULONG)Size;
	Lookaside->L.Tag = Tag;
	Lookaside->L.Depth = Depth;
	return STATUS_SUCCESS;
}


DDKAPI
VOID ExDeleteLookasideListEx(PLOOKASIDE_LIST_EX Lookaside)
{
	PVOID Entry;
	while ((Entry = (PVOID)InterlockedPopEntrySList(&Lookaside->L.ListHead)) != 0)
		(Lookaside->L.FreeEx)(Entry, Lookaside);
}


```

`src/bcrypt.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2018, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Encryption Routines
 */

#include "stdafx.h"

typedef PVOID BCRYPT_HANDLE;
typedef PVOID BCRYPT_ALG_HANDLE;
typedef PVOID BCRYPT_KEY_HANDLE;


DDKAPI
NTSTATUS BCryptOpenAlgorithmProvider(
	_Out_       BCRYPT_ALG_HANDLE   *phAlgorithm,
	_In_        LPCWSTR pszAlgId,
	_In_opt_    LPCWSTR pszImplementation,
	_In_        ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptCloseAlgorithmProvider(
	_Inout_ BCRYPT_ALG_HANDLE   hAlgorithm,
	_In_    ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptSetProperty(
	_Inout_                 BCRYPT_HANDLE   hObject,
	_In_                    LPCWSTR pszProperty,
	_In_reads_bytes_(cbInput)    PUCHAR   pbInput,
	_In_                    ULONG   cbInput,
	_In_                    ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptGetProperty(
	_In_                                        BCRYPT_HANDLE   hObject,
	_In_                                        LPCWSTR pszProperty,
	_Out_writes_bytes_to_opt_(cbOutput, *pcbResult) PUCHAR   pbOutput,
	_In_                                        ULONG   cbOutput,
	_Out_                                       ULONG   *pcbResult,
	_In_                                        ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptGenerateSymmetricKey(
	_Inout_                             BCRYPT_ALG_HANDLE   hAlgorithm,
	_Out_                               BCRYPT_KEY_HANDLE   *phKey,
	_Out_writes_bytes_all_opt_(cbKeyObject)  PUCHAR   pbKeyObject,
	_In_                                ULONG   cbKeyObject,
	_In_reads_bytes_(cbSecret)               PUCHAR   pbSecret,
	_In_                                ULONG   cbSecret,
	_In_                                ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptDestroyKey(
	_Inout_ BCRYPT_KEY_HANDLE   hKey)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptEncrypt(
	_Inout_                                     BCRYPT_KEY_HANDLE hKey,
	_In_reads_bytes_opt_(cbInput)                    PUCHAR   pbInput,
	_In_                                        ULONG   cbInput,
	_In_opt_                                    VOID    *pPaddingInfo,
	_Inout_updates_bytes_opt_(cbIV)                    PUCHAR   pbIV,
	_In_                                        ULONG   cbIV,
	_Out_writes_bytes_to_opt_(cbOutput, *pcbResult) PUCHAR   pbOutput,
	_In_                                        ULONG   cbOutput,
	_Out_                                       ULONG   *pcbResult,
	_In_                                        ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptDecrypt(
	_Inout_                                     BCRYPT_KEY_HANDLE   hKey,
	_In_reads_bytes_opt_(cbInput)                    PUCHAR   pbInput,
	_In_                                        ULONG   cbInput,
	_In_opt_                                    VOID    *pPaddingInfo,
	_Inout_updates_bytes_opt_(cbIV)                    PUCHAR   pbIV,
	_In_                                        ULONG   cbIV,
	_Out_writes_bytes_to_opt_(cbOutput, *pcbResult) PUCHAR   pbOutput,
	_In_                                        ULONG   cbOutput,
	_Out_                                       ULONG   *pcbResult,
	_In_                                        ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


DDKAPI
NTSTATUS
BCryptGenRandom(
	_In_opt_                        BCRYPT_ALG_HANDLE   hAlgorithm,
	_Out_writes_bytes_(cbBuffer)    PUCHAR  pbBuffer,
	_In_                            ULONG   cbBuffer,
	_In_                            ULONG   dwFlags)
{
	return STATUS_NOT_IMPLEMENTED;
}


```

`src/bitmap.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Bitmap Routines
 */

#include "stdddk.h"


static const int BITS_PER_ARRAY = (sizeof(ULONG)* 8);
static const int ALL_BITS_SET = 0xFFFFFFFF;


// Forward declarations
ULONG CalculateArrayIndexFromBitNum(ULONG bitNumber);
ULONG CalculateBitPositionInArrayElement(ULONG bitNumber, ULONG arrayIndex);
ULONG CalculateLastBufferIndex(ULONG lastBitNum);
VOID ClearArrayElements(PRTL_BITMAP bufferElement, ULONG startingIndex, ULONG endIndex);
VOID ClearBitsInRange(ULONG& bufferElement, ULONG startingIndex, ULONG endIndex);
VOID SetArrayElements(PRTL_BITMAP bufferElement, ULONG startingIndex, ULONG endIndex);
VOID SetBitsInRange(ULONG& bufferElement, ULONG startingIndex, ULONG endIndex);
ULONG CalculateBitNumberInBitMap(ULONG bufferIndex, ULONG bitPosition);
VOID CountClearRun(ULONG& bufferElement, ULONG bufferIndex, ULONG startBitPosition,
	ULONG lastBitPosition, bool& runStarted, bool& runEnded, ULONG& startBit, ULONG& runCount);
bool NumClearBitsFound(ULONG& bufferElement, ULONG bufferIndex, ULONG numToFind,
	ULONG startBitPosition, ULONG endBitPosition, bool& runStarted, ULONG& startBit, ULONG& runCount);
bool NumSetBitsFound(ULONG& bufferElement, ULONG bufferIndex, ULONG numToFind,
	ULONG startBitPosition, ULONG endBitPosition, bool& runStarted, ULONG& startBit, ULONG& runCount);

DDKAPI
VOID RtlInitializeBitMap(PRTL_BITMAP BitMapHeader, PULONG BitMapBuffer, ULONG SizeOfBitMap)
{
	BitMapHeader->Buffer = BitMapBuffer;
	BitMapHeader->SizeOfBitMap = SizeOfBitMap;
}


DDKAPI
VOID RtlClearBit(PRTL_BITMAP BitMapHeader, ULONG BitNumber)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

	ULONG array_index = CalculateArrayIndexFromBitNum(BitNumber);
	ClearBitsInRange(BitMapHeader->Buffer[array_index], BitNumber, BitNumber);
}


DDKAPI
VOID RtlSetBit(PRTL_BITMAP BitMapHeader, ULONG BitNumber)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

	ULONG array_index = CalculateArrayIndexFromBitNum(BitNumber);
	SetBitsInRange(BitMapHeader->Buffer[array_index], BitNumber, BitNumber);
}

DDKAPI
BOOLEAN RtlTestBit(PRTL_BITMAP BitMapHeader, ULONG BitNumber)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT(BitNumber < BitMapHeader->SizeOfBitMap);

	ULONG array_index = CalculateArrayIndexFromBitNum(BitNumber);

	return BitMapHeader->Buffer[array_index] & (1 << BitNumber) ? true : false;
}


DDKAPI
VOID RtlClearAllBits(PRTL_BITMAP BitMapHeader)
{
	DDKASSERT(NULL != BitMapHeader);

	const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
	const ULONG last_bit_number = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

	// Zero all buffer elements up to the last element if
	// there is greater than one element
	if (last_buffer_index > 0)
		ClearArrayElements(BitMapHeader, 0, (last_buffer_index - 1));

	// Clear all the bits in the last buffer element.
	// This may not be 2^n boundary aligned.
	ClearBitsInRange(BitMapHeader->Buffer[last_buffer_index], 0, last_bit_number);
}


DDKAPI
VOID RtlSetAllBits(PRTL_BITMAP BitMapHeader)
{
	DDKASSERT(NULL != BitMapHeader);

	const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
	const ULONG last_bit_number = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

	// Set the bits in all buffer elements up to the last element if
	// there is greater than one element
	if (last_buffer_index > 0)
		SetArrayElements(BitMapHeader, 0, (last_buffer_index - 1));

	// Set all the bits in the last buffer element.
	// This may not be 2^n boundary aligned.
	SetBitsInRange(BitMapHeader->Buffer[last_buffer_index], 0, last_bit_number);
}


DDKAPI
VOID RtlClearBits(PRTL_BITMAP BitMapHeader, ULONG StartingIndex, ULONG NumberToClear)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT((StartingIndex + NumberToClear) <= BitMapHeader->SizeOfBitMap);

	if (0 != NumberToClear)
	{
		const ULONG start_buffer_index = CalculateArrayIndexFromBitNum(StartingIndex);
		const ULONG starting_bit_position = CalculateBitPositionInArrayElement(StartingIndex, start_buffer_index);

		const ULONG last_bit = (StartingIndex + NumberToClear) - 1;
		const ULONG last_buffer_index = CalculateLastBufferIndex(last_bit);
		const ULONG last_bit_position = CalculateBitPositionInArrayElement(last_bit, last_buffer_index);

		if (start_buffer_index == last_buffer_index)
		{
			// These may not be 2^n boundary aligned.
			ClearBitsInRange(BitMapHeader->Buffer[last_buffer_index], starting_bit_position, last_bit_position);
		}
		else
		{
			// Clear the bits in the first buffer element.
			// These may not be 2^n boundary aligned.
			ClearBitsInRange(BitMapHeader->Buffer[start_buffer_index], starting_bit_position, (BITS_PER_ARRAY - 1));

			// Clear all the buffer elements between the start buffer and end buffer.
			ClearArrayElements(BitMapHeader, (start_buffer_index + 1), (last_buffer_index - 1));

			// Clear the bits in the last buffer element.
			// These may not be 2^n boundary aligned.
			ClearBitsInRange(BitMapHeader->Buffer[last_buffer_index], 0, last_bit_position);
		}
	}
}


DDKAPI
VOID RtlSetBits(PRTL_BITMAP BitMapHeader, ULONG StartingIndex, ULONG NumberToSet)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT((StartingIndex + NumberToSet) <= BitMapHeader->SizeOfBitMap);

	if (0 != NumberToSet)
	{
		const ULONG start_buffer_index = CalculateArrayIndexFromBitNum(StartingIndex);
		const ULONG starting_bit_position = CalculateBitPositionInArrayElement(StartingIndex, start_buffer_index);

		const ULONG last_bit = (StartingIndex + NumberToSet) - 1;
		const ULONG last_buffer_index = CalculateLastBufferIndex(last_bit);
		const ULONG last_bit_position = CalculateBitPositionInArrayElement(last_bit, last_buffer_index);

		if (start_buffer_index == last_buffer_index)
		{
			// These may not be 2^n boundary aligned.
			SetBitsInRange(BitMapHeader->Buffer[last_buffer_index], starting_bit_position, last_bit_position);
		}
		else
		{
			// Set the bits in the first buffer element.
			// These may not be 2^n boundary aligned.
			SetBitsInRange(BitMapHeader->Buffer[start_buffer_index], starting_bit_position, (BITS_PER_ARRAY - 1));

			// Set all the buffer elements between the start buffer and last buffer.
			SetArrayElements(BitMapHeader, (start_buffer_index + 1), (last_buffer_index - 1));

			// Set the bits in the last buffer element.
			// These may not be 2^n boundary aligned.
			SetBitsInRange(BitMapHeader->Buffer[last_buffer_index], 0, last_bit_position);
		}
	}
}


DDKAPI
ULONG RtlFindNextForwardRunClear(PRTL_BITMAP BitMapHeader, ULONG FromIndex, PULONG StartingRunIndex)
{
	DDKASSERT(NULL != BitMapHeader);
	DDKASSERT(FromIndex < BitMapHeader->SizeOfBitMap);
	DDKASSERT(NULL != StartingRunIndex);

	ULONG run_count = 0;

	const ULONG start_buffer_index = CalculateArrayIndexFromBitNum(FromIndex);
	const ULONG start_bit_position = CalculateBitPositionInArrayElement(FromIndex, start_buffer_index);

	const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
	const ULONG last_bit_position = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

	ULONG run_start_bit = 0;
	bool run_started = FALSE;
	bool run_ended = FALSE;

	if (start_buffer_index == last_buffer_index)
	{
		CountClearRun(BitMapHeader->Buffer[start_buffer_index], start_buffer_index,
			start_bit_position, last_bit_position, run_started, run_ended, run_start_bit, run_count);
        *StartingRunIndex = run_start_bit;
		return run_count;
	}

	// Search the first buffer element
	CountClearRun(BitMapHeader->Buffer[start_buffer_index], start_buffer_index,
		start_bit_position, (BITS_PER_ARRAY - 1), run_started, run_ended, run_start_bit, run_count);

	if (run_ended)
	{
		*StartingRunIndex = run_start_bit;
		return run_count;
	}

	// Search buffer elements between the start and last buffers if the run
	// has not already ended.
	for (ULONG buffer_index = (start_buffer_index + 1); buffer_index < last_buffer_index; buffer_index++)
	{
		CountClearRun(BitMapHeader->Buffer[buffer_index], buffer_index, 0,
			(BITS_PER_ARRAY - 1), run_started, run_ended, run_start_bit, run_count);

		if (run_ended)
		{
			*StartingRunIndex = run_start_bit;
			return run_count;
		}
	}

	// Search the last buffer element
	CountClearRun(BitMapHeader->Buffer[last_buffer_index], last_buffer_index,
		0, last_bit_position, run_started, run_ended, run_start_bit, run_count);
	
	*StartingRunIndex = run_start_bit;
	return run_count;
}

DDKAPI
ULONG RtlFindFirstRunClear(PRTL_BITMAP BitMapHeader, PULONG StartingRunIndex) {
	return RtlFindNextForwardRunClear(BitMapHeader, 0, StartingRunIndex);
}

DDKAPI
BOOLEAN RtlAreBitsClear(PRTL_BITMAP BitMapHeader, ULONG StartingIndex, ULONG Length)
{
	DDKASSERT(NULL != BitMapHeader);

	if ((0 == Length) || (BitMapHeader->SizeOfBitMap < (StartingIndex + Length)))
	{
		return FALSE;
	}
	else
	{
		const ULONG start_buffer_index = CalculateArrayIndexFromBitNum(StartingIndex);
		const ULONG start_bit_number = CalculateBitPositionInArrayElement(StartingIndex, start_buffer_index);

		const ULONG last_buffer_index = CalculateArrayIndexFromBitNum((StartingIndex + Length - 1));
		const ULONG last_bit_number = CalculateBitPositionInArrayElement((StartingIndex + Length - 1), last_buffer_index);

		ULONG bits_checked = 0;

		if (start_buffer_index == last_buffer_index)
		{
			for (ULONG bit_num = start_bit_number; bit_num <= last_bit_number; bit_num++)
			{
				if (Length > bits_checked)
				{
					ULONG bit_set = BitMapHeader->Buffer[last_buffer_index] & (1 << bit_num);
					if (bit_set)
					{
						return FALSE;
					}

					bits_checked++;
				}
			}
			return TRUE;
		}

		// Search the start buffer element.
		for (ULONG bit_num = start_bit_number; bit_num < BITS_PER_ARRAY; bit_num++)
		{
			if (Length > bits_checked)
			{
				ULONG bit_set = BitMapHeader->Buffer[start_buffer_index] & (1 << bit_num);
				if (bit_set)
				{
					return FALSE;
				}

				bits_checked++;
			}
			else
			{
				return TRUE;
			}
		}

		// Search the buffer elements between start and last buffers.
		for (ULONG buffer_num = (start_buffer_index + 1); buffer_num < last_buffer_index; buffer_num++)
		{
			if (Length > bits_checked)
			{
				if (0 != BitMapHeader->Buffer[buffer_num])
				{
					return FALSE;
				}
				bits_checked += BITS_PER_ARRAY;
			}
			else
			{
				return TRUE;
			}
		}

		// Search the last buffer element.
		for (ULONG bit_num = 0; bit_num <= last_bit_number; bit_num++)
		{
			if (Length > bits_checked)
			{
				ULONG bit_set = BitMapHeader->Buffer[last_buffer_index] & (1 << bit_num);
				if (bit_set)
				{
					return FALSE;
				}

				bits_checked++;
			}
		}
	}

	return TRUE;
}


DDKAPI
BOOLEAN RtlAreBitsSet(PRTL_BITMAP BitMapHeader, ULONG StartingIndex, ULONG Length)
{
	DDKASSERT(NULL != BitMapHeader);

	if ((0 == Length) || (BitMapHeader->SizeOfBitMap < (StartingIndex + Length)))
	{
		return FALSE;
	}
	else
	{
		const ULONG start_buffer_index = CalculateArrayIndexFromBitNum(StartingIndex);
		const ULONG start_bit_number = CalculateBitPositionInArrayElement(StartingIndex, start_buffer_index);

		const ULONG last_buffer_index = CalculateArrayIndexFromBitNum((StartingIndex + Length - 1));
		const ULONG last_bit_number = CalculateBitPositionInArrayElement((StartingIndex + Length - 1), last_buffer_index);

		ULONG bits_checked = 0;

		if (start_buffer_index == last_buffer_index)
		{
			for (ULONG bit_num = start_bit_number; bit_num <= last_bit_number; bit_num++)
			{
				if (Length > bits_checked)
				{
					ULONG bit_set = BitMapHeader->Buffer[last_buffer_index] & (1 << bit_num);
					if (!bit_set)
					{
						return FALSE;
					}

					bits_checked++;
				}
			}
			return TRUE;
		}

		// Search the start buffer element.
		for (ULONG bit_num = start_bit_number; bit_num < BITS_PER_ARRAY; bit_num++)
		{
			if (Length > bits_checked)
			{
				ULONG bit_set = BitMapHeader->Buffer[start_buffer_index] & (1 << bit_num);
				if (!bit_set)
				{
					return FALSE;
				}

				bits_checked++;
			}
			else
			{
				return TRUE;
			}
		}

		// Search the buffer elements between start and last buffers.
		for (ULONG buffer_num = (start_buffer_index + 1); buffer_num < last_buffer_index; buffer_num++)
		{
			if (Length > bits_checked)
			{
				if (ALL_BITS_SET != BitMapHeader->Buffer[buffer_num])
				{
					return FALSE;
				}
				bits_checked += BITS_PER_ARRAY;
			}
			else
			{
				return TRUE;
			}
		}

		// Search the last buffer element.
		for (ULONG bit_num = 0; bit_num <= last_bit_number; bit_num++)
		{
			if (Length > bits_checked)
			{
				ULONG bit_set = BitMapHeader->Buffer[last_buffer_index] & (1 << bit_num);
				if (!bit_set)
				{
					return FALSE;
				}

				bits_checked++;
			}
		}
	}

	return TRUE;
}


DDKAPI
ULONG RtlFindClearBits(PRTL_BITMAP BitMapHeader, ULONG NumberToFind, ULONG HintIndex)
{
	DDKASSERT(NULL != BitMapHeader);

	if (NumberToFind < BitMapHeader->SizeOfBitMap)
	{
		ULONG start_buffer_index = CalculateArrayIndexFromBitNum(HintIndex);
		ULONG start_bit_position = CalculateBitPositionInArrayElement(HintIndex, start_buffer_index);

		const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
		const ULONG last_bit_position = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

		ULONG num_bits_to_check = BitMapHeader->SizeOfBitMap - HintIndex;

		bool run_started = FALSE;
		int loop_count = 2;

		ULONG start_bit = ALL_BITS_SET;
		ULONG run_count = 0;

		bool num_clear_bits_found = FALSE;

		// If the number of clear bits to find is greater than the number of bits between
		// HintIndex and the end of the bit map OR HintIndex is greater than the size of the bit map
		// start looking from the start of the bit map.
		if ((NumberToFind > num_bits_to_check) || (BitMapHeader->SizeOfBitMap <= HintIndex))
		{
			start_buffer_index = 0;
			start_bit_position = 0;
			loop_count--;
		}

		while (0 != loop_count)
		{
			if (start_buffer_index == last_buffer_index)
			{
				num_clear_bits_found = NumClearBitsFound(BitMapHeader->Buffer[start_buffer_index],
					start_buffer_index, NumberToFind, start_bit_position, last_bit_position, run_started, start_bit, run_count);
				if (num_clear_bits_found)
				{
					return start_bit;
				}
			}
			else
			{
				// Search through the start buffer element.
				num_clear_bits_found = NumClearBitsFound(BitMapHeader->Buffer[start_buffer_index],
					start_buffer_index, NumberToFind, start_bit_position, (BITS_PER_ARRAY - 1), run_started, start_bit, run_count);
				if (num_clear_bits_found)
				{
					return start_bit;
				}

				// Check all the buffer elements between start and last.
				if (!num_clear_bits_found)
				{
					for (ULONG buffer_index = (start_buffer_index + 1); buffer_index < last_buffer_index; buffer_index++)
					{
						num_clear_bits_found = NumClearBitsFound(BitMapHeader->Buffer[buffer_index],
							buffer_index, NumberToFind, 0, (BITS_PER_ARRAY - 1), run_started, start_bit, run_count);
						if (num_clear_bits_found)
						{
							return start_bit;
						}
					}
				}

				// Search through the last buffer
				if (!num_clear_bits_found)
				{
					num_clear_bits_found = NumClearBitsFound(BitMapHeader->Buffer[last_buffer_index],
						last_buffer_index, NumberToFind, 0, last_bit_position, run_started, start_bit, run_count);
					if (num_clear_bits_found)
					{
						return start_bit;
					}
				}
			}

			// Reset variables before going back around the loop.
			if (!num_clear_bits_found)
			{
				start_buffer_index = 0;
				start_bit_position = 0;
				run_started = FALSE;
				run_count = 0;
				loop_count--;
			}
			else
			{
				loop_count = 0;
			}
		}
	}

	return ALL_BITS_SET;
}


DDKAPI
ULONG RtlFindSetBits(PRTL_BITMAP BitMapHeader, ULONG NumberToFind, ULONG HintIndex)
{
	DDKASSERT(NULL != BitMapHeader);

	if (NumberToFind < BitMapHeader->SizeOfBitMap)
	{
		ULONG start_buffer_index = CalculateArrayIndexFromBitNum(HintIndex);
		ULONG start_bit_position = CalculateBitPositionInArrayElement(HintIndex, start_buffer_index);

		const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
		const ULONG last_bit_position = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

		ULONG num_bits_to_check = BitMapHeader->SizeOfBitMap - HintIndex;

		bool run_started = FALSE;
		int loop_count = 2;

		ULONG start_bit = ALL_BITS_SET;
		ULONG run_count = 0;

		bool num_set_bits_found = FALSE;

		// If the number of set bits to find is greater than the number of bits between
		// HintIndex and the end of the bit map OR HintIndex is greater than the size of the bit map,
		// start looking from the start of the bit map.
		if ((NumberToFind > num_bits_to_check) || (BitMapHeader->SizeOfBitMap <= HintIndex))
		{
			start_buffer_index = 0;
			start_bit_position = 0;
			loop_count--;
		}

		while (0 != loop_count)
		{
			if (start_buffer_index == last_buffer_index)
			{
				num_set_bits_found = NumSetBitsFound(BitMapHeader->Buffer[start_buffer_index], 
					start_buffer_index, NumberToFind, start_bit_position, last_bit_position, run_started, start_bit, run_count);
				if (num_set_bits_found)
				{
					return start_bit;
				}
			}
			else
			{
				// Search through the start buffer element.
				num_set_bits_found = NumSetBitsFound(BitMapHeader->Buffer[start_buffer_index], start_buffer_index, NumberToFind, start_bit_position, (BITS_PER_ARRAY - 1), run_started, start_bit, run_count);
				if (num_set_bits_found)
				{
					return start_bit;
				}

				// Check all the buffer elements between start and last.
				if (!num_set_bits_found)
				{
					for (ULONG buffer_index = (start_buffer_index + 1); buffer_index < last_buffer_index; buffer_index++)
					{
						num_set_bits_found = NumSetBitsFound(BitMapHeader->Buffer[buffer_index], buffer_index, NumberToFind, 0, (BITS_PER_ARRAY - 1), run_started, start_bit, run_count);
						if (num_set_bits_found)
						{
							return start_bit;
							break;
						}
					}
				}

				// Search through the last buffer
				if (!num_set_bits_found)
				{
					num_set_bits_found = NumSetBitsFound(BitMapHeader->Buffer[last_buffer_index], last_buffer_index, NumberToFind, 0, last_bit_position, run_started, start_bit, run_count);
					if (num_set_bits_found)
					{
						return start_bit;
					}
				}
			}

			// Reset variables before going back around the loop.
			if (!num_set_bits_found)
			{
				start_buffer_index = 0;
				start_bit_position = 0;
				run_started = FALSE;
				run_count = 0;
				loop_count--;
			}
			else
			{
				loop_count = 0;
			}
		}
	}

	return ALL_BITS_SET;
}


DDKAPI
ULONG RtlNumberOfSetBits(PRTL_BITMAP BitMapHeader)
{
	DDKASSERT(NULL != BitMapHeader);

	ULONG number_of_set_bits = 0;
	const ULONG last_buffer_index = CalculateLastBufferIndex(BitMapHeader->SizeOfBitMap - 1);
	const ULONG last_bit_position = CalculateBitPositionInArrayElement((BitMapHeader->SizeOfBitMap - 1), last_buffer_index);

	// Check all buffer elements up to the last element
	for (ULONG buffer_index = 0; buffer_index < last_buffer_index; buffer_index++)
	{
		if (ALL_BITS_SET == BitMapHeader->Buffer[buffer_index])
		{
			number_of_set_bits += BITS_PER_ARRAY;
		}
		else
		{
			for (ULONG bit_num = 0; bit_num < BITS_PER_ARRAY; bit_num++)
			{
				ULONG bit_set = BitMapHeader->Buffer[buffer_index] & (1 << bit_num);
				if (bit_set)
				{
					number_of_set_bits++;
				}
			}
		}
	}

	// Check last buffer element
	for (ULONG bit_num = 0; bit_num <= last_bit_position; bit_num++)
	{
		ULONG bit_set = BitMapHeader->Buffer[last_buffer_index] & (1 << bit_num);
		if (bit_set)
		{
			number_of_set_bits++;
		}
	}

	return number_of_set_bits;
}


DDKAPI
ULONG RtlFindClearBitsAndSet(PRTL_BITMAP BitMapHeader, ULONG NumberToFind, ULONG HintIndex)
{
	ULONG startBitIndex = RtlFindClearBits(BitMapHeader, NumberToFind, HintIndex);

	if (startBitIndex != ALL_BITS_SET)
		RtlSetBits(BitMapHeader, startBitIndex, NumberToFind);

	return startBitIndex;
}


DDKAPI
ULONG RtlFindSetBitsAndClear(PRTL_BITMAP BitMapHeader, ULONG NumberToFind, ULONG HintIndex)
{
	ULONG startBitIndex = RtlFindSetBits(BitMapHeader, NumberToFind, HintIndex);

	if (startBitIndex != ALL_BITS_SET)
		RtlClearBits(BitMapHeader, startBitIndex, NumberToFind);

	return startBitIndex;
}

/*
 *	Start of commonly used functions 
 */

// Calculate the array index from the given bit number.
ULONG CalculateArrayIndexFromBitNum(ULONG bitNumber)
{
	ULONG array_index = bitNumber / BITS_PER_ARRAY;
	return(array_index);
}

// Calculates the bit position within the given array element from the overall bit number
ULONG CalculateBitPositionInArrayElement(ULONG bitNumber, ULONG arrayIndex)
{
	ULONG bit_position = bitNumber - (arrayIndex * BITS_PER_ARRAY);
	return(bit_position);
}

// Calculates the last buffer index from the number of bits in the buffer
ULONG CalculateLastBufferIndex(ULONG lastBitNum)
{
	ULONG last_buffer_index = lastBitNum / BITS_PER_ARRAY;
	return(last_buffer_index);
}

// Clear array elements
VOID ClearArrayElements(PRTL_BITMAP bufferElement, ULONG startingIndex, ULONG endIndex)
{
	for (ULONG buffer_index = startingIndex; buffer_index <= endIndex; buffer_index++)
	{
		bufferElement->Buffer[buffer_index] = 0;
	}
}

// Clears all the bits in range to a 0.
VOID ClearBitsInRange(ULONG& bufferElement, ULONG startingIndex, ULONG endIndex)
{
	for (ULONG bit_num = startingIndex; bit_num <= endIndex; bit_num++)
	{
		bufferElement &= ~(1 << bit_num);
	}
}

// Set array elements
VOID SetArrayElements(PRTL_BITMAP bufferElement, ULONG startingIndex, ULONG endIndex)
{
	for (ULONG buffer_index = startingIndex; buffer_index <= endIndex; buffer_index++)
	{
		bufferElement->Buffer[buffer_index] = ALL_BITS_SET;
	}
}

// Sets all the bits in range to a 1.
VOID SetBitsInRange(ULONG& bufferElement, ULONG startingIndex, ULONG endIndex)
{
	for (ULONG bit_num = startingIndex; bit_num <= endIndex; bit_num++)
	{
		bufferElement |= (1 << bit_num);
	}
}

// Calculate the overall bit number in the bit map from the buffer index and bit position.
ULONG CalculateBitNumberInBitMap(ULONG bufferIndex, ULONG bitPosition)
{
	ULONG bit_number = (bufferIndex * BITS_PER_ARRAY) + bitPosition;
	return bit_number;
}

// Count the number of clear bits in a given buffer element.
// This function indicates when a run has started and finished and returns start of the run together
// with the number of clear bits in the run.
VOID CountClearRun(ULONG& bufferElement, ULONG bufferIndex, ULONG startBitPosition,
	ULONG lastBitPosition, bool& runStarted, bool& runEnded, ULONG& startBit, ULONG& runCount)
{
	// If the buffer contains all zeros and a run has not started, the start
	// of the run is the start bit position
	if ((0 == bufferElement) && (!runStarted))
	{
		startBit = CalculateBitNumberInBitMap(bufferIndex, startBitPosition);
		runCount = (lastBitPosition - startBitPosition) + 1;
		runStarted = TRUE;
		runEnded = FALSE;
	}
	// If the buffer contains all zeros and the run has started, add 32 to the run count.
	else if ((0 == bufferElement) && (runStarted))
	{
		runCount += BITS_PER_ARRAY;
	}
	// If the buffer does not contain all zeros, search for the start and end of the run.
	else
	{
		for (ULONG bit_position = startBitPosition; bit_position <= lastBitPosition; bit_position++)
		{
			ULONG bit_set = bufferElement & (1 << bit_position);
			if (!bit_set)
			{
				if (!runStarted)
				{
					startBit = CalculateBitNumberInBitMap(bufferIndex, bit_position);
					runStarted = TRUE;
				}
				runCount++;
			}
			else if (bit_set && runStarted)
			{
				runEnded = TRUE;
				break;
			}
		}
	}
}

// Count the number of contiguous clear bits in a given buffer element.
bool NumClearBitsFound(ULONG& bufferElement, ULONG bufferIndex, ULONG numToFind,
	ULONG startBitPosition, ULONG endBitPosition, bool& runStarted, ULONG& startBit, ULONG& runCount)
{
	// If the buffer contains all zeros and a run has not yet started
	if ((0 == bufferElement) && (!runStarted))
	{
		startBit = CalculateBitNumberInBitMap(bufferIndex, startBitPosition);
		runStarted = TRUE;
		runCount += (endBitPosition - startBitPosition) + 1;

		if (runCount >= numToFind)
		{
			return TRUE;
		}
	}
	else if ((0 == bufferElement) && (runStarted))
	{
		runCount += BITS_PER_ARRAY;

		if (runCount >= numToFind)
		{
			return TRUE;
		}
	}
	else
	{
		for (ULONG bit_num = startBitPosition; bit_num <= endBitPosition; bit_num++)
		{
			ULONG bit_set = bufferElement & (1 << bit_num);
			if (!bit_set)
			{
				if (!runStarted)
				{
					startBit = CalculateBitNumberInBitMap(bufferIndex, bit_num);
					runStarted = TRUE;
				}
				runCount++;

				if (runCount >= numToFind)
				{
					return TRUE;
				}
			}
			else
			{
				runCount = 0;
				runStarted = FALSE;
			}
		}
	}

	return FALSE;
}

// Count the number of contiguous set bits in a given buffer element.
bool NumSetBitsFound(ULONG& bufferElement, ULONG bufferIndex, ULONG numToFind,
	ULONG startBitPosition, ULONG endBitPosition, bool& runStarted, ULONG& startBit, ULONG& runCount)
{
	// If the buffer contains all ones and a run has not yet started
	if ((ALL_BITS_SET == bufferElement) && (!runStarted))
	{
		startBit = CalculateBitNumberInBitMap(bufferIndex, startBitPosition);
		runStarted = TRUE;
		runCount += (endBitPosition - startBitPosition) + 1;

		if (runCount >= numToFind)
		{
			return TRUE;
		}
	}
	else if ((ALL_BITS_SET == bufferElement) && (runStarted))
	{
		runCount += BITS_PER_ARRAY;

		if (runCount >= numToFind)
		{
			return TRUE;
		}
	}
	else
	{
		for (ULONG bit_position = startBitPosition; bit_position <= endBitPosition; bit_position++)
		{
			ULONG bit_set = bufferElement & (1 << bit_position);
			if (bit_set)
			{
				if (!runStarted)
				{
					startBit = CalculateBitNumberInBitMap(bufferIndex, bit_position);
					runStarted = TRUE;
				}
				runCount++;

				if (runCount >= numToFind)
				{
					return TRUE;
				}
			}
			else
			{
				runCount = 0;
				runStarted = FALSE;
			}
		}
	}

	return FALSE;
}

```

`src/cpu.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * CPU Routines.
 */

#include "stdafx.h"


#undef KeNumberProcessors

extern "C" {
extern volatile CCHAR KeNumberProcessors;
extern volatile CCHAR _KeNumberProcessors;
};


void DdkCpuInit()
{
    SYSTEM_INFO sysinfo;
    GetSystemInfo(&sysinfo);
    
	KeNumberProcessors = (CCHAR) sysinfo.dwNumberOfProcessors;
	_KeNumberProcessors = (CCHAR) sysinfo.dwNumberOfProcessors;
}

```

`src/crt.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * CRT Routines.
 */

#include "stdafx.h"


void DdkForceReference()
{
	ddkfail("DdkForceReference called");

	(void)isdigit(0);
	_purecall();
	__C_specific_handler(0,0,0,0);
}

```

`src/data.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Data Definitions
 */

#include "stdddk.h"


extern "C" {

#undef MmBadPointer
PVOID MmBadPointer = 0;
PVOID pMmBadPointer = (PVOID)&MmBadPointer;

#undef KeNumberProcessors
volatile CCHAR KeNumberProcessors;
volatile CCHAR _KeNumberProcessors;

#undef NlsMbCodePageTag
BOOLEAN NlsMbCodePageTag = FALSE;
BOOLEAN *pNlsMbCodePageTag = &NlsMbCodePageTag;

#undef NlsMbOemCodePageTag
BOOLEAN NlsMbOemCodePageTag = FALSE;
BOOLEAN *pNlsMbOemCodePageTag = &NlsMbOemCodePageTag;


/*
 *	Object Type Values
 */

#undef CmKeyObjectType
static OBJECT_TYPE _CmKeyType = { CmKeyType };
POBJECT_TYPE CmKeyObjectType = &_CmKeyType;
POBJECT_TYPE *pCmKeyObjectType = &CmKeyObjectType;

#undef IoFileObjectType
static OBJECT_TYPE _IoFileType = { IoFileType };
POBJECT_TYPE IoFileObjectType = &_IoFileType;
POBJECT_TYPE *pIoFileObjectType = &IoFileObjectType;

#undef ExEventObjectType
static OBJECT_TYPE _ExEventType = { EventType };
POBJECT_TYPE ExEventObjectType = &_ExEventType;
POBJECT_TYPE *pExEventObjectType = &ExEventObjectType;

#undef ExSemaphoreObjectType
static OBJECT_TYPE _ExSemaphoreType = { SemaphoreType };
POBJECT_TYPE ExSemaphoreObjectType = &_ExSemaphoreType;
POBJECT_TYPE *pExSemaphoreObjectType = &ExSemaphoreObjectType;

#undef TmTransactionManagerObjectType
static OBJECT_TYPE _TmTransactionManagerType = { TransactionManagerType };
POBJECT_TYPE TmTransactionManagerObjectType = &_TmTransactionManagerType;
POBJECT_TYPE *pTmTransactionManagerObjectType = &TmTransactionManagerObjectType;

#undef TmResourceManagerObjectType
static OBJECT_TYPE _TmResourceManagerType = { ResourceManagerType };
POBJECT_TYPE TmResourceManagerObjectType = &_TmResourceManagerType;
POBJECT_TYPE *pTmResourceManagerObjectType = &TmResourceManagerObjectType;

#undef TmEnlistmentObjectType
static OBJECT_TYPE _TmEnlistmentType = { EnlistmentType };
POBJECT_TYPE TmEnlistmentObjectType = &_TmEnlistmentType;
POBJECT_TYPE *pTmEnlistmentObjectType = &TmEnlistmentObjectType;

#undef TmTransactionObjectType
static OBJECT_TYPE _TmTransactionType = { TransactionType };
POBJECT_TYPE TmTransactionObjectType = &_TmTransactionType;
POBJECT_TYPE *pTmTransactionObjectType = &TmTransactionObjectType;

#undef PsProcessType
static OBJECT_TYPE _PsProcessType = { ProcessType };
POBJECT_TYPE PsProcessType = &_PsProcessType;
POBJECT_TYPE *pPsProcessType = &PsProcessType;

#undef PsThreadType
static OBJECT_TYPE _PsThreadType = { ThreadType };
POBJECT_TYPE PsThreadType = &_PsThreadType;
POBJECT_TYPE *pPsThreadType = &PsThreadType;

#undef SeTokenObjectType
static OBJECT_TYPE _SeTokenType = { SecurityTokenType };
POBJECT_TYPE SeTokenObjectType = &_SeTokenType;
POBJECT_TYPE *pSeTokenObjectType = &SeTokenObjectType;

};

```

`src/data.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Data Definitions.
 */

#ifndef _DATA_H_
#define _DATA_H_

#define MmBadPointer					pMmBadPointer
#define KeNumberProcessors				_KeNumberProcessors
#define NlsMbCodePageTag				pNlsMbCodePageTag
#define NlsMbOemCodePageTag				pNlsMbOemCodePageTag

#define CmKeyObjectType					pCmKeyObjectType
#define IoFileObjectType				pIoFileObjectType
#define ExEventObjectType				pExEventObjectType
#define ExSemaphoreObjectType			pExSemaphoreObjectType
#define TmTransactionManagerObjectType	pTmTransactionManagerObjectType
#define TmResourceManagerObjectType		pTmResourceManagerObjectType
#define TmEnlistmentObjectType			pTmEnlistmentObjectType
#define TmTransactionObjectType			pTmTransactionObjectType
#define PsProcessType					pPsProcessType
#define PsThreadType					pPsThreadType
#define SeTokenObjectType				pSeTokenObjectType

#endif /* _DATA_H_ */

```

`src/dbg.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
* Debug Routines.
*/

#include "stdafx.h"
#include <dpfilter.h>
#include <stdio.h>
#include <stddef.h>


DDKAPI
ULONG vDbgPrintEx(ULONG ComponentId, ULONG Level, PCCH Format, va_list arglist)
{
	UNREFERENCED_PARAMETER(ComponentId);
	UNREFERENCED_PARAMETER(Level);

	if (IsDebuggerPresent()) {
		char s[2048];
		int n = vsnprintf(s, sizeof(s) - 1, Format, arglist);

		if (n > 0 && n < sizeof(s) - 1 && s[n - 1] != '\n')
			strcpy(s + n, "\n");

		OutputDebugString(s);
	}

	return 0;
}


extern "C"
DDKUSEDECL
ULONG __cdecl DbgPrint(PCSTR Format, ...)
{
	va_list args;
	va_start(args, Format);
	vDbgPrintEx(DPFLTR_DEFAULT_ID, DPFLTR_INFO_LEVEL, Format, args);
	va_end(args);
	return 0;
}


DDKAPI
ULONG DbgPrintEx(ULONG ComponentId, ULONG Level, PCSTR Format, ...)
{
	va_list args;
	va_start(args, Format);
	vDbgPrintEx(ComponentId, Level, Format, args);
	va_end(args);
	return 0;
}

```

`src/ddk.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * DDK routines for user level testing.
 */

#include "stdddk.h"

extern "C" {
#include "tdi.h"
#include "tdikrnl.h"
#include "ws2def.h"
}
#include "netioapi.h"


DDKAPI
NTSTATUS WppAutoLogTrace(PVOID AutoLogContext, UCHAR MessageLevel,
	ULONG MessageFlags, LPGUID MessageGuid, USHORT MessageNumber, ...)
{
	UNREFERENCED_PARAMETER(AutoLogContext);
	UNREFERENCED_PARAMETER(MessageLevel);
	UNREFERENCED_PARAMETER(MessageFlags);
	UNREFERENCED_PARAMETER(MessageGuid);
	UNREFERENCED_PARAMETER(MessageNumber);
	return STATUS_SUCCESS;
}


union WPP_CB_TYPE;

DDKAPI
VOID WppAutoLogStart(WPP_CB_TYPE *WppCb, PDRIVER_OBJECT DrvObj, PCUNICODE_STRING RegPath)
{
	UNREFERENCED_PARAMETER(WppCb);
	UNREFERENCED_PARAMETER(DrvObj);
	UNREFERENCED_PARAMETER(RegPath);
}


DDKAPI
VOID WppAutoLogStop(WPP_CB_TYPE *WppCb, PDRIVER_OBJECT DrvObj)
{
	UNREFERENCED_PARAMETER(WppCb);
	UNREFERENCED_PARAMETER(DrvObj);
}


DDKAPI
NTSTATUS DbgQueryDebugFilterState(ULONG ComponentId, ULONG Level)
{
	UNREFERENCED_PARAMETER(ComponentId);
	UNREFERENCED_PARAMETER(Level);
	return FALSE;
}


DDKAPI
USHORT KeQueryNodeMaximumProcessorCount (USHORT NodeNumber)
{
	UNREFERENCED_PARAMETER(NodeNumber);
	return 64;
}


DDKAPI
PVOID MmMapLockedPagesWithReservedMapping (PVOID MappingAddress,
    ULONG PoolTag, PMDL MemoryDescriptorList, MEMORY_CACHING_TYPE CacheType)
{
	UNREFERENCED_PARAMETER(MappingAddress);
	UNREFERENCED_PARAMETER(PoolTag);
	UNREFERENCED_PARAMETER(MemoryDescriptorList);
	UNREFERENCED_PARAMETER(CacheType);
	return MappingAddress;
}


DDKAPI
VOID MmUnmapReservedMapping (PVOID BaseAddress, ULONG PoolTag, PMDL MemoryDescriptorList)
{
	UNREFERENCED_PARAMETER(BaseAddress);
	UNREFERENCED_PARAMETER(PoolTag);
	UNREFERENCED_PARAMETER(MemoryDescriptorList);

}


DDKAPI
PVOID MmAllocateMappingAddress(SIZE_T NumberOfBytes, ULONG PoolTag)
{
	return ExAllocatePoolWithTag(NonPagedPool, NumberOfBytes, PoolTag);
}


DDKAPI
VOID MmFreeMappingAddress(PVOID BaseAddress, ULONG PoolTag)
{
	ExFreePoolWithTag(BaseAddress, PoolTag);
}


DDKAPI
USHORT KeQueryActiveGroupCount()
{
	return 1;
}


DDKAPI
KAFFINITY KeQueryGroupAffinity(USHORT GroupNumber)
{
	UNREFERENCED_PARAMETER(GroupNumber);
	return 0xf;
}


DDKAPI
ULONG KeGetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber)
{
	// TODO - need a cpuid that is constant until the thread suspends
	UNREFERENCED_PARAMETER(ProcNumber);
	return 0;
}


DDKAPI
ULONG KeQueryActiveProcessorCountEx(USHORT GroupNumber)
{
	UNREFERENCED_PARAMETER(GroupNumber);
	return 16;
}


DDKAPI
VOID ExQueueWorkItem(PWORK_QUEUE_ITEM WorkItem, WORK_QUEUE_TYPE QueueType)
{
	UNREFERENCED_PARAMETER(WorkItem);
	UNREFERENCED_PARAMETER(QueueType);
}


NTSTATUS TdiRegisterPnPHandlers(PTDI_CLIENT_INTERFACE_INFO ClientInterfaceInfo,
    ULONG InterfaceInfoSize, HANDLE *BindingHandle)
{
	UNREFERENCED_PARAMETER(ClientInterfaceInfo);
	UNREFERENCED_PARAMETER(InterfaceInfoSize);
	UNREFERENCED_PARAMETER(BindingHandle);
	return 0;
}


NTSTATUS TdiDeregisterPnPHandlers(HANDLE BindingHandle)
{
	UNREFERENCED_PARAMETER(BindingHandle);
	return 0;
}


struct { PVOID id; PVOID extn; } ExtensionList[10];


DDKAPI
NTSTATUS IoAllocateDriverObjectExtension(PDRIVER_OBJECT DriverObject,
    PVOID ClientIdentificationAddress, ULONG DriverObjectExtensionSize, PVOID *DriverObjectExtension)
{
	*DriverObjectExtension = ExAllocatePool(NonPagedPool, DriverObjectExtensionSize);

	if (!*DriverObjectExtension)
		return STATUS_INSUFFICIENT_RESOURCES;

	for (int i = 0; i < 10; i++)
		if (!ExtensionList[i].id || ExtensionList[i].id == ClientIdentificationAddress) {
			ExtensionList[i].id = ClientIdentificationAddress;
			ExtensionList[i].extn = *DriverObjectExtension;
			return STATUS_SUCCESS;
		}

	return STATUS_UNSUCCESSFUL;
}


DDKAPI
PVOID IoGetDriverObjectExtension(PDRIVER_OBJECT DriverObject, PVOID ClientIdentificationAddress)
{
	for (int i = 0; i < 10; i++)
		if (ExtensionList[i].id == ClientIdentificationAddress)
			return ExtensionList[i].extn;

	return 0;
}


DDKAPI
VOID IoReuseIrp(PIRP Irp, NTSTATUS Iostatus)
{
	UNREFERENCED_PARAMETER(Irp);
	UNREFERENCED_PARAMETER(Iostatus);
}


DDKAPI
NTSTATUS ZwMakeTemporaryObject(HANDLE Handle)
{
	UNREFERENCED_PARAMETER(Handle);
	return 0;
}


DDKAPI
VOID KeStallExecutionProcessor(ULONG MicroSeconds)
{
	UNREFERENCED_PARAMETER(MicroSeconds);
	return;
}


NTSTATUS PcwRegister(PPCW_REGISTRATION *Registration, PPCW_REGISTRATION_INFORMATION Info)
{
	UNREFERENCED_PARAMETER(Registration);
	UNREFERENCED_PARAMETER(Info);
	return STATUS_SUCCESS;
}


VOID PcwUnregister(PPCW_REGISTRATION Registration)
{
	UNREFERENCED_PARAMETER(Registration);
}


NTSTATUS PcwCreateInstance(PPCW_INSTANCE *Instance,
	PPCW_REGISTRATION Registration, PCUNICODE_STRING Name, ULONG Count, PPCW_DATA Data)
{
	UNREFERENCED_PARAMETER(Instance);
	UNREFERENCED_PARAMETER(Registration);
	UNREFERENCED_PARAMETER(Name);
	UNREFERENCED_PARAMETER(Count);
	UNREFERENCED_PARAMETER(Data);
	return STATUS_NOT_SUPPORTED;
}


VOID PcwCloseInstance(PPCW_INSTANCE Instance)
{
	UNREFERENCED_PARAMETER(Instance);
}


NTSTATUS PcwAddInstance(PPCW_BUFFER Buffer,
	PCUNICODE_STRING Name, ULONG Id, ULONG Count, PPCW_DATA Data)
{
	UNREFERENCED_PARAMETER(Buffer);
	UNREFERENCED_PARAMETER(Name);
	UNREFERENCED_PARAMETER(Id);
	UNREFERENCED_PARAMETER(Count);
	UNREFERENCED_PARAMETER(Data);
	return STATUS_NOT_SUPPORTED;
}


DDKAPI
VOID MmBuildMdlForNonPagedPool(PMDL MemoryDescriptorList)
{
	UNREFERENCED_PARAMETER(MemoryDescriptorList);
}


DDKAPI
NTSTATUS IoRegisterLastChanceShutdownNotification(PDEVICE_OBJECT DeviceObject)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	return STATUS_SUCCESS;
}


DDKAPI
POWER_STATE PoSetPowerState(PDEVICE_OBJECT DeviceObject, POWER_STATE_TYPE Type, POWER_STATE State)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Type);
	UNREFERENCED_PARAMETER(State);

	POWER_STATE state;
	state.SystemState = PowerSystemUnspecified;
	return state;
}


DDKAPI
VOID ExAcquireFastMutex(PFAST_MUTEX FastMutex)
{
	UNREFERENCED_PARAMETER(FastMutex);
}


DDKAPI
VOID ExReleaseFastMutex(PFAST_MUTEX FastMutex)
{
	UNREFERENCED_PARAMETER(FastMutex);
}


DDKAPI
BOOLEAN ExTryToAcquireFastMutex(PFAST_MUTEX FastMutex)
{
	UNREFERENCED_PARAMETER(FastMutex);
	return FALSE;
}


DDKAPI
BOOLEAN IoIs32bitProcess(PIRP Irp)
{
	UNREFERENCED_PARAMETER(Irp);
	return FALSE;
}


DDKAPI
ULONG IoWMIDeviceObjectToProviderId(PDEVICE_OBJECT DeviceObject)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	return 0;
}


DDKAPI
ULONG ExSetTimerResolution(ULONG DesiredTime, BOOLEAN SetResolution)
{
	UNREFERENCED_PARAMETER(DesiredTime);
	UNREFERENCED_PARAMETER(SetResolution);
	return 0;
}


DDKAPI
VOID IoAcquireCancelSpinLock(PKIRQL Irql)
{
	UNREFERENCED_PARAMETER(Irql);
}


DDKAPI
VOID IoReleaseCancelSpinLock(KIRQL Irql)
{
	UNREFERENCED_PARAMETER(Irql);
}


DDKAPI
LARGE_INTEGER KeQueryPerformanceCounter(PLARGE_INTEGER PerformanceFrequency)
{
	UNREFERENCED_PARAMETER(PerformanceFrequency);

	LARGE_INTEGER v;
	v.QuadPart = 0;
	return v;
}


DDKAPI
NTSTATUS ZwCreateSection(PHANDLE SectionHandle, ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes, PLARGE_INTEGER MaximumSize, ULONG SectionPageProtection,
    ULONG AllocationAttributes, HANDLE FileHandle)
{
	UNREFERENCED_PARAMETER(SectionHandle);
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(ObjectAttributes);
	UNREFERENCED_PARAMETER(MaximumSize);
	UNREFERENCED_PARAMETER(SectionPageProtection);
	UNREFERENCED_PARAMETER(AllocationAttributes);
	UNREFERENCED_PARAMETER(FileHandle);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS ZwOpenSection(PHANDLE SectionHandle,
	ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes)
{
	UNREFERENCED_PARAMETER(SectionHandle);
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(ObjectAttributes);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS ZwMapViewOfSection(HANDLE SectionHandle, HANDLE ProcessHandle,
    PVOID *BaseAddress, ULONG_PTR ZeroBits, SIZE_T CommitSize, PLARGE_INTEGER SectionOffset,
    PSIZE_T ViewSize, SECTION_INHERIT InheritDisposition, ULONG AllocationType, ULONG Win32Protect)
{
	UNREFERENCED_PARAMETER(SectionHandle);
	UNREFERENCED_PARAMETER(ProcessHandle);
	UNREFERENCED_PARAMETER(BaseAddress);
	UNREFERENCED_PARAMETER(ZeroBits);
	UNREFERENCED_PARAMETER(CommitSize);
	UNREFERENCED_PARAMETER(SectionOffset);
	UNREFERENCED_PARAMETER(ViewSize);
	UNREFERENCED_PARAMETER(InheritDisposition);
	UNREFERENCED_PARAMETER(AllocationType);
	UNREFERENCED_PARAMETER(Win32Protect);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS ZwUnmapViewOfSection(HANDLE ProcessHandle, PVOID BaseAddress)
{
	UNREFERENCED_PARAMETER(ProcessHandle);
	UNREFERENCED_PARAMETER(BaseAddress);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS ZwCreateDirectoryObject(PHANDLE DirectoryHandle,
	ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes)
{
	UNREFERENCED_PARAMETER(DirectoryHandle);
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(ObjectAttributes);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
VOID IoInvalidateDeviceState(PDEVICE_OBJECT PhysicalDeviceObject)
{
	UNREFERENCED_PARAMETER(PhysicalDeviceObject);
}


DDKAPI
VOID IoInvalidateDeviceRelations(PDEVICE_OBJECT DeviceObject, DEVICE_RELATION_TYPE Type)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Type);
}


DDKAPI
VOID IoDisconnectInterrupt(PKINTERRUPT InterruptObject)
{
	UNREFERENCED_PARAMETER(InterruptObject);
}


DDKAPI
PIRP IoBuildSynchronousFsdRequest(ULONG MajorFunction,
    PDEVICE_OBJECT DeviceObject, PVOID Buffer, ULONG Length,
	PLARGE_INTEGER StartingOffset, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock)
{
	UNREFERENCED_PARAMETER(MajorFunction);
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Buffer);
	UNREFERENCED_PARAMETER(Length);
	UNREFERENCED_PARAMETER(StartingOffset);
	UNREFERENCED_PARAMETER(Event);
	UNREFERENCED_PARAMETER(IoStatusBlock);
	return 0;
}


DDKAPI
NTSTATUS PoCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Irp);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoRegisterShutdownNotification(PDEVICE_OBJECT DeviceObject)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	return STATUS_SUCCESS;
}


DDKAPI
VOID IoUnregisterShutdownNotification(PDEVICE_OBJECT DeviceObject)
{
	UNREFERENCED_PARAMETER(DeviceObject);
}


DDKAPI
struct _DMA_ADAPTER *IoGetDmaAdapter(PDEVICE_OBJECT PhysicalDeviceObject,
    struct _DEVICE_DESCRIPTION *DeviceDescription,PULONG NumberOfMapRegisters)
{
	UNREFERENCED_PARAMETER(PhysicalDeviceObject);
	UNREFERENCED_PARAMETER(DeviceDescription);
	UNREFERENCED_PARAMETER(NumberOfMapRegisters);
	return 0;
}


DDKAPI
NTSTATUS IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Action)
{
	UNREFERENCED_PARAMETER(DeviceObject);
	UNREFERENCED_PARAMETER(Action);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoWMIWriteEvent(PVOID WnodeEventItem)
{
	UNREFERENCED_PARAMETER(WnodeEventItem);
	return STATUS_SUCCESS;
}


DDKAPI
VOID PoStartNextPowerIrp(PIRP Irp)
{
	UNREFERENCED_PARAMETER(Irp);
}


DDKAPI
VOID RtlAssert(PVOID VoidFailedAssertion, PVOID VoidFileName, ULONG LineNumber, PSTR MutableMessage)
{
	UNREFERENCED_PARAMETER(VoidFailedAssertion);
	UNREFERENCED_PARAMETER(VoidFileName);
	UNREFERENCED_PARAMETER(LineNumber);
	UNREFERENCED_PARAMETER(MutableMessage);
}


DDKAPI
NTSTATUS IoRegisterPlugPlayNotification(IO_NOTIFICATION_EVENT_CATEGORY EventCategory,
    ULONG EventCategoryFlags, PVOID EventCategoryData, PDRIVER_OBJECT DriverObject,
    PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine, PVOID Context, PVOID *NotificationEntry)
{
	UNREFERENCED_PARAMETER(EventCategory);
	UNREFERENCED_PARAMETER(EventCategoryFlags);
	UNREFERENCED_PARAMETER(EventCategoryData);
	UNREFERENCED_PARAMETER(DriverObject);
	UNREFERENCED_PARAMETER(CallbackRoutine);
	UNREFERENCED_PARAMETER(Context);
	UNREFERENCED_PARAMETER(NotificationEntry);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoReportTargetDeviceChange(PDEVICE_OBJECT PhysicalDeviceObject, PVOID NotificationStructure)
{
	UNREFERENCED_PARAMETER(PhysicalDeviceObject);
	UNREFERENCED_PARAMETER(NotificationStructure);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoUnregisterPlugPlayNotification(PVOID NotificationEntry)
{
	UNREFERENCED_PARAMETER(NotificationEntry);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoUnregisterPlugPlayNotificationEx(PVOID NotificationEntry)
{
	UNREFERENCED_PARAMETER(NotificationEntry);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS ZwOpenSymbolicLinkObject(PHANDLE LinkHandle,
	ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes)
{
	UNREFERENCED_PARAMETER(LinkHandle);
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(ObjectAttributes);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS ZwQuerySymbolicLinkObject(HANDLE LinkHandle,
    PUNICODE_STRING LinkTarget, PULONG ReturnedLength)
{
	UNREFERENCED_PARAMETER(LinkHandle);
	UNREFERENCED_PARAMETER(LinkTarget);
	UNREFERENCED_PARAMETER(ReturnedLength);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


/*
 *	Kernel Error Routines
 */

DDKAPI
VOID KeBugCheck(ULONG BugCheckCode)
{
	fprintf(stderr, "BugCheck Code %x\n", BugCheckCode);
	exit(0);
}


DDKAPI
VOID KeBugCheckEx(ULONG BugCheckCode, ULONG_PTR BugCheckParameter1,
	ULONG_PTR BugCheckParameter2, ULONG_PTR BugCheckParameter3, ULONG_PTR BugCheckParameter4)
{
	fprintf(stderr, "BugCheck Code %x, 0x%I64x, 0x%I64x, 0x%I64x, 0x%I64x\n", BugCheckCode,
		BugCheckParameter1, BugCheckParameter2, BugCheckParameter3, BugCheckParameter4);
	exit(0);
}


DDKAPI
BOOLEAN IoRaiseInformationalHardError(NTSTATUS ErrorStatus,
		PUNICODE_STRING String, PKTHREAD Thread)
{
	UNREFERENCED_PARAMETER(String);
	UNREFERENCED_PARAMETER(Thread);

	fprintf(stderr, "HardError %x\n", ErrorStatus);
	return TRUE;
}

DDKAPI
VOID KeSetSystemAffinityThread(KAFFINITY Affinity)
{
	UNREFERENCED_PARAMETER(Affinity);
}

DDKAPI
KAFFINITY KeSetSystemAffinityThreadEx(KAFFINITY Affinity)
{
	UNREFERENCED_PARAMETER(Affinity);
	return ULONGLONG_MAX;
}

DDKAPI
VOID KeRevertToUserAffinityThreadEx(KAFFINITY Affinity)
{
	UNREFERENCED_PARAMETER(Affinity);
}

DDKAPI
VOID KeRevertToUserAffinityThread(VOID)
{
}

DDKAPI
VOID
KeSetSystemGroupAffinityThread(PGROUP_AFFINITY Affinity, PGROUP_AFFINITY PreviousAffinity)
{
	UNREFERENCED_PARAMETER(Affinity);
	UNREFERENCED_PARAMETER(PreviousAffinity);
}

DDKAPI
VOID
KeRevertToUserGroupAffinityThread(PGROUP_AFFINITY PreviousAffinity)
{
	UNREFERENCED_PARAMETER(PreviousAffinity);
}

DDKAPI
VOID
KeQueryNodeActiveAffinity(USHORT NodeNumber, PGROUP_AFFINITY Affinity, PUSHORT Count)
{
	UNREFERENCED_PARAMETER(NodeNumber);
	UNREFERENCED_PARAMETER(Affinity);
	UNREFERENCED_PARAMETER(Count);
}

DDKAPI
USHORT
KeQueryHighestNodeNumber()
{
	return 0;
}

NTSTATUS
KeGetProcessorNumberFromIndex(ULONG ProcIndex, PPROCESSOR_NUMBER ProcNumber)
{
	UNREFERENCED_PARAMETER(ProcIndex);
	UNREFERENCED_PARAMETER(ProcNumber);
	return STATUS_SUCCESS;
}

ULONG
KeGetProcessorIndexFromNumber(PPROCESSOR_NUMBER ProcNumber)
{
	UNREFERENCED_PARAMETER(ProcNumber);
	return 0;
}

DDKAPI
NTSTATUS
KeQueryLogicalProcessorRelationship(PPROCESSOR_NUMBER ProcessorNumber,
	LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Information, PULONG Length)
{
	UNREFERENCED_PARAMETER(ProcessorNumber);
	UNREFERENCED_PARAMETER(RelationshipType);
	UNREFERENCED_PARAMETER(Information);
	UNREFERENCED_PARAMETER(Length);
	return STATUS_NOT_IMPLEMENTED;
}

_Analysis_noreturn_
void DdkFail(wchar_t *s)
{
	ULONG_PTR v[2];

	fprintf(stderr, "%S\n", s);

	v[0] = (ULONG_PTR)s;
	v[1] = NULL;
	RaiseException(EXCEPTION_UNITTEST_ASSERTION, EXCEPTION_NONCONTINUABLE, 2, v);
	exit(0);
}


size_t _SizeofEvent_ = sizeof(KEVENT);
size_t _SizeofMutex_ = sizeof(KMUTEX);
size_t _SizeofTimer_ = sizeof(KTIMER);
size_t _SizeofSemaphore_ = sizeof(KSEMAPHORE);
size_t _SizeofDpc_ = sizeof(KDPC);


DDKAPI
BOOLEAN KeRegisterBugCheckReasonCallback(
	PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord,
	PKBUGCHECK_REASON_CALLBACK_ROUTINE CallbackRoutine,
	KBUGCHECK_CALLBACK_REASON Reason,
	PUCHAR Component)
{
	UNREFERENCED_PARAMETER(CallbackRecord);
	UNREFERENCED_PARAMETER(CallbackRoutine);
	UNREFERENCED_PARAMETER(Reason);
	UNREFERENCED_PARAMETER(Component);
	return true;
}


DDKAPI
BOOLEAN KeDeregisterBugCheckReasonCallback(
	PKBUGCHECK_REASON_CALLBACK_RECORD CallbackRecord)
{
	UNREFERENCED_PARAMETER(CallbackRecord);
	return true;
}


DDKAPI
BOOLEAN MmIsAddressValid(PVOID VirtualAddress)
{
	UNREFERENCED_PARAMETER(VirtualAddress);
	return true;
}


typedef PVOID PWSK_REGISTRATION;
typedef PVOID PWSK_PROVIDER_NPI;
typedef PVOID PWSK_CLIENT_NPI;

CONST GUID NPI_WSK_INTERFACE_ID = {};

DDKAPI
NTSTATUS WskRegister(PWSK_CLIENT_NPI WskClientNpi, PWSK_REGISTRATION WskRegistration)
{
	UNREFERENCED_PARAMETER(WskClientNpi);
	UNREFERENCED_PARAMETER(WskRegistration);
	return STATUS_NOT_IMPLEMENTED;
}

DDKAPI
VOID WskDeregister(PWSK_REGISTRATION WskRegistration)
{
	UNREFERENCED_PARAMETER(WskRegistration);
}


DDKAPI
NTSTATUS WskCaptureProviderNPI(PWSK_REGISTRATION  WskRegistration, ULONG WaitTimeout, PWSK_PROVIDER_NPI WskProviderNpi)
{
	UNREFERENCED_PARAMETER(WskRegistration);
	UNREFERENCED_PARAMETER(WaitTimeout);
	UNREFERENCED_PARAMETER(WskProviderNpi);
	return STATUS_NOT_IMPLEMENTED;
}

DDKAPI
VOID WskReleaseProviderNPI(PWSK_REGISTRATION WskRegistration)
{
	UNREFERENCED_PARAMETER(WskRegistration);
}

NTSTATUS 
NETIOAPI_API_
GetUnicastIpAddressTable(ADDRESS_FAMILY Family, PMIB_UNICASTIPADDRESS_TABLE *Table)
{
	UNREFERENCED_PARAMETER(Family);
	UNREFERENCED_PARAMETER(Table);
	return STATUS_NOT_IMPLEMENTED;
}


NTSTATUS 
NETIOAPI_API_
NotifyUnicastIpAddressChange(
	ADDRESS_FAMILY Family, PUNICAST_IPADDRESS_CHANGE_CALLBACK Callback, 
	PVOID CallerContext, BOOLEAN InitialNotification, HANDLE *NotificationHandle)
{
	UNREFERENCED_PARAMETER(Family);
	UNREFERENCED_PARAMETER(Callback);
	UNREFERENCED_PARAMETER(CallerContext);
	UNREFERENCED_PARAMETER(InitialNotification);
	UNREFERENCED_PARAMETER(NotificationHandle);
	return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NETIOAPI_API_ GetUnicastIpAddressEntry(PMIB_UNICASTIPADDRESS_ROW row)
{
	UNREFERENCED_PARAMETER(row);
	return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NETIOAPI_API_
CancelMibChangeNotify2(HANDLE NotificationHandle)
{
	UNREFERENCED_PARAMETER(NotificationHandle);
	return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
NETIOAPI_API_
GetIfEntry2(PMIB_IF_ROW2 Row)
{
	UNREFERENCED_PARAMETER(Row);
	return STATUS_NOT_IMPLEMENTED;
}


VOID 
NETIOAPI_API_
FreeMibTable(PVOID Memory)
{
	UNREFERENCED_PARAMETER(Memory);
}

DDKAPI
PWSTR RtlIpv6AddressToStringW(const struct in6_addr *Addr, PWSTR S)
{
	UNREFERENCED_PARAMETER(Addr);
	return S;
}

DDKAPI
PWSTR RtlIpv4AddressToStringW(const struct in_addr *Addr, PWSTR S)
{
	UNREFERENCED_PARAMETER(Addr);
	return S;
}

DDKAPI
LONG RtlIpv4StringToAddressW(PCWSTR S, BOOLEAN Strict, LPCWSTR *Terminator, struct in_addr *Addr)
{
	UNREFERENCED_PARAMETER(S);
	UNREFERENCED_PARAMETER(Strict);
	UNREFERENCED_PARAMETER(Terminator);
	UNREFERENCED_PARAMETER(Addr);
	return STATUS_NOT_IMPLEMENTED;
}

DDKAPI
LONG RtlIpv6StringToAddressW(PCWSTR S, PCWSTR *Terminator, struct in6_addr *Addr)
{
	UNREFERENCED_PARAMETER(S);
	UNREFERENCED_PARAMETER(Terminator);
	UNREFERENCED_PARAMETER(Addr);
	return STATUS_NOT_IMPLEMENTED;
}


```

`src/ddk.def`:

```def
LIBRARY   ddk
EXPORTS
	CmKeyObjectType					CONSTANT
	ExEventObjectType				CONSTANT
	ExSemaphoreObjectType			CONSTANT
	IoFileObjectType				CONSTANT
	PsProcessType					CONSTANT
	PsThreadType					CONSTANT
	SeTokenObjectType				CONSTANT
	TmEnlistmentObjectType			CONSTANT
	TmResourceManagerObjectType		CONSTANT
	TmTransactionManagerObjectType	CONSTANT
	TmTransactionObjectType			CONSTANT
	MmBadPointer					CONSTANT
	KeNumberProcessors				CONSTANT
	NlsMbCodePageTag				CONSTANT
	NlsMbOemCodePageTag				CONSTANT
	PcwRegister
	PcwUnregister
	PcwCreateInstance
	PcwCloseInstance
	PcwAddInstance
	WmiCompleteRequest
	WmiSystemControl
	WmiFireEvent
	TdiRegisterPnPHandlers
	TdiDeregisterPnPHandlers
	InitializeSListHead
	isdigit
	isprint
	swprintf
	sprintf
	_snprintf
	_snwprintf
	_vsnprintf
	_strnicmp
	strncpy
	strncmp
	strcmp
	strcpy
	strspn
	_stricmp
	_wcsicmp
	_wcsnicmp
	wcsncmp
	wcsncpy
	wcsncpy_s
	_wcslwr
	strstr
	strchr
	wcsstr
	atoi
	toupper
	tolower
	towupper
	towlower
	_purecall
	__C_specific_handler
	__chkstk
	DbgPrint
	KeGetProcessorNumberFromIndex
	KeGetProcessorIndexFromNumber
	NPI_WSK_INTERFACE_ID			CONSTANT
	GetIfEntry2
	GetUnicastIpAddressTable
	NotifyUnicastIpAddressChange
	GetUnicastIpAddressEntry
	CancelMibChangeNotify2
	FreeMibTable
```

`src/defs.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Common definitions.
 */

#ifdef _NTDDK_
#include <winnt.h>
#include <winerror.h>
#define DDKUSEDECL	_Use_decl_annotations_
#else
#include <Windows.h>
#define DDKUSEDECL
#endif
#include <ddk.h>
#include <stdio.h>
#include <stdlib.h>

extern "C" _Analysis_noreturn_ void DdkFail(wchar_t *s);
#define ddkfail(s) DdkFail(L"DDK: " L##s)

#include "object.h"

#undef DDKAPI
#undef DDKAPI_NODECL
#define DDKAPI_NODECL extern "C" __declspec(dllexport)
#define DDKAPI DDKAPI_NODECL DDKUSEDECL

#define DDKASSERT(v) ((!(v)) ? DdkFail( L"DDK: Assert " L#v),0 : 0)

typedef struct _IMAGE IMAGE, *PIMAGE;

BOOLEAN DdkIsDpc();
BOOLEAN DdkIsWorkItem();
DWORD DdkGetWaitTime(LARGE_INTEGER *pTimeout);
DWORD DdkGetDelayTime(LARGE_INTEGER *pTimeout);
FILETIME DdkGetDueTime(LARGE_INTEGER Timeout);
VOID DdkAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT DeviceObject);
VOID DdkRemoveDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT DeviceObject);
void DdkCreatePath(PUNICODE_STRING Out, PUNICODE_STRING Name, PWCH Dir = 0, PWCH Prefix = 0);
BOOLEAN DdkInsertName(PUNICODE_STRING Name, POBJECT pObj, PWCH Dir = 0, PWCH *pPath = 0);
POBJECT DdkCreateName(PUNICODE_STRING Name, POBJECT pObj, PWCH Dir = 0, PWCH *pPath = 0);
VOID DdkRemoveName(PUNICODE_STRING Name);
VOID DdkRemoveObjectName(POBJECT Object);
POBJECT DdkLookupName(PUNICODE_STRING Name, PWCH Dir = 0);
POBJECT DdkLookupName(PWCH Name, PWCH Dir = 0);
POBJECT DdkLookupName(char *Name, PWCH Dir = 0);
PFILE_OBJECT DdkGetFilePointer(HANDLE FileHandle);
void DdkFreeFileObject(OBJECT *pObj);
void DdkFreeDriverObject(OBJECT *pObj);
void DdkFreeDeviceObject(OBJECT *pObj);
void DdkFreeKeyObject(OBJECT *pObj);
POBJECT DdkResolveSymbolicLink(OBJECT *pObj);
BOOLEAN DdkIsDeviceInterface(PUNICODE_STRING path, BOOLEAN all);
NTSTATUS DdkCreateDriver(char *pName, PDRIVER_INITIALIZE DriverInit, PIMAGE Image);
VOID DdkUnloadImage(PIMAGE pImage);
NTSTATUS DdkPnpCreateDevice(PDRIVER_OBJECT DriverObject);
void DdkPnpUnload(PDRIVER_OBJECT DriverObject);
NTSTATUS DdkSynchronousIrp(PDEVICE_OBJECT DeviceObject, UCHAR Major, UCHAR Minor, PIRP Irp = NULL);
ULONG DdkGetTickCountMultiplier();
ULONG64 DdkGetTickCount();
ULONG64 DdkReadCR8();
VOID DdkWriteCR8(ULONG64 v);
WCHAR *DdkAllocUnicodeBuffer(size_t len);
char *DdkAllocAnsiBuffer(size_t len);
BOOLEAN DdkWaitLastReference(POBJECT pObj, int maxsecs, int count);
void DdkThreadLock();
void DdkThreadUnlock();
LONG DdkInvokeForAllThreads(LONG (*func)(HANDLE));
WCHAR *DdkUnicodeToString(UNICODE_STRING *u, WCHAR remove = 0);
void DdkGetLocalPath(WCHAR *buffer, int len, UNICODE_STRING *path, bool create);
void DdkGetLocalPath(char *buffer, size_t len, char *path, char *file, char *suffix = "");


#define EXCEPTION_UNITTEST_ASSERTION   (DWORD)0xe3530001


extern size_t _SizeofEvent_, _SizeofMutex_, _SizeofTimer_, _SizeofSemaphore_, _SizeofDpc_;


```

`src/detours.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

 /*
  * Detours Routines.
  */

#include "stdafx.h"
#include "detours.h"


/*
 *	Detours is designed to attach a single, essentially static, intercept to a
 *	function. In a Unit Test environment, multiple short-lived tests, requiring
 *	different intercepts, can be running concurrently.
 *
 *	A list of active intercepts is maintained and a wrapper selects the
 *	appropriate intercept for the current thread. The intercept is identified
 *	by a unique identity in case the compiler/linker merges common code.
 */

typedef struct _INTERCEPT {
	struct _INTERCEPT *next;
	struct _DETOUR *detour;		// Detour
	PVOID intercept;			// Intercept function
	PVOID identity;				// Identity of intercept
	PVOID instance;				// Instance of intercept
	PVOID thread;				// Thread to intercept
} INTERCEPT;


/*
 *	Each detour starts with the position-independent code located in wrapper[]
 *	that preserves the arguments and 'this' pointer, calls DdkGetIntercept to
 *	identify the appropriate detour and then executes it.
 */

typedef struct _DETOUR {
	char wrapper[16];			// Wrapper code (must be first element)
	struct _REGION *region;		// Region
	PVOID function;				// Original function
	PVOID trampoline;			// Trampoline
	SRWLOCK lock;				// Intercept lock
	INTERCEPT *intercepts;		// Intercept list
} DETOUR;


/*
 *	Detours are created in regions of memory located near to the target
 *	function so that the wrapper can be reached with a signed 32-bit offset.
 */

typedef struct _REGION {
	struct _REGION *next;
	DWORD size;					// Region size
	ULONG refcount;				// Reference count
	size_t count;				// Detour count
	size_t freecount;			// Free detours
	size_t hwm;					// High water mark
	DETOUR detour[1];			// Detour array
} REGION;


static REGION *regionlist;
static SRWLOCK Lock = SRWLOCK_INIT;

__declspec(thread) PVOID realpointer = NULL;

extern "C" void _DdkWrapper(), _DdkWrapperEnd();


NTSTATUS DdkAllocateIntercept(PVOID pIntercept,
	PVOID pIdentity, PVOID pInstance, PVOID pThread, INTERCEPT **ppEntry);
NTSTATUS DdkFreeIntercept(INTERCEPT *pEntry);
DETOUR *DdkFindDetour(PVOID pFunction);
NTSTATUS DdkAllocateDetour(PVOID pFunction, DETOUR **ppDetour);
NTSTATUS DdkFreeDetour(DETOUR *pDetour);
NTSTATUS DdkAttachDetour(DETOUR *pDetour);
NTSTATUS DdkDetachDetour(DETOUR *pDetour);
NTSTATUS DdkUpdateDetour(DETOUR *pDetour, bool enable);
NTSTATUS DdkAllocateRegion(PVOID pFunction, REGION **ppRegion);
void DdkFreeRegion(REGION *pRegion);
void DdkAddReference(REGION *pRegion);
void DdkDeleteReference(REGION *pRegion);
NTSTATUS DdkGetDetourStatus(LONG rc);


PVOID DdkCodeFromPointer(PVOID pAddr)
{
	return DetourCodeFromPointer(pAddr, NULL);
}


PVOID DdkFindFunction(const char *pName)
{
	char *program, *system;
	PVOID pSysAddr = NULL;

	if (!pName) return NULL;

	size_t slen = (system = getenv("SystemRoot")) ? strlen(system) : 0;
	size_t plen = (program = getenv("ProgramFiles")) ? strlen(program) : 0;

	const char *cp = strchr((char *)pName, '!');
	const char *symbol = cp ? cp + 1 : pName;
	size_t len = cp ? (cp - pName) : 0;

	for (HMODULE h = NULL; (h = DetourEnumerateModules(h)); ) {
		char path[MAX_PATH] = { 0 };
		if (!GetModuleFileNameA(h, path, sizeof(path) - 1)) continue;

		// Limit search to specific module (module!symbol)

		if (len) {
			if (!(cp = strrchr(path, '\\'))) cp = strrchr(path, '/');
			cp = cp ? cp + 1 : path;
			if (strnicmp(cp, pName, len) || (cp[len] && cp[len] != '.'))
				continue;
		}

		// Deprioritise non-driver modules in system paths

		if (!(cp = strrchr(path, '.')) || stricmp(cp, ".sys"))
			if ((slen && _strnicmp(path, system, slen) == 0) ||
					(plen && _strnicmp(path, program, plen) == 0)) {
				if (!pSysAddr)
					pSysAddr = DetourFindFunction(path, symbol);
				continue;
			}

		PVOID v = DetourFindFunction(path, symbol);
		if (v) return v;
	}

	return pSysAddr;
}


HMODULE DdkFindModule(PVOID pAddr)
{
	ULONG_PTR addr = (ULONG_PTR)pAddr;

	for (HMODULE h = NULL; (h = DetourEnumerateModules(h)); ) {
		char path[MAX_PATH] = { 0 };
		if (!GetModuleFileNameA(h, path, sizeof(path) - 1)) continue;

		IMAGE_OPTIONAL_HEADER64 *pOpt = &((PIMAGE_NT_HEADERS64)((ULONG_PTR)h
			+ ((PIMAGE_DOS_HEADER)h)->e_lfanew))->OptionalHeader;

		if (pOpt->ImageBase <= addr && addr < pOpt->ImageBase + pOpt->SizeOfImage)
			return h;
	}

	return NULL;
}


NTSTATUS DdkAttachIntercept(PVOID pFunction, PVOID pIntercept,
	PVOID pIdentity, PVOID pInstance, PVOID pThread)
{
	INTERCEPT *pEntry;

	if (!pFunction || !pIntercept)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = DdkAllocateIntercept(pIntercept,
						pIdentity, pInstance, pThread, &pEntry);

	if (!NT_SUCCESS(status))
		return status;

	AcquireSRWLockExclusive(&Lock);
	DETOUR *pDetour = DdkFindDetour(pFunction);

	if (!pDetour) {
		status = DdkAllocateDetour(pFunction, &pDetour);

		if (!NT_SUCCESS(status)) {
			DdkFreeIntercept(pEntry);
			ReleaseSRWLockExclusive(&Lock);
			return status;
		}
	}

	pEntry->detour = pDetour;

	AcquireSRWLockExclusive(&pDetour->lock);
	pEntry->next = pDetour->intercepts;
	pDetour->intercepts = pEntry;
	ReleaseSRWLockExclusive(&pDetour->lock);

	ReleaseSRWLockExclusive(&Lock);
	return STATUS_SUCCESS;
}


NTSTATUS DdkDetachIntercept(PVOID pId, PVOID pThread)
{
	if (!regionlist)
		return STATUS_SUCCESS;

	NTSTATUS status = STATUS_SUCCESS;

	AcquireSRWLockExclusive(&Lock);

	for (REGION *pRegion = regionlist, *pNext; pRegion; pRegion = pNext) {
		DdkAddReference(pRegion);

		for (size_t i = 0; i < pRegion->hwm; i++)
			for (INTERCEPT *p = pRegion->detour[i].intercepts, *next; p; p = next) {
				next = p->next;

				if ((!pThread || p->thread == pThread) &&
						(!pId || p->identity == pId || p->instance == pId)) {
					NTSTATUS rc = DdkFreeIntercept(p);
					if (!NT_SUCCESS(rc)) status = rc;
				}
			}

		pNext = pRegion->next;
		DdkDeleteReference(pRegion);
	}

	ReleaseSRWLockExclusive(&Lock);
	return status;
}


NTSTATUS DdkDetachAddressRange(PVOID pAddr, size_t len, HMODULE module)
{
	PVOID pModuleAddr = NULL, pModuleEnd = NULL;
	PVOID pEnd = (PVOID)((char *)pAddr + len);

	if (!regionlist || !len)
		return STATUS_SUCCESS;

	if (module) {
		IMAGE_OPTIONAL_HEADER64 *pOpt = &((PIMAGE_NT_HEADERS64)((ULONG_PTR)module
				+ ((PIMAGE_DOS_HEADER)module)->e_lfanew))->OptionalHeader;

		pModuleAddr = (PVOID)pOpt->ImageBase;
		pModuleEnd = (PVOID)((char *)pOpt->ImageBase + pOpt->SizeOfImage);
	}

	NTSTATUS status = STATUS_SUCCESS;

	AcquireSRWLockExclusive(&Lock);

	for (REGION *pRegion = regionlist, *pNext; pRegion; pRegion = pNext) {
		DdkAddReference(pRegion);

		for (size_t i = 0; i < pRegion->hwm; i++) {
			DETOUR *pDetour = &pRegion->detour[i];

			if (!pDetour->function) continue;

			if (pAddr <= pDetour->function && pDetour->function < pEnd)
				for (INTERCEPT *p = pDetour->intercepts, *next; p; p = next) {
					next = p->next;

					if (!module || (pModuleAddr <= p->intercept
							&& p->intercept < pModuleEnd)) {
						NTSTATUS rc = DdkFreeIntercept(p);
						if (!NT_SUCCESS(rc)) status = rc;
					}
				}
		}

		pNext = pRegion->next;
		DdkDeleteReference(pRegion);
	}

	ReleaseSRWLockExclusive(&Lock);
	return status;
}


DDKAPI
PVOID DdkGetIntercept(DETOUR *pDetour)
{
	if (!pDetour || !pDetour->function)
		ddkfail("Invalid detour");

	AcquireSRWLockShared(&pDetour->lock);
	PVOID pIntercept = pDetour->trampoline;

	for (INTERCEPT *ep = pDetour->intercepts; ep; ep = ep->next) {
		if (ep->thread == DdkGetCurrentThread()) {
			pIntercept = ep->intercept;
			break;
		}

		if (ep->thread == NULL)
			pIntercept = ep->intercept;
	}

	if (!pIntercept)
		pIntercept = pDetour->function;

	realpointer = pDetour->trampoline;

	ReleaseSRWLockShared(&pDetour->lock);
	return pIntercept;
}


PVOID DdkGetRealPointer()
{
	PVOID v = realpointer;

	if (!v)
		ddkfail("Real pointer not found");

	realpointer = NULL;
	return v;
}


static NTSTATUS DdkAllocateIntercept(PVOID pIntercept,
	PVOID pIdentity, PVOID pInstance, PVOID pThread, INTERCEPT **ppEntry)
{
	INTERCEPT *pEntry = (INTERCEPT *)calloc(1, sizeof(INTERCEPT));

	if (!pEntry)
		return STATUS_INSUFFICIENT_RESOURCES;

	pEntry->intercept = pIntercept;
	pEntry->identity = pIdentity;
	pEntry->instance = pInstance;
	pEntry->thread = pThread;
	*ppEntry = pEntry;
	return STATUS_SUCCESS;
}


static NTSTATUS DdkFreeIntercept(INTERCEPT *pEntry)
{
	if (!pEntry) return STATUS_SUCCESS;

	NTSTATUS status = STATUS_SUCCESS;
	DETOUR *pDetour = pEntry->detour;

	if (pDetour) {
		AcquireSRWLockExclusive(&pDetour->lock);

		for (INTERCEPT **epp = &pDetour->intercepts; *epp; epp = &(*epp)->next)
			if (*epp == pEntry) {
				*epp = pEntry->next;
				pEntry->next = NULL;
				break;
			}

		ReleaseSRWLockExclusive(&pDetour->lock);
		status = DdkFreeDetour(pDetour);
	}

	free(pEntry);
	return status;
}


static bool DdkIsRegionWithinJumpBounds(REGION *pRegion,
	PVOID pFunction, int slack = 0)
{
	unsigned int maxjump = 0x80000000U - slack;
	char *pAddr = (char *)pFunction;

	if (pAddr >= (char *)pRegion
		&& pAddr - (char *)pRegion <= maxjump) return true;

	if ((char *)pRegion + pRegion->size > pAddr
		&& (char *)pRegion + pRegion->size - pAddr <= maxjump) return true;

	return false;
}


static DETOUR *DdkFindDetour(PVOID pFunction)
{
	for (REGION *pRegion = regionlist; pRegion; pRegion = pRegion->next) {
		if (!DdkIsRegionWithinJumpBounds(pRegion, pFunction)) continue;

		for (size_t i = 0; i < pRegion->hwm; i++)
			if (pRegion->detour[i].function == pFunction)
				return &pRegion->detour[i];
	}

	return NULL;
}


static NTSTATUS DdkAllocateDetour(PVOID pFunction, DETOUR **ppDetour)
{
	REGION *pRegion;

	// Allocate from first available region within jump bounds

	for (pRegion = regionlist; pRegion; pRegion = pRegion->next)
		if (pRegion->freecount && DdkIsRegionWithinJumpBounds(pRegion,
			pFunction, 0x100)) break;

	// Allocate a new region if necessary

	if (!pRegion) {
		NTSTATUS status = DdkAllocateRegion(pFunction, &pRegion);

		if (!NT_SUCCESS(status))
			return status;
	}

	// Find free detour

	DETOUR *pDetour = NULL;

	for (size_t i = 0; i < pRegion->count; i++)
		if (!pRegion->detour[i].function) {
			pDetour = &pRegion->detour[i];
			if (i >= pRegion->hwm)
				pRegion->hwm = i + 1;
			break;
		}

	if (!pDetour)
		ddkfail("Region has no free detours");

	// Initialise detour

	pDetour->function = pFunction;
	pDetour->intercepts = NULL;
	pDetour->trampoline = NULL;
	pRegion->freecount--;

	// Attach detour to function

	NTSTATUS status = DdkAttachDetour(pDetour);

	if (!NT_SUCCESS(status)) {
		DdkFreeDetour(pDetour);
		return status;
	}

	*ppDetour = pDetour;
	return STATUS_SUCCESS;
}


static NTSTATUS DdkFreeDetour(DETOUR *pDetour)
{
	if (!pDetour || pDetour->intercepts)
		return STATUS_SUCCESS;

	REGION *pRegion = pDetour->region;

	NTSTATUS status = DdkDetachDetour(pDetour);

	if (!pDetour->trampoline && pDetour->function) {
		pDetour->function = NULL;
		pRegion->freecount++;
	}

	for (; pRegion->hwm; pRegion->hwm--)
		if (pRegion->detour[pRegion->hwm - 1].function) break;

	DdkFreeRegion(pRegion);
	return status;
}


static NTSTATUS DdkAttachDetour(DETOUR *pDetour)
{
	if (!pDetour || pDetour->trampoline)
		return STATUS_SUCCESS;

	pDetour->trampoline = pDetour->function;

	NTSTATUS status = DdkUpdateDetour(pDetour, true);

	if (!NT_SUCCESS(status))
		pDetour->trampoline = NULL;

	return status;
}


static NTSTATUS DdkDetachDetour(DETOUR *pDetour)
{
	if (!pDetour || !pDetour->trampoline)
		return STATUS_SUCCESS;

	NTSTATUS status = DdkUpdateDetour(pDetour, false);

	if (NT_SUCCESS(status))
		pDetour->trampoline = NULL;

	return status;
}


static NTSTATUS DdkUpdateDetour(DETOUR *pDetour, bool enable)
{
	LONG rc = DetourTransactionBegin();
	
	if (rc != NO_ERROR)
		return DdkGetDetourStatus(rc);

	DdkThreadLock();
	rc = DdkInvokeForAllThreads(DetourUpdateThread);

	if (rc != NO_ERROR) {
		DdkThreadUnlock();
		DetourTransactionAbort();
		return DdkGetDetourStatus(rc);
	}

	rc = (enable) ? DetourAttach(&pDetour->trampoline, &pDetour->wrapper) :
					DetourDetach(&pDetour->trampoline, &pDetour->wrapper);

	if (rc != NO_ERROR) {
		DdkThreadUnlock();
		DetourTransactionAbort();
		return DdkGetDetourStatus(rc);
	}

	rc = DetourTransactionCommit();

	DdkThreadUnlock();
	return DdkGetDetourStatus(rc);
}


static NTSTATUS DdkAllocateRegion(PVOID pFunction, REGION **ppRegion)
{
	DWORD size;
	REGION *pRegion = (REGION *)DetourAllocateRegionWithinJumpBounds(pFunction, &size);

	if (!pRegion || size < sizeof(REGION)) {
		if (pRegion) VirtualFree(pRegion, 0, MEM_RELEASE);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	pRegion->size = size;
	pRegion->count = (size - sizeof(REGION)) / sizeof(DETOUR) + 1;
	pRegion->freecount = pRegion->count;
	pRegion->refcount = 0;

	const size_t len = (char *)&_DdkWrapperEnd - (char *)&_DdkWrapper;

	if (sizeof(pRegion->detour[0].wrapper) < len)
		ddkfail("Wrapper array is too small");

	for (int i = 0; i < pRegion->count; i++) {
		memcpy(pRegion->detour[i].wrapper, &_DdkWrapper, len);
		pRegion->detour[i].region = pRegion;
		InitializeSRWLock(&pRegion->detour[i].lock);
	}

	pRegion->next = regionlist;
	*ppRegion = regionlist = pRegion;
	return STATUS_SUCCESS;
}


static void DdkFreeRegion(REGION *pRegion)
{
	if (!pRegion || pRegion->refcount || pRegion->freecount != pRegion->count)
		return;

	// Remove region from list

	for (REGION **pp = &regionlist; *pp; pp = &(*pp)->next)
		if (*pp == pRegion) {
			*pp = pRegion->next;
			break;
		}

	VirtualFree(pRegion, 0, MEM_RELEASE);
}


static void DdkAddReference(REGION *pRegion)
{
	pRegion->refcount++;
}


static void DdkDeleteReference(REGION *pRegion)
{
	pRegion->refcount--;
	DdkFreeRegion(pRegion);
}


static NTSTATUS DdkGetDetourStatus(LONG rc)
{
	switch (rc) {
	case NO_ERROR:
		return STATUS_SUCCESS;

	case ERROR_INVALID_OPERATION:
		return STATUS_OPERATION_IN_PROGRESS;

	case ERROR_ACCESS_DENIED:
		return STATUS_ACCESS_DENIED;

	case ERROR_NOT_ENOUGH_MEMORY:
		return STATUS_INSUFFICIENT_RESOURCES;

	case ERROR_INVALID_BLOCK:
		return STATUS_INVALID_BLOCK_LENGTH;

	case ERROR_INVALID_HANDLE:
		return STATUS_INVALID_HANDLE;

	case ERROR_INVALID_DATA:
		return STATUS_DATA_ERROR;
	}

	return STATUS_UNSUCCESSFUL;
}
```

`src/detours_x64.asm`:

```asm
;;-
;;  SPDX-License-Identifier: BSD-3-Clause
;;
;;  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
;;
;;  Details about the Windows Kernel API are based on the documentation
;;  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
;;

;; 
;;  Position-independent template wrapper that preserves the arguments and
;;  'this' pointer, calls DdkGetIntercept to identify the appropriate detour
;;  and then executes it.
;;
;;  Derived from:
;;
;;  typedef void *(*fn_t)(void *, void *, void *, void *);
;;  extern fn_t DdkGetIntercept(void *);
;;  fn_t (*get)(void *) = &DdkGetIntercept;
;;
;;  void _DdkWrapper(void *a, void *b, void *c, void *d) {
;;    (*(*get)((void *)0))(a,b,c,d);
;;  }
;;

PUBLIC _DdkWrapper
PUBLIC _DdkWrapperEnd
PUBLIC _DdkWrapperMain

EXTRN DdkGetIntercept:PROC

_TEXT SEGMENT

a$ = 48
b$ = 56
c$ = 64
d$ = 72

_DdkWrapper PROC
        call    QWORD PTR _GetMain
_ReturnAddr::

        ALIGN   8
_GetMain::
        DQ      _DdkWrapperMain
_DdkWrapperEnd::
_GetIntercept::
        DQ      DdkGetIntercept

_DdkWrapperMain::
        pop     rax
        mov     QWORD PTR [rsp+32], r9
        mov     QWORD PTR [rsp+24], r8
        mov     QWORD PTR [rsp+16], rdx
        mov     QWORD PTR [rsp+8], rcx
        sub     rsp, 40                                 ; 00000028H

;;  Call DdkGetIntercept

        mov     rcx, rax
        sub     rcx, _ReturnAddr - _DdkWrapper
        call    QWORD PTR _GetIntercept

        mov     r9, QWORD PTR d$[rsp]
        mov     r8, QWORD PTR c$[rsp]
        mov     rdx, QWORD PTR b$[rsp]
        mov     rcx, QWORD PTR a$[rsp]
        add     rsp, 40                                 ; 00000028H
        jmp     rax  

_DdkWrapper ENDP

_TEXT ENDS

END
 
```

`src/device.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Device Routines.
 */

#include "stdddk.h"


typedef struct _DEVICE_OBJECT_POWER_EXTENSION {
	ULONG	unused;
} DEVOBJ_POWER, *PDEVOBJ_POWER;

typedef struct _DEVICE : public OBJECT {
	DEVICE_OBJECT Device;
	DEVOBJ_EXTENSION Extension;
	DEVOBJ_POWER Power;
	PWCH DeviceName;
} DEVICE, *PDEVICE;

static volatile LONG UniqueId = -1;


static PDEVICE GetDevice(OBJECT *pObj)
{
	if (!pObj || pObj->type != IoDeviceType)
		ddkfail("Invalid device specified");

	return static_cast<DEVICE *>(pObj);
}


DDKAPI
NTSTATUS IoCreateDevice(PDRIVER_OBJECT DriverObject, ULONG DeviceExtensionSize,
	PUNICODE_STRING DeviceName, DEVICE_TYPE DeviceType, ULONG DeviceCharacteristics,
	BOOLEAN Exclusive, PDEVICE_OBJECT *DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	DEVICE *pDevice = (DEVICE *)DdkAllocObject(
		sizeof(DEVICE) + DeviceExtensionSize, IoDeviceType, true);

	if (!pDevice) return STATUS_INSUFFICIENT_RESOURCES;

	DDKASSERT(DriverObject);

	pDevice->Device.Type = IO_TYPE_DEVICE;
	pDevice->Device.Size = sizeof(DEVICE_OBJECT);
	pDevice->Device.ReferenceCount = 0;
	pDevice->Device.DriverObject = DriverObject;
	pDevice->Device.DeviceExtension = (PVOID)(pDevice+1);
	pDevice->Device.DeviceType = DeviceType;
	pDevice->Device.Characteristics = DeviceCharacteristics;
	pDevice->Device.AlignmentRequirement = FILE_BYTE_ALIGNMENT;
	pDevice->Device.StackSize = 1;
	pDevice->Device.DeviceObjectExtension = &pDevice->Extension;

	pDevice->Extension.Type = IO_TYPE_DEVICE_OBJECT_EXTENSION;
	pDevice->Extension.Size = sizeof(DEVOBJ_EXTENSION);
	pDevice->Extension.DeviceObject = &pDevice->Device;
	pDevice->Extension.Dope = &pDevice->Power;

	if (DeviceName) {
		if (!DdkInsertName(DeviceName, pDevice, L"\\Device", &pDevice->DeviceName))
			return STATUS_OBJECT_NAME_EXISTS;
	}

	else if (DeviceCharacteristics & FILE_AUTOGENERATED_DEVICE_NAME) {
		UNICODE_STRING u;
		WCHAR buf[30];

		swprintf(buf, sizeof(buf), L"\\Device\\%08x", InterlockedIncrement(&UniqueId));
		RtlInitUnicodeString(&u, buf);

		if (!DdkInsertName(&u, pDevice, L"\\Device", &pDevice->DeviceName))
			return STATUS_OBJECT_NAME_EXISTS;
	}

	*DeviceObject = (PDEVICE_OBJECT)ToPointer(pDevice);

	DdkAddDevice(DriverObject, *DeviceObject);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoGetDeviceObjectPointer(PUNICODE_STRING ObjectName,
	ACCESS_MASK DesiredAccess, PFILE_OBJECT *FileObject, PDEVICE_OBJECT *DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	IO_STATUS_BLOCK iostatus;
	OBJECT_ATTRIBUTES attr;
	HANDLE FileHandle;

	InitializeObjectAttributes(&attr, ObjectName, 0, NULL, NULL);

	// TODO - set correct flags

	NTSTATUS rc = IoCreateFile(&FileHandle, 0,
		&attr, &iostatus, NULL, 0, 0, 0, 0, NULL, NULL, CreateFileTypeNone, NULL, 0);

	if (!NT_SUCCESS(rc)) return rc;

	PFILE_OBJECT pFile = DdkGetFilePointer(FileHandle);

	*DeviceObject = IoGetRelatedDeviceObject(pFile);
	*FileObject = pFile;

	return STATUS_SUCCESS;
}


DDKAPI
VOID IoDeleteDevice(PDEVICE_OBJECT DeviceObject)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	DEVICE *pDevice = GetDevice(FromPointer(DeviceObject));

	DdkRemoveObjectName(pDevice);
	DdkDereferenceObject(pDevice);
}


DDKAPI
NTSTATUS IoRegisterDeviceInterface(PDEVICE_OBJECT PhysicalDeviceObject,
	CONST GUID *InterfaceClassGuid, PUNICODE_STRING ReferenceString, PUNICODE_STRING SymbolicLinkName)
{
	DEVICE *pDevice = GetDevice(FromPointer(PhysicalDeviceObject));
	UNICODE_STRING guid, link, path;

	DDKASSERT(InterfaceClassGuid);
	DDKASSERT(SymbolicLinkName);
	DDKASSERT(ReferenceString == NULL);

	// TODO - handle multiple registrations

	if (!pDevice->DeviceName)
		return STATUS_INVALID_DEVICE_REQUEST;

	if (!NT_SUCCESS(RtlStringFromGUID(*InterfaceClassGuid, &guid)))
		return STATUS_INVALID_DEVICE_REQUEST;

	DdkCreatePath(&link, &guid, L"\\??", L"ROOT#SYSTEM#0000#");
	RtlFreeUnicodeString(&guid);
	RtlInitUnicodeString(&path, pDevice->DeviceName);

	if (DdkIsDeviceInterface(&link, TRUE)) {
		*SymbolicLinkName = link;
		return STATUS_OBJECT_NAME_EXISTS;
	}

	IoDeleteSymbolicLink(&link);
	NTSTATUS status = IoCreateSymbolicLink(&link, &path);

	if (!NT_SUCCESS(status)) {
		RtlFreeUnicodeString(&link);
		return status;
	}

	IoSetDeviceInterfaceState(&link, FALSE);

	*SymbolicLinkName = link;
	return status;
}


DDKAPI
NTSTATUS IoGetDeviceInterfaces(CONST GUID *InterfaceClassGuid,
    PDEVICE_OBJECT PhysicalDeviceObject, ULONG Flags, PZZWSTR *SymbolicLinkList)
{
	BOOLEAN all = (Flags & DEVICE_INTERFACE_INCLUDE_NONACTIVE) != 0;
	UNICODE_STRING guid, link;

	DDKASSERT(InterfaceClassGuid);
	DDKASSERT(SymbolicLinkList);

	// TODO - handle multiple registrations

	if (!NT_SUCCESS(RtlStringFromGUID(*InterfaceClassGuid, &guid)))
		return STATUS_INVALID_DEVICE_REQUEST;

	DdkCreatePath(&link, &guid, L"\\??", L"ROOT#SYSTEM#0000#");
	RtlFreeUnicodeString(&guid);

	WCHAR *buf = (WCHAR *)ExAllocatePool(NonPagedPool, link.Length + sizeof(WCHAR) * 2);

	if (!buf) {
		RtlFreeUnicodeString(&link);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	memset(buf, 0, link.Length + sizeof(WCHAR) * 2);

	if (DdkIsDeviceInterface(&link, all))
		memcpy(buf, link.Buffer, link.Length);

	RtlFreeUnicodeString(&link);
	*SymbolicLinkList = buf;
	return STATUS_SUCCESS;
}


DDKAPI
PDEVICE_OBJECT IoAttachDeviceToDeviceStack(PDEVICE_OBJECT SourceDevice,
	PDEVICE_OBJECT TargetDevice)
{
	PDEVICE_OBJECT pDevice;
	NTSTATUS status = IoAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, &pDevice);
	return NT_SUCCESS(status) ? pDevice : NULL;
}


DDKAPI
NTSTATUS IoAttachDeviceToDeviceStackSafe(PDEVICE_OBJECT SourceDevice,
    PDEVICE_OBJECT TargetDevice, PDEVICE_OBJECT *AttachedToDeviceObject)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(TargetDevice);

	SourceDevice->StackSize = pDevice->StackSize + 1;
	SourceDevice->AlignmentRequirement = pDevice->AlignmentRequirement;

	*AttachedToDeviceObject = pDevice;
	SourceDevice->DeviceObjectExtension->AttachedTo = pDevice;
	pDevice->AttachedDevice = SourceDevice;

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoAttachDevice(PDEVICE_OBJECT SourceDevice,
	PUNICODE_STRING TargetDevice, PDEVICE_OBJECT *AttachedDevice)
{
	PFILE_OBJECT pFileObject;
	PDEVICE_OBJECT pDeviceObject;

	NTSTATUS status = IoGetDeviceObjectPointer(TargetDevice,
		FILE_READ_ATTRIBUTES, &pFileObject, &pDeviceObject);
	
	if (!NT_SUCCESS(status))
		return status;

	status = IoAttachDeviceToDeviceStackSafe(SourceDevice, pDeviceObject, AttachedDevice);

	ObDereferenceObject(pFileObject);
	return status;
}


DDKAPI
NTSTATUS IoAttachDeviceByPointer(PDEVICE_OBJECT SourceDevice,
    PDEVICE_OBJECT TargetDevice)
{
	PDEVICE_OBJECT pDevice;
	return IoAttachDeviceToDeviceStackSafe(SourceDevice, TargetDevice, &pDevice);
}


DDKAPI
VOID IoDetachDevice(PDEVICE_OBJECT TargetDevice)
{
	TargetDevice->AttachedDevice->DeviceObjectExtension->AttachedTo = NULL;
	TargetDevice->AttachedDevice = NULL;
}


DDKAPI
PDEVICE_OBJECT IoGetAttachedDevice(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject;

	while (pDevice->AttachedDevice)
		pDevice = pDevice->AttachedDevice;

	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetAttachedDeviceReference(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(DeviceObject);

	ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetLowerDeviceObject(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject->DeviceObjectExtension->AttachedTo;

	if (pDevice) ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
PDEVICE_OBJECT IoGetDeviceAttachmentBaseRef(PDEVICE_OBJECT DeviceObject)
{
	PDEVICE_OBJECT pDevice = DeviceObject;

	while (pDevice->DeviceObjectExtension->AttachedTo)
		pDevice = pDevice->DeviceObjectExtension->AttachedTo;

	ObReferenceObject(pDevice);
	return pDevice;
}


DDKAPI
VOID IoInitializeRemoveLockEx(PIO_REMOVE_LOCK Lock, ULONG AllocateTag,
    ULONG MaxLockedMinutes, ULONG HighWatermark, ULONG RemlockSize)
{
	memset(Lock, 0, RemlockSize);

	if (RemlockSize > sizeof(Lock->Common)) {
		IO_REMOVE_LOCK_DBG_BLOCK *pDbg =
			(IO_REMOVE_LOCK_DBG_BLOCK *)((ULONG_PTR)Lock + sizeof(Lock->Common));

		KeInitializeSpinLock(&pDbg->Spin);
		InitializeListHead(&pDbg->LockList);
		pDbg->AllocateTag = AllocateTag;
		pDbg->HighWatermark = HighWatermark;
		pDbg->MaxLockedTicks = (MaxLockedMinutes * 600000000I64) / KeQueryTimeIncrement();
	}

	Lock->Common.IoCount = 1;
	KeInitializeEvent(&Lock->Common.RemoveEvent, NotificationEvent, FALSE);
}


DDKAPI
NTSTATUS IoAcquireRemoveLockEx(PIO_REMOVE_LOCK RemoveLock,
	PVOID Tag, PCSTR File, ULONG Line, ULONG RemlockSize)
{
	InterlockedIncrement(&RemoveLock->Common.IoCount);

	if (RemoveLock->Common.Removed) {
		if (InterlockedDecrement(&RemoveLock->Common.IoCount) == 0)
			KeSetEvent(&RemoveLock->Common.RemoveEvent, IO_NO_INCREMENT, FALSE);

		return STATUS_DELETE_PENDING;
	}

	return STATUS_SUCCESS;
}


DDKAPI
VOID IoReleaseRemoveLockEx(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize)
{
	if (InterlockedDecrement(&RemoveLock->Common.IoCount) == 0)
		KeSetEvent(&RemoveLock->Common.RemoveEvent, IO_NO_INCREMENT, FALSE);
}


DDKAPI
VOID IoReleaseRemoveLockAndWaitEx(PIO_REMOVE_LOCK RemoveLock, PVOID Tag, ULONG RemlockSize)
{
	RemoveLock->Common.Removed = TRUE;
	InterlockedDecrement(&RemoveLock->Common.IoCount);

	if (InterlockedDecrement(&RemoveLock->Common.IoCount) > 0)
		KeWaitForSingleObject(&RemoveLock->Common.RemoveEvent, Executive, KernelMode, FALSE, 0);
}


void DdkFreeDeviceObject(OBJECT *pObj)
{
	PDEVICE_OBJECT DeviceObject = (PDEVICE_OBJECT)ToPointer(pObj);
	DdkRemoveDevice(DeviceObject->DriverObject, DeviceObject);
}

```

`src/dpc.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	DPC Routines
 */

#include "stdafx.h"


typedef struct _DPC {
	PTP_WORK Work;
	PCRITICAL_SECTION Lock;
    PKDEFERRED_ROUTINE DeferredRoutine;
    PVOID DeferredContext;
    PVOID SystemArgument1;
    PVOID SystemArgument2;
	volatile LONG queued;
	volatile LONG cancel;
    UCHAR Importance;
    bool threaded;
} DPC, *PDPC;


__declspec(thread) bool DdkDpcActive = false;
static volatile LONGLONG DpcsQueued, DpcsCompleted;


static VOID DdkDpcCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)
{
	DPC *pDpc = (DPC *)Context;
	KIRQL irql = (pDpc->threaded ? PASSIVE_LEVEL : DISPATCH_LEVEL);
	KIRQL oldirql;

	DdkThreadInit();
	DdkDpcActive = true;
	InterlockedExchange(&pDpc->queued, 0);
	DisassociateCurrentThreadFromCallback(Instance);
	KeLowerIrql(PASSIVE_LEVEL);
	KeRaiseIrql(irql, &oldirql);

	(*pDpc->DeferredRoutine)((PRKDPC)pDpc,
		pDpc->DeferredContext, pDpc->SystemArgument1, pDpc->SystemArgument2);

	DDKASSERT(KeGetCurrentIrql() == irql);

	InterlockedIncrement64(&DpcsCompleted);
	KeLowerIrql(PASSIVE_LEVEL);
	DdkDpcActive = false;
}


DDKAPI
VOID KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)
{
	DPC *pDpc = (DPC *)Dpc;

	if (sizeof(DPC) > _SizeofDpc_)
		ddkfail("DPC is too small to initialize");

	memset(Dpc, 0, _SizeofDpc_);

	DdkThreadInit();
	pDpc->Lock = (PCRITICAL_SECTION)calloc(1, sizeof(CRITICAL_SECTION));
	pDpc->Work = CreateThreadpoolWork(DdkDpcCallback, (PVOID)pDpc, NULL);

	if (!pDpc->Work || !pDpc->Lock)
		ddkfail("Unable to initialize DPC");

	if (!InitializeCriticalSectionAndSpinCount(pDpc->Lock, 4000))
		ddkfail("KeInitializeDpc failed to initialize spinlock");

	pDpc->DeferredRoutine = DeferredRoutine;
	pDpc->DeferredContext = DeferredContext;
	pDpc->Importance = MediumImportance;
}


DDKAPI
VOID KeInitializeThreadedDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOID DeferredContext)
{
	KeInitializeDpc(Dpc, DeferredRoutine, DeferredContext);
	((PDPC)Dpc)->threaded = true;
}


DDKAPI
BOOLEAN KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2)
{
	DPC *pDpc = (DPC *)Dpc;

	EnterCriticalSection(pDpc->Lock);

	if (pDpc->queued || pDpc->cancel) {
		LeaveCriticalSection(pDpc->Lock);
		return FALSE;
	}

	pDpc->SystemArgument1 = SystemArgument1;
	pDpc->SystemArgument2 = SystemArgument2;
	pDpc->queued = 1;

	InterlockedIncrement64(&DpcsQueued);
	SubmitThreadpoolWork(pDpc->Work);
	LeaveCriticalSection(pDpc->Lock);
	return TRUE;
}


DDKAPI
BOOLEAN KeRemoveQueueDpc(PRKDPC Dpc)
{
	DPC *pDpc = (DPC *)Dpc;

	EnterCriticalSection(pDpc->Lock);

	if (!pDpc->queued || pDpc->cancel) {
		LeaveCriticalSection(pDpc->Lock);
		return FALSE;
	}

	pDpc->cancel = 1;
	LeaveCriticalSection(pDpc->Lock);
	WaitForThreadpoolWorkCallbacks(pDpc->Work, TRUE);

	BOOLEAN rc = (InterlockedExchange(&pDpc->queued, 0) != 0);
	if (rc) InterlockedIncrement64(&DpcsCompleted);
	InterlockedExchange(&pDpc->cancel, 0);
	return rc;
}


DDKAPI
VOID KeFlushQueuedDpcs()
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	LONGLONG queued = DpcsQueued;
	while (DpcsCompleted < queued) Sleep(10);
}


BOOLEAN DdkIsDpc()
{
	return (DdkDpcActive != false);
}

```

`src/driver.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Driver Routines.
 */

#include "stdddk.h"


typedef struct _DRIVER : public OBJECT {
	DRIVER_OBJECT Driver;
	DRIVER_EXTENSION Extension;
	volatile LONG loadcount;
	PIMAGE Image;
	WCHAR Name[1];
} DRIVER, *PDRIVER;


void DdkLoadLock();
void DdkLoadUnlock();
PIMAGE DdkLoadImage(char *pPath, char *pName);
PDRIVER_INITIALIZE DdkGetImageEntry(PIMAGE pImage);
void DdkGetDriverName(char *pFile, char *np, wchar_t *wp);
void DdkGetDriverPath(char *pFile, char *pPath, char *pName);
NTSTATUS DdkReferenceDriver(OBJECT *pObj, bool loaded);
NTSTATUS DdkDriverEntry(PDRIVER_OBJECT DriverObject);
void DdkDelayLoad(PIMAGE pImage, HRESULT (*pLoad)(const char *));
void DdkDelayUnload(PIMAGE pImage, INT (*pUnload)(const char *));


DRIVER_DISPATCH DdkDefaultDispatch;


static PDRIVER GetDriver(OBJECT *pObj)
{
	if (!pObj || pObj->type != IoDriverType)
		ddkfail("Invalid driver specified");

	return static_cast<DRIVER *>(pObj);
}


DDKAPI
NTSTATUS DdkLoadDriver(char *pFile, HRESULT (*pLoadAll)(const char *))
{
	char name[MAX_PATH+1], path[MAX_PATH+1];
	wchar_t wname[MAX_PATH+1];

	DdkThreadInit();

	// Check if driver is loaded

	DdkGetDriverName(pFile, name, wname);

	DdkLoadLock();
	OBJECT *pObj = DdkLookupName(wname, L"\\Driver");

	if (pObj) {
		NTSTATUS rc = DdkReferenceDriver(pObj, true);

		if (pLoadAll && NT_SUCCESS(rc))
			DdkDelayLoad(GetDriver(pObj)->Image, pLoadAll);

		DdkLoadUnlock();
		return rc;
	}

	// Load the driver

	DdkGetDriverPath(pFile, path, name);
	PIMAGE pImage = DdkLoadImage(path, name);

	NTSTATUS rc = DdkCreateDriver(name, DdkGetImageEntry(pImage), pImage);

	if (pLoadAll && NT_SUCCESS(rc))
		DdkDelayLoad(pImage, pLoadAll);

	DdkLoadUnlock();
	return rc;
}


DDKAPI_NODECL
NTSTATUS DdkInitDriver(char *pName, PDRIVER_INITIALIZE DriverInit)
{
	DdkThreadInit();

	DdkLoadLock();
	OBJECT *pObj = DdkLookupName(pName, L"\\Driver");

	if (pObj) {
		NTSTATUS rc = DdkReferenceDriver(pObj, false);
		DdkLoadUnlock();
		return rc;
	}

	NTSTATUS rc = DdkCreateDriver(pName, DriverInit, NULL);

	DdkLoadUnlock();
	return rc;
}


static NTSTATUS DdkReferenceDriver(OBJECT *pObj, bool loaded)
{
	DRIVER *pDriver = GetDriver(pObj);

	if ((pDriver->Image != NULL) != loaded)
		ddkfail("DdkReferenceDriver: Driver linked statically and dynamically");

	pDriver->loadcount++;
	return STATUS_SUCCESS;
}


DDKAPI_NODECL
VOID DdkUnloadDriver(char *pName, INT (*pUnload)(const char *))
{
	DdkThreadInit();

	DdkLoadLock();
	OBJECT *pObj = DdkLookupName(pName, L"\\Driver");

	if (!pObj) {
		DdkLoadUnlock();
		return;
	}

	DRIVER *pDriver = GetDriver(pObj);

	if (pUnload && pDriver->Image)
		DdkDelayUnload(pDriver->Image, pUnload);

	if (pDriver->loadcount && !--(pDriver->loadcount)) {
		DdkPnpUnload(&pDriver->Driver);

		if (pDriver->Driver.DriverUnload)
			(*pDriver->Driver.DriverUnload)(&pDriver->Driver);

		DdkRemoveObjectName(pObj);

		if (!DdkWaitLastReference(pObj, 120, 2))
			ddkfail("Timeout unloading driver");
	}

	DdkDereferenceObject(pObj);
	DdkDereferenceObject(pObj);
	DdkLoadUnlock();
}


NTSTATUS DdkCreateDriver(char *pName, PDRIVER_INITIALIZE DriverInit, PIMAGE Image)
{
	DRIVER *pDriver = (DRIVER *)DdkAllocObject(sizeof(DRIVER)
			+ strlen(pName) * sizeof(WCHAR), IoDriverType);

	DDKASSERT(pName && DriverInit);

	pDriver->Driver.Type = IO_TYPE_DRIVER;
	pDriver->Driver.Size = sizeof(DRIVER_OBJECT);
	pDriver->Driver.DriverExtension = &pDriver->Extension;
	pDriver->Driver.DriverInit = DriverInit;
	pDriver->Extension.DriverObject = &pDriver->Driver;
	pDriver->Image = Image;

	for (ULONG i = 0; i <= strlen(pName); i++)
		pDriver->Name[i] = (unsigned char)(pName[i]);

	RtlInitUnicodeString(&pDriver->Driver.DriverName, pDriver->Name);
	
	if (!DdkInsertName(&pDriver->Driver.DriverName, pDriver, L"\\Driver")) {
		DdkDereferenceObject(pDriver);
		return STATUS_OBJECT_NAME_EXISTS;
	}

	for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		pDriver->Driver.MajorFunction[i] = DdkDefaultDispatch;

	wchar_t params[MAX_PATH+1];
	swprintf(params, sizeof(params), L"%s\\Parameters", pDriver->Name);

	RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, pDriver->Name);
	RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, params);

	NTSTATUS rc = DdkDriverEntry(&pDriver->Driver);

	if (!NT_SUCCESS(rc)) {
		DdkDereferenceObject(pDriver);
		return rc;
	}

	pDriver->loadcount++;

	if (pDriver->Extension.AddDevice)
		DdkPnpCreateDevice(&pDriver->Driver);

	return STATUS_SUCCESS;
}


NTSTATUS DdkDriverEntry(PDRIVER_OBJECT DriverObject)
{
	wchar_t wname[MAX_PATH+1];
	UNICODE_STRING u;

	swprintf(wname, sizeof(wname),
		L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\%s",
		DriverObject->DriverName.Buffer);

	RtlInitUnicodeString(&u, wname);

	NTSTATUS rc = (*DriverObject->DriverInit)(DriverObject, &u);

	if (rc != STATUS_SUCCESS)
		ddkfail("DriverEntry failed");

	return STATUS_SUCCESS;
}


VOID DdkAddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT DeviceObject)
{
	DRIVER *pDriver = GetDriver(FromPointer(DriverObject));
	PDEVICE_OBJECT *ppDevice = &pDriver->Driver.DeviceObject;

	while (*ppDevice) ppDevice = &(*ppDevice)->NextDevice;
	*ppDevice = DeviceObject;

	DdkReferenceObject(pDriver);
}


VOID DdkRemoveDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT DeviceObject)
{
	DRIVER *pDriver = GetDriver(FromPointer(DriverObject));
	PDEVICE_OBJECT *ppDevice = &pDriver->Driver.DeviceObject;

	for (; *ppDevice; ppDevice = &(*ppDevice)->NextDevice)
		if (*ppDevice == DeviceObject) {
			*ppDevice = DeviceObject->NextDevice;
			DdkDereferenceObject(pDriver);
			return;
		}
}


void DdkFreeDriverObject(OBJECT *pObj)
{
	DRIVER *pDriver = GetDriver(pObj);

	if (pDriver->Image)
		DdkUnloadImage(pDriver->Image);
}


NTSTATUS DdkDefaultDispatch(DEVICE_OBJECT *pDevice, IRP *pIrp)
{
	pIrp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_INVALID_DEVICE_REQUEST;
}

```

`src/event.cpp`:

```cpp
 /*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Event Routines
 */

#include "stdafx.h"


typedef struct _EVENT : public OBJECT {
	bool	notify;
} EVENT, *PEVENT;



static void DdkInitEvent(PEVENT pEvent, EVENT_TYPE Type, BOOLEAN State)
{
	pEvent->h = CreateEvent(NULL, (Type == NotificationEvent), (State != FALSE), NULL);
	pEvent->type = EventType;
	pEvent->notify = (Type == NotificationEvent);
	if (!pEvent->h) ddkfail("Unable to initialize Event");
}


DDKAPI
VOID KeInitializeEvent(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State)
{
	EVENT *pEvent = (EVENT *)Event;

	DdkInitializeObject(pEvent, sizeof(EVENT), _SizeofEvent_);
	DdkInitEvent(pEvent, Type, State);
}


static PKEVENT DdkCreateEvent(
	PUNICODE_STRING EventName, PHANDLE EventHandle, EVENT_TYPE Type)
{
	DDKASSERT(EventHandle);
	DDKASSERT(EventName && EventName->Length);

	POBJECT pObj = DdkAllocObject(_SizeofEvent_, EventType, true);
	if (!pObj) return 0;

	DdkInitEvent((PEVENT)pObj, Type, TRUE);
	PEVENT pEvent = (PEVENT)DdkCreateName(EventName, pObj, L"\\BaseNamedObjects");

	if (pEvent == pObj) DdkDereferenceObject(pEvent);

	if (pEvent->type != EventType || pEvent->notify != (Type == NotificationEvent)) {
		DdkDereferenceObject(pEvent);
		return 0;
	}

	*EventHandle = ToHandle(pEvent);
	return (PKEVENT)ToPointer(pEvent);	
}


DDKAPI
PKEVENT IoCreateNotificationEvent(PUNICODE_STRING EventName, PHANDLE EventHandle)
{
	return DdkCreateEvent(EventName, EventHandle, NotificationEvent);
}


DDKAPI
PKEVENT IoCreateSynchronizationEvent(PUNICODE_STRING EventName, PHANDLE EventHandle)
{
	return DdkCreateEvent(EventName, EventHandle, SynchronizationEvent);
}


DDKAPI
LONG KeSetEvent(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait)
{
	EVENT *pEvent = (EVENT *)Event;

	DDKASSERT(KeGetCurrentIrql() <= (Wait ? APC_LEVEL : DISPATCH_LEVEL));

	DWORD rc = WaitForSingleObject(pEvent->h, 0);

	if (rc == WAIT_OBJECT_0) {
		if (!pEvent->notify) SetEvent(pEvent->h);
		return 1;
	}

	SetEvent(pEvent->h);
	return 0;
}


DDKAPI
LONG KeResetEvent(PRKEVENT Event)
{
	EVENT *pEvent = (EVENT *)Event;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	DWORD rc = WaitForSingleObject(pEvent->h, 0);

	if (rc == WAIT_OBJECT_0) {
		if (pEvent->notify) ResetEvent(pEvent->h);
		return 1;
	}

	return 0;
}


DDKAPI
VOID KeClearEvent(PRKEVENT Event)
{
	EVENT *pEvent = (EVENT *)Event;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	ResetEvent(pEvent->h);
}


DDKAPI
LONG KeReadStateEvent(PRKEVENT Event)
{
	EVENT *pEvent = (EVENT *)Event;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	DWORD rc = WaitForSingleObject(pEvent->h, 0);

	if (rc == WAIT_OBJECT_0) {
		if (!pEvent->notify) SetEvent(pEvent->h);
		return TRUE;
	}

	return FALSE;
}

```

`src/exception.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Exception Handling.
 */

#include "stdafx.h"


extern "C" LONG DdkExceptionHandler(EXCEPTION_POINTERS *xp);

static PVOID DdkVectoredHandle;


void DdkExceptionInit()
{
	DdkVectoredHandle = AddVectoredExceptionHandler(0, DdkExceptionHandler);

	if (!DdkVectoredHandle)
		ddkfail("Unable to register exception handler");
}


void DdkExceptionDeinit()
{
	if (DdkVectoredHandle) {
		RemoveVectoredExceptionHandler(DdkVectoredHandle);
		DdkVectoredHandle = NULL;
	}
}


static DWORD64 *DdkGetRegister(EXCEPTION_POINTERS *xp, UCHAR reg)
{
	// Assumes that the registers are stored in instruction decode
	// order which is currently true and likely to remain so.

	DWORD64 *pReg = &xp->ContextRecord->Rax;
	return &pReg[reg & 0xf];
}


static LONG DdkAccessException(EXCEPTION_POINTERS *xp)
{
	static const ULONG64 KernelShared = 0xFFFFF78000000000UI64;
	static const DWORD64 UserShared = 0x7FFE0000UI64;

	// Check for Read Access Exception

	if (xp->ExceptionRecord->NumberParameters != 2
	|| xp->ExceptionRecord->ExceptionInformation[0] != 0)
		return EXCEPTION_CONTINUE_SEARCH;

	ULONG64 addr = (ULONG64) xp->ExceptionRecord->ExceptionInformation[1];

	// Check for Read from KI_USER_SHARED_DATA

	if (addr >= KernelShared && addr < KernelShared + 0x800) {
		bool found = false;

		// The address of the shared area is in a register so
		// rather than decoding the instructions just fixup the
		// registers and continue.

		for (UCHAR i = 0; i < 16; i++) {
			DWORD64 *pReg = DdkGetRegister(xp, i);

			if ((ULONG64)(*pReg) == addr) {
				*pReg = (UserShared | (*pReg & 0x7ff));
				found = true;
			}
		}

		if (found) return EXCEPTION_CONTINUE_EXECUTION;
	}

	return EXCEPTION_CONTINUE_SEARCH;
}


static LONG DdkPrivException(EXCEPTION_POINTERS *xp)
{
	UCHAR *op = (UCHAR *)(xp->ExceptionRecord->ExceptionAddress);

	// Check for CR8 access (irql value)

	// These are MOVs with format 0x44 0x0F 0x20 0xC0
	// The register is in bytes 0 and 3 (mask 0x01 and 0x07)
	// The direction is in byte 2 (0x20: read, 0x22 write)

	if ((op[0] & 0xf6) == 0x44 && op[1] == 0x0f
			&& (op[2] & 0xfd) == 0x20 && (op[3] & 0xf8) == 0xc0) {

		DWORD64 *pReg = DdkGetRegister(xp, ((op[0] & 1) << 3) + (op[3] & 0x7));

		// Emulate the failing instruction

		if (op[2] & 0x02) DdkWriteCR8((ULONG64)*pReg);
		else *pReg = (DWORD64)DdkReadCR8();

		// Skip over it and continue running

		xp->ContextRecord->Rip += 4;
		return EXCEPTION_CONTINUE_EXECUTION;
	}

	return EXCEPTION_CONTINUE_SEARCH;
}


extern "C"
LONG DdkExceptionHandler(EXCEPTION_POINTERS *xp)
{
	if (xp->ExceptionRecord->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
		return DdkAccessException(xp);

	if (xp->ExceptionRecord->ExceptionCode == EXCEPTION_PRIV_INSTRUCTION)
		return DdkPrivException(xp);

    if (xp->ExceptionRecord->ExceptionCode == STATUS_ASSERTION_FAILURE) {
        xp->ExceptionRecord->ExceptionCode = EXCEPTION_UNITTEST_ASSERTION;
        xp->ExceptionRecord->NumberParameters = 2;
		xp->ExceptionRecord->ExceptionInformation[0] = 0;
        xp->ExceptionRecord->ExceptionInformation[1] = 0;
    }

	return EXCEPTION_CONTINUE_SEARCH;
}

```

`src/executive.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Executive Routines
 */

#include "stdafx.h"
#include "Objbase.h"


DDKAPI
NTSTATUS ExUuidCreate(UUID *Uuid)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	DDKASSERT(Uuid);
		
	if (CoCreateGuid(Uuid) != S_OK)
		return STATUS_RETRY;

	return STATUS_SUCCESS;
}

```

`src/file.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * File Routines.
 */

#include "stdddk.h"
#include <ntifs.h>
#include <fileapi.h>
#include <handleapi.h>


DWORD DdkGetFileDisposition(ULONG Disposition, ULONG *pInfo);
DWORD DdkGetFileFlags(ULONG CreateOptions);
bool DdkIsFilePath(PUNICODE_STRING path);
BOOL DdkGetFileInfo(HANDLE h, ULONG FileInformationClass,
	PVOID buffer, ULONG Length, size_t InfoSize, DWORD *pBytesCopied);
NTSTATUS DdkGetFileStatus(DWORD rc);


typedef struct _FILEOBJ : public OBJECT {
	FILE_OBJECT File;
} FILEOBJ, *PFILEOBJ;


static PFILEOBJ GetFile(OBJECT *pObj)
{
	if (!pObj || pObj->type != IoFileType)
		ddkfail("Invalid file object specified");

	return static_cast<FILEOBJ *>(pObj);
}


static PFILEOBJ GetFileFromHandle(HANDLE h)
{
	OBJECT *pObj = FromHandle(h);

	if (!pObj || pObj->type != IoFileType)
		return NULL;

	return static_cast<FILEOBJ *>(pObj);
}


static NTSTATUS SetStatus(
	PIO_STATUS_BLOCK IoStatusBlock, NTSTATUS status, ULONG info)
{
	IoStatusBlock->Information = info;
	IoStatusBlock->Status = status;
	return status;
}


static FILEOBJ *DdkAllocFile()
{
	FILEOBJ *pFile = (FILEOBJ *)DdkAllocObject(sizeof(FILEOBJ), IoFileType, true);

	if (!pFile) return NULL;

	pFile->File.Type = IO_TYPE_FILE;
	pFile->File.Size = sizeof(FILE_OBJECT);

	KeInitializeEvent(&pFile->File.Lock, SynchronizationEvent, TRUE);
	KeInitializeEvent(&pFile->File.Event, NotificationEvent, FALSE);
	KeInitializeSpinLock(&pFile->File.IrpListLock);
	InitializeListHead(&pFile->File.IrpList);
	return pFile;
}


static
NTSTATUS DdkIoCreateDevice(FILEOBJ **ppFile, POBJECT_ATTRIBUTES ObjectAttributes,
	PIO_STATUS_BLOCK IoStatusBlock, ULONG Options)
{
	OBJECT *pObj = DdkLookupName(ObjectAttributes->ObjectName);

	if (pObj && pObj->type == IoSymbolicLinkType) {
		if (Options & IO_STOP_ON_SYMLINK)
			return SetStatus(IoStatusBlock, STATUS_STOPPED_ON_SYMLINK, FILE_DOES_NOT_EXIST);

		pObj = DdkResolveSymbolicLink(pObj);
	}

	if (!pObj || pObj->type != IoDeviceType)
		return SetStatus(IoStatusBlock, STATUS_OBJECT_NAME_NOT_FOUND, FILE_DOES_NOT_EXIST);

	FILEOBJ *pFile = DdkAllocFile();

	if (!pFile) {
		DdkDereferenceObject(pObj);
		return SetStatus(IoStatusBlock, STATUS_INSUFFICIENT_RESOURCES, FILE_EXISTS);
	}

	pFile->File.DeviceObject = (PDEVICE_OBJECT)ToPointer(pObj);

	*ppFile = pFile;
	return SetStatus(IoStatusBlock, STATUS_SUCCESS, FILE_OPENED);
}


static
NTSTATUS DdkIoCreateDir(WCHAR *path,
	ULONG Disposition, ULONG *pDisp, bool *pCreated)
{
	if (Disposition != FILE_CREATE && Disposition != FILE_OPEN &&
			Disposition != FILE_OPEN_IF)
		return STATUS_INVALID_PARAMETER;

	if (Disposition == FILE_OPEN)
		return STATUS_SUCCESS;

	DWORD disp;
	*pDisp = DdkGetFileDisposition(FILE_OPEN, &disp);

	if (!CreateDirectoryW(path, NULL)) {
		DWORD rc = GetLastError();

		if (rc == ERROR_ALREADY_EXISTS) {
			*pCreated = false;
			return (Disposition != FILE_CREATE) ? STATUS_SUCCESS :
				STATUS_OBJECT_NAME_COLLISION;
		}

		return DdkGetFileStatus(rc);
	}

	*pCreated = true;
	return STATUS_SUCCESS;
}


static
NTSTATUS DdkIoCreateFile(FILEOBJ **ppFile, ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
	ULONG FileAttributes, ULONG ShareAccess, ULONG Disposition,
	ULONG CreateOptions)
{
	WCHAR path[MAX_PATH + 1];

	DdkGetLocalPath(path, sizeof(path) / sizeof(WCHAR),
		ObjectAttributes->ObjectName,
		(Disposition != FILE_OPEN && Disposition != FILE_OVERWRITE));

	ULONG info;
	bool created = true;
	DWORD disp = DdkGetFileDisposition(Disposition, &info);

	if (CreateOptions & FILE_DIRECTORY_FILE) {
		NTSTATUS status = DdkIoCreateDir(path, Disposition, &disp, &created);

		if (!NT_SUCCESS(status))
			return SetStatus(IoStatusBlock, status, 0);
	}

	SetLastError(ERROR_SUCCESS);

	HANDLE h = CreateFileW(path, DesiredAccess, ShareAccess,
		NULL, disp, (DWORD)FileAttributes | DdkGetFileFlags(CreateOptions), NULL);

	DWORD rc = GetLastError();

	if (h == INVALID_HANDLE_VALUE)
		return SetStatus(IoStatusBlock, DdkGetFileStatus(rc),
			(rc == ERROR_FILE_EXISTS) ? FILE_EXISTS : FILE_DOES_NOT_EXIST);

	if (Disposition == FILE_SUPERSEDE || Disposition == FILE_OPEN_IF ||
			Disposition == FILE_OVERWRITE_IF)
		if (rc != ERROR_ALREADY_EXISTS && created) info = FILE_CREATED;

	FILEOBJ *pFile = DdkAllocFile();

	if (!pFile) {
		CloseHandle(h);
		return SetStatus(IoStatusBlock, STATUS_INSUFFICIENT_RESOURCES, FILE_EXISTS);
	}

	pFile->h = h;

	*ppFile = pFile;
	return SetStatus(IoStatusBlock, STATUS_SUCCESS, info);
}


DDKAPI
NTSTATUS IoCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess,
    ULONG Disposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength,
    CREATE_FILE_TYPE CreateFileType, PVOID InternalParameters, ULONG Options)
{
	return IoCreateFileEx(FileHandle, DesiredAccess, ObjectAttributes,
		IoStatusBlock, AllocationSize, FileAttributes, ShareAccess,
		Disposition, CreateOptions, EaBuffer, EaLength, CreateFileType,
		InternalParameters, Options, NULL);
}


DDKAPI
NTSTATUS IoCreateFileEx(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess,
    ULONG Disposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength,
    CREATE_FILE_TYPE CreateFileType, PVOID InternalParameters, ULONG Options,
	PIO_DRIVER_CREATE_CONTEXT DriverContext)
{
	UNREFERENCED_PARAMETER(AllocationSize);
	UNREFERENCED_PARAMETER(CreateFileType);
	UNREFERENCED_PARAMETER(InternalParameters);
	UNREFERENCED_PARAMETER(Options);
	UNREFERENCED_PARAMETER(DriverContext);

	if (!ObjectAttributes || !ObjectAttributes->ObjectName || !IoStatusBlock)
		return STATUS_INVALID_PARAMETER;

	DDKASSERT(!ObjectAttributes->RootDirectory);

	FILEOBJ *pFile;
	NTSTATUS status = !DdkIsFilePath(ObjectAttributes->ObjectName) ?
		DdkIoCreateDevice(&pFile, ObjectAttributes, IoStatusBlock, Options) :
		DdkIoCreateFile(&pFile, DesiredAccess, ObjectAttributes, IoStatusBlock,
			FileAttributes, ShareAccess, Disposition, CreateOptions);

	if (!NT_SUCCESS(status))
		return status;

	*FileHandle = ToHandle(pFile);
	return status;
}


DDKAPI
NTSTATUS ZwOpenFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
    ULONG ShareAccess, ULONG OpenOptions)
{
	return IoCreateFileEx(FileHandle, DesiredAccess, ObjectAttributes,
		IoStatusBlock, NULL, 0, ShareAccess, FILE_OPEN, OpenOptions,
		NULL, NULL, CreateFileTypeNone, NULL, 0, NULL);
}


DDKAPI
NTSTATUS ZwCreateFile(PHANDLE FileHandle, ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes, PIO_STATUS_BLOCK IoStatusBlock,
    PLARGE_INTEGER AllocationSize, ULONG FileAttributes, ULONG ShareAccess,
    ULONG CreateDisposition, ULONG CreateOptions, PVOID EaBuffer, ULONG EaLength)
{
	return IoCreateFileEx(FileHandle, DesiredAccess, ObjectAttributes,
		IoStatusBlock, AllocationSize, FileAttributes, ShareAccess,
		CreateDisposition, CreateOptions, EaBuffer, EaLength,
		CreateFileTypeNone, NULL, 0, NULL);
}


static
NTSTATUS DdkReadWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
	PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
	PLARGE_INTEGER ByteOffset, bool write)
{
	if (!IoStatusBlock || !Buffer)
		return STATUS_INVALID_PARAMETER;

	if (Event) return STATUS_NOT_SUPPORTED;

	FILEOBJ *pFile = GetFileFromHandle(FileHandle);

	if (!pFile) return STATUS_INVALID_HANDLE;

	LARGE_INTEGER offset;
	OVERLAPPED overlap;

	if (!ByteOffset || (ByteOffset->HighPart == -1 &&
			ByteOffset->LowPart == FILE_USE_FILE_POINTER_POSITION))
		offset = pFile->File.CurrentByteOffset;

	else offset = *ByteOffset;

	memset(&overlap, 0, sizeof(overlap));
	overlap.Offset = offset.LowPart;
	overlap.OffsetHigh = offset.HighPart;

	NTSTATUS status = STATUS_SUCCESS;
	DWORD bytes = 0;

	BOOL rc = (write) ?
		WriteFile(pFile->h, Buffer, Length, &bytes, &overlap) :
		ReadFile(pFile->h, Buffer, Length, &bytes, &overlap);

	if (!rc) status = DdkGetFileStatus(GetLastError());

	offset.QuadPart += bytes;
	pFile->File.CurrentByteOffset = offset;

	SetStatus(IoStatusBlock, status, bytes);

	if (ApcRoutine)
		ApcRoutine(ApcContext, IoStatusBlock, 0);

	return status;
}


DDKAPI
NTSTATUS ZwReadFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
	PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
	PLARGE_INTEGER ByteOffset, PULONG Key)
{
	UNREFERENCED_PARAMETER(Key);

	return DdkReadWriteFile(FileHandle, Event, ApcRoutine, ApcContext,
		IoStatusBlock, Buffer, Length, ByteOffset, false);
}


DDKAPI
NTSTATUS ZwWriteFile(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine,
    PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length,
    PLARGE_INTEGER ByteOffset, PULONG Key)
{
	UNREFERENCED_PARAMETER(Key);

	return DdkReadWriteFile(FileHandle, Event, ApcRoutine, ApcContext,
		IoStatusBlock, Buffer, Length, ByteOffset, true);
}


DDKAPI
NTSTATUS ZwFlushBuffersFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock)
{
	FILEOBJ *pFile = GetFileFromHandle(FileHandle);
	NTSTATUS status = STATUS_SUCCESS;

	if (!pFile) return STATUS_INVALID_HANDLE;

	if (!FlushFileBuffers(pFile->h))
		status = DdkGetFileStatus(GetLastError());

	return SetStatus(IoStatusBlock, status, 0);
}


DDKAPI
NTSTATUS ZwQueryInformationFile(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock,
    PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass)
{
	FILEOBJ *pFile = GetFileFromHandle(FileHandle);

	if (!pFile) return STATUS_INVALID_HANDLE;

	if (!IoStatusBlock || !FileInformation)
		return STATUS_INVALID_PARAMETER;

	NTSTATUS status = STATUS_SUCCESS;
	DWORD bytes = 0;

	switch (FileInformationClass) {
	case FileBasicInformation:
	{
		if (!DdkGetFileInfo(pFile->h, FileInformationClass, FileInformation,
				Length, sizeof(FILE_BASIC_INFORMATION), &bytes))
			status = DdkGetFileStatus(GetLastError());
		break;
	}

	case FileStandardInformation:
	{
		if (!DdkGetFileInfo(pFile->h, FileInformationClass, FileInformation,
				Length, sizeof(FILE_STANDARD_INFORMATION), &bytes))
			status = DdkGetFileStatus(GetLastError());
		break;
	}

	case FilePositionInformation:
	{
		FILE_POSITION_INFORMATION *pInfo = (FILE_POSITION_INFORMATION *)FileInformation;

		if (Length < sizeof(*pInfo))
			return SetStatus(IoStatusBlock, STATUS_BUFFER_TOO_SMALL, 0);

		memcpy(&pInfo->CurrentByteOffset, &pFile->File.CurrentByteOffset,
			sizeof(LARGE_INTEGER));

		bytes = sizeof(*pInfo);
		break;
	}

	default:
		status = STATUS_NOT_SUPPORTED;
		break;
	}

	return SetStatus(IoStatusBlock, status, bytes);
}


DDKAPI
NTSTATUS ZwDeleteFile(POBJECT_ATTRIBUTES ObjectAttributes)
{
	WCHAR path[MAX_PATH + 1];

	if (!ObjectAttributes)
		return STATUS_INVALID_PARAMETER;

	DdkGetLocalPath(path, sizeof(path) / sizeof(WCHAR),
		ObjectAttributes->ObjectName, false);

	if (!DeleteFileW(path))
		return DdkGetFileStatus(GetLastError());

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS ZwQueryDirectoryFile(HANDLE FileHandle, HANDLE Event,
    PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock,
    PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass,
    BOOLEAN ReturnSingleEntry, PUNICODE_STRING FileName, BOOLEAN RestartScan)
{
	UNREFERENCED_PARAMETER(FileHandle);
	UNREFERENCED_PARAMETER(Event);
	UNREFERENCED_PARAMETER(ApcRoutine);
	UNREFERENCED_PARAMETER(ApcContext);
	UNREFERENCED_PARAMETER(IoStatusBlock);
	UNREFERENCED_PARAMETER(FileInformation);
	UNREFERENCED_PARAMETER(Length);
	UNREFERENCED_PARAMETER(FileInformationClass);
	UNREFERENCED_PARAMETER(ReturnSingleEntry);
	UNREFERENCED_PARAMETER(FileName);
	UNREFERENCED_PARAMETER(RestartScan);
	return STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
PDEVICE_OBJECT IoGetRelatedDeviceObject(PFILE_OBJECT FileObject)
{
	FILEOBJ *pFile = GetFile(FromPointer(FileObject));

	return IoGetAttachedDevice(pFile->File.DeviceObject);
}


PFILE_OBJECT DdkGetFilePointer(HANDLE FileHandle)
{
	FILEOBJ *pObj = GetFile(FromHandle(FileHandle));
	return (PFILE_OBJECT)ToPointer(pObj);
}


void DdkFreeFileObject(OBJECT *pObj)
{
	FILEOBJ *pFile = GetFile(pObj);

	if (pFile->File.DeviceObject)
		DdkDereferenceObject(FromPointer(pFile->File.DeviceObject));
}


static
NTSTATUS DdkGetFileStatus(DWORD rc)
{
	switch (rc) {
	case ERROR_SUCCESS:
		return STATUS_SUCCESS;

	case ERROR_ACCESS_DENIED:
		return STATUS_ACCESS_DENIED;

	case ERROR_NOT_ENOUGH_MEMORY:
		return STATUS_INSUFFICIENT_RESOURCES;

	case ERROR_INVALID_HANDLE:
		return STATUS_INVALID_HANDLE;

	case ERROR_FILE_NOT_FOUND:
		return STATUS_OBJECT_NAME_NOT_FOUND;

	case ERROR_FILE_EXISTS:
		return STATUS_OBJECT_NAME_COLLISION;

	case ERROR_SHARING_VIOLATION:
		return STATUS_SHARING_VIOLATION;

	case ERROR_MORE_DATA:
		return STATUS_BUFFER_TOO_SMALL;

	case ERROR_INVALID_PARAMETER:
		return STATUS_INVALID_PARAMETER;

	case ERROR_NOACCESS:
		return STATUS_ACCESS_VIOLATION;

	case ERROR_HANDLE_EOF:
		return STATUS_END_OF_FILE;

	case ERROR_PATH_NOT_FOUND:
		return STATUS_OBJECT_PATH_NOT_FOUND;
	}

	return STATUS_UNSUCCESSFUL;
}
```

`src/init.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Initialization Routines.
 */

#include "stdafx.h"


void DdkInit();
void DdkCpuInit();
void DdkTimeInit();
void DdkNameInit();
void DdkLoadInit();
void DdkLocalInit();
void DdkRegistryInit();
void DdkTestInit();
void DdkWaitInit();
void DdkPnpInit();
void DdkRegistryDeinit();
void DdkLocalDeinit();
void DdkExceptionInit();
void DdkExceptionDeinit();

static bool initialised = false;
static struct _DdkInit { _DdkInit() { DdkInit(); } } _DdkInit;


void DdkInit()
{
	if (!initialised) {
		DdkExceptionInit();
		DdkCpuInit();
		DdkTimeInit();
		DdkNameInit();
		DdkLocalInit();
		DdkRegistryInit();
		DdkLoadInit();
		DdkTestInit();
		DdkWaitInit();
		DdkPnpInit();
		initialised = true;
	}

	DdkThreadInit();
}


void DdkDeinit()
{
	DdkDetachIntercept(NULL, NULL);
	DdkRegistryDeinit();
	DdkLocalDeinit();
	DdkExceptionDeinit();
}


extern "C"
int DllMain(HANDLE hModule, DWORD reason, PVOID lpReserved)
{
    switch (reason)
	{
		case DLL_PROCESS_ATTACH:
			DdkInit();
			break;

		case DLL_THREAD_ATTACH:
			DdkThreadInit();
			break;

		case DLL_THREAD_DETACH:
			DdkThreadDeinit();
			break;

		case DLL_PROCESS_DETACH:
			DdkDeinit();
			break;
    }

    return TRUE;
}

```

`src/inline.c`:

```c
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Inline Routines.
 *
 *	Note: This file is an optimisation that is compiled and linked with
 *	unit test code to try and reduce the frequency of exceptions.  It is not
 *	required for correct operation.
 *
 *	In normal circumstances the exception handler will catch privileged
 *	instructions and resolve them quickly.  When the Visual Studio Debugger
 *	is involved it gets notified about every exception which can have a
 *	significant impact on run time.
 *
 *	This file redefines the COMDAT sections for inline functions and is
 *	linked with the test code as the first object file.  The functions
 *	are declared as dllexport to ensure that the linker references the
 *	code.  There are no documented guarantees that the linker will handle
 *	this as intended, but it seems to work for Debug builds.
 *
 *	For Release builds the compiler has already inlined the code and so
 *	the generated code is unchanged.
 */

typedef unsigned char KIRQL;

__declspec(dllimport) void KeLowerIrql(KIRQL irql);
__declspec(dllimport) KIRQL KfRaiseIrql(KIRQL irql);
__declspec(dllimport) KIRQL DdkRaiseIrqlToDpcLevel();

__declspec(dllexport) __forceinline void KzLowerIrql(KIRQL irql) { KeLowerIrql(irql); }
__declspec(dllexport) __forceinline KIRQL KzRaiseIrql(KIRQL irql) { return KfRaiseIrql(irql); }
__declspec(dllexport) __forceinline KIRQL KeRaiseIrqlToDpcLevel() { return DdkRaiseIrqlToDpcLevel(); }


/*
 *	KeGetCurrentIrql isn't inline by default in WDK 10.0.20348 (which defines
 *	NTDDI_WIN10_FE), so don't generate a definition to avoid a conflict.
 */
#include <sdkddkver.h>

#if !defined(NTDDI_WIN10_FE)
__declspec(dllimport) KIRQL DdkGetCurrentIrql(); 
__declspec(dllexport) __forceinline KIRQL KeGetCurrentIrql() { return DdkGetCurrentIrql(); }
#endif

```

`src/interlocked.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Interlocked Routines
 */

#include "stdafx.h"


DDKAPI
LARGE_INTEGER ExInterlockedAddLargeInteger(PLARGE_INTEGER Addend,
    LARGE_INTEGER Increment, PKSPIN_LOCK Lock)
{
	LARGE_INTEGER x;
	x.QuadPart = InterlockedExchangeAdd64(&Addend->QuadPart, Increment.QuadPart);
	return x;
}

```

`src/irp.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * IRP Routines.
 */

#include "stdddk.h"


IO_COMPLETION_ROUTINE DdkIrpCompletion;
IO_COMPLETION_ROUTINE DdkIoctlCompletion;


NTSTATUS DdkSynchronousIrp(PDEVICE_OBJECT DeviceObject, UCHAR Major, UCHAR Minor, PIRP Irp)
{
	IO_STACK_LOCATION *pStack;
	KEVENT event;

	if (!Irp && (Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE)) == NULL)
 		return STATUS_INSUFFICIENT_RESOURCES;

	// Setup request

	pStack = IoGetNextIrpStackLocation(Irp);
	pStack->MajorFunction = Major;
	pStack->MinorFunction = Minor;

	KeInitializeEvent(&event, NotificationEvent, FALSE);
	IoSetCompletionRoutine(Irp, DdkIrpCompletion, (PVOID)&event, TRUE, TRUE, TRUE);

	Irp->IoStatus.Status = STATUS_SUCCESS;
	Irp->IoStatus.Information = 0;
	Irp->Tail.Overlay.Thread = PsGetCurrentThread();

	// Issue request

	NTSTATUS status = IoCallDriver(DeviceObject, Irp);

	if (status == STATUS_PENDING) {
		KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, 0);
		status = Irp->IoStatus.Status;
	}

	IoFreeIrp(Irp);
	return status;
}


NTSTATUS DdkIrpCompletion(DEVICE_OBJECT *, IRP *, void *pContext)
{
	KeSetEvent((KEVENT *)pContext, IO_NO_INCREMENT, FALSE);
	return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS DdkIoctlCompletion(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context)
{
    if (Irp->Flags & IRP_BUFFERED_IO) {
        RtlCopyMemory(Irp->UserBuffer, Irp->AssociatedIrp.SystemBuffer, Irp->IoStatus.Information);
    }

	// TODO - copy data buffers

	if (Irp->UserIosb)
		*(Irp->UserIosb) = Irp->IoStatus;

	if (Irp->UserEvent)
		KeSetEvent(Irp->UserEvent, IO_NO_INCREMENT, FALSE);

	if (Irp->MdlAddress)
		IoFreeMdl(Irp->MdlAddress);

	IoFreeIrp(Irp);
	return STATUS_MORE_PROCESSING_REQUIRED;
}


DDKAPI
PIRP IoBuildDeviceIoControlRequest(ULONG IoControlCode, PDEVICE_OBJECT DeviceObject,
    PVOID InputBuffer, ULONG InputBufferLength, PVOID OutputBuffer, ULONG OutputBufferLength,
    BOOLEAN InternalDeviceIoControl, PKEVENT Event, PIO_STATUS_BLOCK IoStatusBlock)
{
	PIRP pIrp = IoAllocateIrp(DeviceObject->StackSize, FALSE);
	if (!pIrp) return 0;

	IO_STACK_LOCATION *pStack = IoGetNextIrpStackLocation(pIrp);

	pStack->MajorFunction = (InternalDeviceIoControl)
		? IRP_MJ_INTERNAL_DEVICE_CONTROL : IRP_MJ_DEVICE_CONTROL;

	pStack->MinorFunction = 0;
	pStack->Parameters.DeviceIoControl.IoControlCode = IoControlCode;
	pStack->Parameters.DeviceIoControl.InputBufferLength = InputBufferLength;
	pStack->Parameters.DeviceIoControl.OutputBufferLength = OutputBufferLength;
	pStack->DeviceObject = DeviceObject;

	switch (METHOD_FROM_CTL_CODE(IoControlCode)) {
	case METHOD_BUFFERED:
		pIrp->AssociatedIrp.SystemBuffer = ExAllocatePool(NonPagedPool,
			(InputBufferLength > OutputBufferLength) ? InputBufferLength : OutputBufferLength);

		if (!pIrp->AssociatedIrp.SystemBuffer) {
			IoFreeIrp(pIrp);
			return 0;
		}

		memcpy(pIrp->AssociatedIrp.SystemBuffer, InputBuffer, InputBufferLength);
        pIrp->UserBuffer = OutputBuffer;
		pIrp->Flags |= (IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER);
		break;

	case METHOD_IN_DIRECT:
	case METHOD_OUT_DIRECT:
		pIrp->AssociatedIrp.SystemBuffer = InputBuffer;
		pIrp->Flags |= IRP_BUFFERED_IO;

		if (!IoAllocateMdl(OutputBuffer, OutputBufferLength, FALSE, FALSE, pIrp)) {
			IoFreeIrp(pIrp);
			return 0;
		}
		break;

	case METHOD_NEITHER:
		pStack->Parameters.DeviceIoControl.Type3InputBuffer = InputBuffer;
		pIrp->UserBuffer = OutputBuffer;
		break;
	}

	pIrp->UserEvent = Event;
	pIrp->UserIosb = IoStatusBlock;
	pIrp->RequestorMode = KernelMode;

	IoSetCompletionRoutine(pIrp, DdkIoctlCompletion, 0, TRUE, TRUE, TRUE);
	return pIrp;
}


DDKAPI
PIRP IoAllocateIrp(CCHAR StackSize, BOOLEAN ChargeQuota)
{
	IRP *pIrp = (IRP *)ExAllocatePool(NonPagedPool, IoSizeOfIrp(StackSize));

	if (pIrp) IoInitializeIrp(pIrp, IoSizeOfIrp(StackSize), StackSize);
	return pIrp;
}


DDKAPI
VOID IoInitializeIrp(PIRP Irp, USHORT PacketSize, CCHAR StackSize)
{
	memset(Irp, 0, PacketSize);

	Irp->Size = PacketSize;
	Irp->StackCount = StackSize;
	Irp->CurrentLocation = StackSize + 1;

	Irp->Tail.Overlay.CurrentStackLocation =
		(PIO_STACK_LOCATION)(((char *)Irp) + PacketSize);
}


DDKAPI
VOID IoFreeIrp(PIRP Irp)
{
	ExFreePool(Irp);
}


DDKAPI
NTSTATUS IofCallDriver(PDEVICE_OBJECT DeviceObject, PIRP Irp)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	DDKASSERT(Irp->CurrentLocation > 0);

	IoSetNextIrpStackLocation(Irp);
	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(Irp);

	pStack->DeviceObject = DeviceObject;
	return DeviceObject->DriverObject->MajorFunction[pStack->MajorFunction](DeviceObject, Irp);
}


DDKAPI
VOID IofCompleteRequest(PIRP Irp, CCHAR PriorityBoost)
{
	while (Irp->CurrentLocation <= Irp->StackCount) {
		PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(Irp);
		PIO_COMPLETION_ROUTINE Completion = pStack->CompletionRoutine;
		PVOID Context = pStack->Context;
		UCHAR Control = pStack->Control;

		Irp->PendingReturned = ((Control & SL_PENDING_RETURNED) != 0);

		IoSkipCurrentIrpStackLocation(Irp);
		memset(pStack, 0, sizeof(*pStack));

		if ((NT_SUCCESS(Irp->IoStatus.Status) && (Control & SL_INVOKE_ON_SUCCESS))
		|| (!NT_SUCCESS(Irp->IoStatus.Status) && (Control & SL_INVOKE_ON_ERROR))
		|| (Irp->Cancel && (Control & SL_INVOKE_ON_CANCEL))) {
			PDEVICE_OBJECT DeviceObject = (Irp->CurrentLocation <= Irp->StackCount)
				? IoGetCurrentIrpStackLocation(Irp)->DeviceObject : NULL;

			if (Completion(DeviceObject, Irp, Context) == STATUS_MORE_PROCESSING_REQUIRED)
				return;

			continue;
		}
		
		if (Irp->PendingReturned && Irp->CurrentLocation <= Irp->StackCount)
			IoMarkIrpPending(Irp);
	}

	ddkfail("IoCompleteRequest completing IRP");
}


```

`src/irql.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	IRQL Routines
 */

#include "stdafx.h"


#undef KeRaiseIrql
#undef KeGetCurrentIrql

__declspec(thread) KIRQL DdkCurrentIrql = PASSIVE_LEVEL;


#ifndef _DDKINLINE_
DDKAPI
KIRQL KeGetCurrentIrql()
{
	return DdkCurrentIrql;
}
#endif


DDKAPI
KIRQL DdkGetCurrentIrql()
{
	return DdkCurrentIrql;
}


ULONG64 DdkReadCR8()
{
	return (ULONG64)DdkCurrentIrql;
}


VOID DdkWriteCR8(ULONG64 v)
{
	DdkCurrentIrql = (KIRQL)v;
}


DDKAPI
KIRQL KfRaiseIrql(KIRQL NewIrql)
{
    KIRQL irql = DdkCurrentIrql;

	DDKASSERT(KeGetCurrentIrql() <= NewIrql);

	DdkCurrentIrql = NewIrql;
    return irql;
}


DDKAPI
VOID KeRaiseIrql(KIRQL NewIrql, PKIRQL OldIrql)
{
	*OldIrql = KfRaiseIrql(NewIrql);
}


DDKAPI
VOID KeLowerIrql(KIRQL NewIrql)
{
	DDKASSERT(KeGetCurrentIrql() >= NewIrql);
	DdkCurrentIrql = NewIrql;
}


DDKAPI
KIRQL DdkRaiseIrqlToDpcLevel()
{
	return KfRaiseIrql(DISPATCH_LEVEL);
}

```

`src/list.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Doubly Linked List Routines
 */

#include "stdddk.h"


DDKAPI
PLIST_ENTRY ExInterlockedRemoveHeadList(PLIST_ENTRY ListHead, PKSPIN_LOCK Lock)
{
	PLIST_ENTRY Entry;
	KIRQL irql;
	KeAcquireSpinLock(Lock, &irql);
	Entry = RemoveHeadList(ListHead);
	KeReleaseSpinLock(Lock, irql);
	return Entry;
}


DDKAPI
PLIST_ENTRY ExInterlockedInsertHeadList(PLIST_ENTRY ListHead,
    PLIST_ENTRY ListEntry, PKSPIN_LOCK Lock)
{
	PLIST_ENTRY Entry;
	KIRQL irql;
	KeAcquireSpinLock(Lock, &irql);
	Entry = !IsListEmpty(ListHead) ? ListHead->Flink : 0;
	InsertHeadList(ListHead, ListEntry);
	KeReleaseSpinLock(Lock, irql);
	return Entry;
}


DDKAPI
PLIST_ENTRY ExInterlockedInsertTailList(PLIST_ENTRY ListHead,
    PLIST_ENTRY ListEntry, PKSPIN_LOCK Lock)
{
	PLIST_ENTRY Entry;
	KIRQL irql;
	KeAcquireSpinLock(Lock, &irql);
	Entry = !IsListEmpty(ListHead) ? ListHead->Blink : 0;
	InsertTailList(ListHead, ListEntry);
	KeReleaseSpinLock(Lock, irql);
	return Entry;
}

```

`src/load.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Load Routines.
 */

#include "stdafx.h"
#include "delayimp.h"


typedef struct _DELAYLOAD {
	HMODULE module;
	LONG refcnt;
} DELAYLOAD, *PDELAYLOAD;

static const int maxmodules = 100;

typedef struct _IMAGE {
	struct _IMAGE *Next;
	HMODULE h;
	PIMAGE_NT_HEADERS64 Header;
	PDRIVER_INITIALIZE DriverEntry;
	DELAYLOAD DelayLoad[maxmodules];
	char *Data;
	char Name[1];
} IMAGE, *PIMAGE;

IMAGE *DdkImageList;


void DdkSaveImageData(PIMAGE pImage);
void DdkRestoreImageData(PIMAGE pImage);
char *DdkReadImage(char *pPath, DWORD *pSize);
void DdkUpdateImage(char *pBuffer, DWORD size, DWORD *pEntry);
bool DdkWriteImage(char *pBuffer, char *pLoad, DWORD size);
bool DdkGetWriteTime(char *pPath, FILETIME *pTime);
NTSTATUS DdkDetachAddressRange(PVOID pAddr, size_t len, HMODULE module);
HMODULE DdkFindModule(PVOID pAddr);
char *DdkFindDLLName(HMODULE h, char *pName);

static CRITICAL_SECTION Lock;


void DdkLoadInit()
{
	if (!InitializeCriticalSectionAndSpinCount(&Lock, 4000))
		ddkfail("DdkLoadInit failed to initialize lock");
}


void DdkLoadLock()
{
	EnterCriticalSection(&Lock);
}


void DdkLoadUnlock()
{
	LeaveCriticalSection(&Lock);
}


PIMAGE DdkLoadImage(char *pPath, char *pName)
{
	char tmp[MAX_PATH+1];
	DWORD size, entry;

	for (PIMAGE pEntry = DdkImageList; pEntry; pEntry = pEntry->Next)
		if (!stricmp(pEntry->Name, pName)) return pEntry;

	char *pBuffer = DdkReadImage(pPath, &size);

	if (!pBuffer)
		ddkfail("Unable to read driver file");

	DdkUpdateImage(pBuffer, size, &entry);
	DdkGetLocalPath(tmp, sizeof(tmp), "C:\\Windows\\System32\\drivers", pName, ".sys");

	if (!DdkWriteImage(pBuffer, tmp, size))
		ddkfail("Unable to write driver file");

	free(pBuffer);

	HMODULE h = LoadLibrary(tmp);
	if (!h) ddkfail("Unable to load driver");

	PIMAGE p = (PIMAGE)calloc(1, sizeof(IMAGE) + strlen(pName));
	if (!p) ddkfail("Unable to create image");

	p->Header = (PIMAGE_NT_HEADERS64)((ULONG_PTR)h + ((PIMAGE_DOS_HEADER)h)->e_lfanew);
	p->DriverEntry = (PDRIVER_INITIALIZE)((ULONG_PTR)h + (ULONG_PTR)entry);
	p->Next = DdkImageList;
	p->h = h;

	strcpy(p->Name, pName);
	DdkSaveImageData(p);
	DdkImageList = p;
	return p;
}


void DdkDelayLoad(PIMAGE pImage, HRESULT (*pLoad)(const char *))
{
	if (!pImage || !pLoad) return;

	DELAYLOAD *pDelay = pImage->DelayLoad;
	HMODULE h = DdkFindModule(pLoad);
	int i, empty = -1;

	if (!h) return;

	for (i = maxmodules - 1; i >= 0; i--)
		if (pDelay[i].module == h) break;
		else if (!pDelay[i].module) empty = i;

	if (i < 0 && (i = empty) < 0)
		ddkfail("Unable to reference driver");

	pDelay[i].module = h;
	pDelay[i].refcnt++;

	char *pDLL = DdkFindDLLName(h, pImage->Name);
	if (pDLL) (*pLoad)(pDLL);
}


void DdkDelayUnload(PIMAGE pImage, INT (*pUnload)(const char *))
{
	if (!pImage || !pUnload) return;

	DELAYLOAD *pDelay = pImage->DelayLoad;
	HMODULE h = DdkFindModule(pUnload);

	if (!h) return;

	for (int i = 0; i < maxmodules; i++)
		if (pDelay[i].module == h) {
			if (pDelay[i].refcnt-- > 1) return;
			pDelay[i].module = NULL;
			break;
		}

	// Remove any remaining detours

	IMAGE_OPTIONAL_HEADER64 *pOpt = &pImage->Header->OptionalHeader;
	NTSTATUS status = DdkDetachAddressRange((PVOID)pOpt->ImageBase, pOpt->SizeOfImage, h);

	if (!NT_SUCCESS(status))
		ddkfail("Unable to detach detours for module");

	char *pDLL = DdkFindDLLName(h, pImage->Name);
	if (pDLL) (*pUnload)(pDLL);
}


static bool isSaveData(PIMAGE_SECTION_HEADER p)
{
	return (p->Characteristics & (IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_CNT_UNINITIALIZED_DATA))
		&& (p->Characteristics & IMAGE_SCN_MEM_WRITE);
}


static void DdkSaveImageData(PIMAGE pImage)
{
	PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pImage->Header);
	DWORD len = 0;

	for (int i = 0; i < pImage->Header->FileHeader.NumberOfSections; i++)
		if (isSaveData(&pSection[i])) len += pSection[i].Misc.VirtualSize;

	if (!len) return;

	pImage->Data = (char *)malloc(len);
	char *cp = pImage->Data;

	if (!cp) ddkfail("Unable to save image data");

	for (int i = 0; i < pImage->Header->FileHeader.NumberOfSections; i++)
		if (isSaveData(&pSection[i])) {
			memcpy(cp, (char *)(pImage->h) + pSection[i].VirtualAddress, pSection[i].Misc.VirtualSize);
			cp += pSection[i].Misc.VirtualSize;
		}
}


static void DdkRestoreImageData(PIMAGE pImage)
{
	PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pImage->Header);
	char *cp = pImage->Data;

	if (!cp) return;

	for (int i = 0; i < pImage->Header->FileHeader.NumberOfSections; i++)
		if (isSaveData(&pSection[i])) {
			memcpy((char *)(pImage->h) + pSection[i].VirtualAddress, cp, pSection[i].Misc.VirtualSize);
			cp += pSection[i].Misc.VirtualSize;
		}
}


static char *DdkReadImage(char *pPath, DWORD *pSize)
{
	HANDLE h = CreateFile(pPath, GENERIC_READ, FILE_SHARE_READ,
		NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	if (h == INVALID_HANDLE_VALUE) return 0;

	BY_HANDLE_FILE_INFORMATION info;

	if (!GetFileInformationByHandle(h, &info) || info.nFileSizeHigh) {
		CloseHandle(h);
		return 0;
	}

	char *pBuffer = (char *)malloc(info.nFileSizeLow);

	if (!pBuffer) {
		CloseHandle(h);
		return 0;
	}

	if (!ReadFile(h, pBuffer, info.nFileSizeLow, pSize, NULL)
			|| *pSize != info.nFileSizeLow) {
		CloseHandle(h);
		free(pBuffer);
		return 0;
	}

	CloseHandle(h);
	return pBuffer;
}


static void DdkUpdateImage(char *pBuffer, DWORD size, DWORD *pEntry)
{
	// Set DLL flag

	PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pBuffer;
	PIMAGE_NT_HEADERS64 pHdr = (PIMAGE_NT_HEADERS64)(&pBuffer[pDos->e_lfanew]);

	pHdr->FileHeader.Characteristics |= IMAGE_FILE_DLL;

	// Disable DriverEntry

	*pEntry = pHdr->OptionalHeader.AddressOfEntryPoint;
	pHdr->OptionalHeader.AddressOfEntryPoint = 0;

	// Link against ddk.dll

	for (DWORD i = 0; i < size; i++) {
		if (!strnicmp(&pBuffer[i], "ntoskrnl.exe", 12))
			strcpy(&pBuffer[i], "ddk.dll");
		
		else if (!strnicmp(&pBuffer[i], "hal.dll", 7))
			strcpy(&pBuffer[i], "ddk.dll");

		else if (!strnicmp(&pBuffer[i], "wmilib.sys", 10))
			strcpy(&pBuffer[i], "ddk.dll");
	}

	// Edit references to USER_SHARED_DATA

	unsigned char from[] = { 0x00, 0x00, 0x80, 0xf7, 0xff, 0xff };
	unsigned char to[] = { 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00 };

	for (DWORD i = 0; i < size; i++)
		if (!memcmp(&pBuffer[i], from, sizeof(from)))
			if (i > 1 && (unsigned char)pBuffer[i-1] < 0x80)
				memcpy(&pBuffer[i], to, sizeof(to));
}


static bool DdkWriteImage(char *pBuffer, char *pLoad, DWORD size)
{
	HANDLE h = CreateFile(pLoad, GENERIC_WRITE, 0,
		NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

	if (h == INVALID_HANDLE_VALUE) return false;

	DWORD bytesWritten;

	if (!WriteFile(h, pBuffer, size, &bytesWritten, NULL)
			|| bytesWritten != size) {
		CloseHandle(h);
		return false;
	}

	CloseHandle(h);
	return true;
}


VOID DdkUnloadImage(PIMAGE pImage)
{
	IMAGE_OPTIONAL_HEADER64 *pOpt = &pImage->Header->OptionalHeader;
	PDELAYLOAD pDelay = pImage->DelayLoad;
	HMODULE h;

	// Check for residual references

	for (int i = 0; i < maxmodules; i++)
		if (pDelay[i].module && pDelay[i].refcnt)
			ddkfail("Driver still referenced");

	// Detach any remaining detours

	NTSTATUS status = DdkDetachAddressRange((PVOID)pOpt->ImageBase, pOpt->SizeOfImage, NULL);

	if (!NT_SUCCESS(status))
		ddkfail("Unable to detach detours from image");

	FreeLibrary(pImage->h);

	if (GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS, (LPCTSTR)pImage->h, &h)) {
		DdkRestoreImageData(pImage);
		return;
	}

	for (PIMAGE *ppEntry = &DdkImageList; *ppEntry; ppEntry = &(*ppEntry)->Next)
		if (*ppEntry == pImage) {
			*ppEntry = pImage->Next;
			break;
		}

	if (pImage->Data) free(pImage->Data);
	free(pImage);
}


PDRIVER_INITIALIZE DdkGetImageEntry(PIMAGE pImage)
{
	return pImage->DriverEntry;
}


char *DdkFindDLLName(HMODULE h, char *pName)
{
	IMAGE_OPTIONAL_HEADER64 *pOpt = &((PIMAGE_NT_HEADERS64)((ULONG_PTR)h
		+ ((PIMAGE_DOS_HEADER)h)->e_lfanew))->OptionalHeader;

	IMAGE_DATA_DIRECTORY *pDelay =
		&pOpt->DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];

	if (!pDelay->Size) return NULL;

	size_t len = strlen(pName);

	for (PCImgDelayDescr pDesc = (PCImgDelayDescr)((char *)h +
			pDelay->VirtualAddress); pDesc->rvaDLLName != 0; pDesc++) {
		if (!strnicmp(pName, (char *)h + pDesc->rvaDLLName, len)
				&& !stricmp((char *)h + pDesc->rvaDLLName + len, ".sys"))
			return (char *)h + pDesc->rvaDLLName;
	}

	return NULL;
}


void DdkGetDriverName(char *pFile, char *np, wchar_t *wp)
{
	char *cp = strrchr(pFile, '\\');
	if (!cp) cp = pFile;

	strcpy(np, cp);
	cp = strrchr(np, '.');
	if (cp) *cp = 0;

	do *wp++ = *np; while (*np++);
}


void DdkGetDriverPath(char *pFile, char *pPath, char *pName)
{
	char *cp = strchr(pFile, '\\');

	if (cp) {
		strcpy(pPath, pFile);
		cp = strrchr(pPath, '\\');
		sprintf(cp+1, "%s.sys", pName);
		return;
	}

	HMODULE ddk = LoadLibrary("ddk.dll");

	if (ddk && GetModuleFileName(ddk, pPath, MAX_PATH+1)) {
		if ((cp = strrchr(pPath, '\\')) != NULL) *cp = 0;

		char *dp = strrchr(pPath, '\\');
		dp = (dp) ? dp + 1 : (cp && cp > pPath) ? pPath : 0;

		sprintf((cp ? cp : pPath), (cp ? "\\%s.sys" : "%s.sys"), pName);

		if (dp) {
			char up[MAX_PATH+1];
			FILETIME t, upt;

			strcpy(up, pPath);
			sprintf(&up[dp - pPath], "%s.sys", pName);

			if (!DdkGetWriteTime(pPath, &t)
			|| (DdkGetWriteTime(up, &upt) && CompareFileTime(&t, &upt) < 0))
				strcpy(pPath, up);
		}
	}

	if (ddk) FreeLibrary(ddk);
	if (GetFileAttributes(pPath) != INVALID_FILE_ATTRIBUTES) return;

	if (GetSystemDirectory(pPath, MAX_PATH+1)) {
		sprintf(&pPath[strlen(pPath)], "\\drivers\\%s.sys", pName);
		if (GetFileAttributes(pPath) != INVALID_FILE_ATTRIBUTES) return;
	}

	sprintf(pPath, "%s.sys", pName);
}


bool DdkGetWriteTime(char *pPath, FILETIME *pTime)
{
    HANDLE h = CreateFile(pPath, GENERIC_READ, FILE_SHARE_READ, NULL,
        OPEN_EXISTING, 0, NULL);

    if (h == INVALID_HANDLE_VALUE || !GetFileTime(h, NULL, NULL, pTime))
		return false;
        
    CloseHandle(h);
	return true;
}

```

`src/local.cpp`:

```cpp
/*****************************************************************************
 *                                                                           *
 *                        NOTICE                                             *
 *                                                                           *
 *           COPYRIGHT (c) 2022 DATACORE SOFTWARE CORPORATION                *
 *                                                                           *
 *                    ALL RIGHTS RESERVED                                    *
 *                                                                           *
 *                                                                           *
 *    This Computer Program is CONFIDENTIAL and a TRADE SECRET of            *
 *    DATACORE SOFTWARE CORPORATION. Any reproduction of this program        *
 *    without the express written consent of DATACORE SOFTWARE CORPORATION   *
 *    is a violation of the copyright laws and may subject you to criminal   *
 *    prosecution.                                                           *
 *                                                                           *
 *****************************************************************************/


/*
 * Local Resource Routines.
 */

#include "stdafx.h"


void DdkDeleteDirectory(char *pDir);

static HANDLE TempLock;
static char TempBase[MAX_PATH+1], TempDir[MAX_PATH+1];


void DdkLocalInit()
{
	if (!GetTempPath(sizeof(TempBase), TempBase)
			|| strlen(TempBase) > sizeof(TempBase) - 40)
		ddkfail("Unable to get temporary file path");

	strcat(TempBase, "ddk\\");
	sprintf(TempDir, "%s%x\\", TempBase, GetCurrentProcessId());

	// Cleanup temporary files, holding global mutex

	if (!(TempLock = CreateMutex(NULL, TRUE, "Global\\DDKTempDir")))
		ddkfail("Unable to create temporary file mutex");

	if (GetLastError() == ERROR_SUCCESS)
		DdkDeleteDirectory(TempBase);

	else WaitForSingleObject(TempLock, INFINITE);

	DdkDeleteDirectory(TempDir);

	// Create temporary directory

	CreateDirectory(TempBase, NULL);
	BOOL rc = CreateDirectory(TempDir, NULL);

	ReleaseMutex(TempLock);

	if (!rc)
		ddkfail("Unable to create temporary directory");
}


void DdkLocalDeinit()
{
	if (TempLock == NULL) return;

	WaitForSingleObject(TempLock, INFINITE);
	DdkDeleteDirectory(TempDir);
	RemoveDirectory(TempBase);
	ReleaseMutex(TempLock);
}


static void DdkDeleteDirectory(char *pDir)
{
	char path[MAX_PATH+1];
	WIN32_FIND_DATA find;

	size_t n = snprintf(path, sizeof(path), "%s\\*.*", pDir);
	if (n > sizeof(path) - 1) return;

	HANDLE h = FindFirstFile(path, &find);
	if (h == INVALID_HANDLE_VALUE) return;

	char *cp = strrchr(path, '\\') + 1;

	do {
		if (strcmp(find.cFileName, ".") && strcmp(find.cFileName, "..")) {
			size_t i = snprintf(cp, sizeof(path) - n, "%s", find.cFileName);
			if (i > sizeof(path) - n - 1) continue;

			if (find.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
				DdkDeleteDirectory(path);
				RemoveDirectory(path);
			}

			else DeleteFile(path);
		}
	} while (FindNextFile(h, &find));

	FindClose(h);
	RemoveDirectory(pDir);
}


DWORD DdkGetFileDisposition(ULONG Disposition, ULONG *pInfo)
{
	switch (Disposition) {
	case FILE_SUPERSEDE:
		*pInfo = FILE_SUPERSEDED;
		return CREATE_ALWAYS;

	case FILE_CREATE:
		*pInfo = FILE_CREATED;
		return CREATE_NEW;

	case FILE_OPEN:
		*pInfo = FILE_OPENED;
		return OPEN_EXISTING;

	case FILE_OPEN_IF:
		*pInfo = FILE_OPENED;
		return OPEN_ALWAYS;

	case FILE_OVERWRITE:
		*pInfo = FILE_OVERWRITTEN;
		return TRUNCATE_EXISTING;

	case FILE_OVERWRITE_IF:
		*pInfo = FILE_OVERWRITTEN;
		return CREATE_ALWAYS;
	}

	return (DWORD)-1;
}


DWORD DdkGetFileFlags(ULONG CreateOptions)
{
	DWORD flags = 0;

	if (CreateOptions & FILE_WRITE_THROUGH)
		flags |= FILE_FLAG_WRITE_THROUGH;

	if (CreateOptions & FILE_NO_INTERMEDIATE_BUFFERING)
		flags |= FILE_FLAG_NO_BUFFERING;

	if (CreateOptions & FILE_DELETE_ON_CLOSE)
		flags |= FILE_FLAG_DELETE_ON_CLOSE;

	if (CreateOptions & FILE_DIRECTORY_FILE)
		flags |= FILE_FLAG_BACKUP_SEMANTICS;

#if 0
	// TODO: Add asynchronous support
	if ((CreateOptions & FILE_SYNCHRONOUS_IO_ALERT) == 0 &&
			(CreateOptions & FILE_SYNCHRONOUS_IO_NONALERT) == 0)
		flags |= FILE_FLAG_OVERLAPPED;
#endif

	return flags;
}


BOOL DdkGetFileInfo(HANDLE h, ULONG FileInformationClass,
	PVOID buffer, ULONG Length, size_t InfoSize, DWORD *pBytesCopied)
{
	// The DDK file information definitions are not in scope, so use the documented
	// integer numbers. The DDK and user space structures have different names, but
	// are identical. As a sanity check assert that the sizes match.

	BOOL rc = 0;

	switch (FileInformationClass) {
	case 4:	// FileBasicInformation
	{
		DDKASSERT(sizeof(FILE_BASIC_INFO) == InfoSize);
		rc = GetFileInformationByHandleEx(h, FileBasicInfo, buffer, Length);
		break;
	}

	case 5:	// FileStandardInformation
	{
		DDKASSERT(sizeof(FILE_STANDARD_INFO) == InfoSize);
		rc = GetFileInformationByHandleEx(h, FileStandardInfo, buffer, Length);
		break;
	}

	default:
		SetLastError(ERROR_INVALID_PARAMETER);
		return 0;
	}

	if (rc) *pBytesCopied = InfoSize;
	return rc;
}


bool DdkIsFilePath(PUNICODE_STRING path)
{
	WCHAR *wp = path->Buffer;
	WCHAR *ep = wp + path->Length / sizeof(WCHAR);

	while (wp < ep && *wp == L'\\') wp++;
	if (wp + 2 < ep && wcsncmp(wp, L"??\\", 3) == 0) wp += 3;

	return (wp + 1 < ep && wp[1] == L':');
}


void
DdkGetLocalPath(WCHAR *buffer, int len, UNICODE_STRING *path, bool create)
{
	// Remove drive letter and path separator

	WCHAR *wp = path->Buffer;
	WCHAR *ep = wp + path->Length / sizeof(WCHAR);

	while (wp < ep && *wp == L'\\') wp++;
	if (wp + 2 < ep && wcsncmp(wp, L"??\\", 3) == 0) wp += 3;
	if (wp + 1 < ep && wp[1] == L':') wp += 2;
	while (wp < ep && (*wp == L'\\' || *wp == L'/')) wp++;

	// Construct path to local file

	int n = _snwprintf(buffer, len, L"%S%.*s", TempDir, (int)(ep - wp), wp);

	if (n > len - 1) n = len - 1;

	// Create intermediate directories

	for (int i = strlen(TempDir); create && i < n &&
			(i += wcscspn(&buffer[i], L"\\/")) < n; i++) {
		buffer[i] = L'\0';
		CreateDirectoryW(buffer, NULL);
		buffer[i] = L'\\';
	}
}


void
DdkGetLocalPath(char *buffer, size_t len, char *path, char *file, char *suffix)
{
	// Remove drive letter and path separator

	while (*path == '\\') path++;
	if (strncmp(path, "??\\", 3) == 0) path += 3;
	if (*path && path[1] == ':') path += 2;

	while (*path == '\\' || *path == '/') path++;

	size_t n = snprintf(buffer, len, "%s%s%s%s%s", TempDir, path,
		(*file) ? "\\" : "", file, suffix);

	if (n > len - 1) n = len - 1;

	// Create intermediate directories

	for (size_t i = strlen(TempDir); i < n &&
			(i += strcspn(&buffer[i], "\\/")) < n; i++) {
		buffer[i] = 0;
		CreateDirectory(buffer, NULL);
		buffer[i] = '\\';
	}
}

```

`src/log.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Event Log Routines
 */

#include "stdddk.h"


DDKAPI
PVOID IoAllocateErrorLogEntry(PVOID IoObject, UCHAR EntrySize)
{
	// TODO
	return 0;
}


DDKAPI
VOID IoWriteErrorLogEntry(PVOID ElEntry)
{
	// TODO
}

```

`src/mdl.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * MDL Routines.
 */

#include "stdddk.h"


DDKAPI
PMDL IoAllocateMdl(PVOID VirtualAddress, ULONG Length,
	BOOLEAN SecondaryBuffer, BOOLEAN ChargeQuota, PIRP Irp)
{
	MDL *pMdl = (MDL *)ExAllocatePool(NonPagedPool, MmSizeOfMdl(VirtualAddress, Length));
	MDL **ppMdl;

	DDKASSERT(ChargeQuota == FALSE);
	DDKASSERT(Irp || !SecondaryBuffer);

	if (!pMdl) return 0;

	memset(pMdl, 0, MmSizeOfMdl(VirtualAddress, Length));
	MmInitializeMdl(pMdl, VirtualAddress, Length);

	if (!Irp) return pMdl;

	for (ppMdl = &Irp->MdlAddress; SecondaryBuffer && *ppMdl; )
		ppMdl = &(*ppMdl)->Next;

	*ppMdl = pMdl;
	return pMdl;
}


DDKAPI
VOID IoBuildPartialMdl(PMDL SourceMdl,
	PMDL TargetMdl, PVOID VirtualAddress, ULONG Length)
{
	ULONG_PTR SourceAddress = (ULONG_PTR)MmGetMdlVirtualAddress(SourceMdl);
	ULONG_PTR Address = (ULONG_PTR)VirtualAddress;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	DDKASSERT(SourceMdl->MdlFlags & (MDL_PAGES_LOCKED \
		| MDL_MAPPED_TO_SYSTEM_VA | MDL_SOURCE_IS_NONPAGED_POOL));

	DDKASSERT(Address >= SourceAddress);
	DDKASSERT(Address < SourceAddress + MmGetMdlByteCount(SourceMdl));

	if (!Length)
		Length = MmGetMdlByteCount(SourceMdl) - (ULONG)(Address - SourceAddress);

	DDKASSERT(Length != 0);
	DDKASSERT(Address + Length <= SourceAddress + MmGetMdlByteCount(SourceMdl));
	DDKASSERT(TargetMdl->Size >= MmSizeOfMdl(VirtualAddress, Length));

	MmInitializeMdl(TargetMdl, VirtualAddress, Length);

	ULONG pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(VirtualAddress, Length);

	for (ULONG i = 0; i < pages; i++)
		MmGetMdlPfnArray(TargetMdl)[i] = (PFN_NUMBER)
			((ULONG_PTR)MmGetMdlVirtualAddress(TargetMdl) >> PAGE_SHIFT) + i;

	TargetMdl->MdlFlags |= MDL_PARTIAL;
}


DDKAPI
VOID IoFreeMdl(PMDL Mdl)
{
	ExFreePool(Mdl);
}


DDKAPI
SIZE_T MmSizeOfMdl(PVOID Base, SIZE_T Length)
{
	return sizeof(MDL) + ADDRESS_AND_SIZE_TO_SPAN_PAGES(Base, Length) * sizeof(PFN_NUMBER);
}

```

`src/memory.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Memory Manager Routines.
 */

#include "stdddk.h"


#undef MmMapLockedPagesSpecifyCache


DDKAPI
VOID MmProbeAndLockPages(PMDLX Mdl,
	KPROCESSOR_MODE AccessMode, LOCK_OPERATION Operation)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	ULONG pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
		MmGetMdlVirtualAddress(Mdl), MmGetMdlByteCount(Mdl));

	for (ULONG i = 0; i < pages; i++)
		MmGetMdlPfnArray(Mdl)[i] = (PFN_NUMBER)
			((ULONG_PTR)MmGetMdlVirtualAddress(Mdl) >> PAGE_SHIFT) + i;

	Mdl->MdlFlags |= MDL_PAGES_LOCKED;
}


DDKAPI
PVOID MmMapLockedPagesSpecifyCache(PMDL Mdl,
    KPROCESSOR_MODE AccessMode, MEMORY_CACHING_TYPE CacheType,
	PVOID RequestedAddress, ULONG BugCheckOnFailure, ULONG Priority)
{
	// TODO - map virtual memory into MDL

	return (PVOID)((PCHAR)(Mdl->StartVa) + Mdl->ByteOffset);
}


DDKAPI
PVOID MmMapLockedPages(PMDL Mdl, KPROCESSOR_MODE AccessMode)
{
	// TODO - map virtual memory into MDL

	return (PVOID) ((PCHAR) (Mdl->StartVa) + Mdl->ByteOffset);
}


DDKAPI
NTSTATUS MmProtectMdlSystemAddress(PMDL MemoryDescriptorList, ULONG NewProtect)
{
	return STATUS_SUCCESS;
}


DDKAPI
VOID MmUnmapLockedPages(PVOID BaseAddress, PMDL Mdl)
{
}


DDKAPI
VOID MmUnlockPages(PMDLX Mdl)
{
	Mdl->MdlFlags &= ~MDL_PAGES_LOCKED;
}


DDKAPI
PHYSICAL_ADDRESS MmGetPhysicalAddress(PVOID BaseAddress)
{
	PHYSICAL_ADDRESS x;
	x.QuadPart = (ULONG_PTR)BaseAddress;
	return x;
}


DDKAPI
PVOID MmGetSystemRoutineAddress(PUNICODE_STRING SystemRoutineName)
{
	UNICODE_STRING getver = RTL_CONSTANT_STRING(L"RtlGetVersion");

	if (RtlCompareUnicodeString(SystemRoutineName, &getver, FALSE) == 0)
		return &RtlGetVersion;

	// TODO - other routines
	return 0;
}

```

`src/mutex.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Mutex Routines
 */

#include "stdafx.h"


typedef struct _MUTEX : public OBJECT {
	DWORD			threadid;
	volatile LONG	count;
} MUTEX, *PMUTEX;


DDKAPI
VOID KeInitializeMutex(PRKMUTEX Mutex, ULONG Level)
{
	MUTEX *pMutex = (MUTEX *)Mutex;

	DdkInitializeObject(pMutex, sizeof(MUTEX), _SizeofMutex_);

	pMutex->h = CreateMutex(NULL, FALSE, NULL);
	pMutex->type = MutexType;

	if (!pMutex->h) ddkfail("Unable to initialize Mutex");
}


DDKAPI
LONG KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait)
{
	MUTEX *pMutex = (MUTEX *)Mutex;
	LONG rc = 1;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	if (pMutex->threadid == GetCurrentThreadId())
		if (!--pMutex->count) {
			pMutex->threadid = 0;
			rc = 0;
		}

	if (!ReleaseMutex(pMutex->h)) return 1;
	return rc;
}


DDKAPI
LONG KeReadStateMutex(PRKMUTEX Mutex)
{
	MUTEX *pMutex = (MUTEX *)Mutex;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return (pMutex->count == 0);
}


void DdkUpdateMutex(OBJECT *pObj)
{
	MUTEX *pMutex = (MUTEX *)pObj;
	DWORD id = GetCurrentThreadId();

	if (pMutex->threadid != id) {
		pMutex->threadid = id;
		pMutex->count = 1;
	}

	else pMutex->count++;
}


```

`src/name.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Name Handling Routines
 */

#include "stdafx.h"


typedef struct _NAME {
	struct _NAME	*Next;
	POBJECT			Object;
	UNICODE_STRING	Name;
	WCHAR			Buffer[1];
} NAME, *PNAME;


NAME *DdkNameList;
static CRITICAL_SECTION Lock;


void DdkNameInit()
{
	if (!InitializeCriticalSectionAndSpinCount(&Lock, 4000))
		ddkfail("DdkNameInit failed to initialize spinlock");
}


void DdkCreatePath(PUNICODE_STRING Out, PUNICODE_STRING Name, PWCH Dir, PWCH Prefix)
{
	size_t d = (Dir && *Dir && Name->Buffer[0] != '\\') ? wcslen(Dir) + 1 : 0;
	size_t p = (Prefix && *Prefix && Name->Buffer[0] != '\\') ? wcslen(Prefix) : 0;
	PWCH s = DdkAllocUnicodeBuffer(Name->Length + (d + p + 1) * sizeof(WCHAR));
	s[0] = 0;

	if (d) {
		wcscpy(s, Dir);
		if (Dir[wcslen(Dir)-1] != '\\') wcscat(s, L"\\");
	}

	if (p) wcscat(s, Prefix);

	wcsncat(s, Name->Buffer, Name->Length / sizeof(WCHAR));
	RtlInitUnicodeString(Out, s);
}


static POBJECT DdkFindName(PUNICODE_STRING Path, PWCH *pPath = 0)
{
	for (PNAME pEntry = DdkNameList; pEntry; pEntry = pEntry->Next)
		if (RtlCompareUnicodeString(Path, &pEntry->Name, TRUE) == 0)
			if (pEntry->Object->refcount) {
				if (pPath) *pPath = pEntry->Buffer;
				return pEntry->Object;
			}

	return 0;
}


POBJECT DdkCreateName(PUNICODE_STRING Name, POBJECT pObj, PWCH Dir, PWCH *pPath)
{
	DDKASSERT(Name && pObj);
	DDKASSERT(Name->Length >= sizeof(WCHAR));

	UNICODE_STRING u;
	DdkCreatePath(&u, Name, Dir);

	NAME *pEntry = (NAME *)calloc(1, sizeof(NAME) + u.Length);
	if (!pEntry) ddkfail("Unable to create name");

	wcsncpy(pEntry->Buffer, u.Buffer, u.Length / sizeof(WCHAR));
	RtlInitUnicodeString(&pEntry->Name, pEntry->Buffer);
	RtlFreeUnicodeString(&u);

	EnterCriticalSection(&Lock);
	POBJECT pLookup = DdkFindName(&pEntry->Name, pPath);

	if (pLookup) {
		DdkReferenceObject(pLookup);
		DdkDereferenceObject(pObj);
		LeaveCriticalSection(&Lock);
		free(pEntry);
		return pLookup;
	}

	pEntry->Object = pObj;
	pEntry->Next = DdkNameList;
	DdkNameList = pEntry;
	DdkReferenceObject(pObj);
	if (pPath) *pPath = pEntry->Buffer;
	LeaveCriticalSection(&Lock);
	return pObj;
}


BOOLEAN DdkInsertName(PUNICODE_STRING Name, POBJECT pObj, PWCH Dir, PWCH *pPath)
{
	POBJECT pResult = DdkCreateName(Name, pObj, Dir, pPath);

	if (pResult != pObj) {
		DdkDereferenceObject(pResult);
		return FALSE;
	}

	return TRUE;
}


VOID DdkRemoveName(PUNICODE_STRING Name)
{
	EnterCriticalSection(&Lock);
	PNAME *ppEntry = &DdkNameList, *ppNext;

	for (PNAME pEntry; (pEntry = *ppEntry) != 0; ppEntry = ppNext) {
		ppNext = &(*ppEntry)->Next;

		if (RtlCompareUnicodeString(Name, &pEntry->Name, TRUE) == 0) {
			*ppEntry = pEntry->Next;
			ppNext = ppEntry;
			DdkDereferenceObject(pEntry->Object);
			free(pEntry);
		}
	}

	LeaveCriticalSection(&Lock);
}


VOID DdkRemoveObjectName(POBJECT Object)
{
	EnterCriticalSection(&Lock);
	PNAME *ppEntry = &DdkNameList, *ppNext;

	for (PNAME pEntry; (pEntry = *ppEntry) != 0; ppEntry = ppNext) {
		ppNext = &(*ppEntry)->Next;

		if (pEntry->Object == Object) {
			*ppEntry = pEntry->Next;
			ppNext = ppEntry;
			DdkDereferenceObject(pEntry->Object);
			free(pEntry);
		}
	}

	LeaveCriticalSection(&Lock);
}


POBJECT DdkLookupName(PUNICODE_STRING Name, PWCH Dir)
{
	UNICODE_STRING u;
	DdkCreatePath(&u, Name, Dir);
	EnterCriticalSection(&Lock);

	OBJECT *pObj = DdkFindName(&u);
	if (pObj) DdkReferenceObject(pObj);

	LeaveCriticalSection(&Lock);
	RtlFreeUnicodeString(&u);
	return pObj;
}


POBJECT DdkLookupName(PWCH Name, PWCH Dir)
{
	UNICODE_STRING u;
	RtlInitUnicodeString(&u, Name);
	return DdkLookupName(&u, Dir);
}


POBJECT DdkLookupName(char *Name, PWCH Dir)
{
	WCHAR wname[256];
	swprintf(wname, sizeof(wname), L"%S", Name);
	return DdkLookupName(wname, Dir);
}


```

`src/object.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Object Routines
 */

#include "stdafx.h"
#include <time.h>


void DdkFreeObject(OBJECT *pObj);


static VOID DdkObjectCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)
{
	OBJECT *pObj = (POBJECT)Context;

	DdkFreeObject(pObj);
	CloseThreadpoolWork(Work);
}


OBJECT *DdkAllocObject(size_t size, USHORT type, bool opt)
{
	if (type != ThreadType) DdkThreadInit();

	OBJECT *pObj = (OBJECT *)calloc(1, size);

	if (!pObj) {
		if (!opt) ddkfail("Unable to allocate object");
		return 0;
	}

	pObj->refcount = 1;
	pObj->type = type;
	pObj->alloc = 1;
	return pObj;
}


void DdkFreeObject(OBJECT *pObj)
{
	switch (pObj->type) {
	case IoFileType:
		DdkFreeFileObject(pObj);
		break;

	case IoDriverType:
		DdkFreeDriverObject(pObj);
		break;

	case IoDeviceType:
		DdkFreeDeviceObject(pObj);
		break;

	case KeyType:
		DdkFreeKeyObject(pObj);
		break;
	}

	if (pObj->h) {
		DDKASSERT(pObj->h != GetCurrentProcess());
		CloseHandle(pObj->h);
		pObj->h = NULL;
	}

	DdkRemoveObjectName(pObj);
	if (pObj->alloc) free(pObj);
}


void DdkInitializeObject(OBJECT *pObj, size_t size, size_t maxsize)
{
	DdkThreadInit();

	if (size > maxsize)
		ddkfail("Object is too small to initialize");

	memset(pObj, 0, maxsize);
	pObj->refcount = 1;
}


void DdkReferenceObject(OBJECT *pObj)
{
	InterlockedIncrement(&pObj->refcount);
}


DDKAPI
LONG_PTR ObfReferenceObjectWithTag(PVOID Object, ULONG Tag)
{
	OBJECT *pObj = FromPointer(Object);

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	InterlockedIncrement(&pObj->refcount);
	return (LONG_PTR)0;
}


DDKAPI
LONG_PTR ObfReferenceObject(PVOID Object)
{
	return ObfReferenceObjectWithTag(Object, 'tlfD');
}


#undef ObReferenceObject

DDKAPI
LONG_PTR ObReferenceObject(PVOID Object)
{
	return ObfReferenceObjectWithTag(Object, 'tlfD');
}


#undef ObReferenceObjectWithTag

DDKAPI
LONG_PTR ObReferenceObjectWithTag(PVOID Object, ULONG Tag)
{
	return ObfReferenceObjectWithTag(Object, Tag);
}


DDKAPI
NTSTATUS ObReferenceObjectByPointerWithTag(PVOID Object, ACCESS_MASK DesiredAccess,
	POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, ULONG Tag)
{
	OBJECT *pObj = FromPointer(Object);

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	if (ObjectType && ObjectType->type != pObj->type)
		return STATUS_OBJECT_TYPE_MISMATCH;

	InterlockedIncrement(&pObj->refcount);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS ObReferenceObjectByPointer(PVOID Object,
	ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode)
{
	return ObReferenceObjectByPointerWithTag(Object,
		DesiredAccess, ObjectType, AccessMode, 'tlfD');
}


DDKAPI
NTSTATUS ObReferenceObjectByHandleWithTag(HANDLE Handle,
    ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode,
    ULONG Tag, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation)
{
	OBJECT *pObj = FromHandle(Handle);

	if (!pObj) return STATUS_INVALID_HANDLE;

	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	DDKASSERT(HandleInformation == NULL);

	NTSTATUS rc = ObReferenceObjectByPointerWithTag(
		ToPointer(pObj), DesiredAccess, ObjectType, AccessMode, Tag);

	if (rc != STATUS_SUCCESS) return rc;

	*Object = ToPointer(pObj);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS ObReferenceObjectByHandle(HANDLE Handle,
    ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode,
    PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation)
{
	return ObReferenceObjectByHandleWithTag(Handle,
		DesiredAccess, ObjectType, AccessMode, 'tlfD', Object, HandleInformation);
}


void DdkDereferenceObject(OBJECT *pObj)
{
	if (!InterlockedDecrement(&pObj->refcount))
		DdkFreeObject(pObj);
}


DDKAPI
LONG_PTR ObfDereferenceObjectWithTag(PVOID Object, ULONG Tag)
{
	OBJECT *pObj = FromPointer(Object);

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	if (InterlockedDecrement(&pObj->refcount))
		return (ULONG_PTR)0;

	DdkFreeObject(pObj);
	return (ULONG_PTR)0;
}


DDKAPI
LONG_PTR ObfDereferenceObject(PVOID Object)
{
	return ObfDereferenceObjectWithTag(Object, 'tlfD');
}


#undef ObDereferenceObject

DDKAPI
LONG_PTR ObDereferenceObject(PVOID Object)
{
	return ObfDereferenceObjectWithTag(Object, 'tlfD');
}


#undef ObDereferenceObjectWithTag

DDKAPI
LONG_PTR ObDereferenceObjectWithTag(PVOID Object, ULONG Tag)
{
	return ObfDereferenceObjectWithTag(Object, Tag);
}


DDKAPI
VOID ObDereferenceObjectDeferDeleteWithTag(PVOID Object, ULONG Tag)
{
	OBJECT *pObj = FromPointer(Object);

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	if (InterlockedDecrement(&pObj->refcount)) return;

	PTP_WORK Work = CreateThreadpoolWork(DdkObjectCallback, (PVOID)pObj, NULL);

	if (!Work)
		ddkfail("Unable to defer object deletion");

	SubmitThreadpoolWork(Work);
}


DDKAPI
VOID ObDereferenceObjectDeferDelete(PVOID Object)
{
	ObDereferenceObjectDeferDeleteWithTag(Object, 'tlfD');
}


DDKAPI
NTSTATUS ZwClose(HANDLE Handle)
{
	OBJECT *pObj = FromHandle(Handle);

	if (!pObj) return STATUS_INVALID_HANDLE;

	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ObfDereferenceObject(pObj);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS ObCloseHandle(HANDLE Handle, KPROCESSOR_MODE PreviousMode)
{
	return ZwClose(Handle);
}


BOOLEAN DdkWaitLastReference(POBJECT pObj, int maxsecs, int count)
{
	time_t start = time(NULL);

	while (pObj->refcount > count) {
		if (time(NULL) - start >= maxsecs)
			return FALSE;

		SleepEx(1, FALSE);
	}

	return TRUE;
}

```

`src/object.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Object Definition
 */

#ifndef _OBJECT_H_
#define _OBJECT_H_

typedef struct _OBJECT {
	USHORT			type;
	USHORT			alloc:1;
	USHORT			temporary:1;
	volatile LONG	refcount;
	HANDLE			h;
} OBJECT, *POBJECT;

enum _OBJECTTYPE {
	MinObjectType = 0x2dc0, EventType, MutexType, SemaphoreType, ThreadType,
	TimerType, ProcessType, SecurityTokenType, EnlistmentType,
	ResourceManagerType, TransactionManagerType, TransactionType, CmKeyType,
	IoFileType, IoDeviceType, IoDriverType, IoSymbolicLinkType, KeyType,
	MaxObjectType
};

typedef struct _OBJECT_TYPE {
	USHORT	type;
} OBJECT_TYPE, *POBJECT_TYPE;


/*
 *	Object Validation
 */

inline bool isPublicObject(OBJECT *pObj) {
	return (pObj && (pObj->type == IoFileType
		|| pObj->type == IoDeviceType || pObj->type == IoDriverType));
}

inline bool isDispatchObject(OBJECT *pObj) {
	return (pObj && (pObj->type == EventType || pObj->type == MutexType
		|| pObj->type == SemaphoreType || pObj->type == ThreadType || pObj->type == TimerType));
}

inline bool isValidObject(OBJECT *pObj) {
	return (pObj && pObj->type > MinObjectType && pObj->type < MaxObjectType);
}

inline bool isHandleObject(OBJECT *pObj) {
	return (isValidObject(pObj) && pObj->refcount > 0
		&& (pObj->type == EventType || pObj->type == SemaphoreType || pObj->type == ThreadType
		|| pObj->type == ProcessType || pObj->type == IoFileType || pObj->type == SecurityTokenType
		|| pObj->type == EnlistmentType || pObj->type == ResourceManagerType
		|| pObj->type == TransactionManagerType || pObj->type == TransactionType
		|| pObj->type == KeyType));
}


/*
 *	Convert to/from DDK handles and pointers
 */

inline HANDLE ToHandle(OBJECT *pObj) {
	return (HANDLE)(((ULONG_PTR)pObj) | 1);
}

inline OBJECT *FromHandle(HANDLE Handle) {
	OBJECT *pObj = (OBJECT *)(((ULONG_PTR)Handle) & ~1);
	return (isHandleObject(pObj) ? pObj : 0);
}

inline PVOID ToPointer(OBJECT *pObj) {
	return (PVOID)(&pObj[isPublicObject(pObj)?1:0]);
}

inline OBJECT *FromPointer(PVOID Object) {
	OBJECT *pObj = (OBJECT *)Object;
	if (pObj && !isValidObject(pObj)) pObj--;
	if (!pObj || !isValidObject(pObj) || pObj->refcount <= 0
			|| (pObj != (OBJECT *)Object && !isPublicObject(pObj)))
		ddkfail("Invalid object pointer");
	return pObj;
}

#endif /* __cplusplus */


OBJECT *DdkAllocObject(size_t size, USHORT type, bool opt = false);
void DdkInitializeObject(OBJECT *pObj, size_t size, size_t maxsize);
void DdkReferenceObject(OBJECT *pObj);
void DdkDereferenceObject(OBJECT *pObj);

```

`src/pnp.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Plug and Play Routines.
 */

#include "stdddk.h"


DRIVER_INITIALIZE DdkPnpDriverEntry;
DRIVER_UNLOAD DdkPnpDriverUnload;
DRIVER_DISPATCH DdkPnpDispatch;

NTSTATUS DdkPnpIssueRequest(PDEVICE_OBJECT DeviceObject, UCHAR Request, PIRP Irp = NULL);
NTSTATUS DdkPnpRemoveDevice(PDEVICE_OBJECT DeviceObject, bool force);
NTSTATUS DdkPnpStartDevice(PDEVICE_OBJECT DeviceObject);


static PDRIVER_OBJECT DdkPnpManager;


void DdkPnpInit()
{
	if (!NT_SUCCESS(DdkInitDriver("PnpManager", DdkPnpDriverEntry)))
		ddkfail("Unable to create PnP Manager");
}


NTSTATUS DdkPnpCreateDevice(PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT DeviceObject;

	if (!DriverObject->DriverExtension->AddDevice)
		return STATUS_SUCCESS;

	NTSTATUS status = IoCreateDevice(DdkPnpManager, 0, NULL, FILE_DEVICE_CONTROLLER,
		FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &DeviceObject);

	if (!NT_SUCCESS(status))
		return status;

	status = DriverObject->DriverExtension->AddDevice(DriverObject, DeviceObject);

	if (!NT_SUCCESS(status)) {
		IoDeleteDevice(DeviceObject);
		return status;
	}

	return DdkPnpStartDevice(IoGetAttachedDevice(DeviceObject));
}


void DdkPnpUnload(PDRIVER_OBJECT DriverObject)
{
	PDEVICE_OBJECT DeviceObject = DriverObject->DeviceObject;

	while (DeviceObject) {
		PDEVICE_OBJECT pDevice = IoGetDeviceAttachmentBaseRef(DeviceObject);

		if (pDevice->DriverObject == DdkPnpManager) {
			DdkPnpRemoveDevice(DeviceObject, true);
			DeviceObject = DriverObject->DeviceObject;
		}

		else DeviceObject = DeviceObject->NextDevice;
		ObDereferenceObject(pDevice);
	}
}


NTSTATUS DdkPnpStartDevice(PDEVICE_OBJECT DeviceObject)
{
	CM_RESOURCE_LIST list;
	PIRP Irp;

	if ((Irp = IoAllocateIrp(DeviceObject->StackSize, FALSE)) == NULL)
 		return STATUS_INSUFFICIENT_RESOURCES;

	list.Count = 1;
	list.List[0].InterfaceType = InterfaceTypeUndefined;
	list.List[0].BusNumber = 0;
	list.List[0].PartialResourceList.Version = 1;
	list.List[0].PartialResourceList.Revision = 1;
	list.List[0].PartialResourceList.Count = 0;

	PIO_STACK_LOCATION pStack = IoGetNextIrpStackLocation(Irp);
	pStack->Parameters.StartDevice.AllocatedResources = &list;

	NTSTATUS status = DdkPnpIssueRequest(DeviceObject, IRP_MN_START_DEVICE, Irp);

	if (!NT_SUCCESS(status))
		DdkPnpIssueRequest(DeviceObject, IRP_MN_REMOVE_DEVICE);

	return status;
}


NTSTATUS DdkPnpRemoveDevice(PDEVICE_OBJECT DeviceObject, bool force)
{
	NTSTATUS status = DdkPnpIssueRequest(DeviceObject, IRP_MN_QUERY_REMOVE_DEVICE);

	if (!NT_SUCCESS(status) && !force) {
		DdkPnpIssueRequest(DeviceObject, IRP_MN_CANCEL_REMOVE_DEVICE);
		return status;
	}

	if (!NT_SUCCESS(status))
		DdkPnpIssueRequest(DeviceObject, IRP_MN_SURPRISE_REMOVAL);
	
	return DdkPnpIssueRequest(DeviceObject, IRP_MN_REMOVE_DEVICE);
}


NTSTATUS DdkPnpIssueRequest(PDEVICE_OBJECT DeviceObject, UCHAR Request, PIRP Irp)
{
	PDEVICE_OBJECT pDevice = IoGetAttachedDevice(DeviceObject);

	return DdkSynchronousIrp(pDevice, IRP_MJ_PNP, Request, Irp);
}


static NTSTATUS DdkPnpDriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
{
	for (ULONG i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
		DriverObject->MajorFunction[i] = DdkPnpDispatch;

	DriverObject->DriverUnload = DdkPnpDriverUnload;
	DdkPnpManager = DriverObject;
	return STATUS_SUCCESS;
}


static void DdkPnpDriverUnload(PDRIVER_OBJECT DriverObject)
{
	DdkPnpManager = NULL;
}


static NTSTATUS DdkPnpDispatch(DEVICE_OBJECT *pDevice, IRP *pIrp)
{
	PIO_STACK_LOCATION pStack = IoGetCurrentIrpStackLocation(pIrp);
	NTSTATUS status = STATUS_SUCCESS;

	if (pStack->MajorFunction == IRP_MJ_PNP) {
		if (pStack->MinorFunction == IRP_MN_REMOVE_DEVICE)
		    IoDeleteDevice(pDevice);
	}

	pIrp->IoStatus.Status = status;
	pIrp->IoStatus.Information = 0;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return status;
}

```

`src/registry.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Registry Routines.
 */

#include "stdddk.h"
#include <winreg.h>


typedef struct KEY : public OBJECT {
	HKEY			Key;
} KEY, *PKEY;


NTSTATUS DdkQueryEnumerateValues(HKEY key,
	RTL_QUERY_REGISTRY_TABLE *qp, PVOID Context, PVOID Environment);

NTSTATUS DdkQueryValue(HKEY key, RTL_QUERY_REGISTRY_TABLE *qp,
	PVOID Context, PVOID Environment);

NTSTATUS DdkQueryCallback(RTL_QUERY_REGISTRY_TABLE *qp,
	DWORD type, PVOID data, DWORD bytes, PVOID Context, PVOID Environment);

NTSTATUS DdkQueryDirect(RTL_QUERY_REGISTRY_TABLE *qp, DWORD type,
	PVOID data, DWORD bytes, PVOID Context, PVOID Environment);

void DdkGetDefaultValue(RTL_QUERY_REGISTRY_TABLE *qp, DWORD *pType,
	PVOID *pData, DWORD *pBytes);

NTSTATUS DdkGetRegistryObject(PKEY *ppKey,
	POBJECT_ATTRIBUTES ObjectAttributes, ULONG *pDisposition);

void DdkExpandString(PVOID *pString, ULONG *pBytes, PVOID Environment);
void DdkCreateRegistryKey(ULONG RelativeTo, PWSTR Path);
WCHAR *DdkGetRelativePath(ULONG RelativeTo);
bool DdkCheckKeyExists(ULONG RelativeTo, PCWSTR Path, bool parent);
NTSTATUS DdkGetRegistryKey(HKEY *pHkey, ULONG RelativeTo, PCWSTR Path, bool create);
NTSTATUS DdkGetRegistryStatus(LSTATUS rc);


static HKEY hive = NULL;


void DdkRegistryInit()
{
	char path[MAX_PATH+1];

	DdkGetLocalPath(path, sizeof(path), "C:\\Windows\\System32\\Config", "hive.dat");

	if (RegLoadAppKeyA(path, &hive, KEY_ALL_ACCESS,
			REG_PROCESS_APPKEY, NULL) != ERROR_SUCCESS)
		ddkfail("Unable to create registry hive");

	DdkCreateRegistryKey(RTL_REGISTRY_CONTROL, L"");
	DdkCreateRegistryKey(RTL_REGISTRY_DEVICEMAP, L"");

	DdkCreateRegistryKey(RTL_REGISTRY_SERVICES, L"");
	DdkCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Disk");
	DdkCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Tcpip\\Parameters");

	RtlWriteRegistryValue(RTL_REGISTRY_SERVICES,
		L"Tcpip\\Parameters", L"Hostname", REG_SZ, L"UnitTest", sizeof(WCHAR) * 9);

	DdkCreateRegistryKey(RTL_REGISTRY_WINDOWS_NT, L"");
	DdkCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\User\\.Default");
	DdkCreateRegistryKey(RTL_REGISTRY_ABSOLUTE, L"\\Registry\\User\\CurrentUser");
	DdkCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
		L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName");

	RtlWriteRegistryValue(RTL_REGISTRY_ABSOLUTE,
		L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\ComputerName",
		L"ComputerName", REG_SZ, L"UnitTest", sizeof(WCHAR) * 9);

	RtlWriteRegistryValue(RTL_REGISTRY_WINDOWS_NT, L"",
		L"SystemRoot", REG_SZ, L"C:\\Windows", sizeof(WCHAR) * 11);

	DWORD major = 10, minor = 0;

	RtlWriteRegistryValue(RTL_REGISTRY_WINDOWS_NT, L"",
		L"CurrentMajorVersionNumber", REG_DWORD, &major, sizeof(major));

	RtlWriteRegistryValue(RTL_REGISTRY_WINDOWS_NT, L"",
		L"CurrentMinorVersionNumber", REG_DWORD, &minor, sizeof(minor));
}


void DdkRegistryDeinit()
{
	if (hive != NULL)
		RegCloseKey(hive);
}


DDKAPI
void DdkCreateRegistryKey(ULONG RelativeTo, PWSTR Path)
{
	HKEY key = NULL;
	DdkGetRegistryKey(&key, RelativeTo, Path, true);

	if (key && key != hive)
		RegCloseKey(key);
}


DDKAPI
void DdkDeleteRegistryKey(ULONG RelativeTo, PWSTR Path)
{
	HKEY key = NULL;
	DdkGetRegistryKey(&key, RelativeTo, Path, false);

	if (key) RegDeleteKeyW(key, L"");

	if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0)
		if (key && key != hive) RegCloseKey(key);
}


DDKAPI
NTSTATUS ZwOpenKey(PHANDLE KeyHandle,
	ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes)
{
	return ZwOpenKeyEx(KeyHandle, DesiredAccess, ObjectAttributes, 0);
}


DDKAPI
NTSTATUS ZwOpenKeyEx(PHANDLE KeyHandle,
	ACCESS_MASK DesiredAccess, POBJECT_ATTRIBUTES ObjectAttributes, ULONG OpenOptions)
{
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(OpenOptions);

	if (!KeyHandle)
		return STATUS_INVALID_PARAMETER;

	PKEY pKey = NULL;
	NTSTATUS status = DdkGetRegistryObject(&pKey, ObjectAttributes, NULL);

	if (NT_SUCCESS(status))
		*KeyHandle = ToHandle(pKey);

	return status;
}


DDKAPI
NTSTATUS ZwCreateKey(PHANDLE KeyHandle, ACCESS_MASK DesiredAccess,
    POBJECT_ATTRIBUTES ObjectAttributes, ULONG TitleIndex, PUNICODE_STRING Class,
    ULONG CreateOptions, PULONG Disposition)
{
	UNREFERENCED_PARAMETER(DesiredAccess);
	UNREFERENCED_PARAMETER(TitleIndex);
	UNREFERENCED_PARAMETER(Class);
	UNREFERENCED_PARAMETER(CreateOptions);

	if (!KeyHandle)
		return STATUS_INVALID_PARAMETER;

	PKEY pKey = NULL;
	ULONG disposition = 0;

	NTSTATUS status = DdkGetRegistryObject(&pKey, ObjectAttributes, &disposition);

	if (NT_SUCCESS(status)) {
		*KeyHandle = ToHandle(pKey);

		if (Disposition)
			*Disposition = disposition;
	}

	return status;
}


DDKAPI
NTSTATUS ZwQueryValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName,
	KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation,
    ULONG Length, PULONG ResultLength)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	WCHAR *name = DdkUnicodeToString(ValueName, L'\\');
	ULONG namelen = wcslen(name);
	DWORD type, datalen;

	LSTATUS rc = RegQueryValueExW(pKey->Key, name, NULL, &type, NULL, &datalen);

	if (rc != ERROR_SUCCESS)
		return DdkGetRegistryStatus(rc);

	switch (KeyValueInformationClass) {
	case KeyValueBasicInformation:
	{
		KEY_VALUE_BASIC_INFORMATION *pInfo = (KEY_VALUE_BASIC_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;
		pInfo->NameLength = namelen * sizeof(WCHAR);
		memcpy(pInfo->Name, name, pInfo->NameLength);
		break;
	}

	case KeyValueFullInformation:
	{
		KEY_VALUE_FULL_INFORMATION *pInfo = (KEY_VALUE_FULL_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo) + datalen;

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;
		pInfo->NameLength = namelen * sizeof(WCHAR);
		pInfo->DataOffset = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);
		memcpy(pInfo->Name, name, pInfo->NameLength);

		rc = RegQueryValueExW(pKey->Key, name, NULL, NULL,
			(PBYTE)&pInfo->Name + pInfo->NameLength, &datalen);
			
		pInfo->DataLength = datalen;
		break;
	}

	case KeyValuePartialInformation:
	{
		KEY_VALUE_PARTIAL_INFORMATION *pInfo = (KEY_VALUE_PARTIAL_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Data[datalen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;

		rc = RegQueryValueExW(pKey->Key, name, NULL,
			NULL, (PBYTE)pInfo->Data, &datalen);
			
		pInfo->DataLength = datalen;
		break;
	}

	default:
		return STATUS_INVALID_PARAMETER;
	}

	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwEnumerateKey(HANDLE KeyHandle, ULONG Index,
    KEY_INFORMATION_CLASS KeyInformationClass, PVOID KeyInformation,
	ULONG Length, PULONG ResultLength)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	WCHAR name[1024], classname[1024];
	DWORD namelen = sizeof(name) / sizeof(name[0]);
	DWORD classlen = sizeof(classname) / sizeof(classname[0]);
	FILETIME ftime;

	LSTATUS rc = RegEnumKeyExW(pKey->Key, Index, name, &namelen,
		NULL, classname, &classlen, &ftime);

	if (rc != ERROR_SUCCESS)
		return DdkGetRegistryStatus(rc);

	switch (KeyInformationClass) {
	case KeyBasicInformation:
	{
		KEY_BASIC_INFORMATION *pInfo = (KEY_BASIC_INFORMATION *)KeyInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->LastWriteTime.HighPart = ftime.dwHighDateTime;
		pInfo->LastWriteTime.LowPart = ftime.dwLowDateTime;
		pInfo->TitleIndex = 0;
		pInfo->NameLength = namelen * sizeof(WCHAR);
		memcpy(pInfo->Name, name, pInfo->NameLength);
		break;
	}

	case KeyNodeInformation:
	{
		KEY_NODE_INFORMATION *pInfo = (KEY_NODE_INFORMATION *)KeyInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo) +
			classlen * sizeof(WCHAR);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->LastWriteTime.HighPart = ftime.dwHighDateTime;
		pInfo->LastWriteTime.LowPart = ftime.dwLowDateTime;
		pInfo->TitleIndex = 0;
		pInfo->ClassOffset = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);
		pInfo->ClassLength = classlen * sizeof(WCHAR);
		pInfo->NameLength = namelen * sizeof(WCHAR);
		memcpy(pInfo->Name, name, pInfo->NameLength);
		memcpy(&pInfo->Name[namelen], classname, pInfo->ClassLength);
		break;
	}

	case KeyFullInformation:
	{
		KEY_FULL_INFORMATION *pInfo = (KEY_FULL_INFORMATION *)KeyInformation;
		HKEY key;

		*ResultLength = (ULONG)((char *)&pInfo->Class[classlen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		rc = RegOpenKeyW(pKey->Key, name, &key);
		if (rc != ERROR_SUCCESS) break;

		pInfo->LastWriteTime.HighPart = ftime.dwHighDateTime;
		pInfo->LastWriteTime.LowPart = ftime.dwLowDateTime;
		pInfo->TitleIndex = 0;
		pInfo->ClassOffset = (ULONG)((char *)&pInfo->Class - (char *)pInfo);
		pInfo->ClassLength = classlen * sizeof(WCHAR);
		memcpy(&pInfo->Class, classname, pInfo->ClassLength);

		rc = RegQueryInfoKeyW(key, NULL, NULL, NULL, &pInfo->SubKeys,
			&pInfo->MaxNameLen, &pInfo->MaxClassLen, &pInfo->Values,
			&pInfo->MaxValueNameLen, &pInfo->MaxValueDataLen, NULL, NULL);

		RegCloseKey(key);
		break;
	}

	default:
		return STATUS_INVALID_PARAMETER;
	}

	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwEnumerateValueKey(HANDLE KeyHandle, ULONG Index,
    KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation,
	ULONG Length, PULONG ResultLength)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	WCHAR name[1024];
	DWORD namelen = sizeof(name) / sizeof(name[0]);
	DWORD type, datalen;

	LSTATUS rc = RegEnumValueW(pKey->Key, Index, name, &namelen,
		NULL, &type, NULL, &datalen);

	if (rc != ERROR_SUCCESS)
		return DdkGetRegistryStatus(rc);

	switch (KeyValueInformationClass) {
	case KeyValueBasicInformation:
	{
		KEY_VALUE_BASIC_INFORMATION *pInfo = (KEY_VALUE_BASIC_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;
		pInfo->NameLength = namelen * sizeof(WCHAR);
		memcpy(pInfo->Name, name, pInfo->NameLength);
		break;
	}

	case KeyValueFullInformation:
	{
		KEY_VALUE_FULL_INFORMATION *pInfo = (KEY_VALUE_FULL_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo) + datalen;

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;
		pInfo->NameLength = namelen * sizeof(WCHAR);
		pInfo->DataOffset = (ULONG)((char *)&pInfo->Name[namelen] - (char *)pInfo);
		memcpy(pInfo->Name, name, pInfo->NameLength);

		namelen = sizeof(name) / sizeof(name[0]);
		rc = RegEnumValueW(pKey->Key, Index, name, &namelen, NULL,
			NULL, (PBYTE)&pInfo->Name + pInfo->NameLength, &datalen);
			
		pInfo->DataLength = datalen;
		break;
	}

	case KeyValuePartialInformation:
	{
		KEY_VALUE_PARTIAL_INFORMATION *pInfo = (KEY_VALUE_PARTIAL_INFORMATION *)KeyValueInformation;

		*ResultLength = (ULONG)((char *)&pInfo->Data[datalen] - (char *)pInfo);

		if (!pInfo) break;
		if (Length < *ResultLength) return STATUS_BUFFER_TOO_SMALL;

		pInfo->TitleIndex = 0;
		pInfo->Type = type;

		namelen = sizeof(name) / sizeof(name[0]);
		rc = RegEnumValueW(pKey->Key, Index, name, &namelen, NULL,
			NULL, (PBYTE)pInfo->Data, &datalen);
			
		pInfo->DataLength = datalen;
		break;
	}

	default:
		return STATUS_INVALID_PARAMETER;
	}

	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwSetValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName,
    ULONG TitleIndex, ULONG Type, PVOID Data, ULONG DataSize)
{
	UNREFERENCED_PARAMETER(TitleIndex);

	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	WCHAR *name = DdkUnicodeToString(ValueName, L'\\');

	LSTATUS rc = RegSetValueExW(pKey->Key, name, 0, Type,
			(const BYTE *)Data, DataSize);

	free(name);
	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwFlushKey(HANDLE KeyHandle)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	LSTATUS rc = RegFlushKey(pKey->Key);

	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwDeleteValueKey(HANDLE KeyHandle, PUNICODE_STRING ValueName)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	WCHAR *name =  DdkUnicodeToString(ValueName, L'\\');
	LSTATUS rc = RegDeleteValueW(pKey->Key, name);

	free(name);
	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS ZwDeleteKey(HANDLE KeyHandle)
{
	PKEY pKey = (PKEY)FromHandle(KeyHandle);

	if (!pKey || !pKey->Key)
		return STATUS_INVALID_HANDLE;

	LSTATUS rc = RegDeleteKeyW(pKey->Key, L"");

	return DdkGetRegistryStatus(rc);
}


DDKAPI
NTSTATUS RtlCreateRegistryKey(ULONG RelativeTo, PWSTR Path)
{
	if (!DdkCheckKeyExists(RelativeTo, Path, true))
		return STATUS_OBJECT_NAME_NOT_FOUND;

	HKEY key = NULL;
	NTSTATUS status = DdkGetRegistryKey(&key, RelativeTo, Path, true);

	if (!NT_SUCCESS(status)) return status;

	if (key != hive)
		RegCloseKey(key);

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlCheckRegistryKey(ULONG RelativeTo, PWSTR Path)
{
	return DdkCheckKeyExists(RelativeTo, Path, false) ?
		STATUS_SUCCESS : STATUS_OBJECT_NAME_NOT_FOUND;
}


DDKAPI
NTSTATUS RtlWriteRegistryValue(ULONG RelativeTo, PCWSTR Path,
	PCWSTR ValueName, ULONG ValueType, PVOID ValueData, ULONG ValueLength)
{
	HKEY key = NULL;
	NTSTATUS status = DdkGetRegistryKey(&key, RelativeTo, Path, false);

	if (!NT_SUCCESS(status)) return status;

	LSTATUS rc = RegSetValueExW(key, ValueName, 0, ValueType,
			(const BYTE *)ValueData, ValueLength);

	if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0)
		if (key != hive) RegCloseKey(key);

	return DdkGetRegistryStatus(rc);
}


#undef RtlQueryRegistryValues
DDKAPI
NTSTATUS RtlQueryRegistryValues(ULONG RelativeTo, PCWSTR Path,
	PRTL_QUERY_REGISTRY_TABLE QueryTable, PVOID Context, PVOID Environment)
{
	HKEY base = NULL;
	NTSTATUS status = DdkGetRegistryKey(&base, RelativeTo, Path, false);

	if (!NT_SUCCESS(status)) return status;

	HKEY key = base;

	for (RTL_QUERY_REGISTRY_TABLE *qp = QueryTable; NT_SUCCESS(status); qp++) {
		if (qp->Flags & (RTL_QUERY_REGISTRY_SUBKEY | RTL_QUERY_REGISTRY_TOPKEY)) {
			if (key && key != base)
				RegCloseKey(key);
			key = base;
		}

		if (qp->Flags & RTL_QUERY_REGISTRY_SUBKEY) {
			if (qp->Name == NULL) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			LSTATUS rc = RegOpenKeyW(base, qp->Name, &key);

			if (rc != ERROR_SUCCESS) {
				status = DdkGetRegistryStatus(rc);
				break;
			}

			if (!qp->QueryRoutine) continue;
		}

		if (qp->Name == NULL || (qp->Flags & RTL_QUERY_REGISTRY_SUBKEY)) {
			if (!qp->QueryRoutine) break;

			if (qp->Flags & RTL_QUERY_REGISTRY_DIRECT)
				return STATUS_INVALID_PARAMETER;
			
			if (qp->Flags & RTL_QUERY_REGISTRY_NOVALUE) {
				status = qp->QueryRoutine(qp->Name,
					REG_NONE, NULL, 0, Context, qp->EntryContext);
				continue;
			}

			status = DdkQueryEnumerateValues(key, qp, Context, Environment);
			continue;
		}

		status = DdkQueryValue(key, qp, Context, Environment);

		if (NT_SUCCESS(status) && (qp->Flags & RTL_QUERY_REGISTRY_DELETE))
			RegDeleteKeyValueW(key, L"", qp->Name);
	}

	if (key && key != base)
		RegCloseKey(key);

	if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0) 
		if (base && base != hive) RegCloseKey(base);

	return status;
}


static
NTSTATUS DdkQueryEnumerateValues(HKEY key,
	RTL_QUERY_REGISTRY_TABLE *qp, PVOID Context, PVOID Environment)
{
	RTL_QUERY_REGISTRY_TABLE entry = *qp;
	NTSTATUS status = STATUS_SUCCESS;
	DWORD index = 0, count = 0;

	for (; NT_SUCCESS(status); index++, count++) {
		WCHAR name[1024];
		DWORD len = sizeof(name) / sizeof(name[0]);

		LSTATUS rc = RegEnumValueW(key, index, name, &len, NULL, NULL, NULL, NULL);

		if (rc != ERROR_SUCCESS) {
			if (rc != ERROR_NO_MORE_ITEMS)
				status = DdkGetRegistryStatus(rc);
			break;
		}

		entry.Name = name;
		status = DdkQueryValue(key, &entry, Context, Environment);

		if (NT_SUCCESS(status) && (qp->Flags & RTL_QUERY_REGISTRY_DELETE))
			if (RegDeleteKeyValueW(key, L"", name) == ERROR_SUCCESS)
				index--;
	}

	if ((qp->Flags & RTL_QUERY_REGISTRY_REQUIRED) && !count)
		return STATUS_OBJECT_NAME_NOT_FOUND;

	return status;
}


static
NTSTATUS DdkQueryValue(HKEY key,
	RTL_QUERY_REGISTRY_TABLE *qp, PVOID Context, PVOID Environment)
{
	DWORD nullbytes = sizeof(WCHAR) * 3;
	DWORD len = 0, bytes = 0, type;
	BYTE *buffer = NULL;
	LSTATUS rc;

	// Validate parameters

	if (!(qp->Flags & RTL_QUERY_REGISTRY_DIRECT) == !qp->QueryRoutine)
			return STATUS_INVALID_PARAMETER;

	// Read the registry value, ensuring the buffer is always null terminated

	do {
		len += PAGE_SIZE;
		if (bytes > len) len = bytes + nullbytes;

		if (!(buffer = (BYTE *)realloc(buffer, len)))
			return STATUS_INSUFFICIENT_RESOURCES;

		bytes = len - nullbytes;
		rc = RegQueryValueExW(key, qp->Name, 0, &type, buffer, &bytes);

		if (rc == ERROR_SUCCESS)
			memset(buffer + bytes, 0, nullbytes);
	} while (rc == ERROR_MORE_DATA);

	NTSTATUS status = STATUS_SUCCESS;
	VOID *data = buffer;

	// Return value through QueryRoutine

	if ((qp->Flags & RTL_QUERY_REGISTRY_DIRECT) == 0) {
		status = (rc != ERROR_SUCCESS) ? DdkGetRegistryStatus(rc) :
			DdkQueryCallback(qp, type, data, bytes, Context, Environment);

		free(buffer);
		return status;
	}

	// Return value as Direct data

	if (rc == ERROR_SUCCESS && (qp->Flags & RTL_QUERY_REGISTRY_TYPECHECK))
		if (type != ((qp->DefaultType >> RTL_QUERY_REGISTRY_TYPECHECK_SHIFT) & 0xff)) {
			free(buffer);
			return STATUS_OBJECT_TYPE_MISMATCH;
		}

	if (rc == ERROR_FILE_NOT_FOUND) {
		if (qp->DefaultType == REG_NONE) {
			free(buffer);
	
			if (qp->Flags & RTL_QUERY_REGISTRY_REQUIRED)
				return STATUS_OBJECT_NAME_NOT_FOUND;

			return STATUS_SUCCESS;
		}

		DdkGetDefaultValue(qp, &type, &data, &bytes);
		rc = ERROR_SUCCESS;
	}

	status = (rc != ERROR_SUCCESS) ? DdkGetRegistryStatus(rc) :
		DdkQueryDirect(qp, type, data, bytes, Context, Environment);

	free(buffer);
	return status;
}


static
NTSTATUS DdkQueryCallback(RTL_QUERY_REGISTRY_TABLE *qp, DWORD type,
	PVOID data, DWORD bytes, PVOID Context, PVOID Environment)
{
	// Handle a callback where expansion is not required

	if ((qp->Flags & RTL_QUERY_REGISTRY_NOEXPAND) ||
			(type != REG_MULTI_SZ && type != REG_EXPAND_SZ))
		return qp->QueryRoutine(qp->Name,
			type, data, bytes, Context, qp->EntryContext);

	// Expand the buffer into individual strings

	NTSTATUS status = STATUS_SUCCESS;
	WCHAR *dp = (WCHAR *)data;
	ULONG i = 0;

	do {
		ULONG base = i;
		while (dp[i++] != L'\0') ;

		if (i == base + 1) break;

		PVOID buffer = (WCHAR *)data + base;
		ULONG len = (i - base - 1) * sizeof(WCHAR);

		// Expand environment variables

		if (type == REG_EXPAND_SZ)
			DdkExpandString(&buffer, &len, Environment);

		status = qp->QueryRoutine(qp->Name, REG_SZ,
			(WCHAR *)buffer, len, Context, qp->EntryContext);

		// Free any buffer from string expansion

		if (buffer != (WCHAR *)data + base)
			free(buffer);
	} while (NT_SUCCESS(status) && type == REG_MULTI_SZ);

	return status;
}


NTSTATUS DdkQueryDirect(RTL_QUERY_REGISTRY_TABLE *qp, DWORD type,
	PVOID data, DWORD bytes, PVOID Context, PVOID Environment)
{
	DWORD nullbytes = sizeof(WCHAR) * 3;
	NTSTATUS status = STATUS_SUCCESS;
	PVOID initialdata = data;

	if (qp->EntryContext == NULL)
		return STATUS_INVALID_PARAMETER;

	switch (type) {
	case REG_MULTI_SZ:
	case REG_EXPAND_SZ:

		if ((qp->Flags & RTL_QUERY_REGISTRY_NOEXPAND) == 0) {
			if (type == REG_MULTI_SZ) {
				status = STATUS_INVALID_PARAMETER;
				break;
			}

			DdkExpandString(&data, &bytes, Environment);
		}
		/* FallThru */

	case REG_SZ:
	{
		UNICODE_STRING *u = (UNICODE_STRING *)qp->EntryContext;

		if (bytes >= sizeof(WCHAR) && memcmp((char *)data +
				bytes - sizeof(WCHAR), L"\0", sizeof(WCHAR)) == 0)
			bytes -= sizeof(WCHAR);

		if (!u->Buffer) {
			u->Buffer = DdkAllocUnicodeBuffer(bytes + nullbytes);
			u->MaximumLength = (USHORT)(bytes + nullbytes);
		}

		u->Length = (USHORT)min(u->MaximumLength, bytes);
		memcpy(u->Buffer, data, min(u->MaximumLength, bytes));

		memset((char *)u->Buffer + u->Length, 0,
			min(u->MaximumLength - u->Length, (USHORT)nullbytes));
		break;
	}

	case REG_DWORD:
	case REG_QWORD:
	case REG_BINARY:
	case REG_DWORD_BIG_ENDIAN:
	{
		if (bytes <= sizeof(ULONG)) {
			memcpy(qp->EntryContext, data, bytes);
			break;
		}

		LONG size = *(LONG *)qp->EntryContext;

		if (size < 0) {
			memcpy(qp->EntryContext, data, min(-size, (LONG)bytes));
			break;
		}

		struct { ULONG size, type; } v;

		v.size = bytes;
		v.type = type;
		memcpy(qp->EntryContext, &v, min(size, sizeof(v)));

		if (size > sizeof(v))
			memcpy((char *)qp->EntryContext + sizeof(v), data,
				min(size - sizeof(v), bytes));
		break;
	}

	default:
		ddkfail("Unsupported type for registry value");
		break;
	}

	// Free any buffer from string expansion

	if (data != initialdata)
		free(data);

	return status;
}


static
void DdkGetDefaultValue(RTL_QUERY_REGISTRY_TABLE *qp, DWORD *pType,
	PVOID *pData, DWORD *pBytes)
{
	ULONG type = (qp->DefaultType & 0xff);

	*pType = type;
	*pData = qp->DefaultData;
	*pBytes = qp->DefaultLength;

	if (*pBytes || (type != REG_SZ &&
			type != REG_EXPAND_SZ && type != REG_MULTI_SZ))
		return;

	// Calculate default length

	WCHAR *dp = (WCHAR *)qp->DefaultData;
	ULONG i = 0;

	do while (dp[i++] != L'\0') ;
	while (type == REG_MULTI_SZ && (i < 2 || dp[i-1] || dp[i-2]));

	*pBytes = (DWORD)(i * sizeof(WCHAR));
}


static
void DdkExpandString(PVOID *pString, ULONG *pBytes, PVOID Environment)
{
	UNREFERENCED_PARAMETER(pBytes);

	if (Environment != NULL)
		ddkfail("Unable to expand registry values");
}


DDKAPI
NTSTATUS RtlDeleteRegistryValue(ULONG RelativeTo, PCWSTR Path, PCWSTR ValueName)
{
	HKEY key = NULL;
	NTSTATUS status = DdkGetRegistryKey(&key, RelativeTo, Path, false);

	if (!NT_SUCCESS(status)) {
		if (status == STATUS_OBJECT_NAME_NOT_FOUND)
			return STATUS_SUCCESS;

		return status;
	}

	DWORD rc = RegDeleteValueW(key, ValueName);

	if ((RelativeTo & RTL_REGISTRY_HANDLE) == 0)
		if (key != hive) RegCloseKey(key);

	return DdkGetRegistryStatus(rc);
}


static bool
DdkCheckKeyExists(ULONG RelativeTo, PCWSTR Path, bool parent)
{
	if (RelativeTo & RTL_REGISTRY_HANDLE)
		return true;

	WCHAR *s = (WCHAR *)Path, *cp;

	if (parent && (s = wcsdup(Path))) {
		if ((cp = wcsrchr(s, L'\\'))) *cp = L'\0';
		else *s = L'\0';
	}

	HKEY key = NULL;
	if (s) DdkGetRegistryKey(&key, RelativeTo, s, false);

	if (key && key != hive)
		RegCloseKey(key);

	if (s && s != Path)
		free(s);

	return (key != NULL);
}


static
NTSTATUS DdkGetRegistryObject(PKEY *ppKey,
	POBJECT_ATTRIBUTES ObjectAttributes, ULONG *pDisposition)
{
	if (!ObjectAttributes || !ObjectAttributes->ObjectName->Buffer)
		return STATUS_INVALID_PARAMETER;

	HKEY base = hive;

	if (ObjectAttributes->RootDirectory) {
		PKEY pKey = (PKEY)FromHandle((HANDLE)ObjectAttributes->RootDirectory);

		if (!pKey || !pKey->Key)
			return STATUS_INVALID_HANDLE;

		base = pKey->Key;
	}

	WCHAR *path =  DdkUnicodeToString(ObjectAttributes->ObjectName, L'\\');
	LSTATUS rc = ERROR_SUCCESS;
	HKEY key = base;

	if (*path)
		rc = (!pDisposition) ? RegOpenKeyW(base, path, &key) :
			RegCreateKeyExW(base, path, NULL, NULL, 0, KEY_ALL_ACCESS,
				NULL, &key, pDisposition);

	if (rc != ERROR_SUCCESS) {
		free(path);
		return DdkGetRegistryStatus(rc);
	}

	free(path);

	PKEY pKey = (KEY *)DdkAllocObject(sizeof(KEY), KeyType, true);

	if (!pKey) {
		if (key != base)
			RegCloseKey(key);

		return STATUS_INSUFFICIENT_RESOURCES;
	}

	pKey->Key = key;
	*ppKey = pKey;
	return STATUS_SUCCESS;
}


static
NTSTATUS DdkGetRegistryKey(HKEY *pHkey,
	ULONG RelativeTo, PCWSTR Path, bool create)
{
	*pHkey = NULL;

	if (RelativeTo & RTL_REGISTRY_HANDLE) {
		if (create) return STATUS_INVALID_PARAMETER;

		PKEY pKey = (PKEY)FromHandle((HANDLE)Path);

		if (!pKey || !pKey->Key)
			return STATUS_INVALID_HANDLE;

		*pHkey = pKey->Key;
		return STATUS_SUCCESS;
	}

	WCHAR *rel = DdkGetRelativePath(RelativeTo);
	HKEY base = hive;

	while (*rel == '\\') rel++;
	while (*Path == '\\') Path++;

	auto OpenKey = (create) ? RegCreateKeyW : RegOpenKeyW;

	if (*rel) {
		LSTATUS rc = OpenKey(base, rel, &base);

		if (rc != ERROR_SUCCESS)
			return DdkGetRegistryStatus(rc);
	}

	NTSTATUS status = STATUS_SUCCESS;
	HKEY key = base;

	if (*Path) {
		LSTATUS rc = OpenKey(base, Path, &key);

		if (rc != ERROR_SUCCESS) {
			status = DdkGetRegistryStatus(rc);
			key = NULL;
		}
	}

	if (base != key && base != hive)
		RegCloseKey(base);

	*pHkey = key;
	return status;
}


static WCHAR *
DdkGetRelativePath(ULONG RelativeTo)
{
	switch (RelativeTo & ~RTL_REGISTRY_OPTIONAL) {
	case RTL_REGISTRY_ABSOLUTE:
		return L"";

	case RTL_REGISTRY_CONTROL:
		return L"\\Registry\\Machine\\System\\CurrentControlSet\\Control";

	case RTL_REGISTRY_DEVICEMAP:
		return L"\\Registry\\Machine\\Hardware\\DeviceMap";

	case RTL_REGISTRY_SERVICES:
		return L"\\Registry\\Machine\\System\\CurrentControlSet\\Services";

	case RTL_REGISTRY_USER:
		return PsIsSystemThread(DdkGetCurrentThread())
			? L"\\Registry\\User\\CurrentUser" : L"\\Registry\\User\\.Default";

	case RTL_REGISTRY_WINDOWS_NT:
		return L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion";
	}

	ddkfail("Unknown RTL_REGISTRY value");
	return L"";
}


void DdkFreeKeyObject(OBJECT *pObj)
{
	PKEY pKey = (PKEY)ToPointer(pObj);

	if (pKey->Key && pKey->Key != hive)
		RegCloseKey(pKey->Key);

	pKey->Key = NULL;
}


static
NTSTATUS DdkGetRegistryStatus(LSTATUS rc)
{
	switch (rc) {
	case ERROR_SUCCESS:
		return STATUS_SUCCESS;

	case ERROR_ACCESS_DENIED:
		return STATUS_ACCESS_DENIED;

	case ERROR_NOT_ENOUGH_MEMORY:
		return STATUS_INSUFFICIENT_RESOURCES;

	case ERROR_INVALID_HANDLE:
		return STATUS_INVALID_HANDLE;

	case ERROR_FILE_NOT_FOUND:
		return STATUS_OBJECT_NAME_NOT_FOUND;

	case ERROR_MORE_DATA:
		return STATUS_BUFFER_TOO_SMALL;

	case ERROR_NO_MORE_ITEMS:
		return STATUS_NO_MORE_ENTRIES;
	}

	return STATUS_UNSUCCESSFUL;
}
```

`src/resource.h`:

```h
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif

```

`src/rtl.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * RTL Routines.
 */

#include "stdddk.h"


#undef RtlZeroMemory


/*
 * Memory Routines
 */

DDKAPI_NODECL
VOID RtlZeroMemory(PVOID Destination, SIZE_T Length)
{
	DDKASSERT(Destination != NULL);

	memset(Destination, 0, Length);
}


DDKAPI
SIZE_T RtlCompareMemory(const VOID *Source1, const VOID *Source2, SIZE_T Length)
{
	DDKASSERT(Source1 != NULL && Source2 != NULL);

	char *s1 = (char *)Source1, *s2 = (char *)Source2;

	for (SIZE_T i = 0; i < Length; i++)
		if (s1[i] != s2[i]) return i;

	return Length;
}

DDKAPI
NTSTATUS RtlGetVersion(PRTL_OSVERSIONINFOW OsVersionInfo)
{
	DDKASSERT(OsVersionInfo != NULL);

	if (OsVersionInfo->dwOSVersionInfoSize == sizeof(RTL_OSVERSIONINFOEXW)) {
		PRTL_OSVERSIONINFOEXW OsVersionInfoEx = (PRTL_OSVERSIONINFOEXW)OsVersionInfo;

		OsVersionInfoEx->wServicePackMajor = 0x0;
		OsVersionInfoEx->wServicePackMinor = 0x0;
		OsVersionInfoEx->wSuiteMask = 0x110;
		OsVersionInfoEx->wProductType = 0x03;
		OsVersionInfoEx->wReserved = 0x00;
	}
	else
		OsVersionInfo->dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);

	OsVersionInfo->dwMajorVersion = 0x6;
	OsVersionInfo->dwMinorVersion = 0x3;
	OsVersionInfo->dwBuildNumber = 0x2580;
	OsVersionInfo->dwPlatformId = 0x2;

	return STATUS_SUCCESS;
}


#undef RtlUshortByteSwap
DDKAPI
USHORT RtlUshortByteSwap(USHORT Source)
{
	return _byteswap_ushort(Source);
}


#undef RtlUlongByteSwap
DDKAPI
ULONG RtlUlongByteSwap(ULONG Source)
{
	return _byteswap_ulong(Source);
}


#undef RtlUlonglongByteSwap
DDKAPI
ULONGLONG RtlUlonglongByteSwap(ULONGLONG Source)
{
	return _byteswap_uint64(Source);
}

```

`src/semaphore.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Semaphore Routines
 */

#include "stdafx.h"


typedef struct _SEMAPHORE : public OBJECT {
	DWORD			threadid;
	volatile LONG	count;
} SEMAPHORE, *PSEMAPHORE;


DDKAPI
VOID KeInitializeSemaphore(PRKSEMAPHORE Semaphore, LONG Count, LONG Limit)
{
	SEMAPHORE *pSema = (SEMAPHORE *)Semaphore;

	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	DdkInitializeObject(pSema, sizeof(SEMAPHORE), _SizeofSemaphore_);

	pSema->h = CreateSemaphore(NULL, Count, Limit, NULL);
	pSema->type = SemaphoreType;
	pSema->count = Count;

	if (!pSema->h) ddkfail("Unable to initialize Semaphore");
}


DDKAPI
LONG KeReleaseSemaphore(PRKSEMAPHORE Semaphore,
	KPRIORITY Increment, LONG Adjustment, BOOLEAN Wait)
{
	SEMAPHORE *pSema = (SEMAPHORE *)Semaphore;
	LONG prev;

	DDKASSERT(KeGetCurrentIrql() <= (Wait ? PASSIVE_LEVEL : DISPATCH_LEVEL));

	InterlockedAdd(&pSema->count, Adjustment);

	if (!ReleaseSemaphore(pSema->h, Adjustment, &prev))
		KeBugCheck(STATUS_SEMAPHORE_LIMIT_EXCEEDED);

	return (prev != 0);
}


DDKAPI
LONG KeReadStateSemaphore(PRKMUTEX Semaphore)
{
	SEMAPHORE *pSema = (SEMAPHORE *)Semaphore;
	return (pSema->count != 0);
}


void DdkUpdateSemaphore(OBJECT *pObj)
{
	SEMAPHORE *pSema = (SEMAPHORE *)pObj;
	InterlockedDecrement(&pSema->count);
}


```

`src/shared.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Shared User Data.
 */

#include "stdddk.h"


#define SHARED_DATA	0x7FFE0000;


ULONG DdkGetTickCountMultiplier()
{
	PKUSER_SHARED_DATA pData = (PKUSER_SHARED_DATA)SHARED_DATA;
	return pData->TickCountMultiplier;
}


ULONG64 DdkGetTickCount()
{
	PKUSER_SHARED_DATA pData = (PKUSER_SHARED_DATA)SHARED_DATA;
	return pData->TickCountQuad;
}


```

`src/slist.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Singly Linked List Routines
 */

#include "stdafx.h"


/*
 *	Singly Linked List Routines
 */

DDKAPI
USHORT ExQueryDepthSList(PSLIST_HEADER SListHead)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return QueryDepthSList(SListHead);
}


DDKAPI
PSLIST_ENTRY ExpInterlockedPopEntrySList(PSLIST_HEADER ListHead)
{
	return InterlockedPopEntrySList(ListHead);
}


DDKAPI
PSLIST_ENTRY ExpInterlockedPushEntrySList(
	PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry)
{
	return InterlockedPushEntrySList(ListHead, ListEntry);
}


DDKAPI
PSLIST_ENTRY ExpInterlockedFlushSList(PSLIST_HEADER ListHead)
{
	return InterlockedFlushSList(ListHead);
}

```

`src/spinlock.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	SpinLock Routines
 */

#include "stdafx.h"


typedef struct _LOCKHANDLE {
	PKSPIN_LOCK		lock;
	KIRQL			irql;
} LOCKHANDLE, *PLOCKHANDLE;


static ULONG lockcount = 1;
static const int maxv = 4096;

static SRWLOCK *lockv[4096];
static SRWLOCK Lock = SRWLOCK_INIT;


DDKAPI
VOID KeInitializeSpinLock(PKSPIN_LOCK SpinLock)
{
	if (sizeof(SRWLOCK) > sizeof(KSPIN_LOCK))
		ddkfail("spinlock is too small to initialize");

	InitializeSRWLock((SRWLOCK *)SpinLock);
}


DDKAPI
BOOLEAN KeTestSpinLock(PKSPIN_LOCK SpinLock)
{
	return (((SRWLOCK *)SpinLock)->Ptr == 0) ? TRUE : FALSE;
}


static
KIRQL AcquireSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql)
{
	KIRQL rc;
	KeRaiseIrql(NewIrql, &rc);
	AcquireSRWLockExclusive((SRWLOCK *)SpinLock);
	return rc;
}


DDKAPI
KIRQL KeAcquireSpinLockRaiseToDpc(PKSPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return AcquireSpinLock(SpinLock, DISPATCH_LEVEL);
}


DDKAPI
KIRQL KeAcquireSpinLockForDpc(PKSPIN_LOCK SpinLock)
{
	return AcquireSpinLock(SpinLock, DISPATCH_LEVEL);
}


DDKAPI
VOID KeAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	AcquireSpinLock(SpinLock, KeGetCurrentIrql());
}


DDKAPI
BOOLEAN KeTryToAcquireSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	return (TryAcquireSRWLockExclusive((SRWLOCK *)SpinLock) != 0) ? TRUE : FALSE;
}


DDKAPI
VOID KeReleaseSpinLock(PKSPIN_LOCK SpinLock, KIRQL NewIrql)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	ReleaseSRWLockExclusive((SRWLOCK *)SpinLock);
	KeLowerIrql(NewIrql);
}


DDKAPI
VOID KeReleaseSpinLockFromDpcLevel(PKSPIN_LOCK SpinLock)
{
	KeReleaseSpinLock(SpinLock, KeGetCurrentIrql());
}


DDKAPI
VOID KeReleaseSpinLockForDpc(PKSPIN_LOCK SpinLock, KIRQL OldIrql)
{
	KeReleaseSpinLock(SpinLock, OldIrql);
}


DDKAPI
VOID KeAcquireInStackQueuedSpinLock(PKSPIN_LOCK SpinLock, PKLOCK_QUEUE_HANDLE LockHandle)
{
	PLOCKHANDLE h = (PLOCKHANDLE)LockHandle;
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	h->irql = AcquireSpinLock(SpinLock, DISPATCH_LEVEL);
	h->lock = SpinLock;
}


DDKAPI
VOID KeAcquireInStackQueuedSpinLockAtDpcLevel(PKSPIN_LOCK SpinLock, PKLOCK_QUEUE_HANDLE LockHandle)
{
	PLOCKHANDLE h = (PLOCKHANDLE)LockHandle;
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	h->irql = AcquireSpinLock(SpinLock, KeGetCurrentIrql());
	h->lock = SpinLock;
}


DDKAPI
VOID KeReleaseInStackQueuedSpinLock(PKLOCK_QUEUE_HANDLE LockHandle)
{
	PLOCKHANDLE h = (PLOCKHANDLE)LockHandle;
	DDKASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	KeReleaseSpinLock(h->lock, h->irql);
}


DDKAPI
VOID KeReleaseInStackQueuedSpinLockFromDpcLevel(PKLOCK_QUEUE_HANDLE LockHandle)
{
	PLOCKHANDLE h = (PLOCKHANDLE)LockHandle;
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	KeReleaseSpinLock(h->lock, h->irql);
}


static
SRWLOCK *GetSRWLock(PEX_SPIN_LOCK SpinLock)
{
	ULONG i = *(ULONG *)SpinLock;

	if (i == 0) {
		AcquireSRWLockExclusive(&Lock);

		if ((i = *(ULONG *)SpinLock) == 0) {
			i = lockcount;

			if (i / maxv >= sizeof(lockv) / sizeof(lockv[0]))
				ddkfail("Too many read write spinlocks");

			 if (!lockv[i / maxv] && !(lockv[i / maxv] = (SRWLOCK *)calloc(maxv, sizeof(SRWLOCK))))
				 ddkfail("Unable to allocate read write spinlock");

			 lockcount++;
			 InterlockedExchange((ULONG *)SpinLock, i);
		}

		ReleaseSRWLockExclusive(&Lock);
	}

	if (i >= lockcount || !lockv[i / maxv])
		ddkfail("Uninitialized read write lock");

	return &lockv[i / maxv][i % maxv];
}


static
KIRQL AcquireSpinLockShared(PEX_SPIN_LOCK SpinLock, KIRQL NewIrql)
{
	KIRQL rc;
	KeRaiseIrql(NewIrql, &rc);
	AcquireSRWLockShared(GetSRWLock(SpinLock));
	return rc;
}


DDKAPI
KIRQL ExAcquireSpinLockShared(PEX_SPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return AcquireSpinLockShared(SpinLock, DISPATCH_LEVEL);
}


DDKAPI
VOID ExReleaseSpinLockShared(PEX_SPIN_LOCK SpinLock, KIRQL NewIrql)
{
	DDKASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);
	ReleaseSRWLockShared(GetSRWLock(SpinLock));
	KeLowerIrql(NewIrql);
}


DDKAPI
VOID ExAcquireSpinLockSharedAtDpcLevel(PEX_SPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	AcquireSpinLockShared(SpinLock, KeGetCurrentIrql());
}


DDKAPI
VOID ExReleaseSpinLockSharedFromDpcLevel(PEX_SPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	ReleaseSRWLockShared(GetSRWLock(SpinLock));
}


DDKAPI
LOGICAL ExTryConvertSharedSpinLockExclusive(PEX_SPIN_LOCK SpinLock)
{
	// Not supported by SRWLOCKs
	return FALSE;
}


static
KIRQL AcquireSpinLockExclusive(PEX_SPIN_LOCK SpinLock, KIRQL NewIrql)
{
	KIRQL rc;
	KeRaiseIrql(NewIrql, &rc);
	AcquireSRWLockExclusive(GetSRWLock(SpinLock));
	return rc;
}


DDKAPI
KIRQL ExAcquireSpinLockExclusive(PEX_SPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return AcquireSpinLockExclusive(SpinLock, DISPATCH_LEVEL);
}


DDKAPI
VOID ExReleaseSpinLockExclusive(PEX_SPIN_LOCK SpinLock, KIRQL NewIrql)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	ReleaseSRWLockExclusive(GetSRWLock(SpinLock));
	KeLowerIrql(NewIrql);
}


DDKAPI
VOID ExAcquireSpinLockExclusiveAtDpcLevel(PEX_SPIN_LOCK SpinLock)
{
	DDKASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
	AcquireSpinLockExclusive(SpinLock, KeGetCurrentIrql());
}

DDKAPI
VOID ExReleaseSpinLockExclusiveFromDpcLevel(PEX_SPIN_LOCK SpinLock)
{
	ExReleaseSpinLockExclusive(SpinLock, KeGetCurrentIrql());
}

```

`src/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// Ddk.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`src/stdafx.h`:

```h
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "defs.h"

```

`src/stdddk.cpp`:

```cpp
// stdddk.cpp : source file that includes just the standard includes
// DdkDdk.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdddk.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`src/stdddk.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

// stdddk.h : include file for standard DDK include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include "ddk.h"
#include "defs.h"

```

`src/string.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	String Routines
 */

#include "stdddk.h"
#include <stringapiset.h>


char *DdkAllocAnsiBuffer(size_t len)
{
	void *s = ExAllocatePool(NonPagedPool, len);
	if (!s) ddkfail("Unable to allocate memory");
	return (char *)s;
}


DDKAPI
VOID RtlInitAnsiString(PANSI_STRING a, PCSZ s)
{
	// The kernel's version of RtlInitAnsiString() truncates the string if it is too long
	// but we will fail instead as no DataCore driver should be using strings this long ...
	DDKASSERT(!s || strlen(s) <= (MAXUSHORT - 1));

	a->Buffer = (char *)s;
	a->Length = (s) ? (USHORT) strlen(s) : 0;
	a->MaximumLength = (s) ? a->Length + 1 : 0;
}


DDKAPI
VOID RtlInitString(PSTRING DestinationString, PCSZ SourceString)
{
	RtlInitAnsiString(DestinationString, SourceString);
}


DDKAPI
ULONG RtlxAnsiStringToUnicodeSize(PCANSI_STRING AnsiString)
{
	size_t len = mbstowcs(NULL, AnsiString->Buffer, AnsiString->Length);
	return ((__int64)len >= 0) ? (ULONG)((len + sizeof(ANSI_NULL)) * sizeof(WCHAR)) : 0;
}


DDKAPI 
LONG RtlCompareString(const STRING *s1, const STRING *s2, BOOLEAN ign)
{
	int l = (s1->Length < s2->Length) ? s1->Length : s2->Length;

	int rc = (l) ? (ign ? _strnicmp(s1->Buffer, s2->Buffer, l)
		: strncmp(s1->Buffer, s2->Buffer, l)) : 0;

	if (rc != 0) return rc;
	return s1->Length - s2->Length;
}


DDKAPI
VOID RtlFreeAnsiString(PANSI_STRING AnsiString)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);
	
	if (AnsiString->Buffer != NULL)
		ExFreePool(AnsiString->Buffer);

	AnsiString->Buffer = NULL;
}


DDKAPI
VOID RtlCopyString(PSTRING DestinationString, const STRING *SourceString)
{	
	DDKASSERT(DestinationString != NULL);
	
	if (SourceString == NULL){
		DestinationString->Length = 0;
		return;
	}

	const USHORT len = SourceString->Length < DestinationString->MaximumLength ? SourceString->Length : DestinationString->MaximumLength;

	DDKASSERT(DestinationString->Buffer != NULL);
	
	memcpy(DestinationString->Buffer, SourceString->Buffer, len);
	DestinationString->Length = len;
}


DDKAPI
BOOLEAN RtlEqualString(const STRING *s1, const STRING *s2, BOOLEAN CaseInSensitive)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	return RtlCompareString(s1, s2, CaseInSensitive) == 0;
}


DDKAPI
VOID RtlUpperString(PSTRING DestinationString, const STRING *SourceString)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);
	DDKASSERT(DestinationString != NULL || SourceString != NULL);

	USHORT len = SourceString->Length < DestinationString->MaximumLength ? SourceString->Length : DestinationString->MaximumLength;

	// convert to uppercase one char at a time
	// NB we don't use _strupr_s() as this uses null-termination ...
	char ch;
	for (USHORT i = 0; i < len; i++) {
		ch = SourceString->Buffer[i];
		if (islower(ch))
			ch = (char)toupper(ch);
		DestinationString->Buffer[i] = ch;
	}
	
	DestinationString->Length = len;
}

```

`src/symlink.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Symbolic Link Routines.
 */

#include "stdddk.h"


typedef struct _SYMLINK : public OBJECT {
	UNICODE_STRING	Destination;
	BOOLEAN			Enabled;
	WCHAR			Buffer[1];
} SYMLINK, *PSYMLINK;


DDKAPI
NTSTATUS IoCreateSymbolicLink(PUNICODE_STRING SymbolicLinkName, PUNICODE_STRING DeviceName)
{
	DDKASSERT(DeviceName && DeviceName->Length);
	DDKASSERT(SymbolicLinkName && SymbolicLinkName->Length);

	SYMLINK *pLink = (SYMLINK *)DdkAllocObject(
		sizeof(SYMLINK) + DeviceName->Length, IoSymbolicLinkType, true);

	if (!pLink) return STATUS_INSUFFICIENT_RESOURCES;

	wcsncpy(pLink->Buffer, DeviceName->Buffer, DeviceName->Length / sizeof(WCHAR));
	RtlInitUnicodeString(&pLink->Destination, pLink->Buffer);
	pLink->Enabled = TRUE;

	if (!DdkInsertName(SymbolicLinkName, pLink))
		return STATUS_OBJECT_NAME_EXISTS;

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS IoDeleteSymbolicLink(PUNICODE_STRING SymbolicLinkName)
{
	DDKASSERT(SymbolicLinkName && SymbolicLinkName->Length);

	OBJECT *pObj = DdkLookupName(SymbolicLinkName);

	if (!pObj || pObj->type != IoSymbolicLinkType)
		return STATUS_OBJECT_NAME_NOT_FOUND;

	DdkRemoveObjectName(pObj);
	DdkDereferenceObject(pObj);
	return STATUS_SUCCESS;
}


POBJECT DdkResolveSymbolicLink(OBJECT *pObj)
{
	int count = 0;

	while (pObj && pObj->type == IoSymbolicLinkType) {
		if (count++ > 1000) ddkfail("Recursive Symbolic Link");

		SYMLINK *pSym = static_cast<SYMLINK *>(pObj);
		if (!pSym->Enabled) break;

		pObj = DdkLookupName(&pSym->Destination);
		ObDereferenceObject(pSym);
	}

	return pObj;
}


BOOLEAN DdkIsDeviceInterface(PUNICODE_STRING path, BOOLEAN all)
{
	OBJECT *pObj = DdkLookupName(path);
	BOOLEAN rc = FALSE;

	if (pObj && pObj->type == IoSymbolicLinkType) {
		SYMLINK *pSym = static_cast<SYMLINK *>(pObj);

		if (all || pSym->Enabled) {
			OBJECT *pDev = DdkLookupName(&pSym->Destination);
			rc = (pDev && pDev->type == IoDeviceType);
			if (pDev) DdkDereferenceObject(pDev);		
		}
	}

	if (pObj) DdkDereferenceObject(pObj);
	return rc;
}


DDKAPI
NTSTATUS IoSetDeviceInterfaceState(PUNICODE_STRING SymbolicLinkName, BOOLEAN Enable)
{
	NTSTATUS status = STATUS_OBJECT_NAME_NOT_FOUND;
	OBJECT *pObj = DdkLookupName(SymbolicLinkName);

	if (pObj && pObj->type == IoSymbolicLinkType) {
		SYMLINK *pSym = static_cast<SYMLINK *>(pObj);
		status = (!pSym->Enabled && !Enable) ? STATUS_OBJECT_NAME_NOT_FOUND :
				   (pSym->Enabled && Enable) ? STATUS_OBJECT_NAME_EXISTS : STATUS_SUCCESS;
		pSym->Enabled = Enable;
	}

	if (pObj) DdkDereferenceObject(pObj);
	return status;
}

```

`src/thread.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Thread Routines
 */

#include "stdafx.h"
#include <intrin.h>


typedef struct PROCESS : public OBJECT {
	KPRIORITY			BasePriority;
} *PPROCESS;

typedef struct _THREAD : public OBJECT {
	PKSTART_ROUTINE		Start;
	PVOID				Context;
	PPROCESS			process;
	KPRIORITY			Priority;
	KPRIORITY			BasePriority;
	DWORD				ThreadId;
	struct _THREAD		*next;
} THREAD, *PTHREAD;


void DdkInsertThread();


__declspec(thread) PTHREAD DdkCurrentThread = 0;
__declspec(thread) PPROCESS DdkCurrentProcess = 0;

static PROCESS SystemProcess;
DDKAPI PEPROCESS PsInitialSystemProcess = 0;

static const int DefaultThreadPriority = 8;
static const int DefaultBaseThreadPriority = 16;

static THREAD *threadlist;
static SRWLOCK Lock = SRWLOCK_INIT;


static DWORD StartThread(PVOID arg)
{
	THREAD *pThread = (THREAD *)arg;

	while (pThread->h == NULL) Sleep(1);

	DdkThreadDeinit();
	DdkCurrentThread = pThread;
	DdkCurrentProcess = pThread->process;
	DdkThreadInit();
	DdkInsertThread();

	(*pThread->Start)(pThread->Context);

	PsTerminateSystemThread(0);
	return 0;
}


/*
 *	VOID DdkThreadInit()
 *
 *	Initialise the thread in preparation for DDK calls.
 */

void DdkThreadInit()
{
	static const DWORD TebCurrentThread = 0x188;

	if (SystemProcess.type != ProcessType) {
		SystemProcess.type = ProcessType;
		SystemProcess.h = GetCurrentProcess();
		SystemProcess.BasePriority = DefaultBaseThreadPriority;
		InterlockedIncrement(&SystemProcess.refcount);
		PsInitialSystemProcess = (PEPROCESS)ToPointer(&SystemProcess);
	}

	if (!DdkCurrentProcess)
		DdkCurrentProcess = &SystemProcess;

	if (!DdkCurrentThread) {
		DdkCurrentThread = (THREAD *)DdkAllocObject(sizeof(THREAD), ThreadType);
		DdkCurrentThread->process = &SystemProcess;
		DdkCurrentThread->Priority = DefaultThreadPriority;
		DdkCurrentThread->BasePriority = DefaultBaseThreadPriority;

		if (!DuplicateHandle(GetCurrentProcess(), GetCurrentThread(), GetCurrentProcess(),
				&DdkCurrentThread->h, 0, FALSE, DUPLICATE_SAME_ACCESS))
			ddkfail("Failed to duplicate thread handle");

		DdkInsertThread();
	}

	// Update the Thread Environment Block with a pointer to the thread,
	// allowing the inline version of KeGetCurrentThread() to run unchanged.
	// The area is named SoftFpcr and seems to be unused.

	__writegsqword(TebCurrentThread, (DWORD64)DdkCurrentThread);
}


void DdkInsertThread()
{
	DdkThreadLock();
	DdkCurrentThread->ThreadId = GetCurrentThreadId();

	for (THREAD *pThread = threadlist; pThread; pThread = pThread->next)
		if (pThread->ThreadId == DdkCurrentThread->ThreadId)
			ddkfail("Thread already in list");

	DdkCurrentThread->next = threadlist;
	threadlist = DdkCurrentThread;
	DdkThreadUnlock();
}


void DdkThreadDeinit()
{
	if (DdkCurrentThread) {
		DdkDetachIntercept(NULL, DdkGetCurrentThread());
		DdkThreadLock();

		for (THREAD **pp = &threadlist; *pp; pp = &(*pp)->next)
			if (*pp == DdkCurrentThread) {
				*pp = DdkCurrentThread->next;
				DdkCurrentThread->next = NULL;
				break;
			}

		DdkDereferenceObject(DdkCurrentThread);
		DdkCurrentThread = NULL;
		DdkThreadUnlock();
	}
}


LONG DdkInvokeForAllThreads(LONG (*func)(HANDLE))
{
	for (THREAD *pThread = threadlist; pThread; pThread = pThread->next) {
		LONG rc = (*func)((pThread == DdkCurrentThread)
			? GetCurrentThread() : pThread->h);

		if (rc != NO_ERROR)
			return rc;
	}

	return NO_ERROR;
}


PKTHREAD DdkGetCurrentThread()
{
	if (!DdkCurrentThread) DdkThreadInit();
	return (PKTHREAD)ToPointer(DdkCurrentThread);
}


static PPROCESS GetProcess(OBJECT *pObj)
{
	if (!pObj || pObj->type != ProcessType)
		ddkfail("Invalid process specified");

	return static_cast<PROCESS *>(pObj);
}


static PTHREAD GetThread(OBJECT *pObj)
{
	if (!pObj || pObj->type != ThreadType)
		ddkfail("Invalid thread specified");

	return static_cast<THREAD *>(pObj);
}


DDKAPI
NTSTATUS PsCreateSystemThread(PHANDLE ThreadHandle, ULONG DesiredAccess,
	POBJECT_ATTRIBUTES ObjectAttributes, HANDLE ProcessHandle, PCLIENT_ID ClientId,
    PKSTART_ROUTINE StartRoutine, PVOID StartContext)
{
	DdkThreadInit();
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	PROCESS *pProcess = (!ProcessHandle) ? &SystemProcess : GetProcess(FromHandle(ProcessHandle));
	THREAD *pThread = (THREAD *)DdkAllocObject(sizeof(THREAD), ThreadType, true);

	if (!pThread) return STATUS_INSUFFICIENT_RESOURCES;

	pThread->Start = StartRoutine;
	pThread->Context = StartContext;
	pThread->process = pProcess;
	pThread->Priority = DefaultThreadPriority;
	pThread->BasePriority = DefaultBaseThreadPriority;

	DdkReferenceObject(pThread);
	pThread->h = CreateThread(NULL, 0, StartThread, pThread, 0, NULL);

	if (pThread->h == NULL) {
		free(pThread);
		return STATUS_INSUFFICIENT_RESOURCES;
	}

	*ThreadHandle = ToHandle(pThread);
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS PsTerminateSystemThread(NTSTATUS ExitStatus)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	DdkThreadDeinit();

	ExitThread(ExitStatus);
	return STATUS_UNSUCCESSFUL;
}


DDKAPI
PEPROCESS IoGetCurrentProcess()
{
	DdkThreadInit();
	return (PEPROCESS)ToPointer(DdkCurrentProcess);
}


DDKAPI
HANDLE PsGetCurrentProcessId()
{
	DdkThreadInit();
	return ToHandle(DdkCurrentProcess);
}


DDKAPI
KPRIORITY KeQueryPriorityThread(PKTHREAD Thread)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	
	return GetThread(FromPointer(Thread))->Priority;
}


DDKAPI
KPRIORITY KeSetPriorityThread(PKTHREAD Thread, KPRIORITY Priority)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	KPRIORITY oldPriority = KeQueryPriorityThread(Thread);
	KPRIORITY newPriority = Priority < 0 ? 0 : Priority > 31 ? 31 : Priority;
		
	GetThread(FromPointer(Thread))->Priority = newPriority;
	return oldPriority;
}


DDKAPI
LONG KeSetBasePriorityThread(PKTHREAD Thread, LONG Increment)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	PTHREAD pThread = GetThread(FromPointer(Thread));
	KPRIORITY oldBase = pThread->BasePriority;
	KPRIORITY newBase = pThread->process->BasePriority + Increment;

	if (newBase > 31) newBase = 31;
	else if (newBase < 0) newBase = 0;

	pThread->BasePriority = newBase;
	return oldBase - pThread->process->BasePriority;
}


DDKAPI
HANDLE PsGetProcessId(PEPROCESS Process)
{
	DdkThreadInit();
	return ToHandle(GetProcess(FromPointer(Process)));
}


#ifndef _DDKINLINE_
DDKAPI
PKTHREAD KeGetCurrentThread()
{
	DdkThreadInit();
	return (PKTHREAD)ToPointer(DdkCurrentThread);	
}


DDKAPI
PKTHREAD PsGetCurrentThread()
{
	DdkThreadInit();
	return (PKTHREAD)ToPointer(DdkCurrentThread);	
}
#endif


DDKAPI
HANDLE PsGetCurrentThreadId()
{
	DdkThreadInit();
	return ToHandle(DdkCurrentThread);
}


DDKAPI
BOOLEAN PsIsSystemThread(PETHREAD Thread)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);
	return (GetThread(FromPointer(Thread))->process == &SystemProcess);
}


void DdkThreadLock() {
	AcquireSRWLockExclusive(&Lock);
}


void DdkThreadUnlock() {
	ReleaseSRWLockExclusive(&Lock);
}

```

`src/time.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Time Routines
 */

#include "stdafx.h"


ULONG KeMaximumIncrement;

typedef VOID (*PGETPRECISE)(LPFILETIME);
static PGETPRECISE pGetSystemTimePreciseAsFileTime;


void DdkTimeInit()
{
	ULONGLONG v = 10000I64 * DdkGetTickCountMultiplier();
	v += ((1 << 23) - 1);		// round up before shift as this is what the kernel seems to do
	KeMaximumIncrement = (ULONG)(v >> 24);

	pGetSystemTimePreciseAsFileTime = (PGETPRECISE)GetProcAddress(
		GetModuleHandle("kernel32.dll"), "GetSystemTimePreciseAsFileTime");

	if (!pGetSystemTimePreciseAsFileTime)
		pGetSystemTimePreciseAsFileTime = &GetSystemTimeAsFileTime;
}


DDKAPI
VOID KeQueryTickCount(PLARGE_INTEGER CurrentCount)
{
	CurrentCount->QuadPart = (LONGLONG)DdkGetTickCount();
}


DDKAPI
ULONG KeQueryTimeIncrement()
{
	return KeMaximumIncrement;
}


DWORD DdkGetWaitTime(LARGE_INTEGER *pTimeout)
{
	if (!pTimeout) return INFINITE;

	if (pTimeout->QuadPart <= 0)
		return (DWORD)((-pTimeout->QuadPart) / 10000);

	LARGE_INTEGER v;
	FILETIME now;

	GetSystemTimeAsFileTime(&now);
	
	v.HighPart = now.dwHighDateTime;
	v.LowPart = now.dwLowDateTime;

	if (v.QuadPart > pTimeout->QuadPart)
		return 0;

	v.QuadPart = (pTimeout->QuadPart - v.QuadPart) / 10000;

	if (v.HighPart)
		ddkfail("Wait timeout is too large");

	return v.LowPart;
}


DWORD DdkGetDelayTime(LARGE_INTEGER *pTimeout)
{
	if (!pTimeout)
		ddkfail("Timeout is zero pointer");

	return DdkGetWaitTime(pTimeout);
}


FILETIME DdkGetDueTime(LARGE_INTEGER Timeout)
{
	FILETIME x;
	x.dwHighDateTime = Timeout.HighPart;
	x.dwLowDateTime = Timeout.LowPart;
	return x;
}


DDKAPI
VOID RtlTimeToTimeFields(PLARGE_INTEGER Time, PTIME_FIELDS TimeFields)
{
	FILETIME ft;
	SYSTEMTIME st;

	ft.dwLowDateTime = Time->LowPart;
	ft.dwHighDateTime = Time->HighPart;

	if (!FileTimeToSystemTime(&ft, &st))
		ddkfail("Could not convert time structure");

	TimeFields->Year = st.wYear;
	TimeFields->Month = st.wMonth;
	TimeFields->Day = st.wDay;
	TimeFields->Hour = st.wHour;
	TimeFields->Minute = st.wMinute;
	TimeFields->Second = st.wSecond;
	TimeFields->Milliseconds = st.wMilliseconds;
	TimeFields->Weekday = st.wDayOfWeek;
}


DDKAPI
BOOLEAN RtlTimeFieldsToTime(PTIME_FIELDS TimeFields, PLARGE_INTEGER Time)
{
	FILETIME ft;
	SYSTEMTIME st;

	st.wYear = TimeFields->Year;
	st.wMonth = TimeFields->Month;
	st.wDay = TimeFields->Day;
	st.wHour = TimeFields->Hour;
	st.wMinute = TimeFields->Minute;
	st.wSecond = TimeFields->Second;
	st.wMilliseconds = TimeFields->Milliseconds;
	st.wDayOfWeek = TimeFields->Weekday;

	if (!SystemTimeToFileTime(&st, &ft))
		return FALSE;

	Time->LowPart = ft.dwLowDateTime;
	Time->HighPart = ft.dwHighDateTime;

	return TRUE;
}


DDKAPI
VOID ExSystemTimeToLocalTime(PLARGE_INTEGER SystemTime, PLARGE_INTEGER LocalTime)
{
	FILETIME SysTime;
	FILETIME localTime;

	SysTime.dwLowDateTime = SystemTime->LowPart;
	SysTime.dwHighDateTime = SystemTime->HighPart;

	if (!FileTimeToLocalFileTime(&SysTime, &localTime))
		ddkfail("Could not convert system time to a valid local time");

	LocalTime->LowPart = localTime.dwLowDateTime;
	LocalTime->HighPart = localTime.dwHighDateTime;
}


#undef KeQuerySystemTime
DDKAPI
VOID KeQuerySystemTime(PLARGE_INTEGER CurrentTime)
{
	FILETIME ft;

	GetSystemTimeAsFileTime(&ft);

	CurrentTime->LowPart = ft.dwLowDateTime;
	CurrentTime->HighPart = ft.dwHighDateTime;
}


DDKAPI
VOID KeQuerySystemTimePrecise(PLARGE_INTEGER CurrentTime)
{
	FILETIME ft;

	(*pGetSystemTimePreciseAsFileTime)(&ft);

	CurrentTime->LowPart = ft.dwLowDateTime;
	CurrentTime->HighPart = ft.dwHighDateTime;
}

```

`src/timer.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Timer Routines
 */

#include "stdafx.h"


DDKAPI BOOLEAN KeInsertQueueDpc(PRKDPC Dpc, PVOID SystemArgument1, PVOID SystemArgument2);
DDKAPI BOOLEAN KeRemoveQueueDpc(PRKDPC Dpc);


typedef struct _TIMER : public OBJECT {
	PTP_TIMER		Clock;
	PKDPC			Dpc;
	FILETIME		DueTime;
	LONG			Period;
	volatile LONG	state;
	bool			notify;
} TIMER, *PTIMER;

enum { TimerIdle, TimerActive, TimerDone };


static VOID DdkTimerCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer)
{
	TIMER *pTimer = (PTIMER)Context;

	if (pTimer->Period || InterlockedCompareExchange(
			&pTimer->state, TimerDone, TimerActive) == TimerActive) {
		SetEvent(pTimer->h);
		if (pTimer->Dpc) KeInsertQueueDpc(pTimer->Dpc, 0, 0);
	}
}


DDKAPI
VOID KeInitializeTimerEx(PKTIMER Timer, TIMER_TYPE Type)
{
	TIMER *pTimer = (TIMER *)Timer;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	DdkInitializeObject(pTimer, sizeof(TIMER), _SizeofTimer_);

	pTimer->h = CreateEvent(NULL, (Type == NotificationTimer), FALSE, NULL);
	pTimer->Clock = CreateThreadpoolTimer(DdkTimerCallback, (PVOID)Timer, NULL);
	pTimer->type = TimerType;
	pTimer->state = TimerIdle;
	pTimer->notify = (Type == NotificationTimer);

	if (!pTimer->h || !pTimer->Clock)
		ddkfail("Unable to initialize Timer");
}


DDKAPI
VOID KeInitializeTimer(PKTIMER Timer)
{
	KeInitializeTimerEx(Timer, NotificationTimer);
}


DDKAPI
BOOLEAN KeCancelTimer(PKTIMER Timer)
{
	TIMER *pTimer = (TIMER *)Timer;
	LONG rc = InterlockedExchange(&pTimer->state, TimerIdle);

	SetThreadpoolTimer(pTimer->Clock, NULL, 0, 0);
	WaitForThreadpoolTimerCallbacks(pTimer->Clock, TRUE);
	return (rc == TimerActive);
}


DDKAPI
BOOLEAN KeSetTimerEx(PKTIMER Timer, LARGE_INTEGER DueTime, LONG Period, PKDPC Dpc)
{
	DDKASSERT(Period <= MAXLONG);
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	TIMER *pTimer = (TIMER *)Timer;
	LONG rc = InterlockedExchange(&pTimer->state, TimerIdle);

	SetThreadpoolTimer(pTimer->Clock, NULL, 0, 0);
	WaitForThreadpoolTimerCallbacks(pTimer->Clock, TRUE);

	pTimer->Dpc = Dpc;
	pTimer->Period = Period;
	pTimer->DueTime = DdkGetDueTime(DueTime);
	pTimer->state = TimerActive;

	ResetEvent(pTimer->h);
	SetThreadpoolTimer(pTimer->Clock, &pTimer->DueTime, Period, 0);
	return (rc == TimerActive);
}


DDKAPI
BOOLEAN KeSetTimer(PKTIMER Timer, LARGE_INTEGER DueTime, PKDPC Dpc)
{
	return KeSetTimerEx(Timer, DueTime, 0, Dpc);
}


DDKAPI
BOOLEAN KeReadStateTimer(PKTIMER Timer)
{
	TIMER *pTimer = (TIMER *)Timer;

	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	DWORD rc = WaitForSingleObject(pTimer->h, 0);

	if (rc == WAIT_OBJECT_0) {
		if (!pTimer->notify) SetEvent(pTimer->h);
		return TRUE;
	}

	return FALSE;
}

```

`src/unicode.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Unicode String Routines
 */

#include "stdddk.h"
#include <stringapiset.h>


WCHAR *DdkAllocUnicodeBuffer(size_t len)
{
	void *s = ExAllocatePool(NonPagedPool, len);
	if (!s) ddkfail("Unable to allocate memory");
	return (WCHAR *)s;
}


DDKAPI
VOID RtlInitUnicodeString(PUNICODE_STRING u, PCWSTR s)
{
	// The kernel's version of RtlInitUnicodeString() truncates the string if it is too long
	// but we will fail instead as no DataCore driver should be using strings this long ...
	DDKASSERT(!s || ((wcslen(s) + 1) * sizeof(WCHAR)) <= (MAXUSHORT - 1));

	u->Buffer = (WCHAR *)s;
	u->Length = (s) ? (USHORT)(wcslen(s) * sizeof(WCHAR)) : 0;
	u->MaximumLength = (s) ? u->Length + sizeof(UNICODE_NULL) : 0;
}


DDKAPI
VOID RtlCopyUnicodeString(PUNICODE_STRING u, PCUNICODE_STRING s)
{
	int i = 0;

	if (s != NULL) {
		for (; i < u->MaximumLength && i < s->Length; i++)
			((char *)u->Buffer)[i] = ((char *)s->Buffer)[i];
	}

	u->Length = (USHORT) i;
}


DDKAPI
NTSTATUS RtlIntegerToUnicodeString(ULONG val, ULONG base, PUNICODE_STRING u)
{
	DDKASSERT(u != NULL);
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	switch (base) {
		case 0:				// 0 or 10 => decimal
			base = 10; 
		case 10:
			break;
		case 2:				// binary
		case 8:				// octal
		case 16:			// hex
			break;
		default:
			return STATUS_INVALID_PARAMETER;
	}

	// convert into a local buffer to avoid C runtime library error handling behaviour (e.g. if buffer is too small etc) - 
	// which by default seems to involve displaying a dialog box & aborting the process
	const int BufLen = 64+1;	// max for a binary 64-bit integer + a null terminator
	WCHAR buf[BufLen];	

	errno_t err = _ui64tow_s((unsigned __int64)val, buf, BufLen, (int)base);
	DDKASSERT(err == 0);

	// buffer overflow ?
	size_t lenInBytes = wcslen(buf) * sizeof(WCHAR);
	if (lenInBytes > u->MaximumLength)
		return STATUS_BUFFER_OVERFLOW;

	memcpy(u->Buffer, buf, lenInBytes);

	u->Length = (USHORT) lenInBytes;
	return STATUS_SUCCESS;
}


DDKAPI
LONG RtlCompareUnicodeStrings(PCWCH String1, 
	SIZE_T String1Length, PCWCH String2, SIZE_T String2Length, BOOLEAN ign)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	SIZE_T l = (String1Length < String2Length) ? String1Length : String2Length;
	int rc = (l) ? (ign ? _wcsnicmp(String1, String2, l / sizeof(WCHAR))
			            : wcsncmp(String1, String2, l / sizeof(WCHAR))) : 0;

	if (rc != 0) return rc;
	return (ULONG)(String1Length - String2Length);
}


DDKAPI
LONG RtlCompareUnicodeString(PCUNICODE_STRING u1, PCUNICODE_STRING u2, BOOLEAN ign)
{
	return RtlCompareUnicodeStrings(u1->Buffer, u1->Length, u2->Buffer, u2->Length, ign);
}


DDKAPI
NTSTATUS RtlAppendUnicodeToString(PUNICODE_STRING Destination, PCWSTR Source)
{
	USHORT n = (USHORT)wcslen(Source);

	if (Destination->Length + (n * sizeof(WCHAR)) > Destination->MaximumLength)
		return STATUS_BUFFER_TOO_SMALL;

	wcsncpy(&Destination->Buffer[Destination->Length / sizeof(WCHAR)], Source, n);

	Destination->Length += (n * sizeof(WCHAR));
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlAppendUnicodeStringToString(PUNICODE_STRING u, PCUNICODE_STRING s)
{
	int i = 0;

	if (u->Length + s->Length > u->MaximumLength)
		return STATUS_BUFFER_TOO_SMALL;

	while (u->Length < u->MaximumLength && i < s->Length)
		((char *)u->Buffer)[u->Length++] = ((char *)s->Buffer)[i++];

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlUpcaseUnicodeString(PUNICODE_STRING DestinationString,
    PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString)
{
	int i = 0;

	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	if (AllocateDestinationString) {
		DestinationString->Buffer = DdkAllocUnicodeBuffer(SourceString->Length);
		DestinationString->MaximumLength = SourceString->Length;
	}

	if (DestinationString->MaximumLength < SourceString->Length)
		return STATUS_BUFFER_TOO_SMALL;

	DDKASSERT(DestinationString->Buffer != NULL);

	// convert to uppercase one char at a time
	// NB we don't use _wcsupr_s() as this uses null-termination ...
	int wlen = SourceString->Length / sizeof(WCHAR);
	for (int i = 0; i < wlen; i++) {
		WCHAR ch = SourceString->Buffer[i];
		if (iswlower(ch)) 
			ch = towupper(ch);
		DestinationString->Buffer[i] = ch;
	}

	DestinationString->Length = SourceString->Length;
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlUnicodeStringToInteger(PCUNICODE_STRING String, ULONG Base, PULONG Value)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	*Value = 0;

	if ((Base != 16 && Base != 10 && Base != 8 && Base != 2 && Base != 0) || String->Length == 0)
		return STATUS_INVALID_PARAMETER;
		
	const WCHAR *tail = &String->Buffer[(String->Length - 1)/sizeof(WCHAR)];
	WCHAR *head = String->Buffer;

	while (head <= tail && iswspace(*head)) head++;
	
	const WCHAR sign = (head <= tail) && (*head == L'+' || *head == L'-') ? *head++ : L'+';

	if (Base == 0 && head < tail && *head == '0'){
		Base = (*++head == L'x') ? 16 : (*head == L'o') ? 8 : (*head == L'b') ? 2 : 0;

		if (Base) head++;
	}

	Base = !Base ? 10 : Base;

	for (; head <= tail; head++){
		ULONG digit = (L'0' <= *head && *head <= L'9') ? *head - L'0' :
					  (L'a' <= *head && *head <= L'f') ? *head - L'a' + 10 :
					  (L'A' <= *head && *head <= L'F') ? *head - L'A' + 10 : ULONG_MAX;

		if (digit >= Base) break;
		*Value = (*Value * Base) + digit;
	}

	*Value = (sign == L'-') ? -(LONG)*Value : *Value;

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlAnsiStringToUnicodeString(PUNICODE_STRING DestinationString,
    PCANSI_STRING SourceString, BOOLEAN AllocateDestinationString)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ULONG len = RtlAnsiStringToUnicodeSize(SourceString);

	if (!len) return STATUS_INVALID_PARAMETER;

	if (AllocateDestinationString) {
		DestinationString->Buffer = DdkAllocUnicodeBuffer(len);
		DestinationString->MaximumLength = (USHORT)len;
	}

	if (len > DestinationString->MaximumLength + sizeof(UNICODE_NULL))
		return STATUS_BUFFER_TOO_SMALL;

	size_t count = mbstowcs(DestinationString->Buffer,
		SourceString->Buffer, DestinationString->MaximumLength / sizeof(WCHAR));

	DestinationString->Length = (USHORT)(count * sizeof(WCHAR));
	return STATUS_SUCCESS;
}


DDKAPI
BOOLEAN RtlEqualUnicodeString(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive)
{
	return RtlCompareUnicodeString(String1, String2, CaseInSensitive) == 0;
}


DDKAPI
VOID RtlFreeUnicodeString(PUNICODE_STRING UnicodeString)
{
	if (UnicodeString->Buffer != NULL)
		ExFreePool(UnicodeString->Buffer);

	UnicodeString->Buffer = NULL;
}


DDKAPI
ULONG RtlxUnicodeStringToAnsiSize(PCUNICODE_STRING UnicodeString)
{
	return WideCharToMultiByte(CP_ACP, 0, UnicodeString->Buffer,
		UnicodeString->Length / sizeof(WCHAR), 0, 0, NULL, NULL) + sizeof(char);
}


DDKAPI
WCHAR RtlUpcaseUnicodeChar(WCHAR SourceCharacter)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);
	return towupper(SourceCharacter);
}


DDKAPI
WCHAR RtlDowncaseUnicodeChar(WCHAR SourceCharacter)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	return towlower(SourceCharacter);
}


DDKAPI
NTSTATUS RtlHashUnicodeString(PCUNICODE_STRING String,
	BOOLEAN CaseInSensitive, ULONG HashAlgorithm, PULONG HashValue)
{
	ULONG hash = 0;

	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	if (!String || !HashValue)
		return STATUS_INVALID_PARAMETER;

	if (HashAlgorithm != HASH_STRING_ALGORITHM_DEFAULT)
		if (HashAlgorithm != HASH_STRING_ALGORITHM_X65599)
			return STATUS_INVALID_PARAMETER;

	for (USHORT i = 0; i < String->Length / sizeof(WCHAR); i++) {
		WCHAR c = (CaseInSensitive) ? towupper(String->Buffer[i]) : String->Buffer[i];
		hash = c + (hash << 6) + (hash << 16) - hash;
	}

	*HashValue = hash;
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlGUIDFromString(PCUNICODE_STRING GuidString, GUID* Guid)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	DDKASSERT(GuidString != NULL);
	DDKASSERT(Guid != NULL);

	if (GuidString->Length != 38 * sizeof(WCHAR))
		return STATUS_INVALID_PARAMETER;

	if (GuidString->Buffer[0] != L'{' || GuidString->Buffer[37] != L'}')
		return STATUS_INVALID_PARAMETER;

	unsigned short tmpI[8];

	int returnValue = swscanf(GuidString->Buffer, L"{%08lX-%04hX-%04hX-%02hX%02hX-%02hX%02hX%02hX%02hX%02hX%02hX}",
		&Guid->Data1, &Guid->Data2, &Guid->Data3,
		&tmpI[0], &tmpI[1], &tmpI[2], &tmpI[3],
		&tmpI[4], &tmpI[5], &tmpI[6], &tmpI[7]);

	if (returnValue != 11)
		return STATUS_INVALID_PARAMETER;

	for (unsigned int i = 0; i < 8; i++)
		Guid->Data4[i] = (unsigned char)tmpI[i];

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlStringFromGUID(REFGUID Guid, PUNICODE_STRING GuidString)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
	DDKASSERT(GuidString != NULL);

	GuidString->Buffer = DdkAllocUnicodeBuffer(39 * sizeof(WCHAR));
	GuidString->MaximumLength = 39 * sizeof(WCHAR);
	GuidString->Length = 38 * sizeof(WCHAR);

	int count = swprintf(GuidString->Buffer, L"{%08lX-%04hX-%04hX-%02hhX%02hhX-%02hhX%02hhX%02hhX%02hhX%02hhX%02hhX}",
		Guid.Data1, Guid.Data2, Guid.Data3,
		Guid.Data4[0], Guid.Data4[1], Guid.Data4[2], Guid.Data4[3],
		Guid.Data4[4], Guid.Data4[5], Guid.Data4[6], Guid.Data4[7]);

	if (count != 38){
		RtlFreeUnicodeString(GuidString);
		return STATUS_INVALID_PARAMETER;
	}

	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlUnicodeStringToAnsiString(PANSI_STRING DestinationString,
PCUNICODE_STRING SourceString, BOOLEAN AllocateDestinationString)
{
	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ULONG len = RtlxUnicodeStringToAnsiSize(SourceString);

	if (AllocateDestinationString){
		DestinationString->MaximumLength = (USHORT)len;
		DestinationString->Buffer = DdkAllocAnsiBuffer(DestinationString->MaximumLength);
	}
	else if (len > DestinationString->MaximumLength)
		return STATUS_BUFFER_TOO_SMALL;

	size_t count = wcstombs(DestinationString->Buffer, SourceString->Buffer, DestinationString->MaximumLength);

	DestinationString->Length = (USHORT)count;
	return STATUS_SUCCESS;
}


DDKAPI
NTSTATUS RtlUnicodeToUTF8N(PCHAR UTF8StringDestination, ULONG UTF8StringMaxByteCount,
	PULONG UTF8StringActualByteCount, PCWCH UnicodeStringSource, ULONG UnicodeStringByteCount)
{
	DDKASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	DDKASSERT(UTF8StringMaxByteCount < INT_MAX);
	DDKASSERT(UnicodeStringByteCount / sizeof(WCHAR) < INT_MAX);

	if ((UTF8StringDestination == NULL && UTF8StringActualByteCount == NULL) || (PCHAR)UnicodeStringSource == UTF8StringDestination)
		return STATUS_INVALID_PARAMETER;

	if (UnicodeStringSource == NULL)
		return STATUS_INVALID_PARAMETER_4;

	if ((UnicodeStringByteCount % sizeof(WCHAR)) != 0)
		return STATUS_INVALID_PARAMETER_5;
		
	if (UTF8StringDestination == NULL)
		UTF8StringMaxByteCount = 0;

	NTSTATUS status = STATUS_SUCCESS;

	if (UnicodeStringByteCount == 0)
		return status;

	ULONG actualByteCount = (ULONG)WideCharToMultiByte(CP_UTF8, WC_ERR_INVALID_CHARS, UnicodeStringSource,
		UnicodeStringByteCount / sizeof(WCHAR), UTF8StringDestination, UTF8StringMaxByteCount, NULL, NULL);
	
	if (actualByteCount == 0){
		DWORD err = GetLastError();
		switch (err) {
			case ERROR_INSUFFICIENT_BUFFER:
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			case ERROR_NO_UNICODE_TRANSLATION:
				status = STATUS_SOME_NOT_MAPPED;
				actualByteCount = (ULONG)WideCharToMultiByte(CP_UTF8, 0, UnicodeStringSource,
					UnicodeStringByteCount / sizeof(WCHAR), UTF8StringDestination, UTF8StringMaxByteCount, NULL, NULL);
				break;
			default:
				DDKASSERT(0); // This should never happen and indicates a programming error;
		}
	}
	
	if (status == STATUS_BUFFER_TOO_SMALL) {
		ULONG tempUnicodeStringByteCount = UnicodeStringByteCount - sizeof(WCHAR);
		// In this situation the Windows function WideCharToMultiByte sets the actual byte count to 0
		// however a truncated string has been written to the buffer, this loop retrieves the number of
		// bytes written.
		do {
			actualByteCount = (ULONG)WideCharToMultiByte(CP_UTF8, 0, UnicodeStringSource,
				tempUnicodeStringByteCount / sizeof(WCHAR), UTF8StringDestination, UTF8StringMaxByteCount, NULL, NULL);
			tempUnicodeStringByteCount -= sizeof(WCHAR);
		} while ((actualByteCount == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER) && tempUnicodeStringByteCount != 0);
	}

	if (UTF8StringActualByteCount)
		*UTF8StringActualByteCount = actualByteCount;

	return status;
}


DDKAPI
NTSTATUS RtlUTF8ToUnicodeN(PWSTR UnicodeStringDestination, ULONG UnicodeStringMaxByteCount,
	PULONG UnicodeStringActualByteCount, PCCH UTF8StringSource, ULONG UTF8StringByteCount)
{	
	DDKASSERT(KeGetCurrentIrql() < DISPATCH_LEVEL);

	DDKASSERT(UTF8StringByteCount < INT_MAX);
	DDKASSERT(UnicodeStringMaxByteCount / sizeof(WCHAR) < INT_MAX);

	if ((UnicodeStringDestination == NULL && UnicodeStringActualByteCount == NULL) || ((PCCH)UnicodeStringDestination == UTF8StringSource))
		return STATUS_INVALID_PARAMETER;

	if (UTF8StringSource == NULL)
		return STATUS_INVALID_PARAMETER_4;
		
	if (UnicodeStringDestination == NULL)
		UnicodeStringMaxByteCount = 0;

	NTSTATUS status = STATUS_SUCCESS;

	if (UTF8StringByteCount == 0)
		return status;

	ULONG actualCharCount = (ULONG)MultiByteToWideChar(CP_UTF8, MB_ERR_INVALID_CHARS, UTF8StringSource,
		UTF8StringByteCount, UnicodeStringDestination, UnicodeStringMaxByteCount / sizeof(WCHAR));

	if (actualCharCount == 0) {
		DWORD err = GetLastError();
		switch (err) {
			case ERROR_INSUFFICIENT_BUFFER:
				status = STATUS_BUFFER_TOO_SMALL;
				break;
			case ERROR_NO_UNICODE_TRANSLATION:
				status = STATUS_SOME_NOT_MAPPED;
				actualCharCount = (ULONG)MultiByteToWideChar(CP_UTF8, 0, UTF8StringSource, UTF8StringByteCount,
					UnicodeStringDestination, UnicodeStringMaxByteCount / sizeof(WCHAR));
				break;
			default:
				DDKASSERT(0); // This should never happen and indicates a programming error
		}
	}

	if (status == STATUS_BUFFER_TOO_SMALL) {
		ULONG tempUtf8StringByteCount = UTF8StringByteCount - sizeof(WCHAR);
		// In this situation the Windows function MultiByteToWideChar sets the actual byte count to 0
		// however a truncated string has been written to the buffer, this loop retrieves the number of
		// bytes written.
		do {
			actualCharCount = (ULONG)MultiByteToWideChar(CP_UTF8, 0, UTF8StringSource,
				tempUtf8StringByteCount, UnicodeStringDestination, UnicodeStringMaxByteCount / sizeof(WCHAR));
			tempUtf8StringByteCount -= sizeof(char);
		} while ((actualCharCount == 0 && GetLastError() == ERROR_INSUFFICIENT_BUFFER) && tempUtf8StringByteCount != 0);
	}

	if (UnicodeStringActualByteCount)
		*UnicodeStringActualByteCount = actualCharCount * sizeof(WCHAR);

	return status;
}


WCHAR *DdkUnicodeToString(UNICODE_STRING *u, WCHAR remove)
{
	if (!u) return NULL;

	USHORT start = 0;

	if (remove) {
		while (start + sizeof(WCHAR) - 1 < u->Length &&
				u->Buffer[start / sizeof(WCHAR)] == remove)
			start += sizeof(WCHAR);
	}

	char *s = (char *)malloc(u->Length + sizeof(WCHAR) - start);
	if (!s) ddkfail("Unable to allocate memory");

	if (u->Length - start)
		memcpy(s, (char *)u->Buffer + start, u->Length - start);

	memset(s + u->Length - start, 0, sizeof(WCHAR));
	return (WCHAR *)s;
}

```

`src/unittest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * Unit Test Support Routines.
 */

#include "stdafx.h"


void DdkModuleCleanup();
void DdkTestAdd(char *pName);
bool DdkTestRemove(char *pName);


static DWORD cleanupid;
static void (*cleanupfn)();
static char *cleanupname;
static CRITICAL_SECTION Lock;

static const int maxv = 200;
static char *vec[maxv];


void DdkTestInit()
{
	if (!InitializeCriticalSectionAndSpinCount(&Lock, 4000))
		ddkfail("DdkTestInit failed to initialize lock");
}


void DdkModuleStart(char *pName, void (*cleanup)())
{
	DdkThreadInit();
	EnterCriticalSection(&Lock);

	// Improve test behaviour with Visual Studio which starts a
	// new module on the same thread without calling cleanup first.

	if (cleanupid == GetCurrentThreadId())
		if (cleanupfn && cleanupfn != cleanup) DdkModuleCleanup();

	cleanupid = GetCurrentThreadId();
	cleanupfn = cleanup;
	cleanupname = pName;
	DdkTestRemove(pName);
	LeaveCriticalSection(&Lock);
}


void DdkModuleCleanup()
{
	char *name = cleanupname;

	(*cleanupfn)();

	DdkModuleEnd(name);
	DdkTestAdd(name);
}



BOOLEAN DdkModuleEnd(char *pName)
{
	EnterCriticalSection(&Lock);
	cleanupid = 0;
	cleanupfn = NULL;
	cleanupname = NULL;
	bool rc = DdkTestRemove(pName);
	LeaveCriticalSection(&Lock);
	return (rc != true);
}


void DdkTestAdd(char *pName)
{
	if (!pName) return;

	char *name = strrchr(pName, ':');
	name = name ? name + 1 : pName;

	for (int i = 0; i < maxv; i++)
		if (!vec[i]) {
			vec[i] = strdup(name);
			break;
		}
}


bool DdkTestRemove(char *pName)
{
	bool rc = false;
	if (!pName) return rc;

	char *name = strrchr(pName, ':');
	name = name ? name + 1 : pName;

	for (int i = 0; i < maxv; i++)
		if (vec[i] && !strcmp(vec[i], name)) {
			free(vec[i]);
			vec[i] = NULL;
			rc = true;
		}

	return rc;
}





```

`src/wait.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2017, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Wait Routines
 */

#include "stdafx.h"


extern void DdkUpdateMutex(OBJECT *pObj);
extern void DdkUpdateSemaphore(OBJECT *pObj);


static HANDLE nullevent;


void DdkWaitInit()
{
	nullevent = CreateEvent(NULL, FALSE, FALSE, NULL);
}


static POBJECT GetDispatch(OBJECT *pObj)
{
	if (!pObj || !isDispatchObject(pObj) || !pObj->h)
		ddkfail("Invalid dispatch object");

	return pObj;
}


static NTSTATUS WaitStatus(OBJECT **pVec, ULONG count, int all, DWORD rc)
{
	if ((LONG)rc >= WAIT_OBJECT_0 && rc < WAIT_OBJECT_0 + MAXIMUM_WAIT_OBJECTS) {
		for (ULONG i = (all) ? 0 : (rc - WAIT_OBJECT_0); i < count; i++) {
			if (pVec[i]->type == SemaphoreType) DdkUpdateSemaphore(pVec[i]);
			if (pVec[i]->type == MutexType) DdkUpdateMutex(pVec[i]);
			if (!all) break;
		}

		return (STATUS_WAIT_0 + (rc - WAIT_OBJECT_0));
	}

	if (rc == WAIT_TIMEOUT) return STATUS_TIMEOUT;
	if (rc == WAIT_IO_COMPLETION) return STATUS_ALERTED;
	return STATUS_UNSUCCESSFUL;
}


DDKAPI
NTSTATUS KeWaitForSingleObject(PVOID Object, KWAIT_REASON WaitReason,
	KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Timeout)
{
	return KeWaitForMultipleObjects(1, &Object, WaitAny, WaitReason, WaitMode, Alertable, Timeout, NULL);
}


DDKAPI
NTSTATUS KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType,
	KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
	PLARGE_INTEGER Timeout, PKWAIT_BLOCK WaitBlockArray)
{
	POBJECT obj[MAXIMUM_WAIT_OBJECTS];
	HANDLE h[MAXIMUM_WAIT_OBJECTS];
	ULONG i = 0;

	if (Count >= MAXIMUM_WAIT_OBJECTS) {
		KeBugCheck(0xC);
		return STATUS_UNSUCCESSFUL;
	}

	for (; i < Count; i++) {
		obj[i] = GetDispatch(FromPointer(Object[i]));
		h[i] = obj[i]->h;
	}

	// Adding a dummy entry seems to significantly speed up
	// WaitForSingleObject when used with timers and threadpools

	if (i == 1 && nullevent) h[i++] = nullevent;

	DWORD rc = WaitForMultipleObjectsEx(i, h,
		(WaitType == WaitAll), DdkGetWaitTime(Timeout), (Alertable != FALSE));

	return WaitStatus(obj, Count, (WaitType == WaitAll), rc);
}


DDKAPI
NTSTATUS KeDelayExecutionThread(KPROCESSOR_MODE WaitMode,
	BOOLEAN Alertable, PLARGE_INTEGER Interval)
{
	DDKASSERT(KeGetCurrentIrql() <= APC_LEVEL);

	DWORD rc = SleepEx(DdkGetDelayTime(Interval), (Alertable != FALSE));

	if (rc == WAIT_IO_COMPLETION) return STATUS_ALERTED;
	return STATUS_SUCCESS;
}

```

`src/wmi.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 * WMI Routines.
 */

#include "stdddk.h"

extern "C" {
#include <wmilib.h>
}


NTSTATUS WmiCompleteRequest(PDEVICE_OBJECT DeviceObject,
    PIRP Irp, NTSTATUS Status, ULONG BufferUsed, CCHAR PriorityBoost)
{
	// TODO
	return STATUS_SUCCESS;
}


NTSTATUS WmiSystemControl(PWMILIB_CONTEXT WmiLibInfo,
    PDEVICE_OBJECT DeviceObject, PIRP Irp, PSYSCTL_IRP_DISPOSITION IrpDisposition)
{
	// TODO
	return STATUS_SUCCESS;
}


NTSTATUS WmiFireEvent(PDEVICE_OBJECT DeviceObject,
    LPCGUID Guid, ULONG InstanceIndex, ULONG EventDataSize, PVOID EventData)
{
	// TODO
	return STATUS_SUCCESS;
}

```

`src/workitem.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Work Item Routines
 */

#include "stdafx.h"


typedef struct _IO_WORKITEM {
	PTP_WORK Work;
	void *IoObject;
	PIO_WORKITEM_ROUTINE WorkerRoutine;
	PIO_WORKITEM_ROUTINE_EX WorkerRoutineEx;
	WORK_QUEUE_TYPE QueueType;
	void *Context;
	volatile LONG queued;
} IO_WORKITEM;


__declspec(thread) bool DdkWorkItemActive = false;


static VOID DdkWorkCallback(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work)
{
	PIO_WORKITEM pWork = (IO_WORKITEM *)Context;
	IO_WORKITEM w = *pWork;

	DdkThreadInit();
	DdkWorkItemActive = true;
	KeLowerIrql(PASSIVE_LEVEL);
	InterlockedExchange(&pWork->queued, 0);

	if (w.WorkerRoutineEx)
		(*w.WorkerRoutineEx)(w.IoObject, w.Context, pWork);

	else (*w.WorkerRoutine)((PDEVICE_OBJECT)(w.IoObject), w.Context);

	DDKASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ObDereferenceObject(w.IoObject);
	DdkWorkItemActive = false;
}


DDKAPI
ULONG IoSizeofWorkItem()
{
	return (ULONG)sizeof(IO_WORKITEM);
}


DDKAPI
VOID IoInitializeWorkItem(PVOID IoObject, PIO_WORKITEM IoWorkItem)
{
	DDKASSERT(IoObject);
	memset(IoWorkItem, 0, sizeof(IO_WORKITEM));

	IoWorkItem->Work = CreateThreadpoolWork(DdkWorkCallback, (PVOID)IoWorkItem, NULL);

	if (!IoWorkItem->Work)
		ddkfail("Unable to initialize WorkItem");

	IoWorkItem->IoObject = IoObject;
}


DDKAPI
VOID IoUninitializeWorkItem(PIO_WORKITEM IoWorkItem)
{
	DDKASSERT(IoWorkItem);
	DDKASSERT(!IoWorkItem->queued);

	CloseThreadpoolWork(IoWorkItem->Work);
	memset(IoWorkItem, 0, sizeof(IO_WORKITEM));
}


DDKAPI
PIO_WORKITEM IoAllocateWorkItem(PDEVICE_OBJECT DeviceObject)
{
	DDKASSERT(DeviceObject);
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	IO_WORKITEM *pWork = (IO_WORKITEM *)ExAllocatePool(NonPagedPool, sizeof(IO_WORKITEM));

	if (pWork) IoInitializeWorkItem(DeviceObject, pWork);
	return pWork;
}


DDKAPI
VOID IoQueueWorkItem(PIO_WORKITEM IoWorkItem,
		PIO_WORKITEM_ROUTINE WorkerRoutine, WORK_QUEUE_TYPE QueueType, PVOID Context)
{
	DDKASSERT(IoWorkItem);
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	IoWorkItem->WorkerRoutine = WorkerRoutine;
	IoWorkItem->QueueType = QueueType;
	IoWorkItem->Context = Context;
	IoWorkItem->queued = true;

	ObReferenceObject(IoWorkItem->IoObject);
	SubmitThreadpoolWork(IoWorkItem->Work);
}


DDKAPI
VOID IoQueueWorkItemEx(PIO_WORKITEM IoWorkItem,
    PIO_WORKITEM_ROUTINE_EX WorkerRoutine, WORK_QUEUE_TYPE QueueType, PVOID Context)
{
	DDKASSERT(IoWorkItem);
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	IoWorkItem->WorkerRoutineEx = WorkerRoutine;
	IoWorkItem->QueueType = QueueType;
	IoWorkItem->Context = Context;
	IoWorkItem->queued = true;

	ObReferenceObject(IoWorkItem->IoObject);
	SubmitThreadpoolWork(IoWorkItem->Work);
}


DDKAPI
VOID IoFreeWorkItem(PIO_WORKITEM IoWorkItem)
{
	DDKASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

	IoUninitializeWorkItem(IoWorkItem);
	ExFreePool(IoWorkItem);
}


BOOLEAN DdkIsWorkItem()
{
	return (DdkWorkItemActive != false);
}

```

`test/AfxHeaderTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Afx Header Tests
 */

#define NO_WARN_MBCS_MFC_DEPRECATION
#define _AFXDLL
#define _AFX_NOFORCE_LIBS

#include <afx.h>
#include <afxwin.h>
#include <ddk.h>
#include <ntifs.h>
#include <wmilib.h>
#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkAfxHeaderTest)
	{
	public:
		
		TEST_METHOD(DdkAfxHeader)
		{
			Assert::IsTrue(true);
		}
	};
}

```

`test/BitMapTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	BitMap Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkBitMapTest)
	{
		static const int bitcount = 1000;
		static const int bufcount = (bitcount - 1) / (sizeof(ULONG) * 8);

		ULONG buffer[bufcount+1];
		RTL_BITMAP map;

		static const ULONG NUM_BITS_PER_ARRAY_INDEX = (sizeof(ULONG)* 8);
		static const ULONG ALL_BITS_SET = 0xFFFFFFFF;

	public:

		TEST_METHOD_INITIALIZE(DdkBitMapInit)
		{
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);
		}


#pragma region RtlInitializeBitMapTests

		// Check initialisation to zero
		TEST_METHOD(DdkBitMapInitToZero)
		{
			// Check bit map is initialised to 0 in "TEST_METHOD_INITIALIZE"
			for (int buffer_index = 0; buffer_index <= bufcount; buffer_index++)
			{
				Assert::IsTrue(0 == map.Buffer[buffer_index]);
			}
		}

		// Check initialisation to one
		TEST_METHOD(DdkBitMapInitToOne)
		{
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Check bit map is initialised to 1
			for (int buffer_index = 0; buffer_index <= bufcount; buffer_index++)
			{
				Assert::IsTrue(ALL_BITS_SET == map.Buffer[buffer_index]);
			}
		}

#pragma endregion


#pragma region RtlClearBitTests
		
		TEST_METHOD(DdkBitMapClearBitNullPtr)
		{
			TEST_DDK_FAIL(RtlClearBit(NULL, 0));
		}

		TEST_METHOD(DdkBitMapClearBitExceedBufSize)
		{
			TEST_DDK_FAIL(RtlClearBit(&map, (bitcount + 1)));
		}

		TEST_METHOD(DdkBitMapClearBit)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Specify bit to be cleared and call clear bit function
			ULONG bit_to_clear = 652;
			RtlClearBit(&map, bit_to_clear);

			// Set up comparison for Assert check
			int array_index = bit_to_clear / NUM_BITS_PER_ARRAY_INDEX;
			int shift_number = bit_to_clear - (array_index * NUM_BITS_PER_ARRAY_INDEX);
			
			ULONG comparison_num = ALL_BITS_SET & ~(1 << shift_number);

			Assert::IsTrue(comparison_num == map.Buffer[array_index]);
		}

#pragma endregion
		

#pragma region RtlSetBitTests

		TEST_METHOD(DdkBitMapSetBitNullPtr)
		{
			TEST_DDK_FAIL(RtlSetBit(NULL, 0));
		}

		TEST_METHOD(DdkBitMapSetBitExceedBufSize)
		{
			TEST_DDK_FAIL(RtlSetBit(&map, (bitcount + 1)));
		}

		TEST_METHOD(DdkBitMapSetBit)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Specify bit to be set and call set bit function
			ULONG bit_to_clear = 67;
			RtlSetBit(&map, bit_to_clear);

			// Set up comparison for Assert check
			int array_index = bit_to_clear / NUM_BITS_PER_ARRAY_INDEX;
			int shift_number = bit_to_clear - (array_index * NUM_BITS_PER_ARRAY_INDEX);

			ULONG comparison_num = 0x0 | (1 << shift_number);

			Assert::IsTrue(comparison_num == map.Buffer[array_index]);
		}

#pragma endregion


#pragma region RtlClearAllBitsTests

		TEST_METHOD(DdkBitMapClearAllBitsNullPtr)
		{
			TEST_DDK_FAIL(RtlClearAllBits(NULL));
		}

		TEST_METHOD(DdkBitMapClearAllBits)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Clear all the bits in the bit map
			RtlClearAllBits(&map);

			unsigned last_buffer_index = (map.SizeOfBitMap - 1) / NUM_BITS_PER_ARRAY_INDEX;

			// Check that all the buffer elements up to the last buffer are 0.
			for (unsigned buffer_index = 0; buffer_index < last_buffer_index; buffer_index++)
			{
				Assert::IsTrue(0 == map.Buffer[buffer_index]);
			}

			// Check that the last buffer element is 0.
			unsigned last_bit_position_in_array_element = (bitcount - 1) - (last_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			for (unsigned bit_position = 0; bit_position <= last_bit_position_in_array_element; bit_position++)
			{
				ULONG bit_set = map.Buffer[last_buffer_index] & (1 << bit_position);
				Assert::IsTrue(0 == bit_set);
			}
		}

		TEST_METHOD(DdkBitMapClearAllBitsOneArrayElement)
		{
			ULONG buf[1] = { 0xFF };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			// Clear all the bits in the bit map
			RtlClearAllBits(&map);
			Assert::IsTrue(0 == map.Buffer[0]);
		}

#pragma endregion

		
#pragma region RtlSetAllBitsTests

		TEST_METHOD(DdkBitMapSetAllBitsNullPtr)
		{
			TEST_DDK_FAIL(RtlSetAllBits(NULL));
		}

		TEST_METHOD(DdkBitMapSetAllBits)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Set all the bits in the bit map
			RtlSetAllBits(&map);

			unsigned last_buffer_index = (map.SizeOfBitMap - 1) / NUM_BITS_PER_ARRAY_INDEX;

			// Check that all the buffer elements up to the last buffer are 1.
			for (unsigned buffer_index = 0; buffer_index < last_buffer_index; buffer_index++)
			{
				Assert::IsTrue(ALL_BITS_SET == map.Buffer[buffer_index]);
			}

			unsigned last_bit_position_in_array_element = (bitcount - 1) - (last_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			// Check that the bits in the last element are 1.
			// This may not be 2^n boundary aligned.
			for (unsigned bit_position = 0; bit_position <= last_bit_position_in_array_element; bit_position++)
			{
				ULONG bit_set = map.Buffer[last_buffer_index] & (1 << bit_position);
				Assert::IsTrue(bit_set != 0);
			}
		}

		TEST_METHOD(DdkBitMapSetAllBitsOneArrayElement)
		{
			ULONG buf[1] = { 0X0 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			// Set all the bits in the bit map
			RtlSetAllBits(&map);
			Assert::IsTrue(ALL_BITS_SET == map.Buffer[0]);
		}

#pragma endregion


#pragma region RtlClearBitsTests

		TEST_METHOD(DdkBitMapClearBitsNullPtr)
		{
			ULONG starting_index = 0;
			ULONG num_to_clear = 10;

			TEST_DDK_FAIL(RtlClearBits(NULL, starting_index, num_to_clear));
		}

		TEST_METHOD(DdkBitMapClearBitsStartIndexExceedsBufSize)
		{
			ULONG starting_index = bitcount + 1;
			ULONG num_to_clear = 10;

			TEST_DDK_FAIL(RtlClearBits(&map, starting_index, num_to_clear));
		}

		TEST_METHOD(DdkBitMapClearBitsNumToClearExceedsBufSize)
		{
			ULONG starting_index = 0;
			ULONG num_to_clear = bitcount + 1;

			TEST_DDK_FAIL(RtlClearBits(&map, starting_index, num_to_clear));
		}

		TEST_METHOD(DdkBitMapClearBits)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 67;
			ULONG number_to_clear = 100;

			RtlClearBits(&map, starting_index, number_to_clear);

			ULONG start_buffer_index = starting_index / NUM_BITS_PER_ARRAY_INDEX;
			unsigned start_bit_position = starting_index - (start_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			ULONG last_buffer_index = (starting_index + number_to_clear - 1) / NUM_BITS_PER_ARRAY_INDEX;
			unsigned last_bit_position = (starting_index + number_to_clear - 1) - (last_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			// Check the first buffer element
			for (ULONG bit_position = start_bit_position; bit_position < NUM_BITS_PER_ARRAY_INDEX; bit_position++)
			{
				ULONG bit_set = map.Buffer[start_buffer_index] & (1 << bit_position);
				Assert::IsTrue(0 == bit_set);
			}

			// Check buffer elements between start and last
			for (ULONG buffer_index = (start_buffer_index + 1); buffer_index < last_buffer_index; buffer_index++)
			{
				Assert::IsTrue(0 == map.Buffer[buffer_index]);
			}

			// Check last buffer element
			for (ULONG bit_position = 0; bit_position <= last_bit_position; bit_position++)
			{
				ULONG bit_set = map.Buffer[last_buffer_index] & (1 << bit_position);
				Assert::IsTrue(0 == bit_set);
			}
		}

		TEST_METHOD(DdkBitMapClearBitsSameStartEndIndex)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 1;
			ULONG num_to_clear = 8;

			RtlClearBits(&map, starting_index, num_to_clear);
			Assert::IsTrue(0xFFFFFE01 == map.Buffer[0]);

			for (int i = 1; i <= bufcount; i++)
				Assert::IsTrue(ALL_BITS_SET == map.Buffer[i]);
		}

#pragma endregion


#pragma region RtlSetBitsTests
		
		TEST_METHOD(DdkBitMapSetBitsNullPtr)
		{
			ULONG starting_index = 0;
			ULONG num_to_set = 10;

			TEST_DDK_FAIL(RtlSetBits(NULL, starting_index, num_to_set));
		}

		TEST_METHOD(DdkBitMapSetBitsStartIndexExceedsBufSize)
		{
			ULONG starting_index = bitcount + 1;
			ULONG num_to_set = 10;

			TEST_DDK_FAIL(RtlSetBits(&map, starting_index, num_to_set));
		}

		TEST_METHOD(DdkBitMapSetBitsNumToClearExceedsBufSize)
		{
			ULONG starting_index = 0;
			ULONG num_to_set = bitcount + 1;

			TEST_DDK_FAIL(RtlSetBits(&map, starting_index, num_to_set));
		}

		TEST_METHOD(DdkBitMapSetBits)
		{
			// Initialise buffer to all ones
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 67;
			ULONG number_to_set = 100;

			RtlSetBits(&map, starting_index, number_to_set);

			ULONG start_buffer_index = starting_index / NUM_BITS_PER_ARRAY_INDEX;
			unsigned start_bit_position = starting_index - (start_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			ULONG last_buffer_index = (starting_index + number_to_set - 1) / NUM_BITS_PER_ARRAY_INDEX;
			unsigned last_bit_position = (starting_index + number_to_set - 1) - (last_buffer_index * NUM_BITS_PER_ARRAY_INDEX);

			// Check the first buffer element
			for (ULONG bit_position = start_bit_position; bit_position < NUM_BITS_PER_ARRAY_INDEX; bit_position++)
			{
				ULONG bit_set = map.Buffer[start_buffer_index] & (1 << bit_position);
				Assert::IsTrue(bit_set != 0);
			}

			// Check buffer elements between start and last
			for (ULONG buffer_index = (start_buffer_index + 1); buffer_index < last_buffer_index; buffer_index++)
			{
				Assert::IsTrue(ALL_BITS_SET == map.Buffer[buffer_index]);
			}

			// Check last buffer element
			for (ULONG bit_position = 0; bit_position <= last_bit_position; bit_position++)
			{
				ULONG bit_set = map.Buffer[last_buffer_index] & (1 << bit_position);
				Assert::IsTrue(bit_set != 0);
			}
		}

		TEST_METHOD(DdkBitMapSetBitsSameStartEndIndex)
		{
			// Initialise buffer to all ones
			memset(buffer, 0x00, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 1;
			ULONG num_to_set = 8;

			RtlSetBits(&map, starting_index, num_to_set);
			Assert::IsTrue(0x000001FE == map.Buffer[0]);

			for (int i = 1; i <= bufcount; i++)
				Assert::IsTrue(0x0 == map.Buffer[i]);
		}
	
#pragma endregion


#pragma region RtlFindNextForwardRunClearTests

		TEST_METHOD(DdkBitMapFindNextForwardRunClearBufNullPtr)
		{
			ULONG from_index = 0;
			ULONG first_clear_bit_in_run = 0;

			TEST_DDK_FAIL(RtlFindNextForwardRunClear(NULL, from_index, &first_clear_bit_in_run));
		}

		TEST_METHOD(DdkBitMapFindNextForwardRunClearFirstClearBitNullPtr)
		{
			ULONG from_index = 0;

			TEST_DDK_FAIL(RtlFindNextForwardRunClear(&map, from_index, NULL));
		}

		TEST_METHOD(DdkBitMapFindNextForwardRunClearFromIndexExceedsBufSize)
		{
			ULONG from_index = bitcount + 1;
			ULONG first_clear_bit_in_run = 0;

			TEST_DDK_FAIL(RtlFindNextForwardRunClear(&map, from_index, &first_clear_bit_in_run));
		}

		TEST_METHOD(DdkBitMapFindNextForwardRunClear)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Set one element in the bit map to a run of zeros
			unsigned set_run_index = 10;
			map.Buffer[set_run_index] = 0x000000ff;

			unsigned set_run_index2 = 11;
			map.Buffer[set_run_index2] = 0xff000000;

			const ULONG from_index = 320;
			ULONG first_clear_bit_in_run = 0;
			ULONG run_count = RtlFindNextForwardRunClear(&map, from_index, &first_clear_bit_in_run);

			Assert::IsTrue(48 == run_count);

			ULONG expected_first_bit_in_run = (set_run_index * NUM_BITS_PER_ARRAY_INDEX) + 8;
			Assert::IsTrue(expected_first_bit_in_run == first_clear_bit_in_run);
		}

		TEST_METHOD(DdkBitMapFindNextForwardRunClearSameStartEndIndex)
		{
			ULONG buf[1] = { 0x000000FF };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			const ULONG from_index = 2;
			ULONG first_clear_bit_in_run = 0;
			ULONG run_count = RtlFindNextForwardRunClear(&map, from_index, &first_clear_bit_in_run);
			Assert::IsTrue(24 == run_count);
		}

		TEST_METHOD(DdkBitMapFindNextForwardRunClearSameStartEndIndexNoRun)
		{
			ULONG buf[1] = { ALL_BITS_SET };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			const ULONG from_index = 16;
			ULONG first_clear_bit_in_run = 0;
			ULONG run_count = RtlFindNextForwardRunClear(&map, from_index, &first_clear_bit_in_run);
			Assert::IsTrue(0 == run_count);
		}

#pragma endregion


#pragma region RtlAreBitsClearTests

		TEST_METHOD(DdkBitMapAreBitsClearNullPtr)
		{
			ULONG starting_index = 8;
			ULONG length = 64;

			TEST_DDK_FAIL(RtlAreBitsClear(NULL, starting_index, length));
		}

		TEST_METHOD(DdkBitMapAreBitsClearStartIndexExceedBufSize)
		{
			ULONG starting_index = bitcount + 1;
			ULONG length = 64;

			Assert::IsTrue(RtlAreBitsClear(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsClearLengthExceedBufSize)
		{
			ULONG starting_index = 8;
			ULONG length = bitcount + 1;

			Assert::IsTrue(RtlAreBitsClear(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsClearLengthZero)
		{
			ULONG starting_index = 8;
			ULONG length = 0;

			Assert::IsTrue(RtlAreBitsClear(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsClearExpectReturnTrue)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 8;
			ULONG length = 64;

			// Clear 64 bits in the bit map, starting at the starting index
			// before carrying out the check
			map.Buffer[0] = 0x000000ff;
			map.Buffer[1] = 0x0;
			map.Buffer[2] = 0xffffff00;

			// Expected to return TRUE because the starting index starts at the clear run
			BOOLEAN bits_clear = RtlAreBitsClear(&map, starting_index, length);

			Assert::IsTrue(TRUE == bits_clear);
		}

		TEST_METHOD(DdkBitMapAreBitsClearExpectReturnFalse)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG starting_index = 0;
			ULONG length = 64;

			// Clear 64 bits in the bit map, starting at the starting index
			// before carrying out the check
			map.Buffer[0] = 0x000000ff;
			map.Buffer[1] = 0x0;
			map.Buffer[2] = 0xffffff00;

			// Expected to return FALSE because the starting index starts before the clear run
			BOOLEAN bits_clear = RtlAreBitsClear(&map, starting_index, length);

			Assert::IsTrue(FALSE == bits_clear);
		}

		TEST_METHOD(DdkBitMapAreBitsClearSameStartEndIndex)
		{
			ULONG buf[1] = { 0xFF00000F };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);
			ULONG starting_index = 4;
			ULONG length = 20;

			BOOLEAN bits_clear = RtlAreBitsClear(&map, starting_index, length);
			Assert::IsTrue(TRUE == bits_clear);
		}

		TEST_METHOD(DdkBitMapAreBitsClearSameStartEndIndexReturnFalse)
		{
			ULONG buf[1] = { 0xFF00000F };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);
			ULONG starting_index = 12;
			ULONG length = 20;

			BOOLEAN bits_clear = RtlAreBitsClear(&map, starting_index, length);
			Assert::IsTrue(FALSE == bits_clear);
		}

#pragma endregion


#pragma region RtlAreBitsSetTests

		TEST_METHOD(DdkBitMapAreBitsSetNullPtr)
		{
			ULONG starting_index = 8;
			ULONG length = 64;

			TEST_DDK_FAIL(RtlAreBitsSet(NULL, starting_index, length));
		}

		TEST_METHOD(DdkBitMapAreBitsSetStartIndexExceedBufSize)
		{
			ULONG starting_index = bitcount + 1;
			ULONG length = 64;

			Assert::IsTrue(RtlAreBitsSet(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsSetLengthExceedBufSize)
		{
			ULONG starting_index = 8;
			ULONG length = bitcount + 1;

			Assert::IsTrue(RtlAreBitsSet(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsSetLengthZero)
		{
			ULONG starting_index = 8;
			ULONG length = 0;

			Assert::IsTrue(RtlAreBitsSet(&map, starting_index, length) == FALSE);
		}

		TEST_METHOD(DdkBitMapAreBitsSetExpectReturnTrue)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Set 64 bits in the bit map, starting at the starting index
			// before carrying out the check
			map.Buffer[0] = 0xffffff00;
			map.Buffer[1] = 0x00ffffff;

			ULONG starting_index = 8;
			ULONG length = 48;

			// Expected to return TRUE because starting index is at the start of set run
			BOOLEAN bits_set = RtlAreBitsSet(&map, starting_index, length);

			Assert::IsTrue(TRUE == bits_set);
		}

		TEST_METHOD(DdkBitMapAreBitsSetExpectReturnFalse)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			// Set 64 bits in the bit map, starting at the starting index
			// before carrying out the check
			map.Buffer[0] = 0xffffff00;
			map.Buffer[1] = 0x00ffffff;

			ULONG starting_index = 0;
			ULONG length = 48;

			BOOLEAN bits_set = RtlAreBitsSet(&map, starting_index, length);

			// Expected to return FALSE because starting index is after the start of set run
			Assert::IsTrue(FALSE == bits_set);
		}

		TEST_METHOD(DdkBitMapAreBitsSetSameStartEndIndex)
		{
			ULONG buf[1] = { 0x00FFFFF0 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);
			ULONG starting_index = 4;
			ULONG length = 20;

			BOOLEAN bits_set = RtlAreBitsSet(&map, starting_index, length);
			Assert::IsTrue(TRUE == bits_set);
		}

		TEST_METHOD(DdkBitMapAreBitsSetSameStartEndIndexReturnFalse)
		{
			ULONG buf[1] = { 0x00FFFFF0 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);
			ULONG starting_index = 12;
			ULONG length = 20;

			BOOLEAN bits_set = RtlAreBitsSet(&map, starting_index, length);
			Assert::IsTrue(FALSE == bits_set);
		}

#pragma endregion


#pragma region RtlFindClearBitsTests

		TEST_METHOD(DdkBitMapFindClearBitsNullPtr)
		{
			ULONG number_to_find = 32;
			ULONG hint_index = 0;

			TEST_DDK_FAIL(RtlFindClearBits(NULL, number_to_find, hint_index));
		}

		TEST_METHOD(DdkBitMapFindClearBitsNumToFindExceedBufSize)
		{
			ULONG number_to_find = bitcount + 1;
			ULONG hint_index = 0;

			Assert::IsTrue(ALL_BITS_SET == RtlFindClearBits(&map, number_to_find, hint_index));
		}

		TEST_METHOD(DdkBitMapFindClearBitsExpectFindClearBits)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			int run_index = 28;
			map.Buffer[run_index] = 0x000000ff;
			map.Buffer[run_index + 1] = 0;
			
			ULONG number_to_find = 56;
			ULONG hint_index = (run_index * NUM_BITS_PER_ARRAY_INDEX) + (NUM_BITS_PER_ARRAY_INDEX / 2); // Start in the middle of the run

			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);

			ULONG expected_answer = (run_index * NUM_BITS_PER_ARRAY_INDEX) + 8;

			Assert::IsTrue(expected_answer == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindClearBitsExpectDontFindClearBits)
		{
			// Initialise buffer to all ones
			memset(buffer, 0xff, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			int run_index = 28;

			ULONG number_to_find = 56;
			ULONG hint_index = (run_index * NUM_BITS_PER_ARRAY_INDEX) + (NUM_BITS_PER_ARRAY_INDEX / 2); // Start in the middle of the run

			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);

			Assert::IsTrue(ALL_BITS_SET == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindClearBitsSameStartEndIndex)
		{
			ULONG buf[1] = { 0xFFF000FF };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);
			
			ULONG number_to_find = 12;
			ULONG hint_index = 6;
			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);
			Assert::IsTrue(8 == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindClearBitsSameStartEndIndexBitsNotFound)
		{
			ULONG buf[1] = { ALL_BITS_SET };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 12;
			ULONG hint_index = 6;
			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);
			Assert::IsTrue(ALL_BITS_SET == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindClearBitsSameStartEndIndexLoopTwice)
		{
			ULONG buf[1] = { 0xFFF000FF };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 12;
			ULONG hint_index = 16;
			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);
			Assert::IsTrue(8 == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindClearBitsTwoClearBitRuns)
		{
			ULONG buf[1] = { 0x0000FF00 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 16;
			ULONG hint_index = 0;
			ULONG bit_starting_run = RtlFindClearBits(&map, number_to_find, hint_index);
			Assert::IsTrue(16 == bit_starting_run);
		}

#pragma endregion


#pragma region RtlFindSetBitsTests

		TEST_METHOD(DdkBitMapFindSetBitsNullPtr)
		{
			ULONG number_to_find = 32;
			ULONG hint_index = 0;

			TEST_DDK_FAIL(RtlFindSetBits(NULL, number_to_find, hint_index));
		}

		TEST_METHOD(DdkBitMapFindSetBitsNumToFindExceedBufSize)
		{
			ULONG number_to_find = bitcount + 1;
			ULONG hint_index = 0;

			Assert::IsTrue(ALL_BITS_SET == RtlFindSetBits(&map, number_to_find, hint_index));
		}

		TEST_METHOD(DdkBitMapFindSetBitsExpectFindSetBits)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			int run_index = 0;
			map.Buffer[run_index] = 0xffffff00;
			map.Buffer[run_index + 1] = 0x000000ff;

			ULONG number_to_find = 32;
			ULONG hint_index = (run_index * NUM_BITS_PER_ARRAY_INDEX) + (NUM_BITS_PER_ARRAY_INDEX / 2); // Start in the middle of the run

			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);

			ULONG expected_answer = (run_index * NUM_BITS_PER_ARRAY_INDEX) + 8;

			Assert::IsTrue(expected_answer == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindSetBitsExpectDontFindSetBits)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			int run_index = 0;

			ULONG number_to_find = 32;
			ULONG hint_index = (run_index * NUM_BITS_PER_ARRAY_INDEX) + (NUM_BITS_PER_ARRAY_INDEX / 2); // Start in the middle of the run

			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);

			Assert::IsTrue(ALL_BITS_SET == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindSetBitsSameStartEndIndex)
		{
			ULONG buf[1] = { 0x000FFF00 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 12;
			ULONG hint_index = 6;
			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);
			Assert::IsTrue(8 == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindSetBitsSameStartEndIndexBitsNotFound)
		{
			ULONG buf[1] = { 0x0 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 12;
			ULONG hint_index = 6;
			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);
			Assert::IsTrue(ALL_BITS_SET == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindSetBitsSameStartEndIndexLoopTwice)
		{
			ULONG buf[1] = { 0x000FFF00 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 12;
			ULONG hint_index = 16;
			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);
			Assert::IsTrue(8 == bit_starting_run);
		}

		TEST_METHOD(DdkBitMapFindSetBitsTwoSetBitRuns)
		{
			ULONG buf[1] = { 0xFFFF00FF };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_to_find = 16;
			ULONG hint_index = 0;
			ULONG bit_starting_run = RtlFindSetBits(&map, number_to_find, hint_index);
			Assert::IsTrue(16 == bit_starting_run);
		}

#pragma endregion


#pragma region RtlNumberOfSetBitsTests

		TEST_METHOD(DdkBitMapNumberOfSetBitsNullPtr)
		{
			TEST_DDK_FAIL(RtlNumberOfSetBits(NULL));
		}

		TEST_METHOD(DdkBitMapNumberOfSetBitsAreSet)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0x0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			map.Buffer[0] = 0xffffff00;
			map.Buffer[1] = ALL_BITS_SET;
			map.Buffer[2] = ALL_BITS_SET;

			ULONG number_of_set_bits = RtlNumberOfSetBits(&map);

			Assert::IsTrue(88 == number_of_set_bits);
		}

		TEST_METHOD(DdkBitMapNumberOfSetBitsNotSet)
		{
			// Initialise buffer to all zeros
			memset(buffer, 0x0, sizeof(buffer));
			RtlInitializeBitMap(&map, buffer, bitcount);

			ULONG number_of_set_bits = RtlNumberOfSetBits(&map);

			Assert::IsTrue(0 == number_of_set_bits);
		}

		TEST_METHOD(DdkBitMapNumberOfSetBitsSameStartEndIndex)
		{
			ULONG buf[1] = { 0xFFFF0000 };
			RtlInitializeBitMap(&map, buf, NUM_BITS_PER_ARRAY_INDEX);

			ULONG number_of_set_bits = RtlNumberOfSetBits(&map);
			Assert::IsTrue(16 == number_of_set_bits);
		}

#pragma endregion

#pragma region RtlFindClearBitsAndSetTests

		TEST_METHOD(DdkBitMapFindClearBitsAndSetWithHint)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[arrayIndex] = 0x00000000;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetNoHint)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[arrayIndex] = 0x00000000;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, 0);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetOddBit)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));
			buffer[2] = 0x00100000;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(ALL_BITS_SET == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				if (i == arrayIndex)
					Assert::IsTrue(0x00100000 == buffer[i]);
				else
					Assert::IsTrue(ALL_BITS_SET == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetHalfRun)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[arrayIndex] = buffer[arrayIndex + 1] = 0x00000000;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				if (i == arrayIndex + 1)
					Assert::IsTrue(0x00000000 == buffer[i]);
				else
					Assert::IsTrue(ALL_BITS_SET == buffer[i]);
			
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetEndToEnd)
		{
			const ULONG firstElement = 0xFFFFFF00, lastElement = 0x000000FF;

			memset(&buffer[1], ALL_BITS_SET, sizeof(buffer) - (2 * sizeof(buffer[0])));

			buffer[0] = firstElement;
			buffer[bufcount] = lastElement;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, 0);

			Assert::IsTrue(ALL_BITS_SET == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);

			Assert::IsTrue(buffer[0] == firstElement);
			Assert::IsTrue(buffer[bufcount] == lastElement);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetSecondGroup)
		{
			const ULONG arrayIndex = bufcount, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[0] = buffer[arrayIndex] = 0x00000000;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, 8, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);
			
			Assert::IsTrue(0x00000000 == buffer[0]);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetSpanningTwoArrayElements)
		{
			const ULONG firstElement = 0x000000FF, lastElement = 0xFFFFFF00;
			const ULONG arrayIndex = 2, hintBitIndex = (arrayIndex * NUM_BITS_PER_ARRAY_INDEX) + 8;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[arrayIndex] = firstElement;
			buffer[arrayIndex + 1] = lastElement;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindClearBitsAndSetSpanningTwoArrayElementsIncorrectHint)
		{
			const ULONG firstElement = 0x000000FF, lastElement = 0xFFFFFF00;

			const ULONG arrayIndex = 2;
			const ULONG runStartBit = (arrayIndex * NUM_BITS_PER_ARRAY_INDEX) + 8, hintBitIndex = runStartBit + 1;

			memset(buffer, ALL_BITS_SET, sizeof(buffer));

			buffer[arrayIndex] = firstElement;
			buffer[arrayIndex + 1] = lastElement;

			ULONG startBitIndex = RtlFindClearBitsAndSet(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(runStartBit == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(ALL_BITS_SET == buffer[i]);
		}

#pragma endregion

#pragma region RtlFindSetBitsAndClearTests

		TEST_METHOD(DdkBitMapFindSetBitsAndClearWithHint)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			buffer[arrayIndex] = ALL_BITS_SET;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearNoHint)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			buffer[arrayIndex] = ALL_BITS_SET;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, 0);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearOddBit)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;
			const ULONG brokenSetBit = 0xFFF0FFFF;

			buffer[arrayIndex] = brokenSetBit;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(ALL_BITS_SET == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				if (i == arrayIndex)
					Assert::IsTrue(brokenSetBit == buffer[i]);
				else
					Assert::IsTrue(0x00000000 == buffer[i]);			
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearHalfRun)
		{
			const ULONG arrayIndex = 2, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			buffer[arrayIndex] = buffer[arrayIndex + 1] = ALL_BITS_SET;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 0; i < bufcount + 1; i++)
				if (i == arrayIndex + 1)
					Assert::IsTrue(ALL_BITS_SET == buffer[i]);
				else
					Assert::IsTrue(0x00000000 == buffer[i]);

		}
		
		TEST_METHOD(DdkBitMapFindSetBitsAndClearEndToEnd)
		{
			const ULONG firstElement = 0x000000FF, lastElement = 0xFFFFFF00;

			buffer[0] = firstElement;
			buffer[bufcount] = lastElement;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, 0);

			Assert::IsTrue(ALL_BITS_SET == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);

			Assert::IsTrue(firstElement == buffer[0]);
			Assert::IsTrue(lastElement == buffer[bufcount]);
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearSecondGroup)
		{
			const ULONG arrayIndex = bufcount, hintBitIndex = arrayIndex * NUM_BITS_PER_ARRAY_INDEX;

			buffer[0] = buffer[arrayIndex] = ALL_BITS_SET;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, 8, hintBitIndex);

			Assert::IsTrue(bufcount * NUM_BITS_PER_ARRAY_INDEX == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);

			Assert::IsTrue(ALL_BITS_SET == buffer[0]);
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearSpanningTwoArrayElements)
		{
			const ULONG firstElement = 0xFFFFFF00, lastElement = 0x000000FF;
			const ULONG arrayIndex = 2, hintBitIndex = (arrayIndex * NUM_BITS_PER_ARRAY_INDEX) + 8;
			
			buffer[arrayIndex] = firstElement;
			buffer[arrayIndex + 1] = lastElement;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(hintBitIndex == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);
		}

		TEST_METHOD(DdkBitMapFindSetBitsAndClearSpanningTwoArrayElementsIncorrectHint)
		{
			const ULONG firstElement = 0xFFFFFF00, lastElement = 0x000000FF;

			const ULONG arrayIndex = 2;
			const ULONG runStartBit = (arrayIndex * NUM_BITS_PER_ARRAY_INDEX) + 8, hintBitIndex = runStartBit + 1;

			buffer[arrayIndex] = firstElement;
			buffer[arrayIndex + 1] = lastElement;

			ULONG startBitIndex = RtlFindSetBitsAndClear(&map, NUM_BITS_PER_ARRAY_INDEX, hintBitIndex);

			Assert::IsTrue(runStartBit == startBitIndex);

			for (int i = 1; i < bufcount; i++)
				Assert::IsTrue(0x00000000 == buffer[i]);
		}

#pragma endregion

	};
}

```

`test/CpuTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	CPU Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkCpuTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkCpuTestInit)
		{
			DdkThreadInit();
		}

		TEST_METHOD(DdkCpuCount)
		{
			Assert::IsTrue(KeNumberProcessors > 0 && KeNumberProcessors < 16);
		}

	};
}

```

`test/DdkUnitTest.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="12.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <ProjectGuid>{EC884926-BF4A-42EF-8168-107EDB958B9E}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>DdkUnitTest</RootNamespace>
    <ProjectName>DdkUnitTest</ProjectName>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>DynamicLibrary</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>WindowsApplicationForDrivers10.0</PlatformToolset>
    <CharacterSet>MultiByte</CharacterSet>
    <UseOfMfc>false</UseOfMfc>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Config\Driver.UnitTest.props" />
  </ImportGroup>
  <ImportGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="PropertySheets">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
    <Import Project="..\Config\Driver.UnitTest.props" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" />
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <Optimization>Disabled</Optimization>
      <PreprocessorDefinitions>WIN32;_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <PrecompiledHeader>Use</PrecompiledHeader>
      <Optimization>MaxSpeed</Optimization>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <PreprocessorDefinitions>WIN32;NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <UseFullPaths>true</UseFullPaths>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClInclude Include="..\inc\UnitTest.h" />
    <ClInclude Include="stdafx.h" />
    <ClInclude Include="targetver.h" />
    <ClInclude Include="Test.h" />
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="AfxHeaderTest.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="BitMapTest.cpp" />
    <ClCompile Include="CpuTest.cpp" />
    <ClCompile Include="DetoursTest.cpp" />
    <ClCompile Include="DpcTest.cpp" />
    <ClCompile Include="FileTest.cpp" />
    <ClCompile Include="HeaderTest.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Use</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Use</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="DeviceTest.cpp" />
    <ClCompile Include="DriverTest.cpp" />
    <ClCompile Include="EventTest.cpp" />
    <ClCompile Include="RegistryTest.cpp" />
    <ClCompile Include="RtlTest.cpp" />
    <ClCompile Include="StringTest.cpp" />
    <ClCompile Include="Test.cpp" />
    <ClCompile Include="InlineTest.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="IrpTest.cpp" />
    <ClCompile Include="IrqlTest.cpp" />
    <ClCompile Include="MdlTest.cpp" />
    <ClCompile Include="MemoryTest.cpp" />
    <ClCompile Include="MutexTest.cpp" />
    <ClCompile Include="ObjectTest.cpp" />
    <ClCompile Include="SemaphoreTest.cpp" />
    <ClCompile Include="SListTest.cpp" />
    <ClCompile Include="SpinLockTest.cpp" />
    <ClCompile Include="stdafx.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">Create</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">Create</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="SymLinkTest.cpp" />
    <ClCompile Include="ThreadTest.cpp">
      <PreprocessToFile Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">false</PreprocessToFile>
    </ClCompile>
    <ClCompile Include="TimerTest.cpp" />
    <ClCompile Include="TimeTest.cpp" />
    <ClCompile Include="UnicodeTest.cpp" />
    <ClCompile Include="WaitTest.cpp" />
    <ClCompile Include="WinHeaderTest.cpp">
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">NotUsing</PrecompiledHeader>
      <PrecompiledHeader Condition="'$(Configuration)|$(Platform)'=='Release|x64'">NotUsing</PrecompiledHeader>
    </ClCompile>
    <ClCompile Include="WorkItemTest.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="..\src\Ddk.vcxproj">
      <Project>{12FAF1AE-B4C9-449F-A188-F03CBA835662}</Project>
    </ProjectReference>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`test/DdkUnitTest.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{D28C530A-4629-44C9-857B-3ADD3501C144}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{064CDA4A-B496-43B7-A302-0F6C19A1D320}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{B9F26555-1FDD-484C-B1AC-1EEFE17F9175}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="stdafx.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="targetver.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="..\inc\UnitTest.h">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="Test.h">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="stdafx.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IrqlTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ObjectTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DeviceTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DriverTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="EventTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="IrpTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SemaphoreTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="HeaderTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WinHeaderTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SpinLockTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MdlTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MemoryTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="MutexTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SListTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="SymLinkTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="ThreadTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TimerTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="TimeTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="InlineTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WorkItemTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DpcTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="Test.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="CpuTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="BitMapTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="StringTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="UnicodeTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RtlTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="AfxHeaderTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="WaitTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="DetoursTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="RegistryTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="FileTest.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
</Project>
```

`test/DetoursTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

 /*
  *	Detours Tests
  */

#include "stdafx.h"


namespace DdkUnitTest
{
	LONG TestDetoursVar = 100;

	// Note: Need to ensure test functions are large enough
	// to detour and don't get inlined

	__declspec(noinline) void DoWork() { GetCurrentThreadId(); }

	__declspec(noinline) LONG TestDetourFunction(LONG arg) {
		return DoWork(), arg + 1;
	}

	__declspec(noinline) LONG TestDetourFunction2(LONG arg) {
		return DoWork(), arg + 2;
	}

	__declspec(noinline) LONG TestDetourFunction3(LONG arg) {
		return DoWork(), arg + 3;
	}

	__declspec(noinline) LONG TestDetourFunction4(LONG arg) {
		return DoWork(), arg + 4;
	}

	__declspec(noinline) LONG TestDetourFunction5(LONG arg) {
		return DoWork(), arg + 5;
	}

	class TestDetourClass {
		volatile LONG value;
	public:
		TestDetourClass(LONG v) : value(v) { }
		__declspec(noinline) LONG Increment(LONG arg) {
			return DoWork(), arg + 1;
		}
	};

	// Test defining mocks at global scope

	TEST_DEFINE_MOCK_FUNCTION(function1, LONG, &TestDetourFunction, (LONG arg)) {
		return TEST_REAL_FUNCTION(arg) + 0x100;
	} TEST_END_MOCK;

	TEST_DEFINE_MOCK_METHOD(method1, TestDetourClass, LONG, &TestDetourClass::Increment, (LONG arg)) {
		return TEST_REAL_METHOD(arg) + 0x100;
	} TEST_END_MOCK;

	// Test global mock enabled for all threads

	TEST_DEFINE_MOCK_FUNCTION(function9, LONG, &TestDetourFunction3, (LONG arg)) {
		return TEST_REAL_FUNCTION(arg) + 0x900;
	} TEST_END_MOCK;

	TEST_CLASS(DdkDetoursTest)
	{
		// Test defining mocks at class scope

		TEST_DEFINE_MOCK_FUNCTION(function2, LONG, &TestDetourFunction, (LONG arg)) {
			return TEST_REAL_FUNCTION(arg) + 0x200;
		} TEST_END_MOCK;

		TEST_DEFINE_MOCK_METHOD(method2, TestDetourClass, LONG, &TestDetourClass::Increment, (LONG arg)) {
			return TEST_REAL_METHOD(arg) + 0x200;
		} TEST_END_MOCK;

	public:
		TEST_METHOD_INITIALIZE(DdkDetoursTestInit)
		{
			DdkThreadInit();

			// Enable mock at class creation for later testing

			TEST_ENABLE_MOCK(function9);
			Assert::IsTrue(TestDetourFunction3(1) == 0x904);
		}

		TEST_METHOD_CLEANUP(DdkDetoursTestCleanup)
		{
			Assert::IsTrue(TestDetourFunction3(1) == 0x904);
			TEST_DISABLE_MOCK(function9);
			Assert::IsTrue(TestDetourFunction3(1) == 0x4);
		}

		TEST_METHOD(DdkDetoursFindFunction)
		{
			// Function in current DLL

			TEST_FIND_FUNCTION(uniq1, LONG, GetUniqueId, ());
			TEST_FIND_FUNCTION(uniq2, LONG, "DdkUnitTest::GetUniqueId", ());

			Assert::IsTrue(uniq1.GetPointer() == uniq2.GetPointer());
			Assert::IsTrue(uniq1.GetPointer() == (void *)&GetUniqueId);

			// Check function can be called

			LONG u1 = GetUniqueId();
			LONG u2 = uniq2();

			Assert::IsTrue(u2 != u1);

			// Taking address of function

			TEST_FIND_FUNCTION(uniq3, void, &GetUniqueId, ());

			Assert::IsTrue(uniq1.GetPointer() == uniq3.GetPointer());

			// Using pointer object

			TEST_FIND_FUNCTION(uniq4, void, uniq1, ());

			Assert::IsTrue(uniq1.GetPointer() == uniq4.GetPointer());

			// Using PVOID

			PVOID ptr = (PVOID)&GetUniqueId;

			TEST_FIND_FUNCTION(uniq6, LONG, ptr, ());
			TEST_FIND_FUNCTION(uniq7, LONG, &ptr, ());

			Assert::IsTrue(uniq1.GetPointer() == uniq6.GetPointer());
			Assert::IsTrue(uniq1.GetPointer() == uniq7.GetPointer());

			// Check function in DDK DLL

			TEST_FIND_FUNCTION(init1, void, DdkThreadInit, ());
			TEST_FIND_FUNCTION(init2, void, "DdkThreadInit", ());

			Assert::IsTrue(init1.GetPointer() == init2.GetPointer());

			// Check function in system DLL

			TEST_FIND_FUNCTION(get1, DWORD, GetLastError, ());
			TEST_FIND_FUNCTION(get2, DWORD, "GetLastError", ());

			Assert::IsTrue(get1.GetPointer() == get2.GetPointer());

			// Check function in specific DLL

			TEST_FIND_FUNCTION(init3, void, "ddk!DdkThreadInit", ());
			TEST_FIND_FUNCTION(init4, void, "dxk!DdkThreadInit", ());

			Assert::IsTrue(init1.GetPointer() == init3.GetPointer());
			Assert::IsFalse(init4.IsValid());

			// Check static function in specific DLL

			char *DdkReadImage(char *pPath, DWORD *pSize);

			TEST_FIND_FUNCTION(read1, char *, "ddk!DdkReadImage", (char *pPath, DWORD *pSize));

			Assert::IsTrue(read1.IsValid());

			// Check function in specific DLL with suffix

			TEST_FIND_FUNCTION(init5, void, "ddk.dll!DdkThreadInit", ());
			TEST_FIND_FUNCTION(init6, void, "dxk.dll!DdkThreadInit", ());

			Assert::IsTrue(init1.GetPointer() == init5.GetPointer());
			Assert::IsFalse(init6.IsValid());
		}

		TEST_METHOD(DdkDetoursFindMethod)
		{
			TestDetourClass test(10);

			// Method in current DLL

			TEST_FIND_METHOD(incr1, TestDetourClass, LONG, &TestDetourClass::Increment, (LONG arg));
			TEST_FIND_METHOD(incr2, TestDetourClass, LONG,
				"DdkUnitTest::TestDetourClass::Increment", (LONG arg));

			Assert::IsTrue(incr1.GetPointer() == incr2.GetPointer());
			Assert::IsTrue(incr1 == &TestDetourClass::Increment);

			// Check method can be called

			LONG u1 = test.Increment(1);
			LONG u2 = (&test->*incr1)(2);

			Assert::IsTrue(u2 == u1 + 1);

			// Using pointer object

			TEST_FIND_METHOD(incr3, TestDetourClass, LONG, incr1, (LONG arg));
			TEST_FIND_METHOD(incr4, TestDetourClass, LONG, incr2, (LONG arg));

			Assert::IsTrue(incr1.GetPointer() == incr3.GetPointer());
			Assert::IsTrue(incr1.GetPointer() == incr4.GetPointer());
		}

		TEST_METHOD(DdkDetoursFindVariable)
		{
			// Variable in current DLL

			TEST_FIND_VARIABLE(var1, LONG, &TestDetoursVar);
			TEST_FIND_VARIABLE(var2, LONG, "DdkUnitTest::TestDetoursVar");

			Assert::IsTrue(var1.GetPointer() == var2.GetPointer());
			Assert::IsTrue(var1.GetPointer() == &TestDetoursVar);

			// Variable in DDK DLL

			TEST_FIND_VARIABLE(var3, CCHAR *, "ddk!KeNumberProcessors");

			Assert::IsTrue(var3.GetPointer() != NULL);

			// Static variable in DDK DLL

			TEST_FIND_VARIABLE(var4, char *, "ddk!cleanupname");

			Assert::IsTrue(var4.GetPointer() != NULL);
		}

		TEST_METHOD(DdkDetoursAttachFunction)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Attach with Using
			{
				TEST_USING_MOCK(function1);
				Assert::IsTrue(TestDetourFunction(1) == 0x102);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Attach a different mock
			{
				TEST_USING_MOCK(function2);
				Assert::IsTrue(TestDetourFunction(1) == 0x202);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);

			TEST_DEFINE_MOCK_FUNCTION(function3, LONG, &TestDetourFunction, (LONG arg)) {
				return TEST_REAL_FUNCTION(arg) + 0x300;
			} TEST_END_MOCK;

			// Test attaching mock with local scope
			{
				TEST_USING_MOCK(function3);
				Assert::IsTrue(TestDetourFunction(1) == 0x302);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD(DdkDetoursAttachMethod)
		{
			TestDetourClass test(10);

			Assert::IsTrue(test.Increment(1) == 2);

			// Attach with Using
			{
				TEST_USING_MOCK(method1);
				Assert::IsTrue(test.Increment(1) == 0x102);
			}

			Assert::IsTrue(test.Increment(1) == 2);

			// Attach a different mock
			{
				TEST_USING_MOCK(method2);
				Assert::IsTrue(test.Increment(1) == 0x202);
			}

			Assert::IsTrue(test.Increment(1) == 2);

			// Test attaching mock with local scope

			TEST_DEFINE_MOCK_METHOD(method3, TestDetourClass, LONG, &TestDetourClass::Increment, (LONG arg)) {
				return TEST_REAL_METHOD(arg) + 0x300;
			} TEST_END_MOCK;

			{
				TEST_USING_MOCK(method3);
				Assert::IsTrue(test.Increment(1) == 0x302);
			}

			Assert::IsTrue(test.Increment(1) == 2);
		}

		TEST_METHOD(DdkDetoursGlobalEnable)
		{
			// Check mock enabled in constructor

			Assert::IsTrue(TestDetourFunction3(1) == 0x904);
		}

		TEST_METHOD(DdkDetoursEnableFunction)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Check Enable and Disable function

			TEST_ENABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);
			TEST_DISABLE_MOCK(function1);

			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD(DdkDetoursEnableMethod)
		{
			TestDetourClass test(10);

			Assert::IsTrue(test.Increment(1) == 2);

			// Check Enable and Disable method

			TEST_ENABLE_MOCK(method1);
			Assert::IsTrue(test.Increment(1) == 0x102);
			TEST_DISABLE_MOCK(method1);

			Assert::IsTrue(test.Increment(1) == 2);
		}

		TEST_METHOD(DdkDetoursDisable)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Disable after Enable

			TEST_ENABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);
			TEST_DISABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Disable due to out of scope
			{
				TEST_USING_MOCK(function1);
				Assert::IsTrue(TestDetourFunction(1) == 0x102);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Disable after Using
			{
				TEST_USING_MOCK(function1);
				Assert::IsTrue(TestDetourFunction(1) == 0x102);

				TEST_DISABLE_MOCK(function1);
				Assert::IsTrue(TestDetourFunction(1) == 2);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Detour function out of scope
			{
				TEST_DEFINE_MOCK_FUNCTION(function8, LONG, &TestDetourFunction, (LONG arg)) {
					return TEST_REAL_FUNCTION(arg) + 0x800;
				} TEST_END_MOCK;

				TEST_ENABLE_MOCK(function8);
				Assert::IsTrue(TestDetourFunction(1) == 0x802);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD(DdkDetoursAttachRepeatedly)
		{
			// Multiple Attach and Detach sequences

			for (int i = 0; i < 100; i++) {
				Assert::IsTrue(TestDetourFunction(1) == 2);
				TEST_USING_MOCK(function1);
				Assert::IsTrue(TestDetourFunction(1) == 0x102);
			}
		}

		TEST_METHOD_ASYNC(DdkDetoursAsyncThread)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Use different mock on another thread
			{
				TEST_USING_MOCK(function2);
				Assert::IsTrue(TestDetourFunction(1) == 0x202);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD(DdkDetoursAttachThread)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			TEST_ENABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);

			// Start thread to use different mock

			TEST_ASYNC_START(id, DdkDetoursAsyncThread);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);

			TEST_DISABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD_ASYNC(DdkDetoursAsyncMultiple)
		{
			static volatile LONG count = 0;

			TEST_DEFINE_MOCK_FUNCTION(function3, LONG, &TestDetourFunction, (LONG arg)) {
				return TEST_REAL_FUNCTION(arg) + 0x300;
			} TEST_END_MOCK;

			Assert::IsTrue(TestDetourFunction(1) == 2);

			// Alternate between mocks on different threads

			if (InterlockedIncrement(&count) & 1) {
				TEST_USING_MOCK(function2);
				Assert::IsTrue(TestDetourFunction(1) == 0x202);
			} else {
				TEST_USING_MOCK(function3);
				Assert::IsTrue(TestDetourFunction(1) == 0x302);
			}

			Assert::IsTrue(TestDetourFunction(1) == 2);
		}

		TEST_METHOD(DdkDetoursAttachMultiple)
		{
			Assert::IsTrue(TestDetourFunction(1) == 2);

			TEST_ENABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);

			// Start multiple threads using different mocks

			TEST_ASYNC_START_VEC(id, DdkDetoursAsyncMultiple, 100);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);
			TEST_ASYNC_WAIT_VEC(id);
			Assert::IsTrue(TestDetourFunction(1) == 0x102);

			TEST_DISABLE_MOCK(function1);
			Assert::IsTrue(TestDetourFunction(1) == 2);
		}


		TEST_METHOD_ASYNC(DdkDetoursAsyncAllThreads)
		{
			TEST_DEFINE_MOCK_FUNCTION(function4, LONG, &TestDetourFunction2, (LONG arg)) {
				return TEST_REAL_FUNCTION(arg) + 0x400;
			} TEST_END_MOCK;

			Assert::IsTrue(TestDetourFunction2(1) == 0x503);

			// Attach mock for thread with global mock active
			{
				TEST_USING_MOCK(function4);
				Assert::IsTrue(TestDetourFunction2(1) == 0x403);
			}

			Assert::IsTrue(TestDetourFunction2(1) == 0x503);
		}

		TEST_METHOD(DdkDetoursAttachAllThreads)
		{
			TEST_DEFINE_MOCK_FUNCTION(function5, LONG, &TestDetourFunction2, (LONG arg)) {
				return TEST_REAL_FUNCTION(arg) + 0x500;
			} TEST_END_MOCK;

			Assert::IsTrue(TestDetourFunction2(1) == 3);

			// Attach global mock and start thread to use different mock
			{
				TEST_USING_MOCK(function5, TEST_ALL_THREADS);
				Assert::IsTrue(TestDetourFunction2(1) == 0x503);

				TEST_ASYNC_START(id, DdkDetoursAsyncAllThreads);
				Assert::IsTrue(TestDetourFunction2(1) == 0x503);
				TEST_ASYNC_WAIT(id);
				Assert::IsTrue(TestDetourFunction2(1) == 0x503);
			}

			Assert::IsTrue(TestDetourFunction2(1) == 3);
		}

		TEST_METHOD(DdkDetoursDetachAddressRange)
		{
			TEST_DEFINE_MOCK_FUNCTION(function, LONG, &TestDetourFunction4, (LONG arg)) {
				return TEST_REAL_FUNCTION(arg) + 0x100;
			} TEST_END_MOCK;

			TEST_FIND_FUNCTION(DetachAddressRange, NTSTATUS, "ddk!DdkDetachAddressRange",
				(PVOID pAddr, size_t len, HMODULE module));

			Assert::IsTrue(TestDetourFunction4(1) == 5);

			TEST_ENABLE_MOCK(function);
			Assert::IsTrue(TestDetourFunction4(1) == 0x105);

			// Detach function without mock

			NTSTATUS status = DetachAddressRange(&TestDetourFunction5, 1, NULL);
			Assert::IsTrue(NT_SUCCESS(status));
			Assert::IsTrue(TestDetourFunction4(1) == 0x105);

			// Detach function with mock

			status = DetachAddressRange(&TestDetourFunction4, 1, NULL);
			Assert::IsTrue(NT_SUCCESS(status));
			Assert::IsTrue(TestDetourFunction4(1) == 5);
		}

		static __declspec(noinline) LONG TestDetourFunction9(LONG arg0, LONG arg1, LONG arg2,
				LONG arg3, LONG arg4, LONG arg5, LONG arg6, LONG arg7, LONG arg8, LONG arg9) {
			return DoWork(), arg0 + arg1 + arg2 + arg3 + arg4 + arg5 + arg6 + arg7 + arg8 + arg9;
		}

		TEST_METHOD(DdkDetoursMultipleArgs)
		{
			TEST_DEFINE_MOCK_FUNCTION(function, LONG, &TestDetourFunction9,
					(LONG arg0, LONG arg1, LONG arg2, LONG arg3, LONG arg4,
					LONG arg5, LONG arg6, LONG arg7, LONG arg8, LONG arg9)) {
				return TEST_REAL_FUNCTION(arg0,arg1,arg2,arg3,arg4,
					arg5,arg6,arg7,arg8,arg9) + 0x500;
			} TEST_END_MOCK;

			Assert::AreEqual(55L, TestDetourFunction9(1,2,3,4,5,6,7,8,9,10));

			// Check arguments are preserved by mock
			{
				TEST_USING_MOCK(function);
				Assert::AreEqual(0x500 + 55L, TestDetourFunction9(1,2,3,4,5,6,7,8,9,10));
			}
		}
	};
}

```

`test/DeviceTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Device Tests
 */

#include "stdafx.h"
#include "initguid.h"


namespace DdkUnitTest
{
	DEFINE_GUID(DEVICE_TEST_GUID, 0x60b01b68, 0x7d9b, 0x413f, 0x8f, 0xc0, 0xfe, 0x4e, 0x75, 0x31, 0xd0, 0x80);

	TEST_CLASS(DdkDeviceTest)
	{
		PDRIVER_OBJECT pDriver;
		PDEVICE_OBJECT pDevice;
		PFILE_OBJECT pFile;
		UNICODE_STRING u;
		UNICODE_STRING symLinkName;
		PWSTR symLinkList;
		
		char DriverName[100];
		wchar_t DeviceName[100];

		static NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
		{
			DdkDeviceTest *pTest = (DdkDeviceTest *)_wtoll(&DriverObject->DriverName.Buffer[3]);
			pTest->pDriver = DriverObject;
			return STATUS_SUCCESS;
		}

	public:

		TEST_METHOD_INITIALIZE(DdkDeviceTestInit)
		{
			DdkThreadInit();

			sprintf(DriverName, "DRV%I64d:%d", (LONGLONG)this, GetUniqueId());
			swprintf(DeviceName, L"\\Device\\D%I64d:%d", (LONGLONG)this, GetUniqueId());

			pDriver = 0;
			pDevice = 0;
			pFile = 0;
			RtlInitUnicodeString(&u, DeviceName);
			RtlInitUnicodeString(&symLinkName, NULL);
			symLinkList = NULL;

			NTSTATUS rc = DdkInitDriver(DriverName, DriverEntry);

			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsNotNull(pDriver);
		}

		TEST_METHOD_CLEANUP(DdkDeviceTestCleanup)
		{
			if (pFile) ObDereferenceObject(pFile);
			if (pDevice) IoDeleteDevice(pDevice);
			if (pDriver) DdkUnloadDriver(DriverName);

			RtlFreeUnicodeString(&symLinkName);
			if (symLinkList) ExFreePool(symLinkList);
		}

		TEST_METHOD(DdkDeviceCreate)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);
		}

		TEST_METHOD(DdkDeviceCreateExists)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsNotNull(pDevice);

			rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(rc == STATUS_OBJECT_NAME_EXISTS);
		}

		TEST_METHOD(DdkDeviceCreateAutoGen)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, NULL, FILE_DEVICE_DISK,
				FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &pDevice);

			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD(DdkDeviceCreateNoName)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, NULL, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD(DdkDeviceGetObjectPointer)
		{
			DEVICE_OBJECT *pDevice2;

			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoGetDeviceObjectPointer(&u, 0, &pFile, &pDevice2);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice2);

			Assert::IsTrue(pDevice == pDevice2);
			Assert::IsTrue(pFile->DeviceObject == pDevice);
		}

		TEST_METHOD(DdkDeviceRegisterInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));
		}

		TEST_METHOD(DdkDeviceReRegisterInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			RtlFreeUnicodeString(&symLinkName);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(STATUS_OBJECT_NAME_EXISTS == rc);
		}

		TEST_METHOD(DdkDeviceEnableInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, TRUE);
			Assert::IsTrue(NT_SUCCESS(rc));
		}

		TEST_METHOD(DdkDeviceReEnableInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, TRUE);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, TRUE);
			Assert::IsTrue(STATUS_OBJECT_NAME_EXISTS == rc);
		}

		TEST_METHOD(DdkDeviceDisableNewInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, FALSE);
			Assert::IsTrue(STATUS_OBJECT_NAME_NOT_FOUND == rc);
		}

		TEST_METHOD(DdkDeviceDisableInterface)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, TRUE);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, FALSE);
			Assert::IsTrue(NT_SUCCESS(rc));
		}

		TEST_METHOD(DdkDeviceGetInterfaces)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoSetDeviceInterfaceState(&symLinkName, TRUE);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, 0, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(RtlCompareUnicodeStrings(symLinkName.Buffer, symLinkName.Length, symLinkList, symLinkName.Length, FALSE) == 0);

			ExFreePool(symLinkList);
			symLinkList = NULL;

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(RtlCompareUnicodeStrings(symLinkName.Buffer, symLinkName.Length, symLinkList, symLinkName.Length, FALSE) == 0);
		}

		TEST_METHOD(DdkDeviceGetInterfacesNull)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, 0, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(UNICODE_NULL == *symLinkList);
		}

		TEST_METHOD(DdkDeviceGetInterfacesDisabled)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, 0, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(UNICODE_NULL == *symLinkList);

			ExFreePool(symLinkList);
			symLinkList = NULL;

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, DEVICE_INTERFACE_INCLUDE_NONACTIVE, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(RtlCompareUnicodeStrings(symLinkName.Buffer, symLinkName.Length, symLinkList, symLinkName.Length, FALSE) == 0);
		}

		TEST_METHOD(DdkDeviceGetInterfacesDeleted)
		{
			NTSTATUS rc = IoCreateDevice(pDriver, 200, &u, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);

			rc = IoRegisterDeviceInterface(pDevice, &DEVICE_TEST_GUID, NULL, &symLinkName);
			Assert::IsTrue(NT_SUCCESS(rc));

			IoDeleteDevice(pDevice);
			pDevice = NULL;

			rc = IoGetDeviceInterfaces(&DEVICE_TEST_GUID, pDevice, 0, &symLinkList);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(UNICODE_NULL == *symLinkList);
		}
	};
}

```

`test/DpcTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	DPC Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkDpcTest)
	{
		KDPC dpc;
		KDPC dpcthreaded;
		LONG count;
		LONG threaded;

	public:
		TEST_METHOD_INITIALIZE(DdkDpcTestInit)
		{
			DdkThreadInit();
			count = 0;
			threaded = 0;
			KeInitializeDpc(&dpc, DdkDpcProc, 0);
			KeInitializeThreadedDpc(&dpcthreaded, DdkDpcProcThreaded, 0);
		}

		TEST_METHOD_CLEANUP(DdkDpcTestCleanup)
		{
			KeFlushQueuedDpcs();
		}

		TEST_METHOD_CALLBACK(DdkDpcProc, PRKDPC Dpc,
			PVOID DeferredContext, PVOID Context, PVOID Arg2)
		{
			count++;
		}

		TEST_METHOD_CALLBACK(DdkDpcProcThreaded, PRKDPC Dpc,
			PVOID DeferredContext, PVOID Context, PVOID Arg2)
		{
			threaded++;
		}

		TEST_METHOD(DdkDpcQueue)
		{
			TEST_CALLBACK_INIT(id);
			Assert::IsTrue(KeInsertQueueDpc(&dpc, id, 0) != 0);

			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(count == 1);
		}

		TEST_METHOD(DdkDpcQueueThreaded)
		{
			TEST_CALLBACK_INIT(id);
			Assert::IsTrue(KeInsertQueueDpc(&dpcthreaded, id, 0) != 0);

			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(threaded == 1);
		}

		TEST_METHOD(DdkDpcQueueMany)
		{
			LONG rm = 0, add = 0;

			for (int i = 0; i < 1000; i++) {
				TEST_CALLBACK_INIT(id);

				Assert::IsTrue(KeInsertQueueDpc(&dpc, id, 0) != 0);

				if ((i % 10) == 0 && KeRemoveQueueDpc(&dpc)) {
					TEST_CALLBACK_CANCELLED(id);
					rm++;
				}

				else add++;

				TEST_CALLBACK_WAIT(id);
				Assert::IsTrue(count == add);
			}

			Assert::IsTrue(rm && add);
		}

		TEST_METHOD(DdkDpcFlushQueued)
		{
			TEST_CALLBACK_INIT(id);
			Assert::IsTrue(KeInsertQueueDpc(&dpc, id, 0) != 0);

			KeFlushQueuedDpcs();
			Assert::IsTrue(count == 1);

			TEST_CALLBACK_WAIT(id);
		}
	};
}

```

`test/DriverTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Driver Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkDriverTest)
	{
		PDRIVER_OBJECT pDriver;
		char DriverName[100];
		int unload;

		static void DriverUnload(PDRIVER_OBJECT DriverObject)
		{
			DdkDriverTest *pTest = (DdkDriverTest *)_wtoll(&DriverObject->DriverName.Buffer[3]);
			pTest->pDriver = 0;
			pTest->unload++;
		}

		static NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
		{
			DdkDriverTest *pTest = (DdkDriverTest *)_wtoll(&DriverObject->DriverName.Buffer[3]);
			DriverObject->DriverUnload = DriverUnload;
			pTest->pDriver = DriverObject;
			return STATUS_SUCCESS;
		}

	public:
		TEST_METHOD_INITIALIZE(DdkDriverTestInit)
		{
			DdkThreadInit();
			sprintf(DriverName, "DRV%I64d:%d", (LONGLONG)this, GetUniqueId());

			unload = 0;
			pDriver = 0;
			NTSTATUS rc = DdkInitDriver(DriverName, DriverEntry);

			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD_CLEANUP(DdkDriverTestCleanup)
		{
			if (pDriver) DdkUnloadDriver(DriverName);
		}

	public:
		TEST_METHOD(DdkDriverLoad)
		{
			Assert::IsNotNull(pDriver);
		}

		TEST_METHOD(DdkDriverUnload)
		{
			DdkUnloadDriver(DriverName);
			Assert::IsTrue(unload == 1);
		}
	};
}

```

`test/EventTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Event Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkEventTest)
	{
		LARGE_INTEGER nowait;
		UNICODE_STRING u;
		KEVENT event;
		HANDLE h1;
		HANDLE h2;

		wchar_t EventName[100];

	public:
		TEST_METHOD_INITIALIZE(DdkEventTestInit)
		{
			DdkThreadInit();
			KeInitializeEvent(&event, NotificationEvent, FALSE);
			swprintf(EventName, L"\\BaseNamedObjects\\EVT%I64d:%d", (LONGLONG)this, GetUniqueId());
			RtlInitUnicodeString(&u, EventName);
			nowait.QuadPart = 0;
			h1 = h2 = NULL;
		}

		TEST_METHOD_CLEANUP(DdkEventTestCleanup)
		{
			if (h1) ZwClose(h1);
			if (h1) ZwClose(h2);
		}

		TEST_METHOD(DdkEventInit)
		{
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventInitSet)
		{
			KeInitializeEvent(&event, NotificationEvent, TRUE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventInitSetSync)
		{
			KeInitializeEvent(&event, SynchronizationEvent, TRUE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventSet)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventSetAgain)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventReset)
		{
			Assert::IsTrue(KeResetEvent(&event) == 0);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventResetAgain)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			Assert::IsTrue(KeResetEvent(&event) != 0);
			Assert::IsTrue(KeResetEvent(&event) == 0);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventClear)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			KeClearEvent(&event);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventClearAgain)
		{
			KeClearEvent(&event);
			KeClearEvent(&event);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventReadState)
		{
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventReadStateSet)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventReadStateSetSync)
		{
			KeInitializeEvent(&event, SynchronizationEvent, TRUE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventWait)
		{
			NTSTATUS rc = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_TIMEOUT);
		}

		TEST_METHOD(DdkEventWaitSet)
		{
			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			NTSTATUS rc = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateEvent(&event) == TRUE);
		}

		TEST_METHOD(DdkEventWaitSetSync)
		{
			KeInitializeEvent(&event, SynchronizationEvent, TRUE);
			NTSTATUS rc = KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateEvent(&event) == FALSE);
		}

		TEST_METHOD(DdkEventCreate)
		{
			PKEVENT pEvent = IoCreateSynchronizationEvent(&u, &h1);
			Assert::IsNotNull(pEvent);
			Assert::IsNotNull(h1);
			Assert::IsTrue(KeReadStateEvent(pEvent) != 0);
		}

		TEST_METHOD(DdkEventCreateOpen)
		{
			PKEVENT pEvent = IoCreateNotificationEvent(&u, &h1);
			Assert::IsNotNull(pEvent);

			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);

			PKEVENT pEvent2 = IoCreateNotificationEvent(&u, &h2);
			Assert::IsNotNull(pEvent2);
			Assert::IsTrue(KeReadStateEvent(pEvent2) != 0);
		}

		TEST_METHOD(DdkEventCloseReset)
		{
			PKEVENT pEvent = IoCreateSynchronizationEvent(&u, &h1);
			Assert::IsNotNull(pEvent);

			KeSetEvent(&event, IO_NO_INCREMENT, FALSE);
			ZwClose(h1);
			h1 = 0;

			PKEVENT pEvent2 = IoCreateSynchronizationEvent(&u, &h2);
			Assert::IsNotNull(pEvent2);
			Assert::IsTrue(KeReadStateEvent(pEvent2) != 0);
		}

		TEST_METHOD(DdkEventCreateWait)
		{
			PKEVENT pEvent = IoCreateSynchronizationEvent(&u, &h1);
			Assert::IsNotNull(pEvent);

			KeClearEvent(pEvent);

			NTSTATUS rc = KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_TIMEOUT);
		}

		TEST_METHOD(DdkEventCreateWaitSet)
		{
			PKEVENT pEvent = IoCreateSynchronizationEvent(&u, &h1);
			Assert::IsNotNull(pEvent);

			NTSTATUS rc = KeWaitForSingleObject(pEvent, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateEvent(pEvent) == FALSE);
		}
	};
}

```

`test/FileTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	File Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkFileTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkFileTestInit)
		{
			DdkThreadInit();
		}

		/*
		 *	Check ZwCreateFile with FILE_CREATE
		 */
		TEST_METHOD(DdkFileZwCreateCreate)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test101.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_CREATE for directory
		 */
		TEST_METHOD(DdkFileZwCreateCreateDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test151");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_CREATE and file exists
		 */
		TEST_METHOD(DdkFileZwCreateCreateExists)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test102.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_COLLISION, status);
			Assert::IsTrue(h == NULL);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}
		/*
		 *	Check ZwCreateFile with FILE_CREATE and directory exists
		 */
		TEST_METHOD(DdkFileZwCreateCreateExistsDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test152");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_COLLISION, status);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN
		 */
		TEST_METHOD(DdkFileZwCreateOpen)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test201.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN for directory
		 */
		TEST_METHOD(DdkFileZwCreateOpenDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test251");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN and doesn't exist
		 */
		TEST_METHOD(DdkFileZwCreateOpenNonExistant)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test202.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((ULONG_PTR)FILE_DOES_NOT_EXIST, iostat.Information);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN and directory doesn't exist
		 */
		TEST_METHOD(DdkFileZwCreateOpenNonExistantDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test252");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((ULONG_PTR)FILE_DOES_NOT_EXIST, iostat.Information);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN_IF
		 */
		TEST_METHOD(DdkFileZwCreateOpenIf)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test301.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN_IF for directory
		 */
		TEST_METHOD(DdkFileZwCreateOpenIfDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test351");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN_IF and file exists
		 */
		TEST_METHOD(DdkFileZwCreateOpenIfExists)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test302.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateFile with FILE_OPEN_IF and directory exists
		 */
		TEST_METHOD(DdkFileZwCreateOpenIfExistsDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test352");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN_IF,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenFile
		 */
		TEST_METHOD(DdkFileZwOpen)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1101.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwOpenFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, 0, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenFile for directory
		 */
		TEST_METHOD(DdkFileZwOpenDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1151");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwOpenFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, 0, FILE_DIRECTORY_FILE);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenFile non-existant file
		 */
		TEST_METHOD(DdkFileZwOpenNonExistant)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1102.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwOpenFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, 0, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwOpenFile non-existant directory
		 */
		TEST_METHOD(DdkFileZwOpenNonExistantDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1152");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwOpenFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, 0, FILE_DIRECTORY_FILE);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwDeleteFile
		 */
		TEST_METHOD(DdkFileZwDelete)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test901.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::IsTrue(h == NULL);
		}

		/*
		 *	Check ZwWriteFile
		 */
		TEST_METHOD(DdkFileZwWrite)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1001.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwWriteFile with multiple writes
		 */
		TEST_METHOD(DdkFileZwWriteMultiple)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1002.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			ULONG total = 0;

			for (ULONG i = strlen(buffer); i > 0; total += i--) {
				status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, i, NULL, NULL);
				Assert::AreEqual(STATUS_SUCCESS, status);
				Assert::AreEqual((ULONG_PTR)i, iostat.Information);
			}

			FILE_POSITION_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FilePositionInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::AreEqual((__int64)total, info.CurrentByteOffset.QuadPart);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwWriteFile with overlapping 
		 */
		TEST_METHOD(DdkFileZwWriteOverlap)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1003.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			ULONG total = 0;

			for (ULONG i = strlen(buffer); i > 0; i--) {
				if (total) total -= (i - 1);

				LARGE_INTEGER offset;
				offset.QuadPart = total;
				status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer,
					strlen(buffer), &offset, NULL);

				Assert::AreEqual(STATUS_SUCCESS, status);
				Assert::AreEqual((ULONG_PTR)strlen(buffer), iostat.Information);
				total += strlen(buffer);
			}

			FILE_POSITION_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FilePositionInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::AreEqual((__int64)total, info.CurrentByteOffset.QuadPart);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwWriteFile with APC completion 
		 */
		static void ZwWriteApc(void *pContext, IO_STATUS_BLOCK *ios, ULONG)
		{
			Assert::AreEqual(STATUS_SUCCESS, ios->Status);
			Assert::AreEqual((ULONG_PTR)pContext, ios->Information);
			ios->Information = (ULONG_PTR)ZwWriteApc;
		}

		TEST_METHOD(DdkFileZwWriteApc)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1001.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, ZwWriteApc, (PVOID)strlen(buffer),
				&iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::IsTrue(NT_SUCCESS(status));
			while (iostat.Information != (ULONG_PTR)ZwWriteApc) Sleep(1);
			Assert::IsTrue(NT_SUCCESS(iostat.Status));

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwReadFile
		 */
		TEST_METHOD(DdkFileZwRead)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test2001.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char buf[200];
			status = ZwReadFile(h, NULL, NULL, NULL, &iostat, buf, sizeof(buf), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);
			Assert::IsTrue(memcmp(buffer, buf, strlen(buffer)) == 0);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwReadFile with multiple reads
		 */
		TEST_METHOD(DdkFileZwReadMultiple)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test2002.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char buf[200];

			for (ULONG i = 0; i < strlen(buffer); i++) {
				status = ZwReadFile(h, NULL, NULL, NULL, &iostat, buf + i, 1, NULL, NULL);
				Assert::AreEqual(STATUS_SUCCESS, status);
				Assert::AreEqual((ULONG_PTR)1, iostat.Information);
			}

			status = ZwReadFile(h, NULL, NULL, NULL, &iostat,
				buf + strlen(buffer), 1, NULL, NULL);
			Assert::AreNotEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)0, iostat.Information);

			Assert::IsTrue(memcmp(buffer, buf, strlen(buffer)) == 0);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwReadFile with overlap
		 */
		TEST_METHOD(DdkFileZwReadOverlap)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test2003.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char buf[200];

			for (ULONG i = 0; i < strlen(buffer); i++) {
				LARGE_INTEGER offset;
				offset.QuadPart = i;
				status = ZwReadFile(h, NULL, NULL, NULL, &iostat, buf + i, 5, &offset, NULL);
				Assert::AreEqual(STATUS_SUCCESS, status);
				Assert::AreEqual((ULONG_PTR)(min(5,strlen(buffer) - i)), iostat.Information);
			}

			status = ZwReadFile(h, NULL, NULL, NULL, &iostat,
				buf + strlen(buffer), 1, NULL, NULL);
			Assert::AreNotEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)0, iostat.Information);

			Assert::IsTrue(memcmp(buffer, buf, strlen(buffer)) == 0);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwReadFile with APC completion
		 */
		static void ZwReadApc(void *pContext, IO_STATUS_BLOCK *ios, ULONG)
		{
			Assert::AreEqual(STATUS_SUCCESS, ios->Status);
			Assert::AreEqual((ULONG_PTR)pContext, ios->Information);
			ios->Information = (ULONG_PTR)ZwReadApc;
		}

		TEST_METHOD(DdkFileZwReadApc)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test2004.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_OPEN,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_OPENED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char buf[200];
			status = ZwReadFile(h, NULL, ZwReadApc, (PVOID)strlen(buffer),
				&iostat, buf, sizeof(buf), NULL, NULL);

			Assert::IsTrue(NT_SUCCESS(status));
			while (iostat.Information != (ULONG_PTR)ZwReadApc) Sleep(1);
			Assert::IsTrue(NT_SUCCESS(iostat.Status));

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwFlushBuffersFile
		 */
		TEST_METHOD(DdkFileZwFlush)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1601.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			status = ZwFlushBuffersFile(h, &iostat);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryInformationFile basic
		 */
		TEST_METHOD(DdkFileZwQueryInfoBasic)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1701.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			FILE_BASIC_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FileBasicInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::IsTrue(info.LastWriteTime.QuadPart >= info.CreationTime.QuadPart);
			Assert::IsTrue(info.LastAccessTime.QuadPart >= info.CreationTime.QuadPart);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryInformationFile basic for directory
		 */
		TEST_METHOD(DdkFileZwQueryInfoBasicDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1751");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			FILE_BASIC_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FileBasicInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::IsTrue(info.LastWriteTime.QuadPart >= info.CreationTime.QuadPart);
			Assert::IsTrue(info.LastAccessTime.QuadPart >= info.CreationTime.QuadPart);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryInformationFile standard
		 */
		TEST_METHOD(DdkFileZwQueryInfoStandard)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1702.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			FILE_STANDARD_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FileStandardInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::IsTrue(info.EndOfFile.QuadPart == strlen(buffer));
			Assert::AreEqual((ULONG)1, info.NumberOfLinks);
			Assert::IsFalse(info.DeletePending);
			Assert::IsFalse(info.Directory);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryInformationFile standard for directory
		 */
		TEST_METHOD(DdkFileZwQueryInfoStandardDirectory)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1752");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			FILE_STANDARD_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FileStandardInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::AreEqual((ULONG)1, info.NumberOfLinks);
			Assert::IsFalse(info.DeletePending);
			Assert::IsTrue(info.Directory);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryInformationFile position
		 */
		TEST_METHOD(DdkFileZwQueryInfoPosition)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test1703.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			HANDLE h = NULL;
			NTSTATUS status = ZwCreateFile(&h, GENERIC_READ | GENERIC_WRITE,
				&attr, &iostat, NULL, FILE_ATTRIBUTE_NORMAL, 0, FILE_CREATE,
				FILE_NON_DIRECTORY_FILE, NULL, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG_PTR)FILE_CREATED, iostat.Information);
			Assert::IsTrue(h != NULL);

			char *buffer = "This is a test message\r\n";
			status = ZwWriteFile(h, NULL, NULL, NULL, &iostat, buffer, strlen(buffer), NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(strlen(buffer), iostat.Information);

			FILE_POSITION_INFORMATION info;
			status = ZwQueryInformationFile(h, &iostat, &info,
				(ULONG)sizeof(info), FilePositionInformation);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(sizeof(info), iostat.Information);
			Assert::IsTrue(info.CurrentByteOffset.QuadPart == strlen(buffer));

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwDeleteFile with non-existant file
		 */
		TEST_METHOD(DdkFileZwDeleteNonExistant)
		{
			OBJECT_ATTRIBUTES attr;
			IO_STATUS_BLOCK iostat;
			UNICODE_STRING u;

			RtlInitUnicodeString(&u, L"\\??\\C:\\Test\\Test902.txt");

			InitializeObjectAttributes(&attr, &u,
				(OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE), NULL, NULL);

			NTSTATUS status = ZwDeleteFile(&attr);
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}
	};
}

```

`test/HeaderTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	DDK Header Tests
 */

#include "stdafx.h"
#include <ntifs.h>
#include <wmilib.h>


namespace DdkUnitTest
{
	size_t _SizeofCriticalSection_ = sizeof(CRITICAL_SECTION);

	TEST_CLASS(DdkHeaderTest)
	{
	public:
		
		TEST_METHOD(DdkHeader)
		{
			Assert::IsTrue(true);
		}
	};
}

```

`test/InlineTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Inline Tests
 */

#define _DDKINLINE_

#undef NTDDI_VERSION
#define NTDDI_VERSION NTDDI_WIN7
#define NT_INLINE_IRQL
#define NT_INLINE_GET_CURRENT_IRQL

#define KeGetCurrentThread DdkUnitTest_KeGetCurrentThread
#define PsGetCurrentThread DdkUnitTest_PsGetCurrentThread
#define KeGetCurrentIrql DdkUnitTest_KeGetCurrentIrql
#define KzLowerIrql DdkUnitTest_KzLowerIrql
#define KzRaiseIrql DdkUnitTest_KzRaiseIrql

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkInlineTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkInlineTestInit)
		{
			DdkThreadInit();
		}

		TEST_METHOD_CLEANUP(DdkInlineTestCleanup)
		{
			KeLowerIrql(PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkInlineIrql)
		{
			KIRQL irql = KeGetCurrentIrql();
			Assert::IsTrue(irql == PASSIVE_LEVEL);

			KeRaiseIrql(DISPATCH_LEVEL, &irql);
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);

			KeLowerIrql(PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkInlineThread)
		{
			PKTHREAD Thread = KeGetCurrentThread();
			Assert::IsTrue(PsIsSystemThread(Thread) == TRUE);
		}

		TEST_METHOD(DdkInlineTickCount)
		{
			for (int i = 0; true; i++) {
				ULONGLONG x = GetTickCount64(), v;

				KeQueryTickCount(&v);
				v = (v * KeQueryTimeIncrement()) / 10000;

				if (x == v) break;
				Assert::IsTrue(i < 10);
			}
		}
	};
}

```

`test/IrpTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	IRP Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkIrpTest)
	{
		IRP *pIrp;

	public:
		TEST_METHOD_INITIALIZE(DdkIrpTestInit)
		{
			DdkThreadInit();
		}

		TEST_METHOD_CLEANUP(DdkIrpTestCleanup)
		{
			if (pIrp) IoFreeIrp(pIrp);
		}

		TEST_METHOD(DdkIrpAllocate)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);
		}

		TEST_METHOD(DdkIrpFree)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);
			IoFreeIrp(pIrp);
			pIrp = 0;
		}

		TEST_METHOD(DdkIrpStackZero)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);

			IO_STACK_LOCATION *pStack = IoGetNextIrpStackLocation(pIrp);
			Assert::IsTrue(pStack->MajorFunction == 0);
			Assert::IsTrue(pStack->Context == 0);
		}

		TEST_METHOD(DdkIrpStackNext)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);

			IO_STACK_LOCATION *pStack = IoGetNextIrpStackLocation(pIrp);
			IoSetNextIrpStackLocation(pIrp);

			Assert::IsFalse(IoGetNextIrpStackLocation(pIrp) == pStack);
			Assert::IsTrue(IoGetCurrentIrpStackLocation(pIrp) == pStack);
		}

		TEST_METHOD(DdkIrpStackCopyNext)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);

			IO_STACK_LOCATION *pStack = IoGetNextIrpStackLocation(pIrp);
			pStack->MajorFunction = IRP_MJ_CREATE;

			IoSetNextIrpStackLocation(pIrp);
			IoCopyCurrentIrpStackLocationToNext(pIrp);
			pStack = IoGetNextIrpStackLocation(pIrp);

			Assert::IsTrue(pStack->MajorFunction == IRP_MJ_CREATE);
		}
	};
}

```

`test/IrqlTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	IRQL Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkIrqlTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkIrqlInit) 
		{
			DdkThreadInit();
			KeLowerIrql(PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD_CLEANUP(DdkIrqlTestCleanup)
		{
			KeLowerIrql(PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkIrqlRaise)
		{
			KIRQL irql;
			KeRaiseIrql(DISPATCH_LEVEL, &irql);
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
		}

		TEST_METHOD(DdkIrqlRaiseToDpc)
		{
			KIRQL irql = KeRaiseIrqlToDpcLevel();
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
		}	

		TEST_METHOD(DdkIrqlLower)
		{
			KIRQL irql;
			KeRaiseIrql(DISPATCH_LEVEL, &irql);
			KeLowerIrql(PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD_ASYNC(DdkIrqlAsync)
		{
			KIRQL lo = (TEST_IS_ASYNC) ? APC_LEVEL : PASSIVE_LEVEL;
			KIRQL hi = (TEST_IS_ASYNC) ? HIGH_LEVEL : DISPATCH_LEVEL;
			KIRQL irql;

			KeLowerIrql(PASSIVE_LEVEL);
			KeRaiseIrql(lo, &irql);

			for (int i = 0; i < 100000; i++) {
				irql = KeGetCurrentIrql();
				Assert::IsTrue(irql == ((i & 1) ? hi : lo));
				if (i & 1) KeLowerIrql(lo);
				else KeRaiseIrql(hi, &irql);
			}

			KeLowerIrql(PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkIrqlMulti)
		{
			TEST_ASYNC_START(id, DdkIrqlAsync);
			DdkIrqlAsync();
			TEST_ASYNC_WAIT(id);
		}
	};
}

```

`test/MdlTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	MDL Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkMdlTest)
	{
		MDL *pMdl;
		MDL *pMdl2;
		IRP *pIrp;

	public:
		TEST_METHOD_INITIALIZE(DdkMdlInit)
		{
			DdkThreadInit();
			pMdl = pMdl2 = 0;
			pIrp = 0;
		}

		TEST_METHOD_CLEANUP(DdkMdlCleanup)
		{
			if (pMdl) IoFreeMdl(pMdl);
			if (pMdl2) IoFreeMdl(pMdl2);
			if (pIrp) IoFreeIrp(pIrp);
		}
		
		TEST_METHOD(DdkMdlSize)
		{
			SIZE_T base = sizeof(MDL);
			Assert::IsTrue(MmSizeOfMdl(0, 0) == base);
			Assert::IsTrue(MmSizeOfMdl(0, 1) == base + sizeof(PFN_NUMBER));
			Assert::IsTrue(MmSizeOfMdl((PVOID)(PAGE_SIZE-1), 2) == base + sizeof(PFN_NUMBER) * 2);
		}

		TEST_METHOD(DdkMdlAllocate)
		{
			pMdl = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			Assert::IsNotNull(pMdl);
			Assert::IsTrue(MmGetMdlByteOffset(pMdl) == 1);
			Assert::IsTrue(MmGetMdlByteCount(pMdl) == PAGE_SIZE*3);
			Assert::IsTrue(MmGetMdlVirtualAddress(pMdl) == (PVOID)1);
			Assert::IsTrue(pMdl->MdlFlags == 0);
		}

		TEST_METHOD(DdkMdlFree)
		{
			pMdl = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			Assert::IsNotNull(pMdl);
			IoFreeMdl(pMdl);
			pMdl = 0;
		}

		TEST_METHOD(DdkMdlProbeAndLock)
		{
			pMdl = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			Assert::IsNotNull(pMdl);

			MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);

			for (int i = 0; i < 4; i++)
				Assert::IsTrue(MmGetMdlPfnArray(pMdl)[i] == i);
		}

		TEST_METHOD(DdkMdlBuildPartial)
		{
			pMdl = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			pMdl2 = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			Assert::IsNotNull(pMdl);
			Assert::IsNotNull(pMdl2);

			MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);
			IoBuildPartialMdl(pMdl, pMdl2, (PVOID)100, 0);

			Assert::IsTrue(MmGetMdlByteOffset(pMdl2) == 100);
			Assert::IsTrue(MmGetMdlByteCount(pMdl2) == PAGE_SIZE*3-99);
			Assert::IsTrue(MmGetMdlVirtualAddress(pMdl2) == (PVOID)100);

			for (int i = 0; i < 4; i++)
				Assert::IsTrue(MmGetMdlPfnArray(pMdl2)[i] == i);
		}

		TEST_METHOD(DdkMdlPrepareReuse)
		{
			pMdl = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			pMdl2 = IoAllocateMdl((PVOID)1, PAGE_SIZE*3, FALSE, FALSE, NULL);
			Assert::IsNotNull(pMdl);
			Assert::IsNotNull(pMdl2);

			MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);
			IoBuildPartialMdl(pMdl, pMdl2, (PVOID)100, 0);
			MmPrepareMdlForReuse(pMdl2);
		}

		TEST_METHOD(DdkMdlAttachIrp)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);

			pMdl = IoAllocateMdl((PVOID)4095, PAGE_SIZE*3, FALSE, FALSE, pIrp);
			Assert::IsNotNull(pMdl);
			Assert::IsTrue(pIrp->MdlAddress == pMdl);
		}

		TEST_METHOD(DdkMdlAttachIrpSecondary)
		{
			pIrp = IoAllocateIrp(3, FALSE);
			Assert::IsNotNull(pIrp);
			pMdl = IoAllocateMdl((PVOID)4095, PAGE_SIZE*3, FALSE, FALSE, pIrp);
			Assert::IsNotNull(pMdl);

			pMdl2 = IoAllocateMdl((PVOID)40960, PAGE_SIZE, TRUE, FALSE, pIrp);
			Assert::IsNotNull(pMdl2);
			Assert::IsTrue(pIrp->MdlAddress == pMdl);
			Assert::IsTrue(pIrp->MdlAddress->Next == pMdl2);
		}
	};
}

```

`test/MemoryTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Memory Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkMemoryTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkMemoryTestInit)
		{
			DdkThreadInit();
		}
		
		TEST_METHOD(DdkMemoryPhysAddr)
		{
			LARGE_INTEGER addr = MmGetPhysicalAddress((PVOID)0x123456789I64);
			Assert::IsTrue(addr.QuadPart == 0x123456789I64);
		}

	};
}

```

`test/MutexTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Mutex Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkMutexTest)
	{
		LARGE_INTEGER nowait;
		KMUTEX mutex;
		ULONG value;
		LONG count;
		LONG asynccount;

	public:
		TEST_METHOD_INITIALIZE(DdkMutexTestInit)
		{
			DdkThreadInit();
			KeInitializeMutex(&mutex, 0);
			nowait.QuadPart = 0;
			value = 0;
			count = 0;
			asynccount = 0;
		}

		TEST_METHOD(DdkMutexInit)
		{
			Assert::IsTrue(KeReadStateMutex(&mutex) == 1);
		}

		TEST_METHOD(DdkMutexWait)
		{
			NTSTATUS rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateMutex(&mutex) == 0);
		}

		TEST_METHOD(DdkMutexRelease)
		{
			NTSTATUS rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			KeReleaseMutex(&mutex, FALSE);
			Assert::IsTrue(KeReadStateMutex(&mutex) == 1);
		}

		TEST_METHOD(DdkMutexWaitRecursive)
		{
			NTSTATUS rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateMutex(&mutex) == 0);
		}

		TEST_METHOD(DdkMutexReleaseRecursive)
		{
			NTSTATUS rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			KeReleaseMutex(&mutex, FALSE);
			Assert::IsTrue(KeReadStateMutex(&mutex) == 0);

			KeReleaseMutex(&mutex, FALSE);
			Assert::IsTrue(KeReadStateMutex(&mutex) == 1);
		}

		TEST_METHOD_ASYNC(DdkMutexAsync)
		{
			LARGE_INTEGER timeout;
			timeout.QuadPart = (-20) * 10000I64;

			for (int i = 0, last = 0; i < 20000; i++) {
				NTSTATUS rc = KeWaitForSingleObject(&mutex, Executive, KernelMode, FALSE, &timeout);
				if (rc == STATUS_TIMEOUT) continue;

				if (TEST_IS_ASYNC) {
					Assert::IsTrue((value & 0xffff) == last);
					value = (value & 0xffff0000) + i;
					asynccount++;
				} else {
					Assert::IsTrue((value >> 16) == last);
					value = (value & 0xffff) + (i << 16);
					count++;
				}

				last = i;
				KeReleaseMutex(&mutex, FALSE);
			}
		}

		TEST_METHOD(DdkMutexMulti)
		{
			TEST_ASYNC_START(id, DdkMutexAsync);
			DdkMutexAsync();
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(count && asynccount);
		}
	};
}

```

`test/ObjectTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Object Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	static POBJECT_TYPE *TypeVec[] = {
		PsProcessType, CmKeyObjectType, ExEventObjectType, ExSemaphoreObjectType,
		IoFileObjectType, PsThreadType, SeTokenObjectType, TmEnlistmentObjectType,
		TmResourceManagerObjectType, TmTransactionManagerObjectType,
		TmTransactionObjectType, 0
	};

	TEST_CLASS(DdkObjectTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkObjectInit)
		{
			DdkThreadInit();
			Assert::IsNotNull(PsGetCurrentProcess());
		}
			
		TEST_METHOD(DdkObjectCheckTypeByPointer)
		{
			for (int i = 1; TypeVec[i]; i++) {
				NTSTATUS rc = ObReferenceObjectByPointer(PsGetCurrentProcess(),
					THREAD_ALL_ACCESS, *TypeVec[i], KernelMode);

				Assert::IsTrue(rc == STATUS_OBJECT_TYPE_MISMATCH);
			}
		}

		TEST_METHOD(DdkObjectCheckTypeByHandle)
		{
			PVOID pObj;

			for (int i = 1; TypeVec[i]; i++) {
				NTSTATUS rc = ObReferenceObjectByHandle(PsGetCurrentProcessId(),
					THREAD_ALL_ACCESS, *TypeVec[i], KernelMode, &pObj, NULL);

				Assert::IsTrue(rc == STATUS_OBJECT_TYPE_MISMATCH);
			}
		}

		TEST_METHOD(DdkObjectReferenceByPointer)
		{
			NTSTATUS rc = ObReferenceObjectByPointer(PsGetCurrentProcess(),
					THREAD_ALL_ACCESS, *PsProcessType, KernelMode);

			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD(DdkObjectReferenceByHandle)
		{
			PVOID pObj;

			NTSTATUS rc = ObReferenceObjectByHandle(PsGetCurrentProcessId(),
				THREAD_ALL_ACCESS, *PsProcessType, KernelMode, &pObj, NULL);

			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD(DdkObjectDereference)
		{
			PVOID pObj;

			NTSTATUS rc = ObReferenceObjectByHandle(PsGetCurrentProcessId(),
				THREAD_ALL_ACCESS, *PsProcessType, KernelMode, &pObj, NULL);

			Assert::IsTrue(rc == STATUS_SUCCESS);

			ObDereferenceObject(pObj);
		}

		TEST_METHOD(DdkObjectFinalClose)
		{
			UNICODE_STRING u;
			HANDLE Event;

			RtlInitUnicodeString(&u, L"Object1");
			PKEVENT pEvent = IoCreateSynchronizationEvent(&u, &Event);
			Assert::IsNotNull(pEvent);

			KeResetEvent(pEvent);
			Assert::IsTrue(KeReadStateEvent(pEvent) == FALSE);

			NTSTATUS rc = ObReferenceObjectByPointer(pEvent,
					THREAD_ALL_ACCESS, *ExEventObjectType, KernelMode);

			Assert::IsTrue(rc == STATUS_SUCCESS);

			ZwClose(Event);
			Assert::IsTrue(KeReadStateEvent(pEvent) == FALSE);

			ObDereferenceObject(pEvent);
			pEvent = IoCreateSynchronizationEvent(&u, &Event);
			Assert::IsNotNull(pEvent);

			Assert::IsTrue(KeReadStateEvent(pEvent) == TRUE);
			ZwClose(pEvent);
		}
	};
}

```

`test/RegistryTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2022, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Registry Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkRegistryTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkRegistryTestInit)
		{
			DdkThreadInit();
		}

		/*
		 *	Check predefined 'RelativeTo' keys
		 */
		TEST_METHOD(DdkRegistryCheckRelative)
		{
			NTSTATUS status;

			status = RtlCheckRegistryKey(RTL_REGISTRY_CONTROL, L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCheckRegistryKey(RTL_REGISTRY_DEVICEMAP, L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCheckRegistryKey(RTL_REGISTRY_SERVICES, L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCheckRegistryKey(RTL_REGISTRY_USER, L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCheckRegistryKey(RTL_REGISTRY_WINDOWS_NT, L"");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenKey for an existing key
		 */
		TEST_METHOD(DdkRegistryZwOpenKey)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenKey for a non-existant key
		 */
		TEST_METHOD(DdkRegistryZwOpenKeyNotPresent)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NotFound");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((HANDLE)NULL, h);
		}

		/*
		 *	Check ZwOpenKeyEx for an existing key
		 */
		TEST_METHOD(DdkRegistryZwOpenKeyEx)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenKeyEx for a non-existant key
		 */
		TEST_METHOD(DdkRegistryZwOpenKeyExNotPresent)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\NotFound");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((HANDLE)NULL, h);
		}

		/*
		 *	Check ZwOpenKeyEx relative for an existing key
		 */
		TEST_METHOD(DdkRegistryZwOpenKeyExRelative)
		{
			HANDLE h = NULL, base = NULL;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&base, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, base);

			RtlInitUnicodeString(&u, L"CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, base, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(base);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwOpenKeyEx relative for a non-existant key
		 */
		TEST_METHOD(DdkRegistryZwOpenKeyExRelativeNotPresent)
		{
			HANDLE h = NULL, base = NULL;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&base, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, base);

			RtlInitUnicodeString(&u, L"CurrentControlSet\\Services\\NotFound");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, base, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((HANDLE)NULL, h);

			status = ZwClose(base);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateKey creating a key
		 */
		TEST_METHOD(DdkRegistryZwCreateKey)
		{
			OBJECT_ATTRIBUTES attr;
			DWORD disposition = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Test2001");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwCreateKey(&h, GENERIC_ALL, &attr, 0, NULL,
				REG_OPTION_NON_VOLATILE, &disposition);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)REG_CREATED_NEW_KEY, disposition);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwDeleteKey(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateKey opening a key
		 */
		TEST_METHOD(DdkRegistryZwCreateKeyExists)
		{
			OBJECT_ATTRIBUTES attr;
			DWORD disposition = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwCreateKey(&h, GENERIC_ALL, &attr, 0, NULL,
				REG_OPTION_NON_VOLATILE, &disposition);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)REG_OPENED_EXISTING_KEY, disposition);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwCreateKey creating a key with a missing path component
		 */
		TEST_METHOD(DdkRegistryZwCreateKeyMissingPath)
		{
			OBJECT_ATTRIBUTES attr;
			DWORD disposition = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Test2002\\Test2002");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwCreateKey(&h, GENERIC_ALL, &attr, 0, NULL,
				REG_OPTION_NON_VOLATILE, &disposition);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)REG_CREATED_NEW_KEY, disposition);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwDeleteKey(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwDeleteKey
		 */
		TEST_METHOD(DdkRegistryZwDeleteKey)
		{
			OBJECT_ATTRIBUTES attr;
			DWORD disposition = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Test2003");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwCreateKey(&h, GENERIC_ALL, &attr, 0, NULL,
				REG_OPTION_NON_VOLATILE, &disposition);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)REG_CREATED_NEW_KEY, disposition);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwDeleteKey(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			h = NULL;
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((HANDLE)NULL, h);
		}

		/*
		 *	Check ZwSetValueKey writing a String to the default value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678";
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Test1901");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwCreateKey(&h, KEY_ALL_ACCESS, &attr, 0, NULL,
				REG_OPTION_NON_VOLATILE, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"");
			status = ZwSetValueKey(h, &u, 0, REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test1901", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test1901", L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test1901");
		}

		/*
		 *	Check ZwSetValueKey creating a DWORD value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyInteger)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1401");
			status = ZwSetValueKey(h, &u, 0, REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1401";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1401");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey modifying a DWORD value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyIntegerRewrite)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x23456781;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1402");
			status = ZwSetValueKey(h, &u, 0, REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = 0x12345678;
			status = ZwSetValueKey(h, &u, 0, REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1402";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1402");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey writing a QWORD value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyQuad)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			__int64 data = 0x12345678;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1411");
			status = ZwSetValueKey(h, &u, 0, REG_QWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));
			*(LONG *)&data = (-(LONG)sizeof(data));


			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1411";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((__int64)0x12345678, data);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1411");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey writing a BINARY value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyBinary)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { int a, b, c; } data;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			data.a = 0x12345678;
			data.b = 0x23456789;
			data.c = 0x34567890;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1412");
			status = ZwSetValueKey(h, &u, 0, REG_BINARY, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));
			*(LONG *)&data = (-(LONG)sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1412";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(0x12345678, data.a);
			Assert::AreEqual(0x23456789, data.b);
			Assert::AreEqual(0x34567890, data.c);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1412");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey writing a String value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678";
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1601");
			status = ZwSetValueKey(h, &u, 0, REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1601";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1601");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey modifying a String value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyStringRewrite)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"3456789012";
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1641");
			status = ZwSetValueKey(h, &u, 0, REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = L"12345678";
			status = ZwSetValueKey(h, &u, 0, REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1641";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1641");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwSetValueKey writing a Multi-String value
		 */
		TEST_METHOD(DdkRegistryZwSetValueKeyMultiString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1651");
			status = ZwSetValueKey(h, &u, 0, REG_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test1651";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 18), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual(0, wcsncmp(u.Buffer + sizeof(WCHAR) * 9, data + sizeof(WCHAR) * 9, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[17]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[18]);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1651");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryValueKey for basic info
		 */
		TEST_METHOD(DdkRegistryZwQueryValueKeyBasic)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			struct { KEY_VALUE_BASIC_INFORMATION info; WCHAR v[1024]; } data;
			DWORD resultlen = 0;

			RtlInitUnicodeString(&u, L"SystemRoot");

			status = ZwQueryValueKey(h, &u, KeyValueBasicInformation,
				(PVOID)&data.info, sizeof(data), &resultlen);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
			Assert::AreEqual((ULONG)20, data.info.NameLength);
			Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
				+ data.info.NameLength), resultlen);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryValueKey for full info
		 */
		TEST_METHOD(DdkRegistryZwQueryValueKeyFull)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			struct { KEY_VALUE_FULL_INFORMATION info; WCHAR v[1024]; } data;
			DWORD resultlen = 0;

			RtlInitUnicodeString(&u, L"SystemRoot");

			status = ZwQueryValueKey(h, &u, KeyValueFullInformation,
				(PVOID)&data.info, sizeof(data), &resultlen);

			Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
			Assert::AreEqual((ULONG)20, data.info.NameLength);
			Assert::AreEqual((ULONG)22, data.info.DataLength);
			Assert::AreEqual(0, wcsncmp((WCHAR*)((char *)&data + data.info.DataOffset),
				L"C:\\Windows", 10));
			Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
				+ data.info.NameLength + data.info.DataLength), resultlen);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwQueryValueKey for partial info
		 */
		TEST_METHOD(DdkRegistryZwQueryValueKeyPartial)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			struct { KEY_VALUE_PARTIAL_INFORMATION info; WCHAR v[1024]; } data;
			DWORD resultlen = 0;

			RtlInitUnicodeString(&u, L"SystemRoot");

			status = ZwQueryValueKey(h, &u, KeyValuePartialInformation,
				(PVOID)&data.info, sizeof(data), &resultlen);

			Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
			Assert::AreEqual(0, wcsncmp((WCHAR*)data.info.Data, L"C:\\Windows", 10));
			Assert::AreEqual((ULONG)(((char *)&data.info.Data - (char *)&data)
				+ data.info.DataLength), resultlen);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateKey for basic info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateKeyBasic)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_BASIC_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateKey(h, i, KeyBasicInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (wcsncmp(data.info.Name, L"Control", 7) == 0) {
					Assert::AreEqual((ULONG)14, data.info.NameLength);
					Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
						+ data.info.NameLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 2 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateKey for node info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateKeyNode)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_NODE_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateKey(h, i, KeyNodeInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (wcsncmp(data.info.Name, L"Control", 7) == 0) {
					Assert::AreEqual((ULONG)14, data.info.NameLength);
					Assert::AreEqual((ULONG)0, data.info.ClassLength);
					Assert::AreEqual((char *)&data.info.Name + data.info.NameLength,
						(char *)&data + data.info.ClassOffset);
					Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
						+ data.info.NameLength + data.info.ClassLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 2 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateKey for full info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateKeyFull)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_FULL_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateKey(h, i, KeyFullInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (data.info.SubKeys > 0) {
					Assert::IsTrue(data.info.MaxNameLen < 256);
					Assert::IsTrue(data.info.MaxValueNameLen < 256);
					Assert::AreEqual((char *)data.info.Class, (char *)&data + data.info.ClassOffset);
					Assert::AreEqual((ULONG)(((char *)&data.info.Class - (char *)&data)
						+ data.info.ClassLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 2 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateValueKey for basic info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateValueKeyBasic)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_VALUE_BASIC_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateValueKey(h, i, KeyValueBasicInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (wcsncmp(data.info.Name, L"SystemRoot", 10) == 0) {
					Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
					Assert::AreEqual((ULONG)20, data.info.NameLength);
					Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
						+ data.info.NameLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 3 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateValueKey for full info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateValueKeyFull)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_VALUE_FULL_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateValueKey(h, i, KeyValueFullInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (wcsncmp(data.info.Name, L"SystemRoot", 10) == 0) {
					Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
					Assert::AreEqual((ULONG)20, data.info.NameLength);
					Assert::AreEqual((ULONG)22, data.info.DataLength);
					Assert::AreEqual(0, wcsncmp((WCHAR*)((char *)&data + data.info.DataOffset),
						L"C:\\Windows", 10));
					Assert::AreEqual((ULONG)(((char *)&data.info.Name - (char *)&data)
						+ data.info.NameLength + data.info.DataLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 3 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwEnumerateValueKey for partial info
		 */
		TEST_METHOD(DdkRegistryZwEnumerateValueKeyPartial)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			DWORD i = 0, match = 0;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKeyEx(&h, GENERIC_ALL, &attr, 0);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			for (; true; i++) {
				struct { KEY_VALUE_PARTIAL_INFORMATION info; WCHAR v[1024]; } data;
				DWORD resultlen = 0;
			
				NTSTATUS status = ZwEnumerateValueKey(h, i, KeyValuePartialInformation,
					(PVOID)&data.info, sizeof(data), &resultlen);

				if (status == STATUS_NO_MORE_ENTRIES) break;

				Assert::AreEqual(STATUS_SUCCESS, status);

				if (data.info.DataLength == 22) {
					Assert::AreEqual((ULONG)REG_SZ, data.info.Type);
					Assert::AreEqual(0, wcsncmp((WCHAR*)data.info.Data, L"C:\\Windows", 10));
					Assert::AreEqual((ULONG)(((char *)&data.info.Data - (char *)&data)
						+ data.info.DataLength), resultlen);
					match++;
				}
			}

			Assert::IsTrue(i >= 3 && match);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwFlushKey
		 */
		TEST_METHOD(DdkRegistryZwFlushKey)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwFlushKey(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwDeleteValueKey on a value that exists
		 */
		TEST_METHOD(DdkRegistryZwDeleteValueKey)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test1311",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test1311";
			table[0].EntryContext = &data;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			RtlInitUnicodeString(&u, L"Test1311");
			status = ZwDeleteValueKey(h, &u);
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = 0;
			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check ZwDeleteValueKey on a value that doesn't exist
		 */
		TEST_METHOD(DdkRegistryZwDeleteValueKeyNonExistantValue)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			RtlInitUnicodeString(&u, L"Test1312");
			status = ZwDeleteValueKey(h, &u);
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwClose for a valid key
		 */
		TEST_METHOD(DdkRegistryZwClose)
		{
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check ZwClose for a NULL key
		 */
		TEST_METHOD(DdkRegistryZwCloseNull)
		{
			NTSTATUS status = ZwClose(NULL);
			Assert::AreEqual(STATUS_INVALID_HANDLE, status);
		}

		/*
		 *	Check whether a key that exists is identified
		 */
		TEST_METHOD(DdkRegistryCheckKey)
		{
			NTSTATUS status;

			status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check user keys
		 */
		TEST_METHOD(DdkRegistryCheckUserKeys)
		{
			NTSTATUS status;

			status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\User\\CurrentUser");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\User\\.Default");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check that non-existant keys return an error
		 */
		TEST_METHOD(DdkRegistryCheckKeyNotPresent)
		{
			NTSTATUS status;

			status = RtlCheckRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\xx");
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			
			status = RtlCheckRegistryKey(RTL_REGISTRY_CONTROL, L"xx");
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}

		/*
		 *	Check creating a key
		 */
		TEST_METHOD(DdkRegistryCreateKey)
		{
			NTSTATUS status;

			status = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Test101");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test102");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Test101");

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test102");
		}

		/*
		 *	Check creating a key with a missing path component
		 */
		TEST_METHOD(DdkRegistryCreateKeyMissingPath)
		{
			NTSTATUS status;

			status = RtlCreateRegistryKey(RTL_REGISTRY_ABSOLUTE,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\xx\\Test201");
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"xx\\Test202");
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}

		/*
		 *	Check creating a key that exists
		 */
		TEST_METHOD(DdkRegistryRecreateKey)
		{
			NTSTATUS status;

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test301");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test301");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test301");
		}

		/*
		 *	Check deleting a value that exists
		 */
		TEST_METHOD(DdkRegistryDeleteValue)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test311",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test311";
			table[0].EntryContext = &data;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test311");
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = 0;
			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check deleting a value that doesn't exist
		 */
		TEST_METHOD(DdkRegistryDeleteValueNonExistant)
		{
			NTSTATUS status;

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test312");
			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}

		/*
		 *	Check deleting a value using a handle
		 */
		TEST_METHOD(DdkRegistryDeleteValueHandle)
		{
			DWORD data = 0x12345678;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test317",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_HANDLE, (WCHAR *)h, L"Test317");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check deleting a value using a null handle
		 */
		TEST_METHOD(DdkRegistryDeleteValueNullHandle)
		{
			DWORD data = 0x12345678;
			NTSTATUS status;
			HANDLE h = NULL;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test318",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_HANDLE, (WCHAR *)h, L"Test318");
			Assert::AreEqual(STATUS_INVALID_HANDLE, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test318");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check writing a String to default value
		 */
		TEST_METHOD(DdkRegistryWriteDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test901");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test901", L"",
				REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test901", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test901", L"");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test901");
		}

		/*
		 *	Check creating a DWORD value
		 */
		TEST_METHOD(DdkRegistryWriteInteger)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test401",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test401";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test401");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check modifying a DWORD value
		 */
		TEST_METHOD(DdkRegistryWriteIntegerRewrite)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x23456781;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test501",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = 0x12345678;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test501",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test501";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test501");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check creating a DWORD value using a handle
		 */
		TEST_METHOD(DdkRegistryWriteIntegerHandle)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\System\\CurrentControlSet\\Services");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE, (WCHAR *)h, L"Test408",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test408";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_HANDLE, (WCHAR *)h, L"Test408");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check creating a DWORD value using a null handle
		 */
		TEST_METHOD(DdkRegistryWriteIntegerNullHandle)
		{
			DWORD data = 0x12345678;
			NTSTATUS status;
			HANDLE h = NULL;

			status = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE, (WCHAR *)h, L"Test408",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_INVALID_HANDLE, status);
		}

		/*
		 *	Check writing a QWORD value
		 */
		TEST_METHOD(DdkRegistryWriteQuad)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			__int64 data = 0x12345678;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test411",
				REG_QWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));
			*(LONG *)&data = (-(LONG)sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test411";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((__int64)0x12345678, data);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test411");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check writing a BINARY value
		 */
		TEST_METHOD(DdkRegistryWriteBinary)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { int a, b, c; } data;
			NTSTATUS status;

			data.a = 0x12345678;
			data.b = 0x23456789;
			data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test412",
				REG_BINARY, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));
			*(LONG *)&data = (-(LONG)sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test412";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(0x12345678, data.a);
			Assert::AreEqual(0x23456789, data.b);
			Assert::AreEqual(0x34567890, data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test412");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check writing a String value
		 */
		TEST_METHOD(DdkRegistryWriteString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test601",
				REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test601";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test601");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check modifying a String value
		 */
		TEST_METHOD(DdkRegistryWriteStringRewrite)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"3456789012";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test641",
				REG_SZ, data, sizeof(WCHAR) * 11);
			Assert::AreEqual(STATUS_SUCCESS, status);

			data = L"12345678";
			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test641",
				REG_SZ, data, sizeof(WCHAR) * 9);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test641";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test641");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check writing a Multi-String value
		 */
		TEST_METHOD(DdkRegistryWriteMultiString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test651",
				REG_MULTI_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test651";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 18), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual(0, wcsncmp(u.Buffer + sizeof(WCHAR) * 9, data + sizeof(WCHAR) * 9, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[17]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[18]);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test651");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying an non-existant value
		 */
		TEST_METHOD(DdkRegistryQueryNotFound)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data;

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Hostname101";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}

		/*
		 *	Check querying an non-existant subkey
		 */
		TEST_METHOD(DdkRegistryQuerySubkeyNotFound)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
			table[0].Name = L"NotThere";
			table[0].DefaultType = REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
		}

		/*
		 *	Check querying an entry with NOVALUE
		 */
		static NTSTATUS QueryNoValueRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			Assert::AreEqual(REG_NONE, ValueType);
			Assert::AreEqual((PVOID)NULL, ValueData);
			Assert::AreEqual((ULONG)0, ValueLength);
			Assert::AreEqual((PVOID)0x1234, EntryContext);
			Assert::AreEqual((PVOID)0x5678, Context);
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryNoValue)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_NOVALUE;
			table[0].Name = NULL;
			table[0].QueryRoutine = QueryNoValueRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], (PVOID)0x5678, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying with correct type
		 */
		TEST_METHOD(DdkRegistryQueryTypeOk)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			UNICODE_STRING u;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_TYPECHECK;
			table[0].Name = L"Hostname";
			table[0].EntryContext = &u;
			table[0].DefaultType = (REG_SZ << RTL_QUERY_REGISTRY_TYPECHECK_SHIFT) | REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, L"UnitTest", 8));
		}

		/*
		 *	Check querying with incorrect type
		 */
		TEST_METHOD(DdkRegistryQueryTypeFail)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_TYPECHECK;
			table[0].Name = L"Hostname";
			table[0].EntryContext = &data;
			table[0].DefaultType = (REG_DWORD << RTL_QUERY_REGISTRY_TYPECHECK_SHIFT) | REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_TYPE_MISMATCH, status);
		}

		/*
		 *	Check querying with spurious routine
		 */
		TEST_METHOD(DdkRegistryQuerySpuriousRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].QueryRoutine = QueryNoValueRoutine;
			table[0].DefaultType = REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_INVALID_PARAMETER, status);
		}

		/*
		 *	Check querying with missing routine
		 */
		TEST_METHOD(DdkRegistryQueryMissingRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags =RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_INVALID_PARAMETER, status);
		}

		/*
		 *	Check querying and delete value
		 */
		TEST_METHOD(DdkRegistryQueryDelete)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			DWORD data = 0x12345678;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test111",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_DELETE;
			table[0].Name = L"Test111";
			table[0].EntryContext = &data;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data);

			memset(table, 0, sizeof(table));
			data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test111";
			table[0].EntryContext = &data;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check querying a null name using a routine
		 */
		static NTSTATUS QueryNullRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			if (wcscmp(ValueName, L"CurrentMajorVersionNumber") == 0) {
				Assert::AreEqual(REG_DWORD, ValueType);
				Assert::AreEqual((DWORD)10, *(DWORD *)ValueData);
				Assert::AreEqual((ULONG)sizeof(DWORD), ValueLength);
				(*(DWORD *)EntryContext)++;
			}
			(*(DWORD *)Context)++;
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryNull)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			ULONG count = 0, match = 0;
			NTSTATUS status;
 
			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = NULL;
			table[0].QueryRoutine = QueryNullRoutine;
			table[0].EntryContext = (PVOID)&match;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)1, match);
			Assert::IsTrue(count > match);
		}

		/*
		 *	Check querying a null name on an empty key using a routine
		 */
		static NTSTATUS QueryNullEmptyRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			(*(DWORD *)Context)++;
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryNullEmpty)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			ULONG count = 0;
			NTSTATUS status;
 
			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test121");
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));

			table[0].Flags = 0;
			table[0].Name = NULL;
			table[0].QueryRoutine = QueryNullRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test121", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)0, count);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test121");
		}

		/*
		 *	Check querying a required null name on an empty key using a routine
		 */
		TEST_METHOD(DdkRegistryQueryNullEmptyRequired)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			ULONG count = 0;
			NTSTATUS status;
 
			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test122");
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = NULL;
			table[0].QueryRoutine = QueryNullRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test121", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((ULONG)0, count);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test122");
		}

		/*
		 *	Check querying a null name on a subkey using a routine
		 */
		TEST_METHOD(DdkRegistryQueryNullSubkey)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			ULONG count = 0;
			NTSTATUS status;
 
			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test123");
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			DWORD data = 0x12345678;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test123", L"Test123",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_SUBKEY;
			table[0].Name = L"Test123";
			table[0].QueryRoutine = QueryNullRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)1, count);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test123", L"Test123");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test123");
		}

		/*
		 *	Check querying a null name with delete using a routine
		 */
		TEST_METHOD(DdkRegistryQueryNullDelete)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			ULONG count = 0;
			NTSTATUS status;
 
			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test124");
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			DWORD data = 0x12345678;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test124", L"Test124",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test124", L"Test125",
				REG_DWORD, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_DELETE;
			table[0].Name = NULL;
			table[0].QueryRoutine = QueryNullEmptyRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test124", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)2, count);

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Test124", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test124");
		}

		/*
		 *	Check querying a required value
		 */
		TEST_METHOD(DdkRegistryQueryRequiredPresent)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)10, data);
		}

		/*
		 *	Check querying a non present required value
		 */
		TEST_METHOD(DdkRegistryQueryRequiredNotPresent)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"NotFound";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check querying a required value with a routine
		 */
		TEST_METHOD(DdkRegistryQueryRequiredPresentRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;
			DWORD count = 0;

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].QueryRoutine = QueryNullEmptyRoutine;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)1, count);
		}

		/*
		 *	Check querying a non-present required value with a routine
		 */
		TEST_METHOD(DdkRegistryQueryRequiredNotPresentRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;
			DWORD count = 0;

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"NotFound";
			table[0].QueryRoutine = QueryNullEmptyRoutine;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], &count, NULL);

			Assert::AreEqual(STATUS_OBJECT_NAME_NOT_FOUND, status);
			Assert::AreEqual((DWORD)0, count);
		}

		/*
		 *	Check querying multiple values
		 */
		TEST_METHOD(DdkRegistryQueryMultiple)
		{
			DWORD data1 = 0x12345678, data2 = 0x34567890;
			RTL_QUERY_REGISTRY_TABLE table[3];
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test471",
				REG_DWORD, &data1, sizeof(data1));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test472",
				REG_DWORD, &data2, sizeof(data2));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			data1 = data2 = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test471";
			table[0].EntryContext = &data1;
			table[0].DefaultType = REG_NONE;
			table[1].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[1].Name = L"Test472";
			table[1].EntryContext = &data2;
			table[1].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data1);
			Assert::AreEqual((DWORD)0x34567890, data2);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test471");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test472");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying multiple values with subkey
		 */
		TEST_METHOD(DdkRegistryQueryMultipleSubkey)
		{
			DWORD data1 = 0x12345678, data2 = 0x34567890, data3 = 0x56789012;
			RTL_QUERY_REGISTRY_TABLE table[6];
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test481",
				REG_DWORD, &data1, sizeof(data1));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test482Key");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test482Key", L"Test482",
				REG_DWORD, &data2, sizeof(data2));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test483Key");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test483Key", L"Test483",
				REG_DWORD, &data3, sizeof(data3));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			data1 = data2 = data3 = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test481";
			table[0].EntryContext = &data1;
			table[0].DefaultType = REG_NONE;
			table[1].Flags = RTL_QUERY_REGISTRY_SUBKEY;
			table[1].Name = L"Test482Key";
			table[2].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[2].Name = L"Test482";
			table[2].EntryContext = &data2;
			table[2].DefaultType = REG_NONE;
			table[3].Flags = RTL_QUERY_REGISTRY_SUBKEY;
			table[3].Name = L"Test483Key";
			table[4].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[4].Name = L"Test483";
			table[4].EntryContext = &data3;
			table[4].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data1);
			Assert::AreEqual((DWORD)0x34567890, data2);
			Assert::AreEqual((DWORD)0x56789012, data3);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test481");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test482Key", L"Test482");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test483Key", L"Test483");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test482Key");
			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test483Key");
		}

		/*
		 *	Check querying multiple values with topkey
		 */
		TEST_METHOD(DdkRegistryQueryMultipleTopkey)
		{
			DWORD data1 = 0x12345678, data2 = 0x34567890, data3 = 0x56789012;
			RTL_QUERY_REGISTRY_TABLE table[5];
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test491",
				REG_DWORD, &data1, sizeof(data1));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlCreateRegistryKey(RTL_REGISTRY_SERVICES, L"Test492Key");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"Test492Key", L"Test492",
				REG_DWORD, &data2, sizeof(data2));
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test493",
				REG_DWORD, &data3, sizeof(data3));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			data1 = data2 = data3 = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test491";
			table[0].EntryContext = &data1;
			table[0].DefaultType = REG_NONE;
			table[1].Flags = RTL_QUERY_REGISTRY_SUBKEY;
			table[1].Name = L"Test492Key";
			table[2].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[2].Name = L"Test492";
			table[2].EntryContext = &data2;
			table[2].DefaultType = REG_NONE;
			table[3].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_TOPKEY;
			table[3].Name = L"Test493";
			table[3].EntryContext = &data3;
			table[3].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x12345678, data1);
			Assert::AreEqual((DWORD)0x34567890, data2);
			Assert::AreEqual((DWORD)0x56789012, data3);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test491");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"Test492Key", L"Test492");
			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test493");
			Assert::AreEqual(STATUS_SUCCESS, status);

			DdkDeleteRegistryKey(RTL_REGISTRY_SERVICES, L"Test492Key");
		}

		/*
		 *	Check querying a String value
		 */
		TEST_METHOD(DdkRegistryQueryString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			UNICODE_STRING u;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Hostname";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, L"UnitTest", 8));
		}

		/*
		 *	Check querying a String value using a routine
		 */
		static NTSTATUS QueryStringRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			Assert::AreEqual(REG_SZ, ValueType);
			Assert::AreEqual(0, wcscmp((WCHAR *)ValueData, L"UnitTest"));
			Assert::AreEqual((ULONG)(sizeof(WCHAR) * 9), ValueLength);
			Assert::AreEqual((PVOID)0x1234, EntryContext);
			Assert::AreEqual((PVOID)0x5678, Context);
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryStringRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Hostname";
			table[0].QueryRoutine = QueryStringRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], (PVOID)0x5678, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a non-existant String value returns the default
		 */
		TEST_METHOD(DdkRegistryQueryStringDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			UNICODE_STRING u;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
			table[0].Name = L"Hostname101";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_SZ;
			table[0].DefaultData = L"NotThere";
			table[0].DefaultLength = sizeof(WCHAR) * 9;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, L"NotThere", 8));
		}

		/*
		 *	Check querying a non-existant String value returns a calculated
		 *	default string length
		 */
		TEST_METHOD(DdkRegistryQueryStringDefaultNoLength)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			UNICODE_STRING u;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
			table[0].Name = L"Hostname101";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_SZ;
			table[0].DefaultData = L"NotThere";
			table[0].DefaultLength = 0;

			NTSTATUS status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"Tcpip\\Parameters", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 8), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, L"NotThere", 8));
		}

		/*
		 *	Check querying a Multi-String value
		 */
		TEST_METHOD(DdkRegistryQueryMultiString)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test671",
				REG_MULTI_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test671";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 18), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual(0, wcsncmp(u.Buffer + sizeof(WCHAR) * 9, data + sizeof(WCHAR) * 9, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[17]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[18]);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test671");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a Multi-String value using a routine
		 */
		static NTSTATUS QueryMultiStringRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			Assert::AreEqual(REG_MULTI_SZ, ValueType);
			Assert::AreEqual((ULONG)sizeof(WCHAR) * 19, ValueLength);
			Assert::AreEqual(0, wcsncmp((WCHAR *)ValueData, L"12345678", 8));
			Assert::AreEqual(0, wcsncmp((WCHAR *)ValueData + 9, L"23456789", 8));
			Assert::AreEqual((WCHAR)L'\0', ((WCHAR *)ValueData)[8]);
			Assert::AreEqual((WCHAR)L'\0', ((WCHAR *)ValueData)[17]);
			Assert::AreEqual((WCHAR)L'\0', ((WCHAR *)ValueData)[18]);
			Assert::AreEqual((PVOID)0x1234, EntryContext);
			Assert::AreEqual((PVOID)0x5678, Context);
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryMultiStringRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test671",
				REG_MULTI_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test671";
			table[0].QueryRoutine = QueryMultiStringRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], (PVOID)0x5678, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test671");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying an expanded Multi-String value using a routine
		 */
		static NTSTATUS QueryMultiStringExpandRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			Assert::AreEqual(REG_SZ, ValueType);
			Assert::AreEqual((ULONG)sizeof(WCHAR) * 8, ValueLength);

			if ((*(DWORD *)Context) == 0) {
				Assert::AreEqual(0, wcsncmp((WCHAR *)ValueData, L"12345678", 8));
				Assert::AreEqual((WCHAR)L'\0', ((WCHAR *)ValueData)[8]);
				Assert::AreEqual((PVOID)0x1234, EntryContext);
			} else {
				Assert::AreEqual(0, wcsncmp((WCHAR *)ValueData, L"23456789", 8));
				Assert::AreEqual((WCHAR)L'\0', ((WCHAR *)ValueData)[8]);
				Assert::AreEqual((PVOID)0x1234, EntryContext);
			}

			(*(DWORD *)Context)++;
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryMultiStringExpandRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			NTSTATUS status;
			DWORD index = 0;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test681",
				REG_MULTI_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test681";
			table[0].QueryRoutine = QueryMultiStringExpandRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], &index, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)2, index);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test681");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a Multi-String value without NOEXPAND
		 */
		TEST_METHOD(DdkRegistryQueryMultiStringExpand)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test672",
				REG_MULTI_SZ, data, sizeof(WCHAR) * 19);
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test672";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreNotEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((USHORT)0, u.Length);
			Assert::AreEqual((USHORT)0, u.MaximumLength);
			Assert::AreEqual((WCHAR *)0, u.Buffer);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test672");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a Multi-String value with a default
		 */
		TEST_METHOD(DdkRegistryQueryMultiStringDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test679";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_MULTI_SZ;
			table[0].DefaultData = (PVOID)data;
			table[0].DefaultLength = 19 * sizeof(WCHAR);

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 18), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual(0, wcsncmp(u.Buffer + sizeof(WCHAR) * 9, data + sizeof(WCHAR) * 9, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[17]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[18]);
		}

		/*
		 *	Check querying a Multi-String value with a default and no length
		 */
		TEST_METHOD(DdkRegistryQueryMultiStringDefaultNoLength)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED |
							 RTL_QUERY_REGISTRY_NOEXPAND;
			table[0].Name = L"Test679";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_MULTI_SZ;
			table[0].DefaultData = (PVOID)data;
			table[0].DefaultLength = 0;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((sizeof(WCHAR) * 18), (size_t)u.Length);
			Assert::AreEqual(0, wcsncmp(u.Buffer, data, 8));
			Assert::AreEqual(0, wcsncmp(u.Buffer + sizeof(WCHAR) * 9, data + sizeof(WCHAR) * 9, 8));
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[8]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[17]);
			Assert::AreEqual((WCHAR)L'\0', (WCHAR)u.Buffer[18]);
		}

		/*
		 *	Check querying a Multi-String value without a default
		 */
		TEST_METHOD(DdkRegistryQueryMultiStringNoDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			WCHAR *data = L"12345678\0" L"23456789\0";
			UNICODE_STRING u;
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			RtlInitUnicodeString(&u, NULL);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
			table[0].Name = L"Test677";
			table[0].EntryContext = &u;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((USHORT)0, u.Length);
			Assert::AreEqual((USHORT)0, u.MaximumLength);
			Assert::AreEqual((WCHAR *)0, u.Buffer);
		}

		/*
		 *	Check querying a DWORD value
		 */
		TEST_METHOD(DdkRegistryQueryInteger)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)10, data);
		}

		/*
		 *	Check querying a non-existant DWORD value returns the default
		 */
		TEST_METHOD(DdkRegistryQueryIntegerDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0, val = 0x1234567;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test611";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_DWORD;
			table[0].DefaultData = &val;
			table[0].DefaultLength = (ULONG)sizeof(val);

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0x1234567, data);
		}

		/*
		 *	Check querying an optional DWORD value with no default
		 */
		TEST_METHOD(DdkRegistryQueryIntegerNoDefault)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
			table[0].Name = L"Test691";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check querying a DWORD value using a routine
		 */
		static NTSTATUS QueryIntegerRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			Assert::AreEqual(REG_DWORD, ValueType);
			Assert::AreEqual((DWORD)10, *(DWORD *)ValueData);
			Assert::AreEqual((ULONG)sizeof(DWORD), ValueLength);
			Assert::AreEqual((PVOID)0x1234, EntryContext);
			Assert::AreEqual((PVOID)0x5678, Context);
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryIntegerRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].QueryRoutine = QueryIntegerRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], (PVOID)0x5678, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a DWORD value using a handle
		 */
		TEST_METHOD(DdkRegistryQueryIntegerHandle)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			OBJECT_ATTRIBUTES attr;
			UNICODE_STRING u;
			NTSTATUS status;
			HANDLE h = NULL;

			RtlInitUnicodeString(&u,
				L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion");

			InitializeObjectAttributes(&attr, &u, OBJ_KERNEL_HANDLE, NULL, NULL);
			status = ZwOpenKey(&h, GENERIC_ALL, &attr);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreNotEqual((HANDLE)NULL, h);

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((DWORD)10, data);

			status = ZwClose(h);
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a DWORD value using a null handle
		 */
		TEST_METHOD(DdkRegistryQueryIntegerNullHandle)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			NTSTATUS status;
			HANDLE h = NULL;

			memset(table, 0, sizeof(table));
			DWORD data = 0;

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"CurrentMajorVersionNumber";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE, (WCHAR *)h,
				&table[0], NULL, NULL);

			Assert::AreEqual(STATUS_INVALID_HANDLE, status);
			Assert::AreEqual((DWORD)0, data);
		}

		/*
		 *	Check querying a BINARY value
		 */
		typedef struct { int a, b, c; } QueryBinary_t;
	
		TEST_METHOD(DdkRegistryQueryBinary)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			QueryBinary_t data;
			NTSTATUS status;

			data.a = 0x12345678;
			data.b = 0x23456789;
			data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test811",
				REG_BINARY, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&data, 0, sizeof(data));
			*(LONG *)&data = (-(LONG)sizeof(data));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test811";
			table[0].EntryContext = &data;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual(0x12345678, data.a);
			Assert::AreEqual(0x23456789, data.b);
			Assert::AreEqual(0x34567890, data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test811");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a BINARY value returns size and type
		 */
		TEST_METHOD(DdkRegistryQueryBinaryWithInfo)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { ULONG size, type; QueryBinary_t data; } buffer;
			NTSTATUS status;

			buffer.data.a = 0x12345678;
			buffer.data.b = 0x23456789;
			buffer.data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test821",
				REG_BINARY, &buffer.data, sizeof(buffer.data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&buffer, 0, sizeof(buffer));
			*(ULONG *)&buffer = (ULONG)sizeof(buffer);

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test821";
			table[0].EntryContext = &buffer;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)sizeof(buffer.data), buffer.size);
			Assert::AreEqual(REG_BINARY, buffer.type);
			Assert::AreEqual(0x12345678, buffer.data.a);
			Assert::AreEqual(0x23456789, buffer.data.b);
			Assert::AreEqual(0x34567890, buffer.data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test821");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a BINARY value with a buffer that's too small
		 *	for all the data
		 */
		TEST_METHOD(DdkRegistryQueryBinaryWithInfoPartial)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { ULONG size, type; QueryBinary_t data; } buffer;
			NTSTATUS status;

			buffer.data.a = 0x12345678;
			buffer.data.b = 0x23456789;
			buffer.data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test831",
				REG_BINARY, &buffer.data, sizeof(buffer.data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&buffer, 0, sizeof(buffer));
			*(ULONG *)&buffer = (ULONG)(sizeof(buffer) - sizeof(int));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test831";
			table[0].EntryContext = &buffer;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)sizeof(buffer.data), buffer.size);
			Assert::AreEqual(REG_BINARY, buffer.type);
			Assert::AreEqual(0x12345678, buffer.data.a);
			Assert::AreEqual(0x23456789, buffer.data.b);
			Assert::AreEqual(0, buffer.data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test831");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a BINARY value with room for the size only
		 */
		TEST_METHOD(DdkRegistryQueryBinaryWithInfoSize)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { ULONG size, type; QueryBinary_t data; } buffer;
			NTSTATUS status;

			buffer.data.a = 0x12345678;
			buffer.data.b = 0x23456789;
			buffer.data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test842",
				REG_BINARY, &buffer.data, sizeof(buffer.data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&buffer, 0, sizeof(buffer));
			*(ULONG *)&buffer = (ULONG)(sizeof(buffer.size));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test842";
			table[0].EntryContext = &buffer;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)sizeof(buffer.data), buffer.size);
			Assert::AreEqual((ULONG)0, buffer.type);
			Assert::AreEqual(0, buffer.data.a);
			Assert::AreEqual(0, buffer.data.b);
			Assert::AreEqual(0, buffer.data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test842");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a BINARY value with room for the size and type only
		 */
		TEST_METHOD(DdkRegistryQueryBinaryWithInfoType)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			struct { ULONG size, type; QueryBinary_t data; } buffer;
			NTSTATUS status;

			buffer.data.a = 0x12345678;
			buffer.data.b = 0x23456789;
			buffer.data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test843",
				REG_BINARY, &buffer.data, sizeof(buffer.data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));
			memset(&buffer, 0, sizeof(buffer));
			*(ULONG *)&buffer = (ULONG)(sizeof(buffer.size) + sizeof(buffer.type));

			table[0].Flags = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test843";
			table[0].EntryContext = &buffer;
			table[0].DefaultType = REG_NONE;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], NULL, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);
			Assert::AreEqual((ULONG)sizeof(buffer.data), buffer.size);
			Assert::AreEqual(REG_BINARY, buffer.type);
			Assert::AreEqual(0, buffer.data.a);
			Assert::AreEqual(0, buffer.data.b);
			Assert::AreEqual(0, buffer.data.c);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test843");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}

		/*
		 *	Check querying a BINARY value with a routine
		 */
		static NTSTATUS QueryBinaryRoutine(PWSTR ValueName, ULONG ValueType,
			PVOID ValueData, ULONG ValueLength, PVOID Context, PVOID EntryContext)
		{
			QueryBinary_t *ptr = (QueryBinary_t *)ValueData;
			Assert::AreEqual(REG_BINARY, ValueType);
			Assert::AreEqual(0x12345678, ptr->a);
			Assert::AreEqual(0x23456789, ptr->b);
			Assert::AreEqual(0x34567890, ptr->c);
			Assert::AreEqual((ULONG)sizeof(*ptr), ValueLength);
			Assert::AreEqual((PVOID)0x1234, EntryContext);
			Assert::AreEqual((PVOID)0x5678, Context);
			return STATUS_SUCCESS;
		}

		TEST_METHOD(DdkRegistryQueryBinaryRoutine)
		{
			RTL_QUERY_REGISTRY_TABLE table[2];
			QueryBinary_t data;
			NTSTATUS status;

			data.a = 0x12345678;
			data.b = 0x23456789;
			data.c = 0x34567890;

			status = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test911",
				REG_BINARY, &data, sizeof(data));
			Assert::AreEqual(STATUS_SUCCESS, status);

			memset(table, 0, sizeof(table));

			table[0].Flags = RTL_QUERY_REGISTRY_REQUIRED;
			table[0].Name = L"Test911";
			table[0].QueryRoutine = QueryBinaryRoutine;
			table[0].EntryContext = (PVOID)0x1234;

			status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
				L"", &table[0], (PVOID)0x5678, NULL);

			Assert::AreEqual(STATUS_SUCCESS, status);

			status = RtlDeleteRegistryValue(RTL_REGISTRY_SERVICES, L"", L"Test911");
			Assert::AreEqual(STATUS_SUCCESS, status);
		}
	};
}

```

`test/RtlTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Rtl Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkRtlTest)
	{
	public:
		static const int BUF_LEN = 10;

		TEST_METHOD_INITIALIZE(DdkRtlTestInit)
		{
			DdkThreadInit();
		}

		/*
		 * Zero All bytes within a buffer
		 */
		TEST_METHOD(DdkRtlZeroMemory)
		{
			UCHAR TestBuf[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);

			RtlZeroMemory(&TestBuf, BUF_LEN);

			for (int i = 0; i < BUF_LEN; i++)
				Assert::IsTrue(TestBuf[i] == 0);
		}

		/*
		 * Zero Half the bytes within a buffer
		 */
		TEST_METHOD(DdkRtlZeroMemoryHalf)
		{
			UCHAR TestBuf[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);

			RtlZeroMemory(&TestBuf, (BUF_LEN / 2));

			for (int i = 0; i < (BUF_LEN / 2); i++)
				Assert::IsTrue(TestBuf[i] == 0);
			
			for (int i = (BUF_LEN / 2); i < BUF_LEN; i++)
				Assert::IsTrue(TestBuf[i] == 0xff);			
		}

		/*
		 * Compare two matching buffers
		 */
		TEST_METHOD(DdkRtlCompareMemory)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2, 0xff, BUF_LEN);

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, BUF_LEN);
			Assert::IsTrue(result == BUF_LEN);
		}

		/*
		 * Compare with no matches
		 */
		TEST_METHOD(DdkRtlCompareMemoryExpectZero)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2[1], 0xff, BUF_LEN - sizeof(UCHAR));
			TestBuf2[0] = 0;

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, BUF_LEN);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Compare with only half the bytes matching
		 */
		TEST_METHOD(DdkRtlCompareMemoryExpectHalf)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2, 0xff, (BUF_LEN / 2));

			memset(&TestBuf2[BUF_LEN / 2], 0, (BUF_LEN / 2));

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, BUF_LEN);
			Assert::IsTrue(result == (BUF_LEN / 2));
		}

		/*
		 * Compare with size 0
		 */
		TEST_METHOD(DdkRtlCompareMemorySizeZero)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2, 0xff, BUF_LEN);

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, 0);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Compare with size 1
		 */
		TEST_METHOD(DdkRtlCompareMemorySizeOne)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2, 0xff, BUF_LEN);

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, 1);
			Assert::IsTrue(result == 1);
		}

		/*
		 * Compare with one byte not matching
		 */
		TEST_METHOD(DdkRtlCompareMemoryOneDifferentByte)
		{
			UCHAR TestBuf[BUF_LEN];
			UCHAR TestBuf2[BUF_LEN];
			memset(&TestBuf, 0xff, BUF_LEN);
			memset(&TestBuf2, 0xff, BUF_LEN);

			TestBuf2[BUF_LEN / 2] = 0;

			SIZE_T result = RtlCompareMemory(&TestBuf, &TestBuf2, BUF_LEN);
			Assert::IsTrue(result == (BUF_LEN / 2));
		}

		/*
		 * Compare two larger buffers that match
		 */
		TEST_METHOD(DdkRtlCompareMemoryLargeBuffer)
		{
			UCHAR largeBuffer[1024];
			memset(&largeBuffer, 0xff, sizeof(largeBuffer));
			UCHAR largeBuffer2[1024];
			memset(&largeBuffer2, 0xff, sizeof(largeBuffer2));

			SIZE_T result = RtlCompareMemory(&largeBuffer, &largeBuffer2, sizeof(largeBuffer));
			Assert::IsTrue(result == sizeof(largeBuffer));
		}
		
		/*
		 * Compare two larger buffers with last UCHAR not matching
		 */
		TEST_METHOD(DdkRtlCompareMemoryLargeBufferZeroLast)
		{
			UCHAR largeBuffer[1024];
			memset(&largeBuffer, 0xff, sizeof(largeBuffer));
			UCHAR largeBuffer2[1024];
			memset(&largeBuffer2, 0xff, (sizeof(largeBuffer2)-sizeof(UCHAR)));
			largeBuffer2[1023] = 0;

			SIZE_T result = RtlCompareMemory(&largeBuffer, &largeBuffer2, sizeof(largeBuffer));
			Assert::IsTrue(result == (sizeof(largeBuffer) - sizeof(UCHAR)));
		}

		/*
		 * Compare two larger buffers first UCHAR not matching
		 */
		TEST_METHOD(DdkRtlCompareMemoryLargeBufferZeroFirst)
		{
			UCHAR largeBuffer[1024];
			memset(&largeBuffer, 0xff, sizeof(largeBuffer));
			UCHAR largeBuffer2[1024];
			memset(&largeBuffer2, 0xff, sizeof(largeBuffer2));
			largeBuffer2[0] = 0;

			SIZE_T result = RtlCompareMemory(&largeBuffer, &largeBuffer2, sizeof(largeBuffer));
			Assert::IsTrue(result == 0);
		}

		/*
		 * Compare two bytes
		 */
		TEST_METHOD(DdkRtlCompareMemorySmallBuffer)
		{
			unsigned char smallBuffer = 0xff;
			unsigned char smallBuffer2 = 0xff;

			SIZE_T result = RtlCompareMemory(&smallBuffer, &smallBuffer2, sizeof(smallBuffer));
			Assert::IsTrue(result == 1);
		}

		/*
		 * Compare two zero'd bytes
		 */
		TEST_METHOD(DdkRtlCompareMemoryMatchingZeroBytes)
		{
			unsigned char smallBuffer = 0;
			unsigned char smallBuffer2 = 0;

			SIZE_T result = RtlCompareMemory(&smallBuffer, &smallBuffer2, sizeof(smallBuffer));
			Assert::IsTrue(result == 1);
		}		

		/*
		* Compare two non matching bytes
		*/
		TEST_METHOD(DdkRtlCompareMemoryNonMatchingBytes)
		{
			unsigned char smallBuffer = 0;
			unsigned char smallBuffer2 = 0xff;

			SIZE_T result = RtlCompareMemory(&smallBuffer, &smallBuffer2, sizeof(smallBuffer));
			Assert::IsTrue(result == 0);
		}

		TEST_METHOD(DdkRtlGetVersionStandardInfo)
		{
			RTL_OSVERSIONINFOW osInfo;
			osInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOW);

			NTSTATUS returnStatus = RtlGetVersion(&osInfo);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);

			Assert::IsTrue(osInfo.dwOSVersionInfoSize == sizeof(RTL_OSVERSIONINFOW));
			Assert::IsTrue(osInfo.dwMajorVersion == 0x6); 
			Assert::IsTrue(osInfo.dwMinorVersion == 0x3);
			Assert::IsTrue(osInfo.dwBuildNumber == 0x2580);
			Assert::IsTrue(osInfo.dwPlatformId == 0x2);
		}


		TEST_METHOD(DdkRtlGetVersionStandardInfoNoSize)
		{
			RTL_OSVERSIONINFOW osInfo;

			NTSTATUS returnStatus = RtlGetVersion(&osInfo);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);

			Assert::IsTrue(osInfo.dwOSVersionInfoSize == sizeof(RTL_OSVERSIONINFOW));
			Assert::IsTrue(osInfo.dwMajorVersion == 0x6);
			Assert::IsTrue(osInfo.dwMinorVersion == 0x3);
			Assert::IsTrue(osInfo.dwBuildNumber == 0x2580);
			Assert::IsTrue(osInfo.dwPlatformId == 0x2);
		}

		TEST_METHOD(DdkRtlGetVersionExtendedInfo)
		{
			RTL_OSVERSIONINFOEXW osInfo;
			osInfo.dwOSVersionInfoSize = sizeof(RTL_OSVERSIONINFOEXW);

			NTSTATUS returnStatus = RtlGetVersion((PRTL_OSVERSIONINFOW)&osInfo);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);

			Assert::IsTrue(osInfo.dwOSVersionInfoSize == sizeof(RTL_OSVERSIONINFOEXW));
			Assert::IsTrue(osInfo.dwMajorVersion == 0x6);
			Assert::IsTrue(osInfo.dwMinorVersion == 0x3);
			Assert::IsTrue(osInfo.dwBuildNumber == 0x2580);
			Assert::IsTrue(osInfo.dwPlatformId == 0x2);

			Assert::IsTrue(osInfo.wServicePackMajor == 0x0);
			Assert::IsTrue(osInfo.wServicePackMinor == 0x0);
			Assert::IsTrue(osInfo.wSuiteMask == 0x110);
			Assert::IsTrue(osInfo.wProductType == 0x03);
			Assert::IsTrue(osInfo.wReserved == 0x00);
		}
		
		TEST_METHOD(DdkByteSwapUshort)
		{
			const USHORT source = 0x0123;

			USHORT result = RtlUshortByteSwap(source);

			Assert::IsTrue(0x2301 == result);
		}

		TEST_METHOD(DdkByteSwapUshortNull)
		{
			USHORT result = RtlUshortByteSwap(NULL);

			Assert::IsTrue(0x0000 == result);
		}

		TEST_METHOD(DdkByteSwapUlong)
		{
			const ULONG source = 0x01234567;

			ULONG result = RtlUlongByteSwap(source);

			Assert::IsTrue(0x67452301 == result);
		}

		TEST_METHOD(DdkByteSwapUlongNull)
		{
			ULONG result = RtlUlongByteSwap(NULL);

			Assert::IsTrue(0x00000000 == result);
		}

		TEST_METHOD(DdkByteSwapUlonglong)
		{
			const ULONGLONG source = 0x0123456789ABCDEF;

			ULONGLONG result = RtlUlonglongByteSwap(source);

			Assert::IsTrue(0xEFCDAB8967452301 == result);
		}

		TEST_METHOD(DdkByteSwapUlonglongNull)
		{
			ULONGLONG result = RtlUlonglongByteSwap(NULL);

			Assert::IsTrue(0x0000000000000000 == result);
		}
	};
}

```

`test/SListTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	SList Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkSListTest)
	{
		SLIST_HEADER list;
		KSPIN_LOCK lock;
		LONG count;
		LONG asynccount;

		typedef struct _TEST : public SLIST_ENTRY {
			ULONG v;
			volatile LONG on;
		} TEST, *PTEST;

		static const int nvec = 100;
		struct _TEST vec[nvec];

	public:

		TEST_METHOD_INITIALIZE(DdkSListTestInit)
		{
			DdkThreadInit();
			KeInitializeSpinLock(&lock);
			ExInitializeSListHead(&list);
			Assert::IsTrue(ExQueryDepthSList(&list) == 0);

			for (int i = 0; i < nvec; i++) {
				vec[i].v = i;
				vec[i].on = 0;
			}

			for (int i = 0; i < nvec; i++) {
				Assert::IsTrue(InterlockedExchange(&vec[i].on, 1) == 0);
				ExInterlockedPushEntrySList(&list, &vec[i], &lock);
				Assert::IsTrue(ExQueryDepthSList(&list) == i+1);
			}

			count = asynccount = 0;
		}

		TEST_METHOD(DdkSListAdd)
		{
			for (int i = 0; i < nvec; i++)
				Assert::IsTrue(vec[i].on == 1);
		}

		TEST_METHOD(DdkSListRemove)
		{
			for (int i = nvec-1; i >= 0; i--) {
				TEST *p = (TEST *)ExInterlockedPopEntrySList(&list, &lock);
				Assert::IsTrue(p->v == i);
				Assert::IsTrue(ExQueryDepthSList(&list) == i);
				Assert::IsTrue(InterlockedExchange(&vec[i].on, 0) == 1);
			}

			for (int i = 0; i < nvec; i++)
				Assert::IsTrue(vec[i].on == 0);
		}

		TEST_METHOD(DdkSListFlush)
		{
			TEST *p = (TEST *)ExInterlockedFlushSList(&list);
			Assert::IsTrue(p == &vec[nvec - 1]);
			Assert::IsTrue(ExQueryDepthSList(&list) == 0);
		}

		TEST_METHOD_ASYNC(DdkSListAsync)
		{
			for (int i = 0, last = 0; i < 10000; i++) {
				TEST *p = (TEST *)ExInterlockedPopEntrySList(&list, &lock);
				Assert::IsTrue(InterlockedExchange(&p->on, 0) == 1);
				if (TEST_IS_ASYNC) asynccount++;
				else count++;
				Assert::IsTrue(InterlockedExchange(&p->on, 1) == 0);
				ExInterlockedPushEntrySList(&list, p, &lock);
			}
		}

		TEST_METHOD(DdkMutexMulti)
		{
			TEST_ASYNC_START(id, DdkSListAsync);
			DdkSListAsync();
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(count && asynccount);
		}
	};
}

```

`test/SemaphoreTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Driver Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkSemaphoreTest)
	{
		LARGE_INTEGER nowait;
		KSEMAPHORE sema;
		ULONG value;
		LONG count;
		LONG asynccount;

	public:
		TEST_METHOD_INITIALIZE(DdkSemaphoreTestInit)
		{
			DdkThreadInit();
			KeInitializeSemaphore(&sema, 1, 1);
			nowait.QuadPart = 0;
			value = 0;
			count = 0;
			asynccount = 0;
		}

		TEST_METHOD(DdkSemaphoreInit)
		{
			KeInitializeSemaphore(&sema, 0, 1);
			Assert::IsTrue(KeReadStateSemaphore(&sema) == 0);
		}

		TEST_METHOD(DdkSemaphoreInit1)
		{
			KeInitializeSemaphore(&sema, 1, 1);
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);
		}

		TEST_METHOD(DdkSemaphoreWait)
		{
			KeInitializeSemaphore(&sema, 0, 1);
			NTSTATUS rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_TIMEOUT);
			Assert::IsTrue(KeReadStateSemaphore(&sema) == 0);
		}

		TEST_METHOD(DdkSemaphoreWait1)
		{
			NTSTATUS rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateSemaphore(&sema) == 0);
		}

		TEST_METHOD(DdkSemaphoreWait2)
		{
			KeInitializeSemaphore(&sema, 2, 2);
			NTSTATUS rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);
		}

		TEST_METHOD(DdkSemaphoreReadState)
		{
			KeInitializeSemaphore(&sema, 0, 1);
			Assert::IsTrue(KeReadStateSemaphore(&sema) == 0);
		}

		TEST_METHOD(DdkSemaphoreReadState1)
		{
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);
		}

		TEST_METHOD(DdkSemaphoreRelease)
		{
			KeInitializeSemaphore(&sema, 0, 1);
			Assert::IsTrue(KeReleaseSemaphore(&sema, IO_NO_INCREMENT, 1, FALSE) == 0);
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);
		}

		TEST_METHOD(DdkSemaphoreRelease2)
		{
			KeInitializeSemaphore(&sema, 0, 2);
			Assert::IsTrue(KeReleaseSemaphore(&sema, IO_NO_INCREMENT, 2, FALSE) == 0);
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);
			
			NTSTATUS rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateSemaphore(&sema) != 0);

			rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &nowait);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(KeReadStateSemaphore(&sema) == 0);
		}

		TEST_METHOD_ASYNC(DdkSemaphoreAsync)
		{
			LARGE_INTEGER timeout;
			timeout.QuadPart = (-20) * 10000I64;

			for (int i = 0, last = 0; i < 20000; i++) {
				NTSTATUS rc = KeWaitForSingleObject(&sema, Executive, KernelMode, FALSE, &timeout);
				if (rc == STATUS_TIMEOUT) continue;

				if (TEST_IS_ASYNC) {
					Assert::IsTrue((value & 0xffff) == last);
					value = (value & 0xffff0000) + i;
					asynccount++;
				} else {
					Assert::IsTrue((value >> 16) == last);
					value = (value & 0xffff) + (i << 16);
					count++;
				}

				last = i;
				KeReleaseSemaphore(&sema, IO_NO_INCREMENT, 1, FALSE);
			}
		}

		TEST_METHOD(DdkSemaphoreMulti)
		{
			TEST_ASYNC_START(id, DdkSemaphoreAsync);
			DdkSemaphoreAsync();
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(count && asynccount);
		}
	};
}

```

`test/SpinLockTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace DdkUnitTest
{
	TEST_CLASS(DdkSpinLockTest)
	{
		KSPIN_LOCK lock;
		EX_SPIN_LOCK xlock;
		ULONG value;
		LONG count;
		LONG asynccount;
		LONG tryfail;
		LONG tryok;

	public:
		TEST_METHOD_INITIALIZE(DdkSpinLockTestInit)
		{
			DdkThreadInit();
			value = 0;
			count = asynccount = tryfail = tryok = 0;
			KeInitializeSpinLock(&lock);
			xlock = 0;
			KeLowerIrql(PASSIVE_LEVEL);
		}

		TEST_METHOD_CLEANUP(DdkSpinLockTestCleanup)
		{
			KeLowerIrql(PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockAcquire)
		{
			KIRQL irql;
			KeAcquireSpinLock(&lock, &irql);
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
		}

		TEST_METHOD(DdkSpinLockTryAcquire)
		{
			KIRQL irql;
			KeRaiseIrql(DISPATCH_LEVEL, &irql);
			Assert::IsTrue(KeTryToAcquireSpinLockAtDpcLevel(&lock) != 0);
		}

		TEST_METHOD(DdkSpinLockTryAcquireBusy)
		{
			KIRQL irql;
			KeAcquireSpinLock(&lock, &irql);
			Assert::IsTrue(KeTryToAcquireSpinLockAtDpcLevel(&lock) == 0);
		}

		TEST_METHOD(DdkSpinLockRelease)
		{
			KIRQL irql;
			KeAcquireSpinLock(&lock, &irql);
			KeReleaseSpinLock(&lock, irql);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockAcquireAtDpc)
		{
			KIRQL irql;
			KeRaiseIrql(HIGH_LEVEL, &irql);
			KeAcquireSpinLockAtDpcLevel(&lock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);

			KeReleaseSpinLockFromDpcLevel(&lock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);
			KeLowerIrql(irql);
		}

		TEST_METHOD(DdkSpinLockAcquireForDpc)
		{
			KIRQL irql = KeAcquireSpinLockForDpc(&lock);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);

			KeReleaseSpinLockForDpc(&lock, irql);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockRaiseToDpc)
		{
			KIRQL irql = KeAcquireSpinLockRaiseToDpc(&lock);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);

			KeReleaseSpinLock(&lock, irql);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockAcquireQueued)
		{
			KLOCK_QUEUE_HANDLE h;
			KeAcquireInStackQueuedSpinLock(&lock, &h);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
			KeReleaseInStackQueuedSpinLock(&h);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockAcquireQueuedAtDpc)
		{
			KLOCK_QUEUE_HANDLE h;
			KIRQL irql;
			KeRaiseIrql(DISPATCH_LEVEL, &irql);
			KeAcquireInStackQueuedSpinLockAtDpcLevel(&lock, &h);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
			KeReleaseInStackQueuedSpinLockFromDpcLevel(&h);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
			KeLowerIrql(irql);
		}

		TEST_METHOD_ASYNC(DdkSpinLockAsync)
		{
			for (int v, i = 0, last = 0; i < 8000000; i++) {
				KIRQL irql;

				if (i > 1000000 && count && asynccount && tryfail && tryok)
					break;

				if ((i % 10) != 0) KeAcquireSpinLock(&lock, &irql);
				else {
					KeRaiseIrql(DISPATCH_LEVEL, &irql);
					if (!KeTryToAcquireSpinLockAtDpcLevel(&lock)) {
						InterlockedIncrement(&tryfail);
						KeLowerIrql(irql);
						continue;
					}
					InterlockedIncrement(&tryok);
				}

				if (TEST_IS_ASYNC) {
					v = (value & 0xffff);
					value = (value & 0xffff0000) + (i & 0xffff);
					asynccount++;
				} else {
					v = (value >> 16) & 0xffff;
					value = (value & 0xffff) + (i << 16);
					count++;
				}

				KeReleaseSpinLock(&lock, irql);
				Assert::IsTrue(v == last);
				last = (i & 0xffff);
			}
		}

		TEST_METHOD(DdkSpinLockMulti)
		{
			TEST_ASYNC_START(id, DdkSpinLockAsync);
			DdkSpinLockAsync();
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(count && asynccount && tryfail && tryok);
		}

		TEST_METHOD(DdkSpinLockSharedAcquire)
		{
			KIRQL irql = ExAcquireSpinLockShared(&xlock);
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
		}

		TEST_METHOD(DdkSpinLockSharedRelease)
		{
			KIRQL irql = ExAcquireSpinLockShared(&xlock);
			ExReleaseSpinLockShared(&xlock, irql);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockSharedAcquireAtDpc)
		{
			KIRQL irql;
			KeRaiseIrql(HIGH_LEVEL, &irql);
			ExAcquireSpinLockSharedAtDpcLevel(&xlock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);

			ExReleaseSpinLockSharedFromDpcLevel(&xlock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);
			KeLowerIrql(irql);
		}

		TEST_METHOD(DdkSpinLockExclusiveAcquire)
		{
			KIRQL irql = ExAcquireSpinLockExclusive(&xlock);
			Assert::IsTrue(irql == PASSIVE_LEVEL);
			Assert::IsTrue(KeGetCurrentIrql() == DISPATCH_LEVEL);
		}

		TEST_METHOD(DdkSpinLockExclusiveRelease)
		{
			KIRQL irql = ExAcquireSpinLockExclusive(&xlock);
			ExReleaseSpinLockExclusive(&xlock, irql);
			Assert::IsTrue(KeGetCurrentIrql() == PASSIVE_LEVEL);
		}

		TEST_METHOD(DdkSpinLockExclusiveAcquireAtDpc)
		{
			KIRQL irql;
			KeRaiseIrql(HIGH_LEVEL, &irql);
			ExAcquireSpinLockExclusiveAtDpcLevel(&xlock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);

			ExReleaseSpinLockExclusiveFromDpcLevel(&xlock);
			Assert::IsTrue(KeGetCurrentIrql() == HIGH_LEVEL);
			KeLowerIrql(irql);
		}

		TEST_METHOD_ASYNC(DdkSpinLockSharedAsync)
		{
			for (int v, i = 0, last = 0; i < 1000000; i++) {
				bool ex = ((i % 10) == 0);
				KIRQL irql = (ex) ? ExAcquireSpinLockExclusive(&xlock)
								  : ExAcquireSpinLockShared(&xlock);

				if (TEST_IS_ASYNC) {
					v = (value & 0xffff);
					if (ex) value = (value & 0xffff0000) + (i & 0xffff);
					if (ex) asynccount++;
				} else {
					v = (value >> 16) & 0xffff;
					if (ex) value = (value & 0xffff) + (i << 16);
					if (ex) count++;
				}

				if (ex) ExReleaseSpinLockExclusive(&xlock, irql);
				else ExReleaseSpinLockShared(&xlock, irql);

				Assert::IsTrue(v == last);
				if (ex) last = (i & 0xffff);
			}
		}

		TEST_METHOD(DdkSpinLockSharedMulti)
		{
			TEST_ASYNC_START(id, DdkSpinLockSharedAsync);
			DdkSpinLockSharedAsync();
			TEST_ASYNC_WAIT(id);
			Assert::IsTrue(count && asynccount);
		}
	};
}

```

`test/StringTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	String Tests
 */

#include "stdafx.h"


#define MAX_STRING_LEN  0xFFFF


namespace DdkUnitTest
{
	TEST_CLASS(DdkStringTest)
	{
	public:

		/*
		 * Initialise a short string 
		 */		
		TEST_METHOD(DdkStringInitShort)
		{
			const PCSZ s = "abc";
			STRING s1;
			RtlInitString(&s1, s);
			Assert::IsTrue(s1.Buffer == s);
			Assert::IsTrue(s1.Length == strlen(s));
			Assert::IsTrue(s1.MaximumLength == strlen(s) + 1);
		}

		/*
		 * Initialize an empty string
		 */
		TEST_METHOD(DdkStringInitNull)
		{
			const PCSZ s = NULL;
			STRING s1;
			RtlInitString(&s1, s);
			Assert::IsTrue(s1.Buffer == NULL);
			Assert::IsTrue(s1.Length == 0);
			Assert::IsTrue(s1.MaximumLength == 0);
		}

		/*
		 * Initialize a maximum-length string
		 */
		TEST_METHOD(DdkStringInitLong)
		{
			const LONG STRING_LEN = MAX_STRING_LEN; 
			STRING s1;
			char *s = (char*)malloc((STRING_LEN) * sizeof(char)); 
			Assert::IsTrue(s != NULL);
			memset(s, L'A', STRING_LEN - 1);
			s[STRING_LEN - 1] = 0;
			RtlInitString(&s1, s);

			Assert::IsTrue(s1.Buffer == s);
			Assert::IsTrue(s1.Length == strlen(s));
			Assert::IsTrue(s1.MaximumLength == strlen(s) + 1);
			
			free(s);			
		}

		/*
		 * Initialize a string which is too long
		 */
		TEST_METHOD(DdkStringInitTooLong)
		{
			const LONG STRING_LEN = MAX_STRING_LEN + 1;
			STRING s1;
			char *s = (char*)malloc((STRING_LEN) * sizeof(char));
			Assert::IsTrue(s != NULL);
			memset(s, L'A', STRING_LEN - 1);
			s[STRING_LEN - 1] = 0;

			TEST_DDK_FAIL(RtlInitString(&s1, s));
			
			free(s);
		}

		/*
		 * Compare 2 identical strings with the same case
		 */
		TEST_METHOD(DdkStringCompareIdentical)
		{
			STRING str1 = RTL_CONSTANT_STRING("abcde");
			STRING str2 = RTL_CONSTANT_STRING("abcde");
			Assert::IsTrue(RtlCompareString(&str1, &str2, TRUE) == 0);
			Assert::IsTrue(RtlCompareString(&str1, &str2, FALSE) == 0);
		}

		/*
		 * Compare 2 different strings
		 */
		TEST_METHOD(DdkStringCompareDiff)
		{
			STRING str1 = RTL_CONSTANT_STRING("abcde1");
			STRING str2 = RTL_CONSTANT_STRING("abcde2");
			Assert::IsTrue(RtlCompareString(&str1, &str2, TRUE) < 0);
			Assert::IsTrue(RtlCompareString(&str1, &str2, FALSE) < 0);
		}

		/*
		 * Compare 2 strings, which differ only by case
		 */
		TEST_METHOD(DdkStringCompareDiffCase)
		{
			STRING str1 = RTL_CONSTANT_STRING("Abcde");
			STRING str2 = RTL_CONSTANT_STRING("abcde");
			Assert::IsTrue(RtlCompareString(&str1, &str2, TRUE) == 0);
			Assert::IsTrue(RtlCompareString(&str1, &str2, FALSE) != 0);
		}		

		TEST_METHOD(DdkStringCompareLess)
		{
			STRING str1 = RTL_CONSTANT_STRING("Firs");
			STRING str2 = RTL_CONSTANT_STRING("first");
			Assert::IsTrue(RtlCompareString(&str1, &str2, TRUE) < 0);
		}

		TEST_METHOD(DdkStringCompareGreater)
		{
			STRING str1 = RTL_CONSTANT_STRING("First12");
			STRING str2 = RTL_CONSTANT_STRING("first");
			Assert::IsTrue(RtlCompareString(&str1, &str2, TRUE) > 0);
		}

		TEST_METHOD(DdkStringCompareUnequal)
		{
			STRING str1 = RTL_CONSTANT_STRING("First");
			STRING str2 = RTL_CONSTANT_STRING("Last");
			Assert::IsFalse(RtlCompareString(&str1, &str2, TRUE) == 0);
		}
				
		/* 
		 * Copy string from one buffer to another
		 */
		TEST_METHOD(DdkStringCopy)
		{
			const STRING sourceStr = RTL_CONSTANT_STRING("abcde");
			const USHORT maxLength = 6;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlCopyString(&destinationStr, &sourceStr);

			Assert::IsTrue(destinationStr.Length == sourceStr.Length);
			Assert::IsTrue(memcmp(destinationStr.Buffer, sourceStr.Buffer, sourceStr.Length) == 0);

			delete[] destinationStr.Buffer;
			destinationStr.Buffer = NULL;
		}

		/*
		* Attempt to copy a string from one buffer to a smaller buffer
		*/
		TEST_METHOD(DdkStringCopyShortDestination)
		{
			const STRING sourceStr = RTL_CONSTANT_STRING("abcde");
			const USHORT maxLength = 3;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlCopyString(&destinationStr, &sourceStr);

			Assert::IsTrue(destinationStr.Length == maxLength);
			Assert::IsTrue(memcmp(destinationStr.Buffer, sourceStr.Buffer, destinationStr.MaximumLength) == 0);

			delete[] destinationStr.Buffer;
			destinationStr.Buffer = NULL;
		}

		/*
		 * Attempt to copy a NULL string
		 */
		TEST_METHOD(DdkStringCopyNullSource)
		{
			const USHORT maxLength = 3;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlCopyString(&destinationStr, NULL);

			Assert::IsTrue(destinationStr.Length == 0);

			delete[] destinationStr.Buffer;
			destinationStr.Buffer = NULL;
		}

		TEST_METHOD(DdkStringCopyNullDestination)
		{
			const STRING s = RTL_CONSTANT_STRING("AbCdE");

			TEST_DDK_FAIL(RtlCopyString(NULL, &s));
		}

		TEST_METHOD(DdkStringEqualCaseSensitiveSucceed)
		{
			const STRING s1 = RTL_CONSTANT_STRING("aBcDe");
			const STRING s2 = RTL_CONSTANT_STRING("aBcDe");

			Assert::IsTrue(RtlEqualString(&s1, &s2, FALSE) == TRUE);
		}

		/*
		 * Compare two strings which differ only by case
		 */
		TEST_METHOD(DdkStringEqualCaseSensitiveFail)
		{
			const STRING s1 = RTL_CONSTANT_STRING("aBcDe");
			const STRING s2 = RTL_CONSTANT_STRING("AbCdE");

			Assert::IsFalse(RtlEqualString(&s1, &s2, FALSE) == TRUE);
		}

		TEST_METHOD(DdkStringEqualCaseInSensitive)
		{
			const STRING s1 = RTL_CONSTANT_STRING("abcde");
			const STRING s2 = RTL_CONSTANT_STRING("aBcDE");

			Assert::IsTrue(RtlEqualString(&s1, &s2, TRUE) == TRUE);
		}

		/*
		 * Compare two strings of different length
		 */
		TEST_METHOD(DdkStringUnequal)
		{
			const STRING s1 = RTL_CONSTANT_STRING("abcde");
			const STRING s2 = RTL_CONSTANT_STRING("abc");

			Assert::IsFalse(RtlEqualString(&s1, &s2, TRUE) == TRUE);
		}

		/*
		 * Convert lower case string to upper case
		 */
		TEST_METHOD(DdkStringLowerToUpper)
		{
			const STRING expectedStr = RTL_CONSTANT_STRING("ABCDE");
			const STRING sourceStr = RTL_CONSTANT_STRING("abcde");
			const USHORT maxLength = 6;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlUpperString(&destinationStr, &sourceStr);

			Assert::IsTrue(destinationStr.Length == expectedStr.Length);
			Assert::IsTrue(memcmp(destinationStr.Buffer, expectedStr.Buffer, expectedStr.Length) == 0);

			delete[] destinationStr.Buffer;
			destinationStr.Buffer = NULL;
		}

		TEST_METHOD(DdkStringMixedToUpper)
		{
			const STRING expectedStr = RTL_CONSTANT_STRING("ABCDE");
			const STRING sourceStr = RTL_CONSTANT_STRING("aBcDe");
			const USHORT maxLength = 6;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlUpperString(&destinationStr, &sourceStr);

			Assert::IsTrue(destinationStr.Length == expectedStr.Length);
			Assert::IsTrue(memcmp(destinationStr.Buffer, expectedStr.Buffer, expectedStr.Length) == 0);
		}
		
		TEST_METHOD(DdkStringUpperToUpper)
		{
			const STRING expectedStr = RTL_CONSTANT_STRING("ABCDE");
			const STRING sourceStr = RTL_CONSTANT_STRING("ABCDE");
			const USHORT maxLength = 6;

			STRING destinationStr;
			destinationStr.MaximumLength = maxLength;
			destinationStr.Buffer = new char[maxLength];

			RtlUpperString(&destinationStr, &sourceStr);

			Assert::IsTrue(destinationStr.Length == expectedStr.Length);
			Assert::IsTrue(memcmp(destinationStr.Buffer, expectedStr.Buffer, expectedStr.Length) == 0);
		}
	};
}

```

`test/SymLinkTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Symbolic Link Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkSymLinkTest)
	{
		PDRIVER_OBJECT pDriver;
		PDEVICE_OBJECT pDevice;
		PFILE_OBJECT pFile;
		UNICODE_STRING udev;
		UNICODE_STRING ulink;
		
		char DriverName[100];
		wchar_t DeviceName[100];
		wchar_t LinkName[100];

		static NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
		{
			DdkSymLinkTest *pTest = (DdkSymLinkTest *)_wtoll(&DriverObject->DriverName.Buffer[3]);
			pTest->pDriver = DriverObject;
			return STATUS_SUCCESS;
		}

	public:
		TEST_METHOD_INITIALIZE(DdkSymLinkTestInit)
		{
			DdkThreadInit();

			sprintf(DriverName, "DRV%I64d:%d", (LONGLONG)this, GetUniqueId());
			swprintf(DeviceName, L"\\Device\\D%I64d:%d", (LONGLONG)this, GetUniqueId());
			swprintf(LinkName, L"\\Device\\L%I64d:%d", (LONGLONG)this, GetUniqueId());

			pDriver = 0;
			pDevice = 0;
			pFile = 0;

			RtlInitUnicodeString(&udev, DeviceName);
			RtlInitUnicodeString(&ulink, LinkName);

			NTSTATUS rc = DdkInitDriver(DriverName, DriverEntry);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsNotNull(pDriver);

			rc = IoCreateDevice(pDriver, 200, &udev, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsNotNull(pDevice);
		}

		TEST_METHOD_CLEANUP(DdkSymLinkTestCleanup)
		{
			IoDeleteSymbolicLink(&ulink);
			if (pFile) ObDereferenceObject(pFile);
			if (pDevice) IoDeleteDevice(pDevice);
			if (pDriver) DdkUnloadDriver(DriverName);
		}

		TEST_METHOD(DdkSymLinkCreate)
		{
			NTSTATUS rc = IoCreateSymbolicLink(&ulink, &udev);
			Assert::IsTrue(rc == STATUS_SUCCESS);
		}

		TEST_METHOD(DdkSymLinkCreateExists)
		{
			NTSTATUS rc = IoCreateSymbolicLink(&ulink, &udev);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			rc = IoCreateSymbolicLink(&ulink, &udev);
			Assert::IsTrue(rc == STATUS_OBJECT_NAME_EXISTS);
		}

		TEST_METHOD(DdkSymLinkOpen)
		{
			NTSTATUS rc = IoCreateSymbolicLink(&ulink, &udev);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			PDEVICE_OBJECT pDevice2;
			rc = IoGetDeviceObjectPointer(&ulink, 0, &pFile, &pDevice2);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsTrue(pDevice2 == pDevice);
			Assert::IsTrue(pFile->DeviceObject == pDevice);
		}

		TEST_METHOD(DdkSymLinkDelete)
		{
			NTSTATUS rc = IoCreateSymbolicLink(&ulink, &udev);
			Assert::IsTrue(rc == STATUS_SUCCESS);

			IoDeleteSymbolicLink(&ulink);

			PDEVICE_OBJECT pDevice2;
			rc = IoGetDeviceObjectPointer(&ulink, 0, &pFile, &pDevice2);
			Assert::IsTrue(rc == STATUS_OBJECT_NAME_NOT_FOUND);
		}
	};
}

```

`test/Test.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	DDK Unit Test Initialization
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_MODULE_INITIALIZE(DdkUnitTestInit)
	{
		TEST_MODULE_START(DdkUnitTestCleanup);
	}

	TEST_MODULE_CLEANUP(DdkUnitTestCleanup)
	{
		TEST_MODULE_END();
	}

	LONG GetUniqueId() {
		static volatile LONG value = 0;
		return InterlockedIncrement(&value);
	}
}

```

`test/Test.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013-2014, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Test Definitions
 */

namespace DdkUnitTest { LONG GetUniqueId(); }

#define TEST_DDK_FAIL(call) TEST_EXPECT_ASSERT(call)

```

`test/ThreadTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Thread Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkThreadTest)
	{
		const int DefaultThreadPriority = 8;

		HANDLE child;
		HANDLE h;

	public:
		TEST_METHOD_INITIALIZE(DdkThreadTestInit)
		{
			DdkThreadInit();
			child = 0;
			h = 0;

			KeSetBasePriorityThread(KeGetCurrentThread(), 0);
			KeSetPriorityThread(KeGetCurrentThread(), DefaultThreadPriority);
		}

		TEST_METHOD_CLEANUP(DdkThreadTestCleanup)
		{
			if (h) ZwClose(h);

			KeSetBasePriorityThread(KeGetCurrentThread(), 0);
			KeSetPriorityThread(KeGetCurrentThread(), DefaultThreadPriority);
		}

		TEST_METHOD(DdkThreadId)
		{
			Assert::IsNotNull(PsGetCurrentThread());
			Assert::IsNotNull(PsGetCurrentThreadId());
		}

		TEST_METHOD(DdkThreadSystem)
		{
			Assert::IsTrue(PsIsSystemThread(PsGetCurrentThread()) == TRUE);
			Assert::IsTrue(PsGetCurrentProcess() == PsInitialSystemProcess);
		}

		TEST_METHOD(DdkThreadProcessId)
		{
			Assert::IsNotNull(PsGetCurrentProcess());
			Assert::IsNotNull(PsGetCurrentProcessId());
			Assert::IsTrue(PsGetProcessId(PsGetCurrentProcess()) == PsGetCurrentProcessId());	
		}

		TEST_METHOD_CALLBACK(DdkThreadProc, PVOID Context)
		{
			PKTHREAD pkThread = KeGetCurrentThread();
			child = PsGetCurrentThreadId();
						
			Assert::IsTrue(KeQueryPriorityThread(pkThread) == DefaultThreadPriority);
			Assert::IsTrue(KeSetBasePriorityThread(pkThread, 0) == 0);
		}
	
		TEST_METHOD(DdkThreadCreate)
		{
			TEST_CALLBACK_INIT(cb);

			NTSTATUS rc = PsCreateSystemThread(&h,
				THREAD_ALL_ACCESS, NULL, NULL, NULL, DdkThreadProc, cb); 

			Assert::IsNotNull(h);
			Assert::IsTrue(h != PsGetCurrentThreadId());

			TEST_CALLBACK_WAIT(cb);

			Assert::IsNotNull(child);
			Assert::IsTrue(child != PsGetCurrentThreadId());
		}

		TEST_METHOD(DdkThreadQueryPriorityDefault)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			Assert::IsTrue(DefaultThreadPriority == KeQueryPriorityThread(currentThread));
		}

		TEST_METHOD(DdkThreadSetPriorityIncrement)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			for (int priority = DefaultThreadPriority + 1; priority <= 31; priority++){
				Assert::IsTrue(KeSetPriorityThread(currentThread, priority) == priority - 1);
				Assert::IsTrue(KeQueryPriorityThread(currentThread) == priority);
			}
		}

		TEST_METHOD(DdkThreadSetPriorityDecrement)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			for (int priority = DefaultThreadPriority - 1; priority >= 0; priority--){
				Assert::IsTrue(KeSetPriorityThread(currentThread, priority) == priority + 1);
				Assert::IsTrue(KeQueryPriorityThread(currentThread) == priority);
			}
		}

		TEST_METHOD(DdkThreadSetPriorityBelowMin)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			KeSetPriorityThread(currentThread, -1);
			Assert::IsTrue(KeQueryPriorityThread(currentThread) == 0);
		}

		TEST_METHOD(DdkThreadSetPriorityAboveMax)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			KeSetPriorityThread(currentThread, 32);
			Assert::IsTrue(KeQueryPriorityThread(currentThread) == 31);
		}

		TEST_METHOD(DdkThreadSetBasePriorityIncrement)
		{
			PKTHREAD currentThread = KeGetCurrentThread();
			PEPROCESS currentProcess = PsGetCurrentProcess();

			KPRIORITY oldBaseDif = KeSetBasePriorityThread(currentThread, 0);
			Assert::IsTrue(oldBaseDif == 0);

			for (int i = 1; i < 16; i++) {
				oldBaseDif = KeSetBasePriorityThread(currentThread, i);
				Assert::IsTrue(oldBaseDif == i - 1);
			}
		}

		TEST_METHOD(DdkThreadSetBasePriorityDecrement)
		{
			PKTHREAD currentThread = KeGetCurrentThread();

			KPRIORITY oldBaseDif = KeSetBasePriorityThread(currentThread, 0);
			Assert::IsTrue(KeSetBasePriorityThread(currentThread, 0) == 0);

			for (int i = -1; i > -16; i--) {
				oldBaseDif = KeSetBasePriorityThread(currentThread, i);
				Assert::IsTrue(oldBaseDif == i + 1);
			}
		}
	};
}

```

`test/TimeTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Time Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkTimeTest)
	{
	public:
		TEST_METHOD_INITIALIZE(DdkTimeTestInit)
		{
			DdkThreadInit();
		}

		TEST_METHOD(DdkTimeTickCount)
		{
			for (int i = 0; true; i++) {
				ULONGLONG x = GetTickCount64(), v;

				KeQueryTickCount(&v);
				v = (v * KeQueryTimeIncrement()) / 10000;

				if (x == v) break;
				Assert::IsTrue(i < 10);
			}
		}

		/*
		 * Convert LARGE_INTEGER to TIME_FIELDS
		 */
		TEST_METHOD(DdkTimeToTimeFields)
		{
			LARGE_INTEGER time;
			time.QuadPart = 123479190430320000;
			const TIME_FIELDS expectedTimeFields = { 1992, 4, 16, 17, 30, 43, 32, 4 };
			TIME_FIELDS timeFields;

			RtlTimeToTimeFields(&time, &timeFields);

			Assert::IsTrue(memcmp(&expectedTimeFields, &timeFields, sizeof(expectedTimeFields)) == 0);
		}

		/*
		 * Convert LARGE_INTEGER to TIME_FIELDS at zero day
		 */
		TEST_METHOD(DdkTimeToTimeFieldsZero)
		{
			TIME_FIELDS timeFields;
			LARGE_INTEGER time = { 0 }; // January 1st 1601
			const TIME_FIELDS expectedTimeFields = { 1601, 1, 1, 0, 0, 0, 0, 1 };

			RtlTimeToTimeFields(&time, &timeFields);

			Assert::IsTrue(memcmp(&expectedTimeFields, &timeFields, sizeof(expectedTimeFields)) == 0);
		}

		/*
		 * Convert TIME_FIELDS to LARGE_INTEGER
		 */
		TEST_METHOD(DdkTimeFieldsToTime)
		{			
			LARGE_INTEGER time, expectedTime;
			TIME_FIELDS timeFields = { 1992, 4, 16, 17, 30, 43, 32, 4 };

			expectedTime.QuadPart = 123479190430320000;

			BOOLEAN returnValue = RtlTimeFieldsToTime(&timeFields, &time);

			Assert::IsTrue(time.QuadPart == expectedTime.QuadPart);
			Assert::IsTrue(returnValue == TRUE);
		}

		/*
		 * Convert TIME_FIELDS to LARGE_INTEGER at zero time
		 */
		TEST_METHOD(DdkTimeFieldsToTimeZero)
		{
			const LARGE_INTEGER expectedTime = { 0 }; // January 1st 1601

			LARGE_INTEGER time;
			TIME_FIELDS timeFields = { 1601, 1, 1, 0, 0, 0, 0, 1 };
			
			BOOLEAN returnValue = RtlTimeFieldsToTime(&timeFields, &time);

			Assert::IsTrue(time.QuadPart == expectedTime.QuadPart);
			Assert::IsTrue(returnValue == TRUE);
		}

		/*
		 * Retrieve the current system time as a Large_Integer
		 */
		TEST_METHOD(DdkTimeQuerySystemTime)
		{
			LARGE_INTEGER li1, li2;
			FILETIME ft;
			
			GetSystemTimeAsFileTime(&ft);
			KeQuerySystemTime(&li1);
			KeQuerySystemTimePrecise(&li2);

			FILETIME kernelTime1, kernelTime2;
			kernelTime1.dwHighDateTime = li1.HighPart;
			kernelTime1.dwLowDateTime = li1.LowPart;
			
			kernelTime2.dwHighDateTime = li2.HighPart;
			kernelTime2.dwLowDateTime = li2.LowPart;

			Assert::IsTrue(CompareFileTime(&ft, &kernelTime1) <= 0);
			Assert::IsTrue(CompareFileTime(&kernelTime1, &kernelTime2) <= 0);
		}

		/*
		 * Retrieve the current precise time as a Large_Integer
		 */
		TEST_METHOD(DdkTimeQuerySystemTimePrecise)
		{
			LARGE_INTEGER li1, li2;
			FILETIME ft;

			GetSystemTimeAsFileTime(&ft);
			KeQuerySystemTimePrecise(&li1);
			KeQuerySystemTimePrecise(&li2);

			FILETIME kernelTime1, kernelTime2;
			kernelTime1.dwHighDateTime = li1.HighPart;
			kernelTime1.dwLowDateTime = li1.LowPart;

			kernelTime2.dwHighDateTime = li2.HighPart;
			kernelTime2.dwLowDateTime = li2.LowPart;

			Assert::IsTrue(CompareFileTime(&ft, &kernelTime1) <= 0);
			Assert::IsTrue(CompareFileTime(&kernelTime1, &kernelTime2) <= 0);
		}

	};
}

```

`test/TimerTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Timer Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkTimerTest)
	{
		KTIMER timer;
		KEVENT asyncEvent;
		LARGE_INTEGER dueTime;
		LARGE_INTEGER maxTime;
		LARGE_INTEGER timeStart;
		LONG count;

		static const int ThreadCount = 3;
		static const int PeriodicTimerIterations = 10;

		static const LONGLONG msec = 10000I64;

	public:
		TEST_METHOD_INITIALIZE(DdkTimerTestInit)
		{
			DdkThreadInit();
			KeInitializeEvent(&asyncEvent, SynchronizationEvent, FALSE);
			KeQuerySystemTime(&timeStart);

			dueTime.QuadPart = -30 * msec;
			maxTime.QuadPart = -60 * 1000 * msec;
			count = 0;
		}

		TEST_METHOD_CLEANUP(DdkTimerTestCleanup)
		{
			KeCancelTimer(&timer);
			KeFlushQueuedDpcs();
		}

		/*
		 *	On a loaded system the time intervals can be significantly
		 *	extended so the validation is fairly slack.
		 */
		bool CheckTime(LONGLONG expect) {
			LARGE_INTEGER timeEnd;
			KeQuerySystemTime(&timeEnd);

			LONGLONG delta = (timeEnd.QuadPart - timeStart.QuadPart);
			return (delta + 30 * msec >= expect) && (delta <= expect + 20 * 1000 * msec);
		}

		/*
		 *	Initialise and set a timer and test the initial state
		 */
		TEST_METHOD(DdkTimerInit)
		{
			KeInitializeTimer(&timer);
			Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);

			KeInitializeTimerEx(&timer, NotificationTimer);
			Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);

			KeInitializeTimerEx(&timer, SynchronizationTimer);
			Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);
		}

		/*
		 *	Initialise and cancel a timer
		 */
		TEST_METHOD(DdkTimerCancel)
		{
			KeInitializeTimer(&timer);
			Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);
			Assert::IsTrue(KeCancelTimer(&timer) == FALSE);
		}

		/*
		 *	Initialise and set a one-shot timer and then wait for it to complete
		 */
		TEST_METHOD(DdkTimerNotificationWait)
		{
			KeInitializeTimerEx(&timer, NotificationTimer);

			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, 0, NULL) == FALSE);
			Assert::IsTrue(KeWaitForSingleObject(&timer, Executive, KernelMode, FALSE, &maxTime) == STATUS_SUCCESS);

			Assert::IsTrue(CheckTime(-dueTime.QuadPart));
			Assert::IsTrue(KeReadStateTimer(&timer) == TRUE);
		}

		/*
		 *	Initialise and set a one-shot timer and then wait for it to complete
		 */
		TEST_METHOD(DdkTimerSynchronizationWait)
		{
			KeInitializeTimerEx(&timer, SynchronizationTimer);

			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, 0, NULL) == FALSE);
			Assert::IsTrue(KeWaitForSingleObject(&timer, Executive, KernelMode, FALSE, &maxTime) == STATUS_SUCCESS);

			Assert::IsTrue(CheckTime(-dueTime.QuadPart));
			Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);
		}

		TEST_METHOD_CALLBACK(DdkTimerCallback, PRKDPC Dpc,
			PVOID Context, PVOID Arg1, PVOID Arg2)
		{
			Assert::IsTrue(KeReadStateTimer(&timer) == TRUE);
			count++;
		}

		/*
		 *	Initialise and set a one-shot timer, specify a DPC then wait for the DPC to run
		 */
		TEST_METHOD(DdkTimerDpc)
		{
			TEST_CALLBACK_INIT(id);

			KDPC dpc;
			KeInitializeDpc(&dpc, &DdkTimerCallback, id);
			KeInitializeTimerEx(&timer, NotificationTimer);
			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, 0, &dpc) == FALSE);

			TEST_CALLBACK_WAIT(id);

			Assert::IsTrue(CheckTime(-dueTime.QuadPart));
			Assert::IsTrue(count == 1);
			Assert::IsTrue(KeReadStateTimer(&timer) == TRUE);
		}

		/*
		 *	Initialise and set a periodic Synchronization Timer, wait for it to complete
		 *	several times, then cancel it. Using (TIMER_TYPE = NotificationTimer and Period != 0)
		 *	is not so useful as in this case, according to the DDK: "all waiting threads are
		 *	released and the timer remains in the signaled state until it is explicitly reset"
		 *	as it's not obvious which API to use to reset the timer.
		 */
		TEST_METHOD(DdkTimerPeriodicSynchronization)
		{
			KeInitializeTimerEx(&timer, SynchronizationTimer);

			const int repeatMsec = 20;
			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, repeatMsec, NULL) == FALSE);

			for (int i = 0; i < PeriodicTimerIterations; i++) {
				Assert::IsTrue(KeWaitForSingleObject(&timer, Executive, KernelMode, FALSE, &maxTime) == STATUS_SUCCESS);
				Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);
				Assert::IsTrue(CheckTime(-dueTime.QuadPart + i * repeatMsec * msec));
			}

			Assert::IsTrue(KeCancelTimer(&timer) == TRUE);
		}

		/*
		 *	Initialise and set a periodic timer, specify a DPC, wait for it to complete
		 *	several times, then cancel it.
		 *	Warning: calling Logger::PrintMessage() completely messes up the timings (!)
		 */
		TEST_METHOD(DdkTimerPeriodicDpc)
		{
			TEST_CALLBACK_INIT(id);

			KDPC dpc;
			KeInitializeDpc(&dpc, &DdkTimerCallback, id);
			KeInitializeTimerEx(&timer, NotificationTimer);

			const int repeatMsec = 10;
			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, repeatMsec, &dpc) == FALSE);

			for (int i = 0; i < PeriodicTimerIterations; i++) {
				TEST_CALLBACK_WAIT(id);
				Assert::IsTrue(CheckTime(-dueTime.QuadPart + i * repeatMsec * msec));
			}

			Assert::IsTrue(KeCancelTimer(&timer) == TRUE);
		}

		TEST_METHOD_ASYNC(DdkTimerAsync)
		{
			Assert::IsTrue(KeWaitForSingleObject(&timer, Executive, KernelMode, FALSE, &maxTime) == STATUS_SUCCESS);
			count++;
			KeSetEvent(&asyncEvent, IO_NO_INCREMENT, FALSE);
		}

		/*
		 *	Create several threads all waiting on a synchronization timer.
		 *	Verify that only one thread is released each time the timer expires.
		 */
		TEST_METHOD(DdkTimerSynchronizationMultipleThreads)
		{
			KeInitializeTimerEx(&timer, SynchronizationTimer);

			TEST_ASYNC_START_VEC(id, DdkTimerAsync, ThreadCount);

			for (int i = 0; i < ThreadCount; i++) {
				Assert::IsTrue(KeSetTimerEx(&timer, dueTime, 0, NULL) == FALSE);
				Assert::IsTrue(KeWaitForSingleObject(&asyncEvent, Executive, KernelMode, FALSE, &maxTime) == STATUS_SUCCESS);
				Assert::IsTrue(KeReadStateTimer(&timer) == FALSE);
				Assert::IsTrue(count == i+1);
			}

			TEST_ASYNC_WAIT_VEC(id);
			Assert::IsTrue(KeCancelTimer(&timer) == FALSE);
		}

		/*
		 *	Create several threads waiting on a notification timer.
		 *	All threads should be released when the timer expires.
		 */
		TEST_METHOD(DdkTimerNotificationMultipleThreads)
		{
			KeInitializeTimerEx(&timer, NotificationTimer);

			TEST_ASYNC_START_VEC(id, DdkTimerAsync, ThreadCount);
			Assert::IsTrue(KeSetTimerEx(&timer, dueTime, 0, NULL) == FALSE);
			TEST_ASYNC_WAIT_VEC(id);

			Assert::IsTrue(KeReadStateTimer(&timer) == TRUE);
			Assert::IsTrue(KeCancelTimer(&timer) == FALSE);
		}
	};
}

```

`test/UnicodeTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2016, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	String Tests
 */

#include "stdafx.h"
#include "initguid.h"


// The maximum MaximumLength for a UNICODE_STRING 
#define MAX_USTRING_WCHARS (MAXUSHORT / sizeof(WCHAR))			// 0x7FFF  WCHARs


namespace DdkUnitTest
{
	DEFINE_GUID(UNICODE_TEST_GUID, 0x6B29FC40, 0xCA47, 0x1067, 0xB3, 0x1D, 0x00, 0xDD, 0x01, 0x06, 0x62, 0xDA);

	TEST_CLASS(DdkUnicodeTest)
	{
	public:

		/*
		 * Initialise a short string 
		 */
		TEST_METHOD(DdkUnicodeInitStringShort)
		{
			UNICODE_STRING unicodeString;
			const WCHAR* wideString = L"abc";
			RtlInitUnicodeString(&unicodeString, wideString);
			Assert::IsTrue(unicodeString.Buffer == wideString);
			Assert::IsTrue(unicodeString.Length == wcslen(wideString) * sizeof(WCHAR));
			Assert::IsTrue(unicodeString.MaximumLength == (wcslen(wideString) * sizeof(WCHAR)) + sizeof(WCHAR));
		}

		/*
		 * Initialize an empty string
		 */
		TEST_METHOD(DdkUnicodeInitStringEmpty)
		{
			UNICODE_STRING unicodeString;
			const WCHAR* wideString = NULL;
			RtlInitUnicodeString(&unicodeString, wideString);
			Assert::IsTrue(unicodeString.Buffer == NULL);
			Assert::IsTrue(unicodeString.Length == 0);
			Assert::IsTrue(unicodeString.MaximumLength == 0);
		}

		/*
		 * Pass a maximum-length string (MAXUSHORT -1) to RtlInitUnicodeString;
		 */
		TEST_METHOD(DdkUnicodeInitStringLong)
		{
			const LONG64 STRING_LEN = MAX_USTRING_WCHARS;	// 0x7FFF
			UNICODE_STRING unicodeString;
			WCHAR* wideString = (WCHAR*)malloc((STRING_LEN) * sizeof(WCHAR));	// allocate space for string + a null terminator
			Assert::IsTrue(wideString != NULL);
			wmemset(wideString, L'A', STRING_LEN-1);
			wideString[STRING_LEN-1] = UNICODE_NULL;
			RtlInitUnicodeString(&unicodeString, wideString);

			Assert::IsTrue(unicodeString.Buffer == wideString);
			Assert::IsTrue(unicodeString.Length == wcslen(wideString) * sizeof(WCHAR));
			Assert::IsTrue(unicodeString.MaximumLength == (wcslen(wideString) * sizeof(WCHAR)) + sizeof(WCHAR));

			free(wideString);
		}

		/*
		 * Pass a string which is too long (> MAXUSHORT -1) to RtlInitUnicodeString; 
		 * RtlInitUnicodeString should call ddkfail when this happens
		 */
		TEST_METHOD(DdkUnicodeInitStringTooLong)
		{
			const LONG64 STRING_LEN = MAX_USTRING_WCHARS + 1;	// 0x8000
			UNICODE_STRING unicodeString;
			WCHAR* wideString = (WCHAR*) malloc((STRING_LEN) * sizeof(WCHAR));	// allocate space for string + a null terminator
			Assert::IsTrue(wideString != NULL);
			wmemset(wideString, L'A', STRING_LEN-1);
			wideString[STRING_LEN-1] = 0;
			
			TEST_DDK_FAIL(RtlInitUnicodeString(&unicodeString, wideString));

			free(wideString);
		}

		/*
		 * Copy a short unicode string to a destination unicode string with sufficient buffer space
		 */
		TEST_METHOD(DdkUnicodeCopyStringShort)
		{
			UNICODE_STRING unicodeStringSrc;
			const WCHAR* wideStringSrc = L"abc";
			RtlInitUnicodeString(&unicodeStringSrc, wideStringSrc);

			const int DestStringLen = 4;
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, DestStringLen);

			RtlCopyUnicodeString(&unicodeStringDst, &unicodeStringSrc);

			Assert::IsTrue(unicodeStringDst.Buffer == unicodeStringDst_buffer);					// dest buffer should be unmodified
			Assert::IsTrue(unicodeStringDst.MaximumLength == sizeof(unicodeStringDst_buffer));	// dest buffer size should be unmodified
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringSrc.Length);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringSrc.Buffer, unicodeStringSrc.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Copy a short unicode string to a destination unicode string with insufficient buffer space
		 */
		TEST_METHOD(DdkUnicodeCopyStringTruncated)
		{
			UNICODE_STRING unicodeStringSrc;
			const WCHAR* wideStringSrc = L"abc";
			RtlInitUnicodeString(&unicodeStringSrc, wideStringSrc);

			const int DestStringLen = 2;
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, DestStringLen);

			RtlCopyUnicodeString(&unicodeStringDst, &unicodeStringSrc);

			Assert::IsTrue(unicodeStringDst.Buffer == unicodeStringDst_buffer);					// dest buffer should be unmodified
			Assert::IsTrue(unicodeStringDst.MaximumLength == sizeof(unicodeStringDst_buffer));	// dest buffer size should be unmodified
			Assert::IsTrue(unicodeStringDst.Length == DestStringLen * sizeof(WCHAR));
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringSrc.Buffer, DestStringLen) == 0);
		}

		/*
		 * Copy an empty unicode string
		 */
		TEST_METHOD(DdkUnicodeCopyStringEmpty)
		{
			const int DestStringLen = 2;
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, DestStringLen);

			RtlCopyUnicodeString(&unicodeStringDst, NULL);

			Assert::IsTrue(unicodeStringDst.Buffer == unicodeStringDst_buffer);					// dest buffer should be unmodified
			Assert::IsTrue(unicodeStringDst.MaximumLength == sizeof(unicodeStringDst_buffer));	// dest buffer size should be unmodified
			Assert::IsTrue(unicodeStringDst.Length == 0);
		}

		/*
		 * Convert an unsigned integer to a string
		 */
		TEST_METHOD(DdkUnicodeIntegerToString)
		{
			ULONG base = 10;
			const unsigned int num = 2147483647;
			const WCHAR valStr[] = L"2147483647";

			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, (sizeof(valStr) / sizeof(WCHAR)));

			NTSTATUS status = RtlIntegerToUnicodeString(num, base, &unicodeStringDst);
			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == wcslen(valStr) * sizeof(WCHAR));
			Assert::IsTrue(wcsncmp(unicodeStringDst_buffer, valStr, unicodeStringDst.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Convert an integer to a hex string
		 */
		TEST_METHOD(DdkUnicodeIntegerToStringHex)
		{
			ULONG base = 16;
			const unsigned int num = 0x12345678;
			const WCHAR valStr[] = L"12345678";

			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, (sizeof(valStr) / sizeof(WCHAR)));

			NTSTATUS status = RtlIntegerToUnicodeString(num, base, &unicodeStringDst);
			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == wcslen(valStr) * sizeof(WCHAR));
			Assert::IsTrue(wcsncmp(unicodeStringDst_buffer, valStr, unicodeStringDst.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Convert an integer to a binary string
		 */
		TEST_METHOD(DdkUnicodeIntegerToStringBinary)
		{
			ULONG base = 2;
			const unsigned int num = 0xFFFFFFFE;
			const WCHAR valStr[] = L"11111111111111111111111111111110";

			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, (sizeof(valStr) / sizeof(WCHAR)));

			NTSTATUS status = RtlIntegerToUnicodeString(num, base, &unicodeStringDst);
			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == wcslen(valStr) * sizeof(WCHAR));
			Assert::IsTrue(wcsncmp(unicodeStringDst_buffer, valStr, unicodeStringDst.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Convert an integer to a string where the string buffer supplied is too small
		 */
		TEST_METHOD(DdkUnicodeIntegerToStringOverflow)
		{
			ULONG base = 10;
			const unsigned int num = 1234567890;
			const WCHAR valStr[] = L"1234567890";

			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 2);	// declare a 2 char buffer

			NTSTATUS status = RtlIntegerToUnicodeString(num, base, &unicodeStringDst);
			Assert::IsTrue(status == STATUS_BUFFER_OVERFLOW);
		}

		/*
		 * Compare 2 identical strings with the same case
		 */
		TEST_METHOD(DdkUnicodeCompareStringsIdentical)
		{
			UNICODE_STRING str1 = RTL_CONSTANT_STRING(L"abcde");
			UNICODE_STRING str2 = RTL_CONSTANT_STRING(L"abcde");
			LONG res = RtlCompareUnicodeString(&str1, &str2, true);
			Assert::IsTrue(res == 0);
			res = RtlCompareUnicodeString(&str1, &str2, false);
			Assert::IsTrue(res == 0);
		}

		/*
		 * Compare 2 different strings
		 */
		TEST_METHOD(DdkUnicodeCompareStringsDiff)
		{
			UNICODE_STRING str1 = RTL_CONSTANT_STRING(L"abcde1");
			UNICODE_STRING str2 = RTL_CONSTANT_STRING(L"abcde2");
			LONG res = RtlCompareUnicodeString(&str1, &str2, true);
			Assert::IsTrue(res < 0);
			res = RtlCompareUnicodeString(&str1, &str2, false);
			Assert::IsTrue(res < 0);
		}

		/*
		 * Compare 2 strings, which differ only by case
		 */
		TEST_METHOD(DdkUnicodeCompareStringsDiffCase)
		{
			UNICODE_STRING str1 = RTL_CONSTANT_STRING(L"Abcde");
			UNICODE_STRING str2 = RTL_CONSTANT_STRING(L"abcde");
			LONG res = RtlCompareUnicodeString(&str1, &str2, true);
			Assert::IsTrue(res == 0);
			res = RtlCompareUnicodeString(&str1, &str2, false);
			Assert::IsTrue(res != 0);
		}

		/*
		 * Concatenates a null-terminated unicode string to a buffered Unicode string.
		 */
		TEST_METHOD(DdkUnicodeAppendToString)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 10);
			const WCHAR unicodeStringSrc[] = L"67890";
			const WCHAR expectedString[] = L"1234567890";

			RtlAppendUnicodeToString(&unicodeStringDst, L"12345");
			NTSTATUS status = RtlAppendUnicodeToString(&unicodeStringDst, unicodeStringSrc);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == wcslen(expectedString) * sizeof(WCHAR));
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, expectedString, wcslen(expectedString)) == 0);
		}

		/*
		 * Concatenates a null-terminated unicode string to a buffered Unicode string which is too small
		 */
		TEST_METHOD(DdkUnicodeAppendToStringTooSmall)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 9);
			const WCHAR unicodeStringSrc[] = L"67890";
			const WCHAR expectedString[] = L"1234567890";

			RtlAppendUnicodeToString(&unicodeStringDst, L"12345");
			NTSTATUS status = RtlAppendUnicodeToString(&unicodeStringDst, unicodeStringSrc);

			Assert::IsTrue(status == STATUS_BUFFER_TOO_SMALL);
		}

		/*
		 * Concatenates 2 unicode strings
		 */
		TEST_METHOD(DdkUnicodeAppendStringToString)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 10);
			UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"67890");
			UNICODE_STRING unicodeStringExpected = RTL_CONSTANT_STRING(L"1234567890");

			RtlAppendUnicodeToString(&unicodeStringDst, L"12345");
			NTSTATUS status = RtlAppendUnicodeStringToString(&unicodeStringDst, &unicodeStringSrc);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringExpected.Length);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringExpected.Buffer, unicodeStringExpected.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Concatenates one unicode string to another which is too short
		 */
		TEST_METHOD(DdkUnicodeAppendStringToStringTooSmall)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 9);
			UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"67890");

			RtlAppendUnicodeToString(&unicodeStringDst, L"12345");
			NTSTATUS status = RtlAppendUnicodeStringToString(&unicodeStringDst, &unicodeStringSrc);

			Assert::IsTrue(status == STATUS_BUFFER_TOO_SMALL);
		}

		/*
		 * Convert a unicode string to upper case
		 */
		TEST_METHOD(DdkUnicodeUpcaseString)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 24);
			UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"My name is Michael Caine");
			UNICODE_STRING unicodeStringExpected = RTL_CONSTANT_STRING(L"MY NAME IS MICHAEL CAINE");
			NTSTATUS status = RtlUpcaseUnicodeString(&unicodeStringDst, &unicodeStringSrc, false);
			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringExpected.Length);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringExpected.Buffer, unicodeStringExpected.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Convert a unicode string to upper case, allocating the destination buffer
		 */
		TEST_METHOD(DdkUnicodeUpcaseStringAlloc)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 24);
			UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"My name is Michael Caine");
			UNICODE_STRING unicodeStringExpected = RTL_CONSTANT_STRING(L"MY NAME IS MICHAEL CAINE");
			NTSTATUS status = RtlUpcaseUnicodeString(&unicodeStringDst, &unicodeStringSrc, true);
			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringExpected.Length);
			Assert::IsTrue(unicodeStringDst.Buffer != unicodeStringDst_buffer);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringExpected.Buffer, unicodeStringExpected.Length / sizeof(WCHAR)) == 0);
			
			RtlFreeUnicodeString(&unicodeStringDst);
			Assert::IsTrue(unicodeStringDst.Buffer == NULL);
		}

		/*
		 * Convert a unicode string containing a decimal number to an integer, passing a base
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalWithBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L" 214748364ze5h7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 214748364);
		}

		/*
		 * Convert a unicode string containing a decimal number to an integer, passing a base but no excess data terminating the number or preceding spaces
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalClean)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"214748364");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 214748364);
		}


		/*
		 * Convert a null terminated unicode string containing a decimal number to an integer, passing a base
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalWithNullTerminator)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L" 214748364\0");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 214748364);
		}

		/*
		 * Convert a unicode string containing a decimal number to an integer, passing no base
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0214748364ze5h7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 214748364);
		}

		/*
		 * Convert a unicode string containing a negative decimal number to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalNegative)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	-214748364ze5h7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == -214748364);
		}

		/*
		 * Convert a unicode string containing 0 with no base
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalZero)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"0");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a decimal number with a series of preceding zeros
		 * Passing in a base and no prefix in the string
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalPrecedingZeros)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-0000214748364ze5h7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == -214748364);
		}

		/*
		 * Convert a unicode string containing a decimal number with a series of preceding zero
		 * no base and no prefix in the string
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalPrecedingZerosNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"00001010");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 1010);
		}

		/*
		 * Convert a unicode string containing the highest possible positive hex number
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexMax)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"+0xFFFFFFFF");
			ULONG result = 0;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0xFFFFFFFF);
		}

		/*
		 * Convert a unicode string containing the lowest possible negative decimal number
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalMaxNegative)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-2147483648");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0x80000000);
		}

		/*
		 * Convert a unicode string containing decimal value greater than MAX_ULONG 
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"1836873016182535765326452654254231");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 3815155863);
		}

		/*
		 * Convert a unicode string containing negative decimal value less than MIN_LONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerDecimalNegativeOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-1836873016182535765326452654254231");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 479811433);
		}

		/*
		 * Convert a unicode string containing a hexadecimal number, passing base but no prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexBaseNoPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	+123456FDzt4g");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 16, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0x123456FD);
		}

		/*
		 * Convert a unicode string containing a hexadecimal number, passing prefix but no base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexPrefixNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   0x023567cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0x023567cf);
		}

		/*
		 * Convert a unicode string containing a hexadecimal number, passing the base and a prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexPrefixAndBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   +0x234567cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 16, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a hexadecimal number, passing the base and an incorrect prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexBaseAndIncorrectPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   +0o234567cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 16, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a hexadecimal number with a series of preceding zeros
		 * passing the base and a prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexPrecedingZeros)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   +0x000002367cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0x000002367cf);
		}

		/*
		 * Convert a unicode string containing a negative hexadecimal number passing a prefix
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexNegative)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   -0x834567cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0x7cba9831);
		}
		
		/*
		 * Convert a unicode string containing a negative hexadecimal number with an invalid prefix
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexUpperCasePrefixNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"   -0X234567cfu7");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a negative hexadecimal number, passing the base and a prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexUpperCase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"0xABCD");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0xABCD);
		}

		/*
		 * Convert a unicode string containing a Hex value greater than MAX_ULONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"123456789ABCDE0123456789ABCDE");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 16, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 2023406814);
		}

		/*
		 * Convert a unicode string containing a negative Hex value less than MIN_LONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerHexNegativeOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-123456789ABCDE0123456789ABCDE");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 16, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 2271560482);
		}

		/*
		 * Convert a unicode string containing a binary number, passing both a prefix but no base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryPrefixNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0b10102g5e4z");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 10);
		}

		/*
		 * Convert a unicode string containing a binary number, passing the base and no prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryBaseNoPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	1010g5e4z");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 10);
		}

		/*
		 * Convert a unicode string containing a binary number, passing both a prefix and the base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryBaseAndPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0b1010g5e4z");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a binary number, passing both a prefix and the base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryBaseAndIncorrectPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0x1010g5e4z");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}
		
		/*
		 * Convert a unicode string containing a negative binary number
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryNegative)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	-0101010g45ez");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == (ULONG)-42);
		}

		/*
		 * Convert a unicode string containing a binary number with preceding zeros
		 * Passing in the base parameter and no prefix in the string
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryWithPreceedingZeros)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	00000101010g45ez");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == (ULONG)42);
		}

		/*
		* Convert a unicode string containing negative binary value greater than MAX_ULONG
		*/
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryNegativeOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-10000010100001001000011010001000100010101000110010001110101010101010101010");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 3452261718);
		}

		/*
		 * Convert a unicode string containing binary value greater than MAX_ULONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerBinaryOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"10000010100001001000011010001000100010101000110010001110101010101010101010");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 2, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 842705578);
		}

		/*
		 * Convert a unicode string containing a octal number, passing the base but no prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalBaseNoPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	+705137248hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 070513724);
		}
		
		/*
		 * Convert a unicode string containing a octal number, passing a prefix but no base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalPrefixNoBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0o70513724hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 0, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 070513724);
		}

		/*
		 * Convert a unicode string containing a octal number, passing both a prefix and the base to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalBaseAndPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0o70513724hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a octal number, passing both the base an incorrect prefix to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalBaseAndIncorrectPrefix)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	0x70513724hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Convert a unicode string containing a octal number with preceding zeros to an integer
		 * passing the base with no prefix in the string
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalPrecedingZeros)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	000705137hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 000705137);
		}

		/*
		 * Convert a unicode string containing a negative octal number
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalNegative)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"	-070513724hnjgf432");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == -070513724);
		}

		/*
		 * Convert a unicode string containing an octal value greater than MAX_ULONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"10120441504212431654235642564307");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 4002080967);
		}

		/*
		 * Convert a unicode string containing a negative octal value greater than MAX_ULONG
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerOctalNegativeOverflow)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"-10120441504212431654235642564307");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 8, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 292886329);
		}

		/*
		 * Attempt to convert an empty unicode string to an integer
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerEmptyString)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"");			
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_INVALID_PARAMETER);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Attempt to convert a unicode string to an integer passing in an invalid base value.
		 */
		TEST_METHOD(DdkUnicodeStringToIntegerInvalidBase)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"0x123ABC");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 42, &result);

			Assert::IsTrue(status == STATUS_INVALID_PARAMETER);
			Assert::IsTrue(result == 0);
		}

		/*
		* Attempt to convert a string with no valid characters passing no base
		*/
		TEST_METHOD(DdkUnicodeStringToIntegerInvalidString)
		{
			const UNICODE_STRING unicodeStringSrc = RTL_CONSTANT_STRING(L"y");
			ULONG result = -1;

			NTSTATUS status = RtlUnicodeStringToInteger(&unicodeStringSrc, 10, &result);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Compare 2 identical strings for equality
		 */
		TEST_METHOD(DdkUnicodeEqualString)
		{
			UNICODE_STRING str1 = RTL_CONSTANT_STRING(L"ABCde");
			UNICODE_STRING str2 = RTL_CONSTANT_STRING(L"abcde");
			BOOLEAN res = RtlEqualUnicodeString(&str1, &str2, true);
			Assert::IsTrue(res == TRUE);
			res = RtlEqualUnicodeString(&str1, &str2, false);
			Assert::IsTrue(res == FALSE);
		}

		/*
		 * Convert an Ansi String To Unicode
		 */
		TEST_METHOD(DdkUnicodeFromAnsiString)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 24);
			ANSI_STRING ansiStringSrc = RTL_CONSTANT_STRING("My name is Michael Caine");
			UNICODE_STRING unicodeStringExpected = RTL_CONSTANT_STRING(L"My name is Michael Caine");

			NTSTATUS status = RtlAnsiStringToUnicodeString(&unicodeStringDst, &ansiStringSrc, false);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringExpected.Length);
			Assert::IsTrue(unicodeStringDst.Buffer != NULL);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringExpected.Buffer, unicodeStringExpected.Length / sizeof(WCHAR)) == 0);
		}

		/*
		 * Convert an Ansi String To Unicode, allocating the buffer
		 */
		TEST_METHOD(DdkUnicodeFromAnsiStringAlloc)
		{
			DECLARE_UNICODE_STRING_SIZE(unicodeStringDst, 24);
			ANSI_STRING ansiStringSrc = RTL_CONSTANT_STRING("My name is Michael Caine");
			UNICODE_STRING unicodeStringExpected = RTL_CONSTANT_STRING(L"My name is Michael Caine");

			NTSTATUS status = RtlAnsiStringToUnicodeString(&unicodeStringDst, &ansiStringSrc, true);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(unicodeStringDst.Length == unicodeStringExpected.Length);
			Assert::IsTrue(unicodeStringDst.Buffer != unicodeStringDst_buffer);
			Assert::IsTrue(wcsncmp(unicodeStringDst.Buffer, unicodeStringExpected.Buffer, unicodeStringExpected.Length / sizeof(WCHAR)) == 0);

			RtlFreeUnicodeString(&unicodeStringDst);
			Assert::IsTrue(unicodeStringDst.Buffer == NULL);
		}

		/*
		 * Get the ansi-size of a unicode string
		 */
		TEST_METHOD(DdkUnicodeStringToAnsiSize)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"abcde");
			int len = RtlxUnicodeStringToAnsiSize(&unicodeString);
			Assert::IsTrue(len == 6);
		}

		/*
		 * Convert character to uppercase
		 */
		TEST_METHOD(DdkUnicodeCharToUpper)
		{
			WCHAR chLower = 'a';
			WCHAR chUpper = RtlUpcaseUnicodeChar(chLower);
			Assert::IsTrue(chUpper == L'A');
		}

		/*
		 * Convert character to lowercase
		 */
		TEST_METHOD(DdkUnicodeCharToLower)
		{
			WCHAR chUpper = 'Z';
			WCHAR chLower = RtlDowncaseUnicodeChar(chUpper);
			Assert::IsTrue(chLower == L'z');
		}

		/*
		 * Test Default Hash == X65599 hash of a string.
		 */
		TEST_METHOD(DdkUnicodeHashDefault)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"Thi$ Is @ T3ST $tr1ng 4_tH3 D3F@uLt HasH!");
			ULONG defaultResult, x65599Result;

			NTSTATUS defaultStatus = RtlHashUnicodeString(&unicodeString, FALSE, HASH_STRING_ALGORITHM_DEFAULT, &defaultResult);
			NTSTATUS x65599Status = RtlHashUnicodeString(&unicodeString, FALSE, HASH_STRING_ALGORITHM_X65599, &x65599Result);
			Assert::IsTrue(defaultStatus == x65599Status);
			Assert::IsTrue(defaultResult == x65599Result);
		}

		/*
		 * X65599 Hash of lower case string
		 */
		TEST_METHOD(DdkUnicodeHashLower)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"test");
			ULONG result;
			const ULONG caseInsensitiveHash = 1720303922UL;
			const ULONG lowerHash = 1195757874UL;

			NTSTATUS returnStatus = RtlHashUnicodeString(&unicodeString, TRUE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == caseInsensitiveHash);

			returnStatus = RtlHashUnicodeString(&unicodeString, FALSE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == lowerHash);
		}

		/*
		 * X65599 Hash of upper case string
		 */
		TEST_METHOD(DdkUnicodeHashUpper)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"TEST");
			ULONG result;
			const ULONG caseInsensitiveHash = 1720303922UL;
						
			NTSTATUS returnStatus = RtlHashUnicodeString(&unicodeString, TRUE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == caseInsensitiveHash);

			returnStatus = RtlHashUnicodeString(&unicodeString, FALSE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == caseInsensitiveHash);
		}

		/*
		 * X65599 Hash of mixed case string
		 */
		TEST_METHOD(DdkUnicodeHashMixed)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"TEst");
			ULONG result;

			const ULONG caseInsensitiveHash = 1720303922UL;
			const ULONG mixHash = 1722403122UL;
			
			NTSTATUS returnStatus = RtlHashUnicodeString(&unicodeString, TRUE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == caseInsensitiveHash);

			returnStatus = RtlHashUnicodeString(&unicodeString, FALSE, HASH_STRING_ALGORITHM_X65599, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == mixHash);
		}

		/*
		 * Hash of an empty string
		 */
		TEST_METHOD(DdkUnicodeHashEmpty)
		{
			UNICODE_STRING unicodeString = RTL_CONSTANT_STRING(L"");
			ULONG result;

			long returnStatus = RtlHashUnicodeString(&unicodeString, TRUE, HASH_STRING_ALGORITHM_DEFAULT, &result);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(result == 0);
		}

		/*
		 * Hash of a null pointer
		 */
		TEST_METHOD(DdkUnicodeHashNULL)
		{
			ULONG result;
			NTSTATUS returnStatus = RtlHashUnicodeString(nullptr, TRUE, HASH_STRING_ALGORITHM_DEFAULT, &result);
			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Create a Unicode String from a GUID object
		 */
		TEST_METHOD(DdkUnicodeGuidToString)
		{
			UNICODE_STRING guidStr;
			UNICODE_STRING expectedGuidStr = RTL_CONSTANT_STRING(L"{6B29FC40-CA47-1067-B31D-00DD010662DA}");

			NTSTATUS returnStatus = RtlStringFromGUID(UNICODE_TEST_GUID, &guidStr);
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			
			LONG compareResult = RtlCompareUnicodeString(&guidStr, &expectedGuidStr, false);
			Assert::IsTrue(compareResult == 0);

			RtlFreeUnicodeString(&guidStr);
		}

		/*
		 * Create a GUID object from a Unicode String
		 */
		TEST_METHOD(DdkUnicodeGuidFromString)
		{
			GUID guid;
			UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"{6B29FC40-CA47-1067-B31D-00DD010662DA}");
			const unsigned char expectedData4[8] = { 0xB3, 0x1D, 0x00, 0xDD, 0x01, 0x06, 0x62, 0xDA };

			NTSTATUS returnStatus = RtlGUIDFromString(&unicodeStr, &guid);
			
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(guid.Data1 == 0x6B29FC40);
			Assert::IsTrue(guid.Data2 == 0xCA47);
			Assert::IsTrue(guid.Data3 == 0x1067);
			for (unsigned int i = 0; i < 8; i++)
				Assert::IsTrue(guid.Data4[i] == expectedData4[i]);
		}		

		/*
		 * Attempt to create a GUID object from a Unicode String without the curly braces
		 */
		TEST_METHOD(DdkUnicodeGuidFromStringMissingBraces)
		{
			GUID guid;
			UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"6B29FC40-CA47-1067-B31D-00DD010662DA");

			NTSTATUS returnStatus = RtlGUIDFromString(&unicodeStr, &guid);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Attempt to create a GUID object from a Unicode String without dashes in the string
		 */
		TEST_METHOD(DdkUnicodeGuidFromStringMissingDashes)
		{
			GUID guid;
			UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"{6B29FC40CA471067B31D00DD010662DA}");

			NTSTATUS returnStatus = RtlGUIDFromString(&unicodeStr, &guid);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Attempt to create a GUID object from a Unicode String swapping the closing brace for a L'.'
		 */
		TEST_METHOD(DdkUnicodeGuidMissingClosingBrace)
		{
			GUID guid;
			UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"{6B29FC40-CA47-1067-B31D-00DD010662DA.");

			NTSTATUS returnStatus = RtlGUIDFromString(&unicodeStr, &guid);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Convert a Unicode string to the respective UTF8 String
		 */
		TEST_METHOD(DdkUnicodeToUTF8)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const unsigned char expectedUtf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97, 0x69,
				0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrMaxByteCount = 38;

			char utf8StrDst[utf8StrMaxByteCount];
			ULONG utf8StrActualByteCount;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(utf8StrDst, utf8StrMaxByteCount, &utf8StrActualByteCount, unicodeStr.Buffer, unicodeStr.Length);
			
			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(utf8StrActualByteCount == utf8StrMaxByteCount);
			Assert::IsTrue(memcmp(&expectedUtf8Str, &utf8StrDst, utf8StrMaxByteCount) == 0);
		}

		/*
		 * Convert an empty Unicode string to a UTF8 String
		 */
		TEST_METHOD(DdkUnicodeToUTF8EmptySourceString)
		{
			UNICODE_STRING *unicodeStr = new UNICODE_STRING();
			unicodeStr->Length = 0;
			unicodeStr->MaximumLength = 0;
			unicodeStr->Buffer = new WCHAR[1];

			const ULONG utf8StrMaxByteCount = 1;

			char utf8StrDst[utf8StrMaxByteCount];
			ULONG utf8StrActualByteCount = 0;

			utf8StrDst[0] = '\0';  // This is just a place holder as NULL value would cause a STATUS_INVALID_PARAMETER

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(utf8StrDst, utf8StrMaxByteCount, &utf8StrActualByteCount, unicodeStr->Buffer, unicodeStr->Length);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(utf8StrActualByteCount == 0);

			delete unicodeStr;
		}

		/*
		 * Attempt to convert a Unicode string to a UTF8 string with NULL utf8ActualByteCount
		 */
		TEST_METHOD(DdkUnicodeToUTF8NullActualByteCount)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const unsigned char expectedUtf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97, 0x69,
				0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrMaxByteCount = 38;

			char utf8StrDst[utf8StrMaxByteCount];

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(utf8StrDst, utf8StrMaxByteCount, NULL, unicodeStr.Buffer, unicodeStr.Length);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(memcmp(&expectedUtf8Str, &utf8StrDst, utf8StrMaxByteCount) == 0);
		}

		/*
		 * Attempt to convert a Unicode string to a UTF8 string, with a NULL destination pointer
		 */
		TEST_METHOD(DdkUnicodeToUTF8NullDestination)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const ULONG utf8StrMaxByteCount = 38;

			ULONG utf8StrActualByteCount;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(NULL, utf8StrMaxByteCount, &utf8StrActualByteCount, unicodeStr.Buffer, unicodeStr.Length);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(utf8StrActualByteCount == utf8StrMaxByteCount);
		}

		/*
		 * Attempt to convert a Unicode string to a UTF8 string, with a NULL destination pointer and UTF8StringActualByteCount
		 */
		TEST_METHOD(DdkUnicodeToUTF8NullDestinationAndActualByteCount)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const ULONG utf8StrMaxByteCount = 38;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(NULL, utf8StrMaxByteCount, NULL, unicodeStr.Buffer, unicodeStr.Length);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Attempt to convert a NULL Unicode string to a UTF8 string
		 */
		TEST_METHOD(DdkUnicodeToUTF8NullSource)
		{
			const ULONG utf8StrMaxByteCount = 2;

			char utf8StrDst[utf8StrMaxByteCount];
			ULONG utf8StrActualByteCount;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(utf8StrDst, utf8StrMaxByteCount, &utf8StrActualByteCount, NULL, 0);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER_4);
		}

		/*
		 * Attempt to convert a Unicode String to UTF8 string passing the same source and destination pointers.
		 */
		TEST_METHOD(DdkUnicodeToUTF8SamePointer)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const ULONG utf8StrMaxByteCount = 38;

			ULONG utf8StrActualByteCount;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N((PCHAR)unicodeStr.Buffer, utf8StrMaxByteCount, &utf8StrActualByteCount, unicodeStr.Buffer, unicodeStr.Length);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}
		
		/*
		 * Attempt to convert a Unicode string to the respective UTF8 String with a buffer too small
		 */
		TEST_METHOD(DdkUnicodeToUTF8SmallBuffer)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const unsigned char expectedUtf8Str[] = { 0x4d, 0x79 };
			const ULONG utf8StrMaxByteCount = 2;

			char utf8StrDst[utf8StrMaxByteCount];
			ULONG utf8StrActualByteCount;

			NTSTATUS returnStatus = RtlUnicodeToUTF8N(utf8StrDst, utf8StrMaxByteCount, &utf8StrActualByteCount, unicodeStr.Buffer, unicodeStr.Length);

			Assert::IsTrue(returnStatus == STATUS_BUFFER_TOO_SMALL);
			Assert::IsTrue(utf8StrActualByteCount == utf8StrMaxByteCount);
			Assert::IsTrue(memcmp(&expectedUtf8Str, &utf8StrDst, utf8StrActualByteCount) == 0);
		}

		/*
		 * Convert a UTF8 encoded string the equivelent Unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicode)
		{
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8MaxStrByteCount = 38;
			const ULONG unicodeStrMaxByteCount = 52;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8MaxStrByteCount);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(unicodeActualByteCount == unicodeStrMaxByteCount);
		}

		/*
		 * Attempt to convert an empty UTF8 string to a Unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicodeEmptySourceString)
		{
			const unsigned char utf8Str[] = { '\0' }; // This is just a place holder as NULL value would cause a STATUS_INVALID_PARAMETER
			const ULONG utf8MaxStrByteCount = 1;
			const ULONG unicodeStrMaxByteCount = 2;

			ULONG unicodeActualByteCount = 0;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, 0);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(unicodeActualByteCount == 0);
		}

		/*
		 * Attempt to convert a UTF8 string to a Unicode string with NULL unicodeActualByteCount
		 */
		TEST_METHOD(DdkUTF8ToUnicodeNullActualByteCount)
		{
			const UNICODE_STRING expectedUnicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrMaxByteCount = 38, unicodeStrMaxByteCount = 54;

			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, NULL, (char *)utf8Str, utf8StrMaxByteCount);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(memcmp(&unicodeStrDst, expectedUnicodeStr.Buffer, expectedUnicodeStr.Length) == 0);
		}

		/*
		 * Attempt to convert a UTF8 string to the equivelent unicode string with a NULL unicode string destination 
		 */
		TEST_METHOD(DdkUTF8ToUnicodeNullDestination)
		{
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrMaxByteCount = 38, unicodeStrMaxByteCount = 52;

			ULONG unicodeActualByteCount = 0;

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(NULL, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrMaxByteCount);

			Assert::IsTrue(returnStatus == STATUS_SUCCESS);
			Assert::IsTrue(unicodeActualByteCount == unicodeStrMaxByteCount);
		}

		/*
		 * Attempt to convert a Unicode string to a UTF8 string with a NULL destination pointer and NULL actualByteCount.
		 */
		TEST_METHOD(DdkUTF8ToUnicodeNullDestinationAndActualByteCount)
		{
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2 };
			const ULONG utf8StrMaxByteCount = 38, unicodeStrMaxByteCount = 54;

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(NULL, unicodeStrMaxByteCount, NULL, (char *)utf8Str, utf8StrMaxByteCount);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Attempt to convert a NULL UTF8 encoded string to the equivelent unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicodeNullSource)
		{
			const ULONG utf8StrByteCount = 2, unicodeStrMaxByteCount = 50;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, NULL, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER_4);
		}

		/*
		 * Attempt to convert a Unicode String to UTF8 string passing the same source and destination pointers.
		 */
		TEST_METHOD(DdkUTF8ToUnicodeSamePointer)
		{
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrByteCount = 39, unicodeStrMaxByteCount = 56;

			ULONG unicodeActualByteCount;

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN((PWCHAR)utf8Str, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_INVALID_PARAMETER);
		}

		/*
		 * Attempt to convert a UTF8 encoded string the equivelent Unicode string with a buffer too small to hold the result
		 */
		TEST_METHOD(DdkUTF8ToUnicodeSmallBuffer)
		{
			const UNICODE_STRING expectedUnicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is");
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0xf8 };
			const ULONG utf8StrByteCount = 32, unicodeStrMaxByteCount = 20;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_BUFFER_TOO_SMALL);
			Assert::IsTrue(memcmp(expectedUnicodeStr.Buffer, &unicodeStrDst, expectedUnicodeStr.Length) == 0);
		}

		/*
		 * Attempt to convert a UTF8 encoded string expected to be retuned as a default default character unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicodeWithInvalidCharacter)
		{
			const UNICODE_STRING expectedUnicodeStr = RTL_CONSTANT_STRING(L"\uFFFD");
			const unsigned char utf8Str[] = { 0x80 };
			const ULONG utf8StrByteCount = 1, unicodeStrMaxByteCount = 2;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_SOME_NOT_MAPPED);
			Assert::IsTrue(unicodeActualByteCount == expectedUnicodeStr.Length);
			Assert::IsTrue(memcmp(&unicodeStrDst, expectedUnicodeStr.Buffer, expectedUnicodeStr.Length) == 0);
		}

		/*
		 * Attempt to convert a UTF8 encoded string expected to be retuned as a default default character at the beginning of the unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicodeWithInvalidCharacterPrefix)
		{
			const UNICODE_STRING expectedUnicodeStr = RTL_CONSTANT_STRING(L"\uFFFDMy N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\0");
			const unsigned char utf8Str[] = { 0x80, 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97, 0x69,
				0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x00 };
			const ULONG utf8StrByteCount = 39, unicodeStrMaxByteCount = 56;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_SOME_NOT_MAPPED);
			Assert::IsTrue(unicodeActualByteCount == expectedUnicodeStr.Length);
			Assert::IsTrue(memcmp(&unicodeStrDst, expectedUnicodeStr.Buffer, expectedUnicodeStr.Length) == 0);
		}

		/*
		 * Attempt to convert a UTF8 encoded string expected to be retuned as a default default character at then end of the unicode string
		 */
		TEST_METHOD(DdkUTF8ToUnicodeWithInvalidCharacterSuffix)
		{
			const UNICODE_STRING expectedUnicodeStr = RTL_CONSTANT_STRING(L"My N\u00c3m\u04d9 is Mi\u08a2ha\u20acl C\u0917in\u20ac\u2122\uFFFD\0");
			const unsigned char utf8Str[] = { 0x4d, 0x79, 0x20, 0x4e, 0xc3, 0x83, 0x6d, 0xd3, 0x99, 0x20, 0x69, 0x73,
				0x20, 0x4d, 0x69, 0xe0, 0xa2, 0xa2, 0x68, 0x61, 0xe2, 0x82, 0xac, 0x6c, 0x20, 0x43, 0xe0, 0xa4, 0x97,
				0x69, 0x6e, 0xe2, 0x82, 0xac, 0xe2, 0x84, 0xa2, 0x80, 0x00 };
			const ULONG utf8StrByteCount = 39, unicodeStrMaxByteCount = 56;

			ULONG unicodeActualByteCount;
			wchar_t unicodeStrDst[unicodeStrMaxByteCount / sizeof(wchar_t)];

			NTSTATUS returnStatus = RtlUTF8ToUnicodeN(unicodeStrDst, unicodeStrMaxByteCount, &unicodeActualByteCount, (char *)utf8Str, utf8StrByteCount);

			Assert::IsTrue(returnStatus == STATUS_SOME_NOT_MAPPED);
			Assert::IsTrue(unicodeActualByteCount == expectedUnicodeStr.Length);
			Assert::IsTrue(memcmp(&unicodeStrDst, expectedUnicodeStr.Buffer, expectedUnicodeStr.Length) == 0);
		}

		/*
	 	 * Convert a unicode String to an ansi string and using caller allocated a buffer
		 */
		TEST_METHOD(DdkUnicodeToAnsi)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"abcde");
			const ANSI_STRING expectedStr = RTL_CONSTANT_STRING("abcde");
			const USHORT maxLength = 6;

			ANSI_STRING ansiStr;
			ansiStr.MaximumLength = maxLength;
			ansiStr.Buffer = new char[maxLength];
			ansiStr.Length = 0;

			NTSTATUS status = RtlUnicodeStringToAnsiString(&ansiStr, &unicodeStr, FALSE);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(ansiStr.Length == expectedStr.Length);
			Assert::IsTrue(memcmp(ansiStr.Buffer, expectedStr.Buffer, expectedStr.Length) == 0);

			delete[] ansiStr.Buffer;
			ansiStr.Buffer = NULL;
		}

		/*
		 * Convert a unicode String to an ansi string using caller allocated buffer too small to fit the resultant string
		 */
		TEST_METHOD(DdkUnicodeToAnsiSmall)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"abcde");
			const ANSI_STRING expectedStr = RTL_CONSTANT_STRING("abcde");
			const USHORT maxLength = 3;

			ANSI_STRING ansiStr;
			ansiStr.MaximumLength = maxLength;
			ansiStr.Buffer = new char[maxLength];
			ansiStr.Length = 0;

			NTSTATUS status = RtlUnicodeStringToAnsiString(&ansiStr, &unicodeStr, FALSE);

			Assert::IsTrue(status == STATUS_BUFFER_TOO_SMALL);

			delete[] ansiStr.Buffer;
			ansiStr.Buffer = NULL;
		}

		/*
		 * Convert a unicode string to an ansi string using function allocated buffer
		 */
		TEST_METHOD(DdkUnicodeToAnsiAllocate)
		{
			const UNICODE_STRING unicodeStr = RTL_CONSTANT_STRING(L"abcde");
			const ANSI_STRING expectedStr = RTL_CONSTANT_STRING("abcde");
			
			ANSI_STRING ansiStr;

			NTSTATUS status = RtlUnicodeStringToAnsiString(&ansiStr, &unicodeStr, TRUE);

			Assert::IsTrue(status == STATUS_SUCCESS);
			Assert::IsTrue(ansiStr.Length == expectedStr.Length);
			Assert::IsTrue(memcmp(ansiStr.Buffer, expectedStr.Buffer, expectedStr.Length) == 0);

			RtlFreeAnsiString(&ansiStr);
		}
		
	};
}

```

`test/WaitTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Wait Tests
 */

#include "stdafx.h"

namespace DdkUnitTest
{
	TEST_CLASS(DdkWaitTest)
	{
		const static LONG nTicks = 10;

		TEST_METHOD_INITIALIZE(DdkWaitTestInit)
		{
			DdkThreadInit();
		}

		TEST_METHOD(DdkWaitDelayInterval)
		{
			LARGE_INTEGER begin, end, delay;
			delay.QuadPart = -nTicks;
			delay.QuadPart *= KeQueryTimeIncrement();

			KeQueryTickCount(&begin);
			NTSTATUS rc = KeDelayExecutionThread(KernelMode, FALSE, &delay);
			KeQueryTickCount(&end);

			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(end.QuadPart - begin.QuadPart >= nTicks - 1);
		}

		TEST_METHOD(DdkWaitDelayTime)
		{
			LARGE_INTEGER begin, end, finish;

			KeQuerySystemTime(&finish);
			finish.QuadPart = finish.QuadPart + (nTicks * KeQueryTimeIncrement());

			KeQueryTickCount(&begin);
			NTSTATUS rc = KeDelayExecutionThread(KernelMode, FALSE, &finish);
			KeQueryTickCount(&end);

			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsTrue(end.QuadPart - begin.QuadPart >= nTicks - 1);
		}
	};
}
```

`test/WinHeaderTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Windows Header Tests
 */

#include <Windows.h>
#include <ddk.h>
#include <ntifs.h>
#include <wmilib.h>
#include "stdafx.h"


namespace DdkUnitTest
{
	extern size_t _SizeofCriticalSection_;

	TEST_CLASS(DdkWindowsHeaderTest)
	{
	public:
		
		TEST_METHOD(DdkWindowsHeader)
		{
			Assert::IsTrue(sizeof(CRITICAL_SECTION) == _SizeofCriticalSection_);
		}
	};
}

```

`test/WorkItemTest.cpp`:

```cpp
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 1998-2015, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

/*
 *	Work Item Tests
 */

#include "stdafx.h"


namespace DdkUnitTest
{
	TEST_CLASS(DdkWorkItemTest)
	{
		PDRIVER_OBJECT pDriver;
		PDEVICE_OBJECT pDevice;
		PIO_WORKITEM pWork;
		PIO_WORKITEM pIoWork;

		static const int nvec = 10;
		PIO_WORKITEM vec[nvec];

		volatile LONG count;
		volatile LONG blocked;
		volatile LONG waiting;

		char DriverName[100];

		static NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)
		{
			DdkWorkItemTest *pTest = (DdkWorkItemTest *)_wtoll(&DriverObject->DriverName.Buffer[3]);
			pTest->pDriver = DriverObject;
			return STATUS_SUCCESS;
		}

	public:
		TEST_METHOD_INITIALIZE(DdkWorkItemInit)
		{
			DdkThreadInit();

			sprintf(DriverName, "DRV%I64d:%d", (LONGLONG)this, GetUniqueId());
			memset(vec, 0, sizeof(vec));
			pDriver = 0;
			pDevice = 0;
			pWork = 0;
			pIoWork = 0;
			count = 0;
			blocked = 0;
			waiting = 0;

			NTSTATUS rc = DdkInitDriver(DriverName, DriverEntry);
			Assert::IsTrue(rc == STATUS_SUCCESS);
			Assert::IsNotNull(pDriver);

			rc = IoCreateDevice(pDriver, 200, NULL, FILE_DEVICE_DISK, 0, FALSE, &pDevice);
			Assert::IsTrue(NT_SUCCESS(rc));
			Assert::IsNotNull(pDevice);
		}

		TEST_METHOD_CLEANUP(DdkWorkItemCleanup)
		{
			if (pWork) {
				IoUninitializeWorkItem(pWork);
				free(pWork);
			}

			if (pIoWork) IoFreeWorkItem(pIoWork);

			for (int i = 0; i < nvec; i++)
				if (vec[i]) IoFreeWorkItem(vec[i]);

			if (pDevice) IoDeleteDevice(pDevice);
			if (pDriver) DdkUnloadDriver(DriverName);
		}

		TEST_METHOD_CALLBACK(DdkWorkItemProc, PDEVICE_OBJECT DeviceObject, PVOID Context)
		{
			if (blocked) {
				InterlockedIncrement(&waiting);
				while (blocked) Sleep(10);
			}

			InterlockedIncrement(&count);
		}

		TEST_METHOD_CALLBACK(DdkWorkItemProcEx, PVOID IoObject, PVOID Context, PIO_WORKITEM Item)
		{
			InterlockedIncrement(&count);
		}
	
		TEST_METHOD(DdkWorkItemInitialize)
		{
			pWork = (PIO_WORKITEM)malloc(IoSizeofWorkItem());
			Assert::IsNotNull(pWork);

			IoInitializeWorkItem(pDevice, pWork);

			TEST_CALLBACK_INIT(id);
			IoQueueWorkItem(pWork, DdkWorkItemProc, DelayedWorkQueue, id);
			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(count == 1);
		}

		TEST_METHOD(DdkWorkItemInitializeEx)
		{
			pWork = (PIO_WORKITEM)malloc(IoSizeofWorkItem());
			Assert::IsNotNull(pWork);

			IoInitializeWorkItem(pDevice, pWork);

			TEST_CALLBACK_INIT(id);
			IoQueueWorkItemEx(pWork, DdkWorkItemProcEx, DelayedWorkQueue, id);
			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(count == 1);
		}

		TEST_METHOD(DdkWorkItemAlloc)
		{
			pIoWork = IoAllocateWorkItem(pDevice);
			Assert::IsNotNull(pIoWork);

			TEST_CALLBACK_INIT(id);
			IoQueueWorkItem(pIoWork, DdkWorkItemProc, DelayedWorkQueue, id);
			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(count == 1);
		}

		TEST_METHOD(DdkWorkItemAllocEx)
		{
			pIoWork = IoAllocateWorkItem(pDevice);
			Assert::IsNotNull(pIoWork);

			TEST_CALLBACK_INIT(id);
			IoQueueWorkItemEx(pIoWork, DdkWorkItemProcEx, DelayedWorkQueue, id);
			TEST_CALLBACK_WAIT(id);
			Assert::IsTrue(count == 1);
		}

		TEST_METHOD(DdkWorkItemConcurrency)
		{
			InterlockedExchange(&blocked, 1);

			for (int i = 0; i < nvec; i++)
				Assert::IsNotNull((vec[i] = IoAllocateWorkItem(pDevice)));

			TEST_CALLBACK_INIT_VEC(id, nvec);

			for (int i = 0; i < nvec; i++) {
				IoQueueWorkItem(vec[i], DdkWorkItemProc, DelayedWorkQueue, id[i]);
				TEST_CALLBACK_STARTED(id[i]);
			}

			Sleep(20);
			InterlockedExchange(&blocked, 0);

			TEST_CALLBACK_WAIT_VEC(id);

			Assert::IsTrue(waiting > 1);
			Assert::IsTrue(count == nvec);
		}
	};
}

```

`test/stdafx.cpp`:

```cpp
// stdafx.cpp : source file that includes just the standard includes
// DdkTest.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file

```

`test/stdafx.h`:

```h
/*-
 *  SPDX-License-Identifier: BSD-3-Clause
 *
 *  Copyright (c) 2013, DataCore Software Corporation. All rights reserved.
 *
 *  Details about the Windows Kernel API are based on the documentation
 *  available at https://learn.microsoft.com/en-us/windows-hardware/drivers/
 */

// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently, but
// are changed infrequently
//

#pragma once

#include <ddk.h>
#include <Windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <memory.h>
#include <time.h>
#include <errno.h>

#include "targetver.h"
#include "UnitTest.h"

#include "Test.h"

```

`test/targetver.h`:

```h
#pragma once

// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>

```

`tools/bin/README.md`:

```md
In order to build the example projects, the following files need to be copied into tools\bin:

A version of GNU sed.exe for Windows. Version 4.7 is known to work.

dbh.exe and dbghelp.dll from C:\Program Files (x86)\Windows Kits\10\Debuggers\x64

```