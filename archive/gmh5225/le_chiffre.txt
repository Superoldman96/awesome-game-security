Project Path: arc_gmh5225_le_chiffre_0yvub8el

Source Tree:

```txt
arc_gmh5225_le_chiffre_0yvub8el
├── LICENSE
├── Le_Chiffre
│   ├── Le_Chiffre.cpp
│   ├── Le_Chiffre.vcxproj
│   ├── Le_Chiffre.vcxproj.filters
│   ├── antiAC.hpp
│   ├── bsp_parser
│   │   ├── bsp_parser.cpp
│   │   └── valve-bsp-parser
│   │       ├── bsp_parser.hpp
│   │       └── core
│   │           ├── matrix.hpp
│   │           ├── requirements.hpp
│   │           └── valve_structs.hpp
│   ├── client.hpp
│   ├── hacks.hpp
│   ├── i18n
│   │   ├── en.hpp
│   │   ├── fr.hpp
│   │   ├── hu.hpp
│   │   ├── i18n.hpp
│   │   ├── pl.hpp
│   │   ├── ru.hpp
│   │   ├── tr.hpp
│   │   ├── uk.hpp
│   │   └── zh.hpp
│   ├── memory.hpp
│   ├── misc
│   │   ├── config.hpp
│   │   ├── console_io.hpp
│   │   ├── utils.hpp
│   │   ├── web_utils.hpp
│   │   └── xor.hpp
│   ├── overlay
│   │   ├── overlay.hpp
│   │   └── paint.hpp
│   ├── player_entity.hpp
│   ├── sig_scanner.hpp
│   └── signatures.hpp
├── Le_Chiffre.sln
├── README.md
├── frontend
│   ├── assets
│   │   ├── background.png
│   │   └── styles.css
│   ├── index.html
│   └── script.js
└── images
    ├── lc_hacks.jpg
    └── lechiffre_mainmenu.png

```

`LICENSE`:

```
MIT License

Copyright (c) 2021 Andrii R.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`Le_Chiffre.sln`:

```sln

Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 16
VisualStudioVersion = 16.0.29920.165
MinimumVisualStudioVersion = 10.0.40219.1
Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "Le_Chiffre", "Le_Chiffre\Le_Chiffre.vcxproj", "{7545E077-22B0-4895-A3E6-D72A14ECE953}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|x64 = Debug|x64
		Debug|x86 = Debug|x86
		Release|x64 = Release|x64
		Release|x86 = Release|x86
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Debug|x64.ActiveCfg = Debug|x64
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Debug|x64.Build.0 = Debug|x64
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Debug|x86.ActiveCfg = Debug|Win32
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Debug|x86.Build.0 = Debug|Win32
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Release|x64.ActiveCfg = Release|x64
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Release|x64.Build.0 = Release|x64
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Release|x86.ActiveCfg = Release|Win32
		{7545E077-22B0-4895-A3E6-D72A14ECE953}.Release|x86.Build.0 = Release|Win32
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {F18F49D0-C2FD-483F-B06A-E0A96045DFB6}
	EndGlobalSection
EndGlobal

```

`Le_Chiffre/Le_Chiffre.cpp`:

```cpp
#include <Windows.h>
#include <iostream>
#include <ctime>
#include <thread>
#include "memory.hpp"
#include "signatures.hpp"
#include "client.hpp"
#include "hacks.hpp"
#include "antiAC.hpp"
#include "misc/console_io.hpp"
#include "misc/utils.hpp"
#include "misc/config.hpp"
#include "misc/xor.hpp"
#include "i18n/i18n.hpp"
// #include "sig_scanner.hpp"
// #include <cstddef>
// #include "overlay/overlay.hpp"

using std::cout;
using std::endl;
using namespace i18n;

void language_switcher(ConsoleIO* io, hacks_coords* coords, Internalisation* i, hacks_state* state) {
    while (true) { // Language - F1
        if (GetAsyncKeyState(VK_F1)) {
            i->switch_language();
            io->initial_output(coords, i, state);
            Sleep(250);
        }
        Sleep(5);
    }
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    srand((unsigned int)time(NULL));
    ConsoleIO io;
    AntiAC ac;
    Memory mem;
    Client client(&mem);
    Hacks hacks(&mem, &client);
    Internalisation i;
    hacks_coords coords;
    hacks_state state;
    int connect_count = 0;

    i.switch_language(get_user_localisation());
    io.initial_output(&coords, &i, &state);

    std::thread language_thread(language_switcher, &io, &coords, &i, &state);
    language_thread.detach();

    // Overlay ol(&mem);
    // ol.static_start(&ol);
    // HANDLE overlay = CreateThread(NULL, NULL, &ol.static_start, (void*)&ol, NULL, NULL);
    // std::thread t(ol.start);

    std::thread trigger_bot_thread(&Hacks::thread_trigger_bot, &hacks, &state, &coords, &io, &i);
    std::thread aimbot_thread(&Hacks::thread_aimbot, &hacks, &state, &coords, &io, &i);
    std::thread glow_radar_thread(&Hacks::thread_glow_radar, &hacks, &state, &coords, &io, &i);
    std::thread no_flash_thread(&Hacks::thread_no_flash, &hacks, &state, &coords, &io, &i);
    std::thread bunny_hop_thread(&Hacks::thread_bunny_hop, &hacks, &state, &coords, &io, &i);
    std::thread panic_mode_thread(&Hacks::thread_panic_mode, &hacks);

    while (true) {
        while (mem.tProcess != NULL && mem.clientBaseAddr != NULL && mem.engineBaseAddr != NULL) {
            if (!state.process) {
                state.process = true;
                io.set_cursor_position(coords.process);
                io.write_str(i.translate(XorStr("yes")), FOREGROUND_GREEN);
            }

            while (client.in_game()) {
                if (!state.game) {
                    state.game = true;
                    io.set_cursor_position(coords.game);
                    io.write_str(i.translate(XorStr("yes")), FOREGROUND_GREEN);
                    client.update_gamemode();
                    hacks.init();
                }
                
                // SendMessage(ol.hwnd, WM_PAINT, NULL, NULL);
                Sleep(500);
            }

            state.game = false;
            hacks.bsp_setted = false;
            io.set_cursor_position(coords.game);
            io.write_str(i.translate(XorStr("waiting")), FOREGROUND_GREEN | FOREGROUND_RED);
            Sleep(5000);
        }

        state.process = false;
        io.set_cursor_position(coords.process);
        io.write_str(i.translate(XorStr("connecting")), FOREGROUND_GREEN | FOREGROUND_RED);
        ++connect_count;
        Sleep(5000);
        if (connect_count >= 2) {
            connect_count = 0;
            mem.~Memory();
            client.~Client();
            hacks.~Hacks();
            // ol.~Overlay();

            new(&mem) Memory();
            new(&client) Client(&mem);
            new(&hacks) Hacks(&mem, &client);
            // new(&ol) Overlay(&mem);

            // SendMessage(ol.hwnd, WM_DESTROY, NULL, NULL);
            // TerminateThread(overlay, EXIT_SUCCESS);
            // CloseHandle(overlay);
            // overlay = CreateThread(NULL, NULL, &ol.static_start, (void*)&ol, NULL, NULL);
        }
    }

    return EXIT_SUCCESS;
}
```

`Le_Chiffre/Le_Chiffre.vcxproj`:

```vcxproj
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|Win32">
      <Configuration>Debug</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|Win32">
      <Configuration>Release</Configuration>
      <Platform>Win32</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>16.0</VCProjectVersion>
    <ProjectGuid>{7545E077-22B0-4895-A3E6-D72A14ECE953}</ProjectGuid>
    <Keyword>Win32Proj</Keyword>
    <RootNamespace>LeChiffre</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
    <SpectreMitigation>false</SpectreMitigation>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <LinkIncremental>true</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(DXSDK_DIR)Lib\x86</LibraryPath>
    <ExecutablePath>$(VC_ExecutablePath_x86);$(CommonExecutablePath)</ExecutablePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LinkIncremental>true</LinkIncremental>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <LinkIncremental>false</LinkIncremental>
    <IncludePath>$(VC_IncludePath);$(WindowsSDK_IncludePath);$(DXSDK_DIR)Include</IncludePath>
    <LibraryPath>$(VC_LibraryPath_x86);$(WindowsSDK_LibraryPath_x86);$(DXSDK_DIR)Lib\x86</LibraryPath>
    <ExecutablePath>$(VC_ExecutablePath_x86);$(CommonExecutablePath)</ExecutablePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LinkIncremental>false</LinkIncremental>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>-DNOMINMAX %(AdditionalOptions)</AdditionalOptions>
      <Optimization>MaxSpeed</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <DebugInformationFormat>None</DebugInformationFormat>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AssemblyDebug>false</AssemblyDebug>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <OptimizeReferences>true</OptimizeReferences>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>
      </EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>WIN32;_CRT_SECURE_NO_WARNINGS;NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <FavorSizeOrSpeed>Speed</FavorSizeOrSpeed>
      <CreateHotpatchableImage>false</CreateHotpatchableImage>
      <AdditionalIncludeDirectories>
      </AdditionalIncludeDirectories>
      <LanguageStandard>stdcpplatest</LanguageStandard>
      <AdditionalOptions>-DNOMINMAX %(AdditionalOptions)</AdditionalOptions>
      <Optimization>MaxSpeed</Optimization>
      <OmitFramePointers>true</OmitFramePointers>
      <WholeProgramOptimization>true</WholeProgramOptimization>
      <DebugInformationFormat>None</DebugInformationFormat>
      <StringPooling>true</StringPooling>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>false</GenerateDebugInformation>
      <AssemblyDebug>false</AssemblyDebug>
      <GenerateWindowsMetadata>false</GenerateWindowsMetadata>
      <AdditionalOptions>/EMITPOGOPHASEINFO %(AdditionalOptions)</AdditionalOptions>
      <LinkTimeCodeGeneration>UseLinkTimeCodeGeneration</LinkTimeCodeGeneration>
      <EntryPointSymbol>
      </EntryPointSymbol>
    </Link>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <PrecompiledHeader>
      </PrecompiledHeader>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_CONSOLE;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
    </ClCompile>
    <Link>
      <SubSystem>Console</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
    </Link>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="bsp_parser\bsp_parser.cpp" />
    <ClCompile Include="client.hpp" />
    <ClCompile Include="Le_Chiffre.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="antiAC.hpp" />
    <ClInclude Include="bsp_parser\valve-bsp-parser\bsp_parser.hpp" />
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\matrix.hpp" />
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\requirements.hpp" />
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\valve_structs.hpp" />
    <ClInclude Include="i18n\en.hpp" />
    <ClInclude Include="i18n\fr.hpp" />
    <ClInclude Include="i18n\hu.hpp" />
    <ClInclude Include="i18n\i18n.hpp" />
    <ClInclude Include="i18n\pl.hpp" />
    <ClInclude Include="i18n\ru.hpp" />
    <ClInclude Include="i18n\tr.hpp" />
    <ClInclude Include="i18n\uk.hpp" />
    <ClInclude Include="i18n\zh.hpp" />
    <ClInclude Include="misc\config.hpp" />
    <ClInclude Include="misc\console_io.hpp" />
    <ClInclude Include="hacks.hpp" />
    <ClInclude Include="memory.hpp" />
    <ClInclude Include="misc\utils.hpp" />
    <ClInclude Include="misc\web_utils.hpp" />
    <ClInclude Include="misc\xor.hpp" />
    <ClInclude Include="overlay\overlay.hpp" />
    <ClInclude Include="overlay\paint.hpp" />
    <ClInclude Include="player_entity.hpp" />
    <ClInclude Include="signatures.hpp" />
    <ClInclude Include="sig_scanner.hpp" />
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>
```

`Le_Chiffre/Le_Chiffre.vcxproj.filters`:

```filters
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <Filter Include="Source Files">
      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
      <Extensions>cpp;c;cc;cxx;c++;def;odl;idl;hpj;bat;asm;asmx</Extensions>
    </Filter>
    <Filter Include="Header Files">
      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
      <Extensions>h;hh;hpp;hxx;h++;hm;inl;inc;ipp;xsd</Extensions>
    </Filter>
    <Filter Include="Resource Files">
      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <ClCompile Include="Le_Chiffre.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="client.hpp">
      <Filter>Source Files</Filter>
    </ClCompile>
    <ClCompile Include="bsp_parser\bsp_parser.cpp">
      <Filter>Source Files</Filter>
    </ClCompile>
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="signatures.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="memory.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="hacks.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="player_entity.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="antiAC.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="overlay\overlay.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="overlay\paint.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bsp_parser\valve-bsp-parser\bsp_parser.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\valve_structs.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\matrix.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="bsp_parser\valve-bsp-parser\core\requirements.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="sig_scanner.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="misc\config.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="misc\web_utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="misc\utils.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="misc\console_io.hpp">
      <Filter>Source Files</Filter>
    </ClInclude>
    <ClInclude Include="misc\xor.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\i18n.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\en.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\ru.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\uk.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\tr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\pl.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\zh.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\fr.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
    <ClInclude Include="i18n\hu.hpp">
      <Filter>Header Files</Filter>
    </ClInclude>
  </ItemGroup>
</Project>
```

`Le_Chiffre/antiAC.hpp`:

```hpp
#ifndef ANTIAC_HPP
#define ANTIAC_HPP
#pragma once

// #define _WIN32_WINNT 0x0400 // https://docs.microsoft.com/en-us/windows/win32/api/debugapi/nf-debugapi-isdebuggerpresent
#include "Windows.h"

class AntiAC {
private:
	HMODULE module_handle;
	HANDLE process_handle;

public:
	// TODO: Run debugger checks in Thread local storage to make bypassing anti-debug more difficult
	AntiAC() {
		process_handle = GetCurrentProcess();
		check_for_debug();

		// module_handle = GetModuleHandle(NULL);
		// erase_pe_headers();
	}

	void check_for_debug() {
		BOOL has_debug_port = TRUE;

		if (IsDebuggerPresent()) ExitProcess(EXIT_SUCCESS); // running in ring-3 debugger
		if (!CheckRemoteDebuggerPresent(process_handle, &has_debug_port)) ExitProcess(EXIT_SUCCESS); // if method fails to execute - exit process
		if (has_debug_port) ExitProcess(EXIT_SUCCESS); // running in ring-3 debugger
	}

	// https://github.com/LordNoteworthy/al-khaser/blob/8ff90a3979face6e29aacb12521b032f2b379073/al-khaser/AntiDump/ErasePEHeaderFromMemory.cpp#L8-L22
	void erase_pe_headers() {
		DWORD OldProtect = 0;

		VirtualProtect((char*)module_handle, 4096, // Assume x86 page size
			PAGE_READWRITE, &OldProtect);

		// Erase the header
		SecureZeroMemory((char*)module_handle, 4096);
	}
};

#endif
```

`Le_Chiffre/bsp_parser/bsp_parser.cpp`:

```cpp
///--------------------------------------------------------------------------------
///-- Author        ReactiioN
///-- Copyright     2016-2020, ReactiioN
///-- License       MIT
///--------------------------------------------------------------------------------
#include "valve-bsp-parser/bsp_parser.hpp"
#include <filesystem>

using namespace rn;

bsp_parser::bsp_parser(bsp_parser&& rhs) noexcept {
    *this = std::move(rhs);
}

bsp_parser& bsp_parser::operator = (bsp_parser&& rhs) noexcept {
    std::unique_lock<std::shared_timed_mutex> lock(rhs._mutex);

    _bsp_header = rhs._bsp_header;
    std::memset(&rhs._bsp_header, 0, sizeof(valve::dheader_t));

    _vertices = std::move(rhs._vertices);
    _planes = std::move(rhs._planes);
    _edges = std::move(rhs._edges);
    _surf_edges = std::move(rhs._surf_edges);
    _leaves = std::move(rhs._leaves);
    _nodes = std::move(rhs._nodes);
    _surfaces = std::move(rhs._surfaces);
    _tex_infos = std::move(rhs._tex_infos);
    _brushes = std::move(rhs._brushes);
    _brush_sides = std::move(rhs._brush_sides);
    _leaf_faces = std::move(rhs._leaf_faces);
    _leaf_brushes = std::move(rhs._leaf_brushes);
    _polygons = std::move(rhs._polygons);

    return *this;
}

bool bsp_parser::set_current_map(
    const std::string& directory,
    const std::string& map_name,
    std::string& file_path
    ) {
    static auto fix_seperators = [](const std::string& input)
    {
        // convert seperators from DOS to UNIX
        return std::filesystem::path(input).generic_string();
    };

    if (directory.empty() || map_name.empty()) {
        return false;
    }

    file_path = fix_seperators(directory)
        .append("/")
        .append(fix_seperators(map_name));

    _map_name = map_name;

#if defined(RN_BSP_PARSER_MESSAGES)
    std::printf("[+] Loading map: %s ...\n", map_name.data());
#endif

    return true;
}

bool bsp_parser::parse_planes(
    std::ifstream& file
    )
{
    std::vector<valve::dplane_t> planes;
    if (!parse_lump(file, valve::lump_index::planes, planes)) {
        return false;
    }

    _planes.resize(planes.size());

    for (std::size_t i = 0; i < planes.size(); ++i) {
        auto& out = _planes.at(i);
        const auto& in = planes.at(i);

        auto plane_bits = 0;
        for (std::size_t j = 0; j < 3; ++j) {
            out.normal(j) = in.normal(j);
            if (out.normal(j) < 0.f) {
                plane_bits |= 1 << static_cast<std::int32_t>(j);
            }
        }

        out.distance = in.distance;
        out.type = static_cast<std::uint8_t>(in.type);
        out.sign_bits = static_cast<std::uint8_t>(plane_bits);
    }

    return true;
}

bool bsp_parser::parse_nodes(
    std::ifstream& file
    )
{
    std::vector<valve::dnode_t> nodes;
    if (!parse_lump(file, valve::lump_index::nodes, nodes)) {
        return false;
    }

    const auto num_nodes = nodes.size();
    _nodes.resize(num_nodes);

    for (std::size_t i = 0; i < num_nodes; ++i) {
        const auto& in = nodes.at(i);
        auto& out = _nodes.at(i);

        out.mins = in.mins;
        out.maxs = in.maxs;
        out.plane_num = in.plane_num;
        out.plane = _planes.data() + in.plane_num;
        out.first_face = in.first_face;
        out.num_faces = in.num_faces;

        for (std::size_t j = 0; j < 2; ++j) {
            const auto child_index = in.children.at(j);
            out.children.at(j) = child_index;

            if (child_index >= 0) {
                out.leaf_children = nullptr;
                out.node_children = _nodes.data() + child_index;
            }
            else {
                out.leaf_children = _leaves.data() + static_cast<std::ptrdiff_t>(-1 - child_index);
                out.node_children = nullptr;
            }
        }
    }

    return true;
}

bool bsp_parser::parse_leaffaces(
    std::ifstream& file
    )
{
    if (!parse_lump(file, valve::lump_index::leaf_faces, _leaf_faces)) {
        return false;
    }

    const auto num_leaffaces = _leaf_faces.size();
    if (num_leaffaces > valve::MAX_MAP_LEAFBRUSHES) {
        printf("[!] map has to many leaffaces, parsed more than required...\n");
    }
    else if (!num_leaffaces) {
        printf("[!] map has no leaffaces to parse...\n");
    }

    return true;
}

bool bsp_parser::parse_leafbrushes(
    std::ifstream& file
    )
{
    if (!parse_lump(file, valve::lump_index::leaf_brushes, _leaf_brushes)) {
        return false;
    }

    const auto num_leaffaces = _leaf_faces.size();
    if (num_leaffaces > valve::MAX_MAP_LEAFBRUSHES) {
        printf("[!] map has to many leafbrushes, parsed more than required...\n");
    }
    else if (!num_leaffaces) {
        printf("[!] map has no leafbrushes to parse...\n");
    }

    return true;
}

bool bsp_parser::parse_polygons()
{
    _polygons.resize(_surfaces.size());

    for (const auto& surface : _surfaces) {
        const auto& first_edge = surface.first_edge;
        const auto& num_edges = surface.num_edges;

        if (num_edges < 3 || static_cast<size_t>(num_edges) > valve::MAX_SURFINFO_VERTS) {
            continue;
        }
        if (surface.tex_info <= 0) {
            continue;
        }

        valve::polygon polygon;
        vector3 edge;

        for (auto i = 0; i < num_edges; ++i) {
            const auto edge_index = _surf_edges.at(first_edge + i);
            if (edge_index >= 0) {
                edge = _vertices.at(_edges[edge_index].v.at(0)).position;
            }
            else {
                edge = _vertices.at(_edges[-edge_index].v.at(1)).position;
            }
            polygon.verts.at(i) = edge;
        }

        polygon.num_verts = static_cast<std::size_t>(num_edges);
        polygon.plane.origin = _planes.at(surface.plane_num).normal;
        polygon.plane.distance = _planes.at(surface.plane_num).distance;
        _polygons.push_back(polygon);
    }

    return true;
}

void bsp_parser::ray_cast_node(
    const std::int32_t node_index,
    const float        start_fraction,
    const float        end_fraction,
    const vector3& origin,
    const vector3& destination,
    valve::trace_t* out
    )
{
    if (out->fraction <= start_fraction) {
        return;
    }

    if (node_index < 0) {
        auto* leaf = &_leaves.at(static_cast<std::size_t>(-node_index - 1));
        for (std::uint16_t i = 0; i < leaf->num_leafbrushes; ++i) {

            const auto brush_index = static_cast<std::int32_t>(_leaf_brushes.at(leaf->first_leafbrush + i));
            auto* brush = &_brushes.at(brush_index);
            if (!brush || !(brush->contents & valve::MASK_SHOT_HULL)) {
                continue;
            }

            ray_cast_brush(brush, origin, destination, out);
            if (out->fraction == 0.f) {
                return;
            }

            out->brush = brush;
        }
        if (out->start_solid || out->fraction < 1.f) {
            return;
        }
        for (std::uint16_t i = 0; i < leaf->num_leaffaces; ++i) {
            ray_cast_surface(static_cast<std::int32_t>(_leaf_faces.at(leaf->first_leafface + i)), origin, destination, out);
        }
        return;
    }

    auto* node = &_nodes.at(static_cast<std::size_t>(node_index));
    if (!node) {
        return;
    }
    auto* plane = node->plane;
    if (!plane) {
        return;
    }

    float start_distance, end_distance;

    if (plane->type < 3) {
        start_distance = origin(static_cast<std::size_t>(plane->type)) - plane->distance;
        end_distance = destination(static_cast<std::size_t>(plane->type)) - plane->distance;
    }
    else {
        start_distance = origin.dot(plane->normal) - plane->distance;
        end_distance = destination.dot(plane->normal) - plane->distance;
    }

    if (start_distance >= 0.f && end_distance >= 0.f) {
        ray_cast_node(node->children.at(0), start_fraction, end_fraction, origin, destination, out);
    }
    else if (start_distance < 0.f && end_distance < 0.f) {
        ray_cast_node(node->children.at(1), start_fraction, end_fraction, origin, destination, out);
    }
    else {
        std::int32_t side_id;
        float fraction_first, fraction_second;
        vector3 middle;

        if (start_distance < end_distance) {
            /// Back
            side_id = 1;
            const auto inversed_distance = 1.f / (start_distance - end_distance);

            fraction_first = (start_distance + FLT_EPSILON) * inversed_distance;
            fraction_second = (start_distance + FLT_EPSILON) * inversed_distance;
        }
        else if (end_distance < start_distance) {
            /// Front
            side_id = 0;
            const auto inversed_distance = 1.0f / (start_distance - end_distance);

            fraction_first = (start_distance + FLT_EPSILON) * inversed_distance;
            fraction_second = (start_distance - FLT_EPSILON) * inversed_distance;
        }
        else {
            /// Front
            side_id = 0;
            fraction_first = 1.f;
            fraction_second = 0.f;
        }
        if (fraction_first < 0.f) {
            fraction_first = 0.f;
        }
        else if (fraction_first > 1.f) {
            fraction_first = 1.f;
        }
        if (fraction_second < 0.f) {
            fraction_second = 0.f;
        }
        else if (fraction_second > 1.f) {
            fraction_second = 1.f;
        }

        auto fraction_middle = start_fraction + (end_fraction - start_fraction) * fraction_first;
        for (std::size_t i = 0; i < 3; i++) {
            middle(i) = origin(i) + fraction_first * (destination(i) - origin(i));
        }

        ray_cast_node(node->children.at(side_id), start_fraction, fraction_middle, origin, middle, out);
        fraction_middle = start_fraction + (end_fraction - start_fraction) * fraction_second;
        for (std::size_t i = 0; i < 3; i++) {
            middle(i) = origin(i) + fraction_second * (destination(i) - origin(i));
        }

        ray_cast_node(node->children.at(!side_id), fraction_middle, end_fraction, middle, destination, out);
    }
}

void bsp_parser::ray_cast_brush(
    valve::dbrush_t* brush,
    const vector3& origin,
    const vector3& destination,
    valve::trace_t* out
    ) const
{
    if (brush->num_sides) {
        auto fraction_to_enter = -99.f;
        auto fraction_to_leave = 1.f;
        auto starts_out = false;
        auto ends_out = false;
        for (auto i = 0; i < brush->num_sides; ++i) {
            auto const* brush_side = &_brush_sides.at(brush->first_side + i);
            if (!brush_side || brush_side->bevel) {
                continue;
            }

            auto const* plane = &_planes.at(brush_side->plane_num);
            if (!plane) {
                continue;
            }

            const auto start_distance = origin.dot(plane->normal) - plane->distance;
            const auto end_distance = destination.dot(plane->normal) - plane->distance;
            if (start_distance > 0.f) {
                starts_out = true;
                if (end_distance > 0.f) {
                    return;
                }
            }
            else {
                if (end_distance <= 0.f) {
                    continue;
                }
                ends_out = true;
            }
            if (start_distance > end_distance) {
                auto fraction = std::max((start_distance - valve::DIST_EPSILON), 0.f);
                fraction = fraction / (start_distance - end_distance);
                if (fraction > fraction_to_enter) {
                    fraction_to_enter = fraction;
                }
            }
            else {
                const auto fraction = (start_distance + valve::DIST_EPSILON) / (start_distance - end_distance);
                if (fraction < fraction_to_leave) {
                    fraction_to_leave = fraction;
                }
            }
        }

        if (starts_out) {
            if (out->fraction_left_solid - fraction_to_enter > 0.f) {
                starts_out = false;
            }
        }

        out->num_brush_sides = brush->num_sides;

        if (!starts_out) {
            out->start_solid = true;
            out->contents = brush->contents;

            if (!ends_out) {
                out->all_solid = true;
                out->fraction = 0.f;
                out->fraction_left_solid = 1.f;
            }
            else {
                if (fraction_to_leave != 1.f && fraction_to_leave > out->fraction_left_solid) {
                    out->fraction_left_solid = fraction_to_leave;
                    if (out->fraction <= fraction_to_leave) {
                        out->fraction = 1.f;
                    }
                }
            }
            return;
        }

        if (fraction_to_enter < fraction_to_leave) {
            if (fraction_to_enter > -99.f && fraction_to_enter < out->fraction) {
                if (fraction_to_enter < 0.f) {
                    fraction_to_enter = 0.f;
                }

                out->fraction = fraction_to_enter;
                out->brush = brush;
                out->contents = brush->contents;
            }
        }
    }
}

void bsp_parser::ray_cast_surface(
    const std::int32_t surface_index,
    const vector3& origin,
    const vector3& destination,
    valve::trace_t* out
    )
{
    const auto index = static_cast<std::size_t>(surface_index);
    if (index >= _polygons.size()) {
        return;
    }

    auto* polygon = &_polygons.at(index);
    auto* plane = &polygon->plane;
    const auto dot1 = plane->dist(origin);
    const auto dot2 = plane->dist(destination);

    if (dot1 > 0.f != dot2 > 0.f) {
        if (dot1 - dot2 < valve::DIST_EPSILON) {
            return;
        }

        const auto t = dot1 / (dot1 - dot2);
        if (t <= 0) {
            return;
        }

        std::size_t i = 0;
        const auto intersection = origin + (destination - origin) * t;
        for (; i < polygon->num_verts; ++i) {
            auto* edge_plane = &polygon->edge_planes.at(i);
            if (edge_plane->origin.is_zero()) {
                edge_plane->origin = plane->origin - (polygon->verts.at(i) - polygon->verts.at((i + 1) % polygon->num_verts));
                edge_plane->origin.normalize();
                edge_plane->distance = edge_plane->origin.dot(polygon->verts.at(i));
            }
            if (edge_plane->dist(intersection) < 0.0f) {
                break;
            }
        }
        if (i == polygon->num_verts) {
            out->fraction = 0.2f;
            out->end_pos = intersection;
        }
    }
}

bool bsp_parser::load_map(
    const std::string& directory,
    const std::string& map_name
    )
{
    if (map_name == _map_name) {
        return true;
    }

    std::unique_lock<std::shared_timed_mutex> lock(_mutex);

    std::string file_path;
    if (!set_current_map(directory, map_name, file_path)) {
        return false;
    }

    std::ifstream file(file_path, std::ios_base::binary);
    if (!file) {
#if defined(RN_BSP_PARSER_MESSAGES)
        std::printf("[!] failed to open file: %s\n", file_path.data());
#endif
        return false;
    }

    try {
        file.read(reinterpret_cast<char*>(&_bsp_header), sizeof(_bsp_header));
#if defined(RN_BSP_PARSER_MESSAGES)
        if (_bsp_header.m_Version < valve::BSPVERSION) {
            std::printf("[!] unknown BSP version (%d), trying to parse it anyway...\n", _bsp_header.m_Version);
        }
#endif
        if (!valve::has_valid_bsp_ident(_bsp_header.ident)) {
#if defined(RN_BSP_PARSER_MESSAGES)
            std::printf("[!] %s isn't a (valid) .bsp file!\n", map_name.data());
#endif
            return false;
        }

        return parse_lump(file, valve::lump_index::vertices, _vertices)
            && parse_planes(file)
            && parse_lump(file, valve::lump_index::edges, _edges)
            && parse_lump(file, valve::lump_index::surfedges, _surf_edges)
            && parse_lump(file, valve::lump_index::leafs, _leaves)
            && parse_nodes(file)
            && parse_lump(file, valve::lump_index::faces, _surfaces)
            && parse_lump(file, valve::lump_index::tex_info, _tex_infos)
            && parse_lump(file, valve::lump_index::brushes, _brushes)
            && parse_lump(file, valve::lump_index::brush_sides, _brush_sides)
            && parse_leaffaces(file)
            && parse_leafbrushes(file)
            && parse_polygons()
            ;
    }
    catch (...) {
        return false;
    }
}

bool bsp_parser::is_visible(
    const vector3& origin,
    const vector3& destination
    )
{
    std::shared_lock<std::shared_timed_mutex> lock(_mutex);

    valve::trace_t trace{};
    trace_ray(origin, destination, &trace);

    return !(trace.fraction < 1.f);
}

void bsp_parser::trace_ray(
    const vector3& origin,
    const vector3 & final,
    valve::trace_t* out
    )
{
    if (!_planes.empty() && out) {

        out->clear();
        out->fraction = 1.0f;
        out->fraction_left_solid = 0.f;

        ray_cast_node(0, 0.f, 1.f, origin, final, out);

        if (out->fraction < 1.0f) {
            for (std::size_t i = 0; i < 3; ++i) {
                out->end_pos(i) = origin(i) + out->fraction * (final(i) - origin(i));
            }
        }
        else {
            out->end_pos = final;
        }
    }
}

```

`Le_Chiffre/bsp_parser/valve-bsp-parser/bsp_parser.hpp`:

```hpp
///--------------------------------------------------------------------------------
///-- Author        ReactiioN
///-- Copyright     2016-2020, ReactiioN
///-- License       MIT
///--------------------------------------------------------------------------------
#pragma once

#include "core/valve_structs.hpp"
#include <shared_mutex>

namespace rn {
    class bsp_parser final
    {
    public:
        bsp_parser() = default;

        ~bsp_parser() = default;

        bsp_parser(
            const bsp_parser& rhs
            ) = delete;

        bsp_parser& operator = (
            const bsp_parser& rhs
            ) = delete;

        bsp_parser(
            bsp_parser&& rhs
            ) noexcept;

        bsp_parser& operator = (
            bsp_parser&& rhs
            ) noexcept;

    private:
        bool set_current_map(
            const std::string& directory,
            const std::string& map_name,
            std::string& file_path
            );

        bool parse_planes(
            std::ifstream& file
            );

        bool parse_nodes(
            std::ifstream& file
            );

        bool parse_leaffaces(
            std::ifstream& file
            );

        bool parse_leafbrushes(
            std::ifstream& file
            );

        bool parse_polygons();

        void ray_cast_node(
            std::int32_t    node_index,
            float           start_fraction,
            float           end_fraction,
            const vector3& origin,
            const vector3& destination,
            valve::trace_t* out
            );

        void ray_cast_surface(
            std::int32_t    surface_index,
            const vector3& origin,
            const vector3& destination,
            valve::trace_t* out
            );

        void ray_cast_brush(
            valve::dbrush_t* brush,
            const vector3& origin,
            const vector3& destination,
            valve::trace_t* out
            )const;

        template<typename type>
        _NODISCARD
            bool parse_lump(
                std::ifstream& file,
                const valve::lump_index lump_index,
                std::vector<type>& out
                ) const
        {
            const auto index = static_cast<std::underlying_type_t<valve::lump_index>>(lump_index);
            if (index >= _bsp_header.lumps.size()) {
                return false;
            }

            const auto& lump = _bsp_header.lumps.at(index);
            const auto size = static_cast<std::size_t>(lump.file_size) / sizeof(type);

            out.resize(size);

            file.seekg(lump.file_offset);
            file.read(reinterpret_cast<char*>(out.data()), size * static_cast<std::size_t>(sizeof(type)));

            return true;
        }

    public:
        bool load_map(
            const std::string& directory,
            const std::string& map_name
            );

        bool is_visible(
            const vector3& origin,
            const vector3& destination
            );

        void trace_ray(
            const vector3& origin,
            const vector3 & final,
            valve::trace_t* out
            );

    private:
        std::string                      _map_name;
        valve::dheader_t                 _bsp_header;
        std::vector<valve::mvertex_t>    _vertices;
        std::vector<valve::cplane_t>     _planes;
        std::vector<valve::dedge_t>      _edges;
        std::vector<std::int32_t>        _surf_edges;
        std::vector<valve::dleaf_t>      _leaves;
        std::vector<valve::snode_t>      _nodes;
        std::vector<valve::dface_t>      _surfaces;
        std::vector<valve::texinfo_t>    _tex_infos;
        std::vector<valve::dbrush_t>     _brushes;
        std::vector<valve::dbrushside_t> _brush_sides;
        std::vector<std::uint16_t>       _leaf_faces;
        std::vector<std::uint16_t>       _leaf_brushes;
        std::vector<valve::polygon>      _polygons;
        mutable std::shared_timed_mutex  _mutex;
    };
}

```

`Le_Chiffre/bsp_parser/valve-bsp-parser/core/matrix.hpp`:

```hpp
#pragma once

#include "requirements.hpp"

namespace rn::detail {
    template<std::size_t num_rows, std::size_t num_cols>
    class matrix_t {
        using type_array = std::array<float, num_rows* num_cols>;

        static constexpr std::size_t clamp_index(const std::size_t index) {
            return std::clamp(index, std::numeric_limits<std::size_t>::min(), size() - 1);
        }

    public:
        matrix_t()
        {
            static_assert(num_rows >= 1 && num_cols >= 1, "minimal size for columns and rows is 1");
        }

        matrix_t(
            const matrix_t& rhs
            ) = default;

        matrix_t(
            matrix_t&& rhs
            ) noexcept
        {
            *this = std::move(rhs);
        }

        explicit matrix_t(
            const type_array& values
            )
            : _data(values)
        { }

        template<typename ...arguments>
        matrix_t(
            arguments&& ...args
            )
            : _data{ static_cast<float>(std::forward<arguments>(args))... }
        { }

        ~matrix_t() = default;

        matrix_t& operator = (
            const matrix_t& rhs
            ) = default;

        matrix_t& operator = (
            matrix_t&& rhs
            ) noexcept
        {
            _data = rhs._data;

            rhs.clear();

            return *this;
        }

        static constexpr
            std::size_t size()
        {
            return num_rows * num_cols;
        }

        static constexpr
            std::size_t rows()
        {
            return num_rows;
        }

        static constexpr
            std::size_t cols()
        {
            return num_cols;
        }

        static constexpr
            bool is_vector()
        {
            return (num_cols == 1 || num_rows == 1)
                && (num_cols == 1 ? num_rows : num_cols) <= 4;
        }

        matrix_t& operator += (
            const matrix_t& rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) += rhs(i);
            }

            return *this;
        }

        matrix_t& operator += (
            const float rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) += rhs;
            }

            return *this;
        }

        matrix_t& operator -= (
            const matrix_t& rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) -= rhs(i);
            }

            return *this;
        }

        matrix_t& operator -= (
            const float rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) -= rhs;
            }

            return *this;
        }

        matrix_t& operator *= (
            const float rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) *= rhs;
            }

            return *this;
        }

        matrix_t& operator /= (
            const float rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                at(i) /= rhs;
            }

            return *this;
        }

        matrix_t operator + (
            const matrix_t& rhs
            ) const
        {
            auto lhs = *this;
            lhs += rhs;
            return lhs;
        }

        matrix_t operator + (
            const float rhs
            ) const
        {
            auto lhs = *this;
            lhs += rhs;
            return lhs;
        }

        matrix_t operator - (
            const matrix_t& rhs
            ) const
        {
            auto lhs = *this;
            lhs -= rhs;
            return lhs;
        }

        matrix_t operator - (
            const float rhs
            ) const
        {
            auto lhs = *this;
            lhs -= rhs;
            return lhs;
        }

        matrix_t operator * (
            const float rhs
            ) const
        {
            auto lhs = *this;
            lhs *= rhs;
            return lhs;
        }

        matrix_t operator / (
            const float rhs
            ) const
        {
            auto lhs = *this;
            lhs /= rhs;
            return lhs;
        }

        bool operator == (
            const matrix_t& rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                if (at(i) != rhs(i)) {
                    return false;
                }
            }
            return true;
        }

        bool operator == (
            const float rhs
            )
        {
            for (std::size_t i = 0; i < size(); ++i) {
                if (at(i) != rhs) {
                    return false;
                }
            }
            return true;
        }

        bool operator != (
            const matrix_t& rhs
            )
        {
            return !((*this) == rhs);
        }

        bool operator != (
            const float rhs
            )
        {
            return !((*this) == rhs);
        }

        float& operator () (
            const std::size_t index
            )
        {
            return at(index);
        }

        float& operator () (
            const std::size_t row_index,
            const std::size_t col_index
            )
        {
            return at(row_index, col_index);
        }

        const float& operator () (
            const std::size_t index
            ) const
        {
            return at(index);
        }

        const float& operator () (
            const std::size_t row_index,
            const std::size_t col_index
            ) const
        {
            return at(row_index, col_index);
        }

        float& at(
            const std::size_t index
            )
        {
            return _data.at(clamp_index(index));
        }

        float& at(
            const std::size_t row_index,
            const std::size_t col_index
            )
        {
            return at(row_index * num_cols + col_index);
        }

        _NODISCARD
            const float& at(
                const std::size_t index
                ) const
        {
            return _data.at(clamp_index(index));
        }

        _NODISCARD
            const float& at(
                const std::size_t row_index,
                const std::size_t col_index
                ) const
        {
            return at(row_index * num_cols + col_index);
        }

        _NODISCARD
            bool is_zero() const
        {
            return all_of(0.f);
        }

        _NODISCARD
            bool all_of(
                const float value
                ) const
        {
            return std::all_of(_data.begin(), _data.end(), [&value](const float x)
                {
                    return x == value;
                });
        }

        _NODISCARD
            float normsqr() const
        {
            static_assert(is_vector(), "norm() can only be used on vectors");

            auto value = 0.f;

            for (const auto& x : _data) {
                value += (x * x);
            }

            return value;
        }

        _NODISCARD
            float norm() const
        {
            return std::sqrtf(normsqr());
        }

        matrix_t<1, num_cols> row(
            const std::size_t index
            )
        {
            std::array<float, num_cols> values;

            for (std::size_t i = 0; i < num_cols; ++i) {
                values[i] = at(index, i);
            }

            return matrix_t<1, num_cols>(values);
        }

        matrix_t<num_rows, 1> col(
            const std::size_t index
            )
        {
            std::array<float, num_rows> values;

            for (std::size_t i = 0; i < num_rows; ++i) {
                values[i] = at(i, index);
            }

            return matrix_t<num_rows, 1>(values);
        }

        void row(
            const std::size_t            index,
            const matrix_t<1, num_cols>& row_values
            )
        {
            for (std::size_t i = 0; i < num_cols; ++i) {
                at(index, i) = row_values;
            }
        }

        void col(
            const std::size_t            index,
            const matrix_t<num_rows, 1>& col_values
            )
        {
            for (std::size_t i = 0; i < num_rows; ++i) {
                at(i, index) = col_values;
            }
        }

        void fill(
            const float value
            )
        {
            _data.fill(value);
        }

        void clear()
        {
            fill(0.f);
        }

        void set(
            const type_array& values
            )
        {
            _data = values;
        }

        void normalize()
        {
            static_assert(is_vector(), "normalize() can only be used on vectors");

            (*this) /= norm();
        }

        _NODISCARD
            matrix_t normalized() const
        {
            auto lhs = *this;
            lhs.normalize();
            return lhs;
        }

        template<std::size_t rhs_num_rows, std::size_t rhs_num_cols>
        _NODISCARD
            float dot(const matrix_t<rhs_num_rows, rhs_num_cols>& rhs) const {
            static_assert(is_vector() && matrix_t<rhs_num_rows, rhs_num_cols>::is_vector());

            auto value = 0.f;
            const auto length = std::min(size(), rhs_num_rows * rhs_num_cols);

            for (std::size_t i = 0; i < length; ++i) {
                value += at(i) * rhs(i);
            }

            return value;
        }

        _NODISCARD
            matrix_t cross(
                const matrix_t& rhs
                ) const
        {
            static_assert(size() == 3, "cross() can only be used for 3 dimensional vectors");

            return matrix_t{
                at(1) * rhs(2) - at(2) * rhs(1),
                at(2) * rhs(0) - at(0) * rhs(2),
                at(0) * rhs(1) - at(1) * rhs(0),
            };
        }

        _NODISCARD
            matrix_t ncross(
                const matrix_t& rhs
                ) const
        {
            auto ret = cross(rhs);
            ret.normalize();
            return ret;
        }

    private:
        type_array _data{};
    };
}

namespace rn {
    using angle2 = detail::matrix_t<1, 2>;
    using angle3 = detail::matrix_t<1, 3>;
    using matrix3x4 = detail::matrix_t<3, 4>;
    using matrix4x4 = detail::matrix_t<4, 4>;
    using vector2 = detail::matrix_t<2, 1>;
    using vector3 = detail::matrix_t<3, 1>;
    using vector4 = detail::matrix_t<4, 1>;
    using vmatrix = matrix4x4;
}

```

`Le_Chiffre/bsp_parser/valve-bsp-parser/core/requirements.hpp`:

```hpp
///--------------------------------------------------------------------------------
///-- Author        ReactiioN
///-- Copyright     2016-2020, ReactiioN
///-- License       MIT
///--------------------------------------------------------------------------------
#pragma once

#if defined(_MSC_VER)
#if !defined(NOMINMAX)
#define NOMINMAX
#endif
#endif

#include <array>
#include <algorithm>
#include <cmath>
#include <fstream>
#include <string>
#include <vector>

```

`Le_Chiffre/bsp_parser/valve-bsp-parser/core/valve_structs.hpp`:

```hpp
//--------------------------------------------------------------------------------
//-- Author        ReactiioN
//-- Copyright     2016-2020, ReactiioN
//-- License       MIT
//--------------------------------------------------------------------------------
#pragma once

#include "matrix.hpp"

namespace rn::valve {
    constexpr bool has_valid_bsp_ident(
        const std::int32_t ident
        )
    {
        return ident >= ('P' << 24) + ('S' << 16) + ('B' << 8) + 'V';
    }

    constexpr std::int32_t MAX_BRUSH_LIGHTMAP_DIM_WITHOUT_BORDER = 32;
    constexpr std::int32_t MAX_BRUSH_LIGHTMAP_DIM_INCLUDING_BORDER = 35;
    constexpr std::int32_t MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER = 128;
    constexpr std::int32_t MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER = 131;
    constexpr std::int32_t MAX_LIGHTMAP_DIM_WITHOUT_BORDER = MAX_DISP_LIGHTMAP_DIM_WITHOUT_BORDER;
    constexpr std::int32_t MAX_LIGHTMAP_DIM_INCLUDING_BORDER = MAX_DISP_LIGHTMAP_DIM_INCLUDING_BORDER;

    constexpr float        DIST_EPSILON = 0.03125f;
    constexpr std::size_t  MAX_SURFINFO_VERTS = 32;
    constexpr std::int32_t BSPVERSION = 19;
    constexpr std::size_t  HEADER_LUMPS = 64;
    constexpr std::size_t  MAX_POLYGONS = 50120;
    constexpr std::size_t  MAX_MOD_KNOWN = 512;
    constexpr std::size_t  MAX_MAP_MODELS = 1024;
    constexpr std::size_t  MAX_MAP_BRUSHES = 8192;
    constexpr std::size_t  MAX_MAP_ENTITIES = 4096;
    constexpr std::size_t  MAX_MAP_ENTSTRING = 256 * 1024;
    constexpr std::size_t  MAX_MAP_NODES = 65536;
    constexpr std::size_t  MAX_MAP_TEXINFO = 12288;
    constexpr std::size_t  MAX_MAP_TEXDATA = 2048;
    constexpr std::size_t  MAX_MAP_LEAFBRUSHES = 65536;
    constexpr std::size_t  MIN_MAP_DISP_POWER = 2;
    constexpr std::size_t  MAX_MAP_DISP_POWER = 4;
    constexpr std::size_t  MAX_MAP_SURFEDGES = 512000;
    constexpr std::size_t  MAX_DISP_CORNER_NEIGHBORS = 4;

    // NOTE: These are stored in a short in the engine now.  Don't use more than 16 bits
    constexpr std::int32_t SURF_LIGHT = 0x0001; // value will hold the light strength
    constexpr std::int32_t SURF_SLICK = 0x0002; // effects game physics
    constexpr std::int32_t SURF_SKY = 0x0004; // don't draw, but add to skybox
    constexpr std::int32_t SURF_WARP = 0x0008; // turbulent water warp
    constexpr std::int32_t SURF_TRANS = 0x0010;
    constexpr std::int32_t SURF_WET = 0x0020; // the surface is wet
    constexpr std::int32_t SURF_FLOWING = 0x0040; // scroll towards angle
    constexpr std::int32_t SURF_NODRAW = 0x0080; // don't bother referencing the texture
    constexpr std::int32_t SURF_Hint32_t = 0x0100; // make a primary bsp splitter
    constexpr std::int32_t SURF_SKIP = 0x0200; // completely ignore, allowing non-closed brushes
    constexpr std::int32_t SURF_NOLIGHT = 0x0400; // Don't calculate light
    constexpr std::int32_t SURF_BUMPLIGHT = 0x0800; // calculate three lightmaps for the surface for bumpmapping
    constexpr std::int32_t SURF_HITBOX = 0x8000; // surface is part of a hitbox

    constexpr std::int32_t CONTENTS_EMPTY = 0;           // No contents
    constexpr std::int32_t CONTENTS_SOLID = 0x1;         // an eye is never valid in a solid
    constexpr std::int32_t CONTENTS_WINDOW = 0x2;         // translucent, but not watery (glass)
    constexpr std::int32_t CONTENTS_AUX = 0x4;
    constexpr std::int32_t CONTENTS_GRATE = 0x8;         // alpha-tested "grate" textures.  Bullets/sight pass through, but solids don't
    constexpr std::int32_t CONTENTS_SLIME = 0x10;
    constexpr std::int32_t CONTENTS_WATER = 0x20;
    constexpr std::int32_t CONTENTS_MIST = 0x40;
    constexpr std::int32_t CONTENTS_OPAQUE = 0x80;        // things that cannot be seen through (may be non-solid though)
    constexpr std::int32_t LAST_VISIBLE_CONTENTS = 0x80;
    constexpr std::int32_t ALL_VISIBLE_CONTENTS = LAST_VISIBLE_CONTENTS | LAST_VISIBLE_CONTENTS - 1;
    constexpr std::int32_t CONTENTS_TESTFOGVOLUME = 0x100;
    constexpr std::int32_t CONTENTS_UNUSED3 = 0x200;
    constexpr std::int32_t CONTENTS_UNUSED4 = 0x400;
    constexpr std::int32_t CONTENTS_UNUSED5 = 0x800;
    constexpr std::int32_t CONTENTS_UNUSED6 = 0x1000;
    constexpr std::int32_t CONTENTS_UNUSED7 = 0x2000;
    constexpr std::int32_t CONTENTS_MOVEABLE = 0x4000;      // hits entities which are MOVETYPE_PUSH (doors, plats, etc.)
    // remaining contents are non-visible, and don't eat brushes
    constexpr std::int32_t CONTENTS_AREAPORTAL = 0x8000;
    constexpr std::int32_t CONTENTS_PLAYERCLIP = 0x10000;
    constexpr std::int32_t CONTENTS_MONSTERCLIP = 0x20000;
    // currents can be added to any other contents, and may be mixed
    constexpr std::int32_t CONTENTS_CURRENT_0 = 0x40000;
    constexpr std::int32_t CONTENTS_CURRENT_90 = 0x80000;
    constexpr std::int32_t CONTENTS_CURRENT_180 = 0x100000;
    constexpr std::int32_t CONTENTS_CURRENT_270 = 0x200000;
    constexpr std::int32_t CONTENTS_CURRENT_UP = 0x400000;
    constexpr std::int32_t CONTENTS_CURRENT_DOWN = 0x800000;
    constexpr std::int32_t CONTENTS_ORIGIN = 0x1000000;   // removed before bsping an entity
    constexpr std::int32_t CONTENTS_MONSTER = 0x2000000;   // should never be on a brush, only in game
    constexpr std::int32_t CONTENTS_DEBRIS = 0x4000000;
    constexpr std::int32_t CONTENTS_DETAIL = 0x8000000;   // brushes to be added after vis leafs
    constexpr std::int32_t CONTENTS_TRANSLUCENT = 0x10000000;  // int32_t set if any surface has trans
    constexpr std::int32_t CONTENTS_LADDER = 0x20000000;
    constexpr std::int32_t CONTENTS_HITBOX = 0x40000000;  // use accurate hitboxes on trace

    // everyhting
    constexpr std::int32_t MASK_ALL = 0xFFFFFFFF;
    // everything that is normally solid
    constexpr std::int32_t MASK_SOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    // everything that blocks player movement
    constexpr std::int32_t MASK_PLAYERSOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    // blocks npc movement
    constexpr std::int32_t MASK_NPCSOLID = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTERCLIP | CONTENTS_WINDOW | CONTENTS_MONSTER | CONTENTS_GRATE;
    // water physics in these contents
    constexpr std::int32_t MASK_WATER = CONTENTS_WATER | CONTENTS_MOVEABLE | CONTENTS_SLIME;
    // everything that blocks line of sight
    constexpr std::int32_t MASK_OPAQUE = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_SLIME | CONTENTS_OPAQUE;
    // bullets see these as solid
    constexpr std::int32_t MASK_SHOT = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_HITBOX;
    // non-raycasted weapons see this as solid (includes grates)
    constexpr std::int32_t MASK_SHOT_HULL = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_MONSTER | CONTENTS_WINDOW | CONTENTS_DEBRIS | CONTENTS_GRATE;
    // everything normally solid, except monsters (world+brush only)
    constexpr std::int32_t MASK_SOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_GRATE;
    // everything normally solid for player movement, except monsters (world+brush only)
    constexpr std::int32_t MASK_PLAYERSOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_PLAYERCLIP | CONTENTS_GRATE;
    // everything normally solid for npc movement, except monsters (world+brush only)
    constexpr std::int32_t MASK_NPCSOLID_BRUSHONLY = CONTENTS_SOLID | CONTENTS_MOVEABLE | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
    // just the world, used for route rebuilding
    constexpr std::int32_t MASK_NPCWORLDSTATIC = CONTENTS_SOLID | CONTENTS_WINDOW | CONTENTS_MONSTERCLIP | CONTENTS_GRATE;
    // UNDONE: This is untested, any moving water
    constexpr std::int32_t MASK_CURRENT = CONTENTS_CURRENT_0 | CONTENTS_CURRENT_90 | CONTENTS_CURRENT_180 | CONTENTS_CURRENT_270 | CONTENTS_CURRENT_UP | CONTENTS_CURRENT_DOWN;
    constexpr std::int32_t MASK_DEADSOLID = CONTENTS_SOLID | CONTENTS_PLAYERCLIP | CONTENTS_WINDOW | CONTENTS_GRATE;

    enum class lump_index
        : std::size_t
    {
        entities = 0,
        planes = 1,
        tex_data = 2,
        vertices = 3, // "LUMP_VERTEXES"
        visibility = 4,
        nodes = 5,
        tex_info = 6,
        faces = 7,
        lighting = 8,
        occlusion = 9,
        leafs = 10,
        edges = 12,
        surfedges = 13,
        models = 14,
        world_lights = 15,
        leaf_faces = 16,
        leaf_brushes = 17,
        brushes = 18,
        brush_sides = 19,
        ares = 20,
        area_portals = 21,
        portals = 22,
        clusters = 23,
        portal_verts = 24,
        cluster_portals = 25,
        disp_info = 26,
        original_faces = 27,
        phys_collide = 29,
        vert_normals = 30,
        vert_normal_indices = 31,
        lightmap_alphas = 32,
        disp_verts = 33,
        disp_lightmap_sample_positions = 34,
        game_lump = 35,
        leafwaterdata = 36,
        primitives = 37,
        prim_vertices = 38,
        prim_indices = 39,
        pak_file = 40,
        clipportal_vertices = 41,
        cubemaps = 42,
        texdata_string_data = 43,
        texdata_string_table = 44,
        overlays = 45,
        leaf_min_dist_to_water = 46,
        face_macro_texture_info = 47,
        disp_tris = 48
    };

    class lump_t
    {
        using type_four_cc = std::array<char, 4>;
    public:
        std::int32_t file_offset = 0; // 0x0
        std::int32_t file_size = 0; // 0x4
        std::int32_t version = 0; // 0x8
        type_four_cc four_cc{};    // 0xC
    };//Size=0x10

    class dheader_t
    {
        using type_lumps = std::array<lump_t, HEADER_LUMPS>;

    public:
        std::int32_t ident = 0; // 0x000
        std::int32_t version = 0; // 0x004
        type_lumps   lumps{};          // 0x008
        std::int32_t map_revision = 0; // 0x408

    };//Size=0x40C

    class dplane_t
    {
    public:
        vector3      normal;   // 0x00
        float        distance; // 0x0C
        std::int32_t type;     // 0x10
    };//Size=0x14

    class cplane_t
    {
    public:
        vector3      normal;            // 0x00
        float        distance;          // 0x0C
        std::uint8_t type;              // 0x10
        std::uint8_t sign_bits;         // 0x11
    private:
        std::uint8_t _pad0x12[0x2]{}; // 0x12
    };//Size=0x14

    class dedge_t
    {
    public:
        std::array<std::uint16_t, 2> v; // 0x0
    };//Size=0x4

    class mvertex_t
    {
    public:
        vector3 position; // 0x0
    };//Size=0xC

    class dleaf_t
    {
        using type_min_max = std::array<std::int16_t, 3>;

    public:
        std::int32_t  contents;           // 0x00
        std::int16_t  cluster;            // 0x04
        std::int16_t  area : 9;           // 0x06
        std::int16_t  flags : 7;          // 0x11
        type_min_max  mins;               // 0x1A
        type_min_max  maxs;               // 0x20
        std::uint16_t first_leafface;     // 0x26
        std::uint16_t num_leaffaces;      // 0x28
        std::uint16_t first_leafbrush;    // 0x2A
        std::uint16_t num_leafbrushes;    // 0x2C
        std::int16_t  leaf_water_data_id; // 0x2E
    };//Size=0x30

    class dnode_t
    {
        using type_min_max = std::array<std::int16_t, 3>;
        using type_children = std::array<std::int32_t, 2>;

    public:
        std::int32_t  plane_num;         // 0x00
        type_children children;          // 0x04
        type_min_max  mins;              // 0x0C
        type_min_max  maxs;              // 0x12
        std::uint16_t first_face;        // 0x18
        std::uint16_t num_faces;         // 0x1A
        std::int16_t  area;              // 0x1C
    private:
        std::uint8_t  _pad0x1E[0x2]{}; // 0x1E
    };//Size=0x20

    class snode_t
    {
        using type_min_max = std::array<std::int16_t, 3>;
        using type_children = std::array<std::int32_t, 2>;

    public:
        std::int32_t  plane_num;           // 0x00
        cplane_t* plane;               // 0x04
        type_children children;            // 0x08
        dleaf_t* leaf_children;       // 0x10
        snode_t* node_children;       // 0x14
        type_min_max  mins;                // 0x18
        type_min_max  maxs;                // 0x1E
        std::uint16_t first_face;          // 0x24
        std::uint16_t num_faces;           // 0x26
        std::int16_t  area;                // 0x28
    private:
        std::uint8_t  _pad0x2A[0x2]{};   // 0x2A
    };//Size=0x2C

    class dface_t
    {
        using type_styles = std::array<std::uint8_t, 4>;
        using type_luxels = std::array<std::int32_t, 2>;

    public:
        std::uint16_t plane_num;                       // 0x00
        std::uint8_t  side;                            // 0x02
        std::uint8_t  on_node;                         // 0x03
        std::int32_t  first_edge;                      // 0x04
        std::int16_t  num_edges;                       // 0x08
        std::int16_t  tex_info;                        // 0x0A
        std::int16_t  disp_info;                       // 0x0C
        std::int16_t  surface_fog_volume_id;           // 0x0E
        type_styles   styles;                          // 0x10
        std::int32_t  light_offset;                    // 0x18
        float         area;                            // 0x1C
        type_luxels   lightmap_texture_mins_in_luxels; // 0x20
        type_luxels   lightmap_texture_size_in_luxels; // 0x28
        std::int32_t  orig_face;                       // 0x30
        std::uint16_t num_prims;                       // 0x34
        std::uint16_t first_prim_id;                   // 0x36
        std::uint16_t smoothing_groups;                // 0x38
    };//Size=0x3A

    class dbrush_t
    {
    public:
        std::int32_t first_side; // 0x0
        std::int32_t num_sides;  // 0x4
        std::int32_t contents;   // 0x8
    };//Size=0xC

    class dbrushside_t
    {
    public:
        std::uint16_t plane_num; // 0x0
        std::int16_t  tex_info;  // 0x2
        std::int16_t  disp_info; // 0x4
        std::uint8_t  bevel;     // 0x6
        std::uint8_t  thin;      // 0x7
    };//Size=0x8

    class texinfo_t
    {
        using type_vecs = std::array<vector4, 2>;

    public:
        type_vecs    texture_vecs;  // 0x00
        type_vecs    lightmap_vecs; // 0x20
        std::int32_t flags;         // 0x40
        std::int32_t tex_data;      // 0x44
    };//Size=0x48

    class VPlane
    {
    public:
        VPlane() = default;

        VPlane(
            const vector3& origin,
            const float distance
            )
            : origin(origin)
            , distance(distance)
        { }

        VPlane(
            const VPlane& rhs
            ) = default;

        VPlane(
            VPlane&& rhs
            ) noexcept
        {
            *this = std::move(rhs);
        }

        VPlane& operator = (
            const VPlane& rhs
            ) = default;

        VPlane& operator = (
            VPlane&& rhs
            ) noexcept
        {
            origin = std::move(rhs.origin);
            distance = rhs.distance;

            rhs.distance = 0.f;

            return *this;
        }

        _NODISCARD
            float dist(
                const vector3& destination
                ) const
        {
            return origin.dot(destination) - distance;
        }

        void init(
            const vector3& origin,
            const float distance
            )
        {
            this->origin = origin;
            this->distance = distance;
        }

    public:
        vector3 origin = 0.f;
        float   distance = 0.f;
    };

    class polygon
    {
        using type_surfinfo_vecs = std::array<vector3, MAX_SURFINFO_VERTS>;
        using type_edge_planes = std::array<VPlane, MAX_SURFINFO_VERTS>;

    public:
        type_surfinfo_vecs verts;
        std::size_t        num_verts = 0;
        VPlane             plane;
        type_edge_planes   edge_planes;
        type_surfinfo_vecs vec2d;
        std::int32_t       skip = 0;
    };

    struct trace_t
    {
        /// <summary>
        /// Determine if a plan is NOT valid
        /// </summary>
        bool         all_solid = true;
        /// <summary>
        /// Determine if the start point was in a solid area
        /// </summary>
        bool         start_solid = true;
        /// <summary>
        /// Time completed, 1.0              = didn't hit anything
        /// </summary>
        float        fraction = 1.f;
        float        fraction_left_solid = 1.f;
        /// <summary>
        /// Final trace position
        /// </summary>
        vector3      end_pos;
        std::int32_t contents = 0;
        dbrush_t* brush = nullptr;
        std::int32_t num_brush_sides = 0;

        void clear()
        {
            all_solid = true;
            start_solid = true;
            fraction = 1.f;
            fraction_left_solid = 1.f;
            contents = 0;
            brush = nullptr;
            num_brush_sides = 0;
            end_pos.clear();
        }
    };
}

```

`Le_Chiffre/client.hpp`:

```hpp
#ifndef CLIENT_HPP
#define CLIENT_HPP
#pragma once

#include "memory.hpp"
#include "signatures.hpp"
#include "player_entity.hpp"
#include "misc/config.hpp"

using namespace hazedumper;

class Client {
private:
	Memory* memory;
	DWORD _survivalDecisionTypes;
	float def_sensinivity; // used for aimbot
	std::array<char, 0x120> map_dir;
	std::array<char, 0x120> game_dir;

	DWORD _getClientState() {
		return memory->read_mem<DWORD>(memory->engineBaseAddr + signatures::dwClientState);
	}
public:
	Client(Memory* memory) {
		this->memory = memory;
		_survivalDecisionTypes = 0;
		this->def_sensinivity = get_sensitivity();
	}

	// Client states: LOBBY = 1, LOADING = 2, CONNECTING = 3, CONNECTED = 5, INGAME = 6
	bool in_game() {
		if (memory->tProcess != NULL && memory->clientBaseAddr != NULL && memory->engineBaseAddr != NULL) {
			return memory->read_mem<DWORD>(_getClientState() + signatures::dwClientState_State) == 6;
		}

		return false;
	}

	bool is_dangerzone() {
		return _survivalDecisionTypes != 0;
	}

	void update_gamemode() {
		DWORD gameRulesProxy = memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwGameRulesProxy);
		_survivalDecisionTypes = memory->read_mem<DWORD>(gameRulesProxy + netvars::m_SurvivalGameRuleDecisionTypes);
	}

	PlayerEntity get_local_player() {
		DWORD player_id = memory->read_mem<DWORD>(_getClientState() + signatures::dwClientState_GetLocalPlayer);
		return PlayerEntity(memory, memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwEntityList + player_id * 0x10));
	}

	void set_sensitivity(float val) {
		uint32_t sens_pt = memory->read_mem<uint32_t>(memory->clientBaseAddr + signatures::dwSensitivityPtr);
		uint32_t sest_fn = *reinterpret_cast<uint32_t*>(&val) ^ sens_pt;

		memory->write_mem<uint32_t>(memory->clientBaseAddr + signatures::dwSensitivity, sest_fn);
	}

	float get_sensitivity() {
		uint32_t sens_pt = memory->read_mem<uint32_t>(memory->clientBaseAddr + signatures::dwSensitivityPtr);
		uint32_t sens_fn = memory->read_mem<uint32_t>(memory->clientBaseAddr + signatures::dwSensitivity);

		sens_fn ^= sens_pt;

		return *reinterpret_cast<float*>(&sens_fn);
	}

	void reset_sensitivity() {
		if (memory->tProcess != NULL && memory->clientBaseAddr != NULL && memory->engineBaseAddr != NULL) {
			set_sensitivity(this->def_sensinivity);
		}
	}

	const char* get_map_dir() {
		map_dir = memory->read_mem<std::array<char, 0x120>>(_getClientState() + signatures::dwClientState_MapDirectory);
		return map_dir.data();
	}

	const char* get_game_dir() {
		game_dir = memory->read_mem<std::array<char, 0x120>>(memory->engineBaseAddr + signatures::dwGameDir);
		return game_dir.data();
	}
};

#endif
```

`Le_Chiffre/hacks.hpp`:

```hpp
#ifndef HACKS_HPP
#define HACKS_HPP
#pragma once

#include "client.hpp"
#include "memory.hpp"
#include "player_entity.hpp"
#include "bsp_parser/valve-bsp-parser/bsp_parser.hpp"
#include "bsp_parser/valve-bsp-parser/core/matrix.hpp"
#include "misc/config.hpp"
#include "misc/console_io.hpp"

using namespace hazedumper;
using namespace rn;

struct GlowStruct {
	BYTE base[8];
	float red;
	float green;
	float blue;
	float alpha;
	BYTE buffer[16];
	bool redner_occluded;
	bool render_unoccluded;
	bool fullBloom;
	BYTE buffer1[5];
	int glow_style;
};

class Hacks {
private:
	Memory* memory;
	Client* client;
	PlayerEntity player;
	bsp_parser bp;

	// true if aiming on enemy, false otherwise
	bool _aim_on_enemy(PlayerEntity* player, bool dangerzone = false) {
		if (!player->valid_player()) return false;

		DWORD crosshair = player->get_crosshair_id();
		if (crosshair == 0 || crosshair > 33) return false;

		PlayerEntity enemy(memory, memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwEntityList + (crosshair - 1) * 0x10));
		if (!enemy.valid_player()) return false;

		// check if crosshair if pointed on enemy player
		return dangerzone || player->get_team() != enemy.get_team();
	}

	void _enemy_glow(PlayerEntity* target, DWORD glow_obj, float div = 0.f) {
		GlowStruct gt = memory->read_mem<GlowStruct>(glow_obj + (target->get_glow_index() * 0x38));
		gt.red = 1.0f - div / 2.f;
		gt.green = div;
		gt.blue = 0.f;
		gt.alpha = 0.9f;
		gt.redner_occluded = true;
		gt.render_unoccluded = false;
		memory->write_mem<GlowStruct>(glow_obj + (target->get_glow_index() * 0x38), gt);
	}

	/* void _carrier_glow(PlayerEntity* target, DWORD glow_obj) {
		GlowStruct gt = memory->read_mem<GlowStruct>(glow_obj + (target->get_glow_index() * 0x38));
		gt.red = .4f;
		gt.green = .5f;
		gt.blue = 0;
		gt.alpha = 0.9f;
		gt.redner_occluded = true;
		gt.render_unoccluded = false;
		memory->write_mem<GlowStruct>(glow_obj + (target->get_glow_index() * 0x38), gt);
	} */

	// returns an entity which is visible and closest to local player on XYZ axis coordinates
	// if no players are located near local player, it will return an invalid PlayerEntity object
	PlayerEntity _get_closest_enemy(int bone_id = 8) {
		float closest_distance = 10000000; // initial closest distance between local player and an enemy
		PlayerEntity closest_enemy;
		int player_team = player.get_team();
		vector3 player_coords = player.get_bone_position_v3(8);

		for (short i = 0; i < 32; ++i) {
			PlayerEntity target(memory, memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwEntityList + (short)0x10 * i));

			if (target.valid_player() && target.get_team() != player_team) {
				vector3 target_head = target.get_bone_position_v3(bone_id);

				if (is_visible(player_coords, target_head)) {
					float distance = player.get_distance(target.get_origin());
					if (distance < closest_distance) {
						closest_distance = distance;
						closest_enemy = target;
					}
				}
			}
		}

		return closest_enemy;
	}

	bool is_visible(vector3& origin, vector3& destinaiton) {
		return bsp_setted && bp.is_visible(origin, destinaiton);
	}

public:
	bool bsp_setted;

	void init() {
		player = client->get_local_player();
		if (bp.load_map(client->get_game_dir(), client->get_map_dir())) bsp_setted = true;
	}

	void trigger_bot(bool dangerzone = false) {
		if (_aim_on_enemy(&player, dangerzone)) {
			// player.set_attack_state(6); // doesn't properly work on pistols

			player.set_attack_state(5);
			Sleep((rand() % 11) + 10); // 10-20 ms
			player.set_attack_state(4);
		}
	}

	void no_flash() {
		if (player.valid_player() && player.get_flash_duration() > 0.f) player.set_flash_duration(0.f);
	}

	void glow_esp_radar(bool glow_on_enemy, bool radar_hack, bool dangerzone = false) {
		DWORD glow_obj;
		int player_team = player.get_team();

		if (glow_on_enemy) glow_obj = memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwGlowObjectManager);

		for (short i = 0; i < 32; ++i) {
			PlayerEntity target(memory, memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwEntityList + (short)0x10 * i));

			if (target.valid_player()) {
				if (dangerzone && glow_on_enemy) { // TODO: Add team glow for teammates dangerzone mode
					_enemy_glow(&target, glow_obj);
					continue;
				}

				int target_team = target.get_team();

				if (player_team != target_team && glow_on_enemy) {
					float div = target.get_health() / 100.f;
					_enemy_glow(&target, glow_obj, div);
				}

				if (player_team != target_team && radar_hack && !target.is_spotted()) target.set_spotted(true);
			}
		}

		Sleep(5);
	}

	/* void get_spectators() {
		int player_team = player.get_team();

		for (short i = 0; i < 32; ++i) {
			PlayerEntity target(memory, memory->read_mem<DWORD>(memory->clientBaseAddr + signatures::dwEntityList + (short)0x10 * i));

			if (target.valid_player()) {
				int target_team = target.get_team();
				if (player_team != target_team) continue;

			}
		}
	} */

	void aim_bot() {
		if (GetAsyncKeyState(VK_LBUTTON)) {
			PlayerEntity target = _get_closest_enemy();

 			// In fact, the entire aiming and shooting process will be completed within 2 ticks (for a 64tick server), which has almost no effect on the rate of fire
			// The side effect is that the thrown object will be thrown immediately, even directly facing the visible enemy. 
			if (target.valid_player()) {
				player.set_attack_state(4);
				client->set_sensitivity(0.f);
				player.aim_at(target.get_bone_position(8));
				Sleep(5);
				player.set_attack_state(5);
				Sleep((rand() % 11) + 10); // 10-20 ms
				player.set_attack_state(4);
				client->reset_sensitivity();
			} else {
				client->reset_sensitivity();
			}	
		} else {
			client->reset_sensitivity();
		}
	}

	void bunny_hop() {
		if (player.get_flags() & 1 << 0 && player.is_moving()) player.set_jump_state(6);
	}

	void preexit() {
		client->reset_sensitivity();
	}

	void panic_mode() { // closes cheat when triggered
		if (GetKeyState(VK_END) & 0x0001) {
			preexit();
			ExitProcess(EXIT_SUCCESS);
		};
	}

	// Thread methods:
	void thread_trigger_bot(hacks_state* state, hacks_coords* coords, ConsoleIO* io, Internalisation* i) { // Trigger bot - LAlt, F6
		while (true) {
			if (state->game) {
				bool f6 = GetKeyState(VK_F6) & 0x0001;
				bool lalt = GetAsyncKeyState(VK_LMENU);
				bool l_mouse = GetAsyncKeyState(VK_LBUTTON);

				if (f6 != state->activate_trigger) {
					state->activate_trigger = f6;
					io->set_cursor_position(coords->activate_trigger);
					io->write_str(state->activate_trigger ? i->translate(XorStr("on")) : i->translate(XorStr("off")), state->activate_trigger ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (state->activate_trigger && lalt && !l_mouse) trigger_bot(client->is_dangerzone());
			}
			else Sleep(1000);

			Sleep(2);
		}
	}

	void thread_aimbot(hacks_state* state, hacks_coords* coords, ConsoleIO* io, Internalisation* i) { // Aimbot - F4
		while (true) {
			if (state->game) {
				bool f4 = GetKeyState(VK_F4) & 0x0001;

				if (f4 != state->aimbot) {
					state->aimbot = f4;
					io->set_cursor_position(coords->aimbot);
					io->write_str(state->aimbot ? i->translate(XorStr("on")) : i->translate(XorStr("off")), state->aimbot ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (state->aimbot) aim_bot();
				else client->reset_sensitivity();
			}
			else Sleep(1000);

			Sleep(2);
		}
	}

	void thread_glow_radar(hacks_state* state, hacks_coords* coords, ConsoleIO* io, Internalisation* i) { // Glow ESP - F8; Radar hack - F9
		while (true) {
			if (state->game) {
				bool f8 = GetKeyState(VK_F8) & 0x0001; // Enemy glow ESP
				bool f9 = GetKeyState(VK_F9) & 0x0001; // Radar hack

				if (f8 != state->enemy_wh) {
					state->enemy_wh = f8;
					io->set_cursor_position(coords->enemy_wh);
					io->write_str(state->enemy_wh ? i->translate(XorStr("on")) : i->translate(XorStr("off")), state->enemy_wh ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (f9 != state->radar_hack) {
					state->radar_hack = f9;
					io->set_cursor_position(coords->radar_hack);
					io->write_str(state->radar_hack ? i->translate(XorStr("on")) : i->translate(XorStr("off")), state->radar_hack ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (state->enemy_wh || state->radar_hack)
					glow_esp_radar(state->enemy_wh, state->radar_hack, client->is_dangerzone());
			}
			else Sleep(1000);

			Sleep(1);
		}
	}

	void thread_no_flash(hacks_state* state, hacks_coords* coords, ConsoleIO* io, Internalisation* i) { // No flash - F3
		while (true) {
			if (state->game) {
				bool f3 = GetKeyState(VK_F3) & 0x0001;

				if (f3 != state->no_flash) {
					state->no_flash = f3;
					io->set_cursor_position(coords->no_flash);
					io->write_str(state->no_flash ? i->translate(XorStr("on")) : i->translate(XorStr("off")), state->no_flash ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (state->no_flash) no_flash();
			}
			else Sleep(1000);

			Sleep(2);
		}
	}

	void thread_bunny_hop(hacks_state* state, hacks_coords* coords, ConsoleIO* io, Internalisation* i) { // Bunny hop - F2
		while (true) {
			if (state->game) {
				bool f2 = GetKeyState(VK_F2) & 0x0001;
				bool space = GetAsyncKeyState(VK_SPACE);

				if (f2 != state->bunny_hop) {
					state->bunny_hop = f2;
					io->set_cursor_position(coords->bunny_hop);
					io->write_str(f2 ? i->translate(XorStr("on")) : i->translate(XorStr("off")), f2 ? FOREGROUND_GREEN : FOREGROUND_RED);
				}

				if (state->bunny_hop && space) bunny_hop();
			}
			else Sleep(1000);

			Sleep(2);
		}
	}

	void thread_panic_mode() {
		while (true) {
			panic_mode();
			Sleep(1);
		}
	}

	Hacks(Memory* memory, Client* client) {
		this->memory = memory;
		this->client = client;
		bsp_setted = false;
		init();
	}
};
#endif

```

`Le_Chiffre/i18n/en.hpp`:

```hpp
#ifndef INTERNALISATION_EN_HPP
#define INTERNALISATION_EN_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> en {
		{XorStr("on"), XorStrW(L"ON")},
		{XorStr("off"), XorStrW(L"OFF")},
		{XorStr("yes"), XorStrW(L"YES")},
		{XorStr("no"), XorStrW(L"NO")},
		{XorStr("loading"), XorStrW(L"LOADING")},
		{XorStr("outdated"), XorStrW(L"OUTDATED")},
		{XorStr("latest"), XorStrW(L"LATEST")},
		{XorStr("error"), XorStrW(L"ERROR")},
		{XorStr("hold"), XorStrW(L"HOLD")},
		{XorStr("press"), XorStrW(L"PRESS")},
		{XorStr("waiting"), XorStrW(L"WAITING")},
		{XorStr("connecting"), XorStrW(L"CONNECTING")},
		{XorStr("website"), XorStrW(L"The official website: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"State")},
		{XorStr("language"), XorStrW(L"Language (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Connected to CS:GO process")},
		{XorStr("connected_game"), XorStrW(L"Connected to active game")},
		{XorStr("version"), XorStrW(L"Version")},
		{XorStr("cheat_functions"), XorStrW(L"Cheat functions")},
		{XorStr("bunny_hop"), XorStrW(L"Bunny hop (F2)")},
		{XorStr("no_flash"), XorStrW(L"No flashbang (F3)")},
		{XorStr("aimbot"), XorStrW(L"Aimbot (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Activate trigger bot (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Use trigger bot (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"Glow ESP (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Radar hack (F9)")},
		{XorStr("exit"), XorStrW(L"Immediate exit (END)")}
	};
}
#endif // INTERNALISATION_EN_HPP
```

`Le_Chiffre/i18n/fr.hpp`:

```hpp
#ifndef INTERNALISATION_FR_HPP
#define INTERNALISATION_FR_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> fr{
		{XorStr("on"), XorStrW(L"ACTIF")},
		{XorStr("off"), XorStrW(L"INACTIF")},
		{XorStr("yes"), XorStrW(L"OUI")},
		{XorStr("no"), XorStrW(L"NON")},
		{XorStr("loading"), XorStrW(L"CHARGEMENT")},
		{XorStr("outdated"), XorStrW(L"DÉPASSÉ")},
		{XorStr("latest"), XorStrW(L"DERNIERE")},
		{XorStr("error"), XorStrW(L"ERREUR")},
		{XorStr("hold"), XorStrW(L"MAINTENIR")},
		{XorStr("press"), XorStrW(L"PRESSER")},
		{XorStr("waiting"), XorStrW(L"EN ATTENTE")},
		{XorStr("connecting"), XorStrW(L"EN COURS DE CONNEXION")},
		{XorStr("website"), XorStrW(L"Le site web officiel: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"État")},
		{XorStr("language"), XorStrW(L"Langue (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Connecté au processus CS:GO")},
		{XorStr("connected_game"), XorStrW(L"Connecté a la partie active")},
		{XorStr("version"), XorStrW(L"Version")},
		{XorStr("cheat_functions"), XorStrW(L"Fonctionalité du logiciel de triche")},
		{XorStr("bunny_hop"), XorStrW(L"Bunny hop (F2)")},
		{XorStr("no_flash"), XorStrW(L"Pas d'effet de flash (F3)")},
		{XorStr("aimbot"), XorStrW(L"Aimbot (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Activer auto-tir (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Déclencher auto-tir (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"Afficher (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Afficher Ennemi sur la Carte (F9)")},
		{XorStr("exit"), XorStrW(L"Quitter (END)")}
	};
}
#endif // INTERNALISATION_FR_HPP
```

`Le_Chiffre/i18n/hu.hpp`:

```hpp
#ifndef INTERNALISATION_HU_HPP
#define INTERNALISATION_HU_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> hu{
		{XorStr("on"), XorStrW(L"ON")},
		{XorStr("off"), XorStrW(L"OFF")},
		{XorStr("yes"), XorStrW(L"IGEN")},
		{XorStr("no"), XorStrW(L"NEM")},
		{XorStr("loading"), XorStrW(L"BETÖLTÉS")},
		{XorStr("outdated"), XorStrW(L"ELAVULT")},
		{XorStr("latest"), XorStrW(L"LEGÚJABB")},
		{XorStr("error"), XorStrW(L"ERROR")},
		{XorStr("hold"), XorStrW(L"TARTSD")},
		{XorStr("press"), XorStrW(L"NYOMD")},
		{XorStr("waiting"), XorStrW(L"VÁRAKOZÁS")},
		{XorStr("connecting"), XorStrW(L"CSATLAKOZÁS")},
		{XorStr("website"), XorStrW(L"A hivatalos honlap: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"Állapot")},
		{XorStr("language"), XorStrW(L"Nyelv (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Csatlakozva a CS:GO folyamathoz")},
		{XorStr("connected_game"), XorStrW(L"Csatlakozva aktív játékhoz")},
		{XorStr("version"), XorStrW(L"Verzió")},
		{XorStr("cheat_functions"), XorStrW(L"Cheat funkciók")},
		{XorStr("bunny_hop"), XorStrW(L"Nyuszi hopp (F2)")},
		{XorStr("no_flash"), XorStrW(L"Nem vakulsz (F3)")},
		{XorStr("aimbot"), XorStrW(L"Aimbot (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Trigger bot aktiválása (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Trigger bot használata (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"Fénylő ESP (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Radar hack (F9)")},
		{XorStr("exit"), XorStrW(L"Azonnali bezárás (END)")}
	};
}
#endif // INTERNALISATION_HU_HPP
```

`Le_Chiffre/i18n/i18n.hpp`:

```hpp
#ifndef INTERNALISATION_HPP
#define INTERNALISATION_HPP
#pragma once
#include <Windows.h>
#include <string>
#include <map>
#include <vector>

#include "en.hpp"
#include "uk.hpp"
#include "ru.hpp"
#include "tr.hpp"
#include "pl.hpp"
#include "zh.hpp"
#include "fr.hpp"
#include "hu.hpp"

namespace i18n {
	using std::string;
	using std::wstring;
	using std::vector;
	using std::map;

	std::string get_user_localisation() {
		wchar_t lpLocaleName[LOCALE_NAME_MAX_LENGTH] = { 0 };

		if (GetUserDefaultLocaleName(lpLocaleName, LOCALE_NAME_MAX_LENGTH) != 0) {
			std::wstring lang = std::wstring(lpLocaleName).substr(0, 2);

			if (lang == L"uk") return XorStr("UK");
			if (lang == L"ru") return XorStr("RU");
			if (lang == L"tr") return XorStr("TR");
			if (lang == L"pl") return XorStr("PL");
			if (lang == L"zh") return XorStr("ZH");
			if (lang == L"fr") return XorStr("FR");
			if (lang == L"hu") return XorStr("HU");
		}


		return XorStr("EN");
	}

	map<std::string, map<string, wstring>> t{
		{ XorStr("EN"), en },
		{ XorStr("UK"), uk },
		{ XorStr("RU"), ru },
		{ XorStr("TR"), tr },
		{ XorStr("PL"), pl },
		{ XorStr("ZH"), zh },
		{ XorStr("FR"), fr },
		{ XorStr("HU"), hu },
	};

	class Internalisation {
	private:
		vector<string> available;
		vector<string>::iterator lang_it;

		// Returns available translation codes
		vector<string> get_keys() {
			vector<string> keys;

			for (auto const& it : t) {
				keys.push_back(it.first);
			}

			return keys;
		}

	public:
		Internalisation() {
			available = get_keys();
			lang_it = available.begin();
		}

		string get_lang() {
			return *lang_it;
		}

		// If a valid language code is provided, it switches current language into it,
		// otherwise it switches the current language to the next language available
		void switch_language(string code = "") {
			if (!code.empty()) {
				for (auto it = available.begin(); it != available.end(); ++it) {
					if (*it == code) {
						lang_it = it;
						return;
					}
				}
			}

			if (lang_it == available.end() - 1) lang_it = available.begin();
			else ++lang_it;
		}

		// Returns the corresponding translation of 'key'
		std::wstring translate(string key) {
			return t[*lang_it][key];
		}
	};

} // namespace i18n
#endif // INTERNALISATION_HPP
```

`Le_Chiffre/i18n/pl.hpp`:

```hpp
#ifndef INTERNALISATION_PL_HPP
#define INTERNALISATION_PL_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> pl{
		{XorStr("on"), XorStrW(L"WŁĄCZONA")},
		{XorStr("off"), XorStrW(L"WYŁĄCZONA")},
		{XorStr("yes"), XorStrW(L"TAK")},
		{XorStr("no"), XorStrW(L"NIE")},
		{XorStr("loading"), XorStrW(L"ZAŁADUNEK")},
		{XorStr("outdated"), XorStrW(L"PRZESTARZAŁA")},
		{XorStr("latest"), XorStrW(L"NAJNOWSZA")},
		{XorStr("error"), XorStrW(L"BŁĄD")},
		{XorStr("hold"), XorStrW(L"TRZYMAĆ")},
		{XorStr("press"), XorStrW(L"NACIŚNIJ")},
		{XorStr("waiting"), XorStrW(L"CZEKANIE")},
		{XorStr("connecting"), XorStrW(L"POŁĄCZENIE")},
		{XorStr("website"), XorStrW(L"Oficjalna strona internetowa: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"Stan")},
		{XorStr("language"), XorStrW(L"Język (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Połączony z procesem CS:GO")},
		{XorStr("connected_game"), XorStrW(L"Podłączony do aktywnej gry")},
		{XorStr("version"), XorStrW(L"Wersja")},
		{XorStr("cheat_functions"), XorStrW(L"Funkcje")},
		{XorStr("bunny_hop"), XorStrW(L"Króliczy skok (F2)")},
		{XorStr("no_flash"), XorStrW(L"Nie oszałamia granat (F3)")},
		{XorStr("aimbot"), XorStrW(L"Aimbot (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Aktywacja trigger bota (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Użyj trigger bota (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"Glow ESP (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Radar hack (F9)")},
		{XorStr("exit"), XorStrW(L"Natychmiastowe wyjście (END)")}
	};
}
#endif // INTERNALISATION_PL_HPP
```

`Le_Chiffre/i18n/ru.hpp`:

```hpp
#ifndef INTERNALISATION_RU_HPP
#define INTERNALISATION_RU_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> ru {
		{XorStr("on"), XorStrW(L"ВКЛ")},
		{XorStr("off"), XorStrW(L"ВЫКЛ")},
		{XorStr("yes"), XorStrW(L"ДА")},
		{XorStr("no"), XorStrW(L"НЕТ")},
		{XorStr("loading"), XorStrW(L"ЗАГРУЗКА")},
		{XorStr("outdated"), XorStrW(L"УСТАРЕВШАЯ")},
		{XorStr("latest"), XorStrW(L"ПОСЛЕДНЯЯ")},
		{XorStr("error"), XorStrW(L"ОШИБКА")},
		{XorStr("hold"), XorStrW(L"УДЕРЖИВАТЬ")},
		{XorStr("press"), XorStrW(L"НАЖАТЬ")},
		{XorStr("waiting"), XorStrW(L"ОЖИДАНИЕ")},
		{XorStr("connecting"), XorStrW(L"ПОДКЛЮЧЕНИЕ")},
		{XorStr("website"), XorStrW(L"Официальный вебсайт: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"Состояние")},
		{XorStr("language"), XorStrW(L"Язык (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Подключено к CS:GO")},
		{XorStr("connected_game"), XorStrW(L"Подключено к матчу")},
		{XorStr("version"), XorStrW(L"Версия")},
		{XorStr("cheat_functions"), XorStrW(L"Функции чита")},
		{XorStr("bunny_hop"), XorStrW(L"Банни-хоп (F2)")},
		{XorStr("no_flash"), XorStrW(L"Анти-светошумовые гранаты (F3)")},
		{XorStr("aimbot"), XorStrW(L"Аимбот (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Активировать триггер бот (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Использовать триггер бот (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"ВХ (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Радар хак (F9)")},
		{XorStr("exit"), XorStrW(L"Экстренный выход (END)")}
	};
}
#endif // INTERNALISATION_RU_HPP
```

`Le_Chiffre/i18n/tr.hpp`:

```hpp
#ifndef INTERNALISATION_TR_HPP
#define INTERNALISATION_TR_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> tr{
		{XorStr("on"), XorStrW(L"AÇIK")},
		{XorStr("off"), XorStrW(L"KAPALI")},
		{XorStr("yes"), XorStrW(L"EVET")},
		{XorStr("no"), XorStrW(L"HAYIR")},
		{XorStr("loading"), XorStrW(L"YÜKLENİYOR")},
		{XorStr("outdated"), XorStrW(L"GÜNCEL DEĞİL")},
		{XorStr("latest"), XorStrW(L"SON")},
		{XorStr("error"), XorStrW(L"HATA")},
		{XorStr("hold"), XorStrW(L"BASILI TUT")},
		{XorStr("press"), XorStrW(L"BAS")},
		{XorStr("waiting"), XorStrW(L"BEKLENİYOR")},
		{XorStr("connecting"), XorStrW(L"BAĞLANILIYOR")},
		{XorStr("website"), XorStrW(L"Resmi site: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"Durum")},
		{XorStr("language"), XorStrW(L"Dil (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"CS:GO işlemine bağlı")},
		{XorStr("connected_game"), XorStrW(L"Aktif oyuna bağlandı")},
		{XorStr("version"), XorStrW(L"Sürüm")},
		{XorStr("cheat_functions"), XorStrW(L"Hile fonksiyonları")},
		{XorStr("bunny_hop"), XorStrW(L"Bunny hop (F2)")},
		{XorStr("no_flash"), XorStrW(L"Flashlardan kör olmama (F3)")},
		{XorStr("aimbot"), XorStrW(L"Aimbot (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Trigger bot'u aktifleştir (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Trigger bot'u kullan (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"Wallhack (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Radar hilesi (F9)")},
		{XorStr("exit"), XorStrW(L"Anında çıkış (END)")}
	};
}
#endif // INTERNALISATION_TR_HPP
```

`Le_Chiffre/i18n/uk.hpp`:

```hpp
#ifndef INTERNALISATION_UK_HPP
#define INTERNALISATION_UK_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> uk {
		{XorStr("on"), XorStrW(L"УВІМК")},
		{XorStr("off"), XorStrW(L"ВИМК")},
		{XorStr("yes"), XorStrW(L"ТАК")},
		{XorStr("no"), XorStrW(L"НІ")},
		{XorStr("loading"), XorStrW(L"ЗАВАНТАЖЕННЯ")},
		{XorStr("outdated"), XorStrW(L"УСТАРІВША")},
		{XorStr("latest"), XorStrW(L"ОСТАННЯ")},
		{XorStr("error"), XorStrW(L"ПОМИЛКА")},
		{XorStr("hold"), XorStrW(L"УТРИМУВАТИ")},
		{XorStr("press"), XorStrW(L"НАТИСНУТИ")},
		{XorStr("waiting"), XorStrW(L"ОЧІКУВАННЯ")},
		{XorStr("connecting"), XorStrW(L"ПІДКЛЮЧЕННЯ")},
		{XorStr("website"), XorStrW(L"Офіційний вебсайт: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"Стан")},
		{XorStr("language"), XorStrW(L"Мова (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"Підключено до CS:GO")},
		{XorStr("connected_game"), XorStrW(L"Підключено до матчу")},
		{XorStr("version"), XorStrW(L"Версія")},
		{XorStr("cheat_functions"), XorStrW(L"Функції чіту")},
		{XorStr("bunny_hop"), XorStrW(L"Банні-хоп (F2)")},
		{XorStr("no_flash"), XorStrW(L"Анти-світлошумові гранати (F3)")},
		{XorStr("aimbot"), XorStrW(L"Аімбот (F4)")},
		{XorStr("triggerbot"), XorStrW(L"Активувати тригер бот (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"Використовувати тригер бот (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"ВХ (F8)")},
		{XorStr("radar_hack"), XorStrW(L"Радар хак (F9)")},
		{XorStr("exit"), XorStrW(L"Екстренний вихід (END)")}
	};
}
#endif // INTERNALISATION_UK_HPP
```

`Le_Chiffre/i18n/zh.hpp`:

```hpp
#ifndef INTERNALISATION_ZH_HPP
#define INTERNALISATION_ZH_HPP
#pragma once
#include <map>
#include <string>

#include "../misc/xor.hpp"

namespace i18n {
	std::map<std::string, std::wstring> zh{
		{XorStr("on"), XorStrW(L"开")},
		{XorStr("off"), XorStrW(L"关")},
		{XorStr("yes"), XorStrW(L"是")},
		{XorStr("no"), XorStrW(L"否")},
		{XorStr("loading"), XorStrW(L"载入中")},
		{XorStr("outdated"), XorStrW(L"需更新")},
		{XorStr("latest"), XorStrW(L"最新的")},
		{XorStr("error"), XorStrW(L"错误")},
		{XorStr("hold"), XorStrW(L"按住")},
		{XorStr("press"), XorStrW(L"按下")},
		{XorStr("waiting"), XorStrW(L"等待")},
		{XorStr("connecting"), XorStrW(L"等待连接")},
		{XorStr("website"), XorStrW(L"官方网站: https://lechiffre.vercel.app")},
		{XorStr("state"), XorStrW(L"状态")},
		{XorStr("language"), XorStrW(L"语言 (F1)")},
		{XorStr("connected_csgo"), XorStrW(L"连接到CS:GO进程")},
		{XorStr("connected_game"), XorStrW(L"已连接CS:GO游戏")},
		{XorStr("version"), XorStrW(L"版本")},
		{XorStr("cheat_functions"), XorStrW(L"功能")},
		{XorStr("bunny_hop"), XorStrW(L"连跳 (F2)")},
		{XorStr("no_flash"), XorStrW(L"无视闪光 (F3)")},
		{XorStr("aimbot"), XorStrW(L"自瞄 (F4)")},
		{XorStr("triggerbot"), XorStrW(L"自动开枪 (F6)")},
		{XorStr("use_triggerbot"), XorStrW(L"使用自动扳机 (LAlt)")},
		{XorStr("glowesp"), XorStrW(L"发光透视 (F8)")},
		{XorStr("radar_hack"), XorStrW(L"雷达透视 (F9)")},
		{XorStr("exit"), XorStrW(L"退出 (END)")}
	};
}
#endif // INTERNALISATION_ZH_HPP

```

`Le_Chiffre/memory.hpp`:

```hpp
#ifndef MEMORY_HPP
#define MEMORY_HPP

#pragma once
#pragma warning(disable: 6276)

#include <Windows.h>
#include <TlHelp32.h>
#include "misc/config.hpp"

struct MODULE {
	/*BYTE* */DWORD base;
	DWORD size;
};

class Memory {
public:
	DWORD tPID;
	DWORD clientBaseAddr;
	DWORD clientSize;
	DWORD engineBaseAddr;
	DWORD engineSize;
	HANDLE tProcess;
	HWND tHWND;

	Memory() {
		this->tPID = NULL;
		this->tProcess = NULL;

		if (!this->handle_process(TARGET)) return;

		this->tHWND = FindWindowA(0, WINDOW_NAME);
		MODULE client_dll = get_module(CLIENT_DLL);
		MODULE engine_dll = get_module(ENGINE_DLL);

		this->clientBaseAddr = client_dll.base;
		this->engineBaseAddr = engine_dll.base;
		this->clientSize = client_dll.size;
		this->engineSize = engine_dll.size;
	}

	~Memory() {
		CloseHandle(tProcess);
	}

	HANDLE handle_process(const wchar_t* processName) {
		HANDLE handle = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
		PROCESSENTRY32 entry;
		entry.dwSize = sizeof(entry);

		do {
			if (!wcscmp(entry.szExeFile, processName)) {
				tPID = entry.th32ProcessID;
				CloseHandle(handle);
				tProcess = OpenProcess(PROCESS_ALL_ACCESS, false, tPID);
				return tProcess;
			}
		} while (Process32Next(handle, &entry));
		CloseHandle(handle);
		return NULL;
	}

	MODULE get_module(const wchar_t* moduleName) {
		HANDLE hmodule = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, tPID);
		MODULEENTRY32 me32;
		me32.dwSize = sizeof(me32);

		do {
			if (!wcscmp(me32.szModule, moduleName)) {
				CloseHandle(hmodule);
				return { (DWORD)me32.modBaseAddr, me32.modBaseSize };
			}
		} while (Module32Next(hmodule, &me32));

		CloseHandle(hmodule);
		return { NULL, NULL };
	}

	template <typename var>
	bool write_mem(DWORD address, var value) {
		return WriteProcessMemory(tProcess, (LPVOID)address, &value, sizeof(var), NULL);
	}

	template <typename var>
	var read_mem(DWORD address) {
		var value;
		ReadProcessMemory(tProcess, (LPCVOID)address, &value, sizeof(var), NULL);
		return value;
	}
};
#endif
```

`Le_Chiffre/misc/config.hpp`:

```hpp
#ifndef CONFIG_HPP
#define CONFIG_HPP
#pragma once
#include <string>
#include "xor.hpp"

namespace {
	// Config
	const ::std::string CHEAT_VERSION = XorStr("v1.4.18");
	const ::std::string RELEASE_DATE = XorStr("[10 March, 2022]");
	const wchar_t* HOST = L"api.github.com";
	const wchar_t* PATH = L"/repos/blaumaus/le_chiffre/tags?per_page=1";
	const wchar_t* TARGET = L"csgo.exe";
	const wchar_t* CLIENT_DLL = L"client.dll";
	const wchar_t* ENGINE_DLL = L"engine.dll";
	LPCSTR WINDOW_NAME = "Counter-Strike: Global Offensive";

	// Common
	struct coords_vector {
		float x, y, z;
	};

	struct hacks_coords {
		COORD no_flash, activate_trigger, use_trigger, enemy_wh, radar_hack, bunny_hop, aimbot, process, game, version, language;
	};

	struct hacks_state {
		bool no_flash = false;
		bool activate_trigger = false;
		bool use_trigger = false;
		bool enemy_wh = false;
		bool radar_hack = false;
		bool bunny_hop = false;
		bool aimbot = false;
		bool process = false; 
		bool game = false;
	};
}
#endif
```

`Le_Chiffre/misc/console_io.hpp`:

```hpp
#ifndef CONSOLEIO_HPP
#define CONSOLEIO_HPP
#pragma once

#include <Windows.h>
#include <fcntl.h>
#include <io.h>
#include <iostream>
#include "../i18n/i18n.hpp"
#include "config.hpp"
#include "utils.hpp"
#include <thread>

using std::wcout;
using std::wcout;
using std::endl;
using namespace i18n;

class ConsoleIO {
private:
    HWND console_window;
    HANDLE screen_buffer;
    const short screen_width = 62;
    const short screen_height = 20;
    FILE* fp;
    // {defined, {error, latest}}; todo: use std::optional
    std::pair<bool, std::pair<bool, bool>> latest;
    wchar_t* current_font = (wchar_t*)L"Consolas";

    // adjusts window to desired width and height
    void _set_window() { // https://stackoverflow.com/a/40634467
        COORD const size = { screen_width, screen_height };

        SMALL_RECT const minimal_window = { 0, 0, 1, 1 }; // to get rid of scroll bars
        SetConsoleWindowInfo(screen_buffer, TRUE, &minimal_window);

        SMALL_RECT const window = { 0, 0, size.X - 1, size.Y - 1 };
        SetConsoleWindowInfo(screen_buffer, TRUE, &window);

        SetConsoleScreenBufferSize(screen_buffer, size);
    }

    void _set_cursor() {
        _CONSOLE_CURSOR_INFO const cursor_info = { 100, false };
        SetConsoleCursorInfo(screen_buffer, &cursor_info);
    }

    void print_version_status(Internalisation* i, COORD coords) {
        if (!latest.first) {
            latest = std::make_pair(true, is_latest());
        }

        set_cursor_position(coords);
        if (latest.second.first) write_str(i->translate(XorStr("error")), FOREGROUND_RED);
        else if (latest.second.second) write_str(i->translate(XorStr("latest")), FOREGROUND_GREEN);
        else write_str(i->translate(XorStr("outdated")), FOREGROUND_GREEN | FOREGROUND_RED);
    }

    void clear() {
        COORD topLeft = { 0, 0 };
        DWORD written;

        FillConsoleOutputCharacterA(screen_buffer, ' ', screen_width * screen_height, topLeft, &written);
        FillConsoleOutputAttribute(
            screen_buffer, FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE,
            screen_width * screen_height, topLeft, &written
            );
        _set_cursor();
        SetConsoleCursorPosition(screen_buffer, topLeft);
    }

    std::wstring stringToWstring(std::string str) {
        std::wstring wstr(str.begin(), str.end());
        return wstr;
    }
    
    bool fix_font() {
        CONSOLE_FONT_INFOEX cfi;
        cfi.cbSize = sizeof(cfi);
        cfi.dwFontSize.X = 8;
        cfi.dwFontSize.Y = 16;
        cfi.FontFamily = FF_DONTCARE;
        cfi.FontWeight = FW_NORMAL;
        std::wcscpy(cfi.FaceName, L"Consolas");

        return SetCurrentConsoleFontEx(screen_buffer, FALSE, &cfi) == TRUE;
    }

    void fix_font(Internalisation* i) {
        CONSOLE_FONT_INFOEX cfi;
        cfi.cbSize = sizeof(cfi);
        cfi.dwFontSize.X = 8;
        cfi.dwFontSize.Y = 16;
        cfi.FontFamily = FF_DONTCARE;
        cfi.FontWeight = FW_NORMAL;

        if (i->get_lang() == XorStr("ZH")) {
            const wchar_t* font = L"MS Gothic";
            std::wcscpy(cfi.FaceName, font);
            if (SetCurrentConsoleFontEx(screen_buffer, FALSE, &cfi) == FALSE) {
                i->switch_language();
            }
            else {
                current_font = (wchar_t*)font;
            }
        }
        else if (current_font != L"Consolas") {
            std::wcscpy(cfi.FaceName, L"Consolas");
            if (SetCurrentConsoleFontEx(screen_buffer, FALSE, &cfi) == TRUE) {
                current_font = (wchar_t*)L"Consolas";
            }
        }
    }

public:
    ConsoleIO() {
        AllocConsole();
        screen_buffer = GetStdHandle(STD_OUTPUT_HANDLE);
        console_window = GetConsoleWindow();

        SetWindowLong(console_window, GWL_STYLE, GetWindowLong(console_window, GWL_STYLE) & ~WS_MAXIMIZEBOX & ~WS_SIZEBOX);
        _set_window();
        _set_cursor();
        freopen_s(&fp, "CONOUT$", "w", stdout);
        _setmode(_fileno(fp), _O_U8TEXT);
        SetConsoleOutputCP(CP_UTF8);
        SetConsoleCP(CP_UTF8);
        latest = std::make_pair(false, std::make_pair(false, false));
        fix_font();
    }

    ~ConsoleIO() {
        fclose(fp);
    }

    void write_str(std::wstring str, WORD colour, bool clear_right = true) {
        SetConsoleTextAttribute(screen_buffer, colour);
        std::wcout << str;
        if (clear_right) std::wcout << "          "; // 10 spaces buffer
        SetConsoleTextAttribute(screen_buffer, FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN); // resetting to gray colour
    }

    void write_str(std::string str, WORD colour, bool clear_right = true) {
        write_str(stringToWstring(str), colour, clear_right);
    }

    COORD get_cursor_position() {
        CONSOLE_SCREEN_BUFFER_INFO buff_info;

        if (GetConsoleScreenBufferInfo(screen_buffer, &buff_info)) return buff_info.dwCursorPosition;
        else return { 0, 0 }; // returns invalid coords
    }

    void set_cursor_position(COORD coords) {
        SetConsoleCursorPosition(screen_buffer, coords);
    }

    void initial_output(hacks_coords* coords, Internalisation* i, hacks_state* state) {
        clear();
        fix_font(i);

        char* nl = XorStr("\n  ");
        char* cl = XorStr(": ");
        std::wstring on = i->translate(XorStr("on"));
        std::wstring off = i->translate(XorStr("off"));
        std::wstring yes = i->translate(XorStr("yes"));
        std::wstring no = i->translate(XorStr("no"));

        wcout << XorStr("Le Chiffre ") << stringToWstring(CHEAT_VERSION) << ' ' << stringToWstring(RELEASE_DATE) << endl << endl;
        wcout << i->translate(XorStr("website")) << endl << endl;

        wcout << i->translate(XorStr("state")) << cl;
        wcout << nl << i->translate(XorStr("language")) << cl;
        coords->language = get_cursor_position();
        write_str(i->get_lang(), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);

        wcout << nl << i->translate(XorStr("connected_csgo")) << cl;
        coords->process = get_cursor_position();
        write_str(state->process ? yes : no, state->process ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("connected_game")) << cl;
        coords->game = get_cursor_position();
        write_str(state->game ? yes : no, state->game ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("version")) << cl;
        coords->version = get_cursor_position();
        write_str(i->translate(XorStr("loading")), FOREGROUND_GREEN | FOREGROUND_RED);

        std::thread print_ver(&ConsoleIO::print_version_status, this, i, coords->version);
        print_ver.detach();

        Sleep(1); // needed because otherwise on rerendering the 'cheat_functions' string will overlap with cheat status because of async code
        wcout << XorStr("\n\n") << i->translate(XorStr("cheat_functions")) << cl;
        wcout << nl << i->translate(XorStr("bunny_hop")) << cl;
        coords->bunny_hop = get_cursor_position();
        write_str(state->bunny_hop ? on : off, state->bunny_hop ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("no_flash")) << cl;
        coords->no_flash = get_cursor_position();
        write_str(state->no_flash ? on : off, state->no_flash ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("aimbot")) << cl;
        coords->aimbot = get_cursor_position();
        write_str(state->aimbot ? on : off, state->aimbot ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("triggerbot")) << cl;
        coords->activate_trigger = get_cursor_position();
        write_str(state->activate_trigger ? on : off, state->activate_trigger ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("use_triggerbot")) << cl;
        coords->use_trigger = get_cursor_position();
        write_str(i->translate(XorStr("hold")), FOREGROUND_GREEN | FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("glowesp")) << cl;
        coords->enemy_wh = get_cursor_position();
        write_str(state->enemy_wh ? on : off, state->enemy_wh ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("radar_hack")) << cl;
        coords->radar_hack = get_cursor_position();
        write_str(state->radar_hack ? on : off, state->radar_hack ? FOREGROUND_GREEN : FOREGROUND_RED);

        wcout << nl << i->translate(XorStr("exit")) << cl;
        write_str(i->translate(XorStr("press")), FOREGROUND_GREEN | FOREGROUND_RED);
    }
};
#endif
```

`Le_Chiffre/misc/utils.hpp`:

```hpp
#ifndef UTILS_HPP
#define UTILS_HPP
#pragma once
#include "config.hpp"
#include "web_utils.hpp"
#include "console_io.hpp"
#include <iostream>
#include <string>

// Manually gets the value of a key from a JSON string 
// Sorry about that, but I just don't want to import a JSON parsing library only because of one simple task
// I wrote all this code at 4 AM, so it probably needs some refactoring
std::string json_parse_string(std::string data, std::string key) {
	std::string buffer;
	bool quote_opened = false;
	bool key_found = false;

	for (char const& c : data) {
		if (c == *XorStr("\"")) {
			if (!quote_opened) quote_opened = true;
			else {
				if (key_found) return buffer;
				if (buffer == key) key_found = true;
				quote_opened = false;
			}

			buffer.clear();
		}
		else if (quote_opened) buffer.push_back(c);
	}

	return {};
}

std::string get_latest_version() {
	std::string json = web::get(HOST, PATH);

	return json != XorStr("ERROR") ? json_parse_string(json, XorStr("name")) : XorStr("ERROR");
}

// {ERROR, LATEST}
std::pair<bool, bool> is_latest() {
	std::string ver = get_latest_version();

	if (ver == XorStr("ERROR")) return std::make_pair(true, false);
	return std::make_pair(false, ver == CHEAT_VERSION);
}
#endif // !UTILS_HPP
```

`Le_Chiffre/misc/web_utils.hpp`:

```hpp
#ifndef WEB_UTILS_HPP
#define WEB_UTILS_HPP
#pragma once
#include <iostream>
#include <winhttp.h>
#include "xor.hpp"
#pragma comment(lib, "winhttp.lib")

// TODO: Refactor code
namespace web {
	// Sends a GET request
	// Returns a result or "ERROR" if status code != 200 or if something else went wrong
	std::string get(const wchar_t* host, const wchar_t* path, INTERNET_PORT port = INTERNET_DEFAULT_HTTPS_PORT) {
		HINTERNET hSession = NULL, hConnect = NULL, hRequest = NULL;
		std::string res = XorStr("ERROR");

		hSession = WinHttpOpen(L"WinHTTP/1.0", WINHTTP_ACCESS_TYPE_NO_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);

		if (hSession) {
			if (hConnect = WinHttpConnect(hSession, host, port, 0)) hRequest = WinHttpOpenRequest(hConnect, L"GET", path, NULL, WINHTTP_NO_REFERER, WINHTTP_DEFAULT_ACCEPT_TYPES, WINHTTP_FLAG_SECURE);

			if (hRequest && WinHttpSendRequest(hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0, WINHTTP_NO_REQUEST_DATA, 0, 0, 0) && WinHttpReceiveResponse(hRequest, NULL)) {
				DWORD status, len = sizeof(status), read_bytes = 0;
				char* buffer = (char*)malloc(1000);

				if (WinHttpQueryHeaders(hRequest, WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER, NULL, &status, &len, NULL)) {
					if (status == 200 && WinHttpReadData(hRequest, buffer, 1000, &read_bytes)) {
						realloc(buffer, read_bytes);
						res = buffer;
					}
				}
				free(buffer);
			}

			if (hRequest) WinHttpCloseHandle(hRequest);
			if (hConnect) WinHttpCloseHandle(hConnect);
			WinHttpCloseHandle(hSession);
		} // else std::cout << "WinHTTP ERROR CODE: " << GetLastError();

		return res;
	}
}

#endif // !WEB_UTILS_HPP
```

`Le_Chiffre/misc/xor.hpp`:

```hpp
#pragma once
#include <string>
#include <array>
#include <cstdarg>

#define BEGIN_NAMESPACE( x ) namespace x {
#define END_NAMESPACE }

BEGIN_NAMESPACE(XorCompileTime)

constexpr auto time = __TIME__;
constexpr auto seed = static_cast<int>(time[7]) + static_cast<int>(time[6]) * 10 + static_cast<int>(time[4]) * 60 + static_cast<int>(time[3]) * 600 + static_cast<int>(time[1]) * 3600 + static_cast<int>(time[0]) * 36000;

// 1988, Stephen Park and Keith Miller
// "Random Number Generators: Good Ones Are Hard To Find", considered as "minimal standard"
// Park-Miller 31 bit pseudo-random number generator, implemented with G. Carta's optimisation:
// with 32-bit math and without division

template <int N>
struct RandomGenerator {
private:
    static constexpr unsigned a = 16807; // 7^5
    static constexpr unsigned m = 2147483647; // 2^31 - 1

    static constexpr unsigned s = RandomGenerator< N - 1 >::value;
    static constexpr unsigned lo = a * (s & 0xFFFF); // Multiply lower 16 bits by 16807
    static constexpr unsigned hi = a * (s >> 16); // Multiply higher 16 bits by 16807
    static constexpr unsigned lo2 = lo + ((hi & 0x7FFF) << 16); // Combine lower 15 bits of hi with lo's upper bits
    static constexpr unsigned hi2 = hi >> 15; // Discard lower 15 bits of hi
    static constexpr unsigned lo3 = lo2 + hi;

public:
    static constexpr unsigned max = m;
    static constexpr unsigned value = lo3 > m ? lo3 - m : lo3;
};

template <>
struct RandomGenerator<0> {
    static constexpr unsigned value = seed;
};

template <int N, int M>
struct RandomInt {
    static constexpr auto value = RandomGenerator< N + 1 >::value % M;
};

template <int N>
struct RandomChar {
    static const char value = static_cast<char>(1 + RandomInt< N, 0x7F - 1 >::value);
};

template <size_t N, int K, typename Char>
struct XorString {
private:
    const char _key;
    std::array< Char, N + 1 > _encrypted;

    constexpr Char enc(Char c) const {
        return c ^ _key;
    }

    Char dec(Char c) const {
        return c ^ _key;
    }

public:
    template < size_t... Is >
    constexpr __forceinline XorString(const Char* str, std::index_sequence< Is... >) : _key(RandomChar< K >::value), _encrypted{ enc(str[Is])... }
    {
    }

    __forceinline decltype(auto) decrypt(void) {
        for (size_t i = 0; i < N; ++i) {
            _encrypted[i] = dec(_encrypted[i]);
        }
        _encrypted[N] = '\0';
        return _encrypted.data();
    }
};

/*
static auto w_printf = [](const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vprintf_s(fmt, args);
    va_end(args);
};

static auto w_printf_s = [](const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vprintf_s(fmt, args);
    va_end(args);
};

static auto w_sprintf = [](char* buf, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsprintf(buf, fmt, args);
    va_end(args);
};

static auto w_sprintf_ret = [](char* buf, const char* fmt, ...) {
    int ret;
    va_list args;
    va_start(args, fmt);
    ret = vsprintf(buf, fmt, args);
    va_end(args);
    return ret;
};

static auto w_sprintf_s = [](char* buf, size_t buf_size, const char* fmt, ...) {
    va_list args;
    va_start(args, fmt);
    vsprintf_s(buf, buf_size, fmt, args);
    va_end(args);
};

static auto w_sprintf_s_ret = [](char* buf, size_t buf_size, const char* fmt, ...) {
    int ret;
    va_list args;
    va_start(args, fmt);
    ret = vsprintf_s(buf, buf_size, fmt, args);
    va_end(args);
    return ret;
};
*/

#define XorStr( s ) []{ constexpr XorCompileTime::XorString< sizeof(s)/sizeof(char) - 1, __COUNTER__, char > expr( s, std::make_index_sequence< sizeof(s)/sizeof(char) - 1>() ); return expr; }().decrypt()
#define XorStrW( s ) []{ constexpr XorCompileTime::XorString< sizeof(s)/sizeof(wchar_t) - 1, __COUNTER__, wchar_t > expr( s, std::make_index_sequence< sizeof(s)/sizeof(wchar_t) - 1>() ); return expr; }().decrypt()

END_NAMESPACE
```

`Le_Chiffre/overlay/overlay.hpp`:

```hpp
// An invisible D3DX9 overlay over the target process
#ifndef OVERLAY_HPP
#define OVERLAY_HPP
#pragma once

#include <Windows.h>
#include <d3d9.h>
#include "paint.hpp"
#include "../memory.hpp"
#include <iostream>
#include <dwmapi.h>
#include "../misc/xor.hpp"
#pragma comment(lib, "dwmapi.lib")

Paint paint; // draw, write text or do other manipulations with the overlay

class Overlay {
private:
	WCHAR _title[20]; // overlay window title
    Memory* mem;
    RECT rect; // coordinates of target window

    // registers window class
    ATOM _register_ņlass() {
        WNDCLASSEX wc;
        ZeroMemory(&wc, sizeof(WNDCLASSEX));

        wc.cbSize = sizeof(WNDCLASSEX);
        wc.style = CS_HREDRAW | CS_VREDRAW;
        wc.lpfnWndProc = WndProc;
        wc.cbClsExtra = NULL;
        wc.cbWndExtra = NULL;
        wc.hInstance = GetModuleHandle(NULL);
        wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
        wc.hCursor = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = WHITE_BRUSH;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = _title;
        wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);

        return RegisterClassEx(&wc);
    }

    // initialise overlay instance
    bool _init_instance(int width, int height) {
        hwnd = CreateWindowEx(WS_EX_TOPMOST | WS_EX_TRANSPARENT | WS_EX_LAYERED, _title, _title, WS_POPUP, rect.left, rect.top, width, height, 0, 0, 0, 0);
        if (!hwnd) return false;

        SetLayeredWindowAttributes(hwnd, 0, 1.0f, LWA_ALPHA);
        SetLayeredWindowAttributes(hwnd, 0, RGB(0, 0, 0), LWA_COLORKEY);

        MARGINS _margins = { -1, -1, width, height };
        DwmExtendFrameIntoClientArea(hwnd, &_margins);

        ShowWindow(hwnd, SW_SHOW);
        return true;
    }

    void _set_title() {
        for (byte i = 0; i < 19; ++i) {
            _title[i] = 97 + rand() % 26; // [97, 122] - a-z in ASCII
        }
        _title[19] = '\0';
    }

public:
    HWND hwnd; // an HWND to the overlay window

    Overlay(Memory* mem) {
        this->mem = mem;
        if (!init()) {
            MessageBox(
                NULL, 
                XorStrW(L"Error during overlay initialisation.\nThis is most likely due to the cheat failing to detect the game process.\nPlease make sure the game is running and try again."), 
                NULL, 
                MB_OK | MB_ICONERROR | MB_TOPMOST
            );
        }
    }

    ~Overlay() {
        DestroyWindow(hwnd);
    }

    bool init() {
        if (!mem->tHWND) return false;
        if (!GetWindowRect(mem->tHWND, &rect)) return false;
        _set_title();
        // std::cout << "x: [" << rect.left << ", " << rect.top << "]; y: [" << rect.right << ", " << rect.bottom << "]" << std::endl;
        _register_ņlass();

        if (!_init_instance(rect.right - rect.left, rect.bottom - rect.top)) return false;
        paint = Paint(hwnd, mem->tHWND, rect.right - rect.left, rect.bottom - rect.top);
        
        return true;
    }

    DWORD APIENTRY start() {
        MSG msg;

        //while (GetMessage(&msg, nullptr, 0, 0)) {}

        while (true) {
            if (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE)) {
                if (msg.message == WM_QUIT) break;
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                
                GetWindowRect(mem->tHWND, &rect);
                int width = rect.right - rect.left;
                int height = rect.bottom - rect.top;

                MoveWindow(hwnd, rect.left, rect.top, width, height, true);
            }
            Sleep(10);
        }

        return (int)msg.wParam;
    }

    static DWORD WINAPI static_start(void* param) {
        Overlay* ol = (Overlay*)param;
        return ol->start();
    }

    static LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam) {
        switch (message) {
        case WM_PAINT:
            paint.render();
            break;
        case WM_DESTROY:
            PostQuitMessage(0);
            break;
        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
        }
        return 0;
    }
};
#endif
```

`Le_Chiffre/overlay/paint.hpp`:

```hpp
// Class which contains methods to draw stuff (text, boxes, lines) over Direct 3D 9 overlay.
#ifndef PAINT_HPP
#define PAINT_HPP
#pragma once
#pragma warning(disable: 26495)

#include <Windows.h>

#include <d3d9.h>
#include <d3dx9.h>
#pragma comment(lib, "d3d9.lib")
#pragma comment(lib, "d3dx9.lib")
#pragma comment(lib, "legacy_stdio_definitions.lib")

class Paint {
private:
	IDirect3D9Ex* object = NULL; // used to create device
	IDirect3DDevice9Ex* device = NULL; // contains functions like begin and end scene 
	D3DPRESENT_PARAMETERS params; 
	ID3DXFont* d3d_font = 0; // font used when displaying text

	HWND t_hwnd; // target process window
	int width; // target process width
	int height;

	int d3d9init(HWND hwnd) {
		if (FAILED(Direct3DCreate9Ex(D3D_SDK_VERSION, &object))) {
			DestroyWindow(hwnd);
		}

		ZeroMemory(&params, sizeof(params));
		params.BackBufferWidth = width;
		params.BackBufferHeight = height;
		params.Windowed = TRUE;
		params.SwapEffect = D3DSWAPEFFECT_DISCARD;
		params.hDeviceWindow = hwnd;
		params.MultiSampleQuality = D3DMULTISAMPLE_NONE;
		params.BackBufferFormat = D3DFMT_A8R8G8B8;
		params.EnableAutoDepthStencil = TRUE;
		params.AutoDepthStencilFormat = D3DFMT_D16;

		HRESULT res = object->CreateDeviceEx(D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_HARDWARE_VERTEXPROCESSING, &params, 0, &device);
		if (FAILED(res)) DestroyWindow(hwnd);

		D3DXCreateFont(device, 50, 0, FW_BOLD, 1, false, DEFAULT_CHARSET, OUT_DEVICE_PRECIS, ANTIALIASED_QUALITY, DEFAULT_PITCH, L"Consolas", &d3d_font);

		return 0;
	}

	void draw_text(char* text, int x, int y, int a, int r, int g, int b) {
		RECT rect;
		rect.left = x;
		rect.top = y;
		d3d_font->DrawTextA(0, text, strlen(text), &rect, DT_NOCLIP, D3DCOLOR_ARGB(a, r, g, b));
	}

public:
	Paint() {
		this->device = nullptr;
		this->object = nullptr;
	}

	~Paint() {
		if (object != NULL) object->Release();
		if (device != NULL) device->Release();
	}
	
	Paint(HWND hwnd, HWND t_hwnd, int width, int height) {
		this->t_hwnd = t_hwnd;
		this->width = width;
		this->height = height;
		d3d9init(hwnd);
	}

	int render() {
		if (device == nullptr) return 1;

		device->Clear(0, 0, D3DCLEAR_TARGET, 0, 1.0f, 0);
		device->BeginScene();

		if (t_hwnd == GetForegroundWindow()) {
			draw_text((char*)"Test message", 15, 15, 255, 0, 0, 160);
		}

		device->EndScene();
		device->PresentEx(0, 0, 0, 0, 0);

		return 0;
	}
};

#endif
```

`Le_Chiffre/player_entity.hpp`:

```hpp
#ifndef PLAYER_ENTITY_HPP
#define PLAYER_ENTITY_HPP

#pragma once
#pragma warning(disable: 26451) // disabled a warning about arithmetic overflow (cast from float to double)

#define _USE_MATH_DEFINES // to access math consts like PI number
#include <math.h>
#include "memory.hpp"
#include "client.hpp"
#include "signatures.hpp"
#include "misc/config.hpp"
#include "client.hpp"
#include "bsp_parser/valve-bsp-parser/core/matrix.hpp"

using namespace hazedumper;
using namespace rn;

struct BoneMatrix {
	BYTE _junk1[0xC];
	float x;
	BYTE _junk2[0xC];
	float y;
	BYTE _junk3[0xC];
	float z;
};

class PlayerEntity {
private:
	Memory* memory;
	DWORD playerBaseAddr;

public:
	PlayerEntity() {
		memory = nullptr;
		playerBaseAddr = NULL;
	}

	PlayerEntity(Memory* memory, DWORD playerBaseAddr) {
		this->memory = memory;
		this->playerBaseAddr = playerBaseAddr;
	}

	bool valid_player() {
		if (!memory || !playerBaseAddr) return false;

		DWORD health = this->get_health();
		return (health > 0 && health <= 100) && !get_dormant();
	}

	// 4 - don't attack
	// 5 - attack
	// 6 - attack once, next reset to 4
	inline void set_attack_state(DWORD val) {
		memory->write_mem<DWORD>(memory->clientBaseAddr + signatures::dwForceAttack, val);
	}

	// 4 - don't jump
	// 5 - jump
	// 6 - jump once, next reset to 4
	inline void set_jump_state(DWORD val) {
		memory->write_mem<DWORD>(memory->clientBaseAddr + signatures::dwForceJump, val);
	}

	inline void set_flash_duration(float val) {
		memory->write_mem<float>(playerBaseAddr + netvars::m_flFlashDuration, val);
	}

	inline void set_spotted(bool val) {
		memory->write_mem<bool>(playerBaseAddr + netvars::m_bSpotted, val);
	}

	inline bool is_spotted() {
		return memory->read_mem<bool>(playerBaseAddr + netvars::m_bSpotted);
	}

	// aims at XYZ axis point
	void aim_at(coords_vector point) {
		// pitch - point at Y axis in [-89, 89] degrees range - arcsin of Z coord and hypotenuse
		// yaw - point at X axis in [-180, 180] degrees range
		DWORD clst = memory->read_mem<DWORD>(memory->engineBaseAddr + signatures::dwClientState);
		coords_vector view_angles = memory->read_mem<coords_vector>(clst + signatures::dwClientState_ViewAngles);

		coords_vector position = get_origin();
		coords_vector view_point = get_view_offset();
		coords_vector view_pos({ position.x + view_point.x, position.y + view_point.y, position.z + view_point.z });

		coords_vector delta({ point.x - view_pos.x, point.y - view_pos.y, point.z - view_pos.z }); // Y distance between local player view offset (eyes position) and point operand
		float delta_len = (float)sqrt(delta.x * delta.x + delta.y * delta.y + delta.z * delta.z); // distance between two points (hypotenuse)

		float pitch = (float)-asin(delta.z / delta_len) * (180 / (float)M_PI); // -asin because 89 deg is floor and -89 deg is ceil
		float yaw = (float)atan2(delta.y, delta.x) * (180 / (float)M_PI);

		if (pitch >= -89 && pitch <= 89 && yaw >= -180 && yaw <= 180) {
			view_angles.x = pitch; // / smoothing;
			view_angles.y = yaw; // / smoothing;
		}

		memory->write_mem<coords_vector>(clst + signatures::dwClientState_ViewAngles, view_angles);
	}

	// [0, 100]
	inline DWORD get_health() {
		return memory->read_mem<DWORD>(playerBaseAddr + netvars::m_iHealth);
	}

	inline bool get_dormant() {
		return memory->read_mem<bool>(playerBaseAddr + signatures::m_bDormant);
	}

	inline DWORD get_crosshair_id() {
		return memory->read_mem<DWORD>(playerBaseAddr + netvars::m_iCrosshairId);
	}

	// 2 - terrorist
	// 3 - counter terrorist
	inline int get_team() {
		return memory->read_mem<int>(playerBaseAddr + netvars::m_iTeamNum);
	}

	// FL_ONGROUND   (1 << 0) on the ground
	// FL_DUCKING    (1 << 1) fully crouched
	// FL_WATERJUMP  (1 << 2) jumping out of water
	// FL_ONTRAIN    (1 << 3) _controlling_ a train
	// FL_INRAIN     (1 << 4) standing in rain
	// FL_FROZEN     (1 << 5) frozen
	// FL_ATCONTROLS (1 << 6) can't move
	// FL_CLIENT     (1 << 7) player
	// FL_FAKECLIENT (1 << 8) fake client
	// FL_INWATER    (1 << 9) in water
	inline BYTE get_flags() {
		return memory->read_mem<BYTE>(playerBaseAddr + netvars::m_fFlags);
	}

	inline float get_flash_duration() {
		return memory->read_mem<float>(playerBaseAddr + netvars::m_flFlashDuration);
	}

	inline int get_glow_index() {
		return memory->read_mem<int>(playerBaseAddr + netvars::m_iGlowIndex);
	}

	inline DWORD get_base_addr() {
		return this->playerBaseAddr;
	}

	inline coords_vector get_velocity() {
		return memory->read_mem<coords_vector>(playerBaseAddr + netvars::m_vecVelocity);
	}

	inline bool is_moving() {
		coords_vector vec = get_velocity();
		float sum = vec.x + vec.y + vec.z;
		return sum < -0.003 || sum > 0; // 0.003 due to incorrect float precision
	}

	// player's x, y, z location on map
	inline coords_vector get_origin() {
		return memory->read_mem<coords_vector>(playerBaseAddr + netvars::m_vecOrigin);
	}

	// player's x, y, z eyes position
	inline coords_vector get_view_offset() {
		return memory->read_mem<coords_vector>(playerBaseAddr + netvars::m_vecViewOffset);
	}

	// player's x, y, z bone position
	// bone_id - an ID in bone's vector, the most important ones are: 8 - head, 7 - neck, 6, 5, 4, 3, 0 - chest (from top)
	inline coords_vector get_bone_position(int bone_id) {
		DWORD bone_matrix = memory->read_mem<DWORD>(playerBaseAddr + netvars::m_dwBoneMatrix);
		BoneMatrix bone = memory->read_mem<BoneMatrix>(bone_matrix + bone_id * 0x30);
		return coords_vector({ bone.x, bone.y, bone.z });
	}

	// returns rn::vector3 bone position. needed for bsp parser
	inline vector3 get_bone_position_v3(int bone_id) {
		coords_vector cv = get_bone_position(bone_id);
		const std::array<float, 3U> vec = { cv.x, cv.y, cv.z };
		return vector3(vec);
	}

	// returns rn::vector3 view offset. needed for bsp parser
	inline vector3 get_view_offset_v3() {
		coords_vector cv = get_view_offset();
		const std::array<float, 3U> vec = { cv.x, cv.y, cv.z };
		return vector3(vec);
	}

	// returns the distance between 2 player's entities (XYZ points)
	// https://www.math.usm.edu/lambers/mat169/fall09/lecture17.pdf
	inline float get_distance(coords_vector target) {
		coords_vector local = get_origin();
		return (float)sqrt(pow(target.x - local.x, 2) + pow(target.y - local.y, 2) + pow(target.z - local.z, 2));
	}

	// returns the distance between two points located on XY coords
	inline float get_distance_2d(coords_vector p1, coords_vector p2) {
		return (float)sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
	}
};
#endif
```

`Le_Chiffre/sig_scanner.hpp`:

```hpp
// A signature scanner to obtain game memory offsets by provided memory patterns
#ifndef SIG_SCANNER
#define SIG_SCANNER
#pragma once
#include <Windows.h>
#include <cstddef>
#include <iostream>

class SigScanner {
private:
	HANDLE process;

	intptr_t _scan(const char* pattern, const char* mask, char* begin, unsigned size) {
		unsigned patternLength = strlen(mask);

		for (unsigned i = 0; i < size - patternLength; i++) {
			bool found = true;

			for (unsigned j = 0; j < patternLength; j++) {
				if (mask[j] != '?' && pattern[j] != *(char*)((intptr_t)begin + i + j)) {
					found = false;
					break;
				}
			}

			if (found) return ((intptr_t)begin + i);
		}

		return 0;
	}

	char* _find_signature(char* pattern, char* mask, char* begin, intptr_t size) {
		char* match { nullptr };
		SIZE_T bytesRead;
		DWORD oldprotect;
		char* buffer{ nullptr };
		MEMORY_BASIC_INFORMATION mbi;
		mbi.RegionSize = 0x1000;//

		VirtualQueryEx(process, (LPCVOID)begin, &mbi, sizeof(mbi));

		for (char* current = begin; current < begin + size; current += mbi.RegionSize) {
			if (!VirtualQueryEx(process, (LPCVOID)current, &mbi, sizeof(mbi))) continue;
			if (mbi.State != MEM_COMMIT || mbi.Protect == PAGE_NOACCESS) continue;

			delete[] buffer;
			buffer = new char[mbi.RegionSize];

			if (VirtualProtectEx(process, mbi.BaseAddress, mbi.RegionSize, PAGE_EXECUTE_READWRITE, &oldprotect)) {
				ReadProcessMemory(process, mbi.BaseAddress, buffer, mbi.RegionSize, &bytesRead);
				VirtualProtectEx(process, mbi.BaseAddress, mbi.RegionSize, oldprotect, &oldprotect);

				intptr_t internalAddr = _scan(pattern, mask, buffer, bytesRead);

				if (internalAddr != 0) {
					match = current + (internalAddr - (intptr_t)buffer);
					break;
				}
			}
		}

		delete[] buffer;
		return match;
	}

public:
	SigScanner() {
		process = nullptr;
	}

	SigScanner(HANDLE process) {
		this->process = process;
	}

	char* find (const char* signature, char* begin, intptr_t size) {
		char pattern[50];
		char mask[50];
		char last_char = ' ';
		unsigned int j = 0;

		for (unsigned int i = 0; i < strlen(signature); ++i, ++j) {
			if ((signature[i] == '?' || signature[i] == '*') && (last_char != '?' && last_char != '*')) {
				pattern[j] = mask[j] = '?';
			} else if (isspace(last_char)) {
				pattern[j] = last_char = (char)strtol(&signature[i], 0, 16);
				mask[j] = 'x';
			}

			last_char = signature[i];
		}
		pattern[j] = mask[j] = '\0';

		return _find_signature(pattern, mask, begin, size);
	}
};

#endif // !SIG_SCANNER
```

`Le_Chiffre/signatures.hpp`:

```hpp
#ifndef SIGNATURES_HPP
#define SIGNATURES_HPP
#pragma once
#include <cstddef>

// 2022-03-02 12:31:19.354722100 UTC
namespace hazedumper {
	constexpr ::std::int64_t timestamp = 1646224279;
	namespace netvars {
		constexpr ::std::ptrdiff_t cs_gamerules_data = 0x0;
		constexpr ::std::ptrdiff_t m_ArmorValue = 0x117CC;
		constexpr ::std::ptrdiff_t m_Collision = 0x320;
		constexpr ::std::ptrdiff_t m_CollisionGroup = 0x474;
		constexpr ::std::ptrdiff_t m_Local = 0x2FCC;
		constexpr ::std::ptrdiff_t m_MoveType = 0x25C;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidHigh = 0x31D4;
		constexpr ::std::ptrdiff_t m_OriginalOwnerXuidLow = 0x31D0;
		constexpr ::std::ptrdiff_t m_SurvivalGameRuleDecisionTypes = 0x1328;
		constexpr ::std::ptrdiff_t m_SurvivalRules = 0xD00;
		constexpr ::std::ptrdiff_t m_aimPunchAngle = 0x303C;
		constexpr ::std::ptrdiff_t m_aimPunchAngleVel = 0x3048;
		constexpr ::std::ptrdiff_t m_angEyeAnglesX = 0x117D0;
		constexpr ::std::ptrdiff_t m_angEyeAnglesY = 0x117D4;
		constexpr ::std::ptrdiff_t m_bBombDefused = 0x29C0;
		constexpr ::std::ptrdiff_t m_bBombPlanted = 0x9A5;
		constexpr ::std::ptrdiff_t m_bBombTicking = 0x2990;
		constexpr ::std::ptrdiff_t m_bFreezePeriod = 0x20;
		constexpr ::std::ptrdiff_t m_bGunGameImmunity = 0x9990;
		constexpr ::std::ptrdiff_t m_bHasDefuser = 0x117DC;
		constexpr ::std::ptrdiff_t m_bHasHelmet = 0x117C0;
		constexpr ::std::ptrdiff_t m_bInReload = 0x32B5;
		constexpr ::std::ptrdiff_t m_bIsDefusing = 0x997C;
		constexpr ::std::ptrdiff_t m_bIsQueuedMatchmaking = 0x74;
		constexpr ::std::ptrdiff_t m_bIsScoped = 0x9974;
		constexpr ::std::ptrdiff_t m_bIsValveDS = 0x7C;
		constexpr ::std::ptrdiff_t m_bSpotted = 0x93D;
		constexpr ::std::ptrdiff_t m_bSpottedByMask = 0x980;
		constexpr ::std::ptrdiff_t m_bStartedArming = 0x3400;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMax = 0x9D9;
		constexpr ::std::ptrdiff_t m_bUseCustomAutoExposureMin = 0x9D8;
		constexpr ::std::ptrdiff_t m_bUseCustomBloomScale = 0x9DA;
		constexpr ::std::ptrdiff_t m_clrRender = 0x70;
		constexpr ::std::ptrdiff_t m_dwBoneMatrix = 0x26A8;
		constexpr ::std::ptrdiff_t m_fAccuracyPenalty = 0x3340;
		constexpr ::std::ptrdiff_t m_fFlags = 0x104;
		constexpr ::std::ptrdiff_t m_flC4Blow = 0x29A0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMax = 0x9E0;
		constexpr ::std::ptrdiff_t m_flCustomAutoExposureMin = 0x9DC;
		constexpr ::std::ptrdiff_t m_flCustomBloomScale = 0x9E4;
		constexpr ::std::ptrdiff_t m_flDefuseCountDown = 0x29BC;
		constexpr ::std::ptrdiff_t m_flDefuseLength = 0x29B8;
		constexpr ::std::ptrdiff_t m_flFallbackWear = 0x31E0;
		constexpr ::std::ptrdiff_t m_flFlashDuration = 0x10470;
		constexpr ::std::ptrdiff_t m_flFlashMaxAlpha = 0x1046C;
		constexpr ::std::ptrdiff_t m_flLastBoneSetupTime = 0x2928;
		constexpr ::std::ptrdiff_t m_flLowerBodyYawTarget = 0x9ADC;
		constexpr ::std::ptrdiff_t m_flNextAttack = 0x2D80;
		constexpr ::std::ptrdiff_t m_flNextPrimaryAttack = 0x3248;
		constexpr ::std::ptrdiff_t m_flSimulationTime = 0x268;
		constexpr ::std::ptrdiff_t m_flTimerLength = 0x29A4;
		constexpr ::std::ptrdiff_t m_hActiveWeapon = 0x2F08;
		constexpr ::std::ptrdiff_t m_hBombDefuser = 0x29C4;
		constexpr ::std::ptrdiff_t m_hMyWeapons = 0x2E08;
		constexpr ::std::ptrdiff_t m_hObserverTarget = 0x339C;
		constexpr ::std::ptrdiff_t m_hOwner = 0x29DC;
		constexpr ::std::ptrdiff_t m_hOwnerEntity = 0x14C;
		constexpr ::std::ptrdiff_t m_hViewModel = 0x3308;
		constexpr ::std::ptrdiff_t m_iAccountID = 0x2FD8;
		constexpr ::std::ptrdiff_t m_iClip1 = 0x3274;
		constexpr ::std::ptrdiff_t m_iCompetitiveRanking = 0x1A84;
		constexpr ::std::ptrdiff_t m_iCompetitiveWins = 0x1B88;
		constexpr ::std::ptrdiff_t m_iCrosshairId = 0x11838;
		constexpr ::std::ptrdiff_t m_iDefaultFOV = 0x333C;
		constexpr ::std::ptrdiff_t m_iEntityQuality = 0x2FBC;
		constexpr ::std::ptrdiff_t m_iFOV = 0x31F4;
		constexpr ::std::ptrdiff_t m_iFOVStart = 0x31F8;
		constexpr ::std::ptrdiff_t m_iGlowIndex = 0x10488;
		constexpr ::std::ptrdiff_t m_iHealth = 0x100;
		constexpr ::std::ptrdiff_t m_iItemDefinitionIndex = 0x2FBA;
		constexpr ::std::ptrdiff_t m_iItemIDHigh = 0x2FD0;
		constexpr ::std::ptrdiff_t m_iMostRecentModelBoneCounter = 0x2690;
		constexpr ::std::ptrdiff_t m_iObserverMode = 0x3388;
		constexpr ::std::ptrdiff_t m_iShotsFired = 0x103E0;
		constexpr ::std::ptrdiff_t m_iState = 0x3268;
		constexpr ::std::ptrdiff_t m_iTeamNum = 0xF4;
		constexpr ::std::ptrdiff_t m_lifeState = 0x25F;
		constexpr ::std::ptrdiff_t m_nBombSite = 0x2994;
		constexpr ::std::ptrdiff_t m_nFallbackPaintKit = 0x31D8;
		constexpr ::std::ptrdiff_t m_nFallbackSeed = 0x31DC;
		constexpr ::std::ptrdiff_t m_nFallbackStatTrak = 0x31E4;
		constexpr ::std::ptrdiff_t m_nForceBone = 0x268C;
		constexpr ::std::ptrdiff_t m_nTickBase = 0x3440;
		constexpr ::std::ptrdiff_t m_nViewModelIndex = 0x29D0;
		constexpr ::std::ptrdiff_t m_rgflCoordinateFrame = 0x444;
		constexpr ::std::ptrdiff_t m_szCustomName = 0x304C;
		constexpr ::std::ptrdiff_t m_szLastPlaceName = 0x35C4;
		constexpr ::std::ptrdiff_t m_thirdPersonViewAngles = 0x31E8;
		constexpr ::std::ptrdiff_t m_vecOrigin = 0x138;
		constexpr ::std::ptrdiff_t m_vecVelocity = 0x114;
		constexpr ::std::ptrdiff_t m_vecViewOffset = 0x108;
		constexpr ::std::ptrdiff_t m_viewPunchAngle = 0x3030;
		constexpr ::std::ptrdiff_t m_zoomLevel = 0x33E0;
	} // namespace netvars
	namespace signatures {
		constexpr ::std::ptrdiff_t anim_overlays = 0x2990;
		constexpr ::std::ptrdiff_t clientstate_choked_commands = 0x4D30;
		constexpr ::std::ptrdiff_t clientstate_delta_ticks = 0x174;
		constexpr ::std::ptrdiff_t clientstate_last_outgoing_command = 0x4D2C;
		constexpr ::std::ptrdiff_t clientstate_net_channel = 0x9C;
		constexpr ::std::ptrdiff_t convar_name_hash_table = 0x2F0F8;
		constexpr ::std::ptrdiff_t dwClientState = 0x58CFC4;
		constexpr ::std::ptrdiff_t dwClientState_GetLocalPlayer = 0x180;
		constexpr ::std::ptrdiff_t dwClientState_IsHLTV = 0x4D48;
		constexpr ::std::ptrdiff_t dwClientState_Map = 0x28C;
		constexpr ::std::ptrdiff_t dwClientState_MapDirectory = 0x188;
		constexpr ::std::ptrdiff_t dwClientState_MaxPlayer = 0x388;
		constexpr ::std::ptrdiff_t dwClientState_PlayerInfo = 0x52C0;
		constexpr ::std::ptrdiff_t dwClientState_State = 0x108;
		constexpr ::std::ptrdiff_t dwClientState_ViewAngles = 0x4D90;
		constexpr ::std::ptrdiff_t dwEntityList = 0x4DCEEAC;
		constexpr ::std::ptrdiff_t dwForceAttack = 0x31FF3C0;
		constexpr ::std::ptrdiff_t dwForceAttack2 = 0x31FF3CC;
		constexpr ::std::ptrdiff_t dwForceBackward = 0x31FF36C;
		constexpr ::std::ptrdiff_t dwForceForward = 0x31FF3F0;
		constexpr ::std::ptrdiff_t dwForceJump = 0x5278DDC;
		constexpr ::std::ptrdiff_t dwForceLeft = 0x31FF378;
		constexpr ::std::ptrdiff_t dwForceRight = 0x31FF384;
		constexpr ::std::ptrdiff_t dwGameDir = 0x62B880;
		constexpr ::std::ptrdiff_t dwGameRulesProxy = 0x52EBE3C;
		constexpr ::std::ptrdiff_t dwGetAllClasses = 0xDDD1D4;
		constexpr ::std::ptrdiff_t dwGlobalVars = 0x58CCC8;
		constexpr ::std::ptrdiff_t dwGlowObjectManager = 0x5317308;
		constexpr ::std::ptrdiff_t dwInput = 0x5220480;
		constexpr ::std::ptrdiff_t dwInterfaceLinkList = 0x965464;
		constexpr ::std::ptrdiff_t dwLocalPlayer = 0xDB35DC;
		constexpr ::std::ptrdiff_t dwMouseEnable = 0xDB92E8;
		constexpr ::std::ptrdiff_t dwMouseEnablePtr = 0xDB92B8;
		constexpr ::std::ptrdiff_t dwPlayerResource = 0x31FD710;
		constexpr ::std::ptrdiff_t dwRadarBase = 0x5203C24;
		constexpr ::std::ptrdiff_t dwSensitivity = 0xDB9184;
		constexpr ::std::ptrdiff_t dwSensitivityPtr = 0xDB9158;
		constexpr ::std::ptrdiff_t dwSetClanTag = 0x8A320;
		constexpr ::std::ptrdiff_t dwViewMatrix = 0x4DC07C4;
		constexpr ::std::ptrdiff_t dwWeaponTable = 0x5220F48;
		constexpr ::std::ptrdiff_t dwWeaponTableIndex = 0x326C;
		constexpr ::std::ptrdiff_t dwYawPtr = 0xDB8F48;
		constexpr ::std::ptrdiff_t dwZoomSensitivityRatioPtr = 0xDBF1B0;
		constexpr ::std::ptrdiff_t dwbSendPackets = 0xD9542;
		constexpr ::std::ptrdiff_t dwppDirect3DDevice9 = 0xA5050;
		constexpr ::std::ptrdiff_t find_hud_element = 0x5B4650F0;
		constexpr ::std::ptrdiff_t force_update_spectator_glow = 0x3BB80A;
		constexpr ::std::ptrdiff_t interface_engine_cvar = 0x3E9EC;
		constexpr ::std::ptrdiff_t is_c4_owner = 0x3C8890;
		constexpr ::std::ptrdiff_t m_bDormant = 0xED;
		constexpr ::std::ptrdiff_t m_flSpawnTime = 0x103C0;
		constexpr ::std::ptrdiff_t m_pStudioHdr = 0x2950;
		constexpr ::std::ptrdiff_t m_pitchClassPtr = 0x5203EC0;
		constexpr ::std::ptrdiff_t m_yawClassPtr = 0xDB8F48;
		constexpr ::std::ptrdiff_t model_ambient_min = 0x59003C;
		constexpr ::std::ptrdiff_t set_abs_angles = 0x1E5430;
		constexpr ::std::ptrdiff_t set_abs_origin = 0x1E5270;
	} // namespace signatures
} // namespace hazedumper
#endif // SIGNATURES_HPP
```

`README.md`:

```md
![](images/lc_hacks.jpg)
**Le Chiffre - is a lightweight opensource CS:GO external cheat which supports lots of features.**

## About
Le Chiffre - is an external feature-rich hack.\
Since it is a public cheat, I strongly recommend reimplementing the cheat logic to make it as unique as possible, or at least changing the filename (as well as it's hash) of the executable file after compilation to minimise the VAC ban risks.\
Also it might be useful to add some junk code in some cases (probably you'd have to turn compiler optimisations off before doing it).\
It's recommended to use [VAC Bypass](https://github.com/danielkrupinski/VAC-Bypass-Loader) to bypass anti-cheat scan and drastically reduce the likelihood of a VAC ban.\
\
You have to use at least the C++17 standard (due to bsp_parser library requirements) to compile the cheat.\
[Le Chiffre official website](https://lechiffre.now.sh)

![](images/lechiffre_mainmenu.png)

## Cheat functions
- F2 - Bunnyhop
- F3 - No flashbang
- F4 - Activate Aim bot
- F6 - Activate trigger bot
- LAlt - Use trigger bot
- F8 - Enemy glow ESP
- F9 - Radar hack
- END - Panic mode (exits cheat immediately)

## Features to be made in future
- CS:GO Overlay to show info like bomb ticker, spectators, etc.
- Aim assist.
- Improve ESP (show the bomb, bomb carrier in a different colour, etc).
- CS:GO offsets autoparser (or just parse the hazedumper offsets on every launch).

## Building the cheat yourself
This project already includes all it's configuration in the .vcxproj file, so if you're using Visual Studio 2019 (or maybe even some earlier versions) it should work and compile fine, just make sure to build it as a x86 Release file.\
But for some reason sometimes Visual Studio may ignore the project configurations, so you'll have to set it manually.\
These are the most frequent issues people can meet while building this project:
 - in project settings you have to set C++ standard as `C++ 2017` or `C++ latest`, it's a requirement of the `bsp_parser` library, which this cheat relies on.
 - in ProjectProperties -> Configuration Properties -> C/C++ -> Preprocessor -> Preprocessor Definitions you have to add the following macros: `_CRT_SECURE_NO_DEPRECATE` and `_CRT_NONSTDC_NO_DEPRECATE`.
 - in Linker settings, the `System` settings has to be set as `Windows (/SUBSYSTEM:WINDOWS)`, as this project is not using the regular `main` funciton as an entry point. 

## Credits
Thanks to [hazedumper](https://github.com/frk1/hazedumper "hazedumper") library for providing memory offsets.\
Thanks to [bsp_parser](https://github.com/ReactiioN1337/valve-bsp-parser "bsp_parser") library for making the aimbot even better.

```

`frontend/assets/styles.css`:

```css
* {
  margin: 0;
  padding: 0;
}

body {
  background-color:hsl(262, 44%, 11%);
  text-align: center;
  font-family: sanf-serif;
}

#background {
  z-index: -1;
  position: fixed;
  background: url("../assets/background.png") no-repeat hsl(262, 44%, 11%);
  background-position: center;
  filter: blur(15px);
  background-attachment: scroll;
  background-size: cover;
  width: 100%;
  height: 100%;
  /* min-height: 1000px; */
}

#content {
  display: flex;
  height: calc(100vh - 10px);
  align-items: center;
  justify-content: center;
}

.name, .minidesc {
  font-family: sans-serif;
  font-size: 70px;
  background: linear-gradient(to right, hsl(263, 84%, 53%), hsl(9, 89%, 48%));
  background-clip: text;
  -webkit-text-fill-color: transparent;
  -webkit-background-clip: text;
}

.minidesc { 
  font-size: 30px; 
  margin: 30px;
}

#description {
  display: inline-block;
  font-family: sans-serif;
  color: hsl(261, 85%, 81%);
  font-size: 20px;
}

.button {
  display: inline-block;
  cursor: pointer;
  text-decoration: none;
  margin:7px;
  padding: 10px;
  font-size: 20px;
  border-radius: 50px;
  transition: all .4s ease;
}

.regular {
  color: hsl(0, 0%, 100%);
  border: .5px solid hsl(261, 85%, 81%);
}

.regular:hover {
  color: hsl(265, 41%, 15%);
  background-color: hsl(261, 85%, 81%);
}

.contact { border: none; }

.drop-shadow {
  filter: drop-shadow(2px 4px 8px #6b6b6b);
}

.noscript {
  color:hsl(261, 85%, 81%);
  padding-top: 10px;
  font-size: 19px;
}
```

`frontend/index.html`:

```html
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="description" content="Counter-Strike: Global Offensive game cheat">
  <meta name="robots" content="index, nofollow">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Le Chiffre - CS:GO hack">
  <meta property="og:description" content="Counter-Strike: Global Offensive game cheat">
  <meta property="og:locale" content="en_US">
  <title>Le Chiffre - CS:GO hack</title>
  <link rel="stylesheet" href="assets/styles.css">
  <script src="script.js" defer></script>
  <script src="https://cdn.jsdelivr.net/gh/Swetrix/swetrix-js@main/dist/swetrix.js" defer></script>
</head>

<body>
  <div id="background"></div>
  <p class="noscript">
    <noscript>Please turn JavaScript on for the best website experience</noscript>
  </p>
  <div id="content">
    <div>
      <p class="name">Le Chiffre</p>
      <p class="minidesc">Counter-Strike: Global Offensive game cheat</p>
      <div id="description" class="drop-shadow">
        Le Chiffre - is a lightweight opensource external cheat, which supports lots of features<br>
        <br>
        <p></p><!-- The text with cheat version info is loaded here via JS -->
        <br>
      </div>
      <div>
        <a href="https://github.com/Blaumaus/le_chiffre/releases" target="_blank" class="button regular" id="download_btn">Download</a>
        <a href="https://github.com/Blaumaus/le_chiffre" target="_blank" class="button regular">The source code</a><br>
        <a href="https://ko-fi.com/andriir" target="_blank" class="button regular">Support project</a>
      </div>
      <div class="contacts">
        <a href="mailto:coopertars@protonmail.ch" target="_blank" class="button regular contact">coopertars@protonmail.ch</a>
      </div>
    </div>
  </div>
</body>

</html>

```

`frontend/script.js`:

```js
const format_date = date => {
  const months = ['Jan.', 'Feb.', 'Mar.', 'Apr.', 'May.', 'Jun.', 'Jul.', 'Aug.', 'Sep.', 'Oct.', 'Nov.', 'Dec.']
  date = date.split('T')[0].split('-')

  return `${date[2]} ${months[date[1] - 1]} ${date[0]}`
}

const set_cookie = (key, val, expires = 1209600) => { // 2 weeks is the default expire time
  document.cookie = `${key}=${val};Max-Age=${expires};path=/;samesite=strict`
}

const check_cookie = key => {
  return document.cookie.split(';').some(item => item.trim().startsWith(`${key}=`))
}

const ask_donation = () => {
  alert('Hello.\nIf you find this project useful and want me to update it regularly, consider donating a small amount to help me cover the costs of development.\n\nYour donations are appreciated!')
}

const check_donation = () => {
  if (!check_cookie('donation')) {
    set_cookie('donation', 1)
    ask_donation()
  }
}

document.addEventListener('DOMContentLoaded', () => {
  const desc = document.querySelector('#description > p')
  const download = document.getElementById('download_btn')

  fetch('https://api.github.com/repos/blaumaus/le_chiffre/releases?per_page=1')
    .then(res => res.json())
    .then(res => {
      const version = res[0]?.tag_name || 'Unknown'
      const date = res[0]?.published_at || 'Unknown'
      const download_url = res[0].assets[0]?.browser_download_url || 'https://github.com/Blaumaus/le_chiffre/releases'
      
      desc.textContent = `The latest cheat version is ${version}, it has been updated on ${format_date(date)}`
      download.textContent = 'Direct download'
      download.href = download_url
    })
    .catch(console.error)

  setTimeout(check_donation, 2500)

  swetrix.init('ZAX-2szETYGP')
  swetrix.trackViews()
})
```