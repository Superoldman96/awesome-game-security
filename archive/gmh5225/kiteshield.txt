Project Path: arc_gmh5225_kiteshield_rayxp6aw

Source Tree:

```txt
arc_gmh5225_kiteshield_rayxp6aw
├── LICENSE
├── Makefile
├── README.md
├── common
│   ├── include
│   │   ├── defs.h
│   │   ├── obfuscation.h
│   │   └── rc4.h
│   ├── obfuscation.c
│   └── rc4.c
├── loader
│   ├── Makefile
│   ├── anti_debug.c
│   ├── bin_to_header.py
│   ├── entry.S
│   ├── include
│   │   ├── anti_debug.h
│   │   ├── debug.h
│   │   ├── elf_auxv.h
│   │   ├── errno.h
│   │   ├── malloc.h
│   │   ├── signal.h
│   │   ├── string.h
│   │   ├── syscalls.h
│   │   └── types.h
│   ├── link.lds
│   ├── loader.c
│   ├── malloc.c
│   ├── runtime.c
│   ├── string.c
│   ├── string_obfuscation.py
│   ├── syscalls.c
│   └── test
│       ├── Makefile
│       ├── attounit.h
│       ├── test_main.c
│       ├── test_malloc.c
│       └── test_rc4.c
├── packer
│   ├── Makefile
│   ├── bddisasm
│   ├── elfutils.c
│   ├── include
│   │   └── elfutils.h
│   └── kiteshield.c
└── testing
    ├── README.md
    ├── build_test_set.sh
    ├── dockerfiles
    │   ├── Dockerfile-alpine
    │   ├── Dockerfile-centos-7
    │   ├── Dockerfile-centos-8
    │   ├── Dockerfile-fedora
    │   ├── Dockerfile-ubuntu-bionic
    │   ├── Dockerfile-ubuntu-focal
    │   ├── Dockerfile-ubuntu-trusty
    │   └── Dockerfile-ubuntu-xenial
    ├── output_wrappers.sh
    ├── run_test_set.sh
    ├── test.sh
    └── tests
        ├── expected_outputs
        │   ├── file_read
        │   ├── fork_chain
        │   ├── fork_exec
        │   ├── fork_many
        │   ├── fork_simple
        │   ├── helloworld
        │   ├── longjmp
        │   ├── multicall
        │   ├── mutual_recursion
        │   ├── prime_sieve
        │   ├── pthread_exit_deep_in_callstack
        │   ├── pthread_many_threads
        │   ├── pthread_shared_stacktraces
        │   ├── pthread_simple
        │   ├── pthread_thread_leader_exit
        │   ├── pthread_with_fork
        │   ├── recursion
        │   ├── signals
        │   └── static_data
        ├── file_read.c
        ├── fork_chain.c
        ├── fork_exec.c
        ├── fork_many.c
        ├── fork_simple.c
        ├── helloworld.c
        ├── longjmp.c
        ├── multicall.c
        ├── mutual_recursion.c
        ├── prime_sieve.c
        ├── pthread_exit_deep_in_callstack.c
        ├── pthread_many_threads.c
        ├── pthread_shared_stacktraces.c
        ├── pthread_simple.c
        ├── pthread_thread_leader_exit.c
        ├── pthread_with_fork.c
        ├── recursion.c
        ├── signals.c
        └── static_data.c

```

`LICENSE`:

```
Copyright (c) 2019-2021 Rhys Rustad-Elliott

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


```

`Makefile`:

```
.PHONY: loader packer

all: packer

debug: packer-debug
debug-antidebug: packer-debug-antidebug

# The packer requires the headerized loader, thus the loader is a dependency of
# the packer
packer: loader
	$(MAKE) -C packer

packer-debug: loader-debug
	$(MAKE) debug -C packer

packer-debug-antidebug: loader-debug-antidebug
	$(MAKE) debug-antidebug -C packer

loader:
	$(MAKE) -C loader

loader-debug:
	$(MAKE) debug -C loader

loader-debug-antidebug:
	$(MAKE) debug-antidebug -C loader

clean:
	$(MAKE) clean -C loader
	$(MAKE) clean -C packer

```

`README.md`:

```md
# Kiteshield

A packer/protector for x86-64 ELF binaries on Linux. Kiteshield wraps ELF
binaries with multiple layers of encryption and injects them with loader code
that decrypts, maps, and executes the packed binary entirely in userspace. A
ptrace-based runtime engine ensures that only functions in the current call
stack are decrypted at any given time and additionally implements a variety of
anti-debugging techniques in order to make packed binaries as hard to
reverse-engineer as possible. Both single and multithreaded binaries are
supported.

See the [Architecture](#architecture) and [Codebase Layout](#codebase-layout)
sections below for a bird's-eye view of how Kiteshield works.

Kiteshield is intended to be a fun academic exercise in binary obfuscation
rather than something that can be used in the real world given the source code,
and thus how it works, is public.

Named for [the shields](https://en.wikipedia.org/wiki/Kite_shield) preferred by
the Normans in the 11th century (alternatively: the kiteshields that are so
prevalent in Old School Runescape).

## Building Kiteshield

Kiteshield requires the [Bitdefender
disassembler](https://github.com/bitdefender/bddisasm) library to decode
instructions in the packer. It is included as a submodule at `packer/bddisasm`.
To build it from a fresh clone, run the following (note you will need to have
CMake installed):

```
git submodule update --init
cd packer/bddisasm
mkdir build
cd build
cmake ..
make
```

You can now build Kiteshield in release mode by running `make` from the top
level directory. Alternatively you can create a debug build with `make debug`.
Debug builds of Kiteshield disable all anti-debugging features and turn on the
loader's very verbose debug logging.

In order to debug the actual anti-debugging functionality, you can build
Kiteshield in debug mode with anti-debugging functionality turned *on* using
`make debug-antidebug`.

## Using Kiteshield

To pack a binary called `program` and output the packed binary to `packed.ks`,
run:

```
./packer/kiteshield program packed.ks
```

`packed.ks` can now be run and should be functionally equivalent to `program`,
but encrypted and hard to reverse engineer. Note that for layer 2 encryption to
be applied, the input binary *must not* be stripped as Kiteshield relies on the
symbol table being present. On most Linux distros, standard system utilities
(eg. `/bin/ls`) are generally stripped.

You can still however pack stripped binaries without layer 2 encryption using
the `-n` flag:

```
./packer/kiteshield -n program packed.ks
```

This will produce an output binary packed with only layer 1 encryption and the
runtime engine omitted.

## <a name="codebase-layout"></a> Codebase Layout

Kiteshield is composed of two separate parts. The packer is a regular C
application that reads, instruments, and encrypts input binaries. The loader is
a freestanding C application responsible for dynamic function decryption and
anti-debugging functionality that is injected into input binaries by the
packer. It receives initial control from the kernel, maps all appropriate
segments of the binary into memory (including the dynamic linker if
applicable), and hands off control to the application. The loader also contains
the runtime engine, which dynamically decrypts and encrypts functions as they
are entered and exited at runtime.

Since the loader receives initial control from the kernel (ie. before any
shared libraries would normally be mapped by the dynamic linker), it does not
have access to libc and thus all needed functionality provided by libc is
re-implemented in the loader code.

Packer and loader code can be found in the `packer/` and `loader/` directories
respectively. Code that is common to both can be found in the `common/`
directory. A high-level overview of the important parts of the codebase is as
follows:

```
kiteshield
├── common                         # Code common to packer/loader
│   ├── include
│   │   ├── defs.h
│   │   ├── obfuscation.h
│   │   └── rc4.h
│   ├── obfuscation.c              # Obfuscation utilities
│   └── rc4.c                      # RC4 stream cipher implementation
├── LICENSE
├── loader                         # Loader code
│   ├── anti_debug.c               # Anti-debugging functionality
│   ├── bin_to_header.py           # Script to "headerize" a compiled loader
│   ├── entry.S                    # Loader entry point code
│   ├── include
│   │   ├── anti_debug.h
│   │   ├── debug.h
│   │   ├── elf_auxv.h
│   │   ├── errno.h
│   │   ├── malloc.h
│   │   ├── obfuscated_strings.h   # Generated file produced by string_obfuscation.py
│   │   ├── signal.h
│   │   ├── string.h
│   │   ├── syscalls.h
│   │   └── types.h
│   ├── link.lds                   # Custom linker script for building loader
│   ├── loader.c                   # Binary loading/mapping code (userspace exec)
│   ├── Makefile
│   ├── malloc.c                   # Freestanding malloc/free implementation
│   ├── runtime.c                  # Main body of runtime engine code
│   ├── string.c                   # String processing utilities (eg. strncat)
│   ├── string_obfuscation.py      # String obfuscation helper script
│   ├── syscalls.c                 # System call implementations in inline assembly
│   └── test                       # Loader unit tests
│       ├── attounit.h
│       ├── Makefile
│       ├── test_main.c
│       ├── test_malloc.c
│       └── test_rc4.c
├── Makefile
├── packer                         # Packer code
│   ├── bddisasm                   # Bitdefender x86-64 disassembler library (submodule)
│   ├── elfutils.c                 # ELF binary reading/writing utilities
│   ├── include
│   │   └── elfutils.h
│   ├── kiteshield.c               # Main body of packer code
│   └── Makefile
├── README.md
└── testing                        # Integration tests (see testing/README.md)
```

## <a name="architecture"></a> Architecture

Kiteshield wraps input ELF binaries in two (or one, if using the `-n` flag)
layers of RC4 encryption such that the binary on disk is fairly well
obfuscated. These layers are stripped off at runtime by the loader.

### Layer 1

The first layer of encryption (referred to in the codebase as the "outer
layer") consists of a single RC4 pass over the entire input binary. This is
designed primarily to fight static analysis. Due to the way the key is
deobfuscated (which is dependent on the loader code) the first layer of
encryption also effectively checksums the loader code before executing the
packed binary, making Kiteshield resistant to code patching.

### Layer 2

The second layer of encryption (referred to in the codebase as the "inner
layer") consists of individual encryption of almost every function in the input
binary (identified via the symbol table at pack-time). A ptrace-based runtime
engine is triggered on every function entry and exit via replacement of each
function's entry instruction and all its return instructions with `int3`
instructions (which deliver a `SIGTRAP` when executed). Upon receiving a trap,
the runtime engine looks up the current function and encrypts or decrypts it as
needed such that only functions within the current call stack are decrypted at
any point in time.

After stripping off layer 1, Kiteshield effectively re-implements the `exec`
syscall in userspace (See `loader/loader.c`. This technique is commonly
referred to in literature as a "userspace exec" or "userland exec".) to map the
packed binary into memory via a series of `mmap`/`mprotect` calls before
forking and handing control off to the packed binary in the child and the
runtime engine in the parent (which attaches to the child using ptrace).

In addition to encryption, Kiteshield's loader code also contains a number of
anti-debugging features designed to make it as difficult as possible to analyze
a running packed binary (See `loader/anti_debug.c` and
`loader/include/anti_debug.h`).

To give a concrete example of Kiteshield in action, consider the following
hello world program, which we will pack with Kiteshield in debug mode.

```c
#include <stdio.h>

int main()
{
  puts("Hello World!");
  return 0;
}
```

When packed in debug mode, loader code in packed binaries will log very verbose
debug information. The following is the log from a packed binary corresponding
to the above program. It has been annotated (and additional newlines added for
clarity) to provide a concrete example of Kiteshield in action:

```
$ ./packed.ks

# Runtime startup
[kiteshield] starting ptrace runtime
[kiteshield] number of trap points: 5
[kiteshield] number of encrypted functions: 3

# List of points in memory that have been instrumented with an int3 instruction
[kiteshield] list of trap points:
[kiteshield] 8000011ac value: c3, type: ret, function: __libc_csu_init (#0)
[kiteshield] 800001150 value: 41, type: ent, function: __libc_csu_init (#0)
[kiteshield] 800001050 value: 31, type: ent, function: _start (#1)
[kiteshield] 80000114b value: c3, type: ret, function: main (#2)
[kiteshield] 800001135 value: 55, type: ent, function: main (#2)

# Runtime has started and is waiting on the packed app, begin mapping binary

# Stripping layer one encryption
[kiteshield] RC4 decrypting binary with key 85e19ad41fb8cc13e87e3cd1589a45fb
[kiteshield] decrypted 12336 bytes

# Mapping segments from packed binary program header table
[kiteshield] mapping LOAD section from packed binary at 800000000
[kiteshield] mapping LOAD section from packed binary at 800001000
[kiteshield] mapping LOAD section from packed binary at 800002000
[kiteshield] mapping LOAD section from packed binary at 800003000

# Mapping dynamic linker specified in INTERP header of packed binary
[kiteshield] mapping INTERP ELF at path /lib64/ld-linux-x86-64.so.2
[kiteshield] mapped LOAD section from fd at b00000000
[kiteshield] interpreter base address is b00000000
[kiteshield] mapped LOAD section from fd at b00001000
[kiteshield] mapped LOAD section from fd at b0001f000
[kiteshield] mapped extra space for static data (.bss) at b00029000 len 400
[kiteshield] mapped LOAD section from fd at b00027000
[kiteshield] binary base address is 800000000

# Modifying ELF auxiliary vector as needed for program execution
[kiteshield] taking 7ffff2997c60 as auxv start
[kiteshield] replaced auxv entry 9 with value 34359742544 (0x800001050)
[kiteshield] replaced auxv entry 3 with value 34359738432 (0x800000040)
[kiteshield] replaced auxv entry 7 with value 47244640256 (0xb00000000)
[kiteshield] replaced auxv entry 5 with value 11 (0xb)
[kiteshield] finished mapping binary into memory
[kiteshield] control will be passed to packed app at b00001090

# Mapping done

# Runtime attaches to the packed application with ptrace
[kiteshield] child is traced, handing control to packed binary

# Program is executing, functions are logged on entry/exit
[kiteshield] tid 13508: entering encrypted function _start decrypting with key 74c974f9d097e5a8c60049c3842c6110
[kiteshield] tid 13508: entering encrypted function __libc_csu_init decrypting with key 9124511baa87daa76c09b2426355dfca
[kiteshield] tid 13508: leaving function __libc_csu_init for address 7fa9a821d02a (no function record) via ret at 8000011ac
[kiteshield] tid 13508: entering encrypted function main decrypting with key 2f1c20e77ff3617b0b89a579669aba48

# Actual program output
Hello World!

# Packed application returns from main() and exits
[kiteshield] tid 13508: leaving function main for address 7fa9a821d09b (no function record) via ret at 80000114b
[kiteshield] tid 13508: exited with status 0
[kiteshield] all threads exited, exiting
```

## Testing

Kiteshield has an extensive set of integration tests to verify correctness
across several different platforms. See `testing/README.md` for details.

## Limitations

Kiteshield was written with obfuscation in mind, not speed. Trapping into the
Kiteshield runtime on every function entrance and exit is very expensive.
Programs packed with layer 2 encryption should expect a serious performance
hit.

## License

[MIT](https://github.com/GunshipPenguin/kiteshield/blob/master/LICENSE) &#x00a9; Rhys Rustad-Elliott

```

`common/include/defs.h`:

```h
/* Definitions needed across loader/packer code */
#ifndef __KITESHIELD_DEFS_H
#define __KITESHIELD_DEFS_H

#include <stdint.h>

#define INT3 0xCC

/* Address at which the loader is initially loaded by the kernel on exec (ie.
 * the p_vaddr field in the binary). Note that if this is updated, the base
 * address in the linker script for the loader code must be updated
 * accordingly.
 */
#define LOADER_ADDR 0x200000ULL

/* Address at which the packed binary is initially loaded by the kernel on
 * exec (ie. the p_vaddr field in the binary) */
#define PACKED_BIN_ADDR 0xA00000ULL

/* Base address the loader will load a position-independent packed binary to
 * before launching.
 *
 * Note that this is only relevant for packed binaries of type ET_DYN (ie.
 * position-independent binaries). ET_EXEC (position-dependent) binaries will
 * ignore this and just use the absolute addresses specified in their program
 * headers.
 */
#define DYN_PROG_BASE_ADDR 0x800000000ULL

/* Base address at which the loader code will load ld.so (or whatever is
 * specified in the INTERP header).
 *
 * As with DYN_PROG_BASE_ADDR, this is only relevant for program interpreters
 * of type ET_DYN. If you happen to be packing something using a weird linker
 * setup where your ld.so is of type ET_EXEC, this will be ignored and the
 * absolute addresses in the program headers will be used instead.
 */
#define DYN_INTERP_BASE_ADDR 0xB00000000ULL

/* This struct is stored at a predefined offset in the loader code, allowing
 * the packer to copy the RC4 decryption key over the loader. */
#define KEY_SIZE 16
struct rc4_key {
  uint8_t bytes[KEY_SIZE];
} __attribute__((packed));

/* Represents a function that has been encrypted/instrumented and that the
 * runtime knows about.
 */
struct function {
  uint32_t id;
  uint64_t start_addr;
  uint32_t len;

  /* Key that this function's code is encrypted with */
  struct rc4_key key;

/* For logging purposes in debug mode */
#ifdef DEBUG_OUTPUT
  char name[32];
#endif
} __attribute__((packed));

enum tp_type {
  TP_FCN_ENTRY,
  TP_JMP,
  TP_RET,
};

/* Represents a point in code at which we injected a single byte int3
 * instruction so that the program will trap into the ptrace runtime to decrypt
 * or encrypt the current function when entering or returning from it
 * respectively.
 */
struct trap_point {
  /* Address in program code of this trap point */
  uint64_t addr;

  /* Trap point type, either a function entry, jmp that potentially leaves its
   * containing function, or ret */
  enum tp_type type;

  /* Byte that was overwritten by the int3, needed so we can overwrite and
   * execute the original instruction */
  uint8_t value;

  /* Index into the function array for the containing function */
  int fcn_i;
} __attribute__((packed));

/* Struct encompassing all the function and trap point information the runtime
 * needs to do its job. One of these is stored at a predefined offset via the
 * linker script so that the runtime can access it.
 */
struct runtime_info {
  int nfuncs;
  int ntraps;
  uint8_t data[];
} __attribute__((packed));

#endif /* __KITESHIELD_DEFS_H */


```

`common/include/obfuscation.h`:

```h
#ifndef __KITESHIELD_OBFUSCATION_H
#define __KITESHIELD_OBFUSCATION_H

#include "common/include/defs.h"

void obf_deobf_outer_key(struct rc4_key *old_key,
                         struct rc4_key *new_key,
                         unsigned char *loader_bin,
                         unsigned int loader_bin_size);

void obf_deobf_rt_info(
    struct runtime_info *rt_info);

#endif /* __KITESHIELD_OBFUSCATION_H */


```

`common/include/rc4.h`:

```h
#ifndef __KITESHIELD_RC4_H
#define __KITESHIELD_RC4_H

struct rc4_state {
  unsigned char S[256];
  int i;
  int j;
};

void rc4_init(struct rc4_state *rc4, unsigned char *key, unsigned int keylen);
unsigned char rc4_get_byte(struct rc4_state *rc4);

#endif /* __KITESHIELD_RC4_H */


```

`common/obfuscation.c`:

```c
#include <stddef.h>
#include "common/include/defs.h"

/* Outer key obfuscation / deobfuscation function.
 *
 * XORs each byte of the outer key (the key used to encrypt the binary as a
 * whole, NOT the per-function keys) with a each byte of code/data in the
 * loader code. Run before the key is embedded in the loader code to ensure the
 * naked key isn't stored on disk and at load time to deobfuscate the key
 * before using it to decrypt the packed binary.
 *
 * This method of obfuscating the outer key has the nice added side effect of
 * effectively checksumming the loader code. If a reverse-engineer patches out
 * some bytes in the loader code with nops, the outer key will be deobfuscated
 * incorrectly, and the program will undoubtedly crash and burn. Furthermore,
 * it will crash somewhere in the packed code (ie. not here), thus drawing
 * attention away from this "checksumming" code.
 *
 * Since this function just XORs the bytes of the key with a bunch of preset
 * bits, it is an involution (ie. it is its own inverse), thus it is used to
 * obfuscate the key in the loader code and then deobfuscate the key in the
 * loader code.
 */
void obf_deobf_outer_key(
    struct rc4_key *old_key,
    struct rc4_key *new_key,
    unsigned char *loader_bin,
    unsigned int loader_bin_size)
{
  __builtin_memcpy(new_key, old_key, sizeof(*old_key));

#ifdef NO_ANTIDEBUG
  return;
#endif

  /* Skip the struct rc4_key of course, we just want the code */
  unsigned int loader_index = sizeof(struct rc4_key);
  unsigned int key_index = 0;
  while (loader_index < loader_bin_size) {
    new_key->bytes[key_index] ^= *((unsigned char *) loader_bin + loader_index);

    loader_index ++;
    key_index = (key_index + 1) % sizeof(new_key->bytes);
  }
}

/* Runtime info obfuscation / deobfuscation function.
 *
 * Obfuscates the passed in runtime info info so we're not storing the
 * per-function keys (and function/trap point metadata) naked on disk.
 *
 * Unlike the outer key, we're not going for a checksumming like effect here,
 * so just use a simple incrementing XOR to obfuscate all the information in
 * the runtime_info struct.
 *
 * As above, this function is an involution.
 */
void obf_deobf_rt_info(
    struct runtime_info *rt_info) {

#ifdef NO_ANTIDEBUG
  return;
#endif

  size_t size = (sizeof(struct trap_point) * rt_info->ntraps) +
                (sizeof(struct function) * rt_info->nfuncs);

  /* Skip the data actually in the struct runtime_info and not the flexible
   * array as we need it to calculate the size to obfuscate/deobfuscate */
  uint8_t *data = (uint8_t *) rt_info + sizeof(struct runtime_info);
  for (size_t i = 0; i < size; i++) {
    data[i] = data[i] ^ (i % 256);
  }
}


```

`common/rc4.c`:

```c
#include "common/include/rc4.h"

/* https://en.wikipedia.org/wiki/RC4#Description */
void rc4_init(struct rc4_state *rc4, unsigned char *key, unsigned int keylen)
{
  for (unsigned int i = 0; i < 256; i++) {
    rc4->S[i] = (unsigned char) i;
  }

  unsigned int j = 0;
  for (unsigned int i = 0; i < 256; i++) {
    j = (j + rc4->S[i] + key[i % keylen]) % 256;

    unsigned char temp = rc4->S[i];
    rc4->S[i] = rc4->S[j];
    rc4->S[j] = temp;
  }

  rc4->i = 0;
  rc4->j = 0;
}

unsigned char rc4_get_byte(struct rc4_state *rc4)
{
  rc4->i = (rc4->i + 1) % 256;
  rc4->j = (rc4->j + rc4->S[rc4->i]) % 256;

  unsigned char temp = rc4->S[rc4->i];
  rc4->S[rc4->i] = rc4->S[rc4->j];
  rc4->S[rc4->j] = temp;

  return rc4->S[(rc4->S[rc4->i] + rc4->S[rc4->j]) % 256];
}


```

`loader/Makefile`:

```
CFLAGS_COMMON = -Wall -Werror -std=gnu99 -fno-pie -nostdlib -nostartfiles -nodefaultlibs -fno-builtin -c -I ..
LDFLAGS = -no-pie

CFLAGS = $(CFLAGS_COMMON) -O2

SRCS = $(wildcard *.[c,S] ../common/*.c)
OBJS_RT = $(addprefix out/rt/, $(addsuffix .o, $(basename $(notdir $(SRCS:.c=.o)))))
OBJS_NO_RT = $(addprefix out/no_rt/, $(addsuffix .o, $(basename $(notdir $(SRCS:.c=.o)))))

OBFUSCATED_STRINGS_HEADER = include/obfuscated_strings.h

.PHONY: all output-dirs debug debug-antidebug clean tests

debug: CFLAGS = $(CFLAGS_COMMON) -g -DDEBUG_OUTPUT -DNO_ANTIDEBUG
debug-antidebug: CFLAGS = $(CFLAGS_COMMON) -g -DDEBUG_OUTPUT

all: output-dirs $(OBFUSCATED_STRINGS_HEADER) out/loader_header_rt.h out/loader_header_no_rt.h tests
debug: all
debug-antidebug: all

tests:
	$(MAKE) -C test clean
	$(MAKE) -C test

out/loader_header_rt.h: $(OBJS_RT)
	$(LD) $(LDFLAGS) $(OBJS_RT) -T link.lds -o out/rt/loader-elf
	objcopy -O binary out/rt/loader-elf out/rt/loader.bin
	cat out/rt/loader.bin | python3 bin_to_header.py GENERATED_LOADER_RT > out/generated_loader_rt.h

out/loader_header_no_rt.h: $(OBJS_NO_RT)
	$(LD) $(LDFLAGS) $(OBJS_NO_RT) -T link.lds -o out/no_rt/loader-elf
	objcopy -O binary out/no_rt/loader-elf out/no_rt/loader.bin
	cat out/no_rt/loader.bin | python3 bin_to_header.py GENERATED_LOADER_NO_RT > out/generated_loader_no_rt.h

$(OBFUSCATED_STRINGS_HEADER):
	python3 string_obfuscation.py > $(OBFUSCATED_STRINGS_HEADER)

out/rt/%.o: %.c
	$(CC) -DUSE_RUNTIME $(CFLAGS) $< -o $@

out/rt/%.o: ../common/%.c
	$(CC) -DUSE_RUNTIME $(CFLAGS) $< -o $@

out/rt/%.o: %.S
	$(CC) -DUSE_RUNTIME -c $< -o $@

out/no_rt/%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

out/no_rt/%.o: ../common/%.c
	$(CC) $(CFLAGS) $< -o $@

out/no_rt/%.o: %.S
	$(CC) -c $< -o $@

output-dirs:
	mkdir -p out/rt
	mkdir -p out/no_rt

clean:
	$(MAKE) clean -C test
	rm -rf out/
	rm -f $(OBFUSCATED_STRINGS_HEADER)

```

`loader/anti_debug.c`:

```c
/* Note most actual antidebug code is defined in this header file as it
 * has to be inlined everywhere. */
#include "loader/include/anti_debug.h"

int sigtrap_counter = 0;

void sigtrap_handler(int sig)
{
  DEBUG("caught SIGTRAP, incrementing SIGTRAP count (antidebug)");
  sigtrap_counter++;
}

/* Simple signal restorer that simply calls sigreturn(2). Normally this is
 * handled by glibc, but we need to explicitly declare and pass it in to
 * rt_sigaction(2) given our freestanding environment.
 */
void restorer();
asm ("restorer:\n"
     "  mov $15, %rax\n"
     "  syscall");

void antidebug_signal_init()
{
#ifdef NO_ANTIDEBUG
  return;
#endif

  struct kernel_sigaction sa;
  sa.sa_mask = ~0UL;
  sa.sa_handler = sigtrap_handler;
  sa.sa_flags = SA_RESTORER;
  sa.sa_restorer = &restorer;

  int res = sys_rt_sigaction(SIGTRAP, &sa, NULL);
  DIE_IF_FMT(res < 0, "rt_sigaction failed with errro %d", res);
}

/* Sets the process's dumpable flag to 0. This makes ptrace attaches impossible
 * and disables coredumping. We can only do this in the parent of course, since
 * the child needs to be ptraced by the process running the runtime.
 *
 * While the latter point above (disabling coredumping) is also achieved
 * through our use of rlimit to set the max core dump size to 0, this is still
 * one more thing a reverse engineer has to get around, which makes it a
 * positive.
 */
void antidebug_prctl_set_nondumpable()
{
#ifdef NO_ANTIDEBUG
  return;
#endif

  int ret = sys_prctl(PR_SET_DUMPABLE, 0, 0, 0, 0);
  DIE_IF_FMT(ret != 0, "prctl(PR_SET_DUMPABLE, 0) failed with %d", ret);
}

/* Sets the environment variables LD_PRELOAD, LD_AUDIT and LD_DEBUG (if
 * present) to empty strings.
 *
 * The first two of these can be used by a reverse engineer to run custom code
 * in dynamically linked packed program's context, the last can be set to to
 * provide potentially useful information on linker operations.
 */
void antidebug_remove_ld_env_vars(void *entry_stacktop)
{
#ifdef NO_ANTIDEBUG
  return;
#endif

  char **environ = entry_stacktop;

  /* Advance past argc */
  environ++;

  /* Advance past argv */
  while (*(++environ) != 0);
  environ++;

  for (char **v = environ; *v != NULL; v++) {
    if (strncmp(*v, DEOBF_STR(LD_PRELOAD), 9) == 0) {
      DEBUG_FMT("LD_PRELOAD is set to %s, removing", *v + 11);
      (*v)[11] = '\0';
    } else if (strncmp(*v, DEOBF_STR(LD_AUDIT), 7) == 0) {
      DEBUG_FMT("LD_AUDIT is set to %s, removing", *v + 9);
      (*v)[9] = '\0';
    } else if (strncmp(*v, DEOBF_STR(LD_DEBUG), 7) == 0) {
      DEBUG_FMT("LD_DEBUG is set to %s, removing", *v + 9);
      (*v)[9] = '\0';
    }
  }
}


```

`loader/bin_to_header.py`:

```py
#!/usr/bin/python3
import binascii
import math
import sys

BYTES_PER_LINE = 16


def bin_to_header(bin_file, array_name):
    byte_strs = \
        ['0x' + binascii.hexlify(byte).decode('ascii')
         for byte in iter(lambda: bytes(bin_file.read(1)), b'')]

    sys.stdout.write('#ifndef KITESHIELD_%s_H\n' % array_name.upper())
    sys.stdout.write('#define KITESHIELD_%s_H\n\n' % array_name.upper())
    sys.stdout.write('char %s[%d] = {\n' % (array_name, len(byte_strs)))

    for line_num in range(math.ceil(len(byte_strs) / BYTES_PER_LINE)):
        start_i = BYTES_PER_LINE * line_num
        end_i = start_i + BYTES_PER_LINE

        line_list = byte_strs[start_i:end_i]
        line_num_comment = '/* %s */' % '{0:#06x}'.format(start_i)

        sys.stdout.writelines([
            line_num_comment, '  ', ', '.join(line_list), ',\n'
        ])

    sys.stdout.write('};\n\n')
    sys.stdout.write('#endif\n')


if __name__ == '__main__':
    if len(sys.argv) == 2:
        bin_to_header(sys.stdin.buffer, sys.argv[1])
    elif len(sys.argv) == 3:
        bin_to_header(open(sys.argv[2], 'rb'), sys.argv[1])
    else:
        print(
            'Syntax: python3 bin_to_header.py <array name> [input file]',
            file=sys.stderr)

```

`loader/entry.S`:

```S
.section .text
.global _start

_start:
  # Per the SysV ABI, the value of %rbp is undefined upon getting control from
  # the kernel and should be set to 0 manually to mark the deepest stack frame.
  xor %ebp, %ebp

#ifdef USE_RUNTIME
  # Fork, starting the runtime in the parent process and returning in the child
  call do_fork

  # We've now forked. The runtime is running in our parent and will not return.
  # here. Only the child will execute the code below.
#endif

  # Load function has the following signature
  # void load(void *entry_stacktop)
  mov %rsp, %rdi # entry_stacktop
  call load

  # Return value of load is the address of ld.so to jump to, store it
  push %rax

#ifdef USE_RUNTIME
  # Binary has been mapped into memory, have the parent ptrace the child
  call child_start_ptrace
#endif

  # The x86-64 SysV ABI specifies that %rdx contains the address of a function
  # to be registered by libc with atexit upon entry (or 0 to indicate no
  # function). In practice, Linux always sets this to 0 (see ELF_PLAT_INIT
  # macro in kernel sources) before handing control to userspace. This register
  # was probably clobbered by the calls to load/do_fork above, so zero it
  # before we jump to program entry so the libc doesn't register a garbage
  # address as an exit handler.
  xor %edx, %edx

  # While we're at it, zero all the other non-privileged registers (besides
  # %rbx, which is holding the program entry point to jump to) that Linux
  # normally zeros before handing control to userspace. Unlike %rdx, this isn't
  # strictly necessary, but we'll do it anyways to make things as deterministic
  # as possible.
  xor %eax, %eax
  xor %ecx, %ecx
  xor %esi, %esi
  xor %edi, %edi
  xor %ebp, %ebp
  xor %r8d, %r8d
  xor %r9d, %r9d
  xor %r10d, %r10d
  xor %r11d, %r11d
  xor %r12d, %r12d
  xor %r13d, %r13d
  xor %r14d, %r14d
  xor %r15d, %r15d

  pop %rbx
  jmp *%rbx

```

`loader/include/anti_debug.h`:

```h
#ifndef __KITESHIELD_ANTI_DEBUG_H
#define __KITESHIELD_ANTI_DEBUG_H

#include "loader/include/types.h"
#include "loader/include/syscalls.h"
#include "loader/include/signal.h"
#include "loader/include/debug.h"
#include "loader/include/string.h"
#include "loader/include/obfuscated_strings.h"

#define TRACED_MSG "We're being traced, exiting (-DNO_ANTIDEBUG to suppress)"

static const char *nextline(const char *curr_line)
{
  const char *ptr = curr_line;
  while (*ptr != '\0') {
    if (*ptr == '\n') return ptr + 1;
    ptr++;
  }

  return NULL; /* EOF */
}

/* Check the TracerPid field in /proc/<pid>/status to verify we're not being
 * ptraced.
 *
 * Always inline this function so that a reverse engineer doesn't have to
 * simply neuter a single function in the compiled code to defeat calls to it
 * everywhere. */
static inline int __attribute__((always_inline)) antidebug_proc_check_traced()
{
#ifdef NO_ANTIDEBUG
  return 0;
#endif

  /* Use /proc/<pid>/status instead of /proc/self/status to make this just a
   * bit more frusturating to circumvent as <pid> will change with each exec.
   *
   * PROC_STATUS_FMT = "/proc/%s/status"
   */
  char proc_path[128];
  ks_snprintf(proc_path, sizeof(proc_path), DEOBF_STR(PROC_STATUS_FMT),
              sys_getpid());

  /* The check this function performs could be bypassed by running the process
   * in a mount namespace with /proc being something controlable from userspace
   * for instance, a bunch of regular files on an actual (non proc) filesystem.
   * Check we're actually reading from a procfs by stat'ing /proc/<pid>/status
   * and verifying that st_size is zero (which it should always be if /proc is
   * a real procfs. If a reverse engineer tries to create a fake proc with a
   * regular file for /proc/<pid>/status, st_size should be greater than 0. */
  struct stat stat;
  DIE_IF_FMT(sys_stat(proc_path, &stat) < 0, "could not stat %s", proc_path);
  if (stat.st_size != 0)
    return 1;

  int fd =  sys_open(proc_path, O_RDONLY, 0);
  DIE_IF_FMT(fd < 0, "could not open %s error %d", proc_path, fd);

  char buf[4096]; /* Should be enough to hold any /proc/<pid>/status */
  int ret = sys_read(fd, buf, sizeof(buf) - 1);
  DIE_IF_FMT(ret < 0, "read failed with error %d", ret);
  buf[ret] = '\0';
  sys_close(fd);

  const char *line = buf;
  char *tracerpid_field = DEOBF_STR(TRACERPID_PROC_FIELD); /* "TracerPid:" */
  do {
    if (strncmp(line, tracerpid_field, 10) != 0) continue;

    /* Strip spaces between : and the pid */
    const char *curr = line + 10;
    while (*curr != '\0') {
      if (*curr != ' ' && *curr != '\t') break;
      curr++;
    }

    if (curr[0] == '0' && curr[1] == '\n') return 0;
    else return 1;
  } while ((line = nextline(line)) != NULL);

  DEBUG(
      "Could not find TracerPid in /proc/self/status, assuming we're traced");
  return 1;
}

/* Delivers a SIGTRAP to ourself by executing an int3. This should be picked up
 * by the signal handler registered with signal_antidebug_init, which
 * increments the global sigtrap_counter by one. If we're running under gdb and
 * the reverse engineer has not explicitly configured GDB to pass the SIGTRAP
 * onto the debugged program, the signal handler won't be invoked, and thus the
 * global won't be incremented, telling us we're being debugged.
 *
 * Always inline antidebug_signal_check() for the same reasons as
 * check_traced() above. */
extern int sigtrap_counter;
static inline int __attribute__((always_inline)) antidebug_signal_check()
{
#ifdef NO_ANTIDEBUG
  return 0;
#endif

  int oldval = sigtrap_counter;
  asm volatile ("int3");

  return sigtrap_counter != oldval + 1;
}

/* Sets the maximum core dump size to 0 via setrlimit. When called in the child
 * (or in the parent pre-fork as limits are inherited after fork), this makes
 * it impossible to eg. hit the child with a SIGSEGV and get a core dump.
 *
 * Always inline antidebug_rlimit_set_zero_core for the same reasons as
 * check_traced() above.
 */
static inline void __attribute__((always_inline))
antidebug_rlimit_set_zero_core()
{
#ifdef NO_ANTIDEBUG
  return;
#endif

  struct rlimit limit;
  limit.rlim_cur = 0;
  limit.rlim_max = 0;
  int ret = sys_setrlimit(RLIMIT_CORE, &limit);
  DIE_IF_FMT(ret != 0, "rlimit(RLIMIT_CORE, {0, 0}) failed with %d", ret);
}

void antidebug_signal_init();
void antidebug_prctl_set_nondumpable();
void antidebug_remove_ld_env_vars(void *entry_stacktop);

#endif /* __KITESHIELD_ANTI_DEBUG_H */


```

`loader/include/debug.h`:

```h
#ifndef __KITESHIELD_DEBUG_H
#define __KITESHIELD_DEBUG_H

#include <stdarg.h>
#include "loader/include/syscalls.h"

#define KITESHIELD_PREFIX "[kiteshield] "

/* Yes this would likely be simpler if ks_printf implemented a width specifier,
 * but introducing all that extra complexity to it just for this one use
 * (printing keys) isn't really of any value. Better to just special case it
 * here.
 */
#define STRINGIFY_KEY(key) \
  ({ char buf[(sizeof((key)->bytes) * 2) + 1]; \
     char *buf_ptr = buf; \
     for (int i = 0; i < KEY_SIZE; i++) { \
       uint8_t byte = (key)->bytes[i]; \
       if ((byte & 0xF0) == 0) { \
         (*buf_ptr++) = '0'; \
         itoa((key)->bytes[i], 0, buf_ptr, 8, 16); \
         buf_ptr ++; \
       } else { \
         itoa((key)->bytes[i], 0, buf_ptr, 8, 16); \
         buf_ptr += 2; \
       } \
     }; \
     buf[sizeof((key)->bytes) * 2] = '\0'; \
     buf; }) \

#ifdef DEBUG_OUTPUT
#define DEBUG(fmtstr) ks_printf(1, KITESHIELD_PREFIX fmtstr "\n")
#else
#define DEBUG(fmtstr) do {} while (0)
#endif

#ifdef DEBUG_OUTPUT
#define DEBUG_FMT(fmtstr, ...)                                                \
  ks_printf(1, KITESHIELD_PREFIX fmtstr "\n", __VA_ARGS__)
#else
#define DEBUG_FMT(fmtstr, ...) do {} while (0)
#endif

#ifdef DEBUG_OUTPUT
#define DIE(msg)                                                              \
  do {                                                                        \
    ks_printf(2, KITESHIELD_PREFIX "%s:%d " msg "\n",                    \
        __FILE__, __LINE__);                                                  \
    sys_exit(1);                                                              \
  } while (0)
#else
#define DIE(msg) sys_exit(0)
#endif

#ifdef DEBUG_OUTPUT
#define DIE_FMT(msg, ...)                                                     \
  do {                                                                        \
    ks_printf(2, KITESHIELD_PREFIX "%s:%d " msg "\n",                     \
        __FILE__, __LINE__, __VA_ARGS__);                                     \
    sys_exit(1);                                                              \
  } while (0)
#else
#define DIE_FMT(msg, ...)                                                     \
  do {                                                                        \
    sys_exit(0);                                                              \
  } while (0)
#endif

#ifdef DEBUG_OUTPUT
#define DIE_IF(cond, msg)                                                     \
  do {                                                                        \
    if (cond) {                                                               \
      ks_printf(2, KITESHIELD_PREFIX "%s:%d " msg "\n",                  \
          __FILE__, __LINE__);                                                \
      sys_exit(1);                                                            \
    }                                                                         \
  } while (0)
#else
#define DIE_IF(cond, msg)                                                     \
  do {                                                                        \
    if (cond) {                                                               \
      sys_exit(0);                                                            \
    }                                                                         \
  } while (0)
#endif

#ifdef DEBUG_OUTPUT
#define DIE_IF_FMT(cond, msg, ...)                                            \
  do {                                                                        \
    if (cond) {                                                               \
      ks_printf(2, KITESHIELD_PREFIX "%s:%d " msg "\n",                  \
          __FILE__, __LINE__, __VA_ARGS__);                                   \
      sys_exit(1);                                                            \
    }                                                                         \
  } while (0)
#else
#define DIE_IF_FMT(cond, msg, ...)                                            \
  do {                                                                        \
    if (cond) {                                                               \
      sys_exit(0);                                                            \
    }                                                                         \
  } while (0)
#endif

void ks_printf(int fd, const char *format, ...);

#endif /* __KITESHIELD_DEBUG_H */

```

`loader/include/elf_auxv.h`:

```h
#ifndef __KITESHIELD_ELF_AUXV_H
#define __KITESHIELD_ELF_AUXV_H

#define AT_NULL   0 /* end of vector */
#define AT_IGNORE 1 /* entry should be ignored */
#define AT_EXECFD 2 /* file descriptor of program */
#define AT_PHDR   3 /* program headers for program */
#define AT_PHENT  4 /* size of program header entry */
#define AT_PHNUM  5 /* number of program headers */
#define AT_PAGESZ 6 /* system page size */
#define AT_BASE   7 /* base address of interpreter */
#define AT_FLAGS  8 /* flags */
#define AT_ENTRY  9 /* entry point of program */
#define AT_NOTELF 10 /* program is not ELF */
#define AT_UID    11 /* real uid */
#define AT_EUID   12 /* effective uid */
#define AT_GID    13 /* real gid */
#define AT_EGID   14 /* effective gid */
#define AT_PLATFORM 15 /* string identifying CPU for optimizations */
#define AT_HWCAP  16 /* arch dependent hints at CPU capabilities */
#define AT_CLKTCK 17 /* frequency at which times() increments */

/* AT_* values 18 through 22 are reserved */
#define AT_SECURE 23 /* secure mode boolean */
#define AT_BASE_PLATFORM 24 /* string identifying real platform, may differ from AT_PLATFORM. */
#define AT_RANDOM 25 /* address of 16 random bytes */
#define AT_HWCAP2 26 /* extension of AT_HWCAP */
#define AT_EXECFN  31 /* filename of program */

#endif /* __KITESHIELD_ELF_AUXV_H */

```

`loader/include/errno.h`:

```h
#ifndef __KITESHIELD_ERRNO_H
#define __KITESHIELD_ERRNO_H

#define EPERM   1  /* Operation not permitted */
#define ENOENT  2  /* No such file or directory */
#define ESRCH   3  /* No such process */
#define EINTR   4  /* Interrupted system call */
#define EIO     5  /* I/O error */
#define ENXIO   6  /* No such device or address */
#define E2BIG   7  /* Argument list too long */
#define ENOEXEC 8  /* Exec format error */
#define EBADF   9  /* Bad file number */
#define ECHILD  10 /* No child processes */
#define EAGAIN  11 /* Try again */
#define ENOMEM  12 /* Out of memory */
#define EACCES  13 /* Permission denied */
#define EFAULT  14 /* Bad address */
#define ENOTBLK 15 /* Block device required */
#define EBUSY   16 /* Device or resource busy */
#define EEXIST  17 /* File exists */
#define EXDEV   18 /* Cross-device link */
#define ENODEV  19 /* No such device */
#define ENOTDIR 20 /* Not a directory */
#define EISDIR  21 /* Is a directory */
#define EINVAL  22 /* Invalid argument */
#define ENFILE  23 /* File table overflow */
#define EMFILE  24 /* Too many open files */
#define ENOTTY  25 /* Not a typewriter */
#define ETXTBSY 26 /* Text file busy */
#define EFBIG   27 /* File too large */
#define ENOSPC  28 /* No space left on device */
#define ESPIPE  29 /* Illegal seek */
#define EROFS   30 /* Read-only file system */
#define EMLINK  31 /* Too many links */
#define EPIPE   32 /* Broken pipe */
#define EDOM    33 /* Math argument out of domain of func */
#define ERANGE  34 /* Math result not representable */

#endif /* __KITESHIELD_ERRNO_H */

```

`loader/include/malloc.h`:

```h
#ifndef __KITESHIELD_MALLOC_H
#define __KITESHIELD_MALLOC_H

#include <stddef.h>

void ks_malloc_init();
void ks_malloc_deinit();

void *ks_malloc(size_t size);
void ks_free(void *ptr);

int ks_malloc_get_n_blocks();

#endif /* __KITESHIELD_MALLOC_H */

```

`loader/include/signal.h`:

```h
#ifndef __KITESHIELD_SIGNAL_H
#define __KITESHIELD_SIGNAL_H

#define SIGHUP                 1
#define SIGINT                 2
#define SIGQUIT                3
#define SIGILL                 4
#define SIGTRAP                5
#define SIGABRT                6
#define SIGIOT                 6
#define SIGBUS                 7
#define SIGFPE                 8
#define SIGKILL                9
#define SIGUSR1                10
#define SIGSEGV                11
#define SIGUSR2                12
#define SIGPIPE                13
#define SIGALRM                14
#define SIGTERM                15
#define SIGSTKFLT              16
#define SIGCHLD                17
#define SIGCONT                18
#define SIGSTOP                19
#define SIGTSTP                20
#define SIGTTIN                21
#define SIGTTOU                22
#define SIGURG                 23
#define SIGXCPU                24
#define SIGXFSZ                25
#define SIGVTALRM              26
#define SIGPROF                27
#define SIGWINCH               28
#define SIGIO                  29
#define SIGPOLL                SIGIO
#define SIGPWR                 30
#define SIGSYS                 31

#endif /* __KITESHIELD_SIGNAL_H */

```

`loader/include/string.h`:

```h
#ifndef __KITESHIELD_STRING_H
#define __KITESHIELD_STRING_H

#include "loader/include/types.h"

void ks_vsnprintf(
    char *str,
    size_t size,
    const char *format,
    va_list vl);

void ks_snprintf(
    char *str,
    size_t size,
    const char *format,
    ...);

void ks_printf(
    int fd,
    const char *format,
    ...);

size_t strnlen(
    const char *s,
    size_t maxlen);

void itoa(
    unsigned long val,
    int is_signed,
    char *buf,
    int bitwidth,
    int radix);

char *strncpy(
    char *dest,
    const char *src,
    size_t n);

char *strncat(
    char *dest,
    const char *src,
    size_t n);

int strncmp(
    const char *s1,
    const char *s2,
    size_t n);

void *memcpy(
    void *dest,
    const void *src,
    size_t n);

void *memset(
    void *s,
    int c,
    size_t n);

#endif /* __KITESHIELD_STRING_H */

```

`loader/include/syscalls.h`:

```h
#ifndef __KITESHIELD_SYSCALLS_H
#define __KITESHIELD_SYSCALLS_H

/* System call constants/defines and wrapper function prototypes.
 *
 * All of the sys_* functions are very lightweight wrappers around the
 * kernel-level syscall interface. Importantly, they expose the *raw* kernel
 * interface, and thus differ from the wrappers in glibc (eg. open(2),
 * read(2)). Often the interface exposed by glibc is the same as the raw kernel
 * interface, but sometimes it differs (eg. ptrace). These functions have the
 * sys_* prefix to emphasize that fact.
 */

#include <stdint.h>
#include "loader/include/types.h"

/* mmap syscall constants/defines */
#define MAP_SHARED 0x01
#define MAP_PRIVATE 0x02
#define MAP_ANONYMOUS 0x20
#define MAP_FIXED 0x10

#define PROT_READ 0x1
#define PROT_WRITE 0x2
#define PROT_EXEC 0x4
#define PROT_NONE 0x0

/* open syscall constants/defines */
#define O_RDONLY 00
#define O_WRONLY 01
#define O_RDWR 02

/* lseek syscall constants/defines */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

/* ptrace syscall constants/defines */
enum __ptrace_request {
  PTRACE_TRACEME = 0,
  PTRACE_PEEKTEXT = 1,
  PTRACE_PEEKDATA = 2,
  PTRACE_PEEKUSER = 3,
  PTRACE_POKETEXT = 4,
  PTRACE_POKEDATA = 5,
  PTRACE_POKEUSER = 6,
  PTRACE_CONT = 7,
  PTRACE_KILL = 8,
  PTRACE_SINGLESTEP = 9,
  PTRACE_GETREGS = 12,
  PTRACE_SETREGS = 13,
  PTRACE_GETFPREGS = 14,
  PTRACE_SETFPREGS = 15,
  PTRACE_ATTACH = 16,
  PTRACE_DETACH = 17,
  PTRACE_GETFPXREGS = 18,
  PTRACE_SETFPXREGS = 19,
  PTRACE_SYSCALL = 24,
  PTRACE_GET_THREAD_AREA = 25,
  PTRACE_SET_THREAD_AREA = 26,
  PTRACE_ARCH_PRCTL = 30,
  PTRACE_SYSEMU = 31,
  PTRACE_SYSEMU_SINGLESTEP = 32,
  PTRACE_SINGLEBLOCK = 33,
  PTRACE_SETOPTIONS = 0x4200,
  PTRACE_GETEVENTMSG = 0x4201,
  PTRACE_GETSIGINFO = 0x4202,
  PTRACE_SETSIGINFO = 0x4203,
  PTRACE_GETREGSET = 0x4204,
  PTRACE_SETREGSET = 0x4205,
  PTRACE_SEIZE = 0x4206,
  PTRACE_INTERRUPT = 0x4207,
  PTRACE_LISTEN = 0x4208,
  PTRACE_PEEKSIGINFO = 0x4209,
  PTRACE_GETSIGMASK = 0x420a,
  PTRACE_SETSIGMASK = 0x420b,
  PTRACE_SECCOMP_GET_FILTER = 0x420c,
  PTRACE_SECCOMP_GET_METADATA = 0x420c
};

enum __ptrace_setoptions {
  PTRACE_O_TRACESYSGOOD = 0x00000001,
  PTRACE_O_TRACEFORK = 0x00000002,
  PTRACE_O_TRACEVFORK = 0x00000004,
  PTRACE_O_TRACECLONE = 0x00000008,
  PTRACE_O_TRACEEXEC = 0x00000010,
  PTRACE_O_TRACEVFORKDONE = 0x00000020,
  PTRACE_O_TRACEEXIT = 0x00000040,
  PTRACE_O_TRACESECCOMP = 0x00000080,
  PTRACE_O_EXITKILL = 0x00100000,
  PTRACE_O_SUSPEND_SECCOMP = 0x00200000,
  PTRACE_O_MASK  = 0x003000ff
};

enum __ptrace_eventcodes {
  PTRACE_EVENT_FORK = 1,
  PTRACE_EVENT_VFORK = 2,
  PTRACE_EVENT_CLONE = 3,
  PTRACE_EVENT_EXEC = 4,
  PTRACE_EVENT_VFORK_DONE = 5,
  PTRACE_EVENT_EXIT = 6,
  PTRACE_EVENT_SECCOMP  = 7,
  PTRACE_EVENT_STOP = 128
};

struct __ptrace_peeksiginfo_args {
  uint64_t off;
  uint32_t flags;
  int32_t nr;
};

enum __ptrace_peeksiginfo_flags {
  PTRACE_PEEKSIGINFO_SHARED = (1 << 0)
};

struct __ptrace_seccomp_metadata {
  uint64_t filter_off;
  uint64_t flags;
};

/* Defined in kernel headers, needed for PTRACE_GETREGS */
struct user_regs_struct {
  unsigned long r15;
  unsigned long r14;
  unsigned long r13;
  unsigned long r12;
  unsigned long bp;
  unsigned long bx;
  unsigned long r11;
  unsigned long r10;
  unsigned long r9;
  unsigned long r8;
  unsigned long ax;
  unsigned long cx;
  unsigned long dx;
  unsigned long si;
  unsigned long di;
  unsigned long orig_ax;
  unsigned long ip;
  unsigned long cs;
  unsigned long flags;
  unsigned long sp;
  unsigned long ss;
  unsigned long fs_base;
  unsigned long gs_base;
  unsigned long ds;
  unsigned long es;
  unsigned long fs;
  unsigned long gs;
};

/* wait4 syscall constants/defines */
#define WEXITSTATUS(status) (((status) & 0xff00) >> 8)
#define WTERMSIG(status) ((status) & 0x7f)
#define WSTOPSIG(status) WEXITSTATUS(status)
#define WIFEXITED(status) (WTERMSIG(status) == 0)
#define WIFSIGNALED(status) \
  (((signed char) (((status) & 0x7f) + 1) >> 1) > 0)
#define WIFSTOPPED(status) (((status) & 0xff) == 0x7f)
#ifdef WCONTINUED
# define WIFCONTINUED(status) ((status) == W_CONTINUED)
#endif

#define WNOHANG		0x00000001
#define WUNTRACED	0x00000002
#define WSTOPPED	WUNTRACED
#define WEXITED		0x00000004
#define WCONTINUED	0x00000008
#define WNOWAIT		0x01000000

#define __WNOTHREAD	0x20000000
#define __WALL		0x40000000
#define __WCLONE	0x80000000

/* rt_sigaction syscall constants/defines */
struct kernel_sigaction {
  void (*sa_handler)(int);
  unsigned long sa_flags;
  void (*sa_restorer)(void);
  unsigned long sa_mask;
};

#define SA_NOCLDSTOP	0x00000001u
#define SA_NOCLDWAIT	0x00000002u
#define SA_SIGINFO	0x00000004u
#define SA_ONSTACK	0x08000000u
#define SA_RESTART	0x10000000u
#define SA_NODEFER	0x40000000u
#define SA_RESETHAND	0x80000000u

#define SA_NOMASK	SA_NODEFER
#define SA_ONESHOT	SA_RESETHAND

#define SA_RESTORER	0x04000000

/* prctl constants/defines */
#define PR_GET_DUMPABLE   3
#define PR_SET_DUMPABLE   4

/* stat constants/defines */
struct stat {
	unsigned long long	st_dev;
	unsigned char	__pad0[4];

	unsigned long	__st_ino;

	unsigned int	st_mode;
	unsigned int	st_nlink;

	unsigned long	st_uid;
	unsigned long	st_gid;

	unsigned long long	st_rdev;
	unsigned char	__pad3[4];

	long long	st_size;
	unsigned long	st_blksize;

	unsigned long long	st_blocks;

	unsigned long	st_atime;
	unsigned long	st_atime_nsec;

	unsigned long	st_mtime;
	unsigned int	st_mtime_nsec;

	unsigned long	st_ctime;
	unsigned long	st_ctime_nsec;

	unsigned long long	st_ino;
};

/* setrlimit constants/defines */
typedef unsigned long rlim_t;
struct rlimit {
  rlim_t rlim_cur;
  rlim_t rlim_max;
};

/* Kinds of resource limit.  */
enum rlimit_resource {
  RLIMIT_CPU = 0,
  RLIMIT_FSIZE = 1,
  RLIMIT_DATA = 2,
  RLIMIT_STACK = 3,
  RLIMIT_CORE = 4,
  RLIMIT_RSS = 5,
  RLIMIT_NOFILE = 7,
  RLIMIT_AS = 9,
  RLIMIT_NPROC = 6,
  RLIMIT_MEMLOCK = 8,
  RLIMIT_LOCKS = 10,
  RLIMIT_SIGPENDING = 11,
  RLIMIT_MSGQUEUE = 12,
  RLIMIT_NICE = 13,
  RLIMIT_RTPRIO = 14,
  RLIMIT_RTTIME = 15,
};

/* clone constants/defines */
#define CSIGNAL              0x000000ff
#define CLONE_VM             0x00000100
#define CLONE_FS             0x00000200
#define CLONE_FILES          0x00000400
#define CLONE_SIGHAND        0x00000800
#define CLONE_PTRACE         0x00002000
#define CLONE_VFORK          0x00004000
#define CLONE_PARENT         0x00008000
#define CLONE_THREAD         0x00010000
#define CLONE_NEWNS          0x00020000
#define CLONE_SYSVSEM        0x00040000
#define CLONE_SETTLS         0x00080000
#define CLONE_PARENT_SETTID  0x00100000
#define CLONE_CHILD_CLEARTID 0x00200000
#define CLONE_DETACHED       0x00400000
#define CLONE_UNTRACED       0x00800000
#define CLONE_CHILD_SETTID   0x01000000
#define CLONE_NEWCGROUP      0x02000000
#define CLONE_NEWUTS         0x04000000
#define CLONE_NEWIPC         0x08000000
#define CLONE_NEWUSER        0x10000000
#define CLONE_NEWPID         0x20000000
#define CLONE_NEWNET         0x40000000
#define CLONE_IO             0x80000000

/* syscall wrapper prototypes */
ssize_t sys_write(
    int fd,
    const char *s,
    size_t count);

ssize_t sys_read(
    int fd,
    void *buf,
    size_t count);

off_t sys_lseek(
    int fd,
    off_t offset,
    int whence);

int sys_open(
    const char *pathname,
    int flags,
    int mode);

int sys_close(
    int fd);

void sys_exit(
    int status) __attribute__((noreturn));

void *sys_mmap(
    void *addr,
    size_t length,
    int prot,
    int flags,
    int fd,
    off_t offset);

int sys_munmap(
    void *addr,
    size_t length);

int sys_mprotect(
    void *addr,
    size_t len,
    int prot);

long sys_ptrace(
    enum __ptrace_request,
    pid_t pid,
    void *addr,
    void *data);

pid_t sys_wait4(
    pid_t pid,
    int *wstatus,
    int options);

pid_t sys_fork();

int sys_kill(
    pid_t pid,
    int sig);

int sys_tgkill(
    pid_t tgid,
    pid_t tid,
    int sig);

pid_t sys_getpid();

int sys_rt_sigaction(
    int sig,
    const struct kernel_sigaction *act,
    const struct kernel_sigaction *oact);

int sys_prctl(
    int option,
    unsigned long arg2,
    unsigned long arg3,
    unsigned long arg4,
    unsigned long arg5);

int sys_stat(
    const char *pathname,
    struct stat *statbuf);

int sys_setrlimit(
    int resource,
    struct rlimit *rlim);

#endif /* __KITESHIELD_SYSCALLS_H */


```

`loader/include/types.h`:

```h
#ifndef __KITESHIELD_TYPES_H
#define __KITESHIELD_TYPES_H

/* Gets us NULL and size_t
 * (use of a system header is ok here as this a a freestanding header) */
#include <stddef.h>

typedef signed long long ssize_t;
typedef unsigned long long off_t;
typedef int pid_t;

#endif /* __KITESHIELD_TYPES_H */


```

`loader/link.lds`:

```lds
OUTPUT_FORMAT("elf64-x86-64")
OUTPUT_ARCH(i386:x86-64)
ENTRY(_start)

SECTIONS
{
  /* Base address the loader code is found at (ie. LOADER_ADDR, see
   * common/include/defs.h) *plus* sizeof(Elf64_Ehdr) + 2 * sizeof(Elf64_Phdr).
   * (as the first segment will include one ehdr and a phdr for both the loader
   * and packed binary). Note that if this address is changed, LOADER_ADDR must
   * be updated accordingly.
   */
  . = 0x2000b0;
  .key : {
    *loader.o(.key)
  }
  .text : {
    *entry.o(.text)
    *loader.o(.text)
    *runtime.o(.text)
    *key_utils.o(.text)
  }
  .bss : {
    *(.bss)
  }
  .data : {
    *(.data)
  }
  .tp_info : {
    *runtime.o(.tp_info)
  }
}


```

`loader/loader.c`:

```c
#include <elf.h>

#include "common/include/defs.h"
#include "common/include/rc4.h"
#include "common/include/obfuscation.h"

#include "loader/include/types.h"
#include "loader/include/debug.h"
#include "loader/include/elf_auxv.h"
#include "loader/include/syscalls.h"
#include "loader/include/anti_debug.h"

#define PAGE_SHIFT 12
#define PAGE_SIZE (1 << PAGE_SHIFT)
#define PAGE_MASK (~0 << PAGE_SHIFT)

#define PAGE_ALIGN_DOWN(ptr) ((ptr) & PAGE_MASK)
#define PAGE_ALIGN_UP(ptr) ((((ptr) - 1) & PAGE_MASK) + PAGE_SIZE)
#define PAGE_OFFSET(ptr) ((ptr) & ~(PAGE_MASK))

struct rc4_key obfuscated_key __attribute__((section(".key")));

static void *map_load_section_from_mem(void *elf_start, Elf64_Phdr phdr)
{
  uint64_t base_addr = ((Elf64_Ehdr *) elf_start)->e_type == ET_DYN ?
                       DYN_PROG_BASE_ADDR : 0;

  /* Same rounding logic as in map_load_section_from_fd, see comment below.
   * Note that we don't need a separate mmap here for bss if memsz > filesz
   * as we map an anonymous region and copy into it rather than mapping from
   * an fd (ie. we can just not touch the remaining space and it will be full
   * of zeros by default).
   */
  void *addr = sys_mmap((void *) (base_addr + PAGE_ALIGN_DOWN(phdr.p_vaddr)),
                        phdr.p_memsz + PAGE_OFFSET(phdr.p_vaddr),
                        PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  DIE_IF((long) addr < 0, "mmap failure");
  DEBUG_FMT("mapping LOAD section from packed binary at %p", addr);

  /* Copy data from the packed binary */
  char *curr_addr = addr;
  for (Elf64_Off f_off = PAGE_ALIGN_DOWN(phdr.p_offset);
       f_off < phdr.p_offset + phdr.p_filesz;
       f_off++) {
    (*curr_addr++) = *((char *) elf_start + f_off);
  }

  /* Set correct permissions (change from -w-) */
  int prot = (phdr.p_flags & PF_R ? PROT_READ : 0)  |
             (phdr.p_flags & PF_W ? PROT_WRITE : 0) |
             (phdr.p_flags & PF_X ? PROT_EXEC : 0);
  DIE_IF(
      sys_mprotect(addr, phdr.p_memsz + PAGE_OFFSET(phdr.p_vaddr), prot) < 0,
      "mprotect error");
  return addr;
}

static void *map_load_section_from_fd(int fd, Elf64_Phdr phdr, int absolute)
{
  int prot = 0;
  if (phdr.p_flags & PF_R)
    prot |= PROT_READ;
  if (phdr.p_flags & PF_W)
    prot |= PROT_WRITE;
  if (phdr.p_flags & PF_X)
    prot |= PROT_EXEC;

  uint64_t base_addr = absolute ? 0 : DYN_INTERP_BASE_ADDR;

  /* mmap requires that the addr and offset fields are multiples of the page
   * size. Since that may not be the case for the p_vaddr and p_offset fields
   * in an ELF binary, we have to do some math to ensure the passed in
   * address/offset are multiples of the page size.
   *
   * To calculate the load address, we start at the interpreter base address
   * (which is a multiple of the page size itself), and add p_vaddr rounded
   * down to the nearest page size multiple. We round down the offset parameter
   * to the nearest page size multiple in the same way. Since both the offset
   * and virtual address are guaranteed to be congruent modulo the page size
   * (as per the ELF standard), this will result in them both being rounded
   * down by the same amount, and the produced mapping will be correct.
   */
  void *addr = sys_mmap((void *) (base_addr + PAGE_ALIGN_DOWN(phdr.p_vaddr)),
                        phdr.p_filesz + PAGE_OFFSET(phdr.p_vaddr),
                        prot,
                        MAP_PRIVATE | MAP_FIXED,
                        fd,
                        PAGE_ALIGN_DOWN(phdr.p_offset));
  DIE_IF((long) addr < 0,
         "mmap failure while mapping load section from fd");

  /* If p_memsz > p_filesz, the remaining space must be filled with zeros
   * (Usually the .bss section), map extra anon pages if this is the case. */
  if (phdr.p_memsz > phdr.p_filesz) {
    /* Unless the segment mapped above falls perfectly on a page boundary,
     * we've mapped some .bss already by virtue of the fact that mmap will
     * round the size of our mapping up to a page boundary. Subtract that
     * already mapped bss from the extra space we have to allocate */

    /* Page size minus amount of space occupied in the last page of the above
     * mapping by the file */
    size_t bss_already_mapped =
      PAGE_SIZE - PAGE_OFFSET(phdr.p_vaddr + phdr.p_filesz);
    void *extra_pages_start =
      (void *) PAGE_ALIGN_UP(base_addr + phdr.p_vaddr + phdr.p_filesz);

    if (bss_already_mapped < (phdr.p_memsz - phdr.p_filesz)) {
      size_t extra_space_needed =
        (size_t) (phdr.p_memsz - phdr.p_filesz) - bss_already_mapped;

      void *extra_space = sys_mmap(extra_pages_start,
                                   extra_space_needed,
                                   prot,
                                   MAP_PRIVATE | MAP_FIXED | MAP_ANONYMOUS,
                                   -1, 0);

      DIE_IF((long) extra_space < 0,
             "mmap failure while mapping extra space for static vars");

      DEBUG_FMT("mapped extra space for static data (.bss) at %p len %u",
                extra_space, extra_space_needed);
    }

    /* While any extra pages mapped will be zeroed by default, this is not the
     * case for the part of the original page corresponding to
     * bss_already_mapped (it will contain junk from the file) so we zero it
     * here.  */
    uint8_t *bss_ptr = (uint8_t *) (base_addr + phdr.p_vaddr + phdr.p_filesz);
    if (!(prot & PROT_WRITE)) {
      DIE_IF(
          sys_mprotect(bss_ptr, bss_already_mapped, PROT_WRITE) < 0,
          "mprotect error");
    }

    for (size_t i = 0; i < bss_already_mapped; i++)
      *(bss_ptr + i) = 0;

    if (!(prot & PROT_WRITE)) {
      DIE_IF(
          sys_mprotect(bss_ptr, bss_already_mapped, prot) < 0,
          "mprotect error");
    }
  }

  DEBUG_FMT("mapped LOAD section from fd at %p", addr);
  return addr;
}

static void map_interp(void *path, void **entry, void **interp_base)
{
  DEBUG_FMT("mapping INTERP ELF at path %s", path);
  int interp_fd = sys_open(path, O_RDONLY, 0);
  DIE_IF(interp_fd < 0, "could not open interpreter binary");

  Elf64_Ehdr ehdr;
  DIE_IF(sys_read(interp_fd, &ehdr, sizeof(ehdr)) < 0,
         "read failure while reading interpreter binary header");

  *entry = ehdr.e_type == ET_EXEC ?
      (void *) ehdr.e_entry : (void *) (DYN_INTERP_BASE_ADDR + ehdr.e_entry);
  int base_addr_set = 0;
  for (int i = 0; i < ehdr.e_phnum; i++) {
    Elf64_Phdr curr_phdr;

    off_t lseek_res = sys_lseek(interp_fd,
                                ehdr.e_phoff + i * sizeof(Elf64_Phdr),
                                SEEK_SET);
    DIE_IF(lseek_res < 0, "lseek failure while mapping interpreter");

    size_t read_res = sys_read(interp_fd, &curr_phdr, sizeof(curr_phdr));
    DIE_IF(read_res < 0, "read failure while mapping interpreter");

    /* We shouldn't be dealing with any non PT_LOAD segments here */
    if (curr_phdr.p_type != PT_LOAD)
      continue;

    void *addr = map_load_section_from_fd(interp_fd, curr_phdr,
          ehdr.e_type == ET_EXEC);

    if (!base_addr_set){
      DEBUG_FMT("interpreter base address is %p", addr);
      *interp_base = addr;
      base_addr_set = 1;
    }
  }

  DIE_IF(sys_close(interp_fd) < 0, "could not close interpreter binary");
}

static void *map_elf_from_mem(
    void *elf_start,
    void **interp_entry,
    void **interp_base)
{
  Elf64_Ehdr *ehdr = (Elf64_Ehdr *) elf_start;

  int load_addr_set = 0;
  void *load_addr = NULL;

  Elf64_Phdr *curr_phdr = elf_start + ehdr->e_phoff;
  Elf64_Phdr *interp_hdr = NULL;
  for (int i = 0; i < ehdr->e_phnum; i++) {
    void *seg_addr = NULL;

    if (curr_phdr->p_type == PT_LOAD)
      seg_addr = map_load_section_from_mem(elf_start, *curr_phdr);
    else if (curr_phdr->p_type == PT_INTERP)
      interp_hdr = curr_phdr;

    if (!load_addr_set && seg_addr != NULL) {
      load_addr = seg_addr;
      load_addr_set = 1;
    }

    curr_phdr++;
  }

  if (interp_hdr) {
    map_interp(elf_start + interp_hdr->p_offset, interp_entry, interp_base);
  } else {
    *interp_base = NULL;
    *interp_entry = NULL;
  }

  return load_addr;
}

static void replace_auxv_ent(unsigned long long *auxv_start,
                             unsigned long long label,
                             unsigned long long value)
{
  unsigned long long *curr_ent = auxv_start;
  while (*curr_ent != label && *curr_ent != AT_NULL) curr_ent += 2;
  DIE_IF_FMT(*curr_ent == AT_NULL, "could not find auxv entry %d", label);

  *(++curr_ent) = value;
  DEBUG_FMT("replaced auxv entry %llu with value %llu (0x%p)", label, value,
            value);
}

static void setup_auxv(
    void *argv_start,
    void *entry,
    void *phdr_addr,
    void *interp_base,
    unsigned long long phnum)
{
  unsigned long long *auxv_start = argv_start;

#define ADVANCE_PAST_NEXT_NULL(ptr) \
  while (*(++ptr) != 0) ;           \
  ptr++;

  ADVANCE_PAST_NEXT_NULL(auxv_start) /* argv */
  ADVANCE_PAST_NEXT_NULL(auxv_start) /* envp */

  DEBUG_FMT("taking %p as auxv start", auxv_start);
  replace_auxv_ent(auxv_start, AT_ENTRY, (unsigned long long) entry);
  replace_auxv_ent(auxv_start, AT_PHDR, (unsigned long long) phdr_addr);
  replace_auxv_ent(auxv_start, AT_BASE, (unsigned long long) interp_base);
  replace_auxv_ent(auxv_start, AT_PHNUM, phnum);
}

static void decrypt_packed_bin(
    void *packed_bin_start,
    size_t packed_bin_size,
    struct rc4_key *key)
{
  struct rc4_state rc4;
  rc4_init(&rc4, key->bytes, sizeof(key->bytes));

  DEBUG_FMT("RC4 decrypting binary with key %s", STRINGIFY_KEY(key));

  unsigned char *curr = packed_bin_start;
  for (int i = 0; i < packed_bin_size; i++) {
    *curr = *curr ^ rc4_get_byte(&rc4);
    curr++;
  }

  DEBUG_FMT("decrypted %u bytes", packed_bin_size);
}

/* Convenience wrapper around obf_deobf_outer_key to automatically pass in
 * correct loader code offsets. */
void loader_outer_key_deobfuscate(
    struct rc4_key *old_key,
    struct rc4_key *new_key)
{
  /* "our" EHDR (ie. the one in the on-disk binary that was run) */
  Elf64_Ehdr *us_ehdr = (Elf64_Ehdr *) LOADER_ADDR;

  /* The PHDR in our binary corresponding to the loader (ie. this code) */
  Elf64_Phdr *loader_phdr = (Elf64_Phdr *)
                            (LOADER_ADDR + us_ehdr->e_phoff);

  /* The first ELF segment (loader code) includes the ehdr and two phdrs,
   * adjust loader code start and size accordingly */
  size_t hdr_adjust = sizeof(Elf64_Ehdr) + (2 * sizeof(Elf64_Phdr));

  void *loader_start = (void *) loader_phdr->p_vaddr + hdr_adjust;
  size_t loader_size = loader_phdr->p_memsz - hdr_adjust;

  obf_deobf_outer_key(old_key, new_key, loader_start, loader_size);
}

/* Load the packed binary, returns the address to hand control to when done */
void *load(void *entry_stacktop)
{
  if (antidebug_proc_check_traced())
    DIE(TRACED_MSG);

  antidebug_remove_ld_env_vars(entry_stacktop);

  /* Disable core dumps via rlimit here before we start doing sensitive stuff
   * like key deobfuscation and binary decryption. Child process should
   * inherit these limits after the fork, although it wouldn't hurt to call
   * this again post-fork just in case this inlined call is patched out. */
  antidebug_rlimit_set_zero_core();

  /* As per the SVr4 ABI */
  /* int argc = (int) *((unsigned long long *) entry_stacktop); */
  char **argv = ((char **) entry_stacktop) + 1;

  /* "our" EHDR (ie. the one in the on-disk binary that was run) */
  Elf64_Ehdr *us_ehdr = (Elf64_Ehdr *) LOADER_ADDR;

  /* The PHDR in our binary corresponding to the loader (ie. this code) */
  Elf64_Phdr *loader_phdr = (Elf64_Phdr *)
                            (LOADER_ADDR + us_ehdr->e_phoff);

  /* The PHDR in our binary corresponding to the encrypted app */
  Elf64_Phdr *packed_bin_phdr = loader_phdr + 1;

  /* The EHDR of the actual application to be run (encrypted until
   * decrypt_packed_bin is called)
   */
  Elf64_Ehdr *packed_bin_ehdr = (Elf64_Ehdr *) (packed_bin_phdr->p_vaddr);

  struct rc4_key actual_key;
  loader_outer_key_deobfuscate(&obfuscated_key, &actual_key);

  decrypt_packed_bin((void *) packed_bin_phdr->p_vaddr,
                     packed_bin_phdr->p_memsz,
                     &actual_key);


  /* Entry point for ld.so if this is a statically linked binary, otherwise
   * map_elf_from_mem will not touch this and it will be set below. */
  void *interp_entry = NULL;
  void *interp_base = NULL;
  void *load_addr = map_elf_from_mem(packed_bin_ehdr, &interp_entry, &interp_base);
  DEBUG_FMT("binary base address is %p", load_addr);

  void *program_entry = packed_bin_ehdr->e_type == ET_EXEC ?
               (void *) packed_bin_ehdr->e_entry : load_addr + packed_bin_ehdr->e_entry;
  setup_auxv(argv,
             program_entry,
             (void *) (load_addr + packed_bin_ehdr->e_phoff),
             interp_base,
             packed_bin_ehdr->e_phnum);

  DEBUG("finished mapping binary into memory");

  /* load returns the initial address entry code should jump to. If we have a
   * dynamic linker, this is its entry address, otherwise, it's the address
   * specified in the binary itself.
   */
  void *initial_entry = interp_entry == NULL ? program_entry : interp_entry;
  DEBUG_FMT("control will be passed to packed app at %p", initial_entry);
  return initial_entry;
}


```

`loader/malloc.c`:

```c
#include "loader/include/malloc.h"
#include "loader/include/debug.h"
#include "loader/include/syscalls.h"

/* 20 MiB */
#define HEAP_SIZE (1 << 20)

void *heap_base = NULL;

struct block {
  size_t size;
  int in_use;
  struct block *next;
  struct block *prev;
};

void ks_malloc_init()
{
  heap_base = sys_mmap(NULL,
      HEAP_SIZE,
      PROT_READ | PROT_WRITE,
      MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  DIE_IF_FMT((long) heap_base < 0, "mmap failure %d", heap_base);

  struct block *first = heap_base;
  first->size = HEAP_SIZE - sizeof(struct block);
  first->in_use = 0;
  first->next = NULL;
  first->prev = NULL;
}

void ks_malloc_deinit()
{
  int ret = sys_munmap(heap_base, HEAP_SIZE);
  DIE_IF_FMT(ret < 0, "munmap failed with %d", ret);
}

static struct block *split_block(size_t size, struct block *victim)
{
  DIE_IF(victim->size < size + sizeof(struct block),
      "not enough room for block split");

  if (victim->size - size <= sizeof(struct block)) {
    /* Not enough space to fit another block in, just return the victim
     * without splitting */
    return victim;
  }

  struct block *new_block =
    (struct block *) (((char *) victim) + sizeof(struct block) + size);
  new_block->size = victim->size - size - sizeof(struct block);
  new_block->in_use = 0;
  new_block->next = victim->next;
  new_block->prev = victim;

  victim->size = size;

  if (victim->next)
    victim->next->prev = new_block;

  victim->next = new_block;

  return victim;
}

int ks_malloc_get_n_blocks()
{
  int n = 0;
  struct block *curr = heap_base;
  while (curr != NULL) {
    n++;
    curr = curr->next;
  }

  return n;
}

void *ks_malloc(size_t size)
{
  DIE_IF(size == 0, "malloc of size 0, likely loader bug");

  struct block *curr = heap_base;
  struct block *target = NULL;
  while (curr != NULL) {
    if (curr->in_use) {
      curr = curr->next;
      continue;
    }

    if (curr->size == size) {
      target = curr;
      break;
    }

    if (curr->size >= size + sizeof(struct block)) {
      target = split_block(size, curr);
      break;
    }

    curr = curr->next;
  }

  DIE_IF(!target, "out of heap memory");
  target->in_use = 1;

  return target + 1;
}

void ks_free(void *ptr)
{
  struct block *block = ((struct block *) ptr) - 1;
  block->in_use = 0;

  /* Coalesce back */
  if (block->prev && !block->prev->in_use) {
    block->prev->size += block->size + sizeof(struct block);
    block->prev->next = block->next;

    if (block->next)
      block->next->prev = block->prev;

    block = block->prev;
  }

  /* Coalesce forward */
  if (block->next && !block->next->in_use) {
    block->size += block->next->size + sizeof(struct block);
    block->next = block->next->next;

    if (block->next)
      block->next->prev = block;
  }
}

```

`loader/runtime.c`:

```c
#ifdef USE_RUNTIME

#include "common/include/defs.h"
#include "common/include/obfuscation.h"
#include "common/include/rc4.h"

#include "loader/include/errno.h"
#include "loader/include/types.h"
#include "loader/include/debug.h"
#include "loader/include/syscalls.h"
#include "loader/include/obfuscated_strings.h"
#include "loader/include/signal.h"
#include "loader/include/string.h"
#include "loader/include/malloc.h"
#include "loader/include/anti_debug.h"

/* See PTRACE_SETOPTIONS in ptrace manpage */
#define PTRACE_EVENT_PRESENT(wstatus, event) \
  ((wstatus) >> 8 == (SIGTRAP | (event) << 8))

#define FCN_ARR_START ((struct function *) (((struct trap_point *) rt_info.data) + rt_info.ntraps))
#define FCN_FROM_TP(tp) ((struct function *) (FCN_ARR_START + tp->fcn_i))

#define FCN_INC_REF(thread, fcn) \
  do { \
    ((thread)->as->fcn_ref_arr[(fcn)->id]++); \
  } while (0)

#define FCN_DEC_REF(thread, fcn) \
  do { \
    ((thread)->as->fcn_ref_arr[(fcn)->id]--); \
  } while(0)

#define FCN_ENTER(thread, fcn) \
  do { \
    bt_push(thread, fcn); \
    FCN_INC_REF(thread, fcn); \
  } while (0)

#define FCN_EXIT(thread, fcn) \
  do { \
    bt_pop(thread); \
    FCN_DEC_REF(thread, fcn); \
  } while (0)

#define FCN_REFCNT(thread, fcn) ((thread)->as->fcn_ref_arr[(fcn)->id])

struct runtime_info rt_info __attribute__((section(".rt_info")));

/* Allocated once per tg to store information common to a thread group. */
struct thread_group {
  pid_t tgid;
  int refcnt;
};

/* Function encryption data needs to be maintained per address space and not
 * per-thread as multiple threads could be executing in the same address space.
 */
struct address_space {
  int refcnt;

  /* Array of "reference counts" indexed by function id of functions in this
   * address space. When a thread enters a function, we bump its refcount and
   * when a thread leaves, we decrement it. Thus, a function's reference count
   * indicates the number of threads having it in their stack trace. When this
   * reaches 0, that indicates we can safely encrypt the function as no thread
   * will return to it in the future, expecting it to be decrypted.
   */
  uint64_t *fcn_ref_arr;
};

/* Structure used to keep track of the current backtrace of each thread. A
 * linked list of these is maintained in each thread context and on thread
 * exit, functions that are still in the thread's backtrace have their
 * reference counts decremented and are re-encrypted as needed.
 */
struct backtrace {
  struct function *fcn;
  struct backtrace *next;
};

/* Information about an executing thread of execution (ie. something created
 * via fork/vfork/clone. A linked list of these is maintained on kiteshield's
 * heap for every thread in existence.
 */
struct thread {
  pid_t tid;
  int has_wait_prio; /* See fair_wait_threads */
  struct backtrace *bt;
  struct address_space *as;
  struct thread_group *tg;
  struct thread *next;
};

struct thread_list {
  size_t size;
  struct thread *head;
};

struct trap_point *get_tp(uint64_t addr) {
  struct trap_point *arr = (struct trap_point *) rt_info.data;
  for (int i = 0; i < rt_info.ntraps; i++) {
    if (arr[i].addr == addr) {
      return &arr[i];
    }
  }

  return NULL;
}

static struct function *get_fcn_at_addr(uint64_t addr)
{
  struct function *arr = FCN_ARR_START;

  for (int i = 0; i < rt_info.nfuncs; i++) {
    struct function *curr = &arr[i];
    if (curr->start_addr <= addr && (curr->start_addr + curr->len) > addr)
      return curr;
  }

  return NULL;
}

static void set_byte_at_addr(pid_t tid, uint64_t addr, uint8_t value)
{
  long word;
  long res = sys_ptrace(PTRACE_PEEKTEXT, tid, (void *) addr, &word);
  DIE_IF_FMT(res != 0, "PTRACE_PEEKTEXT failed with error %d", res);

  word &= (~0) << 8;
  word |= value;

  res = sys_ptrace(PTRACE_POKETEXT, tid, (void *) addr, (void *) word);
  DIE_IF_FMT(res < 0, "PTRACE_POKETEXT failed with error %d", res);
}

static void single_step(pid_t tid)
{
  long res;
  int wstatus;

retry:
  res = sys_ptrace(PTRACE_SINGLESTEP, tid, NULL, NULL);
  DIE_IF_FMT(res < 0, "PTRACE_SINGLESTEP failed with error %d", res);
  sys_wait4(tid, &wstatus, __WALL);

  DIE_IF_FMT(tid < 0, "wait4 syscall failed with error %d", tid);
  DIE_IF_FMT(
      WIFEXITED(wstatus),
      "child exited with status %u during single step",
      WEXITSTATUS(wstatus));
  DIE_IF_FMT(
      WIFSIGNALED(wstatus),
      "child was killed by signal, %u during single step, exiting",
      WTERMSIG(wstatus));
  DIE_IF(
      !WIFSTOPPED(wstatus),
      "child was stopped unexpectedly during single step, exiting");

  if (WSTOPSIG(wstatus) == SIGSTOP) {
    /* stopped by runtime for concurrency purposes, there should be a SIGTRAP
     * in the queue next */
    goto retry;
  }

  DIE_IF_FMT(
      WSTOPSIG(wstatus) != SIGTRAP,
      "child was stopped by unexpected signal %u during single step, exiting",
      WSTOPSIG(wstatus));
}

static void rc4_xor_fcn(
    pid_t tid,
    struct function *fcn)
{
  struct rc4_state rc4;
  rc4_init(&rc4, fcn->key.bytes, sizeof(fcn->key.bytes));

  uint8_t *curr_addr = (uint8_t *) fcn->start_addr;
  size_t remaining = fcn->len;
  while (remaining > 0) {
    long word;
    long res = sys_ptrace(
        PTRACE_PEEKTEXT, tid, (void *) curr_addr, &word);
    DIE_IF_FMT(res != 0, "PTRACE_PEEKTEXT failed with error %d", res);

    int to_write = remaining > 8 ? 8 : remaining;
    for (int i = 0; i < to_write; i++) {
      word ^= ((long) rc4_get_byte(&rc4)) << (i * 8);
    }

    res = sys_ptrace(PTRACE_POKETEXT, tid, curr_addr, (void *) word);
    DIE_IF_FMT(res < 0, "PTRACE_POKETEXT failed with error %d", res);

    res = sys_ptrace(PTRACE_PEEKTEXT, tid, (void *) curr_addr, &word);
    DIE_IF_FMT(res != 0, "PTRACE_PEEKTEXT failed with error %d", res);

    curr_addr += to_write;
    remaining -= to_write;
  }
}

/* Pulls the third field out of /proc/<pid>/stat, which is a single character
 * representing process state Running, Sleeping, Zombie, etc. */
static char get_thread_state(
    pid_t tid)
{
  /* PROC_STAT_FMT = "/proc/%s/stat" */
  char proc_path[128];
  ks_snprintf(proc_path, sizeof(proc_path), DEOBF_STR(PROC_STAT_FMT), tid);

  int fd =  sys_open(proc_path, O_RDONLY, 0);
  DIE_IF_FMT(fd < 0, "could not open %s error %d", proc_path, fd);

  char buf[4096]; /* Should be enough to hold any /proc/<pid>/stat */
  int ret = sys_read(fd, buf, sizeof(buf) - 1);
  DIE_IF_FMT(ret < 0, "read failed with error %d", ret);
  buf[ret] = '\0';
  sys_close(fd);

  int spaces = 0;
  int i = 0;
  while (spaces != 2) {
    if (buf[i] == ' ')
      spaces++;
    i++;
  }

  return buf[i];
}

void bt_push(struct thread *thread, struct function *fcn)
{
  struct backtrace *new_entry = ks_malloc(sizeof(struct backtrace));
  new_entry->fcn = fcn;
  new_entry->next = thread->bt;
  thread->bt = new_entry;
}

void bt_pop(struct thread *thread)
{
  DIE_IF_FMT(!thread->bt,
      "attempting to pop backtrace item from empty backtrace of tid %d",
      thread->tid);

  struct backtrace *new_bt = thread->bt->next;
  ks_free(thread->bt);
  thread->bt = new_bt;
}

static void stop_threads_in_same_as(
    struct thread *thread,
    struct thread_list *tlist)
{
  struct thread *curr = tlist->head;
  while (curr) {
    if (curr != thread && curr->as == thread->as)
      sys_tgkill(curr->tg->tgid, curr->tid, SIGSTOP);

    /* We need to busy loop here waiting for the SIGSTOP to be delivered since
     * sys_tgkill(pid, SIGSTOP) will not immediately stop the process, there is
     * a period of time between the syscall invocation and when the signal is
     * actually delivered (the signal is said to be pending during this time).
     *
     * To prevent this we must ensure the process is fully stopped before
     * proceeding. We can't do a sys_wait4 on the process as that may return a
     * SIGTRAP event from the process hitting an int3 (which needs to be
     * handled in the main loop in runtime_start). Instead repeatedly poll the
     * third field of /proc/<pid>/stat as to not mess with the ptrace state.
     *
     * Any state other than 'R' is acceptable. 'T' indicates the SIGSTOP has
     * been delivered and all other codes (besides 'R') indicated the process
     * is currently in kernel-space. Upon the next return to userspace, the
     * SIGSTOP will be delivered before any instructions can be executed.
     */
    while (get_thread_state(curr->tid) == 'R') {}

    curr = curr->next;
  }
}

static void handle_fcn_entry(
    struct thread *thread,
    struct trap_point *tp)
{
  DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);
  struct function *fcn = FCN_FROM_TP(tp);

  if (FCN_REFCNT(thread, fcn) == 0) {
    DEBUG_FMT(
        "tid %d: entering encrypted function %s decrypting with key %s",
        thread->tid, fcn->name, STRINGIFY_KEY(&fcn->key));

    rc4_xor_fcn(thread->tid, fcn);
  } else {
    /* This thread hit the trap point for entrance to this function, but an
     * earlier thread decrypted it.
     */
    DEBUG_FMT(
        "tid %d: entering already decrypted function %s",
        thread->tid, fcn->name);
  }

  set_byte_at_addr(thread->tid, tp->addr, tp->value);
  single_step(thread->tid);
  set_byte_at_addr(thread->tid, tp->addr, INT3);

  FCN_ENTER(thread, fcn);
}

static void handle_fcn_exit(
    struct thread *thread,
    struct thread_list *tlist,
    struct trap_point *tp)
{
  DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);

  set_byte_at_addr(thread->tid, tp->addr, tp->value);
  single_step(thread->tid);
  set_byte_at_addr(thread->tid, tp->addr, INT3);

  /* We've now executed the ret or jmp instruction and are in the (potentially)
   * new function. Figure out what it is. */
  struct user_regs_struct regs;
  long res = sys_ptrace(PTRACE_GETREGS, thread->tid, NULL, &regs);
  DIE_IF_FMT(res < 0, "PTRACE_GETREGS failed with error %d", res);
  struct function *prev_fcn = FCN_FROM_TP(tp);
  struct function *new_fcn = get_fcn_at_addr(regs.ip);

  if (new_fcn != NULL && new_fcn != prev_fcn) {
    /* We've left the function we were previously in for a new one that we
     * have a record of */
    DEBUG_FMT("tid %d: leaving function %s for %s via %s at %p",
              thread->tid, prev_fcn->name, new_fcn->name,
              tp->type == TP_JMP ? "jmp" : "ret", tp->addr);

    FCN_EXIT(thread, prev_fcn);

    /* Encrypt the function we're leaving provided no other thread is in it */
    if (FCN_REFCNT(thread, prev_fcn) == 0) {
      DEBUG_FMT("tid %d: no other threads were executing in %s, encrypting with key %s",
                thread->tid, prev_fcn->name, STRINGIFY_KEY(&new_fcn->key));

      rc4_xor_fcn(thread->tid, prev_fcn);
      set_byte_at_addr(thread->tid, prev_fcn->start_addr, INT3);
    }

    /* If this is a jump to the start instruction of a function, do not execute
     * any of the code under this conditional (decryption if requried and
     * refcount bump will be handled by handle_fcn_entry).
     *
     * If this is a jump to the middle of a function, we're not going to hit
     * the entry trap point for the function, so that work must be done here.
     *
     * This avoids a double encryption/decryption.
     */
    if (tp->type == TP_JMP && new_fcn->start_addr != regs.ip) {
      DEBUG_FMT("tid %d: function %s is being entered via jmp at non start address %p",
                thread->tid, new_fcn->name, regs.ip);
      if (FCN_REFCNT(thread, new_fcn) == 0) {
        DEBUG_FMT("tid %d: function %s being entered is encrypted, decrypting with key %s",
                  thread->tid, new_fcn->name, STRINGIFY_KEY(&new_fcn->key));

        rc4_xor_fcn(thread->tid, new_fcn);
        set_byte_at_addr(thread->tid, new_fcn->start_addr, INT3);
      }

      FCN_ENTER(thread, new_fcn);
    }
  } else if (!new_fcn) {
    /* We've left the function we were previously in for a new one that we
     * don't have a record of. */
    DEBUG_FMT("tid %d: leaving function %s for address %p (no function record) via %s at %p",
              thread->tid, prev_fcn->name, regs.ip,
              tp->type == TP_JMP ? "jmp" : "ret", tp->addr);

    FCN_EXIT(thread, prev_fcn);

    /* Encrypt prev_fcn (function we're leaving) if we were the last one
     * executing in it */
    if (FCN_REFCNT(thread, prev_fcn) == 0) {
      rc4_xor_fcn(thread->tid, prev_fcn);
      set_byte_at_addr(thread->tid, prev_fcn->start_addr, INT3);
    }
  } else {
    /* We've executed an instrumented jmp or ret but remained in the same
     * function */
    DEBUG_FMT("tid %d: hit trap point in %s at %p, but did not leave function (now at %p) (%s)",
              thread->tid, prev_fcn->name, tp->addr, regs.ip,
              tp->type == TP_JMP ? "internal jmp" : "recursive return");

    /* Decrement the refcnt on a recursive return but not an internal jump */
    if (tp->type == TP_RET)
      FCN_EXIT(thread, prev_fcn);
  }
}

static void handle_trap(
    struct thread *thread,
    struct thread_list *tlist,
    int wstatus)
{
  DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);

  long res;
  struct user_regs_struct regs;

  /* Stop all threads in the same address space. Must be done as to not
   * encounter concurrency issues. */
  stop_threads_in_same_as(thread, tlist);

  res = sys_ptrace(PTRACE_GETREGS, thread->tid, NULL, &regs);
  DIE_IF_FMT(res < 0, "PTRACE_GETREGS failed with error %d", res);

  /* Back up the instruction pointer to the start of the int3 in preparation
   * for executing the original instruction */
  regs.ip--;

  struct trap_point *tp = get_tp(regs.ip);
  if (!tp) {
   DIE_FMT("tid %d: trapped at %p but we don't have an entry",
        thread->tid, regs.ip);
  }

  res = sys_ptrace(PTRACE_SETREGS, thread->tid, NULL, &regs);
  DIE_IF_FMT(res < 0, "PTRACE_SETREGS failed with error %d", res);

  if (tp->type == TP_FCN_ENTRY)
    handle_fcn_entry(thread, tp);
  else
    handle_fcn_exit(thread, tlist, tp);

  DIE_IF(antidebug_signal_check(), TRACED_MSG);

  res = sys_ptrace(PTRACE_CONT, thread->tid, NULL, NULL);
  DIE_IF_FMT(res < 0, "PTRACE_CONT failed with error %d", res);
}

struct thread *find_thread(
    struct thread_list *list,
    pid_t tid)
{
  struct thread *curr = list->head;
  while (curr) {
    if (curr->tid == tid)
      return curr;

    curr = curr->next;
  }

  return NULL;
}

void add_thread(
    struct thread_list *list,
    struct thread *thread)
{
  thread->next = list->head;
  list->head = thread;
  list->size++;
}

void destroy_thread(
    struct thread_list *list,
    struct thread *thread)
{
  DIE_IF(list->head == NULL,
      "(runtime bug) attempting to remove nonexistent thread");

  thread->tg->refcnt--;
  if (thread->tg->refcnt == 0)
    ks_free(thread->tg);

  thread->as->refcnt--;
  if (thread->as->refcnt == 0) {
    ks_free(thread->as->fcn_ref_arr);
    ks_free(thread->as);
  } else {
    /* Thread is exiting, go through its backtrace and decrement function
     * refcounts */
    struct backtrace *curr_bt = thread->bt;
    while (curr_bt) {
      FCN_DEC_REF(thread, curr_bt->fcn);
      if (FCN_REFCNT(thread, curr_bt->fcn) == 0) {
        rc4_xor_fcn(thread->tid, curr_bt->fcn);
        set_byte_at_addr(thread->tid, curr_bt->fcn->start_addr, INT3);
      }
      curr_bt = curr_bt->next;
    }
  }

  /* Free backtrace linked list */
  struct backtrace *curr_bt = thread->bt;
  while (curr_bt) {
    struct backtrace *temp = curr_bt->next;
    ks_free(curr_bt);
    curr_bt = temp;
  }

  struct thread **p = &list->head;
  while ((*p) != thread)
    p = &(*p)->next;

  *p = thread->next;
  list->size--;
  ks_free(thread);
}

struct backtrace *copy_bt(
    struct backtrace *bt)
{
  struct backtrace *copy = NULL;

  struct backtrace *src = bt;
  struct backtrace **dest = &copy;
  while (src) {
    *dest = ks_malloc(sizeof(struct backtrace));
    (*dest)->fcn = src->fcn;

    dest = &(*dest)->next;
    src = src->next;
  }
  *dest = NULL;

  return copy;
}

struct address_space *new_address_space(
    struct address_space *cow_as)
{
    struct address_space *as = ks_malloc(sizeof(struct address_space));
    as->refcnt = 0;

    size_t ref_arr_size = rt_info.nfuncs * sizeof(*as->fcn_ref_arr);
    as->fcn_ref_arr = ks_malloc(ref_arr_size);

    if (cow_as)
      memcpy(as->fcn_ref_arr, cow_as->fcn_ref_arr, ref_arr_size);
    else
      memset(as->fcn_ref_arr, 0, ref_arr_size); /* set everything to encrypted */

    return as;
}

static void handle_exec(
    struct thread *thread,
    struct thread_list *tlist)
{
  pid_t tgid = thread->tg->tgid;

  DEBUG_FMT("tid %d: performed an execve, detaching", tgid);

  /* The exec will get rid of every thread in the thread group. Remove all of
     them from tlist. */
  struct thread *curr_thread = tlist->head;
  while (curr_thread) {
    DEBUG_FMT("%p %p", curr_thread, curr_thread->next);
    if (curr_thread->tg->tgid == thread->tg->tgid) {
      destroy_thread(tlist, curr_thread);
      curr_thread = tlist->head;
    } else {
      curr_thread = curr_thread->next;
    }
  }
  /* thread is now freed */

  /* Allow exec'd program to continue */
  long err = sys_ptrace(PTRACE_DETACH, tgid, NULL, NULL);
  DIE_IF_FMT(err < 0, "PTRACE_CONT failed with error %d", err);
}

static void handle_new_thread(
    pid_t tid,
    struct thread *orig_thread,
    int wstatus,
    struct thread_list *tlist)
{
  pid_t new_tid;
  long ret = sys_ptrace(PTRACE_GETEVENTMSG, tid, 0, &new_tid);
  DIE_IF_FMT(ret < 0, "PTRACE_GETEVENTMSG failed with error %d", ret);

  /* NB: We don't need to manually set PTRACE_O_TRACECLONE and friends on the
   * new thread here as they'll be inherited from the parent (this is not
   * documented in the ptrace man page).
   */

  DEBUG_FMT("tid %d: new thread created with tid %d", tid, new_tid);

  struct thread *new_thread = ks_malloc(sizeof(struct thread));
  new_thread->tid = new_tid;

  /* Determine if new address space or not */
  struct user_regs_struct regs;
  ret = sys_ptrace(PTRACE_GETREGS, tid, NULL, &regs);
  DIE_IF_FMT(ret < 0, "PTRACE_GETREGS failed with error %d", ret);
  int has_clone_vm = regs.di & CLONE_VM;

  if ((PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_VFORK)) ||
      ((PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_CLONE)) && has_clone_vm)) {
    DEBUG_FMT("tid %d: new thread is executing in same address space", tid);
    new_thread->as = orig_thread->as;
  } else { /* fork syscall, or clone without CLONE_VM, new address space */
    DEBUG_FMT("tid %d: new thread is executing in new address space", tid);
    new_thread->as = new_address_space(orig_thread->as);
  }

  int has_clone_thread = regs.di & CLONE_THREAD;
  if (PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_CLONE) && has_clone_thread) {
    new_thread->tg = orig_thread->tg;
    new_thread->tg->refcnt++;
  } else {
    new_thread->tg = ks_malloc(sizeof(struct thread_group));
    new_thread->tg->tgid = new_tid;
    new_thread->tg->refcnt = 1;
  }

  /* Determine what we consider the backtrace of the new thread to be
   *
   * There are two possibilities here, either the thread has done a clone(2)
   * with a child_stack specified as non-null, or done anything else (clone
   * with no child stack, fork, vfork).
   *
   * In the latter of these cases, the logic here is simple. The thread has the
   * same stack and thus the same return addresses on it. The backtrace is
   * therefore identical. Because of this, we just copy the backtrace of the
   * parent thread.
   *
   * The former is a bit trickier. If clone(2) is provided with a child_stack
   * parameter, it must point to a memory region allocated by the parent thread
   * beforehand. Theoretically, this could contain anything, meaning we have no
   * real way of knowing what the backtrace should be. In practice, the clone
   * syscall as implemented in glibc (when returning in the newly-cloned
   * thread), will simply call the passed in fn argument and then immediately
   * exit with its return value. We assume this behaviour here. While this will
   * likely break if a binary does something funky like creating a
   * preformulated stack and passing that in as child_stack, we have no way of
   * handling all such funky cases and assuming the glibc behaviour should
   * cover 99.99% of cases involving clone(2).
   */
  void *child_stack = (void *) regs.si;
  if (((PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_CLONE)) && child_stack != NULL)) {
    DEBUG_FMT("tid %d: new thread has a new stack, removing backtrace", tid);
    /* Backtrace initially contains just the function the thread was in
     * (eg. __clone for glibc) */
    new_thread->bt = NULL;
    if (orig_thread->bt)
      FCN_ENTER(new_thread, orig_thread->bt->fcn);
  } else {
    DEBUG_FMT("tid %d: new thread has the same stack, copying backtrace", tid);
    new_thread->bt = copy_bt(orig_thread->bt);
  }

  new_thread->as->refcnt++;
  new_thread->has_wait_prio = 0;
  add_thread(tlist, new_thread);

  /* Both the existing and new thread will be stopped */
  ret = sys_ptrace(PTRACE_CONT, tid, 0, 0);
  DIE_IF_FMT(ret < 0, "PTRACE_CONT failed with error %d", ret);

retry_child_wait:
  /* The child may not have been scheduled yet, in which case
   * ptrace(PTRACE_CONT, ...) will fail with -ESRCH, loop until it succeeds to
   * get around this.
   */
  ret = sys_ptrace(PTRACE_CONT, new_tid, 0, 0);
  DIE_IF_FMT(ret < 0 && ret != -ESRCH, "PTRACE_CONT failed with error %d", ret);

  if (ret == -ESRCH)
    goto retry_child_wait;
}

/* Fairly waits on all threads in the packed program.
 *
 * This is a wrapper for sys_wait4 used in the main runtime loop to wait
 * on the next thread to service for function encryption or decryption. It gets
 * around a subtle ptrace timing issue.
 *
 * The wait4 syscall is not fair in the sense that a thread rapidly changing
 * state can monopolise it and cause other threads to not be waited on.
 * Internally, when a process ptraces a new thread, it's task_struct is added
 * to a linked list of traced threads in tracer_task_struct->ptraced. New
 * threads are pushed onto the head of this linked list. Whenever the tracer
 * does a wait4, this list is iterated head to tail, with the first thread
 * exhibiting a changed state being the thread that is waited on.
 *
 * This has the consequence that, if the threads at the head of the list very
 * rapidly change state, threads further down in the list may need to wait a
 * very long time, or even forever to get serviced if there are enough threads
 * in front of them changing state rapidly enough. In the case of Kiteshield,
 * this will cause the threads further down in the list to wait a long time or
 * potentially forever for function encryption/decryption. Both of these
 * behaviors (program slowness and program lockup) have been observed when this
 * helper was not in use.
 *
 * To get around this, we wait on threads in a round-robin fashion. The list of
 * threads in the packed program is iterated and each one is waited on with
 * WNOHANG. If the thread has not changed state, we continue on to the next,
 * wrapping around to the head of the list and repeating until we find a thread
 * that has changed state. The next thread to be waited on is preserved via the
 * has_wait_prio flag to preserve strict round-robin ordering between calls.
 */
pid_t fair_wait_threads(struct thread_list *tlist, int *wstatus)
{
  DIE_IF(tlist->head == NULL,
      "(runtime bug) attempting to wait on an empty thread list");

  struct thread *curr = tlist->head;
  while (curr) {
    if (curr->has_wait_prio)
      break;
    curr = curr->next;
  }

  /* If curr == NULL, the thread with wait priority was just destroyed. Just
     give wait priority to the head of the list. */
  if (curr == NULL) {
    curr = tlist->head;
  }
  curr->has_wait_prio = 0;

  pid_t tid;
  while (1) {
    tid = sys_wait4(curr->tid, wstatus, __WALL | WNOHANG);
    DIE_IF_FMT(tid < 0, "wait4 syscall failed with error %d", tid);

    /* Return value of 0 indicates thread has not changed state */
    if (tid != 0)
      break;

    if (curr->next)
      curr = curr->next;
    else
      curr = tlist->head;
  }

  if (curr->next)
    curr->next->has_wait_prio = 1;
  else
    tlist->head->has_wait_prio = 1;

  return tid;
}

void setup_initial_thread(pid_t tid, struct thread_list *tlist)
{
  /* Set up initial forked child (special case of handle_new_thread) */
  long ret;
  while (1) {
    /* Spin while we wait for the child do do a ptrace(PTRACE_TRACEME, ...) and
     * then a raise(SIGSTOP). */
    ret = sys_ptrace(PTRACE_SETOPTIONS, tid, 0,
        (void *) (PTRACE_O_EXITKILL   |
                  PTRACE_O_TRACECLONE |
                  PTRACE_O_TRACEFORK  |
                  PTRACE_O_TRACEEXIT  |
                  PTRACE_O_TRACEEXEC  |
                  PTRACE_O_TRACEVFORK));
    DIE_IF_FMT(ret < 0 && ret != -ESRCH,
        "PTRACE_SETOPTIONS failed with error %d", ret);

    if (ret == 0) break;
  }

  struct thread *thread = ks_malloc(sizeof(struct thread));
  thread->has_wait_prio = 1;
  thread->tg = ks_malloc(sizeof(struct thread_group));
  thread->tg->tgid = tid; /* Created via fork so it's the thread group leader */
  thread->tg->refcnt = 1;
  thread->tid = tid;
  thread->as = new_address_space(NULL);
  thread->as->refcnt = 1;
  thread->bt = NULL;
  thread->next = NULL;
  add_thread(tlist, thread);

  ret = sys_ptrace(PTRACE_CONT, tid, 0, 0);
  DIE_IF_FMT(ret < 0, "PTRACE_CONT failed with error %d", ret);
}

static void handle_thread_exit(
    struct thread *thread,
    struct thread_list *tlist)
{
  /* Undocumented Linux magic right here.
   *
   * If the thread group leader of a thread group with > 1 thread exits
   * while being ptraced, it will hang around as a zombie. Attempting to
   * sys_wait4 on it will result in infinite hanging. It can only be
   * successfully wait4'ed on when every other thread in the thread group
   * has exited and been reaped. This behavior is not documented in the
   * ptrace manpage.
   *
   * Due to this, we don't wait4 on threads if they're the thread group
   * leader UNTIL all threads in the thread group have exited.
   */
  int is_last_in_tg = thread->tg->refcnt == 1;
  int is_tg_leader = thread->tg->tgid == thread->tid;
  pid_t tgid = thread->tg->tgid;
  pid_t tid = thread->tid;

  destroy_thread(tlist, thread);
  /* thread is now freed */

  /* Continue thread and catch exit event */
  long err = sys_ptrace(PTRACE_CONT, tid, NULL, NULL);
  DIE_IF_FMT(err < 0, "PTRACE_CONT failed with error %d", err);

  int wstatus;
  if (!is_tg_leader) {
    pid_t res = sys_wait4(tid, &wstatus, __WALL);
    DIE_IF_FMT(res < 0, "wait4 syscall failed with error %d", res);

    DIE_IF_FMT(!WIFEXITED(wstatus), "tid %d expected to exit but did not",
        tid);
    DEBUG_FMT("tid %d: exited with status %d", tid, WEXITSTATUS(wstatus));
  }

  /* Wait on thread group leader when its the last thread */
  if (is_last_in_tg) {
    pid_t res = sys_wait4(tgid, &wstatus, __WALL);
    DIE_IF_FMT(res < 0, "wait4 syscall failed with error %d", res);

    DIE_IF_FMT(!WIFEXITED(wstatus), "tid %d expected to exit but did not",
        tgid);
    DEBUG_FMT("tid %d: exited with status %d", tgid, WEXITSTATUS(wstatus));
  }
}

void runtime_start(pid_t child_pid)
{
  DEBUG("starting ptrace runtime");
  obf_deobf_rt_info(&rt_info);

  DEBUG_FMT("number of trap points: %u", rt_info.ntraps);
  DEBUG_FMT("number of encrypted functions: %u", rt_info.nfuncs);

  antidebug_signal_init();

#ifdef DEBUG_OUTPUT
  DEBUG("list of trap points:");
  for (int i = 0; i < rt_info.ntraps; i++) {
    struct trap_point *tp = ((struct trap_point *) rt_info.data) + i;
    const char *type =
      tp->type == TP_JMP ? "jmp" : tp->type == TP_RET ? "ret" : "ent";
    DEBUG_FMT("%p value: %hhx, type: %s, function: %s (#%d)",
              tp->addr, tp->value, type,
              FCN_FROM_TP(tp)->name, FCN_FROM_TP(tp)->id);
  }
#endif

  ks_malloc_init();

  /* debugger checks are scattered throughout the runtime to interfere with
   * debugger attaches as much as possible.
   */
  DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);

  /* Do the prctl down here so a reverse engineer will have to defeat the
   * preceeding antidebug_proc_check_traced() call before prctl shows up in a
   * strace */
  antidebug_prctl_set_nondumpable();

  struct thread_list tlist;
  tlist.size = 0;
  tlist.head = NULL;

  setup_initial_thread(child_pid, &tlist);

  /* Main runtime loop */
  while (1) {
    int wstatus;
    pid_t pid = fair_wait_threads(&tlist, &wstatus);

    struct thread *thread = find_thread(&tlist, pid);
    DIE_IF_FMT(!thread,
        "(runtime bug) tid %d trapped but we don't have a record of it", pid);

    if ((PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_FORK)  ||
         PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_VFORK) ||
         PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_CLONE))) {
      /* Trap due to new thread */
      handle_new_thread(pid, thread, wstatus, &tlist);
      continue;
    }

    if (PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_EXEC)) {
      /* Trap due to exec */
      handle_exec(thread, &tlist);
      continue;
    }

    /* destroy_thread (which is called by handle_thread_exit) requires that the
     * thread not yet have exited as it may need to re-encrypt functions in the
     * thread's address space if there are now no threads executing in them. We
     * thus we use PTRACE_EVENT_EXIT instead of WIFEXITED here to keep the
     * thread in a "just about to exit" state that will allow the use of
     * PTRACE_[PEEK/POKE]TEXT.
     */
    if (PTRACE_EVENT_PRESENT(wstatus, PTRACE_EVENT_EXIT)) {
      handle_thread_exit(thread, &tlist);

      if (tlist.size == 0) {
        DEBUG("all threads exited, exiting");
        sys_exit(0);
      }
      continue;
    }

    DIE_IF_FMT(
        WIFSIGNALED(wstatus),
        "child was killed by signal, %u exiting", WTERMSIG(wstatus));
    DIE_IF(
        !WIFSTOPPED(wstatus),
        "child was stopped unexpectedly, exiting");

    if (WSTOPSIG(wstatus) != SIGTRAP && WSTOPSIG(wstatus) != SIGSTOP) {
      DEBUG_FMT("child %d was sent non-SIGTRAP signal %u",
          pid, WSTOPSIG(wstatus));

      /* Forward signal to child and continue */
      sys_ptrace(PTRACE_CONT, pid, NULL, (void *) (long) WSTOPSIG(wstatus));
      continue;
    }

    if (WSTOPSIG(wstatus) == SIGSTOP) {
      /* Thread stopped by runtime for function decryption or encryption,
       * PTRACE_CONT and continue */
      sys_ptrace(PTRACE_CONT, pid, NULL, NULL);
      continue;
    }

    DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);
    DIE_IF(antidebug_signal_check(), TRACED_MSG);

    handle_trap(thread, &tlist, wstatus);
  }
}

void do_fork()
{
  DIE_IF(antidebug_proc_check_traced(), TRACED_MSG);

  pid_t pid = sys_fork();
  DIE_IF_FMT(pid < 0, "fork failed with error %d", pid);

  if (pid != 0) {
    runtime_start(pid);
    sys_exit(0); /* Only the child returns from do_fork */
  }

  /* Just in case the earlier one in load() was patched out :) */
  antidebug_rlimit_set_zero_core();
}

void child_start_ptrace()
{
  long ret = sys_ptrace(PTRACE_TRACEME, 0, NULL, NULL);
  DIE_IF_FMT(ret < 0, "child: PTRACE_TRACEME failed with error %d", ret);

  /* Pause here so runtime can init itself, runtime will do PTRACE_CONT when
   * ready
   */
  sys_kill(sys_getpid(), SIGSTOP);

  DEBUG("child is traced, handing control to packed binary");
}

#endif /* USE_RUNTIME */

```

`loader/string.c`:

```c
#include <stdarg.h>

#include "loader/include/string.h"
#include "loader/include/types.h"
#include "loader/include/obfuscated_strings.h"
#include "loader/include/debug.h"

#define BITS(type) (sizeof(type) * 8)

/**
 * Minimalistic implementation of vsnprintf
 *
 * Format specifier prototype: %[length]specifier
 *
 * - Length sub-specifiers (optional):
 *   - l  -- long
 *   - hh -- char
 *
 * - Specifiers and default lengths (ie. with no length sub-specifier):
 *   - %p -- pointer                      -- sizeof(void *)
 *   - %d -- signed decimal integer       -- sizeof(int)
 *   - %u -- unsigned decimal integer     -- sizeof(int)
 *   - %x -- unsigned hexadecimal integer -- sizeof(int)
 *   - %s -- null-terminated string
 */
void ks_vsnprintf(char *str, size_t size, const char *format, va_list vl)
{
  size_t curr_size = 0;
  char *msg_ptr = str;
  memset(str, 0, size);

  for (const char *fmt_ptr=format; *fmt_ptr != '\0'; fmt_ptr++) {
    if (*fmt_ptr != '%') {
      *(msg_ptr++) = *fmt_ptr;
      continue;
    }

    int length;
    unsigned long long item;
    char item_buf[128];
    __builtin_memset(item_buf, 0, sizeof(item_buf));

    fmt_ptr++;
    switch (*(fmt_ptr)) {
    /* Deal with the non length specifier case */
    case 'p':
      itoa((unsigned long) va_arg(vl, void *), 0, item_buf, BITS(void *), 16);
      goto copy;
    case 'd':
      itoa(va_arg(vl, int), 1, item_buf, BITS(int), 10);
      goto copy;
    case 'u':
      itoa((unsigned int) va_arg(vl, unsigned int), 1, item_buf, BITS(unsigned int), 10);
      goto copy;
    case 'x':
      itoa((unsigned int) va_arg(vl, unsigned int), 1, item_buf, BITS(unsigned int), 16);
      goto copy;
    case 's':
      strncpy(item_buf, va_arg(vl, char *), sizeof(item_buf));
      goto copy;

    /* Length specifier given */
    case 'l':
      fmt_ptr++;
      length = BITS(long);
      item = va_arg(vl, long);
      break;
    case 'h':
      fmt_ptr++;
      if (*(fmt_ptr) == 'h') {
        length = BITS(unsigned char);
        /* Unsigned char gets promoted to int here, so take bottom 8 bits */
        item = va_arg(vl, int) & 0xFF;
      } else {
        DIE_FMT("Invalid length specifier in printf format string: %s", format);
      }
      break;
    default:
      DIE_FMT("Invalid format specifier in printf format string: %s", format);
    }

    fmt_ptr++;
    switch (*(fmt_ptr)) {
    case 'd':
      itoa(item, 1, item_buf, length, 10);
      break;
    case 'u':
      itoa(item, 0, item_buf, length, 10);
      break;
    case 'x':
      itoa(item, 0, item_buf, length, 16);
      break;
    default:
      DIE_FMT("Invalid format specifier in printf format string: %s", format);
    }

copy: ;
    size_t item_size = strnlen(item_buf, sizeof(item_buf));
    if (curr_size + item_size >= size)
      return;

    strncpy(msg_ptr, item_buf, sizeof(item_buf));
    msg_ptr += item_size;
  }
}

void ks_snprintf(char *str, size_t size, const char *format, ...)
{
  va_list vl;

  va_start(vl, format);
  ks_vsnprintf(str, size, format, vl);
  va_end(vl);
}

void ks_printf(int fd, const char *format, ...)
{
  va_list vl;
  char buf[4096];

  va_start(vl, format);
  ks_vsnprintf(buf, sizeof(buf), format, vl);
  sys_write(fd, buf, strnlen(buf, sizeof(buf)));
  va_end(vl);
}

int strncmp(const char *s1, const char *s2, size_t n)
{
  for (int i = 0; i < n; i++) {
    if (s1[i] != s2[i]) {
      return 1;
    }
  }

  return 0;
}

char *strncat(char *dest, const char *src, size_t n)
{
  char *end = dest;
  while (*end != '\0')
    end++;

  size_t i;
  for (i = 0; i < n; i++)
    end[i] = src[i];

  end[i] = '\0';
  return dest;
}

char *strncpy(char *dest, const char *src, size_t n)
{
  size_t i;
  for (i = 0; i < n && src[i] != '\0'; i++) {
    dest[i] = src[i];
  }

  for ( ; i < n; i++) {
    dest[i] = '\0';
  }

  return dest;
}

void itoa(
    unsigned long val,
    int is_signed,
    char *buf,
    int bitwidth,
    int radix)
{
  char *digits = DEOBF_STR(HEX_DIGITS);
  char *buf_ptr = buf;

  int negative = is_signed && ((1 << (bitwidth - 1)) & val);
  if (negative)
    val = ~(val-1);

  do {
    *(buf_ptr++) = digits[val % radix];
  } while ((val /= radix) > 0);

  if (negative)
    *(buf_ptr++) = '-';

  *buf_ptr = '\0';

  /* Buf is now correct, but reversed */
  char *start_ptr = buf;
  char *end_ptr = buf_ptr - 1; /* Avoid the '\0' */
  while (start_ptr < end_ptr) {
    char temp = *start_ptr;
    *(start_ptr++) = *end_ptr;
    *(end_ptr--) = temp;
  }
}

size_t strnlen(const char *s, size_t maxlen)
{
  int len = 0;
  while (*(s + len) != '\0' && len <= maxlen) {
    len++;
  }

  return len;
}

void *memcpy(void *dest, const void *src, size_t n)
{
  for (size_t i = 0; i < n; i++)
    ((char *) dest)[i] = ((char *) src)[i];

  return dest;
}

void *memset(void *s, int c, size_t n)
{
  for (size_t i = 0; i < n; i++)
    ((char *) s)[i] = (char) c;

  return s;
}

```

`loader/string_obfuscation.py`:

```py
#!/usr/bin/python3

# String obfuscation script, this ensures that no strings exist in the loader
# code that could be useful to a reverse engineer. All potentially useful
# strings should be declared in the STRINGS map and deobfuscated at runtime
# using the DEOBF_STR macro.

import binascii
import sys

STRINGS = {
    # loader/include/anti_debug.h
    'PROC_STATUS_FMT': '/proc/%d/status',
    'TRACERPID_PROC_FIELD': 'TracerPid:',

    # loader/runtime.c
    'PROC_STAT_FMT': '/proc/%d/stat',

    # loader/anti_debug.c
    'LD_PRELOAD': 'LD_PRELOAD',
    'LD_AUDIT': 'LD_AUDIT',
    'LD_DEBUG': 'LD_DEBUG',

    # loader/string.c
    'HEX_DIGITS': '0123456789abcdef'
}

# For some reason, gcc likes to optimize out this entire statement expression
# when compiling with more than -O0, mark the cleartext array volatile to
# circumvent
_DEOBF_MACRO = '''
#define DEOBF_STR(str)                                                         \\
  ({ volatile char cleartext[sizeof(str)];                                     \\
     for (int i = 0; i < sizeof(str); i++) {                                   \\
       cleartext[i] = str[i] ^ ((0x83 + i) % 256);                             \\
     };                                                                        \\
     cleartext[sizeof(cleartext) - 1] = '\\0';                                 \\
     (char *) cleartext; })

'''


def escape_str(s):
    return ''.join('\\x{:02x}'.format(ord(c)) for c in s)


def crypt_str(s):
    new = ''
    for i, c in enumerate(s):
        new += chr(ord(c) ^ ((0x83 + i) % 256))
    return new


def output_header(f):
    f.write('#ifndef __KITESHIELD_OBFUSCATED_STRINGS_H\n')
    f.write('#define __KITESHIELD_OBFUSCATED_STRINGS_H\n')
    f.write(_DEOBF_MACRO)
    f.write('\n')

    for name, cleartext in STRINGS.items():
        encrypted = escape_str(crypt_str(cleartext))
        f.write('/* "{0}" */\n'.format(cleartext))
        f.write('static const char {0}[] = "{1}";\n\n'.format(name, encrypted))

    f.write('\n')
    f.write('#endif /* __KITESHIELD_OBFUSCATED_STRINGS_H */\n')


if __name__ == '__main__':
    output_header(sys.stdout)

```

`loader/syscalls.c`:

```c
#include "loader/include/syscalls.h"
#include "loader/include/types.h"

ssize_t sys_write(int fd, const char *s, size_t count)
{
  ssize_t ret = 0;

  asm volatile (
      "mov $1, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%rdx\n"
      "syscall\n"
      "mov %%rax, %0"
  :   "=rm" (ret)
  :   "rm" (fd), "rm" (s), "rm" (count)
  :   "rax", "edi", "rsi", "rdx");

  return ret;
}

ssize_t sys_read(int fd, void *buf, size_t count)
{
  ssize_t ret = 0;

  asm volatile (
      "mov $0, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%rdx\n"
      "syscall\n"
      "mov %%rax, %0"
  :   "=rm" (ret)
  :   "rm" (fd), "rm" (buf), "rm" (count)
  :   "rax", "edi", "rsi", "rdx");

  return ret;
}

off_t sys_lseek(int fd, off_t offset, int whence)
{
  off_t ret = 0;

  asm volatile (
      "mov $8, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%edx\n"
      "syscall\n"
      "mov %%rax, %0"
  :   "=rm" (ret)
  :   "rm" (fd), "rm" (offset), "rm" (whence)
  :   "rax", "edi", "rsi", "edx");

  return ret;
}

int sys_open(const char *pathname, int flags, int mode)
{
  int ret = 0;

  asm volatile (
      "mov $2, %%rax\n"
      "mov %1, %%rdi\n"
      "mov %2, %%esi\n"
      "mov %3, %%edx\n"
      "syscall\n"
      "mov %%eax, %0"
  :   "+rm" (ret)
  :   "rm" (pathname), "rm" (flags), "rm" (mode)
  :   "rax", "rdi", "esi", "edx");

  return ret;
}

int sys_close(int fd)
{
  int ret = 0;

  asm volatile (
      "mov $3, %%rax\n"
      "mov %1, %%edi\n"
      "syscall\n"
      "mov %%eax, %0"
  :   "+rm" (ret)
  :   "rm" (fd)
  :   "rax", "edi");

  return ret;
}

void sys_exit(int status)
{
  asm volatile (
      "mov $60, %%rax\n"
      "mov %0, %%edi\n"
      "syscall"
  :
  :   "rm" (status)
  :   "rax", "edi");

  /* Required so GCC accepts __attribute__((noreturn)) on this function */
  while(1) {}
}

void *sys_mmap(
    void *addr,
    size_t length,
    int prot,
    int flags,
    int fd,
    off_t offset)
{
  void *ret = NULL;

  asm volatile (
      "mov $9, %%rax\n"
      "mov %1, %%rdi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%edx\n"
      "mov %4, %%r10d\n"
      "mov %5, %%r8d\n"
      "mov %6, %%r9\n"
      "syscall\n"
      "mov %%rax, %0"
  :   "+rm" (ret)
  :   "rm" (addr), "rm" (length), "rm" (prot), "rm" (flags), "rm" (fd),
      "rm" (offset)
  :   "rax", "rdi", "rsi", "edx", "r10", "r8", "r9");

  return ret;
}

int sys_munmap(
    void *addr,
    size_t length)
{
  int ret = 0;

  asm volatile (
      "mov $11, %%rax\n"
      "mov %1, %%rdi\n"
      "mov %2, %%rsi\n"
      "syscall\n"
      "mov %%eax, %0"
  :   "+rm" (ret)
  :   "rm" (addr), "rm" (length)
  :   "rax", "rdi", "rsi");

  return ret;
}

int sys_mprotect(void *addr, size_t len, int prot)
{
  int ret = 0;

  asm volatile (
      "mov $10, %%rax\n"
      "mov %1, %%rdi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%edx\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (addr), "rm" (len), "rm" (prot)
  :   "rax", "rdi", "rsi", "edx");

  return ret;
}

long sys_ptrace(
    enum __ptrace_request request,
    pid_t pid,
    void *addr,
    void *data)
{
  long ret = 0;

  /* Note that the raw kernel-level ptrace interface differs from the one
   * exposed by glibc with regards to the PTRACE_PEEK requests. Glibc *returns*
   * the data, while the kernel-level interface stores it in *data.
   *
   * This function exposes the kernel-level interface.
   */
  asm volatile (
      "mov $101, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%esi\n"
      "mov %3, %%rdx\n"
      "mov %4, %%r10\n"
      "syscall\n"
      "mov %%rax, %0\n"
  :   "+rm" (ret)
  :   "rm" (request), "rm" (pid), "rm" (addr), "rm" (data)
  :   "rax", "edi", "esi", "rdx", "r10");

  return ret;
}

pid_t sys_wait4(pid_t pid, int *wstatus, int options)
{
  pid_t ret = 0;

  /* We pass NULL for rusage to simpify the function signature (no need for
   * that parameter currently)
   */
  asm volatile (
      "mov $61, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%edx\n"
      "mov $0, %%r10\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (pid), "rm" ((uint64_t) wstatus), "rm" (options)
  :   "rax", "edi", "esi", "rdx", "r10");

  return ret;
}

pid_t sys_fork()
{
  pid_t ret = 0;

  asm volatile (
      "mov $57, %%rax\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :
  :   "rax");

  return ret;
}

int sys_kill(pid_t pid, int sig)
{
  pid_t ret = 0;

  asm volatile (
      "mov $62, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%esi\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (pid), "rm" (sig)
  :   "rax", "edi", "esi");

  return ret;
}

int sys_tgkill(pid_t tgid, pid_t tid, int sig)
{
  pid_t ret = 0;

  asm volatile (
      "mov $234, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%esi\n"
      "mov %3, %%edx\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (tgid), "rm" (tid), "rm" (sig)
  :   "rax", "edi", "esi", "edx");

  return ret;
}

pid_t sys_getpid()
{
  pid_t ret = 0;

  asm volatile (
      "mov $39, %%rax\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :
  :   "rax");

  return ret;
}

int sys_rt_sigaction(
    int sig,
    const struct kernel_sigaction *act,
    const struct kernel_sigaction *oact)
{
  int ret = 0;
  size_t sigsetsize = sizeof(act->sa_mask);

  asm volatile (
      "mov $13, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%rdx\n"
      "mov %4, %%r10\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (sig), "rm" (act), "rm" (oact), "rm" (sigsetsize)
  :   "rax", "edi", "rsi", "rdx", "r10");

  return ret;
}

int sys_prctl(
    int option,
    unsigned long arg2,
    unsigned long arg3,
    unsigned long arg4,
    unsigned long arg5)
{
  int ret = 0;

  asm volatile (
      "mov $157, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "mov %3, %%rdx\n"
      "mov %4, %%r10\n"
      "mov %5, %%r8\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (option), "rm" (arg2), "rm" (arg3), "rm" (arg4), "rm" (arg5)
  :   "rax", "edi", "rsi", "rdx", "r10", "r8");

  return ret;
}

int sys_stat(const char *pathname, struct stat *statbuf)
{
  int ret = 0;

  asm volatile (
      "mov $4, %%rax\n"
      "mov %1, %%rdi\n"
      "mov %2, %%rsi\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (pathname), "rm" (statbuf)
  :   "rax", "rdi", "rsi");

  return ret;
}

int sys_setrlimit(int resource, struct rlimit *rlim)
{
  int ret = 0;

  asm volatile (
      "mov $160, %%rax\n"
      "mov %1, %%edi\n"
      "mov %2, %%rsi\n"
      "syscall\n"
      "mov %%eax, %0\n"
  :   "+rm" (ret)
  :   "rm" (resource), "rm" (rlim)
  :   "rax", "edi", "rsi");

  return ret;
}


```

`loader/test/Makefile`:

```
CFLAGS = -Wall -g -fno-pie -nostdlib -Werror -std=gnu99 -c -I ../..
LDFLAGS = -no-pie

SRCS = $(wildcard *.c)
OBJS = $(filter-out ../out/rt/entry.o, $(wildcard ../out/rt/*.o))
TEST_OBJS = $(addprefix out/, $(addsuffix .o, $(basename $(notdir $(SRCS:.c=.o)))))

.PHONY: all output-dirs debug debug-antidebug clean

all: output-dirs loadertest

loadertest: $(OBJS) $(TEST_OBJS)
	$(CC) $(LDFLAGS) $(OBJS) $(TEST_OBJS) -o out/loadertest
	./out/loadertest

out/%.o: %.c
	$(CC) $(CFLAGS) $< -o $@

out/%.o: ../common/%.c
	$(CC) $(CFLAGS) $< -o $@

out/%.o: %.S
	$(CC) -c $< -o $@

output-dirs:
	mkdir -p out

clean:
	rm -rf out/

```

`loader/test/attounit.h`:

```h
/*
 * AttoUnit - A tiny header only unit testing framework for C
 * https://github.com/GunshipPenguin/attounit
 * ------------------------------------------------------------
 * Copyright (c) 2018, 2021 Rhys Rustad-Elliott
 * Distributed under the MIT license, see accompanying file LICENSE
 */
#include <stdio.h>
#include <string.h>

#ifndef __GNUC__
#error "Your compiler doesn't support GNU C extensions"
#endif

#define RED   "\x1B[1;31m"
#define GREEN "\x1B[1;32m"
#define RESET "\x1B[0m"

#define CHECK "\xE2\x9C\x93"
#define X_MARK "\xE2\x9C\x97"

#define MAX_NUM_TESTS 2048
#define MAX_TEST_NAME 256
#define MAX_SUITE_NAME 256

struct test_info {
  char test_name[MAX_TEST_NAME];
  char suite_name[MAX_SUITE_NAME];
  void (*func)();
  void (*setup)();
  void (*teardown)();
};

/* Pointers to test suite functions */
extern struct test_info tests[];
extern int num_test_cases;

extern int num_assertions;
extern int num_failed_assertions;
extern int curr_test_num;

#define GENERAL_BIN_ASSERT(a, b, op, desc, a_fmt, b_fmt) do { \
  num_assertions ++; \
  /* Deal with a and b not being pure by evaluating them only once */ \
  typeof(a) a_eval = a; \
  typeof(b) b_eval = b; \
  if (!(a_eval op b_eval)) { \
    num_failed_assertions ++; \
    printf(RED X_MARK " Assertion failed" RESET " at %s:%d (%s/%s)\n", \
      __FILE__, __LINE__, \
      tests[curr_test_num].suite_name, tests[curr_test_num].test_name); \
    printf("\t" #a " " #op " " #b "\n"); \
    printf("\tExpected " #a_fmt " " #desc " " #b_fmt "\n", a_eval, b_eval); \
  } \
} while(0)

#define GENERAL_UNARY_ASSERT(val, op, desc, val_fmt) do { \
  num_assertions ++; \
  /* Deal with val not being pure by evaluating it only once */ \
  typeof(val) val_eval = val; \
  if (!(op val_eval)) { \
    num_failed_assertions ++; \
    printf(RED X_MARK " Assertion failed" RESET " at %s:%d (%s/%s)\n", \
      __FILE__, __LINE__, \
      tests[curr_test_num].suite_name, tests[curr_test_num].test_name); \
    printf("\t" #op #val "\n"); \
    printf("\tExpected " #val_fmt " " #desc "\n", val_eval); \
  } \
} while(0)

#define ASSERT_TRUE(val) GENERAL_UNARY_ASSERT(val, , to be true, %d)
#define ASSERT_FALSE(val) GENERAL_UNARY_ASSERT(val, !, to be false, %d)

#define ASSERT_NULL(val) GENERAL_UNARY_ASSERT(val, !, to be null, %p)
#define ASSERT_NOT_NULL(val) GENERAL_UNARY_ASSERT(val, , to not be null, %p)

#define ASSERT_EQUAL(a, b) GENERAL_BIN_ASSERT(a, b, ==, to equal, %d, %d)
#define ASSERT_EQUAL_FMT(a, b, fmt) GENERAL_BIN_ASSERT(a, b, ==, to equal, fmt, fmt)

#define ASSERT_NOT_EQUAL(a, b) GENERAL_BIN_ASSERT(a, b, !=, to not equal, %d, %d)
#define ASSERT_NOT_EQUAL_FMT(a, b, fmt) GENERAL_BIN_ASSERT(a, b, !=, to not equal, fmt, fmt)

#define ASSERT_GREATER(a, b) GENERAL_BIN_ASSERT(a, b, >, to be greater than, %d, %d)
#define ASSERT_GREATER_FMT(a, b, fmt) GENERAL_BIN_ASSERT(a, b, >, to be greater than, fmt, fmt)

#define ASSERT_LESS(a, b) GENERAL_BIN_ASSERT(a, b, <, to be less than, %d, %d)
#define ASSERT_LESS_FMT(a, b, fmt) GENERAL_BIN_ASSERT(a, b, <, to be less than, fmt, fmt)

#define TEST_SUITE(suitename) \
  /* Static global information about this suite */ \
  static char *suite_name = #suitename; \

#define BEFORE_EACH() \
  static void before_each() \

#define AFTER_EACH() \
  static void after_each() \

#define TEST_CASE(casename) \
  /* Test case function prototype */ \
  void test_case_##casename(); \
  /* Test case constructor */ \
  __attribute__((constructor)) \
  void test_case_ctor_##casename() { \
    strcpy(tests[num_test_cases].test_name, #casename); \
    strcpy(tests[num_test_cases].suite_name, suite_name); \
    tests[num_test_cases].func = test_case_##casename; \
    tests[num_test_cases].setup = before_each; \
    tests[num_test_cases].teardown = after_each; \
    num_test_cases++; \
  } \
  void test_case_##casename()

#define TEST_MAIN() \
  void (*test_suite_funcs[MAX_NUM_TESTS])(); \
  int num_test_cases = 0; \
  int num_assertions = 0; \
  int num_failed_assertions = 0; \
  int curr_test_num = 0; \
  struct test_info tests[MAX_NUM_TESTS]; \
  int main() { \
    for (curr_test_num=0;curr_test_num<num_test_cases;curr_test_num++) { \
      tests[curr_test_num].setup(); \
      tests[curr_test_num].func(); \
      tests[curr_test_num].teardown(); \
    } \
    if (num_failed_assertions == 0) { \
      printf(GREEN CHECK " All assertions passed" RESET " (%d assertions in %d test cases)\n", num_assertions, num_test_cases); \
      return 0; \
    } else { \
      printf(RED X_MARK " %d assertions failed\n" RESET, num_failed_assertions); \
      return 1; \
    } \
  }

```

`loader/test/test_main.c`:

```c
#include "attounit.h"

TEST_MAIN()

```

`loader/test/test_malloc.c`:

```c
#include "attounit.h"
#include "loader/include/malloc.h"

TEST_SUITE(malloc)

BEFORE_EACH() {
  ks_malloc_init();
}
AFTER_EACH() {
  ks_malloc_deinit();
}

TEST_CASE(malloc_basic) {
  void *ptr = ks_malloc(16);
  ASSERT_NOT_NULL(ptr);
  ks_free(ptr);

  ASSERT_EQUAL(ks_malloc_get_n_blocks(), 1);
}

TEST_CASE(malloc_memset) {
  char *ptr = ks_malloc(32 * sizeof(char));
  for (int i = 0; i < 32; i++)
    ptr[i] = i;

  /* Fill a ton of blocks with junk, test will verify none overlap the first
   * one allocated */
  for (int i = 1; i < 1000; i++) {
    void *ptr = ks_malloc(i);
    memset(ptr, i, i);
  }

  for (int i = 0; i < 32; i++)
    ASSERT_EQUAL(ptr[i], i);
}

TEST_CASE(malloc_coalesce) {
  int nblocks = 1000;
  void *ptrs[nblocks];

  ASSERT_EQUAL(ks_malloc_get_n_blocks(), 1);

  for (int i = 1; i < nblocks; i++) {
    ptrs[i] = ks_malloc(i);
    ASSERT_EQUAL(ks_malloc_get_n_blocks(), i + 1);
  }

  for (int i = 1; i < nblocks; i++)
    ks_free(ptrs[i]);

  ASSERT_EQUAL(ks_malloc_get_n_blocks(), 1);
}

TEST_CASE(malloc_coalesce_with_memset) {
  int nblocks = 1000;
  void *ptrs[nblocks];

  ASSERT_EQUAL(ks_malloc_get_n_blocks(), 1);

  for (int i = 1; i < nblocks; i++) {
    ptrs[i] = ks_malloc(i);
    memset(ptrs[i], 0, i);
    ASSERT_EQUAL(ks_malloc_get_n_blocks(), i + 1);
  }

  for (int i = 1; i < nblocks; i++)
    ks_free(ptrs[i]);

  ASSERT_EQUAL(ks_malloc_get_n_blocks(), 1);
}

```

`loader/test/test_rc4.c`:

```c
#include "attounit.h"
#include "common/include/rc4.h"

TEST_SUITE(rc4)

BEFORE_EACH() {}
AFTER_EACH() {}

/* Test vectors taken from RFC6229 */
TEST_CASE(rc4_40bit) {
  struct rc4_state rc4;
  unsigned char key[] = { 0x1, 0x2, 0x3, 0x4, 0x5 };
  unsigned char expected_stream[] = {
    0xb2, 0x39, 0x63, 0x05, 0xf0, 0x3d, 0xc0, 0x27,
    0xcc, 0xc3, 0x52, 0x4a, 0x0a, 0x11, 0x18, 0xa8,
    0x69, 0x82, 0x94, 0x4f, 0x18, 0xfc, 0x82, 0xd5,
    0x89, 0xc4, 0x03, 0xa4, 0x7a, 0x0d, 0x09, 0x19 };

  rc4_init(&rc4, key, sizeof(key));
  for (int i = 0; i < sizeof(expected_stream) / sizeof(unsigned char); i ++) {
    ASSERT_EQUAL_FMT(rc4_get_byte(&rc4), expected_stream[i], 0x%hhx);
  }
}

TEST_CASE(rc4_256bit) {
  struct rc4_state rc4;
  unsigned char key[] = {
    0x1a, 0xda, 0x31, 0xd5, 0xcf, 0x68, 0x82, 0x21,
    0xc1, 0x09, 0x16, 0x39, 0x08, 0xeb, 0xe5, 0x1d,
    0xeb, 0xb4, 0x62, 0x27, 0xc6, 0xcc, 0x8b, 0x37,
    0x64, 0x19, 0x10, 0x83, 0x32, 0x22, 0x77, 0x2a };
  unsigned char expected_stream[] = {
    0xdd, 0x5b, 0xcb, 0x00, 0x18, 0xe9, 0x22, 0xd4,
    0x94, 0x75, 0x9d, 0x7c, 0x39, 0x5d, 0x02, 0xd3,
    0xc8, 0x44, 0x6f, 0x8f, 0x77, 0xab, 0xf7, 0x37,
    0x68, 0x53, 0x53, 0xeb, 0x89, 0xa1, 0xc9, 0xeb };

  rc4_init(&rc4, key, sizeof(key));
  for (int i = 0; i < sizeof(expected_stream) / sizeof(unsigned char); i ++) {
    ASSERT_EQUAL_FMT(rc4_get_byte(&rc4), expected_stream[i], 0x%hhx);
  }
}

```

`packer/Makefile`:

```
CFLAGS_COMMON = -Wall -Werror -std=gnu99 -I .. -I bddisasm/inc
CFLAGS = $(CFLAGS_COMMON) -O2

LDFLAGS = -Lbddisasm/bin/x64/Release -l:libbddisasm.a

SRCS = $(wildcard *.c ../common/*.c)
OBJS = $(addprefix ./obj/, $(notdir $(SRCS:.c=.o)))
BIN_NAME = kiteshield

.PHONY: all debug debug-antidebug output-dirs clean

debug: CFLAGS = $(CFLAGS_COMMON) -g -DDEBUG_OUTPUT -DNO_ANTIDEBUG
debug-antidebug: CFLAGS = $(CFLAGS_COMMON) -g -DDEBUG_OUTPUT

all: output-dirs $(OBJS)
	$(CC) $(OBJS) -o $(BIN_NAME) $(LDFLAGS)

debug: all
debug-antidebug: all

output-dirs:
	mkdir -p obj

obj/%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

obj/%.o: ../common/%.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(BIN_NAME)
	rm -rf obj/

```

`packer/elfutils.c`:

```c
#include <string.h>

#include "packer/include/elfutils.h"

void parse_mapped_elf(
    void *start,
    size_t size,
    struct mapped_elf *elf)
{
  elf->start = start;
  elf->size = size;

  elf->ehdr = (Elf64_Ehdr *) start;
  elf->phdr_tbl = (Elf64_Phdr *) (elf->start + elf->ehdr->e_phoff);
  elf->shdr_tbl = (Elf64_Shdr *) (elf->start + elf->ehdr->e_shoff);

  /* elf_get_sec_by_name only depends on shstrtab being set */
  if (elf->ehdr->e_shstrndx == 0)
    elf->shstrtab = NULL;
  else
    elf->shstrtab = elf->shdr_tbl + elf->ehdr->e_shstrndx;

  elf->strtab = elf_get_sec_by_name(elf, ".strtab");
  elf->symtab = elf_get_sec_by_name(elf, ".symtab");
  elf->text = elf_get_sec_by_name(elf, ".text");
}

const Elf64_Shdr *elf_get_sec_by_name(
    const struct mapped_elf *elf,
    const char *name)
{
  Elf64_Shdr *curr_shdr = elf->shdr_tbl;

  for (int i = 0; i < elf->ehdr->e_shnum; i++) {
    if (curr_shdr->sh_type != SHT_NULL &&
        strcmp(elf_get_sec_name(elf, curr_shdr), name) == 0)
      return curr_shdr;

    curr_shdr++;
  }

  return NULL;
}

const char *elf_get_sec_name(
    const struct mapped_elf *elf,
    const Elf64_Shdr *shdr)
{
  if (elf->shstrtab == NULL)
    return NULL;

  return (const char *) (elf->start + elf->shstrtab->sh_offset + shdr->sh_name);
}

uint8_t *elf_get_sym_location(
    const struct mapped_elf *elf,
    const Elf64_Sym *sym)
{
  for (int i = 0; i < elf->ehdr->e_phnum; i++) {
    Elf64_Phdr *curr_phdr = elf->phdr_tbl + i;

    if (curr_phdr->p_type != PT_LOAD)
      continue;

    if (curr_phdr->p_vaddr <= sym->st_value &&
        (curr_phdr->p_vaddr + curr_phdr->p_memsz) > sym->st_value) {
      return (void *) (elf->start + (curr_phdr->p_offset +
                      (sym->st_value - curr_phdr->p_vaddr)));
    }
  }

  return NULL;
}

int elf_sym_in_text(
    const struct mapped_elf *elf,
    const Elf64_Sym *sym)
{
  return elf->text->sh_addr <= sym->st_value &&
         (elf->text->sh_addr + elf->text->sh_size) > sym->st_value;
}

const char *elf_get_sym_name(
    const struct mapped_elf *elf,
    const Elf64_Sym *sym)
{
  return (const char *) (elf->start + elf->strtab->sh_offset + sym->st_name);
}

```

`packer/include/elfutils.h`:

```h
#ifndef __KITESHIELD_ELFUTILS_H
#define __KITESHIELD_ELFUTILS_H

/* General ELF utility functions */

#include <elf.h>
#include <stddef.h>

struct mapped_elf {
  uint8_t *start;
  size_t size;

  Elf64_Ehdr *ehdr;
  Elf64_Phdr *phdr_tbl;
  Elf64_Shdr *shdr_tbl;

  const Elf64_Shdr *shstrtab;
  const Elf64_Shdr *strtab;
  const Elf64_Shdr *symtab;
  const Elf64_Shdr *text;
};

#define ELF_FOR_EACH_SYMBOL(elf, __cursor)                                                        \
  for (Elf64_Sym *__cursor = (Elf64_Sym *) (elf->start + elf->symtab->sh_offset);                 \
       (void *) __cursor < (void *) (elf->start + elf->symtab->sh_offset + elf->symtab->sh_size); \
       __cursor++)                                                                                \

void parse_mapped_elf(
    void *start,
    size_t size,
    struct mapped_elf *elf);

const char *elf_get_sec_name(
    const struct mapped_elf *elf,
    const Elf64_Shdr *shdr);

const Elf64_Shdr *elf_get_sec_by_name(
    const struct mapped_elf *elf,
    const char *name);

uint8_t *elf_get_sym_location(
    const struct mapped_elf *elf,
    const Elf64_Sym *sym);

const char *elf_get_sym_name(
    const struct mapped_elf *elf,
    const Elf64_Sym *sym);

int elf_sym_in_text(
    const struct mapped_elf *elf,
    const Elf64_Sym *func);

#endif /* __KITESHIELD_ELFUTILS_H */

```

`packer/kiteshield.c`:

```c
#include <stdio.h>
#include <time.h>
#include <elf.h>
#include <fcntl.h>
#include <string.h>
#include <stdarg.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdbool.h>
#include <unistd.h>

#include "bddisasm.h"

#include "common/include/rc4.h"
#include "common/include/obfuscation.h"
#include "common/include/defs.h"
#include "packer/include/elfutils.h"

#include "loader/out/generated_loader_rt.h"
#include "loader/out/generated_loader_no_rt.h"

/* Convenience macro for error checking libc calls */
#define CK_NEQ_PERROR(stmt, err)                                              \
  do {                                                                        \
    if ((stmt) == err) {                                                      \
      perror(#stmt);                                                          \
      return -1;                                                              \
    }                                                                         \
  } while(0)

#define STRINGIFY_KEY(key)                                                    \
  ({ char buf[(sizeof(key.bytes) * 2) + 1];                                   \
     for (int i = 0; i < sizeof(key.bytes); i++) {                            \
       sprintf(&buf[i * 2], "%02hhx", key.bytes[i]);                          \
     };                                                                       \
     buf; })

static int log_verbose = 0;

/* Needs to be defined for bddisasm */
int nd_vsnprintf_s(
    char *buffer,
    size_t sizeOfBuffer,
    size_t count,
    const char *format,
    va_list argptr)
{
  return vsnprintf(buffer, sizeOfBuffer, format, argptr);
}

/* Needs to be defined for bddisasm */
void* nd_memset(void *s, int c, size_t n)
{
  return memset(s, c, n);
}

static void err(char *fmt, ...)
{
  va_list args;
  va_start(args, fmt);

  vfprintf(stderr, fmt, args);
  printf("\n");
}

static void info(char *fmt, ...)
{
  va_list args;
  va_start(args, fmt);

  vprintf(fmt, args);
  printf("\n");
}

static void verbose(char *fmt, ...)
{
  if (!log_verbose)
    return;

  va_list args;
  va_start(args, fmt);

  vprintf(fmt, args);
  printf("\n");
}

static int read_input_elf(char *path, struct mapped_elf *elf)
{
  void *elf_buf;
  size_t size;

  FILE *file;
  CK_NEQ_PERROR(file = fopen(path, "r"), NULL);
  CK_NEQ_PERROR(fseek(file, 0L, SEEK_END), -1);

  CK_NEQ_PERROR(size = ftell(file), -1);
  CK_NEQ_PERROR(elf_buf = malloc(size), NULL);

  CK_NEQ_PERROR(fseek(file, 0L, SEEK_SET), -1);
  CK_NEQ_PERROR(fread(elf_buf, size, 1, file), 0);

  CK_NEQ_PERROR(fclose(file), EOF);

  parse_mapped_elf(elf_buf, size, elf);

  return 0;
}

static int produce_output_elf(
    FILE *output_file,
    struct mapped_elf *elf,
    void *loader,
    size_t loader_size)
{
  /* The entry address is located right after the struct rc4_key (used for
   * passing decryption key and other info to loader), which is the first
   * sizeof(struct rc4_key) bytes of the loader code (guaranteed by the linker
   * script) */
  Elf64_Addr entry_vaddr = LOADER_ADDR +
                           sizeof(Elf64_Ehdr) +
                           (sizeof(Elf64_Phdr) * 2) +
                           sizeof(struct rc4_key);
  Elf64_Ehdr ehdr;
  ehdr.e_ident[EI_MAG0] = ELFMAG0;
  ehdr.e_ident[EI_MAG1] = ELFMAG1;
  ehdr.e_ident[EI_MAG2] = ELFMAG2;
  ehdr.e_ident[EI_MAG3] = ELFMAG3;
  ehdr.e_ident[EI_CLASS] = ELFCLASS64;
  ehdr.e_ident[EI_DATA] = ELFDATA2LSB;
  ehdr.e_ident[EI_VERSION] = EV_CURRENT;
  ehdr.e_ident[EI_OSABI] = ELFOSABI_SYSV;
  ehdr.e_ident[EI_ABIVERSION] = 0;
  memset(ehdr.e_ident + EI_PAD, 0, EI_NIDENT - EI_PAD);

  ehdr.e_type = ET_EXEC;
  ehdr.e_machine = EM_X86_64;
  ehdr.e_version = EV_CURRENT;
  ehdr.e_entry = entry_vaddr;
  ehdr.e_phoff = sizeof(Elf64_Ehdr);
  ehdr.e_shoff = 0;
  ehdr.e_flags = 0;
  ehdr.e_ehsize = sizeof(Elf64_Ehdr);
  ehdr.e_phentsize = sizeof(Elf64_Phdr);
  ehdr.e_phnum = 2;
  ehdr.e_shentsize = sizeof(Elf64_Shdr);
  ehdr.e_shnum = 0;
  ehdr.e_shstrndx = SHN_UNDEF;

  CK_NEQ_PERROR(fwrite(&ehdr, sizeof(ehdr), 1, output_file), 0);

  /* Size of the first segment include the size of the ehdr and two phdrs */
  size_t hdrs_size = sizeof(Elf64_Ehdr) + (2 * sizeof(Elf64_Phdr));

  /* Program header for loader */
  Elf64_Phdr loader_phdr;
  loader_phdr.p_type = PT_LOAD;
  loader_phdr.p_offset = 0;
  loader_phdr.p_vaddr = LOADER_ADDR;
  loader_phdr.p_paddr = loader_phdr.p_vaddr;
  loader_phdr.p_filesz = loader_size + hdrs_size;
  loader_phdr.p_memsz = loader_size + hdrs_size;
  loader_phdr.p_flags = PF_R | PF_W | PF_X;
  loader_phdr.p_align = 0x200000;
  CK_NEQ_PERROR(fwrite(&loader_phdr, sizeof(loader_phdr), 1, output_file), 0);

  /* Program header for packed application */
  int app_offset = ftell(output_file) + sizeof(Elf64_Phdr) + loader_size;
  Elf64_Phdr app_phdr;
  app_phdr.p_type = PT_LOAD;
  app_phdr.p_offset = app_offset;
  app_phdr.p_vaddr = PACKED_BIN_ADDR + app_offset; /* Keep vaddr aligned */
  app_phdr.p_paddr = app_phdr.p_vaddr;
  app_phdr.p_filesz = elf->size;
  app_phdr.p_memsz = elf->size;
  app_phdr.p_flags = PF_R | PF_W;
  app_phdr.p_align =  0x200000;
  CK_NEQ_PERROR(fwrite(&app_phdr, sizeof(app_phdr), 1, output_file), 0);

  /* Loader code/data */
  CK_NEQ_PERROR(
      fwrite(loader, loader_size, 1, output_file), 0);

  /* Packed application contents */
  CK_NEQ_PERROR(fwrite(elf->start, elf->size, 1, output_file), 0);

  return 0;
}

static int get_random_bytes(void *buf, size_t len)
{
  FILE *f;
  CK_NEQ_PERROR(f = fopen("/dev/urandom", "r"), NULL);
  CK_NEQ_PERROR(fread(buf, len, 1, f), 0);
  CK_NEQ_PERROR(fclose(f), EOF);

  return 0;
}

static void encrypt_memory_range(struct rc4_key *key, void *start, size_t len)
{
  struct rc4_state rc4;
  rc4_init(&rc4, key->bytes, sizeof(key->bytes));

  uint8_t *curr = start;
  for (size_t i = 0; i < len; i++) {
    *curr = *curr ^ rc4_get_byte(&rc4);
    curr++;
  }
}

static uint64_t get_base_addr(Elf64_Ehdr *ehdr)
{
  /* Return the base address that the binary is to be mapped in at runtime. If
   * statically linked, use absolute addresses (ie. base address = 0).
   * Otherwise, everything is relative to DYN_PROG_BASE_ADDR. */
  return ehdr->e_type == ET_EXEC ? 0ULL : DYN_PROG_BASE_ADDR;
}

/* Determines if the given jmp instruction requires replacement by an int3 and
 * thus a trap into the runtime at program execution time. JMPs that do leave
 * or have the potential to leave their containing function require
 * instrumentation as otherwise program control would could be handed to
 * encrypted code.
 *
 * While not normally generated by C compilers for average C code, binaries can
 * and do have these kinds of jmps. setjmp/longjmp is one example. glibc
 * additionally contains several of these jumps as a result of handwritten asm
 * or other nonstandard internal constructs.
 */
static int is_instrumentable_jmp(
    INSTRUX *ix,
    uint64_t fcn_start,
    size_t fcn_size,
    uint64_t ix_addr)
{
  /* Indirect jump (eg. jump to value stored in register or at memory location.
   * These must always be instrumented as we have no way at pack-time of
   * knowing where they will hand control, thus the runtime must check them
   * each time and encrypt/decrypt/do nothing as needed.
   */
  if (ix->Instruction == ND_INS_JMPNI)
    return 1;

  /* Jump with (known at pack-time) relative offset, check if it jumps out of
   * its function, if so, it requires instrumentation. */
  if (ix->Instruction == ND_INS_JMPNR || ix->Instruction == ND_INS_Jcc) {
    /* Rel is relative to next instruction so we must add the length */
    int64_t displacement =
      (int64_t) ix->Operands[0].Info.RelativeOffset.Rel + ix->Length;
    uint64_t jmp_dest = ix_addr + displacement;
    if (jmp_dest < fcn_start || jmp_dest >= fcn_start + fcn_size)
      return 1;
  }

  return 0;
}

/* Instruments all appropriate points in the given function (function entry,
 * ret instructions, applicable jmp instructions) with int3 instructions and
 * encrypts it with a newly generated key.
 */
static int process_func(
    struct mapped_elf *elf,
    Elf64_Sym *func_sym,
    struct runtime_info *rt_info,
    struct function *func_arr,
    struct trap_point *tp_arr)
{
  uint8_t *func_start = elf_get_sym_location(elf, func_sym);
  uint64_t base_addr = get_base_addr(elf->ehdr);
  struct function *fcn = &func_arr[rt_info->nfuncs];

  fcn->id = rt_info->nfuncs;
  fcn->start_addr = base_addr + func_sym->st_value;
  fcn->len = func_sym->st_size;
  CK_NEQ_PERROR(get_random_bytes(fcn->key.bytes, sizeof(fcn->key.bytes)), -1);
#ifdef DEBUG_OUTPUT
  strncpy(fcn->name, elf_get_sym_name(elf, func_sym), sizeof(fcn->name));
  fcn->name[sizeof(fcn->name) - 1] = '\0';
#endif

  info("encrypting function %s with key %s",
      elf_get_sym_name(elf, func_sym), STRINGIFY_KEY(fcn->key));

  uint8_t *code_ptr = func_start;
  while (code_ptr < func_start + func_sym->st_size) {
    /* Iterate over every instruction in the function and determine if it
     * requires instrumentation */
    size_t off = (size_t) (code_ptr - func_start);
    uint64_t addr = base_addr + func_sym->st_value + off;

    INSTRUX ix;
    NDSTATUS status = NdDecode(&ix, code_ptr, ND_CODE_64, ND_DATA_64);
    if (!ND_SUCCESS(status)) {
      err("instruction decoding failed at address %p for function %s",
            addr, elf_get_sym_name(elf, func_sym));
      return -1;
    }

    int is_jmp_to_instrument = is_instrumentable_jmp(
        &ix,
        fcn->start_addr,
        func_sym->st_size,
        addr);
    int is_ret_to_instrument =
      ix.Instruction == ND_INS_RETF || ix.Instruction == ND_INS_RETN;

    if (is_jmp_to_instrument || is_ret_to_instrument) {
      struct trap_point *tp =
        (struct trap_point *) &tp_arr[rt_info->ntraps++];

      verbose("\tinstrumenting %s instr at address %p", ix.Mnemonic, addr, off);

      tp->addr = addr;
      tp->type = is_ret_to_instrument ? TP_RET : TP_JMP;
      tp->value = *code_ptr;
      tp->fcn_i = rt_info->nfuncs;
      *code_ptr = INT3;
    }

    code_ptr += ix.Length;
  }

  /* Instrument entry point */
  struct trap_point *tp =
    (struct trap_point *) &tp_arr[rt_info->ntraps++];
  tp->addr = base_addr + func_sym->st_value;
  tp->type = TP_FCN_ENTRY;
  tp->value = *func_start;
  tp->fcn_i = rt_info->nfuncs;

  encrypt_memory_range(&fcn->key, func_start, func_sym->st_size);

  *func_start = INT3;

  rt_info->nfuncs++;

  return 0;
}

/* Individually encrypts every function in the input ELF with their own keys
 * and instruments function entry and exit points as appropriate such that
 * the runtime can encrypt/decrypt during execution.
 */
static int apply_inner_encryption(
    struct mapped_elf *elf,
    struct runtime_info **rt_info)
{
  info("applying inner encryption");

  if (elf->ehdr->e_shoff == 0 || !elf->symtab) {
    info("binary is stripped, not applying inner encryption");
    return -1;
  }

  if (!elf->strtab) {
    err("could not find string table, not applying inner encryption");
    return -1;
  }

  CK_NEQ_PERROR(*rt_info = malloc(sizeof(**rt_info)), NULL);
  (*rt_info)->nfuncs = 0;
  (*rt_info)->ntraps = 0;

  /* "16 MiB ought to be enough for anybody" */
  struct function *fcn_arr;
  CK_NEQ_PERROR(fcn_arr = malloc(1<<24), NULL);

  struct trap_point *tp_arr;
  CK_NEQ_PERROR(tp_arr = malloc(1<<24), NULL);

  ELF_FOR_EACH_SYMBOL(elf, sym) {
    if (ELF64_ST_TYPE(sym->st_info) != STT_FUNC)
      continue;

    /* Statically linked binaries contain several function symbols that alias
     * each other (_IO_vfprintf and fprintf in glibc for instance).
     * Furthermore, there can occasionally be functions that overlap other
     * functions at the ELF level due to weird optimizations and/or custom
     * linker logic (confirmed present in the CentOS 7 glibc-static package)
     *
     * Detect and skip them here as to not double-encrypt.
     */
    uint64_t base = get_base_addr(elf->ehdr);
    struct function *alias = NULL;
    for (size_t i = 0; i < (*rt_info)->nfuncs; i++) {
      struct function *fcn = &fcn_arr[i];

      /* If there's any overlap at all between something we've already
       * encrypted, abort */
      if ((fcn->start_addr < (base + sym->st_value + sym->st_size)) &&
          ((fcn->start_addr + fcn->len) > base + sym->st_value)) {
        alias = fcn;
        break;
      }
    }

    if (alias) {
      /* We have alias->name if DEBUG_OUTPUT is set, so output it for a bit
       * more useful info */
#ifndef DEBUG_OUTPUT
        verbose(
            "not encrypting function %s at %p as it aliases or overlaps one already encrypted at %p of len %u",
            elf_get_sym_name(elf, sym), alias->start_addr, alias->len);
#else
        verbose(
            "not encrypting function %s at %p as it aliases or overlaps %s at %p of len %u",
            elf_get_sym_name(elf, sym), base + sym->st_value, alias->name, alias->start_addr, alias->len);
#endif

        continue;
    }

    /* Skip instrumenting/encrypting functions in cases where it simply will
     * not work or has the potential to mess things up. Specifically, this
     * means we don't instrument functions that:
     *
     *  * Are not in .text (eg. stuff in .init)
     *
     *  * Have an address of 0 (stuff that needs to be relocated, this should
     *  be covered by the point above anyways, but check to be safe)
     *
     *  * Have a size of 0 (stuff in crtstuff.c that was compiled with
     *  -finhibit-size-directive has a size of 0, thus we can't instrument)
     *
     *  * Have a size less than 2 (superset of above point). Instrumentation
     *  requires inserting at least two int3 instructions, each of which is one
     *  byte.
     *
     *  * Start with an instruction that modifies control flow (ie. jmp/ret)
     *  kiteshield instruments the start of every function AND every out of
     *  function jmp/return, so instrumenting these would require putting two
     *  trap points at the same address. It's theoretically possible to support
     *  this in the runtime, but would add a large amount of complexity to it
     *  in order to support encrypting the small amount of hand coded asm
     *  functions in glibc that are like this.
     */
    if (!elf_sym_in_text(elf, sym)) {
      verbose("not encrypting function %s as it's not in .text",
              elf_get_sym_name(elf, sym));
      continue;
    } else if (sym->st_value == 0 ||
               sym->st_size < 2) {
      verbose(
          "not encrypting function %s due to its address or size",
          elf_get_sym_name(elf, sym));
      continue;
    }

    /* We need to do this decoding down here as if we don't, sym->st_value
     * could be 0.
     */
    uint8_t *func_code_start = elf_get_sym_location(elf, sym);
    INSTRUX ix;
    NDSTATUS status = NdDecode(&ix, func_code_start, ND_CODE_64, ND_DATA_64);
    if (!ND_SUCCESS(status)) {
      err("instruction decoding failed at address %p for function %s",
          sym->st_value, elf_get_sym_name(elf, sym));
      return -1;
    }

    if (ix.Instruction == ND_INS_JMPNI ||
        ix.Instruction == ND_INS_JMPNR ||
        ix.Instruction == ND_INS_Jcc ||
        ix.Instruction == ND_INS_CALLNI ||
        ix.Instruction == ND_INS_CALLNR ||
        ix.Instruction == ND_INS_RETN) {
      verbose("not encrypting function %s due to first instruction being jmp/ret/call",
              elf_get_sym_name(elf, sym));
      continue;
    }

    if (process_func(elf, sym, *rt_info, fcn_arr, tp_arr) == -1) {
      err("error instrumenting function %s", elf_get_sym_name(elf, sym));
      return -1;
    }
  }

  size_t tp_arr_sz = sizeof(struct trap_point) * (*rt_info)->ntraps;
  size_t fcn_arr_sz = sizeof(struct function) * (*rt_info)->nfuncs;
  CK_NEQ_PERROR(
      *rt_info = realloc(*rt_info,
              sizeof(struct runtime_info) + tp_arr_sz + fcn_arr_sz),
      NULL);

  memcpy((*rt_info)->data, tp_arr, tp_arr_sz);
  memcpy((*rt_info)->data + tp_arr_sz, fcn_arr, fcn_arr_sz);

  free(tp_arr);
  free(fcn_arr);

  return 0;
}

/* Encrypts the input binary as a whole injects the outer key into the loader
 * code so the loader can decrypt.
 */
static int apply_outer_encryption(
    struct mapped_elf *elf,
    void *loader_start,
    size_t loader_size)
{
  struct rc4_key key;
  CK_NEQ_PERROR(get_random_bytes(key.bytes, sizeof(key.bytes)), -1);
  info("applying outer encryption with key %s", STRINGIFY_KEY(key));

  /* Encrypt the actual binary */
  encrypt_memory_range(&key, elf->start, elf->size);

  /* Obfuscate Key */
  struct rc4_key obfuscated_key;
  obf_deobf_outer_key(&key, &obfuscated_key, loader_start, loader_size);

  /* Copy over obfuscated key so the loader can decrypt */
  *((struct rc4_key *) loader_start) = obfuscated_key;

  return 0;
}

static void *inject_rt_info(
    void *loader,
    struct runtime_info *rt_info,
    size_t old_size,
    size_t *new_size)
{
  size_t rt_info_size = sizeof(struct runtime_info) +
                        sizeof(struct trap_point) * rt_info->ntraps +
                        sizeof(struct function) * rt_info->nfuncs;
  void *loader_rt_info = malloc(old_size + rt_info_size);
  obf_deobf_rt_info(rt_info);
  memcpy(loader_rt_info, loader, old_size);
  *new_size = old_size + rt_info_size;

  info("injected runtime info into loader (old size: %u new size: %u)",
      old_size, *new_size);


  /* subtract sizeof(struct runtime_info) here to ensure we overwrite the
   * non flexible-array portion of the struct that the linker actually puts in
   * the code. */
  memcpy(loader_rt_info + old_size - sizeof(struct runtime_info),
         rt_info, rt_info_size);

  return loader_rt_info;
}

/* Removes everything not needed for program execution from the binary, note
 * that this differs from the standard system strip utility which just discards
 * the .symtab section. This strips everything not covered by a segment as
 * described in the program header table to ensure absolutely no debugging
 * information is left over to aid a reverse engineer. */
static int full_strip(struct mapped_elf *elf)
{
  Elf64_Phdr *curr_phdr = elf->phdr_tbl;
  size_t new_size = 0;
  info("stripping input binary");

  /* Calculate minimum size needed to contain all program headers */
  for (int i = 0; i < elf->ehdr->e_phnum; i++) {
    size_t seg_end = curr_phdr->p_offset + curr_phdr->p_filesz;
    if (seg_end > new_size)
      new_size = seg_end;
    curr_phdr++;
  }

  if (elf->ehdr->e_shoff >= new_size) {
    elf->ehdr->e_shoff = 0;
    elf->ehdr->e_shnum = 0;
    elf->ehdr->e_shstrndx = 0;
  } else {
    info("warning: could not strip out all section info from binary");
    info("output binary may be corrupt!");
  }

  void *new_elf = malloc(new_size);
  CK_NEQ_PERROR(new_elf, NULL);
  memcpy(new_elf, elf->start, new_size);
  free(elf->start);
  parse_mapped_elf(new_elf, new_size, elf);

  return 0;
}

static void usage()
{
  info(
      "Kiteshield, an obfuscating packer for x86-64 binaries on Linux\n"
      "Usage: kiteshield [OPTION] INPUT_FILE OUTPUT_FILE\n\n"
      "  -n       don't apply inner encryption (per-function encryption)\n"
      "  -v       verbose logging"
  );
}

static void banner()
{
  info("                                                    ________\n"
       " _     _  _              _      _        _      _  |   ||   |\n"
       "| |   (_)| |            | |    (_)      | |    | | |___||___|\n"
       "| | __ _ | |_  ___  ___ | |__   _   ___ | |  __| | |___  ___|\n"
       "| |/ /| || __|/ _ \\/ __|| '_ \\ | | / _ \\| | / _` | |   ||   | \n"
       "|   < | || |_|  __/\\__ \\| | | || ||  __/| || (_| |  \\  ||  /\n"
       "|_|\\_\\|_| \\__|\\___||___/|_| |_||_| \\___||_| \\__,_|   \\_||_/\n"
       "Kiteshield: A packer/protector for x86-64 ELF binaries on Linux\n"
       "Copyright (c) Rhys Rustad-Elliott, released under the MIT license\n"
  );
}

int main(int argc, char *argv[])
{
  char *input_path, *output_path;
  int layer_one_only = 0;
  int c;
  int ret;

  while ((c = getopt (argc, argv, "nv")) != -1) {
    switch (c) {
    case 'n':
      layer_one_only = 1;
      break;
    case 'v':
      log_verbose = 1;
      break;
    default:
      usage();
      return -1;
    }
  }

  if (optind + 1 < argc) {
    input_path = argv[optind];
    output_path = argv[optind + 1];
  } else {
    usage();
    return -1;
  }


  banner();

  /* Read ELF to be packed */
  info("reading input binary %s", input_path);
  struct mapped_elf elf;
  ret = read_input_elf(input_path, &elf);
  if (ret == -1) {
    err("error reading input ELF: %s", strerror(errno));
    return -1;
  }

  /* Select loader to use based on the presence of the -n flag. Use the
   * no-runtime version if we're only applying layer 1 or the runtime version
   * if we're applying layer 1 and 2 encryption.
   */
  void *loader;
  size_t loader_size;
  if (!layer_one_only) {
    struct runtime_info *rt_info = NULL;
    ret = apply_inner_encryption(&elf, &rt_info);
    if (ret == -1) {
      err("could not apply inner encryption");
      return -1;
    }

    loader = inject_rt_info(GENERATED_LOADER_RT, rt_info,
        sizeof(GENERATED_LOADER_RT), &loader_size);
  } else {
    info("not applying inner encryption and omitting runtime (-n)");

    loader = GENERATED_LOADER_NO_RT;
    loader_size = sizeof(GENERATED_LOADER_NO_RT);
  }

  /* Fully strip binary */
  if (full_strip(&elf) == -1) {
    err("could not strip binary");
    return -1;
  }

  /* Apply outer encryption */
  ret = apply_outer_encryption(&elf, loader, loader_size);
  if (ret == -1) {
    err("could not apply outer encryption");
    return -1;
  }

  /* Write output ELF */
  FILE *output_file;
  CK_NEQ_PERROR(output_file = fopen(output_path, "w"), NULL);
  ret = produce_output_elf(output_file, &elf, loader, loader_size);
  if (ret == -1) {
    err("could not produce output ELF");
    return -1;
  }

  CK_NEQ_PERROR(fclose(output_file), EOF);
  CK_NEQ_PERROR(
      chmod(output_path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH), -1);

  info("output ELF has been written to %s", output_path);
  return 0;
}


```

`testing/README.md`:

```md
# Kiteshield Integration Test Infrastructure

This directory contains a suite of integration tests intended to exercise
Kiteshield's packer and loader to the greatest extent possible. Tests are
written as single-file C programs which are compiled, packed and run. Output on
standard out and exit status are then checked against expected values.

Notably, each test is compiled and packed in a large number of different
environments, spanning several Linux distros, C compilers, C libraries, and
compilation flags passed to the compiler when building the test. This ensures
as varied a set as possible of ELF binaries are passed to kiteshield for
packing and running. The tests for example, are compiled both statically and
dynamically linked, with various gcc and clang versions, and linked into both
glibc and musl libc. All these varied output binaries are then packed, run, and
have their output verified for correctness.

Several different Docker containers are used to create these environments. For
information on how this is done, see the shell scripts in this directory. They
are rather simple and should be self-documenting.

## Running Tests

```
./test.sh
```

## Adding New Tests

To add a new test called `mytest`, add your test code under `tests/mytest.c`
and expected output on standard output to a file called
`tests/expected_output/mytest`. Then add the following line to
`run_test_set.sh` (assuming 0 is the expected exit code of the test):

```
RUN_RT_AND_NORT_TESTS mytest 0
```

```

`testing/build_test_set.sh`:

```sh
#!/usr/bin/env bash

source output_wrappers.sh

BUILD_TESTS () {
  CC=$1
  CFLAGS=$2

  for C_SRC in tests/*.c
  do
    CC_OUPTPUT_FILE=$(mktemp)
    TEST_NAME=$(basename $C_SRC .c)

    # Kinda kludgy special case, if the test case starts with pthread_, that
    # indicates it requires linking with pthreads
    if [[ $TEST_NAME == pthread_* ]]
    then
      CURR_CFLAGS="$CFLAGS -pthread"
    else
      CURR_CFLAGS=$CFLAGS
    fi

    $CC $CURR_CFLAGS $C_SRC -o out/$TEST_NAME > "$CC_OUPTPUT_FILE" 2>&1
    if [[ $? -ne 0 ]]
    then
      echo_red "Compilation failed in test $TEST_NAME"
      echo_red "*******COMPILER OUTPUT*******"
      cat $CC_OUPTPUT_FILE
      echo_red "*******END COMPILER OUTPUT*******"
      exit 1
    fi
  done

  return 0
}

BUILD_TESTS $1 $2


```

`testing/dockerfiles/Dockerfile-alpine`:

```
FROM alpine:latest

RUN apk add bash build-base clang


```

`testing/dockerfiles/Dockerfile-centos-7`:

```
FROM centos:7

RUN yum install -y gcc clang glibc-static


```

`testing/dockerfiles/Dockerfile-centos-8`:

```
FROM centos:8

# Needed to get glibc-static
RUN yum install -y dnf-plugins-core
run yum config-manager -y --set-enabled powertools

RUN yum install -y gcc clang glibc-static


```

`testing/dockerfiles/Dockerfile-fedora`:

```
FROM fedora:33

RUN dnf -y install gcc clang glibc-static


```

`testing/dockerfiles/Dockerfile-ubuntu-bionic`:

```
FROM ubuntu:18.04

RUN apt-get update
RUN apt-get -y install build-essential python3
RUN apt-get -y install gcc-5 gcc-6 gcc-7 gcc-8 clang-4.0 clang-5.0 clang-6.0 \
  clang-7 clang-8 clang-9 clang-10


```

`testing/dockerfiles/Dockerfile-ubuntu-focal`:

```
FROM ubuntu:20.04

RUN apt-get update
RUN apt-get -y install build-essential python3
RUN apt-get -y install gcc-7 gcc-8 gcc-9 gcc-10 clang-6.0 clang-7 clang-8 \
  clang-9 clang-10 clang-11


```

`testing/dockerfiles/Dockerfile-ubuntu-trusty`:

```
FROM ubuntu:14.04

RUN ["apt-get", "update"]
RUN ["apt-get", "-y", "install", "build-essential", "python3"]
RUN ["apt-get", "-y", "install", "gcc", "clang-3.6"]


```

`testing/dockerfiles/Dockerfile-ubuntu-xenial`:

```
FROM ubuntu:16.04

RUN ["apt-get", "update"]
RUN ["apt-get", "-y", "install", "build-essential", "python3"]
RUN ["apt-get", "-y", "install", "gcc", "clang-3.5", "clang-4.0", "clang-5.0"]


```

`testing/output_wrappers.sh`:

```sh
BOLD='\033[1m'
NOBOLD='\033[0m'

NOCOLOR='\033[0m'
RED='\033[0;31m'
GREEN='\033[0;32m'
ORANGE='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
LIGHTGRAY='\033[0;37m'
DARKGRAY='\033[1;30m'
LIGHTRED='\033[1;31m'
LIGHTGREEN='\033[1;32m'
YELLOW='\033[1;33m'
LIGHTBLUE='\033[1;34m'
LIGHTPURPLE='\033[1;35m'
LIGHTCYAN='\033[1;36m'
WHITE='\033[1;37m'

CHECK_MARK=$(echo -e "\xE2\x9C\x94")
X_MARK=$(echo -e "\xE2\x9C\x97")

function echo_red () {
  echo -e "${RED}${BOLD}$1${NOBOLD}${NOCOLOR}"
}

function echo_green () {
  echo -e "${GREEN}${BOLD}$1${NOBOLD}${NOCOLOR}"
}

function echo_bold () {
  echo -e "${BOLD}$1${NOBOLD}"
}


```

`testing/run_test_set.sh`:

```sh
#!/usr/bin/env bash

source output_wrappers.sh

RUN_TEST () {
  TEST_NAME=$1
  BINARY=$2
  EXPECTED_STATUS=$3
  EXPECTED_OUTPUT=$4

  printf "\t%-60s" "Running test $TEST_NAME"
  ACTUAL_OUTPUT=$(./out/$BINARY)
  ACTUAL_STATUS=$?

  if [[ $ACTUAL_STATUS -ne $EXPECTED_STATUS ]]
  then
    echo_red "$X_MARK failed"

    echo_red "Status differs from expected status in $TEST_NAME"
    echo_red "Expected status: $EXPECTED_STATUS, actual status $ACTUAL_STATUS"
    exit 1;
  elif [ "$ACTUAL_OUTPUT" != "$EXPECTED_OUTPUT" ]
  then
    echo_red "$X_MARK failed"

    echo_red "Output differs from expected output in $TEST_NAME"
    echo_red "*******ACTUAL OUTPUT*******"
    echo "$ACTUAL_OUTPUT"
    echo_red "*******EXPECTED OUTPUT*******"
    echo "$EXPECTED_OUTPUT"
    echo_red "*******END EXPECTED OUTPUT*******"

    exit 1
  else
    echo_green "$CHECK_MARK passed"
  fi


}

RUN_RT_AND_NORT_TESTS () {
  BIN_NAME=$1
  EXPECTED_STATUS=$2
  EXPECTED_OUTPUT=$(cat ./tests/expected_outputs/$BIN_NAME)

  RUN_TEST "(layer 1) ${BIN_NAME}" "${BIN_NAME}.ks.nort" $EXPECTED_STATUS "$EXPECTED_OUTPUT"
  RUN_TEST "(layer 1/2) ${BIN_NAME}" "${BIN_NAME}.ks" $EXPECTED_STATUS "$EXPECTED_OUTPUT"

  return 0;
}

# Single-threaded tests
RUN_RT_AND_NORT_TESTS helloworld 0
RUN_RT_AND_NORT_TESTS multicall 0
RUN_RT_AND_NORT_TESTS recursion 0
RUN_RT_AND_NORT_TESTS file_read 0
RUN_RT_AND_NORT_TESTS longjmp 0
RUN_RT_AND_NORT_TESTS mutual_recursion 0
RUN_RT_AND_NORT_TESTS prime_sieve 0
RUN_RT_AND_NORT_TESTS static_data 0
RUN_RT_AND_NORT_TESTS signals 0

# Muti-threaded tests
RUN_RT_AND_NORT_TESTS pthread_simple 0
RUN_RT_AND_NORT_TESTS pthread_many_threads 0
RUN_RT_AND_NORT_TESTS pthread_shared_stacktraces 0
RUN_RT_AND_NORT_TESTS pthread_exit_deep_in_callstack 0
RUN_RT_AND_NORT_TESTS pthread_with_fork 0
RUN_RT_AND_NORT_TESTS pthread_thread_leader_exit 0
RUN_RT_AND_NORT_TESTS fork_simple 0
RUN_RT_AND_NORT_TESTS fork_many 0
RUN_RT_AND_NORT_TESTS fork_chain 0
RUN_RT_AND_NORT_TESTS fork_exec 0

```

`testing/test.sh`:

```sh
#!/usr/bin/env bash

source output_wrappers.sh

RUN_CONTAINER_TESTS () {
  IMG=$1
  CC=$2
  CFLAGS=$3
  TEST_ID="$IMG/$CC/\"$CFLAGS\""

  echo_bold "Test suite $TEST_ID"

  rm -r testing/out
  mkdir -p testing/out

  printf "\t%-60s" "Building test container..."
  docker build \
    --quiet \
    -t ${IMG}-ks-test \
    -f testing/dockerfiles/Dockerfile-${IMG} . > /dev/null

  if [ $? -ne 0 ]
  then
    echo_red -e "\tError building docker image"
    exit 1
  else
    echo_green "$CHECK_MARK done"
  fi

  printf "\t%-60s" "Building tests..."
  docker run \
    --rm \
    --cap-add=SYS_PTRACE \
    --user 1000:1000 \
    --volume $(pwd):/kiteshield \
    --workdir=/kiteshield/testing \
    ${IMG}-ks-test ./build_test_set.sh $CC $CFLAGS

  if [ $? -ne 0 ]
  then
    echo -e "\tFailure building tests"
    exit 1
  else
    echo_green "$CHECK_MARK done"
  fi

  printf "\t%-60s" "Packing test binaries..."
  for UNPACKED_BIN in testing/out/*
  do
    PACKER_OUTPUT=$(mktemp)
    packer/kiteshield -v $UNPACKED_BIN ${UNPACKED_BIN}.ks > "$PACKER_OUTPUT"

    if [ $? -ne 0 ]
    then
      echo -e "\tFailure packing test binary (layer 1 & 2) $UNPACKED_BIN for $TEST_ID"
      echo -e "\t*******PACKER OUTPUT*******"
      cat $PACKER_OUTPUT
      echo -e "\t*******END PACKER OUTPUT*******"
      exit 1
    fi

    packer/kiteshield -v -n $UNPACKED_BIN ${UNPACKED_BIN}.ks.nort > "$PACKER_OUTPUT"
    if [ $? -ne 0 ]
    then
      echo -e "\tFailure packing test binary (layer 1) $UNPACKED_BIN for $TEST_ID"
      echo -e "\t*******PACKER OUTPUT*******"
      cat $PACKER_OUTPUT
      echo -e "\t*******END PACKER OUTPUT*******"
      exit 1
    fi
  done

  echo_green "$CHECK_MARK done"

  docker run \
    --rm \
    --cap-add=SYS_PTRACE \
    --user 1000:1000 \
    --volume $(pwd):/kiteshield \
    --workdir=/kiteshield/testing \
    ${IMG}-ks-test ./run_test_set.sh

  if [ $? -ne 0 ]
  then
    echo_red "\tFailure running tests"
    exit 1
  else
    echo_green "\tAll tests passed for suite $TEST_ID"
  fi
}

RUN_CONTAINER_TESTS_CFLAGS () {
  RUN_CONTAINER_TESTS $1 $2 ""
  RUN_CONTAINER_TESTS $1 $2 "-static"
  RUN_CONTAINER_TESTS $1 $2 "-static -O3"
}

cd ..

make clean
make

RUN_CONTAINER_TESTS_CFLAGS centos-8 gcc
RUN_CONTAINER_TESTS_CFLAGS centos-8 clang

RUN_CONTAINER_TESTS_CFLAGS centos-7 gcc
RUN_CONTAINER_TESTS_CFLAGS centos-7 clang

RUN_CONTAINER_TESTS_CFLAGS alpine gcc
RUN_CONTAINER_TESTS_CFLAGS alpine clang

RUN_CONTAINER_TESTS_CFLAGS fedora gcc
RUN_CONTAINER_TESTS_CFLAGS fedora clang

RUN_CONTAINER_TESTS_CFLAGS ubuntu-trusty gcc
RUN_CONTAINER_TESTS_CFLAGS ubuntu-trusty clang-3.6

RUN_CONTAINER_TESTS_CFLAGS ubuntu-xenial gcc
RUN_CONTAINER_TESTS_CFLAGS ubuntu-xenial clang-3.5
RUN_CONTAINER_TESTS_CFLAGS ubuntu-xenial clang-4.0
RUN_CONTAINER_TESTS_CFLAGS ubuntu-xenial clang-5.0

RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic gcc-5
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic gcc-6
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic gcc-7
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic gcc-8
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-4.0
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-5.0
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-6.0
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-7
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-8
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-9
RUN_CONTAINER_TESTS_CFLAGS ubuntu-bionic clang-10

RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal gcc-7
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal gcc-8
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal gcc-9
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal gcc-10
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-6.0
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-7
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-8
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-9
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-10
RUN_CONTAINER_TESTS_CFLAGS ubuntu-focal clang-11


```

`testing/tests/expected_outputs/file_read`:

```
Read 5 bytes from /dev/urandom

```

`testing/tests/expected_outputs/fork_chain`:

```
in child, i=0
in child, i=1
in child, i=2
in child, i=3
in child, i=4
in child, i=5
in child, i=6
in child, i=7
in child, i=8
in child, i=9
in child, i=10
in child, i=11
in child, i=12
in child, i=13
in child, i=14
in child, i=15
in child, i=16
in child, i=17
in child, i=18
in child, i=19
in child, i=20
in child, i=21
in child, i=22
in child, i=23
in child, i=24
in child, i=25
in child, i=26
in child, i=27
in child, i=28
in child, i=29
in child, i=30
in child, i=31
in child, i=32
in child, i=33
in child, i=34
in child, i=35
in child, i=36
in child, i=37
in child, i=38
in child, i=39
in child, i=40
in child, i=41
in child, i=42
in child, i=43
in child, i=44
in child, i=45
in child, i=46
in child, i=47
in child, i=48
in child, i=49

```

`testing/tests/expected_outputs/fork_exec`:

```
hello world
child exited with status 0

```

`testing/tests/expected_outputs/fork_many`:

```
in child i=0
in parent, child exited with status 0
in child i=1
in parent, child exited with status 0
in child i=2
in parent, child exited with status 0
in child i=3
in parent, child exited with status 0
in child i=4
in parent, child exited with status 0
in child i=5
in parent, child exited with status 0
in child i=6
in parent, child exited with status 0
in child i=7
in parent, child exited with status 0
in child i=8
in parent, child exited with status 0
in child i=9
in parent, child exited with status 0
in child i=10
in parent, child exited with status 0
in child i=11
in parent, child exited with status 0
in child i=12
in parent, child exited with status 0
in child i=13
in parent, child exited with status 0
in child i=14
in parent, child exited with status 0
in child i=15
in parent, child exited with status 0
in child i=16
in parent, child exited with status 0
in child i=17
in parent, child exited with status 0
in child i=18
in parent, child exited with status 0
in child i=19
in parent, child exited with status 0
in child i=20
in parent, child exited with status 0
in child i=21
in parent, child exited with status 0
in child i=22
in parent, child exited with status 0
in child i=23
in parent, child exited with status 0
in child i=24
in parent, child exited with status 0
in child i=25
in parent, child exited with status 0
in child i=26
in parent, child exited with status 0
in child i=27
in parent, child exited with status 0
in child i=28
in parent, child exited with status 0
in child i=29
in parent, child exited with status 0
in child i=30
in parent, child exited with status 0
in child i=31
in parent, child exited with status 0
in child i=32
in parent, child exited with status 0
in child i=33
in parent, child exited with status 0
in child i=34
in parent, child exited with status 0
in child i=35
in parent, child exited with status 0
in child i=36
in parent, child exited with status 0
in child i=37
in parent, child exited with status 0
in child i=38
in parent, child exited with status 0
in child i=39
in parent, child exited with status 0
in child i=40
in parent, child exited with status 0
in child i=41
in parent, child exited with status 0
in child i=42
in parent, child exited with status 0
in child i=43
in parent, child exited with status 0
in child i=44
in parent, child exited with status 0
in child i=45
in parent, child exited with status 0
in child i=46
in parent, child exited with status 0
in child i=47
in parent, child exited with status 0
in child i=48
in parent, child exited with status 0
in child i=49
in parent, child exited with status 0

```

`testing/tests/expected_outputs/fork_simple`:

```
in child
in parent, child exited with status 0

```

`testing/tests/expected_outputs/helloworld`:

```
Hello World!

```

`testing/tests/expected_outputs/longjmp`:

```
second
main

```

`testing/tests/expected_outputs/multicall`:

```
Call count is now 1
Call count is now 2
Call count is now 3
Call count is now 4
Call count is now 5

```

`testing/tests/expected_outputs/mutual_recursion`:

```
Is 0 even? 1
Is 1 even? 0
Is 2 even? 1
Is 3 even? 0
Is 128 even? 1
Is 887 even? 0
Is 1284 even? 1

Is 0 odd? 0
Is 1 odd? 1
Is 2 odd? 0
Is 3 odd? 1
Is 128 odd? 0
Is 887 odd? 1
Is 1284 odd? 0

```

`testing/tests/expected_outputs/prime_sieve`:

```
2
3
5
7
11
13
17
19
23
29
31
37
41
43
47
53
59
61
67
71
73
79
83
89
97

```

`testing/tests/expected_outputs/pthread_exit_deep_in_callstack`:

```
thread is is exiting

```

`testing/tests/expected_outputs/pthread_many_threads`:

```
Thread 0 executing
Thread 1 executing
Thread 2 executing
Thread 3 executing
Thread 4 executing
Thread 5 executing
Thread 6 executing
Thread 7 executing
Thread 8 executing
Thread 9 executing
Thread 10 executing
Thread 11 executing
Thread 12 executing
Thread 13 executing
Thread 14 executing
Thread 15 executing
Thread 16 executing
Thread 17 executing
Thread 18 executing
Thread 19 executing
Thread 20 executing
Thread 21 executing
Thread 22 executing
Thread 23 executing
Thread 24 executing
Thread 25 executing
Thread 26 executing
Thread 27 executing
Thread 28 executing
Thread 29 executing
Thread 30 executing
Thread 31 executing
Thread 32 executing
Thread 33 executing
Thread 34 executing
Thread 35 executing
Thread 36 executing
Thread 37 executing
Thread 38 executing
Thread 39 executing
Thread 40 executing
Thread 41 executing
Thread 42 executing
Thread 43 executing
Thread 44 executing
Thread 45 executing
Thread 46 executing
Thread 47 executing
Thread 48 executing
Thread 49 executing
Thread 50 executing
Thread 51 executing
Thread 52 executing
Thread 53 executing
Thread 54 executing
Thread 55 executing
Thread 56 executing
Thread 57 executing
Thread 58 executing
Thread 59 executing
Thread 60 executing
Thread 61 executing
Thread 62 executing
Thread 63 executing
Thread 64 executing
Thread 65 executing
Thread 66 executing
Thread 67 executing
Thread 68 executing
Thread 69 executing
Thread 70 executing
Thread 71 executing
Thread 72 executing
Thread 73 executing
Thread 74 executing
Thread 75 executing
Thread 76 executing
Thread 77 executing
Thread 78 executing
Thread 79 executing
Thread 80 executing
Thread 81 executing
Thread 82 executing
Thread 83 executing
Thread 84 executing
Thread 85 executing
Thread 86 executing
Thread 87 executing
Thread 88 executing
Thread 89 executing
Thread 90 executing
Thread 91 executing
Thread 92 executing
Thread 93 executing
Thread 94 executing
Thread 95 executing
Thread 96 executing
Thread 97 executing
Thread 98 executing
Thread 99 executing

```

`testing/tests/expected_outputs/pthread_shared_stacktraces`:

```
thread 0 is in fcn_2
thread 1 is in fcn_2
thread 2 is in fcn_2
thread 3 is in fcn_2
thread 4 is in fcn_2

```

`testing/tests/expected_outputs/pthread_simple`:

```
executing in new thread
thread returns: 0

```

`testing/tests/expected_outputs/pthread_thread_leader_exit`:

```
executing in new thread

```

`testing/tests/expected_outputs/pthread_with_fork`:

```
about to fork
executing in new thread
thread returns: 0
child exited with status 0

```

`testing/tests/expected_outputs/recursion`:

```
1409286144

```

`testing/tests/expected_outputs/signals`:

```
Caught signal 14
Caught signal 2
Caught signal 10
Caught signal 11

```

`testing/tests/expected_outputs/static_data`:

```
10000 bytes of static data are zeroed

```

`testing/tests/file_read.c`:

```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

int main()
{
  char buf[5];
  int fd = open("/dev/urandom", 0);
  ssize_t nbytes = read(fd, buf, 5);
  printf("Read %d bytes from /dev/urandom\n", nbytes);

  return 0;
}


```

`testing/tests/fork_chain.c`:

```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main()
{
  int i;
  for (i = 0; i < 50; i++) {
    pid_t p = fork();

    if (p == 0) {
      printf("in child, i=%d\n", i);
      fflush(stdout);
    } else {
      exit(0);
    }
  }

  return 0;
}

```

`testing/tests/fork_exec.c`:

```c
#include <unistd.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <stdio.h>

int main()
{
  pid_t pid = fork();

  if (pid == 0) {
    char *args[] = { "/bin/echo", "hello world", NULL };
    execv(args[0], args);
  } else {
    int wstatus;
    pid_t pid = wait(&wstatus);
    printf("child exited with status %d\n", WEXITSTATUS(wstatus));
    return 0;
  }
}

```

`testing/tests/fork_many.c`:

```c
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main()
{
  int i;
  for (i = 0; i < 50; i++) {
    pid_t p = fork();

    if (p == 0) {
      printf("in child i=%d\n", i);
      fflush(stdout);
      exit(0);
    } else {
      int wstatus;
      wait(&wstatus);

      if (WIFEXITED(wstatus)) {
        printf("in parent, child exited with status %d\n", WEXITSTATUS(wstatus));
        fflush(stdout);
      } else {
        abort();
      }
    }
  }
}

```

`testing/tests/fork_simple.c`:

```c
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>

int main()
{
  pid_t p = fork();

  if (p == 0) {
    printf("in child\n");
  } else {
    int wstatus;
    wait(&wstatus);

    if (WIFEXITED(wstatus)) {
      printf("in parent, child exited with status %d\n", WEXITSTATUS(wstatus));
    }
  }

  return 0;
}

```

`testing/tests/helloworld.c`:

```c
#include <stdio.h>

int main()
{
  puts("Hello World!");
  return 0;
}

```

`testing/tests/longjmp.c`:

```c
#include <stdio.h>
#include <setjmp.h>

static jmp_buf buf;

void second()
{
  printf("second\n");
  longjmp(buf,1);
}

void first()
{
  second();
  printf("first\n");
}

int main()
{
  if (setjmp(buf) == 0) {
    first();
  } else {
    printf("main\n");
  }

  return 0;
}


```

`testing/tests/multicall.c`:

```c
#include <stdio.h>

int call_count = 0;

int func()
{
  call_count++;
  printf("Call count is now %d\n", call_count);
}

int main()
{
  /* Call func repeatedly to ensure it's being correctly encrypted/decrypted
   * on each call */
  int i;
  for (i = 0; i < 5; i++) {
    func();
  }

  return 0;
}


```

`testing/tests/mutual_recursion.c`:

```c
#include <stdio.h>

int is_odd(int n);

int is_even(int n)
{
  if (n == 0) return 1;
  else return is_odd(n - 1);
}

int is_odd(int n)
{
  if (n == 0) return 0;
  else return is_even(n - 1);
}

int main()
{
  printf("Is 0 even? %d\n", is_even(0));
  printf("Is 1 even? %d\n", is_even(1));
  printf("Is 2 even? %d\n", is_even(2));
  printf("Is 3 even? %d\n", is_even(3));
  printf("Is 128 even? %d\n", is_even(128));
  printf("Is 887 even? %d\n", is_even(887));
  printf("Is 1284 even? %d\n", is_even(1284));

  printf("\n");

  printf("Is 0 odd? %d\n", is_odd(0));
  printf("Is 1 odd? %d\n", is_odd(1));
  printf("Is 2 odd? %d\n", is_odd(2));
  printf("Is 3 odd? %d\n", is_odd(3));
  printf("Is 128 odd? %d\n", is_odd(128));
  printf("Is 887 odd? %d\n", is_odd(887));
  printf("Is 1284 odd? %d\n", is_odd(1284));

  return 0;
}


```

`testing/tests/prime_sieve.c`:

```c
#include <stdio.h>
#include <string.h>

int main()
{
  int primes[100];
  int arr_size = sizeof(primes) / sizeof(int);
  int i, j;

  memset(primes, 1, sizeof(primes));

  for (i = 2; i < 10; i++) {
    if (!primes[i]) continue;
    primes[i] = 1;

    for (j = i * 2; j < arr_size; j+=i) {
      primes[j] = 0;
    }
  }

  for (i = 2; i < arr_size; i++) {
    if (primes[i])
      printf("%d\n", i);
  }

  return 0;
}


```

`testing/tests/pthread_exit_deep_in_callstack.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void fcn_5()
{
  printf("thread is is exiting\n");
  fflush(stdout);
  pthread_exit(NULL);
}

void fcn_4()
{
  fcn_5();
}

void fcn_3()
{
  fcn_4();
}

void fcn_2()
{
  fcn_3();
}

void *fcn_1(void *ptr)
{
  fcn_2();
}

int main()
{
  pthread_t thread;
  pthread_create(&thread, NULL, fcn_1, NULL);
  pthread_join(thread, NULL);

  return 0;
}

```

`testing/tests/pthread_many_threads.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *print_message_function(void *ptr)
{
  long id = (long) ptr;
  printf("Thread %d executing\n", id);
}

int main()
{
  long i;
  for (i = 0; i < 100; i++) {
    pthread_t thread;
    pthread_create(
        &thread, NULL, print_message_function, (void *) i);
    pthread_join(thread, NULL);
  }

  return 0;
}

```

`testing/tests/pthread_shared_stacktraces.c`:

```c
/* Spins a bunch of threads in fcn_1, which wait to go into fcn_2 in sequence
 * where they sequentially print their thread ID. Tests that we don't
 * accidentally encrypt fcn_1 when returning from it if other threads are
 * executing in it. */
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

long curr_thread = 0;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

void fcn_2(long id)
{
  printf("thread %d is in fcn_2\n", id);
  fflush(stdout);

  pthread_mutex_lock(&mutex);
  curr_thread++;
  pthread_mutex_unlock(&mutex);
}

void *fcn_1(void *ptr)
{
  long id = (long) ptr;

  while (1) {
    long val;

    pthread_mutex_lock(&mutex);
    val = curr_thread;
    pthread_mutex_unlock(&mutex);

    if (id == val) {
      fcn_2(id);
      break;
    }
  }
}

int main()
{
#define NTHREADS 5

  pthread_t threads[NTHREADS];
  long i;
  for (i = 0; i < NTHREADS; i++)
    pthread_create(&threads[i], NULL, fcn_1, (void *) i);

  for (i = 0; i < NTHREADS; i++)
    pthread_join(threads[i], NULL);

  return 0;
}

```

`testing/tests/pthread_simple.c`:

```c
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>

void *print_message_function(void *ptr)
{
  char *message = (char *) ptr;
  printf("%s\n", message);
}

int main()
{
  pthread_t thread;
  char *message = "executing in new thread";
  int ret = pthread_create(
  &thread, NULL, print_message_function, (void *) message);

  pthread_join(thread, NULL);

  printf("thread returns: %d\n",ret);

  return 0;
}

```

`testing/tests/pthread_thread_leader_exit.c`:

```c
/* Spins off a new thread then exits in the thread group leader only. This hits
 * a corner case in ptrace on Linux whereby the thread group leader will hang
 * around as a zombie and cannot be waited on, despite having exited (see
 * comments in runtime.c).
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <pthread.h>

void *print_message_function(void *ptr)
{
  char *message = (char *) ptr;
  printf("%s\n", message);
  fflush(stdout);
  sleep(1);
}

int main()
{
  pthread_t thread;
  char *message = "executing in new thread";
  int ret = pthread_create(
  &thread, NULL, print_message_function, (void *) message);

  /* Directly make an exit syscall, _exit(2) and exit(3) will both call
   * exit_group, which will terminate all threads in the group. */
  asm volatile (
      "mov $60, %%rax\n"
      "mov %0, %%edi\n"
      "syscall"
  :
  :   "rm" (0)
  :   "rax", "edi");
}

```

`testing/tests/pthread_with_fork.c`:

```c
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <sys/types.h>
#include <sys/wait.h>

void *print_message_function(void *ptr)
{
  char *message = (char *) ptr;
  printf("%s\n", message);
}

int main()
{
  printf("about to fork\n");
  fflush(stdout);

  pid_t p = fork();
  if (p == 0) {
    pthread_t thread;
    char *message = "executing in new thread";
    int ret = pthread_create(
    &thread, NULL, print_message_function, (void *) message);

    pthread_join(thread, NULL);

    printf("thread returns: %d\n",ret);
  } else {
    int wstatus;
    wait(&wstatus);

    if (WIFEXITED(wstatus))
      printf("child exited with status %d\n", WEXITSTATUS(wstatus));
  }

  return 0;
}

```

`testing/tests/recursion.c`:

```c
#include <stdio.h>

int fact(int n)
{
  if (n == 0) return 1;
  else return n * fact(n-1);
}

int main()
{
  printf("%u\n", fact(30));
  return 0;
}

```

`testing/tests/signals.c`:

```c
#include <stdio.h>
#include <signal.h>

void handler(int sig)
{
  printf("Caught signal %d\n", sig);
}

int main()
{
  struct sigaction sa;
  sa.sa_handler = handler;
  sigaction(SIGALRM, &sa, NULL);
  sigaction(SIGINT, &sa, NULL);
  sigaction(SIGUSR1, &sa, NULL);
  sigaction(SIGSEGV, &sa, NULL);

  raise(SIGALRM);
  raise(SIGINT);
  raise(SIGUSR1);
  raise(SIGSEGV);

  return 0;
}


```

`testing/tests/static_data.c`:

```c
#include <stdio.h>
#include <assert.h>

static char arr[10000];

/* Tests whether data in .bss is completely zeroed (as it should be) when
 * mapped in */
int main()
{
  int i = 0;
  for (; i < sizeof(arr); i++) {
    assert(arr[i] == '\0');
  }

  printf("%u bytes of static data are zeroed\n", i);
  return 0;
}


```