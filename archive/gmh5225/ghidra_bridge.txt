Project Path: arc_gmh5225_ghidra_bridge_0xtn3j7f

Source Tree:

```txt
arc_gmh5225_ghidra_bridge_0xtn3j7f
├── LICENSE
├── README.md
├── ghidra_bridge
│   ├── __init__.py
│   ├── ghidra_bridge.py
│   ├── install_server.py
│   ├── server
│   │   ├── __init__.py
│   │   ├── example_py3_from_ghidra_bridge.py
│   │   ├── ghidra_bridge_port.py
│   │   ├── ghidra_bridge_server.py
│   │   ├── ghidra_bridge_server_background.py
│   │   └── ghidra_bridge_server_shutdown.py
│   └── test_ghidra_bridge.py
└── setup.py

```

`LICENSE`:

```
MIT License

Copyright (c) 2019 justfoxing

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
Ghidra Bridge
=====================
Ghidra is great, and I like scripting as much of my RE as possible. But Ghidra's Python scripting is based on Jython, which isn't in a great state these days. Installing new packages is a hassle, if they can even run in a Jython environment, and it's only going to get worse as Python 2 slowly gets turned off.

So Ghidra Bridge is an effort to sidestep that problem - instead of being stuck in Jython, set up an RPC proxy for Python objects, so we can call into Ghidra/Jython-land to get the data we need, then bring it back to a more up-to-date Python with all the packages you need to do your work. 

The aim is to be as transparent as possible, so once you're set up, you shouldn't need to know if an object is local or from the remote Ghidra - the bridge should seamlessly handle getting/setting/calling against it.

If you like this, you might also be interested in the equivalents for other reverse-engineering tools:
* [jfx_bridge_ida](https://github.com/justfoxing/jfx_bridge_ida) for IDA Pro [![jfx_bridge_ida PyPi version](https://img.shields.io/pypi/v/jfx_bridge_ida.svg)](https://pypi.org/project/jfx-bridge-ida/)
* [jfx_bridge_jeb](https://github.com/justfoxing/jfx_bridge_jeb) for JEB Decompiler [![jfx_bridge_jeb PyPi version](https://img.shields.io/pypi/v/jfx_bridge_jeb.svg)](https://pypi.org/project/jfx-bridge-jeb/)

If you _really_ like this, feel free to buy me a coffee: https://ko-fi.com/justfoxing

Table of contents
======================
* [How to use for Ghidra](#how-to-use-for-ghidra)
* [Security warning](#security-warning)
* [Remote eval](#remote-eval)
* [Long-running commands](#long-running-commands)
* [Remote imports](#remote-imports)
* [Interactive mode](#interactive-mode)
* [How it works](#how-it-works)
* [Design principles](#design-principles)
* [Tested](#tested)
* [TODO](#todo)
* [Contributors](#contributors)

How to use for Ghidra
======================

## Install the Ghidra Bridge package and server scripts
1. Install the ghidra_bridge package (packaged at https://pypi.org/project/ghidra-bridge/):
```
pip install ghidra_bridge
```

2. Install the server scripts to a directory on the Ghidra's script path (e.g., ~/ghidra_scripts, or you can add more directories in the Ghidra Script Manager by clicking the "3 line" button left of the big red "plus" at the top of the Script Manager).
```
python -m ghidra_bridge.install_server ~/ghidra_scripts
```
3. (optional) In the Ghidra Script Manager, select the Bridge folder and click the "In Tool" checkbox at the far left for the ghidra_bridge_server_background.py and ghidra_bridge_server_shutdown.py scripts. This will add these scripts as convenient menu items in Tools->Ghidra Bridge. 

## Start Server
### CodeBrowser Context

For a better interactive shell like IPython or if you need Python 3 libraries in your interactive environment you can start the bridge in the context of an interactive GUI session.

1. If you've done step 3 in the install instructions above, click Tools->Ghidra Bridge->Run in Background.

Otherwise:
1. Open the Ghidra Script Manager.
2. Select the Bridge folder.
3. Run the ghidra_bridge_server_background.py script for a clean, no-popups bridge. You can also use ghidra_bridge_server.py if for some reason you want a big script popup in your face the whole time.

### Headless Analysis Context

You can run Ghidra Bridge as a post analysis script for a headless analysis and then run some further analysis from the client. Use the ghidra_bridge_server.py (not \_background.py) for this one, so it doesn't exit until you shut the bridge down. 
```
$ghidraRoot/support/analyzeHeadless <path to directory to store project> <name for project> -import <path to file to import>  -scriptPath <install directory for the server scripts> -postscript ghidra_bridge_server.py
```

See the analyzeHeadlessREADME.html in Ghidra's support/ directory for more information about how to run the analyzeHeadless command, if required.
### pythonRun Context

You can start the bridge in an environment without any program loaded, for example if you want to access some API like the DataTypeManager that doesn't require a program being analyzed

```
$ghidraRoot/support/pythonRun <install directory for the server scripts>/ghidra_bridge_server.py
```

## Setup Client
From the client python environment:
```python
import ghidra_bridge
with ghidra_bridge.GhidraBridge(namespace=globals()):
    print(getState().getCurrentAddress().getOffset())
    ghidra.program.model.data.DataUtilities.isUndefinedData(currentProgram, currentAddress)
```
or
```python
import ghidra_bridge
b = ghidra_bridge.GhidraBridge(namespace=globals()) # creates the bridge and loads the flat API into the global namespace
print(getState().getCurrentAddress().getOffset())
# ghidra module implicitly loaded at the same time as the flat API
ghidra.program.model.data.DataUtilities.isUndefinedData(currentProgram, currentAddress)
```

## Shutting Down the Server
Warning: if you're running in non-background mode, avoid clicking the "Cancel" button on the script popup, as this will leave the server socket in a bad state, and you'll have to completely close Ghidra to fix it.

To shutdown the server cleanly, if you've done step 3 in the install instructions above, click Tools->Ghidra Bridge->Shutdown. Otherwise, run the ghidra_bridge_server_shutdown.py script from the Bridge folder.

Alternatively, you can call remote_shutdown from any connected client.
```python
import ghidra_bridge
b = ghidra_bridge.GhidraBridge(namespace=globals())
b.remote_shutdown()
```

Security warning
=====================
Be aware that when running, a Ghidra Bridge server effectively provides code execution as a service. If an attacker is able to talk to the port Ghidra Bridge is running on, they can trivially gain execution with the privileges Ghidra is run with. 

Also be aware that the protocol used for sending and receiving Ghidra Bridge messages is unencrypted and unverified - a person-in-the-middle attack would allow complete control of the commands and responses, again providing trivial code execution on the server (and with a little more work, on the client). 

By default, the Ghidra Bridge server only listens on localhost to slightly reduce the attack surface. Only listen on external network addresses if you're confident you're on a network where it is safe to do so. Additionally, it is still possible for attackers to send messages to localhost (e.g., via malicious javascript in the browser, or by exploiting a different process and attacking Ghidra Bridge to elevate privileges). You can mitigate this risk by running Ghidra Bridge from a Ghidra server with reduced permissions (a non-admin user, or inside a container), by only running it when needed, or by running on non-network connected systems.

Remote eval
=====================
Ghidra Bridge is designed to be transparent, to allow easy porting of non-bridged scripts without too many changes. However, if you're happy to make changes, and you run into slowdowns caused by running lots of remote queries (e.g., something like `for function in currentProgram.getFunctionManager().getFunctions(): doSomething()` can be quite slow with a large number of functions as each function will result in a message across the bridge), you can make use of the remote_eval() function to ask for the result to be evaluated on the bridge server all at once, which will require only a single message roundtrip.

The following example demonstrates getting a list of all the names of all the functions in a binary:
```python
import ghidra_bridge 
b = ghidra_bridge.GhidraBridge(namespace=globals())
name_list = b.remote_eval("[ f.getName() for f in currentProgram.getFunctionManager().getFunctions(True)]")
```

If your evaluation is going to take some time, you might need to use the timeout_override argument to increase how long the bridge will wait before deciding things have gone wrong.

If you need to supply an argument for the remote evaluation, you can provide arbitrary keyword arguments to the remote_eval function which will be passed into the evaluation context as local variables. The following argument passes in a function:
```python
import ghidra_bridge 
b = ghidra_bridge.GhidraBridge(namespace=globals())
func = currentProgram.getFunctionManager().getFunctions(True).next()
mnemonics = b.remote_eval("[ i.getMnemonicString() for i in currentProgram.getListing().getInstructions(f.getBody(), True)]", f=func)
```
As a simplification, note also that the evaluation context has the same globals loaded into the \_\_main\_\_ of the script that started the server - in the case of the Ghidra Bridge server, these include the flat API and values such as the currentProgram.

Long-running commands
=====================
If you have a particularly slow call in your script, it may hit the response timeout that the bridge uses to make sure the connection hasn't broken. If this happens, you'll see something like `Exception: Didn't receive response <UUID> before timeout`.

There are two options to increase the timeout. When creating the bridge, you can set a timeout value in seconds with the response_timeout argument (e.g., `b = ghidra_bridge.GhidraBridge(namespace=globals(), response_timeout=20)`) which will apply to all commands run across the bridge. Alternatively, if you just want to change the timeout for one command, you can use remote_eval as mentioned above, with the timeout_override argument (e.g., `b.remote_eval("[ f.getName() for f in currentProgram.getFunctionManager().getFunctions(True)]", timeout_override=20)`). If you use the value -1 for either of these arguments, the response timeout will be disabled and the bridge will wait forever for your response to come back - note that this can cause your script to hang if the bridge runs into problems.

Remote imports
=====================
If you want to import modules from the ghidra-side (e.g., ghidra, java, docking namespaces), you have two options.
* Use remote_import to get a BridgedModule back directly (e.g., `remote_module = b.remote_import("java.math.BigInteger")`). This has the advantage that you have exact control over getting the remote module (and can get remote modules with the same name as local modules) and when it's released, but it does take a little more work.
* Specify hook_import=True when creating the bridge (e.g., `b = ghidra_bridge.GhidraBridge(namespace=globals(), hook_import=True)`). This will add a hook to the import machinery such that, if nothing else can fill the import, the bridge will try to handle it. This allows you to just use the standard `import ghidra.framework.model.ToolListener` syntax after you've connected the bridge. This has the advantage that it may be a little easier to use (you still have to make sure the imports happen AFTER the bridge is connected), but it doesn't allow you to import remote modules with the same name as local modules (the local imports take precedence) and it places the remote modules in sys.modules as proper imports, so they and the bridge will likely stay loaded until the process terminates. Additionally, multiple bridges with hook_import=True will attempt to resolve imports in the order they were connected, which may not be the behaviour you want.

Interactive mode
=====================
Normally, Ghidra scripts get an instance of the Ghidra state and current\* variables (currentProgram, currentAddress, etc) when first started, and it doesn't update while the script runs. However, if you run the Ghidra Python interpreter, that updates its state with every command, so that currentAddress always matches the GUI.

To reflect this, GhidraBridge will automatically attempt to determine if you're running the client in an interactive environment (e.g., the Python interpreter, iPython) or just from a script. If it's an interactive environment, it'll register an event listener with Ghidra and perform some dubious behind-the-scenes shenanigans to make sure that the state is updated with GUI changes to behave like the Ghidra Python interpreter.  It'll also replace `help()` with one that reaches out to use Ghidra's help across the bridge if you give it a bridged object.

You shouldn't have to care about this, but if for some reason the auto-detection doesn't give you the result you need, you can specify the boolean interactive_mode argument when creating your client GhidraBridge to force it on or off as required.

How it works
=====================
The actual bridge RPC code is implemented in [jfx-bridge](https://github.com/justfoxing/jfx_bridge/). Check it out there and file non-Ghidra specific issues related to the bridge there.

Design principles
=====================
* Needs to be run in Ghidra/Jython 2.7 and Python 3
* Needs to be easy to install in Ghidra - no pip install, just add a single directory 
(these two requirements ruled out some of the more mature Python RPC projects I looked into)

Tested
=====================
* Tested and working on Ghidra 9.1(Jython 2.7.1) <-> Python 3.7.3 on Windows
* Automatically tested on Ghidra 9.0(Jython 2.7.1) <-> Python 3.5.3 on Linux (bskaggs/ghidra docker image)

TODO
=====================
* Ghidra plugin for server control (cleaner start/stop, port selection, easy packaging/install)
* Examples
    * Jupyter notebook

Contributors
=====================
* Thx @fmagin for better iPython support, and much more useful reprs!
* Thanks also to @fmagin for remote_eval, allowing faster remote processing for batch queries!

```

`ghidra_bridge/__init__.py`:

```py
from .ghidra_bridge import GhidraBridge

```

`ghidra_bridge/ghidra_bridge.py`:

```py
import sys
import weakref
import pydoc

from jfx_bridge import bridge

from .server.ghidra_bridge_port import DEFAULT_SERVER_PORT

""" Use this list to exclude modules and names loaded by the remote ghidra_bridge side from being loaded into namespaces (they'll 
still be present in the BridgedObject for the __main__ module. This prevents the ghidra_bridge imported by ghidra_bridge_server 
being loaded over the local ghidra_bridge and causing issues. You probably only want this for stuff imported by the ghidra_bridge_server
script that might conflict on the local side (or which is totally unnecessary on the local side, like GhidraBridgeServer).
"""
EXCLUDED_REMOTE_IMPORTS = [
    "logging",
    "subprocess",
    "sys",
    "ghidra_bridge",
    "bridge",
    "GhidraBridgeServer",
]

GHIDRA_BRIDGE_NAMESPACE_TRACK = "__ghidra_bridge_namespace_track__"


def get_listing_panel(tool, ghidra):
    """ Get the code listing UI element, so we can get up-to-date location/highlight/selection """
    cvs = tool.getService(ghidra.app.services.CodeViewerService)
    return cvs.getListingPanel()


class GhidraBridge(bridge.BridgeClient):
    def __init__(
        self,
        connect_to_host=bridge.DEFAULT_HOST,
        connect_to_port=DEFAULT_SERVER_PORT,
        loglevel=None,
        namespace=None,
        interactive_mode=None,
        response_timeout=bridge.DEFAULT_RESPONSE_TIMEOUT,
        hook_import=False,
        record_stats=False,
        **kwargs
    ):
        """ Set up a bridge. Default settings connect to the default ghidra bridge server,

        If namespace is specified (e.g., locals() or globals()), automatically calls get_flat_api() with that namespace. 

        loglevel for what logging messages you want to capture

        interactive_mode should auto-detect interactive environments (e.g., ipython or not in a script), but 
        you can force it to True or False if you need to. False is normal ghidra script behaviour 
        (currentAddress/getState() etc locked to the values when the script started. True is closer to the 
        behaviour in the Ghidra Jython shell - current*/getState() reflect the current values in the GUI

        response_timeout is how long to wait for a response before throwing an exception, in seconds
        
        Set hook_import to True to add a hook to the import system to allowing importing remote modules
        
        Set record_stats to True to record statistics about the bridge to help improve performance. Get the stats with the get_stats() function
        """
        super().__init__(
            connect_to_host=connect_to_host,
            connect_to_port=connect_to_port,
            loglevel=loglevel,
            response_timeout=response_timeout,
            hook_import=hook_import,
            record_stats=record_stats,
            **kwargs
        )

        if interactive_mode is None:
            # from https://stackoverflow.com/questions/2356399/tell-if-python-is-in-interactive-mode, sys.ps1 only present in interactive interpreters
            interactive_mode = bool(getattr(sys, "ps1", sys.flags.interactive))
        self.interactive_mode = interactive_mode
        self.interactive_listener = None

        self.flat_api_modules_list = []
        self.namespace_list = []
        self.namespace = None
        if namespace is not None:
            if connect_to_host is None or connect_to_port is None:
                raise Exception(
                    "Can't get_flat_api for the namespace if connect_to_host/port are none - need a server!"
                )

            # track the namespace we loaded with - if we're part of an __enter__/__exit__ setup, we'll use it to automatically unload the flat api
            self.namespace = namespace
            self.get_flat_api(namespace=self.namespace)

    def get_flat_api(self, namespace=None):
        """ Get the flat API (as well as the GhidraScript API). If a namespace is provided (e.g., locals() or globals()), load the methods and
        fields from the APIs into that namespace (call unload_flat_api() to remove). Otherwise, just return the bridged module.

        Note that the ghidra and java packages are always loaded into the remote script's side, so get_flat_api with namespace will get the
        ghidra api and java namespace for you for free.
        """

        remote_main = self.remote_import("__main__")

        if namespace is not None:
            # we're going to need the all of __main__, so get it all in one hit
            remote_main._bridged_get_all()

        if self.interactive_mode:
            # if we're in headless mode (indicated by no state attribute for pythonRun or no tool for ghidra headless), we can't actually do interactive mode - we don't have access to a PluginTool
            if not hasattr(remote_main, "state") or remote_main.state.getTool() is None:
                self.interactive_mode = False
                self.logger.warning(
                    "Disabling interactive mode - not supported when running against a headless Ghidra"
                )
            else:
                # first, manually update all the current* values (this allows us to get the latest values, instead of what they were when the server started
                tool = remote_main.state.getTool()  # note: tool shouldn't change
                listing_panel = get_listing_panel(tool, remote_main.ghidra)
                locn = listing_panel.getProgramLocation()
                # set the values as overrides in the bridged object - this prevents them from being changed in the remote object
                remote_main._bridge_set_override("currentAddress", locn.getAddress())
                remote_main._bridge_set_override(
                    "currentProgram", listing_panel.getProgram()
                )
                remote_main._bridge_set_override("currentLocation", locn)
                remote_main._bridge_set_override(
                    "currentSelection", listing_panel.getProgramSelection()
                )
                remote_main._bridge_set_override(
                    "currentHighlight", listing_panel.getProgramHighlight()
                )

                # next, keep a reference to this module for updating these addresses
                self.flat_api_modules_list.append(weakref.ref(remote_main))

                # next, overwrite getState with the getState_fix
                def getState_fix():
                    """ Used when in interactive mode - instead of calling the remote getState, 
                        relies on the fact that the current* variables are being updated and creates
                        a GhidraState based on them.

                        This avoids resetting the GUI to the original values in the remote getState
                    """
                    return remote_main.ghidra.app.script.GhidraState(
                        tool,
                        tool.getProject(),
                        remote_main.currentProgram,
                        remote_main.currentLocation,
                        remote_main.currentSelection,
                        remote_main.currentHighlight,
                    )

                remote_main._bridge_set_override("getState", getState_fix)

                # finally, install a listener for updates from the GUI events
                if self.interactive_listener is None:

                    def update_vars(
                        currentProgram=None,
                        currentLocation=None,
                        currentSelection=None,
                        currentHighlight=None,
                    ):
                        """ For all the namespaces and modules we've returned, update the current* variables that have changed
                        """
                        # clear out any dead references
                        self.flat_api_modules_list = [
                            module
                            for module in self.flat_api_modules_list
                            if module() is not None
                        ]

                        update_list = [
                            module() for module in self.flat_api_modules_list
                        ]
                        for update in update_list:
                            # possible that a module might have been removed between the clear out and preparing the update list
                            if update is not None:
                                if currentProgram is not None:
                                    update.currentProgram = currentProgram
                                if currentLocation is not None:
                                    # match the order of updates in GhidraScript - location before address
                                    update.currentLocation = currentLocation
                                    update.currentAddress = currentLocation.getAddress()
                                if currentSelection is not None:
                                    update.currentSelection = (
                                        currentSelection
                                        if not currentSelection.isEmpty()
                                        else None
                                    )
                                if currentHighlight is not None:
                                    update.currentHighlight = (
                                        currentHighlight
                                        if not currentHighlight.isEmpty()
                                        else None
                                    )

                        # repeat the same for the namespace dictionaries, but also make sure we update the tracker so we know what to remove later
                        for update_dict in self.namespace_list:
                            if currentProgram is not None:
                                update_dict["currentProgram"] = currentProgram
                                update_dict[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                                    "currentProgram"
                                ] = update_dict["currentProgram"]
                            if currentLocation is not None:
                                # match the order of updates in GhidraScript - location before address
                                update_dict["currentLocation"] = currentLocation
                                update_dict[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                                    "currentLocation"
                                ] = update_dict["currentLocation"]
                                update_dict[
                                    "currentAddress"
                                ] = currentLocation.getAddress()
                                update_dict[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                                    "currentAddress"
                                ] = update_dict["currentAddress"]
                            if currentSelection is not None:
                                update_dict["currentSelection"] = (
                                    currentSelection
                                    if not currentSelection.isEmpty()
                                    else None
                                )
                                update_dict[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                                    "currentSelection"
                                ] = update_dict["currentSelection"]
                            if currentHighlight is not None:
                                update_dict["currentHighlight"] = (
                                    currentHighlight
                                    if not currentHighlight.isEmpty()
                                    else None
                                )
                                update_dict[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                                    "currentHighlight"
                                ] = update_dict["currentHighlight"]

                    # create the interactive listener to call our update_vars function (InteractiveListener defined in the GhidraBridgeServer class)
                    self.interactive_listener = remote_main.GhidraBridgeServer.InteractiveListener(
                        remote_main.state.getTool(), update_vars
                    )

        if namespace is not None:
            # add a special var to the namespace to track what we add, so we can remove it easily later
            namespace[GHIDRA_BRIDGE_NAMESPACE_TRACK] = dict()

            # load in all the attrs from remote main, skipping the double underscores and avoiding overloading our own ghidra_bridge (and similar modules)
            try:
                for attr in set(
                    remote_main._bridge_attrs
                    + list(remote_main._bridge_overrides.keys())
                ):
                    if (
                        not attr.startswith("__")
                        and attr not in EXCLUDED_REMOTE_IMPORTS
                    ):
                        remote_attr = getattr(remote_main, attr)
                        namespace[attr] = remote_attr
                        # record what we added to the namespace
                        namespace[GHIDRA_BRIDGE_NAMESPACE_TRACK][attr] = remote_attr

                # overload isinstance with bridged_isinstance, so checking bridged objects are of bridged types will just work
                namespace["isinstance"] = bridge.bridged_isinstance
                namespace[GHIDRA_BRIDGE_NAMESPACE_TRACK][
                    "isinstance"
                ] = bridge.bridged_isinstance

                # overwrite help with our own function for using ghidra's help
                def ghidra_help(param=None):
                    """ Used when in interactive mode - calls through the bridge to call ghidra's help and capture the output, then print it locally """
                    if param is not None and not bridge._is_bridged_object(param):
                        # asking for help on something that isn't bridged - just use the original help
                        # make sure we have the real help, just in case we've overridden it already
                        builtin_help = None
                        try:
                            from builtins import help as builtin_help  # python3
                        except:
                            # try falling back to python2 syntax
                            from __builtin__ import help as builtin_help
                        builtin_help(param)
                    else:
                        # make a remote help call - either param is bridged, or no param (in which case, we'll get the default help for the GhidraScript API)
                        help_output = remote_main.GhidraBridgeServer.ghidra_help(param)
                        pydoc.pager(help_output)

                namespace["help"] = ghidra_help
                namespace[GHIDRA_BRIDGE_NAMESPACE_TRACK]["help"] = ghidra_help

            except Exception:
                self.unload_flat_api(namespace)
                raise

            # if we're interactive, keep track of the namespace so we can update the current* values
            if self.interactive_mode:
                self.namespace_list.append(namespace)

        return remote_main

    def unload_flat_api(self, namespace=None):
        """ If get_flat_api was called with a namespace and loaded methods/fields into it, unload_flat_api will remove them.
            Note: if the values don't match what was loaded, we assume the caller has modified for their own reasons, and leave alone.
        """
        if namespace is None:
            if self.namespace is None:
                raise Exception(
                    "Bridge wasn't initialized with a namespace - need to specify the namespace you want to unload from"
                )
            namespace = self.namespace

        if self.interactive_mode and namespace in self.namespace_list:
            self.namespace_list.remove(namespace)

        if GHIDRA_BRIDGE_NAMESPACE_TRACK in namespace:
            for key, value in namespace[GHIDRA_BRIDGE_NAMESPACE_TRACK].items():
                if key in namespace:
                    # we use "is", not ==, because we're checking it's the same object, not just that it matches
                    if namespace[key] is value:
                        del namespace[key]
        else:
            raise Exception(
                GHIDRA_BRIDGE_NAMESPACE_TRACK
                + " not present in namespace - get_flat_api() didn't load into this namespace"
            )

    def get_ghidra_api(self):
        """ get the ghidra api - `ghidra = bridge.get_ghidra_api()` equivalent to doing `import ghidra` in your script.
            Note that the module returned from get_flat_api() will also contain the ghidra module, so you may not need to call this.
        """
        return self.remote_import("ghidra")

    def get_java_api(self):
        """ get the java namespace - `java = bridge.get_java_api()` equivalent to doing `import java` in your script.
            Note that the module returned from get_flat_api() will also contain the java module, so you may not need to call this.
        """
        return self.remote_import("java")

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if self.namespace is not None:
            self.unload_flat_api(self.namespace)

        if self.interactive_listener is not None:
            self.interactive_listener.stop_listening()

```

`ghidra_bridge/install_server.py`:

```py
""" Handle installing the ghidra_bridge server scripts (and supporting jfx_bridge) to a specified directory """
import argparse
import os
import pkg_resources

JFX_BRIDGE = "jfx_bridge"
GHIDRA_BRIDGE = "ghidra_bridge"
SERVER_DIR = "server"


def do_install(install_dir):
    # list the files from jfx_bridge
    jfx_bridge_files = [
        f
        for f in pkg_resources.resource_listdir(JFX_BRIDGE, ".")
        if f != "__pycache__" and not f.startswith("test_")
    ]

    # create a jfx_bridge directory in the install dir
    jfx_bridge_path = os.path.join(install_dir, JFX_BRIDGE)
    if not os.path.isdir(jfx_bridge_path):
        os.makedirs(jfx_bridge_path)

    print("Installing " + JFX_BRIDGE + "...")

    # write out the jfx_bridge files
    for f in jfx_bridge_files:
        dest_path = os.path.join(jfx_bridge_path, f)
        with pkg_resources.resource_stream(JFX_BRIDGE, f) as resource:
            with open(dest_path, "wb") as dest:
                print("\t" + dest_path)
                dest.write(resource.read())

    # list the files from ghidra_bridge server directory
    server_files = [
        f
        for f in pkg_resources.resource_listdir(GHIDRA_BRIDGE, SERVER_DIR)
        if f not in ["__init__.py", "__pycache__"]
    ]

    print("Installing ghidra_bridge server scripts...")

    # write out the ghidra_bridge server files directly in the install dir
    for f in server_files:
        dest_path = os.path.join(install_dir, f)
        with pkg_resources.resource_stream(
            GHIDRA_BRIDGE, SERVER_DIR + "/" + f
        ) as resource:
            with open(dest_path, "wb") as dest:
                print("\t" + dest_path)
                dest.write(resource.read())

    print("Install completed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Install ghidra_bridge server scripts")
    parser.add_argument(
        "install_dir",
        help="A directory on ghidra's script loading path (e.g., ~/ghidra_scripts)",
    )

    args = parser.parse_args()

    do_install(args.install_dir)

```

`ghidra_bridge/server/example_py3_from_ghidra_bridge.py`:

```py
# Example script that demonstrates running a python3 (or technically, py2 should work) script outside the Ghidra interpreter, to use networkx to graph a function. Requires networkx installed in the external environment.
# @author justfoxing
# @category Examples

import argparse


def run_script(server_host, server_port):
    import ghidra_bridge

    # load something ghidra doesn't have
    import networkx

    print("Running inside the bridge!")

    # create the bridge and load the flat API/ghidra modules into the namespace
    with ghidra_bridge.GhidraBridge(
        connect_to_host=server_host, connect_to_port=server_port, namespace=globals()
    ):
        # grab the current function
        function = currentProgram.getFunctionManager().getFunctionContaining(
            currentAddress
        )

        if function is None:
            raise Exception(
                "Current address {} not within a function".format(currentAddress)
            )

        print("Graphing {}:{}".format(function, function.getEntryPoint()))

        model = ghidra.program.model.block.BasicBlockModel(currentProgram)

        # get the first code block in the function
        code_block = model.getFirstCodeBlockContaining(
            function.getEntryPoint(), monitor
        )

        graph = networkx.DiGraph()

        # step through the code blocks, adding them to a networkx graph
        to_visit_list = [code_block]
        visited_list = []

        while len(to_visit_list) > 0:
            visit_block = to_visit_list.pop()
            src_block_address = visit_block.getFirstStartAddress().getOffset()

            # mark as visited
            visited_list.append(src_block_address)

            dest_it = visit_block.getDestinations(monitor)
            dest_ref = dest_it.next()
            while dest_ref is not None:
                dest_block = dest_ref.getDestinationBlock()

                dest_address = dest_block.getFirstStartAddress().getOffset()

                # add an edge
                graph.add_edge(src_block_address, dest_address)

                # add the destination to the visit list, if we haven't already visited it
                if dest_address not in visited_list and dest_address not in [
                    block.getFirstStartAddress().getOffset() for block in to_visit_list
                ]:
                    to_visit_list.append(dest_block)

                dest_ref = dest_it.next()

        # visits completed
        # can now perform graph analysis on the graph... or just print the edges
        print(graph.edges)


if __name__ == "__main__":

    in_ghidra = False
    try:
        import ghidra

        # we're in ghidra!
        in_ghidra = True
    except ModuleNotFoundError:
        # not ghidra
        pass

    if in_ghidra:
        import ghidra_bridge_server

        script_file = getSourceFile().getAbsolutePath()
        # spin up a ghidra_bridge_server and spawn the script in external python to connect back to it
        ghidra_bridge_server.GhidraBridgeServer.run_script_across_ghidra_bridge(
            script_file
        )
    else:
        # we're being run outside ghidra! (almost certainly from spawned by run_script_across_ghidra_bridge())

        parser = argparse.ArgumentParser(
            description="Example py3 script that's expected to be called from ghidra with a bridge"
        )
        # the script needs to handle these command-line arguments and use them to connect back to the ghidra server that spawned it
        parser.add_argument(
            "--connect_to_host",
            type=str,
            required=False,
            default="127.0.0.1",
            help="IP to connect to the ghidra_bridge server",
        )
        parser.add_argument(
            "--connect_to_port",
            type=int,
            required=True,
            help="Port to connect to the ghidra_bridge server",
        )

        args = parser.parse_args()

        run_script(server_host=args.connect_to_host, server_port=args.connect_to_port)

```

`ghidra_bridge/server/ghidra_bridge_port.py`:

```py
DEFAULT_SERVER_PORT = 4768
```

`ghidra_bridge/server/ghidra_bridge_server.py`:

```py
# Run a ghidra_bridge server for external python environments to interact with
# @author justfoxing
# @category Bridge

# NOTE: any imports here may need to be excluded in ghidra_bridge
import logging
import subprocess
import sys
from jfx_bridge import bridge
from ghidra_bridge_port import DEFAULT_SERVER_PORT

# NOTE: we definitely DON'T want to exclude ghidra from ghidra_bridge :P
import ghidra


class GhidraBridgeServer(object):
    """ Class mostly used to collect together functions and variables that we don't want contaminating the global namespace
        variables set in remote clients

        NOTE: this class needs to be excluded from ghidra_bridge - it doesn't need to be in the globals, if people want it and
        know what they're doing, they can get it from the BridgedObject for the main module
    """

    class PrintAccumulator(object):
        """ Class to handle capturing print output so we can send it across the bridge, by hooking sys.stdout.write().
            Not multithreading aware, it'll just capture whatever is printed from the moment it hooks to the moment 
            it stops.
        """

        output = None
        old_stdout = None

        def __init__(self):
            self.output = ""

        def write(self, output):
            self.output += output

        def get_output(self):
            return self.output

        def hook(self):
            self.old_stdout = sys.stdout
            sys.stdout = self

        def unhook(self):
            if self.old_stdout is not None:
                sys.stdout = self.old_stdout

        def __enter__(self):
            self.hook()

            return self

        def __exit__(self, type, value, traceback):
            self.unhook()

    @staticmethod
    def ghidra_help(param=None):
        """ call the ghidra help method, capturing the print output with PrintAccumulator, and return it as a string """
        with GhidraBridgeServer.PrintAccumulator() as help_output:
            help(param)

            return help_output.get_output()

    class InteractiveListener(ghidra.framework.model.ToolListener):
        """ Class to handle registering for plugin events associated with the GUI
            environment, and sending them back to clients running in interactive mode
            so they can update their variables 

            We define the interactive listener on the server end, so it can
            cleanly recover from bridge failures when trying to send messages back. If we
            let it propagate exceptions up into Ghidra, the GUI gets unhappy and can stop
            sending tool events out 
        """

        tool = None
        callback_fn = None

        def __init__(self, tool, callback_fn):
            """ Create with the tool to listen to (from state.getTool() - won't change during execution)
                and the callback function to notify on the client end (should be the update_vars function) """
            self.tool = tool
            self.callback_fn = callback_fn

            # register the listener against the remote tool
            tool.addToolListener(self)

        def stop_listening(self):
            # we're done, make sure we remove the tool listener
            self.tool.removeToolListener(self)

        def processToolEvent(self, plugin_event):
            """ Called by the ToolListener interface """
            try:
                self.callback_fn._bridge_conn.logger.debug(
                    "InteractiveListener got event: " + str(plugin_event)
                )

                event_name = plugin_event.getEventName()
                if "Location" in event_name:
                    self.callback_fn(
                        currentProgram=plugin_event.getProgram(),
                        currentLocation=plugin_event.getLocation(),
                    )
                elif "Selection" in event_name:
                    self.callback_fn(
                        currentProgram=plugin_event.getProgram(),
                        currentSelection=plugin_event.getSelection(),
                    )
                elif "Highlight" in event_name:
                    self.callback_fn(
                        currentProgram=plugin_event.getProgram(),
                        currentHighlight=plugin_event.getHighlight(),
                    )
            except Exception as e:
                # any exception, we just want to bail and shut down the listener.
                # most likely case is the bridge connection has gone down.
                self.stop_listening()
                self.callback_fn._bridge_conn.logger.error(
                    "InteractiveListener failed trying to callback client: " + str(e)
                )

    @staticmethod
    def run_server(
        server_host=bridge.DEFAULT_HOST,
        server_port=DEFAULT_SERVER_PORT,
        response_timeout=bridge.DEFAULT_RESPONSE_TIMEOUT,
        background=True,
    ):
        """ Run a ghidra_bridge_server (forever)
            server_host - what address the server should listen on
            server_port - what port the server should listen on
            response_timeout - default timeout in seconds before a response is treated as "failed"
            background - false to run the server in this thread (script popup will stay), true for a new thread (script popup disappears)
        """
        server = bridge.BridgeServer(
            server_host=server_host,
            server_port=server_port,
            loglevel=logging.INFO,
            response_timeout=response_timeout,
        )

        if background:
            server.start()
            server.logger.info(
                "Server launching in background - will continue to run after launch script finishes..."
            )
        else:
            server.run()

    @staticmethod
    def run_script_across_ghidra_bridge(script_file, python="python", argstring=""):
        """ Spin up a ghidra_bridge_server and spawn the script in external python to connect back to it. Useful in scripts being triggered from
            inside ghidra that need to use python3 or packages that don't work in jython

            The called script needs to handle the --connect_to_host and --connect_to_port command-line arguments and use them to start
            a ghidra_bridge client to talk back to the server.

            Specify python to control what the script gets run with. Defaults to whatever python is in the shell - if changing, specify a path
            or name the shell can find.
            Specify argstring to pass further arguments to the script when it starts up.
        """

        # spawn a ghidra bridge server - use server port 0 to pick a random port
        server = bridge.BridgeServer(
            server_host="127.0.0.1", server_port=0, loglevel=logging.INFO
        )
        # start it running in a background thread
        server.start()

        try:
            # work out where we're running the server
            server_host, server_port = server.server.bridge.get_server_info()

            print("Running " + script_file)

            # spawn an external python process to run against it

            try:
                output = subprocess.check_output(
                    "{python} {script} --connect_to_host={host} --connect_to_port={port} {argstring}".format(
                        python=python,
                        script=script_file,
                        host=server_host,
                        port=server_port,
                        argstring=argstring,
                    ),
                    stderr=subprocess.STDOUT,
                    shell=True,
                )
                print(output)
            except subprocess.CalledProcessError as exc:
                print("Failed ({}):{}".format(exc.returncode, exc.output))

            print(script_file + " completed")

        finally:
            # when we're done with the script, shut down the server
            server.shutdown()


if __name__ == "__main__":
    # legacy version - run the server in the foreground, so we don't break people's expectations
    GhidraBridgeServer.run_server(
        response_timeout=bridge.DEFAULT_RESPONSE_TIMEOUT, background=False
    )


```

`ghidra_bridge/server/ghidra_bridge_server_background.py`:

```py
# Run a ghidra_bridge server in background/no-GUI-mode for external python environments to interact with
# @author justfoxing
# @category Bridge
# @menupath Tools.Ghidra Bridge.Run in Background
# @toolbar python.png

from ghidra_bridge_server import GhidraBridgeServer

if __name__ == "__main__":
    GhidraBridgeServer.run_server(background=True)

```

`ghidra_bridge/server/ghidra_bridge_server_shutdown.py`:

```py
# Shutdown a running ghidra_bridge server cleanly
# @author justfoxing
# @category Bridge
# @menupath Tools.Ghidra Bridge.Shutdown

from jfx_bridge import bridge
from ghidra_bridge_port import DEFAULT_SERVER_PORT

if __name__ == "__main__":
    print("Requesting server shutdown")
    b = bridge.BridgeClient(
        connect_to_host="127.0.0.1", connect_to_port=DEFAULT_SERVER_PORT
    )

    print(b.remote_shutdown())

```

`ghidra_bridge/test_ghidra_bridge.py`:

```py
import unittest
import time

import ghidra_bridge
from ghidra_bridge.server import ghidra_bridge_port

import jfx_bridge
import pytest

class TestGhidraBridge(unittest.TestCase):
    """ Assumes there's a ghidra bridge server running at DEFAULT_SERVER_PORT """

    def test_interactive_currentAddress(self):
        """ confirm that the current address (and ideally, the other current* vars - TODO) are updated when
            interactive mode is enabled """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(),
            connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT,
            interactive_mode=True,
        ):
            if state.getTool() is None:
                self.skipTest(
                    "Interactive mode tests not supported against headless (no tool)"
                )
            else:
                # record the current address as an int
                curr_addr = currentAddress.getOffset()

                # move the current address
                state.setCurrentAddress(currentAddress.add(0x10))

                # add a little sleep, so there's enough time for the update to make it back to us (interactive_mode isn't meant to be scripted...)
                time.sleep(1)

                # check the new address has changed (not sure exactly what it's changed to, because instruction alignments might change exactly where we go)
                self.assertNotEqual(curr_addr, currentAddress.getOffset())

    def test_interactive_getState_fix(self):
        """ confirm that getState is updated, and doesn't cause a reset to old values when interactive mode is enabled """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(),
            connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT,
            interactive_mode=True,
        ):
            if state.getTool() is None:
                self.skipTest(
                    "Interactive mode tests not supported against headless (no tool)"
                )
            else:
                # record the current address as an int
                curr_addr = currentAddress.getOffset()

                # move the current address
                state.setCurrentAddress(currentAddress.add(0x10))

                # call getState
                new_state = getState()

                # check the new address has changed (not sure exactly what it's changed to, because instruction alignments might change exactly where we go)
                self.assertNotEqual(curr_addr, currentAddress.getOffset())

                # check that the state address matches
                self.assertEqual(
                    currentAddress.getOffset(),
                    new_state.getCurrentAddress().getOffset(),
                )

    def test_non_interactive_currentAddress(self):
        """ confirm that the current address (and ideally, the other current* vars - TODO) are NOT updated when
            interactive mode is disabled """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(),
            connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT,
            interactive_mode=False,
        ):
            if state.getTool() is None:
                self.skipTest(
                    "This test isn't supported against headless/no tool ghidra, because of how we try to get the most up to date addresses"
                )
            else:
                listing_panel = ghidra_bridge.ghidra_bridge.get_listing_panel(
                    state.getTool(), ghidra
                )
                # get the actual current address
                actual_current_addr = (
                    listing_panel.getProgramLocation().getAddress().getOffset()
                )

                # record the "current" address as an int
                curr_addr = currentAddress.getOffset()

                # move the current address
                state.setCurrentAddress(currentAddress.add(0x10))

                # check the address has changed
                new_actual_current_addr = (
                    listing_panel.getProgramLocation().getAddress().getOffset()
                )
                self.assertNotEqual(actual_current_addr, new_actual_current_addr)

                # check the currentAddress hasn't changed
                self.assertEqual(curr_addr, currentAddress.getOffset())

    def test_namespace_cleanup(self):
        with ghidra_bridge.GhidraBridge(
            namespace=globals(), connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT
        ):
            self.assertTrue("currentAddress" in globals())

        self.assertTrue("currentAddress" not in globals())

    def test_namespace_cleanup_with_interactive(self):
        """ check that we can still remove if the values we add have been updated by interactive mode """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(),
            connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT,
            interactive_mode=True,
        ):
            self.assertTrue("currentAddress" in globals())

            # cause currentAddress to change
            # move the current address
            state.setCurrentAddress(currentAddress.add(0x10))

            # add a little sleep, so there's enough time for the update to make it back to us (interactive_mode isn't meant to be scripted...)
            time.sleep(1)

        # make sure it's no longer present
        self.assertTrue("currentAddress" not in globals())

    def test_isinstance_fix(self):
        """ check that we automatically fix up isinstance when using namespace, so we can isinstance bridged objects """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(), connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT
        ):
            self.assertTrue(
                isinstance(currentAddress, ghidra.program.model.address.Address)
            )

    def test_str_javapackage(self):
        """ Test that we can now call str on javapackage objects """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(), connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT
        ):
            self.assertTrue("java package ghidra" in str(ghidra))

    def test_memory_callable_iterable(self):
        """ Test that we handle the ghidra.program.model.mem.Memory class - it's callable and iterable """
        with ghidra_bridge.GhidraBridge(
            namespace=globals(), connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT
        ):
            self.assertNotEqual(None, ghidra.program.model.mem.Memory)

    def test_address_comparison(self):
        with ghidra_bridge.GhidraBridge(
            namespace=globals(), connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT
        ):
            test_address = currentAddress.add(1)
            self.assertFalse(test_address < currentAddress)
            self.assertTrue(test_address > currentAddress)

    def test_hook_import(self):
        with ghidra_bridge.GhidraBridge(
            namespace=globals(),
            connect_to_port=ghidra_bridge_port.DEFAULT_SERVER_PORT,
            hook_import=True,
        ):
            import ghidra

            self.assertTrue("ghidra" in str(ghidra))
            from ghidra.framework.model import ToolListener
            import docking.widgets.indexedscrollpane.IndexScrollListener
            import java.math.BigInteger

            bi = java.math.BigInteger(str(10))

    def test_readme_remote_eval_example(self):
        """ Test the example from the readme """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        func = currentProgram.getFunctionManager().getFunctions(True).next()
        mnemonics = b.remote_eval(
            "[ i.getMnemonicString() for i in currentProgram.getListing().getInstructions(f.getBody(), True)]",
            f=func,
        )

    def test_readme_remote_eval_example_backcompat(self):
        """ Test the example from the readme, in its old version, before we changed GhidraBridge to inherit BridgeClient """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        func = currentProgram.getFunctionManager().getFunctions(True).next()
        mnemonics = b.bridge.remote_eval(
            "[ i.getMnemonicString() for i in currentProgram.getListing().getInstructions(f.getBody(), True)]",
            f=func,
        )

    def test_array_creation_without_forced_unicode(self):
        """ Check that we can instatiate an array.array without the error about it wanting a plain string as the first argument. Depends on jfx_bridge 0.8.0 """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        array = b.remote_import("array")

        test = array.array("b", b"\0" * 10)

        self.assertIsNotNone(test)
        
    @pytest.mark.timeout(10)  
    def test_java_exceptions_exec(self):
        """ Make sure we don't hang if we throw a java based exception in an exec """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        jerror = b.remote_import("java.lang.Error")
        with self.assertRaises(jfx_bridge.bridge.BridgeException):
            b.remote_exec("raise java.lang.Error('foo')")
        
    @pytest.mark.timeout(10)  
    def test_java_exceptions_call(self):       
        """ Make sure we don't hang if we throw a java based exception in a call """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        jint = b.remote_import("java.lang.Integer")
        with self.assertRaises(jfx_bridge.bridge.BridgeException):
            jint.divideUnsigned(1,0)
            
    def test_jarray(self):
        """ Make sure we can call the jarray functions, so we can pass byte arrays into java calls """
        b = ghidra_bridge.GhidraBridge(namespace=globals())
        jarray = b.remote_import("jarray")
        z = jarray.zeros(10, 'b')
```

`setup.py`:

```py
import setuptools
import subprocess

with open("README.md", "r") as fh:
    long_description = fh.read()

# determine the version, then write it out into the bridge.py file
version = (
    subprocess.check_output("git describe --tags", shell=True).decode("utf-8").strip()
)
# check if this is a non-tag release and remark it as a dev release
if "-" in version:
    ver, commits, hash = version.split("-")
    version = ver + ".dev" + commits

setuptools.setup(
    name="ghidra_bridge",
    version=version,
    author="justfoxing",
    author_email="justfoxingprojects@gmail.com",
    description="RPC bridge from Python to Ghidra Jython",
    long_description=long_description,
    long_description_content_type="text/markdown",
    url="https://github.com/justfoxing/ghidra_bridge",
    packages=setuptools.find_packages(),
    classifiers=[
        "Programming Language :: Python",
        "License :: OSI Approved :: MIT License",
        "Operating System :: OS Independent",
    ],
    install_requires=["jfx_bridge>=1.0.0"],
)

```