Project Path: arc_gmh5225_EAC_Emu_hp9s1o61

Source Tree:

```txt
arc_gmh5225_EAC_Emu_hp9s1o61
├── README.md
└── src
    ├── Data.asm
    ├── EAC.cpp
    ├── InterfaceData
    │   ├── InterfaceDef.h
    │   └── InterfaceImp.h
    ├── dllmain.cpp
    ├── framework.h
    ├── pch.cpp
    └── pch.h

```

`README.md`:

```md
# EAC_Emu
 A simple EasyAntiCheat x64 emulator.

```

`src/Data.asm`:

```asm
.code
PatchAByte proc 
	mov byte ptr [rcx + 8], 0
	ret
PatchAByte endp 
PatchAnByte proc
	lea rax, qword ptr [rdx + 16]
	ret
PatchAnByte endp
end
```

`src/EAC.cpp`:

```cpp
#include "InterfaceData/InterfaceImp.h"
#include <Windows.h>
LPVOID data = 0;

extern "C"
{
	_declspec(dllexport) void Cerberus_BeginFrame() { return; }
	_declspec(dllexport) void Cerberus_EndFrame() { return; }
	_declspec(dllexport) void Cerberus_GameRoundEnd() { return; }
	_declspec(dllexport) void Cerberus_GameRoundStart() { return; }
	_declspec(dllexport) void Cerberus_PlayerDespawn() { return; }
	_declspec(dllexport) void Cerberus_PlayerRevive() { return; }
	_declspec(dllexport) void Cerberus_PlayerSpawn() { return; }
	_declspec(dllexport) void Cerberus_PlayerTakeDamage() { return; }
	_declspec(dllexport) void Cerberus_PlayerTick() { return; }
	_declspec(dllexport) void Cerberus_PlayerUseWeapon() { return; }
	_declspec(dllexport) void ClientAuth_ClientWriteChallengeResponse() { return; }
	_declspec(dllexport) void ClientAuth_Destroy() { return; }
	_declspec(dllexport) void ClientAuth_Initialize() { return; }
	_declspec(dllexport) void* CreateGameLauncher() { return NULL; }
	_declspec(dllexport) void* CreateHttpsClient() { return NULL; }
	_declspec(dllexport) void* CreateThirdPartyLauncher() { return NULL; }
	_declspec(dllexport) void GameClientP2P_BeginSession() { return; }
	_declspec(dllexport) void GameClientP2P_Cerberus() { return; }
	_declspec(dllexport) void GameClientP2P_EndSession() { return; }
	_declspec(dllexport) void GameClientP2P_InitLocalization() { return; }
	_declspec(dllexport) void GameClientP2P_PollForMessageToPeer() { return; }
	_declspec(dllexport) void GameClientP2P_PollStatus() { return; }
	_declspec(dllexport) void GameClientP2P_ReceiveMessageFromPeer() { return; }
	_declspec(dllexport) void GameClientP2P_RegisterPeer() { return; }
	_declspec(dllexport) void GameClientP2P_ResetState() { return; }
	_declspec(dllexport) void GameClientP2P_SetLogCallback() { return; }
	_declspec(dllexport) void GameClientP2P_SetMaxAllowedMessageLength() { return; }
	_declspec(dllexport) void GameClientP2P_UnregisterPeer() { return; }
	_declspec(dllexport) void GameClientP2P_UpdatePlatformUserAuthTicket() { return; }
	_declspec(dllexport) void GameClient_ConnectionReset() { return; }
	_declspec(dllexport) void GameClient_Destroy() { return; }
	_declspec(dllexport) void GameClient_Initialize() { return; }
	_declspec(dllexport) void GameClient_NetProtect() { return; }
	_declspec(dllexport) void GameClient_PollStatus() { return; }
	_declspec(dllexport) void GameClient_PopNetworkMessage() { return; }
	_declspec(dllexport) void GameClient_PushNetworkMessage() { return; }
	_declspec(dllexport) void GameClient_SetMaxAllowedMessageLength() { return; }
	_declspec(dllexport) void GameClient_ValidateServerHost() { return; }
	_declspec(dllexport) void GameLauncher_Destroy() { return; }
	_declspec(dllexport) void GameLauncher_GetGameProcessId() { return; }
	_declspec(dllexport) void GameLauncher_OpenGameProcess() { return; }
	_declspec(dllexport) void GameLauncher_StartGameA() { return; }
	_declspec(dllexport) void GameLauncher_StartGameW() { return; }
	_declspec(dllexport) void NetProtectClient_GetProtectMessageOutputLength() { return; }
	_declspec(dllexport) void NetProtectClient_ProtectMessage() { return; }
	_declspec(dllexport) void NetProtectClient_UnprotectMessage() { return; }
	_declspec(dllexport) void ThirdPartyLauncher_Destroy() { return; }
	_declspec(dllexport) void ThirdPartyLauncher_Initialize() { return; }
	_declspec(dllexport) void ThirdPartyLauncher_SetServer() { return; }
	_declspec(dllexport) void* CreateGameClient()  // Initialize Interface client.
	{
		void* Pointer = VirtualAlloc(NULL, sizeof(EAC_Attach), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
		if (Pointer == 0)
			return nullptr;
		memcpy(Pointer, (void*)(new EAC_Attach), sizeof(EAC_Attach));
		data = Pointer;
		return Pointer;
	}
	_declspec(dllexport) void* CreateClientAuth()
	{
		return NULL;
	}
}
```

`src/InterfaceData/InterfaceDef.h`:

```h
#pragma once
#include <Windows.h>
class EAC_Interface				// Define Interface functions.
{
public:
	virtual bool FunctionUnamed1() = 0;
	virtual bool FunctionUnamed2() = 0;
	virtual bool FunctionUnamed3() = 0;
	virtual bool FunctionUnamed4() = 0;
	virtual bool FunctionUnamed5() = 0;
	virtual bool FunctionUnamed6() = 0;
	virtual bool FunctionUnamed7() = 0;
	virtual bool FunctionUnamed8() = 0;
	virtual bool FunctionUnamed9() = 0;
	virtual bool FunctionUnamed10() = 0;
	virtual bool FunctionUnamed11() = 0;
	virtual bool FunctionUnamed12() = 0;
	virtual bool FunctionUnamed13() = 0;

	virtual int FunctionUnamed14() = 0;
	virtual void FunctionUnamed15() = 0;
	virtual void FunctionUnamed16() = 0;

	virtual bool FunctionUnamed17() = 0;
	virtual void FunctionUnamed18() = 0;
	virtual void FunctionUnamed19() = 0;
	virtual void FunctionUnamed20() = 0;
	virtual void FunctionUnamed21() = 0;
	virtual void FunctionUnamed22(void*, int) = 0;
	virtual bool FunctionUnamed23() = 0;
	virtual void FunctionUnamed24() = 0;
	virtual bool FunctionUnamed25() = 0;
	virtual void FunctionUnamed26() = 0;
	virtual int FunctionUnamed27() = 0;			// Return 0
	virtual void FunctionUnamed28() = 0;
	virtual void FunctionUnamed29() = 0;
	virtual void FunctionUnamed30() = 0;
	virtual bool FunctionUnamed31() = 0;
	virtual bool FunctionUnamed32() = 0;
	virtual void* FunctionUnamed33(void*, int) = 0;
	virtual void FunctionUnamed34() = 0;
	virtual void FunctionUnamed35() = 0;
	virtual bool FunctionUnamed36() = 0;
	virtual void FunctionUnamed37() = 0;
	virtual void FunctionUnamed38() = 0;
	virtual void FunctionUnamed39() = 0;
	virtual void FunctionUnamed40() = 0;
	virtual void FunctionUnamed41() = 0;
	virtual void FunctionUnamed42() = 0;
	virtual void FunctionUnamed43() = 0;
};
```

`src/InterfaceData/InterfaceImp.h`:

```h
#pragma once
#include "InterfaceDef.h"
extern "C" void PatchAByte();
extern "C" void* PatchAnByte();
class EAC_Attach : public EAC_Interface    // Implement Interface functions.
{
public:
	bool FunctionUnamed1()
	{
		return false;
	}
	bool FunctionUnamed2()
	{
		return false;
	}
	bool FunctionUnamed3()
	{
		return false;
	}
	bool FunctionUnamed4()
	{
		return false;
	}
	bool FunctionUnamed5()
	{
		return false;
	}
	bool FunctionUnamed6()
	{
		return false;
	}
	bool FunctionUnamed7()
	{
		return false;
	}
	bool FunctionUnamed8()
	{
		return false;
	}
	bool FunctionUnamed9()
	{
		return false;
	}
	bool FunctionUnamed10()
	{
		return false;
	}
	bool FunctionUnamed11()
	{
		return false;
	}
	bool FunctionUnamed12()
	{
		return false;
	}
	bool FunctionUnamed13()
	{
		return false;
	}

	int FunctionUnamed14()
	{
		return 0;
	}
	void FunctionUnamed15()
	{
		return;
	}
	void FunctionUnamed16()
	{
		return;
	}

	bool FunctionUnamed17()
	{
		return false;
	}
	void FunctionUnamed18()
	{
		return;
	}
	void FunctionUnamed19()
	{
		return;
	}
	void FunctionUnamed20()
	{
		return;
	}
	void FunctionUnamed21()
	{
		return;
	}
	void FunctionUnamed22(void* buffer, int n)
	{
		PatchAByte();
	}
	bool FunctionUnamed23()
	{
		return true;
	}
	void FunctionUnamed24()
	{
		return;
	}
	bool FunctionUnamed25()
	{
		return true;
	}
	void FunctionUnamed26()
	{
		return;
	}
	int FunctionUnamed27()			// Return 0
	{
		return 0;
	}
	void FunctionUnamed28()
	{
		return;
	}
	void FunctionUnamed29()
	{
		return;
	}
	void FunctionUnamed30()
	{
		return;
	}
	bool FunctionUnamed31()
	{
		return true;
	}
	bool FunctionUnamed32()
	{
		return true;
	}
	void* FunctionUnamed33(void* data, int n)
	{
		return PatchAnByte();
	}
	void FunctionUnamed34()
	{
		return;
	}
	void FunctionUnamed35()
	{
		return;
	}
	bool FunctionUnamed36()
	{
		return false;
	}
	void FunctionUnamed37()
	{
		return;
	}
	void FunctionUnamed38()
	{
		return;
	}
	void FunctionUnamed39()
	{
		return;
	}
	void FunctionUnamed40()
	{
		return;
	}
	void FunctionUnamed41()
	{
		return;
	}
	void FunctionUnamed42()
	{
		return;
	}
	void FunctionUnamed43()
	{
		return;
	}
};
```

`src/dllmain.cpp`:

```cpp
// dllmain.cpp : Defines the entry point for the DLL application.
#include <Windows.h>
BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

`src/framework.h`:

```h
#pragma once

#define WIN32_LEAN_AND_MEAN             // Exclude rarely-used stuff from Windows headers
// Windows Header Files
#include <windows.h>

```

`src/pch.cpp`:

```cpp
// pch.cpp: source file corresponding to the pre-compiled header

#include "pch.h"

// When you are using pre-compiled headers, this source file is necessary for compilation to succeed.

```

`src/pch.h`:

```h
// pch.h: This is a precompiled header file.
// Files listed below are compiled only once, improving build performance for future builds.
// This also affects IntelliSense performance, including code completion and many code browsing features.
// However, files listed here are ALL re-compiled if any one of them is updated between builds.
// Do not add files here that you will be updating frequently as this negates the performance advantage.

#ifndef PCH_H
#define PCH_H

// add headers that you want to pre-compile here
#include "framework.h"

#endif //PCH_H

```