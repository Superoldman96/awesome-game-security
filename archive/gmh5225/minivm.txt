Project Path: arc_gmh5225_minivm_zknzbzgr

Source Tree:

```txt
arc_gmh5225_minivm_zknzbzgr
├── LICENSE
├── README.md
├── embed.sh
├── makefile
├── res
│   ├── MiniVM.svg
│   ├── fib.png
│   └── tree.png
└── vm
    ├── dis.c
    ├── lib.h
    ├── minivm.c
    └── opcode.h

```

`LICENSE`:

```
MIT License

Copyright (c) 2020 Shaw Summa

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

```

`README.md`:

```md
![The MiniVM Logo, looks like a brick according to some, some catfood according to others](res/MiniVM.svg)

# MiniVM

[![Link to Discord](https://img.shields.io/discord/814855814514737152?logo=discord&color=5865F2)](https://discord.gg/UyvxuC5W5q)

**MiniVM is a small and fast cross-language Virtual Machine (VM) written in good ol' C**, meaning it can compile and run just about anywhere. Here are a few reasons why MiniVM is pretty neat:

- Built on a register-based ISA that beats luajit—*with the JIT on*—in some benchmarks. (See the [benchmarks](#benchmarks) section below).
- Has an efficient GC that can handle large amounts of allocations and deallocations efficiently. (Again, check the benchmarks).
- Supports a flexible data model with a number of optimizations to minimize memory usage.
- Leverages Cosmopolitan libc + WebAssembly for easy cross platform portability.
- ... check out the [details](#some-sweet-deets) section for more!

MiniVM is small and flexible enough to run just about any language under the sun (given you've taken the time to write a compiler for it). Front ends we've experimented with include Lua, Scheme, Paka, and others. You can try out the [Paka frontend to MiniVM online](https://fastvm.github.io/xori)!

## History
This project started as an exploration into what it takes to build a fast interpreter. The first version was blocked out during a single Discord call, and ran a small lisp-like language.

This original implementation was a plain stack machine, which, for whatever reason, was a tad faster than it should've been. Leveraging this tiny 1,000 LoC base, MiniVM matured into something a bit bigger, but only slightly. It now runs a language close to ASM, and has got quite faster over time. MiniVM's speed is in no small part due to its architecture. It's a register/stack machine with carefully-selected opcodes that are designed to work well with common data-access patterns.

Above all else, MiniVM is constantly improving every day. We hope you find the journey to be as interesting as the final destination. If you're interested as to where the project is headed next, ping Shaw (`@4984#4984`) on [the Discord Server](https://discord.gg/UyvxuC5W5q).

## Some Sweet Deets
Below is a small discussion of the architecture of MiniVM, and the emergent properties because of these decisions.

### A Register-Based VM
First and foremost, MiniVM is a register-based VM. This means that instructions are larger and operate on *registers*, as opposed to the *stack*. Because of this property, register-based VMs play nicely with modern hardware, and result in less instructions per unit of work done. Consider the following:

```
while x < 1000 {
  x = x + 1
}
```

A stack-based VM would have to emit a single instruction for every single little thing done in the loop above. You'd probably end up with something like:

```
head_of_loop:
  load_var x
  push_int 1000
  less_than
  jump_if_false :end_of_loop
  load_var x
  increment
  store_var x
end_of_loop:
```

This is all well and good, but compare it to what a register-based machine does:

```
// r0 is where x lives
head_of_loop:
  jump_if_reg_less_than_number r0 1000 :end_of_loop
  increment_reg r0 1
  jump :head_of_loop
end_of_loop:
```

Although each instruction is a bit more complex, there are way fewer instructions. And this per-instruction complexity isn't necessarily a bad thing: making instructions more complex offloads work to the host language (C, in this case), which means that the runtime can compile common complex instructions to efficient native code.

### On `malloc` and `putchar`

MiniVM's only dependencies are [9 functions](https://github.com/FastVM/minivm/blob/main/vm/libc.h) in `libc`:

```
printf, malloc, realloc, free, fopen, fclose, fwrite, fread, strlen
```

Only `malloc` and `printf` are relied on heavily, though:
 
> `printf` is the function called by opcode do_putchar.
> `malloc` is required for memory allocations as of recent.
> `realloc` is required to grow memory. It could be replaced with malloc and free calls.
> `free` is required to clean up memory.
> `fopen` is used to open a file.
> `fclose` is used to close a file.
> `fwrite` is used by opcode do_dump and opcode do_write.
> `fread` is used by opcode do_read.
> `strlen` is used to get the length of entries in argc. 
> — Shaw

The entire codebase is highly configurable, allowing users of MiniVM to choose the optimal feature set that supports their application.

### Types

Minivm has a select set of core types. 

- number
  - able to represent at least what a 30 bit signed int can. 
- array
  - unchanging in length
  - mutable data by default

Because MiniVM is a register-based machine, it employs clever instructions to leverage common type layouts for better performance. For instance, to emulate closures arrays can be called as functions if the first item in that array is a function.

## Installation
Building from source is pretty simple:

```
git clone https://github.com/shawsumma/minivm
cd minivm
make
```

One can also use the artifacts from github actions.

[MiniVM Binaries](https://github.com/FastVM/minivm/actions) for Linux, MacOS and Windows can be found here. Click the text next to a green check mark and download the linux-opt, macos-opt or windows-opt single file binary.

## Getting Started
MiniVM has a growing and fairly unstable API.
The best way to get familiar with MiniVM and its opcodes is to read through the headers in the `vm/` directory.

The top of the bytecode file is the usual entry point. MiniVM can be built as a library with `make VM_MAIN=`.

The most common way to get code running on MiniVM is to use [Paka](https://github.com/fastvm/paka). For those looking to try paka and minivm online use [XorI](https://fastvm.github.io/xori).

## Benchmarks
Taking benchmarks is hard. Benchmarks are fraught with peril and don't always tell the full story: if you want to know how your application will perform in a language, no benchmarks will be a substitute for that. We tried to be fair, methodical, and thorough in our benchmarking; despite this, remember to take these results with a grain of salt.

All benchmarks were run in hyperfine on a `2020 MacBook Air M1` with `8GB RAM` running `Big Sur 11.2.3`. The implementations we benchmarked are idiomatic and consistent between target benchmark languages. All benchmarks may be found in the [Paka repository](https://github.com/FastVM/paka/tree/main/bench) if you'd like to run them on your machine.

### Binary Trees: Allocations and GC
![Binary Trees Graph](res/tree.png)

As you can see, MiniVM (no JIT) beats luajit with the JIT on in this benchmark. MiniVM has a custom-built allocator and GC, which beats out luajit's slower modified version of `malloc`. MiniVM also is a hair faster than C for tree sizes above 13 (C is compiled ahead-of time, using `clang` with the `-Ofast` flag for best performance). It beats Node JS with tree sizes less than 13 due to having a faster startup time. Overall, MiniVM's performance is about on par with JIT'd and compiled languages on this benchmark.

The binary tree benchmark measures the time it takes to create a balanced binary tree of a given depth and sum the values in each node to produce a total for the tree. This measures how well the language runtime handles a large number of repeated allocations and deallocations (no memory pooling is used or allowed).

### Recursive Fibonacci: Functions and Math
![Fibonacci Runtime](res/fib.png)

As you can see, `minivm` (no JIT) is a hair slower than Node JS (JIT) but beats `luajit --joff` by a fair margin (no JIT).

The recursive fibonacci benchmark computes `fib(35)` in a recursive manner (not memoized). This mostly measures the performance of basic mathematical operations and the overhead of function calls. The code for `fib` in Paka (a minivm frontend) is:

```
def fib(n) {
    if n < 2 {
        return n
    } else {
        return fib(n - 1) + fib(n - 2)
    }
}
```

We compile this Paka straight to minivm bytecode, there isn't any subsequent optimization of the bytecode by hand.

## Roadmap
- Write assembler for minivm bytecode.
- Reduce dependencies to `libc` functions.
- Add types.
- Improve performance.

> Note: MiniVM is wholly developed by [Shaw](https://github.com/ShawSumma) (4984); this README was written by a [friend](https://github.com/slightknack) of his who thinks he can be a bit too modest at times.

```

`embed.sh`:

```sh
#!/usr/bin/env sh

set -e

MVM=$(dirname $0)

mkdir -p $MVM/bin

cp $1 $MVM/bin/boot.bc

ldc2 -O3 -flto=full -i -I $MVM -J $MVM/bin $MVM/vm/embed.d -of embed

```

`makefile`:

```

OPT ?= -Os

default: all

all: minivm dis

minivm: .dummy
	$(CC) $(OPT) vm/minivm.c -o minivm $(CFLAGS)

pgo-llvm: .dummy
	$(MAKE) minivm CC='$(CC)' OPT='-O1' CFLAGS+='-fprofile-instr-generate=minivm.profraw'
	$(PGO)
	$(PROFDATA) merge -output=minivm.profdata minivm.profraw
	$(MAKE) minivm CC='$(CC)' OPT='$(OPT)' CFLAGS+='-fprofile-instr-use=minivm.profdata'

pgo-llvm-%: .dummy
	$(MAKE) pgo-llvm OPT='$(OPT)' PGO='$(PGO)' CC=clang-$(@:pgo-llvm-%=%) PROFDATA=llvm-profdata-$(@:pgo-llvm-%=%)

dis: .dummy
	$(CC) $(OPT) vm/dis.c -o dis $(CFLAGS)

.dummy:

clean: .dummy
	rm -f $(OBJS) minivm dis minivm.profdata minivm.profraw

```

`res/MiniVM.svg`:

```svg
<svg width="384" height="234" viewBox="0 0 384 234" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M0.0467106 83.4772C0.436107 80.1299 3.25328 77.323 8.2415 76.0028L292.517 0.7655C301.488 -1.60892 314.085 1.72502 320.653 8.21206L380.111 66.9412C382.889 69.6853 384.144 72.5541 383.987 75.1307L384 75.1304V149.439C384 149.446 384 149.454 384 149.461V150.261L383.953 150.262C383.564 153.609 380.747 156.416 375.758 157.736L91.4831 232.974C82.5116 235.348 69.9147 232.014 63.3471 225.527L3.88885 166.798C1.11068 164.054 -0.143577 161.185 0.0130162 158.608L7.09717e-08 158.609V84.29C7.09717e-08 84.2894 7.09717e-08 84.2907 7.09717e-08 84.29V83.4783L0.0467106 83.4772Z" fill="#75819F"/>
<path d="M12.0108 89.0906C8.72704 85.8471 9.70142 82.2553 14.1872 81.0681L298.463 5.83082C302.948 4.64361 309.247 6.31058 312.531 9.55411L371.989 68.2833C375.273 71.5268 374.298 75.1186 369.812 76.3058L85.5371 151.543C81.0514 152.73 74.7529 151.063 71.4691 147.82L12.0108 89.0906Z" fill="white"/>
<path d="M93.1394 134.638C92.4859 134.811 91.9167 134.904 91.4318 134.916L87.0205 136.083L81.8442 136.495L80.8957 136.05C80.8303 136.067 80.5427 135.824 80.0327 135.32C79.3836 134.679 78.8178 134.161 78.3352 133.766L75.0383 130.632C74.2775 129.963 73.2017 128.941 71.8108 127.567L66.2601 122.33C65.101 121.185 63.5669 119.588 61.6577 117.539L59.3913 115.177C58.0385 113.677 55.6699 111.256 52.2855 107.913L50.8947 106.539C50.6249 106.436 50.3045 106.202 49.9337 105.836L49.3488 105.381C48.1898 104.236 47.0824 103.019 46.0267 101.731C44.5812 100.139 43.2093 98.7025 41.9112 97.4203L39.866 95.523C39.2907 95.0366 38.6553 94.4499 37.9599 93.763C37.9135 93.7172 37.7786 93.6658 37.5552 93.6088C37.3971 93.5346 37.2717 93.4516 37.179 93.36C36.7154 92.9021 36.5827 92.4437 36.781 91.9848C36.9793 91.5258 37.4011 91.1239 38.0462 90.779C38.8601 90.2733 40.0839 89.8042 41.7178 89.3718L65.9313 82.9634C65.9966 82.9461 66.141 82.9659 66.3644 83.0229C66.5879 83.0799 66.7881 83.114 66.9652 83.1252C67.8125 83.3074 69.0919 83.7526 70.8034 84.4609C71.2776 84.6838 71.7982 84.9524 72.3652 85.2669C72.9511 85.5182 73.811 85.9584 74.9449 86.5873C76.1442 87.1989 77.9009 88.1565 80.2151 89.4601L83.5472 91.2781C84.7655 91.8266 86.3504 92.6555 88.3021 93.7647C88.869 94.0792 89.436 94.3936 90.0029 94.7081C90.6352 95.0052 91.2349 95.311 91.8018 95.6255C92.257 95.9114 92.6427 96.1287 92.9589 96.2773C93.294 96.3628 93.4848 96.4284 93.5311 96.4742C94.7304 97.0858 95.5914 97.3224 96.1143 97.1841C96.7678 97.0111 96.9197 96.5064 96.5701 95.6699C96.5891 95.6068 96.5617 95.4979 96.488 95.3432C96.3679 95.1428 96.2531 94.8248 96.1436 94.3893L95.3192 91.7333L93.3294 84.857L92.4924 81.9431C92.3175 81.5249 92.1469 81.1926 91.9805 80.9464C91.833 80.637 91.7783 80.4192 91.8162 80.2931C91.6604 79.8117 91.5627 78.9376 91.523 77.6708C91.4789 77.2179 91.4948 76.8653 91.5708 76.613C91.7205 76.5153 91.7816 76.412 91.7543 76.3031C91.7269 76.1942 91.7786 76.1225 91.9093 76.0879L122.005 68.1228C122.135 68.0882 122.646 68.3884 123.538 69.0234L130.647 75.6771C132.725 77.5658 135.85 80.5708 140.023 84.6922L144.056 88.6761C145.632 90.2331 147.296 91.9991 149.047 93.9743C150.798 95.9495 151.919 97.2205 152.41 97.7873L153.605 99.213L156.039 101.617C156.753 102.241 157.76 103.194 159.058 104.476C160.449 105.85 161.524 106.872 162.285 107.541C163.63 108.869 164.622 109.768 165.263 110.237L168.045 112.984L168.307 113.612L164.66 115.535L160.249 116.702C159.884 116.915 159.375 117.108 158.722 117.281C157.545 117.592 155.865 117.979 153.681 118.441L151.161 119.021C150.657 119.096 150.088 119.189 149.453 119.298C148.819 119.408 148.077 119.576 147.227 119.8L143.195 120.606C143.065 120.641 142.99 120.69 142.971 120.753L142.186 120.96C141.86 121.047 141.409 120.847 140.833 120.36C139.514 119.548 137.742 118.043 135.516 115.845C134.033 114.38 132.841 113.244 131.941 112.437L128.088 108.753C127.188 107.947 125.95 106.765 124.374 105.208C124.003 104.841 123.589 104.719 123.131 104.84C122.87 104.909 122.84 105.207 123.042 105.734L123.842 107.874L124.698 109.825C124.845 110.134 124.993 110.444 125.14 110.753C125.288 111.062 125.379 111.357 125.415 111.638L125.759 112.592C126.098 113.664 126.39 114.893 126.634 116.28C126.906 117.776 126.693 119.08 125.997 120.194C125.538 120.722 125.014 121.064 124.425 121.219L122.955 121.608C122.171 121.816 121.471 121.943 120.855 121.99L116.738 123.08C111.157 120.841 105.461 118.284 99.6498 115.409L95.6063 113.257C94.6115 112.765 94.0488 112.537 93.9181 112.571C93.4606 112.692 93.4173 112.936 93.7882 113.302L97.0566 116.531C100.302 119.736 102.624 122.112 104.023 123.658C106.303 126.074 107.744 127.783 108.344 128.785C108.882 129.398 108.987 129.747 108.66 129.834L107.974 130.015L107.414 130.076C105.285 130.756 103.613 131.314 102.399 131.752C101.661 132.005 100.358 132.437 98.49 133.048C96.6221 133.658 94.8386 134.188 93.1394 134.638Z" fill="#75819F"/>
<path d="M184.036 110.407C183.579 110.528 183.038 110.526 182.414 110.401C181.744 110.23 181.102 109.964 180.489 109.604C179.393 108.849 178.269 107.985 177.119 107.012C176.729 106.709 176.256 106.282 175.699 105.733L174.795 104.84L166.27 96.2965C163.349 93.4115 160.573 90.5465 157.941 87.7012L135.966 65.9955C135.502 65.5375 135.695 65.1961 136.545 64.9713C141.054 63.7778 144.397 62.8641 146.572 62.2303L156.375 59.6358C156.571 59.5839 156.712 59.5177 156.796 59.4373C156.88 59.357 157.021 59.2908 157.217 59.2389C157.974 58.9225 159.127 58.5882 160.676 58.2362C161.787 57.9422 163.033 57.6995 164.414 57.5083C164.991 57.5876 165.332 57.5556 165.435 57.4121C165.566 57.3775 165.781 57.2626 166.08 57.0672C167.061 56.8077 167.859 56.6546 168.474 56.6078C169.155 56.5437 169.821 56.6287 170.472 56.8628C171.217 57.1885 171.988 57.623 172.787 58.1664C173.316 58.607 174.322 59.56 175.805 61.0254L190.409 75.4501C190.715 75.8337 191.517 76.6667 192.815 77.9489C194.206 79.3226 195.23 80.4161 195.887 81.2291L198.918 84.3461C199.549 85.0503 200.397 85.929 201.463 86.9822L202.478 88.1072L206.928 92.5033C209.71 95.2508 211.911 97.6295 213.531 99.6393C214.181 100.28 214.601 100.982 214.792 101.744C213.616 102.056 211.963 102.551 209.834 103.231C208.788 103.507 208.148 103.735 207.914 103.913L206.64 104.25C206.183 104.371 205.907 104.386 205.815 104.294C205.199 104.341 204.859 104.373 204.793 104.391L204.287 104.873L195.268 107.26C195.249 107.323 194.75 107.484 193.77 107.744L186.417 109.69L184.036 110.407Z" fill="#75819F"/>
<path d="M240.883 95.5358C240.229 95.7088 239.627 95.81 239.077 95.8395L234.666 97.0071L229.489 97.419L228.639 96.9473C228.574 96.9646 228.286 96.7214 227.776 96.2177C226.254 94.8785 224.59 93.316 222.781 91.53C221.483 90.2478 220.375 89.2348 219.456 88.4909C218.158 87.2087 217.152 86.2557 216.437 85.6319L214.003 83.2278C211.544 81.2078 209.007 78.9472 206.391 76.4459C203.776 73.9446 201.263 71.5033 198.852 69.1221L191.955 62.0639C191.232 61.2681 190.06 60.0689 188.437 58.4661C186.814 56.8634 185.576 55.6814 184.723 54.9203C183.46 53.9189 183.097 53.028 183.633 52.2475C184.054 51.8456 185.082 51.4284 186.716 50.996C189.134 50.356 192.192 49.4887 195.89 48.3939L197.907 47.6857C201.643 46.4647 204.001 45.7245 204.982 45.4651C205.897 45.2229 206.573 45.0728 207.012 45.0149C207.973 44.8185 208.687 44.7458 209.152 44.7967C209.618 44.8475 210.144 44.9987 210.73 45.25C211.381 45.4841 211.865 45.6754 212.181 45.824C213.707 46.3491 215.28 46.92 216.898 47.5367C219.327 48.4618 221.248 49.1727 222.662 49.6693L236.156 54.8945L242.631 57.3613C241.425 56.1707 240.54 55.2147 239.976 54.4932L233.508 48.1051L228.865 43.1504C228.559 42.7667 228.37 42.4976 228.296 42.3429C228.222 42.1882 228.228 42.0707 228.312 41.9903C228.35 41.8641 228.378 41.7695 228.397 41.7064C228.718 41.0409 229.155 40.4899 229.707 40.0534C230.268 39.7888 230.744 39.6047 231.136 39.5009L237.901 37.7107C238.47 37.6181 239.408 37.3988 240.715 37.0529C242.153 36.6724 243.32 36.3926 244.215 36.2135L251.47 34.2936C253.169 33.8439 254.498 33.7243 255.457 33.935C256.547 34.1111 257.718 34.8173 258.969 36.0537L259.567 36.7666L260.581 37.8915C260.794 38.1836 261.132 38.5586 261.596 39.0165L262.987 40.3903L263.878 41.0253L266.104 43.2233C266.827 44.0191 268.138 45.3558 270.039 47.2333L275.185 52.3162C276.325 53.5242 277.985 55.2042 280.164 57.3565L297.549 74.5288L299.8 77.2427C300.605 78.3651 300.731 79.1446 300.178 79.5811L298.581 80.0909L296.845 80.4633L279.2 85.1334C277.986 85.5709 276.595 85.7937 275.029 85.8018C274.255 85.7743 273.3 85.6496 272.164 85.4277L252.221 78.2516C252.174 78.2058 250.598 77.5489 247.491 76.2809C246.412 75.8697 245.435 75.5186 244.56 75.2276C244.244 75.079 243.942 74.9849 243.653 74.9452C243.383 74.8424 243.215 74.7997 243.15 74.8169C242.562 74.9726 242.453 75.2336 242.824 75.6L244.354 77.1111C244.752 77.5863 245.485 78.3506 246.551 79.4038L251.906 84.6929C252.331 85.277 252.961 85.9812 253.796 86.8054L256.23 89.2095L256.676 89.527C257.046 89.8934 257.017 90.1915 256.587 90.4215C256.445 90.6912 255.969 90.8753 255.157 90.974C253.028 91.6537 251.356 92.2123 250.142 92.6498C249.404 92.9031 248.101 93.3351 246.233 93.9455C244.365 94.556 242.582 95.0861 240.883 95.5358Z" fill="#75819F"/>
<path d="M316.722 75.2898C316.264 75.4109 315.723 75.4089 315.1 75.2837C314.429 75.1127 313.787 74.8471 313.174 74.4869C312.078 73.7318 310.955 72.8678 309.804 71.895C309.414 71.5917 308.941 71.1653 308.385 70.6158L307.481 69.7229L298.956 61.1795C296.035 58.2945 293.259 55.4294 290.627 52.5842L268.651 30.8784C268.188 30.4205 268.381 30.0791 269.23 29.8543C273.74 28.6608 277.082 27.7471 279.258 27.1132L289.061 24.5187C289.257 24.4668 289.397 24.4007 289.482 24.3203C289.566 24.2399 289.706 24.1738 289.902 24.1219C290.659 23.8055 291.812 23.4712 293.362 23.1192C294.473 22.8251 295.719 22.5825 297.099 22.3912C297.677 22.4706 298.017 22.4386 298.121 22.2951C298.252 22.2605 298.467 22.1455 298.766 21.9502C299.746 21.6907 300.544 21.5376 301.16 21.4908C301.841 21.4267 302.507 21.5117 303.158 21.7458C303.902 22.0714 304.673 22.506 305.472 23.0494C306.001 23.49 307.007 24.443 308.491 25.9084L323.095 40.3331C323.4 40.7167 324.202 41.5496 325.5 42.8318C326.891 44.2056 327.915 45.299 328.573 46.1121L331.604 49.2291C332.234 49.9333 333.082 50.812 334.149 51.8652L335.163 52.9902L339.614 57.3863C342.396 60.1338 344.597 62.5125 346.217 64.5223C346.866 65.1634 347.286 65.865 347.478 66.6272C346.302 66.9385 344.649 67.434 342.52 68.1137C341.474 68.3904 340.834 68.6179 340.6 68.7959L339.326 69.1332C338.868 69.2543 338.593 69.269 338.5 69.1775C337.885 69.2242 337.544 69.2563 337.479 69.2736L336.973 69.7559L327.954 72.1428C327.935 72.2059 327.435 72.3672 326.455 72.6267L319.103 74.5725L316.722 75.2898Z" fill="#75819F"/>
<path d="M308.549 163.093C308.228 163.184 307.866 163.244 307.465 163.274C307.064 163.304 306.703 163.364 306.381 163.454C306.301 163.477 306.261 163.502 306.261 163.53L306.06 163.587C305.793 163.495 305.66 163.38 305.662 163.241L302.958 150.815C302.205 148.143 301.443 144.932 300.672 141.183C300.646 141.107 300.62 140.976 300.595 140.789C300.596 140.594 300.571 140.421 300.519 140.27C300.39 139.751 300.327 139.27 300.33 138.825C300.333 138.491 300.376 138.188 300.458 137.915C300.515 137.539 300.717 137.302 301.065 137.203L302.471 136.807C302.685 136.803 303.033 136.732 303.515 136.596L305.323 136.129L309.381 134.986C309.408 135.006 309.461 135.018 309.541 135.024C309.621 135.029 309.701 135.034 309.781 135.039C309.835 135.024 309.875 134.999 309.902 134.963C309.956 134.921 309.996 134.895 310.023 134.888C310.131 134.802 310.238 134.744 310.345 134.714L310.506 134.669L310.908 134.597C311.255 134.527 311.992 134.333 313.117 134.016C313.411 133.989 313.813 133.903 314.322 133.76C314.48 134.048 314.739 134.988 315.1 136.578L315.523 138.83C315.625 139.384 315.805 140.206 316.064 141.299C316.063 141.326 316.063 141.396 316.062 141.507C316.088 141.611 316.113 141.742 316.139 141.901C316.191 142.109 316.229 142.348 316.253 142.618C316.305 142.853 316.369 143.112 316.447 143.395C316.472 143.582 316.574 144.206 316.753 145.265L317.407 148.533L317.523 149.125L317.521 149.292C317.575 149.304 317.601 149.366 317.6 149.477L317.638 149.716L317.68 149.455C317.682 149.288 317.723 149.152 317.804 149.046C317.804 149.018 317.804 148.962 317.805 148.879C317.833 148.76 317.861 148.6 317.889 148.397C318.113 147.225 318.336 146.011 318.561 144.755L318.978 142.682C319.035 142.334 319.091 142.027 319.146 141.761C319.202 141.496 319.244 141.248 319.273 141.019L319.398 140.359C319.537 139.738 319.718 138.813 319.942 137.585L320.402 135.292C320.458 134.971 320.598 134.238 320.821 133.094C320.958 132.611 321.109 132.181 321.272 131.802C321.647 131.696 321.942 131.599 322.157 131.511L323.162 131.186L323.965 130.918L324.287 130.786L324.408 130.752C324.461 130.737 324.488 130.757 324.487 130.813C324.514 130.805 324.527 130.816 324.527 130.843C324.554 130.864 324.567 130.874 324.567 130.874C324.674 130.844 324.755 130.807 324.808 130.764C324.889 130.714 324.943 130.685 324.97 130.677L324.97 130.594L327.823 129.79C328.144 129.699 328.412 129.61 328.627 129.522L329.631 129.239C330.14 129.096 330.489 128.97 330.677 128.861L332.123 128.454C332.605 128.318 332.843 128.639 332.837 129.418L332.792 129.929C332.79 130.207 332.733 130.639 332.621 131.226C332.539 131.526 332.483 131.764 332.455 131.938C332.454 132.077 332.44 132.178 332.413 132.241C331.686 136.107 330.881 139.759 329.998 143.197L327.077 157.208C327.076 157.292 326.941 157.482 326.671 157.78L326.551 157.814L326.35 157.829C326.162 157.882 325.988 157.972 325.827 158.101C325.665 158.23 325.504 158.317 325.343 158.362C324.995 158.46 324.634 158.52 324.26 158.543C323.832 158.608 323.47 158.682 323.176 158.765C319.853 159.84 314.977 161.282 308.549 163.093Z" fill="white"/>
<path d="M341.774 153.858C341.506 153.933 341.292 153.966 341.132 153.956L339.324 154.465L337.52 154.516L337.362 154.227C337.335 154.235 337.323 154.086 337.325 153.78C337.328 153.391 337.318 153.075 337.293 152.832L337.268 150.925C337.245 150.516 337.237 149.894 337.244 149.06L337.19 145.872C337.195 145.177 337.23 144.211 337.294 142.972L337.346 141.543C337.406 140.639 337.445 139.172 337.462 137.142L337.469 136.308C337.416 136.24 337.39 136.095 337.392 135.872L337.354 135.592C337.36 134.897 337.406 134.163 337.493 133.389C337.554 132.429 337.588 131.56 337.594 130.781L337.564 129.625C337.539 129.327 337.529 128.969 337.532 128.552C337.533 128.525 337.506 128.49 337.453 128.45C337.427 128.402 337.414 128.35 337.414 128.294C337.417 128.016 337.526 127.75 337.742 127.495C337.957 127.24 338.226 127.026 338.548 126.852C338.978 126.592 339.528 126.368 340.198 126.179L350.122 123.383C350.148 123.376 350.188 123.392 350.241 123.433C350.294 123.473 350.348 123.5 350.401 123.512C350.614 123.647 350.879 123.947 351.195 124.412C351.274 124.556 351.353 124.728 351.432 124.928C351.537 125.092 351.668 125.374 351.826 125.774C352.009 126.166 352.258 126.775 352.572 127.602L353.044 128.759C353.255 129.115 353.491 129.645 353.752 130.348C353.831 130.548 353.909 130.748 353.988 130.947C354.093 131.139 354.185 131.335 354.264 131.535C354.315 131.715 354.368 131.853 354.42 131.949C354.5 132.009 354.54 132.054 354.54 132.081C354.723 132.473 354.923 132.639 355.137 132.579C355.405 132.503 355.621 132.221 355.785 131.731C355.812 131.695 355.839 131.632 355.867 131.541C355.895 131.422 355.963 131.237 356.072 130.984L356.686 129.438L358.322 125.441L359.017 123.748C359.1 123.503 359.155 123.307 359.183 123.16C359.238 122.978 359.292 122.852 359.346 122.781C359.455 122.501 359.713 121.998 360.12 121.274C360.256 121.014 360.378 120.813 360.486 120.671C360.566 120.621 360.62 120.564 360.648 120.501C360.675 120.438 360.715 120.399 360.769 120.384L373.103 116.909C373.157 116.894 373.222 117.083 373.299 117.478L373.386 121.53C373.43 122.683 373.442 124.51 373.421 127.012L373.401 129.43C373.394 130.375 373.345 131.443 373.255 132.633C373.165 133.823 373.105 134.589 373.076 134.93L372.988 135.787L372.977 137.246C373 137.628 373.009 138.208 373.002 138.986C372.995 139.82 373.004 140.442 373.027 140.851C373.02 141.658 373.043 142.206 373.094 142.497L373.08 144.165L372.957 144.532L371.145 145.5L369.337 146.01C369.149 146.118 368.921 146.21 368.653 146.286C368.171 146.421 367.502 146.582 366.645 146.768L365.641 147.009C365.454 147.034 365.24 147.067 364.999 147.107C364.758 147.147 364.463 147.216 364.115 147.314L362.549 147.631C362.496 147.646 362.455 147.671 362.428 147.706L362.107 147.797C361.973 147.835 361.894 147.704 361.87 147.406C361.713 146.895 361.641 145.973 361.652 144.639C361.659 143.749 361.651 143.058 361.629 142.565L361.607 140.325C361.584 139.832 361.577 139.113 361.585 138.168C361.587 137.945 361.494 137.86 361.306 137.913C361.199 137.943 361.091 138.113 360.981 138.421L360.53 139.671L360.16 140.815C360.105 140.997 360.05 141.179 359.995 141.361C359.94 141.543 359.872 141.715 359.791 141.876L359.586 142.433C359.34 143.057 359.027 143.77 358.646 144.57C358.238 145.434 357.738 146.171 357.145 146.782C356.822 147.067 356.54 147.244 356.299 147.312L355.696 147.481C355.374 147.572 355.107 147.62 354.893 147.624L353.206 148.1C352.149 146.622 351.16 144.959 350.24 143.111L349.65 141.738C349.492 141.422 349.387 141.271 349.333 141.286C349.146 141.339 349.051 141.477 349.049 141.699L349.033 143.659C349.017 145.605 348.979 147.044 348.917 147.977C348.852 149.437 348.75 150.464 348.612 151.058C348.582 151.427 348.5 151.63 348.366 151.668L348.085 151.747L347.884 151.762C346.973 152.074 346.249 152.334 345.713 152.54C345.392 152.659 344.829 152.859 344.025 153.141C343.221 153.423 342.47 153.662 341.774 153.858Z" fill="white"/>
</svg>

```

`vm/dis.c`:

```c

#include "opcode.h"
#include "lib.h"

void vm_disassemble(const int *ops, size_t nops, int indent) {
  const int max_nested = 100;
  int nested[max_nested];
  int nested_size = 0;
  for (size_t i = 0; i < nops; ++i) {
    if (nested_size > 0 && i >= nested[nested_size - 1]) {
      --nested_size;
      printf("%*s", indent * nested_size + 2, "");
      printf("}\n");
    }
    printf("%*s", indent * nested_size, "");
    printf("l%zu:\n", i);
    printf("%*s", indent * nested_size + 2, "");
    const int op = ops[i];
    switch (ops[i]) {
    case VM_OPCODE_EXIT:
      printf("exit\n");
      break;
    case VM_OPCODE_REG:
      printf("reg r%i r%i\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_BB:
      printf("bb r%i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_INT:
      printf("int r%i %d\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_JUMP:
      printf("jump l%i\n", ops[i + 1]);
      i += 1;
      break;
    case VM_OPCODE_FUNC: {
      const int index_after_func = ops[i + 1];
      const int fargs = ops[i + 2];
      const int namelen = ops[i + 3];
      printf("func ");
      for (int n = 0; n < namelen; n++) {
        printf("%c", (char)ops[i + 4 + n]);
      }
      printf(" (");
      for (int a = 1; a <= fargs; ++a) {
        if (a != 1) {
          printf(" ");
        }
        printf("r%i", a);
      }
      printf(") {\n");
      i += 1 + 2 + namelen + 1;
      if (nested_size < max_nested - 1) {
        nested[nested_size++] = index_after_func;
      }
    } break;
    case VM_OPCODE_ADD:
      printf("add r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_SUB:
      printf("sub r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_MUL:
      printf("mul r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_DIV:
      printf("div r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_MOD:
      printf("mod r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_POW:
      printf("pow r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_CALL: {
      printf("call r%i l%i (", ops[i + 1], ops[i + 2]);
      const int nargs = ops[i + 3];
      const int farg = i + 4;
      for (int a = 0; a < nargs; ++a) {
        if (a != 0) {
          printf(" ");
        }
        printf("r%i", ops[farg + a]);
      }
      printf(")");
      i += 3 + nargs;
    } break;
    case VM_OPCODE_RETURN:
      printf("return r%i\n", ops[i + 1]);
      i += 1;
      break;
    case VM_OPCODE_PUTCHAR:
      printf("putchar r%i\n", ops[i + 1]);
      i += 1;
      break;
    case VM_OPCODE_STRING: {
      printf("string r%i [", ops[i + 1]);
      const int nargs = ops[i + 2];
      const int farg = i + 3;
      for (int a = 0; a < nargs; ++a) {
        if (a != 0) {
          printf(" ");
        }
        const int ch = ops[farg + a];
        printf("%i", ch);
      }
      printf("]\n");
      i += 2 + nargs;
    } break;
    case VM_OPCODE_LENGTH:
      printf("length r%i r%i\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_GET:
      printf("get r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_SET:
      printf("set r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_DUMP:
      printf("dump r%i r%i\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_READ:
      printf("read r%i r%i\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_WRITE:
      printf("write r%i r%i\n", ops[i + 1], ops[i + 2]);
      i += 2;
      break;
    case VM_OPCODE_ARRAY: {
      printf("array r%i (", ops[i + 1]);
      const int nargs = ops[i + 2];
      const int farg = i + 3;
      for (int a = 0; a < nargs; ++a) {
        const int ch = ops[farg + a];
        if (a != 0) {
          printf(" ");
        }
        printf("r%i", ch);
      }
      printf(")\n");
      i += 2 + nargs;
    } break;
    case VM_OPCODE_CAT:
      printf("cat r%i r%i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_BEQ:
      printf("beq r%i r%i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    case VM_OPCODE_BLT:
      printf("blt r%i r%i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    case VM_OPCODE_ADDI:
      printf("add r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCDOE_SUBI:
      printf("sub r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCDOE_MULI:
      printf("mul r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_DIVI:
      printf("div r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_MODI:
      printf("mod r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_CALL0:
      printf("call r%i l%i ()\n", ops[i + 2], ops[i + 1]);
      i += 2;
      break;
    case VM_OPCODE_CALL1:
      printf("call r%i l%i (r%i)\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_CALL2:
      printf("call r%i l%i (r%i r%i)\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    case VM_OPCODE_CALL3:
      printf("call r%i l%i (r%i r%i r%i)\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4], ops[i + 5]);
      i += 5;
      break;
    case VM_OPCODE_GETI:
      printf("get r%i r%i %i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_SETI:
      printf("set r%i %i r%i\n", ops[i + 1], ops[i + 2], ops[i + 3]);
      i += 3;
      break;
    case VM_OPCODE_BEQI:
      printf("beq r%i %i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    case VM_OPCODE_BLTI:
      printf("blt r%i %i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    case VM_OPCODE_BLTEI:
      printf("blte r%i %i l%i l%i\n", ops[i + 1], ops[i + 2], ops[i + 3],
             ops[i + 4]);
      i += 4;
      break;
    default:
      printf("unknown opcode: %d\n", op);
      // disassembly may not be reliable after an unknown opcode
    }
  }
}

int main(int argc, char **argv) {
  if (argc < 2) {
    printf("cannot run dis: not enough args\n");
    return 1;
  }
  FILE *file = fopen(argv[1], "rb");
  if (file == (void *)0) {
    printf("cannot run dis: file to run could not be read\n");
    return 2;
  }
  size_t nalloc = 1 << 8;
  int *ops = malloc(sizeof(int) * nalloc);
  size_t nops = 0;
  size_t size;
  for (;;) {
    vm_file_opcode_t op = 0;
    size = fread(&op, sizeof(vm_file_opcode_t), 1, file);
    if (size == 0) {
      break;
    }
    if (nops + 1 >= nalloc) {
      nalloc *= 4;
      ops = realloc(ops, sizeof(int) * nalloc);
    }
    ops[nops++] = op;
  }
  fclose(file);
  vm_disassemble(ops, nops, 4);
  free(ops);
}

```

`vm/lib.h`:

```h

#pragma once

// MiniVM needs these three at all times
typedef __SIZE_TYPE__ size_t;

typedef __UINT8_TYPE__ uint8_t;
typedef __UINT16_TYPE__ uint16_t;
typedef __UINT32_TYPE__ uint32_t;
typedef __UINT64_TYPE__ uint64_t;

typedef __INT8_TYPE__ int8_t;
typedef __INT16_TYPE__ int16_t;
typedef __INT32_TYPE__ int32_t;
typedef __INT64_TYPE__ int64_t;

typedef int32_t vm_file_opcode_t;
typedef union {size_t arg; void *op;} vm_opcode_t;
typedef int64_t vm_number_t;
typedef size_t vm_counter_t;

/// The value type of minivm
union vm_obj_t;
/// These represent constant sized mutable arrays
struct vm_gc_entry_t;

typedef union vm_obj_t vm_obj_t;
typedef struct vm_gc_entry_t vm_gc_entry_t;

// I define libc things myself, this massivly speeds up compilation
struct FILE;
typedef struct FILE FILE;

void exit(int code);
size_t strlen(const char *str);
int strcmp(const char *s1, const char *s2);

void *malloc(size_t size);
void *realloc(void *ptr, size_t n);
void free(void *ptr);

int printf(const char *src, ...);
FILE *fopen(const char *src, const char *name);
int fclose(FILE *);
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);

```

`vm/minivm.c`:

```c

// IDIOMS:
// Leak Memory until I find a small GC.
// Undefined Behavior when opcodes are bad.
// Do not use C preprocessor `#.*` lines
// Types end in _t, and never use tagspace
// - only use `int` when it is defined by a LibC function to do so
//   * exit, printf, fclose, and main all use these
// Computed gotos are used along with a jump table.
// - `&&do_whatever` means get address of code at `do_whatever`
// - `vm_jump_next();` means run the next opcode

#include "lib.h"
#include "opcode.h"

#define vm_read() (ops[index++].arg)
#define vm_jump_next() ({ goto *ops[index++].op; })
#define vm_obj_num(v_) ((vm_obj_t){.num = v_})
#define vm_obj_ptr(v_) ((vm_obj_t){.ptr = v_})
#define vm_obj_to_num(o_) ((o_).num)
#define vm_obj_to_ptr(o_) ((o_).ptr)

/// This represents a value in MiniVM
union vm_obj_t {
  /// MiniVM integer type
  vm_number_t num;
  /// MiniVM array type
  vm_gc_entry_t *ptr;
};

/// This is the implementation of an array in minivm
// (DO NOT DEREF A POINTER TO THIS)
struct vm_gc_entry_t {
  // Only required to store 1GiB of items, whatever size they may be.
  /// The array's length in Objects
  size_t len;
  // because we only ever store pointers to the array it is okay for it to be
  // without a set size
  /// The array's value store; zero indexed
  vm_obj_t arr[0];
};

typedef struct {
  vm_number_t outreg;
  vm_number_t index;
  vm_number_t nlocals;
} vm_frame_t;

/// Creates an uninitialized array of length size
vm_gc_entry_t *vm_array_new(size_t size) {
  // Trick for variadic array sizes.
  vm_gc_entry_t *ent = malloc(sizeof(vm_gc_entry_t) + sizeof(vm_obj_t) * size);
  ent->len = size;
  return ent;
}

/// Creates the object in r0 at the beginning of the program.
vm_obj_t vm_global_from(size_t len, const char **args) {
  // Just some minivm arrays.
  vm_gc_entry_t *global = vm_array_new(len);
  for (size_t i = 0; i < len; i++) {
    vm_gc_entry_t *ent = vm_array_new(strlen(args[i]));
    for (const char *src = args[i]; *src != '\0'; src++) {
      ent->arr[src - args[i]] = vm_obj_num(*src);
    }
    global->arr[i] = vm_obj_ptr(ent);
  }
  return vm_obj_ptr(global);
}

int vm_table_opt(size_t nops, vm_opcode_t *ops, void *const *const ptrs) {
  for (size_t i = 0; i < nops; ++i) {
    vm_number_t op = ops[i].arg;
    ops[i].op = ptrs[op];
    switch (op) {
    case VM_OPCODE_EXIT:
      break;
    case VM_OPCODE_REG:
      i += 2;
      break;
    case VM_OPCODE_BB:
      i += 3;
      break;
    case VM_OPCODE_INT:
      i += 2;
      break;
    case VM_OPCODE_JUMP:
      i += 1;
      break;
    case VM_OPCODE_FUNC: {
      vm_number_t namelen = ops[i + 3].arg;
      i += 1 + 2 + namelen + 1;
    } break;
    case VM_OPCODE_ADD:
      i += 3;
      break;
    case VM_OPCODE_SUB:
      i += 3;
      break;
    case VM_OPCODE_MUL:
      i += 3;
      break;
    case VM_OPCODE_DIV:
      i += 3;
      break;
    case VM_OPCODE_MOD:
      i += 3;
      break;
    case VM_OPCODE_POW:
      i += 3;
      break;
    case VM_OPCODE_CALL: {
      vm_number_t nargs = ops[i + 3].arg;
      i += 3 + nargs;
    } break;
    case VM_OPCODE_RETURN:
      i += 1;
      break;
    case VM_OPCODE_PUTCHAR:
      i += 1;
      break;
    case VM_OPCODE_STRING: {
      vm_number_t nargs = ops[i + 2].arg;
      i += 2 + nargs;
    } break;
    case VM_OPCODE_LENGTH:
      i += 2;
      break;
    case VM_OPCODE_GET:
      i += 3;
      break;
    case VM_OPCODE_SET:
      i += 3;
      break;
    case VM_OPCODE_DUMP:
      i += 2;
      break;
    case VM_OPCODE_READ:
      i += 2;
      break;
    case VM_OPCODE_WRITE:
      i += 2;
      break;
    case VM_OPCODE_ARRAY: {
      vm_number_t nargs = ops[i + 2].arg;
      i += 2 + nargs;
    } break;
    case VM_OPCODE_CAT:
      i += 3;
      break;
    case VM_OPCODE_BEQ:
      i += 4;
      break;
    case VM_OPCODE_BLT:
      i += 4;
      break;
    case VM_OPCODE_ADDI:
      i += 3;
      break;
    case VM_OPCDOE_SUBI:
      i += 3;
      break;
    case VM_OPCDOE_MULI:
      i += 3;
      break;
    case VM_OPCODE_DIVI:
      i += 3;
      break;
    case VM_OPCODE_MODI:
      i += 3;
      break;
    case VM_OPCODE_CALL0:
      i += 2;
      break;
    case VM_OPCODE_CALL1:
      i += 3;
      break;
    case VM_OPCODE_CALL2:
      i += 4;
      break;
    case VM_OPCODE_CALL3:
      i += 5;
      break;
    case VM_OPCODE_GETI:
      i += 3;
      break;
    case VM_OPCODE_SETI:
      i += 3;
      break;
    case VM_OPCODE_BEQI:
      i += 4;
      break;
    case VM_OPCODE_BLTI:
      i += 4;
      break;
    case VM_OPCODE_BLTEI:
      i += 4;
      break;
    default:
      printf("unknown opcode: %p\n", ops[i].op);
      // disassembly may not be reliable after an unknown opcode
    }
  }
  return 0;
}

/// VM hot loop
void vm_run_from(size_t nops, vm_opcode_t *ops, vm_obj_t globals) {
  // our dear jump table
  static void *const ptrs[] = {
      [VM_OPCODE_EXIT] = &&do_exit,       [VM_OPCODE_REG] = &&do_store_reg,
      [VM_OPCODE_BB] = &&do_branch_bool,  [VM_OPCODE_INT] = &&do_store_int,
      [VM_OPCODE_JUMP] = &&do_jump,       [VM_OPCODE_FUNC] = &&do_func,
      [VM_OPCODE_ADD] = &&do_add,         [VM_OPCODE_SUB] = &&do_sub,
      [VM_OPCODE_MUL] = &&do_mul,         [VM_OPCODE_DIV] = &&do_div,
      [VM_OPCODE_MOD] = &&do_mod,         [VM_OPCODE_POW] = &&do_pow,
      [VM_OPCODE_CALL] = &&do_call,       [VM_OPCODE_RETURN] = &&do_return,
      [VM_OPCODE_PUTCHAR] = &&do_putchar, [VM_OPCODE_STRING] = &&do_string,
      [VM_OPCODE_LENGTH] = &&do_length,   [VM_OPCODE_GET] = &&do_get,
      [VM_OPCODE_SET] = &&do_set,         [VM_OPCODE_DUMP] = &&do_dump,
      [VM_OPCODE_READ] = &&do_read,       [VM_OPCODE_WRITE] = &&do_write,
      [VM_OPCODE_ARRAY] = &&do_array,     [VM_OPCODE_CAT] = &&do_cat,
      [VM_OPCODE_BEQ] = &&do_beq,         [VM_OPCODE_BLT] = &&do_blt,
      [VM_OPCODE_ADDI] = &&do_addi,       [VM_OPCDOE_SUBI] = &&do_subi,
      [VM_OPCDOE_MULI] = &&do_muli,       [VM_OPCODE_DIVI] = &&do_divi,
      [VM_OPCODE_MODI] = &&do_modi,       [VM_OPCODE_CALL0] = &&do_call0,
      [VM_OPCODE_CALL1] = &&do_call1,     [VM_OPCODE_CALL2] = &&do_call2,
      [VM_OPCODE_CALL3] = &&do_call3,     [VM_OPCODE_GETI] = &&do_geti,
      [VM_OPCODE_SETI] = &&do_seti,       [VM_OPCODE_BEQI] = &&do_beqi,
      [VM_OPCODE_BLTI] = &&do_blti,       [VM_OPCODE_BLTEI] = &&do_bltei,
  };
  vm_table_opt(nops, ops, ptrs);
  size_t index = 0;
  vm_obj_t *locals_base = malloc(sizeof(vm_obj_t) * (1 << 16));
  vm_obj_t *locals = locals_base;
  locals[0] = globals;
  vm_frame_t *frames = malloc(sizeof(vm_frame_t) * (1 << 10));
  vm_frame_t *frame = &frames[0];
  frame->nlocals = 0;
  frame += 1;
  frame->nlocals = 256;
  vm_jump_next();
do_exit : { 
  free(locals_base);
  free(frames);
  return;
}
do_return : {
  vm_number_t from = vm_read();
  vm_obj_t val = locals[from];
  frame--;
  locals = locals - frame->nlocals;
  vm_number_t outreg = frame->outreg;
  locals[outreg] = val;
  index = frame->index;
  vm_jump_next();
}
do_branch_bool : {
  vm_number_t from = vm_read();
  if (vm_obj_to_num(locals[from])) {
    index = ops[index + 1].arg;
    vm_jump_next();
  } else {
    index = ops[index].arg;
    vm_jump_next();
  }
}
do_store_reg : {
  vm_number_t to = vm_read();
  vm_number_t from = vm_read();
  locals[to] = locals[from];
  vm_jump_next();
}
do_store_int : {
  vm_number_t to = vm_read();
  vm_number_t from = vm_read();
  locals[to] = vm_obj_num(from);
  vm_jump_next();
}
do_jump : {
  index = ops[index].arg;
  vm_jump_next();
}
do_func : {
  index = ops[index].arg;
  vm_jump_next();
}
do_add : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  locals[to] =
      vm_obj_num(vm_obj_to_num(locals[lhs]) + vm_obj_to_num(locals[rhs]));
  vm_jump_next();
}
do_sub : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  locals[to] =
      vm_obj_num(vm_obj_to_num(locals[lhs]) - vm_obj_to_num(locals[rhs]));
  vm_jump_next();
}
do_mul : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  locals[to] =
      vm_obj_num(vm_obj_to_num(locals[lhs]) * vm_obj_to_num(locals[rhs]));
  vm_jump_next();
}
do_div : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  locals[to] =
      vm_obj_num(vm_obj_to_num(locals[lhs]) / vm_obj_to_num(locals[rhs]));
  vm_jump_next();
}
do_mod : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  locals[to] =
      vm_obj_num(vm_obj_to_num(locals[lhs]) % vm_obj_to_num(locals[rhs]));
  vm_jump_next();
}
do_pow : {
  vm_number_t to = vm_read();
  vm_number_t lhs = vm_read();
  vm_number_t rhs = vm_read();
  vm_number_t base = vm_obj_to_num(locals[lhs]);
  vm_number_t exp = vm_obj_to_num(locals[rhs]);
  vm_number_t result = 1;
  for (;;) {
    if (exp & 1) {
      result *= base;
    }
    exp >>= 1;
    if (!exp) {
      break;
    }
    base *= base;
  }
  locals[to] = vm_obj_num(result);
  vm_jump_next();
}
do_call : {
  vm_number_t outreg = vm_read();
  vm_number_t next_func = vm_read();
  vm_number_t nargs = vm_read();
  vm_obj_t *next_locals = locals + frame->nlocals;
  for (vm_number_t argno = 1; argno <= nargs; argno++) {
    vm_number_t regno = vm_read();
    next_locals[argno] = locals[regno];
  }
  locals = next_locals;
  frame->index = index;
  frame->outreg = outreg;
  frame++;
  frame->nlocals = ops[next_func - 1].arg;
  index = next_func;
  vm_jump_next();
}
do_putchar : {
  vm_number_t from = vm_read();
  vm_number_t val = vm_obj_to_num(locals[from]);
  printf("%c", (int)val);
  vm_jump_next();
}
do_string : {
  vm_number_t outreg = vm_read();
  vm_number_t nargs = vm_read();
  vm_gc_entry_t *str = vm_array_new(nargs);
  for (size_t i = 0; i < nargs; i++) {
    vm_number_t num = vm_read();
    str->arr[i] = vm_obj_num(num);
  }
  locals[outreg] = vm_obj_ptr(str);
  vm_jump_next();
}
do_length : {
  vm_number_t outreg = vm_read();
  vm_obj_t vec = locals[vm_read()];
  locals[outreg] = vm_obj_num(vm_obj_to_ptr(vec)->len);
  vm_jump_next();
}
do_get : {
  vm_number_t outreg = vm_read();
  vm_obj_t vec = locals[vm_read()];
  vm_obj_t oindex = locals[vm_read()];
  locals[outreg] = vm_obj_to_ptr(vec)->arr[vm_obj_to_num(oindex)];
  vm_jump_next();
}
do_set : {
  vm_obj_t vec = locals[vm_read()];
  vm_obj_t oindex = locals[vm_read()];
  vm_obj_t value = locals[vm_read()];
  vm_obj_to_ptr(vec)->arr[vm_obj_to_num(oindex)] = value;
  vm_jump_next();
}
do_dump : {
  vm_number_t namreg = vm_read();
  vm_gc_entry_t *sname = vm_obj_to_ptr(locals[namreg]);
  size_t slen = sname->len;
  char *name = malloc(sizeof(char) * (slen + 1));
  for (vm_counter_t i = 0; i < slen; i++) {
    vm_obj_t obj = sname->arr[i];
    name[i] = vm_obj_to_num(obj);
  }
  name[slen] = '\0';
  vm_gc_entry_t *ent = vm_obj_to_ptr(locals[vm_read()]);
  size_t xlen = ent->len;
  FILE *out = fopen(name, "wb");
  free(name);
  for (vm_counter_t i = 0; i < xlen; i++) {
    vm_obj_t obj = ent->arr[i];
    vm_file_opcode_t op = vm_obj_to_num(obj);
    fwrite(&op, sizeof(vm_file_opcode_t), 1, out);
  }
  fclose(out);
  vm_jump_next();
}
do_read : {
  vm_number_t outreg = vm_read();
  vm_gc_entry_t *sname = vm_obj_to_ptr(locals[vm_read()]);
  size_t slen = sname->len;
  char *name = malloc(sizeof(char) * (slen + 1));
  for (vm_counter_t i = 0; i < slen; i++) {
    name[i] = vm_obj_to_num(sname->arr[i]);
  }
  name[slen] = '\0';
  size_t where = 0;
  size_t nalloc = 64;
  FILE *in = fopen(name, "rb");
  free(name);
  if (in == (void *)0) {
    locals[outreg] = vm_obj_ptr(vm_array_new(0));
    vm_jump_next();
  }
  uint8_t *str = malloc(sizeof(uint8_t) * nalloc);
  for (;;) {
    uint8_t buf[2048];
    size_t n = fread(buf, 1, 2048, in);
    for (vm_counter_t i = 0; i < n; i++) {
      if (where + 4 >= nalloc) {
        nalloc = 4 + nalloc * 2;
        str = realloc(str, sizeof(uint8_t) * nalloc);
      }
      str[where] = buf[i];
      where += 1;
    }
    if (n < 2048) {
      break;
    }
  }
  fclose(in);
  vm_gc_entry_t *ent = vm_array_new(where);
  for (vm_counter_t i = 0; i < where; i++) {
    ent->arr[i] = vm_obj_num(str[i]);
  }
  free(str);
  locals[outreg] = vm_obj_ptr(ent);
  vm_jump_next();
}
do_write : {
  vm_number_t outreg = vm_read();
  vm_gc_entry_t *sname = vm_obj_to_ptr(locals[outreg]);
  size_t slen = sname->len;
  char *name = malloc(sizeof(char) * (slen + 1));
  for (vm_counter_t i = 0; i < slen; i++) {
    vm_obj_t obj = sname->arr[i];
    name[i] = vm_obj_to_num(obj);
  }
  name[slen] = '\0';
  vm_gc_entry_t *ent = vm_obj_to_ptr(locals[vm_read()]);
  size_t xlen = ent->len;
  FILE *out = fopen(name, "wb");
  free(name);
  for (vm_counter_t i = 0; i < xlen; i++) {
    vm_obj_t obj = ent->arr[i];
    uint8_t op = vm_obj_to_num(obj);
    fwrite(&op, 1, sizeof(uint8_t), out);
  }
  fclose(out);
  vm_jump_next();
}
do_array : {
  vm_number_t outreg = vm_read();
  vm_number_t nargs = vm_read();
  vm_gc_entry_t *vec = vm_array_new(nargs);
  for (vm_counter_t i = 0; i < nargs; i++) {
    vm_number_t vreg = vm_read();
    vec->arr[i] = locals[vreg];
  }
  locals[outreg] = vm_obj_ptr(vec);
  vm_jump_next();
}
do_cat : {
  vm_number_t to = vm_read();
  vm_gc_entry_t *left = vm_obj_to_ptr(locals[vm_read()]);
  vm_gc_entry_t *right = vm_obj_to_ptr(locals[vm_read()]);
  vm_gc_entry_t *ent = vm_array_new(left->len + right->len);
  for (vm_counter_t i = 0; i < left->len; i++) {
    ent->arr[i] = left->arr[i];
  }
  for (vm_counter_t i = 0; i < right->len; i++) {
    ent->arr[left->len + i] = right->arr[i];
  }
  locals[to] = vm_obj_ptr(ent);
  vm_jump_next();
}
do_beq : {
  vm_obj_t lhs = locals[vm_read()];
  vm_obj_t rhs = locals[vm_read()];
  index = ops[index + (vm_obj_to_num(lhs) == vm_obj_to_num(rhs))].arg;
  vm_jump_next();
}
do_blt : {
  vm_obj_t lhs = locals[vm_read()];
  vm_obj_t rhs = locals[vm_read()];
  index = ops[index + (vm_obj_to_num(lhs) < vm_obj_to_num(rhs))].arg;
  vm_jump_next();
}
do_addi : {
  vm_number_t to = vm_read();
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  locals[to] = vm_obj_num(vm_obj_to_num(lhs) + rhs);
  vm_jump_next();
}
do_subi : {
  vm_number_t to = vm_read();
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  locals[to] = vm_obj_num(vm_obj_to_num(lhs) - rhs);
  vm_jump_next();
}
do_muli : {
  vm_number_t to = vm_read();
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  locals[to] = vm_obj_num(vm_obj_to_num(lhs) * rhs);
  vm_jump_next();
}
do_divi : {
  vm_number_t to = vm_read();
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  locals[to] = vm_obj_num(vm_obj_to_num(lhs) / rhs);
  vm_jump_next();
}
do_modi : {
  vm_number_t to = vm_read();
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  locals[to] = vm_obj_num(vm_obj_to_num(lhs) % rhs);
  vm_jump_next();
}
do_call0 : {
  vm_number_t outreg = vm_read();
  vm_number_t next_func = vm_read();
  vm_obj_t *next_locals = locals + frame->nlocals;
  locals = next_locals;
  frame->index = index;
  frame->outreg = outreg;
  frame++;
  frame->nlocals = ops[next_func - 1].arg;
  index = next_func;
  vm_jump_next();
}
do_call1 : {
  vm_number_t outreg = vm_read();
  vm_number_t next_func = vm_read();
  vm_obj_t *next_locals = locals + frame->nlocals;
  next_locals[1] = locals[vm_read()];
  locals = next_locals;
  frame->index = index;
  frame->outreg = outreg;
  frame++;
  frame->nlocals = ops[next_func - 1].arg;
  index = next_func;
  vm_jump_next();
}
do_call2 : {
  vm_number_t outreg = vm_read();
  vm_number_t next_func = vm_read();
  vm_obj_t *next_locals = locals + frame->nlocals;
  next_locals[1] = locals[vm_read()];
  next_locals[2] = locals[vm_read()];
  locals = next_locals;
  frame->index = index;
  frame->outreg = outreg;
  frame++;
  frame->nlocals = ops[next_func - 1].arg;
  index = next_func;
  vm_jump_next();
}
do_call3 : {
  vm_number_t outreg = vm_read();
  vm_number_t next_func = vm_read();
  vm_obj_t *next_locals = locals + frame->nlocals;
  next_locals[1] = locals[vm_read()];
  next_locals[2] = locals[vm_read()];
  next_locals[3] = locals[vm_read()];
  locals = next_locals;
  frame->index = index;
  frame->outreg = outreg;
  frame++;
  frame->nlocals = ops[next_func - 1].arg;
  index = next_func;
  vm_jump_next();
}
do_geti : {
  vm_number_t outreg = vm_read();
  vm_obj_t vec = locals[vm_read()];
  vm_number_t oindex = vm_read();
  locals[outreg] = vm_obj_to_ptr(vec)->arr[oindex];
  vm_jump_next();
}
do_seti : {
  vm_obj_t vec = locals[vm_read()];
  vm_number_t oindex = vm_read();
  vm_obj_t value = locals[vm_read()];
  vm_obj_to_ptr(vec)->arr[oindex] = value;
  vm_jump_next();
}
do_beqi : {
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  index = ops[index + (vm_obj_to_num(lhs) == rhs)].arg;
  vm_jump_next();
}
do_blti : {
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  index = ops[index + (vm_obj_to_num(lhs) < rhs)].arg;
  vm_jump_next();
}
do_bltei : {
  vm_obj_t lhs = locals[vm_read()];
  vm_number_t rhs = vm_read();
  index = ops[index + (vm_obj_to_num(lhs) <= rhs)].arg;
  vm_jump_next();
}
}

/// allocates locals for the program and calls the vm hot loop
void vm_run(size_t nops, vm_opcode_t *ops, size_t nargs, const char **args) {
  vm_run_from(nops, ops, vm_global_from(nargs, args));
}

int main(int argc, const char **argv) {
  if (argc < 2) {
    printf("cannot run vm: not enough args\n");
    return 1;
  }
  FILE *file = fopen(argv[1], "rb");
  if (file == (void *)0) {
    printf("cannot run vm: file to run could not be read\n");
    return 2;
  }
  size_t nalloc = 1 << 8;
  vm_opcode_t *ops = malloc(sizeof(vm_opcode_t) * nalloc);
  size_t nops = 0;
  size_t size;
  for (;;) {
    vm_file_opcode_t op = 0;
    size = fread(&op, sizeof(vm_file_opcode_t), 1, file);
    if (size == 0) {
      break;
    }
    if (nops + 1 >= nalloc) {
      nalloc *= 4;
      ops = realloc(ops, sizeof(vm_opcode_t) * nalloc);
    }
    ops[nops++].arg = op;
  }
  fclose(file);
  vm_run(nops, ops, argc - 2, argv + 2);
  free(ops);
}

```

`vm/opcode.h`:

```h
#pragma once

enum {
  VM_OPCODE_EXIT = 0,
  VM_OPCODE_REG = 1,
  VM_OPCODE_BB = 2,
  VM_OPCODE_INT = 3,
  VM_OPCODE_JUMP = 4,
  VM_OPCODE_FUNC = 5,
  VM_OPCODE_ADD = 6,
  VM_OPCODE_SUB = 7,
  VM_OPCODE_MUL = 8,
  VM_OPCODE_DIV = 9,
  VM_OPCODE_MOD = 10,
  VM_OPCODE_POW = 11,
  VM_OPCODE_CALL = 12,
  VM_OPCODE_RETURN = 13,
  VM_OPCODE_PUTCHAR = 14,
  VM_OPCODE_STRING = 15,
  VM_OPCODE_LENGTH = 16,
  VM_OPCODE_GET = 17,
  VM_OPCODE_SET = 18,
  VM_OPCODE_DUMP = 19,
  VM_OPCODE_READ = 20,
  VM_OPCODE_WRITE = 21,
  VM_OPCODE_ARRAY = 22,
  VM_OPCODE_CAT = 23,
  VM_OPCODE_BEQ = 24,
  VM_OPCODE_BLT = 25,
  VM_OPCODE_ADDI = 26,
  VM_OPCDOE_SUBI = 27,
  VM_OPCDOE_MULI = 28,
  VM_OPCODE_DIVI = 29,
  VM_OPCODE_MODI = 30,
  VM_OPCODE_CALL0 = 31,
  VM_OPCODE_CALL1 = 32,
  VM_OPCODE_CALL2 = 33,
  VM_OPCODE_CALL3 = 34,
  VM_OPCODE_GETI = 35,
  VM_OPCODE_SETI = 36,
  VM_OPCODE_BEQI = 37,
  VM_OPCODE_BLTI = 38,
  VM_OPCODE_BLTEI = 39,
};

```